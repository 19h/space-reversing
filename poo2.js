var addrs_protobuf = [
'0x1402a0831',
'0x1402ff4a7',
'0x140300612',
'0x1403a0daf',
'0x1403b7cc1',
'0x1403c3539',
'0x1403e3d6a',
'0x140463317',
'0x140467eaa',
'0x1404c747e',
'0x1404f7a4b',
'0x14055d435',
'0x1405600ce',
'0x1405600ef',
'0x140A1B050',
'0x140a1dbfd',
'0x140A1DEC0',
'0x140A22710',
'0x140a2561f',
'0x140A2E240',
'0x140a34b58',
'0x140a35287',
'0x140A379D0',
'0x140a3da9b',
'0x140a437a6',
'0x140A567C0',
'0x140A5B2A0',
'0x140A64EE0',
'0x140A65120',
'0x140A66030',
'0x140a6c7d1',
'0x140a6c861',
'0x140a6c8f1',
'0x140a7021c',
'0x140a70b4f',
'0x140a70c3f',
'0x140a70c6f',
'0x140a70c9f',
'0x140A70D10',
'0x140a716dc',
'0x140a716ee',
'0x140A747E0',
'0x140a7a1e5',
'0x140a7e066',
'0x140a7e70d',
'0x140A7E7F0',
'0x140a87870',
'0x140A89DF0',
'0x140a9743b',
'0x140a978eb',
'0x140a9a658',
'0x140aa4cdd',
'0x140aa5f9d',
'0x140aa669d',
'0x140aa698d',
'0x140aa8f9f',
'0x140aa9dff',
'0x140aabd9f',
'0x140aac07f',
'0x140ab9b03',
'0x140abf252',
'0x140ac0745',
'0x140ac28cd',
'0x140ac28dc',
'0x140ac3748',
'0x140ac4543',
'0x140ac4763',
'0x140ac4983',
'0x140ac4dc3',
'0x140ac5203',
'0x140ac5643',
'0x140ac5863',
'0x140ac5a83',
'0x140ac5ca3',
'0x140ac5ec3',
'0x140ac60e3',
'0x140ac6728',
'0x140ac6a78',
'0x140acd1fb',
'0x140acedcb',
'0x140ad2afb',
'0x140ad308b',
'0x140aeacb9',
'0x140aecbf4',
'0x140aeeb05',
'0x140aef17d',
'0x140aef198',
'0x140af09c9',
'0x140af7191',
'0x140af72c9',
'0x140af798c',
'0x140af8a95',
'0x140afeb10',
'0x140afedcf',
'0x140afff42',
'0x140b006ce',
'0x140b01b95',
'0x140b01e57',
'0x140b04da8',
'0x140b04db7',
'0x140b05868',
'0x140b05877',
'0x140b07a5f',
'0x140b09bf9',
'0x140b09c02',
'0x140b09c0b',
'0x140b0a5b8',
'0x140b0a5c8',
'0x140b0a818',
'0x140b107bd',
'0x140b11add',
'0x140b1213d',
'0x140b13c24',
'0x140b14023',
'0x140b14406',
'0x140b1470c',
'0x140b148bc',
'0x140b14a6c',
'0x140b14c1c',
'0x140b14dcc',
'0x140b14f79',
'0x140b15057',
'0x140b150d1',
'0x140b15216',
'0x140b1527d',
'0x140b152e3',
'0x140b15349',
'0x140b156e6',
'0x140b1580c',
'0x140b1591d',
'0x140b15950',
'0x140b159c2',
'0x140b16b0b',
'0x140b1734f',
'0x140b17738',
'0x140b1a268',
'0x140b1a288',
'0x140b1a4a8',
'0x140b1a4c8',
'0x140b1a5c8',
'0x140b1a658',
'0x140b2c18b',
'0x140b2d3c7',
'0x140b2d9dd',
'0x140B2E570',
'0x140b2f59f',
'0x140b2f87f',
'0x140b356eb',
'0x140b41114',
'0x140b41124',
'0x140b4179d',
'0x140b417a5',
'0x140b46fcc',
'0x140b476dd',
'0x140b481d1',
'0x140b4cb80',
'0x140b5538d',
'0x140b55c5d',
'0x140b55f4d',
'0x140b5652d',
'0x140b5681d',
'0x140b56b0d',
'0x140b58dcf',
'0x140b5966f',
'0x140b5994f',
'0x140b59c2f',
'0x140b59f0f',
'0x140b5a1ef',
'0x140b65420',
'0x140b6639f',
'0x140b66a98',
'0x140b6decb',
'0x140b6f36b',
'0x140b6f9bb',
'0x140b6ff4b',
'0x140b704db',
'0x140b70a6b',
'0x140b732b7',
'0x140b825c3',
'0x140b89c4d',
'0x140b89c58',
'0x140b8a104',
'0x140b8d760',
'0x140b967eb',
'0x140b9720c',
'0x140b97ffd',
'0x140b986e0',
'0x140b9ee46',
'0x140b9ee5c',
'0x140ba81bb',
'0x140ba81d1',
'0x140ba8c81',
'0x140ba8c93',
'0x140ba9e59',
'0x140ba9e6b',
'0x140baa4fc',
'0x140baabc3',
'0x140baabd9',
'0x140bb1c1d',
'0x140bb28dd',
'0x140bb3733',
'0x140bb3af1',
'0x140bb3eaf',
'0x140bb43f2',
'0x140bb46fc',
'0x140bb49d5',
'0x140bb4c97',
'0x140bb4e08',
'0x140bb4f79',
'0x140bb50ea',
'0x140bb5263',
'0x140bb8127',
'0x140bb94cb',
'0x140bb94da',
'0x140bbad28',
'0x140bbaf68',
'0x140bbaf88',
'0x140bc2b66',
'0x140bca9ec',
'0x140bcb6cd',
'0x140bcbdbf',
'0x140bcc09f',
'0x140bd31e1',
'0x140bd374b',
'0x140bd3cdb',
'0x140bf547f',
'0x140bf5572',
'0x140bf5589',
'0x140bf69e8',
'0x140bf6b9f',
'0x140bfabfc',
'0x140bfb895',
'0x140bfb95c',
'0x140bfc910',
'0x140bfc98d',
'0x140bffbf4',
'0x140c03e50',
'0x140c0b749',
'0x140c0f12d',
'0x140c0f41d',
'0x140c0f70d',
'0x140c0ffdd',
'0x140c103ef',
'0x140c106cf',
'0x140c109af',
'0x140c10c8f',
'0x140c2a4ff',
'0x140c2a69f',
'0x140c2c2e4',
'0x140c2c2f3',
'0x140c2c9c4',
'0x140c2c9d3',
'0x140c2d0a4',
'0x140c2d0b3',
'0x140c2dbcf',
'0x140c2dbe8',
'0x140c2de68',
'0x140c2dee8',
'0x140c344b0',
'0x140c34a2b',
'0x140c34fdb',
'0x140c3558b',
'0x140c36949',
'0x140c41369',
'0x140c41989',
'0x140c41f54',
'0x140c4819a',
'0x140c4d184',
'0x140c4d2eb',
'0x140c4d45c',
'0x140c521d4',
'0x140c53015',
'0x140c535f3',
'0x140c536f4',
'0x140c54014',
'0x140c58053',
'0x140c68191',
'0x140c754b0',
'0x140c764f1',
'0x140c769e5',
'0x140c797bd',
'0x140c79aed',
'0x140c85ffe',
'0x140c8a6c7',
'0x140c8ad17',
'0x140c8e3cf',
'0x140c8e6af',
'0x140ca9819',
'0x140ca9aa3',
'0x140caa129',
'0x140cab79a',
'0x140cb1200',
'0x140cb4b6e',
'0x140cce200',
'0x140cce4f1',
'0x140ccfcf9',
'0x140cd01a2',
'0x140cd0633',
'0x140cd0af2',
'0x140cd1239',
'0x140cd17bb',
'0x140cd1c89',
'0x140cd2189',
'0x140cd2822',
'0x140cd2eac',
'0x140cd6a53',
'0x140cd6ac6',
'0x140cd6d94',
'0x140cd869a',
'0x140cd9115',
'0x140cd912d',
'0x140d51b5d',
'0x140d548dc',
'0x140d5a5bc',
'0x140d9ae82',
'0x140d9b5d5',
'0x140d9b9ad',
'0x140d9d039',
'0x140d9dd83',
'0x140E01BC0',
'0x140E17210',
'0x140e1befa',
'0x140e30088',
'0x140e30608',
'0x140e30e78',
'0x140e31278',
'0x140e34258',
'0x140e34298',
'0x140e342d8',
'0x140e34318',
'0x140e34358',
'0x140e34398',
'0x140f3e025',
'0x140f47b2d',
'0x140f4834d',
'0x140f485bd',
'0x140fc8568',
'0x140fc8948',
'0x140fc8b48',
'0x140fc8ff8',
'0x140fc94a8',
'0x140fc9a08',
'0x140fc9f58',
'0x140fca338',
'0x140fcbfc8',
'0x140FCE890',
'0x140ffc6b8',
'0x141022588',
'0x141023938',
'0x1410E9B70',
'0x1410EBC10',
'0x1410ed8fb',
'0x1410f3088',
'0x1410f3cd8',
'0x14111bf98',
'0x14112ca08',
'0x1411ea0fc',
'0x14120dd45',
'0x14120e1d2',
'0x141213875',
'0x14158dec3',
'0x1416bf4cb',
'0x1416c20b3',
'0x1416f9d39',
'0x14174f3f1',
'0x14175a6fe',
'0x14177a988',
'0x14177b3c0',
'0x14177b531',
'0x14177c968',
'0x14177ece1',
'0x14177f936',
'0x14177fa66',
'0x14177fa9d',
'0x14177fc06',
'0x141780158',
'0x1422c8375',
'0x1422fd855',
'0x1423096ea',
'0x14230a4c4',
'0x1424d8d61',
'0x1424daa8a',
'0x142619e72',
'0x142619ed9',
'0x1426dba60',
'0x142dd281c',
'0x142dd29ae',
'0x142dd430d',
'0x142def90e',
'0x142f62fa5',
'0x142f83387',
'0x142f88ce9',
'0x142ff6912',
'0x14303e895',
'0x1431ce560',
'0x1435b4bec',
'0x143651a19',
'0x1436535c9',
'0x14365cc07',
'0x14365ff54',
'0x1436743ff',
'0x14367459a',
'0x1436745ab',
'0x143674621',
'0x1436747a4',
'0x14368ef2a',
'0x143697296',
'0x143af4264',
'0x143b00031',
'0x143b08250',
'0x143b15a46',
'0x143b281a1',
'0x143b2921e',
'0x143b29b11',
'0x143b33e35',
'0x143b3561e',
'0x143be09df',
'0x143be0a67',
'0x143be34af',
'0x143be371e',
'0x143c00d4b',
'0x143c36a37',
'0x143e14164',
'0x143e448b7',
'0x144bd44fe',
'0x1451f1f5b',
'0x1451f4fc2',
'0x1451fb0ed',
'0x1451fb255',
'0x145203503',
'0x145203ad2',
'0x145219e98',
'0x145d853fa',
'0x145d8a14d',
'0x145e9be8a',
'0x145fac406',
'0x145fc80e3',
'0x145fc81f1',
'0x145fc8682',
'0x145fcac45',
'0x14606d515',
'0x14617e47d',
'0x1462243e6',
'0x146224435',
'0x1462249ce',
'0x146743ff0',
'0x146747f16',
'0x14674fc78',
'0x146766d6c',
'0x1467c3482',
'0x1467c9ced',
'0x1467c9ea7',
'0x1467ca19b',
'0x1467ca618',
'0x1467caa8c',
'0x14681ded7',
'0x14685dc12',
'0x14686b171',
'0x14686e17f',
'0x14687b388',
'0x146881c9e',
'0x14691c60b',
'0x14699f1ba',
'0x146a01003',
'0x146a011ea',
'0x146a116cd',
'0x146a41532',
'0x146a44905',
'0x146a44a5d',
'0x146a5b6a8',
'0x146a61a0a',
'0x146a61a1f',
'0x1471dc713',
'0x1471de43f',
'0x1471e9bdc',
'0x1472b2b8e',
'0x1472b2b93',
'0x1472ca2ce',
'0x1472eac17',
'0x1472eac62',
'0x1472eac78',
'0x1472eb61a',
'0x1472ebb15',
'0x1472ec1e3',
'0x1472f1c78',
'0x1472f857e',
'0x1473f5e05',
'0x1473f817f',
'0x1473f9e78',
'0x1473fdaf0',
'0x1473fe048',
'0x1473fe4cb',
'0x1473fec8f',
'0x147401abe',
'0x147402d72',
'0x147409136',
'0x14740b8be',
'0x14740bc45',
'0x14740bcb8',
'0x14740bdcb',
'0x14740bf78',
'0x1478BF550',
'0x1478BF6C0',
'0x1478BFE00',
'0x1478BFFB0',
'0x1478C01F0',
'0x1478C0420',
'0x1478c068e',
'0x1478C2910',
'0x1478C2A50',
'0x1478C4090',
'0x1478C44A0',
'0x1478C54D0',
'0x1478C5700',
'0x1478C5AC0',
'0x1478C7380',
'0x1478C77C0',
'0x1478C7DB0',
'0x1478C99C0',
'0x1478CB5C0',
'0x1478CC490',
'0x1478CCB40',
'0x1478CD7B0',
'0x1478CD9A0',
'0x1478CDD80',
'0x1478CDEC0',
'0x1478CDF80',
'0x1478CE330',
'0x1478CE5B0',
'0x1478CEC10',
'0x1478D0230',
'0x1478D11A0',
'0x1478D26B0',
'0x1478D3390',
'0x1478D37C0',
'0x1478D3C00',
'0x1478D3CC0',
'0x1478D3F20',
'0x1478D3FF0',
'0x1478D6EE0',
'0x1478D7150',
'0x1478D74C0',
'0x1478D80B0',
'0x1478D8500',
'0x1478D8D50',
'0x1478D90A0',
'0x1478D90B0',
'0x1478D9F80',
'0x1478d9fd7',
'0x1478DA0F0',
'0x1478DA630',
'0x1478DBD60',
'0x1478DFCD0',
'0x1478DFFD0',
'0x1478E0590',
'0x1478E09A0',
'0x1478E31F0',
'0x1478E3360',
'0x1478F3CF0',
'0x1478F45C0',
'0x147900F10',
'0x147901890',
'0x147901CD0',
'0x147901DE0',
'0x147901EF0',
'0x147902000',
'0x147902500',
'0x147903900',
'0x147903E00',
'0x147904300',
'0x147904800',
'0x147905C50',
'0x14790CA40',
'0x14790CCC0',
'0x14790CDC0',
'0x147912450',
'0x147912FC0',
'0x147914FD0',
'0x1479168C0',
'0x147916CA0',
'0x147916DA0',
'0x1479184B0',
'0x14791A2F0',
'0x14791A470',
'0x14791A6B0',
'0x14791DFE0',
'0x14791E130',
'0x14791EC40',
'0x14791F460',
'0x1479241E0',
'0x1479247F0',
'0x1479260B0',
'0x147928040',
'0x1479287C0',
'0x147928F90',
'0x14792B620',
'0x14792C0B0',
'0x14792C380',
'0x14792C9D0',
'0x14792CB40',
'0x14792CCB0',
'0x14792CE30',
'0x14792E780',
'0x14792E830',
'0x14792F350',
'0x14792F430',
'0x14792F510',
'0x14792F770',
'0x147930B40',
'0x147930C10',
'0x147931A80',
'0x147937270',
'0x1479372C0',
'0x147941370',
'0x14795EFE0',
'0x14795F290',
'0x147965C50',
'0x147967710',
'0x147972D90',
'0x147973260',
'0x147973990',
'0x147973AA0',
'0x147973E00',
'0x147977110',
'0x147977210',
'0x147d28fa2',
];

var addrs = [
//    '0x147000270',
//    '0x147b70da0',
'0x140517A40',
];

console.log('===== ' + addrs.length + ' =====');

// Create a graph structure to track call relationships
const callGraph = {
    nodes: new Map(), // Map of address -> {moduleName, symbolName, callers: Map(caller -> count), totalCalls: number, isRoot: boolean}
    addNode: function(addr, moduleName, symbolName, isRoot = false) {
        if (!this.nodes.has(addr)) {
            this.nodes.set(addr, {
                moduleName: moduleName,
                symbolName: symbolName,
                callers: new Map(),
                totalCalls: 0,
                isRoot: isRoot
            });
        }
        return this.nodes.get(addr);
    },
    addEdge: function(fromAddr, toAddr) {
        const toNode = this.nodes.get(toAddr);
        if (toNode) {
            // Increment total calls
            toNode.totalCalls++;
            
            // Increment calls from specific caller
            const currentCount = toNode.callers.get(fromAddr) || 0;
            toNode.callers.set(fromAddr, currentCount + 1);
        }
    },
    toDot: function() {
        let dot = 'digraph callgraph {\n';
        dot += '  rankdir=TB;\n';
        dot += '  node [shape=box];\n';
        dot += '  edge [arrowhead=vee];\n';
        dot += '  splines=ortho;\n';
        dot += '  overlap=false;\n';
        
        // Create rank constraints for root nodes
        dot += '  { rank = source; ';
        for (let [addr, node] of this.nodes) {
            if (node.isRoot) {
                dot += `"${addr}"; `;
            }
        }
        dot += '}\n';
        
        // Get 90th percentile of calls
        const callCounts = Array.from(this.nodes.values()).map(n => n.totalCalls).sort((a,b) => a-b);
        const p90Calls = callCounts[Math.floor(callCounts.length * 0.9)] || 1; // Avoid division by zero
        
        // Add nodes
        for (let [addr, node] of this.nodes) {
            const label = `${node.moduleName}!${node.symbolName}`;

            if (label === "unknown!unknown") {
                continue;
            }

            // Calculate color intensity using 90th percentile (0-255)
            const intensity = Math.floor((Math.min(node.totalCalls, p90Calls) / p90Calls) * 255);
            const color = `#FF${(255-intensity).toString(16).padStart(2,'0')}${(255-intensity).toString(16).padStart(2,'0')}`;

            // Add border for root nodes
            const border = node.isRoot ? ', penwidth=3, color="#000000"' : '';
            dot += `  "${addr}" [style=filled, fillcolor="${color}"${border}, label="${label}"];\n`;
        }
        
        // Get 90th percentile of edge weights
        const edgeWeights = [];
        for (let node of this.nodes.values()) {
            edgeWeights.push(...Array.from(node.callers.values()));
        }
        edgeWeights.sort((a,b) => a-b);
        const p90Weight = edgeWeights[Math.floor(edgeWeights.length * 0.9)] || 1; // Avoid division by zero
        
        // Add edges
        for (let [addr, node] of this.nodes) {
            for (let [caller, count] of node.callers) {
                // Calculate edge thickness using 90th percentile (1-10)
                const weight = Math.max(1, Math.floor((Math.min(count, p90Weight) / p90Weight) * 10));
                dot += `  "${caller}" -> "${addr}" [penwidth=${weight}];\n`;
            }
        }
        
        dot += '}\n';
        return dot;
    }
};

// Configuration
const MAX_DEPTH = 2; // Limit how deep we intercept
const interceptedAddrs = new Set(); // Track intercepted addresses
const interceptionQueue = []; // Queue for addresses to intercept
let isProcessing = false; // Flag to indicate if queue is being processed

// Function to queue an address for interception
function interceptAddress(addr, depth = 0, isRoot = false) {
    const addrStr = addr.toString();
    if (depth > MAX_DEPTH || interceptedAddrs.has(addrStr)) {
        return;
    }
    interceptionQueue.push({ addr, depth, isRoot });
    if (!isProcessing) {
        isProcessing = true;
        setImmediate(processQueue);
    }
}

// Process the queue until it's empty
function processQueue() {
    while (interceptionQueue.length > 0) {
        const { addr, depth, isRoot } = interceptionQueue.shift();
        const addrStr = addr.toString();
        if (!interceptedAddrs.has(addrStr)) {
            interceptedAddrs.add(addrStr);
            try {
                // Get symbol information for the address
                const addrSymbol = DebugSymbol.fromAddress(addr);
                const addrModule = addrSymbol.moduleName || "unknown";
                const addrName = addrSymbol.name || "unknown";

                // Add to the call graph
                callGraph.addNode(addrStr, addrModule, addrName, isRoot);

                // Attach the interceptor
                Interceptor.attach(addr, {
                    onEnter: function(args) {
                        console.log("Called function at " + addr);
                        const backtrace = Thread.backtrace(this.context, Backtracer.FUZZY);

                        if (backtrace.length === 0) {
                            console.log("Warning: Empty backtrace at " + addr);
                            return;
                        }

                        // Process the backtrace
                        backtrace.forEach(function(traceAddr, index) {
                            const symbol = DebugSymbol.fromAddress(traceAddr);
                            const moduleName = symbol.moduleName || "unknown";
                            const symbolName = symbol.name || "unknown";

                            // Add nodes and edges to the call graph
                            const traceAddrStr = traceAddr.toString();
                            callGraph.addNode(traceAddrStr, moduleName, symbolName);
                            if (index === 0) {
                                callGraph.addEdge(traceAddrStr, addrStr);
                            }
                            if (index > 0) {
                                callGraph.addEdge(traceAddrStr, backtrace[index - 1].toString());
                            }

                            // Only intercept further if within depth limit
                            if (depth < MAX_DEPTH) {
                                //interceptAddress(traceAddr, depth + 1);
                            }
                        });
                        console.log("Graph contains " + callGraph.nodes.size + " unique functions");
                    }
                });
            } catch (e) {
                console.error("Failed to intercept " + addr + ": " + e);
            }
        }
    }
    isProcessing = false;
}

// Intercept initial addresses
addrs.forEach(addr => {
    const addr_ptr = ptr(addr);
    console.log("Queueing initial address: " + addr_ptr);
    interceptAddress(addr_ptr, 0, true);
});

// Keep the program running to allow interceptions
setTimeout(() => {
    console.log("Keeping the program alive...");
    console.log(callGraph.toDot()); // Output the final DOT graph
}, 10000);