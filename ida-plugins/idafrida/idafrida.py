# -*- coding: utf-8 -*-
"""
IDAFrida Plugin: Generate and manage Frida hooking scripts from IDA Pro.
Version: 2.1.0 (IDA 9.0 Port)
Features:
- Basic function/address hooks
- Struct dumping (with Hex-Rays context, using ida_typeinf)
- RPC stub generation (with Hex-Rays context)
- Memory access tracing
- Function hooks with backtraces
- Common Libc function tracers
- Modifiable function hooks
- Conditional function hooks
- Memory scanning
- Configuration management (NetNode)
"""

import json
import os
import sys
import re
import traceback
import subprocess

# --- IDA API Imports ---
try:
    import ida_idaapi
    import ida_kernwin
    import ida_funcs
    import ida_nalt
    import ida_ua
    import ida_idp
    import ida_diskio
    import ida_typeinf # REPLACEMENT for ida_struct/ida_enum
    import ida_bytes
    import ida_name
    import ida_netnode
    import ida_loader
    import ida_ida # For inf_ structure accessors
    import idc

    # Hex-Rays API (optional, but enhances features)
    HAS_HEXRAYS = False
    try:
        import ida_hexrays
        HAS_HEXRAYS = True
    except ImportError:
        print("[IDAFrida] Hex-Rays decompiler not available. Some features will have limited context.")

    # Define idaapi for convenience if needed elsewhere, prefer specific modules
    idaapi = ida_idaapi

except ImportError:
    print("FATAL: Failed to import IDA Pro modules. Ensure this script runs within an IDA environment.")
    sys.exit(1) # Exit if essential IDA modules are missing


# --- PyQt5 Imports ---
try:
    from PyQt5 import QtCore, QtWidgets, QtGui
    from PyQt5.Qt import QApplication # For clipboard
    from PyQt5.QtWidgets import (QDialog, QDialogButtonBox, QHBoxLayout, QLineEdit,
                                 QPushButton, QTextEdit, QVBoxLayout, QLabel, QCheckBox,
                                 QMessageBox) # noqa: F401
    HAS_PYQT = True
except ImportError:
    print("[IDAFrida] Warning: Failed to import PyQt5 modules. UI features will be limited.")
    HAS_PYQT = False
    # Dummy classes for static analysis if PyQt is missing
    class DummyQApplication:
        @staticmethod
        def clipboard():
            class DummyClipboard:
                def setText(self, text): print(f"Clipboard (dummy): {text}")
            return DummyClipboard()
    QApplication = DummyQApplication
    QDialog = object
    # ... add other dummies if needed by linters ...


# --- Plugin Constants ---
PLUGIN_NAME = "IDAFrida"
PLUGIN_VERSION = "2.1.0" # Updated version for IDA 9.0 port
PLUGIN_COMMENT = "Generate and manage Frida hooking scripts from IDA Pro (IDA 9.0 Compatible)."
PLUGIN_HELP = "Right-click in Disassembly, Pseudocode, Functions, Structs, Hex View for options."
PLUGIN_WANTED_NAME = PLUGIN_NAME
PLUGIN_WANTED_HOTKEY = "" # No global hotkey for the plugin itself

# --- Configuration Node ---
# Use netnode for storing config within the IDB (more portable than external file)
CONFIG_NODE_NAME = f"$ {PLUGIN_NAME}_config"
CONFIG_TAG = 'C' # Tag for config data within the node

# --- Logging Helpers ---
def log_info(msg):
    print(f"[*] {PLUGIN_NAME}: {msg}")

def log_warn(msg):
    print(f"[!] {PLUGIN_NAME}: {msg}")
    # ida_kernwin.msg(f"{PLUGIN_NAME} Warning: {msg}\n") # Optional: Show in IDA output

def log_error(msg, e=None):
    print(f"[E] {PLUGIN_NAME}: {msg}")
    if e:
        print(f"    Exception: {e}")
        # print(f"    Traceback: {traceback.format_exc()}") # Optional: Full traceback
    ida_kernwin.warning(f"{PLUGIN_NAME} Error: {msg}" + (f" ({e})" if e else ""))


############################################################################
# Default Frida Hook Templates (Linux Target)
############################################################################

# --- Basic Templates ---
default_func_hook_template = r"""
// Frida Hook Script generated by IDAFrida (Basic Function Hook)
// Target: Function [funcname] in module [filename] at IDA offset [offset]
// Platform: Linux

(function () {
    console.log("[IDAFrida] Script loaded for module: [filename]");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[offset]"); // Offset relative to IDA's imagebase

    // --- Helper Functions ---

    /**
     * Attempts to print argument value, handling potential errors.
     */
    function formatArgument(addr) {
        try {
            // @ts-ignore
            if (addr != null && !addr.isNull() && Process.findRangeByAddress(addr)) {
                 // @ts-ignore
                 return addr + " (ptr)";
            }
            // @ts-ignore
            return addr.toString();
        } catch (e) {
            // @ts-ignore
            return addr + " (error: " + e.message + ")";
        }
    }

    /**
     * Performs the actual hooking logic once the module base is known.
     */
    function hookImplementation(moduleBase) {
        // @ts-ignore
        const targetAddress = moduleBase.add(TARGET_OFFSET);
        // @ts-ignore
        const relativeOffset = targetAddress.sub(moduleBase);

        console.log(`[IDAFrida] Attempting to hook [funcname] at address ${targetAddress} (offset ${relativeOffset} from ${moduleBase})`);

        try {
            Interceptor.attach(targetAddress, {
                onEnter: function (args) {
                    this.log = [`[IDAFrida] ENTER [funcname] @ ${targetAddress} (offset ${relativeOffset})`];
                    this.params = [];
                    const numArgs = parseInt("[nargs]", 10);

                    for (let i = 0; i < numArgs; i++) {
                        this.params.push(args[i]);
                        // @ts-ignore
                        this.log.push(`  arg[${i}]: ${formatArgument(args[i])}`);
                    }
                    console.log(this.log.join('\n'));
                },
                onLeave: function (retval) {
                    const log = [`[IDAFrida] LEAVE [funcname] @ ${targetAddress} (offset ${relativeOffset})`];
                    // @ts-ignore
                    log.push(`  retval: ${formatArgument(retval)}`);
                    console.log(log.join('\n'));
                }
            });
            console.log(`[IDAFrida] Successfully hooked [funcname] at ${targetAddress}`);
        } catch (error) {
            // @ts-ignore
            console.error(`[IDAFrida] Failed to hook [funcname] at ${targetAddress}: ${error.message}`);
            // @ts-ignore
            console.error(error.stack);
        }
    }

    /**
     * Waits for the target library to be loaded if it isn't already.
     */
    function ensureModuleLoadedAndHook() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            console.log(`[IDAFrida] Module ${MODULE_NAME} already loaded at ${module.base}. Hooking now.`);
            hookImplementation(module.base);
            return; // Module found, no need to wait
        }

        // Module not loaded yet, wait for dlopen
        console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
        // @ts-ignore
        const dlopenInterceptor = Interceptor.attach(
            // @ts-ignore
            Module.findExportByName(null, "dlopen"), { // Use standard dlopen for Linux
            onEnter: function(args) {
                // @ts-ignore
                const libraryPath = args[0].readCString();
                if (libraryPath && libraryPath.includes(MODULE_NAME)) {
                    this.libraryFound = true;
                    console.log(`[IDAFrida] dlopen called for: ${libraryPath}`);
                }
            },
            onLeave: function(retval) {
                // @ts-ignore
                if (this.libraryFound && !retval.isNull()) {
                    console.log(`[IDAFrida] Module ${MODULE_NAME} loaded via dlopen.`);
                    // @ts-ignore
                    const loadedModule = Process.findModuleByName(MODULE_NAME);
                    if (loadedModule) {
                        hookImplementation(loadedModule.base);
                        dlopenInterceptor.detach(); // Stop listening once hooked
                    } else {
                         console.error(`[IDAFrida] Failed to find module ${MODULE_NAME} immediately after dlopen returned.`);
                    }
                }
                this.libraryFound = false; // Reset for next call
            }
        });
    }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(ensureModuleLoadedAndHook);

})();
"""

default_address_hook_template = r"""
// Frida Hook Script generated by IDAFrida (Basic Address Hook)
// Target: Address [address] in module [filename]
// Registers to log: [registers]
// Platform: Linux

(function () {
    console.log("[IDAFrida] Script loaded for module: [filename]");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[address]"); // Offset relative to IDA's imagebase
    const REGISTERS_TO_LOG = "[registers]".trim().split(/\s+/).filter(Boolean);

    // --- Helper Functions ---

    /**
     * Attempts to print argument value, handling potential errors.
     */
    function formatArgument(addr) {
        try {
            // @ts-ignore
            if (addr != null && !addr.isNull() && Process.findRangeByAddress(addr)) {
                 // @ts-ignore
                 return addr + " (ptr)";
            }
            // @ts-ignore
            return addr.toString();
        } catch (e) {
            // @ts-ignore
            return addr + " (error: " + e.message + ")";
        }
    }

    /**
     * Performs the actual hooking logic once the module base is known.
     */
    function hookImplementation(moduleBase) {
        // @ts-ignore
        const targetAddress = moduleBase.add(TARGET_OFFSET);
        // @ts-ignore
        const relativeOffset = targetAddress.sub(moduleBase);

        console.log(`[IDAFrida] Attempting to hook address ${targetAddress} (offset ${relativeOffset} from ${moduleBase})`);

        try {
            Interceptor.attach(targetAddress, {
                onEnter: function (args) {
                    const log = [`[IDAFrida] HIT Address ${targetAddress} (offset ${relativeOffset})`];

                    if (REGISTERS_TO_LOG.length > 0) {
                        log.push("  Registers:");
                        REGISTERS_TO_LOG.forEach(reg => {
                            try {
                                // @ts-ignore
                                log.push(`    ${reg}: ${formatArgument(this.context[reg])}`);
                            } catch (e) {
                                // @ts-ignore
                                log.push(`    ${reg}: <error: ${e.message}>`);
                            }
                        });
                    } else {
                        log.push("  (No registers specified to log)");
                    }
                    console.log(log.join('\n'));
                }
            });
            console.log(`[IDAFrida] Successfully hooked address ${targetAddress}`);
        } catch (error) {
            // @ts-ignore
            console.error(`[IDAFrida] Failed to hook address ${targetAddress}: ${error.message}`);
            // @ts-ignore
            console.error(error.stack);
        }
    }

     /**
     * Waits for the target library to be loaded if it isn't already.
     */
    function ensureModuleLoadedAndHook() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            console.log(`[IDAFrida] Module ${MODULE_NAME} already loaded at ${module.base}. Hooking now.`);
            hookImplementation(module.base);
            return; // Module found, no need to wait
        }

        // Module not loaded yet, wait for dlopen
        console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
        // @ts-ignore
        const dlopenInterceptor = Interceptor.attach(
            // @ts-ignore
            Module.findExportByName(null, "dlopen"), { // Use standard dlopen for Linux
            onEnter: function(args) {
                // @ts-ignore
                const libraryPath = args[0].readCString();
                if (libraryPath && libraryPath.includes(MODULE_NAME)) {
                    this.libraryFound = true;
                    console.log(`[IDAFrida] dlopen called for: ${libraryPath}`);
                }
            },
            onLeave: function(retval) {
                // @ts-ignore
                if (this.libraryFound && !retval.isNull()) {
                    console.log(`[IDAFrida] Module ${MODULE_NAME} loaded via dlopen.`);
                    // @ts-ignore
                    const loadedModule = Process.findModuleByName(MODULE_NAME);
                    if (loadedModule) {
                        hookImplementation(loadedModule.base);
                        dlopenInterceptor.detach(); // Stop listening once hooked
                    } else {
                         console.error(`[IDAFrida] Failed to find module ${MODULE_NAME} immediately after dlopen returned.`);
                    }
                }
                this.libraryFound = false; // Reset for next call
            }
        });
    }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(ensureModuleLoadedAndHook);

})();
"""


# --- Tier 1 Templates ---
dump_struct_template = r"""
// Frida Hook Script generated by IDAFrida (Struct Dump)
// Target: Dump struct [structName] at address derived from context
// Module: [filename], Base Offset: [baseOffset]

(function () {
    console.log("[IDAFrida] Script loaded to dump struct [structName] from module: [filename]");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[baseOffset]"); // Offset of the struct *instance* relative to IDA's imagebase
    const STRUCT_NAME = "[structName]";
    const STRUCT_SIZE = [structSize]; // Size in bytes
    const MAX_DEPTH = 3; // Limit recursion depth for nested structs/pointers

    // --- Helper Functions ---
    // @ts-ignore
    function formatAddress(addr) {
        try {
            // @ts-ignore
            if (!addr || addr.isNull()) return "null";
            // @ts-ignore
            const module = Process.findModuleByAddress(addr);
            if (module) {
                // @ts-ignore
                return `${addr} (${module.name}+0x${addr.sub(module.base).toString(16)})`;
            }
            // @ts-ignore
            const symbol = DebugSymbol.fromAddress(addr);
            // @ts-ignore
            if (symbol && symbol.name) {
                 // @ts-ignore
                 return `${addr} (${symbol.name} + 0x${addr.sub(symbol.address).toString(16)})`;
            }
            // @ts-ignore
            return addr.toString();
        } catch(e) {
            // @ts-ignore
            return addr + " (error formatting)";
        }
    }

    // @ts-ignore
    function readStringSafely(ptr, length = 64) {
        try {
            // @ts-ignore
            if (!ptr || ptr.isNull()) return "<null_ptr>";
            // @ts-ignore
            return ptr.readCString(length) || "<empty_string>";
        } catch (e) {
            // @ts-ignore
            return `<read_error: ${e.message}>`;
        }
    }

    /**
     * Reads and logs struct members based on IDA definition.
     */
    // @ts-ignore
    function dumpStructRecursive(structPtr, structName, structSize, indent = "", depth = 0) {
        // @ts-ignore
        if (!structPtr || structPtr.isNull()) {
            console.log(`${indent}Struct ${structName}: <null_ptr>`);
            return;
        }
        if (depth > MAX_DEPTH) {
             console.log(`${indent}Struct ${structName} @ ${formatAddress(structPtr)}: <max_depth_reached>`);
             return;
        }

        console.log(`${indent}Dumping struct ${structName} @ ${formatAddress(structPtr)} (Size: ${structSize} bytes) {`);
        const innerIndent = indent + "  ";
        try {
// --- BEGIN STRUCT MEMBER DUMP ---
[memberDumpCode]
// --- END STRUCT MEMBER DUMP ---
        } catch (error) {
            // @ts-ignore
            console.error(`${innerIndent}[IDAFrida] Error dumping struct ${structName} at ${structPtr}: ${error.message}`);
        }
        console.log(`${indent}}`);
    }

    /**
     * Locates the module and calculates the target address.
     */
    function findAndDump() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            // @ts-ignore
            const targetAddress = module.base.add(TARGET_OFFSET);
            console.log(`[IDAFrida] Found module ${MODULE_NAME} at ${module.base}. Target struct instance address: ${targetAddress}`);
            dumpStructRecursive(targetAddress, STRUCT_NAME, STRUCT_SIZE);
        } else {
            // Module not loaded yet, wait for dlopen (simplified wait)
            console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
            // @ts-ignore
            const dlopenInterceptor = Interceptor.attach(Module.findExportByName(null, "dlopen"), {
                onLeave: function(retval) {
                    // @ts-ignore
                    if (!retval.isNull()) {
                        // @ts-ignore
                        const loadedModule = Process.findModuleByName(MODULE_NAME);
                        if (loadedModule) {
                            // @ts-ignore
                            const targetAddress = loadedModule.base.add(TARGET_OFFSET);
                             console.log(`[IDAFrida] Module ${MODULE_NAME} loaded at ${loadedModule.base}. Target struct instance address: ${targetAddress}`);
                            dumpStructRecursive(targetAddress, STRUCT_NAME, STRUCT_SIZE);
                            dlopenInterceptor.detach();
                        }
                    }
                }
            });
        }
    }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(findAndDump);

})();
"""

rpc_stub_template = r"""
// Frida Hook Script generated by IDAFrida (RPC Stub)
// Target: Export function [funcName] via RPC
// Module: [filename], Offset: [offset]
// Signature: [signature]

(function () {
    console.log("[IDAFrida] Script loaded to export RPC function '[exportName]' for [filename]->[funcName]");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[offset]");
    const SCRIPT_NAME = "IDAFrida"; // Name used by Python caller to get exports

    /**
     * Waits for module and sets up RPC export.
     */
    function setupRpc() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (!module) {
            console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
            // @ts-ignore
            const dlopenInterceptor = Interceptor.attach(Module.findExportByName(null, "dlopen"), {
                onLeave: function(retval) {
                    // @ts-ignore
                    if (!retval.isNull()) {
                        // @ts-ignore
                        if (Process.findModuleByName(MODULE_NAME)) {
                            console.log(`[IDAFrida] Module ${MODULE_NAME} loaded. Setting up RPC.`);
                            performRpcSetup();
                            dlopenInterceptor.detach();
                        }
                    }
                }
            });
            return; // Wait for dlopen
        }
        // Module already loaded
        performRpcSetup();
    }

    /**
     * Performs the actual RPC setup once the module is loaded.
     */
    function performRpcSetup() {
        // @ts-ignore
        const moduleBase = Module.findBaseAddress(MODULE_NAME);
        if (!moduleBase) {
             console.error(`[IDAFrida] Failed to get base address for ${MODULE_NAME} even after load.`);
             return;
        }
        // @ts-ignore
        const targetFuncPtr = moduleBase.add(TARGET_OFFSET);
        console.log(`[IDAFrida] Target function [funcName] found at ${targetFuncPtr}`);

        try {
            // @ts-ignore // Define the NativeFunction
            const targetFunc = new NativeFunction(
                targetFuncPtr,
                '[retTypeFrida]', // Return type (e.g., 'int', 'pointer', 'void')
                [ [argTypesFrida] ] // Argument types (e.g., "'int', 'pointer'")
            );

            // Define the RPC export
            rpc.exports = {
                // The name of the function callable from Python
                '[exportName]': function ([argNamesJs]) { // Arguments (e.g., arg0, arg1)
                    // @ts-ignore
                    const argsArray = Array.from(arguments); // Get arguments as array
                    console.log(`[IDAFrida RPC] Received call to [exportName] with args: ${JSON.stringify(argsArray)}`);
                    try {
                        // --- Argument Marshalling (Basic) ---
                        // Frida handles basic types well (numbers, strings for pointers).
                        // Complex structs/arrays passed by value require manual marshalling here.
                        // Example: If arg0 is a pointer to a struct you need to pass from Python,
                        // Python might send the address as a string/number.
                        // If a struct needs to be *created* in JS based on Python data,
                        // you'd allocate memory and write fields here before calling.
                        console.log("[IDAFrida RPC] Calling native function...");
                        // @ts-ignore
                        var result = targetFunc.apply(null, argsArray); // Use apply to pass args array

                        // --- Return Value Marshalling (Basic) ---
                        // If the native function returns a pointer to a struct/complex data,
                        // you might need to read data from that pointer and return a JS object/array
                        // instead of just the raw pointer, depending on what the Python side expects.
                        // @ts-ignore
                        console.log(`[IDAFrida RPC] Native function [funcName] returned: ${result}`);
                        return result; // Return raw result for now
                    } catch (callError) {
                         // @ts-ignore
                         console.error(`[IDAFrida RPC] Error calling native function [funcName]: ${callError.message}`);
                         // @ts-ignore
                         console.error(callError.stack);
                         throw callError; // Re-throw error to Python caller
                    }
                }
            };
            // Set script name for Python access
            // @ts-ignore
            rpc.exports.scriptName = SCRIPT_NAME;
            console.log(`[IDAFrida] RPC function '[exportName]' exported successfully. Access via session.get_script("${SCRIPT_NAME}").exports`);

        } catch (setupError) {
             // @ts-ignore
             console.error(`[IDAFrida] Error setting up NativeFunction or RPC export for [funcName]: ${setupError.message}`);
             // @ts-ignore
             console.error(setupError.stack);
        }
    }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(setupRpc);

})();
"""

memory_trace_template = r"""
// Frida Hook Script generated by IDAFrida (Memory Trace)
// Target: Monitor memory access at offset [offset] in module [filename]
// Size: [monitorSize] bytes

(function () {
    console.log("[IDAFrida] Script loaded to monitor memory access in module: [filename]");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[offset]");
    const MONITOR_SIZE = [monitorSize];

    /**
     * Waits for module and enables memory monitoring.
     */
    function findAndMonitor() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            // @ts-ignore
            const targetAddress = module.base.add(TARGET_OFFSET);
            console.log(`[IDAFrida] Found module ${MODULE_NAME} at ${module.base}. Monitoring address ${targetAddress} (size: ${MONITOR_SIZE})`);
            enableMonitoring(targetAddress);
        } else {
            console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
            // @ts-ignore
            const dlopenInterceptor = Interceptor.attach(Module.findExportByName(null, "dlopen"), {
                onLeave: function(retval) {
                    // @ts-ignore
                    if (!retval.isNull()) {
                        // @ts-ignore
                        const loadedModule = Process.findModuleByName(MODULE_NAME);
                        if (loadedModule) {
                            // @ts-ignore
                            const targetAddress = loadedModule.base.add(TARGET_OFFSET);
                            console.log(`[IDAFrida] Module ${MODULE_NAME} loaded at ${loadedModule.base}. Monitoring address ${targetAddress} (size: ${MONITOR_SIZE})`);
                            enableMonitoring(targetAddress);
                            dlopenInterceptor.detach();
                        }
                    }
                }
            });
        }
    }

    /**
     * Enables the MemoryAccessMonitor.
     */
    function enableMonitoring(address) {
        try {
            // @ts-ignore
            MemoryAccessMonitor.enable({ base: address, size: MONITOR_SIZE }, {
                onAccess: function (details) {
                    // @ts-ignore
                    var accessSource = DebugSymbol.fromAddress(details.from);
                    // @ts-ignore
                    var sourceInfo = `${details.from} (${accessSource.name ? `${accessSource.moduleName}!${accessSource.name}+${details.from.sub(accessSource.address)}` : 'unknown'})`;
                    // @ts-ignore
                    console.log(`[IDAFrida] Memory Access @ ${details.address} (Op: ${details.operation})`);
                    // @ts-ignore
                    console.log(`  From: ${sourceInfo}`);
                    console.log("---");
                }
            });
             console.log(`[IDAFrida] MemoryAccessMonitor enabled for ${address}.`);
        } catch (error) {
             // @ts-ignore
             console.error(`[IDAFrida] Failed to enable MemoryAccessMonitor at ${address}: ${error.message}`);
             // @ts-ignore
             console.error(error.stack);
        }
    }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(findAndMonitor);

})();
"""


# --- Tier 2 Templates ---
func_hook_with_backtrace_template = r"""
// Frida Hook Script generated by IDAFrida (Function Hook with Backtrace)
// Target: Function [funcname] in module [filename] at IDA offset [offset]
// Platform: Linux

(function () {
    console.log("[IDAFrida] Script loaded for module: [filename] (with backtrace)");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[offset]"); // Offset relative to IDA's imagebase

    // --- Helper Functions ---
    function formatArgument(addr) {
        try {
            // @ts-ignore
            if (addr != null && !addr.isNull() && Process.findRangeByAddress(addr)) {
                 // @ts-ignore
                 return addr + " (ptr)";
            }
            // @ts-ignore
            return addr.toString();
        } catch (e) {
            // @ts-ignore
            return addr + " (error: " + e.message + ")";
        }
     }

    /**
     * Performs the actual hooking logic once the module base is known.
     */
    function hookImplementation(moduleBase) {
        // @ts-ignore
        const targetAddress = moduleBase.add(TARGET_OFFSET);
        // @ts-ignore
        const relativeOffset = targetAddress.sub(moduleBase);

        console.log(`[IDAFrida] Attempting to hook [funcname] at address ${targetAddress} (offset ${relativeOffset} from ${moduleBase})`);

        try {
            Interceptor.attach(targetAddress, {
                onEnter: function (args) {
                    this.log = [`[IDAFrida] ENTER [funcname] @ ${targetAddress} (offset ${relativeOffset})`];
                    this.params = [];
                    const numArgs = parseInt("[nargs]", 10);

                    for (let i = 0; i < numArgs; i++) {
                        this.params.push(args[i]);
                        // @ts-ignore
                        this.log.push(`  arg[${i}]: ${formatArgument(args[i])}`);
                    }
                    console.log(this.log.join('\n'));

                    // --- Backtrace ---
                    try {
                        // @ts-ignore
                        console.log("[IDAFrida] Backtrace:\n" +
                            // @ts-ignore
                            Thread.backtrace(this.context, Backtracer.ACCURATE) // Or .FUZZY
                            // @ts-ignore
                            .map(addr => {
                                const sym = DebugSymbol.fromAddress(addr);
                                // @ts-ignore // Handle cases where symbol lookup fails
                                return sym.moduleName ? `${sym.moduleName}!${sym.name || '??'} (+0x${addr.sub(sym.address).toString(16)}) [${addr}]` : `[${addr}]`;
                            }).join("\n") + "\n");
                    } catch (btError) {
                         // @ts-ignore
                         console.error(`[IDAFrida] Error getting backtrace: ${btError.message}`);
                    }
                    // --- End Backtrace ---

                },
                onLeave: function (retval) {
                    const log = [`[IDAFrida] LEAVE [funcname] @ ${targetAddress} (offset ${relativeOffset})`];
                    // @ts-ignore
                    log.push(`  retval: ${formatArgument(retval)}`);
                    console.log(log.join('\n'));
                }
            });
            console.log(`[IDAFrida] Successfully hooked [funcname] at ${targetAddress}`);
        } catch (error) {
            // @ts-ignore
            console.error(`[IDAFrida] Failed to hook [funcname] at ${targetAddress}: ${error.message}`);
            // @ts-ignore
            console.error(error.stack);
        }
    }

    /**
     * Waits for the target library to be loaded if it isn't already.
     */
    function ensureModuleLoadedAndHook() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            console.log(`[IDAFrida] Module ${MODULE_NAME} already loaded at ${module.base}. Hooking now.`);
            hookImplementation(module.base);
            return; // Module found, no need to wait
        }

        // Module not loaded yet, wait for dlopen
        console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
        // @ts-ignore
        const dlopenInterceptor = Interceptor.attach(
            // @ts-ignore
            Module.findExportByName(null, "dlopen"), { // Use standard dlopen for Linux
            onEnter: function(args) {
                // @ts-ignore
                const libraryPath = args[0].readCString();
                if (libraryPath && libraryPath.includes(MODULE_NAME)) {
                    this.libraryFound = true;
                    console.log(`[IDAFrida] dlopen called for: ${libraryPath}`);
                }
            },
            onLeave: function(retval) {
                // @ts-ignore
                if (this.libraryFound && !retval.isNull()) {
                    console.log(`[IDAFrida] Module ${MODULE_NAME} loaded via dlopen.`);
                    // @ts-ignore
                    const loadedModule = Process.findModuleByName(MODULE_NAME);
                    if (loadedModule) {
                        hookImplementation(loadedModule.base);
                        dlopenInterceptor.detach(); // Stop listening once hooked
                    } else {
                         console.error(`[IDAFrida] Failed to find module ${MODULE_NAME} immediately after dlopen returned.`);
                    }
                }
                this.libraryFound = false; // Reset for next call
            }
        });
     }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(ensureModuleLoadedAndHook);

})();
"""

# Libc Tracers (Define templates for each)
libc_strcpy_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: strcpy
(function () {
    console.log("[IDAFrida] Script loaded to trace strcpy");
    try {
        // @ts-ignore
        Interceptor.attach(Module.findExportByName(null, "strcpy"), {
            onEnter: function(args) {
                // @ts-ignore
                this.dest = args[0];
                // @ts-ignore
                this.srcPtr = args[1];
                try {
                    // @ts-ignore // Limit string read length for safety
                    this.srcStr = this.srcPtr.readCString(256);
                    // @ts-ignore
                    console.log(`[IDAFrida] strcpy(dest=${this.dest}, src="${this.srcStr}")`);
                } catch (e) {
                    // @ts-ignore
                    console.log(`[IDAFrida] strcpy(dest=${this.dest}, src=${this.srcPtr}) - Error reading src: ${e.message}`);
                }
                 // Optional: Backtrace
                 // try { console.log("[IDAFrida] Backtrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + "\n"); } catch(e){}
            },
            onLeave: function(retval) {
                // Optional: Log destination buffer after copy if desired (be careful with size)
                // try { console.log(`  dest after: "${this.dest.readCString(256)}"`); } catch(e){}
                // @ts-ignore
                console.log(`  => returns ${retval} (dest)`);
            }
        });
        console.log("[IDAFrida] Interceptor attached to strcpy.");
    } catch (error) {
         // @ts-ignore
         console.error(`[IDAFrida] Failed to attach to strcpy: ${error.message}`);
    }
})();
"""

libc_memcpy_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: memcpy
(function () {
    console.log("[IDAFrida] Script loaded to trace memcpy");
    try {
        // @ts-ignore
        Interceptor.attach(Module.findExportByName(null, "memcpy"), {
            onEnter: function(args) {
                // @ts-ignore
                this.dest = args[0];
                // @ts-ignore
                this.src = args[1];
                // @ts-ignore
                this.n = args[2].toInt32(); // Or .toString() if size can be large
                // @ts-ignore
                console.log(`[IDAFrida] memcpy(dest=${this.dest}, src=${this.src}, n=${this.n})`);
                // Optional: Dump source buffer if n is reasonable
                if (this.n > 0 && this.n <= 64) {
                    try { // @ts-ignore
                        console.log("  src data:\n" + hexdump(this.src, { length: this.n }));
                    } catch(e){}
                }
                 // Optional: Backtrace
                 // try { console.log("[IDAFrida] Backtrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + "\n"); } catch(e){}
            },
            onLeave: function(retval) {
                 // Optional: Dump dest buffer after copy if n is reasonable
                 if (this.n > 0 && this.n <= 64) {
                    try { // @ts-ignore
                        console.log("  dest data after:\n" + hexdump(this.dest, { length: this.n }));
                    } catch(e){}
                 }
                // @ts-ignore
                console.log(`  => returns ${retval} (dest)`);
            }
        });
        console.log("[IDAFrida] Interceptor attached to memcpy.");
    } catch (error) {
        // @ts-ignore
        console.error(`[IDAFrida] Failed to attach to memcpy: ${error.message}`);
    }
})();
"""

libc_strcmp_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: strcmp
(function () {
    console.log("[IDAFrida] Script loaded to trace strcmp");
    try {
        // @ts-ignore
        Interceptor.attach(Module.findExportByName(null, "strcmp"), {
            onEnter: function(args) {
                // @ts-ignore
                this.s1Ptr = args[0];
                // @ts-ignore
                this.s2Ptr = args[1];
                try {
                    // @ts-ignore
                    this.s1Str = this.s1Ptr.readCString(256);
                    // @ts-ignore
                    this.s2Str = this.s2Ptr.readCString(256);
                    // @ts-ignore
                    console.log(`[IDAFrida] strcmp(s1="${this.s1Str}", s2="${this.s2Str}")`);
                } catch (e) {
                    // @ts-ignore
                    console.log(`[IDAFrida] strcmp(s1=${this.s1Ptr}, s2=${this.s2Ptr}) - Error reading strings: ${e.message}`);
                }
            },
            onLeave: function(retval) {
                // @ts-ignore
                console.log(`  => returns ${retval.toInt32()}`); // Result is int
            }
        });
        console.log("[IDAFrida] Interceptor attached to strcmp.");
    } catch (error) {
        // @ts-ignore
        console.error(`[IDAFrida] Failed to attach to strcmp: ${error.message}`);
    }
})();
"""

libc_malloc_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: malloc
(function () {
    console.log("[IDAFrida] Script loaded to trace malloc");
    try {
        // @ts-ignore
        Interceptor.attach(Module.findExportByName(null, "malloc"), {
            onEnter: function(args) {
                // @ts-ignore
                this.size = args[0].toInt32(); // Or toString()
                // @ts-ignore
                console.log(`[IDAFrida] malloc(size=${this.size})`);
                 // Optional: Backtrace
                 // try { console.log("[IDAFrida] Backtrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + "\n"); } catch(e){}
            },
            onLeave: function(retval) {
                // @ts-ignore
                console.log(`  => returns ptr: ${retval}`);
            }
        });
        console.log("[IDAFrida] Interceptor attached to malloc.");
    } catch (error) {
        // @ts-ignore
        console.error(`[IDAFrida] Failed to attach to malloc: ${error.message}`);
    }
})();
"""

libc_free_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: free
(function () {
    console.log("[IDAFrida] Script loaded to trace free");
    try {
        // @ts-ignore
        Interceptor.attach(Module.findExportByName(null, "free"), {
            onEnter: function(args) {
                // @ts-ignore
                this.ptr = args[0];
                // @ts-ignore
                console.log(`[IDAFrida] free(ptr=${this.ptr})`);
                 // Optional: Backtrace
                 // try { console.log("[IDAFrida] Backtrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + "\n"); } catch(e){}
                 // Optional: Dump memory before free if ptr is valid
                 // if (!this.ptr.isNull()) { try { console.log("  Data before free:\n" + hexdump(this.ptr)); } catch(e){} }
            },
            onLeave: function(retval) {
                // free returns void, nothing to log for retval
            }
        });
        console.log("[IDAFrida] Interceptor attached to free.");
    } catch (error) {
        // @ts-ignore
        console.error(`[IDAFrida] Failed to attach to free: ${error.message}`);
    }
})();
"""

libc_open_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: open / open64
(function () {
    console.log("[IDAFrida] Script loaded to trace open/open64");
    // @ts-ignore
    function hook_open(funcName) {
        try {
            // @ts-ignore
            Interceptor.attach(Module.findExportByName(null, funcName), {
                onEnter: function(args) {
                    // @ts-ignore
                    this.pathnamePtr = args[0];
                    // @ts-ignore
                    this.flags = args[1].toInt32(); // flags are int
                    // mode is optional (usually 3rd arg if O_CREAT is set)
                    this.mode = (args.length > 2) ? args[2].toInt32() : null;
                    try {
                        // @ts-ignore
                        this.pathnameStr = this.pathnamePtr.readCString();
                        // @ts-ignore // Add more flag decoding if needed
                        console.log(`[IDAFrida] ${funcName}(pathname="${this.pathnameStr}", flags=0x${this.flags.toString(16)}${this.mode !== null ? `, mode=0${this.mode.toString(8)}` : ''})`);
                    } catch (e) {
                        // @ts-ignore
                        console.log(`[IDAFrida] ${funcName}(pathname=${this.pathnamePtr}, flags=0x${this.flags.toString(16)}${this.mode !== null ? `, mode=0${this.mode.toString(8)}` : ''}) - Error reading path: ${e.message}`);
                    }
                },
                onLeave: function(retval) {
                    // @ts-ignore
                    console.log(`  => returns fd: ${retval.toInt32()}`); // fd is int
                }
            });
            console.log(`[IDAFrida] Interceptor attached to ${funcName}.`);
        } catch (error) {
             // @ts-ignore // Log error but don't stop script if one fails
             console.warn(`[IDAFrida] Failed to attach to ${funcName}: ${error.message}`);
        }
    }
    hook_open("open");
    hook_open("open64"); // Hook both common variants
})();
"""

libc_read_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: read
(function () {
    console.log("[IDAFrida] Script loaded to trace read");
    try {
        // @ts-ignore
        Interceptor.attach(Module.findExportByName(null, "read"), {
            onEnter: function(args) {
                // @ts-ignore
                this.fd = args[0].toInt32();
                // @ts-ignore
                this.buf = args[1];
                // @ts-ignore
                this.count = args[2].toInt32(); // Or toString()
                // @ts-ignore
                console.log(`[IDAFrida] read(fd=${this.fd}, buf=${this.buf}, count=${this.count})`);
            },
            onLeave: function(retval) {
                // @ts-ignore
                const bytesRead = retval.toInt32();
                // @ts-ignore
                console.log(`  => returns bytesRead: ${bytesRead}`);
                // Optional: Dump buffer if bytesRead > 0 and count is reasonable
                if (bytesRead > 0 && this.count <= 256) {
                     try { // @ts-ignore
                         console.log("  Buffer data:\n" + hexdump(this.buf, { length: bytesRead }));
                     } catch(e){}
                }
            }
        });
        console.log("[IDAFrida] Interceptor attached to read.");
    } catch (error) {
        // @ts-ignore
        console.error(`[IDAFrida] Failed to attach to read: ${error.message}`);
    }
})();
"""

libc_write_template = r"""
// Frida Hook Script generated by IDAFrida (Libc Tracer)
// Target: Trace libc function: write
(function () {
    console.log("[IDAFrida] Script loaded to trace write");
    try {
        // @ts-ignore
        Interceptor.attach(Module.findExportByName(null, "write"), {
            onEnter: function(args) {
                // @ts-ignore
                this.fd = args[0].toInt32();
                // @ts-ignore
                this.buf = args[1];
                // @ts-ignore
                this.count = args[2].toInt32(); // Or toString()
                // @ts-ignore
                console.log(`[IDAFrida] write(fd=${this.fd}, buf=${this.buf}, count=${this.count})`);
                 // Optional: Dump buffer being written if count is reasonable
                if (this.count > 0 && this.count <= 256) {
                     try { // @ts-ignore
                         console.log("  Buffer data:\n" + hexdump(this.buf, { length: this.count }));
                     } catch(e){}
                }
                 // Optional: Backtrace
                 // try { console.log("[IDAFrida] Backtrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + "\n"); } catch(e){}
            },
            onLeave: function(retval) {
                // @ts-ignore
                console.log(`  => returns bytesWritten: ${retval.toInt32()}`);
            }
        });
        console.log("[IDAFrida] Interceptor attached to write.");
    } catch (error) {
        // @ts-ignore
        console.error(`[IDAFrida] Failed to attach to write: ${error.message}`);
    }
})();
"""


# --- Tier 3 Templates ---
modifiable_func_hook_template = r"""
// Frida Hook Script generated by IDAFrida (Modifiable Function Hook)
// Target: Function [funcname] in module [filename] at IDA offset [offset]
// Platform: Linux

(function () {
    console.log("[IDAFrida] Script loaded for modifiable hook on: [filename]->[funcname]");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[offset]"); // Offset relative to IDA's imagebase

    // --- Helper Functions ---
    function formatArgument(addr) {
        try {
            // @ts-ignore
            if (addr != null && !addr.isNull() && Process.findRangeByAddress(addr)) {
                 // @ts-ignore
                 return addr + " (ptr)";
            }
            // @ts-ignore
            return addr.toString();
        } catch (e) {
            // @ts-ignore
            return addr + " (error: " + e.message + ")";
        }
     }

    /**
     * Performs the actual hooking logic once the module base is known.
     */
    function hookImplementation(moduleBase) {
        // @ts-ignore
        const targetAddress = moduleBase.add(TARGET_OFFSET);
        // @ts-ignore
        const relativeOffset = targetAddress.sub(moduleBase);

        console.log(`[IDAFrida] Attempting to hook [funcname] at address ${targetAddress} (offset ${relativeOffset} from ${moduleBase})`);

        try {
            Interceptor.attach(targetAddress, {
                onEnter: function (args) {
                    this.log = [`[IDAFrida] ENTER [funcname] @ ${targetAddress} (offset ${relativeOffset})`];
                    this.params = [];
                    const numArgs = parseInt("[nargs]", 10);

                    for (let i = 0; i < numArgs; i++) {
                        this.params.push(args[i]);
                        // @ts-ignore
                        this.log.push(`  arg[${i}]: ${formatArgument(args[i])}`);
                    }
                    console.log(this.log.join('\n'));

                    // --- Modify Arguments (Example) ---
                    /*
                    if (numArgs > 0) {
                        // Example: Change the first argument to 1 if it's a pointer/number
                        try {
                            // @ts-ignore
                            var originalArg0 = args[0];
                            // @ts-ignore
                            args[0] = ptr("0x1"); // Or new NativePointer("1"), or just 1 for integer types
                            console.log(`[IDAFrida] Modified arg[0] from ${originalArg0} to ${args[0]}`);
                        } catch (modError) {
                            console.error(`[IDAFrida] Error modifying arg[0]: ${modError.message}`);
                        }
                    }
                    */
                    // --- End Modify Arguments ---

                },
                onLeave: function (retval) {
                    const log = [`[IDAFrida] LEAVE [funcname] @ ${targetAddress} (offset ${relativeOffset})`];
                    // @ts-ignore
                    log.push(`  retval (original): ${formatArgument(retval)}`);


                    // --- Modify Return Value (Example) ---
                    /*
                    try {
                        // Example: Force return value to 0
                        // @ts-ignore
                        var originalRetval = retval;
                        // @ts-ignore // Use replace() for NativePointer results
                        retval.replace(ptr("0x0")); // Or just 0 for integer types
                        console.log(`[IDAFrida] Replaced retval from ${originalRetval} to ${retval}`);
                    } catch (modError) {
                         console.error(`[IDAFrida] Error replacing retval: ${modError.message}`);
                    }
                    */
                    // --- End Modify Return Value ---

                    console.log(log.join('\n')); // Log original retval before potential modification is logged
                }
            });
            console.log(`[IDAFrida] Successfully hooked [funcname] at ${targetAddress}`);
        } catch (error) {
            // @ts-ignore
            console.error(`[IDAFrida] Failed to hook [funcname] at ${targetAddress}: ${error.message}`);
            // @ts-ignore
            console.error(error.stack);
        }
    }

    /**
     * Waits for the target library to be loaded if it isn't already.
     */
    function ensureModuleLoadedAndHook() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            console.log(`[IDAFrida] Module ${MODULE_NAME} already loaded at ${module.base}. Hooking now.`);
            hookImplementation(module.base);
            return; // Module found, no need to wait
        }

        // Module not loaded yet, wait for dlopen
        console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
        // @ts-ignore
        const dlopenInterceptor = Interceptor.attach(
            // @ts-ignore
            Module.findExportByName(null, "dlopen"), { // Use standard dlopen for Linux
            onEnter: function(args) {
                // @ts-ignore
                const libraryPath = args[0].readCString();
                if (libraryPath && libraryPath.includes(MODULE_NAME)) {
                    this.libraryFound = true;
                    console.log(`[IDAFrida] dlopen called for: ${libraryPath}`);
                }
            },
            onLeave: function(retval) {
                // @ts-ignore
                if (this.libraryFound && !retval.isNull()) {
                    console.log(`[IDAFrida] Module ${MODULE_NAME} loaded via dlopen.`);
                    // @ts-ignore
                    const loadedModule = Process.findModuleByName(MODULE_NAME);
                    if (loadedModule) {
                        hookImplementation(loadedModule.base);
                        dlopenInterceptor.detach(); // Stop listening once hooked
                    } else {
                         console.error(`[IDAFrida] Failed to find module ${MODULE_NAME} immediately after dlopen returned.`);
                    }
                }
                this.libraryFound = false; // Reset for next call
            }
        });
     }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(ensureModuleLoadedAndHook);

})();
"""

memory_scan_template = r"""
// Frida Hook Script generated by IDAFrida (Memory Scan)
// Target: Scan memory for pattern '[pattern]'
// Scope: [scope]

(function () {
    console.log("[IDAFrida] Script loaded to scan memory.");

    // @ts-ignore
    const pattern = "[pattern]"; // User input pattern (e.g., "48 89 5C 24 08" or string)
    // @ts-ignore
    const moduleName = "[moduleName]"; // Target module or null/empty for all
    // @ts-ignore
    const protection = '[protection]'; // Memory protection filter (e.g., 'r-x', 'rw-')
    // @ts-ignore
    var matchCount = 0;

    console.log(`[IDAFrida] Scanning for pattern: ${pattern}`);
    console.log(`[IDAFrida] Scope: ${moduleName && moduleName !== "null" ? moduleName : 'All Process Memory'}, Protection: ${protection}`);

    /**
     * Performs the memory scan.
     */
    function performScan() {
        // @ts-ignore
        var targetModule = (moduleName && moduleName !== "null") ? Process.findModuleByName(moduleName) : null;

        if (targetModule) {
            console.log(`[IDAFrida] Scanning module ${moduleName} (${targetModule.base} - ${targetModule.base.add(targetModule.size)})`);
            // @ts-ignore
            Memory.scan(targetModule.base, targetModule.size, pattern, {
                onMatch: function(address, size) {
                    matchCount++;
                    // @ts-ignore
                    console.log(`  Match #${matchCount} found at: ${address} (offset ${address.sub(targetModule.base)})`);
                    // Optional: console.log(hexdump(address, { length: 16 }));
                },
                onError: function(reason) {
                    console.error(`[IDAFrida] Error during scan in ${moduleName}: ${reason}`);
                },
                onComplete: function() {
                    console.log(`[IDAFrida] Scan complete for module ${moduleName}. Found ${matchCount} matches.`);
                }
            });
        } else {
             console.log(`[IDAFrida] Scanning all process memory ranges with protection '${protection}'...`);
             // @ts-ignore
             Process.enumerateRanges(protection).forEach(function (range) {
                try {
                    // @ts-ignore
                    Memory.scan(range.base, range.size, pattern, {
                         onMatch: function(address, size) {
                             matchCount++;
                             // @ts-ignore
                             console.log(`  Match #${matchCount} found at: ${address} in range ${range.base}-${range.base.add(range.size)} (${range.protection})`);
                             // Optional: console.log(hexdump(address, { length: 16 }));
                         },
                         onError: function(reason) {
                             // Ignore errors in potentially inaccessible sub-regions
                         },
                         onComplete: function() { } // Completion per range
                    });
                } catch (e) {
                    // Ignore errors scanning entire ranges (e.g., permission denied)
                    // console.warn(`[IDAFrida] Warning scanning range ${range.base}: ${e.message}`);
                }
             });
             console.log(`[IDAFrida] Scan complete for all matching ranges. Found ${matchCount} total matches.`);
        }
    }

    // --- Main Execution ---
    // Use timeout to allow potential module loading if scanning a specific module
    // @ts-ignore
    setTimeout(performScan, 500); // Delay slightly

})();
"""

conditional_func_hook_template = r"""
// Frida Hook Script generated by IDAFrida (Conditional Function Hook)
// Target: Function [funcname] in module [filename] at IDA offset [offset]
// Platform: Linux

(function () {
    console.log("[IDAFrida] Script loaded for conditional hook on: [filename]->[funcname]");

    const MODULE_NAME = "[filename]";
    const TARGET_OFFSET = ptr("[offset]"); // Offset relative to IDA's imagebase

    // --- Helper Functions ---
    function formatArgument(addr) {
        try {
            // @ts-ignore
            if (addr != null && !addr.isNull() && Process.findRangeByAddress(addr)) {
                 // @ts-ignore
                 return addr + " (ptr)";
            }
            // @ts-ignore
            return addr.toString();
        } catch (e) {
            // @ts-ignore
            return addr + " (error: " + e.message + ")";
        }
     }

    /**
     * Performs the actual hooking logic once the module base is known.
     */
    function hookImplementation(moduleBase) {
        // @ts-ignore
        const targetAddress = moduleBase.add(TARGET_OFFSET);
        // @ts-ignore
        const relativeOffset = targetAddress.sub(moduleBase);

        console.log(`[IDAFrida] Attempting to hook [funcname] at address ${targetAddress} (offset ${relativeOffset} from ${moduleBase})`);

        try {
            Interceptor.attach(targetAddress, {
                onEnter: function (args) {
                    const numArgs = parseInt("[nargs]", 10);
                    var conditionMet = false; // Default to false
                    this.shouldLogLeave = false; // Flag for onLeave

                    // --- Condition Logic (Example) ---
                    // Modify this condition based on your needs!
                    try {
                        if (numArgs > 0) {
                            // Example: Condition met if first argument is non-null/non-zero
                            // @ts-ignore
                            conditionMet = !args[0].isNull();
                            // Example: Condition met if first argument equals a specific value
                            // conditionMet = args[0].equals(ptr("0x1337"));
                            // Example: Condition met if first argument points to specific string
                            // conditionMet = args[0].readCString().startsWith("TARGET");
                        } else {
                            // No arguments, maybe condition is always true?
                            conditionMet = true;
                        }
                    } catch (condError) {
                         // @ts-ignore
                         console.error(`[IDAFrida] Error evaluating condition: ${condError.message}`);
                         conditionMet = false; // Fail safe
                    }
                    // --- End Condition Logic ---


                    // Execute hook logic only if condition is met
                    if (conditionMet) {
                        this.shouldLogLeave = true; // Set flag to log onLeave as well
                        this.log = [`[IDAFrida] ENTER [funcname] @ ${targetAddress} (offset ${relativeOffset}) - Condition Met`];
                        this.params = [];

                        for (let i = 0; i < numArgs; i++) {
                            this.params.push(args[i]);
                            // @ts-ignore
                            this.log.push(`  arg[${i}]: ${formatArgument(args[i])}`);
                        }
                        console.log(this.log.join('\n'));

                        // Optional: Add backtrace only when condition met
                        // try { console.log("[IDAFrida] Backtrace:\n" + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + "\n"); } catch(e){}

                    } else {
                        // Optional: Log that the hook was hit but condition wasn't met
                        // console.log(`[IDAFrida] ENTER [funcname] @ ${targetAddress} - Condition NOT Met`);
                    }
                },
                onLeave: function (retval) {
                    // Only log if the condition was met in onEnter
                    if (this.shouldLogLeave) {
                        const log = [`[IDAFrida] LEAVE [funcname] @ ${targetAddress} (offset ${relativeOffset}) - Condition Met`];
                        // @ts-ignore
                        log.push(`  retval: ${formatArgument(retval)}`);
                        console.log(log.join('\n'));
                    }
                }
            });
            console.log(`[IDAFrida] Successfully hooked [funcname] at ${targetAddress}`);
        } catch (error) {
            // @ts-ignore
            console.error(`[IDAFrida] Failed to hook [funcname] at ${targetAddress}: ${error.message}`);
            // @ts-ignore
            console.error(error.stack);
        }
    }

    /**
     * Waits for the target library to be loaded if it isn't already.
     */
    function ensureModuleLoadedAndHook() {
        // @ts-ignore
        let module = Process.findModuleByName(MODULE_NAME);
        if (module) {
            console.log(`[IDAFrida] Module ${MODULE_NAME} already loaded at ${module.base}. Hooking now.`);
            hookImplementation(module.base);
            return; // Module found, no need to wait
        }

        // Module not loaded yet, wait for dlopen
        console.log(`[IDAFrida] Module ${MODULE_NAME} not found. Waiting for dlopen()...`);
        // @ts-ignore
        const dlopenInterceptor = Interceptor.attach(
            // @ts-ignore
            Module.findExportByName(null, "dlopen"), { // Use standard dlopen for Linux
            onEnter: function(args) {
                // @ts-ignore
                const libraryPath = args[0].readCString();
                if (libraryPath && libraryPath.includes(MODULE_NAME)) {
                    this.libraryFound = true;
                    console.log(`[IDAFrida] dlopen called for: ${libraryPath}`);
                }
            },
            onLeave: function(retval) {
                // @ts-ignore
                if (this.libraryFound && !retval.isNull()) {
                    console.log(`[IDAFrida] Module ${MODULE_NAME} loaded via dlopen.`);
                    // @ts-ignore
                    const loadedModule = Process.findModuleByName(MODULE_NAME);
                    if (loadedModule) {
                        hookImplementation(loadedModule.base);
                        dlopenInterceptor.detach(); // Stop listening once hooked
                    } else {
                         console.error(`[IDAFrida] Failed to find module ${MODULE_NAME} immediately after dlopen returned.`);
                    }
                }
                this.libraryFound = false; // Reset for next call
            }
        });
     }

    // --- Main Execution ---
    // @ts-ignore
    setImmediate(ensureModuleLoadedAndHook);

})();
"""


############################################################################
# Configuration Management (Using NetNode)
############################################################################

class Configuration:
    """Handles loading and storing IDAFrida plugin configuration via NetNode."""
    # Default values
    DEFAULT_FRIDA_CMD = """frida -U --attach-name="TARGET_APP_NAME" -l IDAhook.js --no-pause"""
    DEFAULT_TEMPLATE_FUNC = default_func_hook_template
    DEFAULT_TEMPLATE_ADDRESS = default_address_hook_template
    # Add defaults for other templates if they become configurable

    def __init__(self) -> None:
            self.node = ida_netnode.netnode() # Start with an invalid node reference
            created_new = False

            # --- REVISED LOGIC ---
            # 1. Try to find the node by name without creating it first.
            try:
                # Use the constructor: netnode(name, len=0, do_create=False)
                find_node = ida_netnode.netnode(CONFIG_NODE_NAME, 0, False)

                # Check if the constructor returned a valid node ID
                if find_node.index() != ida_netnode.BADNODE:
                    # Node found! Assign it to self.node
                    self.node = find_node
                    log_info(f"Found existing configuration netnode '{CONFIG_NODE_NAME}'.")
                else:
                    # Node not found, so we need to create it.
                    # Use the initially created (invalid) self.node object for creation.
                    log_info(f"Configuration netnode '{CONFIG_NODE_NAME}' not found. Attempting creation...")
                    if not self.node.create(CONFIG_NODE_NAME):
                        # This could happen if there's a race condition or unexpected issue
                        log_error(f"Failed to create configuration netnode '{CONFIG_NODE_NAME}' even after failing to find it.")
                        self.node = None # Indicate failure
                    else:
                        log_info(f"Successfully created new configuration netnode '{CONFIG_NODE_NAME}'.")
                        created_new = True # Mark that we created it

            except Exception as e:
                 log_error(f"Exception during netnode lookup/creation for '{CONFIG_NODE_NAME}'", e)
                 self.node = None
            # --- END REVISED LOGIC ---

            # Check if node initialization succeeded
            if self.node is None:
                log_error("Failed to initialize configuration netnode. Configuration will not persist.")
                # Optionally, load defaults anyway but warn the user
                self._load_defaults()
                log_warn("Using default configuration as persistence failed.")
                return # Stop further processing if node is None

            # Node object (self.node) should now refer to the correct node (either found or created)
            self._load_defaults()
            if not created_new:
                # Only load from storage if we didn't just create the node
                self.load()
            else:
                # Optional: Save defaults immediately if the node was newly created
                log_info("Saving default configuration to newly created netnode.")
                self.store()

    def _load_defaults(self):
        self.frida_cmd = self.DEFAULT_FRIDA_CMD
        self.template_func = self.DEFAULT_TEMPLATE_FUNC
        self.template_address = self.DEFAULT_TEMPLATE_ADDRESS
        # Add other templates here

    def _get_config_json(self) -> dict | None:
        """Reads the JSON config string from the netnode."""
        if not self.node: return None
        try:
            # IDA 9.0: Use get_bytes instead of get_blob
            config_bytes = self.node.getblob(0, CONFIG_TAG)
            if config_bytes:
                return json.loads(config_bytes.decode('utf-8'))
            return None # No config stored yet or empty blob
        except Exception as e:
            # Catch potential exceptions if tag doesn't exist or data is invalid
            # Check specific exception type if available, otherwise check string
            if "SNET_NOT_FOUND" in str(e): # Check if the error is specifically about the tag not found
                 log_info(f"Configuration tag '{CONFIG_TAG}' not found in netnode '{CONFIG_NODE_NAME}'.")
            else:
                 log_error("Failed to read config bytes from netnode", e)
            return None

    def _set_config_json(self, data: dict) -> bool:
        """Writes the JSON config string to the netnode."""
        if not self.node: return False
        try:
            json_str = json.dumps(data, indent=4)
            # IDA 9.0: Use set_bytes instead of set_blob
            # Delete existing data first to avoid issues if new data is smaller
            self.node.delblob(0, CONFIG_TAG) # Use del_bytes
            return self.node.setblob(json_str.encode('utf-8'), 0, CONFIG_TAG) # Use set_bytes
        except Exception as e:
            log_error("Failed to write config bytes to netnode", e)
            return False

    def load(self):
        """Loads configuration from the netnode."""
        if not self.node:
            log_warn("Configuration node not available, using defaults.")
            return

        data = self._get_config_json()
        if data:
            self.frida_cmd = data.get("frida_cmd", self.DEFAULT_FRIDA_CMD)
            self.template_func = data.get("template_func", self.DEFAULT_TEMPLATE_FUNC)
            self.template_address = data.get("template_address", self.DEFAULT_TEMPLATE_ADDRESS)
            # Load other templates if added
            log_info("Configuration loaded from IDB netnode.")
        else:
            log_info("No configuration found in IDB netnode, using defaults.")
            # Optionally save defaults here if desired: self.store()

    def store(self):
        """Saves the current configuration to the netnode."""
        if not self.node:
            log_warn("Configuration node not available, cannot save.")
            return

        data = {
            "frida_cmd": self.frida_cmd,
            "template_func": self.template_func,
            "template_address": self.template_address,
            # Add other templates here
        }
        if self._set_config_json(data):
            log_info("Configuration saved to IDB netnode.")
        else:
            log_error("Failed to save configuration to IDB netnode.")

    def set_frida_cmd(self, s: str):
        self.frida_cmd = s
        self.store()

    def set_template_func(self, s: str):
        self.template_func = s
        self.store()

    def set_template_address(self, s: str):
        self.template_address = s
        self.store()

    def reset(self):
        """Resets configuration to defaults and saves."""
        self._load_defaults()
        self.store()
        log_info("Configuration reset to defaults and saved.")


# Global configuration instance - initialized in plugin init()
global_config = None


############################################################################
# UI Dialogs (Leveraging PyQt if available)
############################################################################

# --- Base Template Editor Dialog ---
class BaseTemplateConfigurationUI(QDialog if HAS_PYQT else object):
    def __init__(self, conf: Configuration, template_attr: str, setter_method) -> None:
        if not HAS_PYQT:
            log_error("PyQt5 not found, cannot display template editor UI.")
            ida_kernwin.warning("PyQt5 is required for the template editor.")
            return
        super().__init__() # Initialize QDialog

        if conf is None:
            log_error("Configuration object not available for UI.")
            ida_kernwin.warning("Configuration error. Cannot open template editor.")
            self.close()
            return

        self.conf = conf
        self.template_attr = template_attr
        self.setter_method = setter_method

        self.setWindowTitle(f"Edit {template_attr.replace('_', ' ').title()}")
        self.setMinimumSize(700, 600) # Set minimum size

        self.edit_template = QTextEdit()
        self.edit_template.setPlainText(getattr(self.conf, self.template_attr))
        self.edit_template.setLineWrapMode(QTextEdit.NoWrap) # Disable line wrap for code

        # Use a monospace font
        font = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
        self.edit_template.setFont(font)

        layout = QVBoxLayout()
        layout.addWidget(QLabel("Edit the Frida JavaScript template below:"))
        layout.addWidget(self.edit_template)

        btn_box = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel | QDialogButtonBox.Reset)
        btn_box.button(QDialogButtonBox.Reset).setText("Reset to Default")
        btn_box.accepted.connect(self.accept) # Connected to Save
        btn_box.rejected.connect(self.reject) # Connected to Cancel
        btn_box.button(QDialogButtonBox.Reset).clicked.connect(self.reset_template)
        layout.addWidget(btn_box)

        self.setLayout(layout)

    def reset_template(self):
        default_value = getattr(self.conf, f"DEFAULT_{self.template_attr.upper()}", "")
        if default_value:
            self.edit_template.setPlainText(default_value)
            log_info(f"Template '{self.template_attr}' reset to default in editor.")
        else:
            log_warn(f"Could not find default value for template '{self.template_attr}'.")

    def accept(self): # Corresponds to "Save" button
        if self.conf and self.setter_method:
            new_template = self.edit_template.toPlainText()
            self.setter_method(new_template) # Calls conf.set_... which includes store()
            log_info(f"Template '{self.template_attr}' updated and saved.")
        super().accept() # Close dialog with QDialog.Accepted

# --- Specific Template Editors ---
class FuncConfigurationUI(BaseTemplateConfigurationUI):
    def __init__(self, conf: Configuration) -> None:
        super().__init__(conf, "template_func", conf.set_template_func if conf else None)

class AddressConfigurationUI(BaseTemplateConfigurationUI):
    def __init__(self, conf: Configuration) -> None:
        super().__init__(conf, "template_address", conf.set_template_address if conf else None)

# --- Input Registers Dialog ---
class InputRegistersUI(QDialog if HAS_PYQT else object):
    def __init__(self) -> None:
        if not HAS_PYQT:
            log_error("PyQt5 not found, cannot display input registers UI.")
            ida_kernwin.warning("PyQt5 is required for the input registers dialog.")
            self.registers_text = None # Indicate failure
            return
        super().__init__()
        self.setWindowTitle("Input Registers for Address Hook")
        self.setMinimumWidth(400)

        self.registers_text = "" # To store the result

        layout = QVBoxLayout()
        layout.addWidget(QLabel("Enter registers to log (space separated):"))
        self.edit_registers = QLineEdit()
        self.edit_registers.setPlaceholderText("e.g., x0 x1 x2 rsp pc (or leave blank)")
        layout.addWidget(self.edit_registers)

        btn_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btn_box.accepted.connect(self.accept)
        btn_box.rejected.connect(self.reject)
        layout.addWidget(btn_box)
        self.setLayout(layout)

    def accept(self):
        self.registers_text = self.edit_registers.text().strip()
        super().accept()

    @staticmethod
    def get_registers() -> str | None:
        """Shows the dialog and returns the entered registers or None if cancelled/failed."""
        ui = InputRegistersUI()
        if not HAS_PYQT and ui.registers_text is None: # Check if init failed
             return None # Indicate UI couldn't be shown

        result = ui.exec_()
        if result == QDialog.Accepted:
            return ui.registers_text
        return None


############################################################################
# Script Generation Logic (IDA 9.0 Ported)
############################################################################

class ScriptGenerator:
    """Generates Frida hook scripts based on templates and IDA info."""
    def __init__(self, configuration: Configuration) -> None:
        if configuration is None:
             raise ValueError("ScriptGenerator requires a valid Configuration object.")
        self.conf = configuration
        self.imagebase = ida_nalt.get_imagebase()
        # More robust 64-bit check using ida_idp module
        self.is_64bit = ida_idp.ph_get_flag() & ida_idp.PR_USE64
        self.til = ida_typeinf.get_idati() # Get local type library

    @staticmethod
    def get_idb_filename():
        """Gets the base name of the current IDB file."""
        try:
            path = ida_nalt.get_input_file_path()
            return os.path.basename(path) if path else "unknown_file"
        except Exception:
            return "unknown_file"

    @staticmethod
    def get_idb_path():
        """Gets the directory containing the current IDB file."""
        try:
            path = ida_nalt.get_input_file_path()
            idb_dir = os.path.dirname(path) if path else None
            if idb_dir and os.path.isdir(idb_dir):
                return idb_dir
            else:
                # Fallback to user directory if IDB path is invalid/missing
                user_dir = ida_diskio.get_user_idadir()
                log_warn(f"Could not determine valid IDB directory. Using user directory: {user_dir}")
                return user_dir
        except Exception as e:
            log_error("Error getting IDB path", e)
            return ida_diskio.get_user_idadir() # Fallback

    def get_function_name(self, ea):
        """Gets the best available name for a function or address."""
        try:
            # Try demangled function name first
            func_name = idc.get_func_name(ea)
            if func_name:
                # Use new ida_ida accessors for demangling flags
                long_flags = ida_ida.inf_get_long_demnames()
                short_flags = ida_ida.inf_get_short_demnames()
                demangled = idc.demangle_name(func_name, long_flags)
                if not demangled: # Fallback to short names if long fails
                    demangled = idc.demangle_name(func_name, short_flags)

                if demangled:
                    # Basic C++ name cleanup (remove args/template params) - adjust if needed
                    clean_name = re.sub(r'\(.*\)', '', demangled)
                    clean_name = re.sub(r'<.*>', '', clean_name)
                    # Remove common prefixes/suffixes if desired
                    # clean_name = clean_name.replace("std::", "")
                    return clean_name.strip() or f"func_{ea:X}"

            # Fallback to regular name at EA
            name = idc.get_name(ea, ida_name.GN_VISIBLE)
            if name and not name.startswith("loc_") and not name.startswith("sub_"):
                return name

            # Fallback to function name if inside one
            if func_name: return func_name

            # Fallback to auto-generated name
            return f"addr_{ea:X}"

        except Exception as e:
             log_error(f"Error getting function/address name for {ea:#x}", e)
             return f"error_{ea:X}"

    def _generate_stub(self, template: str, repdata: dict) -> str:
        """Helper to replace placeholders in a template string."""
        s = template
        try:
            for key, v in repdata.items():
                # Ensure keys are simple strings for replacement
                clean_key = re.sub(r'\W|^(?=\d)', '_', key) # Basic sanitization for key
                s = s.replace(f"[{clean_key}]", str(v)) # Ensure value is string
        except Exception as e:
             log_error(f"Error replacing placeholders in template: {e}")
             return f"// Error generating script stub: {e}"
        # Check for leftover placeholders
        leftovers = re.findall(r'\[([a-zA-Z0-9_]+)\]', s)
        if leftovers:
            log_warn(f"Unreplaced placeholders found in template: {leftovers}")
        return s

    # --- Type Mapping Helpers (More Robust - IDA 9.0 Corrected) ---
    def _map_ida_tif_to_frida(self, tif: ida_typeinf.tinfo_t) -> str:
        """Maps IDA tinfo_t to Frida NativeFunction type strings."""
        if not tif: return 'pointer'
        # Create a copy to avoid modifying original tinfo
        tif_copy = ida_typeinf.tinfo_t(tif)
        tif_copy.clr_const() # Ignore const/volatile qualifiers

        # Basic types - Check specific types first
        if tif_copy.is_void(): return 'void'
        if tif_copy.is_bool(): return 'bool'
        if tif_copy.is_char(): return 'char'     # Usually signed char
        if tif_copy.is_uchar(): return 'uchar'   # Unsigned char
        if tif_copy.is_int16(): return 'int16'   # Signed short
        if tif_copy.is_uint16(): return 'uint16' # Unsigned short
        if tif_copy.is_int32(): return 'int32'   # Signed int (usually 32-bit)
        if tif_copy.is_uint32(): return 'uint32' # Unsigned int (usually 32-bit)
        if tif_copy.is_int64(): return 'int64'   # Signed 64-bit
        if tif_copy.is_uint64(): return 'uint64' # Unsigned 64-bit
        # Add 128-bit if Frida supports it, otherwise map to pointer or error
        if tif_copy.is_int128():
            log_warn("Frida does not directly support int128; mapping to 'pointer'.")
            return 'pointer'
        if tif_copy.is_uint128():
            log_warn("Frida does not directly support uint128; mapping to 'pointer'.")
            return 'pointer'
        # Note: is_long() / is_ulong() might be 32 or 64 bit depending on model.
        # We prioritize the more specific checks (is_int32/is_int64) above.

        # Floating point types
        if tif_copy.is_float(): return 'float'
        if tif_copy.is_double(): return 'double'
        # No direct is_longdouble(), check size if needed, map to double for Frida
        if tif_copy.is_floating(): # Check if it's any float type we missed
             tsize = tif_copy.get_size()
             if tsize == ida_typeinf.BADSIZE: return 'double' # Guess double if size unknown
             # Assuming long double is > 8 bytes (adjust if needed for specific ABI)
             # Map long double to Frida's double
             return 'double'

        # Pointers and Arrays
        if tif_copy.is_ptr_or_array():
            return 'pointer'

        # Enums are typically integers
        if tif_copy.is_enum():
            enum_size = tif_copy.get_size()
            if enum_size == 1: return 'uint8' # Assume unsigned for enums
            if enum_size == 2: return 'uint16'
            if enum_size == 4: return 'uint32'
            if enum_size == 8: return 'uint64'
            return 'int' # Default fallback for unknown size enum

        # Fallback for complex types (structs, unions, typedefs resolving to complex)
        type_name = tif_copy.dstr()
        log_warn(f"Unsupported IDA type '{type_name}' for Frida NativeFunction mapping. Falling back to 'pointer'.")
        return 'pointer'

    def _map_ida_member_tif_to_frida_read(self, mtif: ida_typeinf.tinfo_t, msize_bits: int) -> str:
        """Maps IDA member tinfo_t to Frida Memory.read* methods. msize is in BITS."""
        msize_bytes = (msize_bits + 7) // 8 # Calculate bytes, rounding up
        if not mtif: return f"readByteArray({msize_bytes})" # Fallback if no type info
        mtif_copy = ida_typeinf.tinfo_t(mtif)
        mtif_copy.clr_const()

        # Basic types - Check specific types first
        if mtif_copy.is_bool(): return "readU8()" # Bool often 1 byte
        if mtif_copy.is_char(): return "readS8()"
        if mtif_copy.is_uchar(): return "readU8()"
        if mtif_copy.is_int16(): return "readS16()"  # Use is_int16 instead of is_short
        if mtif_copy.is_uint16(): return "readU16()" # Use is_uint16 instead of is_ushort
        if mtif_copy.is_int32(): return "readS32()"  # Use is_int32 instead of is_int
        if mtif_copy.is_uint32(): return "readU32()" # Use is_uint32 instead of is_uint
        if mtif_copy.is_int64(): return "readS64()"  # Use is_int64 instead of is_longlong
        if mtif_copy.is_uint64(): return "readU64()" # Use is_uint64 instead of is_ulonglong
        # Add 128-bit support if needed, Frida might not have direct read methods
        if mtif_copy.is_int128(): return "readByteArray(16) /* int128 */" # No direct Frida method
        if mtif_copy.is_uint128(): return "readByteArray(16) /* uint128 */" # No direct Frida method
        # is_long/is_ulong are ambiguous, rely on the specific size checks above.

        # Floating point types
        if mtif_copy.is_float(): return "readFloat()"
        if mtif_copy.is_double(): return "readDouble()"
        # Check for long double or other floating types
        if mtif_copy.is_floating(): return "readDouble()" # Map long double etc. to Frida's double for simplicity

        # Pointers
        if mtif_copy.is_ptr():
            pt = mtif_copy.get_pointed_object()
            # Check for char* specifically for string reading hint
            if pt and (pt.is_char() or pt.is_uchar()):
                return "readPointer() /* char* */"
            else:
                return "readPointer()"

        # Arrays
        if mtif_copy.is_array():
            elem_tif = mtif_copy.get_array_element()
            if elem_tif and (elem_tif.is_char() or elem_tif.is_uchar()):
                # Treat char arrays as strings
                return f"readCString({msize_bytes})" # Use total member size in bytes
            else:
                # Other arrays - just show pointer or read bytes
                elem_name = elem_tif.dstr() if elem_tif else '?'
                return f"readPointer() /* Array of {elem_name} */"
                # return f"readByteArray({msize_bytes})"

        # Structs/Unions/Enums
        if mtif_copy.is_struct() or mtif_copy.is_union():
            nested_struct_name = mtif_copy.get_type_name() or "nested_struct_union"
            # Treat as pointer for dump, JS handles recursion
            return f"readPointer() /* Nested: {nested_struct_name} */"
        if mtif_copy.is_enum():
            enum_size_bytes = mtif_copy.get_size()
            if enum_size_bytes == 1: return "readU8()" # Assume unsigned enum
            if enum_size_bytes == 2: return "readU16()"
            if enum_size_bytes == 4: return "readU32()"
            if enum_size_bytes == 8: return "readU64()"
            # Fallback based on actual member size if enum size unknown
            if msize_bytes == 1: return "readU8()"
            if msize_bytes == 2: return "readU16()"
            if msize_bytes == 4: return "readU32()"
            if msize_bytes == 8: return "readU64()"
            return f"readU{msize_bytes*8}()" # Default based on size

        # Fallback based on size if type is complex/unknown
        log_warn(f"Unknown member type '{mtif_copy.dstr()}' size {msize_bytes} bytes. Reading based on size.")
        # Use sign information if available for integer fallbacks
        is_signed = mtif_copy.is_signed()
        if msize_bytes == 1: return "readS8()" if is_signed else "readU8()"
        if msize_bytes == 2: return "readS16()" if is_signed else "readU16()"
        if msize_bytes == 4: return "readS32()" if is_signed else "readU32()"
        if msize_bytes == 8: return "readS64()" if is_signed else "readU64()"
        return f"readByteArray({msize_bytes})"

    def _get_func_details(self, func_ea):
        """Attempts to get function signature details using Hex-Rays or tinfo."""
        details = {'ret': 'pointer', 'args': [], 'argnames': [], 'nargs': 0}
        try:
            # Ensure EA is function start
            func = ida_funcs.get_func(func_ea)
            if not func: raise ValueError("Not a function")
            start_ea = func.start_ea

            # 1. Try Hex-Rays first if available
            if HAS_HEXRAYS:
                cfunc = ida_hexrays.decompile(start_ea)
                if cfunc and cfunc.type:
                    func_type_data = ida_typeinf.func_type_data_t()
                    if cfunc.type.get_func_details(func_type_data):
                        details['ret'] = self._map_ida_tif_to_frida(func_type_data.rettype)
                        details['nargs'] = func_type_data.size()
                        for i in range(func_type_data.size()):
                            arg_tif = func_type_data[i].type
                            arg_name = func_type_data[i].name or f"arg{i}"
                            # Sanitize arg name for JS
                            arg_name_js = re.sub(r'\W|^(?=\d)', '_', arg_name)
                            if not arg_name_js: arg_name_js = f"arg{i}" # Ensure non-empty
                            details['args'].append(self._map_ida_tif_to_frida(arg_tif))
                            details['argnames'].append(arg_name_js)
                        log_info(f"Got function details for {start_ea:#x} via Hex-Rays.")
                        return details
                    else:
                        log_warn(f"Hex-Rays: Could not get func details for {start_ea:#x}.")
                else:
                    log_warn(f"Hex-Rays: Decompilation failed or no type info for {start_ea:#x}.")

            # 2. Fallback to ida_nalt.get_tinfo if Hex-Rays failed or unavailable
            tif = ida_typeinf.tinfo_t()
            if ida_nalt.get_tinfo(tif, start_ea) and tif.is_func(): # Use start_ea
                func_type_data = ida_typeinf.func_type_data_t()
                if tif.get_func_details(func_type_data):
                    details['ret'] = self._map_ida_tif_to_frida(func_type_data.rettype)
                    details['nargs'] = func_type_data.size()
                    for i in range(func_type_data.size()):
                        arg_tif = func_type_data[i].type
                        arg_name = func_type_data[i].name or f"arg{i}"
                        arg_name_js = re.sub(r'\W|^(?=\d)', '_', arg_name)
                        if not arg_name_js: arg_name_js = f"arg{i}"
                        details['args'].append(self._map_ida_tif_to_frida(arg_tif))
                        details['argnames'].append(arg_name_js)
                    log_info(f"Got function details for {start_ea:#x} via tinfo.")
                    return details
                else:
                    log_warn(f"Tinfo: Could not get func details for {start_ea:#x}.")
            else:
                log_warn(f"Tinfo: Could not get tinfo or not a function type for {start_ea:#x}.")

        except ida_hexrays.DecompilationFailure as e:
            log_warn(f"Decompilation failed for {func_ea:#x}: {e}. Using default signature.")
        except Exception as e:
            log_error(f"Unexpected error getting function signature for {func_ea:#x}", e)

        # 3. Absolute fallback (if everything else fails)
        log_warn(f"Using default signature (pointer ret, 0 args) for {func_ea:#x}.")
        details['nargs'] = 0 # Assume 0 args if we have no info
        details['args'] = []
        details['argnames'] = []
        return details

    # --- Generation Methods (IDA 9.0 Ported) ---

    def generate_struct_dump_stub(self, ea, struct_info):
        """Generates Frida script to dump a struct instance using ida_typeinf."""
        struct_tif = struct_info.get('tif') # tinfo_t if available
        struct_name = struct_info.get('name', 'UnknownStruct')
        struct_size_bytes = struct_info.get('size', 0) # Size in bytes

        if ea == idaapi.BADADDR or not struct_tif or not struct_tif.is_struct():
            log_error(f"Invalid address or struct type info for struct dump: {struct_name}")
            return f"// Error: Invalid address or struct type info for {struct_name}."

        if struct_size_bytes == 0:
            struct_size_bytes = struct_tif.get_size() # Ensure size is calculated
            if struct_size_bytes == ida_typeinf.BADSIZE:
                 log_error(f"Could not determine size for struct {struct_name}.")
                 return f"// Error: Could not determine size for struct {struct_name}."

        filename = self.get_idb_filename()
        offset = ea - self.imagebase

        member_dump_code = []
        udt_data = ida_typeinf.udt_type_data_t()
        if struct_tif.get_udt_details(udt_data):
            for udm in udt_data: # Iterate through udt_member_t
                m_name = udm.name
                m_offset_bits = udm.offset
                m_size_bits = udm.size
                m_type = udm.type # This is a tinfo_t

                if m_name is None or m_offset_bits == -1 or m_size_bits is None:
                    log_warn(f"Skipping invalid member in {struct_name}")
                    continue

                m_offset_bytes = m_offset_bits // 8
                m_size_bytes = (m_size_bits + 7) // 8 # Round up size for byte reading

                read_method = self._map_ida_member_tif_to_frida_read(m_type, m_size_bits)
                m_name_js = re.sub(r'\W|^(?=\d)', '_', m_name) # Sanitize name for JS var

                # Generate JS line for this member
                js_line = f'            try {{\n'
                js_line += f'                // @ts-ignore\n'
                # Handle nested structs/pointers for recursive call
                if m_type.is_ptr() and m_type.get_pointed_object().is_struct():
                    nested_tif = m_type.get_pointed_object()
                    nested_name = nested_tif.get_type_name() or "nested_struct"
                    nested_size = nested_tif.get_size()
                    if nested_size == ida_typeinf.BADSIZE: nested_size = 0
                    js_line += f'                var ptr_{m_name_js} = structPtr.add(0x{m_offset_bytes:X}).readPointer();\n'
                    js_line += f'                console.log(`${{innerIndent}}+0x{m_offset_bytes:X} {m_name} ({m_size_bytes} bytes, ptr to {nested_name}): ${{formatAddress(ptr_{m_name_js})}}`);\n'
                    js_line += f'                dumpStructRecursive(ptr_{m_name_js}, "{nested_name}", {nested_size}, innerIndent + "  ", depth + 1);\n'
                elif m_type.is_struct(): # Struct by value
                    nested_name = m_type.get_type_name() or "nested_struct"
                    nested_size = m_type.get_size()
                    if nested_size == ida_typeinf.BADSIZE: nested_size = 0
                    js_line += f'                var nestedPtr_{m_name_js} = structPtr.add(0x{m_offset_bytes:X}); // Address of nested struct\n'
                    js_line += f'                console.log(`${{innerIndent}}+0x{m_offset_bytes:X} {m_name} ({m_size_bytes} bytes, nested {nested_name}):`);\n'
                    js_line += f'                dumpStructRecursive(nestedPtr_{m_name_js}, "{nested_name}", {nested_size}, innerIndent + "  ", depth + 1);\n'
                elif read_method == "readPointer() /* char* */": # char* pointer
                     js_line += f'                var ptr_{m_name_js} = structPtr.add(0x{m_offset_bytes:X}).readPointer();\n'
                     js_line += f'                var str_{m_name_js} = readStringSafely(ptr_{m_name_js});\n'
                     js_line += f'                console.log(`${{innerIndent}}+0x{m_offset_bytes:X} {m_name} ({m_size_bytes} bytes, char*): ${{formatAddress(ptr_{m_name_js})}} -> "${{{f"str_{m_name_js}"}}}"`);\n'
                elif read_method.startswith("readCString"): # String reading (char array)
                     js_line += f'                var val_{m_name_js} = readStringSafely(structPtr.add(0x{m_offset_bytes:X}), {m_size_bytes});\n'
                     js_line += f'                console.log(`${{innerIndent}}+0x{m_offset_bytes:X} {m_name} ({m_size_bytes} bytes): "${{{f"val_{m_name_js}"}}}"`);\n'
                elif "readPointer" in read_method: # Other pointers
                     js_line += f'                var val_{m_name_js} = structPtr.add(0x{m_offset_bytes:X}).readPointer();\n'
                     js_line += f'                console.log(`${{innerIndent}}+0x{m_offset_bytes:X} {m_name} ({m_size_bytes} bytes): ${{formatAddress(val_{m_name_js})}}`);\n'
                else: # Basic types
                    js_line += f'                var val_{m_name_js} = structPtr.add(0x{m_offset_bytes:X}).{read_method};\n'
                    js_line += f'                console.log(`${{innerIndent}}+0x{m_offset_bytes:X} {m_name} ({m_size_bytes} bytes): ${{{f"val_{m_name_js}"}}}`);\n'

                js_line += f'            }} catch (mem_err) {{ console.log(`${{innerIndent}}+0x{m_offset_bytes:X} {m_name}: <read_error: ${{mem_err.message}}>`); }}'
                member_dump_code.append(js_line)
        else:
            log_error(f"Could not get UDT details for struct {struct_name}")
            member_dump_code.append("            console.log('// Error: Could not get UDT details from IDA.');")


        repdata = {
            "filename": filename,
            "structName": struct_name,
            "structSize": struct_size_bytes, # Pass size in bytes
            "baseOffset": hex(offset),
            "memberDumpCode": "\n".join(member_dump_code) if member_dump_code else "            console.log('// No members found or generated.');"
        }
        return self._generate_stub(dump_struct_template, repdata)


    def generate_rpc_stub(self, func_ea):
        """Generates Frida script to export a function via RPC."""
        # ... (Implementation is the same as before, relies on _get_func_details which uses ida_typeinf) ...
        func = ida_funcs.get_func(func_ea)
        if not func:
            log_error(f"Not a function at {func_ea:#x}")
            return "// Error: Not a function."

        start_ea = func.start_ea
        func_name = self.get_function_name(start_ea)
        offset = start_ea - self.imagebase
        filename = self.get_idb_filename()
        # Sanitize name for JS/Python export
        export_name = re.sub(r'[^a-zA-Z0-9_]', '_', func_name)
        if not export_name or export_name.startswith('_'): export_name = f"ida_func_{export_name}"

        # Get function signature details
        details = self._get_func_details(start_ea)
        ret_type_frida = details['ret']
        arg_types_frida_list = details['args']
        arg_names_js_list = details['argnames']

        # Format for template
        arg_types_frida_str = ", ".join([f"'{t}'" for t in arg_types_frida_list])
        arg_names_js_str = ", ".join(arg_names_js_list)
        signature_str = f"{ret_type_frida} {func_name}({', '.join([f'{t} {n}' for t, n in zip(arg_types_frida_list, arg_names_js_list)])})"

        repdata = {
            "filename": filename,
            "offset": hex(offset),
            "funcName": func_name,
            "exportName": export_name,
            "retTypeFrida": ret_type_frida,
            "argTypesFrida": arg_types_frida_str,
            "argNamesJs": arg_names_js_str,
            "signature": signature_str.replace('"', '\\"'), # Escape quotes for JS string
        }
        script = self._generate_stub(rpc_stub_template, repdata)

        # Generate and print example Python caller
        py_caller = self._generate_python_rpc_caller(export_name, details['nargs'], details['argnames'])
        print("-" * 60)
        print(f"Example Python code to call RPC function '{export_name}':")
        print(py_caller)
        print("-" * 60)
        log_info("Example Python caller printed to IDA Output window.")

        return script

    def _generate_python_rpc_caller(self, export_name, num_args, arg_names):
        """Generates example Python code to call the exported RPC function."""
        # ... (Implementation is the same as before) ...
        placeholders = "# TODO: Replace arg values below with appropriate types (int, str(ptr), etc.)"
        if num_args == 0:
            placeholders = ""

        # Construct argument parsing from sys.argv
        arg_parsing_code = []
        arg_parsing_code.append(f"rpc_args = {{}} # Dictionary to hold arguments")
        arg_parsing_code.append(f"expected_args = {arg_names}")
        arg_parsing_code.append(f"script_args = sys.argv[2:]")
        arg_parsing_code.append(f"if len(script_args) != len(expected_args):")
        arg_parsing_code.append(f"    print(f'Error: Expected {{len(expected_args)}} arguments ({{', '.join(expected_args)}}), but got {{len(script_args)}}.')")
        arg_parsing_code.append(f"    print(f'Usage: {{sys.argv[0]}} <process> {" ".join([f'<{n}>' for n in arg_names])}')")
        arg_parsing_code.append(f"    # Example: Provide default values or exit")
        arg_parsing_code.append(f"    # Example defaults (modify!):")
        for i, name in enumerate(arg_names):
             arg_parsing_code.append(f"    # rpc_args['{name}'] = 0 # Default for {name}")
        arg_parsing_code.append(f"    sys.exit(1)") # Exit if args mismatch
        arg_parsing_code.append(f"else:")
        arg_parsing_code.append(f"    for i, arg_str in enumerate(script_args):")
        arg_parsing_code.append(f"        arg_name = expected_args[i]")
        arg_parsing_code.append(f"        # Basic type guessing (refine as needed)")
        arg_parsing_code.append(f"        try:")
        arg_parsing_code.append(f"            if arg_str.lower() == 'true': rpc_args[arg_name] = True")
        arg_parsing_code.append(f"            elif arg_str.lower() == 'false': rpc_args[arg_name] = False")
        arg_parsing_code.append(f"            elif arg_str.startswith('0x'): rpc_args[arg_name] = int(arg_str, 16)")
        arg_parsing_code.append(f"            else: rpc_args[arg_name] = int(arg_str)")
        arg_parsing_code.append(f"        except ValueError:")
        arg_parsing_code.append(f"             # Assume string (Frida might treat as pointer if needed)")
        arg_parsing_code.append(f"             rpc_args[arg_name] = arg_str")
        arg_parsing_code.append(f"")
        arg_parsing_code.append(f"# Convert dict to list in correct order for call")
        arg_parsing_code.append(f"call_args_list = [rpc_args.get(name) for name in expected_args]") # Use get without default to ensure order matches


        return f"""
import frida
import sys
import time
import traceback

# Example Python script to call the exported RPC function '{export_name}'
# Usage: python call_rpc.py <process_name_or_pid> [{' '.join([f'<{n}>' for n in arg_names])}]

FRIDA_SCRIPT_NAME = "IDAFrida" # Match the name set in the JS template

def on_message(message, data):
    if message['type'] == 'error':
        print(f"[Frida Error] {{message.get('description')}}")
        print(f"  Stack: {{message.get('stack')}}")
    else:
        print(f"[Frida Message] {{message}}")

if len(sys.argv) < 2:
    print(f"Usage: {{sys.argv[0]}} <process_name_or_pid> [{' '.join([f'<{n}>' for n in arg_names])}]")
    sys.exit(1)

process_identifier = sys.argv[1]
try:
    process_identifier = int(process_identifier)
except ValueError:
    pass

# --- Argument Parsing ---
{placeholders}
{"\n".join(arg_parsing_code)}
# --- End Argument Parsing ---

session = None
try:
    print(f"Attaching to {{process_identifier}}...")
    device = frida.get_local_device() # Assume local Linux target
    session = device.attach(process_identifier)
    session.enable_child_gating() # Optional: handle child processes
    print("Attached.")

    script = None
    api = None
    # Wait briefly for script to potentially load if attached with -l
    print(f"Waiting for script '{{FRIDA_SCRIPT_NAME}}' to load...")
    for _ in range(5): # Try for ~5 seconds
        try:
            # Use enumerate_scripts() for more robust checking
            scripts = session.enumerate_scripts()
            target_script = next((s for s in scripts if FRIDA_SCRIPT_NAME in s.name), None)
            if target_script:
                script = session.get_script(target_script.name) # Get by actual loaded name
                if script:
                    api = script.exports
                    if api:
                        print(f"Script '{{script.name}}' exports found.")
                        break
        except frida.InvalidOperationError:
            pass # Script not ready yet
        except Exception as e:
             print(f"Error getting script: {{e}}")
             break
        time.sleep(1)

    if not api:
        print(f"Error: Could not get script exports for '{{FRIDA_SCRIPT_NAME}}'.")
        print("Ensure the IDAFrida-generated RPC script is loaded in the target process (e.g., using 'frida -l ...').")
        if session: session.detach()
        sys.exit(1)

    if not hasattr(api, '{export_name}'):
        print(f"Error: Exported function '{export_name}' not found in script API.")
        print(f"Available exports: {{[e for e in dir(api) if not e.startswith('_')]}}")
        if session: session.detach()
        sys.exit(1)

    # Call the exported function
    print(f"Calling RPC function '{export_name}' with args: {{call_args_list}}...")
    result = getattr(api, '{export_name}')(*call_args_list) # Use getattr and * to unpack args
    print(f"RPC call result: {{result}}")


except frida.ProcessNotFoundError:
    print(f"Error: Process not found: {{process_identifier}}")
except frida.InvalidArgumentError as e:
    print(f"Error: Invalid argument during attach or RPC call: {{e}}")
except frida.TransportError as e:
    print(f"Error: Frida transport error (is frida-server running?): {{e}}")
except Exception as e:
    print(f"An unexpected error occurred: {{e}}")
    traceback.print_exc()
finally:
    if session:
        print("Detaching.")
        try:
            session.detach()
        except Exception as detach_err:
            print(f"Error detaching: {{detach_err}}")

"""

    def generate_memory_trace_stub(self, ea, size):
        """Generates Frida script to monitor memory access."""
        if ea == idaapi.BADADDR: return "// Error: Invalid address."
        if size <= 0: size = 1
        filename = self.get_idb_filename()
        offset = ea - self.imagebase
        repdata = {"filename": filename, "offset": hex(offset), "monitorSize": size}
        return self._generate_stub(memory_trace_template, repdata)

    def _generate_func_hook_common(self, func_addr_list: list, template: str) -> str:
        """Common logic for generating function hooks (basic, backtrace, modifiable, conditional)."""
        stubs = []
        filename = self.get_idb_filename()
        if not func_addr_list:
            return "// No functions provided."

        for func_addr in func_addr_list:
            func = ida_funcs.get_func(func_addr)
            if not func:
                log_warn(f"{func_addr:#x} is not the start of a function. Skipping.")
                continue

            start_ea = func.start_ea
            details = self._get_func_details(start_ea)
            offset = start_ea - self.imagebase

            repdata = {
                "filename": filename,
                "funcname": self.get_function_name(start_ea),
                "offset": hex(offset),
                "nargs": details['nargs']
            }
            stubs.append(self._generate_stub(template, repdata))

        if not stubs: return "// No valid functions found to generate hooks."
        return "\n\n//-----------------------\n\n".join(stubs)

    def generate_func_hook(self, func_addr_list: list) -> str:
        """Generates basic function hook script."""
        return self._generate_func_hook_common(func_addr_list, self.conf.template_func) # Use configured template

    def generate_func_hook_with_backtrace(self, func_addr_list: list) -> str:
        """Generates function hook script with backtraces."""
        return self._generate_func_hook_common(func_addr_list, func_hook_with_backtrace_template)

    def generate_modifiable_func_hook(self, func_addr_list: list) -> str:
        """Generates function hook script with modification placeholders."""
        return self._generate_func_hook_common(func_addr_list, modifiable_func_hook_template)

    def generate_conditional_func_hook(self, func_addr_list: list) -> str:
        """Generates function hook script with conditional placeholders."""
        return self._generate_func_hook_common(func_addr_list, conditional_func_hook_template)

    def generate_libc_tracer_stub(self, libc_func_name: str) -> str:
        """Generates a pre-defined tracer for a common libc function."""
        templates = {
            "strcpy": libc_strcpy_template,
            "memcpy": libc_memcpy_template,
            "strcmp": libc_strcmp_template,
            "malloc": libc_malloc_template,
            "free": libc_free_template,
            "open": libc_open_template, # Covers open64 too
            "read": libc_read_template,
            "write": libc_write_template,
        }
        template = templates.get(libc_func_name)
        if template:
            # No replacements needed for these simple templates
            return template
        else:
            log_error(f"No pre-defined tracer template for libc function: {libc_func_name}")
            return f"// Error: No tracer defined for {libc_func_name}"

    def generate_memory_scan_stub(self, pattern: str, module_name: str, protection: str) -> str:
        """Generates Frida script for memory scanning."""
        if not pattern: return "// Error: No pattern provided."
        if not protection: protection = 'r-x' # Default readable/executable
        repdata = {
            "pattern": pattern.replace('\\', '\\\\').replace('"', '\\"'),
            "moduleName": module_name if module_name else "null",
            "protection": protection,
            "scope": module_name if module_name else f"All Process Memory ('{protection}')"
        }
        return self._generate_stub(memory_scan_template, repdata)

    def generate_address_hook_stub(self, address: int, registers: str) -> str:
        """Generates Frida script for a single address hook."""
        if address == idaapi.BADADDR: return "// Error: Invalid address."
        offset = address - self.imagebase
        sanitized_registers = ' '.join(filter(None, [r.strip() for r in registers.split()]))
        repdata = {
            "filename": self.get_idb_filename(),
            "address": hex(offset),
            "registers": sanitized_registers
        }
        return self._generate_stub(self.conf.template_address, repdata) # Use configured template


    # --- File Writing and Generation Wrappers ---
    def _write_and_copy(self, data: str, filename: str) -> bool:
        """Helper to write script to file and copy to clipboard."""
        if not data or data.strip().startswith("// Error"):
            log_error("Script generation resulted in an error or empty content. Not writing or copying.")
            ida_kernwin.warning("Script generation failed. Check logs.")
            return False

        # Ensure directory exists
        output_dir = os.path.dirname(filename)
        if not output_dir or not os.path.isdir(output_dir):
             log_error(f"Output directory '{output_dir}' is invalid or does not exist.")
             ida_kernwin.warning(f"Invalid output directory: {output_dir}")
             return False # Cannot write file

        # Write to file
        try:
            with open(filename, "w", encoding='utf-8') as f:
                f.write(data)
            log_info(f"Generated Frida script saved to: {filename}")
        except Exception as e:
            log_error(f"Error writing Frida script to {filename}", e)
            ida_kernwin.warning(f"Failed to write script to {filename}. Check permissions/path.")
            # Continue to clipboard copy attempt even if file write fails

        # Copy to clipboard (requires PyQt)
        if HAS_PYQT:
            try:
                clipboard = QApplication.clipboard()
                if clipboard:
                    clipboard.setText(data)
                    log_info("Generated Frida script copied to clipboard!")
                else:
                     log_warn("Could not access clipboard.")
            except Exception as e:
                log_error("Error copying Frida script to clipboard", e)
        else:
            log_info("PyQt not available, skipping clipboard copy.")

        return True # Return true if write succeeded or attempted

    def _generate_and_write(self, generator_func, args: tuple, filename: str, success_msg: str):
        """Helper to generate, write, and show message."""
        idb_dir = self.get_idb_path()
        if not idb_dir:
             log_error("Could not determine output directory.")
             ida_kernwin.warning("Could not determine output directory for script.")
             return False
        full_path = os.path.join(idb_dir, filename)

        try:
            data = generator_func(*args)
            if self._write_and_copy(data, full_path):
                ida_kernwin.msg(f"{PLUGIN_NAME}: {success_msg} -> {os.path.basename(full_path)}\n") # Show only filename
                return True
            else:
                return False # Error logged within _write_and_copy
        except Exception as e:
            log_error(f"Error during script generation/writing for {generator_func.__name__}", e)
            ida_kernwin.warning(f"Script generation failed: {e}")
            return False

    # --- Public Generation Methods (to file) ---
    def generate_func_hook_to_file(self, func_addr_list, filename="IDAhook_func.js") -> bool:
        return self._generate_and_write(
            self.generate_func_hook, (func_addr_list,), filename,
            "Basic function hook script generated and copied!"
        )

    def generate_address_hook_to_file(self, address, registers, filename="IDAhook_addr.js") -> bool:
        return self._generate_and_write(
            self.generate_address_hook_stub, (address, registers), filename,
            "Address hook script generated and copied!"
        )

    def generate_struct_dump_to_file(self, ea, struct_info, filename=None) -> bool:
        struct_name_safe = re.sub(r'\W', '_', struct_info.get('name', 'struct'))
        if not filename: filename = f"IDAhook_dump_{struct_name_safe}_{ea:#x}.js"
        return self._generate_and_write(
            self.generate_struct_dump_stub, (ea, struct_info), filename,
            f"Struct dump script for '{struct_info.get('name')}' generated and copied!"
        )

    def generate_rpc_stub_to_file(self, func_ea, filename=None) -> bool:
        func_name_safe = re.sub(r'\W', '_', self.get_function_name(func_ea))
        if not filename: filename = f"IDAhook_rpc_{func_name_safe}.js"
        return self._generate_and_write(
            self.generate_rpc_stub, (func_ea,), filename,
            f"RPC stub script for '{self.get_function_name(func_ea)}' generated and copied! (Check Output window for Python caller)"
        )

    def generate_memory_trace_to_file(self, ea, size, filename=None) -> bool:
        if not filename: filename = f"IDAhook_memtrace_{ea:#x}.js"
        return self._generate_and_write(
            self.generate_memory_trace_stub, (ea, size), filename,
            f"Memory trace script for {ea:#x} generated and copied!"
        )

    def generate_func_hook_with_backtrace_to_file(self, func_addr_list, filename="IDAhook_backtrace.js") -> bool:
        return self._generate_and_write(
            self.generate_func_hook_with_backtrace, (func_addr_list,), filename,
            "Function hook script with backtrace generated and copied!"
        )

    def generate_libc_tracer_to_file(self, libc_func_name, filename=None) -> bool:
        if not filename: filename = f"IDAhook_libc_{libc_func_name}.js"
        return self._generate_and_write(
            self.generate_libc_tracer_stub, (libc_func_name,), filename,
            f"Libc tracer script for '{libc_func_name}' generated and copied!"
        )

    def generate_modifiable_func_hook_to_file(self, func_addr_list, filename="IDAhook_modifiable.js") -> bool:
        return self._generate_and_write(
            self.generate_modifiable_func_hook, (func_addr_list,), filename,
            "Modifiable function hook script generated and copied!"
        )

    def generate_memory_scan_to_file(self, pattern, module_name, protection, filename="IDAhook_memscan.js") -> bool:
        return self._generate_and_write(
            self.generate_memory_scan_stub, (pattern, module_name, protection), filename,
            "Memory scan script generated and copied!"
        )

    def generate_conditional_func_hook_to_file(self, func_addr_list, filename="IDAhook_conditional.js") -> bool:
        return self._generate_and_write(
            self.generate_conditional_func_hook, (func_addr_list,), filename,
            "Conditional function hook script generated and copied!"
        )


############################################################################
# Frida Interaction (Basic Runner)
############################################################################
class Frida:
    """Handles running Frida scripts."""
    def __init__(self, conf: Configuration) -> None:
        if conf is None:
             raise ValueError("Frida interaction requires a valid Configuration object.")
        self.conf = conf

    def run_script(self, script_path: str):
        """Runs the generated Frida script using the configured command."""
        if not self.conf or not self.conf.frida_cmd:
            log_error("Frida command is not configured.")
            ida_kernwin.warning("Frida command not set. Configure it via the menu.")
            return

        if not os.path.exists(script_path):
             log_error(f"Script file not found: {script_path}")
             ida_kernwin.warning(f"Script file not found: {script_path}")
             return

        # Replace placeholder ONLY if it exists in the command template
        placeholder = "IDAhook.js" # Default placeholder name
        cmd_parts = []
        cmd_template = self.conf.frida_cmd

        # Basic placeholder replacement (can be improved with regex)
        if placeholder in cmd_template:
             # Split command carefully respecting quotes (basic approach)
             # This is tricky; using shlex might be better if available/allowed
             temp_cmd = cmd_template.replace(placeholder, "__SCRIPT_PLACEHOLDER__")
             # Simple split for now, might break with complex quoted args
             parts = temp_cmd.split()
             for part in parts:
                 if part == "__SCRIPT_PLACEHOLDER__":
                     cmd_parts.append(script_path)
                 else:
                     cmd_parts.append(part)
        else:
             # If placeholder isn't found, append script path with -l
             log_warn(f"Placeholder '{placeholder}' not found in Frida command. Appending script path with '-l'. Adjust command if needed.")
             cmd_parts = cmd_template.split()
             cmd_parts.extend(["-l", script_path])

        final_cmd_str = subprocess.list2cmdline(cmd_parts)
        log_info(f"Running Frida command: {final_cmd_str}")
        ida_kernwin.warning(f"Attempting to run: {final_cmd_str}\n(Requires 'frida' in PATH. Output may appear in separate console.)")

        try:
            # Run in a way that doesn't block IDA, but output capture is lost easily.
            # For interactive use, running in a separate terminal is often better.
            # Using shell=True is convenient but carries security risks if cmd is untrusted.
            # On Windows, creationflags might be needed to hide console.
            creationflags = 0
            startupinfo = None
            if sys.platform == "win32":
                # Try DETACHED_PROCESS first, allows separate console
                # CREATE_NO_WINDOW hides it completely
                creationflags = subprocess.DETACHED_PROCESS
                # startupinfo = subprocess.STARTUPINFO()
                # startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                # startupinfo.wShowWindow = subprocess.SW_HIDE

            proc = subprocess.Popen(final_cmd_str, shell=True, # Use shell=True carefully
                                    creationflags=creationflags, startupinfo=startupinfo,
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            log_info(f"Frida process started with PID: {proc.pid} (Output may not show in IDA).")
            # We don't wait for it (proc.wait()) to avoid blocking IDA.

        except FileNotFoundError:
             log_error(f"Error: Command 'frida' (or part of the command) not found. Is Frida installed and in your system's PATH?")
             ida_kernwin.warning("Command 'frida' not found. Check PATH.")
        except Exception as e:
            log_error(f"An error occurred while running Frida: {e}")
            ida_kernwin.warning(f"Error running Frida: {e}")


############################################################################
# Action Management
############################################################################

class ActionManager:
    """Manages IDA actions (registration and finalization)."""
    def __init__(self):
        self.__actions = {}

    def register(self, action_instance):
        """Registers an IDA action instance."""
        action_name = action_instance.name
        if action_name in self.__actions:
            log_warn(f"Action '{action_name}' already registered. Overwriting.")
        self.__actions[action_name] = action_instance
        result = ida_kernwin.register_action(
            ida_kernwin.action_desc_t(
                action_instance.name,
                action_instance.description,
                action_instance, # The handler instance
                action_instance.hotkey,
                action_instance.tooltip, # Add tooltip
                action_instance.icon     # Add icon
            )
        )
        if not result:
            log_error(f"Failed to register action: {action_name}")
        # else: log_info(f"Action registered: {action_name}")
        return result

    def initialize(self):
        """Registers all defined actions."""
        log_info("Registering IDAFrida actions...")
        # --- Basic Actions ---
        self.register(GenerateFridaHookScript())
        self.register(GenerateFridaHookScriptOnCurrentAddress())
        self.register(RunGeneratedScript())
        self.register(ViewFridaTemplateFunc())
        self.register(ViewFridaTemplateAddress())
        self.register(SetFridaRunCommand())

        # --- Tier 1 Actions ---
        self.register(DumpStructAtAddress())
        self.register(GenerateRpcStubForFunction())
        self.register(TraceMemoryAccessAtAddress())

        # --- Tier 2 Actions ---
        self.register(GenerateFunctionHookWithBacktrace())
        # Libc Tracers
        self.register(TraceStrcpy())
        self.register(TraceMemcpy())
        self.register(TraceStrcmp())
        self.register(TraceMalloc())
        self.register(TraceFree())
        self.register(TraceOpen())
        self.register(TraceRead())
        self.register(TraceWrite())

        # --- Tier 3 Actions ---
        self.register(GenerateModifiableFunctionHook())
        self.register(GenerateMemoryScanScript())
        self.register(GenerateConditionalFunctionHook())

        log_info("IDAFrida actions registered.")

    def finalize(self):
        """Unregisters all managed IDA actions."""
        log_info("Unregistering IDAFrida actions...")
        unregistered_count = 0
        failed_count = 0
        for name in list(self.__actions.keys()):
            result = ida_kernwin.unregister_action(name)
            if result:
                unregistered_count += 1
                del self.__actions[name]
            else:
                failed_count += 1
                log_warn(f"Failed to unregister action: {name}")
        log_info(f"Unregistered {unregistered_count} actions ({failed_count} failures).")


# Global action manager instance
action_manager = ActionManager()


############################################################################
# IDA Action Classes
############################################################################

# --- Base Action Class ---
class Action(ida_kernwin.action_handler_t):
    """Convenience wrapper for IDA actions."""
    description = "IDAFrida Action"
    hotkey = "" # Default: no hotkey
    tooltip = "" # Tooltip for menu/toolbar
    icon = -1 # Icon ID (-1 for none)

    def __init__(self):
        super().__init__()

    @property
    def name(self):
        """Generates a unique name for the action based on its class name."""
        return f"{PLUGIN_NAME}:{type(self).__name__}"

    def activate(self, ctx):
        # type: (ida_kernwin.action_activation_ctx_t) -> int # Return 0 per IDA docs
        """Called when the action is invoked."""
        try:
            self.do_activate(ctx)
        except Exception as e:
            log_error(f"Error activating action '{self.description}'", e)
            traceback.print_exc() # Print full traceback for debugging
        return 1 # Indicate action handled

    def do_activate(self, ctx):
        """Derived classes should implement their logic here."""
        ida_kernwin.warning(f"Action '{self.description}' ({self.name}) not implemented yet.")

    def update(self, ctx):
        # type: (ida_kernwin.action_activation_ctx_t) -> int
        """Called to determine the action's state (enabled/disabled)."""
        # Default: Enable in common views if plugin is initialized
        if global_config is None:
             return ida_kernwin.AST_DISABLE_FOR_WIDGET

        # IDA 9.0: Replace BWN_STRUCTS with BWN_LOCTYPS, BWN_DUMP with BWN_HEXVIEW_T
        if ctx.widget_type in (ida_kernwin.BWN_DISASM,
                               ida_kernwin.BWN_PSEUDOCODE,
                               ida_kernwin.BWN_FUNCS,
                               ida_kernwin.BWN_TILVIEW,  # Corrected: Covers Local Types (formerly BWN_STRUCTS/BWN_ENUMS in some contexts)
                               ida_kernwin.BWN_HEXVIEW): # Corrected: Standard Hex View constant
             return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET


# --- Menu Action Base Class ---
class IDAFridaMenuAction(Action):
    """Base class for IDAFrida actions appearing in context menus."""
    TOP_MENU_PATH = PLUGIN_NAME # Top-level menu name

    def update(self, ctx):
        # type: (ida_kernwin.action_activation_ctx_t) -> int
        """Attaches action to relevant widgets' context menus."""
        # Call base class update first (applies default widget filtering & init check)
        res = super().update(ctx)
        if res == ida_kernwin.AST_ENABLE_FOR_WIDGET:
            # Attach to popup menu under "IDAFrida/" submenu if enabled for the widget
            # Submenu path determined by derived class or default
            menu_path = getattr(self, "menu_path", self.TOP_MENU_PATH)
            # Ensure path ends with / for submenu creation
            if not menu_path.endswith('/'):
                menu_path += '/'
            ida_kernwin.attach_action_to_popup(ctx.widget, None, self.name, menu_path)
        return res

# --- Helper Function to Get Functions from Context ---
def _get_functions_from_context(ctx):
    selected_funcs = []
    if ctx.widget_type == ida_kernwin.BWN_FUNCS:
        if ctx.chooser_selection:
            for idx in ctx.chooser_selection:
                func = ida_funcs.getn_func(idx - 1) # chooser_selection is 1-based
                if func: selected_funcs.append(func.start_ea)
        if not selected_funcs: ida_kernwin.warning("No functions selected in the Functions window.")
    elif ctx.widget_type in (ida_kernwin.BWN_DISASM, ida_kernwin.BWN_PSEUDOCODE):
        ea = ida_kernwin.get_screen_ea()
        func = ida_funcs.get_func(ea) if ea != idaapi.BADADDR else None
        if func:
            selected_funcs = [func.start_ea]
        else:
            ida_kernwin.warning("Cursor is not inside a function.")
    else:
        # Allow activating even if not in expected view, but return empty list
        log_warn(f"Function context requested from unexpected view: {ctx.widget_type}")
        # ida_kernwin.warning("Action requires Functions, Disassembly, or Pseudocode view.")
    return selected_funcs


# --- Basic Actions Implementation ---
class GenerateFridaHookScript(IDAFridaMenuAction):
    description = "Generate Basic Hook (Function)"
    tooltip = "Generate a basic Frida function hook script"
    hotkey = "Ctrl+Alt+F"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Generate Hook"

    def do_activate(self, ctx):
        if global_config is None: return
        funcs = _get_functions_from_context(ctx)
        if not funcs: return
        gen = ScriptGenerator(global_config)
        gen.generate_func_hook_to_file(funcs)

class GenerateFridaHookScriptOnCurrentAddress(IDAFridaMenuAction):
    description = "Generate Basic Hook (Address)"
    tooltip = "Generate a basic Frida address hook script"
    hotkey = "Ctrl+Alt+A"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Generate Hook"

    def do_activate(self, ctx):
        if global_config is None: return
        current_ea = ida_kernwin.get_screen_ea()
        if current_ea == idaapi.BADADDR:
             ida_kernwin.warning("Invalid address selected.")
             return

        registers_text = InputRegistersUI.get_registers()
        if registers_text is None:
             log_info("Address hook generation cancelled by user.")
             return

        gen = ScriptGenerator(global_config)
        gen.generate_address_hook_to_file(current_ea, registers_text)

    def update(self, ctx):
        # Only enable this action in the Disassembly view
        if ctx.widget_type == ida_kernwin.BWN_DISASM and global_config is not None:
            ida_kernwin.attach_action_to_popup(ctx.widget, None, self.name, self.menu_path + "/")
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET

class RunGeneratedScript(IDAFridaMenuAction):
    description = "Run Frida Script..."
    tooltip = "Run a previously generated Frida script"
    hotkey = "Ctrl+Alt+R"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Manage"

    def do_activate(self, ctx):
        if global_config is None: return
        # Ask user which script to run (more flexible than just 'IDAhook.js')
        idb_dir = ScriptGenerator.get_idb_path()
        if not idb_dir:
            ida_kernwin.warning("Cannot determine script directory.")
            return

        # Use ask_file to let user choose
        script_file = ida_kernwin.ask_file(False, os.path.join(idb_dir, "*.js"), "Select Frida script to run")
        if not script_file or not os.path.exists(script_file):
            log_info("Run script cancelled or file not found.")
            return

        try:
            frida_runner = Frida(global_config)
            frida_runner.run_script(script_file)
        except Exception as e:
            log_error("Failed to initiate Frida runner", e)

class ViewFridaTemplateFunc(IDAFridaMenuAction):
    description = "Edit Function Hook Template..."
    tooltip = "View or edit the default template for function hooks"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Manage/Templates"
    def do_activate(self, ctx):
        if global_config is None: return
        ui = FuncConfigurationUI(global_config)
        if HAS_PYQT: ui.exec_()

class ViewFridaTemplateAddress(IDAFridaMenuAction):
    description = "Edit Address Hook Template..."
    tooltip = "View or edit the default template for address hooks"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Manage/Templates"
    def do_activate(self, ctx):
        if global_config is None: return
        ui = AddressConfigurationUI(global_config)
        if HAS_PYQT: ui.exec_()

class SetFridaRunCommand(IDAFridaMenuAction):
    description = "Set Frida Command..."
    tooltip = "Configure the command used to run Frida scripts"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Manage"
    def do_activate(self, ctx):
        if global_config is None: return
        prompt = ("Enter the Frida command template.\n"
                  "Use 'IDAhook.js' as a placeholder for the script name (will be replaced),\n"
                  "or omit it if you prefer appending '-l <script_path>'.\n"
                  f"Current: {global_config.frida_cmd}")
        new_cmd = ida_kernwin.ask_str(global_config.frida_cmd, ida_kernwin.HIST_CMD, prompt)
        if new_cmd is not None:
            new_cmd = new_cmd.strip()
            if new_cmd:
                global_config.set_frida_cmd(new_cmd)
                log_info(f"Frida command updated to: {new_cmd}")
                ida_kernwin.msg(f"{PLUGIN_NAME}: Frida command updated.\n")
            else: log_info("Frida command not changed (empty input).")
        else: log_info("Frida command update cancelled.")


# --- Tier 1 Actions Implementation (IDA 9.0 Ported) ---
class DumpStructAtAddress(IDAFridaMenuAction):
    description = "Dump Struct at Address/Variable..."
    tooltip = "Generate Frida script to dump struct contents at the cursor"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Memory"

    def do_activate(self, ctx):
        if global_config is None: return
        ea = idaapi.BADADDR
        struct_info = {} # Store name, tif, size

        # Try getting context from Hex-Rays first
        if HAS_HEXRAYS and ctx.widget_type == ida_kernwin.BWN_PSEUDOCODE:
            try:
                vdui = ida_hexrays.get_widget_vdui(ctx.widget)
                if vdui:
                    ea, struct_info = self._get_struct_info_from_vdui(vdui)
                    if ea != idaapi.BADADDR and struct_info:
                         log_info(f"Got struct context from Hex-Rays: {struct_info.get('name')} at {ea:#x}")
                    else:
                         ea = ida_kernwin.get_screen_ea() # Fallback EA
                         log_info("Could not get struct context from Hex-Rays, using screen EA.")
                else: ea = ida_kernwin.get_screen_ea()
            except Exception as e:
                log_error("Error getting Hex-Rays context", e)
                ea = ida_kernwin.get_screen_ea()
        else:
            # Fallback for other views or no Hex-Rays
            ea = ida_kernwin.get_screen_ea()

        if ea == idaapi.BADADDR:
            ida_kernwin.warning("Cannot determine target address.")
            return

        # If struct info wasn't found via Hex-Rays, try guessing from disassembly/structs view
        if not struct_info:
            struct_info = self._guess_struct_info_from_ea(ea, ctx.widget_type)

        # Ask user to confirm/enter struct name
        struct_name_guess = struct_info.get('name', '')
        prompt = f"Enter struct name to dump at {ea:#x}:"
        struct_name_input = ida_kernwin.ask_str(struct_name_guess, ida_kernwin.HIST_TYPE, prompt)

        if not struct_name_input:
            log_info("Struct dump cancelled.")
            return

        # --- IDA 9.0 Change: Use ida_typeinf to get struct info ---
        # Get tinfo_t for the struct name using the local TILL
        local_til = ida_typeinf.get_idati()
        tif = ida_typeinf.tinfo_t()
        if not tif.get_named_type(local_til, struct_name_input):
            ida_kernwin.warning(f"Struct type '{struct_name_input}' not found in IDA's local types.")
            return
        if not tif.is_struct():
             ida_kernwin.warning(f"Type '{struct_name_input}' is not a struct.")
             return

        struct_size = tif.get_size()
        if struct_size == ida_typeinf.BADSIZE:
             ida_kernwin.warning(f"Could not determine size for struct '{struct_name_input}'.")
             return
        # --- End IDA 9.0 Change ---

        # Update struct_info with confirmed details
        struct_info['tif'] = tif
        struct_info['name'] = struct_name_input
        struct_info['size'] = struct_size

        gen = ScriptGenerator(global_config)
        gen.generate_struct_dump_to_file(ea, struct_info)

    def _get_struct_info_from_vdui(self, vdui):
        """Helper to extract struct info from Hex-Rays view using ida_typeinf."""
        ea = idaapi.BADADDR
        info = {}
        try:
            vdui.get_current_item(ida_hexrays.USE_KEYBOARD) # Ensure item is current
            item = vdui.item # citem_t or lvar_t etc.

            if item.is_citem(): # Is it an expression or statement part?
                citem = item.it # Get the citem_t
                ea = citem.ea # Address of the item

                # Check the type of the expression/variable
                tif = citem.tif # Get tinfo_t
                if tif:
                    # Resolve typedefs
                    resolved_tif = ida_typeinf.tinfo_t()
                    if tif.resolve_typedef(resolved_tif):
                        tif = resolved_tif

                    target_tif = None
                    if tif.is_ptr() and tif.get_pointed_object().is_struct():
                        target_tif = tif.get_pointed_object()
                        # Try to get address if it's a variable reference
                        if citem.op == ida_hexrays.cot_var:
                             lvar = vdui.cfunc.get_lvar(citem.v.idx)
                             if lvar and lvar.has_user_info and lvar.is_stk_var():
                                 ea = citem.ea # Use citem EA as reference
                                 log_warn("Struct dump on stack variable: Address might be approximate.")
                             elif lvar and lvar.is_reg_var():
                                 log_warn("Struct dump on register variable: Cannot determine address automatically.")
                                 ea = idaapi.BADADDR # Cannot determine address
                    elif tif.is_struct():
                        target_tif = tif
                        # Similar logic to get address if it's a variable/member

                    if target_tif and ea != idaapi.BADADDR:
                        size = target_tif.get_size()
                        if size != ida_typeinf.BADSIZE:
                            info['tif'] = target_tif
                            info['name'] = target_tif.get_type_name() or "UnnamedStruct"
                            info['size'] = size
                            return ea, info

            elif item.is_lvar(): # Is it a local variable in the variable list?
                 lvar = item.l # Get the lvar_t
                 ea = vdui.cfunc.entry_ea # Use function entry as reference EA
                 tif = lvar.tif
                 if tif:
                     resolved_tif = ida_typeinf.tinfo_t()
                     if tif.resolve_typedef(resolved_tif): tif = resolved_tif
                     target_tif = None
                     if tif.is_ptr() and tif.get_pointed_object().is_struct():
                         target_tif = tif.get_pointed_object()
                     elif tif.is_struct():
                         target_tif = tif

                     if target_tif:
                         size = target_tif.get_size()
                         if size != ida_typeinf.BADSIZE:
                             info['tif'] = target_tif
                             info['name'] = target_tif.get_type_name() or "UnnamedStruct"
                             info['size'] = size
                             log_warn("Struct dump on stack variable: Address might be approximate.")
                             return ea, info # Return func entry EA

        except Exception as e:
            log_error("Error processing Hex-Rays item for struct info", e)

        # Return defaults if failed
        return ida_kernwin.get_screen_ea(), {}


    # --- _guess_struct_info_from_ea needs slight adjustment for BWN_LOCTYPS ---
    def _guess_struct_info_from_ea(self, ea, widget_type):
        """Fallback to guess struct info from disassembly or local types view."""
        info = {}
        try:
            # IDA 9.0: Check Local Types view instead of Structs view
            if widget_type == ida_kernwin.BWN_LOCTYPS:
                # Getting current type name from Local Types view is non-trivial via API.
                # Rely on user input or context from other views for now.
                log_info("Guessing struct from Local Types view is not directly supported, please use context menu from Disassembly/Pseudocode or enter name manually.")
                pass # Rely on user input
            elif widget_type == ida_kernwin.BWN_DISASM:
                # Check operand type for struct offset reference
                for i in range(ida_ua.UA_MAXOP): # Check all operands
                    op_type = idc.get_operand_type(ea, i)
                    # o_displ often involves struct offsets like [reg+struc.field+disp]
                    # o_mem might be a direct reference like 'mov eax, struc_var'
                    if op_type in (idc.o_displ, idc.o_mem):
                        ti = ida_nalt.opinfo_t()
                        # Use get_opinfo for simplicity, might need get_opinfoEx for complex cases
                        if ida_nalt.get_opinfo(ti, ea, i, idc.get_full_flags(ea)):
                            # In IDA 9.0, ti.tid often holds the member ID (mid_t), not struct ID (tid_t)
                            # We need to get the struct's tinfo based on the operand reference
                            op_tif = ida_typeinf.tinfo_t()
                            if ida_nalt.get_op_tinfo(op_tif, ea, i):
                                # Check if the operand type itself is a struct or pointer to struct
                                target_tif = None
                                if op_tif.is_struct():
                                    target_tif = op_tif
                                elif op_tif.is_ptr() and op_tif.get_pointed_object().is_struct():
                                    target_tif = op_tif.get_pointed_object()

                                if target_tif:
                                    size = target_tif.get_size()
                                    if size != ida_typeinf.BADSIZE:
                                        info['tif'] = target_tif
                                        info['name'] = target_tif.get_type_name() or f"struct_{target_tif.get_ordinal()}"
                                        info['size'] = size
                                        log_info(f"Guessed struct '{info['name']}' from operand {i} at {ea:#x}")
                                        return info
                            # Fallback: Check if ti.tid gives a valid struct type (less reliable now)
                            elif ti.tid != idaapi.BADADDR:
                                fallback_tif = ida_typeinf.tinfo_t()
                                if fallback_tif.get_type_by_tid(ti.tid) and fallback_tif.is_struct():
                                    size = fallback_tif.get_size()
                                    if size != ida_typeinf.BADSIZE:
                                        info['tif'] = fallback_tif
                                        info['name'] = fallback_tif.get_type_name() or f"struct_{ti.tid:x}"
                                        info['size'] = size
                                        log_info(f"Guessed struct '{info['name']}' from operand {i} TID at {ea:#x}")
                                        return info
        except Exception as e:
            log_error("Error guessing struct info from EA", e)
        return info


    def update(self, ctx):
        # Enable in Disassembly, Hex View, Local Types, Pseudocode
        # IDA 9.0: Replace BWN_STRUCTS with BWN_LOCTYPS, BWN_DUMP with BWN_HEXVIEW_T
        if ctx.widget_type in (ida_kernwin.BWN_DISASM, ida_kernwin.BWN_HEXVIEW, # Changed
                               ida_kernwin.BWN_LOCTYPS, # Changed
                               ida_kernwin.BWN_PSEUDOCODE) and global_config is not None:
            ida_kernwin.attach_action_to_popup(ctx.widget, None, self.name, self.menu_path + "/")
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET


class GenerateRpcStubForFunction(IDAFridaMenuAction):
    description = "Generate RPC Stub for Function..."
    tooltip = "Generate Frida script to call this function via RPC"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Advanced"

    def do_activate(self, ctx):
        if global_config is None: return
        funcs = _get_functions_from_context(ctx)
        if not funcs: return
        if len(funcs) > 1:
            ida_kernwin.warning("Please select only one function for RPC stub generation.")
            return
        func_ea = funcs[0]

        gen = ScriptGenerator(global_config)
        gen.generate_rpc_stub_to_file(func_ea)

    def update(self, ctx):
         # Enable in Functions, Disassembly, Pseudocode
        if ctx.widget_type in (ida_kernwin.BWN_FUNCS, ida_kernwin.BWN_DISASM, ida_kernwin.BWN_PSEUDOCODE) and global_config is not None:
            ida_kernwin.attach_action_to_popup(ctx.widget, None, self.name, self.menu_path + "/")
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET


class TraceMemoryAccessAtAddress(IDAFridaMenuAction):
    description = "Trace Memory Access at Address..."
    tooltip = "Generate Frida script to monitor reads/writes to an address"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Memory"

    def do_activate(self, ctx):
        if global_config is None: return
        ea = ida_kernwin.get_screen_ea()
        if ea == idaapi.BADADDR:
            ida_kernwin.warning("Invalid address selected.")
            return

        # Guess size based on data type at address
        item_size = ida_bytes.get_item_size(ea)
        default_size = item_size if item_size > 0 else (8 if ScriptGenerator(global_config).is_64bit else 4)

        size_val = ida_kernwin.ask_long(default_size, f"Enter size (bytes) to monitor at {ea:#x}:")
        if size_val is None or size_val <= 0:
            log_info("Memory trace cancelled or invalid size.")
            return

        gen = ScriptGenerator(global_config)
        gen.generate_memory_trace_to_file(ea, size_val)

    def update(self, ctx):
        # Enable in Disassembly, Hex View, Local Types, Pseudocode
        # IDA 9.0: Replace BWN_STRUCTS with BWN_LOCTYPS, BWN_DUMP with BWN_HEXVIEW_T
        if ctx.widget_type in (ida_kernwin.BWN_DISASM, ida_kernwin.BWN_HEXVIEW, # Changed
                               ida_kernwin.BWN_LOCTYPS, # Changed
                               ida_kernwin.BWN_PSEUDOCODE) and global_config is not None:
            ida_kernwin.attach_action_to_popup(ctx.widget, None, self.name, self.menu_path + "/")
            return ida_kernwin.AST_ENABLE_FOR_WIDGET
        return ida_kernwin.AST_DISABLE_FOR_WIDGET


# --- Tier 2 Actions Implementation ---
class GenerateFunctionHookWithBacktrace(IDAFridaMenuAction):
    description = "Generate Hook with Backtrace"
    tooltip = "Generate function hook script including call stack backtrace"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Generate Hook"

    def do_activate(self, ctx):
        if global_config is None: return
        funcs = _get_functions_from_context(ctx)
        if not funcs: return
        gen = ScriptGenerator(global_config)
        gen.generate_func_hook_with_backtrace_to_file(funcs)

# --- Libc Tracer Base and Specific Actions ---
class GenerateLibcTracer(IDAFridaMenuAction):
    # Base class for Libc tracers
    libc_func_name = "OVERRIDE_ME"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Libc Tracers"
    tooltip = "Generate Frida script to trace a common libc function" # Generic tooltip

    def do_activate(self, ctx):
        if global_config is None: return
        if not self.libc_func_name or self.libc_func_name == "OVERRIDE_ME":
            log_error("Libc function name not set for action.")
            return
        gen = ScriptGenerator(global_config)
        gen.generate_libc_tracer_to_file(self.libc_func_name)

    def update(self, ctx):
        # Enable everywhere standard actions are enabled
        # Corrected super call to the direct parent (IDAFridaMenuAction)
        res = super().update(ctx)
        if res == ida_kernwin.AST_ENABLE_FOR_WIDGET:
            ida_kernwin.attach_action_to_popup(ctx.widget, None, self.name, self.menu_path + "/")
        return res

class TraceStrcpy(GenerateLibcTracer): description = "strcpy"; libc_func_name = "strcpy"; tooltip = "Trace calls to strcpy"
class TraceMemcpy(GenerateLibcTracer): description = "memcpy"; libc_func_name = "memcpy"; tooltip = "Trace calls to memcpy"
class TraceStrcmp(GenerateLibcTracer): description = "strcmp"; libc_func_name = "strcmp"; tooltip = "Trace calls to strcmp"
class TraceMalloc(GenerateLibcTracer): description = "malloc"; libc_func_name = "malloc"; tooltip = "Trace calls to malloc"
class TraceFree(GenerateLibcTracer): description = "free"; libc_func_name = "free"; tooltip = "Trace calls to free"
class TraceOpen(GenerateLibcTracer): description = "open / open64"; libc_func_name = "open"; tooltip = "Trace calls to open/open64"
class TraceRead(GenerateLibcTracer): description = "read"; libc_func_name = "read"; tooltip = "Trace calls to read"
class TraceWrite(GenerateLibcTracer): description = "write"; libc_func_name = "write"; tooltip = "Trace calls to write"


# --- Tier 3 Actions Implementation ---
class GenerateModifiableFunctionHook(IDAFridaMenuAction):
    description = "Generate Modifiable Hook"
    tooltip = "Generate function hook with placeholders for modifying args/retval"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Generate Hook"

    def do_activate(self, ctx):
        if global_config is None: return
        funcs = _get_functions_from_context(ctx)
        if not funcs: return
        gen = ScriptGenerator(global_config)
        gen.generate_modifiable_func_hook_to_file(funcs)

class GenerateMemoryScanScript(IDAFridaMenuAction):
    description = "Generate Memory Scan Script..."
    tooltip = "Generate Frida script to scan process memory for a pattern"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Memory"

    def do_activate(self, ctx):
        if global_config is None: return
        # Get pattern
        pattern = ida_kernwin.ask_str("", ida_kernwin.HIST_SRCH, "Enter search pattern (e.g., '41 42 ?? 44' or 'MyString'):")
        if not pattern: return log_info("Memory scan cancelled.")
        # Get scope
        default_module = ScriptGenerator.get_idb_filename()
        module_name = ida_kernwin.ask_str(default_module, ida_kernwin.HIST_FILE, "Module name (or empty for all process memory):")
        module_name = module_name.strip() if module_name is not None else ""
        # Get protection
        protection = ida_kernwin.ask_str("r-x", ida_kernwin.HIST_CMD, "Memory protection (e.g., 'rwx', 'r-x', 'rw-'):")
        protection = protection.strip() if protection is not None else "r-x"

        gen = ScriptGenerator(global_config)
        gen.generate_memory_scan_to_file(pattern, module_name, protection)

    def update(self, ctx):
        # Enable everywhere standard actions are enabled
        # Corrected super call to the direct parent (IDAFridaMenuAction)
        res = super().update(ctx)
        if res == ida_kernwin.AST_ENABLE_FOR_WIDGET:
            ida_kernwin.attach_action_to_popup(ctx.widget, None, self.name, self.menu_path + "/")
        return res

class GenerateConditionalFunctionHook(IDAFridaMenuAction):
    description = "Generate Conditional Hook"
    tooltip = "Generate function hook with placeholders for conditional execution"
    menu_path = f"{IDAFridaMenuAction.TOP_MENU_PATH}/Generate Hook"

    def do_activate(self, ctx):
        if global_config is None: return
        funcs = _get_functions_from_context(ctx)
        if not funcs: return
        gen = ScriptGenerator(global_config)
        gen.generate_conditional_func_hook_to_file(funcs)


############################################################################
# IDA Plugin Registration Class
############################################################################

class IDAFridaPlugin(ida_idaapi.plugin_t):
    flags = ida_idaapi.PLUGIN_KEEP # Keep loaded until IDA exits
    comment = PLUGIN_COMMENT
    help = PLUGIN_HELP
    wanted_name = PLUGIN_WANTED_NAME
    wanted_hotkey = PLUGIN_WANTED_HOTKEY

    def init(self):
        """Called when IDA loads the plugin."""
        global global_config

        # Check for minimum IDA version if necessary
        # if ida_kernwin.get_kernel_version() < "9.0":
        #     log_error("This plugin requires IDA Pro 9.0 or later.")
        #     return ida_idaapi.PLUGIN_SKIP

        log_info(f"Initializing {PLUGIN_NAME} v{PLUGIN_VERSION}...")

        # Initialize configuration (now uses NetNode)
        try:
             global_config = Configuration()
        except Exception as e:
             log_error("Failed to initialize configuration", e)
             return ida_idaapi.PLUGIN_SKIP # Skip loading if config fails

        # Register actions
        try:
            action_manager.initialize()
            log_info(f"{PLUGIN_NAME} initialized successfully.")
            ida_kernwin.msg(f"{PLUGIN_NAME} loaded. Right-click for actions.\n")
            return ida_idaapi.PLUGIN_KEEP # Keep plugin loaded
        except Exception as e:
            log_error("Failed to register actions during init", e)
            action_manager.finalize() # Attempt cleanup
            return ida_idaapi.PLUGIN_SKIP # Skip loading if actions fail

    def run(self, arg):
        """Called when the plugin is invoked via hotkey or menu."""
        ida_kernwin.msg(f"{PLUGIN_NAME}: Use right-click context menus for actions.\n")

    def term(self):
        """Called when IDA unloads the plugin or terminates."""
        log_info(f"Terminating {PLUGIN_NAME}...")
        try:
            action_manager.finalize()
            # No explicit config saving needed for NetNode on term()
        except Exception as e:
            log_error("Error during plugin termination", e)
        log_info(f"{PLUGIN_NAME} terminated.")
        # ida_kernwin.msg(f"{PLUGIN_NAME} unloaded.\n") # Optional


############################################################################
# Plugin Entry Point
############################################################################

def PLUGIN_ENTRY():
    """Required plugin entry point for IDA."""
    return IDAFridaPlugin()


############################################################################
# Main Execution Guard (for running script outside IDA)
############################################################################

if __name__ == "__main__":
    print("-" * 60)
    print(f"This script defines the '{PLUGIN_NAME}' IDA Pro plugin.")
    print(f"Version: {PLUGIN_VERSION}")
    print(f"Description: {PLUGIN_COMMENT}")
    print("-" * 60)
    print("This script must be run from within IDA Pro.")
    print("Copy it to your IDA plugins directory and restart IDA or use Shift+F2.")
    print("-" * 60)
