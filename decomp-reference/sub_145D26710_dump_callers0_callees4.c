// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x145D26710 (sub_145D26710)
// Caller Depth: 0
// Callee/Ref Depth: 4
// Total Functions Found: 32
// ------------------------------------------------------------

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402B1640 (0x1402B1640) ---
void __fastcall sub_1402B1640(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: sub_1402B1640 (0x1402B1640) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: NtCurrentTeb_ww_0 (0x1402E2480) ---
__int64 NtCurrentTeb_ww_0()
{
  return *(unsigned __int8 *)(NtCurrentTeb_w() + 0x12D);
}

// --- End Function: NtCurrentTeb_ww_0 (0x1402E2480) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_1403335B0 (0x1403335B0) ---
__int64 __fastcall sub_1403335B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_1403335B0 (0x1403335B0) ---

// --- Function: sub_14033B1A0 (0x14033B1A0) ---
_QWORD *__fastcall sub_14033B1A0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_35;
  if ( n0xFFFF_35 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "IVehicle");
    n0xFFFF_35 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033B1A0 (0x14033B1A0) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1 & 0xFFFFFFFFFFFFLL, 0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: p_p_p_sub_140384A94 (0x140384A94) ---
void __fastcall p_p_p_sub_140384A94(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
}

// --- End Function: p_p_p_sub_140384A94 (0x140384A94) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 + 0xFFFFFFFA;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 0xC0LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1404232A0 (0x1404232A0) ---
_QWORD *__fastcall sub_1404232A0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( sub_14030EC00(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_6;
    if ( n0xFFFF_6 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v9,
                            "IAttachableComponent");
      n0xFFFF_6 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1404232A0 (0x1404232A0) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_141D17630 (0x141D17630) ---
// attributes: thunk
__int64 __fastcall sub_141D17630(__int64 a1)
{
  return sub_1403335B0(a1);
}

// --- End Function: sub_141D17630 (0x141D17630) ---

// --- Function: sub_1425D69E0 (0x1425D69E0) ---
_QWORD *__fastcall sub_1425D69E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n257; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n257_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n257 = n257_0;
  if ( n257_0 == (__int16)0xFFFF )
  {
    n257 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                       qword_149B4FC88,
                       &v9,
                       "SCItemWeaponComponent");
    n257_0 = n257;
  }
  n257_1 = n257;
  v6 = *(_QWORD *)v4(a1, &v10, &n257_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D69E0 (0x1425D69E0) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || sub_140539D80() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: sub_145C78B90 (0x145C78B90) ---
__int64 __fastcall sub_145C78B90(__int64 a1)
{
  __int64 v2; // [rsp+20h] [rbp-38h]
  __int64 v3; // [rsp+28h] [rbp-30h] BYREF
  __int64 v4; // [rsp+30h] [rbp-28h]
  unsigned __int64 v5; // [rsp+38h] [rbp-20h]
  _QWORD v6[3]; // [rsp+40h] [rbp-18h] BYREF

  _StarEngineModule__(0);
  v5 = *(_QWORD *)(a1 + 8);
  sub_1404232A0(v6, v5);
  v6[1] = v6[0];
  v3 = v6[0];
  if ( AssetMeta::HasActorSubresource(&v3) )
    v2 = v3 & 0xFFFFFFFFFFFFLL;
  else
    v2 = 0;
  if ( v2 && (v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x608LL))(v2)) != 0 )
    return v4;
  else
    return 0;
}

// --- End Function: sub_145C78B90 (0x145C78B90) ---

// --- Function: sub_145C7AAE0 (0x145C7AAE0) ---
_QWORD *__fastcall sub_145C7AAE0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rax
  __int64 v4; // [rsp+20h] [rbp-38h]
  _QWORD *v5; // [rsp+28h] [rbp-30h]
  _BYTE v6[8]; // [rsp+40h] [rbp-18h] BYREF
  __int64 v7; // [rsp+48h] [rbp-10h] BYREF

  v4 = sub_145C78B90(a1);
  if ( v4 )
  {
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v4 + 0xD8LL))(v4, v6);
  }
  else
  {
    sub_1402B1640(&v7);
    v5 = v2;
  }
  *a2 = *v5;
  return a2;
}

// --- End Function: sub_145C7AAE0 (0x145C7AAE0) ---

// --- Function: sub_145C896A0 (0x145C896A0) ---
__int64 __fastcall sub_145C896A0(__int64 a1)
{
  return *(unsigned __int8 *)(sub_141D17630(a1) + 0x19F1);
}

// --- End Function: sub_145C896A0 (0x145C896A0) ---

// --- Function: sub_145D26710 (0x145D26710) ---
char __fastcall sub_145D26710(__int64 a1, unsigned __int64 a2)
{
  bool v4; // al
  unsigned __int64 v5; // rsi
  __int64 (__fastcall *v6)(unsigned __int64, __int64 *, __int64 *); // r15
  __int16 n257; // ax
  __int64 v8; // r15
  __int64 v9; // rsi
  unsigned __int64 *v10; // rax
  _QWORD *v11; // rax
  __int64 *v12; // rax
  unsigned __int64 v13; // rsi
  __int64 (__fastcall *v14)(unsigned __int64, __int64 *, __int64 *); // r15
  __int16 n0xFFFF; // ax
  __int64 v16; // rsi
  __int64 v17; // rax
  __int16 n4; // cx
  __int16 n0xFFFF_1; // ax
  __int64 v20; // [rsp+20h] [rbp-18h] BYREF
  _BYTE v21[16]; // [rsp+28h] [rbp-10h] BYREF
  __int64 v22; // [rsp+70h] [rbp+38h] BYREF
  unsigned __int64 v23; // [rsp+78h] [rbp+40h] BYREF
  __int64 v24; // [rsp+80h] [rbp+48h] BYREF
  __int64 v25; // [rsp+88h] [rbp+50h] BYREF

  v23 = a2;
  v22 = a1;
  if ( is_valid_handle_typeA(&v22) )
  {
    if ( !sub_14030EC00(&v23) )
      return (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x580LL))(
               a1 & 0xFFFFFFFFFFFFLL,
               4) == 0;
    v4 = sub_145D28790(v23);
    v5 = v23 & 0xFFFFFFFFFFFFLL;
    v6 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *, __int64 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    if ( v4 )
    {
      n257 = n257_0;
      if ( n257_0 == (__int16)0xFFFF )
      {
        n257 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                     + 0x10LL))(
                           qword_149B4FC88,
                           &v25,
                           "SCItemWeaponComponent");
        n257_0 = n257;
      }
      LOWORD(v24) = n257;
      v8 = *(_QWORD *)v6(v5, &v20, &v24);
      v24 = v8;
      if ( is_valid_handle_typeA(&v24) )
      {
        v9 = v8 & 0xFFFFFFFFFFFFLL;
        if ( !(unsigned __int8)sub_145C896A0(v8 & 0xFFFFFFFFFFFFLL) )
        {
          v10 = sub_145C7AAE0(v9, &v24);
          if ( sub_14030EC00(v10) )
          {
            v11 = sub_145C7AAE0(v9, &v24);
            v12 = sub_14033B1A0(*v11 & 0xFFFFFFFFFFFFLL, &v25);
            if ( AssetMeta::HasActorSubresource(v12) )
              return (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x580LL))(
                       a1 & 0xFFFFFFFFFFFFLL,
                       0x10) == 0;
          }
LABEL_20:
          if ( !*(_DWORD *)(qword_149E7E430 + 0x264) )
            return (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x580LL))(
                     a1 & 0xFFFFFFFFFFFFLL,
                     1) == 0;
        }
      }
      else
      {
        v13 = v23 & 0xFFFFFFFFFFFFLL;
        v14 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *, __int64 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL)
                                                                               + 0x340LL);
        n0xFFFF = n0xFFFF_91;
        if ( n0xFFFF_91 == (__int16)0xFFFF )
        {
          n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                          + 0x10LL))(
                                qword_149B4FC88,
                                &v25,
                                "SCItemConsumable");
          n0xFFFF_91 = n0xFFFF;
        }
        LOWORD(v24) = n0xFFFF;
        v16 = *(_QWORD *)v14(v13, &v20, &v24);
        v24 = v16;
        if ( !v16 )
          goto LABEL_20;
        v17 = sub_1403B4B50(v16 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(v17 + 4);
        if ( n4 == 4 || *(_WORD *)(v17 + 2) != (HIWORD(v16) & 0xFFF) )
          goto LABEL_20;
        if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v24) )
          goto LABEL_20;
      }
    }
    else
    {
      n0xFFFF_1 = n0xFFFF_28;
      if ( n0xFFFF_28 == (__int16)0xFFFF )
      {
        n0xFFFF_1 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                          + 0x10LL))(
                                qword_149B4FC88,
                                &v25,
                                "EntityComponentCarryable");
        n0xFFFF_28 = n0xFFFF_1;
      }
      LOWORD(v24) = n0xFFFF_1;
      v20 = *(_QWORD *)v6(v5, (__int64 *)v21, &v24);
      if ( !Handle::IsValid(&v20) )
        return (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x580LL))(
                 a1 & 0xFFFFFFFFFFFFLL,
                 0x100) == 0;
    }
  }
  return 1;
}

// --- End Function: sub_145D26710 (0x145D26710) ---

// --- Function: sub_145D28790 (0x145D28790) ---
bool __fastcall sub_145D28790(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  __int64 (__fastcall *v2)(unsigned __int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v4; // rbx
  __int64 v5; // rax
  __int16 n4; // cx
  unsigned __int64 v7; // rbx
  __int64 (__fastcall *v8)(unsigned __int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF_2; // ax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int16 n4_1; // cx
  unsigned __int64 v13; // rbx
  __int64 (__fastcall *v14)(unsigned __int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF_3; // ax
  __int64 v16; // rbx
  __int64 v17; // rax
  __int16 n4_2; // cx
  __int64 *v19; // rax
  _BYTE v21[8]; // [rsp+20h] [rbp-18h] BYREF
  __int64 v22; // [rsp+28h] [rbp-10h] BYREF
  unsigned __int64 v23; // [rsp+70h] [rbp+38h] BYREF
  __int16 n0xFFFF_1; // [rsp+78h] [rbp+40h] BYREF
  char v25; // [rsp+80h] [rbp+48h] BYREF
  __int64 v26; // [rsp+88h] [rbp+50h] BYREF

  v23 = a1;
  if ( !sub_14030EC00(&v23) )
    return 0;
  v1 = v23 & 0xFFFFFFFFFFFFLL;
  v2 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF = n0xFFFF_71;
  if ( n0xFFFF_71 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v25,
                          "SCMeleeWeapon");
    n0xFFFF_71 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v4 = *(_QWORD *)v2(v1, v21, &n0xFFFF_1);
  v26 = v4;
  if ( v4 )
  {
    v5 = sub_1403B4B50(v4 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v5 + 4);
    if ( n4 != 4
      && *(_WORD *)(v5 + 2) == (HIWORD(v4) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_142714E30(&v26)) )
    {
      return 1;
    }
  }
  v7 = v23 & 0xFFFFFFFFFFFFLL;
  v8 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF_2 = n0xFFFF_72;
  if ( n0xFFFF_72 == (__int16)0xFFFF )
  {
    n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v25,
                            "SCItemExplosive");
    n0xFFFF_72 = n0xFFFF_2;
  }
  n0xFFFF_1 = n0xFFFF_2;
  v10 = *(_QWORD *)v8(v7, v21, &n0xFFFF_1);
  v26 = v10;
  if ( v10 )
  {
    v11 = sub_1403B4B50(v10 & 0xFFFFFFFFFFFFLL);
    n4_1 = *(_WORD *)(v11 + 4);
    if ( n4_1 != 4
      && *(_WORD *)(v11 + 2) == (HIWORD(v10) & 0xFFF)
      && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_142714E30(&v26)) )
    {
      return 1;
    }
  }
  v13 = v23 & 0xFFFFFFFFFFFFLL;
  v14 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF_3 = n0xFFFF_73;
  if ( n0xFFFF_73 == (__int16)0xFFFF )
  {
    n0xFFFF_3 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v25,
                            "EntityComponentTriggerableDevices");
    n0xFFFF_73 = n0xFFFF_3;
  }
  n0xFFFF_1 = n0xFFFF_3;
  v16 = *(_QWORD *)v14(v13, v21, &n0xFFFF_1);
  v26 = v16;
  if ( v16 )
  {
    v17 = sub_1403B4B50(v16 & 0xFFFFFFFFFFFFLL);
    n4_2 = *(_WORD *)(v17 + 4);
    if ( n4_2 != 4
      && *(_WORD *)(v17 + 2) == (HIWORD(v16) & 0xFFF)
      && (n4_2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v26)) )
    {
      return 1;
    }
  }
  v19 = sub_1425D69E0(v23 & 0xFFFFFFFFFFFFLL, &v22);
  return is_valid_handle_typeA(v19);
}

// --- End Function: sub_145D28790 (0x145D28790) ---

