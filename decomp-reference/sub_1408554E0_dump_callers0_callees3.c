// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1408554E0 (sub_1408554E0)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 38
// ------------------------------------------------------------

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall sub_1402A3D30(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
// // A wrapper function for allocWithProfilerInfo that allocates memory // without
// providing specific profiler information. It simply forwards // the allocation
// size to the main allocation function with a null // profiler context. // //
// Parameters: //   allocSize: The size of memory in bytes to allocate. // //
// Returns: //   A pointer to the newly allocated memory block, or nullptr if
// allocation fails.
__int64 __fastcall allocWithProfilerInfo_w(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 get_thread_context_ptr()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: rw_lock_release_read_lock (0x1402D2790) ---
// Releases a read lock on a read-write lock. If the current thread is the
// recursive owner, it decrements the recursive count. Otherwise, it atomically
// decrements the main lock state. If the lock state transitions to indicate no
// more readers and pending write locks, it dispatches to a contention handler.
unsigned __int64 __fastcall rw_lock_release_read_lock(__int64 p_rw_lock_state)
{
  unsigned __int64 thread_context_ptr; // rax
  unsigned __int64 lock_state_after_decrement; // rdx

  thread_context_ptr = get_thread_context_ptr();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(thread_context_ptr + 0x18)
    && (thread_context_ptr = *(unsigned int *)(p_rw_lock_state + 0x14), (_DWORD)thread_context_ptr) )
  {
    thread_context_ptr = (unsigned int)(thread_context_ptr - 1);
    *(_DWORD *)(p_rw_lock_state + 0x14) = thread_context_ptr;
  }
  else
  {
    lock_state_after_decrement = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (lock_state_after_decrement & 0x3FF) == 0 )
    {
      thread_context_ptr = 0xFFFF0000FFC00000uLL;
      if ( (lock_state_after_decrement & 0xFFFF0000FFC00000uLL) != 0 )
        return rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, lock_state_after_decrement);
    }
  }
  return thread_context_ptr;
}

// --- End Function: rw_lock_release_read_lock (0x1402D2790) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 status_bits; // rax

  if ( qword_149B3B1F0 )
    status_bits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    status_bits = 1;
  if ( !qword_149B3B208 )
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)status_bits & 0xFFFFFFF7;
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_1403515F0 (0x1403515F0) ---
void __fastcall sub_1403515F0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-18h]
  __int64 n0xB0; // [rsp+90h] [rbp-10h]
  __int64 n0xA8; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  LODWORD(v9) = a6;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 1u, a5, v9, a7, a8);
}

// --- End Function: sub_1403515F0 (0x1403515F0) ---

// --- Function: sub_1403C6650 (0x1403C6650) ---
__int64 __fastcall sub_1403C6650(unsigned __int16 a1)
{
  int v1; // ecx
  int v2; // ecx

  v1 = (a1 ^ (a1 << 8)) & 0xFF00FF;
  v2 = ((v1 ^ (0x10 * v1)) & 0xF0F0F0F ^ (4 * ((v1 ^ (0x10 * v1)) & 0xF0F0F0F))) & 0x33333333;
  return (v2 ^ (2 * v2)) & 0x55555555;
}

// --- End Function: sub_1403C6650 (0x1403C6650) ---

// --- Function: rw_lock_acquire_read_lock_dispatch (0x1403CB300) ---
// Dispatches to either a profiled read lock acquisition function
// (`rw_lock_acquire_read_lock_profiled`) or a standard, unprofiled one
// (`rw_lock_acquire_read_lock_unprofiled`). The choice depends on a boolean flag
// (`is_profiled_mode`), a debug flag within the thread context (at offset `0x1C`),
// and the availability of the global environment (`gEnv`).
double __fastcall rw_lock_acquire_read_lock_dispatch(
        __int64 p_rw_lock_state,
        signed __int64 current_lock_value,
        const char *caller_name,
        const char *lock_name,
        char is_profiled_mode)
{
  if ( is_profiled_mode && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_read_lock_profiled(p_rw_lock_state, current_lock_value, caller_name, lock_name);
  else
    return rw_lock_acquire_read_lock_unprofiled(p_rw_lock_state, current_lock_value, caller_name, lock_name);
}

// --- End Function: rw_lock_acquire_read_lock_dispatch (0x1403CB300) ---

// --- Function: rw_lock_acquire_read_lock_profiled (0x1403CB380) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended, it retries. Upon successful acquisition,
// it logs detailed profiling information, including timestamps, lock name, lock
// owner, and caller, using a dedicated profiling system.
double __fastcall rw_lock_acquire_read_lock_profiled(
        __int64 p_rw_lock_state,
        signed __int64 current_lock_value,
        const char *caller_name,
        const char *lock_name)
{
  __int64 p_profiler_system; // r14
  __int64 thread_context_ptr; // rax
  __int64 p_thread_data; // rsi
  unsigned int thread_id; // r15d
  unsigned __int64 new_lock_value_with_thread_id; // rdx
  bool is_exchange_successful; // zf
  signed __int64 current_lock_value_1; // rax
  __int16 profiler_flags; // ax
  signed __int64 current_lock_value_2; // rax
  const ULONG_PTR *lock_owner_name_string_ptr; // rdx
  double result; // xmm0_8
  _BYTE profiler_data_buffer[16]; // [rsp+30h] [rbp-29h] BYREF
  int profiler_event_type; // [rsp+40h] [rbp-19h] BYREF
  __int64 profiler_event_flags; // [rsp+44h] [rbp-15h]
  int profiler_event_level; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 start_timestamp; // [rsp+50h] [rbp-9h]
  unsigned __int64 end_timestamp; // [rsp+58h] [rbp-1h]
  __int64 profiler_data_ptr_1; // [rsp+60h] [rbp+7h]
  __int64 profiler_data_ptr_2; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  p_profiler_system = ::p_profiler_system;
  thread_context_ptr = get_thread_context_ptr();
  p_thread_data = *(_QWORD *)thread_context_ptr;
  thread_id = *(_DWORD *)(*(_QWORD *)thread_context_ptr + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
    p_profiler_system,
    profiler_data_buffer,
    &v27);
  if ( (current_lock_value & 0x200000) == 0 )
    return result;
  new_lock_value_with_thread_id = (unsigned __int64)thread_id << 0x20;
  while ( (current_lock_value & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(p_thread_data + 0x124) = WORD2(current_lock_value);
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value_with_thread_id | current_lock_value & 0xFFFF0000FFFFFFFFuLL,
                             current_lock_value);
    is_exchange_successful = current_lock_value == current_lock_value_1;
    current_lock_value = current_lock_value_1;
    if ( is_exchange_successful )
    {
      profiler_event_type = 0x1600;
      end_timestamp = 0;
      profiler_data_ptr_1 = 0;
      profiler_data_ptr_2 = 0;
      profiler_event_flags = 1;
      profiler_event_level = 2;
      start_timestamp = __rdtsc();
      isProfileFunctionsInitialized(
        &profiler_event_type,
        &::profiler_flags,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      profiler_flags = ::profiler_flags;
      goto LABEL_10;
    }
LABEL_7:
    if ( (current_lock_value & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(p_thread_data + 0x124) = 0xFFFFFFFF;
  current_lock_value_2 = _InterlockedCompareExchange64(
                           (volatile signed __int64 *)p_rw_lock_state,
                           current_lock_value | new_lock_value_with_thread_id,
                           current_lock_value);
  is_exchange_successful = current_lock_value == current_lock_value_2;
  current_lock_value = current_lock_value_2;
  if ( !is_exchange_successful )
    goto LABEL_7;
  profiler_event_type = 0x1600;
  end_timestamp = 0;
  profiler_data_ptr_1 = 0;
  profiler_data_ptr_2 = 0;
  profiler_event_flags = 1;
  profiler_event_level = 2;
  start_timestamp = __rdtsc();
  isProfileFunctionsInitialized(
    &profiler_event_type,
    &profiler_flags_0,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  profiler_flags = profiler_flags_0;
LABEL_10:
  HIWORD(profiler_event_type) = profiler_flags;
  qword_149B4B8B0("Lock: %s", lock_name);
  lock_owner_name_string_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(p_rw_lock_state + 8) )
    lock_owner_name_string_ptr = *(const ULONG_PTR **)(p_rw_lock_state + 8);
  qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr);
  qword_149B4B8B0("Caller: %s", caller_name);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(p_profiler_system, thread_id);
  end_timestamp = __rdtsc();
  return qword_149B4B878(&profiler_event_type);
}

// --- End Function: rw_lock_acquire_read_lock_profiled (0x1403CB380) ---

// --- Function: rw_lock_acquire_read_lock_unprofiled (0x1403CB5B0) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by a writer). It then attempts to atomically set the read lock flag using
// `_InterlockedCompareExchange64`. Upon successful acquisition, it logs basic
// information about the lock, its owner, and the caller. This version does not
// include detailed performance profiling.
double __fastcall rw_lock_acquire_read_lock_unprofiled(
        __int64 p_rw_lock_state,
        signed __int64 rw_lock_state_2,
        const char *caller_name,
        const char *lock_name)
{
  signed __int64 rw_lock_state; // rbx
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  int *p_profiler_event_type; // rcx
  int new_lock_value; // edi
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_3; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_2; // rdx
  double result; // xmm0_8
  int rw_lock_state_1; // [rsp+30h] [rbp-69h] BYREF
  _DWORD lock_state_val_2[3]; // [rsp+34h] [rbp-65h] BYREF
  int profiler_event_type_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 profiler_event_flags_1; // [rsp+44h] [rbp-55h]
  int profiler_event_level_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 start_timestamp_1; // [rsp+50h] [rbp-49h]
  unsigned __int64 end_timestamp_1; // [rsp+58h] [rbp-41h]
  __int64 profiler_data_ptr_1_1; // [rsp+60h] [rbp-39h]
  __int64 profiler_data_ptr_2_1; // [rsp+68h] [rbp-31h]
  int profiler_event_type_2; // [rsp+90h] [rbp-9h] BYREF
  __int64 profiler_event_flags_2; // [rsp+94h] [rbp-5h]
  int profiler_event_level_2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 start_timestamp_2; // [rsp+A0h] [rbp+7h]
  unsigned __int64 end_timestamp_2; // [rsp+A8h] [rbp+Fh]
  __int64 profiler_data_ptr_1_2; // [rsp+B0h] [rbp+17h]
  __int64 profiler_data_ptr_2_2; // [rsp+B8h] [rbp+1Fh]

  if ( (rw_lock_state_2 & 0x200000) != 0 )
  {
    rw_lock_state = rw_lock_state_2;
    while ( 1 )
    {
      if ( (rw_lock_state & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)p_profiler_system + 0x128LL))(
          p_profiler_system,
          p_rw_lock_state);
      if ( (rw_lock_state & 0x100000) != 0 )
        break;
      new_lock_value = rw_lock_state | 0x100000;
      rw_lock_state_3 = _InterlockedCompareExchange64(
                          (volatile signed __int64 *)p_rw_lock_state,
                          rw_lock_state | 0x100000,
                          rw_lock_state);
      is_exchange_successful = rw_lock_state == rw_lock_state_3;
      rw_lock_state = rw_lock_state_3;
      if ( is_exchange_successful )
      {
        profiler_event_type_2 = 0x1600;
        profiler_event_flags_2 = 1;
        profiler_event_level_2 = 2;
        end_timestamp_2 = 0;
        profiler_data_ptr_1_2 = 0;
        profiler_data_ptr_2_2 = 0;
        start_timestamp_2 = __rdtsc();
        isProfileFunctionsInitialized(
          &profiler_event_type_2,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(profiler_event_type_2) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", lock_name);
        lock_owner_name_string_ptr_2 = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(p_rw_lock_state + 8) )
          lock_owner_name_string_ptr_2 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
        qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_2);
        qword_149B4B8B0("Caller: %s", caller_name);
        lock_state_val_2[0] = new_lock_value;
        qword_149B3B480(p_rw_lock_state, lock_state_val_2, 4, 0xFFFFFFFFLL);
        rw_lock_state = *(_QWORD *)p_rw_lock_state;
        p_profiler_event_type = &profiler_event_type_2;
        end_timestamp_2 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (rw_lock_state & 0x200000) == 0 )
        return result;
    }
    profiler_event_type_1 = 0x1600;
    profiler_event_flags_1 = 1;
    profiler_event_level_1 = 2;
    end_timestamp_1 = 0;
    profiler_data_ptr_1_1 = 0;
    profiler_data_ptr_2_1 = 0;
    start_timestamp_1 = __rdtsc();
    isProfileFunctionsInitialized(
      &profiler_event_type_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(profiler_event_type_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", lock_name);
    lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(p_rw_lock_state + 8) )
      lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
    qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
    qword_149B4B8B0("Caller: %s", caller_name);
    rw_lock_state_1 = rw_lock_state;
    qword_149B3B480(p_rw_lock_state, &rw_lock_state_1, 4, 0xFFFFFFFFLL);
    rw_lock_state = *(_QWORD *)p_rw_lock_state;
    p_profiler_event_type = &profiler_event_type_1;
    end_timestamp_1 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_profiler_event_type);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: rw_lock_acquire_read_lock_unprofiled (0x1403CB5B0) ---

// --- Function: rw_lock_handle_release_contention (0x1403CB820) ---
// Handles the release of a read-write lock when contention or specific lock flags
// are present. It continuously attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`. Depending on the resulting lock state, it may
// trigger further release operations (e.g., waking waiting threads via
// `qword_149B3B488`) or update thread context information related to lock
// ownership and counts.
__int64 __fastcall rw_lock_handle_release_contention(
        volatile signed __int64 *p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  unsigned __int64 new_lock_value; // rdx
  unsigned int lock_owner_thread_id; // r8d
  __int64 current_lock_value_1; // rax
  unsigned __int64 lock_thread_id_high_word; // rbx
  int thread_context_info_1; // [rsp+60h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+68h] [rbp+10h] BYREF
  __int64 thread_context_ptr_1; // [rsp+70h] [rbp+18h] BYREF
  __int64 thread_context_ptr_2; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value;
    if ( (current_lock_value & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
        p_profiler_system,
        &thread_context_ptr_1,
        &thread_context_info_1);
      new_lock_value = current_lock_value & 0xFFFFFFFFFFFFLL;
      lock_owner_thread_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_1 - 1)) << 9)
                                       + thread_context_ptr_1
                                       + 0x124);
      if ( lock_owner_thread_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)lock_owner_thread_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(p_rw_lock_state, new_lock_value, current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    if ( (current_lock_value_1 & 0x3FF) != 0
      || (current_lock_value_1 & 0x200000) != 0
      || (current_lock_value_1 & 0xFFFF0000FFC00000uLL) == 0 )
    {
      return current_lock_value_1;
    }
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0xFFC00000) != 0 )
    return qword_149B3B488(p_rw_lock_state);
  current_lock_value_1 = 0xFFFF000000000000uLL;
  if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
      p_profiler_system,
      &thread_context_ptr_2,
      &thread_context_info_2);
    lock_thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)lock_thread_id_high_word & (thread_context_info_2 - 1)) << 9)
              + thread_context_ptr_2
              + 0x11C) = (unsigned __int16)(lock_thread_id_high_word + thread_context_info_2);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xD8LL))(
             p_profiler_system,
             (unsigned int)lock_thread_id_high_word);
  }
  return current_lock_value_1;
}

// --- End Function: rw_lock_handle_release_contention (0x1403CB820) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: rw_lock_acquire_write_lock_profiled (0x1403DCDF0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended (e.g., by readers or another writer), it
// waits. Upon successful acquisition, it logs detailed profiling information,
// including timestamps, lock name, lock owner, and caller, using a dedicated
// profiling system. It also sets the lock owner pointer at `p_rw_lock_state + 8`.
__int64 __fastcall rw_lock_acquire_write_lock_profiled(
        __int64 p_rw_lock_state,
        unsigned __int64 rw_lock_state,
        __int64 lock_owner_ptr,
        const char *caller_name,
        const char *lock_name)
{
  __int64 p_profiler_system; // r15
  __int64 thread_context_ptr; // rax
  __int64 p_thread_data; // rsi
  unsigned int thread_id; // r14d
  const char *lock_name_1; // r13
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_2; // rax
  __int64 lock_owner_ptr_2; // rax
  unsigned __int64 new_lock_value_with_thread_id; // rdx
  signed __int64 rw_lock_state_3; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  signed __int64 rw_lock_state_1; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int profiler_event_type_1; // [rsp+30h] [rbp-91h] BYREF
  __int64 profiler_event_flags_1; // [rsp+34h] [rbp-8Dh]
  int profiler_event_level_1; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 start_timestamp_1; // [rsp+40h] [rbp-81h]
  unsigned __int64 end_timestamp_1; // [rsp+48h] [rbp-79h]
  __int64 profiler_data_ptr_1_1; // [rsp+50h] [rbp-71h]
  __int64 profiler_data_ptr_2_1; // [rsp+58h] [rbp-69h]
  int n0x1600; // [rsp+80h] [rbp-41h] BYREF
  __int64 profiler_event_flags_2; // [rsp+84h] [rbp-3Dh]
  int n2; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 start_timestamp_2; // [rsp+90h] [rbp-31h]
  unsigned __int64 end_timestamp_2; // [rsp+98h] [rbp-29h]
  __int64 profiler_data_ptr_1_2; // [rsp+A0h] [rbp-21h]
  __int64 profiler_data_ptr_2_2; // [rsp+A8h] [rbp-19h]
  _BYTE profiler_data_buffer[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char profiler_data_buffer_char; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 lock_owner_ptr_1; // [rsp+130h] [rbp+6Fh]

  lock_owner_ptr_1 = lock_owner_ptr;
  p_profiler_system = ::p_profiler_system;
  thread_context_ptr = get_thread_context_ptr();
  p_thread_data = *(_QWORD *)thread_context_ptr;
  thread_id = *(_DWORD *)(*(_QWORD *)thread_context_ptr + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
    p_profiler_system,
    profiler_data_buffer,
    &profiler_data_buffer_char);
  lock_name_1 = lock_name;
  do
  {
    while ( (rw_lock_state & 0x2003FF) != 0 )
    {
      new_lock_value_with_thread_id = (unsigned __int64)thread_id << 0x30;
      if ( (rw_lock_state & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(p_thread_data + 0x124) = HIWORD(rw_lock_state);
        rw_lock_state_3 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            new_lock_value_with_thread_id | rw_lock_state & 0xFFFFFFFFFFFFLL,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_3;
        rw_lock_state = rw_lock_state_3;
        if ( is_exchange_successful )
        {
          profiler_event_type_1 = 0x1600;
          profiler_event_flags_1 = 1;
          profiler_event_level_1 = 2;
          end_timestamp_1 = 0;
          profiler_data_ptr_1_1 = 0;
          profiler_data_ptr_2_1 = 0;
          start_timestamp_1 = __rdtsc();
          isProfileFunctionsInitialized(
            &profiler_event_type_1,
            &word_149B3E394,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(profiler_event_type_1) = word_149B3E394;
          qword_149B4B8B0("Lock: %s", lock_name_1);
          lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
          qword_149B4B8B0("Caller: %s", caller_name);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(
            p_profiler_system,
            thread_id);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          thread_id = *(_DWORD *)(p_thread_data + 0x11C);
          end_timestamp_1 = __rdtsc();
          qword_149B4B878(&profiler_event_type_1);
        }
      }
      else
      {
        *(_DWORD *)(p_thread_data + 0x124) = 0xFFFFFFFF;
        rw_lock_state_1 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            rw_lock_state | new_lock_value_with_thread_id,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_1;
        rw_lock_state = rw_lock_state_1;
        if ( is_exchange_successful )
        {
          n0x1600 = 0x1600;
          profiler_event_flags_2 = 1;
          n2 = 2;
          end_timestamp_2 = 0;
          profiler_data_ptr_1_2 = 0;
          profiler_data_ptr_2_2 = 0;
          start_timestamp_2 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E398,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600) = word_149B3E398;
          qword_149B4B8B0("Lock: %s", lock_name_1);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", caller_name);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(
            p_profiler_system,
            thread_id);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          thread_id = *(_DWORD *)(p_thread_data + 0x11C);
          end_timestamp_2 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
    }
    rw_lock_state_2 = _InterlockedCompareExchange64(
                        (volatile signed __int64 *)p_rw_lock_state,
                        rw_lock_state | 0x200000,
                        rw_lock_state);
    is_exchange_successful = rw_lock_state == rw_lock_state_2;
    rw_lock_state = rw_lock_state_2;
  }
  while ( !is_exchange_successful );
  lock_owner_ptr_2 = lock_owner_ptr_1;
  *(_QWORD *)(p_rw_lock_state + 8) = lock_owner_ptr_1;
  return lock_owner_ptr_2;
}

// --- End Function: rw_lock_acquire_write_lock_profiled (0x1403DCDF0) ---

// --- Function: rw_lock_acquire_write_lock_unprofiled (0x1403DD0B0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by readers). It then attempts to atomically set the write lock flag or
// increment a write lock count using `_InterlockedCompareExchange64`. Upon
// successful acquisition, it logs basic information about the lock, its owner, and
// the caller. This version does not include detailed performance profiling. It
// also sets the lock owner pointer at `p_rw_lock_state + 8`.
signed __int64 __fastcall rw_lock_acquire_write_lock_unprofiled(
        __int64 p_rw_lock_state,
        signed __int64 rw_lock_state,
        __int64 lock_owner_ptr,
        const char *caller_name,
        const char *lock_name)
{
  char is_write_lock_incremented; // r14
  signed __int64 new_lock_value; // rcx
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_2; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  int lock_state_val_1; // esi
  signed __int64 rw_lock_state_1; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int rw_lock_state_3; // [rsp+38h] [rbp-81h] BYREF
  _DWORD lock_state_val_3[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int profiler_event_type_1; // [rsp+48h] [rbp-71h] BYREF
  __int64 profiler_event_flags_1; // [rsp+4Ch] [rbp-6Dh]
  int profiler_event_level_1; // [rsp+54h] [rbp-65h]
  unsigned __int64 start_timestamp_1; // [rsp+58h] [rbp-61h]
  unsigned __int64 end_timestamp_1; // [rsp+60h] [rbp-59h]
  __int64 profiler_data_ptr_1_1; // [rsp+68h] [rbp-51h]
  __int64 profiler_data_ptr_2_1; // [rsp+70h] [rbp-49h]
  int n0x1600; // [rsp+98h] [rbp-21h] BYREF
  __int64 profiler_event_flags_2; // [rsp+9Ch] [rbp-1Dh]
  int n2; // [rsp+A4h] [rbp-15h]
  unsigned __int64 start_timestamp_2; // [rsp+A8h] [rbp-11h]
  unsigned __int64 end_timestamp_2; // [rsp+B0h] [rbp-9h]
  __int64 profiler_data_ptr_1_2; // [rsp+B8h] [rbp-1h]
  __int64 profiler_data_ptr_2_2; // [rsp+C0h] [rbp+7h]

  is_write_lock_incremented = 0;
  do
  {
    while ( 1 )
    {
      if ( (rw_lock_state & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)p_profiler_system + 0x128LL))(
          p_profiler_system,
          p_rw_lock_state);
      if ( (rw_lock_state & 0x2003FF) == 0 )
        break;
      if ( is_write_lock_incremented )
      {
        profiler_event_type_1 = 0x1600;
        profiler_event_flags_1 = 1;
        profiler_event_level_1 = 2;
        end_timestamp_1 = 0;
        profiler_data_ptr_1_1 = 0;
        profiler_data_ptr_2_1 = 0;
        start_timestamp_1 = __rdtsc();
        isProfileFunctionsInitialized(
          &profiler_event_type_1,
          &word_149B3E38C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(profiler_event_type_1) = word_149B3E38C;
        qword_149B4B8B0("Lock: %s", lock_name);
        lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(p_rw_lock_state + 8) )
          lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
        qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
        qword_149B4B8B0("Caller: %s", caller_name);
        rw_lock_state_3 = rw_lock_state;
        qword_149B3B480(p_rw_lock_state, &rw_lock_state_3, 4, 0xFFFFFFFFLL);
        rw_lock_state = *(_QWORD *)p_rw_lock_state;
        end_timestamp_1 = __rdtsc();
        qword_149B4B878(&profiler_event_type_1);
      }
      else
      {
        lock_state_val_1 = rw_lock_state + 0x400000;
        rw_lock_state_1 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            rw_lock_state + 0x400000,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_1;
        rw_lock_state = rw_lock_state_1;
        if ( is_exchange_successful )
        {
          is_write_lock_incremented = 1;
          n0x1600 = 0x1600;
          profiler_event_flags_2 = 1;
          n2 = 2;
          end_timestamp_2 = 0;
          profiler_data_ptr_1_2 = 0;
          profiler_data_ptr_2_2 = 0;
          start_timestamp_2 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E390,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600) = word_149B3E390;
          qword_149B4B8B0("Lock: %s", lock_name);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", caller_name);
          lock_state_val_3[0] = lock_state_val_1;
          qword_149B3B480(p_rw_lock_state, lock_state_val_3, 4, 0xFFFFFFFFLL);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          end_timestamp_2 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
    }
    new_lock_value = (rw_lock_state | 0x200000) - 0x400000;
    if ( !is_write_lock_incremented )
      new_lock_value = rw_lock_state | 0x200000;
    rw_lock_state_2 = _InterlockedCompareExchange64(
                        (volatile signed __int64 *)p_rw_lock_state,
                        new_lock_value,
                        rw_lock_state);
    is_exchange_successful = rw_lock_state == rw_lock_state_2;
    rw_lock_state = rw_lock_state_2;
  }
  while ( !is_exchange_successful );
  *(_QWORD *)(p_rw_lock_state + 8) = lock_owner_ptr;
  return rw_lock_state_2;
}

// --- End Function: rw_lock_acquire_write_lock_unprofiled (0x1403DD0B0) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403DD380) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(
        __int64 p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  signed __int64 new_lock_value; // rdi
  unsigned int thread_context_owner_id; // edx
  signed __int64 current_lock_value_1; // rax
  __int64 p_profiler_system; // rdi
  __int64 thread_context_ptr_1; // r8
  int thread_context_owner_id_2; // ecx
  __int64 thread_context_ptr_2; // r8
  unsigned __int64 thread_id_high_word; // rbx
  const ULONG_PTR *default_lock_owner_ptr; // rax
  int thread_context_info_1; // [rsp+70h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+78h] [rbp+10h] BYREF
  __int64 thread_context_ptr_3; // [rsp+80h] [rbp+18h] BYREF
  __int64 thread_context_ptr_4; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value & 0xFFFFFFFFFFD003FFuLL;
    if ( (current_lock_value & 0xFFFF00100000LL) != 0 )
    {
      new_lock_value = current_lock_value & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (current_lock_value & 0xFFC003FF) == 0 && (current_lock_value & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_4,
        &thread_context_info_2);
      new_lock_value = current_lock_value & 0xFFFFFFD003FFLL;
      thread_context_owner_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_2 - 1)) << 9)
                                          + thread_context_ptr_4
                                          + 0x124);
      if ( thread_context_owner_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)thread_context_owner_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value,
                             current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0x3FF) != 0 )
  {
    if ( (current_lock_value & 0x100000) != 0 )
      qword_149B3B490(p_rw_lock_state);
    if ( (current_lock_value & 0xFFFF00000000LL) != 0 )
    {
      p_profiler_system = ::p_profiler_system;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_3,
        &thread_context_info_1);
      thread_context_ptr_1 = thread_context_ptr_3
                           + ((WORD2(current_lock_value) & (unsigned __int64)(unsigned int)(thread_context_info_1 - 1)) << 9);
      LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_1 + 0x124);
      *(_DWORD *)(thread_context_ptr_1 + 0x11C) = (unsigned __int16)(WORD2(current_lock_value) + thread_context_info_1);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      while ( (_DWORD)current_lock_value != 0xFFFFFFFF )
      {
        thread_context_owner_id_2 = (unsigned __int16)(current_lock_value + thread_context_info_1);
        thread_context_ptr_2 = thread_context_ptr_3
                             + ((unsigned __int64)((unsigned int)current_lock_value & (thread_context_info_1 - 1)) << 9);
        LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_2 + 0x124);
        *(_DWORD *)(thread_context_ptr_2 + 0x11C) = thread_context_owner_id_2;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      }
    }
  }
  else if ( (current_lock_value & 0xFFC00000) != 0 )
  {
    qword_149B3B488(p_rw_lock_state);
  }
  else if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
      ::p_profiler_system,
      &thread_context_ptr_3,
      &thread_context_info_1);
    thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)thread_id_high_word & (thread_context_info_1 - 1)) << 9)
              + thread_context_ptr_3
              + 0x11C) = (unsigned __int16)(thread_id_high_word + thread_context_info_1);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::p_profiler_system + 0xD8LL))(
      ::p_profiler_system,
      (unsigned int)thread_id_high_word);
  }
  default_lock_owner_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(p_rw_lock_state + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return default_lock_owner_ptr;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403DD380) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *thread_base_ctx_ptr; // rax
  unsigned __int64 *thread_base_ctx_ptr_1; // rcx
  unsigned __int64 n0xF; // rax

  thread_base_ctx_ptr = sub_1404B3EA0();
  thread_base_ctx_ptr_1 = thread_base_ctx_ptr;
  if ( !thread_base_ctx_ptr )
    return &ThreadLogContextSlot;
  n0xF = *thread_base_ctx_ptr;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&thread_base_ctx_ptr_1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_14056EE00 (0x14056EE00) ---
char __fastcall sub_14056EE00(_BYTE *a1, __int64 a2)
{
  char v4; // cl
  char result; // al

  if ( (a1[6] & 1) != 0 )
    sub_14056FD20();
  else
    sub_14056EEC0(a1);
  v4 = a1[6];
  result = v4 & 0xFE;
  a1[6] = v4 & 0xFE ^ (*(_BYTE *)(a2 + 6) | v4) & 1;
  return result;
}

// --- End Function: sub_14056EE00 (0x14056EE00) ---

// --- Function: sub_14056EE50 (0x14056EE50) ---
void __fastcall sub_14056EE50(_BYTE *a1, unsigned __int64 a2)
{
  _BYTE *v2; // r8
  unsigned __int8 v3; // cl
  unsigned __int8 v4; // r10
  unsigned __int8 v5; // al
  int v6; // edx

  v2 = a1;
  v3 = a1[6];
  if ( (v3 & 1) != 0 )
  {
    v4 = v2[7];
    if ( v4 >> 1 )
    {
      v5 = (a2 >> 5) - (v3 >> 1);
      if ( v5 < (unsigned __int8)(v4 >> 1) )
      {
        v6 = 1 << (0x1F - (a2 & 0x1F));
        if ( (v4 & 1) != 0 )
          v2 = (_BYTE *)(*(_QWORD *)v2 & 0xFFFFFFFFFFFFLL);
        *(_DWORD *)&v2[4 * v5] &= ~v6;
      }
    }
  }
  else
  {
    sub_140570260(v2);
  }
}

// --- End Function: sub_14056EE50 (0x14056EE50) ---

// --- Function: sub_14056EEC0 (0x14056EEC0) ---
char __fastcall sub_14056EEC0(_BYTE *a1, __int64 a2)
{
  unsigned __int8 v2; // al
  char v4; // r13
  unsigned __int8 v5; // al
  char v6; // r8
  unsigned __int8 v8; // di
  unsigned __int8 v9; // bp
  __int64 v10; // rax
  __int64 v11; // r8
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  int v14; // r10d
  unsigned int v15; // ecx
  unsigned __int8 v16; // al
  unsigned int v17; // r8d
  int v18; // eax
  unsigned int v19; // r8d
  int v20; // eax
  int v21; // ebx
  __int64 v23; // [rsp+60h] [rbp+8h]
  __int64 v24; // [rsp+68h] [rbp+10h]

  v2 = *(_BYTE *)(a2 + 6);
  v4 = v2 & 1;
  v5 = v2 >> 1;
  v6 = a1[7] >> 1;
  if ( v6 )
  {
    v8 = a1[6] >> 1;
    if ( v8 >= v5 )
      v8 = v5;
    v9 = v5 + (*(_BYTE *)(a2 + 7) >> 1);
    if ( v9 < (unsigned __int8)(v6 + (a1[6] >> 1)) )
      v9 = v6 + (a1[6] >> 1);
  }
  else
  {
    v8 = v5;
    v9 = v5 + (*(_BYTE *)(a2 + 7) >> 1);
  }
  LOBYTE(v10) = sub_14056F4A0(a1, v8, v9);
  if ( v8 < v9 )
  {
    v11 = v8;
    v23 = v8;
    v24 = 0;
    do
    {
      v12 = (unsigned __int8)a1[6];
      if ( v8 < (unsigned __int8)((unsigned __int8)v12 >> 1)
        || (v13 = v12 >> 1, v8 >= v13 + ((unsigned __int8)a1[7] >> 1)) )
      {
        v14 = 0;
      }
      else if ( (a1[7] & 1) != 0 )
      {
        v14 = *(_DWORD *)((*(_QWORD *)a1 & 0xFFFFFFFFFFFFLL) + 4 * (v11 - v13));
      }
      else
      {
        v14 = *(_DWORD *)&a1[4 * (v11 - v13)];
      }
      v15 = *(unsigned __int8 *)(a2 + 6);
      v16 = (unsigned __int8)v15 >> 1;
      if ( v4 )
      {
        if ( v8 < v16 || (v17 = v15 >> 1, v8 >= (v15 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
        {
          v18 = 0xFFFFFFFF;
        }
        else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
        {
          v18 = ~*(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v17));
        }
        else
        {
          v18 = ~*(_DWORD *)(a2 + 4 * (v8 - (unsigned __int64)v17));
        }
      }
      else if ( v8 < v16 || (v19 = v15 >> 1, v8 >= (v15 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
      {
        v18 = 0;
      }
      else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
      {
        v18 = *(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - (unsigned __int64)v19));
      }
      else
      {
        v18 = *(_DWORD *)(a2 + 4 * (v8 - (unsigned __int64)v19));
      }
      v20 = v14 | v18;
      v21 = ~v20;
      if ( !v4 )
        v21 = v20;
      v10 = sub_14056F3C0((__int64)a1);
      ++v8;
      v11 = ++v23;
      *(_DWORD *)(v10 + v24) = v21;
      v24 += 4;
    }
    while ( v8 < v9 );
  }
  return v10;
}

// --- End Function: sub_14056EEC0 (0x14056EEC0) ---

// --- Function: sub_14056F3C0 (0x14056F3C0) ---
__int64 __fastcall sub_14056F3C0(__int64 a1)
{
  if ( (*(_BYTE *)(a1 + 7) & 1) != 0 )
    return *(_QWORD *)a1 & 0xFFFFFFFFFFFFLL;
  else
    return a1;
}

// --- End Function: sub_14056F3C0 (0x14056F3C0) ---

// --- Function: sub_14056F4A0 (0x14056F4A0) ---
char __fastcall sub_14056F4A0(_BYTE *a1, unsigned __int8 a2, unsigned __int8 a3)
{
  _BYTE *v3; // r14
  _BYTE *v4; // rbx
  char v5; // r9
  unsigned __int8 v7; // r8
  bool v8; // cf
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // bp
  unsigned __int8 v11; // si
  char result; // al

  v3 = a1 + 6;
  v4 = a1;
  v5 = a2;
  v7 = a1[6] >> 1;
  v8 = v7 < a2;
  v9 = a3;
  if ( v8 )
    v5 = a1[6] >> 1;
  v10 = a1[7] >> 1;
  v11 = (a1[6] >> 1) - v5;
  if ( a3 < (unsigned __int8)(v7 + v10) )
    v9 = v7 + v10;
  sub_1405700C0(a1, v9 - v5, v7);
  if ( (v4[7] & 1) != 0 )
    v4 = (_BYTE *)(*(_QWORD *)v4 & 0xFFFFFFFFFFFFLL);
  memmove(&v4[4 * v10 + 4 * (unsigned __int64)v11 + 0xFFFFFFFC * v10], v4, 4LL * v10);
  memset(v4, 0, 4LL * v11);
  result = (*v3 - 2 * v11) ^ (*v3 ^ (*v3 - 2 * v11)) & 1;
  *v3 = result;
  return result;
}

// --- End Function: sub_14056F4A0 (0x14056F4A0) ---

// --- Function: sub_14056FD20 (0x14056FD20) ---
void __fastcall sub_14056FD20(__int64 a1, __int64 a2)
{
  unsigned __int8 v4; // di
  char v5; // r13
  unsigned __int8 v6; // r12
  __int64 v7; // r15
  __int64 v8; // rbp
  unsigned int v9; // ecx
  unsigned int v10; // r9d
  int v11; // r10d
  unsigned int v12; // ecx
  unsigned __int8 v13; // al
  unsigned int v14; // r9d
  int v15; // ebx
  unsigned int v16; // r9d

  v4 = *(_BYTE *)(a1 + 6) >> 1;
  v5 = *(_BYTE *)(a2 + 6) & 1;
  v6 = v4 + (*(_BYTE *)(a1 + 7) >> 1);
  if ( v4 < v6 )
  {
    v7 = 0;
    v8 = v4;
    do
    {
      v9 = *(unsigned __int8 *)(a1 + 6);
      if ( v4 < (unsigned __int8)((unsigned __int8)v9 >> 1)
        || (v10 = v9 >> 1, v4 >= (v9 >> 1) + (*(unsigned __int8 *)(a1 + 7) >> 1)) )
      {
        v11 = 0;
      }
      else if ( (*(_BYTE *)(a1 + 7) & 1) != 0 )
      {
        v11 = *(_DWORD *)((*(_QWORD *)a1 & 0xFFFFFFFFFFFFLL) + 4 * (v8 - v10));
      }
      else
      {
        v11 = *(_DWORD *)(a1 + 4 * (v8 - v10));
      }
      v12 = *(unsigned __int8 *)(a2 + 6);
      v13 = (unsigned __int8)v12 >> 1;
      if ( v5 )
      {
        if ( v4 < v13 || (v14 = v12 >> 1, v4 >= (v12 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
        {
          v15 = 0xFFFFFFFF;
        }
        else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
        {
          v15 = ~*(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v4 - (unsigned __int64)v14));
        }
        else
        {
          v15 = ~*(_DWORD *)(a2 + 4 * (v4 - (unsigned __int64)v14));
        }
      }
      else if ( v4 < v13 || (v16 = v12 >> 1, v4 >= (v12 >> 1) + (*(unsigned __int8 *)(a2 + 7) >> 1)) )
      {
        v15 = 0;
      }
      else if ( (*(_BYTE *)(a2 + 7) & 1) != 0 )
      {
        v15 = *(_DWORD *)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFLL) + 4 * (v4 - (unsigned __int64)v16));
      }
      else
      {
        v15 = *(_DWORD *)(a2 + 4 * (v4 - (unsigned __int64)v16));
      }
      ++v4;
      ++v8;
      *(_DWORD *)(sub_14056F3C0(a1) + v7) = v11 & ~v15;
      v7 += 4;
    }
    while ( v4 < v6 );
  }
}

// --- End Function: sub_14056FD20 (0x14056FD20) ---

// --- Function: sub_1405700C0 (0x1405700C0) ---
void __fastcall sub_1405700C0(_BYTE *a1, unsigned __int8 a2, unsigned __int8 a3)
{
  bool v5; // r13
  char v6; // r12
  _BYTE *v7; // r14
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // r15
  unsigned __int8 v10; // r15
  unsigned __int64 allocSize; // rbp
  _BYTE *v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int8 v14; // al

  v5 = a2 > 1u;
  v6 = a1[7] & 1;
  if ( v6 )
    v7 = (_BYTE *)(*(_QWORD *)a1 & 0xFFFFFFFFFFFFLL);
  else
    v7 = a1;
  v8 = a1[6] >> 1;
  v9 = a3;
  if ( a3 < v8 )
    v9 = v8;
  v10 = v9 - v8;
  if ( a2 <= 1u )
  {
    v13 = (unsigned __int64)a1;
  }
  else
  {
    allocSize = saturated_mul(a2, 4u);
    v12 = (_BYTE *)allocWithProfilerInfo_w(allocSize);
    v13 = (unsigned __int64)v12;
    if ( v12 )
      memset(v12, 0, allocSize);
    else
      v13 = 0;
  }
  v14 = a2;
  if ( (unsigned __int8)(a1[7] >> 1) < a2 )
    v14 = a1[7] >> 1;
  memmove((void *)v13, &v7[4 * v10], 4 * (v10 + (unsigned __int64)v14) - 4LL * v10);
  if ( v6 )
    sub_1402A3D30(v7);
  if ( a2 <= 1u )
  {
    if ( !a2 )
      *(_DWORD *)a1 = 0;
  }
  else
  {
    *(_QWORD *)a1 = v13 ^ (*(_QWORD *)a1 ^ v13) & 0xFFFF000000000000uLL;
  }
  a1[7] = v5 | (2 * a2);
}

// --- End Function: sub_1405700C0 (0x1405700C0) ---

// --- Function: sub_140570260 (0x140570260) ---
void __fastcall sub_140570260(_BYTE *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  char v3; // si
  __int64 v4; // rbx
  unsigned __int8 v5; // r8
  unsigned __int8 v6; // di

  v2 = a2 >> 5;
  v3 = 0x1F - (a2 & 0x1F);
  v4 = (__int64)a1;
  if ( a1[7] >= 2u )
  {
    sub_14056F4A0(a1, v2, v2 + 1);
    v6 = v2 - (*(_BYTE *)(v4 + 6) >> 1);
    if ( (*(_BYTE *)(v4 + 7) & 1) != 0 )
      v4 = *(_QWORD *)v4 & 0xFFFFFFFFFFFFLL;
    *(_DWORD *)(v4 + 4LL * v6) |= 1 << v3;
  }
  else
  {
    v5 = (2 * v2) | a1[6] & 1;
    a1[6] = v5;
    sub_1405700C0(a1, 1u, v5 >> 1);
    if ( (*(_BYTE *)(v4 + 7) & 1) != 0 )
      v4 = *(_QWORD *)v4 & 0xFFFFFFFFFFFFLL;
    *(_DWORD *)v4 = 1 << v3;
  }
}

// --- End Function: sub_140570260 (0x140570260) ---

// --- Function: sub_14083D860 (0x14083D860) ---
char __fastcall sub_14083D860(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned __int16 v4; // ax
  int v5; // r8d
  int v6; // eax
  float v7; // ecx

  if ( *a2 == a2[1] )
  {
    v4 = 1;
  }
  else
  {
    v4 = *(_WORD *)(*a2 + 8 * a1 + 6);
    if ( !v4 )
      return v4;
  }
  v5 = v4;
  v6 = (v4 & 0x7FFF) << 0xD;
  LODWORD(v7) = v6 + 0x38000000;
  if ( (v6 & 0xF800000) == 0xF800000 )
  {
    LODWORD(v7) = v6 + 0x70000000;
  }
  else if ( (v6 & 0xF800000) == 0 )
  {
    v7 = COERCE_FLOAT(v6 + 0x38800000) + -0.000061035156;
  }
  LOBYTE(v4) = sub_14056F590(a3, (int)COERCE_FLOAT((v5 << 0x10) & 0x80000000 | LODWORD(v7)));
  return v4;
}

// --- End Function: sub_14083D860 (0x14083D860) ---

// --- Function: sub_14083D8F0 (0x14083D8F0) ---
int *__fastcall sub_14083D8F0(__int64 a1, int *a2, int a3, _QWORD **a4, __int64 a5, _DWORD *a6, char *a7, _DWORD *a8)
{
  _DWORD *v8; // r11
  unsigned int v9; // r8d
  __int64 v10; // r10
  unsigned __int8 v11; // di
  unsigned __int8 n4; // r12
  char v13; // r13
  bool v14; // r14
  unsigned int v16; // r15d
  int v17; // edx
  int v18; // esi
  unsigned __int64 v19; // rcx
  char v20; // al
  int v21; // edi
  __int64 *ThreadLogContextSlot; // rax
  char v23; // cl
  unsigned __int16 v24; // r8
  int v25; // ecx
  __int64 v26; // rsi
  char v27; // al
  unsigned __int16 v28; // di
  int v29; // ecx
  int v30; // ecx
  unsigned int v32; // [rsp+50h] [rbp-89h]
  int v33; // [rsp+58h] [rbp-81h] BYREF
  unsigned __int16 v34; // [rsp+5Ch] [rbp-7Dh]
  char v35; // [rsp+5Eh] [rbp-7Bh]
  int v36; // [rsp+60h] [rbp-79h]
  int v37; // [rsp+64h] [rbp-75h]
  unsigned int v38; // [rsp+68h] [rbp-71h]
  int v39; // [rsp+70h] [rbp-69h] BYREF
  int v40; // [rsp+74h] [rbp-65h]
  unsigned __int16 v41; // [rsp+78h] [rbp-61h]
  char n2; // [rsp+7Ah] [rbp-5Fh]
  int v43; // [rsp+80h] [rbp-59h]
  _DWORD v44[2]; // [rsp+88h] [rbp-51h] BYREF
  _DWORD v45[2]; // [rsp+90h] [rbp-49h] BYREF
  __int64 v46; // [rsp+98h] [rbp-41h] BYREF
  _QWORD v47[2]; // [rsp+A0h] [rbp-39h] BYREF
  __int64 v48[2]; // [rsp+B0h] [rbp-29h] BYREF
  __int128 v49; // [rsp+C0h] [rbp-19h] BYREF
  char v51; // [rsp+128h] [rbp+4Fh]
  char v52; // [rsp+130h] [rbp+57h]
  _QWORD **v53; // [rsp+138h] [rbp+5Fh]

  v53 = a4;
  v8 = a6;
  v9 = 4 * a3 + 1;
  v10 = a1;
  v32 = v9;
  v11 = 0;
  n4 = 0;
  v52 = 0;
  v13 = 0;
  v14 = 1;
  v38 = *(_DWORD *)(a1 + 0x10);
  v16 = v9;
  v43 = *a6;
  *((_BYTE *)a2 + 0xA) = 1;
  v51 = *a7;
  *(_QWORD *)a2 = 0;
  *((_WORD *)a2 + 4) = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  if ( v9 >= v9 + 4 )
    return a2;
  v17 = __ROL4__(1, v9);
  v18 = -v9;
  v19 = v9;
  v36 = -v9;
  v37 = v17;
  v46 = v9;
  do
  {
    if ( (v17 & *(_DWORD *)(*(_QWORD *)(v10 + 0x18) + 4 * (v19 >> 5))) != 0 )
    {
      if ( v9 < v38 )
      {
        sub_14083D8F0(v10, (unsigned int)&v39, v16, (_DWORD)a4, a5, (__int64)v8, (__int64)a7, (__int64)a8);
        if ( n2 )
        {
          if ( n2 == 1 )
          {
            if ( !v13 )
            {
              v13 = 1;
              v23 = 2 * v40;
              a2[1] = v40 + 1;
              *a2 = v39 - ((v18 + v16) << v23);
            }
            v14 = 0;
          }
          else if ( n2 == 2 )
          {
            v44[0] = 0xC9;
            v47[0] = v44;
            v44[1] = 0xBB;
            v47[1] = v45;
            v21 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)v47,
                    (__int64)"Returned from non PBM node",
                    "Is not possible to return from a child node full of PBM pixels. This implies that the BitMask is inc"
                    "orrect, or miss-matching PBM");
            if ( (v21 & 0xFFFFF) != 0 )
            {
              ThreadLogContextSlot = getThreadLogContextSlot();
              v48[0] = (__int64)v45;
              v48[1] = (__int64)&v46;
              v45[0] = 0xC9;
              v49 = 0;
              v45[1] = 0xBB;
              sub_1403515F0(
                3u,
                v48,
                "Returned from non PBM node",
                "Is not possible to return from a child node full of PBM pixels. This implies that the BitMask is incorre"
                "ct, or miss-matching PBM",
                1,
                v21,
                &v49,
                0,
                (__int64)ThreadLogContextSlot);
            }
            a4 = v53;
            ++n4;
LABEL_31:
            v11 = v52;
            goto LABEL_32;
          }
        }
        else if ( v14 )
        {
          v24 = v41;
          if ( !v13 )
          {
            v25 = v40;
            *((_WORD *)a2 + 4) = v41;
            v13 = 1;
            v34 = v24;
            a2[1] = v25 + 1;
            *a2 = v39 - ((v18 + v16) << (2 * v25));
          }
          a4 = v53;
          v52 = ++v11;
          v14 = *((_WORD *)a2 + 4) == v24;
          goto LABEL_32;
        }
        a4 = v53;
LABEL_32:
        v8 = a6;
        v9 = v32;
        v10 = a1;
        goto LABEL_33;
      }
      v26 = v16 - *(_DWORD *)(v10 + 0x10);
      v27 = sub_14083D860(v26, a4[1], (__int64)a4[2]);
      a4 = v53;
      if ( v27 )
      {
        v28 = *(unsigned __int8 *)(**v53 + 4 * v26)
            | (unsigned __int16)(((*(_BYTE *)(**v53 + 4 * v26 + 1) >> 4)
                                | (unsigned __int16)(0x10 * (*(_BYTE *)(**v53 + 4 * v26 + 2) >> 4))) << 8);
        if ( !v13 )
        {
          *((_WORD *)a2 + 4) = v28;
          *a2 = v26 - v36 - v16;
        }
        v13 = 1;
        if ( v14 )
          v14 = v28 == *((_WORD *)a2 + 4);
        if ( v28 )
        {
          v29 = *(_DWORD *)(a1 + 0x30);
          ++v52;
          v35 = 0;
          v34 = v28;
          v33 = v26;
          sub_14085B160(v29, (_DWORD)a6, (_DWORD)a7, (unsigned int)&v33, a5);
          a4 = v53;
          *a8 ^= v28 | ((_DWORD)v26 << 0x10);
        }
      }
      else
      {
        ++n4;
      }
      v18 = v36;
      goto LABEL_31;
    }
    if ( v9 >= v38 )
    {
      v20 = sub_14083D860(v16 - *(_DWORD *)(v10 + 0x10), a4[1], (__int64)a4[2]);
      v10 = a1;
      a4 = v53;
      v9 = v32;
      v8 = a6;
      if ( v20 )
      {
        ++n4;
        v14 = 0;
      }
    }
LABEL_33:
    ++v16;
    v19 = v46 + 1;
    v37 = __ROL4__(v37, 1);
    v17 = v37;
    ++v46;
  }
  while ( v16 < v9 + 4 );
  if ( v13 && n4 != 4 && v14 && v11 + n4 == 4 )
  {
    *v8 = v43;
    *a7 = v51;
    v30 = *(_DWORD *)(v10 + 0x30);
    v35 = *((_BYTE *)a2 + 4) + 1;
    v33 = *a2;
    *((_BYTE *)a2 + 0xA) = 0;
    sub_14085B160(v30, (_DWORD)v8, (_DWORD)a7, (unsigned int)&v33, a5);
  }
  return a2;
}

// --- End Function: sub_14083D8F0 (0x14083D8F0) ---

// --- Function: sub_14083DD00 (0x14083DD00) ---
int *__fastcall sub_14083DD00(__int64 a1, int *a2, int a3, _QWORD **a4, __int64 a5, _DWORD *a6, char *a7, _DWORD *a8)
{
  _DWORD *v8; // r11
  unsigned int v9; // r8d
  __int64 v10; // r10
  unsigned __int8 v11; // bl
  char v12; // r12
  unsigned __int8 n4; // r13
  bool v14; // r15
  unsigned int v16; // r14d
  int v17; // edx
  int v18; // esi
  unsigned __int64 v19; // rcx
  _QWORD *v20; // rax
  int v21; // ebx
  __int64 *ThreadLogContextSlot; // rax
  char v23; // cl
  unsigned __int16 v24; // r8
  int v25; // ecx
  __int64 v26; // rsi
  char v27; // al
  unsigned __int16 v28; // bx
  int v29; // ecx
  int v30; // ecx
  unsigned int v32; // [rsp+50h] [rbp-89h]
  char v33; // [rsp+54h] [rbp-85h]
  int v34; // [rsp+58h] [rbp-81h] BYREF
  unsigned __int16 v35; // [rsp+5Ch] [rbp-7Dh]
  char v36; // [rsp+5Eh] [rbp-7Bh]
  int v37; // [rsp+60h] [rbp-79h]
  int v38; // [rsp+64h] [rbp-75h]
  unsigned int v39; // [rsp+68h] [rbp-71h]
  int v40; // [rsp+70h] [rbp-69h] BYREF
  int v41; // [rsp+74h] [rbp-65h]
  unsigned __int16 v42; // [rsp+78h] [rbp-61h]
  char n2; // [rsp+7Ah] [rbp-5Fh]
  int v44; // [rsp+80h] [rbp-59h]
  _DWORD v45[2]; // [rsp+88h] [rbp-51h] BYREF
  _DWORD v46[2]; // [rsp+90h] [rbp-49h] BYREF
  __int64 v47; // [rsp+98h] [rbp-41h] BYREF
  _QWORD v48[2]; // [rsp+A0h] [rbp-39h] BYREF
  __int64 v49[2]; // [rsp+B0h] [rbp-29h] BYREF
  __int128 v50; // [rsp+C0h] [rbp-19h] BYREF
  char v52; // [rsp+128h] [rbp+4Fh]
  char v53; // [rsp+130h] [rbp+57h]
  _QWORD **v54; // [rsp+138h] [rbp+5Fh]

  v54 = a4;
  v8 = a6;
  v9 = 4 * a3 + 1;
  v10 = a1;
  v32 = v9;
  v11 = 0;
  v12 = 0;
  v53 = 0;
  n4 = 0;
  v52 = 0;
  v14 = 1;
  v39 = *(_DWORD *)(a1 + 0x10);
  v16 = v9;
  v44 = *a6;
  *((_BYTE *)a2 + 0xA) = 1;
  v33 = *a7;
  *(_QWORD *)a2 = 0;
  *((_WORD *)a2 + 4) = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  if ( v9 >= v9 + 4 )
    return a2;
  v17 = __ROL4__(1, v9);
  v18 = -v9;
  v19 = v9;
  v37 = -v9;
  v38 = v17;
  v47 = v9;
  do
  {
    if ( (v17 & *(_DWORD *)(*(_QWORD *)(v10 + 0x18) + 4 * (v19 >> 5))) != 0 )
    {
      if ( v9 >= v39 )
      {
        v26 = v16 - *(_DWORD *)(v10 + 0x10);
        v27 = sub_14083D860(v26, a4[1], (__int64)a4[2]);
        a4 = v54;
        if ( v27 )
        {
          v28 = *(unsigned __int8 *)(**v54 + 4 * v26)
              | (unsigned __int16)(((*(_BYTE *)(**v54 + 4 * v26 + 1) >> 4)
                                  | (unsigned __int16)(0x10 * (*(_BYTE *)(**v54 + 4 * v26 + 2) >> 4))) << 8);
          if ( !v52 )
          {
            *((_WORD *)a2 + 4) = v28;
            *a2 = v26 - v37 - v16;
          }
          v12 = 1;
          v52 = 1;
          if ( v14 )
            v14 = v28 == *((_WORD *)a2 + 4);
          if ( v28 )
          {
            v29 = *(_DWORD *)(a1 + 0x30);
            ++v53;
            v36 = 0;
            v35 = v28;
            v34 = v26;
            sub_14085B160(v29, (_DWORD)a6, (_DWORD)a7, (unsigned int)&v34, a5);
            a4 = v54;
            *a8 ^= v28 | ((_DWORD)v26 << 0x10);
          }
          v18 = v37;
          goto LABEL_32;
        }
        v12 = v52;
        ++n4;
        v18 = v37;
      }
      else
      {
        sub_14083DD00(v10, (unsigned int)&v40, v16, (_DWORD)a4, a5, (__int64)v8, (__int64)a7, (__int64)a8);
        if ( n2 )
        {
          if ( n2 == 1 )
          {
            if ( !v12 )
            {
              v12 = 1;
              v52 = 1;
              v23 = 2 * v41;
              a2[1] = v41 + 1;
              *a2 = v40 - ((v18 + v16) << v23);
            }
            v14 = 0;
          }
          else if ( n2 == 2 )
          {
            v45[0] = 0xC9;
            v48[0] = v45;
            v45[1] = 0xBB;
            v48[1] = v46;
            v21 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)v48,
                    (__int64)"Returned from non PBM node",
                    "Is not possible to return from a child node full of PBM pixels. This implies that the BitMask is inc"
                    "orrect, or miss-matching PBM");
            if ( (v21 & 0xFFFFF) != 0 )
            {
              ThreadLogContextSlot = getThreadLogContextSlot();
              v49[0] = (__int64)v46;
              v49[1] = (__int64)&v47;
              v46[0] = 0xC9;
              v50 = 0;
              v46[1] = 0xBB;
              sub_1403515F0(
                3u,
                v49,
                "Returned from non PBM node",
                "Is not possible to return from a child node full of PBM pixels. This implies that the BitMask is incorre"
                "ct, or miss-matching PBM",
                1,
                v21,
                &v50,
                0,
                (__int64)ThreadLogContextSlot);
            }
            a4 = v54;
            ++n4;
LABEL_32:
            v11 = v53;
            goto LABEL_33;
          }
        }
        else if ( v14 )
        {
          v24 = v42;
          if ( !v12 )
          {
            v25 = v41;
            v12 = 1;
            *((_WORD *)a2 + 4) = v42;
            v35 = v24;
            v52 = 1;
            a2[1] = v25 + 1;
            *a2 = v40 - ((v18 + v16) << (2 * v25));
          }
          a4 = v54;
          v53 = ++v11;
          v14 = *((_WORD *)a2 + 4) == v24;
          goto LABEL_33;
        }
        a4 = v54;
      }
LABEL_33:
      v8 = a6;
      v9 = v32;
      v10 = a1;
      goto LABEL_34;
    }
    if ( v9 >= v39 )
    {
      v20 = a4[1];
      if ( *v20 == v20[1] || *(_WORD *)(*v20 + 8LL * (v16 - *(_DWORD *)(v10 + 0x10)) + 6) )
      {
        ++n4;
        v14 = 0;
      }
    }
LABEL_34:
    ++v16;
    v19 = v47 + 1;
    v38 = __ROL4__(v38, 1);
    v17 = v38;
    ++v47;
  }
  while ( v16 < v9 + 4 );
  if ( v12 && n4 != 4 && v14 && v11 + n4 == 4 )
  {
    *v8 = v44;
    *a7 = v33;
    v30 = *(_DWORD *)(v10 + 0x30);
    v36 = *((_BYTE *)a2 + 4) + 1;
    v34 = *a2;
    *((_BYTE *)a2 + 0xA) = 0;
    sub_14085B160(v30, (_DWORD)v8, (_DWORD)a7, (unsigned int)&v34, a5);
  }
  return a2;
}

// --- End Function: sub_14083DD00 (0x14083DD00) ---

// --- Function: sub_140846400 (0x140846400) ---
double __fastcall sub_140846400(__int64 a1, __int64 a2, const void **a3, _DWORD *a4)
{
  __int64 v4; // r12
  __int64 v6; // rsi
  __int64 v7; // r15
  unsigned __int16 n3; // cx
  unsigned int n0x10; // edi
  int v10; // eax
  unsigned int v11; // edx
  int v12; // r13d
  __int64 n0x10_1; // rax
  char n5; // cl
  __int64 v15; // r14
  _BYTE *v16; // rax
  __int64 v17; // rax
  _BYTE *v18; // r15
  _BYTE *v19; // rdi
  __int64 v20; // rcx
  __int64 v21; // rax
  char *v22; // rsi
  char *v23; // r12
  const void *v24; // rcx
  bool v25; // zf
  char v27[4]; // [rsp+40h] [rbp-C0h] BYREF
  int v28; // [rsp+44h] [rbp-BCh] BYREF
  int v29; // [rsp+48h] [rbp-B8h] BYREF
  int v30; // [rsp+4Ch] [rbp-B4h] BYREF
  __int64 n0x10_2; // [rsp+50h] [rbp-B0h]
  __int64 v32; // [rsp+58h] [rbp-A8h]
  _QWORD v33[3]; // [rsp+60h] [rbp-A0h] BYREF
  unsigned __int64 v34; // [rsp+78h] [rbp-88h]
  __int64 v35; // [rsp+80h] [rbp-80h]
  __int64 v36; // [rsp+88h] [rbp-78h]
  int n0x900; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v38; // [rsp+B4h] [rbp-4Ch]
  int v39; // [rsp+BCh] [rbp-44h]
  unsigned __int64 v40; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v41; // [rsp+C8h] [rbp-38h]
  __int64 v42; // [rsp+D0h] [rbp-30h]
  __int64 v43; // [rsp+D8h] [rbp-28h]
  int v44[3]; // [rsp+100h] [rbp+0h] BYREF
  int v45[5]; // [rsp+10Ch] [rbp+Ch] BYREF

  v4 = 0;
  n0x900 = 0x900;
  v38 = 0;
  v39 = 0;
  v6 = a2;
  v41 = 0;
  v7 = a1;
  v42 = 0;
  v43 = 0;
  v40 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x900,
    &word_149C41BC8,
    "CDamageMapQuadTreeBitMask::CreateSnapshotData",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMapQuadTreeBitMask.cpp",
    0x1F);
  HIWORD(n0x900) = word_149C41BC8;
  if ( *(_QWORD *)(v7 + 0x18) != *(_QWORD *)(v7 + 0x20) )
  {
    n3 = 0;
    n0x10 = *(_DWORD *)(v6 + 0x18);
    if ( n0x10 >= 0x10 )
      n3 = 3;
    v10 = sub_1403C6650(n3);
    v11 = *(_DWORD *)(v6 + 0x18) * *(_DWORD *)(v6 + 0x18);
    v12 = v10;
    v30 = 0;
    n0x10_1 = 0x10;
    n5 = 5;
    if ( n0x10 < 0x10 )
      n5 = 1;
    v15 = v11 >> n5;
    v32 = v15;
    if ( n0x10 < 0x10 )
      n0x10_1 = 1;
    n0x10_2 = n0x10_1;
    do
    {
      v33[0] = 0x900;
      v33[1] = 0;
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v33[2] = __rdtsc();
      isProfileFunctionsInitialized(
        v33,
        &word_149C41BCC,
        "Create Snapshot Chunk",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMapQuadTreeBitMask.cpp",
        0x30);
      WORD1(v33[0]) = word_149C41BCC;
      v16 = *a3;
      a3[1] = *a3;
      if ( v15 )
        sub_1408470E0(a3, v15, &v30);
      else
        a3[1] = v16;
      v17 = *(_QWORD *)(v6 + 0x10);
      v29 = 0;
      v28 = 0;
      v27[0] = 0;
      if ( *(_BYTE *)(v17 + 7) < 2u && (*(_BYTE *)(v17 + 6) & 1) != 0 )
        sub_14083DD00(v7, v44, v12, (_QWORD **)v6, (__int64)a3, &v28, v27, &v29);
      else
        sub_14083D8F0(v7, v45, v12, (_QWORD **)v6, (__int64)a3, &v28, v27, &v29);
      v18 = *a3;
      v19 = a3[1];
      v20 = (__int64)*a3 + 4 * v28 + 4 * (unsigned int)(v27[0] != 0);
      if ( (_BYTE *)v20 != v19 )
      {
        v19 -= (unsigned __int64)&v19[-v20] & 0xFFFFFFFFFFFFFFFCuLL;
        a3[1] = v19;
      }
      v21 = (v19 - v18) >> 2;
      if ( v21 )
      {
        v4 = 4 * v21;
        v22 = (char *)allocWithProfilerInfo_w(4 * v21);
      }
      else
      {
        v22 = 0;
      }
      v23 = &v22[v4];
      if ( v18 != v19 )
        memmove(v22, v18, v19 - v18);
      v24 = *a3;
      *a3 = v22;
      a3[1] = v23;
      a3[2] = v23;
      if ( v24 )
        sub_1402A3D30(v24);
      if ( v29 )
        *a4 = v29;
      v34 = __rdtsc();
      qword_149B4B878(v33);
      v15 = v32;
      v7 = a1;
      ++v12;
      a3 += 3;
      ++a4;
      v25 = n0x10_2-- == 1;
      v4 = 0;
      v6 = a2;
    }
    while ( !v25 );
  }
  v41 = __rdtsc();
  return qword_149B4B878(&n0x900);
}

// --- End Function: sub_140846400 (0x140846400) ---

// --- Function: sub_1408470E0 (0x1408470E0) ---
__int64 __fastcall sub_1408470E0(__int64 a1, unsigned __int64 a2, int *a3)
{
  _DWORD *v3; // rdi
  __int64 v7; // rdi
  unsigned __int64 v8; // rcx
  char *v9; // rbp
  __int64 v10; // r14
  __int64 v11; // r12
  __int64 v12; // rdi
  char *v13; // rdx
  __int64 v14; // rax
  int v15; // eax
  _DWORD *v16; // rdi
  unsigned __int64 j; // rcx
  char *v18; // rdi
  __int64 result; // rax
  int v20; // eax
  unsigned __int64 i; // rcx

  v3 = *(_DWORD **)(a1 + 8);
  if ( a2 <= (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v3) >> 2 )
  {
    if ( a2 )
    {
      v20 = *a3;
      for ( i = a2; i; --i )
        *v3++ = v20;
    }
    result = 4 * a2;
    *(_QWORD *)(a1 + 8) += 4 * a2;
  }
  else
  {
    v7 = ((__int64)v3 - *(_QWORD *)a1) >> 2;
    v8 = 2 * v7;
    if ( !v7 )
      v8 = 1;
    if ( v8 < v7 + a2 )
      v8 = v7 + a2;
    v9 = 0;
    if ( v8 )
    {
      v10 = 4 * v8;
      v9 = (char *)allocWithProfilerInfo_w(4 * v8);
      v11 = v10;
    }
    else
    {
      v10 = 0;
      v11 = 0;
    }
    v12 = *(_QWORD *)(a1 + 8);
    if ( *(_QWORD *)a1 == v12 )
      v13 = v9;
    else
      v13 = (char *)memmove(v9, *(const void **)a1, v12 - *(_QWORD *)a1) + 4 * ((__int64)(v12 - a2) >> 2);
    v14 = v10;
    if ( a2 )
    {
      v15 = *a3;
      v16 = v13;
      for ( j = a2; j; --j )
        *v16++ = v15;
      v14 = v11;
    }
    v18 = &v13[4 * a2];
    if ( *(_QWORD *)a1 )
    {
      sub_1402A3D30(*(const void **)a1);
      v14 = v10;
    }
    result = (__int64)&v9[v14];
    *(_QWORD *)a1 = v9;
    *(_QWORD *)(a1 + 0x10) = result;
    *(_QWORD *)(a1 + 8) = v18;
  }
  return result;
}

// --- End Function: sub_1408470E0 (0x1408470E0) ---

// --- Function: sub_1408554E0 (0x1408554E0) ---
double __fastcall sub_1408554E0(__int64 a1, __int64 *a2, _DWORD *a3, __int64 a4)
{
  __int64 v8; // rdi
  __int64 i; // rbx
  __int64 v10; // rax
  int v11; // eax
  __int64 v12; // rdi
  signed __int64 v13; // rdx
  __int64 v14; // rdx
  __int64 v15; // rsi
  volatile signed __int64 *v16; // rbx
  int v17; // edi
  __int64 v18; // r8
  unsigned __int64 v19; // rax
  int v20; // eax
  unsigned __int64 n0x200000; // rax
  _QWORD v23[2]; // [rsp+30h] [rbp-D0h] BYREF
  int n0x900_1; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v25; // [rsp+44h] [rbp-BCh]
  int v26; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v27; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v28; // [rsp+58h] [rbp-A8h]
  __int64 v29; // [rsp+60h] [rbp-A0h]
  __int64 v30; // [rsp+68h] [rbp-98h]
  int n0x900_2; // [rsp+90h] [rbp-70h] BYREF
  __int64 v32; // [rsp+94h] [rbp-6Ch]
  int v33; // [rsp+9Ch] [rbp-64h]
  unsigned __int64 v34; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v35; // [rsp+A8h] [rbp-58h]
  __int64 v36; // [rsp+B0h] [rbp-50h]
  __int64 v37; // [rsp+B8h] [rbp-48h]
  int n0x900; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v39; // [rsp+E4h] [rbp-1Ch]
  int v40; // [rsp+ECh] [rbp-14h]
  unsigned __int64 v41; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v42; // [rsp+F8h] [rbp-8h]
  __int64 v43; // [rsp+100h] [rbp+0h]
  __int64 v44; // [rsp+108h] [rbp+8h]
  _QWORD v45[3]; // [rsp+130h] [rbp+30h] BYREF
  int v46; // [rsp+148h] [rbp+48h]
  int v47; // [rsp+14Ch] [rbp+4Ch]
  _BYTE v48[64]; // [rsp+150h] [rbp+50h] BYREF

  n0x900 = 0x900;
  v39 = 0;
  v40 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v41 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x900,
    &word_149C41B9C,
    "CDamageMap::MT_SetupSnapshotForDetachedJoints",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xD77);
  HIWORD(n0x900) = word_149C41B9C;
  v23[0] = 0;
  n0x900_1 = 0x900;
  v25 = 0;
  v26 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v27 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x900_1,
    &word_149C41B94,
    "CDamageMap::MT_GetJointsFromDetachList",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xD48);
  HIWORD(n0x900_1) = word_149C41B94;
  if ( *(_QWORD *)(a1 + 0x130) )
  {
    v8 = a2[1];
    for ( i = *a2; i != v8; i += 0x28 )
    {
      if ( !*(_DWORD *)(i + 0x1C) )
      {
        v10 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x130) + 0x70LL))(*(_QWORD *)(a1 + 0x130));
        v11 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v10 + 0x30LL))(v10, *(unsigned int *)(i + 0x20));
        if ( v11 >= 0 )
          sub_14056EE50(v23, v11);
      }
    }
  }
  v28 = __rdtsc();
  qword_149B4B878(&n0x900_1);
  n0x900_2 = 0x900;
  v32 = 0;
  v33 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v34 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x900_2,
    &word_149C41B98,
    "CDamageMap::MT_CreateSnapshotForJoints",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\RenderDll\\XRenderD3D9\\../Common/DamageMap.cpp",
    0xD65);
  v12 = *(_QWORD *)(a1 + 0x110);
  HIWORD(n0x900_2) = word_149C41B98;
  if ( *(_DWORD *)(v12 + 0x58) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(v12 + 0x5C);
  }
  else
  {
    v13 = _InterlockedIncrement64((volatile signed __int64 *)(v12 + 0x48));
    if ( (v13 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        v12 + 0x48,
        v13,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        1);
  }
  v14 = *(_QWORD *)(a1 + 0x120);
  v45[0] = v12 + 8;
  v45[1] = v14 + 0x18;
  v45[2] = v23;
  v46 = *(_DWORD *)(v14 + 0x50);
  v47 = 0;
  sub_140846400(a1 + 8, v45, a4, v48);
  rw_lock_release_read_lock(v12 + 0x48);
  v35 = __rdtsc();
  qword_149B4B878(&n0x900_2);
  *a3 = *(_DWORD *)(*(_QWORD *)(a1 + 0x120) + 0x58LL);
  v15 = *(_QWORD *)(a1 + 0x110);
  v16 = (volatile signed __int64 *)(v15 + 0x48);
  v17 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(v15 + 0x58) == v17 )
  {
    ++*(_DWORD *)(v15 + 0x5C);
  }
  else
  {
    v18 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    v19 = _InterlockedCompareExchange64(v16, 0x200000, 0);
    if ( v19 )
      sub_1403DCD60(
        v15 + 0x48,
        v19,
        v18,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        1);
    else
      *(_QWORD *)(v15 + 0x50) = v18;
    *(_DWORD *)(v15 + 0x58) = v17;
  }
  sub_14056EE00(v15 + 0x38, v23);
  if ( v15 != 0xFFFFFFFFFFFFFFB8uLL )
  {
    v20 = *(_DWORD *)(v15 + 0x5C);
    if ( v20 )
    {
      *(_DWORD *)(v15 + 0x5C) = v20 - 1;
    }
    else
    {
      *(_DWORD *)(v15 + 0x58) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(v16, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v15 + 0x50) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        rw_lock_handle_write_release_contention(v15 + 0x48, n0x200000);
    }
  }
  if ( (v23[0] & 0x100000000000000LL) != 0 && (v23[0] & 0xFFFFFFFFFFFFLL) != 0 )
    sub_1402A3D30((const void *)(v23[0] & 0xFFFFFFFFFFFFLL));
  v42 = __rdtsc();
  return qword_149B4B878(&n0x900);
}

// --- End Function: sub_1408554E0 (0x1408554E0) ---

// --- Function: sub_14085B160 (0x14085B160) ---
__int64 __fastcall sub_14085B160(int a1, unsigned int *a2, unsigned __int8 *a3, __int64 a4, _QWORD *a5)
{
  int v5; // ebx
  _QWORD *v6; // r14
  int n7; // eax
  int n2; // r8d
  unsigned int v11; // eax
  int v12; // ecx
  __int64 v13; // r10
  char v14; // r12
  bool v15; // zf
  unsigned int v16; // ebx
  __int64 result; // rax
  __int64 v18; // r15
  unsigned __int64 v19; // r13
  unsigned int v20; // eax
  _BYTE *v21; // rdx
  int v22; // r11d
  char v23; // bp
  unsigned int v24; // r9d
  int v25; // r10d
  unsigned __int8 v26; // r9
  unsigned int v27; // [rsp+50h] [rbp+8h] BYREF

  v5 = *(unsigned __int8 *)(a4 + 6);
  v6 = a5;
  n7 = 1;
  n2 = 2;
  if ( (_BYTE)v5 )
    n7 = 7;
  v11 = 2 * (v5 & n7);
  v12 = a1 - v11;
  v13 = v11;
  if ( (_BYTE)v5 )
    n2 = 4;
  v14 = n2 + v12 + 0x10;
  v15 = (_BYTE)v5 == 0;
  v16 = n2 + v12 + 0x10;
  result = !v15;
  v18 = (__int64)(a5[1] - *a5) >> 2;
  v19 = v13
      | result
      | (*(unsigned __int16 *)(a4 + 4) << (n2 + v12))
      | (unsigned __int64)(((*(_DWORD *)a4 >> v13) & (unsigned int)((1 << v12) - 1)) << n2);
  if ( n2 + v12 != 0xFFFFFFF0 )
  {
    do
    {
      v20 = *a2;
      if ( *a2 >= (unsigned int)v18 )
      {
        v21 = (_BYTE *)v6[1];
        v27 = 0;
        sub_140846F10((__int64)v6, v21, v20 - (unsigned int)v18 + 1, &v27);
        v20 = *a2;
      }
      v22 = *a3;
      v23 = v14 - v16;
      v24 = 0x20 - v22;
      if ( 0x20 - v22 >= v16 )
        v24 = v16;
      if ( (_BYTE)v22 )
        v25 = (1 << v22) - 1;
      else
        v25 = 0;
      v16 -= v24;
      *(_DWORD *)(*v6 + 4LL * v20) = *(_DWORD *)(*v6 + 4LL * v20) & v25 | (v19 >> v23 << v22);
      v26 = *a3 + v24;
      result = v26;
      *a3 = v26;
      *a2 += v26 >> 5;
      *a3 &= 0x1Fu;
    }
    while ( v16 );
  }
  return result;
}

// --- End Function: sub_14085B160 (0x14085B160) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 rotatedCookie; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  rotatedCookie = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)rotatedCookie )
  {
    StackCookie = __ROR8__(rotatedCookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

