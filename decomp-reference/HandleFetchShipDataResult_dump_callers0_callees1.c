// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1454048C0 (HandleFetchShipDataResult)
// Caller Depth: 0
// Callee/Ref Depth: 1
// Total Functions Found: 17
// ------------------------------------------------------------

// --- Function: identity_int64 (0x1402A24F0) ---
// This function is a simple identity function that returns its single __int64
// argument unchanged. It effectively acts as a pass-through.
__int64 __fastcall identity_int64(__int64 a1)
{
  return a1;
}

// --- End Function: identity_int64 (0x1402A24F0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes a global callback function if it is registered, passing the provided
// arguments. If no callback is registered, it defaults to returning a status of 1.
// The resulting status bits are then masked: bit 2 is cleared if qword_149B3B208
// is zero, and bit 3 is cleared if qword_149B3B210 is zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 statusBits; // rax

  if ( qword_149B3B1F0 )
    statusBits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    statusBits = 1;
  if ( !qword_149B3B208 )
    statusBits = (unsigned int)statusBits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)statusBits & 0xFFFFFFF7;
  return statusBits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: ReportTelemetryEvent (0x1403045C0) ---
// This function serves as a comprehensive structured logging or telemetry event
// reporting mechanism. It captures various contextual data points such as
// timestamps, unique IDs (UUID-like), player information, source location, and
// custom event-specific data. The collected data is formatted into a human-
// readable string and/or a JSON-like structure. Depending on global configuration
// flags, the formatted output can be directed to standard output, standard error,
// or custom logging callbacks. It also handles dynamic memory allocation and
// deallocation for internal buffers and data structures.
void __fastcall ReportTelemetryEvent(
        unsigned int logLevel,
        __int64 *playerId,
        char *messageString,
        char *sourceLocation,
        vraudio::AudioBuffer *audioBufferContext,
        unsigned __int64 audioBufferCount,
        __int64 unknownContext1,
        __int64 outputFlags,
        _QWORD *unknownContext2,
        __int64 callbackContext)
{
  _QWORD *unknownContext2_1; // rdi
  __int64 callbackContext_1; // rbx
  __int64 timestampMs_1; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 eventKeyCount; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *audioBufferContext_2; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *audioBufferContext_4; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *audioBufferContext_8; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_1; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 audioBufferCount_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 eventKeyCount_1; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 logMessageBuffer; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char outputFlags_1; // cl
  int v90; // eax
  FILE *File; // rax
  int g_logToStderrEnabled; // r8d
  FILE *File_1; // rax
  char outputFlags_2; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_1; // rax
  const void *Buffer_2; // rsi
  double *Buffer; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *eventKeyListPtr; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *eventKeyListPtr_1; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int eventKeyVectorPtr; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME uuid; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *audioBufferContext_1; // [rsp+F0h] [rbp+50h]
  __int64 timestampMs; // [rsp+F8h] [rbp+58h]
  unsigned __int64 audioBufferContext_5; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *audioBufferContext_3; // [rsp+110h] [rbp+70h]
  char *sourceLocation_1; // [rsp+118h] [rbp+78h]
  char *messageStringa; // [rsp+120h] [rbp+80h]
  __int64 *playerIda; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *audioBufferContext_6; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *audioBufferContext_7; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 audioBufferCount_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char timestampBuffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t uuidString[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  unknownContext2_1 = unknownContext2;
  callbackContext_1 = callbackContext;
  sourceLocation_1 = sourceLocation;
  messageStringa = messageString;
  playerIda = playerId;
  n4 = logLevel;
  audioBufferContext_1 = audioBufferContext;
  if ( qword_149B3B188 )
  {
    timestampMs_1 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &uuid);
    timestampMs_1 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&uuid - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  timestampMs = timestampMs_1;
  if ( callbackContext_1
    && !sub_1402FFCB0(
          timestampMs_1,
          unknownContext2_1,
          callbackContext_1,
          (__int64)audioBufferContext,
          audioBufferCount) )
  {
    return;
  }
  if ( qword_149B3B1E0 )
  {
    uuid = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(uuidString, 0x25);
  }
  else
  {
    uuid = (struct _FILETIME)qword_149B3B250++;
    swprintf(uuidString, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(timestampBuffer, 0x20u, timestampMs_1);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  eventKeyCount = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  audioBufferCount_2 = 0;
  if ( !audioBufferCount )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  audioBufferContext_2 = audioBufferContext_1;
  v20 = v117;
  audioBufferContext_3 = audioBufferContext_1;
  while ( 2 )
  {
    audioBufferContext_4 = audioBufferContext_2;
    if ( *((_BYTE *)audioBufferContext_2 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = audioBufferContext_2;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    audioBufferContext_5 = (unsigned __int64)audioBufferContext_2;
    if ( eventKeyCount < 0x400 )
    {
      v147[eventKeyCount] = audioBufferContext_2;
LABEL_30:
      n0xF_29 = ++eventKeyCount;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, audioBufferCount);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              v14,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400;
          ++__Val_0_;
        }
        while ( n0x400 < 0x400 );
        eventKeyCount = n0xF_29;
        audioBufferContext_2 = audioBufferContext_3;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          v14,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&audioBufferContext_5);
      }
      else
      {
        *_Whereptr_1 = audioBufferContext_2;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)audioBufferContext_2 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)audioBufferContext_2 + 1) = sub_1402FF3C0(&v142, audioBufferContext_2);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)audioBufferContext_2 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    audioBufferContext_5 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)audioBufferContext_2, &v130, &audioBufferContext_5);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      audioBufferContext_4 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      audioBufferContext_6 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        audioBufferContext_8 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        audioBufferContext_7 = audioBufferContext_8;
        v48 = *(_QWORD **)audioBufferContext_8;
        v49 = **(_QWORD ***)audioBufferContext_8;
        if ( v49 == *(_QWORD **)audioBufferContext_8 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        audioBufferContext_8 = audioBufferContext_7;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)audioBufferContext_8 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)audioBufferContext_8 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          audioBufferContext_4 = audioBufferContext_6;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        audioBufferContext_4 = audioBufferContext_6;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)audioBufferContext_4 + 1) = v57;
      eventKeyCount = n0xF_29;
      audioBufferContext_7 = audioBufferContext_4;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_1 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, audioBufferCount);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                v14,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_1;
            ++__Val_0__1;
          }
          while ( n0x400_1 < 0x400 );
          eventKeyCount = n0xF_29;
          audioBufferContext_4 = audioBufferContext_6;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            v14,
            _Whereptr_3,
            &audioBufferContext_7);
        }
        else
        {
          *_Whereptr_3 = audioBufferContext_4;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = audioBufferContext_4;
      }
      n0xF_29 = ++eventKeyCount;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    audioBufferContext_2 = audioBufferContext_3;
    v29 = v143;
LABEL_94:
    if ( audioBufferContext_5 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[audioBufferContext_5];
    v124 += audioBufferContext_5;
LABEL_98:
    audioBufferContext_2 = (vraudio::AudioBuffer *)((char *)audioBufferContext_2 + 0x70);
    v69 = v120;
    audioBufferCount_1 = audioBufferCount_2 + 1;
    *((_QWORD *)audioBufferContext_4 + 0xA) = v29;
    audioBufferCount_2 = audioBufferCount_1;
    audioBufferContext_3 = audioBufferContext_2;
    if ( audioBufferCount_1 < audioBufferCount )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = eventKeyCount;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = eventKeyCount;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * eventKeyCount], (__int64)(8 * eventKeyCount) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( eventKeyCount_1 = 0; eventKeyCount_1 < eventKeyCount; ++eventKeyCount_1 )
  {
    v76 = *(_QWORD *)&v71[8 * eventKeyCount_1];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_131;
    }
  }
  logMessageBuffer = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    logMessageBuffer = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(logMessageBuffer & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_131:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(
            timestampMs,
            n4,
            messageStringa,
            playerIda,
            sourceLocation_1,
            audioBufferContext_1,
            audioBufferCount,
            v146,
            n0x10_1,
            &outputFlags);
    v123[0] = v87;
  }
  outputFlags_1 = outputFlags;
  if ( (outputFlags & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&uuid,
            timestampMs,
            uuidString,
            n4,
            playerIda,
            messageStringa,
            sourceLocation_1,
            audioBufferContext_1,
            audioBufferCount,
            unknownContext1,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &outputFlags);
    outputFlags_1 = outputFlags;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (outputFlags_1 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", timestampBuffer, v83);
    outputFlags_1 = outputFlags;
  }
  g_logToStderrEnabled = n2_126;
  if ( n2_126 == 1 && (outputFlags_1 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(n2_126 + 1);
    fprintf(File_1, "%s %s\n", timestampBuffer, v83);
    g_logToStderrEnabled = n2_126;
  }
  v83[v88] = 0;
  outputFlags_2 = outputFlags;
  v95 = (outputFlags & 1) != 0 && n2_125 == 2;
  v96 = (outputFlags & 2) != 0 && g_logToStderrEnabled == 2;
  if ( (outputFlags & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_2 = 0;
    }
    else
    {
      Buffer_1 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_2 = (const void *)Buffer_1;
      if ( Buffer_1 )
      {
        Buffer = (double *)Buffer_1;
        goto LABEL_167;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer = (double *)&v117;
LABEL_167:
    eventKeyVectorPtr = v123[0];
    *(_BYTE *)Buffer = 0;
    sub_140302E40(
      *(_QWORD *)&uuid,
      timestampMs,
      timestampBuffer,
      uuidString,
      n4,
      playerIda,
      messageStringa,
      sourceLocation_1,
      (__int64)audioBufferContext_1,
      audioBufferCount,
      unknownContext1,
      (__int64)v71,
      n0xF_29,
      Buffer,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      outputFlags,
      eventKeyVectorPtr);
    sub_1402A3D30(Buffer_2);
    outputFlags_2 = outputFlags;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (outputFlags_2 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      outputFlags_2 = outputFlags;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (outputFlags_2 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    eventKeyListPtr = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = eventKeyListPtr[5];
        eventKeyListPtr_1 = (_QWORD *)*eventKeyListPtr;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)eventKeyListPtr[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_191;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        eventKeyListPtr[4] = 0;
        eventKeyListPtr[5] = 0xF;
        *((_BYTE *)eventKeyListPtr + 0x10) = 0;
        sub_1402A3D30(eventKeyListPtr);
        eventKeyListPtr = eventKeyListPtr_1;
      }
      while ( eventKeyListPtr_1 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_191:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: ReportTelemetryEvent (0x1403045C0) ---

// --- Function: validateHandleAccess (0x14030EC00) ---
// Validates a given handle by checking its internal type, flags, and thread-
// specific access permissions. It extracts the raw pointer and flags from the
// handle, then performs checks against metadata associated with the handle. It
// also verifies if the current thread's context or global settings permit access
// to the handle based on its type.
bool __fastcall validateHandleAccess(unsigned __int64 *a1)
{
  unsigned __int64 handleValue; // r9
  __int64 rawPointer; // r10
  unsigned __int64 handleFlags; // r9
  __int64 flagMask; // rax
  __int64 metadataBase; // r10
  __int64 metadataPtr; // rbx
  bool isThreadAccessPermitted; // al

  handleValue = *a1;
  if ( !*a1 )
    return 0;
  rawPointer = handleValue & 0xFFFFFFFFFFFFLL;
  handleFlags = HIWORD(handleValue);
  if ( (handleFlags & 0xF000) != 0 )
  {
    flagMask = map_flag_to_mask(0x2000u);
    metadataPtr = metadataBase & ~(flagMask - 1);
  }
  else
  {
    metadataPtr = rawPointer - 6;
  }
  if ( *(_WORD *)(metadataPtr + 2) != (handleFlags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (isThreadAccessPermitted = sub_140539D80()) )
    isThreadAccessPermitted = 1;
  return *(_WORD *)(metadataPtr + 4) == 2 && isThreadAccessPermitted || sub_140392020(a1) != 0;
}

// --- End Function: validateHandleAccess (0x14030EC00) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to a thread-specific log context slot. This function first
// obtains a thread-local data block. If the block is valid, it uses an internal
// index (clamped to 15) from the block to calculate and return the address of a
// specific log context slot within that block. If the thread-local data block is
// not available, it returns a pointer to a global fallback context.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *threadDataBlock; // rax
  unsigned __int64 *threadDataBlock_1; // rcx
  unsigned __int64 n0xF; // rax

  threadDataBlock = sub_1404B3EA0();
  threadDataBlock_1 = threadDataBlock;
  if ( !threadDataBlock )
    return &dword_149B45F40;
  n0xF = *threadDataBlock;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&threadDataBlock_1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Logs a fatal error message. If the fatal error system is not properly
// initialized (missing necessary function pointers), it triggers a debug break.
// Otherwise, it formats the provided message into a buffer and dispatches it to an
// external logging function. Execution typically halts after this function.
_BYTE *LogFatalError(const char *formatString, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC pfnInitFatalFunctionsAddr; // rax
  _BYTE *result; // rax
  _QWORD *pStdioCommonVsnprintf; // rax
  int formattedMessageLength; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, formatString);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    pfnInitFatalFunctionsAddr = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))pfnInitFatalFunctionsAddr)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    pStdioCommonVsnprintf = sub_1402A4380();
    formattedMessageLength = _stdio_common_vsprintf(
                               *pStdioCommonVsnprintf | 2LL,
                               formattedMessageBuffer,
                               0x1000u,
                               formatString,
                               0,
                               args);
    if ( formattedMessageLength < 0 )
      formattedMessageLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedMessageLength >= 0x1000 )
      formattedMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: InitTraceContextPlayerIdIntDescriptor (0x140A60210) ---
// Initializes a structure to describe a "PlayerId" field within a "TraceContext"
// for logging or telemetry. It sets up various function pointers for
// serialization, deserialization, comparison, and memory management specific to an
// integer type. The PlayerId value itself is copied from the provided source.
__int64 __fastcall InitTraceContextPlayerIdIntDescriptor(
        __int64 fieldDescriptor,
        __int64 threadLogContextSlot,
        _QWORD *playerIdValuePtr)
{
  __int64 fieldCount; // rax

  *(_QWORD *)fieldDescriptor = threadLogContextSlot;
  *(_QWORD *)(fieldDescriptor + 8) = "TraceContext";
  *(_WORD *)(fieldDescriptor + 0x58) = 0x100;
  *(_QWORD *)(fieldDescriptor + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(fieldDescriptor + 0x20) = sub_1403EB240;
  *(_QWORD *)(fieldDescriptor + 0x30) = sub_1403E77F0;
  *(_QWORD *)(fieldDescriptor + 0x40) = sub_1403E4E60;
  *(_QWORD *)(fieldDescriptor + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(fieldDescriptor + 0x78) = "PlayerId";
  *(_QWORD *)(fieldDescriptor + 0x10) = 0;
  *(_QWORD *)(fieldDescriptor + 0x28) = 0;
  *(_QWORD *)(fieldDescriptor + 0x38) = 0;
  *(_QWORD *)(fieldDescriptor + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(fieldDescriptor + 0x60) = 0xB0;
  *(_QWORD *)(fieldDescriptor + 0x68) = 0xA8;
  *(_QWORD *)(fieldDescriptor + 0x70) = playerIdValuePtr;
  *(_BYTE *)(fieldDescriptor + 0xC9) = 1;
  *(_QWORD *)(fieldDescriptor + 0x80) = *playerIdValuePtr;
  *(_QWORD *)(fieldDescriptor + 0x88) = sub_1403EB550;
  *(_QWORD *)(fieldDescriptor + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(fieldDescriptor + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(fieldDescriptor + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(fieldDescriptor + 0xB8) = sub_1403E4C70;
  fieldCount = 2;
  *(_QWORD *)(fieldDescriptor + 0x98) = 0;
  *(_QWORD *)(fieldDescriptor + 0xA8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(fieldDescriptor + 0xC8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xD0) = 0x18;
  *(_QWORD *)(fieldDescriptor + 0xD8) = 0x17;
  return fieldCount;
}

// --- End Function: InitTraceContextPlayerIdIntDescriptor (0x140A60210) ---

// --- Function: InitTraceContextPlayerIdErrorDetailsDescriptor (0x140A60320) ---
// Initializes a complex structure to describe a "TraceContext" event, including
// "PlayerId" and "ErrorDetails" fields. It configures function pointers for
// serialization, deserialization, comparison, and memory management for both the
// PlayerId (integer type) and ErrorDetails (custom type) sections. This function
// is used to set up the descriptor for structured logging of events with
// associated error information.
__int64 __fastcall InitTraceContextPlayerIdErrorDetailsDescriptor(
        __int64 fieldDescriptor,
        __int64 *threadLogContextSlot,
        _QWORD *playerIdValuePtr,
        __int64 errorDetailsPtr)
{
  __int64 fieldCount; // rax

  *(_QWORD *)fieldDescriptor = threadLogContextSlot;
  *(_QWORD *)(fieldDescriptor + 8) = "TraceContext";
  *(_WORD *)(fieldDescriptor + 0x58) = 0x100;
  *(_QWORD *)(fieldDescriptor + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(fieldDescriptor + 0x20) = sub_1403EB240;
  *(_QWORD *)(fieldDescriptor + 0x30) = sub_1403E77F0;
  *(_QWORD *)(fieldDescriptor + 0x40) = sub_1403E4E60;
  *(_QWORD *)(fieldDescriptor + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(fieldDescriptor + 0x78) = "PlayerId";
  *(_QWORD *)(fieldDescriptor + 0x10) = 0;
  *(_QWORD *)(fieldDescriptor + 0x28) = 0;
  *(_QWORD *)(fieldDescriptor + 0x38) = 0;
  *(_QWORD *)(fieldDescriptor + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(fieldDescriptor + 0x60) = 0xB0;
  *(_QWORD *)(fieldDescriptor + 0x68) = 0xA8;
  *(_QWORD *)(fieldDescriptor + 0x70) = playerIdValuePtr;
  *(_BYTE *)(fieldDescriptor + 0xC9) = 1;
  *(_QWORD *)(fieldDescriptor + 0x80) = *playerIdValuePtr;
  *(_QWORD *)(fieldDescriptor + 0x88) = sub_1403EB550;
  *(_QWORD *)(fieldDescriptor + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(fieldDescriptor + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(fieldDescriptor + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(fieldDescriptor + 0xB8) = sub_1403E4C70;
  *(_QWORD *)(fieldDescriptor + 0xE8) = "ErrorDetails";
  *(_QWORD *)(fieldDescriptor + 0xF8) = sub_1403EB620;
  *(_QWORD *)(fieldDescriptor + 0x100) = sub_1403EB130;
  *(_QWORD *)(fieldDescriptor + 0x110) = sub_1403E7690;
  *(_QWORD *)(fieldDescriptor + 0x120) = sub_1403E4E60;
  *(_QWORD *)(fieldDescriptor + 0x128) = allocWithProfilerInfo_ww;
  fieldCount = 3;
  *(_QWORD *)(fieldDescriptor + 0x98) = 0;
  *(_QWORD *)(fieldDescriptor + 0xA8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(fieldDescriptor + 0xC8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xD0) = 0x18;
  *(_QWORD *)(fieldDescriptor + 0xD8) = 0x17;
  *(_QWORD *)(fieldDescriptor + 0xE0) = errorDetailsPtr;
  *(_WORD *)(fieldDescriptor + 0x138) = 0;
  *(_QWORD *)(fieldDescriptor + 0xF0) = 0;
  *(_QWORD *)(fieldDescriptor + 0x108) = 0;
  *(_QWORD *)(fieldDescriptor + 0x118) = 0;
  *(_QWORD *)(fieldDescriptor + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(fieldDescriptor + 0x140) = 0x48;
  *(_QWORD *)(fieldDescriptor + 0x148) = 0x800;
  return fieldCount;
}

// --- End Function: InitTraceContextPlayerIdErrorDetailsDescriptor (0x140A60320) ---

// --- Function: ZeroInitializeAndNotifyEngine (0x1426FC500) ---
// Initializes the first three QWORDs of the provided structure to zero. Following
// initialization, it invokes the _StarEngineModule__ callback, likely to register
// or notify the engine about the state of this parameter.
Parameter *__fastcall ZeroInitializeAndNotifyEngine(Parameter *Parameter)
{
  *(_QWORD *)Parameter = 0;
  *((_QWORD *)Parameter + 1) = 0;
  *((_QWORD *)Parameter + 2) = 0;
  _StarEngineModule__((ULONG_PTR)Parameter);
  return Parameter;
}

// --- End Function: ZeroInitializeAndNotifyEngine (0x1426FC500) ---

// --- Function: add_0xC7 (0x142744750) ---
// This function takes an unsigned 8-bit integer, casts it to an unsigned integer,
// and adds the constant value 0xC7 (199) to it, returning the result as a 64-bit
// integer.
__int64 __fastcall add_0xC7(unsigned __int8 a1)
{
  return (unsigned int)a1 + 0xC7;
}

// --- End Function: add_0xC7 (0x142744750) ---

// --- Function: InitTraceContextWithPlayerIdDescriptor (0x1453E85E0) ---
// Initializes a comprehensive event descriptor structure for a "TraceContext"
// event. This includes setting up the base context, assigning function pointers
// for various operations (serialization, comparison, memory management), and
// recursively initializing a nested "PlayerId" field descriptor. The PlayerId is
// expected to be an integer type.
__int64 __fastcall InitTraceContextWithPlayerIdDescriptor(
        __int64 eventDescriptor,
        __int64 *threadLogContextSlot,
        _QWORD *playerIdValuePtr,
        _QWORD *nestedFieldContext)
{
  *(_QWORD *)eventDescriptor = threadLogContextSlot;
  *(_QWORD *)(eventDescriptor + 8) = sub_1403B3E60();
  *(_BYTE *)(eventDescriptor + 0x59) = 1;
  *(_QWORD *)(eventDescriptor + 0x10) = 0;
  *(_QWORD *)(eventDescriptor + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(eventDescriptor + 0x20) = sub_1403EB240;
  *(_QWORD *)(eventDescriptor + 0x28) = 0;
  *(_QWORD *)(eventDescriptor + 0x30) = sub_1403E77F0;
  *(_QWORD *)(eventDescriptor + 0x38) = 0;
  *(_QWORD *)(eventDescriptor + 0x40) = sub_1403E4E60;
  *(_QWORD *)(eventDescriptor + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(eventDescriptor + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(eventDescriptor + 0x58) = 0;
  *(_QWORD *)(eventDescriptor + 0x60) = 0xB0;
  *(_QWORD *)(eventDescriptor + 0x68) = 0xA8;
  return sub_1453E97D0(eventDescriptor + 0x70, playerIdValuePtr, nestedFieldContext) + 1;
}

// --- End Function: InitTraceContextWithPlayerIdDescriptor (0x1453E85E0) ---

// --- Function: HandleFetchShipDataResult (0x1454048C0) ---
// Processes the result of an asynchronous operation to fetch ship data. It first
// validates the input handle. Based on the operation's success or failure, it logs
// appropriate messages (success, error, or invalid entity) using a structured
// logging system. For successful operations, it proceeds to process the fetched
// ship data. For failed operations, it handles error details and performs
// necessary cleanup.
void __fastcall HandleFetchShipDataResult(unsigned __int64 *operationHandle, _BYTE *operationResult)
{
  void *v2; // rsp
  void *v3; // rsp
  void *v4; // rsp
  __int64 v5; // [rsp+18h] [rbp-168h]
  _QWORD v6[8]; // [rsp+30h] [rbp-150h] BYREF
  __int64 v7; // [rsp+88h] [rbp-F8h]
  _BYTE v8[144]; // [rsp+A0h] [rbp-E0h] BYREF
  int v9; // [rsp+180h] [rbp+0h]
  int v11; // [rsp+188h] [rbp+8h]
  int eventDescriptorBuffer; // [rsp+18Ch] [rbp+Ch]
  _QWORD *v13; // [rsp+190h] [rbp+10h]
  _DWORD v14[2]; // [rsp+198h] [rbp+18h] BYREF
  char callbackStatus; // [rsp+1A0h] [rbp+20h] BYREF
  _DWORD v16[2]; // [rsp+1A8h] [rbp+28h] BYREF
  char v17; // [rsp+1B0h] [rbp+30h] BYREF
  _DWORD v18[2]; // [rsp+1B8h] [rbp+38h] BYREF
  char logMessageDescriptor; // [rsp+1C0h] [rbp+40h] BYREF
  _DWORD v20[2]; // [rsp+1C8h] [rbp+48h] BYREF
  char v21; // [rsp+1D0h] [rbp+50h] BYREF
  _DWORD v22[2]; // [rsp+1D8h] [rbp+58h] BYREF
  char v23; // [rsp+1E0h] [rbp+60h] BYREF
  _DWORD v24[2]; // [rsp+1E8h] [rbp+68h] BYREF
  char v25; // [rsp+1F0h] [rbp+70h] BYREF
  _BYTE *v26; // [rsp+1F8h] [rbp+78h]
  vraudio::AudioBuffer *__Val_0___2; // [rsp+200h] [rbp+80h]
  _QWORD *v28; // [rsp+208h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___1; // [rsp+210h] [rbp+90h]
  _QWORD *v30; // [rsp+218h] [rbp+98h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+220h] [rbp+A0h]
  __int64 *ThreadLogContextSlot_2; // [rsp+228h] [rbp+A8h]
  __int64 *v33; // [rsp+230h] [rbp+B0h]
  __int64 eventDescriptorPtr; // [rsp+238h] [rbp+B8h]
  _BYTE *v35; // [rsp+240h] [rbp+C0h]
  _QWORD *eventDescriptorPtr2; // [rsp+248h] [rbp+C8h]
  __int64 *ThreadLogContextSlot; // [rsp+250h] [rbp+D0h]
  __int64 v38; // [rsp+258h] [rbp+D8h]
  __int64 *errorDetailsPtr; // [rsp+260h] [rbp+E0h]
  __int64 errorDetailsValue; // [rsp+268h] [rbp+E8h]
  _QWORD *v41; // [rsp+270h] [rbp+F0h]
  __int64 *v42; // [rsp+278h] [rbp+F8h]
  __int64 *ThreadLogContextSlot_1; // [rsp+280h] [rbp+100h]
  __int64 v44; // [rsp+288h] [rbp+108h]
  __int64 playerIdPtr; // [rsp+290h] [rbp+110h]
  __int64 *playerIdValue; // [rsp+298h] [rbp+118h]
  __int64 v47; // [rsp+2A0h] [rbp+120h]
  _QWORD *v48; // [rsp+2A8h] [rbp+128h]
  _QWORD src__4[2]; // [rsp+2B0h] [rbp+130h] BYREF
  _QWORD src__5[2]; // [rsp+2C0h] [rbp+140h] BYREF
  _QWORD v51[2]; // [rsp+2D0h] [rbp+150h] BYREF
  _QWORD src__2[2]; // [rsp+2E0h] [rbp+160h] BYREF
  _QWORD src__3[2]; // [rsp+2F0h] [rbp+170h] BYREF
  _QWORD v54[2]; // [rsp+300h] [rbp+180h] BYREF
  _QWORD src_[2]; // [rsp+310h] [rbp+190h] BYREF
  __int64 v56; // [rsp+320h] [rbp+1A0h] BYREF
  int playerIdPtr_1; // [rsp+328h] [rbp+1A8h]
  _QWORD src__1[2]; // [rsp+330h] [rbp+1B0h] BYREF
  _QWORD v59[2]; // [rsp+340h] [rbp+1C0h] BYREF
  _QWORD v60[2]; // [rsp+350h] [rbp+1D0h] BYREF
  char v61; // [rsp+360h] [rbp+1E0h]
  _QWORD v62[2]; // [rsp+368h] [rbp+1E8h] BYREF
  char v63; // [rsp+378h] [rbp+1F8h]
  _QWORD v64[2]; // [rsp+380h] [rbp+200h] BYREF
  char v65; // [rsp+390h] [rbp+210h]
  __int64 n2; // [rsp+398h] [rbp+218h]
  _QWORD v67[2]; // [rsp+3A0h] [rbp+220h] BYREF
  __int64 v68; // [rsp+3B0h] [rbp+230h] BYREF
  _QWORD v69[2]; // [rsp+3B8h] [rbp+238h] BYREF
  _BYTE dst__4[16]; // [rsp+3C8h] [rbp+248h] BYREF
  __int64 dst__5[2]; // [rsp+3D8h] [rbp+258h] BYREF
  _BYTE dst__2[16]; // [rsp+3E8h] [rbp+268h] BYREF
  __int64 dst__3[2]; // [rsp+3F8h] [rbp+278h] BYREF
  _BYTE dst_[16]; // [rsp+408h] [rbp+288h] BYREF
  __int64 dst__1[2]; // [rsp+418h] [rbp+298h] BYREF
  __int64 Parameter_[3]; // [rsp+428h] [rbp+2A8h] BYREF

  if ( validateHandleAccess(operationHandle + 1) )
  {
    if ( *operationResult == 1 )
    {
      if ( *operationResult != 1 )
        LogFatalError(
          "GetSuccess should only be called on a result holding a T_Success object. Did you forget to do a cast-to-bool check first?");
      v13 = operationResult + 8;
      v22[0] = add_0xC7(0x16u);
      v22[1] = 8;
      src_[0] = v22;
      src_[1] = &v23;
      qmemcpy(dst_, src_, sizeof(dst_));
      eventDescriptorBuffer = invokeGlobalCallbackAndMaskStatusBits(
                                5,
                                (__int64)dst_,
                                (__int64)"CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
                                "Received $$ player insured entitlements results for player $$");
      if ( (eventDescriptorBuffer & 0xFFFFF) != 0 )
      {
        errorDetailsPtr = GetPlayerIdFromContext(qword_149E7E438, v69);
        errorDetailsValue = identity_int64(*errorDetailsPtr);
        v64[0] = 0;
        v64[1] = errorDetailsValue;
        v65 = 0;
        v41 = v64;
        playerIdPtr = (v13[1] - *v13) / 0xB0LL;
        v56 = 0;
        playerIdPtr_1 = playerIdPtr;
        v42 = &v56;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v59[0] = 0;
        v59[1] = 0;
        v24[0] = add_0xC7(0x16u);
        v24[1] = 8;
        src__1[0] = v24;
        src__1[1] = &v25;
        qmemcpy(dst__1, src__1, sizeof(dst__1));
        v69[1] = 3;
        v4 = alloca(0x150);
        v30 = v6;
        __Val_0__ = (vraudio::AudioBuffer *)v6;
        InitTraceContextWithPlayerIdDescriptor((__int64)v6, ThreadLogContextSlot_1, v42, v41);
        LODWORD(v5) = eventDescriptorBuffer;
        ReportTelemetryEvent(
          5u,
          dst__1,
          "CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
          "Received $$ player insured entitlements results for player $$",
          __Val_0__,
          3u,
          1,
          v5,
          v59,
          0);
      }
      v44 = *operationHandle;
      ProcessFetchedShipEntitlements(v44, operationHandle[2], v13, *((_BYTE *)operationHandle + 0x18));
    }
    else
    {
      v20[0] = add_0xC7(0x16u);
      v20[1] = 8;
      src__2[0] = v20;
      src__2[1] = &v21;
      qmemcpy(dst__2, src__2, sizeof(dst__2));
      v11 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)dst__2,
              (__int64)"CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
              "FetchOwnedShipsData Failed - PlayerId: $$, Error: $$");
      if ( (v11 & 0xFFFFF) != 0 )
      {
        if ( *operationResult )
          LogFatalError(
            "GetError should only be called on a result holding a T_Error object. Did you forget to do a cast-to-bool check first?");
        v35 = operationResult + 8;
        v33 = GetPlayerIdFromContext(qword_149E7E438, &v68);
        eventDescriptorPtr = identity_int64(*v33);
        v62[0] = 0;
        v62[1] = eventDescriptorPtr;
        v63 = 0;
        eventDescriptorPtr2 = v62;
        ThreadLogContextSlot = getThreadLogContextSlot();
        v54[0] = 0;
        v54[1] = 0;
        v14[0] = add_0xC7(0x16u);
        v14[1] = 8;
        src__3[0] = v14;
        src__3[1] = &callbackStatus;
        qmemcpy(dst__3, src__3, sizeof(dst__3));
        v67[1] = 3;
        v3 = alloca(0x150);
        v28 = v6;
        __Val_0___1 = (vraudio::AudioBuffer *)v6;
        InitTraceContextPlayerIdErrorDetailsDescriptor(
          (__int64)v6,
          ThreadLogContextSlot,
          eventDescriptorPtr2,
          (__int64)v35);
        LODWORD(v5) = v11;
        ReportTelemetryEvent(
          3u,
          dst__3,
          "CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
          "FetchOwnedShipsData Failed - PlayerId: $$, Error: $$",
          __Val_0___1,
          3u,
          1,
          v5,
          v54,
          0);
      }
      v38 = *operationHandle;
      ZeroInitializeAndNotifyEngine((Parameter *)Parameter_);
      ProcessFetchedShipData(v38, Parameter_);
      DeallocateShipDataList((Parameter *)Parameter_);
    }
  }
  else
  {
    v18[0] = add_0xC7(0x16u);
    v18[1] = 8;
    src__4[0] = v18;
    src__4[1] = &logMessageDescriptor;
    qmemcpy(dst__4, src__4, sizeof(dst__4));
    v9 = invokeGlobalCallbackAndMaskStatusBits(
           5,
           (__int64)dst__4,
           (__int64)"CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
           "ASOP entity was null in the GetPlayerInsuredEntitledShips callback for player $$");
    if ( (v9 & 0xFFFFF) != 0 )
    {
      playerIdValue = GetPlayerIdFromContext(qword_149E7E438, v67);
      v47 = identity_int64(*playerIdValue);
      v60[0] = 0;
      v60[1] = v47;
      v61 = 0;
      v48 = v60;
      ThreadLogContextSlot_2 = getThreadLogContextSlot();
      v51[0] = 0;
      v51[1] = 0;
      v16[0] = add_0xC7(0x16u);
      v16[1] = 8;
      src__5[0] = v16;
      src__5[1] = &v17;
      qmemcpy(dst__5, src__5, sizeof(dst__5));
      n2 = 2;
      v2 = alloca(0xE0);
      v26 = v8;
      __Val_0___2 = (vraudio::AudioBuffer *)v8;
      InitTraceContextPlayerIdIntDescriptor((__int64)v8, (__int64)ThreadLogContextSlot_2, v48);
      LODWORD(v7) = v9;
      ReportTelemetryEvent(
        5u,
        dst__5,
        "CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
        "ASOP entity was null in the GetPlayerInsuredEntitledShips callback for player $$",
        __Val_0___2,
        2u,
        1,
        v7,
        v51,
        0);
    }
  }
}

// --- End Function: HandleFetchShipDataResult (0x1454048C0) ---

// --- Function: ProcessFetchedShipEntitlements (0x145413B20) ---
// Processes a list of fetched ship entitlements. This function logs the data
// fetching process, initializes internal data structures, and iterates through the
// provided entitlements list, adding each item to a local collection. It interacts
// with asynchronous operations (futures/promises) to manage data flow, potentially
// canceling or resolving them. The function also integrates with engine services
// for data management and performs extensive logging of the process.
void __fastcall ProcessFetchedShipEntitlements(
        __int64 shipDataProviderContext,
        __int64 unknownContext,
        _QWORD *entitlementsList,
        char processFlags)
{
  void *v4; // rsp
  void *v5; // rsp
  __int64 v6; // rax
  __int64 *futureResult; // rax
  int v8; // [rsp+8h] [rbp-2C8h]
  __int64 v9; // [rsp+18h] [rbp-2B8h]
  _BYTE eventDescriptorBuffer[144]; // [rsp+30h] [rbp-2A0h] BYREF
  __int64 v11; // [rsp+F8h] [rbp-1D8h]
  _BYTE v12[368]; // [rsp+110h] [rbp-1C0h] BYREF
  int n3; // [rsp+2D0h] [rbp+0h]
  int callbackStatus; // [rsp+2D4h] [rbp+4h]
  int v15; // [rsp+2D8h] [rbp+8h]
  __int64 playerIdValue_1; // [rsp+2E0h] [rbp+10h]
  _DWORD v17[2]; // [rsp+2E8h] [rbp+18h] BYREF
  char v18; // [rsp+2F0h] [rbp+20h] BYREF
  _DWORD v19[2]; // [rsp+2F8h] [rbp+28h] BYREF
  char v20; // [rsp+300h] [rbp+30h] BYREF
  _DWORD v21[2]; // [rsp+308h] [rbp+38h] BYREF
  char v22; // [rsp+310h] [rbp+40h] BYREF
  _DWORD v23[2]; // [rsp+318h] [rbp+48h] BYREF
  char v24; // [rsp+320h] [rbp+50h] BYREF
  _BYTE *eventDescriptorPtr; // [rsp+328h] [rbp+58h]
  __int64 __Val_0__; // [rsp+330h] [rbp+60h]
  __int64 v27; // [rsp+338h] [rbp+68h]
  _QWORD *entitlementsList_1; // [rsp+340h] [rbp+70h]
  _BYTE *p_eventDescriptorBuffer; // [rsp+348h] [rbp+78h]
  vraudio::AudioBuffer *p_eventDescriptorBuffer_1; // [rsp+350h] [rbp+80h]
  __int64 (__fastcall ***v31)(_QWORD); // [rsp+358h] [rbp+88h]
  __int64 v32; // [rsp+360h] [rbp+90h]
  __int64 v33; // [rsp+368h] [rbp+98h]
  __int64 **p_futureResultPtr3; // [rsp+370h] [rbp+A0h]
  __int64 v35; // [rsp+378h] [rbp+A8h]
  __int64 eventDescriptorPtr3; // [rsp+380h] [rbp+B0h]
  __int64 eventDescriptorPtr4; // [rsp+388h] [rbp+B8h]
  __int64 playerIdPtr; // [rsp+390h] [rbp+C0h]
  __int64 *ThreadLogContextSlot; // [rsp+398h] [rbp+C8h]
  __int64 playerIdValue; // [rsp+3A0h] [rbp+D0h]
  __int64 playerIdValue_2; // [rsp+3A8h] [rbp+D8h]
  __int64 v42; // [rsp+3B0h] [rbp+E0h]
  __int64 *errorDetailsPtr; // [rsp+3B8h] [rbp+E8h]
  __int64 errorDetailsValue; // [rsp+3C0h] [rbp+F0h]
  _QWORD *v45; // [rsp+3C8h] [rbp+F8h]
  __int64 *ThreadLogContextSlot_1; // [rsp+3D0h] [rbp+100h]
  __int64 v47; // [rsp+3D8h] [rbp+108h]
  __int64 (__fastcall *v48)(__int64, _BYTE *, __int64, __int64 **, __int64 *, int); // [rsp+3E0h] [rbp+110h]
  _BYTE *p_engineService; // [rsp+3E8h] [rbp+118h]
  __int64 **v50; // [rsp+3F0h] [rbp+120h]
  __int64 *v51; // [rsp+3F8h] [rbp+128h]
  __int64 v52; // [rsp+400h] [rbp+130h]
  _BYTE *p_engineService_1; // [rsp+408h] [rbp+138h]
  __int64 *v54; // [rsp+410h] [rbp+140h]
  __int64 v55; // [rsp+418h] [rbp+148h]
  __int64 *processedEntitlements[3]; // [rsp+420h] [rbp+150h] BYREF
  _QWORD src_[2]; // [rsp+438h] [rbp+168h] BYREF
  __int64 v58; // [rsp+448h] [rbp+178h] BYREF
  int v59; // [rsp+450h] [rbp+180h]
  _QWORD src__1[2]; // [rsp+458h] [rbp+188h] BYREF
  _QWORD v61[2]; // [rsp+468h] [rbp+198h] BYREF
  _QWORD src__2[2]; // [rsp+478h] [rbp+1A8h] BYREF
  _QWORD src__3[2]; // [rsp+488h] [rbp+1B8h] BYREF
  _QWORD v64[2]; // [rsp+498h] [rbp+1C8h] BYREF
  _QWORD v65[2]; // [rsp+4A8h] [rbp+1D8h] BYREF
  char v66; // [rsp+4B8h] [rbp+1E8h]
  _QWORD v67[2]; // [rsp+4C0h] [rbp+1F0h] BYREF
  char v68; // [rsp+4D0h] [rbp+200h]
  _QWORD v69[2]; // [rsp+4D8h] [rbp+208h] BYREF
  char v70; // [rsp+4E8h] [rbp+218h]
  __int64 v71; // [rsp+4F0h] [rbp+220h] BYREF
  _QWORD v72[2]; // [rsp+4F8h] [rbp+228h] BYREF
  _QWORD v73[2]; // [rsp+508h] [rbp+238h] BYREF
  _BYTE dst_[16]; // [rsp+518h] [rbp+248h] BYREF
  __int64 dst__1[2]; // [rsp+528h] [rbp+258h] BYREF
  _BYTE dst__2[16]; // [rsp+538h] [rbp+268h] BYREF
  __int64 dst__3[2]; // [rsp+548h] [rbp+278h] BYREF
  __int64 futureResultPtr[2]; // [rsp+558h] [rbp+288h] BYREF
  void (__fastcall *futureResultPtr2[3])(char *); // [rsp+568h] [rbp+298h] BYREF
  _QWORD futureResultPtr3[3]; // [rsp+580h] [rbp+2B0h] BYREF
  char processFlags_1; // [rsp+598h] [rbp+2C8h]
  __int64 *v82[3]; // [rsp+5A0h] [rbp+2D0h] BYREF
  _BYTE v83[32]; // [rsp+5B8h] [rbp+2E8h] BYREF
  _BYTE traceContext[40]; // [rsp+5D8h] [rbp+308h] BYREF
  __int64 memoryManager[14]; // [rsp+600h] [rbp+330h] BYREF
  _BYTE engineService[56]; // [rsp+670h] [rbp+3A0h] BYREF
  _BYTE engineService_1[56]; // [rsp+6A8h] [rbp+3D8h] BYREF

  v19[0] = add_0xC7(0x16u);
  v19[1] = 8;
  src_[0] = v19;
  src_[1] = &v20;
  qmemcpy(dst_, src_, sizeof(dst_));
  callbackStatus = invokeGlobalCallbackAndMaskStatusBits(
                     5,
                     (__int64)dst_,
                     (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData",
                     "Fetching Owned Ship Data of $$ entitlements for player $$. ATCId: $$");
  if ( (callbackStatus & 0xFFFFF) != 0 )
  {
    v52 = identity_int64(unknownContext);
    v65[0] = 0;
    v65[1] = v52;
    v66 = 0;
    eventDescriptorPtr3 = (__int64)v65;
    v54 = GetPlayerIdFromContext(qword_149E7E438, v72);
    v55 = identity_int64(*v54);
    v67[0] = 0;
    v67[1] = v55;
    v68 = 0;
    eventDescriptorPtr4 = (__int64)v67;
    v35 = (entitlementsList[1] - *entitlementsList) / 0xB0LL;
    v58 = 0;
    v59 = v35;
    playerIdPtr = (__int64)&v58;
    ThreadLogContextSlot = getThreadLogContextSlot();
    v61[0] = 0;
    v61[1] = 0;
    v17[0] = add_0xC7(0x16u);
    v17[1] = 8;
    src__1[0] = v17;
    src__1[1] = &v18;
    qmemcpy(dst__1, src__1, sizeof(dst__1));
    v72[1] = 4;
    v4 = alloca(0x1C0);
    eventDescriptorPtr = v12;
    __Val_0__ = (__int64)v12;
    sub_1453E86F0((__int64)v12, ThreadLogContextSlot, playerIdPtr, eventDescriptorPtr4, eventDescriptorPtr3);
    LODWORD(v11) = callbackStatus;
    ReportTelemetryEvent(
      5u,
      dst__1,
      "CEntityComponentShipListProvider::FetchOwnedShipsData",
      "Fetching Owned Ship Data of $$ entitlements for player $$. ATCId: $$",
      (vraudio::AudioBuffer *)__Val_0__,
      4u,
      1,
      v11,
      v61,
      0);
  }
  sub_14036DC00((__int64)traceContext);
  sub_14036C440((__int64)memoryManager);
  sub_141259930((__int64)memoryManager, 0x81, 0x95);
  sub_144D049F0(memoryManager, 0x2000);
  v27 = sub_1464E7930(qword_149E7E438);
  if ( v27 )
  {
    n3 = sub_146481E10(v27);
    if ( n3 )
    {
      if ( n3 == 1 || n3 == 3 )
        sub_1415A29D0(memoryManager, 2);
    }
    else
    {
      sub_1415A29D0(memoryManager, 1);
    }
  }
  unknown_libname_472(processedEntitlements);
  sub_140AB53A0(processedEntitlements, (entitlementsList[1] - *entitlementsList) / 0xB0LL);
  entitlementsList_1 = entitlementsList;
  playerIdValue_1 = *entitlementsList;
  playerIdValue = entitlementsList[1];
  while ( playerIdValue_1 != playerIdValue )
  {
    playerIdValue_2 = playerIdValue_1;
    sub_14042FD60((__int64)processedEntitlements, (const void **)(playerIdValue_1 + 8));
    playerIdValue_1 += 0xB0;
  }
  v42 = *(_QWORD *)(shipDataProviderContext + 8);
  futureResultPtr3[0] = shipDataProviderContext;
  futureResultPtr3[1] = unknownContext;
  futureResultPtr3[2] = v42;
  processFlags_1 = processFlags;
  v50 = v82;
  sub_140509680(v82, entitlementsList);
  sub_14039A4B0((__int64 *)(shipDataProviderContext + 0xE8));
  v21[0] = add_0xC7(0x16u);
  v21[1] = 8;
  src__2[0] = v21;
  src__2[1] = &v22;
  qmemcpy(dst__2, src__2, sizeof(dst__2));
  v15 = invokeGlobalCallbackAndMaskStatusBits(
          5,
          (__int64)dst__2,
          (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData",
          "AsyncQueryEntitiesByEntitlement for player $$");
  if ( (v15 & 0xFFFFF) != 0 )
  {
    errorDetailsPtr = GetPlayerIdFromContext(qword_149E7E438, v73);
    errorDetailsValue = identity_int64(*errorDetailsPtr);
    v69[0] = 0;
    v69[1] = errorDetailsValue;
    v70 = 0;
    v45 = v69;
    ThreadLogContextSlot_1 = getThreadLogContextSlot();
    v64[0] = 0;
    v64[1] = 0;
    v23[0] = add_0xC7(0x16u);
    v23[1] = 8;
    src__3[0] = v23;
    src__3[1] = &v24;
    qmemcpy(dst__3, src__3, sizeof(dst__3));
    v73[1] = 2;
    v5 = alloca(0xE0);
    p_eventDescriptorBuffer = eventDescriptorBuffer;
    p_eventDescriptorBuffer_1 = (vraudio::AudioBuffer *)eventDescriptorBuffer;
    InitTraceContextPlayerIdIntDescriptor((__int64)eventDescriptorBuffer, (__int64)ThreadLogContextSlot_1, v45);
    LODWORD(v9) = v15;
    ReportTelemetryEvent(
      5u,
      dst__3,
      "CEntityComponentShipListProvider::FetchOwnedShipsData",
      "AsyncQueryEntitiesByEntitlement for player $$",
      p_eventDescriptorBuffer_1,
      2u,
      1,
      v9,
      v64,
      0);
  }
  v31 = *(__int64 (__fastcall ****)(_QWORD))(identity_int64((__int64)&qword_149B4FBE0) + 0x188);
  v32 = (**v31)(v31);
  v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x60LL))(v32);
  v48 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64, __int64 **, __int64 *, int))(*(_QWORD *)v33 + 0x28LL);
  v47 = *GetPlayerIdFromContext(qword_149E7E438, &v71);
  LOBYTE(v8) = 0x29;
  v51 = (__int64 *)v48(v33, v83, v47, processedEntitlements, memoryManager, v8);
  p_engineService = engineService;
  p_futureResultPtr3 = (__int64 **)sub_1453ED820((__int64)engineService, futureResultPtr3);
  p_engineService_1 = engineService_1;
  v6 = sub_1453ED820((__int64)engineService_1, p_futureResultPtr3);
  sub_1453D2020(futureResultPtr2, v6);
  sub_140B01DB0(p_futureResultPtr3 + 4);
  futureResult = sub_1404CC7C0(v51, futureResultPtr, futureResultPtr2);
  sub_1403798D0(
    (std::shared_ptr<vraudio::MixerNode> *)(shipDataProviderContext + 0xE8),
    (std::shared_ptr<vraudio::MixerNode> *)futureResult);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)futureResultPtr);
  sub_1402A2AD0(futureResultPtr2);
  sub_140370B50((__int64)v83);
  sub_140B01DB0(v82);
  sub_1404634D0((__int64)processedEntitlements);
  sub_140375750(memoryManager);
  sub_1403762C0((__int64)traceContext);
}

// --- End Function: ProcessFetchedShipEntitlements (0x145413B20) ---

// --- Function: ProcessFetchedShipData (0x14542ABD0) ---
// Processes a list of fetched ship data. This function logs its entry, then
// iterates through the provided data, copying and adding each item to an internal
// collection. It then sorts or further processes this collection. For each
// processed item, it retrieves a handle, performs data swaps, and updates
// associated fields. Finally, it manages the lifecycle of a future/promise object
// and updates internal state or logging contexts.
__int64 __fastcall ProcessFetchedShipData(__int64 shipDataProviderContext, __int64 *fetchedShipDataList)
{
  void **v2; // rax
  char buf; // [rsp+20h] [rbp-148h] BYREF
  _BYTE tempBuf1[7]; // [rsp+21h] [rbp-147h] BYREF
  __int64 v6; // [rsp+28h] [rbp-140h]
  __int64 v7; // [rsp+30h] [rbp-138h]
  __int64 v8; // [rsp+38h] [rbp-130h]
  __int64 *fetchedShipDataList_1; // [rsp+40h] [rbp-128h]
  __int64 v10; // [rsp+48h] [rbp-120h]
  __int64 v11; // [rsp+50h] [rbp-118h]
  __int64 v12; // [rsp+58h] [rbp-110h]
  __int64 v13; // [rsp+60h] [rbp-108h]
  __int64 v14; // [rsp+68h] [rbp-100h]
  __int64 v15; // [rsp+70h] [rbp-F8h]
  __int64 v16; // [rsp+78h] [rbp-F0h]
  __int64 v17; // [rsp+80h] [rbp-E8h]
  void *handleObject; // [rsp+88h] [rbp-E0h] BYREF
  __int64 (__fastcall *updateFunction)(__int64, __int64); // [rsp+90h] [rbp-D8h]
  __int64 futureObject[5]; // [rsp+98h] [rbp-D0h] BYREF
  _BYTE p_tempShipDataBuffer[64]; // [rsp+C0h] [rbp-A8h] BYREF
  _QWORD v22[3]; // [rsp+100h] [rbp-68h] BYREF
  _QWORD v23[7]; // [rsp+118h] [rbp-50h] BYREF

  sub_1402AE3D0(futureObject, "CEntityComponentShipListProvider::OnFetchedShipData", shipDataProviderContext + 0x70, 1);
  sub_145462260((Parameter *)(shipDataProviderContext + 0x88));
  fetchedShipDataList_1 = fetchedShipDataList;
  v6 = *fetchedShipDataList;
  v14 = fetchedShipDataList[1];
  while ( v6 != v14 )
  {
    v15 = v6;
    sub_1453F6D90(p_tempShipDataBuffer, v6);
    v16 = shipDataProviderContext + 0x88;
    futureObject[3] = sub_1453DC930(shipDataProviderContext + 0x88, (__int64)p_tempShipDataBuffer);
    sub_1402ABD50(v23);
    sub_140370D10(v22);
    v6 += 0x70;
  }
  sub_145445B60(shipDataProviderContext, (ULONG_PTR *)(shipDataProviderContext + 0x88));
  v10 = shipDataProviderContext + 0x88;
  v7 = *(_QWORD *)(shipDataProviderContext + 0x88);
  v17 = *(_QWORD *)(shipDataProviderContext + 0x90);
  while ( v7 != v17 )
  {
    v8 = v7;
    v2 = sub_14458F090(&handleObject);
    sub_140377FE0((void **)(v7 + 0x58), v2);
    sub_1402ABD50(&handleObject);
    v11 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0x98);
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0xA0LL))(v11);
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x140LL))(v12);
    updateFunction = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 0x140LL);
    *(_DWORD *)(v7 + 0x68) = updateFunction(v13, v7 + 8);
    v7 += 0x88;
  }
  sub_1402B1820(futureObject);
  futureObject[1] = shipDataProviderContext + 0xF8;
  memset(&buf, 0, sizeof(buf));
  sub_1453D5A00(shipDataProviderContext + 0xF8, &buf);
  memset(tempBuf1, 0, 1u);
  return sub_1453D5960(shipDataProviderContext + 0xF8, tempBuf1);
}

// --- End Function: ProcessFetchedShipData (0x14542ABD0) ---

// --- Function: DeallocateShipDataList (0x14545F7E0) ---
// Deallocates memory associated with a list or vector of ship data objects. It
// iterates through each element in the collection, invoking a specific
// deallocation routine for a nested pointer within each element (at offset +0x48).
// After cleaning up individual elements, it frees the main buffer backing the
// collection and nullifies the collection's pointers.
Parameter *__fastcall DeallocateShipDataList(Parameter *shipDataVector)
{
  Parameter *shipDataVector_1; // rax
  __int64 currentElementPtr; // [rsp+20h] [rbp-58h]
  __int64 *endPtr; // [rsp+38h] [rbp-40h]
  Parameter *shipDataVector_2; // [rsp+40h] [rbp-38h]
  __int64 currentElementPtr_1; // [rsp+48h] [rbp-30h]

  endPtr = (__int64 *)((char *)shipDataVector + 8);
  shipDataVector_2 = (Parameter *)((char *)shipDataVector + 0x10);
  _StarEngineModule__((ULONG_PTR)shipDataVector);
  shipDataVector_1 = shipDataVector;
  if ( *(_QWORD *)shipDataVector )
  {
    currentElementPtr_1 = *endPtr;
    for ( currentElementPtr = *(_QWORD *)shipDataVector; currentElementPtr != currentElementPtr_1; currentElementPtr += 0x70 )
      sub_140370D10((_QWORD *)(currentElementPtr + 0x48));
    std::_Deallocate<16,0>(
      *(_QWORD **)shipDataVector,
      0x70 * ((*(_QWORD *)shipDataVector_2 - *(_QWORD *)shipDataVector) / 0x70LL));
    *(_QWORD *)shipDataVector = 0;
    *endPtr = 0;
    shipDataVector_1 = shipDataVector_2;
    *(_QWORD *)shipDataVector_2 = 0;
  }
  return shipDataVector_1;
}

// --- End Function: DeallocateShipDataList (0x14545F7E0) ---

// --- Function: GetPlayerIdFromContext (0x1464E7490) ---
// Retrieves a QWORD value from a fixed offset (0xC10) within the provided base
// structure. The retrieved value is stored at the location pointed to by 'a2'.
// This function likely extracts a specific identifier or pointer from a larger
// context object.
_QWORD *__fastcall GetPlayerIdFromContext(__int64 contextBase, _QWORD *outputPtr)
{
  *outputPtr = *(_QWORD *)(contextBase + 0xC10);
  return outputPtr;
}

// --- End Function: GetPlayerIdFromContext (0x1464E7490) ---

// --- Function: __security_check_cookie (0x148033700) ---
// Standard stack security check function. Compares the provided stack cookie with
// the global security cookie. If a mismatch is detected or the cookie is
// corrupted, it triggers a security failure report.
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

