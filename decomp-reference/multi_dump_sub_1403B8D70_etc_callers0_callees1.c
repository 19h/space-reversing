// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x1403B8D70 (sub_1403B8D70)
//   - 0x140518100 (sub_140518100)
//   - 0x141F4E8E0 (sub_141F4E8E0)
//   - 0x146A1B960 (sub_146A1B960)
//   - 0x146A1CA30 (sub_146A1CA30)
//   - 0x146A24480 (sub_146A24480)
//   - 0x146A27DC0 (sub_146A27DC0)
//   - 0x146A2D6C0 (sub_146A2D6C0)
//   - 0x146A2D800 (sub_146A2D800)
//   - 0x146A2D940 (sub_146A2D940)
//   - 0x146A2DA50 (sub_146A2DA50)
//   - 0x146A2DDF0 (sub_146A2DDF0)
//   - 0x146A2DEF0 (sub_146A2DEF0)
//   - 0x146A2E020 (sub_146A2E020)
//   - 0x146A2E140 (sub_146A2E140)
//   - 0x146A2F670 (sub_146A2F670)
//   - 0x146A31880 (sub_146A31880)
//   - 0x146A31930 (sub_146A31930)
//   - 0x146A31AE0 (sub_146A31AE0)
//   - 0x146A31E30 (sub_146A31E30)
//   - 0x146A31E70 (sub_146A31E70)
//   - 0x146A320C0 (sub_146A320C0)
//   - 0x146A321C0 (sub_146A321C0)
//   - 0x146A32280 (sub_146A32280)
//   - 0x146A322A0 (sub_146A322A0)
//   - 0x146A322C0 (sub_146A322C0)
//   - 0x146A32360 (sub_146A32360)
//   - 0x146A32380 (sub_146A32380)
//   - 0x146A323B0 (sub_146A323B0)
//   - 0x146A32530 (sub_146A32530)
//   - 0x146A327B0 (sub_146A327B0)
//   - 0x146A33560 (sub_146A33560)
//   - 0x146A38520 (sub_146A38520)
//   - 0x146A414F0 (sub_146A414F0)
//   - 0x146A41530 (sub_146A41530)
//   - 0x146A42040 (sub_146A42040)
//   - 0x146A429B0 (sub_146A429B0)
//   - 0x146A42A40 (sub_146A42A40)
//   - 0x146A42B00 (sub_146A42B00)
// Caller Depth: 0
// Callee/Ref Depth: 1
// Total Functions Found: 94
// ------------------------------------------------------------

// --- Function: sub_1402A3190 (0x1402A3190) ---
__int64 sub_1402A3190(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n511;
  while ( Buffer[n511] );
  sub_1402A3BE0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A3190 (0x1402A3190) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
void __fastcall sub_1402A3D30(const void *a1)
{
  sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall allocWithProfilerInfo_w(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall sub_1402A6760(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PEAVListener@Logger@gte@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@1@PEAU?$_Tree_node@PEAVListener@Logger@gte@@PEAX@1@@Z (0x1402A7F70) ---
void __fastcall std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
        std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *this,
        std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *_Al,
        std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode)
{
  std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode_1; // rbx
  std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode_2; // rcx

  _Rootnode_1 = _Rootnode;
  while ( !*((_BYTE *)_Rootnode_1 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      this,
      _Al,
      *((std::_Tree_node<gte::Logger::Listener *,void *> **)_Rootnode_1 + 2));
    _Rootnode_2 = _Rootnode_1;
    _Rootnode_1 = *(std::_Tree_node<gte::Logger::Listener *,void *> **)_Rootnode_1;
    sub_1402A3D30(_Rootnode_2);
  }
}

// --- End Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PEAVListener@Logger@gte@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@1@PEAU?$_Tree_node@PEAVListener@Logger@gte@@PEAX@1@@Z (0x1402A7F70) ---

// --- Function: LogTraceConditional (0x1402C1000) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( gEnv && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
        qword_149B4FCB0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C1000) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@2@@Z (0x1402DE6E0) ---
unsigned __int64 __fastcall std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
        unsigned __int64 **a1,
        unsigned __int64 a2,
        unsigned __int64 buf)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *_Last; // rcx
  unsigned __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int64 *v8; // rdi
  unsigned __int64 *v9; // rcx
  signed __int64 v10; // rax
  unsigned __int64 result; // rax
  unsigned __int64 buf_1; // [rsp+40h] [rbp+18h] BYREF

  buf_1 = buf;
  _Last = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)a1[1];
  if ( (_Last
      - (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)*a1) >> 3 >= a2 )
  {
    std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>>>(
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *const)*a1,
      _Last,
      (const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)&buf_1);
    return result;
  }
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_20;
  v6 = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( v6 )
      v8 = (unsigned __int64 *)allocWithProfilerInfo_w(8 * a2);
    else
      v8 = 0;
    goto LABEL_10;
  }
  if ( v6 + 0x27 < v6 )
LABEL_20:
    sub_1402E1170();
  v7 = allocWithProfilerInfo_w(v6 + 0x27);
  if ( !v7 )
    goto LABEL_18;
  v8 = (unsigned __int64 *)((v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v8[0xFFFFFFFF] = v7;
LABEL_10:
  v9 = *a1;
  v10 = a1[2] - *a1;
  if ( !v10 )
    goto LABEL_15;
  if ( (unsigned __int64)(8 * v10) >= 0x1000 )
  {
    if ( (unsigned __int64)v9 - v9[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v9 = (unsigned __int64 *)v9[0xFFFFFFFF];
      goto LABEL_14;
    }
LABEL_18:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_14:
  sub_1402A3D30(v9);
LABEL_15:
  result = (unsigned __int64)&v8[v6 / 8];
  *a1 = v8;
  a1[1] = &v8[v6 / 8];
  a1[2] = &v8[v6 / 8];
  if ( v8 != &v8[v6 / 8] )
  {
    do
      *v8++ = buf;
    while ( v8 != (unsigned __int64 *)result );
  }
  return result;
}

// --- End Function: ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@2@@Z (0x1402DE6E0) ---

// --- Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
        __int64 **a1,
        __int64 a2,
        __int64 a3)
{
  _QWORD *v4; // r11
  _QWORD *v6; // rax
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(_QWORD **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 0x18) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (_QWORD *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (_QWORD *)v4[2] )
      v4[2] = a3;
  }
  v8 = a3;
  while ( !*(_BYTE *)(*(_QWORD *)(v8 + 8) + 0x18LL) )
  {
    v9 = *(_QWORD *)(v8 + 8);
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 0x18) )
      {
        v13 = *(_QWORD **)(v9 + 0x10);
        if ( (_QWORD *)v8 == v13 )
        {
          v8 = *(_QWORD *)(v8 + 8);
          *(_QWORD *)(v9 + 0x10) = *v13;
          if ( !*(_BYTE *)(*v13 + 0x19LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(*(_QWORD *)(v8 + 8) + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 0x10LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 0x19) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v12 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 0x18) )
      {
        v19 = *(_QWORD *)v9;
        if ( v8 == *(_QWORD *)v9 )
        {
          v8 = *(_QWORD *)(v8 + 8);
          *(_QWORD *)v9 = *(_QWORD *)(v19 + 0x10);
          v20 = *(_QWORD *)(v19 + 0x10);
          if ( !*(_BYTE *)(v20 + 0x19) )
            *(_QWORD *)(v20 + 8) = v9;
          *(_QWORD *)(v19 + 8) = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(__int64 **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          *(_QWORD *)(v19 + 0x10) = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(*(_QWORD *)(v8 + 8) + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 0x19LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v11 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 0x18LL) = 1;
  return a3;
}

// --- End Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---

// --- Function: unknown_libname_7 (0x1402E11B0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402E11B0) ---

// --- Function: sub_140307890 (0x140307890) ---
char *__fastcall sub_140307890(__int64 a1, _WORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _WORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  char *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 0x10);
  if ( v2 == v4 )
  {
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*(_QWORD *)a1] >> 1;
    if ( v8 == 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = (__int64)&v4[-*(_QWORD *)a1] >> 1;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x7FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_WORD *)sub_140391AB0(a1, 2 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = *(char **)(a1 + 8);
    v16 = *(char **)a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 2;
      Size = *(_QWORD *)(a1 + 8) - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *(_QWORD *)a1 )
      sub_1403A3120(a1, *(const void **)a1, 2 * ((__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 1));
    *(_QWORD *)a1 = v13;
    result = v17;
    *(_QWORD *)(a1 + 8) = &v13[v11];
    *(_QWORD *)(a1 + 0x10) = &v13[v12];
  }
  else
  {
    *(_WORD *)v2 = *a2;
    result = *(char **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result + 2;
  }
  return result;
}

// --- End Function: sub_140307890 (0x140307890) ---

// --- Function: sub_1403084D0 (0x1403084D0) ---
void __fastcall sub_1403084D0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  __int64 *v6; // rdi

  v3 = a3;
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    sub_1403084D0(a1, a2, (__int64 *)v3[2]);
    v6 = v3;
    v3 = (__int64 *)*v3;
    sub_140370D10(v6 + 5);
    sub_1402A3D30(v6);
  }
}

// --- End Function: sub_1403084D0 (0x1403084D0) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)get_thread_context_ptr() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_descriptor_ptr)
{
  unsigned __int64 entity_descriptor_value; // r9
  __int64 entity_base_addr_or_id; // r10
  unsigned __int64 entity_type_and_flags; // r9
  __int64 alignment_boundary_value; // rax
  __int64 entity_base_addr_or_id_for_alignment; // r10
  __int64 entity_header_ptr; // rbx
  bool is_privileged_or_bypass_mode; // al

  entity_descriptor_value = *entity_descriptor_ptr;
  if ( !*entity_descriptor_ptr )
    return 0;
  entity_base_addr_or_id = entity_descriptor_value & 0xFFFFFFFFFFFFLL;
  entity_type_and_flags = HIWORD(entity_descriptor_value);
  if ( (entity_type_and_flags & 0xF000) != 0 )
  {
    alignment_boundary_value = map_flag_to_mask(0x2000u);
    entity_header_ptr = entity_base_addr_or_id_for_alignment & ~(alignment_boundary_value - 1);
  }
  else
  {
    entity_header_ptr = entity_base_addr_or_id - 6;
  }
  if ( *(_WORD *)(entity_header_ptr + 2) != (entity_type_and_flags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D)
    || (is_privileged_or_bypass_mode = is_thread_privileged_or_bypass_mode()) )
  {
    is_privileged_or_bypass_mode = 1;
  }
  return *(_WORD *)(entity_header_ptr + 4) == 2 && is_privileged_or_bypass_mode
      || validate_entity_descriptor_detailed_access(entity_descriptor_ptr) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---

// --- Function: sub_14035B140 (0x14035B140) ---
_QWORD *__fastcall sub_14035B140(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149B3B33C + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035B140 (0x14035B140) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_140360130 (0x140360130) ---
_DWORD *__fastcall sub_140360130(_DWORD *a1)
{
  *a1 = 0xF0000000;
  return a1;
}

// --- End Function: sub_140360130 (0x140360130) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_1403912C0 (0x1403912C0) ---
char __fastcall sub_1403912C0(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+38h] [rbp+10h] BYREF

  v3 = a2;
  if ( (_WORD)a2 == 0xFFFF )
    return 0;
  else
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)qword_149B4FBF8 + 0x70LL))(
             qword_149B4FBF8,
             a1,
             &v3);
}

// --- End Function: sub_1403912C0 (0x1403912C0) ---

// --- Function: sub_1403A3120 (0x1403A3120) ---
void __fastcall sub_1403A3120(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403B38D0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 0x20) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ; v7 + 0x40 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 0x28) = 0 )
    {
      v11 = v7;
      v7 += 0x40LL;
    }
    if ( v7 < v8 )
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~((1LL << ((__int64)v8 % 0x40)) - 1);
  }
  else
  {
    sub_147605980(a2);
  }
}

// --- End Function: sub_1403A3120 (0x1403A3120) ---

// --- Function: sub_1403AC700 (0x1403AC700) ---
const char *__fastcall sub_1403AC700(int a1)
{
  const char *p_Unknown_Pass; // rax

  switch ( a1 )
  {
    case 0:
      p_Unknown_Pass = "PostNetworkStartUpdate";
      break;
    case 1:
      p_Unknown_Pass = "PrePhysicsUpdate-UpdateZoneHost";
      break;
    case 2:
      p_Unknown_Pass = "PrePhysicsUpdate";
      break;
    case 3:
      p_Unknown_Pass = "PrePhysicsUpdate2";
      break;
    case 4:
      p_Unknown_Pass = "TrackviewInterruptUpdate";
      break;
    case 5:
      p_Unknown_Pass = "PreUpdate";
      break;
    case 6:
      p_Unknown_Pass = "Update-UpdateZoneHosts";
      break;
    case 7:
      p_Unknown_Pass = "Update";
      break;
    case 8:
      p_Unknown_Pass = "PostUpdate";
      break;
    case 9:
      p_Unknown_Pass = "PostAnimationUpdate";
      break;
    case 0xA:
      p_Unknown_Pass = "PreRenderUpdate_AimableController";
      break;
    case 0xB:
      p_Unknown_Pass = "PreRenderUpdate_LocalPlayerAimComponent";
      break;
    case 0xC:
      p_Unknown_Pass = "PreRenderUpdate";
      break;
    case 0xD:
      p_Unknown_Pass = "EndOfFrameUpdate";
      break;
    default:
      __debugbreak();
      p_Unknown_Pass = "Unknown Pass";
      break;
  }
  return p_Unknown_Pass;
}

// --- End Function: sub_1403AC700 (0x1403AC700) ---

// --- Function: sub_1403B8D70 (0x1403B8D70) ---
__int64 __fastcall sub_1403B8D70(__int64 a1)
{
  return a1 + 0x88;
}

// --- End Function: sub_1403B8D70 (0x1403B8D70) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403DD380) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(
        __int64 p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  unsigned __int64 new_lock_value; // rdi
  unsigned int thread_context_owner_id; // edx
  signed __int64 current_lock_value_1; // rax
  __int64 p_profiler_system; // rdi
  __int64 thread_context_ptr_1; // r8
  int thread_context_owner_id_2; // ecx
  __int64 thread_context_ptr_2; // r8
  unsigned __int64 thread_id_high_word; // rbx
  const ULONG_PTR *default_lock_owner_ptr; // rax
  int thread_context_info_1; // [rsp+70h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+78h] [rbp+10h] BYREF
  __int64 thread_context_ptr_3; // [rsp+80h] [rbp+18h] BYREF
  __int64 thread_context_ptr_4; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value & 0xFFFFFFFFFFD003FFuLL;
    if ( (current_lock_value & 0xFFFF00100000LL) != 0 )
    {
      new_lock_value = current_lock_value & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (current_lock_value & 0xFFC003FF) == 0 && (current_lock_value & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_4,
        &thread_context_info_2);
      new_lock_value = current_lock_value & 0xFFFFFFD003FFLL;
      thread_context_owner_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_2 - 1)) << 9)
                                          + thread_context_ptr_4
                                          + 0x124);
      if ( thread_context_owner_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)thread_context_owner_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value,
                             current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0x3FF) != 0 )
  {
    if ( (current_lock_value & 0x100000) != 0 )
      qword_149B3B490(p_rw_lock_state);
    if ( (current_lock_value & 0xFFFF00000000LL) != 0 )
    {
      p_profiler_system = ::p_profiler_system;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_3,
        &thread_context_info_1);
      thread_context_ptr_1 = thread_context_ptr_3
                           + ((WORD2(current_lock_value) & (unsigned __int64)(unsigned int)(thread_context_info_1 - 1)) << 9);
      LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_1 + 0x124);
      *(_DWORD *)(thread_context_ptr_1 + 0x11C) = (unsigned __int16)(WORD2(current_lock_value) + thread_context_info_1);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      while ( (_DWORD)current_lock_value != 0xFFFFFFFF )
      {
        thread_context_owner_id_2 = (unsigned __int16)(current_lock_value + thread_context_info_1);
        thread_context_ptr_2 = thread_context_ptr_3
                             + ((unsigned __int64)((unsigned int)current_lock_value & (thread_context_info_1 - 1)) << 9);
        LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_2 + 0x124);
        *(_DWORD *)(thread_context_ptr_2 + 0x11C) = thread_context_owner_id_2;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      }
    }
  }
  else if ( (current_lock_value & 0xFFC00000) != 0 )
  {
    qword_149B3B488(p_rw_lock_state);
  }
  else if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
      ::p_profiler_system,
      &thread_context_ptr_3,
      &thread_context_info_1);
    thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)thread_id_high_word & (thread_context_info_1 - 1)) << 9)
              + thread_context_ptr_3
              + 0x11C) = (unsigned __int16)(thread_id_high_word + thread_context_info_1);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::p_profiler_system + 0xD8LL))(
      ::p_profiler_system,
      (unsigned int)thread_id_high_word);
  }
  default_lock_owner_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(p_rw_lock_state + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return default_lock_owner_ptr;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403DD380) ---

// --- Function: sub_1403F6E80 (0x1403F6E80) ---
void __fastcall sub_1403F6E80(__int64 *a1)
{
  _QWORD *v2; // rcx
  __int64 v3; // rcx
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx

  v2 = (_QWORD *)a1[3];
  if ( v2 )
  {
    if ( ((a1[5] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[3] = 0;
    a1[4] = 0;
    a1[5] = 0;
  }
  v3 = a1[1];
  **(_QWORD **)(v3 + 8) = 0;
  v4 = *(_QWORD **)v3;
  if ( v4 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      sub_1402A3D30(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  sub_1402A3D30((const void *)a1[1]);
}

// --- End Function: sub_1403F6E80 (0x1403F6E80) ---

// --- Function: sub_140518100 (0x140518100) ---
__int64 __fastcall sub_140518100(__int64 a1)
{
  return a1 + 0xD8;
}

// --- End Function: sub_140518100 (0x140518100) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !gEnv || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( gEnv && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_1408FBC10 (0x1408FBC10) ---
void __fastcall sub_1408FBC10(__int64 a1)
{
  const void **v2; // rcx
  unsigned __int64 i; // rbx

  sub_147605980(*(const void **)(a1 + 0x10));
  sub_147605980(*(const void **)(a1 + 0x18));
  sub_147605980(*(const void **)(a1 + 0x20));
  v2 = *(const void ***)(a1 + 0x38);
  for ( i = 0; i < (__int64)(*(_QWORD *)(a1 + 0x40) - (_QWORD)v2) >> 3; ++i )
  {
    sub_147605980(v2[i]);
    v2 = *(const void ***)(a1 + 0x38);
  }
  if ( v2 )
  {
    if ( ((*(_QWORD *)(a1 + 0x48) - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)((char *)v2 - (_BYTE *)v2[0xFFFFFFFF] - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (const void **)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    *(_QWORD *)(a1 + 0x38) = 0;
    *(_QWORD *)(a1 + 0x40) = 0;
    *(_QWORD *)(a1 + 0x48) = 0;
  }
}

// --- End Function: sub_1408FBC10 (0x1408FBC10) ---

// --- Function: sub_1411F87F0 (0x1411F87F0) ---
char *__fastcall sub_1411F87F0(__int64 a1, _BYTE *a2, _WORD *a3)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v13; // rax
  char *v14; // rbx
  char *v15; // rcx
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  size_t Size; // r8

  v3 = (__int64)&a2[-*(_QWORD *)a1] >> 1;
  v5 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if ( v5 == 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 1;
  v9 = v8 >> 1;
  v10 = v5 + 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_19;
  v11 = v5 + 1;
  if ( v9 + v8 >= v10 )
    v11 = v9 + v8;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL )
    goto LABEL_19;
  allocSize = 2 * v11;
  if ( 2 * v11 < 0x1000 )
  {
    if ( allocSize )
      v14 = (char *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_14;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_19:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    invalid_parameter_noinfo_noreturn();
  v14 = (char *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)v14 + 0xFFFFFFFF) = v13;
LABEL_14:
  v15 = v14;
  *(_WORD *)&v14[2 * v3] = *a3;
  v16 = *(_BYTE **)(a1 + 8);
  v17 = *(_BYTE **)a1;
  if ( a2 == v16 )
  {
    Size = v16 - v17;
  }
  else
  {
    memmove(v14, v17, a2 - v17);
    v15 = &v14[2 * v3 + 2];
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v15, v17, Size);
  sub_1403DEA10((const void **)a1, (__int64)v14, v10, v11);
  return &v14[2 * v3];
}

// --- End Function: sub_1411F87F0 (0x1411F87F0) ---

// --- Function: sub_14166FBB0 (0x14166FBB0) ---
__int64 __fastcall sub_14166FBB0(const void **a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    if ( (unsigned __int64)(0x78 * (((_BYTE *)a1[2] - (_BYTE *)v2) / 0x78)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_14166FBB0 (0x14166FBB0) ---

// --- Function: sub_14195D2E0 (0x14195D2E0) ---
__int64 __fastcall sub_14195D2E0(__int64 *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    sub_14042EF40(v2, a1[1]);
    v3 = (_QWORD *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_14195D2E0 (0x14195D2E0) ---

// --- Function: sub_141F4E8E0 (0x141F4E8E0) ---
__int64 __fastcall sub_141F4E8E0(__int64 a1)
{
  return a1 + 0xF0;
}

// --- End Function: sub_141F4E8E0 (0x141F4E8E0) ---

// --- Function: sub_142478E00 (0x142478E00) ---
char *__fastcall sub_142478E00(const void **a1, _BYTE *a2, _WORD *a3)
{
  signed __int64 v3; // rbp
  signed __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _WORD *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  _BYTE *v20; // rcx
  char *result; // rax

  v3 = (a2 - (_BYTE *)*a1) >> 1;
  v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) >> 1;
  if ( v5 == 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 1;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 2 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = (_WORD *)v14 + v3;
  *v15 = *a3;
  v16 = v14;
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v16 = v15 + 1;
    Size = (_BYTE *)a1[1] - a2;
    v18 = a2;
  }
  memmove(v16, v18, Size);
  v20 = *a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(2 * (((_BYTE *)a1[2] - v20) >> 1)) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v20[-*((_QWORD *)v20 + 0xFFFFFFFF) - 8] <= 0x1F )
    {
      v20 = (_BYTE *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = v14;
  result = (char *)v14 + 2 * v3;
  a1[1] = (char *)v14 + 2 * v9;
  a1[2] = (char *)v14 + allocSize;
  return result;
}

// --- End Function: sub_142478E00 (0x142478E00) ---

// --- Function: sub_143A96E90 (0x143A96E90) ---
__int64 __fastcall sub_143A96E90(__int64 *a1, _WORD *a2)
{
  if ( a1[1] == a1[2] )
    return sub_143A99AB0(a1, a1[1], a2);
  else
    return sub_143A965E0(a1, a2);
}

// --- End Function: sub_143A96E90 (0x143A96E90) ---

// --- Function: sub_146A12030 (0x146A12030) ---
void __fastcall sub_146A12030(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  _QWORD *v4; // rcx

  if ( a1 != a2 )
  {
    v3 = a1;
    do
    {
      v4 = *(_QWORD **)v3;
      if ( *(_QWORD *)v3 )
      {
        if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(v3 + 0x10) - (_QWORD)v4) >> 1)) >= 0x1000 )
        {
          if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
            invalid_parameter_noinfo_noreturn();
          v4 = (_QWORD *)v4[0xFFFFFFFF];
        }
        sub_1402A3D30(v4);
        *(_QWORD *)v3 = 0;
        *(_QWORD *)(v3 + 8) = 0;
        *(_QWORD *)(v3 + 0x10) = 0;
      }
      v3 += 0x18;
    }
    while ( v3 != a2 );
  }
}

// --- End Function: sub_146A12030 (0x146A12030) ---

// --- Function: sub_146A15B80 (0x146A15B80) ---
unsigned __int64 __fastcall sub_146A15B80(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  __int64 v8; // rax
  unsigned __int64 v9; // r14
  __int64 v10; // rax
  __int64 v11; // rbx
  _QWORD *v12; // rcx
  unsigned __int64 v13; // rax
  __int64 v14; // r10
  _QWORD *v15; // rcx
  __int64 *i; // rax
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // rdx
  __int64 *v20; // r8
  unsigned __int64 result; // rax

  if ( a2 > 0xAAAAAAAAAAAAAAALL )
    unknown_libname_10();
  v4 = (a1[1] - *a1) / 0x18;
  v5 = (a1[2] - *a1) / 0x18;
  v6 = v5 >> 1;
  if ( v5 > 0xAAAAAAAAAAAAAAALL - (v5 >> 1) )
    goto LABEL_25;
  v7 = v6 + v5;
  if ( v6 + v5 >= a2 )
  {
    if ( v7 > 0xAAAAAAAAAAAAAAALL )
      goto LABEL_25;
  }
  else
  {
    v7 = a2;
  }
  v8 = 3 * v7;
  v9 = 8 * v8;
  if ( (unsigned __int64)(8 * v8) < 0x1000 )
  {
    if ( v9 )
      v11 = allocWithProfilerInfo_w(8 * v8);
    else
      v11 = 0;
    goto LABEL_13;
  }
  if ( v9 + 0x27 < v9 )
LABEL_25:
    sub_1402E1170();
  v10 = allocWithProfilerInfo_w(v9 + 0x27);
  if ( !v10 )
    goto LABEL_23;
  v11 = (v10 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v11 - 8) = v10;
LABEL_13:
  v12 = (_QWORD *)(v11 + 0x18 * v4);
  v13 = a2 - v4;
  if ( a2 != v4 )
  {
    do
    {
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      v12 += 3;
      --v13;
    }
    while ( v13 );
  }
  sub_146A12030((__int64)v12, (__int64)v12);
  v14 = a1[1];
  v15 = (_QWORD *)v11;
  for ( i = (__int64 *)*a1; i != (__int64 *)v14; v15 += 3 )
  {
    v17 = i[2];
    v18 = i[1];
    v19 = *i;
    i[2] = 0;
    i[1] = 0;
    *i = 0;
    i += 3;
    *v15 = v19;
    v15[1] = v18;
    v15[2] = v17;
  }
  sub_146A12030((__int64)v15, (__int64)v15);
  if ( *a1 )
  {
    sub_146A12030(*a1, a1[1]);
    v20 = (__int64 *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) < 0x1000 )
    {
LABEL_21:
      sub_1402A3D30(v20);
      goto LABEL_22;
    }
    if ( (unsigned __int64)v20 - v20[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v20 = (__int64 *)v20[0xFFFFFFFF];
      goto LABEL_21;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  result = v9 + v11;
  *a1 = v11;
  a1[1] = v11 + 0x18 * a2;
  a1[2] = v9 + v11;
  return result;
}

// --- End Function: sub_146A15B80 (0x146A15B80) ---

// --- Function: sub_146A15F20 (0x146A15F20) ---
_WORD *__fastcall sub_146A15F20(unsigned __int64 a1, _WORD *a2, __int64 a3, unsigned __int8 a4)
{
  _WORD *v6; // rbp
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r14
  _WORD *v9; // r15
  _WORD *result; // rax
  _QWORD *v11; // rdi
  unsigned __int64 v12; // r14
  __int64 v13; // rdx
  __int64 v14; // rcx
  char v15; // al
  __int64 v16; // rax
  __int64 v17; // r8
  __int64 v18; // rdx
  __int64 v19; // rax
  _WORD *v20; // [rsp+30h] [rbp-78h] BYREF
  unsigned __int64 v21; // [rsp+38h] [rbp-70h]
  __int64 v22; // [rsp+40h] [rbp-68h] BYREF
  __int16 v23; // [rsp+48h] [rbp-60h]
  char v24; // [rsp+4Ah] [rbp-5Eh]
  char v25; // [rsp+4Bh] [rbp-5Dh]
  char v26; // [rsp+4Ch] [rbp-5Ch]
  int v27; // [rsp+50h] [rbp-58h]
  char v28; // [rsp+54h] [rbp-54h]
  char v29; // [rsp+55h] [rbp-53h]
  __int64 v30; // [rsp+58h] [rbp-50h]
  __int64 v31; // [rsp+60h] [rbp-48h]
  __int64 v32; // [rsp+68h] [rbp-40h]
  __int64 v33; // [rsp+70h] [rbp-38h]
  __int64 v34; // [rsp+78h] [rbp-30h]
  __int64 v35; // [rsp+80h] [rbp-28h]

  v6 = a2;
  v7 = a1;
  if ( (__int64)((__int64)a2 - a1) < 0x948 )
    return sub_146A13430(v7, v6);
  while ( a3 > 0 )
  {
    sub_146A14530((unsigned __int64 *)&v20, v7, (unsigned __int64)v6);
    v8 = v21;
    v9 = v20;
    a3 = (a3 >> 2) + (a3 >> 1);
    if ( (__int64)((__int64)v20 - v7) / 0x48 >= (__int64)((__int64)v6 - v21) / 0x48 )
    {
      sub_146A15F20(v21, v6, a3, a4);
      v6 = v9;
    }
    else
    {
      sub_146A15F20(v7, v20, a3, a4);
      v7 = v8;
    }
    if ( (__int64)((__int64)v6 - v7) < 0x948 )
      return sub_146A13430(v7, v6);
  }
  sub_146A13A40(v7, (__int64)v6);
  result = (_WORD *)((char *)v6 - v7);
  if ( (__int64)((__int64)v6 - v7) >= 0x90 )
  {
    v11 = v6 + 0xFFFFFFEC;
    v12 = 0x28 - v7;
    do
    {
      if ( (__int64)((__int64)v11 + v12) / 0x48 >= 2 )
      {
        v13 = v11[1];
        v14 = *v11;
        LOWORD(v22) = *((_WORD *)v11 + 0xFFFFFFF0);
        BYTE2(v22) = *((_BYTE *)v11 + 0xFFFFFFE2);
        HIDWORD(v22) = *((_DWORD *)v11 + 0xFFFFFFF9);
        v23 = *((_WORD *)v11 + 0xFFFFFFF4);
        v24 = *((_BYTE *)v11 + 0xFFFFFFEA);
        v25 = *((_BYTE *)v11 + 0xFFFFFFEB);
        v26 = *((_BYTE *)v11 + 0xFFFFFFEC);
        v27 = *((_DWORD *)v11 + 0xFFFFFFFC);
        v28 = *((_BYTE *)v11 + 0xFFFFFFF4);
        v15 = *((_BYTE *)v11 + 0xFFFFFFF5);
        v11[1] = 0;
        *v11 = 0;
        v29 = v15;
        v16 = v11[0xFFFFFFFF];
        v11[0xFFFFFFFF] = 0;
        v17 = v11[4];
        v32 = v13;
        v18 = v11[3];
        v30 = v16;
        v19 = v11[2];
        v34 = v18;
        v31 = v14;
        v11[4] = 0;
        v11[3] = 0;
        v11[2] = 0;
        v33 = v19;
        v35 = v17;
        sub_146A1D000((__int64)(v11 + 0xFFFFFFFC), v7);
        sub_146A15600(v7, 0, (__int64)((__int64)v11 - 0x20 - v7) / 0x48, (__int64)&v22);
        sub_146A1CF50(&v22);
      }
      v11 += 0xFFFFFFF7;
      result = (_WORD *)((char *)v11 + v12);
    }
    while ( (__int64)((__int64)v11 + v12) >= 0x90 );
  }
  return result;
}

// --- End Function: sub_146A15F20 (0x146A15F20) ---

// --- Function: sub_146A165D0 (0x146A165D0) ---
__int64 __fastcall sub_146A165D0(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 *v5; // r15
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 *v8; // rbx
  __int64 *v9; // rbp
  __int64 *v10; // rcx
  __int64 **v12; // r13
  _QWORD *v13; // r12
  __int64 v14; // rdi
  __int64 v15; // rcx
  float v16; // xmm1_4
  float v17; // kr00_4
  unsigned __int64 n8_2; // rdx
  float v19; // xmm0_4
  float v20; // kr00_4
  unsigned __int64 v23; // rcx
  unsigned __int64 n8_1; // rax
  unsigned __int64 n8; // rcx
  unsigned __int64 v26; // r8
  __int64 v27; // rdx
  __int64 *v28; // rax
  __int64 *v29; // rdx
  int v30; // ecx
  __int64 *v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // rax
  __int64 *v34; // r8
  unsigned __int64 v35; // [rsp+70h] [rbp+8h]

  v5 = *(__int64 **)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 0x18);
  v35 = 0x100000001B3LL
      * (a3[3]
       ^ (0x100000001B3LL * (a3[2] ^ (0x100000001B3LL * (a3[1] ^ (0x100000001B3LL * (*a3 ^ 0xCBF29CE484222325uLL)))))));
  v7 = 2 * (v35 & *(_QWORD *)(a1 + 0x30));
  v8 = *(__int64 **)(v6 + 8 * v7 + 8);
  if ( v8 == v5 )
  {
    v8 = v5;
    v9 = v5;
  }
  else
  {
    v10 = *(__int64 **)(v6 + 8 * v7);
    if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
    {
LABEL_6:
      *(_QWORD *)a2 = v8;
      *(_BYTE *)(a2 + 8) = 0;
      return a2;
    }
    while ( v8 != v10 )
    {
      v8 = (__int64 *)v8[1];
      if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
        goto LABEL_6;
    }
    v5 = v8;
    v9 = v8;
  }
  v12 = (__int64 **)(a1 + 8);
  v13 = (_QWORD *)(a1 + 0x30);
  if ( *(_QWORD *)(a1 + 0x10) == 0xAAAAAAAAAAAAAAALL )
    std::_Xlength_error("unordered_map/set too long");
  v14 = allocWithProfilerInfo_w(0x18u);
  *(_DWORD *)(v14 + 0x10) = *(_DWORD *)a3;
  *(_WORD *)(v14 + 0x14) = 0xFFFF;
  v15 = *(_QWORD *)(a1 + 0x10) + 1LL;
  if ( v15 < 0 )
  {
    v17 = (float)(v15 & 1 | ((unsigned __int64)v15 >> 1));
    v16 = v17 + v17;
  }
  else
  {
    v16 = (float)v15;
  }
  n8_2 = *(_QWORD *)(a1 + 0x38);
  if ( (n8_2 & 0x8000000000000000uLL) != 0LL )
  {
    v20 = (float)(*(_QWORD *)(a1 + 0x38) & 1LL | (n8_2 >> 1));
    v19 = v20 + v20;
  }
  else
  {
    v19 = (float)(__int64)n8_2;
  }
  if ( *(float *)a1 >= (float)(v16 / v19) )
  {
    v26 = v35;
  }
  else
  {
    _XMM1 = 0;
    __asm { vroundss xmm1, xmm1, xmm0, 2 }
    v23 = 0;
    if ( *(float *)&_XMM1 >= 9.223372e18 )
    {
      *(float *)&_XMM1 = *(float *)&_XMM1 - 9.223372e18;
      if ( *(float *)&_XMM1 < 9.223372e18 )
        v23 = 0x8000000000000000uLL;
    }
    n8_1 = v23 + (unsigned int)(int)*(float *)&_XMM1;
    n8 = 8;
    if ( n8_1 > 8 )
      n8 = n8_1;
    if ( n8_2 < n8 )
    {
      if ( n8_2 >= 0x200 || (n8_2 *= 8LL, n8_2 < n8) )
        n8_2 = n8;
    }
    std::_Hash<std::_Umap_traits<int,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>>>,0>>::_Forced_rehash(
      (unsigned __int64 **)a1,
      n8_2);
    v26 = v35;
    v27 = *(_QWORD *)(a1 + 0x18);
    v8 = *(__int64 **)(a1 + 8);
    v28 = *(__int64 **)(v27 + 0x10 * (v35 & *(_QWORD *)(a1 + 0x30)) + 8);
    if ( v28 != v8 )
    {
      v29 = *(__int64 **)(v27 + 0x10 * (v35 & *(_QWORD *)(a1 + 0x30)));
      v30 = *(_DWORD *)(v14 + 0x10);
      if ( v30 != *((_DWORD *)v28 + 4) )
      {
        while ( 1 )
        {
          v8 = v28;
          if ( v28 == v29 )
            break;
          v28 = (__int64 *)v28[1];
          if ( v30 == *((_DWORD *)v28 + 4) )
            goto LABEL_30;
        }
        v13 = (_QWORD *)(a1 + 0x30);
        v12 = (__int64 **)(a1 + 8);
        v9 = v28;
        v5 = v28;
        goto LABEL_34;
      }
LABEL_30:
      v8 = (__int64 *)*v28;
    }
    v13 = (_QWORD *)(a1 + 0x30);
    v9 = v8;
    v12 = (__int64 **)(a1 + 8);
    v5 = v8;
  }
LABEL_34:
  v31 = (__int64 *)v8[1];
  ++*(_QWORD *)(a1 + 0x10);
  *(_QWORD *)v14 = v5;
  *(_QWORD *)(v14 + 8) = v31;
  *v31 = v14;
  v8[1] = v14;
  v32 = *(_QWORD *)(a1 + 0x18);
  v33 = 2 * (v26 & *v13);
  v34 = *(__int64 **)(v32 + 0x10 * (v26 & *v13));
  if ( v34 == *v12 )
  {
    *(_QWORD *)(v32 + 8 * v33) = v14;
    goto LABEL_39;
  }
  if ( v34 != v9 )
  {
    if ( *(__int64 **)(v32 + 8 * v33 + 8) != v31 )
    {
LABEL_40:
      *(_QWORD *)a2 = v14;
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
LABEL_39:
    *(_QWORD *)(v32 + 8 * v33 + 8) = v14;
    goto LABEL_40;
  }
  *(_QWORD *)(v32 + 8 * v33) = v14;
  *(_QWORD *)a2 = v14;
  *(_BYTE *)(a2 + 8) = 1;
  return a2;
}

// --- End Function: sub_146A165D0 (0x146A165D0) ---

// --- Function: sub_146A1A2E0 (0x146A1A2E0) ---
unsigned __int64 *__fastcall sub_146A1A2E0(__int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int16 *p_n0x800)
{
  __int64 v6; // r8
  __int16 n0x800; // ax
  unsigned __int64 *result; // rax
  __int128 v9; // xmm0
  __int64 v10; // r14
  volatile signed __int32 **v11; // rsi
  volatile signed __int32 *v12; // rax
  volatile signed __int32 *v13; // rcx
  volatile signed __int32 *v14; // rdi
  volatile signed __int32 *v15; // rdi
  __int16 n0x800_1; // [rsp+28h] [rbp-30h] BYREF
  __int128 v17; // [rsp+30h] [rbp-28h]

  v6 = a1[1];
  if ( v6 == a1[2] )
  {
    *a2 = sub_146A12910(a1, a3, (__int64)p_n0x800);
    return a2;
  }
  else
  {
    n0x800 = *p_n0x800;
    if ( a3 == v6 )
    {
      *(_WORD *)v6 = n0x800;
      *(_QWORD *)(v6 + 8) = 0;
      *(_QWORD *)(v6 + 0x10) = 0;
      *(_QWORD *)(v6 + 8) = *((_QWORD *)p_n0x800 + 1);
      *(_QWORD *)(v6 + 0x10) = *((_QWORD *)p_n0x800 + 2);
      result = a2;
      *((_QWORD *)p_n0x800 + 1) = 0;
      *((_QWORD *)p_n0x800 + 2) = 0;
      a1[1] += 0x18;
      *a2 = a3;
    }
    else
    {
      v9 = *(_OWORD *)(p_n0x800 + 4);
      *((_QWORD *)p_n0x800 + 1) = 0;
      *((_QWORD *)p_n0x800 + 2) = 0;
      n0x800_1 = n0x800;
      *(_WORD *)v6 = *(_WORD *)(v6 - 0x18);
      *(_QWORD *)(v6 + 8) = 0;
      *(_QWORD *)(v6 + 0x10) = 0;
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(v6 - 0x10);
      *(_QWORD *)(v6 + 0x10) = *(_QWORD *)(v6 - 8);
      v10 = v6 - 0x18;
      *(_QWORD *)(v10 + 8) = 0;
      *(_QWORD *)(v10 + 0x10) = 0;
      a1[1] += 0x18;
      v17 = v9;
      if ( v6 - 0x18 != a3 )
      {
        v11 = (volatile signed __int32 **)(v6 + 0x10);
        do
        {
          v11 += 0xFFFFFFFD;
          *((_WORD *)v11 + 0xFFFFFFF8) = *(_WORD *)(v10 - 0x18);
          v10 -= 0x18;
          v12 = v11[0xFFFFFFFC];
          v13 = v11[0xFFFFFFFD];
          v11[0xFFFFFFFC] = 0;
          v11[0xFFFFFFFD] = 0;
          v14 = *v11;
          v11[0xFFFFFFFF] = v12;
          *v11 = v13;
          if ( v14 )
          {
            if ( _InterlockedExchangeAdd(v14 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v14)(v14);
              if ( _InterlockedExchangeAdd(v14 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v14 + 8LL))(v14);
            }
          }
        }
        while ( v10 != a3 );
      }
      sub_146A0CB20(a3, (__int64)&n0x800_1);
      v15 = (volatile signed __int32 *)*((_QWORD *)&v17 + 1);
      if ( *((_QWORD *)&v17 + 1)
        && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v17 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
        if ( _InterlockedExchangeAdd(v15 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8LL))(v15);
      }
      result = a2;
      *a2 = a3;
    }
  }
  return result;
}

// --- End Function: sub_146A1A2E0 (0x146A1A2E0) ---

// --- Function: sub_146A1B960 (0x146A1B960) ---
__int64 __fastcall sub_146A1B960(__int64 a1)
{
  __int16 v2; // bp
  __int64 v3; // rax
  const vraudio::AudioBuffer **_Whereptr; // rdx
  _QWORD *v5; // rax
  __int64 v6; // rcx
  _QWORD *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rax
  _QWORD *v11; // rax
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rdi
  char *v15; // rsi
  _QWORD *v16; // rcx

  *(_QWORD *)a1 = off_148C17B90;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  v2 = *(_WORD *)(a1 + 0x28);
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  ++*(_DWORD *)(a1 + 0x28);
  *(_QWORD *)(a1 + 0x30) = sub_147605AA0(*(void **)(a1 + 0x30), 0xCu, 0);
  *(_DWORD *)(a1 + 0x20) = 0xC;
  *(_DWORD *)(a1 + 0x24) = 0xC;
  v3 = allocWithProfilerInfo(0x1000u, 0);
  *(_QWORD *)(a1 + 0x48) = v3;
  *(_QWORD *)(a1 + 0x50) = 2;
  _Whereptr = *(const vraudio::AudioBuffer ***)(a1 + 0x60);
  if ( _Whereptr == *(const vraudio::AudioBuffer ***)(a1 + 0x68) )
  {
    sub_1402A6760(
      (std::vector<vraudio::AudioBuffer const *> *)(a1 + 0x58),
      _Whereptr,
      (const vraudio::AudioBuffer **)(a1 + 0x48));
  }
  else
  {
    *_Whereptr = (const vraudio::AudioBuffer *)v3;
    *(_QWORD *)(a1 + 0x60) += 8LL;
  }
  v5 = (_QWORD *)sub_147605AA0(*(void **)(a1 + 0x38), 8LL * *(unsigned int *)(a1 + 0x28), 0);
  v6 = *(_QWORD *)(a1 + 0x48);
  *(_QWORD *)(a1 + 0x38) = v5;
  *v5 = v6;
  ***(_BYTE ***)(a1 + 0x38) = 0;
  v7 = (_QWORD *)sub_147605AA0(*(void **)(a1 + 0x40), 8LL * *(unsigned int *)(a1 + 0x28), 0);
  v8 = *(_QWORD *)(a1 + 0x48);
  *(_QWORD *)(a1 + 0x40) = v7;
  *v7 = v8 + 1;
  ***(_BYTE ***)(a1 + 0x40) = 0;
  *(_DWORD *)(a1 + 0x2C) = *(_DWORD *)(a1 + 0x28);
  v9 = *(_QWORD *)(a1 + 0x30);
  *(_WORD *)v9 = v2;
  *(_WORD *)(v9 + 2) = 0;
  *(_QWORD *)(v9 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  v10 = allocWithProfilerInfo_w(0x28u);
  *(_QWORD *)v10 = v10;
  *(_QWORD *)(v10 + 8) = v10;
  *(_QWORD *)(v10 + 0x10) = v10;
  *(_WORD *)(v10 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x88) = v10;
  *(_DWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  v11 = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  *v11 = v11;
  v11[1] = v11;
  *(_QWORD *)(a1 + 0xA0) = v11;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 7;
  *(_QWORD *)(a1 + 0xD0) = 8;
  *(_DWORD *)(a1 + 0x98) = 0x3F800000;
  std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
    (unsigned __int64 **)(a1 + 0xB0),
    0x10u,
    *(_QWORD *)(a1 + 0xA0));
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = 0;
  *(_QWORD *)(a1 + 0xE8) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  v12 = allocWithProfilerInfo_w(0x30u);
  *(_QWORD *)v12 = v12;
  *(_QWORD *)(v12 + 8) = v12;
  *(_QWORD *)(v12 + 0x10) = v12;
  *(_WORD *)(v12 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0xF0) = v12;
  *(_DWORD *)(a1 + 0x100) = 0;
  *(_WORD *)(a1 + 0x104) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  v13 = *(_QWORD *)(a1 + 0xD8);
  if ( (unsigned __int64)((*(_QWORD *)(a1 + 0xE8) - v13) >> 1) < 0x40 )
  {
    v14 = (*(_QWORD *)(a1 + 0xE0) - v13) >> 1;
    v15 = (char *)allocWithProfilerInfo_w(0x80u);
    memmove(v15, *(const void **)(a1 + 0xD8), *(_QWORD *)(a1 + 0xE0) - *(_QWORD *)(a1 + 0xD8));
    v16 = *(_QWORD **)(a1 + 0xD8);
    if ( v16 )
    {
      if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(a1 + 0xE8) - (_QWORD)v16) >> 1)) >= 0x1000 )
      {
        if ( (unsigned __int64)v16 - v16[0xFFFFFFFF] - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v16 = (_QWORD *)v16[0xFFFFFFFF];
      }
      sub_1402A3D30(v16);
    }
    *(_QWORD *)(a1 + 0xD8) = v15;
    *(_QWORD *)(a1 + 0xE0) = &v15[2 * v14];
    *(_QWORD *)(a1 + 0xE8) = v15 + 0x80;
  }
  return a1;
}

// --- End Function: sub_146A1B960 (0x146A1B960) ---

// --- Function: sub_146A1C9A0 (0x146A1C9A0) ---
__int64 __fastcall sub_146A1C9A0(__int64 *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    sub_146A12030(v2, a1[1]);
    v3 = (_QWORD *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_146A1C9A0 (0x146A1C9A0) ---

// --- Function: sub_146A1CA30 (0x146A1CA30) ---
__int64 (__fastcall **__fastcall sub_146A1CA30(__int64 a1))()
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rbx
  const void *v4; // rcx
  __int64 (__fastcall **result)(); // rax

  *(_QWORD *)a1 = off_148C17B90;
  sub_14166FBB0((const void **)(a1 + 0x108));
  sub_1403084D0(a1 + 0xF0, a1 + 0xF0, *(__int64 **)(*(_QWORD *)(a1 + 0xF0) + 8LL));
  sub_1402A3D30(*(const void **)(a1 + 0xF0));
  v2 = *(_QWORD **)(a1 + 0xD8);
  if ( v2 )
  {
    if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(a1 + 0xE8) - (_QWORD)v2) >> 1)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    *(_QWORD *)(a1 + 0xD8) = 0;
    *(_QWORD *)(a1 + 0xE0) = 0;
    *(_QWORD *)(a1 + 0xE8) = 0;
  }
  sub_1403F6E80((__int64 *)(a1 + 0x98));
  v3 = *(_QWORD **)(*(_QWORD *)(a1 + 0x88) + 8LL);
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *)(a1 + 0x88),
      (std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *)(a1 + 0x88),
      (std::_Tree_node<gte::Logger::Listener *,void *> *)v3[2]);
    v4 = v3;
    v3 = (_QWORD *)*v3;
    sub_1402A3D30(v4);
  }
  sub_1402A3D30(*(const void **)(a1 + 0x88));
  sub_146A1C9A0((__int64 *)(a1 + 0x70));
  sub_1408FBC10(a1 + 0x20);
  sub_14195D2E0((__int64 *)(a1 + 8));
  result = &off_1481C0BC8;
  *(_QWORD *)a1 = &off_1481C0BC8;
  return result;
}

// --- End Function: sub_146A1CA30 (0x146A1CA30) ---

// --- Function: sub_146A24480 (0x146A24480) ---
char *__fastcall sub_146A24480(char *a1, char a2)
{
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  const void *v6; // rcx

  *(_QWORD *)a1 = off_148C17B90;
  sub_14166FBB0((const void **)a1 + 0x21);
  sub_1403084D0((__int64)(a1 + 0xF0), (__int64)(a1 + 0xF0), *(__int64 **)(*((_QWORD *)a1 + 0x1E) + 8LL));
  sub_1402A3D30(*((const void **)a1 + 0x1E));
  v4 = (_QWORD *)*((_QWORD *)a1 + 0x1B);
  if ( v4 )
  {
    if ( (unsigned __int64)(2 * ((__int64)(*((_QWORD *)a1 + 0x1D) - (_QWORD)v4) >> 1)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    *((_QWORD *)a1 + 0x1B) = 0;
    *((_QWORD *)a1 + 0x1C) = 0;
    *((_QWORD *)a1 + 0x1D) = 0;
  }
  sub_1403F6E80((__int64 *)a1 + 0x13);
  v5 = *(_QWORD **)(*((_QWORD *)a1 + 0x11) + 8LL);
  while ( !*((_BYTE *)v5 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *)(a1 + 0x88),
      (std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *)(a1 + 0x88),
      (std::_Tree_node<gte::Logger::Listener *,void *> *)v5[2]);
    v6 = v5;
    v5 = (_QWORD *)*v5;
    sub_1402A3D30(v6);
  }
  sub_1402A3D30(*((const void **)a1 + 0x11));
  sub_146A1C9A0((__int64 *)a1 + 0xE);
  sub_1408FBC10((__int64)(a1 + 0x20));
  sub_14195D2E0((__int64 *)a1 + 1);
  *(_QWORD *)a1 = &off_1481C0BC8;
  if ( (a2 & 1) != 0 )
    sub_1402A3D30(a1);
  return a1;
}

// --- End Function: sub_146A24480 (0x146A24480) ---

// --- Function: sub_146A24990 (0x146A24990) ---
double __fastcall sub_146A24990(__int64 a1, __int64 a2, char a3, char a4)
{
  __int64 v7; // r8
  unsigned __int64 v8; // rdx
  __int64 n0xE; // r12
  __int64 v10; // rbx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rcx
  __int64 v13; // rcx
  bool v14; // r15
  volatile signed __int64 *v15; // rdi
  signed __int64 v16; // rdx
  int n0xE_1; // ecx
  char v18; // si
  _OWORD *v19; // rax
  char v20; // si
  unsigned __int64 p_p_sub_146A26220[2]; // [rsp+30h] [rbp-69h] BYREF
  int n0x1000; // [rsp+40h] [rbp-59h] BYREF
  __int64 v24; // [rsp+44h] [rbp-55h]
  int v25; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v26; // [rsp+50h] [rbp-49h]
  unsigned __int64 v27; // [rsp+58h] [rbp-41h]
  __int64 v28; // [rsp+60h] [rbp-39h]
  __int64 v29; // [rsp+68h] [rbp-31h]
  __int128 v30; // [rsp+90h] [rbp-9h]
  __int128 v31; // [rsp+A0h] [rbp+7h] BYREF
  __int64 v32; // [rsp+B0h] [rbp+17h] BYREF
  char v33; // [rsp+B8h] [rbp+1Fh]
  __int64 v34; // [rsp+108h] [rbp+6Fh]

  n0x1000 = 0x1000;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v24 = 1;
  v26 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x1000,
    &word_1515B005C,
    "CEntityComponentUpdateScheduler::ActivateComponent",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0xF65);
  HIWORD(n0x1000) = word_1515B005C;
  p_p_sub_146A26220[0] = *(_QWORD *)(a2 + 8);
  if ( !is_entity_descriptor_valid_or_accessible(p_p_sub_146A26220) )
    goto LABEL_39;
  v7 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v8 = __popcnt(*(_QWORD *)(v7 + a1 + 0x42B8) & ((1LL << a3) - 1));
  n0xE = *(int *)(*(_QWORD *)(v7 + a1 + 0x4150) + 0x20 * v8 + 0xC);
  v10 = *(_QWORD *)(a2 + 0x18) + 0xC * v8;
  v11 = p_p_sub_146A26220[0];
  if ( p_p_sub_146A26220[0] )
  {
    v12 = (p_p_sub_146A26220[0] & 0xF000000000000000uLL) != 0
        ? p_p_sub_146A26220[0] & 0xFFFFFF000000LL
        : (p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v12 + 2) == (HIWORD(p_p_sub_146A26220[0]) & 0xFFF) )
    {
      if ( *(_WORD *)(v12 + 4) < 3u )
      {
LABEL_10:
        if ( (v11 & 0xFFFFFFFFFFFFLL) != 0 )
        {
          v13 = (v11 & 0xF000000000000000uLL) != 0 ? v11 & 0xFFFFFF000000LL : (v11 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v13 + 4) == 1 )
          {
            _InterlockedOr8((volatile signed __int8 *)(v10 + 0xB), 2u);
            goto LABEL_39;
          }
        }
        goto LABEL_16;
      }
      if ( check_thread_state_and_value_not_equal((_QWORD *)(p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL)) )
      {
        v11 = p_p_sub_146A26220[0];
        goto LABEL_10;
      }
    }
  }
LABEL_16:
  v14 = !is_thread_privileged_or_bypass_mode() && !*(_BYTE *)(get_thread_context_ptr() + 0x12D);
  v34 = a1 + 0x478 * n0xE;
  v15 = (volatile signed __int64 *)(v34 + 0x1D0);
  if ( *(_DWORD *)(v34 + 0x1E0) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(v34 + 0x1E4);
  }
  else
  {
    v16 = _InterlockedIncrement64(v15);
    if ( (v16 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)v15,
        v16,
        "CEntityComponentUpdateScheduler::ActivateComponent",
        "m_perPassState[nPass].bIsRunningLock",
        1);
  }
  if ( a4
    || v14
    || (n0xE_1 = *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x920LL),
        n0xE_1 == 0x10)
    || n0xE_1 != (_DWORD)n0xE && *(_BYTE *)(v34 + 0x1C9) )
  {
    v33 = a3;
    v32 = a2;
    _InterlockedIncrement16((volatile signed __int16 *)(a2 + 0x22));
    sub_1403CA640(a1 + 0x30, &v32, 0x10u);
  }
  else if ( !*(_BYTE *)(v10 + 9) )
  {
    if ( n0xE_1 == (_DWORD)n0xE )
    {
      if ( !*(_BYTE *)(v10 + 0xA) )
      {
        v18 = *(_BYTE *)(v10 + 0xA);
        *(_BYTE *)(v10 + 0xA) = 1;
        if ( !v18 )
        {
          *(_QWORD *)&v30 = a2;
          BYTE8(v30) = a3;
          v19 = (_OWORD *)sub_1403CA4D0(a1 + 0x174970, 0x10u, 0);
          *v19 = v30;
        }
      }
    }
    else
    {
      v20 = *(_BYTE *)(v10 + 9);
      *(_BYTE *)(v10 + 9) = 1;
      if ( !v20 )
      {
        *(_BYTE *)(v10 + 7) = 0;
        *(_QWORD *)&v31 = a2;
        BYTE8(v31) = a3;
        if ( sub_146A4A420(
               (volatile signed __int64 *)((p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL) + 0x18 * (n0xE + 0x25)),
               &v31,
               0) )
        {
          sub_146A24D00(a1, p_p_sub_146A26220, (unsigned int)n0xE, 0);
        }
      }
    }
  }
  rw_lock_release_read_lock((__int64)v15);
LABEL_39:
  v27 = __rdtsc();
  return qword_149B4B878(&n0x1000);
}

// --- End Function: sub_146A24990 (0x146A24990) ---

// --- Function: sub_146A24F10 (0x146A24F10) ---
unsigned __int64 __fastcall sub_146A24F10(
        __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source,
        const vraudio::AudioBuffer *__Val_0___1,
        __int64 a3)
{
  __int64 v4; // rbx
  const vraudio::AudioBuffer *__Val_0___2; // rsi
  unsigned __int64 thread_context_ptr; // rax
  int v7; // ebp
  __int64 v8; // r8
  __int64 __Val_0___3; // rdx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  int v11; // eax
  unsigned __int64 n0x200000; // rax
  const vraudio::AudioBuffer *__Val_0__; // [rsp+58h] [rbp+10h] BYREF

  __Val_0__ = __Val_0___1;
  v4 = a3 + 0x10;
  __Val_0___2 = __Val_0___1;
  thread_context_ptr = get_thread_context_ptr();
  v7 = *(_DWORD *)(thread_context_ptr + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v8 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    thread_context_ptr = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0x200000, 0);
    if ( thread_context_ptr )
      thread_context_ptr = sub_1403DCD60(
                             v4,
                             thread_context_ptr,
                             v8,
                             "CEntityComponentUpdateScheduler::ActivateDebugUpdate",
                             "pAllocator->lock",
                             1);
    else
      *(_QWORD *)(v4 + 8) = v8;
    __Val_0___2 = __Val_0__;
    *(_DWORD *)(v4 + 0x10) = v7;
  }
  if ( !*((_BYTE *)__Val_0___2 + 0x68) )
  {
    __Val_0___3 = *(_QWORD *)(*(_QWORD *)(a3 + 0x2D0) - 8LL);
    if ( (const vraudio::AudioBuffer *)__Val_0___3 != __Val_0___2 )
    {
      *(_QWORD *)(*(_QWORD *)(a3 + 0x2C8) + 8LL * *((unsigned int *)__Val_0___2 + 0x19)) = __Val_0___3;
      *(_DWORD *)(__Val_0___3 + 0x64) = *((_DWORD *)__Val_0___2 + 0x19);
    }
    *(_QWORD *)(a3 + 0x2D0) -= 8LL;
    _Whereptr = *(const vraudio::AudioBuffer ***)(a3 + 0x2B8);
    if ( _Whereptr == *(const vraudio::AudioBuffer ***)(a3 + 0x2C0) )
    {
      sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)(a3 + 0x2B0), _Whereptr, &__Val_0__);
    }
    else
    {
      *_Whereptr = __Val_0___2;
      *(_QWORD *)(a3 + 0x2B8) += 8LL;
    }
    thread_context_ptr = (unsigned int)((__int64)(*(_QWORD *)(a3 + 0x2B8) - *(_QWORD *)(a3 + 0x2B0)) >> 3) - 1;
    *((_DWORD *)__Val_0___2 + 0x19) = thread_context_ptr;
    *((_BYTE *)__Val_0___2 + 0x68) = 1;
  }
  if ( v4 )
  {
    v11 = *(_DWORD *)(v4 + 0x14);
    if ( v11 )
    {
      thread_context_ptr = (unsigned int)(v11 - 1);
      *(_DWORD *)(v4 + 0x14) = thread_context_ptr;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        thread_context_ptr = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v4 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return (unsigned __int64)rw_lock_handle_write_release_contention(v4, n0x200000);
      }
    }
  }
  return thread_context_ptr;
}

// --- End Function: sub_146A24F10 (0x146A24F10) ---

// --- Function: sub_146A27DC0 (0x146A27DC0) ---
unsigned __int64 __fastcall sub_146A27DC0(__int64 a1, unsigned __int16 a2, __int16 a3)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rsi
  __int64 v5; // rbp
  __int64 v6; // rbx
  unsigned __int64 thread_context_ptr; // rax
  int v8; // edi
  __int64 v9; // r8
  int v10; // eax
  unsigned __int64 n0x200000; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v5 = 0x2E0LL * a2;
  v6 = v5 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4068;
  thread_context_ptr = get_thread_context_ptr();
  v8 = *(_DWORD *)(thread_context_ptr + 0x18);
  if ( *(_DWORD *)(v6 + 0x10) == v8 )
  {
    ++*(_DWORD *)(v6 + 0x14);
  }
  else
  {
    v9 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    thread_context_ptr = _InterlockedCompareExchange64((volatile signed __int64 *)v6, 0x200000, 0);
    if ( thread_context_ptr )
      thread_context_ptr = sub_1403DCD60(
                             v6,
                             thread_context_ptr,
                             v9,
                             "CEntityComponentUpdateScheduler::ChangeComponentDebugUpdatePolicy",
                             "pAllocator->lock",
                             1);
    else
      *(_QWORD *)(v6 + 8) = v9;
    *(_DWORD *)(v6 + 0x10) = v8;
  }
  *(_WORD *)(v5 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x4098) = a3;
  *(_BYTE *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1F4F62) = 1;
  if ( v6 )
  {
    v10 = *(_DWORD *)(v6 + 0x14);
    if ( v10 )
    {
      thread_context_ptr = (unsigned int)(v10 - 1);
      *(_DWORD *)(v6 + 0x14) = thread_context_ptr;
    }
    else
    {
      *(_DWORD *)(v6 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v6, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        thread_context_ptr = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v6 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return (unsigned __int64)rw_lock_handle_write_release_contention(v6, n0x200000);
      }
    }
  }
  return thread_context_ptr;
}

// --- End Function: sub_146A27DC0 (0x146A27DC0) ---

// --- Function: sub_146A28460 (0x146A28460) ---
__int64 __fastcall sub_146A28460(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v6; // rax
  _BYTE *v7; // rdx
  _QWORD *v8; // r12
  __int64 n4; // rcx
  bool v10; // zf
  _BYTE *v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r10
  __int64 v16; // r11
  __int64 v17; // rdi
  __int64 v18; // rsi
  __int64 n4_1; // rcx
  _QWORD *v20; // rdi
  _QWORD *i; // rbp
  __int64 v22; // rbx
  __int64 v23; // rdx
  char *v24; // r8
  char *v25; // r9
  char *v26; // r10
  __int64 v27; // rcx
  __int64 n4_2; // rdx
  bool v29; // al
  __int64 v30; // rsi
  __int64 v31; // rdx
  __int64 v32; // rax
  unsigned __int16 v33; // cx
  __int64 v34; // rax
  __int128 v35; // xmm0
  int v36; // ecx
  __int128 v37; // [rsp+20h] [rbp-78h] BYREF
  double v38; // [rsp+40h] [rbp-58h] BYREF
  int v39; // [rsp+48h] [rbp-50h] BYREF

  result = sub_142306700(a2);
  if ( *(_DWORD *)((*(_QWORD *)result & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF )
  {
    v6 = sub_146B49880(qword_1515B1A08, (_QWORD *)result);
    v7 = (_BYTE *)(a3 + 0x2A0);
    v8 = (_QWORD *)v6;
    n4 = 4;
    do
    {
      v10 = (v7++)[v6 - a3 - 0x22C] == 0;
      v7[0xFFFFFFFF] = !v10;
      v7[3] = v7[v6 - a3 - 0x225] != 0;
      v7[7] = v7[v6 - a3 - 0x1ED];
      v7[0xB] = v7[v6 - a3 - 0x231] != 0;
      v7[0xF] = v7[v6 - a3 - 0x229] != 0;
      v7[0x13] = v7[v6 - a3 - 0x1E9];
      --n4;
    }
    while ( n4 );
    result = *(unsigned __int16 *)(a2 + 0x2EC);
    if ( (_WORD)result != 0xFFFF )
    {
      v11 = (_BYTE *)(a3 + 0x2B8);
      v12 = v8[1] + 0x38 * result - a3;
      v13 = v12 - 0x29C;
      v14 = v12 - 0x294;
      v15 = v12 - 0x290;
      v16 = v12 - 0x2A0;
      v17 = v12 - 0x298;
      v18 = v12 - 0x28C;
      n4_1 = 4;
      do
      {
        v10 = (v11++)[v13] == 0;
        v11[0xFFFFFFFF] = !v10;
        v11[3] = v11[v14 - 1] != 0;
        v11[7] = v11[v15 - 1];
        v11[0xB] = v11[v16 - 1] != 0;
        v11[0xF] = v11[v17 - 1] != 0;
        result = (unsigned __int8)v11[v18 - 1];
        v11[0x13] = result;
        --n4_1;
      }
      while ( n4_1 );
    }
    v20 = *(_QWORD **)(a2 + 0x240);
    for ( i = *(_QWORD **)(a2 + 0x248); v20 != i; ++v20 )
    {
      v22 = *v20 & 0xFFFFFFFFFFFFLL;
      result = *(unsigned __int16 *)(v22 + 0x62);
      if ( (_WORD)result != 0xFFFF )
      {
        v23 = *v8 + 0x20LL * *(unsigned __int16 *)(v22 + 0x62);
        v24 = (char *)&v38 - v23;
        v25 = (char *)&v38 - v23 + 4;
        v26 = (char *)&v39 - v23;
        v27 = v23 + 0x10;
        n4_2 = 4;
        do
        {
          v10 = *(_BYTE *)(v27 - 4) == 0;
          ++v27;
          v29 = !v10;
          v10 = *(_BYTE *)(v27 - 1) == 0;
          v24[v27 - 0x11] = v29;
          v25[v27 - 0x11] = !v10;
          v26[v27 - 0x11] = *(_BYTE *)(v27 + 3);
          --n4_2;
        }
        while ( n4_2 );
        v30 = *(_QWORD *)(a3 + 0x2D0);
        DWORD2(v37) = 0;
        v31 = v30;
        v32 = *(_QWORD *)(v30 + 8);
        *(_QWORD *)&v37 = v32;
        if ( !*(_BYTE *)(v32 + 0x19) )
        {
          v33 = *(_WORD *)(v22 + 0x10);
          do
          {
            *(_QWORD *)&v37 = v32;
            if ( *(_WORD *)(v32 + 0x1A) >= v33 )
            {
              v31 = v32;
              DWORD2(v37) = 1;
              v32 = *(_QWORD *)v32;
            }
            else
            {
              v32 = *(_QWORD *)(v32 + 0x10);
              DWORD2(v37) = 0;
            }
          }
          while ( !*(_BYTE *)(v32 + 0x19) );
        }
        if ( *(_BYTE *)(v31 + 0x19)
          || (result = *(unsigned __int16 *)(v31 + 0x1A), *(_WORD *)(v22 + 0x10) < (unsigned __int16)result) )
        {
          if ( *(_QWORD *)(a3 + 0x2D8) == 0x666666666666666LL )
            unknown_libname_7();
          v34 = allocWithProfilerInfo_w(0x28u);
          v35 = v37;
          *(_WORD *)(v34 + 0x1A) = *(_WORD *)(v22 + 0x10);
          *(_QWORD *)(v34 + 0x1C) = 0;
          *(_DWORD *)(v34 + 0x24) = 0;
          *(_QWORD *)v34 = v30;
          *(_QWORD *)(v34 + 8) = v30;
          *(_QWORD *)(v34 + 0x10) = v30;
          *(_WORD *)(v34 + 0x18) = 0;
          v37 = v35;
          result = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                     (__int64 **)(a3 + 0x2D0),
                     (__int64)&v37,
                     v34);
          v31 = result;
        }
        v36 = v39;
        *(double *)(v31 + 0x1C) = v38;
        *(_DWORD *)(v31 + 0x24) = v36;
      }
    }
  }
  return result;
}

// --- End Function: sub_146A28460 (0x146A28460) ---

// --- Function: sub_146A28BD0 (0x146A28BD0) ---
unsigned __int64 __fastcall sub_146A28BD0(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, __int64 a3, __int64 a4)
{
  __int16 *v4; // r13
  __int64 *v5; // rbx
  _QWORD *v6; // r11
  unsigned __int64 v7; // r15
  int n0xE; // r14d
  __int64 **v9; // rax
  __int64 *v10; // rdi
  __int64 *v11; // r12
  __int64 v12; // rsi
  __int16 v13; // r10
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rcx
  __int64 v16; // rax
  bool v17; // zf
  __int64 v18; // rdx
  __int64 v19; // r14
  const void **v20; // rax
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 *v23; // rcx
  const void *v24; // rcx
  _BYTE *v25; // rcx
  __int64 v26; // r8
  __int64 v27; // rbx
  unsigned __int64 result; // rax
  _QWORD *v29; // rsi
  __int64 v30; // rdi
  float v31; // ecx
  __int64 v32; // rax
  unsigned __int8 v33; // cf
  __int64 *v34; // rcx
  __m256 *v35; // rdx
  int n0xE_2; // [rsp+30h] [rbp-79h]
  __int16 v37; // [rsp+34h] [rbp-75h] BYREF
  char v38; // [rsp+36h] [rbp-73h]
  _QWORD *v39; // [rsp+38h] [rbp-71h]
  __int64 **v40; // [rsp+40h] [rbp-69h]
  __int16 v41; // [rsp+50h] [rbp-59h] BYREF
  char v42; // [rsp+52h] [rbp-57h]
  int v43; // [rsp+54h] [rbp-55h]
  __int16 v44; // [rsp+58h] [rbp-51h]
  char v45; // [rsp+5Ah] [rbp-4Fh]
  char v46; // [rsp+5Bh] [rbp-4Eh]
  char v47; // [rsp+5Ch] [rbp-4Dh]
  int n0xE_1; // [rsp+60h] [rbp-49h]
  bool v49; // [rsp+64h] [rbp-45h]
  bool v50; // [rsp+65h] [rbp-44h]
  _BYTE *v51; // [rsp+68h] [rbp-41h] BYREF
  __int128 v52; // [rsp+70h] [rbp-39h]
  __int128 v53; // [rsp+80h] [rbp-29h] BYREF
  __int64 v54; // [rsp+90h] [rbp-19h]
  __m256 v55; // [rsp+A0h] [rbp-9h] BYREF
  __int64 v57; // [rsp+118h] [rbp+6Fh]

  v57 = a2;
  v4 = (__int16 *)(a2 + 0x10);
  v5 = (__int64 *)(a4 + 8);
  v6 = (_QWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10) + 0x4058);
  v7 = 0;
  v39 = v6;
  n0xE = 0;
  n0xE_2 = 0;
  v9 = (__int64 **)(v6 + 0x22);
  v40 = (__int64 **)(v6 + 0x22);
  do
  {
    v10 = *v9;
    v11 = v9[1];
    if ( *v9 != v11 )
    {
      do
      {
        v12 = *v10;
        v13 = *(_WORD *)(*v10 + 8);
        if ( v13 )
        {
          v42 = *(_BYTE *)(v12 + 0x10);
          v51 = 0;
          v14 = v6[0x4C] & ((1LL << v42) - 1);
          v52 = 0;
          v15 = 3 * __popcnt(v14);
          v54 = 0;
          v16 = *(_QWORD *)(a2 + 0x18);
          v17 = *(_BYTE *)(v16 + 4 * v15) == 0;
          v18 = v16 + 4 * v15;
          LOWORD(v16) = *v4;
          v49 = !v17;
          v41 = v16;
          v43 = *(_DWORD *)(v12 + 0x18);
          v45 = *(_BYTE *)(v12 + 0xB);
          v46 = *(_BYTE *)(v18 + 5);
          v47 = *(_BYTE *)(v12 + 0xA);
          v53 = 0;
          v44 = v13;
          n0xE_1 = n0xE;
          v50 = sub_146A38570(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, v57, (__int64)v6, __popcnt(v14));
          v19 = p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x478LL * n0xE;
          v20 = (const void **)sub_146A1D220(v19 + 0x5B8, v4);
          if ( &v51 != (_BYTE **)v20 )
            sub_146A11EE0((std::vector<short> *)&v51, (char *)*v20, ((_BYTE *)v20[1] - (_BYTE *)*v20) >> 1);
          v37 = *v4;
          v38 = *(_BYTE *)(v12 + 0x10);
          v21 = sub_146A1D080((__int64 *)(v19 + 0x5D0), (unsigned __int16 *)&v37);
          if ( &v53 != (__int128 *)v21 )
            sub_140307340(
              (unsigned __int64 *)&v53,
              *(char **)v21,
              (__int64)(*(_QWORD *)(v21 + 8) - *(_QWORD *)v21) >> 2);
          v22 = *v5;
          v23 = v5 + 0xFFFFFFFF;
          if ( *v5 == v5[1] )
          {
            sub_146A126F0(v23, v22, (__int64)&v41);
          }
          else
          {
            sub_146A19EB0((__int64)v23, v22, (__int64)&v41);
            *v5 += 0x48;
          }
          v24 = (const void *)v53;
          if ( (_QWORD)v53 )
          {
            if ( ((v54 - (_QWORD)v53) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
            {
              v24 = *(const void **)(v53 - 8);
              if ( (unsigned __int64)(v53 - (_QWORD)v24 - 8) > 0x1F )
LABEL_28:
                invalid_parameter_noinfo_noreturn();
            }
            sub_1402A3D30(v24);
          }
          v25 = v51;
          if ( v51 )
          {
            if ( (unsigned __int64)(2 * ((__int64)(*((_QWORD *)&v52 + 1) - (_QWORD)v51) >> 1)) >= 0x1000 )
            {
              v25 = (_BYTE *)*((_QWORD *)v51 + 0xFFFFFFFF);
              if ( (unsigned __int64)(v51 - v25 - 8) > 0x1F )
                goto LABEL_28;
            }
            sub_1402A3D30(v25);
          }
          a2 = v57;
          v6 = v39;
          n0xE = n0xE_2;
        }
        ++v10;
      }
      while ( v10 != v11 );
      v9 = v40;
    }
    ++n0xE;
    v9 += 3;
    v5 += 6;
    n0xE_2 = n0xE;
    v40 = v9;
  }
  while ( n0xE < 0xE );
  v26 = v6[0x17];
  v27 = v6[0x16];
  result = (unsigned __int64)((unsigned __int128)((v26 - v27) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F;
  if ( (v26 - v27) / 0x30 )
  {
    v29 = v39;
    v30 = 0;
    do
    {
      if ( (v26 - v27) / 0x30 <= v7 )
      {
        __asm { vzeroupper }
        unknown_libname_11();
      }
      v31 = *(float *)(v30 + v27 + 0x14);
      LOWORD(v55.m256_f32[0]) = *v4;
      v55.m256_f32[1] = *(float *)(v30 + v27);
      LOWORD(v55.m256_f32[2]) = *(_WORD *)(v30 + v27 + 0x18);
      BYTE2(v55.m256_f32[2]) = *(_BYTE *)(v30 + v27 + 0x1A);
      *(_QWORD *)&v55.m256_f32[4] = *(_QWORD *)(v30 + v27 + 0x20);
      v32 = *(_QWORD *)(v57 + 0x58);
      v33 = _bittest64(&v32, v7);
      v55.m256_f32[3] = v31;
      LOBYTE(v55.m256_f32[6]) = v33;
      __asm { vzeroupper }
      BYTE1(v55.m256_f32[6]) = sub_146A37FA0(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, v57, v7);
      v34 = (__int64 *)(a4 + 0x30LL * *(int *)(v30 + v27 + 0x14) + 0x18);
      v35 = (__m256 *)v34[1];
      if ( v35 == (__m256 *)v34[2] )
      {
        sub_140347820(v34, v35, (__m256i *)&v55);
      }
      else
      {
        *v35 = v55;
        v34[1] += 0x20;
      }
      v26 = v29[0x17];
      v27 = v29[0x16];
      ++v7;
      v30 += 0x30;
      result = (unsigned __int64)((unsigned __int128)((v26 - v27) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F;
    }
    while ( v7 < (v26 - v27) / 0x30 );
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_146A28BD0 (0x146A28BD0) ---

// --- Function: sub_146A2D6C0 (0x146A2D6C0) ---
unsigned __int64 __fastcall sub_146A2D6C0(__int64 a1, unsigned __int16 a2)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // r14
  __int64 v3; // rbx
  __int64 v4; // rsi
  volatile signed __int64 *v5; // rdi
  unsigned __int64 thread_context_ptr; // rax
  int v7; // ebp
  __int64 v8; // r8
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // r9
  int v10; // eax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v3 = a2;
  v4 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0LL * a2;
  v5 = (volatile signed __int64 *)(v4 + 0x4068);
  thread_context_ptr = get_thread_context_ptr();
  v7 = *(_DWORD *)(thread_context_ptr + 0x18);
  if ( *(_DWORD *)(v4 + 0x4078) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x407C);
  }
  else
  {
    v8 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    thread_context_ptr = _InterlockedCompareExchange64(v5, 0x200000, 0);
    if ( thread_context_ptr )
      thread_context_ptr = sub_1403DCD60(
                             v4 + 0x4068,
                             thread_context_ptr,
                             v8,
                             "CEntityComponentUpdateScheduler::DisableComponentDebugUpdate",
                             "pAllocator->lock",
                             1);
    else
      *(_QWORD *)(v4 + 0x4070) = v8;
    *(_DWORD *)(v4 + 0x4078) = v7;
  }
  if ( !*(_QWORD *)(v4 + 0x40C0) )
  {
    if ( (_WORD)v3 == 0xFFFF )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const char **)(*(_QWORD *)(pEngineComponentScheduler + 0x38) + 8 * v3);
    thread_context_ptr = sub_1405C0E00(
                           6u,
                           2u,
                           "%s is disabling debug update before it was enabled!",
                           p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
  }
  --*(_QWORD *)(v4 + 0x40C0);
  *(_BYTE *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1F4F62) = 1;
  if ( v4 != 0xFFFFFFFFFFFFBF98uLL )
  {
    v10 = *(_DWORD *)(v4 + 0x407C);
    if ( v10 )
    {
      thread_context_ptr = (unsigned int)(v10 - 1);
      *(_DWORD *)(v4 + 0x407C) = thread_context_ptr;
    }
    else
    {
      *(_DWORD *)(v4 + 0x4078) = 0xFFFFFFFF;
      thread_context_ptr = _InterlockedCompareExchange64(v5, 0, 0x200000);
      if ( thread_context_ptr == 0x200000 )
        *(_QWORD *)(v4 + 0x4070) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        return (unsigned __int64)rw_lock_handle_write_release_contention(v4 + 0x4068, thread_context_ptr);
    }
  }
  return thread_context_ptr;
}

// --- End Function: sub_146A2D6C0 (0x146A2D6C0) ---

// --- Function: sub_146A2D800 (0x146A2D800) ---
__int64 __fastcall sub_146A2D800(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r9
  __int64 v5; // rdi
  unsigned int *v6; // rcx
  unsigned __int64 v7; // r8
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  __int64 result; // rax

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v5 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0 * v3;
  v6 = *(unsigned int **)(v5 + 0x4108);
  v7 = (*(_QWORD *)(v5 + 0x4110) - (_QWORD)v6) / 0x30LL;
  while ( v7 )
  {
    if ( v6[0xC * (v7 >> 1)] >= a3 )
    {
      v7 >>= 1;
    }
    else
    {
      v6 += 0xC * (v7 >> 1) + 0xC;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
    goto LABEL_10;
  if ( a3 < *v6 )
    v6 = *(unsigned int **)(v5 + 0x4110);
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
  {
LABEL_10:
    if ( (_WORD)v3 == 0xFFFF )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const char **)(*(_QWORD *)(pEngineComponentScheduler + 0x38) + 8 * v3);
    return sub_1405C0E00(
             6u,
             2u,
             "Calling DisableComponentEventHandler for Event %d on Component %s which doesn't have a handler registered for this event",
             a3,
             p_p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  else
  {
    result = ~(1LL << (((__int64)v6 - *(_QWORD *)(v5 + 0x4108)) / 0x30));
    *(_QWORD *)(a2 + 0x58) &= result;
  }
  return result;
}

// --- End Function: sub_146A2D800 (0x146A2D800) ---

// --- Function: sub_146A2D940 (0x146A2D940) ---
unsigned __int64 __fastcall sub_146A2D940(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  __int64 v5; // rbx
  int v6; // esi
  __int64 v7; // r8
  int v8; // eax
  unsigned __int64 n0x200000; // rax

  v3 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  if ( *(_WORD *)(v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4098) == 3 )
  {
    v5 = v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4068;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = get_thread_context_ptr();
    v6 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18);
    if ( *(_DWORD *)(v5 + 0x10) == v6 )
    {
      ++*(_DWORD *)(v5 + 0x14);
    }
    else
    {
      v7 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      p_p_p_p_p_p_p_p_p_p_p_p_Source = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
      if ( p_p_p_p_p_p_p_p_p_p_p_p_Source )
        p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1403DCD60(
                                           v5,
                                           p_p_p_p_p_p_p_p_p_p_p_p_Source,
                                           v7,
                                           "CEntityComponentUpdateScheduler::DisableComponentInstanceDebugUpdate",
                                           "pAllocator->lock",
                                           1);
      else
        *(_QWORD *)(v5 + 8) = v7;
      *(_DWORD *)(v5 + 0x10) = v6;
    }
    *(_BYTE *)(a2 + 0x69) = 0;
    if ( v5 )
    {
      v8 = *(_DWORD *)(v5 + 0x14);
      if ( v8 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)(v8 - 1);
        *(_DWORD *)(v5 + 0x14) = p_p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v5 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          return (unsigned __int64)rw_lock_handle_write_release_contention(v5, n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_146A2D940 (0x146A2D940) ---

// --- Function: sub_146A2DA50 (0x146A2DA50) ---
__int64 __fastcall sub_146A2DA50(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rbx
  int v4; // r15d
  __int64 v6; // r9
  unsigned __int64 v7; // rdx
  __int64 v8; // r8
  __int64 result; // rax
  __int64 pEngineComponentScheduler; // rdi
  const char *v11; // rbp
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdi
  __int64 v13; // rcx
  const char *v14; // rax

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v4 = a3;
  v6 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0 * v3;
  v7 = __popcnt(*(_QWORD *)(v6 + 0x42B8) & ((1LL << a3) - 1));
  v8 = *(_QWORD *)(v6 + 0x4150) + 0x20 * v7;
  switch ( *(_WORD *)(v8 + 8) )
  {
    case 2:
    case 5:
    case 6:
    case 9:
    case 0xA:
    case 0xC:
    case 0xF:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
      result = *(_QWORD *)(a2 + 0x18);
      *(_BYTE *)(result + 0xC * v7) = 0;
      break;
    default:
      pEngineComponentScheduler = ::pEngineComponentScheduler;
      v11 = sub_1403AC700(*(_DWORD *)(v8 + 0xC));
      if ( (_WORD)v3 == 0xFFFF )
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const char **)(*(_QWORD *)(pEngineComponentScheduler + 0x38) + 8 * v3);
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a2 + 8)) )
        v13 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v13 = 0;
      v14 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x70LL))(v13);
      result = sub_1405C0E00(
                 6u,
                 2u,
                 "DisableComponentUpdate called Component %s.%s for Pass %s (Id %d) which is not set to use the Manual update policy",
                 v14,
                 p_p_p_p_p_p_p_p_p_p_p_p_Source,
                 v11,
                 v4);
      break;
  }
  return result;
}

// --- End Function: sub_146A2DA50 (0x146A2DA50) ---

// --- Function: sub_146A2DDF0 (0x146A2DDF0) ---
unsigned __int64 __fastcall sub_146A2DDF0(__int64 a1, unsigned __int16 a2)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbp
  __int64 v3; // rdi
  __int64 v4; // rbx
  unsigned __int64 thread_context_ptr; // rax
  int v6; // esi
  __int64 v7; // r8
  int v8; // eax
  unsigned __int64 n0x200000; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v3 = 0x2E0LL * a2;
  v4 = v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4068;
  thread_context_ptr = get_thread_context_ptr();
  v6 = *(_DWORD *)(thread_context_ptr + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v6 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v7 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    thread_context_ptr = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0x200000, 0);
    if ( thread_context_ptr )
      thread_context_ptr = sub_1403DCD60(
                             v4,
                             thread_context_ptr,
                             v7,
                             "CEntityComponentUpdateScheduler::EnableComponentDebugUpdate",
                             "pAllocator->lock",
                             1);
    else
      *(_QWORD *)(v4 + 8) = v7;
    *(_DWORD *)(v4 + 0x10) = v6;
  }
  ++*(_QWORD *)(v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x40C0);
  *(_BYTE *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1F4F62) = 1;
  if ( v4 )
  {
    v8 = *(_DWORD *)(v4 + 0x14);
    if ( v8 )
    {
      thread_context_ptr = (unsigned int)(v8 - 1);
      *(_DWORD *)(v4 + 0x14) = thread_context_ptr;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        thread_context_ptr = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v4 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return (unsigned __int64)rw_lock_handle_write_release_contention(v4, n0x200000);
      }
    }
  }
  return thread_context_ptr;
}

// --- End Function: sub_146A2DDF0 (0x146A2DDF0) ---

// --- Function: sub_146A2DEF0 (0x146A2DEF0) ---
__int64 __fastcall sub_146A2DEF0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r9
  __int64 v5; // rbx
  unsigned int *v6; // rcx
  unsigned __int64 v7; // r8
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  __int64 result; // rax

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v5 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0 * v3;
  v6 = *(unsigned int **)(v5 + 0x4108);
  v7 = (*(_QWORD *)(v5 + 0x4110) - (_QWORD)v6) / 0x30LL;
  while ( v7 )
  {
    if ( v6[0xC * (v7 >> 1)] >= a3 )
    {
      v7 >>= 1;
    }
    else
    {
      v6 += 0xC * (v7 >> 1) + 0xC;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
    goto LABEL_10;
  if ( a3 < *v6 )
    v6 = *(unsigned int **)(v5 + 0x4110);
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
  {
LABEL_10:
    if ( (_WORD)v3 == 0xFFFF )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const char **)(*(_QWORD *)(pEngineComponentScheduler + 0x38) + 8 * v3);
    return sub_1405C0E00(
             6u,
             2u,
             "Calling EnableComponentEventHandler for Event %d on Component %s which doesn't have a handler registered for this event",
             a3,
             p_p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  else
  {
    result = 1LL << (((__int64)v6 - *(_QWORD *)(v5 + 0x4108)) / 0x30);
    *(_QWORD *)(a2 + 0x58) |= result;
  }
  return result;
}

// --- End Function: sub_146A2DEF0 (0x146A2DEF0) ---

// --- Function: sub_146A2E020 (0x146A2E020) ---
char __fastcall sub_146A2E020(__int64 a1, __int64 __Val_0__)
{
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rax
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbp
  __int64 v5; // rdi
  volatile signed __int64 *v6; // rbx
  int v7; // r14d
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  int v10; // eax
  unsigned __int64 n0x200000; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(unsigned __int16 *)(__Val_0__ + 0x10);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v5 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0 * p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
  if ( *(_WORD *)(v5 + 0x4098) == 3 )
  {
    v6 = (volatile signed __int64 *)(v5 + 0x4068);
    v7 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
    if ( *(_DWORD *)(v5 + 0x4078) == v7 )
    {
      ++*(_DWORD *)(v5 + 0x407C);
    }
    else
    {
      v8 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      v9 = _InterlockedCompareExchange64(v6, 0x200000, 0);
      if ( v9 )
        sub_1403DCD60(
          v5 + 0x4068,
          v9,
          v8,
          "CEntityComponentUpdateScheduler::EnableComponentInstanceDebugUpdate",
          "pAllocator->lock",
          1);
      else
        *(_QWORD *)(v5 + 0x4070) = v8;
      *(_DWORD *)(v5 + 0x4078) = v7;
    }
    *(_BYTE *)(__Val_0__ + 0x69) = 1;
    LOBYTE(p_p_p_p_p_p_p_p_p_p_p_p_Source_1) = sub_146A37E70(p_p_p_p_p_p_p_p_p_p_p_p_Source, __Val_0__, v5 + 0x4058);
    if ( (_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source_1 )
      LOBYTE(p_p_p_p_p_p_p_p_p_p_p_p_Source_1) = sub_146A24F10(
                                                   p_p_p_p_p_p_p_p_p_p_p_p_Source,
                                                   (const vraudio::AudioBuffer *)__Val_0__,
                                                   v5 + 0x4058);
    if ( v5 != 0xFFFFFFFFFFFFBF98uLL )
    {
      v10 = *(_DWORD *)(v5 + 0x407C);
      if ( v10 )
      {
        LODWORD(p_p_p_p_p_p_p_p_p_p_p_p_Source_1) = v10 - 1;
        *(_DWORD *)(v5 + 0x407C) = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
      }
      else
      {
        *(_DWORD *)(v5 + 0x4078) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64(v6, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v5 + 0x4070) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          LOBYTE(p_p_p_p_p_p_p_p_p_p_p_p_Source_1) = (unsigned __int8)rw_lock_handle_write_release_contention(
                                                                        v5 + 0x4068,
                                                                        n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
}

// --- End Function: sub_146A2E020 (0x146A2E020) ---

// --- Function: sub_146A2E140 (0x146A2E140) ---
void __fastcall sub_146A2E140(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  sub_146A2E150(p_p_p_p_p_p_p_p_p_p_p_p_Source_8, a2, a3);
}

// --- End Function: sub_146A2E140 (0x146A2E140) ---

// --- Function: sub_146A2E150 (0x146A2E150) ---
void __fastcall sub_146A2E150(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rbx
  int v5; // r12d
  __int64 v7; // r13
  unsigned __int64 v8; // rsi
  __int64 v9; // rdx
  unsigned __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  bool v13; // al
  unsigned __int64 v14; // rdx
  __int64 pEngineComponentScheduler; // rsi
  const char *v16; // r14
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rsi
  __int64 v18; // rcx
  const char *v19; // rax
  unsigned __int64 v20; // [rsp+80h] [rbp+8h] BYREF
  __int64 v21; // [rsp+88h] [rbp+10h]

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v5 = a3;
  v7 = p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0 * v3;
  v21 = (1LL << a3) - 1;
  v8 = __popcnt(*(_QWORD *)(v7 + 0x42B8) & v21);
  v9 = *(_QWORD *)(v7 + 0x4150) + 0x20 * v8;
  switch ( *(_WORD *)(v9 + 8) )
  {
    case 2:
    case 5:
    case 6:
    case 9:
    case 0xA:
    case 0xC:
    case 0xF:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
      v10 = *(_QWORD *)(a2 + 8);
      v20 = v10;
      if ( !v10 )
        goto LABEL_16;
      v11 = (v10 & 0xF000000000000000uLL) != 0 ? v10 & 0xFFFFFF000000LL : (v10 & 0xFFFFFFFFFFFFLL) - 6;
      if ( *(_WORD *)(v11 + 2) != (HIWORD(v10) & 0xFFF) )
        goto LABEL_16;
      if ( *(_WORD *)(v11 + 4) < 3u )
        goto LABEL_10;
      if ( check_thread_state_and_value_not_equal((_QWORD *)(v10 & 0xFFFFFFFFFFFFLL)) )
      {
        v10 = v20;
LABEL_10:
        if ( (v10 & 0xFFFFFFFFFFFFLL) != 0 )
        {
          v12 = (v10 & 0xF000000000000000uLL) != 0 ? v10 & 0xFFFFFF000000LL : (v10 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v12 + 4) == 1 )
          {
            _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a2 + 0x18) + 0xC * v8 + 0xB), 1u);
            return;
          }
        }
      }
LABEL_16:
      *(_BYTE *)(*(_QWORD *)(a2 + 0x18) + 0xC * v8) = 1;
      v13 = is_entity_descriptor_valid_or_accessible(&v20);
      v14 = v20 & 0xFFFFFFFFFFFFLL;
      if ( !v13 )
        v14 = 0;
      if ( sub_146A38570(p_p_p_p_p_p_p_p_p_p_p_p_Source, v14, a2, v7 + 0x4058, __popcnt(*(_QWORD *)(v7 + 0x42B8) & v21)) )
        sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a2, v5, 0);
      return;
    default:
      pEngineComponentScheduler = ::pEngineComponentScheduler;
      v16 = sub_1403AC700(*(_DWORD *)(v9 + 0xC));
      if ( (_WORD)v3 == 0xFFFF )
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const char **)(*(_QWORD *)(pEngineComponentScheduler + 0x38) + 8 * v3);
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a2 + 8)) )
        v18 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v18 = 0;
      v19 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x70LL))(v18);
      sub_1405C0E00(
        6u,
        2u,
        "EnableComponentUpdate called Component %s.%s for Pass %s (Id %d) which is not set to use the Manual update policy",
        v19,
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
        v16,
        v5);
      return;
  }
}

// --- End Function: sub_146A2E150 (0x146A2E150) ---

// --- Function: sub_146A2F670 (0x146A2F670) ---
void __fastcall sub_146A2F670(__int64 a1)
{
  __int64 v1; // rdi
  __int64 i; // rbx
  _QWORD *v3; // r14
  const char **v4; // rbp
  _BYTE *v5; // rcx
  const char **v6; // rsi
  __int64 n0x1FF; // rdx
  __int128 v8; // [rsp+20h] [rbp-278h] BYREF
  __int64 v9; // [rsp+30h] [rbp-268h]
  __int64 v10; // [rsp+38h] [rbp-260h] BYREF
  __int64 v11; // [rsp+40h] [rbp-258h] BYREF
  __int64 n0x1FF_1; // [rsp+48h] [rbp-250h]
  _BYTE *v13; // [rsp+50h] [rbp-248h]
  _BYTE v14[520]; // [rsp+58h] [rbp-240h] BYREF

  *(_BYTE *)(a1 + 0x105) = 1;
  v1 = *(_QWORD *)(a1 + 0x10);
  for ( i = *(_QWORD *)(a1 + 8); i != v1; i += 0x18 )
  {
    v3 = *(_QWORD **)(i + 8);
    v8 = 0;
    v9 = 0;
    (*(void (__fastcall **)(_QWORD, __int128 *))(*(_QWORD *)*v3 + 0x30LL))(*v3, &v8);
    v4 = (const char **)*((_QWORD *)&v8 + 1);
    v5 = v14;
    v6 = (const char **)v8;
    n0x1FF = 0x1FF;
    v13 = v14;
    n0x1FF_1 = 0x1FF;
    v14[0] = 0;
    v11 = 0;
    if ( (_QWORD)v8 != *((_QWORD *)&v8 + 1) )
    {
      do
      {
        sub_1402A3190((__int64)&v11, "%s%s", "Engine.Components.", *v6);
        (*(void (__fastcall **)(__int64, __int64 *, _BYTE *))(*(_QWORD *)qword_149B4FBF8 + 0x28LL))(
          qword_149B4FBF8,
          &v10,
          v13);
        if ( (_WORD)v10 != 0xFFFF )
          sub_1403912C0((__int64)(v3 + 6), v10);
        ++v6;
      }
      while ( v6 != v4 );
      v6 = (const char **)v8;
      v5 = v13;
      n0x1FF = n0x1FF_1;
    }
    if ( v5 != v14 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v5);
      v6 = (const char **)v8;
    }
    if ( v6 )
      sub_1403A3120((__int64)&v8, v6, (v9 - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8uLL);
  }
}

// --- End Function: sub_146A2F670 (0x146A2F670) ---

// --- Function: sub_146A2FA80 (0x146A2FA80) ---
__int64 __fastcall sub_146A2FA80(__int64 a1, unsigned int a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v6; // r10
  _BYTE *v7; // rdx
  _BYTE *v8; // rbp
  unsigned __int64 v9; // rsi
  __int64 result; // rax
  unsigned int v11; // ebx

  v4 = *(_QWORD *)(a1 + 0x10) + a2;
  v6 = *(unsigned __int16 *)(v4 + 2);
  if ( v6 > a4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) )
  {
    v7 = a3;
    while ( v7[v4 + 0xC - (_QWORD)a3] == *v7 )
    {
      if ( ++v7 - a3 >= v6 )
        goto LABEL_6;
    }
    return 0;
  }
LABEL_6:
  v8 = &a3[v6];
  v9 = a4 - v6;
  if ( a4 == v6 )
    return v4;
  v11 = *(_DWORD *)(v4 + 4);
  if ( v11 == 0xFFFFFFFF )
    return 0;
  while ( 1 )
  {
    result = sub_146A2FA80(a1, v11, v8, v9);
    if ( result )
      break;
    v11 = *(_DWORD *)(v11 + *(_QWORD *)(a1 + 0x10) + 8LL);
    if ( v11 == 0xFFFFFFFF )
      return 0;
  }
  return result;
}

// --- End Function: sub_146A2FA80 (0x146A2FA80) ---

// --- Function: sub_146A31880 (0x146A31880) ---
__int64 __fastcall sub_146A31880(__int64 a1, unsigned __int16 a2, __int64 *a3)
{
  __int16 **v5; // rbx
  __int64 result; // rax
  unsigned __int16 *v7; // rbp
  __int16 *i; // rbx
  __int16 v9; // ax
  __int16 v10; // [rsp+48h] [rbp+10h] BYREF

  v10 = a2;
  v5 = (__int16 **)(*(_QWORD *)(a1 + 0x70) + 0x18LL * a2);
  sub_146A4A820((__int64)a3, v5[1] - *v5 + ((a3[1] - *a3) >> 1) + 1);
  result = (__int64)sub_140307890((__int64)a3, &v10);
  v7 = (unsigned __int16 *)v5[1];
  for ( i = *v5; i != (__int16 *)v7; ++i )
  {
    v9 = 0xFFFF;
    if ( (unsigned int)(unsigned __int16)*i < *(_DWORD *)(a1 + 0x28) )
      v9 = *i;
    v10 = v9;
    result = sub_143A96E90(a3, &v10);
  }
  return result;
}

// --- End Function: sub_146A31880 (0x146A31880) ---

// --- Function: sub_146A31930 (0x146A31930) ---
void __fastcall sub_146A31930(__int64 a1, unsigned __int16 a2, __int64 *a3)
{
  __int64 **v5; // rax
  __int64 *v6; // rcx
  __int64 v7; // rax
  const char **v8; // r14
  const char **v9; // rdi
  __int64 v10; // rsi
  __int16 n0xFFFF; // ax
  const char *v12; // rbx
  unsigned __int64 v13; // r9
  __int16 *v14; // rax
  __int128 v15; // [rsp+20h] [rbp-38h] BYREF
  __int64 v16; // [rsp+30h] [rbp-28h]
  __int16 n0xFFFF_1; // [rsp+78h] [rbp+20h] BYREF

  v5 = (__int64 **)sub_146A31EC0(a1, a2);
  if ( v5 )
  {
    v6 = *v5;
    if ( *v5 )
    {
      v7 = *v6;
      v15 = 0;
      v16 = 0;
      (*(void (__fastcall **)(__int64 *, __int128 *))(v7 + 0x30))(v6, &v15);
      sub_146A4A820((__int64)a3, ((__int64)(*((_QWORD *)&v15 + 1) - v15) >> 3) + ((a3[1] - *a3) >> 1));
      v8 = (const char **)*((_QWORD *)&v15 + 1);
      v9 = (const char **)v15;
      if ( (_QWORD)v15 != *((_QWORD *)&v15 + 1) )
      {
        v10 = a1 + 0x20;
        while ( 1 )
        {
          n0xFFFF = 0xFFFF;
          v12 = *v9;
          if ( *(_DWORD *)(v10 + 8) )
          {
            v13 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++v13;
            while ( v12[v13] );
            v14 = (__int16 *)sub_146A2FA80(v10, 0, *v9, v13);
            if ( !v14 )
            {
              n0xFFFF_1 = 0xFFFF;
LABEL_11:
              LogFatalError("Trying to get a component id from name %s which has not yet been registered", v12);
              goto LABEL_12;
            }
            n0xFFFF = *v14;
          }
          n0xFFFF_1 = n0xFFFF;
          if ( n0xFFFF == (__int16)0xFFFF )
            goto LABEL_11;
LABEL_12:
          sub_143A96E90(a3, &n0xFFFF_1);
          if ( ++v9 == v8 )
          {
            v9 = (const char **)v15;
            break;
          }
        }
      }
      if ( v9 )
        sub_1403A3120((__int64)&v15, v9, (v16 - (_QWORD)v9) & 0xFFFFFFFFFFFFFFF8uLL);
    }
  }
}

// --- End Function: sub_146A31930 (0x146A31930) ---

// --- Function: sub_146A31AE0 (0x146A31AE0) ---
void __fastcall sub_146A31AE0(__int64 a1, unsigned __int16 n0xFFFF_4, __int64 *a3)
{
  __int64 n0xFFFF; // rbx
  __int64 v5; // rdx
  __int64 v7; // r8
  __int64 v8; // rax
  __int16 **v9; // rdi
  unsigned __int16 *v10; // r14
  __int16 *i; // rdi
  __int16 n0xFFFF_2; // ax
  __int64 **v13; // rax
  __int64 *v14; // rcx
  __int64 v15; // rax
  const char **v16; // r14
  const char **v17; // rdi
  __int16 n0xFFFF_3; // ax
  const char *v19; // rbx
  unsigned __int64 v20; // r9
  __int16 *v21; // rax
  __int128 v22; // [rsp+20h] [rbp-38h] BYREF
  __int64 v23; // [rsp+30h] [rbp-28h]
  __int16 n0xFFFF_1; // [rsp+68h] [rbp+10h] BYREF

  n0xFFFF = n0xFFFF_4;
  v5 = *a3;
  v7 = a3[1];
  if ( v5 != v7 )
  {
    a3[1] = v5;
    v7 = v5;
  }
  v8 = *(_QWORD *)(a1 + 0x70);
  n0xFFFF_1 = n0xFFFF;
  v9 = (__int16 **)(v8 + 0x18 * n0xFFFF);
  sub_146A4A820((__int64)a3, ((v7 - v5) >> 1) + v9[1] - *v9 + 1);
  sub_140307890((__int64)a3, &n0xFFFF_1);
  v10 = (unsigned __int16 *)v9[1];
  for ( i = *v9; i != (__int16 *)v10; ++i )
  {
    n0xFFFF_2 = 0xFFFF;
    if ( (unsigned int)(unsigned __int16)*i < *(_DWORD *)(a1 + 0x28) )
      n0xFFFF_2 = *i;
    n0xFFFF_1 = n0xFFFF_2;
    sub_143A96E90(a3, &n0xFFFF_1);
  }
  v13 = (__int64 **)sub_146A31EC0(a1, n0xFFFF);
  if ( v13 )
  {
    v14 = *v13;
    if ( *v13 )
    {
      v15 = *v14;
      v22 = 0;
      v23 = 0;
      (*(void (__fastcall **)(__int64 *, __int128 *))(v15 + 0x30))(v14, &v22);
      sub_146A4A820((__int64)a3, ((__int64)(*((_QWORD *)&v22 + 1) - v22) >> 3) + ((a3[1] - *a3) >> 1));
      v16 = (const char **)*((_QWORD *)&v22 + 1);
      v17 = (const char **)v22;
      if ( (_QWORD)v22 != *((_QWORD *)&v22 + 1) )
      {
        while ( 1 )
        {
          n0xFFFF_3 = 0xFFFF;
          v19 = *v17;
          if ( *(_DWORD *)(a1 + 0x28) )
          {
            v20 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++v20;
            while ( v19[v20] );
            v21 = (__int16 *)sub_146A2FA80(a1 + 0x20, 0, *v17, v20);
            if ( !v21 )
            {
              n0xFFFF_1 = 0xFFFF;
LABEL_16:
              LogFatalError("Trying to get a component id from name %s which has not yet been registered", v19);
              goto LABEL_17;
            }
            n0xFFFF_3 = *v21;
          }
          n0xFFFF_1 = n0xFFFF_3;
          if ( n0xFFFF_3 == (__int16)0xFFFF )
            goto LABEL_16;
LABEL_17:
          sub_143A96E90(a3, &n0xFFFF_1);
          if ( ++v17 == v16 )
          {
            v17 = (const char **)v22;
            break;
          }
        }
      }
      if ( v17 )
        sub_1403A3120((__int64)&v22, v17, (v23 - (_QWORD)v17) & 0xFFFFFFFFFFFFFFF8uLL);
    }
  }
}

// --- End Function: sub_146A31AE0 (0x146A31AE0) ---

// --- Function: sub_146A31E30 (0x146A31E30) ---
__int64 __fastcall sub_146A31E30(__int64 a1, unsigned __int16 a2)
{
  _QWORD *v2; // rax

  v2 = (_QWORD *)sub_146A31EC0(a1, a2);
  return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v2 + 0x20LL))(*v2);
}

// --- End Function: sub_146A31E30 (0x146A31E30) ---

// --- Function: sub_146A31E70 (0x146A31E70) ---
__int64 __fastcall sub_146A31E70(__int64 a1, unsigned __int16 a2)
{
  _QWORD *v2; // rax

  v2 = (_QWORD *)sub_146A31EC0(a1, a2);
  if ( v2 && *v2 )
    return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v2 + 0x48LL))(*v2);
  else
    return 0;
}

// --- End Function: sub_146A31E70 (0x146A31E70) ---

// --- Function: sub_146A31EC0 (0x146A31EC0) ---
__int64 __fastcall sub_146A31EC0(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // r10
  __int64 v4; // r8
  unsigned __int64 v5; // rdx

  v2 = *(_QWORD *)(a1 + 0x10);
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (v2 - v4) / 0x18;
  while ( v5 )
  {
    if ( *(_WORD *)(v4 + 0x18 * (v5 >> 1)) >= a2 )
    {
      v5 >>= 1;
    }
    else
    {
      v4 += 0x18 * (v5 >> 1) + 0x18;
      v5 += 0xFFFFFFFFFFFFFFFFuLL - (v5 >> 1);
    }
  }
  if ( v4 == v2 )
    return 0;
  if ( a2 < *(_WORD *)v4 )
    v4 = *(_QWORD *)(a1 + 0x10);
  if ( v4 == v2 )
    return 0;
  else
    return *(_QWORD *)(v4 + 8);
}

// --- End Function: sub_146A31EC0 (0x146A31EC0) ---

// --- Function: sub_146A320C0 (0x146A320C0) ---
_WORD *__fastcall sub_146A320C0(__int64 a1, _WORD *a2, char *a3)
{
  sub_146A32730(a1 + 0x20, a2, a3);
  if ( *a2 == 0xFFFF )
    LogFatalError("Trying to get a component id from name %s which has not yet been registered", a3);
  return a2;
}

// --- End Function: sub_146A320C0 (0x146A320C0) ---

// --- Function: sub_146A321C0 (0x146A321C0) ---
_WORD *__fastcall sub_146A321C0(_QWORD *a1, _WORD *a2, int a3)
{
  __int64 v3; // r9
  __int64 *v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rcx
  __int16 v7; // cx
  _WORD *result; // rax

  v3 = a1[0x14];
  v4 = (__int64 *)(a1[0x16]
                 + 0x10
                 * ((0x100000001B3LL
                   * (HIBYTE(a3)
                    ^ (0x100000001B3LL
                     * (BYTE2(a3)
                      ^ (0x100000001B3LL
                       * (BYTE1(a3) ^ (0x100000001B3LL * ((unsigned __int8)a3 ^ 0xCBF29CE484222325uLL))))))))
                  & a1[0x19]));
  v5 = v4[1];
  if ( v5 != v3 )
  {
    v6 = *v4;
    if ( a3 == *(_DWORD *)(v5 + 0x10) )
      goto LABEL_7;
    while ( v5 != v6 )
    {
      v5 = *(_QWORD *)(v5 + 8);
      if ( a3 == *(_DWORD *)(v5 + 0x10) )
        goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  if ( !v5 )
    v5 = v3;
  if ( v5 == v3 )
  {
    *a2 = 0xFFFF;
    return a2;
  }
  else
  {
    v7 = *(_WORD *)(v5 + 0x14);
    result = a2;
    *a2 = v7;
  }
  return result;
}

// --- End Function: sub_146A321C0 (0x146A321C0) ---

// --- Function: sub_146A32280 (0x146A32280) ---
const ULONG_PTR *__fastcall sub_146A32280(__int64 a1, unsigned __int16 a2)
{
  if ( a2 == 0xFFFF )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(*(_QWORD *)(a1 + 0x38) + 8LL * a2);
}

// --- End Function: sub_146A32280 (0x146A32280) ---

// --- Function: sub_146A322A0 (0x146A322A0) ---
const ULONG_PTR *__fastcall sub_146A322A0(__int64 a1, unsigned __int16 a2)
{
  if ( a2 == 0xFFFF )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(*(_QWORD *)(a1 + 0x40) + 8LL * a2);
}

// --- End Function: sub_146A322A0 (0x146A322A0) ---

// --- Function: sub_146A322C0 (0x146A322C0) ---
__int64 __fastcall sub_146A322C0(__int64 a1)
{
  __int64 *v2; // r10
  unsigned int v3; // r8d
  __int64 *j; // rax
  __int64 **v5; // rcx
  __int64 *i; // rcx
  __int64 *v7; // rdx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 0x104) )
    return *(unsigned int *)(a1 + 0x100);
  v2 = *(__int64 **)(a1 + 0x88);
  v3 = *(_DWORD *)(a1 + 0x90);
  j = (__int64 *)*v2;
  while ( j != v2 )
  {
    v5 = (__int64 **)j[2];
    v3 ^= *((_DWORD *)j + 7);
    if ( *((_BYTE *)v5 + 0x19) )
    {
      for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
      {
        if ( j != (__int64 *)i[2] )
          break;
        j = i;
      }
      j = i;
    }
    else
    {
      v7 = *v5;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v7 + 0x19); v7 = (__int64 *)*v7 )
        j = v7;
    }
  }
  *(_DWORD *)(a1 + 0x100) = v3;
  result = v3;
  *(_BYTE *)(a1 + 0x104) = 1;
  return result;
}

// --- End Function: sub_146A322C0 (0x146A322C0) ---

// --- Function: sub_146A32360 (0x146A32360) ---
__int64 __fastcall sub_146A32360(__int64 a1, unsigned __int16 a2)
{
  _QWORD *v2; // rax

  v2 = (_QWORD *)sub_146A31EC0(a1, a2);
  return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v2 + 0x18LL))(*v2);
}

// --- End Function: sub_146A32360 (0x146A32360) ---

// --- Function: sub_146A32380 (0x146A32380) ---
char __fastcall sub_146A32380(__int64 a1, unsigned __int16 a2)
{
  if ( a2 == 0xFFFF )
    return 0;
  else
    return *(_BYTE *)(0x2E0LL * a2 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4062);
}

// --- End Function: sub_146A32380 (0x146A32380) ---

// --- Function: sub_146A323B0 (0x146A323B0) ---
__int64 __fastcall sub_146A323B0(__int64 a1)
{
  LogTraceConditional("Component Timings is disabled, you can enable it at ComponentStats.h");
  return a1 + 0x108;
}

// --- End Function: sub_146A323B0 (0x146A323B0) ---

// --- Function: sub_146A32530 (0x146A32530) ---
__int64 __fastcall sub_146A32530(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // r14
  _QWORD *v4; // rax
  __int64 n0xE; // r15
  __int64 n0xE_1; // rcx
  __int64 v9; // rax
  __int64 *v10; // rsi
  __int64 *i; // rbx
  __int64 v12; // rdx
  __int64 v13; // rsi
  unsigned __int8 v15; // [rsp+20h] [rbp-48h]

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v4 = (_QWORD *)(a2 + 0x28);
  n0xE = 0xE;
  n0xE_1 = 0xE;
  do
  {
    v4[0xFFFFFFFB] = 0;
    v4[0xFFFFFFFC] = 0;
    v4[0xFFFFFFFD] = 0;
    v4[0xFFFFFFFE] = 0;
    v4[0xFFFFFFFF] = 0;
    *v4 = 0;
    v4 += 6;
    --n0xE_1;
  }
  while ( n0xE_1 );
  *(_QWORD *)(a2 + 0x2D0) = 0;
  *(_QWORD *)(a2 + 0x2D8) = 0;
  v9 = allocWithProfilerInfo_w(0x28u);
  *(_QWORD *)v9 = v9;
  *(_QWORD *)(v9 + 8) = v9;
  *(_QWORD *)(v9 + 0x10) = v9;
  *(_WORD *)(v9 + 0x18) = 0x101;
  *(_QWORD *)(a2 + 0x2D0) = v9;
  v10 = *(__int64 **)(a3 + 0x248);
  for ( i = *(__int64 **)(a3 + 0x240); i != v10; ++i )
  {
    if ( is_valid_handle_typeA(i) )
      v12 = *i & 0xFFFFFFFFFFFFLL;
    else
      v12 = 0;
    sub_146A28BD0(p_p_p_p_p_p_p_p_p_p_p_p_Source, v12, a3, a2);
  }
  v13 = a2;
  do
  {
    sub_146A15F20(*(_QWORD *)v13, *(_WORD **)(v13 + 8), (*(_QWORD *)(v13 + 8) - *(_QWORD *)v13) / 0x48LL, v15);
    v13 += 0x30;
    --n0xE;
  }
  while ( n0xE );
  sub_146A28460(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, a2);
  return a2;
}

// --- End Function: sub_146A32530 (0x146A32530) ---

// --- Function: sub_146A32730 (0x146A32730) ---
_WORD *__fastcall sub_146A32730(__int64 a1, _WORD *a2, _BYTE *a3)
{
  unsigned __int64 v4; // r9
  _WORD *v5; // rax
  _WORD *result; // rax

  if ( *(_DWORD *)(a1 + 8) )
  {
    v4 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v4;
    while ( a3[v4] );
    v5 = (_WORD *)sub_146A2FA80(a1, 0, a3, v4);
    if ( v5 )
      *a2 = *v5;
    else
      *a2 = 0xFFFF;
    return a2;
  }
  else
  {
    result = a2;
    *a2 = 0xFFFF;
  }
  return result;
}

// --- End Function: sub_146A32730 (0x146A32730) ---

// --- Function: sub_146A327B0 (0x146A327B0) ---
unsigned __int64 __fastcall sub_146A327B0(__int64 a1, __int16 a2)
{
  _WORD *v2; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r9

  v2 = *(_WORD **)(a1 + 0xD8);
  result = 0;
  v4 = (__int64)(*(_QWORD *)(a1 + 0xE0) - (_QWORD)v2) >> 1;
  if ( !v4 )
    return 0x40;
  while ( *v2 != a2 )
  {
    ++result;
    ++v2;
    if ( result >= v4 )
      return 0x40;
  }
  return result;
}

// --- End Function: sub_146A327B0 (0x146A327B0) ---

// --- Function: sub_146A33560 (0x146A33560) ---
__int64 __fastcall sub_146A33560(__int64 a1, unsigned __int16 a2)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // r9
  unsigned int v3; // r10d
  char p_p_p_p_p_p_p_p_p_p_p_Source; // r8
  char p_p_p_p_p_p_p_p_p_p_p_Source_1; // cl

  if ( a2 == 0xFFFF )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = &::p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(*(_QWORD *)(a1 + 0x38) + 8LL * a2);
  v3 = 0x811C9DC5;
  do
  {
    p_p_p_p_p_p_p_p_p_p_p_Source = *(_BYTE *)p_p_p_p_p_p_p_p_p_p_p_p_Source;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)((char *)p_p_p_p_p_p_p_p_p_p_p_p_Source + 1);
    p_p_p_p_p_p_p_p_p_p_p_Source_1 = p_p_p_p_p_p_p_p_p_p_p_Source - 0x20;
    if ( (unsigned __int8)(p_p_p_p_p_p_p_p_p_p_p_Source - 0x61) > 0x19u )
      p_p_p_p_p_p_p_p_p_p_p_Source_1 = p_p_p_p_p_p_p_p_p_p_p_Source;
    v3 = 0x1000193 * (v3 ^ p_p_p_p_p_p_p_p_p_p_p_Source_1);
  }
  while ( p_p_p_p_p_p_p_p_p_p_p_Source );
  return v3;
}

// --- End Function: sub_146A33560 (0x146A33560) ---

// --- Function: sub_146A36EA0 (0x146A36EA0) ---
__int64 __fastcall sub_146A36EA0(unsigned int *a1, char *Src_1, unsigned __int16 Size_4, unsigned __int8 *a4)
{
  __int64 v4; // rdi
  unsigned __int16 v5; // bp
  __int64 Size_1; // r13
  char *Src_2; // r10
  _BYTE *v10; // rdx
  unsigned __int64 Size_3; // r9
  unsigned __int16 Size_2; // r14
  __int64 v13; // rsi
  __int64 v14; // r15
  unsigned __int16 v15; // di
  __int64 result; // rax
  char *Src_3; // rcx
  __int64 v18; // rdx
  unsigned int v19; // edi
  unsigned int v20; // eax
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // rax
  unsigned int j; // ecx
  unsigned __int16 p_Size_1; // ax
  __int64 v27; // rcx
  size_t p_Size_2; // r8
  void *Src_4; // rdx
  unsigned __int64 Size_5; // rdx
  __int64 v31; // r11
  unsigned __int64 Size_6; // r15
  unsigned __int16 Size_9; // r14
  unsigned __int16 Size_7; // r15
  __int64 v35; // r13
  unsigned int v36; // edx
  int v37; // edi
  int v38; // ecx
  unsigned __int64 v39; // rax
  __int64 v40; // rsi
  __int64 v41; // rdi
  __int64 Size_10; // r9
  unsigned __int8 *v43; // rax
  int v44; // r8d
  int v45; // eax
  unsigned __int64 v46; // rax
  _WORD *v47; // rcx
  __int64 v48; // rdi
  __int16 v49; // ax
  __int64 v50; // rsi
  __int64 Size_8; // r9
  unsigned __int16 v52; // bp
  unsigned __int8 *v53; // rax
  char *v54; // rdx
  __int64 v55; // rcx
  _WORD *v56; // rax
  __int64 v57; // rdx
  unsigned int v58; // ecx
  __int64 i; // rax
  unsigned __int8 *v60; // [rsp+20h] [rbp-78h]
  int v61; // [rsp+30h] [rbp-68h]
  unsigned int v62; // [rsp+30h] [rbp-68h]
  int v63; // [rsp+34h] [rbp-64h]
  void *Src; // [rsp+38h] [rbp-60h] BYREF
  _WORD *v65; // [rsp+40h] [rbp-58h]
  char v66; // [rsp+A0h] [rbp+8h] BYREF
  unsigned __int16 p_Size; // [rsp+A8h] [rbp+10h] BYREF
  unsigned __int16 Size; // [rsp+B0h] [rbp+18h]
  unsigned __int8 *v69; // [rsp+B8h] [rbp+20h]

  v69 = a4;
  Size = Size_4;
  v4 = *((_QWORD *)a1 + 2);
  v5 = 0;
  Size_1 = Size_4;
  Src = Src_1;
  Src_2 = Src_1;
  v66 = 0;
  p_Size = Size_4;
  v10 = (_BYTE *)(v4 + 0xC);
  Size_3 = *(unsigned __int16 *)(v4 + 2);
  Size_2 = Size_4;
  if ( (_WORD)Size_3 && *v10 != *Src_2 )
  {
    v13 = 0xFFFFFFFFLL;
    goto LABEL_7;
  }
  if ( (unsigned __int16)Size_3 > Size_4 )
    goto LABEL_5;
  if ( *(_WORD *)(v4 + 2) )
  {
    Src_3 = Src_1;
    v18 = v10 - Src_1;
    while ( Src_3[v18] == *Src_3 )
    {
      if ( ++Src_3 - Src_1 >= Size_3 )
        goto LABEL_14;
    }
LABEL_5:
    v66 = 1;
LABEL_6:
    v13 = 0;
    goto LABEL_7;
  }
LABEL_14:
  Size_2 = Size_4 - Size_3;
  p_Size = Size_4 - Size_3;
  Src_2 = &Src_1[*(unsigned __int16 *)(v4 + 2)];
  Src = Src_2;
  if ( Size_4 == (_WORD)Size_3 )
    goto LABEL_6;
  v19 = *(_DWORD *)(v4 + 4);
  if ( v19 == 0xFFFFFFFF )
    goto LABEL_6;
  while ( 1 )
  {
    v20 = sub_146A2F970((__int64)a1, v19, (_BYTE **)&Src, &p_Size, &v66);
    v13 = v20;
    if ( v20 != 0xFFFFFFFF )
      break;
    v19 = *(_DWORD *)(v19 + *((_QWORD *)a1 + 2) + 8LL);
    if ( v19 == 0xFFFFFFFF )
    {
      Src_2 = (char *)Src;
      Size_2 = p_Size;
      goto LABEL_6;
    }
  }
  Src_2 = (char *)Src;
  Size_2 = p_Size;
LABEL_7:
  v14 = (unsigned int)v13;
  if ( v66 )
  {
    Size_5 = 0;
    v31 = (unsigned int)v13 + *((_QWORD *)a1 + 2);
    Size_6 = *(unsigned __int16 *)(v31 + 2);
    if ( *(_WORD *)(v31 + 2) )
    {
      do
      {
        if ( Size_2 < Size_5 )
          break;
        if ( *(_BYTE *)(Size_5 + v31 + 0xC) != Src_2[Size_5] )
          break;
        ++v5;
        ++Size_5;
      }
      while ( Size_5 < Size_6 );
    }
    Size_9 = Size_2 - v5;
    Size_7 = Size_6 - v5;
    if ( !Size_7 )
      __debugbreak();
    v35 = *a1;
    v36 = a1[1];
    v37 = Size_7 + 0xC;
    v63 = *(_DWORD *)(v31 + 4);
    if ( Size_9 )
    {
      v44 = *a1;
      v45 = v37 + Size_9 + 0xC;
      v61 = v45;
      if ( v36 < v45 + (int)v35 )
      {
        v46 = sub_147605AA0(*((void **)a1 + 2), (unsigned int)(v45 + v35), 0);
        v44 = *a1;
        *((_QWORD *)a1 + 2) = v46;
        a1[1] = v44 + v61;
        v45 = v61;
      }
      v47 = (_WORD *)(*((_QWORD *)a1 + 2) + (unsigned int)v13);
      *a1 = v44 + v45;
      v62 = v37 + v35;
      v48 = *((_QWORD *)a1 + 2) + v35;
      v49 = *v47;
      v65 = v47;
      v50 = v5;
      *(_WORD *)v48 = v49;
      *(_WORD *)(v48 + 2) = Size_7;
      *(_QWORD *)(v48 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v48 + 0xC), (char *)v47 + v5 + 0xC, Size_7);
      Size_8 = Size;
      *(_DWORD *)(v48 + 4) = v63;
      v52 = *((_WORD *)a1 + 4);
      v53 = v69;
      ++a1[2];
      sub_146A25430((__int64)a1, v52, Src_1, Size_8, v53);
      v54 = (char *)Src + v50;
      v55 = *((_QWORD *)a1 + 2) + v62;
      *(_WORD *)v55 = v52;
      *(_WORD *)(v55 + 2) = Size_9;
      *(_QWORD *)(v55 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v55 + 0xC), v54, Size_9);
      v56 = v65;
      v65[1] -= Size_7;
      *v56 = 0xFFFF;
      *((_DWORD *)v56 + 1) = v35;
      if ( (_DWORD)v35 == 0xFFFFFFFF )
      {
        *((_DWORD *)v56 + 1) = v62;
      }
      else
      {
        v57 = *((_QWORD *)a1 + 2);
        v58 = *(_DWORD *)(v57 + v35 + 8);
        for ( i = v57 + v35; v58 != 0xFFFFFFFF; v58 = *(_DWORD *)(i + 8) )
          i = v57 + v58;
        *(_DWORD *)(i + 8) = v62;
      }
      return v52;
    }
    else
    {
      v38 = *a1;
      if ( v36 < v37 + (int)v35 )
      {
        v39 = sub_147605AA0(*((void **)a1 + 2), (unsigned int)(v37 + v35), 0);
        v38 = *a1;
        *((_QWORD *)a1 + 2) = v39;
        a1[1] = v38 + v37;
      }
      v40 = *((_QWORD *)a1 + 2) + v13;
      *a1 = v38 + v37;
      v41 = *((_QWORD *)a1 + 2) + v35;
      *(_WORD *)v41 = *(_WORD *)v40;
      *(_WORD *)(v41 + 2) = Size_7;
      *(_QWORD *)(v41 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v41 + 0xC), (const void *)(v40 + v5 + 0xCLL), Size_7);
      Size_10 = Size;
      *(_DWORD *)(v41 + 4) = v63;
      LOWORD(v41) = *((_WORD *)a1 + 4);
      v43 = v69;
      ++a1[2];
      sub_146A25430((__int64)a1, v41, Src_1, Size_10, v43);
      *(_WORD *)(v40 + 2) -= Size_7;
      result = (unsigned __int16)v41;
      *(_WORD *)v40 = v41;
      *(_DWORD *)(v40 + 4) = v35;
    }
  }
  else
  {
    v15 = *((_WORD *)a1 + 4);
    ++a1[2];
    if ( Size_2 )
    {
      v21 = (unsigned int)sub_1402B9A90((int *)a1, (unsigned int)Size_2 + 0xC);
      sub_146A25430((__int64)a1, v15, Src_1, Size_1, v69);
      v22 = *((_QWORD *)a1 + 2);
      v23 = *(unsigned int *)(v14 + v22 + 4);
      if ( (_DWORD)v23 == 0xFFFFFFFF )
      {
        *(_DWORD *)(v14 + v22 + 4) = v21;
      }
      else
      {
        v24 = v22 + v23;
        for ( j = *(_DWORD *)(v22 + v23 + 8); j != 0xFFFFFFFF; j = *(_DWORD *)(v24 + 8) )
          v24 = v22 + j;
        *(_DWORD *)(v24 + 8) = v21;
      }
      p_Size_1 = p_Size;
      v27 = *((_QWORD *)a1 + 2) + v21;
      p_Size_2 = p_Size;
      Src_4 = Src;
      *(_WORD *)v27 = v15;
      *(_WORD *)(v27 + 2) = p_Size_1;
      *(_QWORD *)(v27 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v27 + 0xC), Src_4, p_Size_2);
      return v15;
    }
    else
    {
      v60 = v69;
      *(_WORD *)(v13 + *((_QWORD *)a1 + 2)) = v15;
      sub_146A25430((__int64)a1, v15, Src_1, Size_1, v60);
      return v15;
    }
  }
  return result;
}

// --- End Function: sub_146A36EA0 (0x146A36EA0) ---

// --- Function: sub_146A37E70 (0x146A37E70) ---
bool __fastcall sub_146A37E70(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 __Val_0__, __int64 a3)
{
  bool v6; // al
  unsigned __int64 v7; // rdx
  bool result; // al
  signed __int64 v9; // rdx
  bool v10; // bl
  unsigned __int64 v11; // [rsp+48h] [rbp+10h] BYREF

  v11 = *(_QWORD *)(__Val_0__ + 8);
  v6 = is_entity_descriptor_valid_or_accessible(&v11);
  v7 = v11 & 0xFFFFFFFFFFFFLL;
  if ( !v6 )
    v7 = 0;
  switch ( *(_WORD *)(a3 + 0x40) )
  {
    case 0:
      return 1;
    case 1:
      return sub_146A37560(p_p_p_p_p_p_p_p_p_p_p_p_Source, v7, __Val_0__, 1u);
    case 2:
      result = sub_146A376D0(p_p_p_p_p_p_p_p_p_p_p_p_Source, v7, __Val_0__, 1u);
      if ( result )
        return 1;
      break;
    case 3:
      if ( *(_DWORD *)(a3 + 0x20) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
      {
        ++*(_DWORD *)(a3 + 0x24);
      }
      else
      {
        v9 = _InterlockedIncrement64((volatile signed __int64 *)(a3 + 0x10));
        if ( (v9 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            a3 + 0x10,
            v9,
            "CEntityComponentUpdateScheduler::IsComponentDebugUpdateActive",
            "pAllocator->lock",
            1);
      }
      v10 = *(_BYTE *)(__Val_0__ + 0x69) != 0;
      rw_lock_release_read_lock(a3 + 0x10);
      return v10;
    default:
      __debugbreak();
      return 1;
  }
  return result;
}

// --- End Function: sub_146A37E70 (0x146A37E70) ---

// --- Function: sub_146A38520 (0x146A38520) ---
bool __fastcall sub_146A38520(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // r9
  _WORD *v4; // rax

  v2 = a1 + 0x20;
  if ( !*(_DWORD *)(v2 + 8) )
    return 0;
  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v3;
  while ( a2[v3] );
  v4 = (_WORD *)sub_146A2FA80(v2, 0, a2, v3);
  return v4 && *v4 != 0xFFFF;
}

// --- End Function: sub_146A38520 (0x146A38520) ---

// --- Function: sub_146A414F0 (0x146A414F0) ---
char *__fastcall sub_146A414F0(__int64 a1, __int16 a2)
{
  __int64 v2; // rcx
  char *result; // rax
  __int16 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  v2 = a1 + 0xD8;
  result = *(char **)(v2 + 8);
  if ( result == *(char **)(v2 + 0x10) )
    return sub_1411F87F0(v2, *(_BYTE **)(v2 + 8), &v4);
  *(_WORD *)result = a2;
  *(_QWORD *)(v2 + 8) += 2LL;
  return result;
}

// --- End Function: sub_146A414F0 (0x146A414F0) ---

// --- Function: sub_146A41530 (0x146A41530) ---
void __fastcall sub_146A41530(__int64 a1, __int64 *a2)
{
  __int64 v4; // rax
  unsigned int *v5; // r13
  unsigned __int8 *v6; // r14
  unsigned __int64 Size; // rdi
  char *v8; // rsi
  unsigned __int16 *v9; // rax
  unsigned __int16 n0x800; // bx
  unsigned int v11; // r9d
  char *v12; // r10
  char v13; // r8
  char v14; // cl
  __int64 v15; // rdi
  __int64 inserted; // rcx
  __int64 v17; // rax
  __int64 v18; // rax
  __int128 v19; // xmm0
  _QWORD *v20; // rsi
  __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // r9
  __int64 v24; // rdi
  unsigned __int64 i; // r9
  unsigned __int64 j; // r15
  unsigned __int64 Size_1; // rdi
  char *v28; // r14
  unsigned __int16 *v29; // rax
  unsigned __int16 n0x800_1; // si
  __int64 v31; // rcx
  _WORD *v32; // rax
  __int64 v33; // rcx
  _BYTE *v34; // rdx
  _QWORD *v35; // r8
  __int64 *v36; // rsi
  __int64 v37; // rcx
  unsigned __int64 v38; // rdx
  __int64 v39; // rax
  __int64 *v40; // r14
  __int64 v41; // rdi
  unsigned int v42; // eax
  __int64 v43; // rcx
  unsigned __int16 *v44; // r9
  unsigned __int16 *v45; // r8
  unsigned __int64 v46; // rdx
  __int64 v47; // rdi
  __int128 v48; // [rsp+20h] [rbp-59h]
  __int128 v49; // [rsp+30h] [rbp-49h] BYREF
  __int128 v50; // [rsp+40h] [rbp-39h] BYREF
  __int128 v51; // [rsp+58h] [rbp-21h] BYREF
  __int64 v52; // [rsp+68h] [rbp-11h]
  unsigned __int16 p_n0x800; // [rsp+70h] [rbp-9h] BYREF
  __int128 v54; // [rsp+78h] [rbp-1h]
  _QWORD *v55; // [rsp+E0h] [rbp+67h] BYREF
  __int64 *v56; // [rsp+E8h] [rbp+6Fh]
  unsigned __int16 n0x800_2; // [rsp+F0h] [rbp+77h] BYREF
  unsigned int v58; // [rsp+F8h] [rbp+7Fh] BYREF

  v56 = a2;
  v55 = (_QWORD *)a1;
  v52 = 0;
  v4 = *a2;
  v51 = 0;
  (*(void (__fastcall **)(__int64 *, __int128 *))(v4 + 0x30))(a2, &v51);
  if ( (_QWORD)v51 == *((_QWORD *)&v51 + 1) )
    LogFatalError("Failed to retrieve component name on registration");
  v5 = (unsigned int *)(a1 + 0x20);
  v6 = (unsigned __int8 *)(*(__int64 (__fastcall **)(__int64 *))(*a2 + 0x38))(a2);
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  v8 = *(char **)v51;
  do
    ++Size;
  while ( v8[Size] );
  if ( !*(_DWORD *)(a1 + 0x28)
    || (v9 = (unsigned __int16 *)sub_146A2FA80(a1 + 0x20, 0, *(_BYTE **)v51, (unsigned __int16)Size)) == 0
    || (n0x800 = *v9, *v9 == 0xFFFF) )
  {
    n0x800 = sub_146A36EA0((unsigned int *)(a1 + 0x20), v8, Size, v6);
  }
  if ( n0x800 >= 0x800u )
    LogFatalError(
      "Too many registered components. Please increase CEntity::MAX_SUPPORTED_COMPONENTS (current value %d)",
      0x800);
  v11 = 0x811C9DC5;
  v12 = *(char **)v51;
  do
  {
    v13 = *v12++;
    v14 = v13 - 0x20;
    if ( (unsigned __int8)(v13 - 0x61) > 0x19u )
      v14 = v13;
    v11 = 0x1000193 * (v11 ^ v14);
  }
  while ( v13 );
  v15 = *(_QWORD *)(a1 + 0x88);
  v58 = v11;
  inserted = v15;
  DWORD2(v50) = 0;
  v17 = *(_QWORD *)(v15 + 8);
  *(_QWORD *)&v50 = v17;
  while ( !*(_BYTE *)(v17 + 0x19) )
  {
    *(_QWORD *)&v50 = v17;
    if ( *(_DWORD *)(v17 + 0x1C) >= v11 )
    {
      inserted = v17;
      DWORD2(v50) = 1;
      v17 = *(_QWORD *)v17;
    }
    else
    {
      v17 = *(_QWORD *)(v17 + 0x10);
      DWORD2(v50) = 0;
    }
  }
  if ( *(_BYTE *)(inserted + 0x19) || v11 < *(_DWORD *)(inserted + 0x1C) )
  {
    if ( *(_QWORD *)(a1 + 0x90) == 0x666666666666666LL )
      unknown_libname_7();
    v18 = allocWithProfilerInfo_w(0x28u);
    v19 = v50;
    *(_DWORD *)(v18 + 0x1C) = v58;
    *(_WORD *)(v18 + 0x20) = 0xFFFF;
    *(_QWORD *)v18 = v15;
    *(_QWORD *)(v18 + 8) = v15;
    *(_QWORD *)(v18 + 0x10) = v15;
    *(_WORD *)(v18 + 0x18) = 0;
    v49 = v19;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 (__int64 **)(a1 + 0x88),
                 (__int64)&v49,
                 v18);
  }
  *(_WORD *)(inserted + 0x20) = n0x800;
  *(_WORD *)(*(_QWORD *)sub_146A165D0(a1 + 0x98, (__int64)&v50, (unsigned __int8 *)&v58) + 0x14LL) = n0x800;
  v20 = *(_QWORD **)(a1 + 0x78);
  v21 = *(_QWORD *)(a1 + 0x70);
  v22 = (__int64)v20 - v21;
  v23 = *(unsigned int *)(a1 + 0x28) + ((__int64)(*((_QWORD *)&v51 + 1) - v51) >> 3);
  if ( v23 >= ((__int64)v20 - v21) / 0x18 )
  {
    if ( v23 > v22 / 0x18 )
    {
      if ( v23 <= (*(_QWORD *)(a1 + 0x80) - v21) / 0x18 )
      {
        for ( i = v23 - v22 / 0x18; i; --i )
        {
          *v20 = 0;
          v20[1] = 0;
          v20[2] = 0;
          v20 += 3;
        }
        sub_146A12030((__int64)v20, (__int64)v20);
        *(_QWORD *)(a1 + 0x78) = v20;
      }
      else
      {
        sub_146A15B80(
          (__int64 *)(a1 + 0x70),
          *(unsigned int *)(a1 + 0x28) + ((__int64)(*((_QWORD *)&v51 + 1) - v51) >> 3));
      }
    }
  }
  else
  {
    v24 = v21 + 0x18 * v23;
    sub_146A12030(v24, *(_QWORD *)(a1 + 0x78));
    *(_QWORD *)(a1 + 0x78) = v24;
  }
  for ( j = 1; j < (__int64)(*((_QWORD *)&v51 + 1) - v51) >> 3; ++j )
  {
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    v28 = *(char **)(v51 + 8 * j);
    do
      ++Size_1;
    while ( v28[Size_1] );
    if ( !v5[2]
      || (v29 = (unsigned __int16 *)sub_146A2FA80((__int64)v5, 0, *(_BYTE **)(v51 + 8 * j), (unsigned __int16)Size_1)) == 0
      || (n0x800_1 = *v29, *v29 == 0xFFFF) )
    {
      n0x800_1 = sub_146A36EA0(v5, v28, Size_1, (unsigned __int8 *)&p_p_p_p_p_p_p_p_p_p_p_Source);
    }
    if ( n0x800_1 > 0x800u )
      LogFatalError("Too many registered components. Please increase MAX_SUPPORTED_COMPONENTS");
    v31 = v55[0xE];
    v32 = *(_WORD **)(v31 + 0x18LL * n0x800_1);
    v33 = v31 + 0x18LL * n0x800_1;
    v34 = *(_BYTE **)(v33 + 8);
    if ( v32 == (_WORD *)v34 )
    {
LABEL_44:
      n0x800_2 = n0x800;
      if ( v34 == *(_BYTE **)(v33 + 0x10) )
      {
        sub_142478E00((const void **)v33, v34, &n0x800_2);
      }
      else
      {
        *(_WORD *)v34 = n0x800;
        *(_QWORD *)(v33 + 8) += 2LL;
      }
    }
    else
    {
      while ( *v32 != n0x800_1 )
      {
        if ( ++v32 == (_WORD *)v34 )
          goto LABEL_44;
      }
    }
  }
  v35 = v55;
  v36 = v55 + 1;
  v37 = v55[1];
  v38 = (v55[2] - v37) / 0x18;
  if ( v38 )
  {
    do
    {
      if ( *(_WORD *)(v37 + 0x18 * (v38 >> 1)) >= n0x800 )
      {
        v38 >>= 1;
      }
      else
      {
        v37 += 0x18 * (v38 >> 1) + 0x18;
        v38 += 0xFFFFFFFFFFFFFFFFuLL - (v38 >> 1);
      }
    }
    while ( v38 );
    v35 = v55;
  }
  if ( v37 != v55[2] && n0x800 < *(_WORD *)v37 )
    v37 = v55[2];
  if ( v37 != v35[2] && *(_QWORD *)(v37 + 8) )
    LogFatalError("Remapping Component Factories is not Supported!");
  v39 = allocWithProfilerInfo_w(0x50u);
  v40 = v56;
  v41 = v39;
  if ( v39 )
  {
    *(_DWORD *)(v39 + 8) = 1;
    *(_DWORD *)(v39 + 0xC) = 1;
    *(_QWORD *)v39 = off_148C1CE70;
    *(_QWORD *)(v39 + 0x18) = 0;
    *(_QWORD *)(v39 + 0x20) = 0;
    *(_QWORD *)(v39 + 0x10) = v40;
    *(_QWORD *)(v39 + 0x30) = 0;
    *(_QWORD *)(v39 + 0x38) = 0;
    sub_140360130((_DWORD *)(v39 + 0x40));
    v42 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v41 + 0x10) + 0x18LL))(*(_QWORD *)(v41 + 0x10));
    v43 = *(_QWORD *)(v41 + 0x10);
    *(_QWORD *)(v41 + 0x18) = v42;
    *(_QWORD *)(v41 + 0x20) = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v43 + 0x20LL))(v43);
  }
  else
  {
    v41 = 0;
  }
  v44 = (unsigned __int16 *)v36[1];
  v45 = (unsigned __int16 *)*v36;
  *(_QWORD *)&v48 = v41 + 0x10;
  *((_QWORD *)&v48 + 1) = v41;
  p_n0x800 = n0x800;
  v54 = v48;
  v46 = ((char *)v44 - (char *)v45) / 0x18;
  while ( v46 )
  {
    if ( v45[0xC * (v46 >> 1)] >= n0x800 )
    {
      v46 >>= 1;
    }
    else
    {
      v45 += 0xC * (v46 >> 1) + 0xC;
      v46 += 0xFFFFFFFFFFFFFFFFuLL - (v46 >> 1);
    }
  }
  if ( v45 == v44 || n0x800 < *v45 )
    sub_146A1A2E0(v36, &v55, (__int64)v45, &p_n0x800);
  if ( *((_QWORD *)&v54 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v54 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      v47 = *((_QWORD *)&v54 + 1);
      (***((void (__fastcall ****)(_QWORD))&v54 + 1))(*((_QWORD *)&v54 + 1));
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v47 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v54 + 1) + 8LL))(*((_QWORD *)&v54 + 1));
    }
  }
  *(_QWORD *)(0x2E0LL * n0x800 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4058) = v40;
  if ( (_QWORD)v51 )
    sub_1403A3120((__int64)&v51, (const void *)v51, (v52 - v51) & 0xFFFFFFFFFFFFFFF8uLL);
}

// --- End Function: sub_146A41530 (0x146A41530) ---

// --- Function: sub_146A42040 (0x146A42040) ---
void __fastcall sub_146A42040(__int64 a1, unsigned __int16 a2, const char *a3)
{
  __int64 v3; // rdi
  __int64 *v4; // rsi
  __int64 *v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rbx
  __int128 v8; // xmm0
  void *v10; // [rsp+28h] [rbp-30h] BYREF
  __int128 v11; // [rsp+30h] [rbp-28h] BYREF

  v3 = a1 + 0xF0;
  CreateStringObjectFromString(&v10, a3);
  v4 = *(__int64 **)v3;
  v5 = v4;
  DWORD2(v11) = 0;
  v6 = v4[1];
  *(_QWORD *)&v11 = v6;
  while ( !*(_BYTE *)(v6 + 0x19) )
  {
    *(_QWORD *)&v11 = v6;
    if ( *(_WORD *)(v6 + 0x20) >= a2 )
    {
      v5 = (__int64 *)v6;
      DWORD2(v11) = 1;
      v6 = *(_QWORD *)v6;
    }
    else
    {
      v6 = *(_QWORD *)(v6 + 0x10);
      DWORD2(v11) = 0;
    }
  }
  if ( *((_BYTE *)v5 + 0x19) || a2 < *((_WORD *)v5 + 0x10) )
  {
    if ( *(_QWORD *)(v3 + 8) == 0x555555555555555LL )
      unknown_libname_7();
    v7 = allocWithProfilerInfo_w(0x30u);
    *(_WORD *)(v7 + 0x20) = a2;
    sub_14035B140((_QWORD *)(v7 + 0x28), (__int64 *)&v10);
    v8 = v11;
    *(_QWORD *)v7 = v4;
    *(_QWORD *)(v7 + 8) = v4;
    *(_QWORD *)(v7 + 0x10) = v4;
    *(_WORD *)(v7 + 0x18) = 0;
    v11 = v8;
    std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
      (__int64 **)v3,
      (__int64)&v11,
      v7);
  }
  sub_140370D10(&v10);
}

// --- End Function: sub_146A42040 (0x146A42040) ---

// --- Function: sub_146A429B0 (0x146A429B0) ---
double __fastcall sub_146A429B0(__int64 a1, __int64 a2)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdi
  __int64 v4; // rax
  double result; // xmm0_8
  unsigned __int64 v6; // [rsp+38h] [rbp+10h] BYREF

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  if ( !*(_BYTE *)(a2 + 0x20) )
  {
    v6 = *(_QWORD *)(a2 + 8);
    if ( is_entity_descriptor_valid_or_accessible(&v6) && *(_BYTE *)((v6 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
    {
      v4 = *(unsigned __int16 *)(a2 + 0x10);
      *(_BYTE *)(a2 + 0x20) = 1;
      return sub_146A24990(
               p_p_p_p_p_p_p_p_p_p_p_p_Source,
               a2,
               *(_BYTE *)(**(_QWORD **)(p_p_p_p_p_p_p_p_p_p_p_p_Source
                                      + 0x2E0 * v4
                                      + 0x18LL * *(int *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0 * v4 + 0x4080)
                                      + 0x4168)
                        + 0x10LL),
               0);
    }
  }
  return result;
}

// --- End Function: sub_146A429B0 (0x146A429B0) ---

// --- Function: sub_146A42A40 (0x146A42A40) ---
double __fastcall sub_146A42A40(__int64 a1, __int64 a2, char a3)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rsi
  __int64 v5; // rdi
  __int64 v7; // rax
  unsigned __int64 v8; // r8
  char v9; // dl
  char *v10; // r8
  char *v11; // rax
  double result; // xmm0_8
  char v13; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v14; // [rsp+58h] [rbp+20h] BYREF

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v5 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v14 = *(_QWORD *)(a2 + 8);
  if ( is_entity_descriptor_valid_or_accessible(&v14) && *(_BYTE *)((v14 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
  {
    v13 = 1;
    v7 = *(_QWORD *)(a2 + 0x18);
    v8 = 3 * __popcnt(*(_QWORD *)(v5 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x42B8) & ((1LL << a3) - 1)) + 1;
    v9 = *(_BYTE *)(v7 + 4 * v8);
    v10 = (char *)(v7 + 4 * v8);
    v11 = &v13;
    if ( v9 )
      v11 = v10;
    *v10 = *v11;
    if ( !v9 )
      return sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a2, a3, 0);
  }
  return result;
}

// --- End Function: sub_146A42A40 (0x146A42A40) ---

// --- Function: sub_146A42B00 (0x146A42B00) ---
char __fastcall sub_146A42B00(__int64 a1, __int64 a2, char a3, char a4)
{
  return sub_146A42B10(p_p_p_p_p_p_p_p_p_p_p_p_Source_8, a2, a3, a4);
}

// --- End Function: sub_146A42B00 (0x146A42B00) ---

// --- Function: sub_146A42B10 (0x146A42B10) ---
char __fastcall sub_146A42B10(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, char a3, char a4)
{
  __int64 v6; // r15
  char result; // al
  __int64 v8; // r12
  int v9; // r14d
  bool v10; // bl
  char v11; // di
  unsigned __int64 v12; // rax
  _DWORD *v13; // r13
  unsigned __int64 v14; // rcx
  bool v15; // zf
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // rcx
  char v19; // r14
  __int64 v20; // rbx
  signed __int64 v21; // rbp
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rcx
  __int64 v24; // rcx
  unsigned __int64 v25; // [rsp+30h] [rbp-68h] BYREF
  __int64 v26; // [rsp+38h] [rbp-60h] BYREF
  int n0xF; // [rsp+40h] [rbp-58h]
  char v28; // [rsp+44h] [rbp-54h]
  char v29; // [rsp+45h] [rbp-53h]
  int v31; // [rsp+A8h] [rbp+10h]

  v6 = p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v25 = *(_QWORD *)(a2 + 8);
  result = is_entity_descriptor_valid_or_accessible(&v25);
  if ( result )
  {
    result = v25;
    if ( (v25 & 0xFFFFFFFFFFFFLL) != 0 && *(_BYTE *)((v25 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
    {
      v8 = (1LL << a3) - 1;
      v9 = *(_DWORD *)(0x20 * __popcnt(v8 & *(_QWORD *)(v6 + 0x42B8)) + *(_QWORD *)(v6 + 0x4150) + 0xC);
      v31 = v9;
      v10 = !is_thread_privileged_or_bypass_mode() && !*(_BYTE *)(get_thread_context_ptr() + 0x12D);
      v11 = 0;
      v12 = v25;
      v13 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x920LL);
      if ( *v13 == v9 )
      {
        if ( !v25
          || ((v25 & 0xF000000000000000uLL) == 0 ? (v14 = (v25 & 0xFFFFFFFFFFFFLL) - 6) : (v14 = v25 & 0xFFFFFF000000LL),
              *(_WORD *)(v14 + 2) != (HIWORD(v25) & 0xFFF)
           || *(_WORD *)(v14 + 4) >= 3u
           && (v15 = !check_thread_state_and_value_not_equal((_QWORD *)(v25 & 0xFFFFFFFFFFFFLL)), v12 = v25, v15)
           || (v12 & 0xFFFFFFFFFFFFLL) == 0
           || ((v12 & 0xF000000000000000uLL) == 0
             ? (v16 = (v12 & 0xFFFFFFFFFFFFLL) - 6)
             : (v16 = v12 & 0xFFFFFF000000LL),
               *(_WORD *)(v16 + 4) != 1)) )
        {
          v11 = 1;
        }
      }
      if ( v10 )
      {
        if ( !v12 )
          goto LABEL_36;
        v17 = (v12 & 0xF000000000000000uLL) != 0 ? v12 & 0xFFFFFF000000LL : (v12 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v17 + 2) != (HIWORD(v12) & 0xFFF) )
          goto LABEL_36;
        if ( *(_WORD *)(v17 + 4) >= 3u )
        {
          if ( !check_thread_state_and_value_not_equal((_QWORD *)(v12 & 0xFFFFFFFFFFFFLL)) )
          {
LABEL_36:
            v11 = 1;
            goto LABEL_37;
          }
          v12 = v25;
        }
        if ( (v12 & 0xFFFFFFFFFFFFLL) == 0 )
          goto LABEL_36;
        v18 = (v12 & 0xF000000000000000uLL) != 0 ? v12 & 0xFFFFFF000000LL : (v12 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v18 + 4) != 1 )
          goto LABEL_36;
      }
LABEL_37:
      v19 = v11;
      if ( *v13 == 0x10 )
        v19 = 1;
      v20 = 0x478LL * v31 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1D0;
      if ( *(_DWORD *)(v20 + 0x10) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
      {
        ++*(_DWORD *)(v20 + 0x14);
      }
      else
      {
        v21 = _InterlockedIncrement64((volatile signed __int64 *)v20);
        if ( (v21 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            v20,
            v21,
            "CEntityComponentUpdateScheduler::SetFrequencyForComponentUpdate",
            "m_perPassState[nPass].bIsRunningLock",
            1);
      }
      if ( *(_BYTE *)(0x478LL * v31 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1C9) )
      {
        v22 = v25;
        if ( !v25 )
          goto LABEL_58;
        v23 = (v25 & 0xF000000000000000uLL) != 0 ? v25 & 0xFFFFFF000000LL : (v25 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v23 + 2) != (HIWORD(v25) & 0xFFF) )
          goto LABEL_58;
        if ( *(_WORD *)(v23 + 4) >= 3u )
        {
          if ( !check_thread_state_and_value_not_equal((_QWORD *)(v25 & 0xFFFFFFFFFFFFLL)) )
            goto LABEL_58;
          v22 = v25;
        }
        if ( (v22 & 0xFFFFFFFFFFFFLL) == 0 )
          goto LABEL_58;
        v24 = (v22 & 0xF000000000000000uLL) != 0 ? v22 & 0xFFFFFF000000LL : (v22 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v24 + 4) != 1 )
          goto LABEL_58;
      }
      if ( !v19 )
      {
        *(_BYTE *)(*(_QWORD *)(a2 + 0x18) + 0xC * __popcnt(*(_QWORD *)(v6 + 0x42B8) & v8) + 5) = a4;
        return rw_lock_release_read_lock(v20);
      }
LABEL_58:
      v28 = a3;
      v29 = a4;
      n0xF = 0xF;
      v26 = a2;
      _InterlockedIncrement16((volatile signed __int16 *)(a2 + 0x22));
      sub_1403CA640(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x140, &v26, 0x10u);
      return rw_lock_release_read_lock(v20);
    }
  }
  return result;
}

// --- End Function: sub_146A42B10 (0x146A42B10) ---

// --- Function: sub_146A4A820 (0x146A4A820) ---
unsigned __int64 __fastcall sub_146A4A820(__int64 a1, unsigned __int64 a2)
{
  const void *v3; // rcx
  unsigned __int64 result; // rax
  __int64 v5; // r14
  __int64 v6; // rsi
  char *v7; // rdi

  v3 = *(const void **)a1;
  result = (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v3) >> 1;
  if ( a2 > result )
  {
    if ( a2 > 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = 2 * a2;
    v6 = (__int64)(*(_QWORD *)(a1 + 8) - (_QWORD)v3) >> 1;
    v7 = (char *)sub_140391AB0(a1, 2 * a2);
    memmove(v7, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    if ( *(_QWORD *)a1 )
      sub_1403A3120(a1, *(const void **)a1, 2 * ((__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 1));
    *(_QWORD *)a1 = v7;
    *(_QWORD *)(a1 + 8) = &v7[2 * v6];
    result = (unsigned __int64)&v7[v5];
    *(_QWORD *)(a1 + 0x10) = &v7[v5];
  }
  return result;
}

// --- End Function: sub_146A4A820 (0x146A4A820) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: sub_147605AA0 (0x147605AA0) ---
unsigned __int64 __fastcall sub_147605AA0(void *a1, unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  unsigned __int64 result; // rax
  char v7; // al
  __int64 v8; // rax

  if ( !a1 )
    return allocWithProfilerInfo(allocSize, profilerInfo);
  if ( !allocSize )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
      return 0;
    }
    return 0;
  }
  if ( gEnv && qword_149B4FBE8 && a1 == (void *)qword_149B4FBE8 )
    __debugbreak();
  if ( (unsigned __int64)a1 >= qword_149B00898 && (unsigned __int64)a1 < qword_149B00898 + 0x8000000000LL )
    LogFatalError("Address %p was allocated by streaming malloc and cannot be reallocated!", a1);
  if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
    LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
  v7 = sub_1474DA7B0();
  sub_14056A7D0(v7);
  v8 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
  result = sub_147603760((__int64)a1, v8 + allocSize, (unsigned __int64)profilerInfo);
  if ( !result )
  {
    sub_1476052F0(allocSize);
    return 0;
  }
  return result;
}

// --- End Function: sub_147605AA0 (0x147605AA0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

