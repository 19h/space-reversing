// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x145C69BF0 (sub_145C69BF0)
// Caller Depth: 1
// Callee/Ref Depth: 4
// Total Functions Found: 97
// ------------------------------------------------------------

// --- Function: identity_passthrough (0x1402A24F0) ---
// Returns the input value unchanged. This function serves as a simple identity
// transformation.
__int64 __fastcall identity_passthrough(__int64 input_value)
{
  return input_value;
}

// --- End Function: identity_passthrough (0x1402A24F0) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---

// --- Function: callable_object_release_or_destroy (0x1402A2AD0) ---
// Acts as a custom deleter or release function for a callable object. If the
// internal state (at `a1[1]`) indicates an active callable (value >= 2), it
// invokes the stored function pointer with specific arguments (2, a1) to perform
// cleanup, then nullifies the function pointer and the object's primary pointer.
// Otherwise, it simply nullifies the primary pointer.
__int64 __fastcall callable_object_release_or_destroy(_QWORD *object_ptr)
{
  void (__fastcall *release_func_or_state)(__int64, _QWORD *); // rax
  __int64 result; // rax

  release_func_or_state = (void (__fastcall *)(__int64, _QWORD *))object_ptr[1];
  if ( (unsigned __int64)release_func_or_state < 2 )
  {
    result = 0;
    *object_ptr = 0;
  }
  else
  {
    release_func_or_state(2, object_ptr);
    result = 0;
    object_ptr[1] = 0;
    *object_ptr = 0;
  }
  return result;
}

// --- End Function: callable_object_release_or_destroy (0x1402A2AD0) ---

// --- Function: sub_1402A2B80 (0x1402A2B80) ---
__int64 __fastcall sub_1402A2B80(__int64 a1, __int64 a2)
{
  return a2;
}

// --- End Function: sub_1402A2B80 (0x1402A2B80) ---

// --- Function: sub_1402A2DB0 (0x1402A2DB0) ---
__int64 __fastcall sub_1402A2DB0(__int64 a1, __int64 a2)
{
  return ~(a2 - 1) & (a2 + a1 - 1);
}

// --- End Function: sub_1402A2DB0 (0x1402A2DB0) ---

// --- Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---
bool __fastcall AK::WriteBytesCount::Reserve(AK::WriteBytesCount *this)
{
  return 0;
}

// --- End Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---

// --- Function: engine_module_noop_callback (0x1402A34C0) ---
// An empty function, likely serving as a no-operation callback or a placeholder
// for module-specific logic that is disabled or not implemented in this build
// configuration.
void __fastcall engine_module_noop_callback(ULONG_PTR unused_param)
{
  ;
}

// --- End Function: engine_module_noop_callback (0x1402A34C0) ---

// --- Function: memory_deallocate_wrapper (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall memory_deallocate_wrapper(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: memory_deallocate_wrapper (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_Wrapper (0x1402A3D40) ---
// // A wrapper function for allocWithProfilerInfo that allocates memory // without
// providing specific profiler information. It simply forwards // the allocation
// size to the main allocation function with a null // profiler context. // //
// Parameters: //   allocSize: The size of memory in bytes to allocate. // //
// Returns: //   A pointer to the newly allocated memory block, or nullptr if
// allocation fails.
__int64 __fastcall allocWithProfilerInfo_Wrapper(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_Wrapper (0x1402A3D40) ---

// --- Function: unknown_libname_2 (0x1402ADBA0) ---
// Microsoft VisualC v14 64bit runtime
_QWORD *__fastcall unknown_libname_2(_QWORD *a1, _QWORD *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

// --- End Function: unknown_libname_2 (0x1402ADBA0) ---

// --- Function: unknown_libname_472 (0x1402AE2A0) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_472(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_472 (0x1402AE2A0) ---

// --- Function: sub_1402B2810 (0x1402B2810) ---
__int64 __fastcall sub_1402B2810(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)a1 )
  {
    sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_1402B2810 (0x1402B2810) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---
// Microsoft VisualC v14 64bit runtime
__int64 __fastcall __crt_strtox::maximum_signed_value(__crt_strtox *this)
{
  return 0x7FFFFFFFFFFFFFFFLL;
}

// --- End Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---

// --- Function: unknown_libname_473 (0x1402E37F0) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
unsigned __int64 unknown_libname_473()
{
  return 0xFFFFFFFFFFFFFFFFuLL;
}

// --- End Function: unknown_libname_473 (0x1402E37F0) ---

// --- Function: sub_140306140 (0x140306140) ---
__int64 __fastcall sub_140306140(__int64 a1, __int64 a2)
{
  return -a2 & (a1 + a2 - 1);
}

// --- End Function: sub_140306140 (0x140306140) ---

// --- Function: sub_1403090B0 (0x1403090B0) ---
__int64 __fastcall sub_1403090B0(unsigned int *a1)
{
  return *a1;
}

// --- End Function: sub_1403090B0 (0x1403090B0) ---

// --- Function: sub_1403093A0 (0x1403093A0) ---
unsigned __int64 __fastcall sub_1403093A0(unsigned __int64 n4_1, unsigned __int64 n4)
{
  if ( n4_1 > n4 )
    return n4_1;
  return n4;
}

// --- End Function: sub_1403093A0 (0x1403093A0) ---

// --- Function: sub_1403093B0 (0x1403093B0) ---
__int64 __fastcall sub_1403093B0(unsigned int a1, unsigned int a2)
{
  if ( (int)a1 < (int)a2 )
    return a1;
  return a2;
}

// --- End Function: sub_1403093B0 (0x1403093B0) ---

// --- Function: sub_140332A70 (0x140332A70) ---
unsigned __int64 __fastcall sub_140332A70(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 n8_2,
        unsigned __int8 a5)
{
  __int64 n8; // rdx
  unsigned __int64 n8_1; // rcx
  __int64 (__fastcall *v9)(unsigned __int64, unsigned __int64 *, __int64, _QWORD); // rax
  __int64 v10; // rdi
  unsigned __int64 v11; // r10
  __int64 v12; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v14; // r8
  __int64 v15; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 n0x20_1; // rax
  unsigned __int64 n0x20; // rcx
  __int64 n0x10000; // r8
  unsigned __int64 n0x10000_1; // rcx

  n8 = 8;
  n8_1 = 8;
  if ( n8_2 > 8 )
    n8_1 = n8_2;
  if ( a2 )
  {
    v9 = *(__int64 (__fastcall **)(unsigned __int64, unsigned __int64 *, __int64, _QWORD))(a2 - 8);
    if ( n8_1 > 8 )
      n8 = n8_1;
    v10 = (n8 + 7) & ~(n8 - 1);
    v11 = a2 - v10;
    if ( *a3 )
      *a3 += v10;
    v12 = v9(v11, a3, n8, a5);
    if ( *a3 )
      *a3 -= v10;
    result = v12 + v10;
    if ( !v12 )
      return 0;
  }
  else
  {
    v14 = *a3;
    if ( v14 )
    {
      if ( n8_1 > 8 )
        n8 = n8_1;
      v15 = (n8 + 7) & ~(n8 - 1);
      allocSize = v14 + v15;
      *a3 = v14 + v15;
      if ( v14 + v15 )
      {
        if ( a5 )
        {
          n0x20_1 = allocSize + 0x10;
          n0x20 = 0x20;
          if ( n0x20_1 > 0x20 )
          {
            do
              n0x20 *= 2LL;
            while ( n0x20 < n0x20_1 );
            n0x10000 = 0x10000;
            if ( n0x20 > 0x10000 )
            {
              n0x10000_1 = n0x20 >> 3;
              if ( n0x10000_1 > 0x10000 )
                n0x10000 = n0x10000_1;
              n0x20 = ~(n0x10000 - 1) & (n0x10000 + n0x20_1 - 1);
            }
          }
          allocSize = n0x20 - 0x10;
          *a3 = allocSize;
        }
        allocSize = allocWithProfilerInfo(allocSize, (struct _exception *)n8);
      }
      if ( *a3 )
        *a3 -= v15;
      a2 = v15 + allocSize;
      if ( !allocSize )
        a2 = 0;
      if ( a2 )
        *(_QWORD *)(a2 - 8) = sub_140332D60;
    }
    return a2;
  }
  return result;
}

// --- End Function: sub_140332A70 (0x140332A70) ---

// --- Function: sub_140332FA0 (0x140332FA0) ---
__int64 __fastcall sub_140332FA0(_QWORD *a1)
{
  __int64 v1; // rax

  v1 = *(unsigned int *)(*a1 - 4LL);
  LODWORD(v1) = v1 & 0x7FFFFFFF;
  return *a1 + 8 * v1;
}

// --- End Function: sub_140332FA0 (0x140332FA0) ---

// --- Function: unknown_libname_248_w (0x1403490F0) ---
const __m128i *__fastcall unknown_libname_248_w(const __m128i *a1, const __m128i *a2, unsigned __int64 *a3)
{
  return unknown_libname_248(a1, a2, *a3);
}

// --- End Function: unknown_libname_248_w (0x1403490F0) ---

// --- Function: sub_14035A0F0 (0x14035A0F0) ---
unsigned __int64 __fastcall sub_14035A0F0(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        int *a4,
        unsigned __int64 n4,
        unsigned __int8 a6)
{
  __int64 v6; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rax
  _QWORD *v12; // rdx
  _QWORD *v13; // rdx
  unsigned __int64 n4_1; // rdx
  __int64 n8; // r8
  __int64 v16; // rdi
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v19; // [rsp+48h] [rbp+10h] BYREF

  v6 = *a4;
  if ( (_DWORD)v6 )
  {
    v19 = 8 * v6;
    v10 = sub_140332BC0(a1, 0, &v19, n4, a6);
    v11 = v19 >> 3;
    *a4 = v19 >> 3;
  }
  else
  {
    v10 = 0;
    LODWORD(v11) = 0;
  }
  if ( a2 )
  {
    if ( v10 )
    {
      if ( a3 < (int)v11 )
        LODWORD(v11) = a3;
      if ( a2 != v10 )
      {
        v11 = (int)v11;
        if ( a2 > v10 || a2 + 8LL * (int)v11 <= v10 )
        {
          if ( (_DWORD)v11 )
          {
            v13 = (_QWORD *)v10;
            do
            {
              *v13 = *(_QWORD *)((char *)v13 + a2 - v10);
              ++v13;
              --v11;
            }
            while ( v11 );
          }
        }
        else if ( (_DWORD)v11 )
        {
          v12 = (_QWORD *)(v10 + 8 * ((int)v11 - 1LL));
          do
          {
            *v12 = *(_QWORD *)((char *)v12 + a2 - v10);
            v12 += 0xFFFFFFFF;
            --v11;
          }
          while ( v11 );
        }
      }
    }
    n4_1 = 4;
    v19 = 0;
    n8 = 8;
    if ( n4 > 4 )
      n4_1 = n4;
    v16 = a2 - ((n4_1 + 3) & ~(n4_1 - 1));
    n8_1 = 8;
    if ( n4_1 > 8 )
      n8_1 = n4_1;
    if ( v16 )
    {
      if ( n8_1 > 8 )
        n8 = n8_1;
      (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64, _QWORD))(v16 - 8))(
        v16 - ((n8 + 7) & ~(n8 - 1)),
        &v19,
        n8,
        0);
    }
  }
  return v10;
}

// --- End Function: sub_14035A0F0 (0x14035A0F0) ---

// --- Function: sub_1403719A0 (0x1403719A0) ---
__int64 __fastcall sub_1403719A0(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)a1 )
  {
    sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFFCuLL);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_1403719A0 (0x1403719A0) ---

// --- Function: sub_140391AB0 (0x140391AB0) ---
__int64 __fastcall sub_140391AB0(__int64 a1, unsigned __int64 allocSize)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  unsigned __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403B38D0();
  n0x40 = (allocSize >> 8) + ((_BYTE)allocSize != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
      goto LABEL_7;
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 0x40LL;
      if ( n0x4000 >= 0x4000 )
        goto LABEL_2;
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
        n0x40_1 = 0xFFFFFFFFFFFFFFFFuLL;
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
          goto LABEL_2;
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ;
          n0x4000_2 + 0x40 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL);
          v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = 0xFFFFFFFFFFFFFFFFuLL )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 0x40LL;
    }
    if ( n0x4000_2 < n0x4000 )
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 0x40)) - 1;
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056DB80((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056DBC0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_14056DA40((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(allocSize, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140391AB0 (0x140391AB0) ---

// --- Function: sub_1403A3120 (0x1403A3120) ---
void __fastcall sub_1403A3120(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403B38D0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 0x20) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ; v7 + 0x40 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 0x28) = 0 )
    {
      v11 = v7;
      v7 += 0x40LL;
    }
    if ( v7 < v8 )
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~((1LL << ((__int64)v8 % 0x40)) - 1);
  }
  else
  {
    sub_147605980(a2);
  }
}

// --- End Function: sub_1403A3120 (0x1403A3120) ---

// --- Function: sub_1403B38D0 (0x1403B38D0) ---
__int64 sub_1403B38D0()
{
  __int64 v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  result = *(_QWORD *)v0;
  if ( !*(_QWORD *)v0 )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_Wrapper(0x828u);
    if ( v2 )
    {
      v2[3] = &p_p_p_p_p_p_p_p_p_p_p_Source;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)v0 = v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 0xC0);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 0xC0) = v6 | 1;
      _tlregdtor((__int64)sub_1480BD400);
    }
    return *(_QWORD *)v0;
  }
  return result;
}

// --- End Function: sub_1403B38D0 (0x1403B38D0) ---

// --- Function: sub_1403E4CD0 (0x1403E4CD0) ---
void __fastcall sub_1403E4CD0(__int64 a1, const void *a2, __int64 a3)
{
  sub_1403A3120(a1, a2, 8 * a3);
}

// --- End Function: sub_1403E4CD0 (0x1403E4CD0) ---

// --- Function: sub_14042E600 (0x14042E600) ---
void __fastcall sub_14042E600(_QWORD *a1, unsigned __int64 a2)
{
  size_t Size; // rdi
  char *v4; // rax
  char *v5; // rbx

  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    Size = 4 * a2;
    v4 = (char *)sub_140391AB0((__int64)a1, 4 * a2);
    *a1 = v4;
    v5 = v4;
    a1[2] = &v4[Size];
    memset(v4, 0, Size);
    a1[1] = &v5[Size];
  }
}

// --- End Function: sub_14042E600 (0x14042E600) ---

// --- Function: sub_1404619D0 (0x1404619D0) ---
unsigned __int64 __fastcall sub_1404619D0(unsigned __int64 *a1)
{
  return sub_140503E10(a1, 0, 0);
}

// --- End Function: sub_1404619D0 (0x1404619D0) ---

// --- Function: sub_140503E10 (0x140503E10) ---
unsigned __int64 __fastcall sub_140503E10(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // r10
  int v6; // ecx
  int v7; // eax
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rdx
  int v10; // eax
  unsigned __int64 v11; // rax
  unsigned __int64 result; // rax
  __int64 v13; // rdx
  int v14; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v6 = *(_DWORD *)(*a1 - 4);
  v7 = 8 * v6;
  if ( v6 >= 0 )
    v8 = (unsigned __int64)v7 >> 3;
  else
    LODWORD(v8) = *(_DWORD *)(v7 + v3);
  v9 = 0;
  v10 = 0;
  if ( a3 )
    LOBYTE(v10) = a2 > (int)v8;
  else
    LOBYTE(v10) = a2 != (_DWORD)v8;
  if ( v10 )
  {
    v14 = a2;
    if ( v6 )
      v9 = v3;
    v11 = sub_14035A0F0((__int64)a1, v9, v6 & 0x7FFFFFFF, &v14, 8u, a3);
    *a1 = v11;
    v3 = v11;
    if ( !v11 )
    {
      result = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
      *a1 = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
      return result;
    }
    LODWORD(v8) = v14;
  }
  v13 = 8 * a2;
  *(_DWORD *)(v3 - 4) = a2;
  result = v13 + 4;
  if ( 8LL * (int)v8 >= (unsigned __int64)(v13 + 4) )
  {
    *(_DWORD *)(v3 - 4) = a2 | 0x80000000;
    *(_DWORD *)(v13 + v3) = v8;
  }
  return result;
}

// --- End Function: sub_140503E10 (0x140503E10) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10();
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DB80 (0x14056DB80) ---
__int64 __fastcall sub_14056DB80(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 0x1000 )
        return 0x1000;
      if ( ++v1 == v2 )
        return 0x1000;
    }
  }
  return 0x1000;
}

// --- End Function: sub_14056DB80 (0x14056DB80) ---

// --- Function: sub_14056DBC0 (0x14056DBC0) ---
__int64 __fastcall sub_14056DBC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E2E40(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056DBC0 (0x14056DBC0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *stdioCommonVsprintfContext; // rax
  int formattedLength; // eax
  char errorMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, Format);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !gEnv || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    stdioCommonVsprintfContext = sub_1402A4380();
    formattedLength = _stdio_common_vsprintf(
                        *stdioCommonVsprintfContext | 2LL,
                        errorMessageBuffer,
                        0x1000u,
                        Format,
                        0,
                        args);
    if ( formattedLength < 0 )
      formattedLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedLength >= 0x1000 )
      errorMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      errorMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_142180350 (0x142180350) ---
bool __fastcall sub_142180350(__int64 a1, __int64 a2)
{
  return *(_WORD *)(a1 + 8) == *(_WORD *)(a2 + 8) && *(_QWORD *)a1 == *(_QWORD *)a2;
}

// --- End Function: sub_142180350 (0x142180350) ---

// --- Function: sub_1422DA490 (0x1422DA490) ---
__int64 __fastcall sub_1422DA490(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // r10
  __int64 v5; // rsi
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  unsigned __int64 v9; // r9
  unsigned __int64 v10; // rdx
  int v11; // eax
  unsigned __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  int v16; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v5 = a2;
  v6 = *(_DWORD *)(*a1 - 4);
  v7 = 8 * v6;
  v8 = (v6 & 0x7FFFFFFF) + a2;
  if ( v6 >= 0 )
    v9 = (unsigned __int64)v7 >> 3;
  else
    LODWORD(v9) = *(_DWORD *)(v3 + v7);
  v10 = 0;
  v11 = 0;
  if ( a3 )
    LOBYTE(v11) = v8 > (int)v9;
  else
    LOBYTE(v11) = v8 != (_DWORD)v9;
  if ( v11 )
  {
    v16 = v8;
    if ( v6 )
      v10 = v3;
    v12 = sub_14035A0F0((__int64)a1, v10, v6 & 0x7FFFFFFF, &v16, 8u, a3);
    *a1 = v12;
    v3 = v12;
    if ( !v12 )
    {
      *a1 = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
      goto LABEL_15;
    }
    LODWORD(v9) = v16;
  }
  v13 = 8 * v8;
  *(_DWORD *)(v3 - 4) = v8;
  if ( 8LL * (int)v9 >= (unsigned __int64)(v13 + 4) )
  {
    *(_DWORD *)(v3 - 4) = v8 | 0x80000000;
    *(_DWORD *)(v13 + v3) = v9;
  }
LABEL_15:
  v14 = *(unsigned int *)(*a1 - 4);
  LODWORD(v14) = v14 & 0x7FFFFFFF;
  return *a1 + 8 * (v14 - v5);
}

// --- End Function: sub_1422DA490 (0x1422DA490) ---

// --- Function: sub_1426F0230 (0x1426F0230) ---
char *__fastcall sub_1426F0230(const void *a1, __int64 a2, char *a3)
{
  size_t Size; // [rsp+28h] [rbp-40h]

  Size = a2 - (_QWORD)a1;
  memmove(a3, a1, a2 - (_QWORD)a1);
  return &a3[Size];
}

// --- End Function: sub_1426F0230 (0x1426F0230) ---

// --- Function: sub_1426F08A0 (0x1426F08A0) ---
__int64 __fastcall sub_1426F08A0(AK::WriteBytesCount *a1, const void *src)
{
  __int64 *v3; // [rsp+20h] [rbp-48h]
  __int64 v4; // [rsp+28h] [rbp-40h]
  __int64 v5; // [rsp+48h] [rbp-20h]

  v3 = (__int64 *)((char *)a1 + 8);
  v4 = *((_QWORD *)a1 + 1);
  AK::WriteBytesCount::Reserve(a1);
  qmemcpy((void *)sub_1402A2B80(0x10, v4), src, 0x10u);
  v5 = *v3;
  *v3 += 0x10;
  return v5;
}

// --- End Function: sub_1426F08A0 (0x1426F08A0) ---

// --- Function: sub_1426F3380 (0x1426F3380) ---
char *__fastcall sub_1426F3380(AK::WriteBytesCount *src_2, AK::WriteBytesCount *src_1, char *a3)
{
  AK::WriteBytesCount *src; // [rsp+20h] [rbp-68h]
  char *v6; // [rsp+38h] [rbp-50h]

  src = src_2;
  if ( AK::WriteBytesCount::Reserve(src_2) )
  {
    v6 = a3;
    while ( src != src_1 )
    {
      qmemcpy((void *)sub_1402A2B80(0x10, (__int64)v6), src, 0x10u);
      v6 += 0x10;
      src = (AK::WriteBytesCount *)((char *)src + 0x10);
    }
    return v6;
  }
  else
  {
    sub_1426F0230(src, (__int64)src_1, a3);
    return &a3[0x10 * ((src_1 - src) >> 4)];
  }
}

// --- End Function: sub_1426F3380 (0x1426F3380) ---

// --- Function: sub_1426FAB20 (0x1426FAB20) ---
Parameter *__fastcall sub_1426FAB20(Parameter *Parameter_1)
{
  engine_module_noop_callback((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_1426FAB20 (0x1426FAB20) ---

// --- Function: std__Tree_unchecked_const_iterator_ctor (0x1426FC3B0) ---
// Standard C++ tree iterator constructor. Initializes the iterator's internal node
// pointer and calls a module-specific callback function.
Parameter *__fastcall std__Tree_unchecked_const_iterator_ctor(Parameter *this_iterator, __int64 node_ptr)
{
  *(_QWORD *)this_iterator = node_ptr;
  engine_module_noop_callback((ULONG_PTR)this_iterator);
  return this_iterator;
}

// --- End Function: std__Tree_unchecked_const_iterator_ctor (0x1426FC3B0) ---

// --- Function: bb_comparison_operator_type_destroy (0x1426FC570) ---
// Destroys or resets a `BB_ComparisonOperatorType` structure. It calls
// `sub_1426FAB20` (which includes a no-op module callback), sets the first three
// QWORDs of the structure to zero, and then calls the no-op module callback again.
// This function ensures the structure is in a clean or uninitialized state.
BB_ComparisonOperatorType *__fastcall bb_comparison_operator_type_destroy(BB_ComparisonOperatorType *operator_type_ptr)
{
  sub_1426FAB20((Parameter *)operator_type_ptr);
  *(_QWORD *)operator_type_ptr = 0;
  *((_QWORD *)operator_type_ptr + 1) = 0;
  *((_QWORD *)operator_type_ptr + 2) = 0;
  engine_module_noop_callback((ULONG_PTR)operator_type_ptr);
  return operator_type_ptr;
}

// --- End Function: bb_comparison_operator_type_destroy (0x1426FC570) ---

// --- Function: unknown_libname_67 (0x14277CFC0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_67()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_67 (0x14277CFC0) ---

// --- Function: sub_14277D150 (0x14277D150) ---
void __fastcall sub_14277D150(BB_ComparisonOperatorType *Parameter_1, const void *a2, __int64 a3)
{
  engine_module_noop_callback((ULONG_PTR)Parameter_1);
  sub_1403A3120((__int64)Parameter_1, a2, 0x10 * a3);
}

// --- End Function: sub_14277D150 (0x14277D150) ---

// --- Function: sub_1428BF6D0 (0x1428BF6D0) ---
Parameter *__fastcall sub_1428BF6D0(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  Parameter *Parameter_2; // [rsp+30h] [rbp-28h]
  _QWORD *v5; // [rsp+40h] [rbp-18h]

  v5 = Parameter + 1;
  Parameter_2 = Parameter + 2;
  engine_module_noop_callback((ULONG_PTR)Parameter);
  Parameter_1 = Parameter;
  if ( *Parameter )
  {
    sub_1403E4CD0((__int64)Parameter, *Parameter, ((_BYTE *)*Parameter_2 - (_BYTE *)*Parameter) >> 3);
    *Parameter = 0;
    *v5 = 0;
    Parameter_1 = Parameter_2;
    *Parameter_2 = 0;
  }
  return Parameter_1;
}

// --- End Function: sub_1428BF6D0 (0x1428BF6D0) ---

// --- Function: sub_1428CE360 (0x1428CE360) ---
__int64 __fastcall sub_1428CE360(void *buf, __int64 a2)
{
  memset(buf, 0, a2 - (_QWORD)buf);
  return a2;
}

// --- End Function: sub_1428CE360 (0x1428CE360) ---

// --- Function: sub_142BB4550 (0x142BB4550) ---
__int64 __fastcall sub_142BB4550(_QWORD *a1, __int64 a2, int a3)
{
  int v4; // [rsp+8h] [rbp-40h]

  v4 = (*(_DWORD *)(*a1 - 4LL) & 0x7FFFFFFF) - a3;
  *(_QWORD *)a2 = *a1 + 8LL * a3;
  *(_DWORD *)(a2 + 8) = v4;
  return a2;
}

// --- End Function: sub_142BB4550 (0x142BB4550) ---

// --- Function: sub_142C04A60 (0x142C04A60) ---
unsigned __int64 __fastcall sub_142C04A60(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [rsp+20h] [rbp-38h]
  __int64 v4; // [rsp+30h] [rbp-28h]
  unsigned __int64 v5; // [rsp+40h] [rbp-18h] BYREF
  __int64 v6; // [rsp+48h] [rbp-10h] BYREF

  v3 = (__int64)(a1[2] - *a1) >> 4;
  v5 = unknown_libname_473() / 0x10;
  v6 = __crt_strtox::maximum_signed_value((__crt_strtox *)0x10);
  v4 = *unknown_libname_2(&v6, &v5);
  if ( v3 > v4 - v3 / 2 )
    return v4;
  if ( v3 / 2 + v3 >= a2 )
    return v3 / 2 + v3;
  return a2;
}

// --- End Function: sub_142C04A60 (0x142C04A60) ---

// --- Function: sub_142C05020 (0x142C05020) ---
__int64 __fastcall sub_142C05020(BB_ComparisonOperatorType *Parameter, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  BB_ComparisonOperatorType *v6; // [rsp+30h] [rbp-28h]
  BB_ComparisonOperatorType *v8; // [rsp+40h] [rbp-18h]

  v8 = Parameter + 2;
  v6 = Parameter + 4;
  engine_module_noop_callback((ULONG_PTR)Parameter);
  if ( *(_QWORD *)Parameter )
    sub_14277D150(Parameter, *(const void **)Parameter, (__int64)(*(_QWORD *)v6 - *(_QWORD *)Parameter) >> 4);
  *(_QWORD *)Parameter = a2;
  *(_QWORD *)v8 = 0x10 * a3 + a2;
  result = 0x10 * a4 + a2;
  *(_QWORD *)v6 = result;
  return result;
}

// --- End Function: sub_142C05020 (0x142C05020) ---

// --- Function: sub_142C09E40 (0x142C09E40) ---
unsigned __int64 __fastcall sub_142C09E40(
        __int64 a1,
        unsigned __int64 a2,
        __int64 *a3,
        unsigned __int64 a4,
        unsigned __int8 a5)
{
  __int64 v6; // [rsp+30h] [rbp-18h]
  unsigned __int64 v9; // [rsp+58h] [rbp+10h]
  unsigned __int64 n8; // [rsp+68h] [rbp+20h]

  n8 = sub_1403093A0(a4, 4u);
  v6 = sub_1402A2DB0(4, n8);
  if ( a2 )
    a2 -= v6;
  if ( *a3 )
  {
    *a3 = sub_1402A2DB0(*a3, 4);
    *a3 += v6;
  }
  v9 = sub_140332A70(a1, a2, (unsigned __int64 *)a3, n8, a5);
  if ( *a3 )
    *a3 -= v6;
  if ( v9 )
    v9 += v6;
  return v9;
}

// --- End Function: sub_142C09E40 (0x142C09E40) ---

// --- Function: sub_142C09F90 (0x142C09F90) ---
__int64 __fastcall sub_142C09F90(BB_ComparisonOperatorType *Parameter_1, __int64 a2)
{
  engine_module_noop_callback((ULONG_PTR)Parameter_1);
  return sub_140391AB0((__int64)Parameter_1, 0x10 * a2);
}

// --- End Function: sub_142C09F90 (0x142C09F90) ---

// --- Function: sub_142C0A070 (0x142C0A070) ---
unsigned __int64 __fastcall sub_142C0A070(int *a1)
{
  int v2; // [rsp+24h] [rbp-14h]

  v2 = sub_1402A2DB0(8LL * (*a1 & 0x7FFFFFFF), 4);
  if ( *a1 >= 0 )
    return v2 / 8uLL;
  else
    return *(unsigned int *)((char *)a1 + v2 + 4);
}

// --- End Function: sub_142C0A070 (0x142C0A070) ---

// --- Function: sub_142C0AFD0 (0x142C0AFD0) ---
__int64 __fastcall sub_142C0AFD0(int *a1, __int64 **a2)
{
  __int64 v3; // [rsp+28h] [rbp-50h]
  __int64 *v4; // [rsp+38h] [rbp-40h]
  __int64 v5; // [rsp+48h] [rbp-30h]
  _QWORD *v6; // [rsp+50h] [rbp-28h]
  __int64 v7; // [rsp+58h] [rbp-20h]

  v4 = *a2;
  v3 = *(_QWORD *)a1;
  v5 = *(_QWORD *)a1 + 8LL * a1[2];
  while ( v3 != v5 )
  {
    v6 = (_QWORD *)sub_1402A2B80(8, v3);
    v7 = *v4++;
    *v6 = v7;
    v3 += 8;
  }
  return *(_QWORD *)a1;
}

// --- End Function: sub_142C0AFD0 (0x142C0AFD0) ---

// --- Function: sub_142C0DBC0 (0x142C0DBC0) ---
__int64 __fastcall sub_142C0DBC0(_DWORD *a1, int a2, int a3)
{
  int v4; // [rsp+24h] [rbp-14h]

  *a1 = a2;
  v4 = sub_1402A2DB0(8LL * a2, 4);
  if ( 8LL * a3 >= (unsigned __int64)(v4 + 4LL) )
  {
    *a1 |= 0x80000000;
    *(_DWORD *)((char *)a1 + v4 + 4) = a3;
  }
  return 0;
}

// --- End Function: sub_142C0DBC0 (0x142C0DBC0) ---

// --- Function: sub_142C19E60 (0x142C19E60) ---
__int64 __fastcall sub_142C19E60(__int64 a1)
{
  __int64 result; // rax

  memset((void *)sub_1402A2B80(8, *(_QWORD *)(a1 + 8)), 0, 8u);
  result = *(_QWORD *)(a1 + 8) + 8LL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_142C19E60 (0x142C19E60) ---

// --- Function: sub_142C23A90 (0x142C23A90) ---
char *__fastcall sub_142C23A90(char *buf, __int64 a2, __int64 a3)
{
  char *buf_1; // [rsp+30h] [rbp-28h] BYREF
  char *buf_2; // [rsp+38h] [rbp-20h]
  __int64 v6; // [rsp+40h] [rbp-18h]

  if ( AK::WriteBytesCount::Reserve((AK::WriteBytesCount *)buf) )
  {
    buf_1 = buf;
    buf_2 = buf;
    v6 = a3;
    while ( a2 )
    {
      sub_142C19E60((__int64)&buf_1);
      --a2;
    }
    return buf_2;
  }
  else
  {
    sub_1428CE360(buf, (__int64)&buf[8 * a2]);
    return &buf[8 * a2];
  }
}

// --- End Function: sub_142C23A90 (0x142C23A90) ---

// --- Function: ??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z_w (0x142E98210) ---
int *__fastcall sub_142E98210(char *_First, __int64 a2, int *_Dest)
{
  return std::_Copy_memmove<int *,int *>(_First, &_First[8 * a2], _Dest);
}

// --- End Function: ??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z_w (0x142E98210) ---

// --- Function: sub_1432A7540 (0x1432A7540) ---
Parameter *__fastcall sub_1432A7540(Parameter *Parameter_1)
{
  engine_module_noop_callback((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_1432A7540 (0x1432A7540) ---

// --- Function: sub_1438FCE40 (0x1438FCE40) ---
unsigned __int64 __fastcall sub_1438FCE40(unsigned __int64 *a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v2; // [rsp+8h] [rbp-30h]
  unsigned __int64 v3; // [rsp+28h] [rbp-10h]

  v2 = *a1 + 8LL * *((int *)a1 + 2);
  do
  {
    v3 = v2;
    v2 -= 8LL;
    result = *a1;
  }
  while ( v3 > *a1 );
  return result;
}

// --- End Function: sub_1438FCE40 (0x1438FCE40) ---

// --- Function: sub_1438FD140 (0x1438FD140) ---
_QWORD *__fastcall sub_1438FD140(_QWORD *a1, _QWORD *a2, __int64 *a3)
{
  unsigned int v3; // eax
  __int64 v4; // r8
  _QWORD *v6; // [rsp+28h] [rbp-40h]
  unsigned __int64 v7; // [rsp+40h] [rbp-28h]
  __int64 v8; // [rsp+48h] [rbp-20h]
  __int64 v9[3]; // [rsp+50h] [rbp-18h] BYREF

  v6 = a2;
  v7 = *a1 + 8LL * (*(_DWORD *)(*a1 - 4LL) & 0x7FFFFFFF);
  while ( (unsigned __int64)a3 < v7 )
  {
    v8 = *a3++;
    *v6++ = v8;
  }
  v9[0] = a3 - v6;
  v3 = sub_1403090B0((unsigned int *)v9);
  LOBYTE(v4) = 1;
  sub_1438FDFC0(a1, v3, v4);
  return a2;
}

// --- End Function: sub_1438FD140 (0x1438FD140) ---

// --- Function: sub_1438FDFC0 (0x1438FDFC0) ---
unsigned __int64 __fastcall sub_1438FDFC0(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 *v3; // rax
  int v5; // [rsp+24h] [rbp-24h]
  _BYTE v6[24]; // [rsp+30h] [rbp-18h] BYREF

  v5 = (*(_DWORD *)(*a1 - 4) & 0x7FFFFFFF) - a2;
  v3 = (unsigned __int64 *)sub_142BB4550(a1, (__int64)v6, v5);
  sub_1438FCE40(v3);
  return sub_140503E10(a1, v5, a3);
}

// --- End Function: sub_1438FDFC0 (0x1438FDFC0) ---

// --- Function: sub_1439147B0 (0x1439147B0) ---
__int64 __fastcall sub_1439147B0(AK::WriteBytesCount *a1, const void *src)
{
  if ( *((_QWORD *)a1 + 1) == *((_QWORD *)a1 + 2) )
    return sub_143914F80(a1, *((_QWORD *)a1 + 1), src);
  else
    return sub_1426F08A0(a1, src);
}

// --- End Function: sub_1439147B0 (0x1439147B0) ---

// --- Function: sub_143914F80 (0x143914F80) ---
char *__fastcall sub_143914F80(Parameter *Parameter, AK::WriteBytesCount *src_1, const void *src)
{
  char *v4; // [rsp+20h] [rbp-98h]
  __int64 v6; // [rsp+30h] [rbp-88h]
  AK::WriteBytesCount **v8; // [rsp+40h] [rbp-78h]
  unsigned __int64 v9; // [rsp+48h] [rbp-70h]
  __int64 v10; // [rsp+58h] [rbp-60h]
  unsigned __int64 v11; // [rsp+70h] [rbp-48h] BYREF
  __int64 v12; // [rsp+78h] [rbp-40h] BYREF
  __int64 v13; // [rsp+80h] [rbp-38h]
  __int64 v14; // [rsp+88h] [rbp-30h]
  void *dst; // [rsp+90h] [rbp-28h]

  v8 = (AK::WriteBytesCount **)(Parameter + 1);
  v6 = ((__int64)src_1 - *Parameter) >> 4;
  v10 = (__int64)(Parameter[1] - *Parameter) >> 4;
  v11 = unknown_libname_473() / 0x10;
  v12 = __crt_strtox::maximum_signed_value((__crt_strtox *)0x10);
  v13 = *unknown_libname_2(&v12, &v11);
  if ( v10 == v13 )
    unknown_libname_67();
  v9 = sub_142C04A60(Parameter, v10 + 1);
  v4 = (char *)sub_142C09F90((BB_ComparisonOperatorType *)Parameter, v9);
  v14 = (__int64)&v4[0x10 * v6 + 0x10];
  dst = (void *)sub_1402A2B80(0x10, (__int64)&v4[0x10 * v6]);
  qmemcpy(dst, src, 0x10u);
  if ( src_1 == *v8 )
  {
    sub_1426F3380((AK::WriteBytesCount *)*Parameter, *v8, v4);
  }
  else
  {
    sub_1426F3380((AK::WriteBytesCount *)*Parameter, src_1, v4);
    sub_1426F3380(src_1, *v8, &v4[0x10 * v6 + 0x10]);
  }
  sub_142C05020((BB_ComparisonOperatorType *)Parameter, (__int64)v4, v10 + 1, v9);
  return &v4[0x10 * v6];
}

// --- End Function: sub_143914F80 (0x143914F80) ---

// --- Function: sub_143BF0EF0 (0x143BF0EF0) ---
int *__fastcall sub_143BF0EF0(AK::WriteBytesCount *_First_1, __int64 a2, int *_Dest)
{
  char *_First; // [rsp+28h] [rbp-50h]
  int *_Dest_1; // [rsp+38h] [rbp-40h]

  _First = (char *)_First_1;
  if ( AK::WriteBytesCount::Reserve(_First_1) )
  {
    _Dest_1 = _Dest;
    while ( a2 )
    {
      *(_QWORD *)sub_1402A2B80(8, (__int64)_Dest_1) = *(_QWORD *)_First;
      _Dest_1 += 2;
      _First += 8;
      --a2;
    }
    return _Dest_1;
  }
  else
  {
    std::_Copy_memmove<int *,int *>(_First, a2, _Dest);
    return &_Dest[2 * a2];
  }
}

// --- End Function: sub_143BF0EF0 (0x143BF0EF0) ---

// --- Function: sub_144F24FA0 (0x144F24FA0) ---
__int64 __fastcall sub_144F24FA0(Parameter *Parameter_1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [rsp+20h] [rbp-28h] BYREF
  __int64 v4; // [rsp+28h] [rbp-20h] BYREF
  unsigned __int64 v5; // [rsp+30h] [rbp-18h]

  v3 = unknown_libname_473() / 8;
  v4 = __crt_strtox::maximum_signed_value((__crt_strtox *)8);
  v5 = *unknown_libname_2(&v4, &v3);
  if ( a2 > v5 )
    unknown_libname_10();
  return sub_144F25010(Parameter_1, a2);
}

// --- End Function: sub_144F24FA0 (0x144F24FA0) ---

// --- Function: sub_144F25010 (0x144F25010) ---
__int64 __fastcall sub_144F25010(__int64 *Parameter, __int64 a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  __int64 *v5; // [rsp+38h] [rbp-20h]
  __int64 *v6; // [rsp+40h] [rbp-18h]

  v5 = Parameter + 1;
  v6 = Parameter + 2;
  v2 = sub_1403E2270((__int64)Parameter, a2);
  *Parameter = v2;
  *v5 = v2;
  result = v2 + 8 * a2;
  *v6 = result;
  return result;
}

// --- End Function: sub_144F25010 (0x144F25010) ---

// --- Function: sub_145C2DA60 (0x145C2DA60) ---
_QWORD *__fastcall sub_145C2DA60(_QWORD *a1, _BYTE *dst)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_145C2E920(a1, dst);
  return a1;
}

// --- End Function: sub_145C2DA60 (0x145C2DA60) ---

// --- Function: sub_145C2E920 (0x145C2E920) ---
_QWORD *__fastcall sub_145C2E920(_QWORD *a1, _BYTE *dst)
{
  _QWORD *result; // rax
  void *dst_1; // [rsp+20h] [rbp-28h]
  void *dst_2; // [rsp+28h] [rbp-20h]

  callable_object_release_or_destroy(a1);
  dst_1 = (void *)allocWithProfilerInfo_Wrapper(0x28u);
  if ( dst_1 )
  {
    qmemcpy(dst_1, dst, 0x28u);
    dst_2 = dst_1;
  }
  else
  {
    dst_2 = 0;
  }
  a1[2] = dst_2;
  *a1 = sub_145C56030;
  result = a1;
  a1[1] = sub_145C563B0;
  return result;
}

// --- End Function: sub_145C2E920 (0x145C2E920) ---

// --- Function: sub_145C369F0 (0x145C369F0) ---
int *__fastcall sub_145C369F0(BB_ComparisonOperatorType *Parameter, _QWORD *src, unsigned __int64 a3)
{
  int *result; // rax
  char v4; // [rsp+20h] [rbp-78h]
  int *v6; // [rsp+30h] [rbp-68h]
  _QWORD *i; // [rsp+40h] [rbp-58h]
  unsigned __int64 v8; // [rsp+48h] [rbp-50h]
  void *dst; // [rsp+58h] [rbp-40h]
  BB_ComparisonOperatorType *v10; // [rsp+70h] [rbp-28h]
  __int64 v11; // [rsp+80h] [rbp-18h]

  v6 = (int *)(Parameter + 2);
  v10 = Parameter + 4;
  engine_module_noop_callback((ULONG_PTR)Parameter);
  if ( a3 <= (__int64)(*(_QWORD *)v10 - *(_QWORD *)Parameter) >> 3 )
  {
    v8 = (__int64)(*(_QWORD *)v6 - *(_QWORD *)Parameter) >> 3;
    if ( a3 <= v8 )
    {
      v11 = *(_QWORD *)Parameter + 8 * a3;
      dst = *(void **)Parameter;
      if ( AK::WriteBytesCount::Reserve((AK::WriteBytesCount *)a3) )
        qmemcpy(dst, src, 8 * a3);
      else
        std::_Copy_memmove<int *,int *>((char *)src, a3, (int *)dst);
      result = v6;
      *(_QWORD *)v6 = v11;
    }
    else
    {
      v4 = 0;
      if ( !AK::WriteBytesCount::Reserve(*(AK::WriteBytesCount **)Parameter) )
      {
        std::_Copy_memmove<int *,int *>((char *)src, v8, *(int **)Parameter);
        src += v8;
        v4 = 1;
      }
      if ( !v4 )
      {
        for ( i = *(_QWORD **)Parameter; i != *(_QWORD **)v6; ++i )
          *i = *src++;
      }
      result = sub_143BF0EF0((AK::WriteBytesCount *)src, a3 - v8, *(int **)v6);
      *(_QWORD *)v6 = result;
    }
  }
  else
  {
    sub_145CCE140((__int64 *)Parameter, a3);
    result = sub_143BF0EF0((AK::WriteBytesCount *)src, a3, *(int **)Parameter);
    *(_QWORD *)v6 = result;
  }
  return result;
}

// --- End Function: sub_145C369F0 (0x145C369F0) ---

// --- Function: sub_145C37440 (0x145C37440) ---
void __fastcall sub_145C37440(Parameter *Parameter_1, unsigned __int64 a2)
{
  char *v2; // rax
  ULONG_PTR Parameter; // [rsp+20h] [rbp-38h] BYREF
  Parameter *Parameter_4; // [rsp+28h] [rbp-30h]
  Parameter *Parameter_2; // [rsp+30h] [rbp-28h]
  void *v6; // [rsp+38h] [rbp-20h]
  Parameter *Parameter_3; // [rsp+40h] [rbp-18h]

  Parameter_3 = Parameter_1;
  v6 = &unk_1481A033C;
  Parameter_4 = Parameter_1;
  identity_passthrough((__int64)&Parameter);
  if ( a2 )
  {
    sub_144F24FA0(Parameter_1, a2);
    Parameter_2 = Parameter_1;
    v2 = sub_142C23A90(*(char **)Parameter_4, a2, (__int64)Parameter_3);
    *((_QWORD *)Parameter_4 + 1) = v2;
    Parameter_2 = 0;
  }
  engine_module_noop_callback((ULONG_PTR)&Parameter);
}

// --- End Function: sub_145C37440 (0x145C37440) ---

// --- Function: sub_145C3C990 (0x145C3C990) ---
_QWORD *__fastcall sub_145C3C990(_QWORD *a1, __int64 a2, __int64 a3, _BYTE *dst)
{
  __int64 v4; // rax

  while ( a2 != a3 )
  {
    v4 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 8) + 8LL))(*(_QWORD *)(a2 + 8));
    if ( sub_142180350((__int64)dst, v4) )
      break;
    a2 += 0x10;
  }
  *a1 = a2;
  return a1;
}

// --- End Function: sub_145C3C990 (0x145C3C990) ---

// --- Function: sub_145C3D090 (0x145C3D090) ---
unsigned __int64 __fastcall sub_145C3D090(
        __int64 a1,
        unsigned __int64 a2,
        unsigned int a3,
        unsigned int *a4,
        unsigned __int64 a5,
        unsigned __int8 a6)
{
  unsigned __int64 v7; // [rsp+38h] [rbp-C0h]
  int v8; // [rsp+40h] [rbp-B8h]
  unsigned __int64 v9; // [rsp+60h] [rbp-98h] BYREF
  _QWORD v10[6]; // [rsp+68h] [rbp-90h] BYREF
  __int64 v11; // [rsp+98h] [rbp-60h] BYREF
  unsigned __int64 v12; // [rsp+A0h] [rbp-58h] BYREF
  int v13; // [rsp+A8h] [rbp-50h]
  _QWORD src_[2]; // [rsp+B0h] [rbp-48h] BYREF
  _BYTE dst_[16]; // [rsp+C0h] [rbp-38h] BYREF
  _BYTE dst__1[40]; // [rsp+D0h] [rbp-28h] BYREF

  if ( *a4 )
  {
    v9 = 8LL * (int)*a4;
    v7 = sub_142C09E40(a1, 0, (__int64 *)&v9, a5, a6);
    v10[0] = v9 / 8;
    *a4 = sub_1403090B0((unsigned int *)v10);
  }
  else
  {
    v7 = 0;
  }
  if ( a2 )
  {
    if ( v7 )
    {
      v8 = sub_1403093B0(a3, *a4);
      v10[1] = v7;
      v10[2] = v7;
      v12 = v7;
      v13 = v8;
      v10[5] = &v12;
      v10[3] = a2;
      v10[4] = a2;
      src_[0] = a2;
      LODWORD(src_[1]) = a3;
      qmemcpy(dst_, src_, sizeof(dst_));
      qmemcpy(dst__1, dst_, 0x10u);
      sub_145CD0880(&v12, dst__1);
    }
    v11 = 0;
    sub_142C09E40(a1, a2, &v11, a5, 0);
  }
  return v7;
}

// --- End Function: sub_145C3D090 (0x145C3D090) ---

// --- Function: sub_145C3DBE0 (0x145C3DBE0) ---
__int64 *__fastcall sub_145C3DBE0(__int64 *a1, _QWORD *a2)
{
  _BYTE dst_[16]; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v4[40]; // [rsp+30h] [rbp-28h] BYREF

  *a1 = sub_140306140((__int64)&unk_149B3B404, 8);
  qmemcpy(dst_, (const void *)sub_142BB4550(a2, (__int64)v4, 0), sizeof(dst_));
  sub_145CD1190(a1, dst_);
  return a1;
}

// --- End Function: sub_145C3DBE0 (0x145C3DBE0) ---

// --- Function: sub_145C3DC50 (0x145C3DC50) ---
__int64 *__fastcall sub_145C3DC50(__int64 *a1, _QWORD *a2)
{
  _BYTE dst_[16]; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v4[40]; // [rsp+30h] [rbp-28h] BYREF

  *a1 = sub_140306140((__int64)&unk_149B3B404, 8);
  qmemcpy(dst_, (const void *)sub_142BB4550(a2, (__int64)v4, 0), sizeof(dst_));
  sub_145CD12C0(a1, dst_);
  return a1;
}

// --- End Function: sub_145C3DC50 (0x145C3DC50) ---

// --- Function: sub_145C45920 (0x145C45920) ---
BB_ComparisonOperatorType *__fastcall sub_145C45920(
        BB_ComparisonOperatorType *Parameter,
        BB_ComparisonOperatorType *Parameter_1)
{
  if ( Parameter != Parameter_1 )
    sub_145C369F0(
      Parameter,
      *(_QWORD **)Parameter_1,
      (__int64)(*((_QWORD *)Parameter_1 + 1) - *(_QWORD *)Parameter_1) >> 3);
  return Parameter;
}

// --- End Function: sub_145C45920 (0x145C45920) ---

// --- Function: sub_145C47A30 (0x145C47A30) ---
char __fastcall sub_145C47A30(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  __int64 v4; // rax
  unsigned __int8 *v5; // rax
  __int64 v6; // rcx
  unsigned __int8 v7; // dl
  unsigned int v8; // eax
  char v9; // [rsp+20h] [rbp-108h]
  __int64 v10; // [rsp+28h] [rbp-100h] BYREF
  __int64 v11; // [rsp+30h] [rbp-F8h] BYREF
  BOOL v12; // [rsp+38h] [rbp-F0h]
  __int64 *v13; // [rsp+40h] [rbp-E8h]
  __int64 v14; // [rsp+48h] [rbp-E0h]
  __int64 *v15; // [rsp+50h] [rbp-D8h]
  __int64 *v16; // [rsp+58h] [rbp-D0h]
  __int64 v17; // [rsp+60h] [rbp-C8h]
  unsigned __int64 v18; // [rsp+68h] [rbp-C0h] BYREF
  __int64 v19; // [rsp+70h] [rbp-B8h]
  __int64 v20; // [rsp+78h] [rbp-B0h]
  void (__fastcall *v21)(__int64, unsigned __int64 *); // [rsp+80h] [rbp-A8h]
  __int64 v22; // [rsp+88h] [rbp-A0h]
  __int64 *v23; // [rsp+90h] [rbp-98h]
  __int64 v24; // [rsp+98h] [rbp-90h]
  unsigned int (__fastcall *v25)(__int64, __int64, __int64 *, _QWORD); // [rsp+A0h] [rbp-88h]
  __int64 v26; // [rsp+A8h] [rbp-80h]
  unsigned __int64 v27; // [rsp+B0h] [rbp-78h]
  __int64 *v28; // [rsp+B8h] [rbp-70h]
  __int64 v29; // [rsp+C0h] [rbp-68h]
  __int64 v30; // [rsp+C8h] [rbp-60h]
  __int64 v31; // [rsp+D0h] [rbp-58h]
  _QWORD *src; // [rsp+D8h] [rbp-50h]
  AK::WriteBytesCount *v33; // [rsp+E0h] [rbp-48h]
  __int64 v34; // [rsp+E8h] [rbp-40h]
  __int64 v35; // [rsp+F0h] [rbp-38h]
  __int64 v36; // [rsp+F8h] [rbp-30h]
  _QWORD src_[2]; // [rsp+100h] [rbp-28h] BYREF
  _QWORD v38[3]; // [rsp+110h] [rbp-18h] BYREF

  v21 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)a2 + 0x68LL);
  v21(a2, &v18);
  if ( entity_descriptor_check_valid_and_accessible(&v18) )
  {
    v22 = descriptor_extract_base_address_or_id(&v18);
    v23 = sub_14033A530(v22, v38);
    v24 = *v23;
    v10 = v24;
    if ( AssetMeta::HasActorSubresource(&v10) )
    {
      v11 = sub_140306140((__int64)&unk_149B3B404, 8);
      v19 = *(_QWORD *)a1 & 0xFFFFFFFFFFFFLL;
      v25 = *(unsigned int (__fastcall **)(__int64, __int64, __int64 *, _QWORD))(*(_QWORD *)v19 + 0x5B0LL);
      v14 = v38[1];
      if ( AssetMeta::HasActorSubresource(&v10) )
        v14 = v10 & 0xFFFFFFFFFFFFLL;
      else
        v14 = 0;
      if ( !v25(v19, v14, &v11, 0) )
      {
        **(_BYTE **)(a1 + 0x20) = 0;
        sub_1404619D0((unsigned __int64 *)&v11);
        return 1;
      }
      v9 = 0;
      v20 = v10 & 0xFFFFFFFFFFFFLL;
      v16 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v10 & 0xFFFFFFFFFFFFLL) + 0x608LL))(v10 & 0xFFFFFFFFFFFFLL);
      if ( v16 )
      {
        v15 = &v11;
        v13 = (__int64 *)v11;
        v27 = v11;
        v26 = v11 - 4;
        v28 = (__int64 *)(v11 + 8LL * (*(_DWORD *)(v11 - 4) & 0x7FFFFFFF));
        while ( v13 != v28 )
        {
          v17 = *v13;
          v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x18LL))(v17);
          v30 = sub_1402A2660(v3);
          v29 = *v16;
          v4 = (*(__int64 (__fastcall **)(__int64 *))(v29 + 0x18))(v16);
          v5 = (unsigned __int8 *)sub_1402A2660(v4);
          v6 = v30 - (_QWORD)v5;
          while ( 1 )
          {
            v7 = *v5;
            if ( *v5 != v5[v6] )
              break;
            ++v5;
            if ( !v7 )
            {
              v8 = 0;
              goto LABEL_16;
            }
          }
          v8 = v7 < v5[v6] ? 0xFFFFFFFF : 1;
LABEL_16:
          if ( !v8 )
          {
            v9 = 1;
            v33 = *(AK::WriteBytesCount **)(a1 + 8);
            v31 = v10;
            src_[0] = v10;
            src_[1] = v17;
            src = src_;
            sub_1439147B0(v33, src_);
            break;
          }
          ++v13;
        }
      }
      v34 = v11 - 4;
      v12 = (*(_DWORD *)(v11 - 4) & 0x7FFFFFFF) == 0;
      if ( !v12 && !v9 )
      {
        v35 = *(_QWORD *)(a1 + 0x10);
        sub_1402A6620(v35, &v10);
        v36 = *(_QWORD *)(a1 + 0x18);
        sub_145CD1250(v36, &v11);
      }
      sub_1404619D0((unsigned __int64 *)&v11);
    }
  }
  return 1;
}

// --- End Function: sub_145C47A30 (0x145C47A30) ---

// --- Function: sub_145C56030 (0x145C56030) ---
char __fastcall sub_145C56030(__int64 a1, __int64 a2)
{
  return sub_145C47A30(*(_QWORD *)(a1 + 0x10), a2);
}

// --- End Function: sub_145C56030 (0x145C56030) ---

// --- Function: sub_145C563B0 (0x145C563B0) ---
_QWORD *__fastcall sub_145C563B0(int n2, __int64 a2, _QWORD *a3)
{
  _QWORD *result; // rax
  void *dst; // [rsp+50h] [rbp-48h]
  void *dst_1; // [rsp+58h] [rbp-40h]
  const void *src; // [rsp+60h] [rbp-38h]

  if ( n2 )
  {
    if ( n2 == 1 )
    {
      result = a3;
      if ( *a3 )
      {
        if ( a3[1] == 1 )
        {
          *(_QWORD *)(a2 + 0x10) = 0;
          *(_QWORD *)a2 = *a3;
          *(_QWORD *)(a2 + 8) = 1;
        }
        else
        {
          *(_QWORD *)(a2 + 0x10) = a3[2];
          *(_QWORD *)a2 = *a3;
          *(_QWORD *)(a2 + 8) = a3[1];
        }
        a3[2] = 0;
        *a3 = 0;
        result = a3;
        a3[1] = 0;
      }
    }
    else if ( n2 == 2 )
    {
      memory_deallocate_wrapper(*(const void **)(a2 + 0x10));
      *(_QWORD *)(a2 + 0x10) = 0;
      *(_QWORD *)a2 = 0;
      result = (_QWORD *)a2;
      *(_QWORD *)(a2 + 8) = 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    src = (const void *)a3[2];
    result = a3;
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        *(_QWORD *)(a2 + 0x10) = 0;
        *(_QWORD *)a2 = *a3;
        result = (_QWORD *)a2;
        *(_QWORD *)(a2 + 8) = 1;
      }
      else
      {
        dst = (void *)allocWithProfilerInfo_Wrapper(0x28u);
        if ( dst )
        {
          qmemcpy(dst, src, 0x28u);
          dst_1 = dst;
        }
        else
        {
          dst_1 = 0;
        }
        *(_QWORD *)(a2 + 0x10) = dst_1;
        *(_QWORD *)a2 = sub_145C56030;
        result = (_QWORD *)a2;
        *(_QWORD *)(a2 + 8) = sub_145C563B0;
      }
    }
  }
  return result;
}

// --- End Function: sub_145C563B0 (0x145C563B0) ---

// --- Function: sub_145C69BF0 (0x145C69BF0) ---
__int64 __fastcall sub_145C69BF0(__int64 a1, __int64 a2, __int64 *Parameter)
{
  __int64 v3; // rax
  __int64 *v4; // rax
  __int64 v6; // rax
  char v7; // [rsp+20h] [rbp-2A8h]
  char v8; // [rsp+21h] [rbp-2A7h] BYREF
  unsigned __int8 v9; // [rsp+22h] [rbp-2A6h]
  unsigned __int8 v10; // [rsp+23h] [rbp-2A5h]
  __int64 **v11; // [rsp+28h] [rbp-2A0h]
  __int64 v12; // [rsp+30h] [rbp-298h] BYREF
  char v13; // [rsp+38h] [rbp-290h]
  char v14; // [rsp+39h] [rbp-28Fh]
  char v15; // [rsp+3Ah] [rbp-28Eh]
  __int64 **v16; // [rsp+40h] [rbp-288h] BYREF
  BOOL v17; // [rsp+48h] [rbp-280h]
  BOOL v19; // [rsp+50h] [rbp-278h]
  unsigned __int64 i; // [rsp+58h] [rbp-270h]
  __int64 v21; // [rsp+60h] [rbp-268h]
  __int64 *v22; // [rsp+68h] [rbp-260h]
  __int64 v23; // [rsp+70h] [rbp-258h]
  Parameter *Parameter_1; // [rsp+78h] [rbp-250h]
  Parameter *Parameter_3; // [rsp+80h] [rbp-248h]
  Parameter *Parameter_4; // [rsp+88h] [rbp-240h]
  __int64 *v27; // [rsp+90h] [rbp-238h]
  Parameter *Parameter_6; // [rsp+98h] [rbp-230h]
  __int64 *v29; // [rsp+A0h] [rbp-228h]
  void (__fastcall *v30)(__int64, _QWORD, _QWORD *); // [rsp+A8h] [rbp-220h]
  __int64 v31; // [rsp+B0h] [rbp-218h]
  __int64 v32; // [rsp+B8h] [rbp-210h]
  __int64 v33; // [rsp+C0h] [rbp-208h]
  __int64 v34; // [rsp+C8h] [rbp-200h]
  __int64 v35; // [rsp+D0h] [rbp-1F8h]
  const void *src; // [rsp+D8h] [rbp-1F0h]
  Parameter *Parameter_2; // [rsp+E0h] [rbp-1E8h]
  __int64 v38; // [rsp+E8h] [rbp-1E0h]
  _QWORD Parameter__1[3]; // [rsp+F0h] [rbp-1D8h] BYREF
  __int64 v40; // [rsp+108h] [rbp-1C0h]
  _QWORD Parameter__2[2]; // [rsp+110h] [rbp-1B8h] BYREF
  __int64 v42; // [rsp+120h] [rbp-1A8h]
  __int64 v43; // [rsp+128h] [rbp-1A0h]
  Parameter *Parameter_5; // [rsp+130h] [rbp-198h]
  __int64 v45; // [rsp+138h] [rbp-190h]
  __int64 Parameter__3; // [rsp+140h] [rbp-188h] BYREF
  _QWORD v47[3]; // [rsp+148h] [rbp-180h] BYREF
  __int64 v48; // [rsp+160h] [rbp-168h]
  __int64 *v49; // [rsp+168h] [rbp-160h]
  Parameter *Parameter_7; // [rsp+170h] [rbp-158h]
  __int64 v51; // [rsp+178h] [rbp-150h]
  __int64 v52; // [rsp+180h] [rbp-148h]
  __int64 v53; // [rsp+188h] [rbp-140h] BYREF
  __int64 v54; // [rsp+190h] [rbp-138h]
  __int64 Parameter_; // [rsp+1A0h] [rbp-128h] BYREF
  __int64 v56; // [rsp+1A8h] [rbp-120h]
  _QWORD v57[2]; // [rsp+1B8h] [rbp-110h] BYREF
  _QWORD src_[5]; // [rsp+1C8h] [rbp-100h] BYREF
  _BYTE dst__1[16]; // [rsp+1F0h] [rbp-D8h] BYREF
  _BYTE dst__2[16]; // [rsp+200h] [rbp-C8h] BYREF
  _BYTE dst__3[16]; // [rsp+210h] [rbp-B8h] BYREF
  _BYTE dst__4[16]; // [rsp+220h] [rbp-A8h] BYREF
  _BYTE v63[8]; // [rsp+230h] [rbp-98h] BYREF
  _QWORD v64[3]; // [rsp+238h] [rbp-90h] BYREF
  _BYTE dst_[40]; // [rsp+250h] [rbp-78h] BYREF
  _BYTE dst[72]; // [rsp+280h] [rbp-48h] BYREF

  v8 = 1;
  bb_comparison_operator_type_destroy((BB_ComparisonOperatorType *)&Parameter_);
  v12 = sub_140306140((__int64)&unk_149B3B404, 8);
  v23 = a1 & 0xFFFFFFFFFFFFLL;
  v30 = *(void (__fastcall **)(__int64, _QWORD, _QWORD *))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x630LL);
  src_[0] = a2;
  src_[1] = Parameter;
  src_[2] = &Parameter_;
  src_[3] = &v12;
  src_[4] = &v8;
  qmemcpy(dst_, src_, sizeof(dst_));
  qmemcpy(dst, dst_, 0x28u);
  sub_145C2DA60(v64, dst);
  v30(v23, 0, v64);
  callable_object_release_or_destroy(v64);
  v13 = 0;
  v31 = v12 - 4;
  if ( (*(_DWORD *)(v12 - 4) & 0x7FFFFFFF) != 0 )
  {
    v22 = &v12;
    v21 = v12;
    v33 = v12;
    v14 = 0;
    v32 = v12 - 4;
    v34 = v12 + 8LL * (*(_DWORD *)(v12 - 4) & 0x7FFFFFFF);
    while ( v21 != v34 )
    {
      sub_145C3DBE0(&v16, v21);
      v11 = v16;
      while ( 1 )
      {
        v3 = sub_140332FA0(&v16);
        if ( v11 == (__int64 **)v3 )
          break;
        v4 = *v11;
        v35 = **v11;
        src = (const void *)(*(__int64 (__fastcall **)(__int64 *))(v35 + 8))(v4);
        qmemcpy(dst__1, src, sizeof(dst__1));
        qmemcpy(dst__2, dst__1, sizeof(dst__2));
        qmemcpy(dst__3, dst__2, sizeof(dst__3));
        Parameter_1 = Parameter;
        Parameter_2 = Parameter;
        v38 = Parameter[1];
        std__Tree_unchecked_const_iterator_ctor((Parameter *)Parameter__1, v38);
        Parameter__1[1] = Parameter__1[0];
        v42 = Parameter__1[0];
        Parameter_3 = Parameter;
        Parameter__1[2] = Parameter;
        v40 = *Parameter;
        std__Tree_unchecked_const_iterator_ctor((Parameter *)Parameter__2, v40);
        Parameter__2[1] = Parameter__2[0];
        v43 = Parameter__2[0];
        qmemcpy(dst__4, dst__3, sizeof(dst__4));
        sub_145C3C990(v47, Parameter__2[0], v42, dst__4);
        Parameter_4 = Parameter;
        Parameter_5 = Parameter;
        v45 = Parameter[1];
        std__Tree_unchecked_const_iterator_ctor((Parameter *)&Parameter__3, v45);
        v17 = v47[0] == Parameter__3;
        if ( v47[0] == Parameter__3 )
          ++v11;
        else
          v11 = (__int64 **)sub_1438FD140(&v16, v11, v11 + 1);
      }
      v15 = 0;
      v47[1] = (char *)v16 + 0xFFFFFFFC;
      if ( (*((_DWORD *)v16 + 0xFFFFFFFF) & 0x7FFFFFFF) == 0 )
      {
        v9 = 0;
        sub_1404619D0(&v16);
        sub_145CCFE00(&v12);
        sub_145CD1750(&v12, 0, 0);
        sub_1428BF6D0(&Parameter_);
        return v9;
      }
      sub_1404619D0(&v16);
      v21 += 8;
    }
    unknown_libname_472(&v53);
    v47[2] = v63;
    v6 = sub_145C3DC50(v63, &v12);
    v7 = sub_145C6A720(v6, &v53);
    if ( v7 )
    {
      v27 = &v53;
      v48 = (v54 - v53) >> 3;
      Parameter_6 = &Parameter_;
      v19 = v48 == (v56 - Parameter_) >> 3;
      v7 = v48 == (v56 - Parameter_) >> 3;
      if ( v48 == (v56 - Parameter_) >> 3 )
      {
        for ( i = 0; ; ++i )
        {
          v29 = &v53;
          if ( i >= (v54 - v53) >> 3 )
            break;
          v49 = &v53;
          v52 = *(_QWORD *)(v53 + 8 * i);
          Parameter_7 = &Parameter_;
          v51 = *(_QWORD *)(Parameter_ + 8 * i);
          v57[0] = v51;
          v57[1] = v52;
          sub_1439147B0(Parameter, v57);
        }
      }
    }
    v8 &= v7;
    sub_1402B2810((__int64)&v53);
  }
  v10 = v8;
  sub_145CCFE00(&v12);
  sub_145CD1750(&v12, 0, 0);
  sub_1428BF6D0(&Parameter_);
  return v10;
}

// --- End Function: sub_145C69BF0 (0x145C69BF0) ---

// --- Function: sub_145C6A330 (0x145C6A330) ---
__int64 __fastcall sub_145C6A330(__int64 *dst, __int128 *p_dst, Parameter *Parameter, Parameter *Parameter_1)
{
  __int64 v4; // rax
  __int64 v5; // rax
  unsigned __int8 v7; // [rsp+20h] [rbp-118h]
  unsigned __int8 v8; // [rsp+28h] [rbp-110h]
  __int64 v9; // [rsp+30h] [rbp-108h]
  __int64 v10; // [rsp+38h] [rbp-100h]
  unsigned __int64 v11; // [rsp+40h] [rbp-F8h] BYREF
  unsigned __int64 v12; // [rsp+48h] [rbp-F0h] BYREF
  __int64 v13; // [rsp+50h] [rbp-E8h] BYREF
  __int64 v14; // [rsp+58h] [rbp-E0h] BYREF
  __int64 v15[2]; // [rsp+60h] [rbp-D8h] BYREF
  __int64 v16[2]; // [rsp+70h] [rbp-C8h] BYREF
  __int64 v17; // [rsp+80h] [rbp-B8h]
  __int64 v18; // [rsp+88h] [rbp-B0h]
  __int64 v19; // [rsp+90h] [rbp-A8h]
  __int64 *v20; // [rsp+98h] [rbp-A0h]
  __int64 v21; // [rsp+A0h] [rbp-98h]
  __int64 dst_1; // [rsp+A8h] [rbp-90h]
  __int64 *v23; // [rsp+B0h] [rbp-88h]
  __int64 v24; // [rsp+B8h] [rbp-80h]
  __int64 (__fastcall *v25)(__int64, __int64 *); // [rsp+C0h] [rbp-78h]
  __int64 (__fastcall *v26)(__int64, __int128 *); // [rsp+C8h] [rbp-70h]
  void (__fastcall *v27)(__int64, unsigned __int64 *); // [rsp+D0h] [rbp-68h]
  void (__fastcall *v28)(__int64, unsigned __int64 *); // [rsp+D8h] [rbp-60h]
  __int64 v29; // [rsp+E0h] [rbp-58h]
  __int64 *v30; // [rsp+E8h] [rbp-50h]
  __int64 v31; // [rsp+F0h] [rbp-48h]
  __int64 v32; // [rsp+F8h] [rbp-40h]
  __int64 *v33; // [rsp+100h] [rbp-38h]
  __int64 v34; // [rsp+108h] [rbp-30h]
  __int64 v35; // [rsp+110h] [rbp-28h] BYREF
  __int64 v36; // [rsp+118h] [rbp-20h] BYREF
  __int64 v37; // [rsp+120h] [rbp-18h] BYREF
  __int64 v38; // [rsp+128h] [rbp-10h] BYREF

  v7 = 1;
  if ( sub_142180390((__int64)dst, (__int64)&unk_148B27670) && sub_142180390((__int64)p_dst, (__int64)&unk_148B27670) )
  {
    v19 = *dst;
    v20 = sub_1412A4310(&v35);
    v21 = *v20;
    v15[0] = v21;
    dst_1 = *(_QWORD *)p_dst;
    v23 = sub_1412A4310(&v36);
    v24 = *v23;
    v16[0] = v24;
    if ( AssetMeta::HasActorSubresource(v15) && AssetMeta::HasActorSubresource(v16) )
    {
      v15[1] = v15[0] & 0xFFFFFFFFFFFFLL;
      v25 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(v15[0] & 0xFFFFFFFFFFFFLL) + 0x590LL);
      v9 = v25(v15[0] & 0xFFFFFFFFFFFFLL, dst);
      v16[1] = v16[0] & 0xFFFFFFFFFFFFLL;
      v26 = *(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)(v16[0] & 0xFFFFFFFFFFFFLL) + 0x590LL);
      v10 = v26(v16[0] & 0xFFFFFFFFFFFFLL, p_dst);
      if ( v9 )
      {
        if ( v10 )
        {
          v27 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v9 + 0x68LL);
          v27(v9, &v11);
          v28 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v10 + 0x68LL);
          v28(v10, &v12);
          if ( entity_descriptor_check_valid_and_accessible(&v11) && entity_descriptor_check_valid_and_accessible(&v12) )
          {
            v17 = descriptor_extract_base_address_or_id(&v11);
            v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x20LL))(v17);
            if ( sub_145C8D760(v4) )
            {
              v18 = descriptor_extract_base_address_or_id(&v12);
              v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x20LL))(v18);
              if ( sub_145C8D760(v5) )
              {
                v29 = descriptor_extract_base_address_or_id(&v11);
                v30 = sub_14033AB40(v29, &v37);
                v31 = *v30;
                v13 = v31;
                v32 = descriptor_extract_base_address_or_id(&v12);
                v33 = sub_14033AB40(v32, &v38);
                v34 = *v33;
                v14 = v34;
                if ( AssetMeta::HasActorSubresource(&v13) && AssetMeta::HasActorSubresource(&v14) )
                {
                  v8 = sub_145C69BF0(v13, v14, (__int64 *)Parameter) & 1;
                  return sub_145C69BF0(v14, v13, (__int64 *)Parameter_1) & v8;
                }
              }
            }
          }
        }
      }
    }
  }
  return v7;
}

// --- End Function: sub_145C6A330 (0x145C6A330) ---

// --- Function: sub_145C6A720 (0x145C6A720) ---
__int64 __fastcall sub_145C6A720(__int64 *a1, Parameter *Parameter_5)
{
  int v3; // [rsp+20h] [rbp-208h]
  unsigned __int8 v4; // [rsp+24h] [rbp-204h]
  char v5; // [rsp+25h] [rbp-203h]
  int i; // [rsp+28h] [rbp-200h]
  int v7; // [rsp+30h] [rbp-1F8h]
  _BYTE v8[11]; // [rsp+35h] [rbp-1F3h] BYREF
  int v9; // [rsp+40h] [rbp-1E8h]
  Parameter *Parameter_7; // [rsp+48h] [rbp-1E0h]
  const __m128i *v12; // [rsp+50h] [rbp-1D8h]
  ULONG_PTR v13; // [rsp+58h] [rbp-1D0h]
  __int64 v14; // [rsp+60h] [rbp-1C8h] BYREF
  Parameter *Parameter_6; // [rsp+68h] [rbp-1C0h]
  void *v16; // [rsp+70h] [rbp-1B8h]
  __int64 *v17; // [rsp+78h] [rbp-1B0h]
  Parameter *Parameter_1; // [rsp+80h] [rbp-1A8h]
  ULONG_PTR Parameter[2]; // [rsp+88h] [rbp-1A0h] BYREF
  ULONG_PTR Parameter__1[2]; // [rsp+98h] [rbp-190h] BYREF
  __int64 *v21; // [rsp+A8h] [rbp-180h]
  const struct __crt_stdio_stream *Parameter_[5]; // [rsp+B0h] [rbp-178h] BYREF
  _DWORD *v23; // [rsp+D8h] [rbp-150h]
  __int64 v24; // [rsp+E0h] [rbp-148h]
  _DWORD *v25; // [rsp+E8h] [rbp-140h]
  _DWORD *v26; // [rsp+F0h] [rbp-138h]
  __int64 v27; // [rsp+F8h] [rbp-130h]
  _DWORD *v28; // [rsp+100h] [rbp-128h]
  __int64 v29; // [rsp+108h] [rbp-120h]
  const struct __crt_stdio_stream *v30; // [rsp+110h] [rbp-118h]
  Parameter *Parameter_2; // [rsp+118h] [rbp-110h]
  Parameter **p_Parameter; // [rsp+120h] [rbp-108h]
  const __m128i *v33; // [rsp+128h] [rbp-100h]
  const struct __crt_stdio_stream *v34; // [rsp+130h] [rbp-F8h]
  Parameter *Parameter_3; // [rsp+138h] [rbp-F0h]
  ULONG_PTR v36; // [rsp+140h] [rbp-E8h]
  const __m128i *v37; // [rsp+148h] [rbp-E0h]
  ULONG_PTR v38; // [rsp+150h] [rbp-D8h]
  const __m128i *v39; // [rsp+158h] [rbp-D0h]
  unsigned __int64 *v40; // [rsp+160h] [rbp-C8h]
  const __m128i *v41; // [rsp+168h] [rbp-C0h]
  ULONG_PTR v42; // [rsp+170h] [rbp-B8h]
  const __m128i *v43; // [rsp+178h] [rbp-B0h]
  const __m128i *v44; // [rsp+180h] [rbp-A8h]
  _QWORD v45[3]; // [rsp+188h] [rbp-A0h] BYREF
  _QWORD v46[2]; // [rsp+1A0h] [rbp-88h] BYREF
  _QWORD *v47; // [rsp+1B0h] [rbp-78h]
  __int64 *v48; // [rsp+1B8h] [rbp-70h]
  _QWORD *v49; // [rsp+1C0h] [rbp-68h]
  _DWORD *v50; // [rsp+1C8h] [rbp-60h]
  __int64 v51; // [rsp+1D0h] [rbp-58h]
  _DWORD *v52; // [rsp+1D8h] [rbp-50h]
  __int64 v53; // [rsp+1E0h] [rbp-48h]
  Parameter *Parameter_4; // [rsp+1E8h] [rbp-40h]
  __int64 v55; // [rsp+1F0h] [rbp-38h]
  _QWORD *v56; // [rsp+1F8h] [rbp-30h]
  _DWORD *v57; // [rsp+200h] [rbp-28h]
  _QWORD v58[4]; // [rsp+208h] [rbp-20h] BYREF

  v57 = (_DWORD *)(*a1 - 4);
  v7 = *v57 & 0x7FFFFFFF;
  if ( v7 )
  {
    Parameter_[3] = (const struct __crt_stdio_stream *)identity_passthrough((__int64)v8);
    Parameter_6 = Parameter_;
    sub_1432A7540((Parameter *)Parameter_);
    Parameter_7 = Parameter_6;
    *Parameter_6 = 0;
    Parameter_7[1] = 0;
    Parameter_7[2] = 0;
    sub_145C37440((Parameter *)Parameter_, v7);
    Parameter_[4] = (const struct __crt_stdio_stream *)identity_passthrough((__int64)&v8[1]);
    v16 = v58;
    identity_passthrough((__int64)v58);
    unknown_libname_472(v16);
    sub_14042E600(v58, v7);
    v3 = 0;
    v9 = 0;
    v4 = 0;
    while ( !v4 )
    {
      v5 = 0;
      for ( i = v9; ; ++i )
      {
        v8[2] = 0;
        v23 = (_DWORD *)(*a1 - 4);
        if ( v3 >= (*v23 & 0x7FFFFFFF) )
          __debugbreak();
        v24 = *a1;
        v8[3] = 0;
        v25 = (_DWORD *)(*(_QWORD *)(v24 + 8LL * v3) - 4LL);
        if ( i >= (*v25 & 0x7FFFFFFF) )
          break;
        v8[4] = 0;
        v26 = (_DWORD *)(*a1 - 4);
        if ( v3 >= (*v26 & 0x7FFFFFFF) )
          __debugbreak();
        v27 = *a1;
        v17 = (__int64 *)(v27 + 8LL * v3);
        v8[5] = 0;
        v28 = (_DWORD *)(*v17 - 4);
        if ( i >= (*v28 & 0x7FFFFFFF) )
          __debugbreak();
        v29 = *v17;
        v40 = (unsigned __int64 *)(v29 + 8LL * i);
        Parameter_1 = Parameter_;
        Parameter_2 = Parameter_;
        v30 = Parameter_[0];
        Parameter[0] = (ULONG_PTR)Parameter_[0];
        engine_module_noop_callback((ULONG_PTR)Parameter);
        p_Parameter = Parameter;
        v12 = (const __m128i *)(Parameter[0] + 8LL * v3);
        v33 = v12;
        v37 = v12;
        Parameter[1] = (ULONG_PTR)Parameter_;
        Parameter_3 = Parameter_;
        v34 = Parameter_[0];
        Parameter__1[0] = (ULONG_PTR)Parameter_[0];
        engine_module_noop_callback((ULONG_PTR)Parameter__1);
        v36 = Parameter__1[0];
        v38 = Parameter__1[0];
        v39 = v37;
        v13 = Parameter__1[0];
        v41 = v37;
        v42 = Parameter__1[0];
        v43 = unknown_libname_248_w((const __m128i *)Parameter__1[0], v37, v40);
        v44 = v43;
        v13 = (ULONG_PTR)v43;
        v45[0] = v43;
        v47 = v45;
        Parameter__1[1] = (ULONG_PTR)Parameter_;
        v45[1] = Parameter_;
        v45[2] = Parameter_[0];
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
          (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v46,
          Parameter_[0]);
        v46[1] = v46;
        v14 = v46[0] + 8LL * v3;
        v48 = &v14;
        if ( *v47 == v14 )
        {
          v49 = v58;
          *(_DWORD *)(v58[0] + 4LL * v3) = i;
          v8[6] = 0;
          v50 = (_DWORD *)(*a1 - 4);
          if ( v3 >= (*v50 & 0x7FFFFFFF) )
            __debugbreak();
          v51 = *a1;
          v21 = (__int64 *)(v51 + 8LL * v3);
          v8[7] = 0;
          v52 = (_DWORD *)(*v21 - 4);
          if ( i >= (*v52 & 0x7FFFFFFF) )
            __debugbreak();
          v53 = *v21;
          v55 = *(_QWORD *)(v53 + 8LL * i);
          Parameter_4 = Parameter_;
          *((_QWORD *)Parameter_[0] + v3) = v55;
          v5 = 1;
          break;
        }
      }
      if ( v5 )
      {
        ++v3;
        v9 = 0;
      }
      else
      {
        if ( --v3 < 0 )
        {
          sub_1403719A0((__int64)v58);
          sub_1402B2810((__int64)Parameter_);
          sub_145CCFE00(a1);
          sub_145CD1750(a1, 0, 0);
          return 0;
        }
        v56 = v58;
        v9 = *(_DWORD *)(v58[0] + 4LL * v3) + 1;
      }
      if ( v3 == v7 )
      {
        sub_145C45920(Parameter_5, (BB_ComparisonOperatorType *)Parameter_);
        v4 = 1;
      }
    }
    sub_1403719A0((__int64)v58);
    sub_1402B2810((__int64)Parameter_);
    sub_145CCFE00(a1);
    sub_145CD1750(a1, 0, 0);
    return v4;
  }
  else
  {
    sub_145CCFE00(a1);
    sub_145CD1750(a1, 0, 0);
    return 1;
  }
}

// --- End Function: sub_145C6A720 (0x145C6A720) ---

// --- Function: sub_145CCE140 (0x145CCE140) ---
__int64 __fastcall sub_145CCE140(__int64 *Parameter, unsigned __int64 a2)
{
  __int64 *v4; // [rsp+30h] [rbp-48h]
  unsigned __int64 v5; // [rsp+38h] [rbp-40h] BYREF
  __int64 v6; // [rsp+40h] [rbp-38h] BYREF
  unsigned __int64 v7; // [rsp+48h] [rbp-30h]
  Parameter *Parameter_1; // [rsp+50h] [rbp-28h]
  __int64 *v9; // [rsp+58h] [rbp-20h]
  __int64 v10; // [rsp+60h] [rbp-18h]

  Parameter_1 = Parameter;
  v9 = Parameter + 1;
  v4 = Parameter + 2;
  v5 = unknown_libname_473() / 8;
  v6 = __crt_strtox::maximum_signed_value((__crt_strtox *)8);
  v7 = *unknown_libname_2(&v6, &v5);
  if ( a2 > v7 )
    unknown_libname_10();
  v10 = sub_1403DE890(Parameter, a2);
  if ( *Parameter )
  {
    sub_1403E4CD0((__int64)Parameter_1, (const void *)*Parameter, (*v4 - *Parameter) >> 3);
    *Parameter = 0;
    *v9 = 0;
    *v4 = 0;
  }
  return sub_144F25010(Parameter, v10);
}

// --- End Function: sub_145CCE140 (0x145CCE140) ---

// --- Function: sub_145CCFE00 (0x145CCFE00) ---
__int64 __fastcall sub_145CCFE00(__int64 *a1)
{
  __int64 result; // rax
  unsigned __int64 *Parameter; // [rsp+28h] [rbp-40h]
  Parameter *Parameter_1; // [rsp+50h] [rbp-18h]

  for ( Parameter = (unsigned __int64 *)(*a1 + 8LL * (*(_DWORD *)(*a1 - 4) & 0x7FFFFFFF)); ; sub_140503E10(
                                                                                               Parameter,
                                                                                               0,
                                                                                               0) )
  {
    Parameter_1 = Parameter;
    Parameter += 0xFFFFFFFF;
    result = *a1;
    if ( (unsigned __int64)Parameter_1 <= *a1 )
      break;
    engine_module_noop_callback((ULONG_PTR)Parameter);
  }
  return result;
}

// --- End Function: sub_145CCFE00 (0x145CCFE00) ---

// --- Function: sub_145CCFEC0 (0x145CCFEC0) ---
unsigned __int64 __fastcall sub_145CCFEC0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 j; // [rsp+20h] [rbp-18h]
  unsigned __int64 i; // [rsp+28h] [rbp-10h]

  if ( a2 <= a1 && a2 + 8 * a3 > a1 )
  {
    for ( i = 0; ; ++i )
    {
      result = a3;
      if ( i >= a3 )
        break;
      sub_145C3CDD0(a1 + 8 * (a3 - i) - 8, a2 + 8 * (a3 - i) - 8);
    }
  }
  else
  {
    for ( j = 0; ; ++j )
    {
      result = a3;
      if ( j >= a3 )
        break;
      sub_145C3CDD0(a1 + 8 * j, a2 + 8 * j);
    }
  }
  return result;
}

// --- End Function: sub_145CCFEC0 (0x145CCFEC0) ---

// --- Function: sub_145CD0640 (0x145CD0640) ---
__int64 __fastcall sub_145CD0640(_QWORD *a1, int a2, unsigned __int8 a3)
{
  sub_145CD1750(a1, a2 + (*(_DWORD *)(*a1 - 4LL) & 0x7FFFFFFFu), a3);
  return *a1 + 8LL * (*(_DWORD *)(*a1 - 4LL) & 0x7FFFFFFF) - 8LL * a2;
}

// --- End Function: sub_145CD0640 (0x145CD0640) ---

// --- Function: sub_145CD0790 (0x145CD0790) ---
__int64 __fastcall sub_145CD0790(int *a1, _QWORD *a2)
{
  __int64 v3; // [rsp+28h] [rbp-50h]
  _QWORD *v4; // [rsp+38h] [rbp-40h]
  __int64 v5; // [rsp+48h] [rbp-30h]
  _QWORD *v6; // [rsp+50h] [rbp-28h]
  __int64 *v7; // [rsp+58h] [rbp-20h]

  v4 = (_QWORD *)*a2;
  v3 = *(_QWORD *)a1;
  v5 = *(_QWORD *)a1 + 8LL * a1[2];
  while ( v3 != v5 )
  {
    v7 = (__int64 *)sub_1402A2B80(8, v3);
    v6 = v4++;
    sub_145C3DBE0(v7, v6);
    v3 += 8;
  }
  return *(_QWORD *)a1;
}

// --- End Function: sub_145CD0790 (0x145CD0790) ---

// --- Function: sub_145CD0880 (0x145CD0880) ---
__int64 __fastcall sub_145CD0880(__int64 a1, _BYTE *dst)
{
  if ( *(_QWORD *)dst != *(_QWORD *)a1 )
    sub_145CCFEC0(*(_QWORD *)a1, *(_QWORD *)dst, *(int *)(a1 + 8));
  return *(_QWORD *)a1;
}

// --- End Function: sub_145CD0880 (0x145CD0880) ---

// --- Function: sub_145CD1190 (0x145CD1190) ---
__int64 __fastcall sub_145CD1190(unsigned __int64 *a1, _BYTE *dst)
{
  int v3; // [rsp+30h] [rbp-68h]
  __int64 v4; // [rsp+50h] [rbp-48h] BYREF
  int v5; // [rsp+58h] [rbp-40h]
  _BYTE dst_[16]; // [rsp+60h] [rbp-38h] BYREF
  __int64 *dst__1[5]; // [rsp+70h] [rbp-28h] BYREF

  v3 = *((_DWORD *)dst + 2);
  v4 = sub_1422DA490(a1, v3, 0);
  v5 = v3;
  qmemcpy(dst_, dst, sizeof(dst_));
  qmemcpy(dst__1, dst_, 0x10u);
  return sub_142C0AFD0((int *)&v4, dst__1);
}

// --- End Function: sub_145CD1190 (0x145CD1190) ---

// --- Function: sub_145CD12C0 (0x145CD12C0) ---
__int64 __fastcall sub_145CD12C0(_QWORD *a1, _BYTE *dst)
{
  int v3; // [rsp+30h] [rbp-68h]
  __int64 v4; // [rsp+50h] [rbp-48h] BYREF
  int v5; // [rsp+58h] [rbp-40h]
  _BYTE dst_[16]; // [rsp+60h] [rbp-38h] BYREF
  _QWORD dst__1[5]; // [rsp+70h] [rbp-28h] BYREF

  v3 = *((_DWORD *)dst + 2);
  v4 = sub_145CD0640(a1, v3, 0);
  v5 = v3;
  qmemcpy(dst_, dst, sizeof(dst_));
  qmemcpy(dst__1, dst_, 0x10u);
  return sub_145CD0790((int *)&v4, dst__1);
}

// --- End Function: sub_145CD12C0 (0x145CD12C0) ---

// --- Function: sub_145CD1750 (0x145CD1750) ---
__int64 __fastcall sub_145CD1750(_QWORD *a1, int a2, unsigned __int8 a3)
{
  __int64 result; // rax
  int v4; // [rsp+30h] [rbp-58h] BYREF
  char v5; // [rsp+34h] [rbp-54h]
  char v6; // [rsp+35h] [rbp-53h]
  char v7; // [rsp+36h] [rbp-52h]
  char v8; // [rsp+37h] [rbp-51h]
  BOOL v9; // [rsp+38h] [rbp-50h]
  BOOL v10; // [rsp+3Ch] [rbp-4Ch]
  BOOL v11; // [rsp+40h] [rbp-48h]
  BOOL v12; // [rsp+44h] [rbp-44h]
  unsigned int v13; // [rsp+48h] [rbp-40h]
  int v14; // [rsp+4Ch] [rbp-3Ch]
  unsigned __int64 v15; // [rsp+50h] [rbp-38h]
  int *v16; // [rsp+58h] [rbp-30h]
  _DWORD *v17; // [rsp+60h] [rbp-28h]
  _DWORD *v18; // [rsp+68h] [rbp-20h]
  _QWORD *v19; // [rsp+70h] [rbp-18h]
  _DWORD *v20; // [rsp+78h] [rbp-10h]

  v5 = 0;
  v16 = (int *)(*a1 - 4LL);
  v4 = sub_142C0A070(v16);
  if ( a3 )
  {
    v9 = a2 > v4;
    v11 = v9;
  }
  else
  {
    v10 = a2 != v4;
    v11 = v10;
  }
  if ( !v11 )
    goto LABEL_10;
  v4 = a2;
  v6 = 0;
  v17 = (_DWORD *)(*a1 - 4LL);
  v13 = *v17 & 0x7FFFFFFF;
  v7 = 0;
  v18 = (_DWORD *)(*a1 - 4LL);
  v12 = *v18 == 0;
  v15 = v12 ? 0LL : *a1;
  v19 = a1;
  *a1 = sub_145C3D090((__int64)a1, v15, v13, (unsigned int *)&v4, 8u, a3);
  if ( *a1 )
  {
LABEL_10:
    v8 = 0;
    v20 = (_DWORD *)(*a1 - 4LL);
    v14 = v4;
    return sub_142C0DBC0(v20, a2, v4);
  }
  else
  {
    result = sub_140306140((__int64)&unk_149B3B404, 8);
    *a1 = result;
  }
  return result;
}

// --- End Function: sub_145CD1750 (0x145CD1750) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: unknown_libname_248 (0x148032240) ---
// Microsoft VisualC v14 64bit runtime
const __m128i *__fastcall unknown_libname_248(const __m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  signed __int64 v3; // r9
  unsigned __int64 v5; // rdx
  const __m128i *v10; // rdx
  unsigned __int64 v13; // r9
  const __m128i *v14; // rdx
  __m128i v15; // xmm1
  __int64 v16; // rax

  v3 = (char *)a2 - (char *)a1;
  v5 = ((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL;
  if ( v5 && (dword_149B1CF54 & 0x20) != 0 )
  {
    _XMM2 = a3;
    _YMM2 = (__m256i)a3;
    __asm
    {
      vpunpcklqdq xmm2, xmm2, xmm2
      vinsertf128 ymm2, ymm2, xmm2, 1
    }
    v10 = (const __m128i *)((char *)a1 + v5);
    while ( 1 )
    {
      __asm
      {
        vpcmpeqq ymm1, ymm2, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        break;
      a1 += 2;
      if ( a1 == v10 )
      {
        v3 &= 0x1Fu;
        __asm { vzeroupper }
        goto LABEL_7;
      }
    }
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
LABEL_7:
    v13 = v3 & 0xFFFFFFFFFFFFFFF0uLL;
    if ( v13 && (dword_149B1CF54 & 4) != 0 )
    {
      v14 = (const __m128i *)((char *)a1 + v13);
      v15 = _mm_unpacklo_epi64((__m128i)a3, (__m128i)a3);
      while ( 1 )
      {
        LODWORD(v16) = _mm_movemask_epi8(_mm_cmpeq_epi64(_mm_loadu_si128(a1), v15));
        if ( (_DWORD)v16 )
          break;
        if ( ++a1 == v14 )
          goto LABEL_12;
      }
      _BitScanForward((unsigned int *)&v16, v16);
      return (const __m128i *)((char *)a1 + v16);
    }
    else
    {
LABEL_12:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i64[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 8);
      }
      return a1;
    }
  }
}

// --- End Function: unknown_libname_248 (0x148032240) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

