// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1475DCD10 (sub_1475DCD10)
// Caller Depth: 0
// Callee/Ref Depth: 5
// Total Functions Found: 101
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: LogTraceConditional (0x1402C1000) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
        qword_149B4FCB0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C1000) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---
std::array<int,2> *__fastcall std::allocator<std::array<int,2>>::allocate(
        std::allocator<std::array<int,2> > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  std::array<int,2> *result; // rax

  if ( _Count > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  allocSize = 8 * _Count;
  if ( 8 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (std::array<int,2> *)allocWithProfilerInfo_w(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E1170();
  v3 = allocWithProfilerInfo_w(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (std::array<int,2> *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---

// --- Function: sub_1403479C0 (0x1403479C0) ---
char *__fastcall sub_1403479C0(__int64 a1, char *a2, __int64 *a3)
{
  char *v3; // rbx
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  std::array<int,2> *v12; // r10
  std::array<int,2> *v13; // rdx
  __int64 v14; // rcx
  char *v15; // rbp
  char *v16; // r8
  char *v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rax
  char *v20; // rdx
  signed __int64 v21; // rax
  __int64 v22; // rcx

  v3 = a2;
  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 3;
  _Count = 0x1FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<std::array<int,2>>::allocate((std::allocator<std::array<int,2> > *)a1, _Count);
  *((_QWORD *)v12 + v4) = (char *)&qword_149B3B33C + 4;
  v13 = v12;
  v14 = *a3;
  *a3 = (__int64)&qword_149B3B33C + 4;
  v15 = (char *)v12 + 8 * v4;
  *(_QWORD *)v15 = v14;
  v16 = *(char **)(a1 + 8);
  v17 = *(char **)a1;
  if ( v3 == v16 )
  {
    for ( ; v17 != v16; *((_QWORD *)v13 + 0xFFFFFFFF) = v18 )
    {
      *(_QWORD *)v13 = (char *)&qword_149B3B33C + 4;
      v13 = (std::array<int,2> *)((char *)v13 + 8);
      v18 = *(_QWORD *)v17;
      *(_QWORD *)v17 = (char *)&qword_149B3B33C + 4;
      v17 += 8;
    }
  }
  else
  {
    for ( ; v17 != v3; *((_QWORD *)v13 + 0xFFFFFFFF) = v19 )
    {
      *(_QWORD *)v13 = (char *)&qword_149B3B33C + 4;
      v13 = (std::array<int,2> *)((char *)v13 + 8);
      v19 = *(_QWORD *)v17;
      *(_QWORD *)v17 = (char *)&qword_149B3B33C + 4;
      v17 += 8;
    }
    v20 = *(char **)(a1 + 8);
    if ( v3 != v20 )
    {
      v21 = v15 - v3;
      do
      {
        *(_QWORD *)&v3[v21 + 8] = (char *)&qword_149B3B33C + 4;
        v22 = *(_QWORD *)v3;
        *(_QWORD *)v3 = (char *)&qword_149B3B33C + 4;
        *(_QWORD *)&v3[v21 + 8] = v22;
        v3 += 8;
      }
      while ( v3 != v20 );
    }
  }
  sub_1403DF810((__int64 *)a1, (__int64)v12, v10, _Count);
  return v15;
}

// --- End Function: sub_1403479C0 (0x1403479C0) ---

// --- Function: sub_14034A870 (0x14034A870) ---
char **__fastcall sub_14034A870(char **a1, char **a2, char **a3)
{
  char **v4; // rbx
  char *v6; // rax
  char *v7; // rdx

  v4 = a2;
  while ( v4 != a1 )
  {
    v6 = a3[0xFFFFFFFF];
    v4 += 0xFFFFFFFF;
    a3 += 0xFFFFFFFF;
    v7 = *v4;
    *v4 = v6;
    *a3 = v7;
    if ( *((_DWORD *)*v4 + 0xFFFFFFFE) )
      sub_1403E9810(v4, 0, 0x20);
  }
  return a3;
}

// --- End Function: sub_14034A870 (0x14034A870) ---

// --- Function: sub_14034F5C0 (0x14034F5C0) ---
void **__fastcall sub_14034F5C0(__int64 a1, __int64 a2, void **a3)
{
  void **v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rsi

  v3 = a3;
  v4 = a2;
  if ( a2 )
  {
    v5 = a1 - (_QWORD)a3;
    do
    {
      sub_14035B160(v3, (const void **)((char *)v3 + v5));
      ++v3;
      --v4;
    }
    while ( v4 );
  }
  return v3;
}

// --- End Function: sub_14034F5C0 (0x14034F5C0) ---

// --- Function: sub_140350530 (0x140350530) ---
_QWORD *__fastcall sub_140350530(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  _QWORD *result; // rax
  __int64 v4; // r8

  for ( result = a3; a1 != a2; ++result )
  {
    *result = (char *)&qword_149B3B33C + 4;
    v4 = *a1;
    *a1++ = (__int64)&qword_149B3B33C + 4;
    *result = v4;
  }
  return result;
}

// --- End Function: sub_140350530 (0x140350530) ---

// --- Function: sub_14035B140 (0x14035B140) ---
_QWORD *__fastcall sub_14035B140(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149B3B33C + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035B140 (0x14035B140) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B360 (0x14035B360) ---
void **__fastcall sub_14035B360(void **a1, void *a2, size_t Size)
{
  _DWORD *v6; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( Size )
  {
    v6 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v6 + 2;
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B360 (0x14035B360) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140377F00 (0x140377F00) ---
char **__fastcall sub_140377F00(char **a1, char **a2)
{
  char *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E9810(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377F00 (0x140377F00) ---

// --- Function: copyStringStructure (0x140377F40) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
char **__fastcall copyStringStructure(char **a1, char **a2)
{
  unsigned __int64 Size; // rdi

  Size = *((int *)*a2 + 0xFFFFFFFE);
  sub_1403E9810(a1, Size, 0x20);
  if ( Size && *a1 != *a2 )
    memcpy(*a1, *a2, Size);
  return a1;
}

// --- End Function: copyStringStructure (0x140377F40) ---

// --- Function: assignCStringToStringStructure (0x140377FA0) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **a1, _BYTE *a2)
{
  __int64 Size; // rax

  if ( a2 )
  {
    Size = -1;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DE230(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DE230(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x140377FA0) ---

// --- Function: ??A?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAAEAD_K@Z (0x14037F840) ---
__int64 __fastcall std::unique_ptr<char [0]>::operator[](_QWORD *a1, __int64 a2)
{
  return a2 + *a1;
}

// --- End Function: ??A?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAAEAD_K@Z (0x14037F840) ---

// --- Function: sub_140384840 (0x140384840) ---
void **__fastcall sub_140384840(void **a1, char *a2)
{
  unsigned __int64 Size; // rax

  if ( a2 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DFF30(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DFF30(a1, 0, 0);
    return a1;
  }
}

// --- End Function: sub_140384840 (0x140384840) ---

// --- Function: sub_140391AB0 (0x140391AB0) ---
__int64 __fastcall sub_140391AB0(__int64 a1, unsigned __int64 allocSize)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  unsigned __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403B38D0();
  n0x40 = (allocSize >> 8) + ((_BYTE)allocSize != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
      goto LABEL_7;
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 0x40LL;
      if ( n0x4000 >= 0x4000 )
        goto LABEL_2;
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
        n0x40_1 = 0xFFFFFFFFFFFFFFFFuLL;
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
          goto LABEL_2;
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ;
          n0x4000_2 + 0x40 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL);
          v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = 0xFFFFFFFFFFFFFFFFuLL )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 0x40LL;
    }
    if ( n0x4000_2 < n0x4000 )
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 0x40)) - 1;
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056DB80((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056DBC0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_14056DA40((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(allocSize, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140391AB0 (0x140391AB0) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403A2CE0 (0x1403A2CE0) ---
__int64 sub_1403A2CE0(__int64 a1, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, a1);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
               qword_149B4FCB0,
               0,
               a1,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1403A2CE0 (0x1403A2CE0) ---

// --- Function: sub_1403A3120 (0x1403A3120) ---
void __fastcall sub_1403A3120(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403B38D0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 0x20) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ; v7 + 0x40 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 0x28) = 0 )
    {
      v11 = v7;
      v7 += 0x40LL;
    }
    if ( v7 < v8 )
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~((1LL << ((__int64)v8 % 0x40)) - 1);
  }
  else
  {
    sub_147605980(a2);
  }
}

// --- End Function: sub_1403A3120 (0x1403A3120) ---

// --- Function: sub_1403B38D0 (0x1403B38D0) ---
__int64 sub_1403B38D0()
{
  __int64 *v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(__int64 **)(NtCurrentTeb_w() + 0x10);
  result = *v0;
  if ( !*v0 )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0x828u);
    if ( v2 )
    {
      v2[3] = &p_p_p_p_p_p_p_p_p_p_p_Source;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *v0 = (__int64)v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 0xC0);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 0xC0) = v6 | 1;
      _tlregdtor((__int64)sub_1480BD400);
    }
    return *v0;
  }
  return result;
}

// --- End Function: sub_1403B38D0 (0x1403B38D0) ---

// --- Function: sub_1403BFA30 (0x1403BFA30) ---
bool __fastcall sub_1403BFA30(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BFA30 (0x1403BFA30) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403DE230 (0x1403DE230) ---
void *__fastcall sub_1403DE230(void **a1, void *a2, size_t Size)
{
  _BYTE *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = *a1;
  if ( Size > *((int *)v5 - 1) )
  {
    v7 = (int *)(v5 - 8);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = (char *)&qword_149B3B33C + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, Size);
  *((_DWORD *)*a1 - 2) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403DE230 (0x1403DE230) ---

// --- Function: sub_1403DF810 (0x1403DF810) ---
__int64 __fastcall sub_1403DF810(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  __int64 i; // rdi
  _QWORD *v10; // rcx
  __int64 result; // rax

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v4 != (_QWORD *)i; ++v4 )
    {
      if ( *(int *)(*v4 - 4LL) > 0 )
        sub_147605980((const void *)(*v4 - 8LL));
    }
    v10 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v10 - v10[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = (_QWORD *)v10[0xFFFFFFFF];
    }
    sub_1402A3D30(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 8 * a3;
  result = a2 + 8 * a4;
  a1[2] = result;
  return result;
}

// --- End Function: sub_1403DF810 (0x1403DF810) ---

// --- Function: sub_1403DFF30 (0x1403DFF30) ---
void __fastcall sub_1403DFF30(void **a1, char *a2, size_t Size)
{
  _BYTE *v4; // rbp
  size_t Size_1; // r13
  unsigned __int64 n8; // r15
  _DWORD *v9; // rax
  char *v10; // rcx

  if ( Size )
  {
    v4 = *a1;
    Size_1 = *((int *)*a1 + 0xFFFFFFFE);
    if ( Size + Size_1 <= *((int *)*a1 + 0xFFFFFFFF) )
    {
      if ( &v4[Size_1] != a2 )
        memcpy(&v4[Size_1], a2, Size);
      *((_DWORD *)*a1 + 0xFFFFFFFE) += Size;
      *((_BYTE *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= Size + Size_1 )
        n8 = Size + Size_1;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        v9 = (_DWORD *)allocWithProfilerInfo(n8 + 9, 0);
        *a1 = v9 + 2;
        *v9 = n8;
        v9[1] = n8;
        *((_BYTE *)*a1 + n8) = 0;
        if ( *a1 != v4 )
          memcpy(*a1, v4, Size_1);
        v10 = (char *)*a1 + Size_1;
        if ( v10 != a2 )
          memcpy(v10, a2, Size);
        *((_DWORD *)*a1 + 0xFFFFFFFE) = Size + Size_1;
        *((_BYTE *)*a1 + Size_1 + Size) = 0;
      }
      if ( *((int *)v4 + 0xFFFFFFFF) > 0 )
        sub_147605980(v4 + 0xFFFFFFF8);
    }
  }
}

// --- End Function: sub_1403DFF30 (0x1403DFF30) ---

// --- Function: sub_1403E2E40 (0x1403E2E40) ---
__int64 __fastcall sub_1403E2E40(__int64 a1, __int64 a2)
{
  HMODULE hModule; // rax
  FARPROC ProcAddress; // rbx
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  ProcAddress = GetProcAddress(hModule, "___cigFetchNonWrapFunction___");
  if ( !ProcAddress )
  {
    hModule_1 = LoadLibraryA(0);
    if ( hModule_1 )
      ProcAddress = GetProcAddress(hModule_1, "___cigFetchNonWrapFunction___");
  }
  return ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a1, a2);
}

// --- End Function: sub_1403E2E40 (0x1403E2E40) ---

// --- Function: EnterCriticalSection (0x1403E3690) ---
// attributes: thunk
void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_EnterCriticalSection(lpCriticalSection);
}

// --- End Function: EnterCriticalSection (0x1403E3690) ---

// --- Function: LeaveCriticalSection (0x1403E3CD0) ---
// attributes: thunk
void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_LeaveCriticalSection(lpCriticalSection);
}

// --- End Function: LeaveCriticalSection (0x1403E3CD0) ---

// --- Function: sub_1403E47B0 (0x1403E47B0) ---
__int64 __fastcall sub_1403E47B0(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // rdx
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E47B0 (0x1403E47B0) ---

// --- Function: sub_1403E61D0 (0x1403E61D0) ---
char *__fastcall sub_1403E61D0(__int64 *a1, char Control_1, unsigned __int64 a3)
{
  __int64 v4; // rcx
  char *v5; // rax
  char Control; // [rsp+30h] [rbp+8h] BYREF
  char v8; // [rsp+31h] [rbp+9h]

  v4 = *a1;
  if ( a3 <= *(int *)(v4 - 8) && (Control = Control_1, v8 = 0, (v5 = strpbrk((const char *)(a3 + v4), &Control)) != 0) )
    return &v5[-*a1];
  else
    return (char *)0xFFFFFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403E61D0 (0x1403E61D0) ---

// --- Function: sub_1403E62A0 (0x1403E62A0) ---
__int64 __fastcall sub_1403E62A0(__int64 *a1, char a2, unsigned __int64 a3)
{
  __int64 v3; // r9
  unsigned __int64 v4; // rax
  __int64 v5; // rax

  v3 = *a1;
  v4 = *(int *)(*a1 - 8);
  if ( *(_DWORD *)(*a1 - 8) )
  {
    if ( a3 >= v4 )
      a3 = v4 - 1;
    v5 = v3 + a3;
    if ( *(_BYTE *)(v3 + a3) == a2 )
      return v5 - v3;
    while ( v5 != v3 )
    {
      if ( *(_BYTE *)--v5 == a2 )
        return v5 - v3;
    }
  }
  return 0xFFFFFFFFFFFFFFFFuLL;
}

// --- End Function: sub_1403E62A0 (0x1403E62A0) ---

// --- Function: sub_1403E7A60 (0x1403E7A60) ---
__int64 __fastcall sub_1403E7A60(_QWORD *a1)
{
  return *(int *)(*a1 - 8LL);
}

// --- End Function: sub_1403E7A60 (0x1403E7A60) ---

// --- Function: sub_1403E8630 (0x1403E8630) ---
char *__fastcall sub_1403E8630(__int64 a1, __int64 *a2)
{
  char *v3; // rdx
  char *result; // rax

  v3 = *(char **)(a1 + 8);
  if ( v3 == *(char **)(a1 + 0x10) )
    return sub_1403479C0(a1, v3, a2);
  *(_QWORD *)v3 = (char *)&qword_149B3B33C + 4;
  result = (char *)*a2;
  *a2 = (__int64)&qword_149B3B33C + 4;
  *(_QWORD *)v3 = result;
  *(_QWORD *)(a1 + 8) += 8LL;
  return result;
}

// --- End Function: sub_1403E8630 (0x1403E8630) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 - 1) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 - 2)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 - 2));
  memset(&(*a1)[*((int *)v3 - 2)], Val_1, Size);
  if ( *((int *)v3 - 1) > 0 )
    sub_147605980(v3 - 8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1403EAD20 (0x1403EAD20) ---
__int64 __fastcall sub_1403EAD20(__int64 a1, const char *String2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 MaxCount_1; // rax
  int v6; // edi
  int v7; // ebx
  size_t MaxCount; // r15

  v2 = 0xFFFFFFFFFFFFFFFFuLL;
  MaxCount_1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++MaxCount_1;
  while ( String2[MaxCount_1] );
  v6 = 0;
  do
    ++v2;
  while ( *(_BYTE *)(a1 + v2) );
  v7 = v2 - MaxCount_1;
  if ( v7 < 0 )
    return 0;
  MaxCount = (int)MaxCount_1;
  while ( _strnicmp((const char *)(a1 + v6), String2, MaxCount) )
  {
    if ( ++v6 > v7 )
      return 0;
  }
  return a1 + v6;
}

// --- End Function: sub_1403EAD20 (0x1403EAD20) ---

// --- Function: sub_1403EAE30 (0x1403EAE30) ---
void **__fastcall sub_1403EAE30(__int64 *a1, void **a2, size_t a3, size_t Size_1)
{
  __int64 v6; // rdx
  size_t v7; // rcx
  size_t Size; // r8

  v6 = *a1;
  v7 = *(int *)(*a1 - 8);
  if ( a3 < v7 )
  {
    Size = v7 - a3;
    if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
      Size_1 = v7 - a3;
    if ( a3 + Size_1 <= v7 )
      Size = Size_1;
    sub_14035B360(a2, (void *)(a3 + v6), Size);
    return a2;
  }
  else
  {
    *a2 = (char *)&qword_149B3B33C + 4;
    return a2;
  }
}

// --- End Function: sub_1403EAE30 (0x1403EAE30) ---

// --- Function: _snprintf_s (0x1403ECF60) ---
int snprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = (unsigned __int64 *)sub_1402A4380();
  result = _stdio_common_vsnprintf_s(*v8, DstBuf, SizeInBytes, MaxCount, Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: _snprintf_s (0x1403ECF60) ---

// --- Function: sub_1403F0B60 (0x1403F0B60) ---
void __fastcall sub_1403F0B60(__int64 **a1, __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 *v4; // rsi
  __int64 v6; // rdx
  __int64 *v8; // r13
  __int64 v11; // rcx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v17; // rax
  _QWORD *v18; // rdi
  __int64 v19; // r12
  _QWORD *v20; // r8
  __int64 v21; // rcx
  __int64 *v22; // rbp
  char **v23; // rdi
  __int64 *j; // rdi
  __int64 *i; // rdi
  __int64 v26; // [rsp+60h] [rbp+8h]

  if ( !a4 )
    return;
  v4 = a1[1];
  v6 = (__int64)a1[2];
  v8 = *a1;
  if ( a4 > (v6 - (__int64)v4) >> 3 )
  {
    v11 = v4 - v8;
    if ( a4 > 0x1FFFFFFFFFFFFFFFLL - v11 )
      unknown_libname_10();
    v12 = v11 + a4;
    v13 = (v6 - (__int64)v8) >> 3;
    v26 = v11 + a4;
    v14 = v13 >> 1;
    if ( v13 <= 0x1FFFFFFFFFFFFFFFLL - (v13 >> 1) )
    {
      v15 = v12;
      if ( v14 + v13 >= v12 )
        v15 = v14 + v13;
      if ( v15 <= 0x1FFFFFFFFFFFFFFFLL )
      {
        allocSize = 8 * v15;
        if ( 8 * v15 < 0x1000 )
        {
          if ( allocSize )
            v18 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
          else
            v18 = 0;
LABEL_16:
          v19 = a2 - v8;
          sub_14034F5C0(a3, a4, (void **)&v18[v19]);
          if ( a4 == 1 && a2 == v4 )
          {
            v20 = v18;
          }
          else
          {
            sub_140350530(v8, a2, v18);
            v8 = a2;
            v20 = &v18[v19 + a4];
          }
          sub_140350530(v8, v4, v20);
          sub_1403DF810((__int64 *)a1, (__int64)v18, v26, v15);
          return;
        }
        if ( allocSize + 0x27 >= allocSize )
        {
          v17 = allocWithProfilerInfo_w(allocSize + 0x27);
          if ( !v17 )
            invalid_parameter_noinfo_noreturn();
          v18 = (_QWORD *)((v17 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
          v18[0xFFFFFFFF] = v17;
          goto LABEL_16;
        }
      }
    }
    sub_1402E1170();
  }
  v21 = 8 * a4;
  v22 = &a2[a4];
  if ( a4 >= v4 - a2 )
  {
    a1[1] = sub_140350530(a2, v4, v22);
    for ( i = a2; i != v4; ++i )
      sub_140370D10(i);
  }
  else
  {
    v23 = (char **)&v4[v21 / 0xFFFFFFFFFFFFFFF8uLL];
    a1[1] = sub_140350530(&v4[v21 / 0xFFFFFFFFFFFFFFF8uLL], v4, v4);
    sub_14034A870((char **)a2, v23, (char **)v4);
    for ( j = a2; j != v22; ++j )
      sub_140370D10(j);
  }
  sub_14034F5C0(a3, a4, (void **)a2);
}

// --- End Function: sub_1403F0B60 (0x1403F0B60) ---

// --- Function: sub_14042FD60 (0x14042FD60) ---
void **__fastcall sub_14042FD60(__int64 a1, const void **a2)
{
  __int64 *v2; // rbx
  __int64 *v4; // r8
  void **result; // rax
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rsi
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r15
  __int64 v13; // r12
  _QWORD *v14; // r14
  void **v15; // r13
  __int64 *v16; // rdx
  _QWORD *v17; // r8
  __int64 *v18; // rcx
  __int64 *v19; // rbx
  __int64 *i; // rsi

  v2 = *(__int64 **)(a1 + 8);
  v4 = *(__int64 **)(a1 + 0x10);
  if ( v2 == v4 )
  {
    v7 = *(__int64 **)a1;
    v8 = 0x1FFFFFFFFFFFFFFFLL;
    v9 = v2 - v7;
    if ( v9 == 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v10 = v4 - v7;
    v11 = v10 >> 1;
    v12 = v9 + 1;
    if ( v10 <= 0x1FFFFFFFFFFFFFFFLL - (v10 >> 1) )
    {
      v8 = v11 + v10;
      if ( v11 + v10 < v12 )
        v8 = v9 + 1;
    }
    v13 = v8;
    v14 = (_QWORD *)sub_140391AB0(a1, 8 * v8);
    v15 = (void **)&v14[v9];
    sub_14035B160(v15, a2);
    v16 = *(__int64 **)(a1 + 8);
    v17 = v14;
    v18 = *(__int64 **)a1;
    if ( v2 != v16 )
    {
      sub_14043EFE0(v18, v2, v14);
      v16 = *(__int64 **)(a1 + 8);
      v17 = v15 + 1;
      v18 = v2;
    }
    sub_14043EFE0(v18, v16, v17);
    v19 = *(__int64 **)a1;
    if ( *(_QWORD *)a1 )
    {
      for ( i = *(__int64 **)(a1 + 8); v19 != i; ++v19 )
        sub_140370D10(v19);
      sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    }
    result = v15;
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = &v14[v12];
    *(_QWORD *)(a1 + 0x10) = &v14[v13];
  }
  else
  {
    sub_14035B160(*(void ***)(a1 + 8), a2);
    result = *(void ***)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result + 1;
  }
  return result;
}

// --- End Function: sub_14042FD60 (0x14042FD60) ---

// --- Function: sub_14043EFE0 (0x14043EFE0) ---
_QWORD *__fastcall sub_14043EFE0(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  __int64 *i; // rbx

  for ( i = a1; i != a2; ++i )
    sub_14035B140(a3++, i);
  return a3;
}

// --- End Function: sub_14043EFE0 (0x14043EFE0) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10(a3);
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DB80 (0x14056DB80) ---
__int64 __fastcall sub_14056DB80(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 0x1000 )
        return 0x1000;
      if ( ++v1 == v2 )
        return 0x1000;
    }
  }
  return 0x1000;
}

// --- End Function: sub_14056DB80 (0x14056DB80) ---

// --- Function: sub_14056DBC0 (0x14056DBC0) ---
__int64 __fastcall sub_14056DBC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E2E40(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056DBC0 (0x14056DBC0) ---

// --- Function: sub_14056DD10 (0x14056DD10) ---
// attributes: thunk
__int64 sub_14056DD10()
{
  return qword_149B4F990();
}

// --- End Function: sub_14056DD10 (0x14056DD10) ---

// --- Function: sub_14059AF30 (0x14059AF30) ---
void __fastcall sub_14059AF30(_QWORD *a1)
{
  const void *v2; // rcx

  if ( *((_BYTE *)a1 + 136) != 1 )
    sub_140370D10(a1 + 19);
  v2 = (const void *)a1[13];
  if ( v2 )
    sub_1402A3D30(v2);
  sub_140370D10(a1 + 8);
  sub_140370D10(a1 + 7);
  sub_140370D10(a1 + 6);
  sub_140370D10(a1 + 5);
  sub_140370D10(a1);
}

// --- End Function: sub_14059AF30 (0x14059AF30) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_141848E00 (0x141848E00) ---
_QWORD *__fastcall sub_141848E00(_QWORD *p_pExceptionObject)
{
  p_pExceptionObject[1] = "bad allocation";
  *p_pExceptionObject = off_1481A05A8;
  return p_pExceptionObject;
}

// --- End Function: sub_141848E00 (0x141848E00) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147557660 (0x147557660) ---
__int64 *__fastcall sub_147557660(__int64 *a1, const char **a2)
{
  __int64 *v2; // rdi
  __int64 *v5; // rbx
  bool v6; // sf
  __int64 *result; // rax

  v2 = (__int64 *)*a1;
  v5 = *(__int64 **)(*a1 + 8);
  while ( !*((_BYTE *)v5 + 0x19) )
  {
    if ( _stricmp((const char *)v5[4], *a2) >= 0 )
    {
      v2 = v5;
      v5 = (__int64 *)*v5;
    }
    else
    {
      v5 = (__int64 *)v5[2];
    }
  }
  if ( *((_BYTE *)v2 + 0x19) )
    return (__int64 *)*a1;
  v6 = _stricmp(*a2, (const char *)v2[4]) < 0;
  result = v2;
  if ( v6 )
    return (__int64 *)*a1;
  return result;
}

// --- End Function: sub_147557660 (0x147557660) ---

// --- Function: sub_1475585A0 (0x1475585A0) ---
__int64 *__fastcall sub_1475585A0(__int64 *a1, __int64 *a2)
{
  __int64 *i; // rbp
  char **v5; // rsi
  char *v6; // r8
  char *j; // r9
  unsigned int n0x12C; // edx
  char v9; // bl
  char n0x12C_2; // r11
  unsigned int n0x12C_1; // eax
  char **k; // rbx
  char *v13; // rdi
  signed __int64 v14; // rdi
  unsigned int n0x12C_3; // edx
  char v16; // r11
  char n0x12C_5; // r10
  unsigned int n0x12C_4; // eax
  char **v19; // rbx
  char **v20; // rcx
  char *v22; // [rsp+40h] [rbp+8h] BYREF

  if ( a1 == a2 )
    return a2;
  for ( i = a1 + 1; i != a2; ++i )
  {
    v5 = (char **)i;
    sub_14035B140(&v22, i);
    v6 = v22;
    for ( j = v22; ; ++j )
    {
      LOBYTE(n0x12C) = *j - 0x20;
      if ( (unsigned __int8)(*j - 0x61) > 0x19u )
        LOBYTE(n0x12C) = *j;
      if ( (_BYTE)n0x12C == 0x5F )
        n0x12C = 0x12C;
      else
        n0x12C = (char)n0x12C;
      v9 = j[*a1 - (_QWORD)v22];
      n0x12C_2 = v9 - 0x20;
      n0x12C_1 = 0x12C;
      if ( (unsigned __int8)(v9 - 0x61) > 0x19u )
        n0x12C_2 = j[*a1 - (_QWORD)v22];
      if ( n0x12C_2 != 0x5F )
        n0x12C_1 = n0x12C_2;
      if ( n0x12C < n0x12C_1 )
        break;
      if ( n0x12C > n0x12C_1 || !*j || !v9 )
      {
        for ( k = (char **)i; ; v5 = k )
        {
          v13 = k[0xFFFFFFFF];
          k += 0xFFFFFFFF;
          v14 = v13 - v6;
          while ( 1 )
          {
            LOBYTE(n0x12C_3) = *v6 - 0x20;
            if ( (unsigned __int8)(*v6 - 0x61) > 0x19u )
              LOBYTE(n0x12C_3) = *v6;
            if ( (_BYTE)n0x12C_3 == 0x5F )
              n0x12C_3 = 0x12C;
            else
              n0x12C_3 = (char)n0x12C_3;
            v16 = v6[v14];
            n0x12C_5 = v16 - 0x20;
            n0x12C_4 = 0x12C;
            if ( (unsigned __int8)(v16 - 0x61) > 0x19u )
              n0x12C_5 = v6[v14];
            if ( n0x12C_5 != 0x5F )
              n0x12C_4 = n0x12C_5;
            if ( n0x12C_3 < n0x12C_4 )
              break;
            if ( n0x12C_3 > n0x12C_4 || !*v6 || !v16 )
              goto LABEL_38;
            ++v6;
          }
          sub_140377F00(v5, k);
          v6 = v22;
        }
      }
    }
    v19 = (char **)i;
    if ( i != a1 )
    {
      do
      {
        v20 = v19;
        v19 += 0xFFFFFFFF;
        sub_140377F00(v20, v19);
      }
      while ( v19 != (char **)a1 );
    }
    v5 = (char **)a1;
LABEL_38:
    sub_140377F00(v5, &v22);
    sub_140370D10(&v22);
  }
  return a2;
}

// --- End Function: sub_1475585A0 (0x1475585A0) ---

// --- Function: sub_1475592E0 (0x1475592E0) ---
void __fastcall sub_1475592E0(__int64 a1, __int64 a2)
{
  __int64 v3; // r13
  __int64 v4; // r15
  __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v7; // r12
  __int64 v8; // rbp
  __int64 v9; // rbx
  __int64 v10; // rdi
  _BYTE *v11; // r9
  __int64 v12; // rbx
  unsigned int n0x12C; // edx
  char v14; // r11
  char n0x12C_2; // r8
  unsigned int n0x12C_1; // eax
  __int64 n2; // rax
  __int64 v18; // rbx
  _BYTE *v19; // r9
  char *v20; // rdi
  unsigned int n0x12C_3; // edx
  char v22; // r11
  char n0x12C_5; // r8
  unsigned int n0x12C_4; // eax
  char *v25; // [rsp+60h] [rbp+8h] BYREF
  __int64 v26; // [rsp+68h] [rbp+10h]

  v3 = (a2 - a1) >> 3;
  v4 = (a2 - a1) >> 4;
  if ( v4 > 0 )
  {
    v5 = a1 + 8 * v4;
    v6 = v3 - 1;
    v7 = (v3 - 1) >> 1;
    do
    {
      v26 = v5 - 8;
      --v4;
      sub_14035B140(&v25, (__int64 *)(v5 - 8));
      v8 = v4;
      v9 = v4;
      if ( v4 < v7 )
      {
        do
        {
          v10 = 2 * v9;
          v11 = *(_BYTE **)(a1 + 0x10 * v9 + 0x10);
          v12 = *(_QWORD *)(a1 + 0x10 * v9 + 8) - (_QWORD)v11;
          while ( 1 )
          {
            LOBYTE(n0x12C) = *v11 - 0x20;
            if ( (unsigned __int8)(*v11 - 0x61) > 0x19u )
              LOBYTE(n0x12C) = *v11;
            if ( (_BYTE)n0x12C == 0x5F )
              n0x12C = 0x12C;
            else
              n0x12C = (char)n0x12C;
            v14 = v11[v12];
            n0x12C_2 = v14 - 0x20;
            n0x12C_1 = 0x12C;
            if ( (unsigned __int8)(v14 - 0x61) > 0x19u )
              n0x12C_2 = v11[v12];
            if ( n0x12C_2 != 0x5F )
              n0x12C_1 = n0x12C_2;
            if ( n0x12C < n0x12C_1 )
              break;
            if ( n0x12C > n0x12C_1 || !*v11 || !v14 )
            {
              n2 = 2;
              goto LABEL_21;
            }
            ++v11;
          }
          n2 = 1;
LABEL_21:
          v9 = v10 + n2;
          sub_140377F00((char **)(a1 + 8 * v8), (char **)(a1 + 8 * (v10 + n2)));
          v8 = v9;
        }
        while ( v9 < v7 );
        v6 = v3 - 1;
      }
      if ( v8 == v7 && (v3 & 1) == 0 )
      {
        sub_140377F00((char **)(a1 + 8 * v8), (char **)(a1 - 8 + 8 * v3));
        v8 = v6;
      }
      if ( v4 < v8 )
      {
        do
        {
          v18 = (v8 - 1) >> 1;
          v19 = *(_BYTE **)(a1 + 8 * v18);
          v20 = (char *)(v25 - v19);
          while ( 1 )
          {
            LOBYTE(n0x12C_3) = *v19 - 0x20;
            if ( (unsigned __int8)(*v19 - 0x61) > 0x19u )
              LOBYTE(n0x12C_3) = *v19;
            if ( (_BYTE)n0x12C_3 == 0x5F )
              n0x12C_3 = 0x12C;
            else
              n0x12C_3 = (char)n0x12C_3;
            v22 = v19[(_QWORD)v20];
            n0x12C_5 = v22 - 0x20;
            n0x12C_4 = 0x12C;
            if ( (unsigned __int8)(v22 - 0x61) > 0x19u )
              n0x12C_5 = v19[(_QWORD)v20];
            if ( n0x12C_5 != 0x5F )
              n0x12C_4 = n0x12C_5;
            if ( n0x12C_3 < n0x12C_4 )
              break;
            if ( n0x12C_3 > n0x12C_4 || !*v19 || !v22 )
              goto LABEL_43;
            ++v19;
          }
          sub_140377F00((char **)(a1 + 8 * v8), (char **)(a1 + 8 * v18));
          v8 = (v8 - 1) >> 1;
        }
        while ( v4 < v18 );
      }
LABEL_43:
      sub_140377F00((char **)(a1 + 8 * v8), &v25);
      sub_140370D10(&v25);
      v5 = v26;
      v6 = v3 - 1;
    }
    while ( v4 > 0 );
  }
}

// --- End Function: sub_1475592E0 (0x1475592E0) ---

// --- Function: sub_147559DA0 (0x147559DA0) ---
void __fastcall sub_147559DA0(char **a1, __int64 *a2, __int64 *a3)
{
  char *v3; // r9
  char *v6; // rbx
  unsigned int n0x12C; // edx
  char n0x12C_1; // cl
  char v10; // r11
  char n0x12C_3; // r8
  unsigned int n0x12C_2; // eax
  _BYTE *i; // r8
  unsigned int n0x12C_4; // edx
  char v15; // r11
  char n0x12C_6; // r10
  unsigned int n0x12C_5; // eax
  _BYTE *j; // r9
  unsigned int n0x12C_7; // edx
  char v20; // r11
  char n0x12C_9; // r10
  unsigned int n0x12C_8; // eax
  char *v23; // [rsp+30h] [rbp+8h] BYREF

  v3 = (char *)*a2;
  v6 = &(*a1)[-*a2];
  while ( 1 )
  {
    n0x12C = 0x12C;
    n0x12C_1 = *v3 - 0x20;
    if ( (unsigned __int8)(*v3 - 0x61) > 0x19u )
      n0x12C_1 = *v3;
    if ( n0x12C_1 != 0x5F )
      n0x12C = n0x12C_1;
    v10 = v3[(_QWORD)v6];
    n0x12C_3 = v10 - 0x20;
    n0x12C_2 = 0x12C;
    if ( (unsigned __int8)(v10 - 0x61) > 0x19u )
      n0x12C_3 = v3[(_QWORD)v6];
    if ( n0x12C_3 != 0x5F )
      n0x12C_2 = n0x12C_3;
    if ( n0x12C < n0x12C_2 )
      break;
    if ( n0x12C > n0x12C_2 || !*v3 || !v10 )
      goto LABEL_16;
    ++v3;
  }
  sub_14035B140(&v23, a2);
  sub_140377F00((char **)a2, a1);
  sub_140377F00(a1, &v23);
  sub_140370D10(&v23);
LABEL_16:
  for ( i = (_BYTE *)*a3; ; ++i )
  {
    LOBYTE(n0x12C_4) = *i - 0x20;
    if ( (unsigned __int8)(*i - 0x61) > 0x19u )
      LOBYTE(n0x12C_4) = *i;
    if ( (_BYTE)n0x12C_4 == 0x5F )
      n0x12C_4 = 0x12C;
    else
      n0x12C_4 = (char)n0x12C_4;
    v15 = i[*a2 - *a3];
    n0x12C_6 = v15 - 0x20;
    n0x12C_5 = 0x12C;
    if ( (unsigned __int8)(v15 - 0x61) > 0x19u )
      n0x12C_6 = i[*a2 - *a3];
    if ( n0x12C_6 != 0x5F )
      n0x12C_5 = n0x12C_6;
    if ( n0x12C_4 < n0x12C_5 )
      break;
    if ( n0x12C_4 > n0x12C_5 || !*i || !v15 )
      return;
  }
  sub_14035B140(&v23, a3);
  sub_140377F00((char **)a3, (char **)a2);
  sub_140377F00((char **)a2, &v23);
  sub_140370D10(&v23);
  for ( j = (_BYTE *)*a2; ; ++j )
  {
    LOBYTE(n0x12C_7) = *j - 0x20;
    if ( (unsigned __int8)(*j - 0x61) > 0x19u )
      LOBYTE(n0x12C_7) = *j;
    if ( (_BYTE)n0x12C_7 == 0x5F )
      n0x12C_7 = 0x12C;
    else
      n0x12C_7 = (char)n0x12C_7;
    v20 = (*a1)[(_QWORD)j - *a2];
    n0x12C_9 = v20 - 0x20;
    n0x12C_8 = 0x12C;
    if ( (unsigned __int8)(v20 - 0x61) > 0x19u )
      n0x12C_9 = (*a1)[(_QWORD)j - *a2];
    if ( n0x12C_9 != 0x5F )
      n0x12C_8 = n0x12C_9;
    if ( n0x12C_7 < n0x12C_8 )
      break;
    if ( n0x12C_7 > n0x12C_8 || !*j || !v20 )
      return;
  }
  sub_14035B140(&v23, a2);
  sub_140377F00((char **)a2, a1);
  sub_140377F00(a1, &v23);
  sub_140370D10(&v23);
}

// --- End Function: sub_147559DA0 (0x147559DA0) ---

// --- Function: sub_14755D3E0 (0x14755D3E0) ---
__int64 **__fastcall sub_14755D3E0(__int64 **a1, char **a2, char **a3)
{
  char **v4; // rbp
  __int64 *v5; // r12
  __int64 n0x28; // rax
  __int64 v7; // rax
  __int64 v8; // r14
  __int64 v9; // rsi
  __int64 *v10; // rbp
  __int64 *v11; // r15
  char *v12; // rsi
  __int64 *v13; // r14
  char *v14; // r11
  char *i; // r10
  unsigned int n0x12C; // r9d
  char n0x12C_1; // dl
  char v18; // bl
  char n0x12C_3; // dl
  unsigned int n0x12C_2; // eax
  __int64 v21; // rsi
  unsigned int n0x12C_4; // r10d
  char n0x12C_5; // dl
  char v24; // r9
  char n0x12C_7; // dl
  unsigned int n0x12C_6; // eax
  __int64 v27; // rsi
  char *j; // r11
  unsigned int n0x12C_8; // r9d
  char n0x12C_9; // dl
  char v31; // r10
  char n0x12C_11; // dl
  unsigned int n0x12C_10; // eax
  char *k; // r11
  unsigned int n0x12C_12; // r10d
  char n0x12C_13; // dl
  char v37; // r9
  char n0x12C_15; // dl
  unsigned int n0x12C_14; // eax
  char **v40; // r14
  __int64 *v41; // rbp
  char *v42; // r11
  char *m; // rbx
  unsigned int n0x12C_16; // r8d
  char n0x12C_17; // dl
  char v46; // r10
  char n0x12C_19; // dl
  unsigned int n0x12C_18; // eax
  __int64 v49; // rsi
  unsigned int n0x12C_20; // r10d
  char n0x12C_21; // al
  char v52; // r9
  char n0x12C_23; // dl
  unsigned int n0x12C_22; // eax
  bool v55; // zf
  char *v56; // rbx
  _QWORD *v57; // rsi
  char *v58; // r9
  __int64 v59; // rdi
  unsigned int n0x12C_24; // r8d
  char n0x12C_25; // dl
  char v62; // r11
  char n0x12C_27; // dl
  unsigned int n0x12C_26; // eax
  __int64 v65; // r11
  unsigned int n0x12C_28; // r9d
  char n0x12C_29; // dl
  char v68; // r10
  char n0x12C_31; // dl
  unsigned int n0x12C_30; // eax
  __int64 *v71; // rax
  __int64 **result; // rax
  char *v73; // [rsp+20h] [rbp-68h] BYREF
  char *v74; // [rsp+28h] [rbp-60h] BYREF
  char *v75; // [rsp+30h] [rbp-58h] BYREF
  char *v76; // [rsp+38h] [rbp-50h] BYREF
  char *v77; // [rsp+40h] [rbp-48h] BYREF
  char *v78[8]; // [rsp+48h] [rbp-40h] BYREF
  char *v81; // [rsp+A0h] [rbp+18h] BYREF

  v4 = a2;
  v5 = (__int64 *)&a2[((char *)a3 - (char *)a2) >> 4];
  n0x28 = a3 + 0xFFFFFFFF - a2;
  if ( n0x28 <= 0x28 )
  {
    sub_147559DA0(a2, v5, (__int64 *)a3 + 0xFFFFFFFF);
  }
  else
  {
    v7 = (n0x28 + 1) >> 3;
    v8 = 0x10 * v7;
    v9 = 8 * v7;
    v10 = (__int64 *)&a2[v7];
    sub_147559DA0(a2, v10, (__int64 *)&a2[2 * v7]);
    sub_147559DA0((char **)&v5[v9 / 0xFFFFFFFFFFFFFFF8uLL], v5, &v5[(unsigned __int64)v9 / 8]);
    sub_147559DA0(
      &a3[v8 / 0xFFFFFFFFFFFFFFF8uLL + 0xFFFFFFFF],
      (__int64 *)&a3[v9 / 0xFFFFFFFFFFFFFFF8uLL + 0xFFFFFFFF],
      (__int64 *)a3 + 0xFFFFFFFF);
    sub_147559DA0((char **)v10, v5, (__int64 *)&a3[v9 / 0xFFFFFFFFFFFFFFF8uLL + 0xFFFFFFFF]);
    v4 = a2;
  }
  v11 = v5 + 1;
  if ( v4 < (char **)v5 )
  {
LABEL_5:
    v12 = (char *)v5[0xFFFFFFFF];
    v13 = v5 + 0xFFFFFFFF;
    v14 = (char *)*v5;
    for ( i = v12; ; ++i )
    {
      n0x12C = 0x12C;
      n0x12C_1 = *i - 0x20;
      if ( (unsigned __int8)(*i - 0x61) > 0x19u )
        n0x12C_1 = *i;
      if ( n0x12C_1 != 0x5F )
        n0x12C = n0x12C_1;
      v18 = i[*v5 - (_QWORD)v12];
      n0x12C_3 = v18 - 0x20;
      n0x12C_2 = 0x12C;
      if ( (unsigned __int8)(v18 - 0x61) > 0x19u )
        n0x12C_3 = i[*v5 - (_QWORD)v12];
      if ( n0x12C_3 != 0x5F )
        n0x12C_2 = n0x12C_3;
      if ( n0x12C < n0x12C_2 )
        break;
      if ( n0x12C > n0x12C_2 || !*i || !v18 )
      {
        v21 = v12 - v14;
        while ( 1 )
        {
          n0x12C_4 = 0x12C;
          n0x12C_5 = *v14 - 0x20;
          if ( (unsigned __int8)(*v14 - 0x61) > 0x19u )
            n0x12C_5 = *v14;
          if ( n0x12C_5 != 0x5F )
            n0x12C_4 = n0x12C_5;
          v24 = v14[v21];
          n0x12C_7 = v24 - 0x20;
          n0x12C_6 = 0x12C;
          if ( (unsigned __int8)(v24 - 0x61) > 0x19u )
            n0x12C_7 = v14[v21];
          if ( n0x12C_7 != 0x5F )
            n0x12C_6 = n0x12C_7;
          if ( n0x12C_4 < n0x12C_6 )
            goto LABEL_34;
          if ( n0x12C_4 > n0x12C_6 || !*v14 || !v24 )
          {
            v5 += 0xFFFFFFFF;
            if ( v4 < (char **)v13 )
              goto LABEL_5;
            goto LABEL_34;
          }
          ++v14;
        }
      }
    }
  }
LABEL_34:
  if ( v11 < (__int64 *)a3 )
  {
    v27 = *v5;
LABEL_36:
    for ( j = (char *)*v11; ; ++j )
    {
      n0x12C_8 = 0x12C;
      n0x12C_9 = *j - 0x20;
      if ( (unsigned __int8)(*j - 0x61) > 0x19u )
        n0x12C_9 = *j;
      if ( n0x12C_9 != 0x5F )
        n0x12C_8 = n0x12C_9;
      v31 = j[v27 - *v11];
      n0x12C_11 = v31 - 0x20;
      n0x12C_10 = 0x12C;
      if ( (unsigned __int8)(v31 - 0x61) > 0x19u )
        n0x12C_11 = j[v27 - *v11];
      if ( n0x12C_11 != 0x5F )
        n0x12C_10 = n0x12C_11;
      if ( n0x12C_8 < n0x12C_10 )
        break;
      if ( n0x12C_8 > n0x12C_10 || !*j || !v31 )
      {
        for ( k = (char *)*v5; ; ++k )
        {
          n0x12C_12 = 0x12C;
          n0x12C_13 = *k - 0x20;
          if ( (unsigned __int8)(*k - 0x61) > 0x19u )
            n0x12C_13 = *k;
          if ( n0x12C_13 != 0x5F )
            n0x12C_12 = n0x12C_13;
          v37 = k[*v11 - v27];
          n0x12C_15 = v37 - 0x20;
          n0x12C_14 = 0x12C;
          if ( (unsigned __int8)(v37 - 0x61) > 0x19u )
            n0x12C_15 = k[*v11 - v27];
          if ( n0x12C_15 != 0x5F )
            n0x12C_14 = n0x12C_15;
          if ( n0x12C_12 < n0x12C_14 )
            break;
          if ( n0x12C_12 > n0x12C_14 || !*k || !v37 )
          {
            if ( ++v11 < (__int64 *)a3 )
              goto LABEL_36;
            goto LABEL_65;
          }
        }
        break;
      }
    }
  }
LABEL_65:
  v40 = (char **)v11;
  v41 = v5;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v40 < a3 )
      {
        while ( 2 )
        {
          v42 = *v40;
          for ( m = (char *)*v5; ; ++m )
          {
            n0x12C_16 = 0x12C;
            n0x12C_17 = *m - 0x20;
            if ( (unsigned __int8)(*m - 0x61) > 0x19u )
              n0x12C_17 = *m;
            if ( n0x12C_17 != 0x5F )
              n0x12C_16 = n0x12C_17;
            v46 = (*v40)[(_QWORD)m - *v5];
            n0x12C_19 = v46 - 0x20;
            n0x12C_18 = 0x12C;
            if ( (unsigned __int8)(v46 - 0x61) > 0x19u )
              n0x12C_19 = (*v40)[(_QWORD)m - *v5];
            if ( n0x12C_19 != 0x5F )
              n0x12C_18 = n0x12C_19;
            if ( n0x12C_16 < n0x12C_18 )
              break;
            if ( n0x12C_16 > n0x12C_18 || !*m || !v46 )
            {
              v49 = *v5 - (_QWORD)v42;
              while ( 1 )
              {
                n0x12C_20 = 0x12C;
                n0x12C_21 = *v42 - 0x20;
                if ( (unsigned __int8)(*v42 - 0x61) > 0x19u )
                  n0x12C_21 = *v42;
                if ( n0x12C_21 != 0x5F )
                  n0x12C_20 = n0x12C_21;
                v52 = v42[v49];
                n0x12C_23 = v52 - 0x20;
                n0x12C_22 = 0x12C;
                if ( (unsigned __int8)(v52 - 0x61) > 0x19u )
                  n0x12C_23 = v42[v49];
                if ( n0x12C_23 != 0x5F )
                  n0x12C_22 = n0x12C_23;
                if ( n0x12C_20 < n0x12C_22 )
                  goto LABEL_99;
                if ( n0x12C_20 > n0x12C_22 || !*v42 || !v52 )
                {
                  if ( v11 != (__int64 *)v40 )
                  {
                    sub_14035B140(&v81, v11);
                    sub_140377F00((char **)v11, v40);
                    sub_140377F00(v40, &v81);
                    sub_140370D10(&v81);
                  }
                  ++v11;
                  goto LABEL_98;
                }
                ++v42;
              }
            }
          }
LABEL_98:
          if ( ++v40 < a3 )
            continue;
          break;
        }
      }
LABEL_99:
      v55 = v41 == (__int64 *)a2;
      if ( v41 > (__int64 *)a2 )
      {
        do
        {
          v56 = (char *)*v5;
          v57 = v41 + 0xFFFFFFFF;
          v58 = (char *)v41[0xFFFFFFFF];
          v59 = *v5 - (_QWORD)v58;
          while ( 1 )
          {
            n0x12C_24 = 0x12C;
            n0x12C_25 = *v58 - 0x20;
            if ( (unsigned __int8)(*v58 - 0x61) > 0x19u )
              n0x12C_25 = *v58;
            if ( n0x12C_25 != 0x5F )
              n0x12C_24 = n0x12C_25;
            v62 = v58[v59];
            n0x12C_27 = v62 - 0x20;
            n0x12C_26 = 0x12C;
            if ( (unsigned __int8)(v62 - 0x61) > 0x19u )
              n0x12C_27 = v58[v59];
            if ( n0x12C_27 != 0x5F )
              n0x12C_26 = n0x12C_27;
            if ( n0x12C_24 < n0x12C_26 )
              break;
            if ( n0x12C_24 > n0x12C_26 || !*v58 || !v62 )
            {
              v65 = *v57 - (_QWORD)v56;
              while ( 1 )
              {
                n0x12C_28 = 0x12C;
                n0x12C_29 = *v56 - 0x20;
                if ( (unsigned __int8)(*v56 - 0x61) > 0x19u )
                  n0x12C_29 = *v56;
                if ( n0x12C_29 != 0x5F )
                  n0x12C_28 = n0x12C_29;
                v68 = v56[v65];
                n0x12C_31 = v68 - 0x20;
                n0x12C_30 = 0x12C;
                if ( (unsigned __int8)(v68 - 0x61) > 0x19u )
                  n0x12C_31 = v56[v65];
                if ( n0x12C_31 != 0x5F )
                  n0x12C_30 = n0x12C_31;
                if ( n0x12C_28 < n0x12C_30 )
                {
                  v71 = (__int64 *)a2;
                  goto LABEL_133;
                }
                if ( n0x12C_28 > n0x12C_30 || !*v56 || !v68 )
                  break;
                ++v56;
              }
              v5 += 0xFFFFFFFF;
              if ( v5 != v57 )
              {
                sub_14035B140(&v73, v5);
                sub_140377F00((char **)v5, (char **)v41 + 0xFFFFFFFF);
                sub_140377F00((char **)v41 + 0xFFFFFFFF, &v73);
                sub_140370D10(&v73);
              }
              break;
            }
            ++v58;
          }
          v71 = (__int64 *)a2;
          v41 += 0xFFFFFFFF;
        }
        while ( a2 < v57 );
LABEL_133:
        v55 = v41 == v71;
      }
      if ( v55 )
        break;
      v41 += 0xFFFFFFFF;
      if ( v40 == a3 )
      {
        v5 += 0xFFFFFFFF;
        if ( v41 != v5 )
        {
          sub_14035B140(&v76, v41);
          sub_140377F00((char **)v41, (char **)v5);
          sub_140377F00((char **)v5, &v76);
          sub_140370D10(&v76);
        }
        v11 += 0xFFFFFFFF;
        sub_14035B140(&v77, v5);
        sub_140377F00((char **)v5, (char **)v11);
        sub_140377F00((char **)v11, &v77);
        sub_140370D10(&v77);
      }
      else
      {
        sub_14035B140(v78, (__int64 *)v40);
        sub_140377F00(v40, (char **)v41);
        sub_140377F00((char **)v41, v78);
        sub_140370D10(v78);
        ++v40;
      }
    }
    if ( v40 == a3 )
      break;
    if ( v11 != (__int64 *)v40 )
    {
      sub_14035B140(&v74, v5);
      sub_140377F00((char **)v5, (char **)v11);
      sub_140377F00((char **)v11, &v74);
      sub_140370D10(&v74);
    }
    ++v11;
    sub_14035B140(&v75, v5);
    sub_140377F00((char **)v5, v40);
    sub_140377F00(v40, &v75);
    sub_140370D10(&v75);
    ++v5;
    ++v40;
  }
  result = a1;
  *a1 = v5;
  a1[1] = v11;
  return result;
}

// --- End Function: sub_14755D3E0 (0x14755D3E0) ---

// --- Function: sub_14755EBA0 (0x14755EBA0) ---
char **__fastcall sub_14755EBA0(__int64 a1, __int64 a2, __int64 a3, char **a4)
{
  char **v4; // rdi
  __int64 v5; // rsi
  __int64 v7; // rbp
  __int64 v10; // rbx
  __int64 v11; // rdi
  _BYTE *v12; // r9
  __int64 v13; // rbx
  unsigned int n0x12C; // edx
  char v15; // r11
  char n0x12C_2; // r8
  unsigned int n0x12C_1; // eax
  __int64 n2; // rax
  __int64 v19; // rbx
  char *v20; // r8
  __int64 v21; // rdi
  unsigned int n0x12C_3; // edx
  char n0x12C_4; // al
  char v24; // r11
  char n0x12C_6; // r9
  unsigned int n0x12C_5; // eax

  v4 = a4;
  v5 = (a3 - 1) >> 1;
  v7 = a2;
  v10 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v11 = 2 * v10;
      v12 = *(_BYTE **)(a1 + 0x10 * v10 + 0x10);
      v13 = *(_QWORD *)(a1 + 0x10 * v10 + 8) - (_QWORD)v12;
      while ( 1 )
      {
        LOBYTE(n0x12C) = *v12 - 0x20;
        if ( (unsigned __int8)(*v12 - 0x61) > 0x19u )
          LOBYTE(n0x12C) = *v12;
        if ( (_BYTE)n0x12C == 0x5F )
          n0x12C = 0x12C;
        else
          n0x12C = (char)n0x12C;
        v15 = v12[v13];
        n0x12C_2 = v15 - 0x20;
        n0x12C_1 = 0x12C;
        if ( (unsigned __int8)(v15 - 0x61) > 0x19u )
          n0x12C_2 = v12[v13];
        if ( n0x12C_2 != 0x5F )
          n0x12C_1 = n0x12C_2;
        if ( n0x12C < n0x12C_1 )
          break;
        if ( n0x12C > n0x12C_1 || !*v12 || !v15 )
        {
          n2 = 2;
          goto LABEL_19;
        }
        ++v12;
      }
      n2 = 1;
LABEL_19:
      v10 = v11 + n2;
      sub_140377F00((char **)(a1 + 8 * v7), (char **)(a1 + 8 * (v11 + n2)));
      v7 = v10;
    }
    while ( v10 < v5 );
    v4 = a4;
  }
  if ( v10 == v5 && (a3 & 1) == 0 )
  {
    sub_140377F00((char **)(a1 + 8 * v7), (char **)(a1 + 8 * (a3 - 1)));
    v7 = a3 - 1;
  }
  if ( a2 < v7 )
  {
    do
    {
      v19 = (v7 - 1) >> 1;
      v20 = *(char **)(a1 + 8 * v19);
      v21 = *v4 - v20;
      while ( 1 )
      {
        n0x12C_3 = 0x12C;
        n0x12C_4 = *v20 - 0x20;
        if ( (unsigned __int8)(*v20 - 0x61) > 0x19u )
          n0x12C_4 = *v20;
        if ( n0x12C_4 != 0x5F )
          n0x12C_3 = n0x12C_4;
        v24 = v20[v21];
        n0x12C_6 = v24 - 0x20;
        n0x12C_5 = 0x12C;
        if ( (unsigned __int8)(v24 - 0x61) > 0x19u )
          n0x12C_6 = v20[v21];
        if ( n0x12C_6 != 0x5F )
          n0x12C_5 = n0x12C_6;
        if ( n0x12C_3 < n0x12C_5 )
          break;
        if ( n0x12C_3 > n0x12C_5 || !*v20 || !v24 )
          return sub_140377F00((char **)(a1 + 8 * v7), a4);
        ++v20;
      }
      sub_140377F00((char **)(a1 + 8 * v7), (char **)(a1 + 8 * v19));
      v4 = a4;
      v7 = (v7 - 1) >> 1;
    }
    while ( a2 < v19 );
  }
  return sub_140377F00((char **)(a1 + 8 * v7), a4);
}

// --- End Function: sub_14755EBA0 (0x14755EBA0) ---

// --- Function: sub_1475609C0 (0x1475609C0) ---
signed __int64 __fastcall sub_1475609C0(char **a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v6; // rsi
  char **v7; // rdi
  __int64 v8; // r15
  char **v9; // r14
  signed __int64 n0x10; // rax
  __int64 *v11; // rsi
  int v12; // [rsp+20h] [rbp-38h]
  __int64 v13; // [rsp+30h] [rbp-28h] BYREF
  char **v14; // [rsp+38h] [rbp-20h]
  __int64 v15; // [rsp+60h] [rbp+8h] BYREF

  v6 = a2;
  v7 = a1;
  if ( (__int64)((a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL) <= 0x100 )
    return sub_1475585A0(v7, v6, a4);
  while ( a3 > 0 )
  {
    sub_14755D3E0(&v13, v7, v6, a4);
    v8 = v13;
    v9 = v14;
    a3 = (a3 >> 2) + (a3 >> 1);
    if ( (__int64)((v13 - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v6 - (_QWORD)v14) & 0xFFFFFFFFFFFFFFF8uLL) )
    {
      sub_1475609C0(v14, v6, a3, a4);
      v6 = v8;
    }
    else
    {
      sub_1475609C0(v7, v13, a3, a4);
      v7 = v9;
    }
    if ( (__int64)((v6 - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL) <= 0x100 )
      return sub_1475585A0(v7, v6, a4);
  }
  sub_1475592E0(v7, v6, a4);
  n0x10 = (v6 - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL;
  if ( n0x10 >= 0x10 )
  {
    v11 = (__int64 *)(v6 - 8);
    do
    {
      sub_14035B140(&v15, v11);
      sub_140377F00((char **)v11, v7);
      LOBYTE(v12) = a4;
      sub_14755EBA0(v7, 0, ((char *)v11 - (char *)v7) >> 3, &v15, v12);
      sub_140370D10(&v15);
      v11 += 0xFFFFFFFF;
      n0x10 = ((unsigned __int64)v11 + 8LL - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL;
    }
    while ( n0x10 >= 0x10 );
  }
  return n0x10;
}

// --- End Function: sub_1475609C0 (0x1475609C0) ---

// --- Function: sub_147563030 (0x147563030) ---
int sub_147563030(char *Buffer, size_t MaxCount, char *Format, ...)
{
  unsigned __int64 *v6; // rax
  int result; // eax
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = (unsigned __int64 *)sub_1402A4380();
  result = _stdio_common_vsnprintf_s(*v6, Buffer, 0x400u, MaxCount, Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: sub_147563030 (0x147563030) ---

// --- Function: sub_147567A80 (0x147567A80) ---
__int64 __fastcall sub_147567A80(__int64 **a1, const char **a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v7; // rbx

  v3 = (__int64)*a1;
  v7 = (*a1)[1];
  while ( !*(_BYTE *)(v7 + 0x19) )
  {
    if ( _stricmp(*(const char **)(v7 + 0x20), *a2) >= 0 )
    {
      v3 = v7;
      v7 = *(_QWORD *)v7;
    }
    else
    {
      v7 = *(_QWORD *)(v7 + 0x10);
    }
  }
  if ( *(_BYTE *)(v3 + 0x19) || _stricmp(*a2, *(const char **)(v3 + 0x20)) < 0 || (__int64 *)v3 == *a1 )
    return *(_QWORD *)a3;
  else
    return *(_QWORD *)(v3 + 0x28);
}

// --- End Function: sub_147567A80 (0x147567A80) ---

// --- Function: sub_147584E40 (0x147584E40) ---
__int64 __fastcall sub_147584E40(char *Destination, rsize_t SizeInBytes, int a3, int a4)
{
  __int64 v4; // rsi
  __int64 v7; // rbx
  unsigned __int64 v8; // rcx
  unsigned __int64 size; // rcx
  void *v10; // rsp
  void *v11; // rsp
  int v12; // eax
  unsigned __int8 v14[16]; // [rsp+40h] [rbp+0h] BYREF
  struct _CONTEXT ContextRecord; // [rsp+50h] [rbp+10h] BYREF

  v4 = a3;
  v7 = a4;
  memset(&ContextRecord, 0, sizeof(ContextRecord));
  ContextRecord.ContextFlags = 0x100001;
  RtlCaptureContext(&ContextRecord);
  v8 = 0xC * v7 + 0xF;
  if ( v8 <= 0xC * v7 )
    v8 = 0xFFFFFFFFFFFFFF0LL;
  size = v8 & 0xFFFFFFFFFFFFFFF0uLL;
  v10 = alloca(size);
  v11 = alloca(size);
  v14[0] = 0;
  GetCurrentThread();
  v12 = sub_1475F7720(&lpCriticalSection__0, v7, (__int64)v14);
  return sub_1475E6D80((int)&lpCriticalSection__0, (int)v14, v12, v14[0], v4, Destination, SizeInBytes);
}

// --- End Function: sub_147584E40 (0x147584E40) ---

// --- Function: sub_147589BA0 (0x147589BA0) ---
void __fastcall sub_147589BA0(__int64 a1, int a2, int a3)
{
  char Destination[16384]; // [rsp+20h] [rbp-4018h] BYREF

  LogTraceConditional("----- Call Stack -----");
  memset(Destination, 0, sizeof(Destination));
  sub_147584E40(Destination, 0x4000u, a2 + 2, a3);
  LogTraceConditional((const char *)&Format_, Destination);
}

// --- End Function: sub_147589BA0 (0x147589BA0) ---

// --- Function: sub_1475AF240 (0x1475AF240) ---
__int64 *__fastcall sub_1475AF240(__int64 a1, const char *a2)
{
  __int64 *v4; // rdi
  __int64 *v5; // rbx
  __int64 *result; // rax
  char *String2; // [rsp+30h] [rbp+8h] BYREF

  if ( dword_1516B6078 )
  {
    sub_1403A2CE0((__int64)"GetConsoleCommand(\"%s\") called", a2);
    sub_147589BA0(*(_QWORD *)(a1 + 0x1F8), 0, 0x20);
  }
  CreateStringObjectFromString((void **)&String2, a2);
  v4 = *(__int64 **)(a1 + 0xD0);
  v5 = (__int64 *)v4[1];
  while ( !*((_BYTE *)v5 + 0x19) )
  {
    if ( _stricmp((const char *)v5[4], String2) >= 0 )
    {
      v4 = v5;
      v5 = (__int64 *)*v5;
    }
    else
    {
      v5 = (__int64 *)v5[2];
    }
  }
  if ( *((_BYTE *)v4 + 0x19) || _stricmp(String2, (const char *)v4[4]) < 0 )
    v4 = *(__int64 **)(a1 + 0xD0);
  sub_140370D10(&String2);
  result = 0;
  if ( v4 != *(__int64 **)(a1 + 0xD0) )
    return v4 + 5;
  return result;
}

// --- End Function: sub_1475AF240 (0x1475AF240) ---

// --- Function: sub_1475B0570 (0x1475B0570) ---
__int64 *sub_1475B0570()
{
  HMODULE hModule; // rax
  HMODULE hModule_1; // rbx

  if ( !byte_151700AE8 )
  {
    hModule = LoadLibraryA("dbghelp");
    hModule_1 = hModule;
    if ( hModule )
    {
      qword_151700A70 = (__int64)GetProcAddress(hModule, "SymInitialize");
      qword_151700A78 = (__int64)GetProcAddress(hModule_1, "SymCleanup");
      qword_151700A80 = (__int64)GetProcAddress(hModule_1, "SymSetOptions");
      qword_151700A88 = (__int64)GetProcAddress(hModule_1, "SymGetOptions");
      qword_151700A90 = (__int64)GetProcAddress(hModule_1, "StackWalkEx");
      qword_151700A98 = (__int64)GetProcAddress(hModule_1, "StackWalk64");
      qword_151700AA0 = (__int64)GetProcAddress(hModule_1, "SymEnumerateModules64");
      qword_151700AA8 = (__int64)GetProcAddress(hModule_1, "SymFunctionTableAccess64");
      qword_151700AB0 = (__int64)GetProcAddress(hModule_1, "SymGetModuleInfo64");
      qword_151700AB8 = (__int64)GetProcAddress(hModule_1, "SymGetModuleBase64");
      qword_151700AC0 = (__int64)GetProcAddress(hModule_1, "SymFromAddr");
      qword_151700AC8 = (__int64)GetProcAddress(hModule_1, "SymFromInlineContext");
      qword_151700AD0 = (__int64)GetProcAddress(hModule_1, "SymGetLineFromAddr64");
      qword_151700AD8 = (__int64)GetProcAddress(hModule_1, "SymGetLineFromInlineContext");
      qword_151700AE0 = (__int64)GetProcAddress(hModule_1, "ImageDirectoryEntryToDataEx");
    }
    byte_151700AE8 = 1;
  }
  return &qword_151700A70;
}

// --- End Function: sub_1475B0570 (0x1475B0570) ---

// --- Function: sub_1475C3FA0 (0x1475C3FA0) ---
__int64 __fastcall sub_1475C3FA0(LPCRITICAL_SECTION lpCriticalSection)
{
  HANDLE CurrentProcess; // rbx
  __int64 *v3; // rax
  FARPROC LockSemaphore; // rsi
  __int64 *v5; // rax
  int v6; // ebx
  __int64 *v7; // rax
  HANDLE v8; // rbx
  __int64 *v9; // rax
  __int64 *v10; // rax
  int v11; // eax
  HMODULE hModule; // rax
  HMODULE hModule_1; // rbx
  HANDLE OwningThread; // rax
  unsigned __int8 LockCount; // bl
  char Drive[8]; // [rsp+30h] [rbp-828h] BYREF
  __int16 v18; // [rsp+38h] [rbp-820h]
  char Dir[1024]; // [rsp+40h] [rbp-818h] BYREF
  CHAR p_ConsoleTitle[1024]; // [rsp+440h] [rbp-418h] BYREF

  EnterCriticalSection(lpCriticalSection);
  if ( !LOBYTE(lpCriticalSection[1].LockCount) || RecursionCount != lpCriticalSection[1].RecursionCount )
  {
    lpCriticalSection[1].RecursionCount = RecursionCount;
    EnterCriticalSection(lpCriticalSection);
    CurrentProcess = GetCurrentProcess();
    v3 = sub_1475B0570();
    ((void (__fastcall *)(HANDLE))v3[1])(CurrentProcess);
    LOBYTE(lpCriticalSection[1].LockCount) = 0;
    LeaveCriticalSection(lpCriticalSection);
    memset(&lpCriticalSection[2], 0, 0x400u);
    if ( GetModuleFileNameA(0, (LPSTR)&lpCriticalSection[2], 0x400u) )
    {
      memset(Dir, 0, sizeof(Dir));
      LockSemaphore = 0;
      *(_QWORD *)Drive = 0;
      v18 = 0;
      splitpath((const char *)&lpCriticalSection[2], Drive, Dir, 0, 0);
      memset(p_ConsoleTitle, 0, sizeof(p_ConsoleTitle));
      sub_143C23AA0(p_ConsoleTitle, "%s%s;.;", Drive, Dir);
      v5 = sub_1475B0570();
      v6 = ((__int64 (*)(void))v5[3])();
      v7 = sub_1475B0570();
      ((void (__fastcall *)(_QWORD))v7[2])(v6 | 0x14u);
      v8 = GetCurrentProcess();
      v9 = sub_1475B0570();
      if ( ((unsigned int (__fastcall *)(HANDLE, CHAR *, __int64))*v9)(v8, p_ConsoleTitle, 1) )
      {
        v10 = sub_1475B0570();
        v11 = ((__int64 (__fastcall *)(HANDLE, __int64 (__fastcall *)(charNode *__hidden), _QWORD))v10[6])(
                v8,
                charNode::raw_length,
                0);
        LOBYTE(lpCriticalSection[1].LockCount) = v11 != 0;
        if ( v11 )
        {
          if ( BYTE1(lpCriticalSection[1].LockCount) )
          {
            hModule = GetModuleHandleA("ntdll.dll");
            hModule_1 = hModule;
            if ( hModule )
            {
              lpCriticalSection[1].OwningThread = GetProcAddress(hModule, "LdrRegisterDllNotification");
              LockSemaphore = GetProcAddress(hModule_1, "LdrUnregisterDllNotification");
            }
            else
            {
              lpCriticalSection[1].OwningThread = 0;
            }
            OwningThread = lpCriticalSection[1].OwningThread;
            lpCriticalSection[1].LockSemaphore = LockSemaphore;
            if ( OwningThread )
            {
              if ( LockSemaphore )
              {
                ((void (__fastcall *)(_QWORD, __int64 (__fastcall *)(int), _QWORD, ULONG_PTR *))OwningThread)(
                  0,
                  sub_1475C6BC0,
                  0,
                  &lpCriticalSection[1].SpinCount);
                if ( lpCriticalSection[1].SpinCount )
                  BYTE1(lpCriticalSection[1].LockCount) = 0;
              }
            }
          }
        }
      }
    }
  }
  LockCount = lpCriticalSection[1].LockCount;
  LeaveCriticalSection(lpCriticalSection);
  return LockCount;
}

// --- End Function: sub_1475C3FA0 (0x1475C3FA0) ---

// --- Function: sub_1475CC5F0 (0x1475CC5F0) ---
char __fastcall sub_1475CC5F0(
        LPCRITICAL_SECTION lpCriticalSection,
        __int64 *a2,
        char *DstBuf,
        size_t SizeInBytes,
        char *Buffer,
        size_t BufferCount,
        _DWORD *a7,
        __int64 *a8,
        char a9)
{
  bool v13; // r15
  __int64 *v14; // rax
  __int64 v15; // rdx
  int v16; // eax
  __int64 *v17; // rax
  __int64 v18; // rdx
  int v19; // eax
  char v21; // [rsp+40h] [rbp-C0h]
  __int64 v22; // [rsp+48h] [rbp-B8h] BYREF
  HANDLE CurrentProcess; // [rsp+50h] [rbp-B0h]
  __int64 *v24; // [rsp+58h] [rbp-A8h]
  LPCRITICAL_SECTION lpCriticalSectiona; // [rsp+60h] [rbp-A0h]
  __m256 v26; // [rsp+68h] [rbp-98h] BYREF
  __int64 v27; // [rsp+88h] [rbp-78h]
  _DWORD v28[152]; // [rsp+90h] [rbp-70h] BYREF

  v24 = a8;
  lpCriticalSectiona = lpCriticalSection;
  EnterCriticalSection(lpCriticalSection);
  sub_1475C3FA0(lpCriticalSection);
  *DstBuf = 0;
  if ( Buffer )
    *Buffer = 0;
  if ( a7 )
    *a7 = 0;
  *a8 = *a2;
  CurrentProcess = GetCurrentProcess();
  v21 = 0;
  v13 = a9 && (*((_BYTE *)a2 + 9) & 2) != 0;
  memset(v28, 0, 0x259u);
  v28[0] = 0x58;
  v28[0x14] = 0x200;
  v22 = 0;
  v14 = sub_1475B0570();
  v15 = *a2;
  if ( a9 )
    v16 = ((__int64 (__fastcall *)(HANDLE, __int64, _QWORD, __int64 *, _DWORD *))v14[0xB])(
            CurrentProcess,
            v15,
            *((unsigned int *)a2 + 2),
            &v22,
            v28);
  else
    v16 = ((__int64 (__fastcall *)(HANDLE, __int64, __int64 *, _DWORD *))v14[0xA])(CurrentProcess, v15, &v22, v28);
  if ( !v16 )
  {
    snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, "0x%016llX", *a2);
    goto LABEL_20;
  }
  if ( v13 )
  {
    snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, "[inlined] %s()", (const char *)&v28[0x15]);
    goto LABEL_18;
  }
  if ( v28[7] )
  {
    snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, "%s()+0x%llx", (const char *)&v28[0x15], v22);
LABEL_18:
    v21 = 1;
    *v24 = *a2 - v22;
    goto LABEL_20;
  }
  snprintf_s(
    DstBuf,
    SizeInBytes,
    0xFFFFFFFFFFFFFFFFuLL,
    "0x%016llX (??? %s+0x%llx)",
    *a2,
    (const char *)&v28[0x15],
    v22);
  *v24 = *a2 - v22;
LABEL_20:
  if ( Buffer && v21 )
  {
    v26 = (__m256)0LL;
    LODWORD(v26.m256_f32[0]) = 0x28;
    v27 = 0;
    LODWORD(v22) = 0;
    __asm { vzeroupper }
    v17 = sub_1475B0570();
    v18 = *a2;
    if ( a9 )
      v19 = ((__int64 (__fastcall *)(HANDLE, __int64, _QWORD, _QWORD, __int64 *, __m256 *))v17[0xD])(
              CurrentProcess,
              v18,
              *((unsigned int *)a2 + 2),
              0,
              &v22,
              &v26);
    else
      v19 = ((__int64 (__fastcall *)(HANDLE, __int64, __int64 *, __m256 *))v17[0xC])(CurrentProcess, v18, &v22, &v26);
    if ( v19 )
    {
      snprintf_s(Buffer, BufferCount, 0xFFFFFFFFFFFFFFFFuLL, (const char *)&Format_, *(_QWORD *)&v26.m256_f32[6]);
      if ( a7 )
        *a7 = LODWORD(v26.m256_f32[4]);
    }
  }
  LeaveCriticalSection(lpCriticalSectiona);
  return 1;
}

// --- End Function: sub_1475CC5F0 (0x1475CC5F0) ---

// --- Function: sub_1475DCD10 (0x1475DCD10) ---
void __fastcall sub_1475DCD10(__int64 a1, __int64 a2)
{
  char *v2; // rdi
  char v4; // r14
  char **v5; // r13
  char n0x5C; // bl
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // rsi
  size_t Size; // rbx
  __int64 v11; // rax
  void **v12; // rax
  bool v13; // bl
  char v14; // si
  char *Size_1; // rax
  void **v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  bool v19; // r14
  _BYTE *v20; // rax
  void **v21; // rcx
  ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  __int64 v23; // rbx
  char *v24; // rdi
  __int64 v25; // r12
  char **v26; // r15
  unsigned int v27; // r13d
  char v28; // r14
  int v29; // esi
  bool v30; // zf
  unsigned int v31; // eax
  size_t Size_2; // rax
  size_t Size_3; // rbx
  __int64 v34; // rax
  __int64 v35; // rax
  const void **p_String2; // rdx
  int v37; // eax
  char *v38; // rsi
  int v39; // ecx
  std::array<int,2> *v40; // r14
  char **_Count_7; // r15
  char *v42; // rbx
  size_t MaxCount_1; // rax
  __int64 v44; // rbx
  unsigned __int64 v45; // r15
  unsigned __int64 v46; // rcx
  unsigned __int64 v47; // rdx
  unsigned __int64 _Count; // r12
  std::array<int,2> *v49; // r13
  __int64 *v50; // rbx
  std::array<int,2> *j; // rbx
  size_t MaxCount; // rax
  __int64 v53; // rbx
  unsigned __int64 v54; // rcx
  unsigned __int64 v55; // rdx
  __int64 *v56; // rbx
  std::array<int,2> *i; // rbx
  std::array<int,2> *v58; // rax
  __int64 v59; // rsi
  __int64 v60; // rdi
  char v61; // r15
  __int64 v62; // r12
  _QWORD *v63; // rax
  _QWORD *ii; // rbx
  char **_Count_5; // r15
  size_t MaxCount_2; // rax
  __int64 v67; // r15
  unsigned __int64 v68; // rcx
  unsigned __int64 v69; // rdx
  unsigned __int64 _Count_2; // r13
  char *v71; // r12
  __int64 *v72; // r15
  signed __int64 v73; // r12
  std::array<int,2> *m; // r15
  std::array<int,2> *v75; // rax
  __int64 **v76; // rax
  __int64 n; // rax
  __int64 *v78; // rcx
  _QWORD *v79; // rax
  _QWORD *mm; // rbx
  char **_Count_6; // r12
  __int64 v82; // r15
  size_t MaxCount_3; // rax
  __int64 v84; // rax
  __int64 v85; // r15
  unsigned __int64 v86; // rcx
  unsigned __int64 v87; // rdx
  unsigned __int64 _Count_3; // r13
  char *v89; // r12
  __int64 *v90; // r15
  signed __int64 v91; // r12
  std::array<int,2> *jj; // r15
  std::array<int,2> *v93; // rax
  __int64 **v94; // rax
  __int64 kk; // rax
  __int64 *v96; // rcx
  unsigned __int64 v97; // r8
  signed __int64 v98; // r8
  char **v99; // r15
  const char **v100; // rbx
  __int64 *v101; // rdx
  __int64 *v102; // r12
  __int64 v103; // r13
  unsigned __int64 v104; // rdx
  unsigned __int64 v105; // rcx
  unsigned __int64 _Count_1; // rax
  __int64 *v107; // rdx
  __int64 v108; // r13
  __int64 *v109; // rcx
  _QWORD *v110; // r8
  char **v111; // r15
  int v112; // eax
  char **v113; // rdx
  int v114; // ebx
  char **v115; // rdx
  std::array<int,2> *k; // rbx
  std::array<int,2> *v117; // rax
  _QWORD *v118; // rbx
  _QWORD *v119; // rdi
  char v120; // [rsp+20h] [rbp-E0h]
  unsigned __int8 v121; // [rsp+21h] [rbp-DFh]
  bool v122; // [rsp+22h] [rbp-DEh]
  __int64 v123; // [rsp+28h] [rbp-D8h] BYREF
  void *v124; // [rsp+30h] [rbp-D0h] BYREF
  void *v125[2]; // [rsp+38h] [rbp-C8h] BYREF
  char *v126; // [rsp+48h] [rbp-B8h]
  char *String2; // [rsp+50h] [rbp-B0h] BYREF
  char **_Count_4; // [rsp+58h] [rbp-A8h]
  std::array<int,2> *v129; // [rsp+60h] [rbp-A0h]
  char **v130; // [rsp+68h] [rbp-98h]
  unsigned int v131; // [rsp+70h] [rbp-90h]
  const char *String2_1; // [rsp+78h] [rbp-88h] BYREF
  int v133; // [rsp+80h] [rbp-80h]
  int v134; // [rsp+84h] [rbp-7Ch]
  __int64 v135; // [rsp+88h] [rbp-78h] BYREF
  __int64 v136; // [rsp+90h] [rbp-70h]
  char *v137; // [rsp+98h] [rbp-68h] BYREF
  void *v138; // [rsp+A0h] [rbp-60h] BYREF
  void *v139[2]; // [rsp+A8h] [rbp-58h] BYREF
  __int64 v140; // [rsp+B8h] [rbp-48h]
  _QWORD v141[11]; // [rsp+C0h] [rbp-40h] BYREF
  char v142; // [rsp+118h] [rbp+18h]

  v2 = *(char **)a2;
  v136 = a1;
  v4 = 0;
  v130 = (char **)a2;
  v5 = (char **)a2;
  v134 = 0;
  n0x5C = *v2;
  v7 = sub_1403E7A60((_QWORD *)(a2 + 8));
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  v9 = (__int64)&v2[n0x5C == 0x5C];
  do
    ++v8;
  while ( *(_BYTE *)(v9 + v8) );
  v13 = 1;
  if ( v7 <= v8 )
  {
    Size = sub_1403E7A60(v5 + 1);
    v11 = sub_1403E62A0((__int64 *)v5 + 1, 0x20, 0xFFFFFFFFFFFFFFFFuLL);
    v12 = sub_1403EAE30((__int64 *)v5 + 1, (void **)&v123, v11 + 1, Size);
    v4 = 1;
    if ( sub_1403EAD20(v9, (const char *)*v12) )
      v13 = 0;
  }
  if ( (v4 & 1) != 0 )
    sub_140370D10(&v123);
  if ( v13 )
  {
    *((_DWORD *)v5 + 4) = 0;
    assignCStringToStringStructure((void **)v5 + 1, &p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  if ( !sub_1403BFA30(v5) )
  {
    sub_14035B3E0(&v137);
    v14 = 0;
    if ( sub_1403E62A0((__int64 *)v5, 0x20, 0xFFFFFFFFFFFFFFFFuLL) != 0xFFFFFFFFFFFFFFFFuLL )
    {
      Size_1 = sub_1403E61D0((__int64 *)v5, 0x20, 0);
      v16 = sub_1403EAE30((__int64 *)v5, (void **)&v123, 0, (size_t)Size_1);
      sub_140377F00(&v137, (char **)v16);
      sub_140370D10(&v123);
      if ( !byte_149B4FE80 )
      {
        v17 = sub_1475AF240(a1, v137);
        if ( v17 )
        {
          if ( (*(_DWORD *)(v17 + 0x20) & 0x1000) != 0 )
          {
            if ( Parameter_2 )
            {
              v18 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_2 + 0x58LL))(Parameter_2);
              if ( v18 )
                (*(void (__fastcall **)(__int64, char **, _QWORD))(*(_QWORD *)v18 + 0x20LL))(
                  v18,
                  v5,
                  *(_QWORD *)(a1 + 0xC8));
            }
LABEL_192:
            sub_140370D10(&v137);
            return;
          }
        }
      }
      v14 = 1;
    }
    v19 = 0;
    v122 = 0;
    if ( qword_149B4FDB8 && qword_149B4FD30 )
    {
      (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)qword_149B4FD30 + 0x28LL))(qword_149B4FD30, v141);
      v19 = (v142 & 7) != 0;
      v122 = v19;
      sub_14059AF30(v141);
    }
    if ( *((_DWORD *)v5 + 4)
      || (v121 = 1, (unsigned int)sub_1403E47B0((unsigned __int8 **)v5 + 1, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source)) )
    {
      v121 = 0;
    }
    if ( !*((_DWORD *)v5 + 4) )
    {
      if ( !sub_1403E7A60(v5) )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (ULONG_PTR *)&p_p_p_p_p_p_p_p_p_p_p_Source;
        v21 = (void **)(v5 + 1);
        goto LABEL_32;
      }
      v20 = (_BYTE *)std::unique_ptr<char [0]>::operator[](v5, 0);
      v21 = (void **)(v5 + 1);
      if ( *v20 == 0x5C )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (ULONG_PTR *)(*v5 + 1);
LABEL_32:
        assignCStringToStringStructure(v21, p_p_p_p_p_p_p_p_p_p_p_p_Source);
        goto LABEL_33;
      }
      copyStringStructure((char **)v21, v5);
    }
LABEL_33:
    v23 = 0;
    v120 = 0;
    v24 = 0;
    v140 = 0;
    v126 = 0;
    *(_OWORD *)v139 = 0;
    *(_OWORD *)v125 = 0;
    if ( v14 )
    {
      if ( (unsigned __int8)sub_1475EC4A0(a1, v19, v137) )
      {
        v123 = 0;
        v123 = sub_147567A80((__int64 **)(a1 + 0x140), (const char **)&v137, (__int64)&v123);
        v25 = v123;
        if ( v123 )
        {
          v26 = v130;
          v27 = 0;
          v131 = 0;
          v28 = 0;
          v29 = 0;
          if ( sub_1403E7A60(v130 + 1) )
          {
            do
            {
              if ( *(_BYTE *)std::unique_ptr<char [0]>::operator[](v26 + 1, v23) == 0x20 )
              {
                v30 = v28 == 0;
                v31 = v27 + 1;
                v28 = 1;
                if ( !v30 )
                  v31 = v27;
                v27 = v31;
              }
              else
              {
                v28 = 0;
              }
              v23 = ++v29;
            }
            while ( v29 < (unsigned __int64)sub_1403E7A60(v26 + 1) );
            v131 = v27;
          }
          Size_2 = sub_1403E62A0((__int64 *)v26 + 1, 0x20, 0xFFFFFFFFFFFFFFFFuLL);
          sub_1403EAE30((__int64 *)v26 + 1, (void **)&v135, 0, Size_2);
          Size_3 = sub_1403E7A60(v26 + 1);
          v34 = sub_1403E62A0((__int64 *)v26 + 1, 0x20, 0xFFFFFFFFFFFFFFFFuLL);
          sub_1403EAE30((__int64 *)v26 + 1, (void **)&String2_1, v34 + 1, Size_3);
          v35 = sub_1403EAD20(v135, "g_spawnentity");
          p_String2 = (const void **)&String2_1;
          if ( !v35 )
            p_String2 = (const void **)&v135;
          sub_14035B160(&v138, p_String2);
          if ( (*(int (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x18LL))(v25) >= (int)v27 )
          {
            v37 = (*(__int64 (__fastcall **)(__int64, _QWORD, void **))(*(_QWORD *)v25 + 8LL))(v25, v27, &v138);
            v38 = (char *)v125[1];
            v39 = 0;
            v40 = (std::array<int,2> *)v125[0];
            v134 = v37;
            v133 = 0;
            if ( v37 > 0 )
            {
              _Count_7 = v26 + 1;
              _Count_4 = _Count_7;
              while ( 1 )
              {
                v42 = (char *)(*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, void **))(*(_QWORD *)v25 + 0x10LL))(
                                v25,
                                (unsigned int)v39,
                                v27,
                                &v138);
                sub_14035B160(&v124, (const void **)&v135);
                sub_140384840(&v124, " ");
                sub_14035B160((void **)&String2, (const void **)&v124);
                sub_140384840((void **)&String2, v42);
                sub_140370D10(&v124);
                if ( dword_149AFF620 )
                  break;
                MaxCount = sub_1403E7A60(_Count_7);
                if ( !_strnicmp(*_Count_7, String2, MaxCount) )
                {
                  v120 = 1;
                  if ( v38 == v24 )
                  {
                    v53 = (v38 - (char *)v40) >> 3;
                    if ( v53 == 0x1FFFFFFFFFFFFFFFLL )
LABEL_195:
                      unknown_libname_10();
                    v45 = v53 + 1;
                    v129 = (std::array<int,2> *)(v53 + 1);
                    v54 = (v24 - (char *)v40) >> 3;
                    v55 = v54 >> 1;
                    if ( v54 <= 0x1FFFFFFFFFFFFFFFLL - (v54 >> 1) )
                    {
                      _Count = v55 + v54;
                      if ( v55 + v54 < v45 )
                        _Count = v53 + 1;
                    }
                    else
                    {
                      _Count = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    v49 = std::allocator<std::array<int,2>>::allocate(
                            (std::allocator<std::array<int,2> > *)v125,
                            _Count);
                    sub_14035B160((void **)v49 + v53, (const void **)&String2);
                    v56 = (__int64 *)v40;
                    if ( v40 != (std::array<int,2> *)v38 )
                    {
                      do
                      {
                        sub_14035B140((__int64 *)((char *)v56 + v49 - v40), v56);
                        ++v56;
                      }
                      while ( v56 != (__int64 *)v38 );
                      v45 = (unsigned __int64)v129;
                    }
                    if ( v40 )
                    {
                      for ( i = v40; i != (std::array<int,2> *)v38; i = (std::array<int,2> *)((char *)i + 8) )
                        sub_140370D10(i);
LABEL_80:
                      v58 = v40;
                      if ( ((v24 - (char *)v40) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
                      {
                        v40 = (std::array<int,2> *)*((_QWORD *)v40 + 0xFFFFFFFF);
                        if ( (unsigned __int64)(v58 - v40 - 8) > 0x1F )
                          invalid_parameter_noinfo_noreturn();
                      }
                      sub_1402A3D30(v40);
                    }
LABEL_83:
                    v59 = 8 * v45;
                    v125[0] = v49;
                    _Count_7 = _Count_4;
                    v60 = 8 * _Count;
                    v25 = v123;
                    v38 = (char *)v49 + v59;
                    v24 = (char *)v49 + v60;
                    v40 = v49;
                    v27 = v131;
                    v126 = v24;
LABEL_84:
                    v125[1] = v38;
                    goto LABEL_85;
                  }
LABEL_52:
                  sub_14035B160((void **)v38, (const void **)&String2);
                  v38 += 8;
                  goto LABEL_84;
                }
LABEL_85:
                sub_140370D10(&String2);
                v39 = v133 + 1;
                v133 = v39;
                if ( v39 >= v134 )
                  goto LABEL_86;
              }
              MaxCount_1 = sub_1403E7A60(_Count_7);
              if ( _strnicmp(*_Count_7, String2, MaxCount_1) )
              {
                if ( sub_1403EAD20((__int64)String2, String2_1) )
                {
                  v120 = 1;
                  sub_14042FD60(v139, &String2);
                }
                goto LABEL_85;
              }
              v120 = 1;
              if ( v38 == v24 )
              {
                v44 = (v38 - (char *)v40) >> 3;
                if ( v44 == 0x1FFFFFFFFFFFFFFFLL )
                  goto LABEL_195;
                v45 = v44 + 1;
                v129 = (std::array<int,2> *)(v44 + 1);
                v46 = (v24 - (char *)v40) >> 3;
                v47 = v46 >> 1;
                if ( v46 <= 0x1FFFFFFFFFFFFFFFLL - (v46 >> 1) )
                {
                  _Count = v47 + v46;
                  if ( v47 + v46 < v45 )
                    _Count = v44 + 1;
                }
                else
                {
                  _Count = 0x1FFFFFFFFFFFFFFFLL;
                }
                v49 = std::allocator<std::array<int,2>>::allocate((std::allocator<std::array<int,2> > *)v125, _Count);
                sub_14035B160((void **)v49 + v44, (const void **)&String2);
                v50 = (__int64 *)v40;
                if ( v40 != (std::array<int,2> *)v38 )
                {
                  do
                  {
                    sub_14035B140((__int64 *)((char *)v50 + v49 - v40), v50);
                    ++v50;
                  }
                  while ( v50 != (__int64 *)v38 );
                  v45 = (unsigned __int64)v129;
                }
                if ( v40 )
                {
                  for ( j = v40; j != (std::array<int,2> *)v38; j = (std::array<int,2> *)((char *)j + 8) )
                    sub_140370D10(j);
                  goto LABEL_80;
                }
                goto LABEL_83;
              }
              goto LABEL_52;
            }
LABEL_86:
            sub_140370D10(&v138);
            sub_140370D10(&String2_1);
            sub_140370D10(&v135);
            v61 = v120;
            if ( v120 )
            {
LABEL_155:
              v97 = (v38 - (char *)v40) >> 3;
              if ( v97 > 1 )
                sub_1475609C0(v40, v38, v97, v121);
              if ( v61 )
              {
                v98 = ((char *)v139[1] - (char *)v139[0]) >> 3;
                if ( v98 )
                {
                  sub_1475609C0(v139[0], v139[1], v98, v121);
                  sub_1403F0B60(
                    (__int64 *)v125,
                    (__int64 *)v38,
                    (__int64)v139[0],
                    ((char *)v139[1] - (char *)v139[0]) >> 3);
                  v24 = v126;
                  v38 = (char *)v125[1];
                  v40 = (std::array<int,2> *)v125[0];
                }
              }
              if ( v121 && v40 != (std::array<int,2> *)v38 )
              {
                CreateStringObjectFromString((void **)&v123, " ");
                v99 = v130 + 3;
                sub_1403E8630(v130 + 3, &v123);
                sub_140370D10(&v123);
                v100 = (const char **)v40;
                do
                {
                  CreateStringObjectFromString(&v124, *v100);
                  v101 = (__int64 *)v99[2];
                  v102 = (__int64 *)v99[1];
                  if ( v102 == v101 )
                  {
                    v103 = ((char *)v102 - *v99) >> 3;
                    if ( v103 == 0x1FFFFFFFFFFFFFFFLL )
                      unknown_libname_10();
                    v104 = ((char *)v101 - *v99) >> 3;
                    String2_1 = (const char *)(v103 + 1);
                    v105 = v104 >> 1;
                    if ( v104 <= 0x1FFFFFFFFFFFFFFFLL - (v104 >> 1) )
                    {
                      _Count_1 = v104 + v105;
                      if ( v104 + v105 < v103 + 1 )
                        _Count_1 = v103 + 1;
                    }
                    else
                    {
                      _Count_1 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    _Count_4 = (char **)_Count_1;
                    v123 = (__int64)std::allocator<std::array<int,2>>::allocate(
                                      (std::allocator<std::array<int,2> > *)v99,
                                      _Count_1);
                    v129 = (std::array<int,2> *)(v123 + 8 * v103);
                    sub_14035B140(v129, (__int64 *)&v124);
                    v107 = (__int64 *)v99[1];
                    v108 = v123;
                    v109 = (__int64 *)*v99;
                    v110 = (_QWORD *)v123;
                    if ( v102 != v107 )
                    {
                      sub_140350530(v109, v102, (_QWORD *)v123);
                      v109 = v102;
                      v107 = (__int64 *)v99[1];
                      v110 = (_QWORD *)((char *)v129 + 8);
                    }
                    sub_140350530(v109, v107, v110);
                    sub_1403DF810((__int64 *)v99, v108, (__int64)String2_1, (__int64)_Count_4);
                  }
                  else
                  {
                    sub_14035B140(v99[1], (__int64 *)&v124);
                    v99[1] += 8;
                  }
                  sub_140370D10(&v124);
                  ++v100;
                }
                while ( v100 != (const char **)v38 );
              }
              v111 = v130;
              v112 = 0;
              v113 = (char **)v40;
              if ( v40 == (std::array<int,2> *)v38 )
              {
LABEL_178:
                if ( *((int *)v130 + 4) > 0 )
                {
                  v115 = v130 + 1;
                  *((_DWORD *)v130 + 4) = 0;
                  copyStringStructure(v111, v115);
                  sub_1475DCD10(v136, v111);
                }
              }
              else
              {
                while ( 1 )
                {
                  v114 = v112 + 1;
                  if ( *((_DWORD *)v130 + 4) <= v112 )
                    break;
                  ++v113;
                  ++v112;
                  if ( v113 == (char **)v38 )
                    goto LABEL_178;
                }
                copyStringStructure(v130, v113);
                sub_140384840((void **)v111, " ");
                *((_DWORD *)v111 + 4) = v114;
              }
              if ( v40 )
              {
                for ( k = v40; k != (std::array<int,2> *)v38; k = (std::array<int,2> *)((char *)k + 8) )
                  sub_140370D10(k);
                v117 = v40;
                if ( ((v24 - (char *)v40) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
                {
                  v40 = (std::array<int,2> *)*((_QWORD *)v40 + 0xFFFFFFFF);
                  if ( (unsigned __int64)(v117 - v40 - 8) > 0x1F )
                    invalid_parameter_noinfo_noreturn();
                }
                sub_1402A3D30(v40);
              }
              v118 = v139[0];
              if ( v139[0] )
              {
                v119 = v139[1];
                if ( v139[0] != v139[1] )
                {
                  do
                    sub_140370D10(v118++);
                  while ( v118 != v119 );
                }
                sub_1403A3120((__int64)v139, v139[0], (v140 - (unsigned __int64)v139[0]) & 0xFFFFFFFFFFFFFFF8uLL);
                *(_OWORD *)v139 = 0;
                v140 = 0;
              }
              goto LABEL_192;
            }
            v5 = v130;
LABEL_91:
            v62 = v136;
            v63 = *(_QWORD **)(v136 + 0xD0);
            ii = (_QWORD *)*v63;
            if ( (_QWORD *)*v63 != v63 )
            {
              _Count_5 = v5 + 1;
              _Count_4 = v5 + 1;
              do
              {
                MaxCount_2 = sub_1403E7A60(_Count_5);
                if ( !_strnicmp(*_Count_5, (const char *)ii[4], MaxCount_2)
                  && (unsigned __int8)sub_1475EC4A0(v62, v122, ii[6]) )
                {
                  CreateStringObjectFromString(&v124, (const char *)ii[4]);
                  if ( v38 == v24 )
                  {
                    v67 = (v38 - (char *)v40) >> 3;
                    if ( v67 == 0x1FFFFFFFFFFFFFFFLL )
                      unknown_libname_10();
                    v123 = v67 + 1;
                    v68 = (v24 - (char *)v40) >> 3;
                    v69 = v68 >> 1;
                    if ( v68 <= 0x1FFFFFFFFFFFFFFFLL - (v68 >> 1) )
                    {
                      _Count_2 = v69 + v68;
                      if ( v69 + v68 < v67 + 1 )
                        _Count_2 = v67 + 1;
                    }
                    else
                    {
                      _Count_2 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    v129 = std::allocator<std::array<int,2>>::allocate(
                             (std::allocator<std::array<int,2> > *)v125,
                             _Count_2);
                    v71 = (char *)v129;
                    sub_14035B140((_QWORD *)v129 + v67, (__int64 *)&v124);
                    v72 = (__int64 *)v40;
                    if ( v40 != (std::array<int,2> *)v38 )
                    {
                      v73 = v71 - (char *)v40;
                      do
                      {
                        sub_14035B140((__int64 *)((char *)v72 + v73), v72);
                        ++v72;
                      }
                      while ( v72 != (__int64 *)v38 );
                      v71 = (char *)v129;
                    }
                    if ( v40 )
                    {
                      for ( m = v40; m != (std::array<int,2> *)v38; m = (std::array<int,2> *)((char *)m + 8) )
                        sub_140370D10(m);
                      v75 = v40;
                      if ( ((v24 - (char *)v40) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
                      {
                        v40 = (std::array<int,2> *)*((_QWORD *)v40 + 0xFFFFFFFF);
                        if ( (unsigned __int64)(v75 - v40 - 8) > 0x1F )
                          invalid_parameter_noinfo_noreturn();
                      }
                      sub_1402A3D30(v40);
                    }
                    v24 = &v71[8 * _Count_2];
                    _Count_5 = _Count_4;
                    v40 = (std::array<int,2> *)v71;
                    v125[0] = v71;
                    v126 = v24;
                    v38 = &v71[8 * v123];
                    v62 = v136;
                  }
                  else
                  {
                    sub_14035B140(v38, (__int64 *)&v124);
                    v38 += 8;
                  }
                  v125[1] = v38;
                  sub_140370D10(&v124);
                }
                v76 = (__int64 **)ii[2];
                if ( *((_BYTE *)v76 + 0x19) )
                {
                  for ( n = ii[1]; !*(_BYTE *)(n + 0x19); n = *(_QWORD *)(n + 8) )
                  {
                    if ( ii != *(_QWORD **)(n + 0x10) )
                      break;
                    ii = (_QWORD *)n;
                  }
                  ii = (_QWORD *)n;
                }
                else
                {
                  v78 = *v76;
                  for ( ii = (_QWORD *)ii[2]; !*((_BYTE *)v78 + 0x19); v78 = (__int64 *)*v78 )
                    ii = v78;
                }
              }
              while ( ii != *(_QWORD **)(v62 + 0xD0) );
            }
            v79 = *(_QWORD **)(v62 + 0xF0);
            mm = (_QWORD *)*v79;
            if ( (_QWORD *)*v79 != v79 )
            {
              _Count_6 = v130 + 1;
              _Count_4 = v130 + 1;
              do
              {
                v82 = mm[5];
                MaxCount_3 = sub_1403E7A60(_Count_6);
                if ( !_strnicmp(*_Count_6, (const char *)mm[4], MaxCount_3) )
                {
                  v84 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v82 + 0x70LL))(v82);
                  if ( (unsigned __int8)sub_1475EC4A0(v136, v122, v84) )
                  {
                    CreateStringObjectFromString(&v124, (const char *)mm[4]);
                    if ( v38 == v24 )
                    {
                      v85 = (v38 - (char *)v40) >> 3;
                      if ( v85 == 0x1FFFFFFFFFFFFFFFLL )
                        unknown_libname_10();
                      v123 = v85 + 1;
                      v86 = (v24 - (char *)v40) >> 3;
                      v87 = v86 >> 1;
                      if ( v86 <= 0x1FFFFFFFFFFFFFFFLL - (v86 >> 1) )
                      {
                        _Count_3 = v87 + v86;
                        if ( v87 + v86 < v85 + 1 )
                          _Count_3 = v85 + 1;
                      }
                      else
                      {
                        _Count_3 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      v129 = std::allocator<std::array<int,2>>::allocate(
                               (std::allocator<std::array<int,2> > *)v125,
                               _Count_3);
                      v89 = (char *)v129;
                      sub_14035B140((_QWORD *)v129 + v85, (__int64 *)&v124);
                      v90 = (__int64 *)v40;
                      if ( v40 != (std::array<int,2> *)v38 )
                      {
                        v91 = v89 - (char *)v40;
                        do
                        {
                          sub_14035B140((__int64 *)((char *)v90 + v91), v90);
                          ++v90;
                        }
                        while ( v90 != (__int64 *)v38 );
                        v89 = (char *)v129;
                      }
                      if ( v40 )
                      {
                        for ( jj = v40; jj != (std::array<int,2> *)v38; jj = (std::array<int,2> *)((char *)jj + 8) )
                          sub_140370D10(jj);
                        v93 = v40;
                        if ( ((v24 - (char *)v40) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
                        {
                          v40 = (std::array<int,2> *)*((_QWORD *)v40 + 0xFFFFFFFF);
                          if ( (unsigned __int64)(v93 - v40 - 8) > 0x1F )
                            invalid_parameter_noinfo_noreturn();
                        }
                        sub_1402A3D30(v40);
                      }
                      v24 = &v89[8 * _Count_3];
                      v40 = (std::array<int,2> *)v89;
                      v125[0] = v89;
                      v126 = v24;
                      v38 = &v89[8 * v123];
                      _Count_6 = _Count_4;
                    }
                    else
                    {
                      sub_14035B140(v38, (__int64 *)&v124);
                      v38 += 8;
                    }
                    v125[1] = v38;
                    sub_140370D10(&v124);
                  }
                }
                v94 = (__int64 **)mm[2];
                if ( *((_BYTE *)v94 + 0x19) )
                {
                  for ( kk = mm[1]; !*(_BYTE *)(kk + 0x19); kk = *(_QWORD *)(kk + 8) )
                  {
                    if ( mm != *(_QWORD **)(kk + 0x10) )
                      break;
                    mm = (_QWORD *)kk;
                  }
                  mm = (_QWORD *)kk;
                }
                else
                {
                  v96 = *v94;
                  for ( mm = (_QWORD *)mm[2]; !*((_BYTE *)v96 + 0x19); v96 = (__int64 *)*v96 )
                    mm = v96;
                }
              }
              while ( mm != *(_QWORD **)(v136 + 0xF0) );
            }
            v61 = 0;
            goto LABEL_155;
          }
          sub_140370D10(&v138);
          sub_140370D10(&String2_1);
          sub_140370D10(&v135);
          v5 = v130;
        }
      }
    }
    v38 = (char *)v125[1];
    v40 = (std::array<int,2> *)v125[0];
    goto LABEL_91;
  }
}

// --- End Function: sub_1475DCD10 (0x1475DCD10) ---

// --- Function: sub_1475DF210 (0x1475DF210) ---
void __fastcall sub_1475DF210(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1475B3F30(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1475DF210 (0x1475DF210) ---

// --- Function: sub_1475E6D80 (0x1475E6D80) ---
void __fastcall sub_1475E6D80(
        struct _RTL_CRITICAL_SECTION *lpCriticalSection,
        __int64 a2,
        unsigned __int64 a3,
        char a4,
        unsigned __int64 a5,
        char *Destination,
        rsize_t SizeInBytes)
{
  __int64 *v10; // rbx
  unsigned __int64 v11; // rdi
  int v13; // [rsp+54h] [rbp-ACh] BYREF
  __int128 Ext; // [rsp+58h] [rbp-A8h] BYREF
  char Buffer[1024]; // [rsp+70h] [rbp-90h] BYREF
  char FullPath[1024]; // [rsp+470h] [rbp+370h] BYREF
  char DstBuf_[1024]; // [rsp+870h] [rbp+770h] BYREF
  char Filename[1024]; // [rsp+C70h] [rbp+B70h] BYREF
  char Source[1024]; // [rsp+1070h] [rbp+F70h] BYREF

  EnterCriticalSection(lpCriticalSection);
  *Destination = 0;
  if ( a2 && a5 < a3 )
  {
    v10 = (__int64 *)(a2 + 0xC * a5);
    v11 = a5;
    do
    {
      memset(Buffer, 0, sizeof(Buffer));
      memset(DstBuf_, 0, sizeof(DstBuf_));
      memset(FullPath, 0, sizeof(FullPath));
      v13 = 0;
      *(_QWORD *)&Ext = 0;
      sub_1475CC5F0(lpCriticalSection, v10, DstBuf_, 0x400u, FullPath, 0x400u, &v13, (__int64 *)&Ext, a4);
      if ( FullPath[0] )
      {
        memset(Filename, 0, sizeof(Filename));
        Ext = 0;
        splitpath_s(FullPath, 0, 0, 0, 0, Filename, 0x400u, (char *)&Ext, 0x10u);
        snprintf_s(Buffer, 0x400u, 0xFFFFFFFFFFFFFFFFuLL, "%s [%s%s @ %u]", DstBuf_, Filename, (const char *)&Ext, v13);
      }
      else
      {
        snprintf_s(Buffer, 0x400u, 0xFFFFFFFFFFFFFFFFuLL, (const char *)&Format_, DstBuf_);
      }
      if ( !Buffer[0] )
        sub_147563030(Buffer, 0xFFFFFFFFFFFFFFFFuLL, "function=0x%p", (const void *)*v10);
      memset(Source, 0, sizeof(Source));
      sub_147563030(Source, 0xFFFFFFFFFFFFFFFFuLL, "%02zu %s\n", v11 - a5, Buffer);
      strncat_s(Destination, SizeInBytes, Source, 0xFFFFFFFFFFFFFFFFuLL);
      ++v11;
      v10 = (__int64 *)((char *)v10 + 0xC);
    }
    while ( v11 < a3 );
  }
  LeaveCriticalSection(lpCriticalSection);
}

// --- End Function: sub_1475E6D80 (0x1475E6D80) ---

// --- Function: sub_1475EC4A0 (0x1475EC4A0) ---
char __fastcall sub_1475EC4A0(__int64 a1, char a2, const char *a3)
{
  __int64 *v6; // rax
  __int64 v7; // rcx
  int v8; // ebx
  __int64 *v10; // rax
  int v11; // ebx
  const char *v12; // [rsp+30h] [rbp+8h] BYREF

  v12 = a3;
  if ( dword_1516B6078 )
  {
    sub_1403A2CE0((__int64)"GetCVar(\"%s\") called", a3);
    sub_147589BA0(*(_QWORD *)(a1 + 0x1F8), 0, 0x20);
  }
  v6 = sub_147557660((__int64 *)(a1 + 0xF0), &v12);
  if ( v6 == *(__int64 **)(a1 + 0xF0) || (v7 = v6[5]) == 0 )
  {
    v10 = sub_1475AF240(a1, a3);
    if ( v10 )
    {
      v11 = *((_DWORD *)v10 + 8);
      if ( !qword_149B4FDB8 )
        LogFatalError("Global Environment not setup, cannot verify platform configuration for whitelist flag checks");
      if ( BYTE1(qword_149B501D6)
        || *(_BYTE *)(a1 + 0x1F4) && (v11 & 0x40) != 0
        || (v11 & 0x200) != 0
        || (v11 & 0x10000000) != 0 && a2 )
      {
        return 1;
      }
    }
  }
  else
  {
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x58LL))(v7);
    if ( !qword_149B4FDB8 )
      LogFatalError("Global Environment not setup, cannot verify platform configuration for whitelist flag checks");
    if ( BYTE1(qword_149B501D6)
      || *(_BYTE *)(a1 + 0x1F4) && (v8 & 0x40) != 0
      || (v8 & 0x200) != 0
      || (v8 & 0x10000000) != 0 && a2 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1475EC4A0 (0x1475EC4A0) ---

// --- Function: sub_1475F7720 (0x1475F7720) ---
unsigned __int64 __fastcall sub_1475F7720(
        LPCRITICAL_SECTION lpCriticalSection,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        bool *a6)
{
  struct _RTL_CRITICAL_SECTION *lpCriticalSection_1; // rdi
  __m256i *v10; // rax
  __int64 n9; // rcx
  __m256i v12; // ymm0
  __int128 v13; // xmm1
  HANDLE CurrentProcess; // r12
  __int64 v15; // r14
  bool v16; // al
  unsigned __int64 v17; // rbp
  __int64 *v18; // rax
  __int64 (__fastcall *v19)(__int64, HANDLE, __int64, _QWORD *, _BYTE *, _QWORD, __int64, __int64, _QWORD, _DWORD); // rdi
  __int64 v20; // rbx
  __int64 *v21; // rax
  int v22; // eax
  __int64 (__fastcall *v23)(__int64, HANDLE, __int64, _QWORD *, _BYTE *, _QWORD, __int64, __int64, _QWORD); // rdi
  __int64 v24; // rbx
  __int64 *v25; // rax
  int v26; // edx
  _QWORD v29[34]; // [rsp+70h] [rbp-638h] BYREF
  _BYTE v30[152]; // [rsp+180h] [rbp-528h] BYREF
  __int64 v31; // [rsp+218h] [rbp-490h]
  __int64 v32; // [rsp+230h] [rbp-478h]
  __int64 v33; // [rsp+278h] [rbp-430h]

  lpCriticalSection_1 = lpCriticalSection;
  EnterCriticalSection(lpCriticalSection);
  sub_1475C3FA0(lpCriticalSection_1);
  v10 = (__m256i *)v30;
  n9 = 9;
  do
  {
    v10 += 4;
    v12 = *(__m256i *)a3;
    v13 = *(_OWORD *)(a3 + 0x70);
    a3 += 0x80;
    v10[0xFFFFFFFCLL] = v12;
    v10[0xFFFFFFFDLL] = *(__m256i *)(a3 - 0x60);
    v10[0xFFFFFFFELL] = *(__m256i *)(a3 - 0x40);
    *(_OWORD *)v10[0xFFFFFFFF].m256i_i8 = *(_OWORD *)(a3 - 0x20);
    *(_OWORD *)&v10[0xFFFFFFFF].m256i_u64[2] = v13;
    --n9;
  }
  while ( n9 );
  *v10 = *(__m256i *)a3;
  v10[1] = *(__m256i *)(a3 + 0x20);
  *(_OWORD *)v10[2].m256i_i8 = *(_OWORD *)(a3 + 0x40);
  __asm { vzeroupper }
  CurrentProcess = GetCurrentProcess();
  memset(v29, 0, sizeof(v29));
  v29[0] = v33;
  v29[6] = v31;
  HIDWORD(v29[1]) = 3;
  HIDWORD(v29[5]) = 3;
  HIDWORD(v29[7]) = 3;
  HIDWORD(v29[3]) = 3;
  HIDWORD(v29[9]) = 3;
  v29[4] = v32;
  v15 = sub_1475B0570()[4];
  v16 = v15 != 0;
  v17 = 0;
  if ( a5 )
  {
    do
    {
      v18 = sub_1475B0570();
      if ( v15 )
      {
        v19 = (__int64 (__fastcall *)(__int64, HANDLE, __int64, _QWORD *, _BYTE *, _QWORD, __int64, __int64, _QWORD, _DWORD))v18[4];
        v20 = sub_1475B0570()[9];
        v21 = sub_1475B0570();
        v22 = v19(0x8664, CurrentProcess, a2, v29, v30, 0, v21[7], v20, 0, 0);
      }
      else
      {
        v23 = (__int64 (__fastcall *)(__int64, HANDLE, __int64, _QWORD *, _BYTE *, _QWORD, __int64, __int64, _QWORD))v18[5];
        v24 = sub_1475B0570()[9];
        v25 = sub_1475B0570();
        v22 = v23(0x8664, CurrentProcess, a2, v29, v30, 0, v25[7], v24, 0);
      }
      if ( !v22 )
        break;
      v26 = 0;
      *(_QWORD *)a4 = v29[0];
      if ( v15 )
        v26 = HIDWORD(v29[0x21]);
      ++v17;
      *(_DWORD *)(a4 + 8) = v26;
      a4 += 0xC;
    }
    while ( v17 < a5 );
    lpCriticalSection_1 = lpCriticalSection;
    v16 = v15 != 0;
  }
  *a6 = v16;
  LeaveCriticalSection(lpCriticalSection_1);
  return v17;
}

// --- End Function: sub_1475F7720 (0x1475F7720) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_147602A80 (0x147602A80) ---
void __fastcall sub_147602A80(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned __int32 v4; // eax
  __int64 v5; // r13
  int v6; // ebx
  unsigned int v7; // ebp
  unsigned __int32 v8; // r15d
  unsigned int v9; // ebx
  unsigned __int32 v10; // [rsp+20h] [rbp-88h]
  unsigned __int32 v11; // [rsp+20h] [rbp-88h]
  int n0x1600; // [rsp+30h] [rbp-78h] BYREF
  __int64 v13; // [rsp+34h] [rbp-74h]
  int n2; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v15; // [rsp+40h] [rbp-68h]
  unsigned __int64 v16; // [rsp+48h] [rbp-60h]
  __int64 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-50h]

  v3 = a1 + 0x12F0;
  v4 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0x12F0), 1u);
  v5 = a1 + 0x12F0 + 0x10 * (v4 & 0x1F);
  v6 = (v4 >> 5) & 0x7FFF;
  v7 = ((v4 - 0x20) >> 5) & 0x7FFF;
  v8 = *(_DWORD *)(v5 + 8);
  if ( (v8 & 0x7FFF) != v7 )
  {
    if ( qword_149B4FDB8 )
    {
      n0x1600 = 0x1600;
      v13 = 1;
      n2 = 2;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v15 = __rdtsc();
      qword_149B4B870(
        &n0x1600,
        &word_1517021C0,
        "Wait on Full Queue",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Containers/CigProducerConsumerQueue.h",
        0xB2);
      HIWORD(n0x1600) = word_1517021C0;
      LOBYTE(v11) = 0;
      sub_1407E63A0(v3, (volatile signed __int32 *)(v5 + 8), v8, v7, v11);
      v16 = __rdtsc();
      qword_149B4B878(&n0x1600);
    }
    else
    {
      LOBYTE(v10) = 0;
      sub_1407E63A0(a1 + 0x12F0, (volatile signed __int32 *)(v5 + 8), v8, v7, v10);
    }
  }
  *(_QWORD *)(v5 + 0x10) = a2;
  v9 = _InterlockedExchange((volatile __int32 *)(v5 + 0xC), v6);
  if ( (v9 & 0xFFFF8000) != 0 )
    sub_1407E6520(v3, v5 + 0xC, v9);
}

// --- End Function: sub_147602A80 (0x147602A80) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476030E0 (0x1476030E0) ---
unsigned __int64 __fastcall sub_1476030E0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n32; // eax
  unsigned int n32_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147603270((__int64)&qword_151700CC0, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n32 = 32;
    n32_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n32 = n32_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(32 - n32) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148D699B0[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 16 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3840;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 12);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147604610(&unk_151700CD0[4 * v12]);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1476034A0((__int64)&qword_151700CC0, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_151701F50;
  if ( qword_151701F50 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_151701E50;
    if ( qword_151701E50 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1476030E0 (0x1476030E0) ---

// --- Function: sub_1476046F0 (0x1476046F0) ---
char __fastcall sub_1476046F0(volatile signed __int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __m128i v4; // rt0
  __m128i v5; // xmm0
  signed __int64 epi64; // r9
  __int64 v7; // rdx
  __m128i v8; // rt0
  signed __int64 v10; // [rsp+18h] [rbp-40h]
  __m128i v11; // [rsp+30h] [rbp-28h]

  v4 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v4.m128i_i64);
  v5 = v4;
  if ( (unsigned int)(v4.m128i_i32[3] + 1) >= a3 )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v5, 1);
    *a2 = v5.m128i_i64[0];
    LODWORD(v10) = epi64 + 1;
    HIDWORD(v10) = HIDWORD(epi64) + 1;
    v8.m128i_i64[0] = v5.m128i_i64[0];
    v8.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v10, (signed __int64)a2, v8.m128i_i64);
    v7 = v8.m128i_i64[1];
    v11 = v8;
    if ( v8.m128i_i64[0] == v5.m128i_i64[0] && (_DWORD)v7 == (_DWORD)epi64 )
      break;
    v5 = v11;
    if ( (unsigned int)(HIDWORD(v7) + 1) >= a3 )
      return 0;
  }
  return 1;
}

// --- End Function: sub_1476046F0 (0x1476046F0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6320);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6336);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6320) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 6320);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

// --- Function: free_0 (0x1480821F7) ---
// attributes: thunk
void __cdecl free_0(void *Block)
{
  free(Block);
}

// --- End Function: free_0 (0x1480821F7) ---

// --- Function: malloc_0 (0x1480821FD) ---
// attributes: thunk
void *__cdecl malloc_0(size_t Size)
{
  return malloc(Size);
}

// --- End Function: malloc_0 (0x1480821FD) ---

// --- Function: sub_1480BD400 (0x1480BD400) ---
__int64 sub_1480BD400()
{
  __int64 v0; // rax

  v0 = NtCurrentTeb_w();
  return sub_1402A3D30(**(const void ***)(v0 + 0x10));
}

// --- End Function: sub_1480BD400 (0x1480BD400) ---

// --- Function: sub_148177D00 (0x148177D00) ---
__int64 sub_148177D00()
{
  volatile signed __int64 *v0; // rdi
  __int64 ThreadLocalStoragePointer; // rax
  __int64 n0x8C; // rsi
  __int64 v3; // rbp
  __int64 v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *v6; // rax
  int v7; // r9d
  _QWORD *v8; // r8

  v0 = unk_151700CD0;
  ThreadLocalStoragePointer = (__int64)NtCurrentTeb()->ThreadLocalStoragePointer;
  n0x8C = 0x8C;
  v3 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF00LL;
  v4 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF10LL;
  do
  {
    v5 = *(_QWORD **)v4;
    if ( *(_QWORD *)v4 )
    {
      v6 = (_QWORD *)*v5;
      v7 = 1;
      v8 = *(_QWORD **)v4;
      if ( *v5 )
      {
        do
        {
          ++v7;
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while ( v6 );
      }
      ThreadLocalStoragePointer = sub_1476047E0(v0, (signed __int64)v5, v8, v7);
      *(_QWORD *)v4 = 0;
      *(_DWORD *)(v4 + 0xC) = 0;
    }
    v4 += 0x10;
    v0 += 4;
    --n0x8C;
  }
  while ( n0x8C );
  *(_BYTE *)(v3 + 1) = 1;
  return ThreadLocalStoragePointer;
}

// --- End Function: sub_148177D00 (0x148177D00) ---

