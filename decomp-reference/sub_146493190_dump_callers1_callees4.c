// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146493190 (sub_146493190)
// Caller Depth: 1
// Callee/Ref Depth: 4
// Total Functions Found: 38
// ------------------------------------------------------------

// --- Function: identity (0x1402A24F0) ---
// A simple passthrough function that returns its input argument unchanged.
__int64 __fastcall identity(__int64 input_value)
{
  return input_value;
}

// --- End Function: identity (0x1402A24F0) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: sub_1402A2B80 (0x1402A2B80) ---
__int64 __fastcall sub_1402A2B80(__int64 a1, __int64 a2)
{
  return a2;
}

// --- End Function: sub_1402A2B80 (0x1402A2B80) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)get_thread_context_ptr() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: NtCurrentTeb_ww_0 (0x1402E2480) ---
__int64 NtCurrentTeb_ww_0()
{
  return *(unsigned __int8 *)(get_thread_context_ptr() + 0x12D);
}

// --- End Function: NtCurrentTeb_ww_0 (0x1402E2480) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *handle_ptr)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *handle_ptr;
  if ( !*handle_ptr )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)get_thread_context_ptr() )
    return sub_14031FE20(handle_ptr) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_desc_ptr)
{
  unsigned __int64 entity_desc_val; // r9
  __int64 entity_base_addr_or_id; // r10
  unsigned __int64 entity_type_flags; // r9
  __int64 align_mask; // rax
  __int64 aligned_base_addr_or_id; // r10
  __int64 entity_header_ptr; // rbx
  bool is_privileged_or_bypass; // al

  entity_desc_val = *entity_desc_ptr;
  if ( !*entity_desc_ptr )
    return 0;
  entity_base_addr_or_id = entity_desc_val & 0xFFFFFFFFFFFFLL;
  entity_type_flags = HIWORD(entity_desc_val);
  if ( (entity_type_flags & 0xF000) != 0 )
  {
    align_mask = map_flag_to_mask(0x2000u);
    entity_header_ptr = aligned_base_addr_or_id & ~(align_mask - 1);
  }
  else
  {
    entity_header_ptr = entity_base_addr_or_id - 6;
  }
  if ( *(_WORD *)(entity_header_ptr + 2) != (entity_type_flags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || (is_privileged_or_bypass = is_thread_privileged_or_bypass_mode()) )
    is_privileged_or_bypass = 1;
  return *(_WORD *)(entity_header_ptr + 4) == 2 && is_privileged_or_bypass
      || validate_entity_descriptor_detailed_access(entity_desc_ptr) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *qword_ptr)
{
  return *qword_ptr & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int result_mask; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        result_mask = 0;
        if ( input_flag == 0x6000 )
          return 0x4000000;
        return result_mask;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_14035C250 (0x14035C250) ---
_BYTE *__fastcall sub_14035C250(_BYTE *a1, char a2)
{
  *a1 = a2;
  return a1;
}

// --- End Function: sub_14035C250 (0x14035C250) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_thread_context_ptr() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = pEntitySystem;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: validate_entity_descriptor_detailed_access (0x140392020) ---
// Performs detailed access validation for an entity descriptor. It extracts the
// entity's base address or ID from the descriptor. It then determines a pointer to
// entity metadata based on the highest bit of the descriptor (either by masking or
// by applying a -6 offset to the base address/ID). The function then dispatches to
// different validation logic based on the value of a status/type field at
// `entity_metadata_ptr + 4`: - If 0, returns false. - If 1, calls
// `check_thread_list_contains_value` with the entity's base address/ID. - If 2,
// checks for a privileged/bypass state (via `get_thread_context_ptr + 0x12D` or
// `is_thread_privileged_or_bypass_mode`). If privileged, returns true; otherwise,
// calls `validate_access_with_virtual_calls`. - If 3 or 4, checks thread data from
// `get_thread_context_ptr`. If a specific thread status is 1, it returns true if
// the entity's base address/ID is NOT equal to the magic value `0x13374770CLL`. -
// For any other status/type, returns false.
char __fastcall validate_entity_descriptor_detailed_access(_QWORD *entity_descriptor_ptr)
{
  _QWORD *entity_base_addr_or_id; // rbx
  __int64 entity_metadata_ptr; // rax
  __int64 thread_data_ptr; // rax

  entity_base_addr_or_id = (_QWORD *)(*entity_descriptor_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*entity_descriptor_ptr & 0xF000000000000000uLL) != 0 )
    entity_metadata_ptr = *entity_descriptor_ptr & 0xFFFFFF000000LL;
  else
    entity_metadata_ptr = (__int64)entity_base_addr_or_id + 0xFFFFFFFA;
  if ( !*(_WORD *)(entity_metadata_ptr + 4) )
    return 0;
  if ( *(_WORD *)(entity_metadata_ptr + 4) == 1 )
    return check_thread_list_contains_value((__int64)entity_base_addr_or_id);
  if ( *(_WORD *)(entity_metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(entity_metadata_ptr + 4) - 3 <= 1 )
    {
      thread_data_ptr = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
      if ( thread_data_ptr )
      {
        if ( *(_DWORD *)(thread_data_ptr + 8) == 1 )
          return *entity_base_addr_or_id != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)entity_base_addr_or_id);
}

// --- End Function: validate_entity_descriptor_detailed_access (0x140392020) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
           pEntitySystem,
           a1,
           0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: get_event_key_from_source_location (0x1403BB9D0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149B3D530;
  if ( !qword_149B3D530 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149B3D530 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BB9D0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 0xC0LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403F7D30 (0x1403F7D30) ---
bool __fastcall sub_1403F7D30(unsigned __int64 *a1)
{
  return !is_entity_descriptor_valid_or_accessible(a1);
}

// --- End Function: sub_1403F7D30 (0x1403F7D30) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 thread_data_ptr; // rcx

  thread_data_ptr = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( thread_data_ptr )
    return *(_BYTE *)(thread_data_ptr + 0x42) != 0;
  else
    return *(_BYTE *)(get_thread_context_ptr() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( gEnv && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_142662660 (0x142662660) ---
_QWORD *__fastcall sub_142662660(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_12;
  if ( n0xFFFF_12 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v9,
                          "SCPlayer");
    n0xFFFF_12 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_142662660 (0x142662660) ---

// --- Function: ??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ (0x1426D6000) ---
void _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator()()
{
  ;
}

// --- End Function: ??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ (0x1426D6000) ---

// --- Function: sub_1426D6280 (0x1426D6280) ---
__int64 __fastcall sub_1426D6280(__int64 a1, unsigned __int8 *a2)
{
  __int64 result; // rax
  _BYTE *v3; // [rsp+20h] [rbp-18h]

  v3 = (_BYTE *)sub_1402A2B80(1, a1);
  result = *a2;
  *v3 = result;
  return result;
}

// --- End Function: sub_1426D6280 (0x1426D6280) ---

// --- Function: sub_1426DA1E0 (0x1426DA1E0) ---
_QWORD *__fastcall sub_1426DA1E0(__int64 a1, _QWORD *a2)
{
  __int16 v3; // [rsp+20h] [rbp-38h] BYREF
  __int16 *v4; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int16 *); // [rsp+30h] [rbp-28h]
  __int64 *v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  _BYTE v8[16]; // [rsp+48h] [rbp-10h] BYREF

  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  v4 = sub_142747460(&v3);
  v6 = (__int64 *)v5(a1, v8, v4);
  v7 = *v6;
  *a2 = v7;
  return a2;
}

// --- End Function: sub_1426DA1E0 (0x1426DA1E0) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || is_thread_privileged_or_bypass_mode() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: sub_142747460 (0x142747460) ---
__int16 *__fastcall sub_142747460(__int16 *a1)
{
  __int16 n0xFFFF; // cx
  __int16 *result; // rax
  char v4; // [rsp+30h] [rbp+8h] BYREF

  if ( n0xFFFF_99 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v4,
                          "SCLocalPlayerPersonalThoughtComponent");
    result = a1;
    n0xFFFF_99 = n0xFFFF;
    *a1 = n0xFFFF;
  }
  else
  {
    *a1 = n0xFFFF_99;
    return a1;
  }
  return result;
}

// --- End Function: sub_142747460 (0x142747460) ---

// --- Function: sub_1427BA760 (0x1427BA760) ---
__int64 __fastcall sub_1427BA760(__int64 a1)
{
  return sub_1402A2B80(1, a1);
}

// --- End Function: sub_1427BA760 (0x1427BA760) ---

// --- Function: sub_143456400 (0x143456400) ---
__int64 sub_143456400()
{
  __int64 result; // rax

  result = (unsigned int)dword_149E25070;
  if ( !dword_149E25070 )
    return get_event_key_from_source_location(
             &dword_149E25070,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\GameInventory\\InventoryEvents.h",
             0x50E);
  return result;
}

// --- End Function: sub_143456400 (0x143456400) ---

// --- Function: sub_143B74400 (0x143B74400) ---
_QWORD *__fastcall sub_143B74400(_QWORD *a1)
{
  *a1 = "struct SCPlayerInventoryEvt_Close";
  return a1;
}

// --- End Function: sub_143B74400 (0x143B74400) ---

// --- Function: sub_143B7FF30 (0x143B7FF30) ---
__int64 __fastcall sub_143B7FF30(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1426D6280)(__int64, unsigned __int8 *); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_143456400();
  v8 = 1;
  v3 = sub_143B74400(&v5);
  v9 = sub_1402A2660((__int64)v3);
  v10 = byte_149E34D80;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1426D6280 = sub_1426D6280;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_143B7FF30 (0x143B7FF30) ---

// --- Function: sub_14644AD60 (0x14644AD60) ---
__int64 sub_14644AD60()
{
  __int64 result; // rax

  result = (unsigned int)dword_149E7D1D8;
  if ( !dword_149E7D1D8 )
    return get_event_key_from_source_location(
             &dword_149E7D1D8,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\GameInventory/InventoryEvents.h",
             0x47B);
  return result;
}

// --- End Function: sub_14644AD60 (0x14644AD60) ---

// --- Function: sub_1464909C0 (0x1464909C0) ---
_QWORD *__fastcall sub_1464909C0(_QWORD *a1)
{
  *a1 = "struct SCPlayerInventoryEvt_ResetAllInventoryCache";
  return a1;
}

// --- End Function: sub_1464909C0 (0x1464909C0) ---

// --- Function: sub_146490A90 (0x146490A90) ---
__int64 __fastcall sub_146490A90(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1427BA760)(__int64); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_14644AD60();
  v8 = 1;
  v3 = sub_1464909C0(&v5);
  v9 = sub_1402A2660((__int64)v3);
  v10 = byte_149E7E39D;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427BA760 = sub_1427BA760;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_146490A90 (0x146490A90) ---

// --- Function: sub_146493190 (0x146493190) ---
__int64 sub_146493190()
{
  __int64 result; // rax
  char v1; // [rsp+20h] [rbp-B8h] BYREF
  _BYTE v2[15]; // [rsp+21h] [rbp-B7h] BYREF
  __int64 v3; // [rsp+30h] [rbp-A8h]
  __int64 v4; // [rsp+38h] [rbp-A0h]
  unsigned __int64 v5; // [rsp+40h] [rbp-98h] BYREF
  __int64 v6; // [rsp+48h] [rbp-90h]
  __int64 v7; // [rsp+50h] [rbp-88h] BYREF
  __int64 v8; // [rsp+58h] [rbp-80h] BYREF
  void (__fastcall *v9)(__int64, unsigned __int64 *); // [rsp+60h] [rbp-78h]
  __int64 v10; // [rsp+68h] [rbp-70h]
  __int64 *v11; // [rsp+70h] [rbp-68h]
  __int64 v12; // [rsp+78h] [rbp-60h]
  _BYTE *v13; // [rsp+80h] [rbp-58h]
  __int64 v14; // [rsp+88h] [rbp-50h]
  __int64 v15; // [rsp+90h] [rbp-48h]
  __int64 *v16; // [rsp+98h] [rbp-40h]
  __int64 v17; // [rsp+A0h] [rbp-38h]
  __int64 v18; // [rsp+A8h] [rbp-30h]
  __int64 v19; // [rsp+B0h] [rbp-28h]
  __int64 v20; // [rsp+B8h] [rbp-20h] BYREF
  _QWORD v21[3]; // [rsp+C0h] [rbp-18h] BYREF

  *(_QWORD *)&v2[7] = *(_QWORD *)(identity((__int64)&pSystem) + 0x98);
  if ( !*(_QWORD *)&v2[7] )
    return sub_1405C0E00(0xAu, 2u, "Cannot CmdClearInventoryCache without a game");
  v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)&v2[7] + 0xA0LL))(*(_QWORD *)&v2[7]);
  if ( !v3 )
    return sub_1405C0E00(0xAu, 2u, "Cannot CmdClearInventoryCache without a game framework");
  v9 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v3 + 0x2C8LL);
  v9(v3, &v5);
  if ( sub_1403F7D30(&v5) )
    return sub_1405C0E00(0xAu, 2u, "Cannot CmdClearInventoryCache without a client entity.");
  v10 = sub_14030ECF0(&v5);
  v11 = sub_1426DA1E0(v10, &v20);
  v12 = *v11;
  v7 = v12;
  if ( Handle::IsValid(&v7) )
    v4 = v7 & 0xFFFFFFFFFFFFLL;
  else
    v4 = 0;
  if ( v4 )
  {
    v14 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
    v13 = sub_14035C250(&v1, 1);
    sub_143B7FF30(v14, v4, (__int64)v13);
  }
  v15 = sub_14030ECF0(&v5);
  v16 = sub_142662660(v15, v21);
  v17 = *v16;
  v8 = v17;
  result = is_valid_handle_typeA(&v8);
  if ( (_BYTE)result )
  {
    result = v8 & 0xFFFFFFFFFFFFLL;
    v6 = v8 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = 0;
  }
  if ( v6 )
  {
    v19 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
    v18 = identity((__int64)v2);
    return sub_146490A90(v19, v6, v18);
  }
  return result;
}

// --- End Function: sub_146493190 (0x146493190) ---

