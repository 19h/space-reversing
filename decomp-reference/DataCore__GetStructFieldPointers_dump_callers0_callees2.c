// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x14723EB40 (DataCore::GetStructFieldPointers)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 23
// ------------------------------------------------------------

// --- Function: unknown_libname_10 (0x1402DFC60) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402DFC60) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !qword_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !qword_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 v13; // r13
  char result; // al
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  __int64 v18; // r15
  _QWORD *v19; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  __int64 *v22; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v24; // rcx
  _QWORD *v25; // rbx
  _BYTE *v26; // rdx
  _BYTE *v27; // rdx
  __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *v31; // r14
  __int64 *v32; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  __int64 v42; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *Buf2_1; // r15
  _QWORD **v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *v56; // rcx
  __m256 *Buf2_2; // rax
  __int64 *v58; // rax
  __int64 *v59; // r14
  __int64 v60; // rcx
  _QWORD *v61; // rbx
  _BYTE *v62; // rdx
  _BYTE *v63; // rdx
  __int64 v64; // r10
  __int64 v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 Buffer_3; // rax
  const void *Buffer_5; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  Stream *Stream; // rax
  int n2; // r8d
  Stream *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 Buffer_4; // rax
  const void *Buffer_6; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  Stream *Stream_2; // rax
  Stream *Stream_3; // rax
  const void **v103; // rsi
  _QWORD **v104; // rcx
  _QWORD *v105; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *v107; // rdi
  _QWORD *v108; // rcx
  __int64 *v109; // rbx
  _QWORD *v110; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  __int64 *v114; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  __int64 v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *v121; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 v123; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *v125; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  _QWORD *v129; // [rsp+128h] [rbp+88h] BYREF
  __int64 *v130; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *v131; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **v135; // [rsp+158h] [rbp+B8h] BYREF
  __int64 v136; // [rsp+160h] [rbp+C0h]
  __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  v121 = (_QWORD *)a5;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v13 = a6;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, a5, a6);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  v135 = 0;
  v15 = 0;
  v130 = (__int64 *)&v135;
  n0x400 = 0;
  v114 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !a6 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  v19 = v121;
  v20 = v112;
  v125 = v121;
  while ( 2 )
  {
    v21 = *((_BYTE *)v19 + 89) == 0;
    v131 = v19;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = v19;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    v123 = (unsigned __int64)v19;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = v19;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v114 = (__int64 *)sub_1402A1E30(0x18u);
        v15 = v114;
        if ( v114 )
        {
          v22 = v114;
          *v114 = 0;
          n0x400_1 = 0;
          v15[1] = 0;
          v24 = (__int64)v15;
          v15[2] = 0;
        }
        else
        {
          v15 = 0;
          v22 = 0;
          n0x400_1 = 0;
          v114 = 0;
          v24 = 0;
        }
        sub_140302260(v24, v13);
        v25 = v141;
        do
        {
          v26 = (_BYTE *)v22[1];
          if ( v26 == (_BYTE *)v22[2] )
          {
            sub_1402A47D0(v15, v26, v25);
          }
          else
          {
            *(_QWORD *)v26 = *v25;
            v22[1] += 8;
          }
          ++n0x400_1;
          ++v25;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        v19 = v125;
      }
      v27 = (_BYTE *)v15[1];
      if ( v27 == (_BYTE *)v15[2] )
      {
        __asm { vzeroupper }
        sub_1402A47D0(v15, v27, &v123);
      }
      else
      {
        *(_QWORD *)v27 = v19;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    v19[1] = sub_1402FD110(&v130, (__int64)v19);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64))v19[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    v123 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*v19, &v124, &v123, v28);
    v31 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    v32 = v130;
    do
    {
      v131 = v31;
      v31[10] = v18;
      v21 = v31[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)v31[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*v32 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)sub_1402A1E30(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)sub_1402A1E30(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *v32 = (__int64)v33;
        }
        v35 = (_BYTE *)v31[1];
        Size_2 = -1;
        memset(&v138, 0, sizeof(v138));
        Size_1 = -1;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)v31[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        v42 = *v32;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        Buf2_1 = *(__m256 **)v138.m256_f32;
        v129 = (_QWORD *)v42;
        v45 = *(_QWORD ***)v42;
        v46 = **(_QWORD ***)v42;
        if ( v46 == *(_QWORD **)v42 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = Buf2_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        v42 = (__int64)v129;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *(_QWORD *)(v42 + 8) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = sub_1402A1E30(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 32) = 0;
          *(_QWORD *)(v51 + 40) = 0;
          *(__m256 *)(v51 + 16) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*(_QWORD *)(v42 + 8);
          v53 = v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = (_QWORD *)v51;
          *v53 = v51;
          v54 = *(_QWORD *)*v32;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 40LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v56 = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v56 = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)v56 - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(v56);
          }
          v15 = v114;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            Buf2_2 = Buf2_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              Buf2_1 = *(__m256 **)&Buf2_1[-1].m256_f32[6];
              if ( (unsigned __int64)((char *)Buf2_2 - (char *)Buf2_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(Buf2_1);
          }
          v15 = v114;
          n0x400_2 = 0;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
        }
      }
      v31[1] = v55;
      n0x400 = n0xF;
      v129 = v31;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !v15 )
        {
          __asm { vzeroupper }
          v58 = (__int64 *)sub_1402A1E30(0x18u);
          v15 = v58;
          v114 = v58;
          if ( v58 )
          {
            *v58 = 0;
            v59 = v58;
            v58[1] = 0;
            v60 = (__int64)v58;
            v58[2] = 0;
          }
          else
          {
            v15 = 0;
            v114 = 0;
            v59 = 0;
            v60 = 0;
          }
          sub_140302260(v60, a6);
          v61 = v141;
          do
          {
            v62 = (_BYTE *)v59[1];
            if ( v62 == (_BYTE *)v59[2] )
            {
              sub_1402A47D0(v15, v62, v61);
            }
            else
            {
              *(_QWORD *)v62 = *v61;
              v59[1] += 8;
            }
            ++n0x400_2;
            ++v61;
          }
          while ( n0x400_2 < 0x400 );
          v31 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        v63 = (_BYTE *)v15[1];
        if ( v63 == (_BYTE *)v15[2] )
        {
          __asm { vzeroupper }
          sub_1402A47D0(v15, v63, &v129);
        }
        else
        {
          *(_QWORD *)v63 = v31;
          v15[1] += 8;
        }
      }
      else
      {
        v141[n0xF] = v31;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      v31 += 13;
      a13 = v30;
      *(_QWORD *)v116 = v31;
    }
    while ( v30 < v124 );
    v19 = v125;
LABEL_94:
    v28 = v137;
    v13 = a6;
    if ( v123 > 1 )
    {
      v28 = -1;
    }
    v64 = v123 + v117;
    v117 += v123;
LABEL_98:
    v19 += 13;
    v125 = v19;
    v131[10] = v28;
    if ( ++v132 < v13 )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v114 = v15;
  n0xF = n0x400;
  v117 = v64;
  if ( !v15 )
  {
    goto LABEL_106;
  }
  if ( !((v15[1] - *v15) >> 3) )
  {
    __debugbreak();
  }
  i = (char *)*v15;
  v114 = v15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 80LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 80LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 80) = -(__int64)(*(_QWORD *)(v71 + 80) != -1);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (v65 + 1) << 10;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    Buffer_5 = 0;
  }
  else
  {
    Buffer_3 = sub_1402A1E30(Size);
    Buffer_5 = (const void *)Buffer_3;
    if ( Buffer_3 )
    {
      Buffer_1 = (char *)Buffer_3;
      goto LABEL_131;
    }
  }
  v79 = Size + 15;
  if ( Size + 15 < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && qword_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, v121, a6, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            v121,
            a6,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    sub_1402F5120(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    sub_1402F5120(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((n0xF + 2 * v117 + v117 + 32) << 7);
    }
    n0x8000_2 = v93 + 128;
    if ( *p_n0x8000_1 < v93 + 128 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      Buffer_6 = 0;
    }
    else
    {
      Buffer_4 = sub_1402A1E30(n0x8000_2);
      Buffer_6 = (const void *)Buffer_4;
      if ( Buffer_4 )
      {
        Buffer_2 = (double *)Buffer_4;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 15;
    if ( n0x8000_2 + 15 < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      (__int64)v121,
      a6,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 128,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(Buffer_6);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  result = free_memory_wrapper(Buffer_5);
  v103 = v135;
  if ( v135 )
  {
    v104 = (_QWORD **)*v135;
    **((_QWORD **)*v135 + 1) = 0;
    v105 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = v105[5];
        v107 = (_QWORD *)*v105;
        if ( n0xF_2 > 0xF )
        {
          v108 = (_QWORD *)v105[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v108 - *(v108 - 1) - 8 > 0x1F )
            {
              goto LABEL_190;
            }
            v108 = (_QWORD *)*(v108 - 1);
          }
          free_memory_wrapper(v108);
        }
        v105[4] = 0;
        v105[5] = 15;
        *((_BYTE *)v105 + 16) = 0;
        free_memory_wrapper(v105);
        v105 = v107;
      }
      while ( v107 );
    }
    free_memory_wrapper(*v103);
    result = free_memory_wrapper(v103);
  }
  v109 = v114;
  if ( v114 )
  {
    v110 = (_QWORD *)*v114;
    if ( *v114 )
    {
      if ( ((v114[2] - (_QWORD)v110) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v110 - *(v110 - 1) - 8 > 0x1F )
        {
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        }
        v110 = (_QWORD *)*(v110 - 1);
      }
      free_memory_wrapper(v110);
      *v109 = 0;
      v109[1] = 0;
      v109[2] = 0;
    }
    return free_memory_wrapper(v109);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: submitTraceContext (0x14034E9F0) ---
// Prepares a trace context structure with specific handler functions and metadata,
// then submits this context along with other logging parameters (level, category,
// message, tags, etc.) to the core logging function `sub_140302350`.
char __fastcall submitTraceContext(
        int log_level,
        __int64 category_ptr,
        void *message_format,
        __int64 arg_ptr_1,
        __int64 trace_context_handlers,
        int status_flags,
        _QWORD *tags_ptr,
        __int64 *list_ptr,
        __int64 thread_log_context_slot)
{
  __int64 status_flags_storage; // [rsp+18h] [rbp-88h]
  __int64 trace_context_handlers_data[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n256; // [rsp+88h] [rbp-18h]
  __int64 n176; // [rsp+90h] [rbp-10h]

  trace_context_handlers_data[0] = thread_log_context_slot;
  trace_context_handlers_data[1] = (__int64)"TraceContext";
  trace_context_handlers_data[3] = (__int64)sub_1403E6C00;
  trace_context_handlers_data[4] = (__int64)sub_1403E6700;
  trace_context_handlers_data[6] = (__int64)sub_1403E2C50;
  trace_context_handlers_data[8] = (__int64)sub_1403E02C0;
  trace_context_handlers_data[9] = (__int64)sub_1403DFFB0;
  LODWORD(status_flags_storage) = status_flags;
  n256 = 256;
  trace_context_handlers_data[2] = 0;
  trace_context_handlers_data[5] = 0;
  trace_context_handlers_data[7] = 0;
  trace_context_handlers_data[10] = -1;
  n176 = 176;
  return sub_140302350(
           log_level,
           category_ptr,
           message_format,
           arg_ptr_1,
           (__int64)trace_context_handlers_data,
           1,
           trace_context_handlers,
           status_flags_storage,
           tags_ptr,
           list_ptr);
}

// --- End Function: submitTraceContext (0x14034E9F0) ---

// --- Function: sub_140357780 (0x140357780) ---
_QWORD *__fastcall sub_140357780(_QWORD *a1, _QWORD *a2)
{
  *a1 = (char *)&qword_149808ABC + 4;
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_140357780 (0x140357780) ---

// --- Function: DestroyStringObject (0x14036D270) ---
// Deallocates the memory buffer associated with a string object created by
// `CreateStringObjectFromString`.  It accesses metadata stored 8 bytes before the
// provided data pointer to get the allocation base pointer required by the
// deallocation function `sub_14739AF10`.  @param ppStringObjectData Pointer to the
// variable holding the pointer to the string object's data.
void __fastcall DestroyStringObject(_QWORD *ppStringObjectData)
{
  int *pStringMetadata; // rcx

  pStringMetadata = (int *)(*ppStringObjectData - 8LL);
  if ( pStringMetadata[1] > 0 )
  {
    sub_14739AF10(pStringMetadata);
  }
}

// --- End Function: DestroyStringObject (0x14036D270) ---

// --- Function: sub_14038E0B0 (0x14038E0B0) ---
__int64 __fastcall sub_14038E0B0(__int64 a1, unsigned __int64 n0x6400000)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403AF4C0();
  n0x40 = (n0x6400000 >> 8) + ((_BYTE)n0x6400000 != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
    {
      goto LABEL_7;
    }
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 64LL;
      if ( n0x4000 >= 0x4000 )
      {
        goto LABEL_2;
      }
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
      {
        n0x40_1 = -1;
      }
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
        {
          goto LABEL_2;
        }
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; n0x4000_2 + 64 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL); v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = -1 )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 64LL;
    }
    if ( n0x4000_2 < n0x4000 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 64)) - 1;
    }
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056A090((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056A0D0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_140569F50((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = sub_14739AFC0(n0x6400000, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_14038E0B0 (0x14038E0B0) ---

// --- Function: sub_14039EFB0 (0x14039EFB0) ---
void __fastcall sub_14039EFB0(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403AF4C0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 32) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; v7 + 64 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 40) = 0 )
    {
      v11 = v7;
      v7 += 64LL;
    }
    if ( v7 < v8 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~((1LL << ((__int64)v8 % 64)) - 1);
    }
  }
  else
  {
    sub_14739AF10(a2);
  }
}

// --- End Function: sub_14039EFB0 (0x14039EFB0) ---

// --- Function: sub_1403DFFB0 (0x1403DFFB0) ---
__int64 sub_1403DFFB0()
{
  return sub_1402A1E30(1uLL);
}

// --- End Function: sub_1403DFFB0 (0x1403DFFB0) ---

// --- Function: sub_1403E02C0 (0x1403E02C0) ---
__int64 __fastcall sub_1403E02C0(const void *a1)
{
  return free_memory_wrapper(a1);
}

// --- End Function: sub_1403E02C0 (0x1403E02C0) ---

// --- Function: sub_1403E2C50 (0x1403E2C50) ---
char __fastcall sub_1403E2C50(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1403E2C50 (0x1403E2C50) ---

// --- Function: sub_1403E6700 (0x1403E6700) ---
__int64 __fastcall sub_1403E6700(__int64 a1, __int64 a2, unsigned __int64 n12)
{
  int v3; // edi
  int n12_1; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12_1 = 0;
  if ( (int)n12 > 0 )
  {
    if ( n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 = 12;
      if ( (int)n12 <= 12 )
      {
        goto LABEL_52;
      }
    }
    v8 = sub_1404EEAB0((unsigned __int8 *)a1, (_BYTE *)((unsigned int)n12_1 + a2), n12 - (unsigned int)n12_1);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v8;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12_1);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 19;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v10 = sub_1404EE450((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v10;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12_1;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v12 = sub_1404EE6A0((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12_1);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 18;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v14 = sub_1404EE300((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12_1 += v14;
    if ( n12_1 < (int)n12 )
    {
LABEL_46:
      if ( n12 - n12_1 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12_1);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12_1 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
  {
    return (unsigned int)-1;
  }
  return (unsigned int)n12_1;
}

// --- End Function: sub_1403E6700 (0x1403E6700) ---

// --- Function: sub_1403E6C00 (0x1403E6C00) ---
// attributes: thunk
__int64 __fastcall sub_1403E6C00(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404EEAB0(a1, a2, n0x21);
}

// --- End Function: sub_1403E6C00 (0x1403E6C00) ---

// --- Function: sub_1404AE300 (0x1404AE300) ---
_QWORD *sub_1404AE300()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  if ( !v0 )
  {
    sub_140535CF0((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A1E30(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_147E52AF0);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404AE300 (0x1404AE300) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 15;
  }
  return (__int64 *)&tls_log_structure_1[22 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: ensureCapacityAndZeroFill (0x1408E1C10) ---
char *__fastcall ensureCapacityAndZeroFill(char **pOutFieldPtrsVec, unsigned __int64 totalFieldCount)
{
  char *v2; // rbp
  char *result; // rax
  unsigned __int64 totalFieldCount_3; // rsi
  unsigned __int64 totalFieldCount_2; // rcx
  unsigned __int64 totalFieldCount_1; // rdx
  unsigned __int64 v9; // r8
  __int64 v10; // r15
  char *v11; // r14
  size_t Size; // rbx

  v2 = pOutFieldPtrsVec[1];
  result = *pOutFieldPtrsVec;
  totalFieldCount_3 = (v2 - *pOutFieldPtrsVec) >> 3;
  if ( totalFieldCount >= totalFieldCount_3 )
  {
    if ( totalFieldCount > totalFieldCount_3 )
    {
      totalFieldCount_2 = (pOutFieldPtrsVec[2] - result) >> 3;
      if ( totalFieldCount <= totalFieldCount_2 )
      {
        Size = 8 * (totalFieldCount - totalFieldCount_3);
        memset(v2, 0, Size);
        result = &v2[Size];
        pOutFieldPtrsVec[1] = &v2[Size];
      }
      else
      {
        totalFieldCount_1 = 0x1FFFFFFFFFFFFFFFLL;
        if ( totalFieldCount > 0x1FFFFFFFFFFFFFFFLL )
        {
          unknown_libname_10();
        }
        v9 = totalFieldCount_2 >> 1;
        if ( totalFieldCount_2 <= 0x1FFFFFFFFFFFFFFFLL - (totalFieldCount_2 >> 1) )
        {
          totalFieldCount_1 = v9 + totalFieldCount_2;
          if ( v9 + totalFieldCount_2 < totalFieldCount )
          {
            totalFieldCount_1 = totalFieldCount;
          }
        }
        v10 = 8 * totalFieldCount_1;
        v11 = (char *)sub_14038E0B0((__int64)pOutFieldPtrsVec, 8 * totalFieldCount_1);
        memset(&v11[8 * totalFieldCount_3], 0, 8 * (totalFieldCount - totalFieldCount_3));
        memmove(v11, *pOutFieldPtrsVec, pOutFieldPtrsVec[1] - *pOutFieldPtrsVec);
        if ( *pOutFieldPtrsVec )
        {
          sub_14039EFB0(
            (__int64)pOutFieldPtrsVec,
            *pOutFieldPtrsVec,
            (pOutFieldPtrsVec[2] - *pOutFieldPtrsVec) & 0xFFFFFFFFFFFFFFF8uLL);
        }
        *pOutFieldPtrsVec = v11;
        pOutFieldPtrsVec[1] = &v11[8 * totalFieldCount];
        result = &v11[v10];
        pOutFieldPtrsVec[2] = &v11[v10];
      }
    }
  }
  else
  {
    result += 8 * totalFieldCount;
    pOutFieldPtrsVec[1] = result;
  }
  return result;
}

// --- End Function: ensureCapacityAndZeroFill (0x1408E1C10) ---

// --- Function: sub_147218A50 (0x147218A50) ---
_QWORD *__fastcall sub_147218A50(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // r15
  unsigned __int64 v6; // rsi
  __int64 v14; // rdi
  __int64 v15; // rdi
  _QWORD *v19; // [rsp+90h] [rbp+18h]

  v19 = a3;
  v4 = a1[3];
  v5 = 0LL;
  v6 = v4 & (a4 >> 7);
  _XMM7 = a4 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v6 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
    {
      break;
    }
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = *a1 + a1[3];
      return a2;
    }
    v5 += 16LL;
    v6 = v4 & (v6 + v5);
    if ( v5 > a1[3] )
    {
      __debugbreak();
    }
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v14, _EBX);
    v15 = v4 & (v14 + v6);
    if ( !(unsigned int)sub_1403DFBE0((unsigned __int8 **)(72 * v15 + a1[1]), a3) )
    {
      break;
    }
    a3 = v19;
    _EBX &= _EBX - 1;
    if ( !_EBX )
    {
      goto LABEL_5;
    }
  }
  *a2 = v15 + *a1;
  a2[1] = 72 * v15 + a1[1];
  return a2;
}

// --- End Function: sub_147218A50 (0x147218A50) ---

// --- Function: DataCore::GetStructFieldPointers (0x14723EB40) ---
// Retrieves pointers to the field descriptors for a given structure identifier
// within the DataCore object.  If `includeChain` is true, it traverses a chain of
// related structure descriptors (e.g., base types or includes) starting from the
// one identified by `structIdentifier`, collecting fields from all of them. Fields
// from chained descriptors are added after the fields from the initial descriptor.
// If `includeChain` is false, only fields from the structure directly identified
// by `structIdentifier` are retrieved.  The function resizes the output vector
// `pOutFieldPtrsVec` and populates it with pointers to the field descriptors (each
// assumed to be 40 bytes).  @param pDataCore Pointer to the CDataCore instance.
// @param structIdentifier Identifier (e.g., name hash or pointer) used to look up
// the initial structure descriptor. @param pOutFieldPtrsVec Pointer to a vector-
// like structure (`begin`, `end`, `capacity_end` pointers) that will be populated
// with field descriptor pointers. @param includeChain If true, retrieves fields
// from the entire structure chain; otherwise, only from the specified structure.
char *__fastcall DataCore::GetStructFieldPointers(
        __int64 pDataCore,
        __int64 structIdentifier,
        char **pOutFieldPtrsVec,
        char includeChain)
{
  char *chainDescIndex_1; // rax
  const char *pNextStructIdentifier; // rbx
  unsigned __int64 chainDescCount; // r14
  signed __int64 pCurrentChainDesc; // rax
  int logFlags; // r15d
  __int64 *pLogContext; // rax
  unsigned __int64 totalFieldCount; // r15
  unsigned __int64 outVecIndex; // rbx
  unsigned __int64 chainDescCount_1; // rax
  char *pDescFromBuffer; // rcx
  __int64 descFieldCount; // rdx
  __int64 chainDescIndex; // r11
  char *pDescFromBufferReverse; // r9
  unsigned __int64 chainDescIndex_3; // r10
  int chainDescIndex_2; // edx
  char *chainDescIndex_4; // r14
  unsigned __int64 totalFieldCount_1; // rbx
  int totalFieldCount_2; // esi
  unsigned __int64 outVecIndexSingle; // rdx
  __int64 descFieldIndexInc; // rcx
  __int64 pCurrentField; // r8
  int n232; // [rsp+50h] [rbp-B0h] BYREF
  int n31; // [rsp+54h] [rbp-ACh]
  __int64 p_n232; // [rsp+58h] [rbp-A8h] BYREF
  __int64 *p_p_n232; // [rsp+60h] [rbp-A0h]
  __int128 a7; // [rsp+68h] [rbp-98h] BYREF
  char *chainDescIndex_5; // [rsp+80h] [rbp-80h]
  __m256 v33; // [rsp+88h] [rbp-78h]
  __m256 v34; // [rsp+A8h] [rbp-58h]
  __m256 v35; // [rsp+C8h] [rbp-38h]
  __int128 v36; // [rsp+E8h] [rbp-18h]
  __int64 v37; // [rsp+F8h] [rbp-8h]

  if ( *pOutFieldPtrsVec != pOutFieldPtrsVec[1] )
  {
    pOutFieldPtrsVec[1] = *pOutFieldPtrsVec;
  }
  if ( includeChain )
  {
    chainDescIndex_1 = (char *)DataCore::LookupDCStructDescByName(pDataCore, structIdentifier);
    if ( chainDescIndex_1 )
    {
      pNextStructIdentifier = (const char *)*((_QWORD *)chainDescIndex_1 + 3);
      v37 = 0;
      chainDescIndex_5 = chainDescIndex_1;
      chainDescCount = 1;
      v33 = (__m256)0LL;
      v34 = (__m256)0LL;
      v35 = (__m256)0LL;
      v36 = 0;
      if ( pNextStructIdentifier )
      {
        while ( 1 )
        {
          __asm { vzeroupper }
          pCurrentChainDesc = DataCore::LookupDCStructDescByName(pDataCore, (__int64)pNextStructIdentifier);
          if ( !pCurrentChainDesc )
          {
            break;
          }
          pNextStructIdentifier = *(const char **)(pCurrentChainDesc + 24);
          (&chainDescIndex_5)[chainDescCount++] = (char *)pCurrentChainDesc;
          if ( !pNextStructIdentifier )
          {
            goto LABEL_11;
          }
        }
        n232 = 232;
        p_n232 = (__int64)&n232;
        n31 = 31;
        p_p_n232 = &p_n232;
        logFlags = invokeGlobalCallbackAndMaskStatusBits(
                     3,
                     (__int64)&p_n232,
                     (__int64)"[DataCore] CDataCore::GetStructDataFields - [%s] has no DCStructDesc",
                     pNextStructIdentifier);
        if ( (logFlags & 0xFFFFF) != 0 )
        {
          pLogContext = getThreadLogContextSlot();
          p_n232 = (__int64)&n232;
          p_p_n232 = &p_n232;
          n232 = 232;
          a7 = 0;
          n31 = 31;
          submitTraceContext(
            3,
            (__int64)&p_n232,
            "[DataCore] CDataCore::GetStructDataFields - [%s] has no DCStructDesc",
            (__int64)pNextStructIdentifier,
            1,
            logFlags,
            &a7,
            0,
            (__int64)pLogContext);
        }
      }
LABEL_11:
      totalFieldCount = 0;
      outVecIndex = 0;
      for ( chainDescCount_1 = 0; chainDescCount_1 < chainDescCount; ++chainDescCount_1 )
      {
        pDescFromBuffer = (&chainDescIndex_5)[chainDescCount_1];
        if ( pDescFromBuffer )
        {
          descFieldCount = *((_QWORD *)pDescFromBuffer + 1);
        }
        else
        {
          descFieldCount = 0;
        }
        totalFieldCount += descFieldCount;
      }
      __asm { vzeroupper }
      chainDescIndex_1 = ensureCapacityAndZeroFill(pOutFieldPtrsVec, totalFieldCount);
      if ( totalFieldCount )
      {
        chainDescIndex_1 = (char *)(unsigned int)(chainDescCount - 1);
        for ( chainDescIndex = (int)chainDescIndex_1; chainDescIndex >= 0; --chainDescIndex )
        {
          pDescFromBufferReverse = (&chainDescIndex_5)[chainDescIndex];
          if ( pDescFromBufferReverse )
          {
            chainDescIndex_3 = *((_QWORD *)pDescFromBufferReverse + 1);
            chainDescIndex_2 = 0;
            if ( chainDescIndex_3 )
            {
              chainDescIndex_1 = 0;
              do
              {
                if ( (pOutFieldPtrsVec[1] - *pOutFieldPtrsVec) >> 3 <= outVecIndex )
                {
                  __debugbreak();
                }
                ++chainDescIndex_2;
                *(_QWORD *)&(*pOutFieldPtrsVec)[8 * outVecIndex++] = *(_QWORD *)pDescFromBufferReverse
                                                                   + 40LL * (_QWORD)chainDescIndex_1;
                chainDescIndex_1 = (char *)chainDescIndex_2;
              }
              while ( chainDescIndex_2 < chainDescIndex_3 );
            }
          }
        }
      }
    }
  }
  else
  {
    chainDescIndex_1 = (char *)DataCore::LookupDCStructDescByName(pDataCore, structIdentifier);
    chainDescIndex_4 = chainDescIndex_1;
    if ( chainDescIndex_1 )
    {
      totalFieldCount_1 = *((_QWORD *)chainDescIndex_1 + 1);
      chainDescIndex_1 = ensureCapacityAndZeroFill(pOutFieldPtrsVec, totalFieldCount_1);
      totalFieldCount_2 = 0;
      if ( totalFieldCount_1 )
      {
        outVecIndexSingle = 0;
        descFieldIndexInc = 0;
        do
        {
          pCurrentField = *(_QWORD *)chainDescIndex_4 + 40 * descFieldIndexInc;
          if ( (pOutFieldPtrsVec[1] - *pOutFieldPtrsVec) >> 3 <= outVecIndexSingle )
          {
            __debugbreak();
          }
          chainDescIndex_1 = *pOutFieldPtrsVec;
          descFieldIndexInc = ++totalFieldCount_2;
          *(_QWORD *)&(*pOutFieldPtrsVec)[8 * outVecIndexSingle++] = pCurrentField;
        }
        while ( totalFieldCount_2 < totalFieldCount_1 );
      }
    }
  }
  return chainDescIndex_1;
}

// --- End Function: DataCore::GetStructFieldPointers (0x14723EB40) ---

// --- Function: DataCore::LookupDCStructDescByName (0x14723EDF0) ---
signed __int64 __fastcall DataCore::LookupDCStructDescByName(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rdx
  __int64 i; // r8
  __int64 v6; // rcx
  __m128i v7; // xmm0
  __int64 v9; // [rsp+20h] [rbp-28h] BYREF
  char *v10; // [rsp+28h] [rbp-20h] BYREF
  __m128i v11; // [rsp+30h] [rbp-18h] BYREF

  v9 = a2;
  sub_140357780(&v10, &v9);
  v3 = -1LL;
  do
  {
    ++v3;
  }
  while ( v10[v3] );
  v4 = 0LL;
  for ( i = 0xCBF29CE484222325uLL; v4 < v3; i = 0x100000001B3LL * (v6 ^ i) )
  {
    v6 = (unsigned __int8)v10[v4++];
  }
  v7 = *(__m128i *)sub_147218A50(
                     (_QWORD *)(a1 + 304),
                     &v11,
                     &v10,
                     0xDE5FB9D2630458E9uLL * i
                   + (((unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
  v10 = (char *)&qword_149808ABC + 4;
  v11 = v7;
  DestroyStringObject(&v10);
  if ( v11.m128i_i64[0] == *(_QWORD *)(a1 + 304) + *(_QWORD *)(a1 + 328) )
  {
    return 0LL;
  }
  else
  {
    return _mm_extract_epi64(v11, 1) + 8;
  }
}

// --- End Function: DataCore::LookupDCStructDescByName (0x14723EDF0) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memmove (0x147E162C1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x147E162C1) ---

// --- Function: memset (0x147E162C7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x147E162C7) ---

