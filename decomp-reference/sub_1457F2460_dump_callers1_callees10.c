// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1457F2460 (sub_1457F2460)
// Caller Depth: 1
// Callee/Ref Depth: 10
// Total Functions Found: 183
// ------------------------------------------------------------

// --- Function: identity_int64 (0x1402A24F0) ---
// This function is a simple identity function that returns its single __int64
// argument unchanged. It effectively acts as a pass-through.
__int64 __fastcall identity_int64(__int64 a1)
{
  return a1;
}

// --- End Function: identity_int64 (0x1402A24F0) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 39 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 39);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 - 1) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---

// --- Function: unknown_libname_472 (0x1402AE2A0) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_472(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_472 (0x1402AE2A0) ---

// --- Function: sub_1402AE7E0 (0x1402AE7E0) ---
__int64 __fastcall sub_1402AE7E0(__int64 a1)
{
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

// --- End Function: sub_1402AE7E0 (0x1402AE7E0) ---

// --- Function: sub_1402B1640 (0x1402B1640) ---
void __fastcall sub_1402B1640(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: sub_1402B1640 (0x1402B1640) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: ?_HasCapturedContext@_ContextCallback@details@Concurrency@@QEBA_NXZ (0x1402B50D0) ---
bool __fastcall Concurrency::details::_ContextCallback::_HasCapturedContext(
        Concurrency::details::_ContextCallback *this)
{
  return *(_QWORD *)this != 0;
}

// --- End Function: ?_HasCapturedContext@_ContextCallback@details@Concurrency@@QEBA_NXZ (0x1402B50D0) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: sub_140305ED0 (0x140305ED0) ---
float *__fastcall sub_140305ED0(float *a1, float *a2)
{
  __int128 v2; // kr00_16
  float v9; // xmm0_4
  float v10; // xmm0_4
  float v11; // xmm4_4
  float Y; // xmm0_4
  float X; // xmm1_4
  float v14; // xmm2_4
  float v15; // xmm2_4
  float v16; // kr00_4
  float v17; // xmm0_4
  float *result; // rax

  v2 = *(unsigned int *)a2;
  *(float *)&v2 = (float)((float)(*a2 * a2[2]) - (float)(a2[3] * a2[1])) * -2.0;
  _XMM1 = v2;
  LODWORD(_XMM0) = 0xBF800000;
  __asm
  {
    vminss  xmm2, xmm1, xmm6
    vmaxss  xmm3, xmm2, xmm0
  }
  if ( *(float *)&_XMM3 >= -1.0 )
    __asm { vminss  xmm0, xmm3, xmm6; X }
  v9 = asinf(*(float *)&_XMM0);
  a1[1] = v9;
  if ( fabs(COERCE_FLOAT(LODWORD(v9) & 0x7FFFFFFF) - 1.5707964) >= 0.0099999998 )
  {
    v14 = a2[1];
    *a1 = atan2f(
            (float)((float)(*a2 * a2[3]) + (float)(*a2 * a2[3])) + (float)((float)(v14 * a2[2]) + (float)(v14 * a2[2])),
            1.0
          - (float)((float)((float)(*a2 * *a2) + (float)(*a2 * *a2)) + (float)((float)(v14 * v14) + (float)(v14 * v14))));
    v15 = a2[2];
    v16 = a2[1];
    Y = (float)((float)(v16 * *a2) + (float)(v16 * *a2)) + (float)((float)(v15 * a2[3]) + (float)(v15 * a2[3]));
    X = 1.0
      - (float)((float)((float)(v16 * v16) + (float)(v16 * v16)) + (float)((float)(v15 * v15) + (float)(v15 * v15)));
  }
  else
  {
    *a1 = 0.0;
    v10 = a2[2];
    v11 = v10 * v10;
    Y = (float)((float)(*a2 * a2[1]) - (float)(v10 * a2[3])) * -2.0;
    X = 1.0 - (float)((float)((float)(*a2 * *a2) + (float)(*a2 * *a2)) + (float)(v11 + v11));
  }
  v17 = atan2f(Y, X);
  result = a1;
  a1[2] = v17;
  return result;
}

// --- End Function: sub_140305ED0 (0x140305ED0) ---

// --- Function: sub_140306040 (0x140306040) ---
float *__fastcall sub_140306040(float *a1, float *a2, float *a3)
{
  float v3; // xmm1_4

  v3 = *a2 - *a3;
  a1[1] = a2[1] - a3[1];
  *a1 = v3;
  return a1;
}

// --- End Function: sub_140306040 (0x140306040) ---

// --- Function: sub_140306070 (0x140306070) ---
float *__fastcall sub_140306070(float *a1, float *a2, float *a3)
{
  float v3; // xmm1_4

  v3 = *a2 + *a3;
  a1[1] = a2[1] + a3[1];
  *a1 = v3;
  return a1;
}

// --- End Function: sub_140306070 (0x140306070) ---

// --- Function: sub_140306140 (0x140306140) ---
__int64 __fastcall sub_140306140(__int64 a1, __int64 a2)
{
  return -a2 & (a1 + a2 - 1);
}

// --- End Function: sub_140306140 (0x140306140) ---

// --- Function: sub_140309960 (0x140309960) ---
__int64 __fastcall sub_140309960(__int64 a1, __int64 a2)
{
  *(_DWORD *)(a1 + 0xC) = *(_DWORD *)(a2 + 0xC);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(double *)(a1 + 0x10) = *(double *)(a2 + 0x10);
  *(_DWORD *)(a1 + 0x18) = *(_DWORD *)(a2 + 0x18);
  return a1;
}

// --- End Function: sub_140309960 (0x140309960) ---

// --- Function: validateHandleAccess (0x14030EC00) ---
// Validates a given handle by checking its internal type, flags, and thread-
// specific access permissions. It extracts the raw pointer and flags from the
// handle, then performs checks against metadata associated with the handle. It
// also verifies if the current thread's context or global settings permit access
// to the handle based on its type.
bool __fastcall validateHandleAccess(unsigned __int64 *a1)
{
  unsigned __int64 handleValue; // r9
  __int64 rawPointer; // r10
  unsigned __int64 handleFlags; // r9
  __int64 flagMask; // rax
  __int64 metadataBase; // r10
  __int64 metadataPtr; // rbx
  bool isThreadAccessPermitted; // al

  handleValue = *a1;
  if ( !*a1 )
    return 0;
  rawPointer = handleValue & 0xFFFFFFFFFFFFLL;
  handleFlags = HIWORD(handleValue);
  if ( (handleFlags & 0xF000) != 0 )
  {
    flagMask = map_flag_to_mask(0x2000u);
    metadataPtr = metadataBase & ~(flagMask - 1);
  }
  else
  {
    metadataPtr = rawPointer - 6;
  }
  if ( *(_WORD *)(metadataPtr + 2) != (handleFlags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (isThreadAccessPermitted = sub_140539D80()) )
    isThreadAccessPermitted = 1;
  return *(_WORD *)(metadataPtr + 4) == 2 && isThreadAccessPermitted || sub_140392020(a1) != 0;
}

// --- End Function: validateHandleAccess (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 24576 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_140359CF0 (0x140359CF0) ---
float *__fastcall sub_140359CF0(float *a1, float *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

// --- End Function: sub_140359CF0 (0x140359CF0) ---

// --- Function: sub_140370740 (0x140370740) ---
__int64 __fastcall sub_140370740(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 0xE0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)a1 = 6;
  *(_QWORD *)(a1 + 0x38) = 0x8000000000000000uLL;
  result = a1;
  *(_DWORD *)(a1 + 0x10) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x28) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x34) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 4) = 0x80000000;
  *(_DWORD *)(a1 + 8) = 0x80000000;
  *(_DWORD *)(a1 + 0x60) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x64) = 0xFFBFFFFF;
  *(_QWORD *)(a1 + 0x70) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x78) = 0x80000000;
  *(_QWORD *)(a1 + 0x80) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x90) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x68) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x6C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x88) = 0x80000000;
  *(_DWORD *)(a1 + 0x9C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xA4) = 0x80000000;
  *(_QWORD *)(a1 + 0xA8) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0xB0) = 0x80000000;
  *(_DWORD *)(a1 + 0xB4) = 0x80000000;
  *(_DWORD *)(a1 + 0xB8) = 0x80000000;
  *(_DWORD *)(a1 + 0xBC) = 0x80000000;
  *(_DWORD *)(a1 + 0xD0) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xD4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xD8) = 0xFFBFFFFF;
  *(_QWORD *)(a1 + 0xF0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x2C) = 0x80000000;
  *(_DWORD *)(a1 + 0xF8) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xE8) = 0x80000000;
  *(_OWORD *)(a1 + 0xC0) = xmmword_1481AD6E0;
  *(_DWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0xC) = 1;
  *(_DWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x58) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x48) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_DWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = 0;
  return result;
}

// --- End Function: sub_140370740 (0x140370740) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_14037F610 (0x14037F610) ---
bool __fastcall sub_14037F610(__int64 a1, __int64 a2)
{
  return a1 != a2;
}

// --- End Function: sub_14037F610 (0x14037F610) ---

// --- Function: j_validateHandleAccess (0x14037F760) ---
// attributes: thunk
bool __fastcall j_validateHandleAccess(unsigned __int64 *a1)
{
  return validateHandleAccess(a1);
}

// --- End Function: j_validateHandleAccess (0x14037F760) ---

// --- Function: sub_14037FB90 (0x14037FB90) ---
bool __fastcall sub_14037FB90(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) != 0;
}

// --- End Function: sub_14037FB90 (0x14037FB90) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1 & 0xFFFFFFFFFFFFLL, 0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: HIWORD_w (0x14037FC90) ---
bool __fastcall HIWORD_w(_QWORD *a1)
{
  return *a1 && *(_QWORD *)((*a1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*a1);
}

// --- End Function: HIWORD_w (0x14037FC90) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_140392370 (0x140392370) ---
const vraudio::AudioBuffer *__fastcall sub_140392370(__int64 a1, const vraudio::AudioBuffer **__Val_0_)
{
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer *result; // rax

  _Whereptr = *(const vraudio::AudioBuffer ***)(a1 + 0x20);
  if ( _Whereptr == *(const vraudio::AudioBuffer ***)(a1 + 0x28) )
    return (const vraudio::AudioBuffer *)std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                                           (std::vector<vraudio::AudioBuffer const *> *)(a1 + 0x18),
                                           _Whereptr,
                                           __Val_0_);
  result = *__Val_0_;
  *_Whereptr = *__Val_0_;
  *(_QWORD *)(a1 + 0x20) += 8LL;
  return result;
}

// --- End Function: sub_140392370 (0x140392370) ---

// --- Function: sub_140392480 (0x140392480) ---
__int64 __fastcall sub_140392480(__int64 a1, unsigned __int8 *p_p_EntityComponentSimpleRotation)
{
  __int64 p_EntityComponentSimpleRotation; // rax

  p_EntityComponentSimpleRotation = *p_p_EntityComponentSimpleRotation;
  *(_BYTE *)(a1 + 3) = p_EntityComponentSimpleRotation;
  return p_EntityComponentSimpleRotation;
}

// --- End Function: sub_140392480 (0x140392480) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403BFC90 (0x1403BFC90) ---
bool __fastcall sub_1403BFC90(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  return v1 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x20LL))(v1);
}

// --- End Function: sub_1403BFC90 (0x1403BFC90) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 192LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 16) & (unsigned int)(v9 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 = (v5 << 16) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 284) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 216LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403E2E40 (0x1403E2E40) ---
__int64 __fastcall sub_1403E2E40(__int64 a1, __int64 a2)
{
  HMODULE hModule; // rax
  FARPROC ProcAddress; // rbx
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  ProcAddress = GetProcAddress(hModule, "___cigFetchNonWrapFunction___");
  if ( !ProcAddress )
  {
    hModule_1 = LoadLibraryA(0);
    if ( hModule_1 )
      ProcAddress = GetProcAddress(hModule_1, "___cigFetchNonWrapFunction___");
  }
  return ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a1, a2);
}

// --- End Function: sub_1403E2E40 (0x1403E2E40) ---

// --- Function: sub_1403E35D0 (0x1403E35D0) ---
__int64 __fastcall sub_1403E35D0(volatile signed __int64 *a1, _QWORD *a2)
{
  __m128i v2; // rt0
  __m128i i; // xmm0
  signed __int64 epi64; // r9
  __int64 result; // rax
  __m128i v6; // rt0
  __m128i v7; // [rsp+10h] [rbp-28h]

  v2 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v2.m128i_i64);
  for ( i = v2; ; i = v7 )
  {
    if ( a2 == (_QWORD *)i.m128i_i64[0] )
      __debugbreak();
    epi64 = _mm_extract_epi64(i, 1);
    *a2 = i.m128i_i64[0];
    v6.m128i_i64[0] = i.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, epi64 + 1, (signed __int64)a2, v6.m128i_i64);
    result = v6.m128i_i64[0];
    v7 = v6;
    if ( *(_OWORD *)&v6 == __PAIR128__(epi64, i.m128i_u64[0]) )
      break;
  }
  return result;
}

// --- End Function: sub_1403E35D0 (0x1403E35D0) ---

// --- Function: EnterCriticalSection (0x1403E3690) ---
// attributes: thunk
void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_EnterCriticalSection(lpCriticalSection);
}

// --- End Function: EnterCriticalSection (0x1403E3690) ---

// --- Function: LeaveCriticalSection (0x1403E3CD0) ---
// attributes: thunk
void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_LeaveCriticalSection(lpCriticalSection);
}

// --- End Function: LeaveCriticalSection (0x1403E3CD0) ---

// --- Function: sub_1403E6750 (0x1403E6750) ---
unsigned __int64 __fastcall sub_1403E6750(unsigned __int64 *a1)
{
  if ( validateHandleAccess(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6750 (0x1403E6750) ---

// --- Function: sub_1403E6790 (0x1403E6790) ---
__int64 __fastcall sub_1403E6790(__int64 a1)
{
  return *(unsigned int *)(a1 + 0x21C);
}

// --- End Function: sub_1403E6790 (0x1403E6790) ---

// --- Function: _snprintf_s (0x1403ECF60) ---
int snprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = (unsigned __int64 *)sub_1402A4380();
  result = _stdio_common_vsnprintf_s(*v8, DstBuf, SizeInBytes, MaxCount, Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: _snprintf_s (0x1403ECF60) ---

// --- Function: sub_1404620B0 (0x1404620B0) ---
__int64 __fastcall sub_1404620B0(__int64 *a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    return sub_140522CF0(v1);
  return result;
}

// --- End Function: sub_1404620B0 (0x1404620B0) ---

// --- Function: sub_14049ABA0 (0x14049ABA0) ---
const ULONG_PTR *__fastcall sub_14049ABA0(__int64 a1, unsigned int *a2)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  volatile signed __int32 *v5; // rbx
  int v6; // esi
  unsigned __int32 v7; // eax
  int v8; // eax
  unsigned __int32 v9; // eax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)sub_140500AC0(a1 + 0x240, *a2);
  if ( !(_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source )
  {
    v5 = (volatile signed __int32 *)(a1 + 0x2D8);
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x2E8) == v6 )
    {
      ++*(_DWORD *)(a1 + 0x2EC);
    }
    else
    {
      v7 = _InterlockedCompareExchange(v5, 1, 0);
      if ( v7 )
        sub_1403C33A0(
          a1 + 0x2D8,
          v7,
          "DeferredActionQueue<struct DefaultRayCaster<47>,struct RayCastRequest,struct RayCastResult,struct DefaultContention>::Cancel",
          1);
      else
        *(_QWORD *)(a1 + 0x2E0) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x2E8) = v6;
    }
    sub_1405002A0(a1 + 0x228, a2);
    v8 = *(_DWORD *)(a1 + 0x2EC);
    if ( v8 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v8 - 1);
      *(_DWORD *)(a1 + 0x2EC) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      *(_DWORD *)(a1 + 0x2E8) = 0xFFFFFFFF;
      v9 = _InterlockedCompareExchange(v5, 0, 1);
      if ( v9 == 1 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(a1 + 0x2E0) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return sub_1403DB1F0(a1 + 0x2D8, v9);
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14049ABA0 (0x14049ABA0) ---

// --- Function: sub_1404B6AF0 (0x1404B6AF0) ---
double *__fastcall sub_1404B6AF0(double *a1, double *a2)
{
  double v2; // xmm4_8
  __int64 v3; // xmm1_8
  double *result; // rax
  double v5; // xmm12_8
  double v6; // xmm10_8
  double v7; // xmm8_8
  double v8; // xmm15_8
  double v9; // xmm11_8
  double v10; // xmm9_8
  double v11; // xmm7_8
  double v12; // xmm6_8
  double v13; // xmm4_8

  v2 = a1[3];
  v3 = *(_QWORD *)a1;
  result = a2;
  v5 = a1[6];
  v6 = a1[5];
  v7 = a1[4];
  v8 = 1.0 / a1[7];
  *(_QWORD *)&v9 = *((_QWORD *)a1 + 1) ^ 0x8000000000000000uLL;
  *(_QWORD *)&v10 = *((_QWORD *)a1 + 2) ^ 0x8000000000000000uLL;
  a2[3] = v2;
  v11 = v9 * v5 - v10 * v6 + v2 * v7;
  v12 = v10 * v7 - v5 * COERCE_DOUBLE(v3 ^ 0x8000000000000000uLL) + v2 * v6;
  v13 = v6 * COERCE_DOUBLE(v3 ^ 0x8000000000000000uLL) - v9 * v7 + v2 * v5;
  a2[7] = v8;
  *a2 = COERCE_DOUBLE(v3 ^ 0x8000000000000000uLL);
  a2[1] = v9;
  a2[2] = v10;
  a2[4] = (v7 + v9 * v13 - v10 * v12 + v9 * v13 - v10 * v12) * COERCE_DOUBLE(*(_QWORD *)&v8 ^ 0x8000000000000000uLL);
  a2[5] = (v6
         + v10 * v11
         - COERCE_DOUBLE(v3 ^ 0x8000000000000000uLL) * v13
         + v10 * v11
         - COERCE_DOUBLE(v3 ^ 0x8000000000000000uLL) * v13)
        * COERCE_DOUBLE(*(_QWORD *)&v8 ^ 0x8000000000000000uLL);
  a2[6] = (v5
         + COERCE_DOUBLE(v3 ^ 0x8000000000000000uLL) * v12
         - v9 * v11
         + COERCE_DOUBLE(v3 ^ 0x8000000000000000uLL) * v12
         - v9 * v11)
        * COERCE_DOUBLE(*(_QWORD *)&v8 ^ 0x8000000000000000uLL);
  return result;
}

// --- End Function: sub_1404B6AF0 (0x1404B6AF0) ---

// --- Function: sub_1405002A0 (0x1405002A0) ---
__int64 __fastcall sub_1405002A0(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rbp
  _DWORD *v4; // r8
  unsigned __int64 v6; // rdx
  _DWORD *v7; // rsi
  _DWORD *v8; // rbx
  void (__fastcall *n2)(__int64, _DWORD *); // rax
  _QWORD *v10; // rdi
  void (__fastcall *v11)(__int64, _DWORD *, _DWORD *); // r9
  void (__fastcall *n2_1)(__int64, _DWORD *); // rax
  __int64 v13; // rbx
  void (__fastcall *n2_2)(__int64, __int64); // r9
  __int64 result; // rax

  v2 = *(_DWORD **)(a1 + 8);
  v4 = *(_DWORD **)a1;
  v6 = ((__int64)v2 - *(_QWORD *)a1) / 0x28;
  while ( v6 )
  {
    if ( v4[0xA * (v6 >> 1)] >= *a2 )
    {
      v6 >>= 1;
    }
    else
    {
      v4 += 0xA * (v6 >> 1) + 0xA;
      v6 += 0xFFFFFFFFFFFFFFFFuLL - (v6 >> 1);
    }
  }
  if ( v4 == v2 || *a2 < *v4 )
    return 0;
  v7 = v4 + 0xA;
  if ( v4 + 0xA != v2 )
  {
    v8 = v4 + 2;
    while ( 1 )
    {
      v8[0xFFFFFFFE] = *v7;
      n2 = (void (__fastcall *)(__int64, _DWORD *))*((_QWORD *)v8 + 1);
      if ( (unsigned __int64)n2 >= 2 )
      {
        n2(2, v8);
        *((_QWORD *)v8 + 1) = 0;
      }
      *(_QWORD *)v8 = 0;
      v10 = v8 + 0xA;
      v11 = (void (__fastcall *)(__int64, _DWORD *, _DWORD *))*((_QWORD *)v8 + 6);
      if ( v11 == (void (__fastcall *)(__int64, _DWORD *, _DWORD *))1 )
        break;
      if ( v11 )
      {
        v11(1, v8, v8 + 0xA);
        n2_1 = (void (__fastcall *)(__int64, _DWORD *))*((_QWORD *)v8 + 6);
        if ( (unsigned __int64)n2_1 >= 2 )
        {
          n2_1(2, v8 + 0xA);
          *((_QWORD *)v8 + 6) = 0;
        }
        goto LABEL_17;
      }
LABEL_18:
      v7 += 0xA;
      *((_BYTE *)v8 + 0x18) = *((_BYTE *)v8 + 0x40);
      v8 += 0xA;
      if ( v7 == v2 )
        goto LABEL_19;
    }
    *(_QWORD *)v8 = *v10;
    *((_QWORD *)v8 + 1) = 1;
LABEL_17:
    *v10 = 0;
    goto LABEL_18;
  }
LABEL_19:
  v13 = *(_QWORD *)(a1 + 8);
  n2_2 = *(void (__fastcall **)(__int64, __int64))(v13 - 0x18);
  if ( (unsigned __int64)n2_2 >= 2 )
  {
    n2_2(2, v13 - 0x20);
    *(_QWORD *)(v13 - 0x18) = 0;
  }
  *(_QWORD *)(v13 - 0x20) = 0;
  result = 1;
  *(_QWORD *)(a1 + 8) -= 0x28LL;
  return result;
}

// --- End Function: sub_1405002A0 (0x1405002A0) ---

// --- Function: sub_140500AC0 (0x140500AC0) ---
__int64 __fastcall sub_140500AC0(__int64 a1, unsigned int a2)
{
  __int64 v3; // rdi
  signed __int64 v5; // rdx
  __int64 v6; // r9
  unsigned __int64 v7; // r8
  int v8; // esi
  __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r8
  char v13; // si
  int v14; // eax
  unsigned __int64 n0x200000; // rax
  unsigned __int8 v16; // bl

  v3 = a1 + 0x18;
  if ( *(_DWORD *)(a1 + 0x28) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)v3);
    if ( (v5 & 0x200000) != 0 )
      sub_1403CB300(
        v3,
        v5,
        "CigAgePriorityQueue<struct DeferredActionQueue<struct DefaultRayCaster<47>,struct RayCastRequest,struct RayCastR"
        "esult,struct DefaultContention>::QueuedRequest,float,float>::erase_TS",
        "m_slotLock",
        1);
  }
  v6 = *(_QWORD *)(a1 + 0x30);
  v7 = (a2 & 0x1FFFF) - 1;
  if ( v7 >= (*(_QWORD *)(a1 + 0x38) - v6) / 0x118
    || (*(_WORD *)(0x118 * v7 + v6 + 0x114) & 0x7FFF) != a2 >> 0x11
    || *(__int16 *)(0x118 * v7 + v6 + 0x114) < 0 )
  {
    goto LABEL_25;
  }
  v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v8 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v9 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v10 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0x200000, 0);
    if ( v10 )
      sub_1403DCD60(
        a1,
        v10,
        v9,
        "CigAgePriorityQueue<struct DeferredActionQueue<struct DefaultRayCaster<47>,struct RayCastRequest,struct RayCastR"
        "esult,struct DefaultContention>::QueuedRequest,float,float>::erase_TS",
        "m_queueLock",
        1);
    else
      *(_QWORD *)(a1 + 8) = v9;
    *(_DWORD *)(a1 + 0x10) = v8;
  }
  v11 = unknown_libname_247(*(_QWORD *)(a1 + 0x60), *(_QWORD *)(a1 + 0x68), a2);
  v12 = *(_QWORD *)(a1 + 0x68);
  if ( v11 == v12 )
  {
    v13 = 0;
  }
  else
  {
    memmove((void *)v11, (const void *)(v11 + 4), v12 - (v11 + 4));
    *(_QWORD *)(a1 + 0x68) -= 4LL;
    v13 = 1;
  }
  if ( a1 )
  {
    v14 = *(_DWORD *)(a1 + 0x14);
    if ( v14 )
    {
      *(_DWORD *)(a1 + 0x14) = v14 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DD380(a1, n0x200000);
    }
  }
  if ( v13 )
  {
    sub_1404FF320(a1, a2);
    v16 = 1;
  }
  else
  {
LABEL_25:
    v16 = 0;
  }
  sub_1402D2790(v3);
  return v16;
}

// --- End Function: sub_140500AC0 (0x140500AC0) ---

// --- Function: sub_140522CF0 (0x140522CF0) ---
__int64 __fastcall sub_140522CF0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC00 + 0x228LL))(qword_149B4FC00, a1);
}

// --- End Function: sub_140522CF0 (0x140522CF0) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10(a3);
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DBC0 (0x14056DBC0) ---
__int64 __fastcall sub_14056DBC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E2E40(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056DBC0 (0x14056DBC0) ---

// --- Function: sub_14056DD10 (0x14056DD10) ---
// attributes: thunk
__int64 sub_14056DD10()
{
  return qword_149B4F990();
}

// --- End Function: sub_14056DD10 (0x14056DD10) ---

// --- Function: sub_1405A5A20 (0x1405A5A20) ---
bool __fastcall sub_1405A5A20(_DWORD *a1)
{
  return (*a1 & 0xFFA00000) == 0xFFA00000;
}

// --- End Function: sub_1405A5A20 (0x1405A5A20) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Logs a fatal error message. If the fatal error system is not properly
// initialized (missing necessary function pointers), it triggers a debug break.
// Otherwise, it formats the provided message into a buffer and dispatches it to an
// external logging function. Execution typically halts after this function.
_BYTE *LogFatalError(const char *formatString, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC pfnInitFatalFunctionsAddr; // rax
  _BYTE *result; // rax
  _QWORD *pStdioCommonVsnprintf; // rax
  int formattedMessageLength; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, formatString);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    pfnInitFatalFunctionsAddr = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))pfnInitFatalFunctionsAddr)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    pStdioCommonVsnprintf = sub_1402A4380();
    formattedMessageLength = _stdio_common_vsprintf(
                               *pStdioCommonVsnprintf | 2LL,
                               formattedMessageBuffer,
                               0x1000u,
                               formatString,
                               0,
                               args);
    if ( formattedMessageLength < 0 )
      formattedMessageLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedMessageLength >= 0x1000 )
      formattedMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_141848E00 (0x141848E00) ---
_QWORD *__fastcall sub_141848E00(_QWORD *p_pExceptionObject)
{
  p_pExceptionObject[1] = "bad allocation";
  *p_pExceptionObject = off_1481A05A8;
  return p_pExceptionObject;
}

// --- End Function: sub_141848E00 (0x141848E00) ---

// --- Function: sub_141976650 (0x141976650) ---
void __fastcall sub_141976650(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx

  v2 = (_QWORD *)a1[0xB];
  if ( v2 )
  {
    if ( ((a1[0xD] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        goto LABEL_12;
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[0xB] = 0;
    a1[0xC] = 0;
    a1[0xD] = 0;
  }
  v3 = (_QWORD *)a1[7];
  if ( !v3 )
    return;
  if ( ((a1[9] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
  {
    if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v3 = (_QWORD *)v3[0xFFFFFFFF];
      goto LABEL_10;
    }
LABEL_12:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_1402A3D30(v3);
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
}

// --- End Function: sub_141976650 (0x141976650) ---

// --- Function: sub_141EF0850 (0x141EF0850) ---
__int64 __fastcall sub_141EF0850(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 0x24) = 0x3F800000;
  *(_QWORD *)(a1 + 0xC) = 0;
  *(_QWORD *)(a1 + 0x14) = 0;
  *(_QWORD *)(a1 + 0x1C) = 0;
  *(_QWORD *)(a1 + 0xB0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x48) = 0x1000004FFLL;
  result = a1;
  *(_OWORD *)(a1 + 0x90) = xmmword_14853E958;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 0x74) = 1;
  *(_QWORD *)(a1 + 0x50) = 0x81;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x3F800000;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_DWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_DWORD *)(a1 + 0xA0) = 0;
  *(_BYTE *)(a1 + 0xAC) = 0;
  *(_DWORD *)(a1 + 0x88) = 0;
  *(_DWORD *)(a1 + 0x8C) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0xA8) = 1;
  *(_DWORD *)(a1 + 0xB8) = 0;
  *(_DWORD *)(a1 + 0xA4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 8) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x40) = 0x80000000;
  *(_DWORD *)(a1 + 0x58) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x5C) = 0x80000000;
  return result;
}

// --- End Function: sub_141EF0850 (0x141EF0850) ---

// --- Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---
__int64 __fastcall std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || sub_140539D80() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: unknown_libname_484 (0x142739050) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
__int64 __fastcall unknown_libname_484(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: unknown_libname_484 (0x142739050) ---

// --- Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_2 (0x14277CFB0) ---
// Microsoft VisualC v14 64bit runtime
const char *__fastcall __crt_win32_buffer_debug_info::file_name(__crt_win32_buffer_debug_info *this)
{
  return (const char *)*((_QWORD *)this + 1);
}

// --- End Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_2 (0x14277CFB0) ---

// --- Function: Handle_GetRawPointerIfValid (0x14277D6A0) ---
// Checks if a given handle is valid using `Handle::IsValid`. If valid, it extracts
// and returns the raw pointer or value stored within the handle; otherwise, it
// returns 0.
__int64 __fastcall Handle_GetRawPointerIfValid(_QWORD *handle_ptr)
{
  if ( Handle::IsValid(handle_ptr) )
    return *handle_ptr & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: Handle_GetRawPointerIfValid (0x14277D6A0) ---

// --- Function: sub_142BB4600 (0x142BB4600) ---
__int64 __fastcall sub_142BB4600(__int64 a1, __int64 a2)
{
  if ( *(_QWORD *)(a1 + 8) == 1 )
    return (*(__int64 (__fastcall **)(__int64))a1)(a2);
  else
    return (*(__int64 (__fastcall **)(__int64, __int64))a1)(a1, a2);
}

// --- End Function: sub_142BB4600 (0x142BB4600) ---

// --- Function: sub_142BCC2B0 (0x142BCC2B0) ---
void sub_142BCC2B0(__int64 a1, ...)
{
  __int64 v1; // rax
  va_list va; // [rsp+78h] [rbp+10h] BYREF

  va_start(va, a1);
  if ( a1 )
  {
    v1 = identity_int64((__int64)&qword_149B4FBE0);
    (*(void (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD, __int64, __int64 *))(**(_QWORD **)(v1 + 0xC0)
                                                                                         + 0x158LL))(
      *(_QWORD *)(v1 + 0xC0),
      0xA,
      2,
      0,
      0,
      a1,
      (__int64 *)va);
  }
}

// --- End Function: sub_142BCC2B0 (0x142BCC2B0) ---

// --- Function: sub_142C0AB10 (0x142C0AB10) ---
_BOOL8 __fastcall sub_142C0AB10(_QWORD *a1)
{
  return *a1 == a1[1];
}

// --- End Function: sub_142C0AB10 (0x142C0AB10) ---

// --- Function: sub_142C0F3C0 (0x142C0F3C0) ---
_BOOL8 __fastcall sub_142C0F3C0(__int64 a1, int a2)
{
  return *(_DWORD *)(a1 + 8) != a2;
}

// --- End Function: sub_142C0F3C0 (0x142C0F3C0) ---

// --- Function: sub_142D28950 (0x142D28950) ---
__int64 __fastcall sub_142D28950(__int64 a1)
{
  int n2_1; // edx
  __int64 n2; // rax

  n2_1 = *(_DWORD *)(a1 + 0x90);
  if ( n2_1 < 0 )
    return 0;
  n2 = 2;
  if ( n2_1 < 2 )
    return (unsigned int)n2_1;
  return n2;
}

// --- End Function: sub_142D28950 (0x142D28950) ---

// --- Function: sub_142EC37E0 (0x142EC37E0) ---
__int64 __fastcall sub_142EC37E0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 4;
  result = a1;
  *(_DWORD *)(a1 + 4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 8) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xC) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x14) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x18) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x20) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x2C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x24) = 0x80000000;
  *(_DWORD *)(a1 + 0x28) = 0x80000000;
  *(_DWORD *)(a1 + 0x30) = 0x80000000;
  *(_DWORD *)(a1 + 0x5C) = 0x80000000;
  *(_DWORD *)(a1 + 0x48) = 0x80000000;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x34) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x38) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x3C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x40) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x10) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x58) = 0x80000000;
  *(_DWORD *)(a1 + 0x44) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x60) = 0x80000000;
  *(_DWORD *)(a1 + 0x80) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x68) = 0x80000000;
  *(_DWORD *)(a1 + 0x6C) = 0x80000000;
  *(_DWORD *)(a1 + 0x70) = 0x80000000;
  *(_DWORD *)(a1 + 0x64) = 0x80000000;
  return result;
}

// --- End Function: sub_142EC37E0 (0x142EC37E0) ---

// --- Function: sub_142F709D0 (0x142F709D0) ---
_UNKNOWN **__fastcall sub_142F709D0(_QWORD *a1)
{
  _UNKNOWN **result; // rax
  volatile signed __int32 *v3; // rcx

  result = &off_148746580;
  *a1 = &off_148746580;
  v3 = (volatile signed __int32 *)a1[1];
  if ( v3 )
    result = (_UNKNOWN **)sub_142FEFD50(v3);
  a1[1] = 0;
  return result;
}

// --- End Function: sub_142F709D0 (0x142F709D0) ---

// --- Function: _InterlockedIncrement_w_17 (0x142F81560) ---
void __fastcall InterlockedIncrement_w_17(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 0x1C));
}

// --- End Function: _InterlockedIncrement_w_17 (0x142F81560) ---

// --- Function: sub_142FEFD50 (0x142FEFD50) ---
__int64 __fastcall sub_142FEFD50(volatile signed __int32 *a1)
{
  __int64 v1; // xmm0_8
  __int64 result; // rax
  _QWORD *v4; // rdi
  const void *v5; // rcx
  const void *v6; // rcx
  _QWORD *v7; // rcx
  const void *v8; // rcx
  const void *v9; // rcx
  _QWORD *v10; // rcx
  const void *v11; // rcx
  __int64 v12; // rdx

  result = (unsigned int)_InterlockedExchangeAdd(a1 + 7, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    switch ( *((_BYTE *)a1 + 0x18) )
    {
      case 6:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_4;
        break;
      case 0xA:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v5 = (const void *)v4[0xC];
        if ( v5 )
          sub_147605980(v5);
        sub_140370D10(v4 + 0xA);
        v4[5] = &off_1481A0DB8;
        goto LABEL_65;
      case 0xE:
      case 0x60:
      case 0x7C:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x13:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x17:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_4:
        sub_140370D10(v4 + 1);
        goto LABEL_65;
      case 0x18:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_141976650(v4 + 8);
        goto LABEL_65;
      case 0x1A:
      case 0x82:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x1B:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x1C:
      case 0x83:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x1D:
      case 0x27:
      case 0x28:
      case 0x53:
      case 0x6D:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x21:
      case 0x22:
      case 0x24:
      case 0x25:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_20;
        break;
      case 0x23:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_20:
        sub_141976650(*(_QWORD **)a1);
        goto LABEL_65;
      case 0x2B:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x2C:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x2D:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x2E:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v7 = (_QWORD *)v4[1];
        if ( !v7 )
          goto LABEL_65;
        if ( ((v4[3] - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
          goto LABEL_31;
        if ( (unsigned __int64)v7 - v7[0xFFFFFFFF] - 8 > 0x1F )
LABEL_49:
          invalid_parameter_noinfo_noreturn();
        v7 = (_QWORD *)v7[0xFFFFFFFF];
LABEL_31:
        sub_1402A3D30(v7);
        v4[1] = 0;
        v4[2] = 0;
        v4[3] = 0;
LABEL_65:
        v6 = v4;
LABEL_66:
        sub_1402A3D30(v6);
        break;
      case 0x2F:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x46:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x4C:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x4E:
      case 0x6E:
      case 0x6F:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x54:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v8 = (const void *)v4[5];
        if ( v8 )
          sub_147605980(v8);
        v9 = (const void *)v4[2];
        if ( v9 )
          goto LABEL_40;
        goto LABEL_65;
      case 0x55:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x57:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_43;
        break;
      case 0x58:
        v10 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        if ( ((*((_QWORD *)a1 + 2) - (_QWORD)v10) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
          goto LABEL_48;
        if ( (unsigned __int64)v10 - v10[0xFFFFFFFF] - 8 > 0x1F )
          goto LABEL_49;
        v10 = (_QWORD *)v10[0xFFFFFFFF];
LABEL_48:
        sub_1402A3D30(v10);
        *(_QWORD *)a1 = 0;
        *((_QWORD *)a1 + 1) = 0;
        *((_QWORD *)a1 + 2) = 0;
        break;
      case 0x5C:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_140370D10(v4 + 5);
        goto LABEL_65;
      case 0x5F:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_43:
        sub_140370D10(v4 + 6);
        goto LABEL_65;
      case 0x63:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x65:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x6A:
      case 0x71:
      case 0x74:
      case 0x7A:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x7E:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x7F:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v11 = (const void *)v4[0xF];
        if ( v11 )
          sub_147605980(v11);
        v9 = (const void *)v4[0xC];
        if ( v9 )
LABEL_40:
          sub_147605980(v9);
        goto LABEL_65;
      case 0x88:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_145EEE160(*(_QWORD **)a1);
        goto LABEL_65;
      default:
        break;
    }
    v12 = *((_QWORD *)a1 + 4);
    if ( (unsigned __int64)a1 < *(_QWORD *)v12 || (unsigned __int64)a1 >= *(_QWORD *)(v12 + 0x28) + *(_QWORD *)v12 )
      __debugbreak();
    *(__m256 *)a1 = ymmword_1486BF420;
    *((_QWORD *)a1 + 4) = v1;
    __asm { vzeroupper }
    return sub_1403E35D0((volatile signed __int64 *)(v12 + 0x50), a1);
  }
  return result;
}

// --- End Function: sub_142FEFD50 (0x142FEFD50) ---

// --- Function: sub_1431BB170 (0x1431BB170) ---
__int64 __fastcall sub_1431BB170(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 8;
  result = a1;
  *(_DWORD *)(a1 + 4) = 0x80000000;
  *(_DWORD *)(a1 + 0x8C) = 0x80000000;
  *(_DWORD *)(a1 + 8) = 0x80000000;
  *(_DWORD *)(a1 + 0xC) = 0x80000000;
  *(_DWORD *)(a1 + 0xB4) = 0x80000000;
  *(_DWORD *)(a1 + 0x1C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x28) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x34) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x40) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x10) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x4C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x50) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x54) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x58) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x70) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x88) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x60) = 0x80000000;
  *(_QWORD *)(a1 + 0x68) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x90) = 0x80000000;
  *(_DWORD *)(a1 + 0x94) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xA0) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xA4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xA8) = 0x80000000;
  *(_DWORD *)(a1 + 0xAC) = 0x80000000;
  *(_DWORD *)(a1 + 0xB0) = 0x80000000;
  *(_DWORD *)(a1 + 0xBC) = 0x80000000;
  *(_DWORD *)(a1 + 0x5C) = 0;
  *(_DWORD *)(a1 + 0xB8) = 1;
  return result;
}

// --- End Function: sub_1431BB170 (0x1431BB170) ---

// --- Function: sub_1431CFB70 (0x1431CFB70) ---
void __fastcall sub_1431CFB70(__int64 a1)
{
  __int64 v2; // rax
  int v3; // eax
  __int64 v4; // rax
  int v5; // eax
  double v6; // xmm0_8
  float v7; // xmm1_4
  float v8; // xmm0_4
  float *v9; // rax
  float v10; // xmm0_4
  float X; // xmm1_4
  float v12; // xmm7_4
  float v13; // xmm8_4
  __m128 v14; // xmm9
  float v15; // xmm10_4
  float v16; // xmm6_4
  float v17; // xmm8_4
  float v18; // xmm9_4
  __m128 v19; // kr00_16
  float v20; // xmm7_4
  float v23; // xmm1_4
  float v24; // xmm5_4
  float v25; // xmm4_4
  float v26; // xmm2_4
  float v27; // xmm0_4
  float Y; // xmm6_4
  __int64 v29; // rcx
  double v30; // xmm0_8
  float v31; // xmm1_4
  float v32; // xmm2_4
  float v33; // xmm2_4
  float v34; // xmm1_4
  float v35[4]; // [rsp+30h] [rbp-B8h] BYREF
  int n0x4300; // [rsp+40h] [rbp-A8h] BYREF
  __int64 v37; // [rsp+44h] [rbp-A4h]
  int v38; // [rsp+4Ch] [rbp-9Ch]
  unsigned __int64 v39; // [rsp+50h] [rbp-98h]
  unsigned __int64 v40; // [rsp+58h] [rbp-90h]
  __int64 v41; // [rsp+60h] [rbp-88h]
  __int64 v42; // [rsp+68h] [rbp-80h]
  float v43; // [rsp+F0h] [rbp+8h] BYREF

  n0x4300 = 0x4300;
  v37 = 0;
  v38 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v39 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20A8C,
    "CAnimatedCharacter::AcquireRequestedBehaviourMovement",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
    0x4E);
  HIWORD(n0x4300) = word_149E20A8C;
  *(_DWORD *)(a1 + 0x310) = 0x3F800000;
  *(_QWORD *)(a1 + 0x304) = 0;
  *(_DWORD *)(a1 + 0x30C) = 0;
  *(_QWORD *)(a1 + 0x314) = 0;
  *(_QWORD *)(a1 + 0x31C) = 0;
  v2 = sub_14030ECF0((_QWORD *)(a1 + 0x3D8));
  if ( (unsigned __int8)sub_1465D2560(v2, *(unsigned int *)(a1 + 0x11C))
    && !*(_BYTE *)(a1 + 0x340)
    && (!(unsigned __int8)sub_1457D6EC0(a1) || *(_DWORD *)(a1 + 0x2F4) != 1) )
  {
    *(_DWORD *)(a1 + 0x304) = *(_DWORD *)(a1 + 0x134);
    *(_DWORD *)(a1 + 0x308) = *(_DWORD *)(a1 + 0x138);
    *(_DWORD *)(a1 + 0x30C) = *(_DWORD *)(a1 + 0x13C);
    *(_DWORD *)(a1 + 0x310) = *(_DWORD *)(a1 + 0x140);
    switch ( *(_DWORD *)(a1 + 0x124) )
    {
      case 1:
        v3 = *(_DWORD *)(a1 + 0x130);
        *(double *)(a1 + 0x314) = *(double *)(a1 + 0x128);
        *(_DWORD *)(a1 + 0x31C) = v3;
        v4 = sub_14030ECF0((_QWORD *)(a1 + 0x3D8));
        if ( *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x798LL))(v4) + 8) )
          *(_DWORD *)(a1 + 0x320) = 3;
        break;
      case 2:
      case 6:
        *(_DWORD *)(a1 + 0x320) = 5;
        goto LABEL_12;
      case 3:
      case 7:
        *(_DWORD *)(a1 + 0x320) = 3;
        goto LABEL_12;
      case 4:
        *(_DWORD *)(a1 + 0x320) = 6;
        goto LABEL_12;
      case 5:
        *(_DWORD *)(a1 + 0x320) = 1;
LABEL_12:
        v5 = *(_DWORD *)(a1 + 0x130);
        *(double *)(a1 + 0x314) = *(double *)(a1 + 0x128);
        *(_DWORD *)(a1 + 0x31C) = v5;
        break;
      default:
        break;
    }
    v6 = sub_1433712C0(a1 + 0x174);
    v35[0] = *(float *)&v6;
    v7 = *(float *)&v6;
    v8 = *(float *)(a1 + 0x190);
    if ( v8 == *(float *)(a1 + 0x170) )
    {
      v43 = v8 + *(float *)(a1 + 0x188);
      v9 = sub_140359CF0(&v43, v35);
      v7 = v35[0];
      v10 = *v9;
    }
    else
    {
      v10 = 0.0;
    }
    *(float *)(a1 + 0x188) = v10;
    if ( v10 < v7 )
    {
      X = *(float *)(a1 + 0x310);
      v12 = *(float *)(a1 + 0x304);
      v13 = *(float *)(a1 + 0x308);
      v14 = (__m128)*(unsigned int *)(a1 + 0x30C);
      v15 = *(float *)(a1 + 0x190) / *(float *)(a1 + 0x184);
      if ( X < 0.0 )
      {
        LODWORD(X) ^= 0x80000000;
        LODWORD(v12) ^= 0x80000000;
        LODWORD(v13) ^= 0x80000000;
        *(_OWORD *)&v14 ^= 0x80000000;
      }
      if ( X <= 0.99989998 )
      {
        Y = fsqrt((float)((float)(v12 * v12) + (float)(v13 * v13)) + (float)(v14.m128_f32[0] * v14.m128_f32[0]));
        atan2f(Y, X);
        v30 = _libm_sse2_sincosf_(v29);
        v31 = *(float *)&v30 * v12;
        v32 = *(float *)&v30 * v13;
        LODWORD(v24) = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v30, (__m128)*(unsigned __int64 *)&v30, 1).m128_u32[0];
        v27 = (float)(*(float *)&v30 * v14.m128_f32[0]) * (float)(1.0 / Y);
        v25 = v31 * (float)(1.0 / Y);
        v26 = v32 * (float)(1.0 / Y);
      }
      else
      {
        v16 = (float)(X * v15) + (float)(1.0 - v15);
        v17 = v13 * v15;
        v19 = v14;
        v18 = v14.m128_f32[0] * v15;
        v20 = v12 * v15;
        v19.m128_f32[0] = (float)((float)(v18 * v18) + (float)(v17 * v17))
                        + (float)((float)(v20 * v20) + (float)(v16 * v16));
        _XMM2 = _mm_shuffle_ps(v19, v19, 0);
        __asm { vrsqrtps xmm3, xmm2 }
        _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
        v23 = (float)(1.5 - (float)((float)((float)(_XMM3.m128_f32[0] * v19.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
            * _XMM3.m128_f32[0];
        v24 = v23 * v16;
        v25 = v23 * v20;
        v26 = v23 * v17;
        v27 = v23 * v18;
      }
      *(float *)(a1 + 0x304) = v25;
      *(float *)(a1 + 0x308) = v26;
      *(float *)(a1 + 0x30C) = v27;
      *(float *)(a1 + 0x310) = v24;
    }
    v33 = *(float *)(a1 + 0x198);
    v34 = v33 * *(float *)(a1 + 0x318);
    *(float *)(a1 + 0x314) = v33 * *(float *)(a1 + 0x314);
    *(float *)(a1 + 0x31C) = v33 * *(float *)(a1 + 0x31C);
    *(float *)(a1 + 0x318) = v34;
  }
  v40 = __rdtsc();
  qword_149B4B878(&n0x4300);
}

// --- End Function: sub_1431CFB70 (0x1431CFB70) ---

// --- Function: sub_1431D0180 (0x1431D0180) ---
__int64 __fastcall sub_1431D0180(__int64 a1, float *a2)
{
  float v2; // xmm10_4
  float v3; // xmm12_4
  __m128 v4; // xmm13
  float v5; // xmm14_4
  float v6; // xmm15_4
  __m128 v7; // xmm5
  __m128 v8; // xmm4
  float v9; // xmm6_4
  float v10; // xmm8_4
  float v11; // xmm11_4
  float v12; // xmm10_4
  __m128 v13; // kr00_16
  float v14; // xmm6_4
  __int64 result; // rax
  __int64 v18; // [rsp+0h] [rbp-A8h]
  __int64 v19; // [rsp+0h] [rbp-A8h]

  v2 = a2[2];
  v3 = *a2;
  v4 = (__m128)*((unsigned int *)a2 + 3);
  v5 = a2[1];
  v6 = (float)(v4.m128_f32[0] * *(float *)(a1 + 0x1B4))
     - (float)((float)((float)(*a2 * *(float *)(a1 + 0x1A8)) + (float)(v5 * *(float *)(a1 + 0x1AC)))
             + (float)(v2 * *(float *)(a1 + 0x1B0)));
  a2[3] = v6;
  v7 = (__m128)*(unsigned __int64 *)a2;
  v8 = (__m128)*(unsigned __int64 *)(a1 + 0x1A8);
  v9 = *(float *)(a1 + 0x1B0);
  v10 = *(float *)(a1 + 0x1AC);
  v18 = *(_QWORD *)(a1 + 0x1A8);
  v11 = (float)((float)(v8.m128_f32[0] * v4.m128_f32[0]) + (float)(v7.m128_f32[0] * *(float *)(a1 + 0x1B4)))
      + (float)((float)(v9 * v5) - (float)(v10 * v2));
  v12 = (float)((float)(_mm_shuffle_ps(v8, v8, 0x55).m128_f32[0] * v4.m128_f32[0])
              + (float)(_mm_shuffle_ps(v7, v7, 0x55).m128_f32[0] * *(float *)(a1 + 0x1B4)))
      + (float)((float)(*(float *)&v18 * v2) - (float)(v9 * v3));
  v13 = v4;
  v14 = (float)((float)(v4.m128_f32[0] * v9) + (float)(a2[2] * *(float *)(a1 + 0x1B4)))
      + (float)((float)(v10 * v3) - (float)(*(float *)&v18 * v5));
  v13.m128_f32[0] = (float)((float)(v14 * v14) + (float)(v12 * v12)) + (float)((float)(v11 * v11) + (float)(v6 * v6));
  _XMM3 = _mm_shuffle_ps(v13, v13, 0);
  __asm { vrsqrtps xmm4, xmm3 }
  _XMM4.m128_f32[0] = _mm_shuffle_ps(_XMM4, _XMM4, 0xFF).m128_f32[0];
  v13.m128_f32[0] = (float)(1.5
                          - (float)((float)((float)(_XMM4.m128_f32[0] * v13.m128_f32[0]) * _XMM4.m128_f32[0]) * 0.5))
                  * _XMM4.m128_f32[0];
  a2[3] = v6 * v13.m128_f32[0];
  *a2 = v11 * v13.m128_f32[0];
  a2[1] = v12 * v13.m128_f32[0];
  a2[2] = v14 * v13.m128_f32[0];
  v7.m128_f32[0] = *(float *)(a1 + 0x198) / *(float *)(a1 + 0x190);
  result = *(unsigned int *)(a1 + 0x1C0);
  v19 = *(_QWORD *)(a1 + 0x1B8);
  a2[4] = (float)(*(float *)&v19 * v7.m128_f32[0]) + a2[4];
  a2[5] = (float)(v7.m128_f32[0] * *((float *)&v19 + 1)) + a2[5];
  a2[6] = (float)(*(float *)&result * v7.m128_f32[0]) + a2[6];
  return result;
}

// --- End Function: sub_1431D0180 (0x1431D0180) ---

// --- Function: sub_1431D2330 (0x1431D2330) ---
__int64 __fastcall sub_1431D2330(__int64 a1, int a2, int a3)
{
  __int128 v3; // xmm6
  unsigned __int64 *v4; // rdi
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 result; // rax
  bool v11; // r14
  int n0xA; // r8d
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rcx
  __int64 v16; // rcx
  int n0x100; // ecx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 *v20; // rsi
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // rcx
  __int64 v27; // rcx
  unsigned __int64 v28; // rcx
  __int64 v29; // rcx
  __int64 *v30; // rsi
  __int64 v31; // rax
  __int64 v32; // rdx
  __int64 v33; // rax
  __int64 v34; // rdx
  unsigned __int64 v35; // [rsp+20h] [rbp-E0h] BYREF
  unsigned __int64 v36; // [rsp+28h] [rbp-D8h]
  _DWORD v37[12]; // [rsp+30h] [rbp-D0h] BYREF
  _BYTE v38[36]; // [rsp+60h] [rbp-A0h] BYREF
  BOOL v39; // [rsp+84h] [rbp-7Ch]
  int n0x10F; // [rsp+A8h] [rbp-58h]
  int v41; // [rsp+BCh] [rbp-44h]
  _DWORD v42[12]; // [rsp+F0h] [rbp-10h] BYREF
  char v43[8]; // [rsp+120h] [rbp+20h] BYREF
  int v44; // [rsp+128h] [rbp+28h]
  __int64 v45; // [rsp+160h] [rbp+60h]
  __int64 v46; // [rsp+168h] [rbp+68h]
  __int64 v47; // [rsp+170h] [rbp+70h]
  __int64 v48; // [rsp+178h] [rbp+78h]
  __int128 v49; // [rsp+240h] [rbp+140h]
  unsigned __int64 v50; // [rsp+280h] [rbp+180h] BYREF

  v4 = (unsigned __int64 *)(a1 + 8);
  v8 = 0;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v9 = *v4 & 0xFFFFFFFFFFFFLL;
  else
    v9 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v9 + 0x3B8LL))(v9, &v50);
  result = v50;
  if ( !v50 )
    return result;
  result = HIWORD(v50);
  if ( *(_QWORD *)((v50 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v50) || !*(_DWORD *)(a1 + 0x2F4) )
    return result;
  if ( (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v50 & 0xFFFFFFFFFFFFLL) + 8LL))(v50 & 0xFFFFFFFFFFFFLL) == 0xB )
  {
    v11 = 0;
    sub_142EC37E0((__int64)v38);
    sub_140370740((__int64)v43);
    n0xA = *(_DWORD *)(a1 + 0x2F4);
    v13 = *(_QWORD *)(a1 + 0x3D0);
    v35 = 0x800000000000000FuLL;
    v36 = 0x8000000080000000uLL;
    switch ( n0xA )
    {
      case 1:
      case 3:
        v41 = 0;
        v46 = ~v13;
        v11 = 1;
        v39 = 0;
        n0x10F = 0x10F;
        HIDWORD(v36) = 0xFFFFFDFF;
        break;
      case 2:
      case 8:
        v41 = 1;
        v11 = 1;
        v39 = 1;
        n0x10F = 0xE;
        v45 = v13;
        v47 = v13;
        HIDWORD(v36) = 0xFFFFFDFF;
        goto LABEL_12;
      case 4:
        v41 = 1;
        v46 = ~v13;
        v48 = ~v13;
        v39 = 0;
        n0x10F = 0x10F;
        HIDWORD(v36) = 0xFFFFFDFF;
        break;
      case 5:
      case 0xA:
        v41 = 1;
        n0x10F = 0x10F;
        v45 = v13;
        v39 = n0xA == 0xA;
        v47 = v13;
        v11 = a2 == 1;
        LODWORD(v36) = 0x200;
        goto LABEL_12;
      case 6:
      case 0xD:
        v41 = 1;
        v39 = 0;
        n0x10F = 0x10F;
        v45 = v13;
        v47 = v13;
        HIDWORD(v36) = 0xFFFFFDFF;
        goto LABEL_12;
      case 7:
        n0x100 = 0x100;
        n0x10F = 0x100;
        v41 = 1;
        v39 = 1;
        if ( *((_DWORD *)qword_149E12BA0 + 1) )
          n0x100 = 0x101;
        v46 = ~v13;
        n0x10F = n0x100;
        goto LABEL_26;
      case 9:
        v41 = 1;
        v39 = 1;
        n0x10F = 0x10F;
        v45 = v13;
LABEL_26:
        v47 = v13;
        v11 = 1;
        HIDWORD(v36) = 0xFFFFFDFF;
        break;
      case 0xB:
        n0x10F = 0xE;
        goto LABEL_30;
      case 0xC:
        n0x10F = 0x10F;
LABEL_30:
        v39 = 0;
        v41 = 1;
        v45 = v13;
        v47 = v13;
        HIDWORD(v36) = 0xFFFFFDFF;
        break;
      default:
LABEL_12:
        if ( n0xA == 6 )
        {
          v14 = *(_QWORD *)(a1 + 0x3C8);
          if ( !v14 || *(_QWORD *)((*(_QWORD *)(a1 + 0x3C8) & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v14) )
            sub_143203A90(a1);
        }
        break;
    }
    if ( *(_DWORD *)(a1 + 0x2F4) != 6 )
    {
      v15 = *(_QWORD *)(a1 + 0x3C8);
      if ( v15 )
      {
        if ( *(_QWORD *)((*(_QWORD *)(a1 + 0x3C8) & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v15) )
          sub_1432075F0(a1);
      }
    }
    if ( validateHandleAccess(v4) )
      v16 = *v4 & 0xFFFFFFFFFFFFLL;
    else
      v16 = 0;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x440LL))(v16);
    if ( v11 )
    {
      v49 = v3;
      *(float *)&v42[9] = 0.0;
      *(float *)&v42[7] = 0.0;
      *(float *)&v42[6] = 0.0;
      *(float *)&v42[5] = 0.0;
      v42[0] = 0;
      v42[4] = 0xFFBFFFFF;
      v42[8] = 0;
      if ( validateHandleAccess(v4) )
        v18 = *v4 & 0xFFFFFFFFFFFFLL;
      else
        v18 = 0;
      (*(void (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD, unsigned __int64, unsigned __int64))(*(_QWORD *)v18 + 0x408LL))(
        v18,
        v42,
        0,
        0,
        v35,
        v36);
      v37[0] = 8;
      *(float *)&v37[5] = 0.0;
      *(float *)&v37[4] = 0.0;
      *(float *)&v37[3] = 0.0;
      *(float *)&v37[8] = 0.0;
      *(float *)&v37[7] = 0.0;
      *(float *)&v37[6] = 0.0;
      v37[1] = 0x80000000;
      v37[2] = 0x80000000;
      v37[9] = 0;
      if ( validateHandleAccess(v4) )
        v19 = *v4 & 0xFFFFFFFFFFFFLL;
      else
        v19 = 0;
      (*(void (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(*(_QWORD *)v19 + 0x408LL))(v19, v37, 0, 0);
      *(_DWORD *)(a1 + 0x3BC) = 0;
    }
    v20 = (__int64 *)(a1 + 0x3E0);
    if ( AssetMeta::HasActorSubresource(v20) )
    {
      if ( (unsigned int)(a3 - 2) > 1 )
      {
        if ( (unsigned int)(a2 - 2) > 1 )
          goto LABEL_47;
        v21 = sub_14030ECF0(v20);
        v22 = 0;
      }
      else
      {
        v21 = sub_14030ECF0(v20);
        LOBYTE(v22) = 1;
      }
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v21 + 0x758LL))(v21, v22);
    }
LABEL_47:
    if ( a3 == 1 )
    {
      v23 = sub_14030ECF0(v20);
      v24 = 0;
    }
    else
    {
      if ( a2 != 1 )
      {
LABEL_52:
        v44 = 0;
        if ( validateHandleAccess(v4) )
          v25 = *v4 & 0xFFFFFFFFFFFFLL;
        else
          v25 = 0;
        (*(void (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v25 + 0x3F8LL))(v25, v38, 0, 0);
        if ( validateHandleAccess(v4) )
          v26 = *v4 & 0xFFFFFFFFFFFFLL;
        else
          v26 = 0;
        (*(void (__fastcall **)(__int64, char *, _QWORD, _QWORD))(*(_QWORD *)v26 + 0x3F8LL))(v26, v43, 0, 0);
        if ( validateHandleAccess(v4) )
          v27 = *v4 & 0xFFFFFFFFFFFFLL;
        else
          v27 = 0;
        (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD, _QWORD))(*(_QWORD *)v27 + 0x3F8LL))(
          v27,
          &v35,
          0,
          0);
        goto LABEL_79;
      }
      v23 = sub_14030ECF0(v20);
      v24 = 1;
    }
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v23 + 0x5B0LL))(v23, v24, 0x13);
    goto LABEL_52;
  }
  v28 = *(_QWORD *)(a1 + 0x3C8);
  if ( v28 && *(_QWORD *)((*(_QWORD *)(a1 + 0x3C8) & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v28) )
    sub_1432075F0(a1);
  if ( validateHandleAccess(v4) )
    v29 = *v4 & 0xFFFFFFFFFFFFLL;
  else
    v29 = 0;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x440LL))(v29);
  v30 = (__int64 *)(a1 + 0x3E0);
  if ( AssetMeta::HasActorSubresource(v30) )
  {
    if ( (unsigned int)(a3 - 2) > 1 )
    {
      if ( (unsigned int)(a2 - 2) > 1 )
        goto LABEL_74;
      v31 = sub_14030ECF0(v30);
      v32 = 0;
    }
    else
    {
      v31 = sub_14030ECF0(v30);
      LOBYTE(v32) = 1;
    }
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v31 + 0x758LL))(v31, v32);
  }
LABEL_74:
  if ( a3 == 1 )
  {
    v33 = sub_14030ECF0(v30);
    v34 = 0;
LABEL_78:
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v33 + 0x5B0LL))(v33, v34, 0x13);
    goto LABEL_79;
  }
  if ( a2 == 1 )
  {
    v33 = sub_14030ECF0(v30);
    v34 = 1;
    goto LABEL_78;
  }
LABEL_79:
  if ( validateHandleAccess(v4) )
    v8 = *v4 & 0xFFFFFFFFFFFFLL;
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x448LL))(v8);
}

// --- End Function: sub_1431D2330 (0x1431D2330) ---

// --- Function: sub_1431F31D0 (0x1431F31D0) ---
void __fastcall sub_1431F31D0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int16 n3; // r14
  __int64 v6; // rax
  float v7[4]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v8; // [rsp+40h] [rbp-C0h]
  int v9; // [rsp+48h] [rbp-B8h]
  __int64 v10; // [rsp+4Ch] [rbp-B4h] BYREF
  int v11; // [rsp+54h] [rbp-ACh]
  unsigned __int64 v12; // [rsp+58h] [rbp-A8h] BYREF
  int n0x4300; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v14; // [rsp+64h] [rbp-9Ch]
  int v15; // [rsp+6Ch] [rbp-94h]
  unsigned __int64 v16; // [rsp+70h] [rbp-90h]
  unsigned __int64 v17; // [rsp+78h] [rbp-88h]
  __int64 v18; // [rsp+80h] [rbp-80h]
  __int64 v19; // [rsp+88h] [rbp-78h]
  _BYTE v20[32]; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 v21[8]; // [rsp+D0h] [rbp-30h] BYREF
  _BYTE v22[48]; // [rsp+110h] [rbp+10h] BYREF

  v1 = 0;
  n0x4300 = 0x4300;
  v14 = 0;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v16 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20A94,
    "CAnimatedCharacter::CalculateAndRequestPhysicalEntityMovement",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
    0x12E);
  HIWORD(n0x4300) = word_149E20A94;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v3 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v3 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v3 + 0x3B8LL))(v3, &v12);
  v4 = *(_QWORD *)(a1 + 0x338);
  if ( v4 )
    n3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x100LL))(v4);
  else
    n3 = 0;
  if ( v12
    && *(_QWORD *)((v12 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v12)
    && ((*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v12 & 0xFFFFFFFFFFFFLL) + 8LL))(v12 & 0xFFFFFFFFFFFFLL) != 6
     || n3 == 3) )
  {
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v1 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v1 + 0x1E8LL))(v1, v21, 2);
    sub_143584460(v7);
    if ( !*(_BYTE *)(a1 + 0x340) )
    {
      sub_1431F3400(a1, v20, v21);
      v6 = sub_1431F4210(a1, v22, v21, v20);
      v7[0] = *(float *)v6;
      v7[1] = *(float *)(v6 + 4);
      v7[2] = *(float *)(v6 + 8);
      v7[3] = *(float *)(v6 + 0xC);
      v8 = *(_QWORD *)(v6 + 0x10);
      v9 = *(_DWORD *)(v6 + 0x18);
      v10 = *(_QWORD *)(v6 + 0x1C);
      v11 = *(_DWORD *)(v6 + 0x24);
    }
    sub_14325E580(a1, v21, (__int64)v7, (float *)&v10);
  }
  else
  {
    *(_BYTE *)(a1 + 0x1D4) = 0;
    *(_BYTE *)(a1 + 0x1A4) = 0;
  }
  v17 = __rdtsc();
  qword_149B4B878(&n0x4300);
}

// --- End Function: sub_1431F31D0 (0x1431F31D0) ---

// --- Function: sub_1431F3400 (0x1431F3400) ---
__int64 __fastcall sub_1431F3400(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  __int128 v3; // xmm15
  float v7; // xmm15_4
  bool v8; // cf
  float v9; // xmm6_4
  float v10; // xmm13_4
  float v11; // xmm7_4
  float v12; // xmm8_4
  int v14; // ecx
  int v15; // ecx
  __int64 v16; // rax
  int v17; // eax
  float v20; // ecx
  float v27; // xmm8_4
  float v28; // xmm7_4
  float v29; // xmm0_4
  __m128 v30; // xmm8
  __int128 v31; // kr00_16
  float v32; // xmm9_4
  float v33; // xmm6_4
  __m128 v34; // kr00_16
  float v37; // xmm10_4
  __m128 n0x3FC00000; // kr00_16
  __m128 n0x3FC00000_1; // xmm3
  __m128 n0x3FC00000_2; // xmm1
  float v41; // xmm7_4
  float v42; // xmm8_4
  __int128 n0x3FC00000_4; // xmm9
  __int128 n0x3FC00000_3; // kr00_16
  __m128 n0x3FC00000_7; // kr00_16
  __m128 n0x3FC00000_8; // xmm6
  float v47; // xmm7_4
  float v48; // xmm8_4
  __m128 n0x3FC00000_10; // xmm9
  __int128 n0x3FC00000_9; // kr00_16
  __m128 n0x3FC00000_11; // kr00_16
  float v54; // xmm1_4
  float v55; // xmm10_4
  float v56; // xmm6_4
  float v57; // xmm7_4
  __m128 n0x3FC00000_6; // xmm8
  __m128 n0x3FC00000_12; // kr00_16
  float Y; // xmm6_4
  __int64 v61; // rcx
  double v62; // xmm0_8
  float v63; // xmm3_4
  float v64; // xmm2_4
  __m128 n0x3FC00000_5; // kr00_16
  __m128 n0x3FC00000_13; // kr00_16
  float v69; // xmm1_4
  float v70; // xmm0_4
  __int64 v72; // rax
  __crt_win32_buffer_debug_info *v73; // rcx
  const char *v74; // rbx
  const char *i; // rsi
  __int64 v78; // [rsp+30h] [rbp-D0h] BYREF
  float v79; // [rsp+38h] [rbp-C8h]
  double v80; // [rsp+3Ch] [rbp-C4h]
  float v81; // [rsp+44h] [rbp-BCh]
  float v82; // [rsp+48h] [rbp-B8h]
  float v83; // [rsp+4Ch] [rbp-B4h]
  float v84; // [rsp+50h] [rbp-B0h]
  float v85; // [rsp+54h] [rbp-ACh]
  double v86; // [rsp+58h] [rbp-A8h]
  float v87; // [rsp+60h] [rbp-A0h]
  float v88; // [rsp+64h] [rbp-9Ch]
  float v89; // [rsp+68h] [rbp-98h]
  float v90; // [rsp+6Ch] [rbp-94h]
  float v91; // [rsp+70h] [rbp-90h]
  char v92; // [rsp+74h] [rbp-8Ch]
  int n0x4300; // [rsp+80h] [rbp-80h] BYREF
  __int64 v94; // [rsp+84h] [rbp-7Ch]
  int v95; // [rsp+8Ch] [rbp-74h]
  unsigned __int64 v96; // [rsp+90h] [rbp-70h]
  unsigned __int64 v97; // [rsp+98h] [rbp-68h]
  __int64 v98; // [rsp+A0h] [rbp-60h]
  __int64 v99; // [rsp+A8h] [rbp-58h]
  __int64 v100; // [rsp+E0h] [rbp-20h]
  char v101[32]; // [rsp+F0h] [rbp-10h] BYREF
  __int128 v102; // [rsp+110h] [rbp+10h]

  v102 = v3;
  v94 = 0;
  v95 = 0;
  v97 = 0;
  v98 = 0;
  v99 = 0;
  n0x4300 = 0x4300;
  v96 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20A90,
    "CAnimatedCharacter::CalculateDesiredAnimMovement",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
    0xC7);
  v7 = 0.0;
  v8 = *(float *)(a1 + 0x198) > 0.0;
  HIWORD(n0x4300) = word_149E20A90;
  if ( v8 )
  {
    v9 = 1.0;
    v10 = 0.0;
    v11 = 0.0;
    v12 = 0.0;
    _XMM11 = 0;
    if ( *(_BYTE *)(a1 + 0x110)
      || *(_BYTE *)(a1 + 0x111)
      || *(_BYTE *)(a1 + 0x112)
      || (v14 = *(_DWORD *)(a1 + 0x2B4), (unsigned int)(v14 - 2) <= 1)
      || (unsigned int)(v14 - 6) <= 3
      || (v15 = *(_DWORD *)(a1 + 0x2D0), (unsigned int)(v15 - 2) <= 1)
      || (unsigned int)(v15 - 6) <= 3 )
    {
      if ( *(_QWORD *)(a1 + 0x330) )
      {
        if ( (unsigned int)sub_142D28950((__int64)qword_149E12BA0) == 2 )
        {
          v16 = (*(__int64 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a1 + 0x330) + 0x1E8LL))(
                  *(_QWORD *)(a1 + 0x330),
                  v101);
        }
        else
        {
          v17 = sub_142D28950((__int64)qword_149E12BA0);
          v16 = (*(__int64 (__fastcall **)(_QWORD, bool))(**(_QWORD **)(a1 + 0x330) + 0x1E0LL))(
                  *(_QWORD *)(a1 + 0x330),
                  v17 != 0);
        }
        _XMM11 = a3[1];
        _XMM5 = a3[2];
        v20 = *(float *)(v16 + 0x18);
        _XMM4 = a3[3];
        _XMM10 = *a3;
        v100 = *(_QWORD *)(v16 + 0x10);
        __asm
        {
          vcvtpd2ps xmm5, xmm5
          vcvtpd2ps xmm11, xmm11
        }
        __asm
        {
          vcvtpd2ps xmm4, xmm4
          vcvtpd2ps xmm10, xmm10
        }
        v27 = (float)((float)(v20 * *(float *)&_XMM11) - (float)(*((float *)&v100 + 1) * *(float *)&_XMM5))
            + (float)(*(float *)&v100 * *(float *)&_XMM4);
        v28 = (float)((float)(*(float *)&v100 * *(float *)&_XMM5) - (float)(v20 * *(float *)&_XMM10))
            + (float)(*((float *)&v100 + 1) * *(float *)&_XMM4);
        *(float *)&_XMM4 = (float)((float)(*((float *)&v100 + 1) * *(float *)&_XMM10)
                                 - (float)(*(float *)&v100 * *(float *)&_XMM11))
                         + (float)(v20 * *(float *)&_XMM4);
        v29 = v27 * *(float *)&_XMM11;
        v30 = (__m128)*(unsigned int *)(v16 + 4);
        v31 = (unsigned int)v100;
        v32 = *(float *)(v16 + 8);
        *(float *)&v31 = (float)(*(float *)&v100
                               + (float)((float)(*(float *)&_XMM4 * *(float *)&_XMM11) - (float)(v28 * *(float *)&_XMM5)))
                       + (float)((float)(*(float *)&_XMM4 * *(float *)&_XMM11) - (float)(v28 * *(float *)&_XMM5));
        _XMM11 = v31;
        v33 = *(float *)(v16 + 0xC);
        v10 = (float)(v20 + (float)((float)(v28 * *(float *)&_XMM10) - v29))
            + (float)((float)(v28 * *(float *)&_XMM10) - v29);
        v34 = v30;
        v34.m128_f32[0] = (float)((float)(v30.m128_f32[0] * v30.m128_f32[0]) + (float)(v32 * v32))
                        + (float)((float)(*(float *)v16 * *(float *)v16) + (float)(v33 * v33));
        _XMM2 = _mm_shuffle_ps(v34, v34, 0);
        __asm { vrsqrtps xmm3, xmm2 }
        _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
        _XMM2.m128_f32[0] = (float)((float)(_XMM3.m128_f32[0] * v34.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5;
        v37 = *(float *)(a1 + 0x190) / *(float *)(a1 + 0x198);
        n0x3FC00000 = (__m128)0x3FC00000u;
        n0x3FC00000.m128_f32[0] = (float)(1.5 - _XMM2.m128_f32[0]) * _XMM3.m128_f32[0];
        n0x3FC00000_1 = n0x3FC00000;
        n0x3FC00000.m128_f32[0] = n0x3FC00000.m128_f32[0] * v33;
        n0x3FC00000_2 = n0x3FC00000;
        v8 = n0x3FC00000.m128_f32[0] < 0.0;
        v41 = *(float *)v16 * n0x3FC00000_1.m128_f32[0];
        v42 = n0x3FC00000_1.m128_f32[0] * v30.m128_f32[0];
        n0x3FC00000_3 = (__int128)n0x3FC00000_1;
        *(float *)&n0x3FC00000_3 = n0x3FC00000_1.m128_f32[0] * v32;
        n0x3FC00000_4 = n0x3FC00000_3;
        if ( v8 )
        {
          *(_OWORD *)&n0x3FC00000_2 ^= 0x80000000;
          v41 = -(float)(*(float *)v16 * n0x3FC00000_1.m128_f32[0]);
          LODWORD(v42) ^= 0x80000000;
          n0x3FC00000_4 = n0x3FC00000_3 ^ 0x80000000;
        }
        if ( n0x3FC00000_2.m128_f32[0] <= 0.99989998 )
        {
          Y = fsqrt(
                (float)((float)(v42 * v42) + (float)(v41 * v41))
              + (float)(*(float *)&n0x3FC00000_4 * *(float *)&n0x3FC00000_4));
          atan2f(Y, n0x3FC00000_2.m128_f32[0]);
          v62 = _libm_sse2_sincosf_(v61);
          v63 = 1.0 / Y;
          v64 = v42 * *(float *)&v62;
          LODWORD(v55) = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v62, (__m128)*(unsigned __int64 *)&v62, 1).m128_u32[0];
          n0x3FC00000_5 = (__m128)n0x3FC00000_4;
          n0x3FC00000_5.m128_f32[0] = (float)(*(float *)&n0x3FC00000_4 * *(float *)&v62) * (float)(1.0 / Y);
          n0x3FC00000_6 = n0x3FC00000_5;
          v56 = (float)(v41 * *(float *)&v62) * (float)(1.0 / Y);
          v57 = v64 * v63;
        }
        else
        {
          if ( n0x3FC00000_2.m128_f32[0] < 0.0 )
          {
            *(_OWORD *)&n0x3FC00000_2 ^= 0x80000000;
            LODWORD(v41) ^= 0x80000000;
            LODWORD(v42) ^= 0x80000000;
            n0x3FC00000_4 ^= 0x80000000;
          }
          n0x3FC00000_7 = n0x3FC00000_2;
          n0x3FC00000_7.m128_f32[0] = (float)(n0x3FC00000_2.m128_f32[0] * v37) + (float)(1.0 - v37);
          n0x3FC00000_8 = n0x3FC00000_7;
          v47 = v41 * v37;
          v48 = v42 * v37;
          n0x3FC00000_9 = n0x3FC00000_4;
          *(float *)&n0x3FC00000_9 = *(float *)&n0x3FC00000_4 * v37;
          n0x3FC00000_10 = (__m128)n0x3FC00000_9;
          n0x3FC00000_11 = n0x3FC00000_8;
          n0x3FC00000_11.m128_f32[0] = (float)((float)(n0x3FC00000_8.m128_f32[0] * n0x3FC00000_8.m128_f32[0])
                                             + (float)(v47 * v47))
                                     + (float)((float)(n0x3FC00000_10.m128_f32[0] * n0x3FC00000_10.m128_f32[0])
                                             + (float)(v48 * v48));
          _XMM2 = _mm_shuffle_ps(n0x3FC00000_11, n0x3FC00000_11, 0);
          __asm { vrsqrtps xmm3, xmm2 }
          _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
          v54 = (float)(1.5
                      - (float)((float)((float)(_XMM3.m128_f32[0] * n0x3FC00000_11.m128_f32[0]) * _XMM3.m128_f32[0])
                              * 0.5))
              * _XMM3.m128_f32[0];
          v55 = v54 * n0x3FC00000_8.m128_f32[0];
          v56 = v47 * v54;
          v57 = v48 * v54;
          n0x3FC00000_12 = n0x3FC00000_10;
          n0x3FC00000_12.m128_f32[0] = n0x3FC00000_10.m128_f32[0] * v54;
          n0x3FC00000_6 = n0x3FC00000_12;
        }
        n0x3FC00000_13 = n0x3FC00000_6;
        n0x3FC00000_13.m128_f32[0] = (float)((float)(n0x3FC00000_6.m128_f32[0] * n0x3FC00000_6.m128_f32[0])
                                           + (float)(v57 * v57))
                                   + (float)((float)(v56 * v56) + (float)(v55 * v55));
        _XMM3 = _mm_shuffle_ps(n0x3FC00000_13, n0x3FC00000_13, 0);
        __asm { vrsqrtps xmm5, xmm3 }
        _XMM5.m128_f32[0] = _mm_shuffle_ps(_XMM5, _XMM5, 0xFF).m128_f32[0];
        v69 = (float)(1.5
                    - (float)((float)((float)(_XMM5.m128_f32[0] * n0x3FC00000_13.m128_f32[0]) * _XMM5.m128_f32[0]) * 0.5))
            * _XMM5.m128_f32[0];
        v7 = v69 * v56;
        v9 = v69 * v55;
        v11 = v69 * v57;
        v12 = v69 * n0x3FC00000_6.m128_f32[0];
      }
    }
    if ( !sub_142C0AB10((_QWORD *)(a1 + 0x3E8)) )
    {
      v70 = *(float *)(a1 + 0x190);
      __asm { vunpcklps xmm1, xmm11, xmm12 }
      v78 = a1;
      v79 = v70;
      v80 = *(double *)&_XMM1;
      v86 = *(double *)&_XMM1;
      v81 = v10;
      v85 = v9;
      v82 = v7;
      v83 = v11;
      v84 = v12;
      v87 = v10;
      v91 = v9;
      v88 = v7;
      v89 = v11;
      v90 = v12;
      v92 = 0;
      v72 = unknown_libname_484(a1 + 0x3E8);
      v73 = (__crt_win32_buffer_debug_info *)(a1 + 0x3E8);
      v74 = (const char *)v72;
      for ( i = __crt_win32_buffer_debug_info::file_name(v73); v74 != i; v74 += 0x20 )
      {
        v92 = 0;
        sub_142BB4600((__int64)(v74 + 8), (__int64)&v78);
      }
      _XMM11 = LODWORD(v86);
      v10 = v87;
      v7 = v88;
      v11 = v89;
      v12 = v90;
      v9 = v91;
    }
    *(float *)(a2 + 0xC) = v9;
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v11;
    *(float *)(a2 + 8) = v12;
    __asm { vunpcklps xmm0, xmm11, xmm12 }
    *(double *)(a2 + 0x10) = *(double *)&_XMM0;
    *(float *)(a2 + 0x18) = v10;
    v97 = __rdtsc();
    qword_149B4B878(&n0x4300);
  }
  else
  {
    *(_DWORD *)(a2 + 0xC) = 0x3F800000;
    *(_QWORD *)a2 = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 0x10) = 0;
    *(_DWORD *)(a2 + 0x18) = 0;
    v97 = __rdtsc();
    qword_149B4B878(&n0x4300);
  }
  return a2;
}

// --- End Function: sub_1431F3400 (0x1431F3400) ---

// --- Function: sub_1431F3CC0 (0x1431F3CC0) ---
void __fastcall sub_1431F3CC0(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm8
  __int128 v3; // xmm10
  float v5; // xmm11_4
  __int128 v6; // xmm0
  int v7; // eax
  __m128 v8; // xmm8
  __m128 v9; // xmm12
  __m128 v10; // kr00_16
  __m128 v11; // xmm9
  float v12; // xmm9_4
  float v13; // xmm13_4
  float v14; // xmm15_4
  float *v15; // rax
  float X; // xmm1_4
  float v17; // xmm9_4
  float v18; // xmm12_4
  float v19; // xmm14_4
  float v20; // xmm15_4
  __int64 v22; // rcx
  __int64 v24; // rcx
  float v25; // xmm11_4
  int n2_1; // eax
  int n2; // edi
  __int64 v28; // r10
  __int128 v29; // xmm6
  __int64 v30; // rax
  __int128 v31; // kr00_16
  __int128 n0x40400000_1; // xmm2
  __int128 n0x40400000; // kr00_16
  float v41; // [rsp+30h] [rbp-198h]
  float v42[2]; // [rsp+34h] [rbp-194h] BYREF
  float v43[2]; // [rsp+3Ch] [rbp-18Ch] BYREF
  float v44[3]; // [rsp+44h] [rbp-184h] BYREF
  float v45[2]; // [rsp+50h] [rbp-178h] BYREF
  float v46; // [rsp+58h] [rbp-170h]
  __int128 v47; // [rsp+60h] [rbp-168h] BYREF
  double v48; // [rsp+70h] [rbp-158h]
  int v49; // [rsp+78h] [rbp-150h]
  int n0x4300; // [rsp+80h] [rbp-148h] BYREF
  __int64 v51; // [rsp+84h] [rbp-144h]
  int v52; // [rsp+8Ch] [rbp-13Ch]
  unsigned __int64 v53; // [rsp+90h] [rbp-138h]
  unsigned __int64 v54; // [rsp+98h] [rbp-130h]
  __int64 v55; // [rsp+A0h] [rbp-128h]
  __int64 v56; // [rsp+A8h] [rbp-120h]
  float v57[8]; // [rsp+D0h] [rbp-F8h] BYREF
  __m256 v58; // [rsp+F0h] [rbp-D8h] BYREF
  __int128 v59; // [rsp+170h] [rbp-58h]
  __int128 v60; // [rsp+190h] [rbp-38h]
  __int128 v61; // [rsp+1B0h] [rbp-18h]

  n0x4300 = 0x4300;
  v51 = 0;
  v52 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v53 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20A5C,
    "CAnimatedCharacter::CalculateParamsForCurrentMotions",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS_ParamCalculation.cpp",
    0x12);
  HIWORD(n0x4300) = word_149E20A5C;
  if ( *(_QWORD *)(a1 + 0x330) )
  {
    v5 = *(float *)(a1 + 0x1A0);
    if ( v5 > 0.0 )
    {
      v6 = *(_OWORD *)(a1 + 0x270);
      v7 = *(_DWORD *)(a1 + 0x288);
      v61 = v1;
      v60 = v2;
      v8 = (__m128)*(unsigned __int64 *)(a1 + 0x280);
      v59 = v3;
      v9 = _mm_shuffle_ps(v8, v8, 0x55);
      v47 = v6;
      v10 = v9;
      v10.m128_f32[0] = (float)(v9.m128_f32[0] * v9.m128_f32[0]) + (float)(v8.m128_f32[0] * v8.m128_f32[0]);
      v11 = _mm_sqrt_ps(_mm_shuffle_ps(v10, v10, 0));
      v12 = _mm_shuffle_ps(v11, v11, 0xFF).m128_f32[0];
      v49 = v7;
      v48 = *(double *)v8.m128_u64;
      sub_140305ED0(v45, (float *)&v47);
      v13 = v46;
      v41 = (float)(1.0 / v5) * v45[0];
      v42[0] = (float)(1.0 / v5) * v45[1];
      v14 = (float)(1.0 / v5) * v46;
      if ( v12 <= 0.0 )
      {
        v44[0] = 0.0;
        v44[1] = 0.0;
        v15 = v44;
      }
      else
      {
        v43[1] = v9.m128_f32[0] * (float)(1.0 / v12);
        v43[0] = v8.m128_f32[0] * (float)(1.0 / v12);
        v15 = v43;
      }
      X = v15[1];
      if ( COERCE_FLOAT(*(_DWORD *)v15 & 0x7FFFFFFF) > 0.0 || COERCE_FLOAT(LODWORD(X) & 0x7FFFFFFF) > 0.0 )
        atan2f(COERCE_FLOAT(*(_DWORD *)v15 ^ 0x80000000), X);
      *(float *)(a1 + 0x360) = (float)(1.0 / v5) * v12;
      sub_14326DBF0((float *)(a1 + 0x360), v5);
      v17 = *(float *)(a1 + 0x364);
      *(float *)(a1 + 0x370) = v14;
      sub_14326DBF0((float *)(a1 + 0x370), v5);
      v18 = *(float *)(a1 + 0x374);
      *(float *)(a1 + 0x380) = v41;
      sub_14326DBF0((float *)(a1 + 0x380), v5);
      v19 = *(float *)(a1 + 0x384);
      *(float *)(a1 + 0x390) = v42[0];
      sub_14326DBF0((float *)(a1 + 0x390), v5);
      v20 = *(float *)(a1 + 0x394);
      *((_QWORD *)&_XMM0 + 1) = 0;
      *(double *)&_XMM0 = _libm_sse2_sincosf_(v22);
      _RCX = a1 + 0x3A0;
      *(float *)(a1 + 0x3A0) = COERCE_FLOAT(_XMM0 ^ 0x80000000);
      __asm { vextractps dword ptr [rcx+4], xmm0, 1 }
      sub_14326DDD0(a1 + 0x3A0, v42);
      *(float *)&_XMM0 = atan2f(COERCE_FLOAT(*(_DWORD *)(a1 + 0x3A8) ^ 0x80000000), *(float *)(a1 + 0x3AC));
      v24 = *(_QWORD *)(a1 + 0x330);
      *(_DWORD *)(a1 + 0x29C) = 0;
      v25 = *(float *)&_XMM0;
      n2_1 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v24 + 0xA0LL))(v24, 0);
      n2 = n2_1;
      if ( n2_1 >= 1 )
      {
        v28 = *(_QWORD *)(a1 + 0x330);
        *(_BYTE *)(a1 + 0x2A0) = 0;
        v29 = 0;
        v30 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v28 + 0xB8LL))(
                v28,
                0,
                (unsigned int)(n2_1 - 1));
        if ( (*(_DWORD *)(v30 + 0x50) & 2) != 0 && *(float *)(v30 + 0x30) > 0.1
          || n2 >= 2
          && (v30 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 0x330) + 0xB8LL))(
                      *(_QWORD *)(a1 + 0x330),
                      0,
                      (unsigned int)(n2 - 2)),
              (*(_DWORD *)(v30 + 0x50) & 2) != 0)
          && *(float *)(v30 + 0x30) > 0.1 )
        {
          v29 = *(unsigned int *)(v30 + 0x48);
          *(_BYTE *)(a1 + 0x2A0) = 1;
        }
        if ( *(_BYTE *)(a1 + 0x2A0) )
        {
          v31 = v29;
          *(float *)&v31 = *(float *)&v29 * 4.0;
          if ( *(float *)&v29 >= 0.5 )
          {
            n0x40400000 = 0x40400000u;
            *(float *)&n0x40400000 = 3.0 - (float)(*(float *)&v29 * 4.0);
            n0x40400000_1 = n0x40400000;
            LODWORD(_XMM1) = 0xBF800000;
            if ( *(float *)&n0x40400000 >= -1.0 )
              __asm { vminss  xmm1, xmm2, xmm10 }
            *(float *)(a1 + 0x29C) = *(float *)&_XMM1;
          }
          else
          {
            LODWORD(_XMM0) = 0xBF800000;
            *(float *)&v31 = *(float *)&v31 - 1.0;
            _XMM1 = v31;
            if ( *(float *)&v31 >= -1.0 )
              __asm { vminss  xmm0, xmm1, xmm10 }
            *(float *)(a1 + 0x29C) = *(float *)&_XMM0;
          }
        }
      }
      LODWORD(_XMM1) = *(_DWORD *)(a1 + 0x298);
      if ( *(float *)&_XMM1 == 3.4028235e38 )
      {
        _XMM3 = *(unsigned int *)(a1 + 0x29C);
        _XMM0 = *(unsigned __int8 *)(a1 + 0x2A0);
        __asm
        {
          vpcmpeqd xmm2, xmm0, xmm1
          vblendvps xmm1, xmm3, xmm7, xmm2
        }
      }
      v58 = ymmword_1487A1520;
      v57[0] = v17;
      v57[1] = v25;
      v57[2] = 0.0;
      v57[3] = v18;
      v57[4] = v19;
      v57[5] = v20;
      v57[6] = v13;
      v57[7] = *(float *)&_XMM1;
      __asm { vzeroupper }
      sub_143263870(a1, &v58, v57, 8);
    }
  }
  v54 = __rdtsc();
  qword_149B4B878(&n0x4300);
}

// --- End Function: sub_1431F3CC0 (0x1431F3CC0) ---

// --- Function: sub_1431F4210 (0x1431F4210) ---
__int64 __fastcall sub_1431F4210(__int64 a1, __int64 a2, double *a3, float *a4)
{
  __int128 v4; // xmm6
  float v10; // xmm4_4
  float v11; // xmm2_4
  float v12; // xmm3_4
  float v13; // xmm5_4
  __int64 v15; // rax
  __int64 v16; // rax
  float v17; // xmm2_4
  float v18; // xmm3_4
  float v20; // [rsp+38h] [rbp-89h] BYREF
  float v21; // [rsp+3Ch] [rbp-85h]
  float v22; // [rsp+40h] [rbp-81h]
  float v23; // [rsp+44h] [rbp-7Dh]
  double v24; // [rsp+48h] [rbp-79h]
  float v25; // [rsp+50h] [rbp-71h]
  int n0x4300; // [rsp+58h] [rbp-69h] BYREF
  __int64 v27; // [rsp+5Ch] [rbp-65h]
  int v28; // [rsp+64h] [rbp-5Dh]
  unsigned __int64 v29; // [rsp+68h] [rbp-59h]
  unsigned __int64 v30; // [rsp+70h] [rbp-51h]
  __int64 v31; // [rsp+78h] [rbp-49h]
  __int64 v32; // [rsp+80h] [rbp-41h]
  _BYTE v33[28]; // [rsp+A8h] [rbp-19h] BYREF
  char v34; // [rsp+C4h] [rbp+3h] BYREF
  __int128 v35; // [rsp+F8h] [rbp+37h]

  v35 = v4;
  v27 = 0;
  v28 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  n0x4300 = 0x4300;
  v29 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20A98,
    "CAnimatedCharacter::CalculateWantedEntityMovement",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
    0x180);
  HIWORD(n0x4300) = word_149E20A98;
  sub_143239C60((unsigned __int8 *)a1, (__int64)&v20, a3, a1 + 0x304, (__int64)a4);
  sub_143584460((float *)a2);
  _XMM6 = LODWORD(v24);
  if ( *(float *)&v24 == a4[4]
    && *((float *)&v24 + 1) == a4[5]
    && (v10 = v25, v25 == a4[6])
    && v20 == *a4
    && (v11 = v21, v21 == a4[1])
    && (v12 = v22, v22 == a4[2])
    && (v13 = v23, v23 == a4[3])
    && *(_DWORD *)(a1 + 0x2B4) != 9
    && *(_DWORD *)(a1 + 0x2D0) != 9 )
  {
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = v11;
    *(float *)(a2 + 8) = v12;
    *(float *)(a2 + 0xC) = v13;
    __asm { vunpcklps xmm0, xmm6, xmm1 }
    *(double *)(a2 + 0x10) = *(double *)&_XMM0;
    *(float *)(a2 + 0x18) = v10;
    v24 = *(double *)&_XMM0;
    *(_QWORD *)(a2 + 0x1C) = 0;
    *(_DWORD *)(a2 + 0x24) = 0;
  }
  else
  {
    v15 = sub_14322F600(a1, (unsigned int)&v34, (unsigned int)&v20, (_DWORD)a4, 0);
    *(_DWORD *)a2 = *(_DWORD *)v15;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v15 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v15 + 8);
    *(_DWORD *)(a2 + 0xC) = *(_DWORD *)(v15 + 0xC);
    *(double *)(a2 + 0x10) = *(double *)(v15 + 0x10);
    *(_DWORD *)(a2 + 0x18) = *(_DWORD *)(v15 + 0x18);
    *(double *)(a2 + 0x1C) = *(double *)(v15 + 0x1C);
    *(_DWORD *)(a2 + 0x24) = *(_DWORD *)(v15 + 0x24);
  }
  if ( *(_DWORD *)(a1 + 0x2B4) == 4 )
  {
    v16 = sub_143208880(a1, (__int64)v33, (unsigned __int64 *)a3, a2);
    *(_DWORD *)a2 = *(_DWORD *)v16;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v16 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v16 + 8);
    *(_DWORD *)(a2 + 0xC) = *(_DWORD *)(v16 + 0xC);
    *(double *)(a2 + 0x10) = *(double *)(v16 + 0x10);
    *(_DWORD *)(a2 + 0x18) = *(_DWORD *)(v16 + 0x18);
  }
  if ( *(_BYTE *)(a1 + 0x1A4) )
  {
    sub_1431D0180(a1, (float *)a2);
    if ( *(_BYTE *)(a1 + 0x1A5) )
      *(_DWORD *)(a1 + 0x320) = 1;
  }
  if ( *(_BYTE *)(a1 + 0x1C4) )
  {
    v17 = *(float *)(a1 + 0x1CC);
    v18 = *(float *)(a1 + 0x1D0);
    *(float *)(a2 + 0x1C) = *(float *)(a1 + 0x1C8) + *(float *)(a2 + 0x1C);
    *(float *)(a2 + 0x20) = v17 + *(float *)(a2 + 0x20);
    *(float *)(a2 + 0x24) = v18 + *(float *)(a2 + 0x24);
  }
  v30 = __rdtsc();
  qword_149B4B878(&n0x4300);
  return a2;
}

// --- End Function: sub_1431F4210 (0x1431F4210) ---

// --- Function: sub_1431F9210 (0x1431F9210) ---
__int64 __fastcall sub_1431F9210(__int64 a1, __int64 a2, __int64 a3)
{
  float v6; // xmm3_4
  float v7; // xmm5_4
  float v8; // kr00_4
  __int64 v10; // rcx
  int n0x4300; // [rsp+30h] [rbp-58h] BYREF
  __int64 v13; // [rsp+34h] [rbp-54h]
  int v14; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v15; // [rsp+40h] [rbp-48h]
  unsigned __int64 v16; // [rsp+48h] [rbp-40h]
  __int64 v17; // [rsp+50h] [rbp-38h]
  __int64 v18; // [rsp+58h] [rbp-30h]

  n0x4300 = 0x4300;
  v13 = 0;
  v14 = 0;
  v16 = 0;
  _RSI = a1;
  v17 = 0;
  v18 = 0;
  v15 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20AB0,
    "CombineHVComponents2D",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS_Common.cpp",
    0x18);
  v6 = *(float *)(a2 + 0xC);
  v7 = *(float *)(a2 + 4);
  v8 = (float)(v7 * *(float *)a2) - (float)(v6 * *(float *)(a2 + 8));
  HIWORD(n0x4300) = word_149E20AB0;
  *(_DWORD *)(_RSI + 0x10) = *(_DWORD *)(a2 + 0x10);
  *(_DWORD *)(_RSI + 0x14) = *(_DWORD *)(a2 + 0x14);
  *(_DWORD *)(_RSI + 0x18) = *(_DWORD *)(a3 + 0x18);
  atan2f(
    -(float)(v8 + v8),
    (float)((float)((float)(v6 * v6) + (float)(v6 * v6)) + (float)((float)(v7 * v7) + (float)(v7 * v7))) - 1.0);
  *((_QWORD *)&_XMM0 + 1) = 0;
  *(double *)&_XMM0 = _libm_sse2_sincosf_(v10);
  __asm { vextractps dword ptr [rsi+0Ch], xmm0, 1 }
  *(float *)(_RSI + 8) = *(float *)&_XMM0;
  *(_QWORD *)_RSI = 0;
  v16 = __rdtsc();
  qword_149B4B878(&n0x4300);
  return _RSI;
}

// --- End Function: sub_1431F9210 (0x1431F9210) ---

// --- Function: sub_1431F9340 (0x1431F9340) ---
__int64 __fastcall sub_1431F9340(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int128 v6; // xmm10
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  double v14; // xmm0_8
  float v15; // xmm10_4
  float v16; // xmm8_4
  float v17; // xmm9_4
  float v18; // xmm7_4
  __int64 v19; // rcx
  double v20; // xmm0_8
  float v21; // xmm5_4
  int v23; // [rsp+20h] [rbp-C8h]
  int v24; // [rsp+30h] [rbp-B8h] BYREF
  float v25; // [rsp+40h] [rbp-A8h] BYREF
  int n0x4300; // [rsp+50h] [rbp-98h] BYREF
  __int64 v27; // [rsp+54h] [rbp-94h]
  int v28; // [rsp+5Ch] [rbp-8Ch]
  unsigned __int64 v29; // [rsp+60h] [rbp-88h]
  unsigned __int64 v30; // [rsp+68h] [rbp-80h]
  __int64 v31; // [rsp+70h] [rbp-78h]
  __int64 v32; // [rsp+78h] [rbp-70h]
  __int128 v33; // [rsp+A0h] [rbp-48h]
  __int128 v34; // [rsp+B0h] [rbp-38h]
  __int128 v35; // [rsp+C0h] [rbp-28h]
  __int128 v36; // [rsp+D0h] [rbp-18h]

  v36 = v3;
  n0x4300 = 0x4300;
  v27 = 0;
  v28 = 0;
  v35 = v4;
  v34 = v5;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = v6;
  v29 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20AB4,
    "CombineHVComponents3D",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS_Common.cpp",
    0x2E);
  HIWORD(n0x4300) = word_149E20AB4;
  *(_DWORD *)(a1 + 0x10) = *(_DWORD *)(a2 + 0x10);
  *(_DWORD *)(a1 + 0x14) = *(_DWORD *)(a2 + 0x14);
  *(_DWORD *)(a1 + 0x18) = *(_DWORD *)(a3 + 0x18);
  sub_140305ED0(&v25, (float *)a2);
  sub_140305ED0((float *)&v24, (float *)a3);
  v14 = _libm_sse2_sincosf4_(v11, v10, v12, v13, v23);
  v15 = *(float *)&v14;
  v16 = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v14, (__m128)*(unsigned __int64 *)&v14, 0xE).m128_f32[0];
  v17 = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v14, (__m128)*(unsigned __int64 *)&v14, 1).m128_f32[0];
  v18 = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v14, (__m128)*(unsigned __int64 *)&v14, 0xAB).m128_f32[0];
  v20 = _libm_sse2_sincosf_(v19);
  v21 = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v20, (__m128)*(unsigned __int64 *)&v20, 1).m128_f32[0];
  *(float *)(a1 + 0xC) = (float)((float)(v16 * v15) * *(float *)&v20) + (float)((float)(v17 * v18) * v21);
  *(float *)a1 = (float)((float)(v21 * v18) * v15) - (float)((float)(*(float *)&v20 * v16) * v17);
  *(float *)(a1 + 4) = (float)((float)(*(float *)&v20 * v18) * v15) + (float)((float)(v21 * v16) * v17);
  *(float *)(a1 + 8) = (float)((float)(*(float *)&v20 * v18) * v17) - (float)((float)(v21 * v16) * v15);
  v30 = __rdtsc();
  qword_149B4B878(&n0x4300);
  return a1;
}

// --- End Function: sub_1431F9340 (0x1431F9340) ---

// --- Function: sub_143203A90 (0x143203A90) ---
AK::WriteBytesCount *__fastcall sub_143203A90(unsigned __int64 *a1)
{
  __int128 v1; // xmm6
  AK::WriteBytesCount *result; // rax
  unsigned __int64 v4; // rcx
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rax
  bool v9; // al
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rbx
  unsigned __int64 v16; // rax
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rcx
  unsigned __int64 v21; // rax
  bool v22; // dl
  __int64 v23; // rcx
  __int64 v24; // rax
  __int64 v25; // rcx
  int v26; // [rsp+30h] [rbp-D8h]
  float v27[8]; // [rsp+58h] [rbp-B0h] BYREF
  _QWORD v28[2]; // [rsp+78h] [rbp-90h] BYREF
  int v29; // [rsp+88h] [rbp-80h] BYREF
  __int128 v30; // [rsp+90h] [rbp-78h]
  __int64 v31; // [rsp+A0h] [rbp-68h]
  unsigned int v32; // [rsp+B4h] [rbp-54h]
  unsigned int v33; // [rsp+B8h] [rbp-50h]
  int n2; // [rsp+BCh] [rbp-4Ch]
  int n0x300; // [rsp+C0h] [rbp-48h]
  char v36; // [rsp+C4h] [rbp-44h]
  __int64 v37; // [rsp+C8h] [rbp-40h]
  _BYTE v38[4]; // [rsp+D8h] [rbp-30h] BYREF
  float v39; // [rsp+DCh] [rbp-2Ch]
  __int128 v40; // [rsp+E0h] [rbp-28h]
  __int64 v41; // [rsp+120h] [rbp+18h]
  __int64 v42; // [rsp+128h] [rbp+20h]
  unsigned __int64 v43; // [rsp+188h] [rbp+80h]
  _BYTE v44[4]; // [rsp+1B8h] [rbp+B0h] BYREF
  int v45; // [rsp+1BCh] [rbp+B4h]
  float v46; // [rsp+228h] [rbp+120h]
  float v47; // [rsp+22Ch] [rbp+124h]
  float v48; // [rsp+230h] [rbp+128h]
  char v49[56]; // [rsp+278h] [rbp+170h] BYREF
  __int128 v50; // [rsp+2B8h] [rbp+1B0h]
  AK::WriteBytesCount *v51; // [rsp+300h] [rbp+1F8h] BYREF
  __int64 v52; // [rsp+308h] [rbp+200h] BYREF

  result = qword_149E12BA0;
  if ( *((_DWORD *)qword_149E12BA0 + 0xB) )
  {
    v4 = a1[0x79];
    if ( v4 && *(_QWORD *)((v4 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v4) )
      sub_1432075F0((__int64)a1);
    v5 = 0;
    if ( validateHandleAccess(a1 + 1) )
      v6 = a1[1] & 0xFFFFFFFFFFFFLL;
    else
      v6 = 0;
    (*(void (__fastcall **)(__int64, AK::WriteBytesCount **))(*(_QWORD *)v6 + 0x3B8LL))(v6, &v51);
    result = v51;
    if ( v51 )
    {
      result = (AK::WriteBytesCount *)((unsigned __int64)v51 >> 0x30);
      if ( *(_QWORD *)(((unsigned __int64)v51 & 0xFFFFFFFFFFFFLL) + 8) == (unsigned __int64)v51 >> 0x30 )
      {
        v50 = v1;
        v36 = v36 & 0xF0 | 8;
        v29 = 0;
        DWORD1(v30) = 0xFFF7FFFF;
        v33 = 0xFFBFFFFF;
        v32 = 0xFFBFFFFF;
        if ( validateHandleAccess(a1 + 1) )
          v7 = a1[1] & 0xFFFFFFFFFFFFLL;
        else
          v7 = 0;
        v8 = (*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v7 + 0x1E8LL))(v7, v49, 2);
        v30 = *(_OWORD *)(v8 + 0x20);
        v31 = *(_QWORD *)(v8 + 0x30);
        v9 = (char)v51;
        if ( v51 )
        {
          v10 = (unsigned __int64)v51 & 0xFFFFFFFFFFFFLL;
          v9 = *(_QWORD *)(((unsigned __int64)v51 & 0xFFFFFFFFFFFFLL) + 8) == (unsigned __int64)v51 >> 0x30;
        }
        else
        {
          v10 = 0;
        }
        v11 = 0;
        if ( v9 )
          v11 = v10;
        (*(void (__fastcall **)(__int64, __int64 *, __int64, _QWORD))(*(_QWORD *)qword_149B4FC00 + 0x218LL))(
          qword_149B4FC00,
          &v52,
          v11,
          0);
        v37 = sub_1402A2660((__int64)&v52);
        sub_1404620B0(&v52);
        n2 = 2;
        n0x300 = 0x300;
        a1[0x79] = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, __int64, int *, unsigned __int64, int, unsigned int, _QWORD, _QWORD, _QWORD))(*(_QWORD *)qword_149B4FC00 + 0x138LL))(
                                qword_149B4FC00,
                                &v52,
                                6,
                                &v29,
                                a1[1],
                                2,
                                0xFFFFFFFF,
                                0,
                                0,
                                0);
        v27[5] = 1.0;
        v27[3] = 0.0;
        v27[4] = 0.0;
        v27[2] = 0.0;
        v27[1] = 0.0;
        v27[0] = 0.0;
        v27[6] = 0.44999999;
        v27[7] = 0.60000002;
        v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC00 + 0x50LL))(qword_149B4FC00);
        v13 = (*(__int64 (__fastcall **)(__int64, __int64, float *))(*(_QWORD *)v12 + 0x30LL))(v12, 6, v27);
        v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC00 + 0x50LL))(qword_149B4FC00);
        v15 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _DWORD))(*(_QWORD *)v14 + 0x40LL))(
                v14,
                v13,
                0,
                0,
                0);
        *(_DWORD *)(v15 + 0x44) = 0;
        sub_141EF0850((__int64)v38);
        v16 = a1[1];
        v17 = (unsigned __int8)~(unsigned __int8)a1[0x7A] & 0xFB;
        v42 = 0;
        v41 = v17;
        v39 = 0.0;
        v40 = 0;
        v43 = v16;
        if ( validateHandleAccess(a1 + 1) )
          v18 = a1[1] & 0xFFFFFFFFFFFFLL;
        else
          v18 = 0;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x440LL))(v18);
        if ( validateHandleAccess(a1 + 1) )
          v19 = a1[1] & 0xFFFFFFFFFFFFLL;
        else
          v19 = 0;
        LOBYTE(v26) = 0;
        (*(void (__fastcall **)(__int64, __int64, _BYTE *, __int64, unsigned __int64, int))(*(_QWORD *)v19 + 0x410LL))(
          v19,
          v15,
          v38,
          0x66,
          a1[0x79],
          v26);
        sub_1431BB170((__int64)v44);
        v45 = 1;
        v48 = 0.80000001;
        v46 = 0.0;
        v47 = 0.0;
        if ( validateHandleAccess(a1 + 1) )
          v20 = a1[1] & 0xFFFFFFFFFFFFLL;
        else
          v20 = 0;
        (*(void (__fastcall **)(__int64, _BYTE *, unsigned __int64, _QWORD))(*(_QWORD *)v20 + 0x3F8LL))(
          v20,
          v44,
          a1[0x79],
          0);
        v21 = a1[0x79];
        LODWORD(v28[0]) = 0x22;
        if ( v21 )
        {
          v23 = v21 & 0xFFFFFFFFFFFFLL;
          v22 = *(_QWORD *)((v21 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v21);
        }
        else
        {
          v22 = 0;
          v23 = 0;
        }
        v24 = 0;
        if ( v22 )
          v24 = v23;
        v28[1] = v24;
        if ( validateHandleAccess(a1 + 1) )
          v25 = a1[1] & 0xFFFFFFFFFFFFLL;
        else
          v25 = 0;
        (*(void (__fastcall **)(__int64, _QWORD *, unsigned __int64, _QWORD))(*(_QWORD *)v25 + 0x3F8LL))(
          v25,
          v28,
          a1[0x79],
          0);
        if ( validateHandleAccess(a1 + 1) )
          v5 = a1[1] & 0xFFFFFFFFFFFFLL;
        return (AK::WriteBytesCount *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x448LL))(v5);
      }
    }
  }
  return result;
}

// --- End Function: sub_143203A90 (0x143203A90) ---

// --- Function: sub_1432075F0 (0x1432075F0) ---
__int64 __fastcall sub_1432075F0(__int64 a1)
{
  unsigned __int64 v1; // rdx
  __int64 result; // rax
  __int64 v4; // r8
  unsigned __int64 v5; // rdx
  bool v6; // r9
  __int64 v7; // rdx

  v1 = *(_QWORD *)(a1 + 0x3C8);
  if ( v1 )
  {
    result = 0xFFFFFFFFFFFFLL;
    v4 = v1 & 0xFFFFFFFFFFFFLL;
    v5 = HIWORD(v1);
    v6 = *(_QWORD *)(v4 + 8) == v5;
    if ( *(_QWORD *)(v4 + 8) == v5 )
    {
      v7 = 0;
      if ( v6 )
        v7 = v4;
      result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149B4FC00 + 0x148LL))(
                 qword_149B4FC00,
                 v7,
                 0);
      *(_QWORD *)(a1 + 0x3C8) = 0;
    }
  }
  return result;
}

// --- End Function: sub_1432075F0 (0x1432075F0) ---

// --- Function: sub_143208880 (0x143208880) ---
__int64 __fastcall sub_143208880(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4)
{
  float v4; // xmm4_4
  __m128 v8; // kr00_16
  __m128 v9; // xmm0
  float v10; // xmm15_4
  __int64 v12; // rcx
  float *v13; // rax
  float v14; // xmm12_4
  float v15; // xmm5_4
  float v16; // xmm13_4
  float v17; // xmm10_4
  float v18; // xmm11_4
  float v19; // xmm4_4
  float v20; // xmm8_4
  float v21; // xmm7_4
  float v22; // xmm4_4
  float v23; // xmm6_4
  float v24; // xmm2_4
  float v26; // xmm3_4
  float v29; // xmm12_4
  float v35; // xmm11_4
  float v36; // kr00_4
  float v37; // xmm8_4
  float v38; // xmm7_4
  float v39; // xmm6_4
  float v40; // xmm6_4
  float v41; // xmm8_4
  float v42; // xmm7_4
  __m128 v43; // kr00_16
  __m128 v46; // xmm1
  float v47; // xmm5_4
  float v48; // xmm4_4
  __m128 v49; // xmm2
  __m128 v50; // kr00_16
  float v51; // xmm3_4
  __m128 v52; // kr00_16
  __m128 v53; // xmm0
  __m128 v55; // kr00_16

  v4 = *(float *)(a1 + 0x198);
  *(_DWORD *)(a2 + 0xC) = *(_DWORD *)(a4 + 0xC);
  *(_DWORD *)a2 = *(_DWORD *)a4;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a4 + 8);
  *(double *)(a2 + 0x10) = *(double *)(a4 + 0x10);
  *(_DWORD *)(a2 + 0x18) = *(_DWORD *)(a4 + 0x18);
  if ( (LODWORD(v4) & 0x7FFFFFFF) - 1 < 0 )
    return a2;
  v8 = (__m128)*(unsigned int *)(a4 + 0x10);
  v8.m128_f32[0] = (float)((float)(*(float *)(a4 + 0x10) * *(float *)(a4 + 0x10))
                         + (float)(*(float *)(a4 + 0x14) * *(float *)(a4 + 0x14)))
                 + (float)(*(float *)(a4 + 0x18) * *(float *)(a4 + 0x18));
  v9 = _mm_sqrt_ps(_mm_shuffle_ps(v8, v8, 0));
  v10 = _mm_shuffle_ps(v9, v9, 0xFF).m128_f32[0] / v4;
  LODWORD(_XMM14) = 0;
  if ( v10 > 0.0 )
  {
    v12 = *(_QWORD *)(a1 + 0x330);
    if ( v12 )
    {
      v13 = (float *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v12 + 0x1E0LL))(v12, 0);
      v14 = v13[5];
      v15 = v13[2];
      v16 = v13[6];
      v17 = v13[1];
      v18 = v13[4];
      v19 = v13[3];
      v20 = (float)((float)(v14 * v15) - (float)(v16 * v17)) + (float)(v18 * v19);
      v21 = (float)((float)(v16 * *v13) - (float)(v18 * v15)) + (float)(v14 * v19);
      v22 = (float)((float)(v18 * v17) - (float)(v14 * *v13)) + (float)(v16 * v19);
      v23 = (float)(v15 * v21) - (float)(v22 * v17);
      v24 = v22 * *v13;
      _XMM4 = a3[3];
      v26 = v17 * v20;
      _XMM10 = a3[1];
      _XMM9 = *a3;
      v29 = (float)(v14 + (float)(v24 - (float)(v15 * v20))) + (float)(v24 - (float)(v15 * v20));
      _XMM5 = a3[2];
      __asm
      {
        vcvtpd2ps xmm5, xmm5
        vcvtpd2ps xmm10, xmm10
        vcvtpd2ps xmm4, xmm4
        vcvtpd2ps xmm9, xmm9
      }
      v35 = (float)(v18 + v23) + v23;
      v36 = (float)(v16 + (float)(v26 - (float)(*v13 * v21))) + (float)(v26 - (float)(*v13 * v21));
      v37 = (float)((float)(*(float *)&_XMM10 * v36) - (float)(*(float *)&_XMM5 * v29))
          + (float)(*(float *)&_XMM4 * v35);
      v38 = (float)((float)(*(float *)&_XMM5 * v35) - (float)(*(float *)&_XMM9 * v36)) + (float)(*(float *)&_XMM4 * v29);
      *(float *)&_XMM4 = (float)((float)(*(float *)&_XMM9 * v29) - (float)(*(float *)&_XMM10 * v35))
                       + (float)(*(float *)&_XMM4 * v36);
      v39 = (float)(*(float *)&_XMM4 * *(float *)&_XMM10) - (float)(v38 * *(float *)&_XMM5);
      *(float *)&_XMM5 = (float)(v37 * *(float *)&_XMM5) - (float)(*(float *)&_XMM4 * *(float *)&_XMM9);
      v40 = (float)(v35 + v39) + v39;
      v41 = (float)(v36 + (float)((float)(v38 * *(float *)&_XMM9) - (float)(v37 * *(float *)&_XMM10)))
          + (float)((float)(v38 * *(float *)&_XMM9) - (float)(v37 * *(float *)&_XMM10));
      v42 = (float)(v29 + *(float *)&_XMM5) + *(float *)&_XMM5;
      v43 = (__m128)*(unsigned int *)(a1 + 0x314);
      v43.m128_f32[0] = (float)((float)(*(float *)(a1 + 0x314) * *(float *)(a1 + 0x314))
                              + (float)(*(float *)(a1 + 0x318) * *(float *)(a1 + 0x318)))
                      + (float)(*(float *)(a1 + 0x31C) * *(float *)(a1 + 0x31C));
      if ( v43.m128_f32[0] <= 0.00000011920929 )
      {
        v49 = (__m128)(unsigned int)n0x3FC00000;
        v48 = *((float *)&n0x3FC00000 + 1);
        v47 = *(float *)&dword_149924108;
      }
      else
      {
        _XMM0 = _mm_shuffle_ps(v43, v43, 0);
        __asm { vrsqrtps xmm3, xmm0 }
        _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
        v46 = (__m128)*(unsigned __int64 *)(a1 + 0x314);
        _XMM3.m128_f32[0] = (float)(1.5
                                  - (float)((float)((float)(_XMM3.m128_f32[0] * v43.m128_f32[0]) * _XMM3.m128_f32[0])
                                          * 0.5))
                          * _XMM3.m128_f32[0];
        v47 = _XMM3.m128_f32[0] * *(float *)(a1 + 0x31C);
        v48 = _mm_shuffle_ps(v46, v46, 0x55).m128_f32[0] * _XMM3.m128_f32[0];
        v50 = v46;
        v50.m128_f32[0] = v46.m128_f32[0] * _XMM3.m128_f32[0];
        v49 = v50;
      }
      v51 = *(float *)(a1 + 0x19C);
      if ( v51 <= 0.0 )
      {
        v53 = 0;
      }
      else
      {
        v52 = v49;
        v52.m128_f32[0] = (float)((float)((float)(v49.m128_f32[0] * v40) + (float)(v42 * v48)) + (float)(v41 * v47))
                        / v51;
        v53 = v52;
      }
      v55 = v53;
      v55.m128_f32[0] = v53.m128_f32[0] / v10;
      _XMM0 = v55;
      if ( v55.m128_f32[0] >= 0.0 )
        __asm { vminss  xmm14, xmm0, cs:Y }
      *(float *)(a2 + 0x10) = *(float *)&_XMM14 * *(float *)(a2 + 0x10);
      *(float *)(a2 + 0x14) = *(float *)&_XMM14 * *(float *)(a2 + 0x14);
      *(float *)(a2 + 0x18) = *(float *)&_XMM14 * *(float *)(a2 + 0x18);
    }
  }
  return a2;
}

// --- End Function: sub_143208880 (0x143208880) ---

// --- Function: sub_143218580 (0x143218580) ---
const char *__fastcall sub_143218580(int a1)
{
  const char *p_INVALID_MOVEMENT_CONTROL_METHOD; // rax

  switch ( a1 )
  {
    case 0:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "Undefined";
      break;
    case 1:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "Entity";
      break;
    case 2:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "Animation";
      break;
    case 3:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "DecoupledCatchUp";
      break;
    case 4:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "ClampedEntity";
      break;
    case 5:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "SmoothedEntity";
      break;
    case 6:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "AnimationHBlended";
      break;
    case 7:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "EntityTranslationAnimationRotation";
      break;
    case 8:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "EntityRotationAnimationTranslation";
      break;
    case 9:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "EntityAdditiveAnimation";
      break;
    default:
      p_INVALID_MOVEMENT_CONTROL_METHOD = "INVALID_MOVEMENT_CONTROL_METHOD";
      break;
  }
  return p_INVALID_MOVEMENT_CONTROL_METHOD;
}

// --- End Function: sub_143218580 (0x143218580) ---

// --- Function: sub_14322F600 (0x14322F600) ---
__int64 __fastcall sub_14322F600(__int64 a1, __int64 a2, __int128 *a3, __int128 *a4, char a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  __int128 v8; // xmm9
  __int128 v9; // xmm10
  __int128 v10; // xmm11
  __int64 v11; // rsi
  int v16; // edx
  int v17; // r12d
  __int128 *v18; // rdx
  int v19; // eax
  int v20; // eax
  float v21; // xmm11_4
  float v22; // xmm9_4
  float v23; // xmm8_4
  float v24; // xmm7_4
  float v25; // xmm10_4
  float v26; // xmm5_4
  float v27; // xmm4_4
  float v28; // xmm6_4
  int v29; // eax
  const char *v30; // rax
  float v31; // xmm14_4
  int v32; // eax
  __int128 v33; // xmm0
  int v34; // eax
  float v35; // xmm4_4
  __m128 v36; // xmm7
  float v37; // xmm10_4
  float v38; // xmm5_4
  float v39; // xmm6_4
  float v40; // xmm8_4
  float v41; // xmm13_4
  float v42; // xmm11_4
  float v43; // xmm10_4
  __m128 v44; // kr00_16
  float v45; // xmm9_4
  float v46; // xmm8_4
  float v49; // xmm7_4
  __int128 v50; // kr00_16
  float v52; // xmm4_4
  int v54; // eax
  int v55; // eax
  double v56; // xmm0_8
  float v57; // eax
  const char *v58; // rax
  int v59; // eax
  __int128 v60; // xmm0
  int v61; // eax
  int v62; // eax
  int v63; // eax
  double v64; // xmm0_8
  float v65; // eax
  int v66; // eax
  const char *v67; // rax
  float v69; // xmm7_4
  __m128 v70; // kr00_16
  float v73; // kr00_4
  float v74; // xmm10_4
  float v75; // xmm4_4
  float v76; // xmm11_4
  float v77; // xmm6_4
  float v78; // xmm9_4
  float v79; // xmm5_4
  float v80; // xmm12_4
  float v81; // xmm8_4
  float v82; // xmm7_4
  unsigned __int128 v83; // kr00_16
  float v87; // xmm1_4
  float v88; // xmm0_4
  float v89; // xmm5_4
  float v90; // xmm12_4
  __m128 v91; // kr00_16
  float v94; // xmm4_4
  float v95; // xmm13_4
  float v96; // xmm11_4
  float v97; // xmm15_4
  float v98; // xmm7_4
  float v99; // xmm5_4
  float v100; // xmm4_4
  float v101; // xmm6_4
  float v102; // xmm7_4
  float v103; // xmm5_4
  float v104; // xmm4_4
  float v105; // xmm7_4
  float v106; // xmm5_4
  float v107; // xmm4_4
  float v108; // xmm6_4
  float v109; // xmm7_4
  float v110; // xmm12_4
  float v111; // xmm0_4
  float v112; // xmm13_4
  float v113; // xmm5_4
  float v114; // xmm4_4
  __int64 v115; // rax
  __int64 v116; // rax
  __int64 v117; // rax
  float v118; // eax
  float v119; // xmm7_4
  float v120; // xmm5_4
  float v121; // xmm4_4
  float v122; // xmm10_4
  float v123; // xmm6_4
  float v124; // xmm5_4
  float v125; // xmm7_4
  float v126; // xmm5_4
  float v127; // xmm4_4
  __int64 v129; // [rsp+38h] [rbp-D0h]
  __int128 v130; // [rsp+40h] [rbp-C8h] BYREF
  double v131; // [rsp+50h] [rbp-B8h]
  _QWORD v132[3]; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v133; // [rsp+70h] [rbp-98h]
  __int64 v134; // [rsp+78h] [rbp-90h]
  unsigned __int64 v135; // [rsp+80h] [rbp-88h] BYREF
  float v136; // [rsp+88h] [rbp-80h]
  float v137; // [rsp+90h] [rbp-78h] BYREF
  float v138; // [rsp+94h] [rbp-74h]
  float v139; // [rsp+98h] [rbp-70h]
  float v140; // [rsp+9Ch] [rbp-6Ch]
  __int64 v141; // [rsp+A0h] [rbp-68h]
  float v142; // [rsp+A8h] [rbp-60h]
  __int128 v143; // [rsp+B0h] [rbp-58h] BYREF
  double v144; // [rsp+C0h] [rbp-48h]
  float v145; // [rsp+C8h] [rbp-40h]
  __int128 v146; // [rsp+D0h] [rbp-38h] BYREF
  double v147; // [rsp+E0h] [rbp-28h]
  float v148; // [rsp+E8h] [rbp-20h]
  __int128 _Al__204; // [rsp+F0h] [rbp-18h]
  __int64 v150; // [rsp+100h] [rbp-8h] BYREF
  float v151; // [rsp+108h] [rbp+0h]
  int n0x4300; // [rsp+118h] [rbp+10h] BYREF
  __int64 v153; // [rsp+11Ch] [rbp+14h]
  int v154; // [rsp+124h] [rbp+1Ch]
  unsigned __int64 v155; // [rsp+128h] [rbp+20h]
  unsigned __int64 v156; // [rsp+130h] [rbp+28h]
  __int64 v157; // [rsp+138h] [rbp+30h]
  __int64 v158; // [rsp+140h] [rbp+38h]
  unsigned __int64 v159; // [rsp+168h] [rbp+60h]
  __int128 v160; // [rsp+178h] [rbp+70h] BYREF
  __int64 v161; // [rsp+188h] [rbp+80h]
  int v162; // [rsp+190h] [rbp+88h]
  __int128 v163; // [rsp+198h] [rbp+90h] BYREF
  __int64 v164; // [rsp+1A8h] [rbp+A0h]
  int v165; // [rsp+1B0h] [rbp+A8h]
  float v166[4]; // [rsp+1B8h] [rbp+B0h] BYREF
  __int64 v167; // [rsp+1C8h] [rbp+C0h]
  int v168; // [rsp+1D0h] [rbp+C8h]
  __int128 v169; // [rsp+1D8h] [rbp+D0h] BYREF
  unsigned int v170; // [rsp+1E8h] [rbp+E0h]
  unsigned int v171; // [rsp+1ECh] [rbp+E4h]
  float v172; // [rsp+1F0h] [rbp+E8h] BYREF
  float v173; // [rsp+1F4h] [rbp+ECh]
  float v174; // [rsp+1F8h] [rbp+F0h]
  unsigned int v175; // [rsp+1FCh] [rbp+F4h]
  unsigned int v176; // [rsp+200h] [rbp+F8h]
  unsigned int v177; // [rsp+204h] [rbp+FCh]
  unsigned int v178; // [rsp+208h] [rbp+100h]
  unsigned int v179; // [rsp+20Ch] [rbp+104h]
  unsigned int v180; // [rsp+210h] [rbp+108h]
  unsigned int v181; // [rsp+214h] [rbp+10Ch]
  unsigned int v182; // [rsp+218h] [rbp+110h]
  unsigned int v183; // [rsp+21Ch] [rbp+114h]
  unsigned int v184; // [rsp+220h] [rbp+118h]
  unsigned __int64 v185; // [rsp+228h] [rbp+120h]
  unsigned int v186; // [rsp+230h] [rbp+128h]
  unsigned int v187; // [rsp+234h] [rbp+12Ch]
  unsigned int v188; // [rsp+238h] [rbp+130h]
  unsigned int v189; // [rsp+23Ch] [rbp+134h]
  unsigned int v190; // [rsp+240h] [rbp+138h]
  unsigned int v191; // [rsp+244h] [rbp+13Ch]
  unsigned int v192; // [rsp+248h] [rbp+140h]
  unsigned int v193; // [rsp+258h] [rbp+150h]
  _BYTE v194[24]; // [rsp+268h] [rbp+160h] BYREF
  __int128 v195; // [rsp+2C8h] [rbp+1C0h]
  __int128 v196; // [rsp+2D8h] [rbp+1D0h]
  __int128 v197; // [rsp+2E8h] [rbp+1E0h]
  __int128 v198; // [rsp+2F8h] [rbp+1F0h]
  __int128 v199; // [rsp+308h] [rbp+200h]
  __int128 v200; // [rsp+318h] [rbp+210h]
  float v201; // [rsp+358h] [rbp+250h]
  float v202; // [rsp+358h] [rbp+250h]

  v200 = v5;
  v11 = 0;
  v199 = v6;
  v198 = v7;
  v197 = v8;
  v196 = v9;
  v195 = v10;
  n0x4300 = 0x4300;
  v153 = 0;
  v154 = 0;
  v156 = 0;
  v157 = 0;
  v158 = 0;
  v155 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20AB8,
    "CAnimatedCharacter::MergeMCM",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS_Common.cpp",
    0x46);
  v16 = *(_DWORD *)(a1 + 0x2B4);
  v17 = *(_DWORD *)(a1 + 0x2D0);
  HIWORD(n0x4300) = word_149E20AB8;
  if ( v16 == v17 )
  {
    switch ( v16 )
    {
      case 1:
      case 4:
      case 5:
        goto LABEL_3;
      case 2:
      case 3:
        v18 = a4;
        goto LABEL_4;
      case 7:
        v19 = *((_DWORD *)a3 + 6);
        v18 = &v160;
        v161 = *((_QWORD *)a3 + 2);
        v160 = *a4;
        v162 = v19;
        goto LABEL_4;
      case 8:
        v20 = *((_DWORD *)a4 + 6);
        v18 = &v163;
        v163 = *a3;
        v164 = *((_QWORD *)a4 + 2);
        v165 = v20;
        goto LABEL_4;
      case 9:
        v21 = *((float *)a3 + 1);
        v22 = *((float *)a4 + 1);
        v23 = *((float *)a3 + 2);
        v24 = *((float *)a4 + 2);
        v25 = *((float *)a3 + 3);
        v26 = *(float *)a4;
        v27 = *((float *)a4 + 3);
        v28 = *(float *)a3;
        v29 = *((_DWORD *)a3 + 6);
        v167 = *((_QWORD *)a3 + 2);
        v166[0] = (float)((float)((float)(v24 * v21) - (float)(v23 * v22)) + (float)(v26 * v25)) + (float)(v28 * v27);
        v166[1] = (float)((float)((float)(v23 * v26) - (float)(v24 * v28)) + (float)(v22 * v25)) + (float)(v21 * v27);
        v166[2] = (float)((float)((float)(v28 * v22) - (float)(v26 * v21)) + (float)(v24 * v25)) + (float)(v23 * v27);
        v168 = v29;
        v166[3] = (float)(v27 * v25) - (float)((float)((float)(v26 * v28) + (float)(v22 * v21)) + (float)(v24 * v23));
        sub_1457BF580(a2, v166, a4 + 1);
        goto LABEL_5;
      default:
        v30 = sub_143218580(v16);
        sub_142BCC2B0((__int64)"CAnimatedCharacter::MergeMCM() - Horizontal & Vertical MCM %s not implemented!", v30);
LABEL_3:
        v18 = a3;
LABEL_4:
        unknown_libname_806(a2, v18);
LABEL_5:
        v156 = __rdtsc();
        qword_149B4B878(&n0x4300);
        break;
    }
  }
  else
  {
    v31 = 0.0;
    *(float *)&v130 = 0.0;
    *((float *)&v130 + 1) = 0.0;
    *((float *)&v130 + 2) = 0.0;
    v131 = 0.0;
    *(float *)v132 = 0.0;
    v133 = 0;
    *(float *)&v134 = 0.0;
    *(float *)&v146 = 0.0;
    *((float *)&v146 + 1) = 0.0;
    *((float *)&v146 + 2) = 0.0;
    v147 = 0.0;
    v148 = 0.0;
    *(float *)&v143 = 0.0;
    *((float *)&v143 + 1) = 0.0;
    *((float *)&v143 + 2) = 0.0;
    v144 = 0.0;
    v145 = 0.0;
    *((float *)&v129 + 1) = 1.0;
    *((float *)&v130 + 3) = 1.0;
    *((float *)&v146 + 3) = 1.0;
    *((float *)&v143 + 3) = 1.0;
    switch ( v16 )
    {
      case 1:
      case 4:
      case 5:
        v32 = *((_DWORD *)a3 + 6);
        v130 = *a3;
        v131 = *((double *)a3 + 2);
        LODWORD(v132[0]) = v32;
        break;
      case 2:
      case 3:
        v33 = *a4;
        goto LABEL_13;
      case 6:
        v35 = *((float *)a3 + 3);
        v36 = (__m128)*((unsigned int *)a3 + 2);
        v37 = *((float *)a4 + 3);
        v38 = *(float *)a3;
        v39 = *((float *)a3 + 1);
        v40 = *((float *)a4 + 1);
        v41 = *(float *)(a1 + 0x2DC);
        if ( (float)((float)((float)(v35 * v37) + (float)(v36.m128_f32[0] * *((float *)a4 + 2)))
                   + (float)((float)(v39 * v40) + (float)(*(float *)a3 * *(float *)a4))) < 0.0 )
        {
          LODWORD(v35) ^= 0x80000000;
          LODWORD(v38) ^= 0x80000000;
          LODWORD(v39) ^= 0x80000000;
          *(_OWORD *)&v36 ^= 0x80000000;
        }
        v42 = (float)((float)(v35 - v37) * v41) + v37;
        v43 = (float)((float)(v38 - *(float *)a4) * v41) + *(float *)a4;
        v44 = v36;
        v45 = (float)((float)(v39 - v40) * v41) + v40;
        v46 = (float)((float)(v36.m128_f32[0] - *((float *)a4 + 2)) * v41) + *((float *)a4 + 2);
        v44.m128_f32[0] = (float)((float)(v46 * v46) + (float)(v45 * v45))
                        + (float)((float)(v43 * v43) + (float)(v42 * v42));
        _XMM2 = _mm_shuffle_ps(v44, v44, 0);
        __asm { vrsqrtps xmm3, xmm2 }
        _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
        v49 = (float)(1.5 - (float)((float)((float)(_XMM3.m128_f32[0] * v44.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
            * _XMM3.m128_f32[0];
        v50 = *((unsigned int *)a3 + 4);
        *(float *)&v50 = (float)((float)(*((float *)a3 + 4) - *((float *)a4 + 4)) * v41) + *((float *)a4 + 4);
        _XMM6 = v50;
        v52 = (float)((float)(*((float *)a3 + 6) - *((float *)a4 + 6)) * v41) + *((float *)a4 + 6);
        *(float *)&v130 = v43 * v49;
        *((float *)&v130 + 2) = v46 * v49;
        *((float *)&v130 + 1) = v45 * v49;
        __asm { vunpcklps xmm0, xmm6, xmm3 }
        v131 = *(double *)&_XMM0;
        *((float *)&v130 + 3) = v42 * v49;
        *(float *)v132 = v52;
        break;
      case 7:
        v54 = *((_DWORD *)a3 + 6);
        v131 = *((double *)a3 + 2);
        v130 = *a4;
        LODWORD(v132[0]) = v54;
        break;
      case 8:
        v33 = *a3;
LABEL_13:
        v34 = *((_DWORD *)a4 + 6);
        v130 = v33;
        v131 = *((double *)a4 + 2);
        LODWORD(v132[0]) = v34;
        break;
      case 9:
        v55 = *((_DWORD *)a3 + 6);
        v130 = *a3;
        v131 = *((double *)a3 + 2);
        v146 = *a4;
        v56 = *((double *)a4 + 2);
        LODWORD(v132[0]) = v55;
        v57 = *((float *)a4 + 6);
        v147 = v56;
        v148 = v57;
        break;
      default:
        v58 = sub_143218580(v16);
        sub_142BCC2B0((__int64)"CAnimatedCharacter::MergeMCM() - Horizontal MCM %s not implemented!", v58);
        break;
    }
    switch ( v17 )
    {
      case 1:
      case 4:
      case 5:
        v59 = *((_DWORD *)a3 + 6);
        *(_OWORD *)&v132[1] = *a3;
        v133 = *((_QWORD *)a3 + 2);
        LODWORD(v134) = v59;
        break;
      case 2:
      case 3:
        v60 = *a4;
        goto LABEL_24;
      case 7:
        v62 = *((_DWORD *)a3 + 6);
        v133 = *((_QWORD *)a3 + 2);
        *(_OWORD *)&v132[1] = *a4;
        LODWORD(v134) = v62;
        break;
      case 8:
        v60 = *a3;
LABEL_24:
        v61 = *((_DWORD *)a4 + 6);
        *(_OWORD *)&v132[1] = v60;
        v133 = *((_QWORD *)a4 + 2);
        LODWORD(v134) = v61;
        break;
      case 9:
        v63 = *((_DWORD *)a3 + 6);
        *(_OWORD *)&v132[1] = *a3;
        v133 = *((_QWORD *)a3 + 2);
        v143 = *a4;
        v64 = *((double *)a4 + 2);
        LODWORD(v134) = v63;
        v65 = *((float *)a4 + 6);
        v144 = v64;
        v145 = v65;
        break;
      default:
        v66 = *((_DWORD *)a3 + 6);
        *(_OWORD *)&v132[1] = *a3;
        v133 = *((_QWORD *)a3 + 2);
        LODWORD(v134) = v66;
        v67 = sub_143218580(v17);
        sub_142BCC2B0((__int64)"CAnimatedCharacter::MergeMCM() - Vertical MCM %s not implemented!", v67);
        break;
    }
    LODWORD(_XMM6) = 0;
    v69 = 0.0;
    v201 = 0.0;
    *(float *)&v129 = 0.0;
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v11 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v11 + 0x3B8LL))(v11, &v135);
    if ( v135 )
    {
      if ( *(_QWORD *)((v135 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v135) )
      {
        v169 = xmmword_148745680;
        v171 = 0xFFBFFFFF;
        v172 = NAN;
        v174 = NAN;
        v177 = 0xFFBFFFFF;
        v175 = 0x80000000;
        v176 = 0x80000000;
        v178 = 0x80000000;
        v187 = 0x80000000;
        v184 = 0x80000000;
        v185 = 0xFFFFFFFFFFFFFFFFuLL;
        v179 = 0xFFBFFFFF;
        v180 = 0xFFBFFFFF;
        v181 = 0xFFBFFFFF;
        v182 = 0xFFBFFFFF;
        v170 = 0xFFBFFFFF;
        v186 = 0x80000000;
        v183 = 0xFFBFFFFF;
        v188 = 0x80000000;
        v193 = 0xFFBFFFFF;
        v190 = 0x80000000;
        v191 = 0x80000000;
        v192 = 0x80000000;
        v189 = 0x80000000;
        if ( (*(unsigned int (__fastcall **)(unsigned __int64, __int128 *))(*(_QWORD *)(v135 & 0xFFFFFFFFFFFFLL) + 0x20LL))(
               v135 & 0xFFFFFFFFFFFFLL,
               &v169) )
        {
          if ( !sub_1405A5A20(&v172)
            && (COERCE_FLOAT(LODWORD(v172) & 0x7FFFFFFF) > 0.00000011920929
             || COERCE_FLOAT(LODWORD(v173) & 0x7FFFFFFF) > 0.00000011920929
             || COERCE_FLOAT(LODWORD(v174) & 0x7FFFFFFF) > 0.00000011920929) )
          {
            v70 = (__m128)LODWORD(v173);
            v70.m128_f32[0] = (float)((float)(v173 * v173) + (float)(v172 * v172)) + (float)(v174 * v174);
            if ( v70.m128_f32[0] <= 9.9999997e-21 )
            {
              v74 = 0.0;
              v75 = 1.0;
              v76 = 0.0;
            }
            else
            {
              _XMM0 = _mm_shuffle_ps(v70, v70, 0);
              __asm { vrsqrtps xmm3, xmm0 }
              _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
              v73 = (float)(1.5
                          - (float)((float)((float)(v70.m128_f32[0] * _XMM3.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
                  * _XMM3.m128_f32[0];
              v74 = v73 * v173;
              v75 = v73 * v174;
              v76 = v73 * v172;
            }
            LODWORD(v77) = src__4 ^ 0x80000000;
            LODWORD(v78) = HIDWORD(src__4) ^ 0x80000000;
            LODWORD(v79) = dword_149932E98 ^ 0x80000000;
            v80 = (float)((float)(COERCE_FLOAT(HIDWORD(src__4) ^ 0x80000000) * v74)
                        + (float)(v76 * COERCE_FLOAT(src__4 ^ 0x80000000)))
                + (float)((float)(COERCE_FLOAT(dword_149932E98 ^ 0x80000000) * v75) + 1.0);
            if ( v80 <= 0.000099999997 )
            {
              if ( (float)((float)((float)((float)((float)(v78 * v78) + (float)(v77 * v77)) + (float)(v79 * v79))
                                 * 0.80999994)
                         - (float)(v77 * v77)) >= 0.0 )
              {
                v136 = *((float *)&src__4 + 1);
                *(float *)&v135 = 0.0;
                HIDWORD(v135) = dword_149932E98 ^ 0x80000000;
              }
              else
              {
                LODWORD(v135) = dword_149932E98;
                *((float *)&v135 + 1) = 0.0;
                LODWORD(v136) = src__4 ^ 0x80000000;
              }
              v159 = v135;
              v91 = (__m128)v135;
              v91.m128_f32[0] = (float)((float)((float)(v91.m128_f32[0] * v91.m128_f32[0])
                                              + (float)(*((float *)&v135 + 1) * *((float *)&v135 + 1)))
                                      + (float)(v136 * v136))
                              + 1.1754944e-38;
              _XMM0 = _mm_shuffle_ps(v91, v91, 0);
              __asm { vrsqrtps xmm3, xmm0 }
              _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
              v94 = (float)(1.5
                          - (float)((float)((float)(v91.m128_f32[0] * _XMM3.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
                  * _XMM3.m128_f32[0];
              v69 = v94 * v136;
              *(float *)&_XMM6 = _mm_shuffle_ps((__m128)v135, (__m128)v135, 0x55).m128_f32[0] * v94;
              v201 = *(float *)&_XMM6;
              v89 = *(float *)&v135 * v94;
              v90 = 0.0;
            }
            else
            {
              v81 = (float)(v78 * v75) - (float)(v79 * v74);
              v82 = (float)(v76 * v79) - (float)(v77 * v75);
              v83 = (unsigned int)src__4 ^ (unsigned __int128)0x80000000;
              *(float *)&v83 = (float)(v77 * v74) - (float)(v76 * v78);
              _XMM6 = v83;
              *(float *)&v83 = (float)((float)(*(float *)&v83 * *(float *)&v83) + (float)(v82 * v82))
                             + (float)((float)(v81 * v81) + (float)(v80 * v80));
              _XMM2 = _mm_shuffle_ps((__m128)v83, (__m128)v83, 0);
              __asm { vrsqrtps xmm3, xmm2 }
              _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
              v87 = (float)(1.5 - (float)((float)((float)(*(float *)&v83 * _XMM3.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
                  * _XMM3.m128_f32[0];
              v88 = v87 * v82;
              v69 = v87 * *(float *)&_XMM6;
              v201 = v88;
              __asm { vinsertps xmm6, xmm6, xmm0, 0Eh }
              v89 = v87 * v81;
              v90 = v87 * v80;
            }
            *((float *)&v129 + 1) = v90;
            *(float *)&v129 = v69;
            v31 = v89;
          }
        }
      }
    }
    LODWORD(v95) = _XMM6 ^ 0x80000000;
    LODWORD(v96) = LODWORD(v69) ^ 0x80000000;
    v97 = *((float *)&v129 + 1);
    v98 = (float)((float)(*(float *)v132 * COERCE_FLOAT(_XMM6 ^ 0x80000000))
                - (float)(COERCE_FLOAT(LODWORD(v69) ^ 0x80000000) * *((float *)&v131 + 1)))
        + (float)(*((float *)&v129 + 1) * *(float *)&v131);
    v99 = (float)((float)(v96 * *(float *)&v131) - (float)(*(float *)v132 * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000)))
        + (float)(*((float *)&v129 + 1) * *((float *)&v131 + 1));
    v100 = (float)((float)(*((float *)&v131 + 1) * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000))
                 - (float)(*(float *)&v131 * COERCE_FLOAT(_XMM6 ^ 0x80000000)))
         + (float)(*((float *)&v129 + 1) * *(float *)v132);
    v101 = (float)(v99 * *(float *)&v129) - (float)(*(float *)&_XMM6 * v100);
    *((float *)&v131 + 1) = (float)((float)((float)(v31 * v100) - (float)(v98 * *(float *)&v129)) + *((float *)&v131 + 1))
                          + (float)((float)(v31 * v100) - (float)(v98 * *(float *)&v129));
    *(float *)v132 = (float)((float)((float)(v98 * v201) - (float)(v31 * v99)) + *(float *)v132)
                   + (float)((float)(v98 * v201) - (float)(v31 * v99));
    v102 = (float)((float)(*(float *)&v134 * v95) - (float)(v96 * *((float *)&v133 + 1)))
         + (float)(*((float *)&v129 + 1) * *(float *)&v133);
    v103 = (float)((float)(v96 * *(float *)&v133) - (float)(*(float *)&v134 * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000)))
         + (float)(*((float *)&v129 + 1) * *((float *)&v133 + 1));
    *(float *)&v131 = (float)(v101 + *(float *)&v131) + v101;
    v104 = (float)((float)(*((float *)&v133 + 1) * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000))
                 - (float)(*(float *)&v133 * v95))
         + (float)(*((float *)&v129 + 1) * *(float *)&v134);
    *(float *)&v134 = (float)((float)((float)(v102 * v201) - (float)(v103 * v31)) + *(float *)&v134)
                    + (float)((float)(v102 * v201) - (float)(v103 * v31));
    *(float *)&v133 = (float)((float)((float)(v103 * *(float *)&v129) - (float)(v104 * v201)) + *(float *)&v133)
                    + (float)((float)(v103 * *(float *)&v129) - (float)(v104 * v201));
    *((float *)&v133 + 1) = (float)((float)((float)(v104 * v31) - (float)(v102 * *(float *)&v129))
                                  + *((float *)&v133 + 1))
                          + (float)((float)(v104 * v31) - (float)(v102 * *(float *)&v129));
    v105 = (float)((float)(v148 * v95) - (float)(v96 * *((float *)&v147 + 1)))
         + (float)(*((float *)&v129 + 1) * *(float *)&v147);
    v106 = (float)((float)(v96 * *(float *)&v147) - (float)(v148 * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000)))
         + (float)(*((float *)&v129 + 1) * *((float *)&v147 + 1));
    v107 = (float)((float)(*((float *)&v147 + 1) * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000))
                 - (float)(*(float *)&v147 * v95))
         + (float)(*((float *)&v129 + 1) * v148);
    v108 = (float)(v106 * *(float *)&v129) - (float)(v107 * v201);
    *((float *)&v147 + 1) = (float)((float)((float)(v107 * v31) - (float)(v105 * *(float *)&v129))
                                  + *((float *)&v147 + 1))
                          + (float)((float)(v107 * v31) - (float)(v105 * *(float *)&v129));
    v148 = (float)((float)((float)(v105 * v201) - (float)(v106 * v31)) + v148)
         + (float)((float)(v105 * v201) - (float)(v106 * v31));
    v109 = (float)((float)(v145 * v95) - (float)(v96 * *((float *)&v144 + 1)))
         + (float)(*((float *)&v129 + 1) * *(float *)&v144);
    v110 = v201;
    v111 = *(float *)&v144 * v95;
    v112 = *(float *)&v129;
    v113 = (float)((float)(v96 * *(float *)&v144) - (float)(v145 * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000)))
         + (float)(*((float *)&v129 + 1) * *((float *)&v144 + 1));
    *(float *)&v147 = (float)(v108 + *(float *)&v147) + v108;
    v114 = (float)((float)(*((float *)&v144 + 1) * COERCE_FLOAT(LODWORD(v31) ^ 0x80000000)) - v111)
         + (float)(*((float *)&v129 + 1) * v145);
    v145 = (float)(v145 + (float)((float)(v201 * v109) - (float)(v113 * v31)))
         + (float)((float)(v201 * v109) - (float)(v113 * v31));
    *(float *)&v144 = (float)(*(float *)&v144 + (float)((float)(v113 * *(float *)&v129) - (float)(v114 * v201)))
                    + (float)((float)(v113 * *(float *)&v129) - (float)(v114 * v201));
    *((float *)&v144 + 1) = (float)(*((float *)&v144 + 1)
                                  + (float)((float)(v114 * v31) - (float)(*(float *)&v129 * v109)))
                          + (float)((float)(v114 * v31) - (float)(*(float *)&v129 * v109));
    if ( a5 )
    {
      v115 = sub_1431F9210((__int64)v194, (__int64)&v130, (__int64)&v132[1]);
      v137 = *(float *)v115;
      v138 = *(float *)(v115 + 4);
      v139 = *(float *)(v115 + 8);
      v140 = *(float *)(v115 + 0xC);
      v141 = *(_QWORD *)(v115 + 0x10);
      v142 = *(float *)(v115 + 0x18);
      v116 = sub_1431F9210((__int64)v194, (__int64)&v146, (__int64)&v143);
    }
    else
    {
      v117 = sub_1431F9340((__int64)v194, (__int64)&v130, (__int64)&v132[1]);
      v137 = *(float *)v117;
      v138 = *(float *)(v117 + 4);
      v139 = *(float *)(v117 + 8);
      v140 = *(float *)(v117 + 0xC);
      v141 = *(_QWORD *)(v117 + 0x10);
      v142 = *(float *)(v117 + 0x18);
      v116 = sub_1431F9340((__int64)v194, (__int64)&v146, (__int64)&v143);
    }
    v202 = *(float *)v116;
    LODWORD(v135) = *(_DWORD *)(v116 + 4);
    v129 = *(_QWORD *)(v116 + 8);
    v150 = *(_QWORD *)(v116 + 0x10);
    v118 = *(float *)(v116 + 0x18);
    v119 = (float)((float)(v110 * v142) - (float)(v112 * *((float *)&v141 + 1))) + (float)(v97 * *(float *)&v141);
    v120 = (float)((float)(v112 * *(float *)&v141) - (float)(v31 * v142)) + (float)(v97 * *((float *)&v141 + 1));
    v121 = (float)((float)(v31 * *((float *)&v141 + 1)) - (float)(v110 * *(float *)&v141)) + (float)(v97 * v142);
    v142 = (float)(v142 + (float)((float)(v120 * v31) - (float)(v119 * v110)))
         + (float)((float)(v120 * v31) - (float)(v119 * v110));
    *((float *)&v141 + 1) = (float)(*((float *)&v141 + 1) + (float)((float)(v119 * v112) - (float)(v121 * v31)))
                          + (float)((float)(v119 * v112) - (float)(v121 * v31));
    v122 = (float)(v140 * *((float *)&v129 + 1))
         - (float)((float)((float)(v138 * *(float *)&v135) + (float)(v137 * v202)) + (float)(v139 * *(float *)&v129));
    *(float *)&v141 = (float)(*(float *)&v141 + (float)((float)(v121 * v110) - (float)(v120 * v112)))
                    + (float)((float)(v121 * v110) - (float)(v120 * v112));
    v123 = (float)((float)((float)(v138 * *(float *)&v129) - (float)(v139 * *(float *)&v135)) + (float)(v140 * v202))
         + (float)(v137 * *((float *)&v129 + 1));
    v124 = (float)((float)((float)(v139 * v202) - (float)(v137 * *(float *)&v129)) + (float)(v140 * *(float *)&v135))
         + (float)(v138 * *((float *)&v129 + 1));
    _Al__204 = Al__204;
    v139 = (float)((float)((float)(v137 * *(float *)&v135) - (float)(v138 * v202)) + (float)(v140 * *(float *)&v129))
         + (float)(v139 * *((float *)&v129 + 1));
    v138 = v124;
    v140 = v122;
    v125 = (float)((float)(v110 * v118) - (float)(v112 * *((float *)&v150 + 1))) + (float)(v97 * *(float *)&v150);
    v126 = (float)((float)(v112 * *(float *)&v150) - (float)(v31 * v118)) + (float)(v97 * *((float *)&v150 + 1));
    v127 = (float)((float)(v31 * *((float *)&v150 + 1)) - (float)(v110 * *(float *)&v150)) + (float)(v97 * v118);
    v137 = v123;
    v151 = (float)(v118 + (float)((float)(v126 * v31) - (float)(v125 * v110)))
         + (float)((float)(v126 * v31) - (float)(v125 * v110));
    *(float *)&v150 = (float)(*(float *)&v150 + (float)((float)(v127 * v110) - (float)(v126 * v112)))
                    + (float)((float)(v127 * v110) - (float)(v126 * v112));
    *((float *)&v150 + 1) = (float)(*((float *)&v150 + 1) + (float)((float)(v125 * v112) - (float)(v127 * v31)))
                          + (float)((float)(v125 * v112) - (float)(v127 * v31));
    sub_1457BF580(a2, &v137, &v150);
    v156 = __rdtsc();
    qword_149B4B878(&n0x4300);
  }
  return a2;
}

// --- End Function: sub_14322F600 (0x14322F600) ---

// --- Function: sub_143235DB0 (0x143235DB0) ---
__int64 __fastcall sub_143235DB0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax
  int v4; // eax
  int v5; // r8d
  unsigned __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v2 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v2 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v2 + 0x3B8LL))(v2, &v6);
  result = v6;
  if ( v6 && (result = HIWORD(v6), *(_QWORD *)((v6 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v6)) )
  {
    v4 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v6 & 0xFFFFFFFFFFFFLL) + 8LL))(v6 & 0xFFFFFFFFFFFFLL);
    v5 = *(_DWORD *)(a1 + 0x2F4);
    *(_DWORD *)(a1 + 0x300) = v4;
    return sub_1431D2330(a1, 0, v5);
  }
  else
  {
    *(_DWORD *)(a1 + 0x300) = 0;
  }
  return result;
}

// --- End Function: sub_143235DB0 (0x143235DB0) ---

// --- Function: sub_143239C60 (0x143239C60) ---
__int64 __fastcall sub_143239C60(unsigned __int8 *a1, __int64 a2, double *a3, __int64 a4, __int64 a5)
{
  float v5; // xmm4_4
  float v8; // xmm8_4
  float v10; // xmm10_4
  float v16; // xmm6_4
  float v17; // xmm5_4
  float v18; // xmm4_4
  __int128 v19; // kr00_16
  __int128 v20; // xmm12
  __int128 v21; // kr00_16
  __int128 v26; // xmm1
  __int128 v27; // kr00_16
  __int128 v28; // xmm14
  __int128 v30; // kr00_16
  __int128 v34; // xmm10
  __int128 v35; // kr00_16
  double v39; // xmm4_8
  double v40; // xmm6_8
  double v41; // xmm4_8
  double v42; // xmm5_8
  double v43; // xmm4_8
  unsigned int v51; // [rsp+B0h] [rbp+8h]

  *(_DWORD *)(a2 + 0xC) = *(_DWORD *)(a4 + 0xC);
  *(_DWORD *)a2 = *(_DWORD *)a4;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a4 + 8);
  *(double *)(a2 + 0x10) = *(double *)(a4 + 0x10);
  *(_DWORD *)(a2 + 0x18) = *(_DWORD *)(a4 + 0x18);
  if ( *((_WORD *)a1 + 0x88) )
  {
    v5 = *(float *)(a5 + 0x18);
    _XMM0 = *(unsigned __int64 *)a3 ^ (unsigned __int128)0x8000000000000000uLL;
    _XMM1 = *((unsigned __int64 *)a3 + 1) ^ (unsigned __int128)0x8000000000000000uLL;
    v8 = *(float *)(a5 + 0x14);
    _XMM9 = *((unsigned __int64 *)a3 + 3);
    v10 = *(float *)(a5 + 0x10);
    __asm { vcvtpd2ps xmm9, xmm9 }
    __asm { vcvtsd2ss xmm14, xmm1, xmm1 }
    __asm { vcvtsd2ss xmm15, xmm0, xmm0 }
    _XMM0 = *((unsigned __int64 *)a3 + 2) ^ (unsigned __int128)0x8000000000000000uLL;
    __asm { vcvtsd2ss xmm7, xmm0, xmm0 }
    v16 = (float)((float)(v5 * *(float *)&_XMM14) - (float)(v8 * *(float *)&_XMM7)) + (float)(v10 * *(float *)&_XMM9);
    v17 = (float)((float)(v10 * *(float *)&_XMM7) - (float)(v5 * *(float *)&_XMM15)) + (float)(v8 * *(float *)&_XMM9);
    v18 = (float)((float)(v8 * *(float *)&_XMM15) - (float)(v10 * *(float *)&_XMM14)) + (float)(v5 * *(float *)&_XMM9);
    *(float *)&v51 = (float)(*(float *)&_XMM14 * v18) - (float)(*(float *)&_XMM7 * v17);
    v19 = _XMM7;
    *(float *)&v19 = (float)(*(float *)&_XMM7 * v16) - (float)(*(float *)&_XMM15 * v18);
    v20 = v19;
    v21 = _XMM15;
    *(float *)&v21 = (float)((float)((float)(*(float *)&_XMM15 * v17) - (float)(*(float *)&_XMM14 * v16))
                           + *(float *)(a5 + 0x18))
                   + (float)((float)(*(float *)&_XMM15 * v17) - (float)(*(float *)&_XMM14 * v16));
    _XMM3 = v21;
    _XMM0 = a1[0x111];
    __asm
    {
      vpcmpeqd xmm1, xmm0, xmm1
      vblendvps xmm2, xmm3, xmm4, xmm1
    }
    v27 = v20;
    *(float *)&v27 = *(float *)&v20 + v8;
    v26 = v27;
    *((_QWORD *)&v27 + 1) = *((_QWORD *)&_XMM2 + 1);
    *(double *)&v27 = *(float *)&_XMM2;
    v28 = v27;
    v30 = v26;
    *(float *)&v30 = *(float *)&v26 + *(float *)&v20;
    _XMM3 = v30;
    *(double *)&v20 = a3[1];
    _XMM0 = a1[0x110];
    __asm
    {
      vpcmpeqd xmm1, xmm0, xmm2
      vblendvps xmm2, xmm3, xmm4, xmm1
    }
    *((_QWORD *)&v30 + 1) = *((_QWORD *)&_XMM2 + 1);
    *(double *)&v30 = *(float *)&_XMM2;
    v34 = v30;
    *(double *)&_XMM9 = a3[2];
    v35 = v51;
    *(float *)&v35 = (float)(*(float *)&v51 + *(float *)(a5 + 0x10)) + *(float *)&v51;
    _XMM3 = v35;
    __asm
    {
      vpcmpeqd xmm1, xmm0, xmm2
      vblendvps xmm2, xmm3, xmm4, xmm1
    }
    v39 = a3[3];
    *((_QWORD *)&v35 + 1) = *((_QWORD *)&_XMM2 + 1);
    *(double *)&_XMM7 = *(double *)&v28 * *(double *)&v20 - *(double *)&v34 * *(double *)&_XMM9 + *(float *)&_XMM2 * v39;
    v40 = *(float *)&_XMM2 * *(double *)&_XMM9 - *(double *)&v28 * *a3 + *(double *)&v34 * v39;
    v41 = *(double *)&v34 * *a3 - *(float *)&_XMM2 * *(double *)&v20 + *(double *)&v28 * v39;
    v42 = v41 * *(double *)&v20 - *(double *)&_XMM9 * v40;
    v43 = *(double *)&_XMM9 * *(double *)&_XMM7 - v41 * *a3;
    *(double *)&v35 = *(float *)&_XMM2 + v42 + v42;
    _XMM2 = v35;
    *(double *)&_XMM3 = v40 * *a3 - *(double *)&_XMM7 * *(double *)&v20;
    __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
    *(float *)(a2 + 0x10) = *(float *)&_XMM0;
    *((_QWORD *)&v35 + 1) = *((_QWORD *)&v34 + 1);
    *(double *)&v35 = *(double *)&v34 + v43 + v43;
    _XMM2 = v35;
    __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
    *(float *)(a2 + 0x14) = *(float *)&_XMM0;
    *((_QWORD *)&v35 + 1) = *((_QWORD *)&v28 + 1);
    *(double *)&v35 = *(double *)&v28 + *(double *)&_XMM3 + *(double *)&_XMM3;
    _XMM2 = v35;
    __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
    *(float *)(a2 + 0x18) = *(float *)&_XMM0;
  }
  if ( a1[0x112] )
  {
    *(_DWORD *)a2 = *(_DWORD *)a5;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a5 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a5 + 8);
    *(_DWORD *)(a2 + 0xC) = *(_DWORD *)(a5 + 0xC);
  }
  return a2;
}

// --- End Function: sub_143239C60 (0x143239C60) ---

// --- Function: sub_14325E580 (0x14325E580) ---
void __fastcall sub_14325E580(__int64 a1, unsigned __int64 *a2, __int64 a3, float *a4)
{
  __int128 v4; // xmm13
  __int16 v8; // ax
  float *v9; // r13
  float v10; // xmm13_4
  float v11; // xmm1_4
  __int128 n0x3F800000; // kr00_16
  __int128 n0x3F800000_1; // xmm2
  __int64 v15; // rcx
  float *v16; // r12
  __int64 v17; // rax
  __m128 v18; // xmm2
  float v19; // xmm3_4
  double v20; // xmm8_8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int128 v24; // kr00_16
  double v25; // xmm11_8
  double v26; // xmm12_8
  double v27; // xmm9_8
  __int64 v29; // rcx
  __int64 v30; // rcx
  int *p_n0x22; // rdx
  __m128 v32; // xmm1
  float v33; // xmm14_4
  char v34; // r14
  float v35; // xmm9_4
  float v36; // xmm8_4
  float v37; // xmm6_4
  bool v38; // zf
  int v39; // eax
  double v44; // xmm8_8
  double v45; // xmm7_8
  double v46; // kr00_8
  double v47; // xmm5_8
  float v56; // xmm7_4
  __m128 v57; // xmm6
  char v58; // si
  __m128 v59; // kr00_16
  float v62; // xmm2_4
  __int128 n0x3FC00000; // kr00_16
  __int128 n0x3FC00000_1; // xmm1
  __int128 n0x3FC00000_2; // xmm2
  float v66; // xmm0_4
  __int128 n0x3FC00000_4; // xmm6
  float v68; // xmm4_4
  __int128 n0x3FC00000_3; // kr00_16
  double v74; // xmm11_8
  double v75; // xmm12_8
  double v76; // xmm13_8
  __int128 n0x3FC00000_5; // xmm1
  __int128 v78; // xmm8
  __int128 v79; // kr00_16
  double v80; // xmm5_8
  double v85; // xmm7_8
  bool v90; // cf
  __int128 n0x3FC00000_6; // kr00_16
  __int128 n0x3FC00000_7; // xmm0
  double v94; // xmm7_8
  __int128 v95; // kr00_16
  __int64 *v104; // rcx
  __int64 v105; // rax
  __int64 v106; // rax
  __int64 v107; // rax
  __int64 v108; // rcx
  int v109; // eax
  int v110; // [rsp+20h] [rbp-E0h]
  int v111; // [rsp+20h] [rbp-E0h]
  float v112; // [rsp+30h] [rbp-D0h]
  float v113; // [rsp+34h] [rbp-CCh]
  int n0x4300_1; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v115; // [rsp+44h] [rbp-BCh]
  int v116; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v117; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v118; // [rsp+58h] [rbp-A8h]
  __int64 v119; // [rsp+60h] [rbp-A0h]
  __int64 v120; // [rsp+68h] [rbp-98h]
  _DWORD v121[4]; // [rsp+90h] [rbp-70h] BYREF
  float v122; // [rsp+A0h] [rbp-60h]
  float v123; // [rsp+A4h] [rbp-5Ch]
  float v124; // [rsp+A8h] [rbp-58h]
  float v125; // [rsp+ACh] [rbp-54h]
  int v126; // [rsp+B0h] [rbp-50h]
  float v127; // [rsp+B4h] [rbp-4Ch]
  __int64 v128; // [rsp+B8h] [rbp-48h] BYREF
  _DWORD v129[10]; // [rsp+C0h] [rbp-40h] BYREF
  unsigned __int64 v130; // [rsp+E8h] [rbp-18h]
  double v131; // [rsp+F0h] [rbp-10h]
  double v132; // [rsp+F8h] [rbp-8h]
  int n0x22; // [rsp+100h] [rbp+0h] BYREF
  __int64 v134; // [rsp+104h] [rbp+4h]
  int v135; // [rsp+10Ch] [rbp+Ch]
  int n0x4300; // [rsp+110h] [rbp+10h] BYREF
  __int64 v137; // [rsp+114h] [rbp+14h]
  int v138; // [rsp+11Ch] [rbp+1Ch]
  unsigned __int64 v139; // [rsp+120h] [rbp+20h]
  unsigned __int64 v140; // [rsp+128h] [rbp+28h]
  __int64 v141; // [rsp+130h] [rbp+30h]
  __int64 v142; // [rsp+138h] [rbp+38h]
  double v143; // [rsp+160h] [rbp+60h]
  double v144[5]; // [rsp+178h] [rbp+78h] BYREF
  double v145; // [rsp+1A0h] [rbp+A0h] BYREF
  double v146; // [rsp+1A8h] [rbp+A8h]
  double v147; // [rsp+1B0h] [rbp+B0h]
  double v148; // [rsp+1B8h] [rbp+B8h]
  double v149; // [rsp+1C0h] [rbp+C0h]
  double v150; // [rsp+1D0h] [rbp+D0h]
  double v151[4]; // [rsp+1E0h] [rbp+E0h] BYREF
  __int128 v152; // [rsp+200h] [rbp+100h]
  double v153; // [rsp+210h] [rbp+110h]
  double v154; // [rsp+218h] [rbp+118h]
  _DWORD v155[28]; // [rsp+220h] [rbp+120h] BYREF
  __int64 v156; // [rsp+290h] [rbp+190h]
  __int128 v157; // [rsp+2D0h] [rbp+1D0h]
  char v158; // [rsp+390h] [rbp+290h]
  float v159; // [rsp+390h] [rbp+290h]
  float v160; // [rsp+390h] [rbp+290h]
  float v162; // [rsp+3A0h] [rbp+2A0h]

  v157 = v4;
  v137 = 0;
  v138 = 0;
  v140 = 0;
  v141 = 0;
  v142 = 0;
  n0x4300 = 0x4300;
  v139 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20A9C,
    "CAnimatedCharacter::RequestPhysicalEntityMovement",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
    0x21F);
  v8 = word_149E20A9C;
  v9 = (float *)(a1 + 0x198);
  v10 = 1.0;
  n0x3F800000 = 0x3F800000u;
  v11 = 1.0 / *(float *)(a1 + 0x198);
  *(float *)&n0x3F800000 = v11 * *(float *)(a3 + 0x10);
  n0x3F800000_1 = n0x3F800000;
  *(float *)&n0x3F800000 = v11 * *(float *)(a3 + 0x18);
  __asm { vunpcklps xmm0, xmm2, xmm0 }
  *(double *)(a1 + 0x28C) = *(double *)&_XMM0;
  HIWORD(n0x4300) = v8;
  *(float *)(a1 + 0x294) = *(float *)&n0x3F800000;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v15 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v15 = 0;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v15 + 0x3B8LL))(v15, &v128);
  v16 = (float *)(a3 + 0x10);
  if ( !AssetMeta::HasActorSubresource((__int64 *)(a1 + 0x3E0))
    || (v17 = sub_14030ECF0((_QWORD *)(a1 + 0x3E0)),
        v9 = (float *)(a1 + 0x198),
        v158 = 1,
        v16 = (float *)(a3 + 0x10),
        !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x750LL))(v17)) )
  {
    v158 = 0;
  }
  if ( (unsigned __int8)sub_1457D7070(a1) && (*(_DWORD *)(a1 + 0x2F4) == 1 || v158) )
  {
    n0x4300_1 = 0x4300;
    v115 = 0;
    v116 = 0;
    v118 = 0;
    v119 = 0;
    v120 = 0;
    v117 = __rdtsc();
    qword_149B4B870(
      &n0x4300_1,
      &word_149E20AA0,
      "CAnimatedCharacter::RequestPhysicalEntityMovement_Attached",
      "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
      0x22D);
    HIWORD(n0x4300_1) = word_149E20AA0;
    if ( !*(_BYTE *)(a1 + 0x340)
      && *(_DWORD *)(a1 + 0x2B4) == 2
      && (COERCE_FLOAT(*(_DWORD *)(a3 + 0x10) & 0x7FFFFFFF) > 0.00000011920929
       || COERCE_FLOAT(*(_DWORD *)(a3 + 0x14) & 0x7FFFFFFF) > 0.00000011920929
       || COERCE_FLOAT(*(_DWORD *)(a3 + 0x18) & 0x7FFFFFFF) > 0.00000011920929
       || fabs(
            1.0
          - (float)((float)((float)(*(float *)(a3 + 8) * *(float *)(a3 + 8))
                          + (float)(*(float *)(a3 + 4) * *(float *)(a3 + 4)))
                  + (float)((float)(*(float *)a3 * *(float *)a3) + (float)(*(float *)(a3 + 0xC) * *(float *)(a3 + 0xC))))) >= 0.001) )
    {
      v18 = (__m128)*(unsigned __int64 *)(a3 + 0x10);
      v19 = *(float *)(a1 + 0x190) / *(float *)(a1 + 0x198);
      _mm_shuffle_ps(v18, v18, 0x55);
      v20 = (float)(*(float *)(a3 + 0x18) * v19);
      if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
        v22 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v22 = 0;
      LOBYTE(v21) = 1;
      LOBYTE(v110) = 0;
      (*(void (__fastcall **)(__int64, double *, __int64, __int64, int))(*(_QWORD *)v22 + 0x1B8LL))(
        v22,
        &v145,
        2,
        v21,
        v110);
      *((_QWORD *)&v24 + 1) = 0;
      *(double *)&v24 = (float)(v18.m128_f32[0] * v19) + v149;
      _XMM14 = v24;
      v25 = *(float *)(a3 + 4);
      v26 = *(float *)(a3 + 8);
      v27 = *(float *)a3;
      *(double *)&v24 = *(float *)(a3 + 0xC);
      v151[0] = v146 * v26 - v25 * v147 + v148 * v27 + v145 * *(double *)&v24;
      v151[1] = v27 * v147 - v145 * v26 + v148 * v25 + v146 * *(double *)&v24;
      v151[2] = v145 * v25 - v146 * v27 + v148 * v26 + *(double *)&v24 * v147;
      v151[3] = v148 * *(double *)&v24 - (v145 * v27 + v146 * v25 + v26 * v147);
      __asm { vunpcklpd xmm1, xmm14, xmm13 }
      v154 = 1.0;
      v152 = _XMM1;
      v153 = v20 + v150;
      if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
        v29 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v29 = 0;
      LOBYTE(v111) = 0;
      (*(void (__fastcall **)(__int64, double *, __int64, __int64, int, _QWORD))(*(_QWORD *)v29 + 0x1D8LL))(
        v29,
        v151,
        2,
        0x80020006LL,
        v111,
        0);
    }
    v156 = 0;
    v155[0] = 2;
    if ( !(*(unsigned int (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)(v128 & 0xFFFFFFFFFFFFLL) + 0x28LL))(
            v128 & 0xFFFFFFFFFFFFLL,
            v155)
      || *(float *)&v155[8] == 0.0
      && *(float *)&v155[9] == 0.0
      && *(float *)&v155[0xA] == 0.0
      && *(float *)&v155[2] == 0.0
      && *(float *)&v155[3] == 0.0
      && *(float *)&v155[4] == 0.0 )
    {
      goto LABEL_69;
    }
    v129[0] = 8;
    *(float *)&v129[5] = 0.0;
    *(float *)&v129[4] = 0.0;
    *(float *)&v129[3] = 0.0;
    *(float *)&v129[8] = 0.0;
    *(float *)&v129[7] = 0.0;
    *(float *)&v129[6] = 0.0;
    v129[1] = 0x80000000;
    v129[2] = 0x80000000;
    v129[9] = 0;
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    {
      p_n0x22 = v129;
      v30 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      v30 = 0;
      p_n0x22 = v129;
    }
    goto LABEL_68;
  }
  if ( !*(_BYTE *)(a1 + 0x340) )
  {
    n0x4300_1 = 0x4300;
    v115 = 0;
    v116 = 0;
    v118 = 0;
    v119 = 0;
    v120 = 0;
    v117 = __rdtsc();
    qword_149B4B870(
      &n0x4300_1,
      &word_149E20AA4,
      "CAnimatedCharacter::RequestPhysicalEntityMovement_Absolute",
      "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
      0x24C);
    v32 = (__m128)*(unsigned __int64 *)v16;
    v33 = *v9;
    v34 = 0;
    v35 = (float)(1.0 / *v9) * v16[2];
    v36 = _mm_shuffle_ps(v32, v32, 0x55).m128_f32[0] * (float)(1.0 / *v9);
    v143 = *(double *)v16;
    v37 = (float)((float)(v36 * 7.0) + (float)((float)(v32.m128_f32[0] * (float)(1.0 / v33)) * 5.0))
        + (float)(v35 * 3.0);
    v38 = v37 == *(float *)(a1 + 0x3BC);
    v127 = 0.0;
    HIWORD(n0x4300_1) = word_149E20AA4;
    v121[0] = 0;
    v126 = 0;
    v122 = NAN;
    v123 = NAN;
    if ( !v38
      || *(_DWORD *)(a1 + 0x320)
      || (float)((float)((float)((float)(7.0 * *(float *)(a1 + 0x284)) + (float)(5.0 * *(float *)(a1 + 0x280)))
                       + (float)(3.0 * *(float *)(a1 + 0x288)))
               * (float)(1.0 / v33)) != v37 )
    {
      v39 = *(_DWORD *)(a1 + 0x320);
      v34 = 1;
      v127 = *(float *)(a1 + 0x190);
      v123 = v32.m128_f32[0] * (float)(1.0 / v33);
      v124 = v36;
      v125 = v35;
      *(float *)(a1 + 0x3BC) = v37;
      v126 = v39;
      *(_BYTE *)(a1 + 0x3C0) = v39;
    }
    _XMM10 = a2[1];
    _XMM11 = *a2;
    _XMM12 = a2[2];
    _XMM9 = a2[3];
    v44 = *(float *)(a3 + 0xC);
    v45 = *(float *)(a3 + 4);
    v46 = *(float *)a3;
    v47 = *(float *)(a3 + 8);
    _XMM0 = COERCE_UNSIGNED_INT64(*(double *)&_XMM9 * v44 - (*(double *)&_XMM11 * v46
                                                           + *(double *)&_XMM10 * v45
                                                           + *(double *)&_XMM12 * v47));
    __asm { vcvtsd2ss xmm4, xmm0, xmm0 }
    v162 = *(float *)&_XMM4;
    _XMM2 = COERCE_UNSIGNED_INT64(v47 * *(double *)&_XMM10 - *(double *)&_XMM12 * v45 + v46 * *(double *)&_XMM9 + *(double *)&_XMM11 * v44);
    __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
    _XMM2 = COERCE_UNSIGNED_INT64(*(double *)&_XMM12 * v46 - v47 * *(double *)&_XMM11 + v45 * *(double *)&_XMM9 + *(double *)&_XMM10 * v44);
    __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
    _XMM2 = COERCE_UNSIGNED_INT64(*(double *)&_XMM11 * v45 - v46 * *(double *)&_XMM10 + v47 * *(double *)&_XMM9 + *(double *)&_XMM12 * v44);
    __asm { vcvtsd2ss xmm8, xmm2, xmm2 }
    v130 = a2[3];
    v131 = *(double *)&_XMM10;
    v132 = *(double *)&_XMM11;
    v143 = *(double *)&_XMM12;
    v159 = *(float *)&_XMM4;
    if ( *(_BYTE *)(a1 + 0x1D4) )
    {
      LODWORD(_XMM4) = *(_DWORD *)(a1 + 0x1DC);
      v56 = *(float *)(a1 + 0x1D8);
      LODWORD(_XMM8) = *(_DWORD *)(a1 + 0x1E0);
      v57 = (__m128)*(unsigned int *)(a1 + 0x1E4);
      v159 = *(float *)&_XMM4;
    }
    else
    {
      v57 = (__m128)LODWORD(v162);
      v56 = *(float *)&_XMM0;
    }
    v58 = *(_BYTE *)(a1 + 0x18D);
    v59 = v57;
    v59.m128_f32[0] = (float)((float)(v57.m128_f32[0] * v57.m128_f32[0]) + (float)(v56 * v56))
                    + (float)((float)(*(float *)&_XMM4 * *(float *)&_XMM4) + (float)(*(float *)&_XMM8 * *(float *)&_XMM8));
    _XMM3 = _mm_shuffle_ps(v59, v59, 0);
    __asm { vrsqrtps xmm5, xmm3 }
    _XMM5.m128_f32[0] = _mm_shuffle_ps(_XMM5, _XMM5, 0xFF).m128_f32[0];
    v62 = (float)((float)(v59.m128_f32[0] * _XMM5.m128_f32[0]) * _XMM5.m128_f32[0]) * 0.5;
    n0x3FC00000 = 0x3FC00000u;
    *(float *)&n0x3FC00000 = (float)(1.5 - v62) * _XMM5.m128_f32[0];
    n0x3FC00000_1 = n0x3FC00000;
    *(float *)&n0x3FC00000 = *(float *)&n0x3FC00000 * v159;
    n0x3FC00000_2 = n0x3FC00000;
    v66 = *(float *)&n0x3FC00000_1 * v56;
    n0x3FC00000_3 = n0x3FC00000_1;
    *(float *)&n0x3FC00000_3 = *(float *)&n0x3FC00000_1 * v57.m128_f32[0];
    n0x3FC00000_4 = n0x3FC00000_3;
    *((_QWORD *)&n0x3FC00000_3 + 1) = *((_QWORD *)&n0x3FC00000_1 + 1);
    *(float *)&n0x3FC00000_3 = *(float *)&n0x3FC00000_1 * *(float *)&_XMM8;
    v68 = *(float *)&n0x3FC00000_1 * *(float *)&_XMM8;
    v112 = *(float *)&n0x3FC00000_1 * v56;
    v160 = *(float *)&n0x3FC00000_2;
    v113 = *(float *)&n0x3FC00000_1 * *(float *)&_XMM8;
    __asm
    {
      vcvtsd2ss xmm5, xmm9, xmm9
      vcvtsd2ss xmm3, xmm11, xmm11
      vcvtsd2ss xmm1, xmm10, xmm10
      vcvtsd2ss xmm7, xmm12, xmm12
    }
    if ( v58 )
    {
      v74 = *(float *)&_XMM1;
      v75 = *(float *)&_XMM3;
      v76 = *(float *)&n0x3FC00000_2;
      *(double *)&n0x3FC00000_3 = *(float *)&n0x3FC00000_3 * *(float *)&n0x3FC00000_3;
      n0x3FC00000_5 = n0x3FC00000_3;
      *((_QWORD *)&v79 + 1) = *((_QWORD *)&_XMM7 + 1);
      *(double *)&v79 = *(float *)&_XMM7;
      v78 = v79;
      v80 = *(float *)&_XMM5;
      *((_QWORD *)&v79 + 1) = *((_QWORD *)&n0x3FC00000_5 + 1);
      *(double *)&v79 = *(double *)&n0x3FC00000_5
                      + v76 * v76
                      + v66 * v66
                      + *(float *)&n0x3FC00000_4 * *(float *)&n0x3FC00000_4;
      _XMM2 = v79;
      __asm
      {
        vmovddup xmm3, xmm2
        vsqrtpd xmm1, xmm3
        vunpckhpd xmm1, xmm1, xmm1
      }
      v85 = 1.0 / *(double *)&_XMM1;
      *((_QWORD *)&v79 + 1) = *((_QWORD *)&v78 + 1);
      *(double *)&v79 = *(double *)&v78 * *(double *)&v78 + v74 * v74 + v75 * v75 + v80 * v80;
      _XMM2 = v79;
      __asm
      {
        vmovddup xmm3, xmm2
        vsqrtpd xmm1, xmm3
        vunpckhpd xmm1, xmm1, xmm1
      }
      *(_QWORD *)&_XMM9 = v130;
      *(double *)&_XMM10 = v131;
      *(double *)&_XMM2 = v75 * (1.0 / *(double *)&_XMM1);
      *(double *)&_XMM12 = v143;
      *(double *)&v79 = v74 * (1.0 / *(double *)&_XMM1);
      _XMM11 = *(unsigned __int64 *)&v132;
      n0x3FC00000_4 = (unsigned int)n0x3FC00000_4;
      v90 = v80 * (1.0 / *(double *)&_XMM1) * (v85 * *(float *)&n0x3FC00000_4)
          + *(double *)&v78 * (1.0 / *(double *)&_XMM1) * (v85 * v68)
          + *(double *)&v79 * (v85 * v76)
          + *(double *)&_XMM2 * (v85 * v66) < *(double *)&qword_1499E5360;
    }
    else
    {
      if ( v33 > 0.0 )
        v10 = v33 * 30.0;
      n0x3FC00000_6 = n0x3FC00000_2;
      *(float *)&n0x3FC00000_6 = (float)((float)(*(float *)&n0x3FC00000_2 * *(float *)&_XMM1)
                                       + (float)(v66 * *(float *)&_XMM3))
                               + (float)((float)(v68 * *(float *)&_XMM7)
                                       + (float)(*(float *)&n0x3FC00000_4 * *(float *)&_XMM5));
      *((_QWORD *)&n0x3FC00000_6 + 1) = (n0x3FC00000_6 & (unsigned __int128)xmmword_14819F760) >> 0x40;
      *(double *)&n0x3FC00000_6 = fabs(*(float *)&n0x3FC00000_6);
      n0x3FC00000_7 = n0x3FC00000_6;
      __asm { vminsd  xmm0, xmm0, cs:qword_1481A4C40; X }
      v90 = (float)(v10 * 0.001) < acos(*(double *)&_XMM0);
    }
    if ( v90 )
    {
      *((_QWORD *)&v95 + 1) = *((_QWORD *)&n0x3FC00000_4 + 1);
      v94 = *(float *)&n0x3FC00000_4;
      *(double *)&v95 = *(float *)&n0x3FC00000_4 * *(double *)&_XMM9
                      + v160 * *(double *)&_XMM10
                      + *(double *)&_XMM11 * v112
                      + v113 * *(double *)&_XMM12;
      _XMM2 = v95;
      __asm { vcvtsd2ss xmm6, xmm2, xmm2 }
      _XMM2 = COERCE_UNSIGNED_INT64(
                v160 * *(double *)&_XMM12
              - v113 * *(double *)&_XMM10
              + *(double *)&_XMM9 * v112
              - *(double *)&_XMM11 * v94);
      __asm { vcvtsd2ss xmm5, xmm2, xmm2 }
      *((_QWORD *)&v95 + 1) = *((_QWORD *)&_XMM11 + 1);
      *(double *)&v95 = *(double *)&_XMM11 * v113
                      - v112 * *(double *)&_XMM12
                      + *(double *)&_XMM9 * v160
                      - v94 * *(double *)&_XMM10;
      _XMM2 = v95;
      __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
      *((_QWORD *)&v95 + 1) = 0;
      *(double *)&v95 = v112 * *(double *)&_XMM10
                      - *(double *)&_XMM11 * v160
                      + *(double *)&_XMM9 * v113
                      - v94 * *(double *)&_XMM12;
      _XMM2 = v95;
      __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
      *(float *)&v121[3] = *(float *)&_XMM1;
      *(float *)&v121[1] = *(float *)&_XMM5;
      *(float *)&v121[2] = *(float *)&_XMM4;
      v122 = *(float *)&_XMM6;
      if ( v58 && !*(_BYTE *)(a1 + 0x342) )
      {
        if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
          v104 = (__int64 *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL);
        else
          v104 = 0;
        v105 = *v104;
        v144[3] = v94;
        v144[0] = v112;
        v144[1] = v160;
        v144[2] = v113;
        (*(void (__fastcall **)(__int64 *, double *, __int64, _QWORD))(v105 + 0x280))(v104, v144, 0x80022000LL, 0);
      }
    }
    else if ( !v34 )
    {
LABEL_61:
      if ( *a4 == 0.0 && a4[1] == 0.0 && a4[2] == 0.0 )
        goto LABEL_69;
      v109 = *((_DWORD *)a4 + 2);
      v134 = *(_QWORD *)a4;
      n0x22 = 0x22;
      v135 = v109;
      if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
        v30 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v30 = 0;
      p_n0x22 = &n0x22;
LABEL_68:
      (*(void (__fastcall **)(__int64, int *, _QWORD, _QWORD))(*(_QWORD *)v30 + 0x408LL))(v30, p_n0x22, 0, 0);
LABEL_69:
      v118 = __rdtsc();
      qword_149B4B878(&n0x4300_1);
      goto LABEL_70;
    }
    if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(v128 & 0xFFFFFFFFFFFFLL) + 8LL))(v128 & 0xFFFFFFFFFFFFLL) == 6 )
    {
      v106 = sub_1402A2660(a1 + 0x328);
      v107 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v106 + 0x30LL))(v106);
      if ( v107 )
        (*(void (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)v107 + 0x140LL))(v107, v121);
    }
    else
    {
      if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
        v108 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v108 = 0;
      (*(void (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(*(_QWORD *)v108 + 0x408LL))(v108, v121, 0, 0);
    }
    goto LABEL_61;
  }
LABEL_70:
  v140 = __rdtsc();
  qword_149B4B878(&n0x4300);
}

// --- End Function: sub_14325E580 (0x14325E580) ---

// --- Function: sub_143263870 (0x143263870) ---
__int64 __fastcall sub_143263870(__int64 a1, __int64 a2, __int64 a3, unsigned int n8)
{
  __int64 n8_1; // rdi
  unsigned __int64 v9; // r10
  void *v10; // rsp
  __int64 v11; // rax
  _DWORD *v12; // r10
  __int64 v13; // rsi
  _DWORD *v14; // r8
  __int64 v15; // rcx
  _QWORD v17[4]; // [rsp+30h] [rbp+0h] BYREF

  n8_1 = n8;
  v9 = 4LL * n8 + 0x13;
  if ( v9 <= 4 * (unsigned __int64)n8 + 4 )
    v9 = 0xFFFFFFFFFFFFFF0LL;
  v10 = alloca(v9 & 0xFFFFFFFFFFFFFFF0uLL);
  v11 = sub_140306140((__int64)v17, 4);
  v12 = (_DWORD *)v11;
  if ( n8 )
  {
    v13 = a3 - v11;
    v14 = (_DWORD *)v11;
    do
    {
      v15 = 0;
      *v14 = *(_DWORD *)((char *)v14 + v13);
      if ( *(_BYTE *)(a1 + 0x16C) )
      {
        while ( *(unsigned __int8 *)(a1 + v15 + 0x164) != *(_DWORD *)((char *)v14 + a2 - v11) )
        {
          if ( ++v15 >= *(unsigned __int8 *)(a1 + 0x16C) )
            goto LABEL_10;
        }
        *v12 = *(_DWORD *)(a1 + 4 * v15 + 0x144);
      }
LABEL_10:
      ++v14;
      ++v12;
      --n8_1;
    }
    while ( n8_1 );
  }
  return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _DWORD))(**(_QWORD **)(a1 + 0x330) + 0x120LL))(
           *(_QWORD *)(a1 + 0x330),
           a2,
           v11,
           n8,
           0);
}

// --- End Function: sub_143263870 (0x143263870) ---

// --- Function: sub_14326DBF0 (0x14326DBF0) ---
float __fastcall sub_14326DBF0(float *a1, float a2)
{
  float *v3; // [rsp+8h] [rbp-40h]
  float v4; // [rsp+10h] [rbp-38h]
  float v5; // [rsp+18h] [rbp-30h]
  float v6; // [rsp+1Ch] [rbp-2Ch]
  float v7; // [rsp+20h] [rbp-28h]
  float *v8; // [rsp+28h] [rbp-20h]

  v4 = a1[3];
  v3 = a1 + 2;
  v8 = a1 + 1;
  if ( v4 <= a2 )
  {
    if ( a2 <= 0.00000011920929 )
    {
      *v8 = *a1;
      *v3 = *v3 - *v3;
    }
    else
    {
      *v3 = (float)(*a1 - *v8) / a2;
      *v8 = *a1;
    }
  }
  else
  {
    v7 = 1.0
       / (float)((float)((float)((float)((float)(2.0 / v4) * a2) + 1.0)
                       + (float)((float)(0.47999999 * (float)((float)(2.0 / v4) * a2)) * (float)((float)(2.0 / v4) * a2)))
               + (float)((float)((float)(0.235 * (float)((float)(2.0 / v4) * a2)) * (float)((float)(2.0 / v4) * a2))
                       * (float)((float)(2.0 / v4) * a2)));
    v5 = *v8 - *a1;
    v6 = (float)(*v3 + (float)(v5 * (float)(2.0 / v4))) * a2;
    *v3 = (float)(*v3 - (float)(v6 * (float)(2.0 / v4))) * v7;
    *v8 = *a1 + (float)((float)(v5 + v6) * v7);
  }
  return a1[1];
}

// --- End Function: sub_14326DBF0 (0x14326DBF0) ---

// --- Function: sub_14326DDD0 (0x14326DDD0) ---
_QWORD *__fastcall sub_14326DDD0(float *a1, _QWORD *a2, float a3)
{
  float v4; // [rsp+34h] [rbp-134h]
  float *v5; // [rsp+38h] [rbp-130h]
  float v6; // [rsp+40h] [rbp-128h]
  float *v8; // [rsp+50h] [rbp-118h]
  __int64 v9; // [rsp+58h] [rbp-110h] BYREF
  float v10[2]; // [rsp+60h] [rbp-108h] BYREF
  float *v11; // [rsp+68h] [rbp-100h]
  float v12; // [rsp+70h] [rbp-F8h]
  float v13; // [rsp+78h] [rbp-F0h]
  float v14; // [rsp+80h] [rbp-E8h]
  float v15; // [rsp+88h] [rbp-E0h]
  float v16; // [rsp+90h] [rbp-D8h]
  float v17; // [rsp+98h] [rbp-D0h]
  float v18; // [rsp+A0h] [rbp-C8h]
  float v19; // [rsp+A8h] [rbp-C0h]
  float v20; // [rsp+B0h] [rbp-B8h]
  float v21; // [rsp+B8h] [rbp-B0h]
  float v22; // [rsp+C0h] [rbp-A8h]
  float v23; // [rsp+C8h] [rbp-A0h]
  float v24[2]; // [rsp+E0h] [rbp-88h] BYREF
  float v25[2]; // [rsp+E8h] [rbp-80h] BYREF
  float *v26; // [rsp+F0h] [rbp-78h]
  float v27[2]; // [rsp+F8h] [rbp-70h] BYREF
  float *v28; // [rsp+100h] [rbp-68h]
  __int64 v29; // [rsp+108h] [rbp-60h]
  float *v30; // [rsp+110h] [rbp-58h]
  float v31[2]; // [rsp+118h] [rbp-50h] BYREF
  __int64 *v32; // [rsp+120h] [rbp-48h]
  float v33; // [rsp+128h] [rbp-40h] BYREF
  float v34; // [rsp+130h] [rbp-38h] BYREF
  float v35; // [rsp+138h] [rbp-30h] BYREF
  float v36; // [rsp+140h] [rbp-28h] BYREF
  float v37; // [rsp+148h] [rbp-20h] BYREF
  float v38[6]; // [rsp+150h] [rbp-18h] BYREF

  v6 = a1[6];
  v5 = a1 + 4;
  v8 = a1 + 2;
  if ( v6 <= a3 )
  {
    if ( a3 <= 0.00000011920929 )
    {
      *(_QWORD *)v8 = *(_QWORD *)a1;
      *(_QWORD *)v5 = *(_QWORD *)sub_140306040(v38, v5, v5);
    }
    else
    {
      v11 = sub_140306040(&v37, a1, v8);
      v23 = v11[1] * (float)(1.0 / a3);
      v22 = *v11 * (float)(1.0 / a3);
      *(float *)&v9 = v22;
      *((float *)&v9 + 1) = v23;
      v32 = &v9;
      *(_QWORD *)v5 = v9;
      *(_QWORD *)v8 = *(_QWORD *)a1;
    }
  }
  else
  {
    v4 = 1.0
       / (float)((float)((float)((float)((float)(2.0 / v6) * a3) + 1.0)
                       + (float)((float)(0.47999999 * (float)((float)(2.0 / v6) * a3)) * (float)((float)(2.0 / v6) * a3)))
               + (float)((float)((float)(0.235 * (float)((float)(2.0 / v6) * a3)) * (float)((float)(2.0 / v6) * a3))
                       * (float)((float)(2.0 / v6) * a3)));
    sub_140306040(v24, v8, a1);
    v13 = v24[1] * (float)(2.0 / v6);
    v12 = v24[0] * (float)(2.0 / v6);
    v25[0] = v12;
    v25[1] = v13;
    v26 = sub_140306070(&v33, v5, v25);
    v15 = v26[1] * a3;
    v14 = *v26 * a3;
    v10[0] = v14;
    v10[1] = v15;
    v17 = v15 * (float)(2.0 / v6);
    v16 = v14 * (float)(2.0 / v6);
    v27[0] = v16;
    v27[1] = v17;
    v28 = sub_140306040(&v34, v5, v27);
    v19 = v28[1] * v4;
    v18 = *v28 * v4;
    *(float *)&v29 = v18;
    *((float *)&v29 + 1) = v19;
    *(_QWORD *)v5 = v29;
    v30 = sub_140306070(&v35, v24, v10);
    v21 = v30[1] * v4;
    v20 = *v30 * v4;
    v31[0] = v20;
    v31[1] = v21;
    *(_QWORD *)v8 = *(_QWORD *)sub_140306070(&v36, a1, v31);
  }
  *a2 = *((_QWORD *)a1 + 1);
  return a2;
}

// --- End Function: sub_14326DDD0 (0x14326DDD0) ---

// --- Function: sub_14328F160 (0x14328F160) ---
_QWORD *__fastcall sub_14328F160(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int128 v4; // xmm9
  __int128 v5; // xmm10
  __int128 v6; // xmm11
  __int128 v7; // xmm12
  __int128 v8; // xmm13
  __int128 v9; // xmm14
  __int128 v10; // xmm15
  __int64 v12; // r15
  __int64 v13; // rcx
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // r9
  __int64 v16; // rax
  __int64 v17; // r10
  __int64 v18; // r14
  bool v19; // al
  unsigned __int64 v20; // r14
  __int64 v21; // rcx
  __int64 v22; // rbx
  __int64 v23; // r14
  __int64 (__fastcall *v24)(__int64, double *, __int64, __int64); // r12
  __int64 v25; // rcx
  __int64 v26; // rbx
  __int64 v27; // rax
  double *v28; // rax
  double v29; // xmm14_8
  double v30; // xmm10_8
  double v31; // xmm8_8
  double v32; // xmm6_8
  double v33; // xmm7_8
  double v34; // xmm5_8
  __int128 v35; // xmm6
  __int128 v36; // kr00_16
  double v38; // xmm13_8
  double v39; // xmm15_8
  double v40; // xmm2_8
  double v41; // xmm8_8
  double v42; // xmm2_8
  __int128 v43; // xmm15
  double v44; // xmm11_8
  double v46; // xmm4_8
  double v47; // xmm14_8
  double v48; // xmm10_8
  double v49; // xmm9_8
  double v50; // xmm8_8
  double v51; // xmm13_8
  double v52; // xmm12_8
  double v53; // xmm5_8
  __int128 v54; // kr00_16
  double v55; // kr00_8
  double v56; // xmm7_8
  double v57; // xmm5_8
  double v59; // xmm5_8
  double v60; // xmm9_8
  double v61; // xmm11_8
  __int128 v63; // xmm1
  double *v64; // rax
  double v65; // xmm14_8
  __int128 v66; // xmm15
  __int128 v67; // xmm12
  __int128 v68; // xmm13
  double v69; // xmm7_8
  double v70; // xmm6_8
  double v71; // xmm4_8
  __int128 v72; // xmm5
  __int128 v73; // xmm4
  double v74; // xmm0_8
  double v75; // xmm7_8
  __int128 v76; // kr00_16
  __int128 v77; // xmm6
  double v78; // kr00_8
  double v80; // xmm9_8
  double v83; // xmm10_8
  __int128 v96; // xmm0
  __int64 v97; // rax
  __int64 v98; // rax
  unsigned __int64 v99; // r14
  __int64 v100; // rcx
  __int64 v101; // rbx
  __int64 v102; // r14
  __int64 (__fastcall *v103)(__int64, double *, __int64, __int64); // r12
  __int64 v104; // rbx
  __int64 v105; // rax
  double *v106; // rax
  double v107; // xmm9_8
  double v108; // xmm13_8
  double v109; // xmm14_8
  double v110; // xmm8_8
  double v111; // xmm7_8
  double v112; // xmm5_8
  double v113; // xmm4_8
  double v114; // xmm6_8
  double v115; // xmm3_8
  double v116; // xmm1_8
  double v117; // xmm11_8
  double v118; // xmm8_8
  double v119; // xmm7_8
  double v120; // xmm10_8
  double v121; // xmm13_8
  double v122; // xmm6_8
  double v123; // xmm15_8
  double v124; // xmm12_8
  double v125; // kr00_8
  double *v126; // rax
  double v127; // xmm15_8
  double v128; // xmm13_8
  double v129; // xmm11_8
  double v130; // xmm14_8
  double v131; // xmm6_8
  __int128 v132; // xmm5
  double v133; // xmm2_8
  double v134; // xmm6_8
  __int128 v135; // kr00_16
  double v136; // xmm8_8
  double v137; // xmm7_8
  double v138; // xmm3_8
  double v139; // kr00_8
  double v141; // xmm10_8
  double v142; // xmm6_8
  double v143; // xmm11_8
  __m128 v145; // xmm4
  unsigned __int64 v151; // [rsp+38h] [rbp-D0h]
  double v152; // [rsp+48h] [rbp-C0h] BYREF
  double v153; // [rsp+50h] [rbp-B8h]
  double v154; // [rsp+58h] [rbp-B0h]
  double v155; // [rsp+60h] [rbp-A8h]
  __int128 v156; // [rsp+68h] [rbp-A0h]
  double v157; // [rsp+78h] [rbp-90h]
  double v158; // [rsp+80h] [rbp-88h]
  double v159; // [rsp+88h] [rbp-80h]
  double v160; // [rsp+98h] [rbp-70h] BYREF
  double v161; // [rsp+A0h] [rbp-68h]
  double v162; // [rsp+A8h] [rbp-60h]
  double v163; // [rsp+B0h] [rbp-58h]
  __int128 v164; // [rsp+B8h] [rbp-50h]
  __int128 v165; // [rsp+C8h] [rbp-40h]
  __m256 v166; // [rsp+D8h] [rbp-30h] BYREF
  __int128 v167; // [rsp+F8h] [rbp-10h]
  __int128 v168; // [rsp+108h] [rbp+0h]
  double v169[8]; // [rsp+118h] [rbp+10h] BYREF
  __int128 v170; // [rsp+158h] [rbp+50h]
  __int128 v171; // [rsp+168h] [rbp+60h]
  __int128 v172; // [rsp+178h] [rbp+70h]
  __int128 v173; // [rsp+188h] [rbp+80h]
  __int128 v174; // [rsp+198h] [rbp+90h]
  __int128 v175; // [rsp+1A8h] [rbp+A0h]
  __int128 v176; // [rsp+1B8h] [rbp+B0h]
  __int128 v177; // [rsp+1C8h] [rbp+C0h]
  __int128 v178; // [rsp+1D8h] [rbp+D0h]
  __int128 v179; // [rsp+1E8h] [rbp+E0h]
  double v180; // [rsp+238h] [rbp+130h] BYREF
  double v181; // [rsp+248h] [rbp+140h] BYREF
  double v182; // [rsp+250h] [rbp+148h]

  v179 = v1;
  v178 = v2;
  v177 = v3;
  v176 = v4;
  v175 = v5;
  v174 = v6;
  v173 = v7;
  v172 = v8;
  v171 = v9;
  v170 = v10;
  v12 = 0;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v13 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v13 = 0;
  (*(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)v13 + 0x1E8LL))(v13, &v160, 2);
  (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)gEnv + 0x120LL))(gEnv, &v180, *(_QWORD *)(a1 + 0x228));
  v14 = *(_QWORD *)&v180;
  if ( v180 == 0.0 )
    goto LABEL_26;
  v15 = HIWORD(*(_QWORD *)&v180);
  if ( (HIWORD(v180) & 0xF000) != 0 )
  {
    v16 = map_flag_to_mask(0x2000u);
    v18 = v17 & ~(v16 - 1);
  }
  else
  {
    v18 = (*(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL) - 6;
  }
  if ( *(_WORD *)(v18 + 2) != (v15 & 0xFFF) )
    goto LABEL_26;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v19 = sub_140539D80(), v14 = *(_QWORD *)&v180, v19) )
    v19 = 1;
  if ( *(_WORD *)(v18 + 4) == 2 && v19 )
    goto LABEL_16;
  if ( !sub_140392020(&v180) )
  {
LABEL_26:
    v63 = *(_OWORD *)(a1 + 0x218);
    v166 = *(__m256 *)(a1 + 0x1E8);
    v167 = *(_OWORD *)(a1 + 0x208);
    v168 = v63;
    goto LABEL_27;
  }
  v14 = *(_QWORD *)&v180;
LABEL_16:
  (*(void (__fastcall **)(unsigned __int64, double *, __int64))(*(_QWORD *)(v14 & 0xFFFFFFFFFFFFLL) + 0x1E8LL))(
    v14 & 0xFFFFFFFFFFFFLL,
    &v152,
    2);
  v20 = *(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v21 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v21 = 0;
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v21 + 0x648LL))(v21);
  if ( (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v20 + 0x648LL))(v20) == v22 )
  {
    v46 = v155;
    v44 = v154;
    v43 = *(unsigned __int64 *)&v153;
    v47 = v152;
  }
  else
  {
    v23 = qword_149B4FBE8;
    v24 = *(__int64 (__fastcall **)(__int64, double *, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL);
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v25 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v25 = 0;
    v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x648LL))(v25);
    v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL) + 0x648LL))(*(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL);
    v28 = (double *)v24(v23, v169, v27, v26);
    v29 = *v28;
    v30 = v28[1];
    v31 = v28[2];
    v32 = v28[3];
    v33 = v30 * v157 - v31 * *((double *)&v156 + 1) + v32 * *(double *)&v156;
    v34 = v31 * *(double *)&v156 - *v28 * v157 + v32 * *((double *)&v156 + 1);
    v35 = COERCE_UNSIGNED_INT64((*v28 * *((double *)&v156 + 1) - v30 * *(double *)&v156 + v32 * v157) * v30 - v34 * v31);
    *((_QWORD *)&v36 + 1) = *((_QWORD *)&v35 + 1);
    *(double *)&v36 = *(double *)&v35 + *(double *)&v156 + v28[4] + *(double *)&v35;
    _XMM12 = v36;
    v38 = v34 * *v28 - v33 * v30 + v157 + v28[6] + v34 * *v28 - v33 * v30;
    v39 = v152 * *v28;
    v182 = v154 * v30 - v153 * v31 + v152 * v28[3] + v155 * *v28;
    v40 = v152 * v31 - v154 * *v28;
    v41 = v28[3];
    *(double *)&v151 = v40 + v153 * v41 + v155 * v30;
    v42 = v41 * v155 - v39;
    v43 = v151;
    v44 = v154 * v41 + v153 * v29 - v152 * v30 + v155 * v28[2];
    __asm { vunpcklpd xmm0, xmm12, xmm6 }
    v46 = v42 - v153 * v30 - v154 * v28[2];
    v47 = v182;
    v169[6] = v38;
    v156 = _XMM0;
    v157 = v38;
  }
  v48 = *(double *)(a1 + 0x260);
  v49 = *(double *)(a1 + 0x258);
  v50 = *(double *)(a1 + 0x250);
  v51 = *(double *)(a1 + 0x240);
  v52 = *(double *)(a1 + 0x238);
  v181 = v46;
  v53 = v44 * v50 - v47 * v48 + v49 * v46;
  *((_QWORD *)&v54 + 1) = *((_QWORD *)&v43 + 1);
  v55 = *(double *)&v43 * (v47 * v49 - *(double *)&v43 * v50 + v48 * v46) - v44 * v53;
  v56 = *(double *)(a1 + 0x248);
  v57 = v47 * v53 - *(double *)&v43 * (*(double *)&v43 * v48 - v44 * v49 + v50 * v46);
  *(double *)&v54 = (v55 + v50 + v55) * v158 + *(double *)&v156;
  _XMM8 = v54;
  *(double *)&v54 = v57 + v48 + v57;
  v59 = v158 * *(double *)(a1 + 0x268);
  v180 = v44;
  v60 = v44;
  v61 = *(double *)(a1 + 0x230);
  *(double *)v166.m256_f32 = *(double *)&v43 * v51 - v60 * v52 + v61 * v46 + v47 * v56;
  *(double *)&v166.m256_f32[2] = v60 * v61 - v47 * v51 + v52 * v46 + *(double *)&v43 * v56;
  *(double *)&v166.m256_f32[4] = v47 * v52 - *(double *)&v43 * v61 + v51 * v46 + v60 * v56;
  *(double *)&v166.m256_f32[6] = v56 * v46 - v47 * v61 - *(double *)&v43 * v52 - v60 * v51;
  __asm { vunpcklpd xmm1, xmm8, xmm4 }
  v167 = _XMM1;
  v157 = *(double *)&v54 * v158 + v157;
  *((double *)&v168 + 1) = v59;
  *(double *)&v168 = v157;
LABEL_27:
  __asm { vzeroupper }
  v64 = sub_1404B6AF0((double *)v166.m256_f32, &v152);
  v65 = v64[1];
  v66 = *((unsigned __int64 *)v64 + 2);
  v67 = *(unsigned __int64 *)v64;
  v68 = *((unsigned __int64 *)v64 + 3);
  v69 = v65 * *(double *)&v165 - *(double *)&v66 * *((double *)&v164 + 1) + *(double *)&v68 * *(double *)&v164;
  v70 = *(double *)&v66 * *(double *)&v164
      - *(double *)&v67 * *(double *)&v165
      + *(double *)&v68 * *((double *)&v164 + 1);
  v71 = *(double *)&v67 * *((double *)&v164 + 1) - v65 * *(double *)&v164 + *(double *)&v68 * *(double *)&v165;
  v72 = COERCE_UNSIGNED_INT64(v65 * v71 - *(double *)&v66 * v70);
  v73 = COERCE_UNSIGNED_INT64(*(double *)&v66 * v69 - *(double *)&v67 * v71);
  v74 = v65 * v69;
  v75 = v64[7];
  *((_QWORD *)&v76 + 1) = *((_QWORD *)&v72 + 1);
  v77 = COERCE_UNSIGNED_INT64(*(double *)&v67 * v70 - v74);
  v78 = *(double *)&v72 + *(double *)&v164 + *(double *)&v72;
  *(double *)&v72 = v160;
  *(double *)&v76 = v78 * v75 + v64[4];
  _XMM3 = v76;
  *((_QWORD *)&v76 + 1) = *((_QWORD *)&v73 + 1);
  v80 = v161;
  __asm { vcvtsd2ss xmm11, xmm3, xmm3 }
  *(double *)&v76 = (*(double *)&v73 + *((double *)&v164 + 1) + *(double *)&v73) * v75 + v64[5];
  _XMM3 = v76;
  *((_QWORD *)&v76 + 1) = *((_QWORD *)&v77 + 1);
  v83 = v162;
  *(double *)&v76 = *(double *)&v77 + *(double *)&v165 + *(double *)&v77;
  *(double *)&v77 = v163;
  __asm { vcvtsd2ss xmm8, xmm3, xmm3 }
  *(double *)&v76 = *(double *)&v76 * v75 + v64[6];
  _XMM3 = v76;
  __asm { vcvtsd2ss xmm7, xmm3, xmm3 }
  _XMM1 = COERCE_UNSIGNED_INT64(v65 * v162 - *(double *)&v66 * v161 + *(double *)&v68 * v160 + *(double *)&v67 * v163);
  __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
  *(float *)(a1 + 0x270) = *(float *)&_XMM2;
  *((_QWORD *)&v76 + 1) = *((_QWORD *)&v66 + 1);
  *(double *)&v76 = *(double *)&v66 * *(double *)&v72
                  - *(double *)&v67 * v83
                  + *(double *)&v68 * v80
                  + v65 * *(double *)&v77;
  _XMM2 = v76;
  __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
  *(float *)(a1 + 0x274) = *(float *)&_XMM1;
  *((_QWORD *)&v76 + 1) = *((_QWORD *)&v67 + 1);
  *(double *)&v76 = *(double *)&v67 * v80
                  - v65 * *(double *)&v72
                  + *(double *)&v68 * v83
                  + *(double *)&v66 * *(double *)&v77;
  _XMM2 = v76;
  __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
  *(float *)(a1 + 0x278) = *(float *)&_XMM1;
  *((_QWORD *)&v76 + 1) = *((_QWORD *)&v68 + 1);
  *(double *)&v76 = *(double *)&v68 * *(double *)&v77
                  - *(double *)&v67 * *(double *)&v72
                  - v65 * v80
                  - *(double *)&v66 * v83;
  _XMM2 = v76;
  __asm
  {
    vunpcklps xmm0, xmm11, xmm8
    vcvtsd2ss xmm1, xmm2, xmm2
  }
  *(float *)(a1 + 0x27C) = *(float *)&_XMM1;
  *(double *)(a1 + 0x280) = *(double *)&_XMM0;
  v96 = v164;
  *(float *)(a1 + 0x288) = *(float *)&_XMM7;
  *(double *)(a1 + 0x1E8) = *(double *)&v72;
  *(double *)(a1 + 0x1F0) = v80;
  *(double *)(a1 + 0x1F8) = v83;
  *(double *)(a1 + 0x200) = *(double *)&v77;
  *(_OWORD *)(a1 + 0x208) = v96;
  v164 = v96;
  *(_OWORD *)(a1 + 0x218) = v165;
  v97 = sub_14030ECF0((_QWORD *)(a1 + 0x3D8));
  v98 = sub_1465EF550(v97);
  sub_144EC9900(v98, &v180);
  if ( validateHandleAccess((unsigned __int64 *)&v180) )
  {
    (*(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)(*(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL) + 0x1E8LL))(
      *(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL,
      &v152,
      2);
    v99 = *(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL;
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v100 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v100 = 0;
    v101 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v100 + 0x648LL))(v100);
    if ( (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v99 + 0x648LL))(v99) != v101 )
    {
      v102 = qword_149B4FBE8;
      v103 = *(__int64 (__fastcall **)(__int64, double *, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL);
      if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
        v12 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      v104 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x648LL))(v12);
      v105 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL) + 0x648LL))(*(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL);
      v106 = (double *)v103(v102, v169, v105, v104);
      v107 = *v106;
      v108 = v106[1];
      v109 = v106[2];
      v110 = v106[3];
      v111 = v108 * v157 - v109 * *((double *)&v156 + 1) + v110 * *(double *)&v156;
      v112 = v109 * *(double *)&v156 - *v106 * v157 + v110 * *((double *)&v156 + 1);
      v113 = *v106 * *((double *)&v156 + 1) - v108 * *(double *)&v156 + v110 * v157;
      v114 = v113 * v108 - v112 * v109;
      v115 = v112 * *v106 - v111 * v108;
      v116 = v114 + *(double *)&v156 + v106[4];
      v117 = v111 * v109 - v113 * *v106 + *((double *)&v156 + 1) + v106[5] + v111 * v109 - v113 * *v106;
      v182 = v108;
      v181 = v110;
      v118 = v153;
      v159 = v107;
      v119 = v109 * v152;
      v120 = v108 * v152;
      v121 = v116 + v114;
      v122 = v115 + v157 + v106[6] + v115;
      v123 = v107 * v152;
      v124 = v107 * v153;
      v152 = v154 * v182 - v153 * v109 + v152 * v181 + v155 * v107;
      v153 = v119 - v154 * v107 + v153 * v181 + v155 * v182;
      v125 = v109 * v154;
      v154 = v154 * v181 + v124 - v120 + v155 * v109;
      v155 = v155 * v181 - v123 - v118 * v182 - v125;
      *(double *)&v156 = v121;
      *((double *)&v156 + 1) = v117;
      v157 = v122;
    }
    *(_QWORD *)(a1 + 0x228) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, double *))(*(_QWORD *)(*(_QWORD *)&v180
                                                                                                  & 0xFFFFFFFFFFFFLL)
                                                                                      + 8LL))(
                                           *(_QWORD *)&v180 & 0xFFFFFFFFFFFFLL,
                                           &v181);
    v126 = sub_1404B6AF0(&v152, v169);
    v127 = v126[1];
    v128 = *v126;
    v129 = v126[2];
    v130 = v126[3];
    v131 = v129 * *(double *)&v164 - *v126 * *(double *)&v165 + v130 * *((double *)&v164 + 1);
    v132 = COERCE_UNSIGNED_INT64(v127
                               * (*v126 * *((double *)&v164 + 1) - v127 * *(double *)&v164 + v130 * *(double *)&v165) - v129 * v131);
    v133 = *v126 * v131;
    v134 = v126[7];
    *((_QWORD *)&v135 + 1) = *((_QWORD *)&v132 + 1);
    v136 = v162;
    v137 = v161;
    v138 = v133 - v127 * (v127 * *(double *)&v165 - v129 * *((double *)&v164 + 1) + v130 * *(double *)&v164);
    v139 = *(double *)&v132 + *(double *)&v164 + *(double *)&v132;
    *(double *)&v132 = v163;
    *(double *)&v135 = v139 * v134 + v126[4];
    _XMM12 = v135;
    v141 = v134 * *((double *)&v165 + 1);
    *(double *)&v135 = (v138 + *(double *)&v165 + v138) * v134;
    v142 = v160;
    v181 = v129;
    v143 = *(double *)&v135 + v126[6];
    *(double *)&v135 = v160 * v181;
    *(double *)(a1 + 0x230) = v127 * v162 - v161 * v181 + v130 * v160 + v128 * v163;
    *(double *)(a1 + 0x238) = *(double *)&v135 - v128 * v136 + v130 * v137 + v127 * *(double *)&v132;
    *(double *)(a1 + 0x240) = v128 * v137 - v127 * v142 + v130 * v136 + *(double *)&v132 * v181;
    *(double *)(a1 + 0x248) = v130 * *(double *)&v132 - v128 * v142 - v127 * v137 - v136 * v181;
    __asm { vunpcklpd xmm0, xmm12, xmm9 }
    *(_OWORD *)(a1 + 0x250) = _XMM0;
    *(double *)(a1 + 0x260) = v143;
    *(double *)(a1 + 0x268) = v141;
  }
  else
  {
    *(_QWORD *)(a1 + 0x228) = 0;
  }
  v145 = (__m128)*(unsigned __int64 *)(a1 + 0x280);
  _XMM2 = *(unsigned int *)(a1 + 0x1A0) ^ (unsigned __int128)xmmword_14819FFD0;
  _XMM1 = 0;
  __asm
  {
    vcmpltss xmm0, xmm2, xmm1
    vblendvps xmm5, xmm1, xmm3, xmm0
  }
  LODWORD(_XMM2) = *(_DWORD *)(a1 + 0x1A0);
  *(float *)(a1 + 0x348) = _mm_shuffle_ps(v145, v145, 0x55).m128_f32[0] * *(float *)&_XMM5;
  *(float *)(a1 + 0x344) = v145.m128_f32[0] * *(float *)&_XMM5;
  *(float *)&v180 = *(float *)&_XMM5;
  return sub_14326DDD0((float *)(a1 + 0x344), &v180, *(float *)&_XMM2);
}

// --- End Function: sub_14328F160 (0x14328F160) ---

// --- Function: sub_14328FE60 (0x14328FE60) ---
void __fastcall sub_14328FE60(__int64 a1, int a2)
{
  __int64 v3; // rbx
  _DWORD *v4; // rbx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int n0x4300; // [rsp+30h] [rbp-58h] BYREF
  __int64 v11; // [rsp+34h] [rbp-54h]
  int v12; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v13; // [rsp+40h] [rbp-48h]
  unsigned __int64 v14; // [rsp+48h] [rbp-40h]
  __int64 v15; // [rsp+50h] [rbp-38h]
  __int64 v16; // [rsp+58h] [rbp-30h]

  n0x4300 = 0x4300;
  v3 = a2;
  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v13 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20ABC,
    "CAnimatedCharacter::UpdateMCMComponent",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS_Common.cpp",
    0xFF);
  HIWORD(n0x4300) = word_149E20ABC;
  v4 = (_DWORD *)(0x1C * v3 + a1 + 0x2A4);
  v4[4] = 1;
  if ( *v4 )
    v4[4] = *v4;
  v5 = v4[1];
  if ( v5 )
    v4[4] = v5;
  v6 = v4[2];
  if ( v6 )
    v4[4] = v6;
  v7 = v4[3];
  if ( v7 )
    v4[4] = v7;
  v8 = v4[6];
  if ( v8 )
  {
    v4[4] = v8;
  }
  else if ( (unsigned __int8)sub_1457D7070(a1) || sub_1457D1F80(a1) )
  {
    v4[4] = 2;
  }
  else if ( *(_BYTE *)(a1 + 0x340) )
  {
    v4[4] = 1;
  }
  v9 = v4[4];
  if ( v9 != v4[5] )
    v4[5] = v9;
  v14 = __rdtsc();
  qword_149B4B878(&n0x4300);
}

// --- End Function: sub_14328FE60 (0x14328FE60) ---

// --- Function: sub_14328FF80 (0x14328FF80) ---
void __fastcall sub_14328FF80(__int64 a1)
{
  *(_DWORD *)(a1 + 0x2BC) = *((_DWORD *)qword_149E12BA0 + 5);
  *(_DWORD *)(a1 + 0x2D8) = *((_DWORD *)qword_149E12BA0 + 6);
  sub_14328FE60(a1, 0);
  sub_14328FE60(a1, 1);
}

// --- End Function: sub_14328FF80 (0x14328FF80) ---

// --- Function: sub_14328FFD0 (0x14328FFD0) ---
void __fastcall sub_14328FFD0(__int64 a1, int n8)
{
  int n8_2; // ecx
  bool v5; // al
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  __int64 v10; // rax
  int n8_1; // edx
  _BYTE *v12; // rcx
  int v13; // r8d
  int n0x4300; // [rsp+30h] [rbp-58h] BYREF
  __int64 v15; // [rsp+34h] [rbp-54h]
  int v16; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v17; // [rsp+40h] [rbp-48h]
  unsigned __int64 v18; // [rsp+48h] [rbp-40h]
  __int64 v19; // [rsp+50h] [rbp-38h]
  __int64 v20; // [rsp+58h] [rbp-30h]

  n0x4300 = 0x4300;
  v15 = 0;
  v16 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v17 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20AA8,
    "CAnimatedCharacter::UpdatePhysicalColliderMode",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
    0x2B1);
  n8_2 = *(_DWORD *)(a1 + 0x2E0);
  HIWORD(n0x4300) = word_149E20AA8;
  v5 = n8 == 1;
  if ( n8_2 )
  {
    n8 = n8_2;
    if ( n8_2 == 1 )
      v5 = 1;
  }
  v6 = *(_DWORD *)(a1 + 0x2E4);
  if ( v6 )
  {
    n8 = *(_DWORD *)(a1 + 0x2E4);
    if ( v6 == 1 )
      v5 = 1;
  }
  v7 = *(_DWORD *)(a1 + 0x2E8);
  if ( v7 )
  {
    n8 = *(_DWORD *)(a1 + 0x2E8);
    if ( v7 == 1 )
      v5 = 1;
  }
  v8 = *(_DWORD *)(a1 + 0x2EC);
  if ( v8 )
  {
    n8 = *(_DWORD *)(a1 + 0x2EC);
    if ( v8 == 1 )
      v5 = 1;
  }
  v9 = *(_DWORD *)(a1 + 0x2F0);
  if ( v9 )
  {
    n8 = *(_DWORD *)(a1 + 0x2F0);
    if ( v9 == 1 )
      v5 = 1;
  }
  if ( v5 )
  {
    n8 = 1;
    goto LABEL_32;
  }
  if ( AssetMeta::HasActorSubresource((__int64 *)(a1 + 0x3E0)) )
  {
    v10 = sub_14030ECF0((_QWORD *)(a1 + 0x3E0));
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x750LL))(v10) )
    {
      if ( (unsigned int)(*(_DWORD *)(a1 + 0x2F4) - 2) > 1 && (unsigned int)(n8 - 2) > 1 )
        goto LABEL_31;
    }
  }
  if ( *(_BYTE *)(a1 + 0x400) )
  {
    n8 = 8;
    goto LABEL_32;
  }
  if ( n8 == 0xD )
  {
LABEL_31:
    n8 = 6;
  }
  else if ( n8 != 9 && (unsigned int)(n8 - 2) > 1 )
  {
    if ( (unsigned __int8)sub_1457D7070(a1) )
    {
      n8 = 8;
    }
    else if ( !n8 )
    {
      n8 = *(_DWORD *)(a1 + 0x2F8);
    }
  }
LABEL_32:
  n8_1 = *(_DWORD *)(a1 + 0x2F4);
  v12 = (_BYTE *)(a1 + 0x2FC);
  if ( n8 == n8_1 )
  {
    if ( *v12 )
    {
LABEL_40:
      *v12 = 0;
      *(_DWORD *)(a1 + 0x2F4) = n8;
      sub_1431D2330(a1, n8_1, n8);
    }
  }
  else
  {
    if ( *(_BYTE *)(a1 + 0x2FC) )
      goto LABEL_40;
    if ( n8 == 1 )
      goto LABEL_40;
    if ( n8 == 7 )
      goto LABEL_40;
    v13 = *(_DWORD *)(a1 + 0x114);
    if ( v13 > 0 && *(_DWORD *)(a1 + 0x118) + 1 <= v13 )
      goto LABEL_40;
  }
  v18 = __rdtsc();
  qword_149B4B878(&n0x4300);
}

// --- End Function: sub_14328FFD0 (0x14328FFD0) ---

// --- Function: sub_1432901E0 (0x1432901E0) ---
void __fastcall sub_1432901E0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  int n2; // eax
  int n2_1; // ecx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rcx
  float v11; // xmm1_4
  unsigned int v12; // eax
  float v13; // xmm0_4
  float v14; // xmm2_4
  bool v15; // zf
  __int64 v16; // rcx
  float v17; // xmm1_4
  unsigned __int64 v18; // [rsp+30h] [rbp-D0h] BYREF
  int n0x4300; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v20; // [rsp+44h] [rbp-BCh]
  int v21; // [rsp+4Ch] [rbp-B4h]
  unsigned __int64 v22; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v23; // [rsp+58h] [rbp-A8h]
  __int64 v24; // [rsp+60h] [rbp-A0h]
  __int64 v25; // [rsp+68h] [rbp-98h]
  _BYTE v26[4]; // [rsp+90h] [rbp-70h] BYREF
  float v27; // [rsp+94h] [rbp-6Ch]
  float v28; // [rsp+98h] [rbp-68h]
  float v29; // [rsp+D4h] [rbp-2Ch]

  n0x4300 = 0x4300;
  v20 = 0;
  v21 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v22 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E20AAC,
    "CAnimatedCharacter::UpdatePhysicsInertia",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\AnimatedCharacter/AnimatedCharacterPPS.cpp",
    0x44E);
  HIWORD(n0x4300) = word_149E20AAC;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v2 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v2 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v2 + 0x3B8LL))(v2, &v18);
  if ( !v18
    || *(_QWORD *)((v18 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v18)
    || (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v18 & 0xFFFFFFFFFFFFLL) + 8LL))(v18 & 0xFFFFFFFFFFFFLL) != 0xB )
  {
    goto LABEL_36;
  }
  v3 = validateHandleAccess((unsigned __int64 *)(a1 + 8)) ? *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL : 0LL;
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x318LL))(v3) )
    goto LABEL_36;
  sub_142EC37E0((__int64)v26);
  if ( *(_BYTE *)(a1 + 0x110)
    || *(_BYTE *)(a1 + 0x111)
    || *(_BYTE *)(a1 + 0x112)
    || (n2 = *(_DWORD *)(a1 + 0x2B4), n2 == 2)
    || (n2_1 = *(_DWORD *)(a1 + 0x2D0), n2_1 == 2)
    || n2 == 8
    || n2_1 == 8
    || (v6 = sub_14030ECF0((_QWORD *)(a1 + 0x3D8)), v7 = sub_1465EEBE0(v6), (unsigned __int8)sub_145AD74D0(v7))
    || (validateHandleAccess((unsigned __int64 *)(a1 + 8)) ? (v8 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) : (v8 = 0),
        !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x720LL))(v8)
     && ((v9 = sub_14030ECF0((_QWORD *)(a1 + 0x3D8)),
          (v10 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x758LL))(v9) + 8) & 0xFFFFFFFFFFFFLL) == 0)
      || !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x20LL))(v10))) )
  {
    v11 = 0.0;
    v29 = 0.0;
    goto LABEL_28;
  }
  v11 = *(float *)(a1 + 0x100);
  v12 = *(_DWORD *)(a1 + 0x2F4) - 8;
  v29 = v11;
  if ( v12 <= 1 )
  {
LABEL_28:
    v14 = 0.0;
    v13 = 0.0;
    goto LABEL_29;
  }
  v13 = *(float *)(a1 + 0xF8);
  v14 = *(float *)(a1 + 0xFC);
LABEL_29:
  v15 = v13 == *(float *)(a1 + 0x104);
  v27 = v13;
  v28 = v14;
  if ( !v15 || v14 != *(float *)(a1 + 0x108) || v11 != *(float *)(a1 + 0x10C) )
  {
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v16 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v16 = 0;
    (*(void (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v16 + 0x3F8LL))(v16, v26, 0, 0);
    v17 = v28;
    *(float *)(a1 + 0x104) = v27;
    *(float *)(a1 + 0x10C) = v29;
    *(float *)(a1 + 0x108) = v17;
  }
LABEL_36:
  v23 = __rdtsc();
  qword_149B4B878(&n0x4300);
}

// --- End Function: sub_1432901E0 (0x1432901E0) ---

// --- Function: sub_143295AA0 (0x143295AA0) ---
__int64 __fastcall sub_143295AA0(__int64 a1, __int64 a2)
{
  int v4; // eax
  float v5; // xmm2_4
  __int64 result; // rax
  float v7; // xmm1_4
  float v8; // xmm0_4

  v4 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149B4FCD8 + 0x538LL))(qword_149B4FCD8);
  v5 = *(float *)(a1 + 0x198);
  *(_DWORD *)(a1 + 0x114) = v4;
  result = *(unsigned int *)(a1 + 0x190);
  *(float *)(a1 + 0x19C) = v5;
  v7 = *(float *)(a2 + 0x10);
  *(float *)(a1 + 0x198) = v7;
  *(_DWORD *)(a1 + 0x194) = result;
  v8 = *(float *)(a2 + 0x14);
  *(float *)(a1 + 0x190) = v8;
  *(float *)(a1 + 0x1A0) = (float)(v8 - v7) + v5;
  return result;
}

// --- End Function: sub_143295AA0 (0x143295AA0) ---

// --- Function: sub_1433712C0 (0x1433712C0) ---
__int64 __fastcall sub_1433712C0(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1433712C0 (0x1433712C0) ---

// --- Function: sub_143584460 (0x143584460) ---
float *__fastcall sub_143584460(float *a1)
{
  a1[3] = 0x3F800000;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  sub_1402AE7E0((__int64)(a1 + 7));
  return a1;
}

// --- End Function: sub_143584460 (0x143584460) ---

// --- Function: Handle_GetRawPointerIfValid_w (0x1442DE8E0) ---
__int64 __fastcall sub_1442DE8E0(__int64 a1)
{
  return Handle_GetRawPointerIfValid((_QWORD *)(a1 + 0x70));
}

// --- End Function: Handle_GetRawPointerIfValid_w (0x1442DE8E0) ---

// --- Function: sub_144E45D10 (0x144E45D10) ---
char sub_144E45D10()
{
  __int64 v1; // [rsp+20h] [rbp-18h]

  v1 = sub_1464E7930(qword_149E7E438);
  if ( v1 )
    return sub_14647F400(v1);
  else
    return 0;
}

// --- End Function: sub_144E45D10 (0x144E45D10) ---

// --- Function: sub_144EC9900 (0x144EC9900) ---
_QWORD *__fastcall sub_144EC9900(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0xA0);
  return a2;
}

// --- End Function: sub_144EC9900 (0x144EC9900) ---

// --- Function: sub_1455C04E0 (0x1455C04E0) ---
_QWORD *__fastcall sub_1455C04E0(__int64 a1, _QWORD *a2)
{
  volatile signed __int32 *v3; // [rsp+38h] [rbp-10h] BYREF

  v3 = *(volatile signed __int32 **)(a1 + 0xF8);
  if ( v3 )
    InterlockedIncrement_w_17((__int64)v3);
  sub_1455C4410(a2, &v3);
  return a2;
}

// --- End Function: sub_1455C04E0 (0x1455C04E0) ---

// --- Function: sub_1455C2030 (0x1455C2030) ---
_QWORD *__fastcall sub_1455C2030(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2960;
  return a1;
}

// --- End Function: sub_1455C2030 (0x1455C2030) ---

// --- Function: sub_1455C4410 (0x1455C4410) ---
_QWORD *__fastcall sub_1455C4410(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2030(a1, a2);
  *a1 = &off_148AB2960;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4410 (0x1455C4410) ---

// --- Function: sub_1457B6FF0 (0x1457B6FF0) ---
__int64 (__fastcall *sub_1457B6FF0())(__int64 a1, __int64 a2)
{
  return sub_1457D6E90;
}

// --- End Function: sub_1457B6FF0 (0x1457B6FF0) ---

// --- Function: unknown_libname_806 (0x1457BF530) ---
// Microsoft VisualC 64bit universal runtime
__int64 __fastcall unknown_libname_806(__int64 a1, __int64 a2)
{
  sub_140309960(a1, a2);
  sub_1402AE7E0(a1 + 0x1C);
  return a1;
}

// --- End Function: unknown_libname_806 (0x1457BF530) ---

// --- Function: sub_1457BF580 (0x1457BF580) ---
__int64 __fastcall sub_1457BF580(__int64 a1, __int64 a2, const void *src)
{
  sub_140309960(a1, a2);
  qmemcpy((void *)(a1 + 0x1C), src, 0xCu);
  return a1;
}

// --- End Function: sub_1457BF580 (0x1457BF580) ---

// --- Function: sub_1457D1F80 (0x1457D1F80) ---
bool __fastcall sub_1457D1F80(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x330)
      && (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x330) + 0x30LL))(*(_QWORD *)(a1 + 0x330));
}

// --- End Function: sub_1457D1F80 (0x1457D1F80) ---

// --- Function: sub_1457D6E90 (0x1457D6E90) ---
__int64 __fastcall sub_1457D6E90(__int64 a1, __int64 a2)
{
  return sub_1457EB8F0(a1, a2);
}

// --- End Function: sub_1457D6E90 (0x1457D6E90) ---

// --- Function: sub_1457D6EC0 (0x1457D6EC0) ---
bool __fastcall sub_1457D6EC0(__int64 a1)
{
  unsigned __int64 v2; // [rsp+20h] [rbp-28h]
  unsigned __int64 *v3; // [rsp+30h] [rbp-18h]
  _BYTE v4[16]; // [rsp+38h] [rbp-10h] BYREF

  v2 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)v2 + 0x150LL))(v2, v4);
  return j_validateHandleAccess(v3);
}

// --- End Function: sub_1457D6EC0 (0x1457D6EC0) ---

// --- Function: sub_1457D7070 (0x1457D7070) ---
__int64 __fastcall sub_1457D7070(__int64 a1)
{
  unsigned __int64 v1; // rax
  unsigned __int8 v3; // [rsp+20h] [rbp-38h]
  unsigned __int64 v4; // [rsp+28h] [rbp-30h]
  unsigned __int64 *v5; // [rsp+40h] [rbp-18h]
  _BYTE v6[16]; // [rsp+48h] [rbp-10h] BYREF

  v4 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  v5 = (unsigned __int64 *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)v4 + 0x150LL))(v4, v6);
  v3 = 0;
  if ( j_validateHandleAccess(v5) )
  {
    v1 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
    if ( (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)v1 + 0x178LL))(v1) != 9 )
      return 1;
  }
  return v3;
}

// --- End Function: sub_1457D7070 (0x1457D7070) ---

// --- Function: sub_1457EB8F0 (0x1457EB8F0) ---
__int64 __fastcall sub_1457EB8F0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // [rsp+24h] [rbp-64h]
  __int64 v4; // [rsp+30h] [rbp-58h]
  __int64 v5; // [rsp+48h] [rbp-40h]
  __int64 v6; // [rsp+50h] [rbp-38h] BYREF
  __int64 v7; // [rsp+58h] [rbp-30h]
  __int64 v9; // [rsp+68h] [rbp-20h]
  void (__fastcall *v10)(__int64); // [rsp+70h] [rbp-18h]
  void (__fastcall *v11)(__int64, __int64 *); // [rsp+78h] [rbp-10h]

  *(_BYTE *)(a1 + 0x18E) = 1;
  sub_143295AA0(a1, a2);
  sub_14328F160(a1, a2);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x3D8) & 0xFFFFFFFFFFFFLL) + 0x688LL))(*(_QWORD *)(a1 + 0x3D8) & 0xFFFFFFFFFFFFLL);
  if ( *(_QWORD *)(a1 + 0xB0) )
  {
    v9 = *(_QWORD *)(a1 + 0xB0);
    v10 = *(void (__fastcall **)(__int64))(*(_QWORD *)v9 + 0xC8LL);
    v10(v9);
  }
  v3 = 0;
  v5 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  v11 = *(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v5 + 0x3B8LL);
  v11(v5, &v6);
  if ( HIWORD_w(&v6) )
  {
    v7 = sub_14030ECF0(&v6);
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
  }
  if ( v3 != *(_DWORD *)(a1 + 0x300) )
    sub_143235DB0(a1);
  if ( *(float *)(a1 + 0x198) > 0.0 && *(float *)(a1 + 0x170) > 0.0 )
  {
    sub_14328FFD0(a1, *(_BYTE *)(v4 + 1) == 0);
    sub_1432901E0(a1);
    if ( *(_BYTE *)(v4 + 1) )
      sub_1431CFB70(a1);
  }
  if ( *(_BYTE *)(v4 + 1) )
  {
    sub_1431F3CC0(a1);
    sub_14328FF80(a1);
    if ( *(float *)(a1 + 0x198) > 0.0 && *(float *)(a1 + 0x170) > 0.0 )
      sub_1431F31D0(a1);
  }
  *(_BYTE *)(a1 + 0x1D4) = 0;
  *(_BYTE *)(a1 + 0x1A4) = 0;
  *(_BYTE *)(a1 + 0x1C4) = 0;
  *(_BYTE *)(a1 + 0x1A5) = 0;
  result = a1;
  *(_BYTE *)(a1 + 0x18E) = 0;
  return result;
}

// --- End Function: sub_1457EB8F0 (0x1457EB8F0) ---

// --- Function: sub_1457F2460 (0x1457F2460) ---
__int64 __fastcall sub_1457F2460(__int64 a1, __int64 a2)
{
  const char *p_EntityComponentSimpleRotation; // [rsp+48h] [rbp+10h] BYREF

  *(_DWORD *)a2 = 0x1010000;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 0x10) = 0;
  *(_BYTE *)(a2 + 0x14) = 0;
  *(_DWORD *)(a2 + 4) = 0xF;
  *(_WORD *)(a2 + 0x12) = 0x3FF;
  unknown_libname_472((_QWORD *)(a2 + 0x18));
  unknown_libname_472((_QWORD *)(a2 + 0x30));
  unknown_libname_472((_QWORD *)(a2 + 0x48));
  unknown_libname_472((_QWORD *)(a2 + 0x60));
  *(_DWORD *)(a2 + 4) = 2;
  *(_WORD *)a2 = 3;
  *(_QWORD *)(a2 + 8) = sub_1457B6FF0();
  LOBYTE(p_EntityComponentSimpleRotation) = 2;
  sub_140392480(a2, (unsigned __int8 *)&p_EntityComponentSimpleRotation);
  p_EntityComponentSimpleRotation = "Actor";
  sub_140392370(a2, &p_EntityComponentSimpleRotation);
  p_EntityComponentSimpleRotation = "SCActorAnimationComponent";
  sub_140392370(a2, &p_EntityComponentSimpleRotation);
  p_EntityComponentSimpleRotation = "EntityComponentSimpleRotation";
  sub_140392370(a2, &p_EntityComponentSimpleRotation);
  return a2;
}

// --- End Function: sub_1457F2460 (0x1457F2460) ---

// --- Function: sub_14583F430 (0x14583F430) ---
__int64 __fastcall sub_14583F430(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 0x3508);
  if ( !result )
    return sub_14601FAD0(a1 + 0x3510);
  return result;
}

// --- End Function: sub_14583F430 (0x14583F430) ---

// --- Function: sub_145ACCD50 (0x145ACCD50) ---
char __fastcall sub_145ACCD50(__int64 a1)
{
  unsigned __int64 v2; // rax
  int n8; // [rsp+24h] [rbp-34h]
  __int64 v4; // [rsp+28h] [rbp-30h]
  __int64 v5; // [rsp+40h] [rbp-18h]

  n8 = *(_DWORD *)(a1 + 0x4F8);
  if ( (n8 & 8) != 0 && n8 == 8 )
    return 1;
  if ( sub_142C0F3C0(a1 + 0x4F0, 0) )
    return 2;
  v2 = sub_1403E6750((unsigned __int64 *)(*(_QWORD *)(a1 + 0x158) + 8LL));
  if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v2 + 0x720LL))(v2)
    && ((v5 = sub_1465EEE60(*(_QWORD *)(a1 + 0x158)),
         v4 = sub_14583F430(v5),
         Concurrency::details::_ContextCallback::_HasCapturedContext((Concurrency::details::_ContextCallback *)(v4 + 0x178)))
     && *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v4 + 0x178) + 4)
     || *(_BYTE *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v4 + 0x20) == 0xB) )
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_145ACCD50 (0x145ACCD50) ---

// --- Function: sub_145AD55F0 (0x145AD55F0) ---
__int64 __fastcall sub_145AD55F0(__int64 a1)
{
  __int64 v1; // rax
  unsigned __int8 v3; // [rsp+20h] [rbp-28h]
  unsigned __int64 v4; // [rsp+28h] [rbp-20h]

  v3 = 0;
  if ( sub_145ACCD50(a1) == 2 )
  {
    v4 = sub_1403E6750((unsigned __int64 *)(*(_QWORD *)(a1 + 0x158) + 8LL));
    if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v4 + 0x720LL))(v4) )
    {
      v1 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x158) + 0x758LL))(*(_QWORD *)(a1 + 0x158));
      if ( !sub_1403BFC90(v1) )
        return 1;
    }
  }
  return v3;
}

// --- End Function: sub_145AD55F0 (0x145AD55F0) ---

// --- Function: sub_145AD72E0 (0x145AD72E0) ---
char __fastcall sub_145AD72E0(__int64 a1)
{
  char result; // al
  __int64 v2; // [rsp+28h] [rbp-30h]
  __int64 v3; // [rsp+30h] [rbp-28h]
  __int64 v4; // [rsp+48h] [rbp-10h]

  if ( !(unsigned __int8)sub_145AD55F0(a1) )
    return 0;
  v3 = sub_1465EEE60(*(_QWORD *)(a1 + 0x158));
  v2 = sub_14583F430(v3);
  switch ( *(_BYTE *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0x20) )
  {
    case 1:
    case 5:
    case 0xB:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x2C:
      result = 0;
      break;
    case 2:
      if ( sub_144E45D10() )
        goto LABEL_15;
      result = 0;
      break;
    case 4:
      if ( *(_BYTE *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0xF0) != 1
        || (*(_DWORD *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0xF8) + 0x1C) & 4) == 0 )
      {
        goto LABEL_15;
      }
      result = 0;
      break;
    case 8:
      if ( *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0x1E8) + 0x10) != 1 )
        goto LABEL_15;
      v4 = *(_QWORD *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0x210);
      if ( !sub_14037F610(v4, 0) )
        goto LABEL_15;
      result = 0;
      break;
    case 0x24:
      if ( !*(_BYTE *)(sub_1402A2660(v2 + 0x200) + 0x58) )
        goto LABEL_15;
      result = 0;
      break;
    default:
LABEL_15:
      result = 1;
      break;
  }
  return result;
}

// --- End Function: sub_145AD72E0 (0x145AD72E0) ---

// --- Function: sub_145AD74D0 (0x145AD74D0) ---
bool __fastcall sub_145AD74D0(__int64 a1)
{
  _QWORD *v2; // rax
  bool v3; // [rsp+20h] [rbp-28h]
  _QWORD v4[3]; // [rsp+30h] [rbp-18h] BYREF

  if ( !sub_145AD72E0(a1) )
    return 0;
  v2 = sub_1455C04E0(a1 + 0x1698, v4);
  v3 = sub_14037FB90((__int64)v2);
  sub_142F709D0(v4);
  return v3;
}

// --- End Function: sub_145AD74D0 (0x145AD74D0) ---

// --- Function: sub_145EEE160 (0x145EEE160) ---
void __fastcall sub_145EEE160(_QWORD *a1)
{
  *a1 = &off_148747D28;
  sub_145F27B80((__int64)a1);
}

// --- End Function: sub_145EEE160 (0x145EEE160) ---

// --- Function: sub_145F27B80 (0x145F27B80) ---
void __fastcall sub_145F27B80(__int64 a1)
{
  __int64 v1; // [rsp+20h] [rbp-48h]
  _BYTE src_[16]; // [rsp+28h] [rbp-40h] BYREF
  _QWORD src__1[6]; // [rsp+38h] [rbp-30h] BYREF

  *(_BYTE *)(a1 + 0x61) = 0;
  *(_BYTE *)(a1 + 0x60) = 0;
  *(_BYTE *)(a1 + 0x34) = 0;
  sub_1402AE7E0((__int64)src_);
  qmemcpy((void *)(a1 + 0x28), src_, 0xCu);
  unknown_libname_472(src__1);
  qmemcpy((void *)(a1 + 0x10), src__1, 0x18u);
  if ( *(_DWORD *)(a1 + 8) )
  {
    v1 = sub_1464E8470(qword_149E7E438);
    sub_14049ABA0(v1, (unsigned int *)(a1 + 8));
  }
  *(_DWORD *)(a1 + 8) = 0;
  sub_1402B1640((_QWORD *)(a1 + 0x38));
}

// --- End Function: sub_145F27B80 (0x145F27B80) ---

// --- Function: sub_145F95D90 (0x145F95D90) ---
__int64 __fastcall sub_145F95D90(__int64 a1, __int64 a2)
{
  return 0x270 * a2 + a1;
}

// --- End Function: sub_145F95D90 (0x145F95D90) ---

// --- Function: sub_14601FAD0 (0x14601FAD0) ---
__int64 __fastcall sub_14601FAD0(__int64 a1)
{
  return sub_145F95D90(*(_QWORD *)a1, *(unsigned int *)(a1 + 8));
}

// --- End Function: sub_14601FAD0 (0x14601FAD0) ---

// --- Function: sub_14647F400 (0x14647F400) ---
char __fastcall sub_14647F400(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 RawPointerIfValid_w; // rax

  v2 = *(_QWORD *)(a1 + 0x200);
  if ( !v2 || !Handle_GetRawPointerIfValid_w(v2) )
    return 1;
  v3 = *(_QWORD *)(a1 + 0x200);
  if ( !v3 )
    return (*(__int64 (**)(void))(MEMORY[0] + 0x700LL))();
  RawPointerIfValid_w = Handle_GetRawPointerIfValid_w(v3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)RawPointerIfValid_w + 0x700LL))(RawPointerIfValid_w);
}

// --- End Function: sub_14647F400 (0x14647F400) ---

// --- Function: sub_1464E7930 (0x1464E7930) ---
__int64 __fastcall sub_1464E7930(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x180LL))(*(_QWORD *)(a1 + 0xE8));
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x28LL))(v1);
}

// --- End Function: sub_1464E7930 (0x1464E7930) ---

// --- Function: sub_1464E8470 (0x1464E8470) ---
__int64 __fastcall sub_1464E8470(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xC60);
}

// --- End Function: sub_1464E8470 (0x1464E8470) ---

// --- Function: sub_1465D2560 (0x1465D2560) ---
_BOOL8 __fastcall sub_1465D2560(__int64 a1, int a2)
{
  __int64 v2; // rax
  int v5; // [rsp+2Ch] [rbp-5Ch] BYREF
  int v6; // [rsp+30h] [rbp-58h]
  int v7; // [rsp+38h] [rbp-50h] BYREF
  int v8; // [rsp+40h] [rbp-48h]
  int v9; // [rsp+48h] [rbp-40h]
  int v10; // [rsp+50h] [rbp-38h] BYREF
  int *v11; // [rsp+58h] [rbp-30h]
  __int64 v12; // [rsp+60h] [rbp-28h]
  int *v13; // [rsp+68h] [rbp-20h]
  int *v14; // [rsp+70h] [rbp-18h]

  v5 = a2;
  v11 = &v5;
  if ( a2 - *(_DWORD *)(a1 + 0x380) < 0 )
    return 0;
  v2 = identity_int64((__int64)&qword_149B4FBE0);
  v6 = sub_1403E6790(v2);
  v7 = v6;
  v13 = &v7;
  v12 = a1 + 0x380;
  v8 = *(_DWORD *)(a1 + 0x384);
  v9 = v8 + *(_DWORD *)(a1 + 0x380);
  v10 = v9;
  v14 = &v10;
  return v6 - v9 <= 0;
}

// --- End Function: sub_1465D2560 (0x1465D2560) ---

// --- Function: sub_1465EEBE0 (0x1465EEBE0) ---
__int64 __fastcall sub_1465EEBE0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270);
}

// --- End Function: sub_1465EEBE0 (0x1465EEBE0) ---

// --- Function: sub_1465EEE60 (0x1465EEE60) ---
__int64 __fastcall sub_1465EEE60(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x2B98LL;
}

// --- End Function: sub_1465EEE60 (0x1465EEE60) ---

// --- Function: sub_1465EF550 (0x1465EF550) ---
__int64 __fastcall sub_1465EF550(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x9B48LL;
}

// --- End Function: sub_1465EF550 (0x1465EF550) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_1475B3F30 (0x1475B3F30) ---
int __fastcall sub_1475B3F30(char *Buffer, size_t BufferCount, unsigned __int64 n0x40000000)
{
  const char *p_%u.%u_MB; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-A8h]
  int v11; // [rsp+28h] [rbp-A0h]
  __m256 DstBuf_; // [rsp+40h] [rbp-88h] BYREF
  __m256 DstBuf__1; // [rsp+60h] [rbp-68h] BYREF
  __m256 v14; // [rsp+80h] [rbp-48h]

  DstBuf_ = (__m256)0LL;
  if ( n0x40000000 >= 0x10000000000LL )
  {
    p_%u.%u_MB = "%u.%u TB";
    v7 = (0xA * (n0x40000000 & 0xFFFFFFFFFFLL)) >> 0x28;
    v8 = n0x40000000 >> 0x28;
LABEL_7:
    v11 = v7;
    v10 = v8;
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, p_%u.%u_MB, v10, v11);
    goto LABEL_11;
  }
  if ( n0x40000000 >= 0x40000000 )
  {
    p_%u.%u_MB = "%u.%u GB";
    v7 = (0xA * (n0x40000000 & 0x3FFFFFFF)) >> 0x1E;
    v8 = n0x40000000 >> 0x1E;
    goto LABEL_7;
  }
  if ( n0x40000000 >= 0x100000 )
  {
    p_%u.%u_MB = "%u.%u MB";
    v7 = (0xA * (n0x40000000 & 0xFFFFF)) >> 0x14;
    v8 = n0x40000000 >> 0x14;
    goto LABEL_7;
  }
  if ( n0x40000000 < 0x400 )
  {
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, "%u byte(s)", n0x40000000);
  }
  else
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf_,
      0x20u,
      0xFFFFFFFFFFFFFFFFuLL,
      "%u.%u KB",
      n0x40000000 >> 0xA,
      (0xA * (n0x40000000 & 0x3FF)) >> 0xA);
  }
LABEL_11:
  DstBuf__1 = (__m256)0LL;
  v14 = (__m256)0LL;
  if ( byte_1516B60CF )
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf__1,
      0x40u,
      0xFFFFFFFFFFFFFFFFuLL,
      " (Started with < %u GB of available system memory.)",
      8);
  }
  __asm { vzeroupper }
  return snprintf_s(
           Buffer,
           BufferCount,
           0xFFFFFFFFFFFFFFFFuLL,
           "Out of system memory. Failed to allocate %s (%zu).%s",
           (const char *)&DstBuf_,
           n0x40000000,
           (const char *)&DstBuf__1);
}

// --- End Function: sub_1475B3F30 (0x1475B3F30) ---

// --- Function: sub_1475DF210 (0x1475DF210) ---
void __fastcall sub_1475DF210(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1475B3F30(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1475DF210 (0x1475DF210) ---

// --- Function: sub_147601A00 (0x147601A00) ---
__int64 __fastcall sub_147601A00(
        __int64 *a1,
        __int64 a2,
        _QWORD *a3,
        unsigned __int64 a4,
        int a5,
        _QWORD **a6,
        __int64 *a7)
{
  __int64 v7; // r11
  __int64 v8; // rsi
  unsigned __int64 v9; // r10
  char v10; // r15
  __int64 i; // rbx
  __int64 v20; // r8
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v25; // rax
  __int64 v26; // rcx
  unsigned __int64 v27; // rax
  __int64 v28; // r9
  __int64 v29; // r11
  __int64 v30; // rdx
  __int64 result; // rax
  __int128 v32; // [rsp+20h] [rbp-38h]

  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a4 >> 7);
  v10 = a4 & 0x7F;
  _XMM2 = a4 & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  for ( i = 0; ; v9 = v7 & (i + v9) )
  {
    _XMM1 = *(_OWORD *)(v8 + v9);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_6:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      goto LABEL_10;
    i += 0x10;
  }
  v20 = a1[1];
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v21, _EAX);
    v22 = v7 & (v9 + v21);
    if ( *(_QWORD *)(0x20 * v22 + v20) == *a3 )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
      goto LABEL_6;
  }
  if ( v22 != 0xFFFFFFFFFFFFFFFFuLL )
  {
    v25 = v8 + v22;
    *(_BYTE *)(a2 + 0x10) = 0;
    v26 = v20 + 0x20 * v22;
    *(_QWORD *)&v32 = v25;
    goto LABEL_11;
  }
LABEL_10:
  v27 = sub_1476048B0(a1, a4);
  v28 = a1[1];
  v29 = 0x20 * v27;
  *(_BYTE *)(a2 + 0x10) = 1;
  v30 = *a7;
  *(_QWORD *)(v28 + v29) = **a6;
  *(_OWORD *)(v28 + v29 + 8) = *(_OWORD *)v30;
  *(double *)(v28 + v29 + 0x18) = *(double *)(v30 + 0x10);
  *(_BYTE *)(v27 + *a1) = v10;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v27 - 0x10)) + *a1 + 1) = v10;
  *(_QWORD *)&v32 = v27 + *a1;
  v26 = 0x20 * v27 + a1[1];
LABEL_11:
  result = a2;
  *((_QWORD *)&v32 + 1) = v26;
  *(_OWORD *)a2 = v32;
  return result;
}

// --- End Function: sub_147601A00 (0x147601A00) ---

// --- Function: sub_147601B90 (0x147601B90) ---
__int64 __fastcall sub_147601B90(
        __int64 *a1,
        __int64 a2,
        _QWORD *a3,
        unsigned __int64 a4,
        int a5,
        _QWORD **a6,
        _QWORD **a7)
{
  __int64 v7; // r11
  __int64 v8; // rsi
  unsigned __int64 v9; // r10
  char v10; // r15
  __int64 i; // rbx
  __int64 v20; // r8
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v25; // rax
  __int64 v26; // rcx
  unsigned __int64 v27; // rax
  __int64 v28; // r9
  __int64 v29; // r11
  _QWORD *v30; // rdx
  __int64 result; // rax
  __int128 v32; // [rsp+20h] [rbp-38h]

  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a4 >> 7);
  v10 = a4 & 0x7F;
  _XMM2 = a4 & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  for ( i = 0; ; v9 = v7 & (i + v9) )
  {
    _XMM1 = *(_OWORD *)(v8 + v9);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_6:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      goto LABEL_10;
    i += 0x10;
  }
  v20 = a1[1];
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v21, _EAX);
    v22 = v7 & (v9 + v21);
    if ( *(_QWORD *)(v20 + 0x10 * v22) == *a3 )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
      goto LABEL_6;
  }
  if ( v22 != 0xFFFFFFFFFFFFFFFFuLL )
  {
    v25 = v8 + v22;
    *(_BYTE *)(a2 + 0x10) = 0;
    v26 = v20 + 0x10 * v22;
    *(_QWORD *)&v32 = v25;
    goto LABEL_11;
  }
LABEL_10:
  v27 = sub_1476049E0(a1, a4);
  v28 = a1[1];
  v29 = 0x10 * v27;
  *(_BYTE *)(a2 + 0x10) = 1;
  v30 = *a7;
  *(_QWORD *)(v28 + v29) = **a6;
  *(_QWORD *)(v28 + v29 + 8) = *v30;
  *(_BYTE *)(v27 + *a1) = v10;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v27 - 0x10)) + *a1 + 1) = v10;
  *(_QWORD *)&v32 = v27 + *a1;
  v26 = 0x10 * v27 + a1[1];
LABEL_11:
  result = a2;
  *((_QWORD *)&v32 + 1) = v26;
  *(_OWORD *)a2 = v32;
  return result;
}

// --- End Function: sub_147601B90 (0x147601B90) ---

// --- Function: sub_147602270 (0x147602270) ---
void __fastcall sub_147602270(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rcx
  _QWORD *v9; // rdi
  __int64 v10; // rcx
  unsigned __int64 v11; // r14
  __int64 v12; // rsi
  __int64 v13; // rcx
  _BYTE v14[32]; // [rsp+30h] [rbp-48h] BYREF

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x11C0));
  v6 = *(_QWORD *)(a1 + 0x1190);
  if ( (unsigned __int64)(0x4000000000LL - *(_QWORD *)(v6 + 8)) < 0x2000000 )
  {
    v7 = *(unsigned int *)(a1 + 0x11AC);
    *(__m256i *)(a1 + 0x1198) = *(__m256i *)sub_14056DBC0(
                                              (__int64)v14,
                                              0x8000000000LL,
                                              *(_DWORD *)(a1 + 0x11AC),
                                              off_148D699A0,
                                              1,
                                              0);// "StarAlloc-Small"
    v6 = (*(_QWORD *)(a1 + 0x1198) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
    __asm { vzeroupper }
    sub_14056DA40(a1 + 0x1198, v6, (v7 + 0x17) & ~(v7 - 1));
    *(_WORD *)(v6 + 0x15) = 0;
    *(_BYTE *)(v6 + 0x17) = 0;
    *(_QWORD *)v6 = 0;
    *(_BYTE *)(v6 + 0x14) = 0;
    *(_QWORD *)(v6 + 8) = ((v6 + 0x2000017) & 0xFFFFFFFFFE000000uLL) - v6;
    *(_DWORD *)(v6 + 0x10) = 0x1337;
    *(_QWORD *)v6 = *(_QWORD *)(a1 + 0x1190);
    *(_BYTE *)(v6 + 0x14) = 1;
    *(_QWORD *)(a1 + 0x1190) = v6;
  }
  v8 = *(_QWORD *)(v6 + 8);
  v9 = (_QWORD *)(v6 + v8 + *(unsigned int *)(a1 + 0x11AC));
  *(_QWORD *)(v6 + 8) = v8 + 0x2000000;
  v10 = *(unsigned int *)(a1 + 0x11AC);
  v11 = a2 + v10 + 0x2F - ((unsigned __int64)v9 + v10 + a2 + 0x2F) % a2;
  if ( *(_BYTE *)(a1 + 0x14F8) )
    v12 = 0x2000000 - v10;
  else
    v12 = ~(v10 - 1) & (v11 + v10 - 1);
  sub_14056DA40(a1 + 0x1198, (__int64)v9, v12);
  v9[5] = 0x1337;
  *v9 = 0;
  v13 = 0x20 * (a3 + 1);
  v9[1] = a3;
  v9[2] = a2;
  v9[4] = v11;
  v9[3] = v12;
  *v9 = *(_QWORD *)(v13 + a1);
  *(_QWORD *)(v13 + a1) = v9;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 0x11C0));
}

// --- End Function: sub_147602270 (0x147602270) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_147602DF0 (0x147602DF0) ---
__int64 __fastcall sub_147602DF0(__int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  __int64 v3; // r12
  __int64 *v4; // rdi
  unsigned __int64 v5; // r11
  unsigned __int128 v9; // rax
  unsigned __int64 v10; // rbx
  __int64 v11; // r9
  __int64 v14; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  _QWORD *v20; // r8
  __int64 v23; // rdx
  __int64 v24; // r9
  __int64 v26; // rbp
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // [rsp+40h] [rbp-68h] BYREF
  __int64 v29; // [rsp+48h] [rbp-60h] BYREF
  __int64 *v30; // [rsp+50h] [rbp-58h] BYREF
  __int64 *v31; // [rsp+58h] [rbp-50h] BYREF
  _BYTE v32[32]; // [rsp+60h] [rbp-48h] BYREF
  _QWORD *v33; // [rsp+B0h] [rbp+8h]

  v3 = *(_QWORD *)(a1 + 0x1270);
  v4 = (__int64 *)(a1 + 0x11F0);
  v5 = *(_QWORD *)(a1 + 0x1208);
  v9 = a2 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = 0;
  v11 = v5 & ((*((_QWORD *)&v9 + 1) + (_QWORD)v9) >> 7);
  _XMM2 = (BYTE8(v9) + (_BYTE)v9) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v14 = *v4;
    _XMM1 = *(_OWORD *)(*v4 + v11);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_6:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      v20 = v33;
      v24 = v14 + v5;
      v23 = v14;
      goto LABEL_11;
    }
    v10 += 0x10LL;
    v11 = v5 & (v10 + v11);
    if ( v10 > v5 )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v18, _EAX);
    LODWORD(v33) = 0;
    v19 = v5 & (v11 + v18);
    v20 = (_QWORD *)(v4[1] + 0x10 * v19);
    if ( *v20 == a2 )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v14 = *v4;
      goto LABEL_6;
    }
  }
  v23 = *v4;
  v24 = *v4 + v19;
LABEL_11:
  if ( v24 == v23 + *(_QWORD *)(a1 + 0x1208) )
  {
    v26 = *(_QWORD *)(a1 + 0x1260);
    v27 = *(_QWORD *)(a1 + 0x1268);
    *(_QWORD *)(a1 + 0x1260) = v26 + 1;
    if ( 0x10 * v26 >= v27 )
    {
      sub_14056DA40(a1 + 0x1270, v3 + v27, *(unsigned int *)(a1 + 0x1284));
      *(_QWORD *)(a1 + 0x1268) += *(unsigned int *)(a1 + 0x1284);
    }
    v28 = a2;
    v30 = (__int64 *)&v28;
    v29 = v26;
    v31 = &v29;
    *(_QWORD *)(v3 + 0x10 * v26) = a2;
    *a3 = v26;
    sub_147601B90(
      v4,
      (__int64)v32,
      &v28,
      (__PAIR128__(a2, a2) * 0xDE5FB9D2630458E9uLL) >> 0x40,
      (int)&byte_14819E9C1,
      &v30,
      &v31);
    return v3 + 0x10 * v26;
  }
  else
  {
    *a3 = v20[1];
    return v3 + 0x10LL * v20[1];
  }
}

// --- End Function: sub_147602DF0 (0x147602DF0) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476030E0 (0x1476030E0) ---
unsigned __int64 __fastcall sub_1476030E0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n32; // eax
  unsigned int n32_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147603270((__int64)&qword_151700CC0, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n32 = 32;
    n32_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n32 = n32_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(32 - n32) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148D699B0[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 16 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3840;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 12);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147604610(&unk_151700CD0[4 * v12]);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1476034A0((__int64)&qword_151700CC0, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_151701F50;
  if ( qword_151701F50 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_151701E50;
    if ( qword_151701E50 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1476030E0 (0x1476030E0) ---

// --- Function: sub_147603270 (0x147603270) ---
__int64 __fastcall sub_147603270(__int64 a1, unsigned __int64 n0xE000)
{
  unsigned __int64 n0xE000_2; // r13
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // rbx
  unsigned __int64 v5; // r12
  __int64 v6; // r15
  __int64 v7; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rsi
  unsigned __int64 v10; // r14
  __int64 v11; // r8
  __int64 v12; // rsi
  __int64 v13; // rax
  __int128 v15; // [rsp+30h] [rbp-40h] BYREF
  double v16; // [rsp+40h] [rbp-30h]
  __int64 v17; // [rsp+48h] [rbp-28h] BYREF
  __int128 v18; // [rsp+50h] [rbp-20h]
  double v19; // [rsp+60h] [rbp-10h]
  double v20; // [rsp+B0h] [rbp+40h] BYREF
  unsigned __int64 n0xE000_1; // [rsp+B8h] [rbp+48h]
  __int64 v22; // [rsp+C0h] [rbp+50h]

  n0xE000_1 = n0xE000;
  n0xE000_2 = n0xE000;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
  v5 = sub_147603A00(n0xE000, 1);
  v6 = ~(*(unsigned int *)(a1 + 0x1284) - 1LL) & (*(unsigned int *)(a1 + 0x1284) + n0xE000_2 - 1);
  v22 = v6;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x12C0));
  v20 = 0.0;
  v7 = sub_147602DF0(a1, v5, &v20);
  v8 = *(_QWORD **)(v7 + 8);
  if ( v8 )
  {
    *(_QWORD *)(v7 + 8) = *v8;
    v9 = v8[1];
    v8[1] = 0;
    *v8 = *(_QWORD *)(a1 + 0x12B8);
    *(_QWORD *)(a1 + 0x12B8) = v8;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 0x1290);
    if ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 )
    {
      do
      {
        v11 = *(unsigned int *)(a1 + 0x12AC);
        v12 = (v11 + 0x17) & ~(v11 - 1);
        *(__m256i *)(a1 + 0x1298) = *(__m256i *)sub_14056DBC0((__int64)&v17, 0x8000000000LL, v11, &off_148D699A8, 1, 0);// "StarAlloc-Large"
        v10 = (*(_QWORD *)(a1 + 0x1298) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
        __asm { vzeroupper }
        sub_14056DA40(a1 + 0x1298, v10, v12);
        *(_WORD *)(v10 + 0x15) = 0;
        *(_BYTE *)(v10 + 0x17) = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)(v10 + 0x10) = 0x1337;
        *(_BYTE *)(v10 + 0x14) = 0;
        *(_QWORD *)(v10 + 8) = v12;
        *(_QWORD *)v10 = *(_QWORD *)(a1 + 0x1290);
        *(_QWORD *)(a1 + 0x1290) = v10;
      }
      while ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 );
      v6 = v22;
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
      n0xE000_2 = n0xE000_1;
    }
    v13 = *(_QWORD *)(v10 + 8);
    v9 = v13 + v10;
    *(_QWORD *)(v10 + 8) = v5 + v13;
  }
  sub_14056DA40(a1 + 0x1270, v9, v6);
  v16 = v20;
  *(_QWORD *)&v15 = n0xE000_2;
  *((_QWORD *)&v15 + 1) = v6;
  v19 = v20;
  v17 = v9;
  v18 = v15;
  sub_1476044E0((__int64 *)(a1 + 0x1228), (__int64)&v15, &v17);
  LeaveCriticalSection(lpCriticalSection);
  return v9;
}

// --- End Function: sub_147603270 (0x147603270) ---

// --- Function: sub_1476034A0 (0x1476034A0) ---
__int64 __fastcall sub_1476034A0(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 n0x10)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 i; // rax
  __int64 v9; // r11
  signed __int32 v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rbp
  unsigned __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r12
  unsigned __int64 v16; // r15
  unsigned __int64 v17; // rax
  _QWORD *v18; // r8
  unsigned __int64 v19; // rax
  int v20; // r9d
  signed __int64 v21; // rdx
  int n2_1; // [rsp+20h] [rbp-48h] BYREF
  __int64 v24; // [rsp+28h] [rbp-40h]
  int n2; // [rsp+78h] [rbp+10h] BYREF
  __int64 v27; // [rsp+80h] [rbp+18h]

  v27 = a3;
  v4 = *(unsigned int *)(a1 + 0x11AC);
  v24 = v4;
  v5 = 0x20 * a3 + a1 + 0x10;
  v6 = a3;
  for ( i = sub_147604610((volatile signed __int64 *)v5); !i; i = sub_147604610((volatile signed __int64 *)v5) )
  {
    v10 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 1, 0) - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        n2 = 2;
        qword_149B3B480(v5 + 0x18, &n2, 4, 0xFFFFFFFFLL);
      }
      else
      {
        v11 = *(_QWORD *)(v5 + 0x10);
        if ( !v11 || 0x2000000LL - *(_QWORD *)(v11 + 0x20) - v4 < a2 )
        {
          sub_147602270(v9, a2, v6);
          v9 = a1;
        }
        v12 = *(_QWORD *)(v5 + 0x10);
        v13 = v12 - v4 + 0x2000000;
        v14 = *(_QWORD *)(v12 + 0x20);
        v15 = v14 + v12;
        if ( v12 + v14 + 0x20 * a2 < v13 )
          v13 = v12 + v14 + 0x20 * a2;
        v16 = ~(v24 - 1) & (v13 - v12 + v4 - 1);
        v17 = *(_QWORD *)(v12 + 0x18);
        if ( v16 > v17 )
        {
          sub_14056DA40(v9 + 0x1198, v17 + v12, v16 - v17);
          *(_QWORD *)(v12 + 0x18) = v16;
        }
        *(_QWORD *)(v12 + 0x20) = v13 - v12;
        v18 = (_QWORD *)(v15 + a2 - 8);
        v19 = v15 + 2 * a2;
        v20 = 1;
        v21 = (signed __int64)v18;
        for ( *v18 = 0; v19 <= v13; v19 += a2 )
        {
          *(_QWORD *)(v19 - 8) = v21;
          ++v20;
          v21 = v19 - 8;
        }
        sub_1476047E0((volatile signed __int64 *)v5, v21, v18, v20);
        if ( _InterlockedExchange((volatile __int32 *)(v5 + 0x18), 0) == 2 )
          qword_149B3B490(v5 + 0x18);
        v6 = v27;
        v4 = v24;
      }
    }
    else if ( (unsigned int)(_InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 2, 1) - 1) <= 1 )
    {
      n2_1 = 2;
      qword_149B3B480(v5 + 0x18, &n2_1, 4, 0xFFFFFFFFLL);
    }
  }
  return i - a2 + 8;
}

// --- End Function: sub_1476034A0 (0x1476034A0) ---

// --- Function: sub_147603A00 (0x147603A00) ---
__int64 __fastcall sub_147603A00(unsigned __int64 n0x10000, char a2)
{
  __int64 result; // rax

  if ( !a2 )
    goto LABEL_18;
  if ( n0x10000 <= 0x10000 )
    return 0x10000;
  if ( n0x10000 <= 0x20000 )
    return 0x20000;
  if ( n0x10000 <= 0x30000 )
    return 0x30000;
  if ( n0x10000 <= 0x40000 )
    return 0x40000;
  if ( n0x10000 <= 0x50000 )
    return 0x50000;
  if ( n0x10000 <= 0x60000 )
    return 0x60000;
  if ( n0x10000 <= 0x70000 )
    return 0x70000;
  if ( n0x10000 <= 0x80000 )
    return 0x80000;
LABEL_18:
  if ( n0x10000 <= 0xA0000 )
    return 0xA0000;
  if ( n0x10000 <= 0xC0000 )
    return 0xC0000;
  if ( n0x10000 <= 0xE0000 )
    return 0xE0000;
  if ( n0x10000 <= 0x100000 )
    return 0x100000;
  if ( n0x10000 <= 0x140000 )
    return 0x140000;
  if ( n0x10000 <= 0x180000 )
    return 0x180000;
  if ( n0x10000 <= 0x1C0000 )
    return 0x1C0000;
  if ( n0x10000 <= 0x200000 )
    return 0x200000;
  if ( n0x10000 <= 0x400000 )
    return 0x400000;
  if ( n0x10000 <= 0x600000 )
    return 0x600000;
  if ( n0x10000 <= 0x800000 )
    return 0x800000;
  if ( n0x10000 <= 0xA00000 )
    return 0xA00000;
  if ( n0x10000 <= 0xC00000 )
    return 0xC00000;
  if ( n0x10000 <= 0xE00000 )
    return 0xE00000;
  if ( n0x10000 <= 0x1000000 )
    return 0x1000000;
  if ( n0x10000 <= 0x1400000 )
    return 0x1400000;
  if ( n0x10000 <= 0x1800000 )
    return 0x1800000;
  if ( n0x10000 <= 0x1C00000 )
    return 0x1C00000;
  if ( n0x10000 <= 0x2000000 )
    return 0x2000000;
  if ( n0x10000 <= 0x2800000 )
    return 0x2800000;
  if ( n0x10000 <= 0x3000000 )
    return 0x3000000;
  if ( n0x10000 <= 0x3800000 )
    return 0x3800000;
  if ( n0x10000 <= 0x4000000 )
    return 0x4000000;
  if ( n0x10000 <= 0x5000000 )
    return 0x5000000;
  if ( n0x10000 <= 0x6000000 )
    return 0x6000000;
  if ( n0x10000 <= 0x7000000 )
    return 0x7000000;
  if ( n0x10000 <= 0x8000000 )
    return 0x8000000;
  if ( n0x10000 <= 0xA000000 )
    return 0xA000000;
  if ( n0x10000 <= 0xC000000 )
    return 0xC000000;
  if ( n0x10000 <= 0xE000000 )
    return 0xE000000;
  if ( n0x10000 <= 0x10000000 )
    return 0x10000000;
  if ( n0x10000 <= 0x14000000 )
    return 0x14000000;
  if ( n0x10000 <= 0x18000000 )
    return 0x18000000;
  if ( n0x10000 <= 0x1C000000 )
    return 0x1C000000;
  if ( n0x10000 <= 0x20000000 )
    return 0x20000000;
  if ( n0x10000 <= 0x28000000 )
    return 0x28000000;
  if ( n0x10000 <= 0x30000000 )
    return 0x30000000;
  if ( n0x10000 <= 0x38000000 )
    return 0x38000000;
  if ( n0x10000 <= 0x40000000 )
    return 0x40000000;
  if ( n0x10000 <= 0x50000000 )
    return 0x50000000;
  if ( n0x10000 <= 0x60000000 )
    return 0x60000000;
  if ( n0x10000 <= 0x70000000 )
    return 0x70000000;
  result = 0x80000000LL;
  if ( n0x10000 > 0x80000000 )
  {
    result = 0xA0000000LL;
    if ( n0x10000 > 0xA0000000 )
    {
      result = 0xC0000000LL;
      if ( n0x10000 > 0xC0000000 )
      {
        result = 0xE0000000LL;
        if ( n0x10000 > 0xE0000000 )
        {
          result = 0x100000000LL;
          if ( n0x10000 > 0x100000000LL )
          {
            result = 0x180000000LL;
            if ( n0x10000 > 0x180000000LL )
            {
              result = 0x200000000LL;
              if ( n0x10000 > 0x200000000LL )
              {
                result = 0x280000000LL;
                if ( n0x10000 > 0x280000000LL )
                {
                  result = 0x300000000LL;
                  if ( n0x10000 > 0x300000000LL )
                  {
                    result = 0x380000000LL;
                    if ( n0x10000 > 0x380000000LL )
                    {
                      result = 0x400000000LL;
                      if ( n0x10000 > 0x400000000LL )
                      {
                        result = 0x500000000LL;
                        if ( n0x10000 > 0x500000000LL )
                        {
                          result = 0x600000000LL;
                          if ( n0x10000 > 0x600000000LL )
                          {
                            result = 0x700000000LL;
                            if ( n0x10000 > 0x700000000LL )
                            {
                              result = 0x800000000LL;
                              if ( n0x10000 > 0x800000000LL )
                              {
                                result = 0xA00000000LL;
                                if ( n0x10000 > 0xA00000000LL )
                                {
                                  result = 0xC00000000LL;
                                  if ( n0x10000 > 0xC00000000LL )
                                  {
                                    result = 0xE00000000LL;
                                    if ( n0x10000 > 0xE00000000LL )
                                    {
                                      result = 0x1000000000LL;
                                      if ( n0x10000 > 0x1000000000LL )
                                      {
                                        result = 0x1400000000LL;
                                        if ( n0x10000 > 0x1400000000LL )
                                        {
                                          result = 0x1800000000LL;
                                          if ( n0x10000 > 0x1800000000LL )
                                          {
                                            result = 0x1C00000000LL;
                                            if ( n0x10000 > 0x1C00000000LL )
                                            {
                                              result = 0x2000000000LL;
                                              if ( n0x10000 > 0x2000000000LL )
                                              {
                                                result = 0x2800000000LL;
                                                if ( n0x10000 > 0x2800000000LL )
                                                {
                                                  result = 0x3000000000LL;
                                                  if ( n0x10000 > 0x3000000000LL )
                                                  {
                                                    result = 0x3800000000LL;
                                                    if ( n0x10000 > 0x3800000000LL )
                                                    {
                                                      result = 0x4000000000LL;
                                                      if ( n0x10000 > 0x4000000000LL )
                                                      {
                                                        _XMM0 = 0;
                                                        if ( (n0x10000 & 0x8000000000000000uLL) != 0LL )
                                                        {
                                                          __asm { vcvtsi2sd xmm0, xmm0, rax }
                                                          *(double *)&_XMM0 = *(double *)&_XMM0 + *(double *)&_XMM0;
                                                        }
                                                        else
                                                        {
                                                          __asm { vcvtsi2sd xmm0, xmm0, rcx }
                                                        }
                                                        LogFatalError(
                                                          "StarAlloc: Requested Allocation Size %.2f MB is larger than su"
                                                          "pported by StarAlloc",
                                                          *(double *)&_XMM0 * 0.00000095367431640625);
                                                        return 0;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_147603A00 (0x147603A00) ---

// --- Function: sub_1476044E0 (0x1476044E0) ---
__int64 __fastcall sub_1476044E0(__int64 *a1, __int64 a2, __int64 *a3)
{
  double v3; // r9
  __int128 v4; // xmm0
  double v5; // xmm1_8
  unsigned __int128 v7; // rax
  __int128 v8; // xmm0
  __int64 result; // rax
  double *v10; // [rsp+40h] [rbp-58h] BYREF
  __int128 *v11; // [rsp+48h] [rbp-50h] BYREF
  __int128 v12; // [rsp+50h] [rbp-48h] BYREF
  char v13; // [rsp+60h] [rbp-38h]
  double v14; // [rsp+68h] [rbp-30h] BYREF
  __int128 v15; // [rsp+70h] [rbp-28h] BYREF
  double v16; // [rsp+80h] [rbp-18h]

  v3 = *(double *)a3;
  v4 = *(_OWORD *)(a3 + 1);
  v5 = *((double *)a3 + 3);
  v10 = &v14;
  v14 = v3;
  v11 = &v15;
  v15 = v4;
  v7 = 0x100000001B3LL
     * (HIBYTE(*(_QWORD *)&v3)
      ^ (0x100000001B3LL
       * (BYTE6(v3)
        ^ (0x100000001B3LL
         * (BYTE5(v3)
          ^ (0x100000001B3LL
           * (BYTE4(v3)
            ^ (0x100000001B3LL
             * (BYTE3(v3)
              ^ (0x100000001B3LL
               * (BYTE2(v3) ^ (0x100000001B3LL * ((0x100000001B3LL * (LOBYTE(v3) ^ 0xCBF29CE484222325uLL)) ^ BYTE1(v3))))))))))))))
     * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v16 = v5;
  sub_147601A00(
    a1,
    (__int64)&v12,
    &v14,
    v7 + *((_QWORD *)&v7 + 1),
    (int)&byte_14819E9C1,
    (_QWORD **)&v10,
    (__int64 *)&v11);
  v8 = v12;
  *(_BYTE *)(a2 + 0x10) = v13;
  result = a2;
  *(_OWORD *)a2 = v8;
  return result;
}

// --- End Function: sub_1476044E0 (0x1476044E0) ---

// --- Function: sub_147604610 (0x147604610) ---
__int64 __fastcall sub_147604610(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __int32 v5; // edx
  __m128i v6; // rt0
  signed __int64 v8; // [rsp+18h] [rbp-40h]
  __m128i v9; // [rsp+30h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    LODWORD(v8) = epi64 + 1;
    HIDWORD(v8) = HIDWORD(epi64) - 1;
    v6.m128i_i64[0] = v2.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v8, *(_QWORD *)v2.m128i_i64[0], v6.m128i_i64);
    v4 = v6.m128i_i64[0];
    v5 = v6.m128i_i32[2];
    v9 = v6;
    if ( v6.m128i_i64[0] == v2.m128i_i64[0] && v5 == (_DWORD)epi64 )
      break;
    v2 = v9;
    if ( !v4 )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_147604610 (0x147604610) ---

// --- Function: sub_1476047E0 (0x1476047E0) ---
__int64 __fastcall sub_1476047E0(volatile signed __int64 *a1, signed __int64 a2, _QWORD *a3, int a4)
{
  __m128i v6; // rt0
  __m128i i; // xmm0
  signed __int64 epi64; // r9
  __int64 result; // rax
  __int32 v10; // edx
  __m128i v11; // rt0
  signed __int64 v12; // [rsp+18h] [rbp-50h]
  __m128i v13; // [rsp+30h] [rbp-38h]

  v6 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v6.m128i_i64);
  for ( i = v6; ; i = v13 )
  {
    epi64 = _mm_extract_epi64(i, 1);
    *a3 = i.m128i_i64[0];
    LODWORD(v12) = epi64 + 1;
    HIDWORD(v12) = a4 + HIDWORD(epi64);
    v11.m128i_i64[0] = i.m128i_i64[0];
    v11.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v12, a2, v11.m128i_i64);
    result = v11.m128i_i64[0];
    v10 = v11.m128i_i32[2];
    v13 = v11;
    if ( v11.m128i_i64[0] == i.m128i_i64[0] && v10 == (_DWORD)epi64 )
      break;
  }
  return result;
}

// --- End Function: sub_1476047E0 (0x1476047E0) ---

// --- Function: sub_1476048B0 (0x1476048B0) ---
unsigned __int64 __fastcall sub_1476048B0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  unsigned __int64 v14; // r10
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  unsigned __int64 result; // rax

  _XMM6 = xmmword_14819F440;
  v4 = 0;
  v5 = a2 >> 7;
  v6 = 0;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 0x10;
    v9 = v7 & (v6 + v9);
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = v7 & (v9 + v13);
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_1476041E0((__int64)a1);
LABEL_11:
        v18 = a1[3];
        v19 = 0;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 0x10;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = v18 & (v20 + _RAX);
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1;
    }
    sub_147604B10(a1, v17);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_1476048B0 (0x1476048B0) ---

// --- Function: sub_1476049E0 (0x1476049E0) ---
unsigned __int64 __fastcall sub_1476049E0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  unsigned __int64 v14; // r10
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  unsigned __int64 result; // rax

  _XMM6 = xmmword_14819F440;
  v4 = 0;
  v5 = a2 >> 7;
  v6 = 0;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 0x10;
    v9 = v7 & (v6 + v9);
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = v7 & (v9 + v13);
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_140828B50((__int64)a1);
LABEL_11:
        v18 = a1[3];
        v19 = 0;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 0x10;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = v18 & (v20 + _RAX);
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1;
    }
    sub_147604DE0(a1, v17);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_1476049E0 (0x1476049E0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
// Standard stack security check function. Compares the provided stack cookie with
// the global security cookie. If a mismatch is detected or the cookie is
// corrupted, it triggers a security failure report.
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: __vdecl_sinf4 (0x148033BF0) ---
__int64 _vdecl_sinf4()
{
  if ( n5 >= 2 )
    return _sse4_sinf4();
  else
    return _sse2_sinf4();
}

// --- End Function: __vdecl_sinf4 (0x148033BF0) ---

// --- Function: __libm_sse2_sincosf_ (0x148033C10) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall _libm_sse2_sincosf_(float a1, __int64 a2, double a3)
{
  __int64 result; // rax

  *(float *)&a3 = a1;
  if ( *(float *)_mm_and_si128(*(__m128i *)&a3, (__m128i)xmmword_14935F690).m128i_i32 >= 0.00012207031 )
    return _vdecl_sinf4();
  return result;
}

// --- End Function: __libm_sse2_sincosf_ (0x148033C10) ---

// --- Function: __libm_sse2_sincosf4_ (0x148033C53) ---
// local variable allocation has failed, the output may be wrong!
double __fastcall _libm_sse2_sincosf4_(double a1, double a2, __int64 a3, __int64 a4, int a5)
{
  double result; // xmm0_8

  *(_QWORD *)&result = _mm_add_ps(_mm_shuffle_ps(*(__m128 *)&a1, *(__m128 *)&a2, 0), (__m128)xmmword_14935F6E0).m128_u64[0];
  _vdecl_sinf4();
  return result;
}

// --- End Function: __libm_sse2_sincosf4_ (0x148033C53) ---

// --- Function: __sse2_sinf4@@16 (0x148034840) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall _sse2_sinf4(double a1, __int64 a2, __int64 a3)
{
  void *v3; // r9
  int v4; // r10d
  _OWORD *v5; // r13
  __m128 v6; // xmm8
  __m128 v7; // xmm6
  __m128 v8; // xmm5
  __m128 v9; // xmm10
  __m128 v10; // xmm3
  __m128 v11; // xmm10
  __m128 v12; // xmm1
  __int64 result; // rax
  __m128 v14; // xmm10
  __int64 n4; // rbx
  int v16; // esi
  __m128i v17; // xmm12
  __m128i v18; // xmm7
  unsigned int v19; // edx
  unsigned int v20; // eax
  unsigned int v21; // r8d
  unsigned int v22; // ecx
  __m128i v23; // xmm1
  __m128i v24; // xmm3
  __m128i v25; // xmm8
  __m128i v26; // xmm4
  __m128i v27; // xmm11
  __m128i v28; // xmm7
  __m128i v29; // xmm12
  __m128i v30; // xmm8
  __m128i v31; // xmm12
  __m128i v32; // xmm14
  __m128i v33; // xmm13
  __m128i v34; // xmm10
  __m128i v35; // xmm12
  __m128i v36; // xmm15
  __m128i v37; // xmm0
  __m128i v38; // xmm9
  __m128i v39; // xmm8
  __m128i v40; // xmm5
  __m128i v41; // xmm2
  __m128i v42; // xmm4
  __m128i v43; // xmm1
  __m128i v44; // xmm11
  __m128i v45; // xmm2
  __m128i v46; // xmm3
  __m128i v47; // xmm6
  __m128i v48; // xmm0
  __m128i v49; // xmm2
  __m128i v50; // xmm9
  __m128i v51; // xmm11
  __m128i v52; // xmm15
  __m128i v53; // xmm13
  __m128i v54; // xmm6
  __m128i v55; // xmm5
  __m128i v56; // xmm1
  __m128i v57; // xmm3
  __m128i v58; // xmm13
  __m128i v59; // xmm9
  __m128 v60; // xmm5
  __m128 v61; // xmm7
  __m128 v62; // xmm1
  __m128 v63; // xmm9
  __m128 v64; // xmm2
  __m128 v65; // xmm10
  __m128 v66; // xmm6
  __m128 v67; // xmm11
  __m128 v68; // xmm1
  __m128 v69; // xmm5
  __m128 v70; // xmm12
  __m128 v71; // xmm8
  __m128 v72; // xmm6
  __m128 v73; // xmm13
  __m128 v74; // xmm7
  __m128 v75; // xmm12
  __m128 v76; // xmm8
  __m128i v77; // xmm2
  __m128 v78; // xmm12
  __m128 v79; // xmm4
  __m128 v80; // xmm11
  unsigned int v81; // edx
  unsigned int v82; // ecx
  __m128 v83; // xmm12
  __m128 v84; // xmm11
  __m128 v85; // xmm7
  __m128 v86; // xmm1
  __m128 v87; // xmm15
  __m128 v88; // xmm10
  __m128 v89; // xmm4
  __m128 v90; // xmm14
  __m128 v91; // xmm9
  __m128 v92; // xmm13
  __m128 v93; // xmm7
  __m128 v94; // [rsp+20h] [rbp-1D8h]
  __m128 v95; // [rsp+30h] [rbp-1C8h]
  __m128 v96; // [rsp+40h] [rbp-1B8h]
  __m128i v97; // [rsp+50h] [rbp-1A8h] BYREF
  __m128i v98; // [rsp+60h] [rbp-198h]
  __m128i v99[2]; // [rsp+70h] [rbp-188h] BYREF
  __m128i v100; // [rsp+90h] [rbp-168h] BYREF
  __m128i v101[4]; // [rsp+A0h] [rbp-158h] BYREF
  _BYTE v102[81]; // [rsp+EFh] [rbp-109h] BYREF
  unsigned __int64 v103; // [rsp+1E8h] [rbp-10h]

  v3 = &unk_151D25500;
  v4 = 0;
  v5 = (_OWORD *)((unsigned __int64)v102 & 0xFFFFFFFFFFFFFFC0uLL);
  v6 = _mm_and_ps(*(__m128 *)&a1, (__m128)xmmword_151D27100);
  v7 = _mm_add_ps(_mm_mul_ps((__m128)xmmword_151D27580, v6), (__m128)xmmword_151D275C0);
  v8 = _mm_sub_ps(v7, (__m128)xmmword_151D275C0);
  v9 = _mm_sub_ps(
         _mm_sub_ps(
           _mm_sub_ps(
             _mm_sub_ps(v6, _mm_mul_ps((__m128)xmmword_151D272C0, v8)),
             _mm_mul_ps((__m128)xmmword_151D27300, v8)),
           _mm_mul_ps((__m128)xmmword_151D27340, v8)),
         _mm_mul_ps((__m128)xmmword_151D27380, v8));
  v10 = _mm_mul_ps(v9, v9);
  v11 = (__m128)_mm_xor_si128((__m128i)v9, _mm_slli_epi32((__m128i)v7, 0x1Fu));
  v12 = _mm_cmpnle_ps(v6, (__m128)xmmword_151D27140);
  result = (unsigned int)_mm_movemask_ps(v12);
  v103 = (unsigned __int64)v102 & 0xFFFFFFFFFFFFFFC0uLL;
  v14 = (__m128)_mm_xor_si128(
                  (__m128i)_mm_add_ps(
                             v11,
                             _mm_mul_ps(
                               _mm_mul_ps(
                                 v10,
                                 _mm_add_ps(
                                   _mm_mul_ps(
                                     _mm_add_ps(
                                       _mm_mul_ps(
                                         _mm_add_ps(
                                           _mm_mul_ps((__m128)xmmword_151D27540, v10),
                                           (__m128)xmmword_151D27500),
                                         v10),
                                       (__m128)xmmword_151D274C0),
                                     v10),
                                   (__m128)xmmword_151D27480)),
                               v11)),
                  (__m128i)_mm_andnot_ps((__m128)xmmword_151D27100, *(__m128 *)&a1));
  if ( (_DWORD)result )
  {
    v96 = v14;
    v17 = _mm_srli_epi32(_mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x7F800000u), 0), *(__m128i *)&a1), 0x17u);
    v18 = _mm_slli_epi32(_mm_add_epi32(_mm_slli_epi32(v17, 1u), v17), 2u);
    v19 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v18, 2));
    v20 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v18, 3));
    v21 = _mm_cvtsi128_si32(v18);
    v22 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v18, 1));
    v95 = v12;
    v23 = _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v19 + 4));
    v24 = _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v20 + 4));
    v4 = _mm_movemask_ps(_mm_cmpeq_ps(_mm_and_ps(v6, (__m128)xmmword_151D27180), (__m128)xmmword_151D27180));
    v94 = *(__m128 *)&a1;
    v25 = _mm_unpacklo_epi64(
            _mm_unpacklo_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v21)),
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v22))),
            _mm_unpacklo_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v19)),
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v20))));
    v26 = _mm_unpacklo_epi32(
            _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v21 + 8)),
            _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v22 + 8)));
    v27 = _mm_unpacklo_epi32(
            _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v19 + 8)),
            _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v20 + 8)));
    v28 = _mm_shuffle_epi32(_mm_cvtsi32_si128(0xFFFFu), 0);
    v29 = _mm_srli_epi32(v25, 0x10u);
    v30 = _mm_and_si128(v25, v28);
    v97 = v29;
    v31 = _mm_add_epi32(
            _mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x7FFFFFu), 0), *(__m128i *)&a1),
            _mm_shuffle_epi32(_mm_cvtsi32_si128(0x800000u), 0));
    v32 = _mm_and_si128(v31, v28);
    v33 = _mm_srli_epi64(v30, 0x20u);
    v34 = _mm_srli_epi64(v32, 0x20u);
    v35 = _mm_srli_epi32(v31, 0x10u);
    v3 = &unk_151D26100;
    v36 = _mm_mul_epu32(v32, v30);
    v37 = _mm_unpacklo_epi64(
            _mm_unpacklo_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v21 + 4)),
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v22 + 4))),
            _mm_unpacklo_epi32(v23, v24));
    v38 = _mm_and_si128(v37, v28);
    v98 = v30;
    v39 = _mm_loadu_si128((const __m128i *)&xmmword_151D23000);
    v101[0] = _mm_or_si128(_mm_and_si128(v36, v39), _mm_slli_epi64(_mm_mul_epu32(v34, v33), 0x20u));
    v40 = _mm_srli_epi64(v38, 0x20u);
    v99[0] = _mm_srli_epi32(v37, 0x10u);
    v100 = _mm_srli_epi64(v99[0], 0x20u);
    v41 = _mm_unpacklo_epi64(v26, v27);
    v42 = _mm_and_si128(v41, v28);
    v43 = _mm_or_si128(_mm_and_si128(_mm_mul_epu32(v32, v38), v39), _mm_slli_epi64(_mm_mul_epu32(v34, v40), 0x20u));
    v44 = _mm_srli_epi64(v35, 0x20u);
    v45 = _mm_srli_epi32(v41, 0x10u);
    v99[1] = v33;
    v46 = _mm_srli_epi64(v45, 0x20u);
    v47 = _mm_or_si128(_mm_and_si128(_mm_mul_epu32(v32, v99[0]), v39), _mm_slli_epi64(_mm_mul_epu32(v34, v100), 0x20u));
    v48 = _mm_add_epi32(
            _mm_srli_epi32(
              _mm_or_si128(
                _mm_and_si128(_mm_mul_epu32(v35, v42), v39),
                _mm_slli_epi64(_mm_mul_epu32(_mm_srli_epi64(v42, 0x20u), v44), 0x20u)),
              0x10u),
            _mm_add_epi32(
              _mm_and_si128(v43, v28),
              _mm_add_epi32(
                _mm_or_si128(
                  _mm_and_si128(_mm_mul_epu32(v35, v45), v39),
                  _mm_slli_epi64(_mm_mul_epu32(v44, v46), 0x20u)),
                _mm_srli_epi32(
                  _mm_or_si128(
                    _mm_and_si128(_mm_mul_epu32(v45, v32), v39),
                    _mm_slli_epi64(_mm_mul_epu32(v46, v34), 0x20u)),
                  0x10u))));
    v49 = _mm_add_epi32(
            _mm_and_si128(v47, v28),
            _mm_add_epi32(
              _mm_or_si128(_mm_and_si128(_mm_mul_epu32(v38, v35), v39), _mm_slli_epi64(_mm_mul_epu32(v40, v44), 0x20u)),
              _mm_srli_epi32(v43, 0x10u)));
    v50 = _mm_mul_epu32(_mm_loadu_si128(&v100), v44);
    v51 = _mm_mul_epu32(v44, v33);
    v52 = _mm_add_epi32(
            _mm_or_si128(_mm_and_si128(_mm_mul_epu32(_mm_loadu_si128(v99), v35), v39), _mm_slli_epi64(v50, 0x20u)),
            _mm_srli_epi32(v47, 0x10u));
    v53 = _mm_add_epi32(_mm_srli_epi32(v48, 0x10u), v49);
    v54 = _mm_loadu_si128(&v97);
    v55 = _mm_loadu_si128(v101);
    v56 = _mm_add_epi32(_mm_srli_epi32(v53, 0x10u), _mm_add_epi32(_mm_and_si128(v55, v28), v52));
    v57 = _mm_add_epi32(
            _mm_slli_epi32(
              _mm_add_epi32(
                _mm_srli_epi32(v56, 0x10u),
                _mm_add_epi32(
                  _mm_and_si128(
                    _mm_or_si128(
                      _mm_and_si128(_mm_mul_epu32(v32, v54), v39),
                      _mm_slli_epi64(_mm_mul_epu32(v34, _mm_srli_epi64(v54, 0x20u)), 0x20u)),
                    v28),
                  _mm_add_epi32(
                    _mm_or_si128(_mm_and_si128(_mm_mul_epu32(v35, v98), v39), _mm_slli_epi64(v51, 0x20u)),
                    _mm_srli_epi32(v55, 0x10u)))),
              0x10u),
            _mm_and_si128(v56, v28));
    v58 = _mm_add_epi32(_mm_slli_epi32(v53, 0x10u), _mm_and_si128(v48, v28));
    *(__m128 *)&a1 = v94;
    v59 = _mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x80000000), 0), (__m128i)v94);
    v60 = (__m128)_mm_or_si128(
                    _mm_srli_epi32(v57, 9u),
                    _mm_xor_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x3F800000u), 0), v59));
    v61 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x47400000u), 0);
    v62 = (__m128)_mm_xor_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x28800000u), 0), v59);
    v63 = (__m128)_mm_xor_si128(v59, _mm_shuffle_epi32(_mm_cvtsi32_si128(0x34000000u), 0));
    v64 = _mm_add_ps(v60, v61);
    v65 = _mm_sub_ps(
            (__m128)_mm_or_si128(
                      _mm_or_si128(
                        _mm_slli_epi32(_mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x1FFu), 0), v57), 0xEu),
                        _mm_srli_epi32(v58, 0x12u)),
                      (__m128i)v63),
            v63);
    v66 = _mm_sub_ps(
            (__m128)_mm_or_si128(
                      _mm_slli_epi32(_mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x3FFFFu), 0), v58), 5u),
                      (__m128i)v62),
            v62);
    v67 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0xB795777A), 0);
    v68 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x35800000u), 0);
    v69 = _mm_sub_ps(v60, _mm_sub_ps(v64, v61));
    v70 = _mm_add_ps(v69, v65);
    v71 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x40C91000u), 0);
    v72 = _mm_add_ps(v66, _mm_add_ps(v65, _mm_sub_ps(v69, v70)));
    v73 = _mm_and_ps((__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0xFFFFF000), 0), v70);
    v74 = _mm_mul_ps(v71, v73);
    v75 = _mm_sub_ps(v70, v73);
    v76 = _mm_add_ps(
            _mm_add_ps(_mm_mul_ps(v71, v75), _mm_mul_ps(v73, v67)),
            _mm_add_ps(
              _mm_mul_ps((__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x40C90FDBu), 0), v72),
              _mm_mul_ps(v67, v75)));
    v77 = _mm_slli_epi32(_mm_and_si128((__m128i)v64, _mm_shuffle_epi32(_mm_cvtsi32_si128(0xFFu), 0)), 4u);
    v78 = _mm_and_ps((__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x7FFFFFFFu), 0), v94);
    v79 = _mm_add_ps(v76, v74);
    v80 = _mm_cmplt_ps(v68, v78);
    v81 = _mm_cvtsi128_si32(v77);
    v82 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v77, 2));
    v83 = _mm_or_ps(_mm_and_ps(_mm_cmple_ps(v78, v68), v94), _mm_and_ps(v79, v80));
    v84 = _mm_and_ps(v80, _mm_add_ps(v76, _mm_sub_ps(v74, v79)));
    a3 = (unsigned int)_mm_cvtsi128_si32(_mm_shuffle_epi32(v77, 3));
    result = (unsigned int)_mm_cvtsi128_si32(_mm_shuffle_epi32(v77, 1));
    v85 = (__m128)_mm_unpacklo_epi64(
                    _mm_unpacklo_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v81)),
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result))),
                    _mm_unpacklo_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v82)),
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3))));
    v86 = (__m128)_mm_unpacklo_epi64(
                    _mm_unpacklo_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v81 + 0xC)),
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result + 0xC))),
                    _mm_unpacklo_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v82 + 0xC)),
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3 + 0xC))));
    v87 = _mm_mul_ps(v83, v86);
    v88 = _mm_mul_ps(v83, v83);
    v89 = _mm_mul_ps(v83, v85);
    v90 = (__m128)_mm_unpacklo_pd(
                    (__m128d)_mm_unpacklo_epi32(
                               _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v81 + 4)),
                               _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result + 4))),
                    (__m128d)_mm_unpacklo_epi32(
                               _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v82 + 4)),
                               _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3 + 4))));
    v91 = _mm_add_ps(v90, v87);
    v92 = _mm_add_ps(v91, v89);
    v93 = _mm_sub_ps(_mm_add_ps(v85, v86), _mm_mul_ps(v83, v90));
    v14 = _mm_or_ps(
            _mm_andnot_ps(v95, v96),
            _mm_and_ps(
              _mm_add_ps(
                v92,
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_add_ps(
                      (__m128)_mm_unpacklo_epi64(
                                _mm_unpacklo_epi32(
                                  _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v81 + 8)),
                                  _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result + 8))),
                                _mm_unpacklo_epi32(
                                  _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v82 + 8)),
                                  _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3 + 8)))),
                      _mm_mul_ps(v84, v93)),
                    _mm_mul_ps(
                      v90,
                      _mm_mul_ps(v88, _mm_add_ps(_mm_mul_ps((__m128)xmmword_151D27280, v88), (__m128)xmmword_151D27240)))),
                  _mm_add_ps(
                    _mm_add_ps(_mm_add_ps(v87, _mm_sub_ps(v90, v91)), _mm_add_ps(v89, _mm_sub_ps(v91, v92))),
                    _mm_mul_ps(
                      _mm_mul_ps(
                        _mm_mul_ps(
                          _mm_add_ps(_mm_mul_ps((__m128)xmmword_151D27200, v88), (__m128)xmmword_151D271C0),
                          v88),
                        v83),
                      v93)))),
              v95));
  }
  if ( v4 )
  {
    *v5 = *(_OWORD *)&a1;
    *(__m128 *)(((unsigned __int64)v102 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40) = v14;
    result = 0;
    n4 = 0;
    v16 = v4;
    do
    {
      if ( _bittest(&v16, n4) )
        result = _common_ssin_cout_rare((char *)v5 + 4 * n4, (char *)v5 + 4 * n4 + 0x40, a3, v3);
      n4 = (unsigned int)(n4 + 1);
    }
    while ( (int)n4 < 4 );
  }
  return result;
}

// --- End Function: __sse2_sinf4@@16 (0x148034840) ---

// --- Function: __sse4_sinf4@@16 (0x148035180) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall _sse4_sinf4(double a1, __int64 a2, __int64 a3)
{
  __m128 v3; // xmm2
  void *v4; // r9
  int v5; // r10d
  _OWORD *v6; // r13
  __m128 v7; // xmm9
  __m128 v8; // xmm8
  __m128 v9; // xmm0
  __m128 v10; // xmm7
  __m128 v11; // xmm6
  __int64 result; // rax
  __m128 v13; // xmm10
  __m128 v14; // xmm4
  __m128 v15; // xmm10
  __m128 v16; // xmm10
  __int64 n4; // rbx
  int v18; // esi
  __m128i v19; // xmm12
  __m128i v20; // xmm9
  unsigned int v21; // r8d
  unsigned int epi32; // edx
  unsigned int v23; // ecx
  unsigned int v24; // eax
  __m128i v25; // xmm10
  __m128i v26; // xmm11
  __m128i v27; // xmm15
  __m128i v28; // xmm7
  __m128i v29; // xmm5
  __m128i v30; // xmm13
  __m128i v31; // xmm14
  __m128i v32; // xmm4
  __m128i v33; // xmm3
  __m128i v34; // xmm14
  __m128i v35; // xmm11
  __m128i v36; // xmm8
  __m128i v37; // xmm9
  __m128i v38; // xmm10
  __m128i v39; // xmm5
  __m128i v40; // xmm6
  __m128i v41; // xmm1
  __m128i v42; // xmm8
  __m128i v43; // xmm15
  __m128i v44; // xmm1
  __m128i v45; // xmm12
  __m128 v46; // xmm13
  __m128 v47; // xmm7
  __m128 v48; // xmm9
  __m128 v49; // xmm14
  __m128 v50; // xmm12
  __m128 v51; // xmm10
  __m128 v52; // xmm8
  __m128 v53; // xmm13
  __m128 v54; // xmm6
  __m128 v55; // xmm5
  __m128 v56; // xmm13
  __m128 v57; // xmm6
  __m128 v58; // xmm11
  __m128 v59; // xmm1
  __m128 v60; // xmm3
  __m128 v61; // xmm9
  __m128 v62; // xmm10
  __m128 v63; // xmm13
  __m128 v64; // xmm15
  __m128 v65; // xmm8
  __m128 v66; // xmm10
  __m128 v67; // xmm15
  __m128 v68; // xmm8
  __m128 v69; // xmm9
  __m128i v70; // xmm14
  unsigned int v71; // edx
  __m128 v72; // xmm7
  unsigned int v73; // ecx
  __m128 v74; // xmm5
  __m128 v75; // xmm12
  __m128 v76; // xmm3
  __m128 v77; // xmm10
  __m128 v78; // xmm6
  __m128 v79; // xmm11
  __m128 v80; // xmm4
  __m128 v81; // xmm6
  __m128 v82; // [rsp+20h] [rbp-158h]
  _BYTE v83[81]; // [rsp+6Fh] [rbp-109h] BYREF
  unsigned __int64 v84; // [rsp+168h] [rbp-10h]

  v3 = *(__m128 *)&a1;
  v4 = &unk_151D25500;
  v5 = 0;
  v6 = (_OWORD *)((unsigned __int64)v83 & 0xFFFFFFFFFFFFFFC0uLL);
  v7 = _mm_and_ps(*(__m128 *)&a1, (__m128)xmmword_151D27100);
  v8 = _mm_andnot_ps((__m128)xmmword_151D27100, *(__m128 *)&a1);
  v9 = _mm_cmpnle_ps(v7, (__m128)xmmword_151D27140);
  v10 = _mm_add_ps(_mm_mul_ps((__m128)xmmword_151D27580, v7), (__m128)xmmword_151D275C0);
  v11 = _mm_sub_ps(v10, (__m128)xmmword_151D275C0);
  result = (unsigned int)_mm_movemask_ps(v9);
  v13 = _mm_sub_ps(
          _mm_sub_ps(
            _mm_sub_ps(
              _mm_sub_ps(v7, _mm_mul_ps((__m128)xmmword_151D272C0, v11)),
              _mm_mul_ps((__m128)xmmword_151D27300, v11)),
            _mm_mul_ps((__m128)xmmword_151D27340, v11)),
          _mm_mul_ps((__m128)xmmword_151D27380, v11));
  v14 = _mm_mul_ps(v13, v13);
  v15 = _mm_xor_ps(v13, (__m128)_mm_slli_epi32((__m128i)v10, 0x1Fu));
  v84 = (unsigned __int64)v83 & 0xFFFFFFFFFFFFFFC0uLL;
  v16 = _mm_xor_ps(
          _mm_add_ps(
            v15,
            _mm_mul_ps(
              _mm_mul_ps(
                v14,
                _mm_add_ps(
                  _mm_mul_ps(
                    _mm_add_ps(
                      _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_151D27540, v14), (__m128)xmmword_151D27500), v14),
                      (__m128)xmmword_151D274C0),
                    v14),
                  (__m128)xmmword_151D27480)),
              v15)),
          v8);
  if ( (_DWORD)result )
  {
    v19 = _mm_srli_epi32(_mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x7F800000u), 0), (__m128i)v3), 0x17u);
    v5 = _mm_movemask_ps(_mm_cmpeq_ps(_mm_and_ps(v7, (__m128)xmmword_151D27180), (__m128)xmmword_151D27180));
    v20 = _mm_slli_epi32(_mm_add_epi32(_mm_slli_epi32(v19, 1u), v19), 2u);
    v21 = _mm_cvtsi128_si32(v20);
    v82 = v16;
    epi32 = _mm_extract_epi32(v20, 2);
    v23 = _mm_extract_epi32(v20, 1);
    v24 = _mm_extract_epi32(v20, 3);
    v4 = &unk_151D26100;
    v25 = _mm_unpacklo_epi64(
            _mm_insert_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v21 + 8)),
              *(_DWORD *)((char *)&unk_151D25500 + v23 + 8),
              1),
            _mm_insert_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + epi32 + 8)),
              *(_DWORD *)((char *)&unk_151D25500 + v24 + 8),
              1));
    v26 = _mm_unpacklo_epi64(
            _mm_insert_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v21 + 4)),
              *(_DWORD *)((char *)&unk_151D25500 + v23 + 4),
              1),
            _mm_insert_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + epi32 + 4)),
              *(_DWORD *)((char *)&unk_151D25500 + v24 + 4),
              1));
    v27 = _mm_srli_epi32(v25, 0x10u);
    v28 = _mm_srli_epi32(v26, 0x10u);
    v29 = _mm_unpacklo_epi64(
            _mm_insert_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + v21)),
              *(_DWORD *)((char *)&unk_151D25500 + v23),
              1),
            _mm_insert_epi32(
              _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D25500 + epi32)),
              *(_DWORD *)((char *)&unk_151D25500 + v24),
              1));
    v30 = _mm_srli_epi32(v29, 0x10u);
    v31 = _mm_add_epi32(
            _mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x7FFFFFu), 0), (__m128i)v3),
            _mm_shuffle_epi32(_mm_cvtsi32_si128(0x800000u), 0));
    v32 = _mm_shuffle_epi32(_mm_cvtsi32_si128(0xFFFFu), 0);
    v33 = _mm_srli_epi32(v31, 0x10u);
    v34 = _mm_and_si128(v31, v32);
    v35 = _mm_and_si128(v26, v32);
    v36 = _mm_mullo_epi32(v34, v35);
    v37 = _mm_mullo_epi32(v34, v28);
    v38 = _mm_add_epi32(
            _mm_srli_epi32(_mm_mullo_epi32(_mm_and_si128(v25, v32), v33), 0x10u),
            _mm_add_epi32(
              _mm_and_si128(v36, v32),
              _mm_add_epi32(_mm_mullo_epi32(v33, v27), _mm_srli_epi32(_mm_mullo_epi32(v27, v34), 0x10u))));
    v39 = _mm_and_si128(v29, v32);
    v40 = _mm_mullo_epi32(v34, v39);
    v41 = _mm_add_epi32(
            _mm_srli_epi32(v38, 0x10u),
            _mm_add_epi32(_mm_and_si128(v37, v32), _mm_add_epi32(_mm_mullo_epi32(v35, v33), _mm_srli_epi32(v36, 0x10u))));
    v42 = _mm_add_epi32(
            _mm_srli_epi32(v41, 0x10u),
            _mm_add_epi32(_mm_and_si128(v40, v32), _mm_add_epi32(_mm_mullo_epi32(v28, v33), _mm_srli_epi32(v37, 0x10u))));
    v43 = _mm_add_epi32(
            _mm_slli_epi32(
              _mm_add_epi32(
                _mm_srli_epi32(v42, 0x10u),
                _mm_add_epi32(
                  _mm_and_si128(_mm_mullo_epi32(v34, v30), v32),
                  _mm_add_epi32(_mm_mullo_epi32(v33, v39), _mm_srli_epi32(v40, 0x10u)))),
              0x10u),
            _mm_and_si128(v42, v32));
    v44 = _mm_add_epi32(_mm_slli_epi32(v41, 0x10u), _mm_and_si128(v38, v32));
    v45 = _mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x80000000), 0), (__m128i)v3);
    v46 = (__m128)_mm_or_si128(
                    _mm_srli_epi32(v43, 9u),
                    _mm_xor_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x3F800000u), 0), v45));
    v47 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x47400000u), 0);
    v48 = (__m128)_mm_xor_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x28800000u), 0), v45);
    v49 = _mm_add_ps(v46, v47);
    v50 = (__m128)_mm_xor_si128(v45, _mm_shuffle_epi32(_mm_cvtsi32_si128(0x34000000u), 0));
    v51 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x40C91000u), 0);
    v52 = _mm_sub_ps(
            (__m128)_mm_or_si128(
                      _mm_or_si128(
                        _mm_slli_epi32(_mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x1FFu), 0), v43), 0xEu),
                        _mm_srli_epi32(v44, 0x12u)),
                      (__m128i)v50),
            v50);
    v53 = _mm_sub_ps(v46, _mm_sub_ps(v49, v47));
    v54 = _mm_add_ps(v53, v52);
    v55 = _mm_and_ps((__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0xFFFFF000), 0), v54);
    v56 = _mm_sub_ps(v53, v54);
    v57 = _mm_sub_ps(v54, v55);
    v58 = _mm_add_ps(
            _mm_sub_ps(
              (__m128)_mm_or_si128(
                        _mm_slli_epi32(_mm_and_si128(_mm_shuffle_epi32(_mm_cvtsi32_si128(0x3FFFFu), 0), v44), 5u),
                        (__m128i)v48),
              v48),
            _mm_add_ps(v52, v56));
    v59 = _mm_mul_ps(v55, v51);
    v60 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0xB795777A), 0);
    v61 = _mm_and_ps((__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x7FFFFFFFu), 0), v3);
    v62 = _mm_add_ps(
            _mm_add_ps(_mm_mul_ps(v51, v57), _mm_mul_ps(v55, v60)),
            _mm_add_ps(
              _mm_mul_ps((__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x40C90FDBu), 0), v58),
              _mm_mul_ps(v60, v57)));
    v63 = (__m128)_mm_shuffle_epi32(_mm_cvtsi32_si128(0x35800000u), 0);
    v64 = _mm_add_ps(v62, v59);
    v65 = _mm_cmplt_ps(v63, v61);
    v66 = _mm_add_ps(v62, _mm_sub_ps(v59, v64));
    v67 = _mm_and_ps(v64, v65);
    v68 = _mm_and_ps(v65, v66);
    v69 = _mm_or_ps(_mm_and_ps(_mm_cmple_ps(v61, v63), v3), v67);
    v70 = _mm_slli_epi32(_mm_and_si128((__m128i)v49, _mm_shuffle_epi32(_mm_cvtsi32_si128(0xFFu), 0)), 4u);
    v71 = _mm_cvtsi128_si32(v70);
    v72 = _mm_mul_ps(v69, v69);
    v73 = _mm_extract_epi32(v70, 2);
    result = (unsigned int)_mm_extract_epi32(v70, 1);
    a3 = (unsigned int)_mm_extract_epi32(v70, 3);
    v74 = (__m128)_mm_unpacklo_pd(
                    (__m128d)_mm_insert_epi32(
                               _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v71 + 4)),
                               *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result + 4),
                               1),
                    (__m128d)_mm_insert_epi32(
                               _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v73 + 4)),
                               *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3 + 4),
                               1));
    v75 = (__m128)_mm_unpacklo_epi64(
                    _mm_insert_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v71 + 0xC)),
                      *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result + 0xC),
                      1),
                    _mm_insert_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v73 + 0xC)),
                      *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3 + 0xC),
                      1));
    v76 = _mm_mul_ps(v69, v75);
    v77 = _mm_add_ps(v74, v76);
    v78 = (__m128)_mm_unpacklo_epi64(
                    _mm_insert_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v71)),
                      *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result),
                      1),
                    _mm_insert_epi32(
                      _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v73)),
                      *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3),
                      1));
    v79 = _mm_mul_ps(v69, v78);
    v80 = _mm_add_ps(v77, v79);
    v81 = _mm_sub_ps(_mm_add_ps(v78, v75), _mm_mul_ps(v69, v74));
    v16 = _mm_blendv_ps(
            v82,
            _mm_add_ps(
              v80,
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    (__m128)_mm_unpacklo_epi64(
                              _mm_insert_epi32(
                                _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v71 + 8)),
                                *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)result + 8),
                                1),
                              _mm_insert_epi32(
                                _mm_cvtsi32_si128(*(_DWORD *)((char *)&unk_151D26100 + v73 + 8)),
                                *(_DWORD *)((char *)&unk_151D26100 + (unsigned int)a3 + 8),
                                1)),
                    _mm_mul_ps(v68, v81)),
                  _mm_mul_ps(
                    v74,
                    _mm_mul_ps(v72, _mm_add_ps(_mm_mul_ps((__m128)xmmword_151D27280, v72), (__m128)xmmword_151D27240)))),
                _mm_add_ps(
                  _mm_add_ps(_mm_add_ps(v76, _mm_sub_ps(v74, v77)), _mm_add_ps(v79, _mm_sub_ps(v77, v80))),
                  _mm_mul_ps(
                    _mm_mul_ps(
                      _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_151D27200, v72), (__m128)xmmword_151D271C0), v72),
                      v69),
                    v81)))),
            v9);
  }
  if ( v5 )
  {
    *v6 = v3;
    *(__m128 *)(((unsigned __int64)v83 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40) = v16;
    result = 0;
    n4 = 0;
    v18 = v5;
    do
    {
      if ( _bittest(&v18, n4) )
        result = _common_ssin_cout_rare((char *)v6 + 4 * n4, (char *)v6 + 4 * n4 + 0x40, a3, v4);
      n4 = (unsigned int)(n4 + 1);
    }
    while ( (int)n4 < 4 );
  }
  return result;
}

// --- End Function: __sse4_sinf4@@16 (0x148035180) ---

// --- Function: __common_ssin_cout_rare (0x14803B830) ---
__int64 __fastcall _common_ssin_cout_rare(__int64 a1, float *a2)
{
  float v2; // xmm1_4
  __int64 result; // rax
  float v4; // xmm1_4
  float v5; // [rsp+20h] [rbp-8h]

  v5 = *(float *)a1;
  v2 = *(float *)a1;
  if ( (*(_WORD *)(a1 + 2) & 0x7F80) != 0x7F80 )
    return 0;
  HIBYTE(v5) = HIBYTE(*(_DWORD *)a1) & 0x7F;
  if ( v5 == INFINITY )
  {
    result = 1;
    v4 = v2 * 0.0;
  }
  else
  {
    v4 = v2 * *(float *)a1;
    result = 0;
  }
  *a2 = v4;
  return result;
}

// --- End Function: __common_ssin_cout_rare (0x14803B830) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

// --- Function: asinf (0x148082227) ---
// attributes: thunk
float __cdecl asinf(float X)
{
  return __imp_asinf(X);
}

// --- End Function: asinf (0x148082227) ---

// --- Function: atan2f (0x14808222D) ---
// attributes: thunk
float __cdecl atan2f(float Y, float X)
{
  return __imp_atan2f(Y, X);
}

// --- End Function: atan2f (0x14808222D) ---

// --- Function: acos (0x14808224B) ---
// attributes: thunk
double __cdecl acos(double X)
{
  return __imp_acos(X);
}

// --- End Function: acos (0x14808224B) ---

