// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x145F1C660 (sub_145F1C660)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 156
// ------------------------------------------------------------

// --- Function: identity (0x1402A24F0) ---
// A simple passthrough function that returns its input argument unchanged.
__int64 __fastcall identity(__int64 input_value)
{
  return input_value;
}

// --- End Function: identity (0x1402A24F0) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---

// --- Function: sub_1402A2950 (0x1402A2950) ---
__int64 __fastcall sub_1402A2950(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  result = a1;
  *(_QWORD *)(a1 + 8) = 0x1FF;
  return result;
}

// --- End Function: sub_1402A2950 (0x1402A2950) ---

// --- Function: sub_1402A2AD0 (0x1402A2AD0) ---
__int64 __fastcall sub_1402A2AD0(_QWORD *object_ptr)
{
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 result; // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *))object_ptr[1];
  if ( (unsigned __int64)n2 < 2 )
  {
    result = 0;
    *object_ptr = 0;
  }
  else
  {
    n2(2, object_ptr);
    result = 0;
    object_ptr[1] = 0;
    *object_ptr = 0;
  }
  return result;
}

// --- End Function: sub_1402A2AD0 (0x1402A2AD0) ---

// --- Function: sub_1402A2B40 (0x1402A2B40) ---
void __fastcall sub_1402A2B40(__int64 a1)
{
  unsigned __int64 v1; // rax
  const void *v2; // rcx

  if ( *(_QWORD *)(a1 + 0x10) != a1 + 0x18 )
  {
    v1 = 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
    v2 = *(const void **)(a1 + 0x10);
    qword_149B3AB68 += v1;
    sub_147605980(v2);
  }
}

// --- End Function: sub_1402A2B40 (0x1402A2B40) ---

// --- Function: sub_1402A3190 (0x1402A3190) ---
__int64 sub_1402A3190(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n511;
  while ( Buffer[n511] );
  sub_1402A3BE0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A3190 (0x1402A3190) ---

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402A3B50 (0x1402A3B50) ---
_BYTE *__fastcall sub_1402A3B50(__int64 *a1, __int64 n511_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0x1FF; // rcx

  result = a1 + 3;
  if ( n511_1 )
  {
    allocSize = n511_1 + 1;
    if ( (unsigned __int64)(n511_1 + 1) <= 0x200 )
    {
      n0x1FF = 0x1FF;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3AB68 += allocSize;
      n0x1FF = n511_1;
    }
    a1[1] = n0x1FF;
    *a1 = n511_1;
    a1[2] = (__int64)result;
    result[n511_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0x1FF;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A3B50 (0x1402A3B50) ---

// --- Function: sub_1402A3BE0 (0x1402A3BE0) ---
__int64 __fastcall sub_1402A3BE0(__int64 a1, const void *a2, size_t n511)
{
  size_t n511_1; // r8
  const void *v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  n511_1 = *(_QWORD *)(a1 + 8);
  if ( n511 > n511_1 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n511_1;
      sub_147605980(v7);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x1FF;
    sub_1402A3B50((__int64 *)a1, n511);
  }
  memmove(*(void **)(a1 + 0x10), a2, n511);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n511;
  *(_BYTE *)(n511 + result) = 0;
  return result;
}

// --- End Function: sub_1402A3BE0 (0x1402A3BE0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall sub_1402A3D30(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A3D90) ---
unsigned __int8 *__fastcall AK::WriteBytesMem::Bytes(AK::WriteBytesMem *this)
{
  return (unsigned __int8 *)*((_QWORD *)this + 2);
}

// --- End Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A3D90) ---

// --- Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_0 (0x1402A4050) ---
const char *__fastcall __crt_win32_buffer_debug_info::file_name(__crt_win32_buffer_debug_info *this)
{
  return (const char *)*((_QWORD *)this + 1);
}

// --- End Function: ?file_name@__crt_win32_buffer_debug_info@@QEBAPEBDXZ_0 (0x1402A4050) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A60C0) ---
void __fastcall std::_Deallocate<16,0>(_QWORD *a1, unsigned __int64 n0x1000)
{
  if ( n0x1000 >= 0x1000 )
  {
    if ( (unsigned __int64)a1 - a1[0xFFFFFFFF] - 8 > 0x1F )
      invalid_parameter_noinfo_noreturn();
    a1 = (_QWORD *)a1[0xFFFFFFFF];
  }
  sub_1402A3D30(a1);
}

// --- End Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A60C0) ---

// --- Function: unknown_libname_472 (0x1402AE2A0) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_472(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_472 (0x1402AE2A0) ---

// --- Function: sub_1402AE3D0 (0x1402AE3D0) ---
__int64 *__fastcall sub_1402AE3D0(__int64 *a1, const char *a2, __int64 a3, char a4)
{
  *a1 = a3;
  sub_1402CD240(a3, a2, a4);
  return a1;
}

// --- End Function: sub_1402AE3D0 (0x1402AE3D0) ---

// --- Function: set_ptr_null (0x1402B1640) ---
void __fastcall sub_1402B1640(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: set_ptr_null (0x1402B1640) ---

// --- Function: sub_1402B1820 (0x1402B1820) ---
const ULONG_PTR *__fastcall sub_1402B1820(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v4; // eax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 0x14);
  if ( v2 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v4 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v1, v4);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402B1820 (0x1402B1820) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: sub_1402C7510 (0x1402C7510) ---
__int64 __fastcall sub_1402C7510(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x78);
}

// --- End Function: sub_1402C7510 (0x1402C7510) ---

// --- Function: sub_1402CD240 (0x1402CD240) ---
__int64 __fastcall sub_1402CD240(__int64 a1, const char *a2, char a3)
{
  __int64 result; // rax
  int v7; // edi
  unsigned __int32 v8; // eax

  result = get_thread_context_ptr();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v8 )
    {
      result = sub_1403C33A0(a1, v8, a2, a3);
    }
    else
    {
      result = get_thread_context_ptr();
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v7;
  }
  return result;
}

// --- End Function: sub_1402CD240 (0x1402CD240) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 status_bits; // rax

  if ( qword_149B3B1F0 )
    status_bits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    status_bits = 1;
  if ( !qword_149B3B208 )
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)status_bits & 0xFFFFFFF7;
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
// A comprehensive function for logging and dispatching telemetry events. It
// captures system time, generates unique identifiers, formats event data
// (including parameters and tags) into a buffer, and conditionally outputs to
// console or dispatches to various logging handlers based on configuration and
// event type. It also handles dynamic memory allocation and deallocation for event
// data structures.
void __fastcall sub_1403045C0(
        unsigned int event_severity_level,
        __int64 *event_data_ptr,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 v84; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char v89; // cl
  int v90; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v94; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  const void *Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *v110; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v112; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int v116; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v128; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v132; // [rsp+118h] [rbp+78h]
  char *v133; // [rsp+120h] [rbp+80h]
  __int64 *event_data_ptr_1; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v132 = a4;
  v133 = a3;
  event_data_ptr_1 = event_data_ptr;
  n4 = event_severity_level;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  v128 = v12;
  if ( v11 && !sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity) )
    return;
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v20 = v117;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v147[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400_1 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400_1 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            sub_1402A6760(v14, _Whereptr, __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        sub_1402A6760(v14, _Whereptr_1, (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)__Val_0___1 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v142, __Val_0___1);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)__Val_0___1, &v130, &__Val_0___4);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      __Val_0___5 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v48 = *(_QWORD **)__Val_0___7;
        v49 = **(_QWORD ***)__Val_0___7;
        if ( v49 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        __Val_0___7 = __Val_0___6;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          __Val_0___3 = __Val_0___5;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        __Val_0___3 = __Val_0___5;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v57;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              sub_1402A6760(v14, _Whereptr_2, __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          sub_1402A6760(v14, _Whereptr_3, &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    __Val_0___1 = __Val_0___2;
    v29 = v143;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[__Val_0___4];
    v124 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 0x70);
    v69 = v120;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 0xA) = v29;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * n0x400], (__int64)(8 * n0x400) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v76 = *(_QWORD *)&v71[8 * n0x400_3];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_130;
    }
  }
  v84 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v84 = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(v84 & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_130:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(v128, n4, v133, event_data_ptr_1, v132, __Val_0__, _Newcapacity, v146, n0x10_1, &a8);
    v123[0] = v87;
  }
  v89 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&FileTime,
            v128,
            (__int64)String,
            n4,
            event_data_ptr_1,
            v133,
            v132,
            __Val_0__,
            _Newcapacity,
            a7,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &a8);
    v89 = a8;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (v89 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v83);
    v89 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v89 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v83);
    n2_126 = ::n2_126;
  }
  v83[v88] = 0;
  v94 = a8;
  v95 = (a8 & 1) != 0 && n2_125 == 2;
  v96 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = (const void *)Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v117;
LABEL_166:
    v116 = v123[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v128,
      Buffer,
      String,
      n4,
      event_data_ptr_1,
      v133,
      v132,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v71,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      a8,
      v116);
    sub_1402A3D30(Buffer_3);
    v94 = a8;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v94 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v94 = a8;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (v94 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    v110 = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = v110[5];
        v112 = (_QWORD *)*v110;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)v110[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_190;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        v110[4] = 0;
        v110[5] = 0xF;
        *((_BYTE *)v110 + 0x10) = 0;
        sub_1402A3D30(v110);
        v110 = v112;
      }
      while ( v112 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *handle_ptr)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *handle_ptr;
  if ( !*handle_ptr )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)get_thread_context_ptr() )
    return sub_14031FE20(handle_ptr) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_desc_ptr)
{
  unsigned __int64 entity_desc_val; // r9
  __int64 entity_base_addr_or_id; // r10
  unsigned __int64 entity_type_flags; // r9
  __int64 align_mask; // rax
  __int64 aligned_base_addr_or_id; // r10
  __int64 entity_header_ptr; // rbx
  bool is_privileged_or_bypass; // al

  entity_desc_val = *entity_desc_ptr;
  if ( !*entity_desc_ptr )
    return 0;
  entity_base_addr_or_id = entity_desc_val & 0xFFFFFFFFFFFFLL;
  entity_type_flags = HIWORD(entity_desc_val);
  if ( (entity_type_flags & 0xF000) != 0 )
  {
    align_mask = map_flag_to_mask(0x2000u);
    entity_header_ptr = aligned_base_addr_or_id & ~(align_mask - 1);
  }
  else
  {
    entity_header_ptr = entity_base_addr_or_id - 6;
  }
  if ( *(_WORD *)(entity_header_ptr + 2) != (entity_type_flags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || (is_privileged_or_bypass = is_thread_privileged_or_bypass_mode()) )
    is_privileged_or_bypass = 1;
  return *(_WORD *)(entity_header_ptr + 4) == 2 && is_privileged_or_bypass
      || validate_entity_descriptor_detailed_access(entity_desc_ptr) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *qword_ptr)
{
  return *qword_ptr & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int result_mask; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        result_mask = 0;
        if ( input_flag == 0x6000 )
          return 0x4000000;
        return result_mask;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: unknown_libname_23 (0x1403376F0) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_23(_QWORD *a1, _QWORD *a2)
{
  return *a1 != *a2;
}

// --- End Function: unknown_libname_23 (0x1403376F0) ---

// --- Function: sub_14033AB40 (0x14033AB40) ---
_QWORD *__fastcall sub_14033AB40(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_7;
  if ( n0xFFFF_7 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v9,
                          "IItemPortContainer");
    n0xFFFF_7 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033AB40 (0x14033AB40) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_1403708B0 (0x1403708B0) ---
_DWORD *__fastcall sub_1403708B0(_DWORD *a1)
{
  _DWORD *result; // rax

  *a1 = 0xA;
  result = a1;
  a1[2] = 0xFFBFFFFF;
  a1[6] = 0xFFBFFFFF;
  a1[3] = 0xFFBFFFFF;
  a1[4] = 0xFFBFFFFF;
  a1[5] = 0xFFBFFFFF;
  a1[1] = 0x80000000;
  a1[9] = 0xFFBFFFFF;
  a1[0xA] = 0xFFBFFFFF;
  a1[0xB] = 0xFFBFFFFF;
  a1[0xF] = 0xFFBFFFFF;
  a1[0x10] = 0xFFBFFFFF;
  a1[0x11] = 0x80000000;
  a1[0x12] = 0x80000000;
  a1[0x13] = 0x80000000;
  a1[0xE] = 0xFFBFFFFF;
  a1[0x14] = 0x80000000;
  a1[0x15] = 0xFFBFFFFF;
  a1[0x16] = 0x80000000;
  a1[0x17] = 0x80000000;
  a1[0x18] = 0x80000000;
  a1[0x19] = 0x80000000;
  a1[0x1A] = 0x80000000;
  a1[0x1B] = 0x80000000;
  return result;
}

// --- End Function: sub_1403708B0 (0x1403708B0) ---

// --- Function: sub_140370D10 (0x140370D10) ---
// // Decrements a reference count associated with a managed object and //
// deallocates the object's memory if the reference count is still positive. //
// This pattern is characteristic of shared pointer or reference-counted // memory
// management, where the reference count is stored in a control block // located
// just before the actual data pointed to by *a1. // // Parameters: //
// pManagedObjectPtr: A pointer to a QWORD, where the QWORD itself points //
// to the managed data. The reference count is expected //                      at
// an offset of -8 bytes from this data pointer.
void __fastcall sub_140370D10(_QWORD *pManagedObjectPtr)
{
  int *v1; // rcx

  v1 = (int *)(*pManagedObjectPtr - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140377F00 (0x140377F00) ---
char **__fastcall sub_140377F00(char **a1, char **a2)
{
  char *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E9810(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377F00 (0x140377F00) ---

// --- Function: j_is_entity_descriptor_valid_or_accessible (0x14037F760) ---
// attributes: thunk
bool __fastcall j_is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_desc_ptr)
{
  return is_entity_descriptor_valid_or_accessible(entity_desc_ptr);
}

// --- End Function: j_is_entity_descriptor_valid_or_accessible (0x14037F760) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
         pEntitySystem,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)get_thread_context_ptr() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: HIWORD_w (0x14037FC90) ---
bool __fastcall HIWORD_w(_QWORD *a1)
{
  return *a1 && *(_QWORD *)((*a1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*a1);
}

// --- End Function: HIWORD_w (0x14037FC90) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(pEntitySystem, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: validate_entity_descriptor_detailed_access (0x140392020) ---
// Performs detailed access validation for an entity descriptor. It extracts the
// entity's base address or ID from the descriptor. It then determines a pointer to
// entity metadata based on the highest bit of the descriptor (either by masking or
// by applying a -6 offset to the base address/ID). The function then dispatches to
// different validation logic based on the value of a status/type field at
// `entity_metadata_ptr + 4`: - If 0, returns false. - If 1, calls
// `check_thread_list_contains_value` with the entity's base address/ID. - If 2,
// checks for a privileged/bypass state (via `get_thread_context_ptr + 0x12D` or
// `is_thread_privileged_or_bypass_mode`). If privileged, returns true; otherwise,
// calls `validate_access_with_virtual_calls`. - If 3 or 4, checks thread data from
// `get_thread_context_ptr`. If a specific thread status is 1, it returns true if
// the entity's base address/ID is NOT equal to the magic value `0x13374770CLL`. -
// For any other status/type, returns false.
char __fastcall validate_entity_descriptor_detailed_access(_QWORD *entity_descriptor_ptr)
{
  _QWORD *entity_base_addr_or_id; // rbx
  __int64 entity_metadata_ptr; // rax
  __int64 thread_data_ptr; // rax

  entity_base_addr_or_id = (_QWORD *)(*entity_descriptor_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*entity_descriptor_ptr & 0xF000000000000000uLL) != 0 )
    entity_metadata_ptr = *entity_descriptor_ptr & 0xFFFFFF000000LL;
  else
    entity_metadata_ptr = (__int64)entity_base_addr_or_id + 0xFFFFFFFA;
  if ( !*(_WORD *)(entity_metadata_ptr + 4) )
    return 0;
  if ( *(_WORD *)(entity_metadata_ptr + 4) == 1 )
    return check_thread_list_contains_value((__int64)entity_base_addr_or_id);
  if ( *(_WORD *)(entity_metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(entity_metadata_ptr + 4) - 3 <= 1 )
    {
      thread_data_ptr = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
      if ( thread_data_ptr )
      {
        if ( *(_DWORD *)(thread_data_ptr + 8) == 1 )
          return *entity_base_addr_or_id != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)entity_base_addr_or_id);
}

// --- End Function: validate_entity_descriptor_detailed_access (0x140392020) ---

// --- Function: sub_1403A2CE0 (0x1403A2CE0) ---
// // Dispatches a log message or event to a global logging/profiling system. //
// This function conditionally calls an internal logging function pointer // (at
// offset +8 from qword_149B4FCB0) only if the global environment (gEnv) // and
// specific logging system pointers (qword_149B4FCA0, qword_149B4FCB0) // are
// initialized and valid. // // Parameters: //   messageTypeOrFormat: The first
// argument to the dispatched function, //                        potentially a
// message type or format string. //   ...: Variadic arguments passed to the
// dispatched function. // // Returns: //   The return value of the dispatched
// logging function, or 0 if the //   logging system is not initialized.
__int64 sub_1403A2CE0(__int64 messageTypeOrFormat, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, messageTypeOrFormat);
  if ( gEnv && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
               qword_149B4FCB0,
               0,
               messageTypeOrFormat,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1403A2CE0 (0x1403A2CE0) ---

// --- Function: sub_1403A58C0 (0x1403A58C0) ---
__int64 __fastcall sub_1403A58C0(__int64 a1, unsigned __int8 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEngineComponentScheduler + 0xA8LL))(
           pEngineComponentScheduler,
           a1,
           a2);
}

// --- End Function: sub_1403A58C0 (0x1403A58C0) ---

// --- Function: sub_1403B0A70 (0x1403B0A70) ---
// Attempts to retrieve an entity's identifier or base address. It first checks if
// the provided entity descriptor is valid and accessible. If so, it calls a
// virtual method on the entity to obtain the ID; otherwise, it sets the output ID
// to zero.
_QWORD *__fastcall sub_1403B0A70(unsigned __int64 *entity_desc_ptr, _QWORD *a2)
{
  if ( is_entity_descriptor_valid_or_accessible(entity_desc_ptr) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*entity_desc_ptr & 0xFFFFFFFFFFFFLL) + 8LL))(
      *entity_desc_ptr & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B0A70 (0x1403B0A70) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
           pEntitySystem,
           a1,
           0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403BA0E0 (0x1403BA0E0) ---
_QWORD *__fastcall sub_1403BA0E0(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x40);
  return a2;
}

// --- End Function: sub_1403BA0E0 (0x1403BA0E0) ---

// --- Function: sub_1403CF100 (0x1403CF100) ---
__int64 __fastcall sub_1403CF100(__int64 a1, unsigned __int8 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pEngineComponentScheduler + 0xB8LL))(
           pEngineComponentScheduler,
           a1,
           a2);
}

// --- End Function: sub_1403CF100 (0x1403CF100) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
        p_profiler_system,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 0x10) & (unsigned int)(v9 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
      p_profiler_system,
      &v11,
      &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403E6750 (0x1403E6750) ---
unsigned __int64 __fastcall sub_1403E6750(unsigned __int64 *a1)
{
  if ( is_entity_descriptor_valid_or_accessible(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6750 (0x1403E6750) ---

// --- Function: sub_1404530C0 (0x1404530C0) ---
__int64 __fastcall sub_1404530C0(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  result = a1;
  *(_DWORD *)(a1 + 8) = 0x18;
  *(_DWORD *)(a1 + 0xC) = 9;
  return result;
}

// --- End Function: sub_1404530C0 (0x1404530C0) ---

// --- Function: sub_140463990 (0x140463990) ---
// attributes: thunk
void __fastcall sub_140463990(__int64 *a1)
{
  sub_1404EAF80(a1);
}

// --- End Function: sub_140463990 (0x140463990) ---

// --- Function: sub_140469400 (0x140469400) ---
__int64 __fastcall sub_140469400(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 result; // rax

  sub_1404EAF80((__int64 *)a1);
  v4 = *(_QWORD *)a1;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 0xC) = *(_DWORD *)(a2 + 0xC);
  result = a1;
  *(_DWORD *)(a2 + 8) = 0x18;
  *(_DWORD *)(a2 + 0xC) = 9;
  return result;
}

// --- End Function: sub_140469400 (0x140469400) ---

// --- Function: sub_14046B610 (0x14046B610) ---
bool __fastcall sub_14046B610(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) != 0x18;
}

// --- End Function: sub_14046B610 (0x14046B610) ---

// --- Function: sub_14049C720 (0x14049C720) ---
int *__fastcall sub_14049C720(__int64 a1)
{
  int v2; // edi
  unsigned __int32 v3; // eax
  void (__fastcall *n2)(__int64, __int64, _QWORD); // rax
  __int64 v5; // rdi
  int v6; // eax
  unsigned __int32 v7; // eax
  signed __int64 v8; // rsi
  _QWORD *v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rbx
  int *result; // rax
  int v13; // [rsp+48h] [rbp-10h] BYREF

  v2 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(a1 + 0x20) == v2 )
  {
    ++*(_DWORD *)(a1 + 0x24);
  }
  else
  {
    v3 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x10), 1, 0);
    if ( v3 )
      sub_1403C33A0(a1 + 0x10, v3, "IAction::ClearOnFinishedCallback", 1);
    else
      *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    *(_DWORD *)(a1 + 0x20) = v2;
  }
  n2 = *(void (__fastcall **)(__int64, __int64, _QWORD))(a1 + 0x30);
  v5 = 0;
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1 + 0x28, 0);
    *(_QWORD *)(a1 + 0x30) = 0;
  }
  *(_QWORD *)(a1 + 0x28) = 0;
  v6 = *(_DWORD *)(a1 + 0x24);
  if ( v6 )
  {
    *(_DWORD *)(a1 + 0x24) = v6 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x20) = 0xFFFFFFFF;
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x10), 0, 1);
    if ( v7 == 1 )
      *(_QWORD *)(a1 + 0x18) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(a1 + 0x10, v7);
  }
  v13 = 1;
  if ( *(_DWORD *)(a1 + 0xE0) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0xE4);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0xD0));
    if ( (v8 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        a1 + 0xD0,
        v8,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        1);
  }
  v9 = (_QWORD *)(a1 + 0xB8);
  v10 = (__int64)(*(_QWORD *)(a1 + 0xC0) - *(_QWORD *)(a1 + 0xB8)) >> 3;
  if ( (_DWORD)v10 )
  {
    v11 = (unsigned int)v10;
    while ( 1 )
    {
      sub_14049C720(*(_QWORD *)(v5 + *v9));
      v5 += 8;
      if ( !--v11 )
        break;
      v9 = (_QWORD *)(a1 + 0xB8);
    }
  }
  result = &v13;
  if ( !--v13 )
    return (int *)rw_lock_release_read_lock(a1 + 0xD0);
  return result;
}

// --- End Function: sub_14049C720 (0x14049C720) ---

// --- Function: sub_1404B0ED0 (0x1404B0ED0) ---
__int64 __fastcall sub_1404B0ED0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x38);
}

// --- End Function: sub_1404B0ED0 (0x1404B0ED0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *thread_base_ctx_ptr; // rax
  unsigned __int64 *thread_base_ctx_ptr_1; // rcx
  unsigned __int64 n0xF; // rax

  thread_base_ctx_ptr = sub_1404B3EA0();
  thread_base_ctx_ptr_1 = thread_base_ctx_ptr;
  if ( !thread_base_ctx_ptr )
    return &dword_149B45F40;
  n0xF = *thread_base_ctx_ptr;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&thread_base_ctx_ptr_1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_1404C7710 (0x1404C7710) ---
bool __fastcall sub_1404C7710(__int64 a1)
{
  return (*(_DWORD *)(a1 + 0x74) & 0x200) != 0;
}

// --- End Function: sub_1404C7710 (0x1404C7710) ---

// --- Function: sub_1404EAF80 (0x1404EAF80) ---
void __fastcall sub_1404EAF80(__int64 *a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int16 n4; // dx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  v2 = *a1;
  v7 = v2;
  if ( v2 )
  {
    v3 = sub_1403B4B50(v2 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v3 + 4);
    if ( n4 != 4
      && *(_WORD *)(v3 + 2) == (HIWORD(v2) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v7)) )
    {
      v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v2 & 0xFFFFFFFFFFFFLL) + 0x870LL))(v2 & 0xFFFFFFFFFFFFLL);
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 8LL))(v5, *((unsigned int *)a1 + 2));
    }
  }
  if ( *((_DWORD *)a1 + 3) != 9 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pGame + 0x1D8LL))(pGame);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v6 + 8LL))(v6, *((unsigned int *)a1 + 3), 0);
  }
  *a1 = 0;
  *((_DWORD *)a1 + 2) = 0x18;
  *((_DWORD *)a1 + 3) = 9;
}

// --- End Function: sub_1404EAF80 (0x1404EAF80) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 thread_data_ptr; // rcx

  thread_data_ptr = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( thread_data_ptr )
    return *(_BYTE *)(thread_data_ptr + 0x42) != 0;
  else
    return *(_BYTE *)(get_thread_context_ptr() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_140597760 (0x140597760) ---
// // Converts a QWORD value, typically a high-resolution timer tick count //
// (e.g., from __rdtsc), into a double-precision floating-point number //
// representing time in seconds (or a scaled unit). // The conversion involves
// scaling the QWORD value by a factor of 0.0000001. // // Parameters: //   None
// explicitly, but implicitly operates on a QWORD value in RCX or a global. // //
// Returns: //   An __m128 containing the scaled time value as a double.
__m128 sub_140597760()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_140597760 (0x140597760) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !gEnv || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1412A8110 (0x1412A8110) ---
__int64 *__fastcall sub_1412A8110(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        _DWORD *a4,
        __int64 a5,
        char a6,
        int a7,
        int a8,
        char a9)
{
  __int64 v10; // xmm1_8
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  _BYTE v16[40]; // [rsp+20h] [rbp-28h] BYREF

  *a1 = a2;
  a1[4] = *(_QWORD *)(a3 + 0x18);
  a1[1] = *(_QWORD *)a3;
  a1[2] = *(_QWORD *)(a3 + 8);
  a1[3] = *(_QWORD *)(a3 + 0x10);
  *(_OWORD *)(a1 + 5) = *(_OWORD *)(a3 + 0x20);
  v10 = *(__int64 *)(a3 + 0x30);
  a1[7] = v10;
  a1[8] = *(_QWORD *)(a3 + 0x38);
  a1[9] = 0;
  a1[0xA] = 0;
  a1[0xB] = 0;
  *((_DWORD *)a1 + 0x1B) = a4[3];
  *((_DWORD *)a1 + 0x18) = *a4;
  *((_DWORD *)a1 + 0x19) = a4[1];
  *((_DWORD *)a1 + 0x1A) = a4[2];
  v11 = *a1;
  a1[0xE] = *(__int64 *)a5;
  *((_DWORD *)a1 + 0x1E) = *(_DWORD *)(a5 + 8);
  *((_BYTE *)a1 + 0x7C) = a6;
  *((_BYTE *)a1 + 0x7F) = a9;
  *(_WORD *)((char *)a1 + 0x7D) = 0;
  if ( v11 )
  {
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pEntitySystem + 0x118LL))(pEntitySystem);
    if ( v12 )
    {
      v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x668LL))(v12);
      if ( v13 )
      {
        v14 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v13 + 0x170LL))(v13, v16, a1 + 5);
        *(_OWORD *)(a1 + 9) = *(_OWORD *)v14;
        a1[0xB] = *(__int64 *)(v14 + 0x10);
      }
      else
      {
        sub_1403A2CE0((__int64)"Constructing SActorTeleportParams with a zone entity id that does not host a zone.");
      }
      return a1;
    }
    else
    {
      sub_1403A2CE0((__int64)"Constructing SActorTeleportParams with invalid zone entity id.");
      return a1;
    }
  }
  else
  {
    *(_OWORD *)(a1 + 9) = *(_OWORD *)(a1 + 5);
    a1[0xB] = v10;
    return a1;
  }
}

// --- End Function: sub_1412A8110 (0x1412A8110) ---

// --- Function: sub_141606CA0 (0x141606CA0) ---
_QWORD *__fastcall sub_141606CA0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_157; // ax
  __int16 n0xFFFF_157_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( is_entity_descriptor_valid_or_accessible(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF_157 = ::n0xFFFF_157;
    if ( ::n0xFFFF_157 == (__int16)0xFFFF )
    {
      n0xFFFF_157 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                       + 0x10LL))(
                                pEngineComponentScheduler,
                                &v8,
                                "ILawComponent");
      ::n0xFFFF_157 = n0xFFFF_157;
    }
    n0xFFFF_157_1 = n0xFFFF_157;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_157_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_141606CA0 (0x141606CA0) ---

// --- Function: sub_14161AEB0 (0x14161AEB0) ---
_QWORD *__fastcall sub_14161AEB0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rcx
  _QWORD *result; // rax
  __int64 v5; // [rsp+38h] [rbp+10h] BYREF

  v3 = *sub_141606CA0(a1, &v5);
  result = a2;
  *a2 = v3;
  return result;
}

// --- End Function: sub_14161AEB0 (0x14161AEB0) ---

// --- Function: sub_141976650 (0x141976650) ---
void __fastcall sub_141976650(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx

  v2 = (_QWORD *)a1[0xB];
  if ( v2 )
  {
    if ( ((a1[0xD] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        goto LABEL_12;
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[0xB] = 0;
    a1[0xC] = 0;
    a1[0xD] = 0;
  }
  v3 = (_QWORD *)a1[7];
  if ( !v3 )
    return;
  if ( ((a1[9] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
  {
    if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v3 = (_QWORD *)v3[0xFFFFFFFF];
      goto LABEL_10;
    }
LABEL_12:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_1402A3D30(v3);
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
}

// --- End Function: sub_141976650 (0x141976650) ---

// --- Function: sub_141A63B10 (0x141A63B10) ---
__int64 __fastcall sub_141A63B10(__int64 a1, __int64 a2)
{
  char **v4; // rcx

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 0x18) = *(_OWORD *)(a2 + 0x18);
  *(_DWORD *)(a1 + 0x28) = *(_DWORD *)(a2 + 0x28);
  *(_BYTE *)(a1 + 0x2C) = *(_BYTE *)(a2 + 0x2C);
  *(_BYTE *)(a1 + 0x2D) = *(_BYTE *)(a2 + 0x2D);
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x34) = *(_DWORD *)(a2 + 0x34);
  v4 = (char **)(a1 + 0x38);
  if ( v4 != (char **)(a2 + 0x38) )
    sub_141A27640(v4, *(_DWORD **)(a2 + 0x38), (__int64)(*(_QWORD *)(a2 + 0x40) - *(_QWORD *)(a2 + 0x38)) >> 6);
  *(_DWORD *)(a1 + 0x50) = *(_DWORD *)(a2 + 0x50);
  if ( a1 + 0x58 != a2 + 0x58 )
    sub_140342360(a1 + 0x58, *(char **)(a2 + 0x58), (__int64)(*(_QWORD *)(a2 + 0x60) - *(_QWORD *)(a2 + 0x58)) >> 3);
  *(_BYTE *)(a1 + 0x70) = *(_BYTE *)(a2 + 0x70);
  *(_DWORD *)(a1 + 0x74) = *(_DWORD *)(a2 + 0x74);
  return a1;
}

// --- End Function: sub_141A63B10 (0x141A63B10) ---

// --- Function: sub_141EEDD20 (0x141EEDD20) ---
_QWORD *__fastcall sub_141EEDD20(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( is_entity_descriptor_valid_or_accessible(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_45;
    if ( n0xFFFF_45 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                   + 0x10LL))(
                            pEngineComponentScheduler,
                            &v8,
                            "IEntityGeometryResource");
      n0xFFFF_45 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_141EEDD20 (0x141EEDD20) ---

// --- Function: sub_1423357D0 (0x1423357D0) ---
_QWORD *__fastcall sub_1423357D0(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x58);
  return a2;
}

// --- End Function: sub_1423357D0 (0x1423357D0) ---

// --- Function: sub_1425D62E0 (0x1425D62E0) ---
_QWORD *__fastcall sub_1425D62E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_31;
  if ( n0xFFFF_31 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v9,
                          "Actor");
    n0xFFFF_31 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D62E0 (0x1425D62E0) ---

// --- Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---
__int64 __fastcall std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---

// --- Function: sub_1426F0C90 (0x1426F0C90) ---
char *__fastcall sub_1426F0C90(Parameter *Parameter, const void *src)
{
  if ( *((_QWORD *)Parameter + 1) == *((_QWORD *)Parameter + 2) )
    return sub_1426F1A90(Parameter, *((AK::WriteBytesCount **)Parameter + 1), src);
  else
    return (char *)sub_1426F08A0(Parameter, src);
}

// --- End Function: sub_1426F0C90 (0x1426F0C90) ---

// --- Function: sub_1426FC500 (0x1426FC500) ---
Parameter *__fastcall sub_1426FC500(Parameter *Parameter)
{
  *(_QWORD *)Parameter = 0;
  *((_QWORD *)Parameter + 1) = 0;
  *((_QWORD *)Parameter + 2) = 0;
  _StarEngineModule__((ULONG_PTR)Parameter);
  return Parameter;
}

// --- End Function: sub_1426FC500 (0x1426FC500) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142744750 (0x142744750) ---
__int64 __fastcall sub_142744750(unsigned __int8 input_byte)
{
  return (unsigned int)input_byte + 0xC7;
}

// --- End Function: sub_142744750 (0x142744750) ---

// --- Function: sub_142749980 (0x142749980) ---
__int64 __fastcall sub_142749980(__int64 a1)
{
  __int64 result; // rax
  bool v2; // [rsp+20h] [rbp-28h]
  unsigned __int8 (__fastcall ***v3)(_QWORD, _QWORD); // [rsp+28h] [rbp-20h]

  result = *(_BYTE *)(a1 + 0x1A) & 1;
  if ( (*(_BYTE *)(a1 + 0x1A) & 1) == 0 )
  {
    v3 = (unsigned __int8 (__fastcall ***)(_QWORD, _QWORD))(((__int64)(*(_QWORD *)(a1 + 0x10) << 0x10) >> 0x10)
                                                          & 0xFFFFFFFFFFFFLL);
    v2 = !v3 || (**v3)(v3, *(_WORD *)(a1 + 0x18) & 0x3FFF);
    result = v2 | *(_BYTE *)(a1 + 0x1A) & 0xFEu;
    *(_BYTE *)(a1 + 0x1A) = result;
  }
  return result;
}

// --- End Function: sub_142749980 (0x142749980) ---

// --- Function: sub_14277C8E0 (0x14277C8E0) ---
Parameter *__fastcall sub_14277C8E0(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  Parameter *Parameter_2; // [rsp+30h] [rbp-38h]
  _QWORD *v4; // [rsp+48h] [rbp-20h]

  v4 = (_QWORD *)((char *)Parameter + 8);
  Parameter_2 = (Parameter *)((char *)Parameter + 0x10);
  _StarEngineModule__((ULONG_PTR)Parameter);
  Parameter_1 = Parameter;
  if ( *(_QWORD *)Parameter )
  {
    std::_Deallocate<16,0>(
      *(_QWORD **)Parameter,
      0x10 * ((__int64)(*(_QWORD *)Parameter_2 - *(_QWORD *)Parameter) >> 4));
    *(_QWORD *)Parameter = 0;
    *v4 = 0;
    Parameter_1 = Parameter_2;
    *(_QWORD *)Parameter_2 = 0;
  }
  return Parameter_1;
}

// --- End Function: sub_14277C8E0 (0x14277C8E0) ---

// --- Function: sub_142E083B0 (0x142E083B0) ---
__int64 __fastcall sub_142E083B0(__int64 a1)
{
  return a1 + 0x1B0;
}

// --- End Function: sub_142E083B0 (0x142E083B0) ---

// --- Function: sub_1432639A0 (0x1432639A0) ---
__int64 __fastcall sub_1432639A0(__int64 a1, int a2, int a3, int a4)
{
  __int64 result; // rax

  result = a2;
  *(_DWORD *)(a1 + 4LL * a2 + 0x2A4) = a3;
  *(_DWORD *)(a1 + 4LL * a2 + 0x2C0) = a4;
  return result;
}

// --- End Function: sub_1432639A0 (0x1432639A0) ---

// --- Function: sub_1433852F0 (0x1433852F0) ---
__int64 __fastcall sub_1433852F0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 0xA0) = a2;
  return result;
}

// --- End Function: sub_1433852F0 (0x1433852F0) ---

// --- Function: sub_143828430 (0x143828430) ---
void __fastcall sub_143828430(__int64 a1, int *a2, unsigned __int64 a3)
{
  int *v5; // rcx
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // r15
  _QWORD *v10; // rsi
  unsigned __int64 allocSize; // r15
  __int64 v12; // rax
  size_t v13; // rbx
  int *v14; // rsi
  unsigned __int64 v15; // rdx
  int v16; // eax
  size_t v17; // rbx
  int *v18; // rdx
  int v19; // eax

  v5 = *(int **)a1;
  v6 = a3;
  v7 = (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v5) >> 3;
  if ( a3 > v7 )
  {
    if ( a3 > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v8 = v7 >> 1;
    if ( v7 <= 0x1FFFFFFFFFFFFFFFLL - (v7 >> 1) )
    {
      v9 = v8 + v7;
      if ( v8 + v7 < v6 )
        v9 = v6;
    }
    else
    {
      v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    v10 = 0;
    if ( v5 )
    {
      if ( 8 * v7 >= 0x1000 )
      {
        if ( (unsigned __int64)v5 - *((_QWORD *)v5 + 0xFFFFFFFF) - 8 > 0x1F )
          goto LABEL_17;
        v5 = (int *)*((_QWORD *)v5 + 0xFFFFFFFF);
      }
      sub_1402A3D30(v5);
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 0x10) = 0;
    }
    if ( v9 > 0x1FFFFFFFFFFFFFFFLL )
      goto LABEL_28;
    allocSize = 8 * v9;
    if ( allocSize < 0x1000 )
    {
      if ( allocSize )
        v10 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      goto LABEL_20;
    }
    if ( allocSize + 0x27 < allocSize )
LABEL_28:
      sub_1402E1170();
    v12 = allocWithProfilerInfo_w(allocSize + 0x27);
    if ( v12 )
    {
      v10 = (_QWORD *)((v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      v10[0xFFFFFFFF] = v12;
LABEL_20:
      *(_QWORD *)a1 = v10;
      *(_QWORD *)(a1 + 8) = v10;
      v13 = v6;
      *(_QWORD *)(a1 + 0x10) = &v10[allocSize / 8];
      memmove(v10, a2, v13 * 8);
      *(_QWORD *)(a1 + 8) = &v10[v13];
      return;
    }
LABEL_17:
    invalid_parameter_noinfo_noreturn();
  }
  v14 = *(int **)(a1 + 8);
  v15 = ((char *)v14 - (char *)v5) >> 3;
  if ( a3 <= v15 )
  {
    v18 = &v5[2 * a3];
    if ( a3 )
    {
      do
      {
        v19 = *a2;
        a2 += 2;
        *v5 = v19;
        v5 += 2;
        v5[0xFFFFFFFF] = a2[0xFFFFFFFF];
        --v6;
      }
      while ( v6 );
    }
    *(_QWORD *)(a1 + 8) = v18;
  }
  else
  {
    for ( ; v5 != v14; v14 = *(int **)(a1 + 8) )
    {
      *v5 = *a2;
      v16 = a2[1];
      a2 += 2;
      v5[1] = v16;
      v5 += 2;
    }
    v17 = 2 * (a3 - v15);
    memmove(v14, a2, v17 * 4);
    *(_QWORD *)(a1 + 8) = &v14[v17];
  }
}

// --- End Function: sub_143828430 (0x143828430) ---

// --- Function: CSCActorStatus::AdjustStatValue (0x143830970) ---
void sub_143830970(_QWORD *a1, int n29_3, double a3, ...)
{
  __int128 v3; // xmm6
  __int64 n29; // r12
  int n0x1D_1; // eax
  _BYTE *v7; // rcx
  __int64 v8; // rcx
  const char *String2_1; // rax
  int v10; // ebx
  const char *p_null_1; // rax
  const char *v12; // rbx
  const char *v13; // rax
  __int64 v14; // rax
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_4; // rbx
  const char *CLIENT:_2; // rdi
  __int64 v17; // rcx
  char v18; // al
  const char *p_Authoritative_2; // r8
  __int64 v20; // rax
  int v21; // ebx
  __int64 v22; // rax
  __int64 v23; // rcx
  __int64 v24; // rax
  __int64 *ThreadLogContextSlot_2; // rax
  __int64 n225; // rdi
  __int64 v27; // rcx
  char v28; // al
  __int64 v29; // rsi
  int v30; // ebx
  int n0x1D; // eax
  _BYTE *v32; // rcx
  __int64 v33; // rcx
  const char *String2; // rax
  const char *p_null; // rax
  const char *v36; // rdi
  const char *v37; // rax
  __int64 v38; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rax
  const char *CLIENT:; // rdi
  __int64 v41; // rcx
  char v42; // al
  const char *p_Authoritative; // r8
  __int64 v44; // rax
  int v45; // edi
  __int64 v46; // rax
  __int64 v47; // rcx
  __int64 v48; // rax
  __int64 *ThreadLogContextSlot; // rax
  float v50; // xmm8_4
  float v51; // xmm0_4
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // r9
  bool v55; // zf
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_3; // rax
  const char *CLIENT:_1; // rbx
  __int64 v58; // rcx
  char v59; // al
  const char *p_Authoritative_1; // r8
  __int64 v61; // rax
  int v62; // ebx
  float v63; // xmm6_4
  const char *v64; // rax
  const char *p_CSCActorStatus::AdjustStatValue_6; // rcx
  __int64 v66; // rax
  __int64 v67; // rcx
  __int64 v68; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 n225_2; // rbx
  __int64 v71; // r15
  unsigned __int64 v72; // rcx
  _DWORD *i; // rax
  __int64 v74; // rax
  __int64 n225_3; // rbx
  __int64 v76; // rax
  __int64 n225_4; // rbx
  __int64 v78; // rax
  __int16 n4; // dx
  __int64 v80; // rax
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_2; // [rsp+80h] [rbp-80h] BYREF
  char v82; // [rsp+88h] [rbp-78h] BYREF
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // [rsp+90h] [rbp-70h] BYREF
  __int64 n225_1; // [rsp+98h] [rbp-68h] BYREF
  __int64 *p_p_p_p_p_p_p_p_p_p_p_p_p_Source; // [rsp+A0h] [rbp-60h] BYREF
  char *v86; // [rsp+A8h] [rbp-58h]
  __int128 v87; // [rsp+B0h] [rbp-50h] BYREF
  const char *p_ClientServerInfo; // [rsp+C0h] [rbp-40h] BYREF
  const char *p_CSCActorStatus::AdjustStatValue_3; // [rsp+C8h] [rbp-38h]
  const void *v90; // [rsp+D0h] [rbp-30h]
  __int64 v91; // [rsp+D8h] [rbp-28h] BYREF
  const char *p_CSCActorStatus::AdjustStatValue_1; // [rsp+E0h] [rbp-20h]
  const void *v93; // [rsp+E8h] [rbp-18h]
  __int64 v94; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v95; // [rsp+F8h] [rbp-8h]
  const void *v96; // [rsp+100h] [rbp+0h]
  __int64 v97[2]; // [rsp+108h] [rbp+8h] BYREF
  unsigned __int64 *p_ClientServerInfo_2; // [rsp+118h] [rbp+18h] BYREF
  __int64 *p_n225; // [rsp+120h] [rbp+20h]
  const void *v100; // [rsp+128h] [rbp+28h]
  const char *p_ClientServerInfo_1; // [rsp+130h] [rbp+30h] BYREF
  const char *p_CSCActorStatus::AdjustStatValue; // [rsp+138h] [rbp+38h]
  const void *v103; // [rsp+140h] [rbp+40h]
  __int128 v104; // [rsp+148h] [rbp+48h] BYREF
  const void *v105; // [rsp+158h] [rbp+58h]
  __int64 v106; // [rsp+160h] [rbp+60h] BYREF
  __int64 v107; // [rsp+168h] [rbp+68h]
  char v108; // [rsp+170h] [rbp+70h]
  __int64 v109; // [rsp+180h] [rbp+80h] BYREF
  __int64 n0x1FF_12; // [rsp+188h] [rbp+88h]
  __int64 *p_n225_1; // [rsp+190h] [rbp+90h]
  _BYTE v112[520]; // [rsp+198h] [rbp+98h] BYREF
  __int64 v113; // [rsp+3A0h] [rbp+2A0h] BYREF
  __int64 n0x1FF_10; // [rsp+3A8h] [rbp+2A8h]
  const char *p_CSCActorStatus::AdjustStatValue_4; // [rsp+3B0h] [rbp+2B0h]
  _BYTE v116[520]; // [rsp+3B8h] [rbp+2B8h] BYREF
  __int64 v117; // [rsp+5C0h] [rbp+4C0h] BYREF
  __int64 n0x1FF_4; // [rsp+5C8h] [rbp+4C8h]
  const char *p_CSCActorStatus::AdjustStatValue_5; // [rsp+5D0h] [rbp+4D0h]
  _BYTE v120[520]; // [rsp+5D8h] [rbp+4D8h] BYREF
  __int64 v121; // [rsp+7E0h] [rbp+6E0h] BYREF
  __int64 n0x1FF_2; // [rsp+7E8h] [rbp+6E8h]
  _BYTE *v123; // [rsp+7F0h] [rbp+6F0h]
  _BYTE v124[520]; // [rsp+7F8h] [rbp+6F8h] BYREF
  __int64 v125; // [rsp+A00h] [rbp+900h] BYREF
  __int64 n0x1FF_6; // [rsp+A08h] [rbp+908h]
  const char *p_CSCActorStatus::AdjustStatValue_2; // [rsp+A10h] [rbp+910h]
  _BYTE v128[520]; // [rsp+A18h] [rbp+918h] BYREF
  __int64 v129; // [rsp+C20h] [rbp+B20h] BYREF
  __int64 n0x1FF_9; // [rsp+C28h] [rbp+B28h]
  _BYTE *v131; // [rsp+C30h] [rbp+B30h]
  _BYTE v132[520]; // [rsp+C38h] [rbp+B38h] BYREF
  __int64 v133; // [rsp+E40h] [rbp+D40h] BYREF
  __int64 n0x1FF_8; // [rsp+E48h] [rbp+D48h]
  _BYTE *v135; // [rsp+E50h] [rbp+D50h]
  _BYTE v136[520]; // [rsp+E58h] [rbp+D58h] BYREF
  __int64 v137; // [rsp+1060h] [rbp+F60h] BYREF
  __int64 n0x1FF_11; // [rsp+1068h] [rbp+F68h]
  _BYTE *v139; // [rsp+1070h] [rbp+F70h]
  _BYTE v140[520]; // [rsp+1078h] [rbp+F78h] BYREF
  __int64 v141; // [rsp+1280h] [rbp+1180h] BYREF
  __int64 n0x1FF_1; // [rsp+1288h] [rbp+1188h]
  _BYTE *v143; // [rsp+1290h] [rbp+1190h]
  _BYTE v144[520]; // [rsp+1298h] [rbp+1198h] BYREF
  __int64 v145; // [rsp+14A0h] [rbp+13A0h] BYREF
  __int64 n0x1FF; // [rsp+14A8h] [rbp+13A8h]
  _BYTE *v147; // [rsp+14B0h] [rbp+13B0h]
  _BYTE v148[520]; // [rsp+14B8h] [rbp+13B8h] BYREF
  __int64 v149; // [rsp+16C0h] [rbp+15C0h] BYREF
  __int64 n0x1FF_3; // [rsp+16C8h] [rbp+15C8h]
  _BYTE *v151; // [rsp+16D0h] [rbp+15D0h]
  _BYTE v152[520]; // [rsp+16D8h] [rbp+15D8h] BYREF
  __int64 v153; // [rsp+18E0h] [rbp+17E0h] BYREF
  __int64 n0x1FF_5; // [rsp+18E8h] [rbp+17E8h]
  _BYTE *v155; // [rsp+18F0h] [rbp+17F0h]
  _BYTE v156[520]; // [rsp+18F8h] [rbp+17F8h] BYREF
  __int64 v157; // [rsp+1B00h] [rbp+1A00h] BYREF
  __int64 n0x1FF_7; // [rsp+1B08h] [rbp+1A08h]
  _BYTE *v159; // [rsp+1B10h] [rbp+1A10h]
  _BYTE v160[520]; // [rsp+1B18h] [rbp+1A18h] BYREF
  __int128 v161; // [rsp+1D50h] [rbp+1C50h]
  __int64 v162; // [rsp+1DC8h] [rbp+1CC8h] BYREF
  va_list va; // [rsp+1DC8h] [rbp+1CC8h]
  __int64 v164; // [rsp+1DD0h] [rbp+1CD0h]
  va_list va1; // [rsp+1DD8h] [rbp+1CD8h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v162 = va_arg(va1, _QWORD);
  v164 = va_arg(va1, _QWORD);
  v161 = v3;
  n29 = n29_3;
  if ( sub_1438351C0((__int64)a1, n29_3) )
  {
    if ( *(float *)&a3 >= 0.00000011920929 || *(float *)&a3 <= -0.00000011920929 )
    {
      n225 = a1[n29 + 0x508];
      n225_1 = n225;
      if ( n225 )
      {
        v27 = *(_QWORD *)(a1[0x54] + 8LL) & 0xFFFFFFFFFFFFLL;
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x720LL))(v27)
          || *(_BYTE *)(*(_QWORD *)(n225 + 0x98) + 0x2ALL) )
        {
          v28 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 0x60LL))(a1);
          v29 = 0;
          v30 = (unsigned __int16)v164;
          v82 = v28;
          p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(int *)(n2_174 + 0x43C) > 0 )
          {
            n0x1D = sub_1427379F0(*(char **)(n2_174 + 0x440), 0x1D);
            if ( n0x1D == 0x1D || n0x1D == (_DWORD)n29 )
            {
              if ( ((v32 = *(_BYTE **)(n2_174 + 0x448), !*v32) || *v32 == 0x30) && !v32[1]
                || (v33 = *(_QWORD *)(a1[0x54] + 8LL) & 0xFFFFFFFFFFFFLL,
                    String2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v33 + 0x70LL))(v33),
                    !_stricmp(*(const char **)(n2_174 + 0x448), String2)) )
              {
                v148[0] = 0;
                v147 = v148;
                v145 = 0;
                v143 = v144;
                n0x1FF = 0x1FF;
                v144[0] = 0;
                v141 = 0;
                n0x1FF_1 = 0x1FF;
                if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)va) )
                  p_null = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v162 & 0xFFFFFFFFFFFFLL)
                                                                            + 0x70LL))(v162 & 0xFFFFFFFFFFFFLL);
                else
                  p_null = "null";
                v36 = *(const char **)(sub_1402A3190(
                                         (__int64)&v141,
                                         "OldValue: %.4f,  Adjustment: %.4f, Source: %s, HitId: %hu",
                                         *(float *)n225,
                                         *(float *)&a3,
                                         p_null,
                                         v30)
                                     + 0x10);
                v37 = sub_142FACAC0(n29, "UNDEFINED");
                v38 = sub_1402A3190((__int64)&v145, "| %s | %s", v37, v36);
                v124[0] = 0;
                v123 = v124;
                v121 = 0;
                n0x1FF_2 = 0x1FF;
                sub_1402A3BE0((__int64)&v121, *(const void **)(v38 + 0x10), *(_QWORD *)v38);
                if ( v143 != v144 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
                  sub_147605980(v143);
                }
                if ( v147 != v148 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
                  sub_147605980(v147);
                }
                sub_1464E72C0(qword_149E7E438, v97);
                v151 = v152;
                v152[0] = 0;
                v149 = 0;
                n0x1FF_3 = 0x1FF;
                if ( byte_149B4FE80 || !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)v97) )
                  p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
                else
                  p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v97[0] & 0xFFFFFFFFFFFFLL) + 0x70LL))(v97[0] & 0xFFFFFFFFFFFFLL);
                CLIENT: = "CLIENT: ";
                p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = (__int64)p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
                if ( byte_149B4FE80 )
                  CLIENT: = "SERVER";
                v41 = *(_QWORD *)(a1[0x54] + 8LL) & 0xFFFFFFFFFFFFLL;
                v42 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v41 + 0x720LL))(v41);
                p_Authoritative = "Non-Authoritative";
                if ( v42 )
                  p_Authoritative = "Authoritative";
                v44 = sub_1402A3190(
                        (__int64)&v149,
                        "%s %s%s",
                        p_Authoritative,
                        CLIENT:,
                        p_p_p_p_p_p_p_p_p_p_p_p_Source_2);
                v120[0] = 0;
                p_CSCActorStatus::AdjustStatValue_5 = v120;
                v117 = 0;
                n0x1FF_4 = 0x1FF;
                sub_1402A3BE0((__int64)&v117, *(const void **)(v44 + 0x10), *(_QWORD *)v44);
                if ( v151 != v152 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_3;
                  sub_147605980(v151);
                }
                p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = 0xE1;
                p_p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
                v86 = &v82;
                v45 = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)&p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
                        (__int64)"ACTOR STAT PREDICTION",
                        "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
                if ( (v45 & 0xFFFFF) != 0 )
                {
                  p_CSCActorStatus::AdjustStatValue = "CSCActorStatus::AdjustStatValue";
                  v95 = (__int64)v123;
                  p_ClientServerInfo = "ClientServerInfo";
                  p_CSCActorStatus::AdjustStatValue_3 = p_CSCActorStatus::AdjustStatValue_5;
                  v46 = a1[0x54];
                  v94 = 0;
                  v96 = 0;
                  p_ClientServerInfo_2 = 0;
                  LODWORD(p_n225) = 0xCB1;
                  p_ClientServerInfo_1 = 0;
                  v103 = 0;
                  v90 = 0;
                  v47 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 **))(*(_QWORD *)(*(_QWORD *)(v46 + 8)
                                                                                              & 0xFFFFFFFFFFFFLL)
                                                                                  + 8LL))(
                                     *(_QWORD *)(v46 + 8) & 0xFFFFFFFFFFFFLL,
                                     &p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
                  v48 = a1[0x54];
                  v107 = v47;
                  v106 = 0;
                  v108 = 0;
                  p_CSCActorStatus::AdjustStatValue_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFLL) + 0x70LL))(*(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFLL);
                  v91 = 0;
                  v93 = 0;
                  ThreadLogContextSlot = getThreadLogContextSlot();
                  p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = 0xE1;
                  *(_QWORD *)&v87 = &p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
                  *((_QWORD *)&v87 + 1) = &v82;
                  v104 = 0;
                  sub_14382B160(
                    5u,
                    (__int64 *)&v87,
                    "ACTOR STAT PREDICTION",
                    "Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                    1,
                    v45,
                    &v104,
                    0,
                    (__int64)ThreadLogContextSlot,
                    &v91,
                    &v106,
                    &p_ClientServerInfo,
                    &p_ClientServerInfo_1,
                    &p_ClientServerInfo_2,
                    &v94);
                  sub_1402A3D30(v93);
                  sub_1402A3D30(v90);
                  sub_1402A3D30(v103);
                  sub_1402A3D30(v96);
                }
                if ( p_CSCActorStatus::AdjustStatValue_5 != v120 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_4;
                  sub_147605980(p_CSCActorStatus::AdjustStatValue_5);
                }
                if ( v123 != v124 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_2;
                  sub_147605980(v123);
                }
                n225 = n225_1;
              }
            }
          }
          v50 = *(float *)n225;
          sub_1438692A0(a1, n29, n225, a3, 1, 1, v162, v30);
          sub_14386E1C0((__int64)a1, n225, 0.0);
          sub_143867C00((__int64)a1, n29, n225, 1);
          *((_BYTE *)a1 + n29 + 0x2A0E) = 1;
          if ( byte_149B501D5 )
          {
            if ( sub_1465D1DE0(a1[0x54]) )
            {
              if ( (unsigned int)n29 <= 1 )
              {
                v51 = *(float *)(*(_QWORD *)(n225 + 0x98) + 0xCLL);
                if ( v51 == *(float *)n225 && v51 == *(float *)(n225 + 0x1C) )
                {
                  v52 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pGame + 0xA0LL))(pGame);
                  v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 0x260LL))(v52);
                  LOBYTE(v54) = 1;
                  (*(void (__fastcall **)(__int64, __int64, _QWORD, __int64))(*(_QWORD *)v53 + 0x18LL))(
                    v53,
                    0x18,
                    0,
                    v54);
                }
              }
            }
          }
          if ( !v82 )
          {
            if ( (*(unsigned __int8 (__fastcall **)(_QWORD *))(*a1 + 0x60LL))(a1) )
            {
              sub_143830370((__int64)a1);
              if ( *(int *)(n2_174 + 0x438) > 0 )
              {
                sub_1464E72C0(qword_149E7E438, &n225_1);
                v55 = byte_149B4FE80 == 0;
                v155 = v156;
                v156[0] = 0;
                v153 = 0;
                n0x1FF_5 = 0x1FF;
                if ( !byte_149B4FE80 )
                {
                  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&n225_1) )
                    p_p_p_p_p_p_p_p_p_p_p_p_Source_3 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(n225_1 & 0xFFFFFFFFFFFFLL) + 0x70LL))(n225_1 & 0xFFFFFFFFFFFFLL);
                  else
                    p_p_p_p_p_p_p_p_p_p_p_p_Source_3 = &p_p_p_p_p_p_p_p_p_p_p_Source;
                  v55 = byte_149B4FE80 == 0;
                  p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)p_p_p_p_p_p_p_p_p_p_p_p_Source_3;
                }
                CLIENT:_1 = "CLIENT: ";
                if ( !v55 )
                  CLIENT:_1 = "SERVER";
                v58 = *(_QWORD *)(a1[0x54] + 8LL) & 0xFFFFFFFFFFFFLL;
                v59 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x720LL))(v58);
                p_Authoritative_1 = "Non-Authoritative";
                if ( v59 )
                  p_Authoritative_1 = "Authoritative";
                v61 = sub_1402A3190(
                        (__int64)&v153,
                        "%s %s%s",
                        p_Authoritative_1,
                        CLIENT:_1,
                        p_p_p_p_p_p_p_p_p_p_p_p_Source);
                v128[0] = 0;
                p_CSCActorStatus::AdjustStatValue_2 = v128;
                v125 = 0;
                n0x1FF_6 = 0x1FF;
                sub_1402A3BE0((__int64)&v125, *(const void **)(v61 + 0x10), *(_QWORD *)v61);
                if ( v155 != v156 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_5;
                  sub_147605980(v155);
                }
                p_p_p_p_p_p_p_p_p_p_p_p_Source = 0xE1;
                *(_QWORD *)&v87 = &p_p_p_p_p_p_p_p_p_p_p_p_Source;
                *((_QWORD *)&v87 + 1) = &n225_1;
                v62 = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)&v87,
                        (__int64)"ACTOR INCAPACITATED",
                        "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
                if ( (v62 & 0xFFFFF) != 0 )
                {
                  v63 = *(float *)n225;
                  v159 = v160;
                  v160[0] = 0;
                  v157 = 0;
                  n0x1FF_7 = 0x1FF;
                  v64 = sub_142FACAC0(n29, "UNDEFINED");
                  p_CSCActorStatus::AdjustStatValue_6 = *(const char **)(sub_1402A3190(
                                                                           (__int64)&v157,
                                                                           "Actor Incapacitated for change in stat: %s, O"
                                                                           "ldValue: %.4f, CurrentValue: %.4f",
                                                                           v64,
                                                                           v50,
                                                                           v63)
                                                                       + 0x10);
                  p_CSCActorStatus::AdjustStatValue_1 = "CSCActorStatus::AdjustStatValue";
                  p_ClientServerInfo_1 = "ClientServerInfo";
                  p_CSCActorStatus::AdjustStatValue = p_CSCActorStatus::AdjustStatValue_2;
                  v66 = a1[0x54];
                  p_CSCActorStatus::AdjustStatValue_3 = p_CSCActorStatus::AdjustStatValue_6;
                  p_ClientServerInfo = 0;
                  v90 = 0;
                  *(_QWORD *)&v87 = 0;
                  DWORD2(v87) = 0xCBE;
                  v91 = 0;
                  v93 = 0;
                  v103 = 0;
                  v67 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 **))(*(_QWORD *)(*(_QWORD *)(v66 + 8)
                                                                                              & 0xFFFFFFFFFFFFLL)
                                                                                  + 8LL))(
                                     *(_QWORD *)(v66 + 8) & 0xFFFFFFFFFFFFLL,
                                     &p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
                  v68 = a1[0x54];
                  v107 = v67;
                  v106 = 0;
                  v108 = 0;
                  v95 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v68 + 8) & 0xFFFFFFFFFFFFLL)
                                                           + 0x70LL))(*(_QWORD *)(v68 + 8) & 0xFFFFFFFFFFFFLL);
                  v94 = 0;
                  v96 = 0;
                  ThreadLogContextSlot_1 = getThreadLogContextSlot();
                  p_p_p_p_p_p_p_p_p_p_p_p_Source = 0xE1;
                  p_ClientServerInfo_2 = &p_p_p_p_p_p_p_p_p_p_p_p_Source;
                  p_n225 = &n225_1;
                  v104 = 0;
                  sub_14382B160(
                    5u,
                    (__int64 *)&p_ClientServerInfo_2,
                    "ACTOR INCAPACITATED",
                    "Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                    1,
                    v62,
                    &v104,
                    0,
                    (__int64)ThreadLogContextSlot_1,
                    &v94,
                    &v106,
                    &p_ClientServerInfo_1,
                    &v91,
                    &v87,
                    &p_ClientServerInfo);
                  sub_1402A3D30(v96);
                  sub_1402A3D30(v103);
                  sub_1402A3D30(v93);
                  sub_1402A3D30(v90);
                  if ( v159 != v160 )
                  {
                    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_7;
                    sub_147605980(v159);
                  }
                }
                if ( p_CSCActorStatus::AdjustStatValue_2 != v128 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_6;
                  sub_147605980(p_CSCActorStatus::AdjustStatValue_2);
                }
              }
            }
          }
          if ( sub_14384AFD0((__int64)a1, n29) )
            sub_144AE9BE0((__int64)(a1 + 0x7C), n29);
          n225_2 = a1[0x90];
          n225_1 = n225_2;
          if ( is_valid_handle_typeA(&n225_1) )
          {
            v71 = a1[0x556];
            if ( v71 )
            {
              v72 = *(_QWORD *)(v71 + 0x180);
              if ( v72 )
              {
                for ( i = (_DWORD *)(*(_QWORD *)(v71 + 0x178) + 8LL); *i != (_DWORD)n29; i += 0x10 )
                {
                  if ( ++v29 >= v72 )
                    return;
                }
                v74 = sub_14379A460(n225_2 & 0xFFFFFFFFFFFFLL);
                v97[0] = v29 << 6;
                sub_143863CC0((__int64)a1, n29, n225, v50 > *(float *)n225, *(_QWORD *)(v71 + 0x178) + (v29 << 6), v74);
                n225_3 = a1[0x92];
                n225_1 = n225_3;
                if ( is_valid_handle_typeA(&n225_1) )
                {
                  v76 = sub_14379A460(n225_3 & 0xFFFFFFFFFFFFLL);
                  sub_143863CC0((__int64)a1, n29, n225, v50 > *(float *)n225, *(_QWORD *)(v71 + 0x178) + v97[0], v76);
                }
                n225_4 = a1[0x93];
                n225_1 = n225_4;
                if ( n225_4 )
                {
                  v78 = sub_1403B4B50(n225_4 & 0xFFFFFFFFFFFFLL);
                  n4 = *(_WORD *)(v78 + 4);
                  if ( n4 != 4
                    && *(_WORD *)(v78 + 2) == (HIWORD(n225_4) & 0xFFF)
                    && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_14031FE20(&n225_1)) )
                  {
                    v80 = sub_14379A460(n225_4 & 0xFFFFFFFFFFFFLL);
                    sub_143863CC0(
                      (__int64)a1,
                      n29,
                      n225,
                      v50 > *(float *)n225,
                      *(_QWORD *)(v71 + 0x178) + (v29 << 6),
                      v80);
                  }
                }
              }
            }
          }
        }
      }
    }
    else if ( *(int *)(n2_174 + 0x43C) > 0 )
    {
      n0x1D_1 = sub_1427379F0(*(char **)(n2_174 + 0x440), 0x1D);
      if ( n0x1D_1 == 0x1D || n0x1D_1 == (_DWORD)n29 )
      {
        if ( ((v7 = *(_BYTE **)(n2_174 + 0x448), !*v7) || *v7 == 0x30) && !v7[1]
          || (v8 = *(_QWORD *)(a1[0x54] + 8LL) & 0xFFFFFFFFFFFFLL,
              String2_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x70LL))(v8),
              !_stricmp(*(const char **)(n2_174 + 0x448), String2_1)) )
        {
          v10 = (unsigned __int16)v164;
          v135 = v136;
          v136[0] = 0;
          v131 = v132;
          v133 = 0;
          n0x1FF_8 = 0x1FF;
          v132[0] = 0;
          v129 = 0;
          n0x1FF_9 = 0x1FF;
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)va) )
            p_null_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v162 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v162 & 0xFFFFFFFFFFFFLL);
          else
            p_null_1 = "null";
          v12 = *(const char **)(sub_1402A3190(
                                   (__int64)&v129,
                                   "Invalid Adjustment: %.4f, Source: %s, HitId: %hu",
                                   *(float *)&a3,
                                   p_null_1,
                                   v10)
                               + 0x10);
          v13 = sub_142FACAC0(n29, "UNDEFINED");
          v14 = sub_1402A3190((__int64)&v133, "| %s | %s", v13, v12);
          v116[0] = 0;
          p_CSCActorStatus::AdjustStatValue_4 = v116;
          v113 = 0;
          n0x1FF_10 = 0x1FF;
          sub_1402A3BE0((__int64)&v113, *(const void **)(v14 + 0x10), *(_QWORD *)v14);
          if ( v131 != v132 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_9;
            sub_147605980(v131);
          }
          if ( v135 != v136 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_8;
            sub_147605980(v135);
          }
          sub_1464E72C0(qword_149E7E438, &p_p_p_p_p_p_p_p_p_p_p_p_Source);
          v139 = v140;
          v140[0] = 0;
          v137 = 0;
          n0x1FF_11 = 0x1FF;
          if ( byte_149B4FE80 || !is_entity_descriptor_valid_or_accessible(&p_p_p_p_p_p_p_p_p_p_p_p_Source) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_4 = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
          else
            p_p_p_p_p_p_p_p_p_p_p_p_Source_4 = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source & 0xFFFFFFFFFFFFLL) + 0x70LL))(p_p_p_p_p_p_p_p_p_p_p_p_Source & 0xFFFFFFFFFFFFLL);
          CLIENT:_2 = "CLIENT: ";
          if ( byte_149B4FE80 )
            CLIENT:_2 = "SERVER";
          v17 = *(_QWORD *)(a1[0x54] + 8LL) & 0xFFFFFFFFFFFFLL;
          v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x720LL))(v17);
          p_Authoritative_2 = "Non-Authoritative";
          if ( v18 )
            p_Authoritative_2 = "Authoritative";
          v20 = sub_1402A3190((__int64)&v137, "%s %s%s", p_Authoritative_2, CLIENT:_2, p_p_p_p_p_p_p_p_p_p_p_p_Source_4);
          v112[0] = 0;
          p_n225_1 = (__int64 *)v112;
          v109 = 0;
          n0x1FF_12 = 0x1FF;
          sub_1402A3BE0((__int64)&v109, *(const void **)(v20 + 0x10), *(_QWORD *)v20);
          if ( v139 != v140 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_11;
            sub_147605980(v139);
          }
          p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = 0xE1;
          p_p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
          v86 = &v82;
          v21 = invokeGlobalCallbackAndMaskStatusBits(
                  5,
                  (__int64)&p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
                  (__int64)"ACTOR STAT PREDICTION",
                  "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
          if ( (v21 & 0xFFFFF) != 0 )
          {
            p_CSCActorStatus::AdjustStatValue_3 = "CSCActorStatus::AdjustStatValue";
            p_CSCActorStatus::AdjustStatValue_1 = p_CSCActorStatus::AdjustStatValue_4;
            p_ClientServerInfo_2 = (unsigned __int64 *)"ClientServerInfo";
            p_n225 = p_n225_1;
            v22 = a1[0x54];
            v91 = 0;
            v93 = 0;
            p_p_p_p_p_p_p_p_p_p_p_p_p_Source = 0;
            LODWORD(v86) = 0xC9D;
            p_ClientServerInfo = 0;
            v90 = 0;
            v100 = 0;
            v23 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(*(_QWORD *)(v22 + 8)
                                                                                       & 0xFFFFFFFFFFFFLL)
                                                                           + 8LL))(
                               *(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFLL,
                               &n225_1);
            v24 = a1[0x54];
            v95 = v23;
            v94 = 0;
            LOBYTE(v96) = 0;
            *((_QWORD *)&v104 + 1) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v24 + 8)
                                                                                    & 0xFFFFFFFFFFFFLL)
                                                                        + 0x70LL))(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFLL);
            *(_QWORD *)&v104 = 0;
            v105 = 0;
            ThreadLogContextSlot_2 = getThreadLogContextSlot();
            p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = 0xE1;
            v97[0] = (__int64)&p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
            v97[1] = (__int64)&v82;
            v87 = 0;
            sub_14382B160(
              5u,
              v97,
              "ACTOR STAT PREDICTION",
              "Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
              1,
              v21,
              &v87,
              0,
              (__int64)ThreadLogContextSlot_2,
              &v104,
              &v94,
              &p_ClientServerInfo_2,
              &p_ClientServerInfo,
              &p_p_p_p_p_p_p_p_p_p_p_p_p_Source,
              &v91);
            sub_1402A3D30(v105);
            sub_1402A3D30(v100);
            sub_1402A3D30(v90);
            sub_1402A3D30(v93);
          }
          if ( p_n225_1 != (__int64 *)v112 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_12;
            sub_147605980(p_n225_1);
          }
          if ( p_CSCActorStatus::AdjustStatValue_4 != v116 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_10;
            sub_147605980(p_CSCActorStatus::AdjustStatValue_4);
          }
        }
      }
    }
  }
}

// --- End Function: CSCActorStatus::AdjustStatValue (0x143830970) ---

// --- Function: sub_14384CC10 (0x14384CC10) ---
void __fastcall sub_14384CC10(__int64 actor_stat, __int64 a2)
{
  __int64 actor_stat_1; // rax
  __int64 v4; // rdx
  __int64 actor_stat_2; // rsi
  __int64 v6; // rdi
  __int64 i; // rbp
  __int64 n29; // rdx
  float *v9; // rax
  float v10; // xmm1_4
  unsigned int *v11; // rax
  __int64 v12; // xmm0_8
  double v13; // kr00_8
  bool v14; // zf
  bool v15; // al
  __int64 v16; // [rsp+20h] [rbp-18h]

  actor_stat_1 = get_actor_stat(a2);
  v4 = *(_QWORD *)(actor_stat + 0x2AB0);
  actor_stat_2 = actor_stat_1;
  v6 = *(_QWORD *)(v4 + 0x48);
  for ( i = v6 + (*(_QWORD *)(v4 + 0x50) << 7); v6 != i; v6 += 0x80 )
  {
    n29 = *(int *)(v6 + 8);
    v9 = *(float **)(actor_stat + 8 * n29 + 0x2840);
    if ( v9 )
      v10 = *v9;
    else
      v10 = 0.0;
    v11 = *(unsigned int **)(actor_stat_2 + 8 * n29 + 0x2840);
    if ( v11 )
      v12 = *v11;
    else
      v12 = 0;
    HIDWORD(v13) = HIDWORD(v12);
    *(float *)&v13 = *(float *)&v12 - v10;
    LOWORD(v16) = 0xFFFF;
    CSCActorStatus::AdjustStatValue((_QWORD *)actor_stat, n29, v13, 0, v16);
  }
  v14 = (*(_BYTE *)(actor_stat + 0xF2) & 1) == 0;
  *(_OWORD *)(actor_stat + 0xD8) = *(_OWORD *)(actor_stat_2 + 0xD8);
  if ( v14 )
  {
    v15 = (*(_QWORD *)(actor_stat + 0xE8) & 0xFFFFFFFFFFFFLL) == 0
       || (**(unsigned __int8 (__fastcall ***)(__int64, _QWORD))(*(_QWORD *)(actor_stat + 0xE8) & 0xFFFFFFFFFFFFLL))(
            *(_QWORD *)(actor_stat + 0xE8) & 0xFFFFFFFFFFFFLL,
            *(_WORD *)(actor_stat + 0xF0) & 0x3FFF);
    *(_BYTE *)(actor_stat + 0xF2) &= ~1u;
    *(_BYTE *)(actor_stat + 0xF2) |= v15;
  }
  if ( actor_stat + 0x2AC0 != actor_stat_2 + 0x2AC0 )
    sub_143828430(
      actor_stat + 0x2AC0,
      *(int **)(actor_stat_2 + 0x2AC0),
      (__int64)(*(_QWORD *)(actor_stat_2 + 0x2AC8) - *(_QWORD *)(actor_stat_2 + 0x2AC0)) >> 3);
}

// --- End Function: sub_14384CC10 (0x14384CC10) ---

// --- Function: sub_143E58000 (0x143E58000) ---
_DWORD *__fastcall sub_143E58000(_DWORD *a1, _DWORD *a2)
{
  a2[3] = a1[0x31];
  *a2 = a1[0x2E];
  a2[1] = a1[0x2F];
  a2[2] = a1[0x30];
  return a2;
}

// --- End Function: sub_143E58000 (0x143E58000) ---

// --- Function: sub_143F20350 (0x143F20350) ---
__int64 __fastcall sub_143F20350(__int64 a1)
{
  return a1 - 0x40;
}

// --- End Function: sub_143F20350 (0x143F20350) ---

// --- Function: sub_143F2D0F0 (0x143F2D0F0) ---
__int64 __fastcall sub_143F2D0F0(__int64 a1)
{
  __int64 v2; // [rsp+20h] [rbp-18h]

  v2 = *(_QWORD *)(sub_143F20350(a1) + 0x268);
  return sub_142E083B0(v2);
}

// --- End Function: sub_143F2D0F0 (0x143F2D0F0) ---

// --- Function: sub_1440A35D0 (0x1440A35D0) ---
__int64 __fastcall sub_1440A35D0(__int64 a1)
{
  return a1 + 0x390;
}

// --- End Function: sub_1440A35D0 (0x1440A35D0) ---

// --- Function: sub_1443C81C0 (0x1443C81C0) ---
__int64 __fastcall sub_1443C81C0(__int64 a1, char a2, __int64 a3, __int16 a4)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 4) = a2;
  *(_DWORD *)a1 = 0x1B;
  sub_141BDC970(a1 + 8, a3);
  result = a1;
  *(_WORD *)(a1 + 0x80) = a4;
  return result;
}

// --- End Function: sub_1443C81C0 (0x1443C81C0) ---

// --- Function: sub_1446F9CC0 (0x1446F9CC0) ---
void __fastcall sub_1446F9CC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  void (__fastcall *n2)(__int64, __int64); // rax

  v2 = a1 + 0x150;
  v4 = *(_QWORD *)(a1 + 0x188);
  if ( v4 )
  {
    LOBYTE(a2) = v4 != v2;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 0x20LL))(v4, a2);
    *(_QWORD *)(v2 + 0x38) = 0;
  }
  v5 = *(_QWORD *)(a1 + 0x1C8);
  if ( v5 )
  {
    LOBYTE(a2) = v5 != a1 + 0x190;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 0x20LL))(v5, a2);
    *(_QWORD *)(a1 + 0x1C8) = 0;
  }
  v6 = *(_QWORD *)(a1 + 0x248);
  if ( v6 )
  {
    LOBYTE(a2) = v6 != a1 + 0x210;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x20LL))(v6, a2);
    *(_QWORD *)(a1 + 0x248) = 0;
  }
  n2 = *(void (__fastcall **)(__int64, __int64))(a1 + 0x30);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1 + 0x28);
    *(_QWORD *)(a1 + 0x30) = 0;
  }
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_DWORD *)(a1 + 0x40) = 0;
  sub_1404ECA40(a1);
}

// --- End Function: sub_1446F9CC0 (0x1446F9CC0) ---

// --- Function: sub_144707640 (0x144707640) ---
void __fastcall sub_144707640(_QWORD *a1, __crt_win32_buffer_debug_info *a2)
{
  const char *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  __int16 n4; // cx
  const char *v8; // rax
  __int16 v9; // rbx^6
  __int64 v10; // rdi
  __int64 v11; // rax
  __int16 n4_1; // cx
  __int64 v13; // rdi
  __int64 v14; // rax
  void (__fastcall ***v15)(_QWORD, __int64); // rbx
  __int64 n0xFFFF; // r8
  unsigned __int8 (__fastcall *v17)(__int64, _QWORD *, __int64, void (__fastcall ***)(_QWORD, __int64), const char *, char); // rsi
  __int16 *v18; // rax
  __int64 v19; // [rsp+68h] [rbp+20h] BYREF

  if ( !BYTE1(isSandboxEditor) )
  {
    v4 = __crt_win32_buffer_debug_info::file_name(a2);
    sub_141873D00((__int64)v4, &v19);
    v5 = v19;
    *a1 = v19;
    v19 = v5;
    if ( v5 )
    {
      v6 = sub_1403B4B50(v5 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v6 + 4);
      if ( n4 != 4
        && *(_WORD *)(v6 + 2) == (HIWORD(v5) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v19)) )
      {
        *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x5D8LL))(v5 & 0xFFFFFFFFFFFFLL)
                 + 0x19) = 0xFF;
      }
    }
    v8 = __crt_win32_buffer_debug_info::file_name(a2);
    sub_14033A9E0((__int64)v8, &v19);
    v9 = HIWORD(v19);
    if ( v19 )
    {
      v10 = v19 & 0xFFFFFFFFFFFFLL;
      v11 = sub_1403B4B50(v19 & 0xFFFFFFFFFFFFLL);
      n4_1 = *(_WORD *)(v11 + 4);
      if ( n4_1 != 4
        && *(_WORD *)(v11 + 2) == (v9 & 0xFFF)
        && (n4_1 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v19)) )
      {
        v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x600LL))(v10);
        if ( v13 )
        {
          v14 = allocWithProfilerInfo_w(0x50u);
          v15 = (void (__fastcall ***)(_QWORD, __int64))v14;
          if ( v14 )
          {
            *(_DWORD *)(v14 + 8) = 0;
            *(_QWORD *)(v14 + 0x10) = &p_p_p_p_p_p_p_p_p_p_p_Source;
            *(_QWORD *)v14 = &off_14897C6B0;
            *(_QWORD *)(v14 + 0x40) = sub_14470BDA0;
            *(_QWORD *)(v14 + 0x48) = sub_14470BEB0;
            *(_DWORD *)(v14 + 0x18) = 0xFFFFFFFF;
            *(_DWORD *)(v14 + 0x1C) = 0;
            *(_QWORD *)(v14 + 0x20) = 0;
            *(_QWORD *)(v14 + 0x28) = 0;
            *(_QWORD *)(v14 + 0x30) = 0;
            *(_QWORD *)(v14 + 0x38) = a1;
          }
          else
          {
            v15 = 0;
          }
          n0xFFFF = (unsigned __int16)n0xFFFF_6;
          v17 = *(unsigned __int8 (__fastcall **)(__int64, _QWORD *, __int64, void (__fastcall ***)(_QWORD, __int64), const char *, char))(*(_QWORD *)v13 + 0x28LL);
          if ( n0xFFFF_6 == (__int16)0xFFFF )
          {
            v18 = (__int16 *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                         + 0x10LL))(
                               pEngineComponentScheduler,
                               &v19,
                               "IAttachableComponent");
            n0xFFFF = (unsigned __int16)*v18;
            n0xFFFF_6 = *v18;
          }
          if ( !v17(v13, a1, n0xFFFF, v15, "CSCActorResultHelperStateInvisible", 1) )
          {
            if ( v15 )
              (**v15)(v15, 1);
          }
        }
      }
    }
  }
}

// --- End Function: sub_144707640 (0x144707640) ---

// --- Function: sub_144707EF0 (0x144707EF0) ---
void __fastcall sub_144707EF0(__int64 *a1, __crt_win32_buffer_debug_info *a2)
{
  const char *v3; // rax
  __int16 v4; // rbx^6
  __int64 v5; // rdi
  __int64 v6; // rax
  __int16 n4; // cx
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 v10; // rbx
  __int64 n0xFFFF; // r8
  void (__fastcall *v12)(__int64, __int64 *, __int64, __int64); // rdi
  __int16 *v13; // rax
  __int64 v14; // rbx
  __int64 v15; // rax
  __int16 n4_1; // dx
  __int64 v17; // [rsp+58h] [rbp+20h] BYREF

  if ( !BYTE1(isSandboxEditor) )
  {
    v3 = __crt_win32_buffer_debug_info::file_name(a2);
    sub_14033A9E0((__int64)v3, &v17);
    v4 = HIWORD(v17);
    if ( v17 )
    {
      v5 = v17 & 0xFFFFFFFFFFFFLL;
      v6 = sub_1403B4B50(v17 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v6 + 4);
      if ( n4 != 4
        && *(_WORD *)(v6 + 2) == (v4 & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v17)) )
      {
        v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x600LL))(v5);
        v10 = v8;
        if ( v8 )
        {
          n0xFFFF = (unsigned __int16)n0xFFFF_6;
          v12 = *(void (__fastcall **)(__int64, __int64 *, __int64, __int64))(*(_QWORD *)v8 + 0x30LL);
          if ( n0xFFFF_6 == (__int16)0xFFFF )
          {
            v13 = (__int16 *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                         + 0x10LL))(
                               pEngineComponentScheduler,
                               &v17,
                               "IAttachableComponent");
            n0xFFFF = (unsigned __int16)*v13;
            n0xFFFF_6 = *v13;
          }
          LOBYTE(v9) = 1;
          v12(v10, a1, n0xFFFF, v9);
        }
      }
    }
    v14 = *a1;
    v17 = v14;
    if ( v14 )
    {
      v15 = sub_1403B4B50(v14 & 0xFFFFFFFFFFFFLL);
      n4_1 = *(_WORD *)(v15 + 4);
      if ( n4_1 != 4
        && *(_WORD *)(v15 + 2) == (HIWORD(v14) & 0xFFF)
        && (n4_1 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v17)) )
      {
        *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v14 & 0xFFFFFFFFFFFFLL) + 0x5D8LL))(v14 & 0xFFFFFFFFFFFFLL)
                 + 0x19) = 0;
      }
    }
    *a1 = 0;
  }
}

// --- End Function: sub_144707EF0 (0x144707EF0) ---

// --- Function: sub_144E3FA70 (0x144E3FA70) ---
__int64 __fastcall sub_144E3FA70(
        __int64 a1,
        __int64 *ThreadLogContextSlot,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        _QWORD *a7)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_144E407E0(a1 + 0x70, a3, a4, a5, a6, a7) + 1;
}

// --- End Function: sub_144E3FA70 (0x144E3FA70) ---

// --- Function: sub_144E55970 (0x144E55970) ---
__int64 __fastcall sub_144E55970(unsigned __int64 *a1, __int64 a2)
{
  __int64 result; // rax
  char v3; // al
  char v4; // al
  void *v5; // rsp
  __int64 v6; // [rsp+18h] [rbp-248h]
  _BYTE v7[480]; // [rsp+30h] [rbp-230h] BYREF
  int v9; // [rsp+264h] [rbp+4h]
  _DWORD v10[2]; // [rsp+268h] [rbp+8h] BYREF
  char v11; // [rsp+270h] [rbp+10h] BYREF
  _DWORD v12[2]; // [rsp+278h] [rbp+18h] BYREF
  char v13; // [rsp+280h] [rbp+20h] BYREF
  const char *p_pure_game; // [rsp+288h] [rbp+28h]
  const char *p_local_client; // [rsp+290h] [rbp+30h]
  unsigned __int64 v16; // [rsp+298h] [rbp+38h]
  const char *p_non_authoritative_dedicated_server; // [rsp+2A0h] [rbp+40h]
  const char *p_remote_client; // [rsp+2A8h] [rbp+48h]
  const char *p_local_client_1; // [rsp+2B0h] [rbp+50h]
  unsigned __int64 v20; // [rsp+2B8h] [rbp+58h]
  _BYTE *v21; // [rsp+2C0h] [rbp+60h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+2C8h] [rbp+68h]
  __int64 v23; // [rsp+2D0h] [rbp+70h]
  _QWORD *v24; // [rsp+2D8h] [rbp+78h]
  _QWORD *v25; // [rsp+2E0h] [rbp+80h]
  _QWORD *v26; // [rsp+2E8h] [rbp+88h]
  _QWORD *v27; // [rsp+2F0h] [rbp+90h]
  __int64 *ThreadLogContextSlot; // [rsp+2F8h] [rbp+98h]
  const void *v29; // [rsp+300h] [rbp+A0h]
  const void *v30; // [rsp+308h] [rbp+A8h]
  const void *v31; // [rsp+310h] [rbp+B0h]
  const void *v32; // [rsp+318h] [rbp+B8h]
  __int64 v33; // [rsp+320h] [rbp+C0h]
  const char *p_local_client_2; // [rsp+328h] [rbp+C8h]
  _QWORD v35[2]; // [rsp+330h] [rbp+D0h] BYREF
  const void *v36; // [rsp+340h] [rbp+E0h]
  _QWORD v37[2]; // [rsp+348h] [rbp+E8h] BYREF
  const void *v38; // [rsp+358h] [rbp+F8h]
  _QWORD v39[2]; // [rsp+360h] [rbp+100h] BYREF
  const void *v40; // [rsp+370h] [rbp+110h]
  _QWORD v41[2]; // [rsp+378h] [rbp+118h] BYREF
  const void *v42; // [rsp+388h] [rbp+128h]
  _QWORD src_[2]; // [rsp+390h] [rbp+130h] BYREF
  _QWORD src__1[2]; // [rsp+3A0h] [rbp+140h] BYREF
  _QWORD v45[3]; // [rsp+3B0h] [rbp+150h] BYREF
  _BYTE dst_[16]; // [rsp+3C8h] [rbp+168h] BYREF
  __int64 dst__1[2]; // [rsp+3D8h] [rbp+178h] BYREF

  result = (unsigned __int8)sub_144E5DE60(a1, off_149A443A0);
  if ( (_BYTE)result )
  {
    if ( sub_1465D1DE0((__int64)a1) )
    {
      if ( *(_BYTE *)(identity((__int64)&pSystem) + 0x2A0) )
      {
        v33 = identity((__int64)&pSystem);
        if ( *(_BYTE *)(v33 + 0x5F6) )
          p_pure_game = "editor";
        else
          p_pure_game = "pure game";
        p_local_client = p_pure_game;
      }
      else
      {
        p_local_client = "local client";
      }
      p_local_client_1 = p_local_client;
    }
    else
    {
      if ( *(_BYTE *)(identity((__int64)&pSystem) + 0x2A0) )
      {
        v16 = sub_1403E6750(a1 + 1);
        if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v16 + 0x720LL))(v16) )
          p_non_authoritative_dedicated_server = "authoritative dedicated server";
        else
          p_non_authoritative_dedicated_server = "non-authoritative dedicated server";
        p_remote_client = p_non_authoritative_dedicated_server;
      }
      else
      {
        p_remote_client = "remote client";
      }
      p_local_client_1 = p_remote_client;
    }
    p_local_client_2 = p_local_client_1;
    v3 = sub_14056A7D0(0x42);
    v10[0] = sub_142744750(v3);
    v10[1] = 0;
    src_[0] = v10;
    src_[1] = &v11;
    qmemcpy(dst_, src_, sizeof(dst_));
    v9 = invokeGlobalCallbackAndMaskStatusBits(
           5,
           (__int64)dst_,
           (__int64)"[ActorState] Body Drag",
           "[ACTOR STATE][$$] '$$' <$$>: $$");
    if ( (v9 & 0xFFFFF) != 0 )
    {
      v41[0] = 0;
      v41[1] = a2;
      v42 = 0;
      v24 = v41;
      v39[0] = 0;
      v39[1] = p_local_client_2;
      v40 = 0;
      v25 = v39;
      v20 = sub_1403E6750(a1 + 1);
      v23 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v20 + 0x70LL))(v20);
      v37[0] = 0;
      v37[1] = v23;
      v38 = 0;
      v26 = v37;
      v35[0] = 0;
      v35[1] = "SSCActorStateCVars::LogBodyDrag";
      v36 = 0;
      v27 = v35;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v45[0] = 0;
      v45[1] = 0;
      v4 = sub_14056A7D0(0x42);
      v12[0] = sub_142744750(v4);
      v12[1] = 0;
      src__1[0] = v12;
      src__1[1] = &v13;
      qmemcpy(dst__1, src__1, sizeof(dst__1));
      v45[2] = 5;
      v5 = alloca(0x230);
      v21 = v7;
      __Val_0__ = (vraudio::AudioBuffer *)v7;
      sub_144E3FE20((__int64)v7, (__int64)ThreadLogContextSlot, v27, v26, v25, v24);
      LODWORD(v6) = v9;
      sub_1403045C0(
        5u,
        dst__1,
        "[ActorState] Body Drag",
        "[ACTOR STATE][$$] '$$' <$$>: $$",
        __Val_0__,
        5u,
        1,
        v6,
        v45,
        0);
      v29 = v36;
      sub_1402A3D30(v36);
      v30 = v38;
      sub_1402A3D30(v38);
      v31 = v40;
      sub_1402A3D30(v40);
      v32 = v42;
      sub_1402A3D30(v42);
    }
    return 0;
  }
  return result;
}

// --- End Function: sub_144E55970 (0x144E55970) ---

// --- Function: sub_144E55DF0 (0x144E55DF0) ---
__int64 __fastcall sub_144E55DF0(unsigned __int64 *a1, __int64 a2)
{
  __int64 _2_; // rax
  char v3; // al
  char v4; // al
  void *v5; // rsp
  __int64 v6; // [rsp+18h] [rbp-2B8h]
  _BYTE v7[592]; // [rsp+30h] [rbp-2A0h] BYREF
  int v9; // [rsp+2D4h] [rbp+4h]
  _DWORD v10[2]; // [rsp+2D8h] [rbp+8h] BYREF
  char v11; // [rsp+2E0h] [rbp+10h] BYREF
  _DWORD v12[2]; // [rsp+2E8h] [rbp+18h] BYREF
  char v13; // [rsp+2F0h] [rbp+20h] BYREF
  const char *p_pure_game; // [rsp+2F8h] [rbp+28h]
  const char *p_local_client; // [rsp+300h] [rbp+30h]
  unsigned __int64 v16; // [rsp+308h] [rbp+38h]
  const char *p_non_authoritative_dedicated_server; // [rsp+310h] [rbp+40h]
  const char *p_remote_client; // [rsp+318h] [rbp+48h]
  const char *p_local_client_1; // [rsp+320h] [rbp+50h]
  unsigned __int64 v20; // [rsp+328h] [rbp+58h]
  unsigned __int64 v21; // [rsp+330h] [rbp+60h]
  __int64 v22; // [rsp+338h] [rbp+68h]
  _BYTE *v23; // [rsp+340h] [rbp+70h]
  __int64 __Val_0__; // [rsp+348h] [rbp+78h]
  __int64 v25; // [rsp+350h] [rbp+80h]
  __int64 v26; // [rsp+358h] [rbp+88h]
  _QWORD *v27; // [rsp+360h] [rbp+90h]
  _QWORD *v28; // [rsp+368h] [rbp+98h]
  _QWORD *v29; // [rsp+370h] [rbp+A0h]
  _QWORD *v30; // [rsp+378h] [rbp+A8h]
  _QWORD *v31; // [rsp+380h] [rbp+B0h]
  __int64 *ThreadLogContextSlot; // [rsp+388h] [rbp+B8h]
  const void *v33; // [rsp+390h] [rbp+C0h]
  const void *v34; // [rsp+398h] [rbp+C8h]
  const void *v35; // [rsp+3A0h] [rbp+D0h]
  const void *v36; // [rsp+3A8h] [rbp+D8h]
  const void *v37; // [rsp+3B0h] [rbp+E0h]
  __int64 v38; // [rsp+3B8h] [rbp+E8h]
  const char *p_local_client_2; // [rsp+3C0h] [rbp+F0h]
  _QWORD v40[2]; // [rsp+3C8h] [rbp+F8h] BYREF
  const void *v41; // [rsp+3D8h] [rbp+108h]
  _QWORD v42[2]; // [rsp+3E0h] [rbp+110h] BYREF
  const void *v43; // [rsp+3F0h] [rbp+120h]
  _QWORD v44[2]; // [rsp+3F8h] [rbp+128h] BYREF
  const void *v45; // [rsp+408h] [rbp+138h]
  _QWORD v46[2]; // [rsp+410h] [rbp+140h] BYREF
  const void *v47; // [rsp+420h] [rbp+150h]
  _QWORD v48[2]; // [rsp+428h] [rbp+158h] BYREF
  const void *v49; // [rsp+438h] [rbp+168h]
  _QWORD src_[2]; // [rsp+440h] [rbp+170h] BYREF
  _QWORD src__1[2]; // [rsp+450h] [rbp+180h] BYREF
  _QWORD v52[3]; // [rsp+460h] [rbp+190h] BYREF
  _BYTE dst_[16]; // [rsp+478h] [rbp+1A8h] BYREF
  __int64 dst__1[2]; // [rsp+488h] [rbp+1B8h] BYREF

  _2_ = (unsigned __int8)sub_144E5DE60(a1, off_149A44608);// "2"
  if ( (_BYTE)_2_ )
  {
    if ( sub_1465D1DE0((__int64)a1) )
    {
      if ( *(_BYTE *)(identity((__int64)&pSystem) + 0x2A0) )
      {
        v38 = identity((__int64)&pSystem);
        if ( *(_BYTE *)(v38 + 0x5F6) )
          p_pure_game = "editor";
        else
          p_pure_game = "pure game";
        p_local_client = p_pure_game;
      }
      else
      {
        p_local_client = "local client";
      }
      p_local_client_1 = p_local_client;
    }
    else
    {
      if ( *(_BYTE *)(identity((__int64)&pSystem) + 0x2A0) )
      {
        v16 = sub_1403E6750(a1 + 1);
        if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v16 + 0x720LL))(v16) )
          p_non_authoritative_dedicated_server = "authoritative dedicated server";
        else
          p_non_authoritative_dedicated_server = "non-authoritative dedicated server";
        p_remote_client = p_non_authoritative_dedicated_server;
      }
      else
      {
        p_remote_client = "remote client";
      }
      p_local_client_1 = p_remote_client;
    }
    p_local_client_2 = p_local_client_1;
    v3 = sub_14056A7D0(0x42);
    v10[0] = sub_142744750(v3);
    v10[1] = 0;
    src_[0] = v10;
    src_[1] = &v11;
    qmemcpy(dst_, src_, sizeof(dst_));
    v9 = invokeGlobalCallbackAndMaskStatusBits(
           5,
           (__int64)dst_,
           (__int64)"[ActorState] Corpse",
           "[ACTOR STATE][$$] $$ '$$' <$$>: $$");
    if ( (v9 & 0xFFFFF) != 0 )
    {
      v48[0] = "Message";
      v48[1] = a2;
      v49 = 0;
      v27 = v48;
      v46[0] = "ClientServer";
      v46[1] = p_local_client_2;
      v47 = 0;
      v28 = v46;
      v20 = sub_1403E6750(a1 + 1);
      v25 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v20 + 0x70LL))(v20);
      v44[0] = "Name";
      v44[1] = v25;
      v45 = 0;
      v29 = v44;
      v21 = sub_1403E6750(a1 + 1);
      v22 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v21 + 0x20LL))(v21);
      v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x18LL))(v22);
      v42[0] = "Class";
      v42[1] = v26;
      v43 = 0;
      v30 = v42;
      v40[0] = 0;
      v40[1] = "SSCActorStateCVars::LogCorpse";
      v41 = 0;
      v31 = v40;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v52[0] = 0;
      v52[1] = 0;
      v4 = sub_14056A7D0(0x42);
      v12[0] = sub_142744750(v4);
      v12[1] = 0;
      src__1[0] = v12;
      src__1[1] = &v13;
      qmemcpy(dst__1, src__1, sizeof(dst__1));
      v52[2] = 6;
      v5 = alloca(0x2A0);
      v23 = v7;
      __Val_0__ = (__int64)v7;
      sub_144E3FA70((__int64)v7, ThreadLogContextSlot, v31, v30, v29, v28, v27);
      LODWORD(v6) = v9;
      sub_1403045C0(
        5u,
        dst__1,
        "[ActorState] Corpse",
        "[ACTOR STATE][$$] $$ '$$' <$$>: $$",
        (vraudio::AudioBuffer *)__Val_0__,
        6u,
        1,
        v6,
        v52,
        0);
      v33 = v41;
      sub_1402A3D30(v41);
      v34 = v43;
      sub_1402A3D30(v43);
      v35 = v45;
      sub_1402A3D30(v45);
      v36 = v47;
      sub_1402A3D30(v47);
      v37 = v49;
      sub_1402A3D30(v49);
    }
    return 0;
  }
  return _2_;
}

// --- End Function: sub_144E55DF0 (0x144E55DF0) ---

// --- Function: sub_144E5DE60 (0x144E5DE60) ---
char __fastcall sub_144E5DE60(unsigned __int64 *a1, char *a2)
{
  char *v2; // rax
  __int64 v3; // rcx
  unsigned __int8 v4; // dl
  unsigned int v5; // eax
  const struct __crt_stdio_stream *v6; // rax
  char *v8; // rax
  __int64 v9; // rcx
  unsigned __int8 v10; // dl
  unsigned int v11; // eax
  char *v12; // rax
  __int64 v13; // rcx
  unsigned __int8 v14; // dl
  unsigned int v15; // eax
  char *v16; // rax
  __int64 v17; // rcx
  unsigned __int8 v18; // dl
  unsigned int v19; // eax
  unsigned __int8 *v20; // rax
  __int64 v21; // rcx
  unsigned __int8 v22; // dl
  unsigned int v23; // eax
  char **v24; // rax
  __int64 *v25; // rax
  char **v26; // rax
  unsigned __int8 *v27; // rax
  __int64 v28; // rcx
  unsigned __int8 v29; // dl
  unsigned int v30; // eax
  void **v31; // rax
  bool v32; // [rsp+21h] [rbp-B7h]
  void *v33; // [rsp+28h] [rbp-B0h] BYREF
  BOOL v34; // [rsp+30h] [rbp-A8h]
  int v35; // [rsp+34h] [rbp-A4h] BYREF
  unsigned __int64 v36; // [rsp+38h] [rbp-A0h]
  unsigned __int64 v37; // [rsp+40h] [rbp-98h]
  unsigned __int64 *v38; // [rsp+48h] [rbp-90h]
  std::pmr::_Identity_equal_resource *v39; // [rsp+50h] [rbp-88h] BYREF
  struct std::pmr::memory_resource *v40; // [rsp+58h] [rbp-80h]
  std::pmr::_Identity_equal_resource *v41; // [rsp+60h] [rbp-78h]
  __int64 *v42; // [rsp+68h] [rbp-70h]
  void *v43; // [rsp+70h] [rbp-68h] BYREF
  __int64 v44; // [rsp+78h] [rbp-60h]
  __int64 (__fastcall *v45)(unsigned __int64, char *); // [rsp+80h] [rbp-58h]
  __int64 v46; // [rsp+88h] [rbp-50h]
  char **v47; // [rsp+90h] [rbp-48h]
  __int64 v48; // [rsp+98h] [rbp-40h]
  __int64 v49; // [rsp+A0h] [rbp-38h] BYREF
  __int64 *v50; // [rsp+A8h] [rbp-30h]
  void *v51; // [rsp+B0h] [rbp-28h] BYREF
  void *v52; // [rsp+B8h] [rbp-20h] BYREF
  char v53[8]; // [rsp+C0h] [rbp-18h] BYREF
  char v54[16]; // [rsp+C8h] [rbp-10h] BYREF

  if ( *a2 )
  {
    v2 = a2;
    v3 = (char *)&String2__4 - a2;
    while ( 1 )
    {
      v4 = *v2;
      if ( *v2 != v2[v3] )
        break;
      ++v2;
      if ( !v4 )
      {
        v5 = 0;
        goto LABEL_7;
      }
    }
    v5 = v4 < (unsigned __int8)v2[v3] ? 0xFFFFFFFF : 1;
LABEL_7:
    if ( v5 )
    {
      v6 = (const struct __crt_stdio_stream *)strtoull(a2, 0, 0);
      v40 = *(struct std::pmr::memory_resource **)_lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
                                                    (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v53,
                                                    v6);
      v38 = a1 + 1;
      sub_1403B0A70(a1 + 1, &v39);
      v41 = v39;
      if ( std::pmr::_Identity_equal_resource::do_is_equal(v39, v40) )
        return 1;
      v8 = a2;
      v9 = "2" - a2;
      while ( 1 )
      {
        v10 = *v8;
        if ( *v8 != v8[v9] )
          break;
        ++v8;
        if ( !v10 )
        {
          v11 = 0;
          goto LABEL_15;
        }
      }
      v11 = v10 < (unsigned __int8)v8[v9] ? 0xFFFFFFFF : 1;
LABEL_15:
      if ( !v11 )
        return 1;
      if ( sub_1465D1DE0((__int64)a1) )
      {
        v12 = a2;
        v13 = "1" - a2;
        while ( 1 )
        {
          v14 = *v12;
          if ( *v12 != v12[v13] )
            break;
          ++v12;
          if ( !v14 )
          {
            v15 = 0;
            goto LABEL_23;
          }
        }
        v15 = v14 < (unsigned __int8)v12[v13] ? 0xFFFFFFFF : 1;
LABEL_23:
        if ( !v15 )
          return 1;
      }
      if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64 *))(*a1 + 0x650))(a1) )
      {
        v16 = a2;
        v17 = "3" - a2;
        while ( 1 )
        {
          v18 = *v16;
          if ( *v16 != v16[v17] )
            break;
          ++v16;
          if ( !v18 )
          {
            v19 = 0;
            goto LABEL_31;
          }
        }
        v19 = v18 < (unsigned __int8)v16[v17] ? 0xFFFFFFFF : 1;
LABEL_31:
        if ( !v19 )
          return 1;
      }
      v35 = 0;
      v42 = (__int64 *)CreateStringObjectFromString(&v43, a2);
      sub_1403D8950(v42, &v33, SubStr_, &v35);
      sub_140370D10(&v43);
      while ( !sub_1403BFA30(&v33) )
      {
        v36 = sub_1403E6750(a1 + 1);
        v44 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v36 + 0x70LL))(v36);
        v20 = (unsigned __int8 *)sub_1402A2660((__int64)&v33);
        v21 = v44 - (_QWORD)v20;
        while ( 1 )
        {
          v22 = *v20;
          if ( *v20 != v20[v21] )
            break;
          ++v20;
          if ( !v22 )
          {
            v23 = 0;
            goto LABEL_40;
          }
        }
        v23 = v22 < v20[v21] ? 0xFFFFFFFF : 1;
LABEL_40:
        if ( !v23 )
          goto LABEL_41;
        sub_14035B3E0(&v49);
        v47 = v24;
        v37 = sub_1403E6750(a1 + 1);
        v45 = *(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)v37 + 8LL);
        v25 = (__int64 *)v45(v37, v54);
        v46 = identity(*v25);
        v26 = sub_1403A9130(v47, "%llu", v46);
        v48 = sub_1402A2660((__int64)v26);
        v27 = (unsigned __int8 *)sub_1402A2660((__int64)&v33);
        v28 = v48 - (_QWORD)v27;
        while ( 1 )
        {
          v29 = *v27;
          if ( *v27 != v27[v28] )
            break;
          ++v27;
          if ( !v29 )
          {
            v30 = 0;
            goto LABEL_47;
          }
        }
        v30 = v29 < v27[v28] ? 0xFFFFFFFF : 1;
LABEL_47:
        v34 = v30 == 0;
        v32 = v30 == 0;
        sub_140370D10(&v49);
        if ( v32 )
        {
LABEL_41:
          sub_140370D10(&v33);
          return 1;
        }
        v50 = (__int64 *)CreateStringObjectFromString(&v52, a2);
        v31 = sub_1403D8950(v50, &v51, SubStr_, &v35);
        sub_140377F00((char **)&v33, (char **)v31);
        sub_140370D10(&v51);
        sub_140370D10(&v52);
      }
      sub_140370D10(&v33);
    }
  }
  return 0;
}

// --- End Function: sub_144E5DE60 (0x144E5DE60) ---

// --- Function: sub_144E8D7A0 (0x144E8D7A0) ---
__int64 __fastcall sub_144E8D7A0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 n0x10; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  void *(__fastcall *p_sub_1427BA670)(__int64, const void *); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_142FB0920();
  n0x10 = 0x10;
  v3 = sub_142F46810(&v5);
  v9 = sub_1402A2660((__int64)v3);
  v10 = byte_149E1A4A0;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427BA670 = sub_1427BA670;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_144E8D7A0 (0x144E8D7A0) ---

// --- Function: sub_144E8D850 (0x144E8D850) ---
__int64 __fastcall sub_144E8D850(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1427BA760)(__int64); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_142FB0950();
  v8 = 1;
  v3 = sub_144E8C9C0(&v5);
  v9 = sub_1402A2660((__int64)v3);
  v10 = byte_149E4D0C3;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427BA760 = sub_1427BA760;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_144E8D850 (0x144E8D850) ---

// --- Function: sub_144E8D900 (0x144E8D900) ---
__int64 __fastcall sub_144E8D900(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1427BA760)(__int64); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_142FB0980();
  v8 = 1;
  v3 = sub_144E8C9E0(&v5);
  v9 = sub_1402A2660((__int64)v3);
  v10 = byte_149E4D0C2;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427BA760 = sub_1427BA760;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_144E8D900 (0x144E8D900) ---

// --- Function: sub_144E9BE40 (0x144E9BE40) ---
__int64 __fastcall sub_144E9BE40(__int64 a1, float a2, __int64 a3)
{
  *(float *)(a1 + 8) = a2;
  *(_QWORD *)a1 = a3;
  return a1;
}

// --- End Function: sub_144E9BE40 (0x144E9BE40) ---

// --- Function: sub_14519DE80 (0x14519DE80) ---
__int64 __fastcall sub_14519DE80(__int64 a1)
{
  __int64 result; // rax
  bool v2; // [rsp+20h] [rbp-28h]
  unsigned __int8 (__fastcall ***v3)(_QWORD, _QWORD); // [rsp+28h] [rbp-20h]

  result = *(_BYTE *)(a1 + 0x4A) & 1;
  if ( (*(_BYTE *)(a1 + 0x4A) & 1) == 0 )
  {
    v3 = (unsigned __int8 (__fastcall ***)(_QWORD, _QWORD))(((__int64)(*(_QWORD *)(a1 + 0x40) << 0x10) >> 0x10)
                                                          & 0xFFFFFFFFFFFFLL);
    v2 = !v3 || (**v3)(v3, *(_WORD *)(a1 + 0x48) & 0x3FFF);
    result = v2 | *(_BYTE *)(a1 + 0x4A) & 0xFEu;
    *(_BYTE *)(a1 + 0x4A) = result;
  }
  return result;
}

// --- End Function: sub_14519DE80 (0x14519DE80) ---

// --- Function: sub_1457B71D0 (0x1457B71D0) ---
_QWORD *__fastcall sub_1457B71D0(__int64 a1, _QWORD *a2)
{
  _QWORD src_[2]; // [rsp+28h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+40h] [rbp-28h] BYREF

  src_[0] = p_p_p_p_p_sub_140384A94;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  sub_1457B7240(a2, *(_QWORD *)(a1 + 8));
  return a2;
}

// --- End Function: sub_1457B71D0 (0x1457B71D0) ---

// --- Function: sub_1457E2710 (0x1457E2710) ---
__int64 __fastcall sub_1457E2710(__int64 a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 4LL * a3 + 0x2E0) = a2;
  result = a4;
  if ( a4 )
    return sub_1457CC8D0(a1);
  return result;
}

// --- End Function: sub_1457E2710 (0x1457E2710) ---

// --- Function: sub_14583F430 (0x14583F430) ---
__int64 __fastcall sub_14583F430(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 0x3508);
  if ( !result )
    return sub_14601FAD0(a1 + 0x3510);
  return result;
}

// --- End Function: sub_14583F430 (0x14583F430) ---

// --- Function: sub_1458A8600 (0x1458A8600) ---
void __fastcall sub_1458A8600(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  int *v5; // rax
  _BYTE v6[8]; // [rsp+20h] [rbp-A8h] BYREF
  _QWORD v7[17]; // [rsp+28h] [rbp-A0h] BYREF

  sub_140468110((_QWORD *)(a1 + 8), 0);
  if ( !*(_BYTE *)(a1 + 0xAC) )
  {
    *(_BYTE *)(a1 + 0xAC) = 1;
    sub_1458B5CD0(a1, a2);
    v4 = sub_1465EECD0(a2);
    v5 = (int *)sub_1443C81C0((__int64)v6, *(_BYTE *)(a1 + 0x28), a1 + 0x30, *(_WORD *)(a1 + 0xA8));
    sub_145ED3E20(v4, v5);
    sub_141976650(v7);
  }
}

// --- End Function: sub_1458A8600 (0x1458A8600) ---

// --- Function: sub_1458B5CD0 (0x1458B5CD0) ---
void __fastcall sub_1458B5CD0(__int64 a1, __int64 a2)
{
  int v4; // eax
  int v5; // eax
  __m256 v6; // ymm0
  float v7; // xmm0_4
  float v8; // xmm0_4
  const void *v9; // rcx
  const void *v10; // rcx
  __int16 v11; // [rsp+20h] [rbp-39h] BYREF
  char v12; // [rsp+22h] [rbp-37h]
  int v13; // [rsp+28h] [rbp-31h]
  int v14; // [rsp+2Ch] [rbp-2Dh]
  __m256 v15; // [rsp+30h] [rbp-29h]
  int v16; // [rsp+50h] [rbp-9h]
  char v17; // [rsp+54h] [rbp-5h]
  char v18; // [rsp+55h] [rbp-4h]
  float v19; // [rsp+58h] [rbp-1h]
  int v20; // [rsp+5Ch] [rbp+3h]
  __int128 v21; // [rsp+60h] [rbp+7h] BYREF
  __int64 v22; // [rsp+70h] [rbp+17h]
  float v23; // [rsp+78h] [rbp+1Fh]
  __int128 v24; // [rsp+80h] [rbp+27h] BYREF
  __int64 v25; // [rsp+90h] [rbp+37h]
  char v26; // [rsp+98h] [rbp+3Fh]
  float v27; // [rsp+9Ch] [rbp+43h]

  v11 = *(_WORD *)(a1 + 0xA8);
  v12 = *(_BYTE *)(a1 + 0x28);
  v13 = *(_DWORD *)(a1 + 0x30);
  v4 = *(_DWORD *)(a1 + 0x34);
  v21 = 0;
  v14 = v4;
  v5 = *(_DWORD *)(a1 + 0x58);
  v23 = -1.0;
  v16 = v5;
  LOBYTE(v5) = *(_BYTE *)(a1 + 0x5C);
  v27 = 1.0;
  v6 = *(__m256 *)(a1 + 0x38);
  v17 = v5;
  LOBYTE(v5) = *(_BYTE *)(a1 + 0x5D);
  v15 = v6;
  v7 = *(float *)(a1 + 0x60);
  v18 = v5;
  v20 = *(_DWORD *)(a1 + 0x64);
  v19 = v7;
  v22 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  __asm { vzeroupper }
  sub_141A62C20((char **)&v21, (char **)(a1 + 0x68));
  v23 = *(float *)(a1 + 0x80);
  sub_140378F00((__int64)&v24, a1 + 0x88);
  v8 = *(float *)(a1 + 0xA4);
  v26 = *(_BYTE *)(a1 + 0xA0);
  v27 = v8;
  sub_145895DC0(a2 + 0x80, &v11);
  v9 = (const void *)v24;
  if ( (_QWORD)v24 )
  {
    if ( ((v25 - (_QWORD)v24) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      v9 = *(const void **)(v24 - 8);
      if ( (unsigned __int64)(v24 - (_QWORD)v9 - 8) > 0x1F )
LABEL_8:
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A3D30(v9);
    v24 = 0;
    v25 = 0;
  }
  v10 = (const void *)v21;
  if ( (_QWORD)v21 )
  {
    if ( ((v22 - (_QWORD)v21) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
    {
      v10 = *(const void **)(v21 - 8);
      if ( (unsigned __int64)(v21 - (_QWORD)v10 - 8) > 0x1F )
        goto LABEL_8;
    }
    sub_1402A3D30(v10);
  }
}

// --- End Function: sub_1458B5CD0 (0x1458B5CD0) ---

// --- Function: sub_1458B8230 (0x1458B8230) ---
double __fastcall sub_1458B8230(
        __int64 a1,
        __crt_win32_buffer_debug_info *a2,
        unsigned __int8 a3,
        __int64 a4,
        __int16 a5)
{
  const char *v8; // rax
  __int64 v9; // rax
  __int64 v10; // rbx
  int v12; // [rsp+40h] [rbp+18h] BYREF

  *(_BYTE *)(a1 + 0x28) = a3;
  sub_141A63B10(a1 + 0x30, a4);
  *(_WORD *)(a1 + 0xA8) = a5;
  *(_WORD *)(a1 + 0xAA) = 0;
  *(_BYTE *)(a1 + 0xAC) = 0;
  sub_1458D16C0(a1, a2, a3);
  v8 = __crt_win32_buffer_debug_info::file_name(a2);
  v9 = sub_1465EECD0((__int64)v8);
  v12 = 0;
  v10 = v9;
  sub_14589EFC0(&v12);
  return sub_145ED3FD0(v10, &v12);
}

// --- End Function: sub_1458B8230 (0x1458B8230) ---

// --- Function: sub_1458B8910 (0x1458B8910) ---
void __fastcall sub_1458B8910(__int64 a1, __crt_win32_buffer_debug_info *a2)
{
  __int128 v2; // xmm6
  const char *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rax
  char *v9; // rcx
  char *v10; // rax
  char *v11; // rcx
  char *v12; // [rsp+58h] [rbp-21h] BYREF
  __int128 v13; // [rsp+60h] [rbp-19h]
  float v14; // [rsp+70h] [rbp-9h]
  char *v15; // [rsp+78h] [rbp-1h] BYREF
  __int128 v16; // [rsp+80h] [rbp+7h]
  char v17; // [rsp+90h] [rbp+17h]
  float v18; // [rsp+94h] [rbp+1Bh]
  __int128 v19; // [rsp+B0h] [rbp+37h]

  v19 = v2;
  if ( sub_1402A2660(a1 + 8) )
  {
    if ( !*(_BYTE *)(a1 + 0xAC) )
    {
      v5 = __crt_win32_buffer_debug_info::file_name(a2);
      sub_1458B5CD0(a1, (__int64)v5);
    }
    v6 = sub_1402A2660(a1 + 8);
    sub_1446F9CC0(v6, v7);
    v8 = sub_1402A2660(a1 + 8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x78LL))(v8);
    sub_140468110((_QWORD *)(a1 + 8), 0);
  }
  v18 = 1.0;
  v12 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  *(_DWORD *)(a1 + 0x30) = 0;
  *(_OWORD *)(a1 + 0x38) = 0;
  *(_OWORD *)(a1 + 0x48) = 0;
  *(_DWORD *)(a1 + 0x58) = 0;
  *(_WORD *)(a1 + 0x5C) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  v14 = -1.0;
  *(_DWORD *)(a1 + 0x34) = 0xFFFFFFFF;
  sub_141976D90((const void **)(a1 + 0x68), (const void **)&v12);
  *(float *)(a1 + 0x80) = v14;
  sub_140378E60((const void **)(a1 + 0x88), (const void **)&v15);
  v9 = v15;
  *(_BYTE *)(a1 + 0xA0) = v17;
  *(float *)(a1 + 0xA4) = v18;
  if ( v9 )
  {
    v10 = v9;
    if ( ((*((_QWORD *)&v16 + 1) - (_QWORD)v9) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      v9 = (char *)*((_QWORD *)v9 + 0xFFFFFFFF);
      if ( (unsigned __int64)(v10 - v9 - 8) > 0x1F )
LABEL_12:
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A3D30(v9);
    v16 = 0;
    v15 = 0;
  }
  v11 = v12;
  if ( v12 )
  {
    if ( ((*((_QWORD *)&v13 + 1) - (_QWORD)v12) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
    {
      v11 = (char *)*((_QWORD *)v12 + 0xFFFFFFFF);
      if ( (unsigned __int64)(v12 - v11 - 8) > 0x1F )
        goto LABEL_12;
    }
    sub_1402A3D30(v11);
  }
}

// --- End Function: sub_1458B8910 (0x1458B8910) ---

// --- Function: sub_1458D16C0 (0x1458D16C0) ---
__int64 __fastcall sub_1458D16C0(__int64 a1, __crt_win32_buffer_debug_info *a2, unsigned __int8 a3)
{
  unsigned __int64 *v6; // r12
  __int64 *v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  _QWORD *v16; // rax
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned int *v19; // rax
  _QWORD *v20; // rax
  __int64 v21; // rax
  __int64 v22; // rdi
  __int64 (__fastcall *v23)(__int64, __int64); // rbx
  __int64 v24; // rax
  __int64 result; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rdi
  __int64 (__fastcall *v30)(__int64, __int64); // rbx
  __int64 v31; // rax
  _QWORD v32[2]; // [rsp+20h] [rbp-10h] BYREF
  __int64 v33; // [rsp+70h] [rbp+40h] BYREF
  __int64 v34; // [rsp+78h] [rbp+48h] BYREF
  char v35; // [rsp+88h] [rbp+58h] BYREF

  v6 = (unsigned __int64 *)__crt_win32_buffer_debug_info::file_name(a2);
  v7 = (__int64 *)(**(__int64 (__fastcall ***)(__int64, __int64 *, __crt_win32_buffer_debug_info *, _QWORD))a1)(
                    a1,
                    &v33,
                    a2,
                    a3);
  sub_1431BF120((__int64 *)(a1 + 8), v7);
  sub_1403715F0(&v33);
  v8 = sub_1402A2660(a1 + 8);
  sub_1404F1310(v8, a1 + 0x48);
  v9 = sub_1402A2660(a1 + 8);
  sub_1404F1300(v9, *(_DWORD *)(a1 + 0x58));
  v10 = sub_1402A2660(a1 + 8);
  sub_1404F1520(v10, *(float *)(a1 + 0xA4));
  if ( is_entity_descriptor_valid_or_accessible(v6 + 1) )
    v11 = v6[1] & 0xFFFFFFFFFFFFLL;
  else
    v11 = 0;
  (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v11 + 8LL))(v11, &v35);
  v12 = sub_1402A2660(a1 + 8);
  v33 = a1;
  sub_145898B20(v12, &v33);
  v13 = sub_1402A2660(a1 + 8);
  v33 = a1;
  sub_145898AF0(v13, &v33);
  v14 = sub_1402A2660(a1 + 8);
  v33 = a1;
  sub_1458989B0(v14, &v33);
  v15 = sub_1402A2660(a1 + 8);
  v32[0] = a1;
  v32[1] = a2;
  sub_145898A80(v15, v32);
  v33 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
           (_QWORD *)(a1 + 0x68),
           &v34);
  v16 = sub_1402E2EC0(a1 + 0x68, &v34);
  if ( v33 != *v16 )
  {
    do
    {
      v17 = sub_1402A2660(a1 + 8);
      v18 = sub_1402A2660((__int64)&v33);
      v19 = (unsigned int *)sub_1402A2660((__int64)&v33);
      sub_14546F0A0(v17, *v19, v18 + 8);
      sub_141A65ED0(&v33);
      v20 = sub_1402E2EC0(a1 + 0x68, &v34);
    }
    while ( v33 != *v20 );
  }
  if ( *(_BYTE *)(a1 + 0x28) == 1 )
  {
    sub_14212E1E0((__int64)v6, &v33);
    v26 = sub_14030ECF0(&v33);
    v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x588LL))(v26);
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v27 + 0x100LL))(v27, 1);
    if ( (_BYTE)result )
    {
      *(_WORD *)(a1 + 0xAA) = 0x100;
    }
    else
    {
      v28 = sub_14030ECF0(&v33);
      v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x588LL))(v28);
      v30 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v29 + 0xB8LL);
      v31 = sub_1402A2660(a1 + 8);
      result = v30(v29, v31);
      *(_BYTE *)(a1 + 0xAA) = 0;
    }
  }
  else
  {
    v21 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v6 + 0x6B8))(v6);
    v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v21 + 0x588LL))(v21);
    v23 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v22 + 0xB8LL);
    v24 = sub_1402A2660(a1 + 8);
    result = v23(v22, v24);
    *(_BYTE *)(a1 + 0xAA) = 0;
  }
  *(_BYTE *)(a1 + 0xAC) = 0;
  return result;
}

// --- End Function: sub_1458D16C0 (0x1458D16C0) ---

// --- Function: sub_1459085B0 (0x1459085B0) ---
void __fastcall sub_1459085B0(
        __int64 a1,
        __crt_win32_buffer_debug_info *a2,
        __int64 a3,
        unsigned __int8 a4,
        __int64 a5,
        __int16 a6)
{
  const char *v9; // rax
  int v10; // ecx
  __int64 v11; // r12
  __int64 v12; // rax
  const char *v13; // rax
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rbx
  __int64 v23; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rbx
  __int64 v32; // rax
  __int64 v35; // rbx
  int *v36; // rax
  _BYTE v37[16]; // [rsp+20h] [rbp-F8h] BYREF
  _BYTE v38[8]; // [rsp+30h] [rbp-E8h] BYREF
  _QWORD v39[17]; // [rsp+38h] [rbp-E0h] BYREF

  v9 = __crt_win32_buffer_debug_info::file_name(a2);
  v10 = *(_DWORD *)(a5 + 4);
  v11 = (__int64)v9;
  if ( v10 == 0xFFFFFFFF )
  {
    if ( sub_1402A2660(a1 + 8) )
    {
      v12 = sub_1402A2660(a1 + 8);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x78LL))(v12);
    }
  }
  else if ( *(_DWORD *)(a1 + 0x34) != v10
         || *(_QWORD *)(a1 + 0x38) != *(_QWORD *)(a5 + 8)
         || *(_QWORD *)(a1 + 0x40) != *(_QWORD *)(a5 + 0x10)
         || *(_QWORD *)(a1 + 0x48) != *(_QWORD *)(a5 + 0x18)
         || *(_QWORD *)(a1 + 0x50) != *(_QWORD *)(a5 + 0x20)
         || *(_DWORD *)(a1 + 0x58) != *(_DWORD *)(a5 + 0x28)
         || *(_BYTE *)(a1 + 0xA0) != *(_BYTE *)(a5 + 0x70)
         || *(float *)(a5 + 0x74) != *(float *)(a1 + 0xA4)
         || *(float *)(a5 + 0x50) != *(float *)(a1 + 0x80)
         || *(_WORD *)(a1 + 0xA8) != a6
         || *(_BYTE *)(a1 + 0x28) != a4 )
  {
    if ( sub_1402A2660(a1 + 8) )
    {
      v13 = __crt_win32_buffer_debug_info::file_name(a2);
      sub_1458B5CD0(a1, (__int64)v13);
      v14 = sub_1402A2660(a1 + 8);
      sub_1446F9CC0(v14, v15);
      v16 = sub_1402A2660(a1 + 8);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x78LL))(v16);
    }
    *(_BYTE *)(a1 + 0x28) = a4;
    sub_141A63B10(a1 + 0x30, a5);
    *(_WORD *)(a1 + 0xA8) = a6;
    *(_WORD *)(a1 + 0xAA) = 0;
    *(_BYTE *)(a1 + 0xAC) = 0;
    sub_1458D16C0(a1, a2, a4);
  }
  if ( *(_BYTE *)(a1 + 0xAB) )
  {
    if ( sub_1402A2660(a1 + 8) )
    {
      v17 = sub_1402A2660(a1 + 8);
      sub_1446F9CC0(v17, v18);
      v19 = sub_1402A2660(a1 + 8);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x80LL))(v19);
    }
    sub_1458A8600(a1, v11);
  }
  if ( sub_1402A2660(a1 + 8) && !*(_BYTE *)(a1 + 0xAC) )
  {
    if ( *(_BYTE *)(a1 + 0xAA) )
    {
      if ( *(_BYTE *)(a5 + 0x2D) )
      {
        v29 = sub_1402A2660(a1 + 8);
        if ( !sub_1404C7710(v29) )
          goto LABEL_37;
        v30 = sub_1402A2660(a1 + 8);
        v31 = sub_1402C7510(v30);
        v32 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v31 + 0x80LL))(v31, 0);
        if ( v32 )
        {
          if ( (*(_DWORD *)(v32 + 0x50) & 2) != 0 )
            goto LABEL_37;
        }
        (*(void (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x60LL))(
          qword_149B4FC40,
          v37,
          0);
        _XMM0 = sub_140597760();
        __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
        *(double *)_XMM0.m128_u64 = (*(double (__fastcall **)(__int64))(*(_QWORD *)v31 + 0xE8LL))(v31);
        if ( (float)(_XMM0.m128_f32[0] - *(float *)(a1 + 0x60)) <= *(float *)&_XMM6 )
        {
LABEL_37:
          *(_BYTE *)(a1 + 0xAC) = 1;
          sub_1458B5CD0(a1, v11);
          v35 = sub_1465EECD0(v11);
          v36 = (int *)sub_1443C81C0((__int64)v38, *(_BYTE *)(a1 + 0x28), a1 + 0x30, *(_WORD *)(a1 + 0xA8));
          sub_145ED3E20(v35, v36);
          sub_141976650(v39);
        }
      }
    }
    else
    {
      v20 = sub_1402A2660(a1 + 8);
      if ( sub_1404C7710(v20) )
      {
        v21 = sub_1402A2660(a1 + 8);
        v22 = sub_1402C7510(v21);
        v23 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v22 + 0x80LL))(v22, 0);
        if ( !v23 || (*(_DWORD *)(v23 + 0x50) & 2) == 0 )
        {
          (*(void (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x60LL))(
            qword_149B4FC40,
            v37,
            0);
          _XMM0 = sub_140597760();
          __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
          _XMM0 = sub_140597760();
          __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
          if ( *(float *)&_XMM6 <= *(float *)&_XMM1 )
            *(float *)&_XMM6 = *(float *)&_XMM1 + *(float *)&_XMM6;
          if ( (*(float (__fastcall **)(__int64))(*(_QWORD *)v22 + 0xE8LL))(v22) < *(float *)&_XMM6 )
          {
            v28 = sub_1402A2660(a1 + 8);
            sub_14049C720(v28);
            (*(void (__fastcall **)(__int64, __crt_win32_buffer_debug_info *))(*(_QWORD *)a1 + 8LL))(a1, a2);
          }
        }
      }
    }
  }
}

// --- End Function: sub_1459085B0 (0x1459085B0) ---

// --- Function: sub_145A3A490 (0x145A3A490) ---
__int64 __fastcall sub_145A3A490(__int64 a1, int n2, char a3, float *a4)
{
  __int64 n2_1; // rax
  __int64 v5; // rbx
  float v6; // xmm2_4

  n2_1 = *(unsigned int *)(a1 + 0x310);
  v5 = a1;
  if ( (_DWORD)n2_1 != n2 )
  {
    *(_DWORD *)(a1 + 0x30C) = n2;
    if ( a4 )
    {
      v6 = *a4;
    }
    else if ( (unsigned int)(n2_1 - 3) > 3 || (unsigned int)(n2 - 3) <= 3 )
    {
      v6 = 0.0;
    }
    else
    {
      v6 = 0.30000001;
    }
    *(float *)(a1 + 0x400) = v6;
    if ( !a3 )
      return sub_1403A58C0(a1, 0);
    if ( *(_BYTE *)(a1 + 0x4B8) || !n2 )
      sub_145A3C120(a1, n2, v6);
    n2_1 = *(unsigned int *)(v5 + 0x310);
    if ( *(_DWORD *)(v5 + 0x30C) != (_DWORD)n2_1 )
    {
      a1 = v5;
      return sub_1403A58C0(a1, 0);
    }
  }
  return n2_1;
}

// --- End Function: sub_145A3A490 (0x145A3A490) ---

// --- Function: sub_145A3A5E0 (0x145A3A5E0) ---
double __fastcall sub_145A3A5E0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rsi
  char v7; // al
  __int64 v8; // rcx
  __int64 v9; // rdx
  int n0x4200; // [rsp+30h] [rbp-58h] BYREF
  __int64 v12; // [rsp+34h] [rbp-54h]
  int v13; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v14; // [rsp+40h] [rbp-48h]
  unsigned __int64 v15; // [rsp+48h] [rbp-40h]
  __int64 v16; // [rsp+50h] [rbp-38h]
  __int64 v17; // [rsp+58h] [rbp-30h]

  v3 = 0;
  n0x4200 = 0x4200;
  v12 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x4200,
    &word_149E6816C,
    "CSCActorPhysicsController::RequestTeleport",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorPhysicsController.cpp",
    0x59C);
  HIWORD(n0x4200) = word_149E6816C;
  *(_QWORD *)(a1 + 0x258) = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 0x260) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x268) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x270) = *(_QWORD *)(a2 + 0x18);
  *(_QWORD *)(a1 + 0x278) = *(_QWORD *)(a2 + 0x20);
  *(_OWORD *)(a1 + 0x280) = *(_OWORD *)(a2 + 0x28);
  *(double *)(a1 + 0x290) = *(double *)(a2 + 0x38);
  *(_QWORD *)(a1 + 0x298) = *(_QWORD *)(a2 + 0x40);
  *(_OWORD *)(a1 + 0x2A0) = *(_OWORD *)(a2 + 0x48);
  *(double *)(a1 + 0x2B0) = *(double *)(a2 + 0x58);
  *(_DWORD *)(a1 + 0x2B8) = *(_DWORD *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x2BC) = *(_DWORD *)(a2 + 0x64);
  *(_DWORD *)(a1 + 0x2C0) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x2C4) = *(_DWORD *)(a2 + 0x6C);
  *(double *)(a1 + 0x2C8) = *(double *)(a2 + 0x70);
  *(_DWORD *)(a1 + 0x2D0) = *(_DWORD *)(a2 + 0x78);
  *(_BYTE *)(a1 + 0x2D4) = *(_BYTE *)(a2 + 0x7C);
  *(_BYTE *)(a1 + 0x2D5) = *(_BYTE *)(a2 + 0x7D);
  *(_BYTE *)(a1 + 0x2D6) = *(_BYTE *)(a2 + 0x7E);
  *(_BYTE *)(a1 + 0x2D7) = *(_BYTE *)(a2 + 0x7F);
  *(_BYTE *)(a1 + 0x2D9) = 0;
  if ( a3 )
  {
    v7 = sub_145A3D0F0(a1, a2) ^ 1;
    *(_BYTE *)(a1 + 0x2D8) = v7;
    if ( !v7 )
      goto LABEL_15;
  }
  else
  {
    *(_BYTE *)(a1 + 0x2D8) = 1;
  }
  sub_1403A58C0(a1, 0);
  if ( !*(_BYTE *)(a1 + 0x4B8) )
  {
    if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
      v8 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
    else
      v8 = 0;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x660LL))(v8) )
      sub_1403CF100(a1, 0);
    if ( *(_BYTE *)(a1 + 0x308) )
    {
      *(_BYTE *)(a1 + 0x2D9) = 1;
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
        v3 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      LOBYTE(v9) = 1;
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v3 + 0x6E8LL))(v3, v9, a1);
    }
  }
LABEL_15:
  v15 = __rdtsc();
  return qword_149B4B878(&n0x4200);
}

// --- End Function: sub_145A3A5E0 (0x145A3A5E0) ---

// --- Function: sub_145A3C120 (0x145A3C120) ---
double __fastcall sub_145A3C120(__int64 a1, int n2, float a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int128 v5; // xmm8
  __int128 v6; // xmm9
  __int128 v7; // xmm10
  __int128 v8; // xmm11
  __int128 v9; // xmm12
  __int128 v10; // xmm13
  __int128 v11; // xmm14
  __int64 v12; // rbx
  __int64 v15; // rax
  int n0xF; // eax
  __int64 v17; // rax
  __int64 v18; // r14
  __int64 v19; // rax
  unsigned int v20; // eax
  char v21; // cl
  unsigned int v22; // r12d
  unsigned int v23; // edi
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rcx
  __int64 v28; // rcx
  unsigned __int64 *v29; // r12
  __int64 v30; // rcx
  __int64 v31; // r9
  __int64 v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rax
  __int64 v36; // rdi
  __int64 v37; // rcx
  _BYTE *v38; // rdx
  __int64 v39; // rcx
  double v40; // xmm11_8
  double v41; // xmm8_8
  double v42; // xmm12_8
  double v43; // xmm13_8
  double v44; // xmm6_8
  double v45; // xmm9_8
  double v46; // kr00_8
  __int64 v47; // rcx
  __int64 v48; // rax
  const char *p_blend; // r9
  __int64 v50; // rax
  __int64 v51; // rcx
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // rdx
  __int64 v55; // rdi
  __int64 v56; // rax
  _QWORD *v57; // rax
  __int64 v58; // rax
  __int64 v59; // rcx
  __int64 v60; // rcx
  __int64 v61; // rdi
  const char *v63; // [rsp+68h] [rbp-98h]
  int v64; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int64 v65; // [rsp+78h] [rbp-88h] BYREF
  _DWORD v66[4]; // [rsp+80h] [rbp-80h] BYREF
  double v67; // [rsp+90h] [rbp-70h] BYREF
  __int64 v68; // [rsp+98h] [rbp-68h]
  double v69; // [rsp+A0h] [rbp-60h]
  double v70; // [rsp+A8h] [rbp-58h]
  double v71; // [rsp+B0h] [rbp-50h]
  double v72; // [rsp+B8h] [rbp-48h]
  double v73; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v74; // [rsp+D0h] [rbp-30h] BYREF
  int n0x4300; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v76; // [rsp+E4h] [rbp-1Ch]
  int v77; // [rsp+ECh] [rbp-14h]
  unsigned __int64 v78; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v79; // [rsp+F8h] [rbp-8h]
  __int64 v80; // [rsp+100h] [rbp+0h]
  __int64 v81; // [rsp+108h] [rbp+8h]
  _DWORD v82[20]; // [rsp+130h] [rbp+30h] BYREF
  unsigned __int64 v83; // [rsp+180h] [rbp+80h]
  unsigned int v84; // [rsp+188h] [rbp+88h]
  unsigned int v85; // [rsp+18Ch] [rbp+8Ch]
  unsigned int v86; // [rsp+190h] [rbp+90h]
  unsigned int v87; // [rsp+194h] [rbp+94h]
  unsigned int v88; // [rsp+198h] [rbp+98h]
  unsigned int v89; // [rsp+19Ch] [rbp+9Ch]
  unsigned int v90; // [rsp+1A0h] [rbp+A0h]
  unsigned int v91; // [rsp+1B0h] [rbp+B0h]
  _DWORD v92[8]; // [rsp+1C0h] [rbp+C0h] BYREF
  __int128 v93; // [rsp+1E0h] [rbp+E0h]
  int v94; // [rsp+1F0h] [rbp+F0h]
  unsigned int v95; // [rsp+1F4h] [rbp+F4h]
  unsigned int v96; // [rsp+1F8h] [rbp+F8h]
  unsigned int v97; // [rsp+204h] [rbp+104h]
  unsigned int v98; // [rsp+208h] [rbp+108h]
  unsigned int v99; // [rsp+214h] [rbp+114h]
  _BYTE v100[16]; // [rsp+220h] [rbp+120h] BYREF
  _BYTE v101[96]; // [rsp+230h] [rbp+130h] BYREF
  __int128 v102; // [rsp+290h] [rbp+190h]
  __int128 v103; // [rsp+2A0h] [rbp+1A0h]
  _BYTE v104[96]; // [rsp+2B0h] [rbp+1B0h]
  _BYTE v105[12]; // [rsp+310h] [rbp+210h] BYREF
  int v106; // [rsp+31Ch] [rbp+21Ch]
  int v107; // [rsp+320h] [rbp+220h]
  _DWORD v108[36]; // [rsp+3A0h] [rbp+2A0h] BYREF
  __int64 v109; // [rsp+430h] [rbp+330h] BYREF
  __int64 n0x1FF; // [rsp+438h] [rbp+338h]
  _BYTE *v111; // [rsp+440h] [rbp+340h]
  _BYTE v112[520]; // [rsp+448h] [rbp+348h] BYREF
  __int128 v113; // [rsp+660h] [rbp+560h]
  __int128 v114; // [rsp+670h] [rbp+570h]
  __int128 v115; // [rsp+680h] [rbp+580h]
  __int128 v116; // [rsp+690h] [rbp+590h]
  __int128 v117; // [rsp+6A0h] [rbp+5A0h]
  __int128 v118; // [rsp+6B0h] [rbp+5B0h]
  __int128 v119; // [rsp+6C0h] [rbp+5C0h]
  __int128 v120; // [rsp+6D0h] [rbp+5D0h]
  __int128 v121; // [rsp+6E0h] [rbp+5E0h]

  v113 = v11;
  v12 = 0;
  v76 = 0;
  v77 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  n0x4300 = 0x4300;
  v78 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x4300,
    &word_149E68168,
    "CSCActorPhysicsController::SetProfile",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorPhysicsController.cpp",
    0x357);
  HIWORD(n0x4300) = word_149E68168;
  if ( n2 != *(_DWORD *)(a1 + 0x310) )
  {
    v15 = sub_1465EEE60(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
    if ( *(_QWORD *)sub_14583F5E0(v15) )
    {
      n0xF = *(_DWORD *)(a1 + 0xAC);
      if ( n0xF == 0xF )
      {
        sub_145A34030(a1);
      }
      else if ( !n0xF )
      {
        v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL) + 0x768LL))(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
        v18 = v17;
        if ( !v17 )
          goto LABEL_99;
        if ( (unsigned int)(n2 - 3) > 3 )
        {
          v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x20LL))(v17);
          v20 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v19 + 0xA0LL))(v19, 0);
          v21 = 0;
          v22 = v20;
          v23 = 0;
          if ( !v20 )
            goto LABEL_99;
          do
          {
            if ( v21 )
              goto LABEL_13;
            v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x20LL))(v18);
            v25 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v24 + 0xB8LL))(v24, 0, v23++);
            v21 = *(_BYTE *)(v25 + 0x54) & 1;
          }
          while ( v23 < v22 );
          if ( !v21 )
          {
            v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x20LL))(v18);
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x40LL))(v26);
            goto LABEL_99;
          }
        }
LABEL_13:
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
          v27 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v27 = 0;
        (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v27 + 0x5B0LL))(v27, 1, 0x13);
      }
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
        v28 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v28 = 0;
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v28 + 0x3B8LL))(v28, &v65);
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v29 = (unsigned __int64 *)(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
      else
        v29 = 0;
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
        v30 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v30 = 0;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x440LL))(v30);
      switch ( n2 )
      {
        case 0:
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v32 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v32 = 0;
          LOBYTE(v31) = 1;
          (*(void (__fastcall **)(__int64, _QWORD, __int64, __int64))(*(_QWORD *)v32 + 0x5B0LL))(v32, 0, 0x13, v31);
          v66[0] = 3;
          v66[1] = 1;
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v33 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v33 = 0;
          (*(void (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(*(_QWORD *)v33 + 0x408LL))(v33, v66, 0, 0);
          *(_QWORD *)(a1 + 0x13C) = 0;
          *(_DWORD *)(a1 + 0x138) = 0;
          *(_QWORD *)(a1 + 0x148) = 0;
          *(_DWORD *)(a1 + 0x144) = 0;
          *(_QWORD *)(a1 + 0x154) = 0;
          *(_DWORD *)(a1 + 0x150) = 0;
          *(_QWORD *)(a1 + 0x160) = 0;
          *(_DWORD *)(a1 + 0x15C) = 0;
          *(_QWORD *)(a1 + 0x16C) = 0;
          *(_DWORD *)(a1 + 0x168) = 0;
          *(_QWORD *)(a1 + 0x178) = 0;
          *(_DWORD *)(a1 + 0x174) = 0;
          *(_DWORD *)(a1 + 0x1B0) = 0;
          *(_QWORD *)(a1 + 0x47C) = 0;
          *(_DWORD *)(a1 + 0x478) = 0;
          goto LABEL_89;
        case 1:
        case 2:
          if ( !v65 || *(_QWORD *)((v65 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v65) )
            goto LABEL_59;
          if ( *(_DWORD *)(a1 + 0x310) == 8 )
          {
            *(_QWORD *)&v67 = 0x8000000000000008uLL;
            v68 = 0x80000000LL;
            v69 = 0.0;
            LODWORD(v70) = 0xFFBFFFFF;
            HIDWORD(v71) = 0;
            if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
              v34 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v34 = 0;
            (*(void (__fastcall **)(__int64, double *, _QWORD, _QWORD))(*(_QWORD *)v34 + 0x408LL))(v34, &v67, 0, 0);
            v35 = sub_1403335B0(a1);
            v36 = sub_143192820(*(_QWORD *)(v35 + 0x18));
            sub_142EC37E0((__int64)v105);
            v106 = *(_DWORD *)(v36 + 0x38);
            v107 = *(_DWORD *)(v36 + 0x34);
            if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            {
              v38 = v105;
              v37 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              v37 = 0;
              v38 = v105;
            }
LABEL_88:
            (*(void (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v37 + 0x3F8LL))(v37, v38, 0, 0);
          }
          else if ( (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 8LL))(v65 & 0xFFFFFFFFFFFFLL) == 6
                 && *(_DWORD *)(a1 + 0x310) )
          {
            v121 = v3;
            v120 = v4;
            v119 = v5;
            v118 = v6;
            v117 = v7;
            v116 = v8;
            v115 = v9;
            v114 = v10;
            if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
              v39 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v39 = 0;
            (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v39 + 0x268LL))(v39, &v67, 0);
            v40 = *(double *)&v68 * v67 - v69 * v70 + *(double *)&v68 * v67 - v69 * v70;
            v41 = v70 * v70 + v70 * v70;
            v42 = *(double *)&v68 * *(double *)&v68 + *(double *)&v68 * *(double *)&v68 + v41 - 1.0;
            v43 = v67 * v70 + v67 * v70 + *(double *)&v68 * v69 + *(double *)&v68 * v69;
            v44 = *(double *)&v68 * v70 + *(double *)&v68 * v70 + v67 * v69 + v67 * v69;
            v45 = *(double *)&v68 * v69 - v67 * v70 + *(double *)&v68 * v69 - v67 * v70;
            v46 = v69 * v69 + v69 * v69 + v41 - 1.0;
            v112[0] = 0;
            v111 = v112;
            v109 = 0;
            n0x1FF = 0x1FF;
            if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
              v47 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v47 = 0;
            v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v47 + 0x648LL))(v47);
            v63 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x1F0LL))(v48);
            p_blend = "snap";
            if ( n2 == 2 )
              p_blend = "blend";
            v50 = sub_1402A3190(
                    (__int64)&v109,
                    "%s: mode=%s pos(%.2f, %.2f, %.2f) dir(%.2f, %.2f, %.2f) up(%.2f, %.2f, %.2f) zone='%s'",
                    "CSCActorPhysicsController::SetProfile",
                    p_blend,
                    v71,
                    v72,
                    v73,
                    v40,
                    v42,
                    v43,
                    v44,
                    v45,
                    v46,
                    v63);
            sub_144E57960(v29, *(_QWORD *)(v50 + 0x10));
            if ( v111 != v112 )
            {
              qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
              sub_147605980(v111);
            }
            sub_141EF04A0((__int64)v101);
            v94 = 0;
            v93 = xmmword_148218FC0;
            v92[0] = 1;
            v92[4] = 0xFFBFFFFF;
            v92[1] = 0xFFBFFFFF;
            v92[7] = 0xFFBFFFFF;
            v95 = 0xFFBFFFFF;
            v97 = 0xFFBFFFFF;
            v98 = 0xFFBFFFFF;
            v99 = 0x80000000;
            v96 = 0xFFBFFFFF;
            sub_142EC37E0((__int64)v108);
            sub_145A316A0(a1, (__int64)v101, (__int64)v92, v108);
            *((_QWORD *)&v102 + 1) = v92;
            BYTE8(v103) = n2 == 2;
            *(_QWORD *)&v103 = v108;
            *((float *)&v103 + 3) = a3;
            if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
              v51 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v51 = 0;
            (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v51 + 0x390LL))(v51, v101);
            *(__m256i *)(a1 + 0x320) = *(__m256i *)v101;
            *(__m256i *)(a1 + 0x340) = *(__m256i *)&v101[0x20];
            *(__m256i *)(a1 + 0x360) = *(__m256i *)&v101[0x40];
            *(_OWORD *)(a1 + 0x380) = v102;
            *(_OWORD *)(a1 + 0x390) = v103;
            *(__m256i *)(a1 + 0x3A0) = *(__m256i *)v104;
            *(__m256i *)(a1 + 0x3C0) = *(__m256i *)&v104[0x20];
            *(__m256i *)(a1 + 0x3E0) = *(__m256i *)&v104[0x40];
            __asm { vzeroupper }
            sub_1465FAFF0((__int64)v29);
          }
          else
          {
LABEL_59:
            v52 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v29 + 0x768))(v29);
            if ( v52 && ((*(_DWORD *)(a1 + 0x310) - 3) & 0xFFFFFFFD) == 0 )
            {
              v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 0x30LL))(v52);
              LOBYTE(v54) = 1;
              (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v53 + 0x268LL))(v53, v54);
            }
            v55 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v29 + 0x768))(v29);
            if ( v65
              && *(_QWORD *)((v65 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v65)
              && (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 8LL))(v65 & 0xFFFFFFFFFFFFLL) == 0xB )
            {
              if ( !v55 )
                goto LABEL_89;
              v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x30LL))(v55);
              v57 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v56 + 0x28LL))(v56, v100);
              if ( *v57 )
              {
                if ( *(_QWORD *)((*v57 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*v57) )
                  goto LABEL_69;
              }
            }
            sub_145A34030(a1);
            if ( v55 )
            {
LABEL_69:
              v58 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x30LL))(v55);
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x90LL))(v58);
            }
          }
          goto LABEL_89;
        case 3:
        case 4:
        case 5:
          if ( v65 && *(_QWORD *)((v65 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v65) )
          {
            sub_145A344E0(a1, n2);
LABEL_89:
            if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
              v60 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v60 = 0;
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v60 + 0x448LL))(v60);
            if ( (unsigned int)(*(_DWORD *)(a1 + 0x310) - 3) <= 3 )
            {
              if ( (unsigned int)(n2 - 3) <= 3 )
                goto LABEL_97;
              v64 = 0;
              v61 = sub_1465EECD0((__int64)v29);
              sub_14035C4A0(&v64, 0xFA);
              sub_145ED3E50(v61, &v64);
            }
            if ( n2 == 1 )
            {
              sub_14325AD60(a1);
LABEL_98:
              *(_DWORD *)(a1 + 0x310) = n2;
              *(_DWORD *)(a1 + 0xAC) = n2 != 0 ? 0xB : 0;
              break;
            }
LABEL_97:
            sub_14326CF90(a1);
            goto LABEL_98;
          }
          sub_145A3C120(a1, 1, 0.0);
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v12 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x448LL))(v12);
          break;
        case 6:
          sub_145A344E0(a1, 6);
          goto LABEL_89;
        case 7:
          goto LABEL_59;
        case 8:
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v59 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v59 = 0;
          (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v59 + 0x3B8LL))(v59, &v74);
          if ( !v74
            || *(_QWORD *)((v74 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v74)
            || (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v74 & 0xFFFFFFFFFFFFLL) + 8LL))(v74 & 0xFFFFFFFFFFFFLL) != 0xB )
          {
            sub_145A34030(a1);
          }
          v82[0] = 4;
          v83 = 0xFFFFFFFFFFFFFFFFuLL;
          *(float *)&v82[3] = 1.0;
          *(float *)&v82[4] = 0.0;
          v82[1] = 0xFFBFFFFF;
          v82[2] = 0xFFBFFFFF;
          v82[5] = 0xFFBFFFFF;
          v82[6] = 0xFFBFFFFF;
          v82[8] = 0xFFBFFFFF;
          v82[0xB] = 0xFFBFFFFF;
          v82[9] = 0x80000000;
          v82[0xA] = 0x80000000;
          v82[0xC] = 0x80000000;
          v85 = 0x80000000;
          v82[0x12] = 0x80000000;
          v82[0xD] = 0xFFBFFFFF;
          v82[0xE] = 0xFFBFFFFF;
          v82[0xF] = 0xFFBFFFFF;
          v82[0x10] = 0xFFBFFFFF;
          v84 = 0x80000000;
          v82[0x11] = 0xFFBFFFFF;
          v86 = 0x80000000;
          v91 = 0xFFBFFFFF;
          v88 = 0x80000000;
          v89 = 0x80000000;
          v90 = 0x80000000;
          v87 = 0x80000000;
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v37 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v37 = 0;
          v38 = v82;
          goto LABEL_88;
        default:
          goto LABEL_89;
      }
    }
  }
LABEL_99:
  v79 = __rdtsc();
  return qword_149B4B878(&n0x4300);
}

// --- End Function: sub_145A3C120 (0x145A3C120) ---

// --- Function: sub_145A3D0F0 (0x145A3D0F0) ---
__int64 __fastcall sub_145A3D0F0(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm8
  __int128 v3; // xmm9
  __int128 v4; // xmm10
  __int128 v5; // xmm11
  __int128 v6; // xmm12
  __int128 v7; // xmm13
  __int128 v8; // xmm14
  __int128 v9; // xmm15
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r13
  __int64 v16; // rax
  __int64 v17; // r10
  __int64 v18; // rax
  _QWORD *v19; // rcx
  double v20; // xmm9_8
  __int128 *v22; // rdx
  __int64 v23; // r12
  __int128 v24; // xmm0
  __int64 v25; // rbx
  __int64 v26; // rbx
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rbx
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rbx
  __int64 (__fastcall *v35)(__int64, unsigned __int64 *, __int64, const char *, __int128 *); // r12
  __int64 v36; // rax
  __m256 v37; // ymm1
  __int128 v38; // xmm0
  __int128 *v39; // rcx
  __int64 *v40; // rdx
  __m256 v41; // ymm1
  __int128 v42; // xmm1
  __int64 v43; // rax
  __int64 v44; // rsi
  __int64 v45; // rax
  _QWORD *v46; // rax
  __int64 v47; // rcx
  _QWORD *v48; // rbx
  _QWORD *v49; // rax
  double v52; // xmm1_8
  __int64 v53; // rax
  __int64 v54; // rcx
  unsigned __int64 *v55; // rax
  __int64 v56; // rcx
  unsigned __int8 v57; // bl
  __int64 v58; // rsi
  bool v59; // al
  __int64 v60; // rcx
  __int64 v61; // rsi
  void (__fastcall *v62)(__int64, __int128 *, __int64 *, unsigned __int64 *, int, unsigned int, __int128 *, _QWORD, __int64 *, int, _QWORD, _BYTE); // rbx
  bool v63; // cl
  void (__fastcall *v64)(__int64, __m256 *, __int64, __int64, int, _QWORD); // r10
  double v65; // kr00_8
  double v66; // xmm11_8
  double v67; // xmm12_8
  __int64 v74; // rax
  __int128 v76; // kr00_16
  __int64 v78; // rcx
  __int64 v79; // rcx
  unsigned __int64 *v80; // rax
  __int64 v81; // rcx
  __int64 v82; // rax
  void (__fastcall *v83)(__int64, __int64, __int64, _QWORD, _QWORD); // rbx
  __int64 v84; // rax
  __int64 v85; // rax
  double v86; // xmm10_8
  double v87; // xmm6_8
  double v88; // xmm12_8
  __int128 v89; // xmm11
  __int128 v90; // kr00_16
  double v91; // xmm15_8
  double v92; // xmm14_8
  __int64 v93; // rax
  __int64 v102; // rcx
  void (__fastcall *v103)(__int64, __int64, __int64, _QWORD, _QWORD); // rbx
  __int64 v104; // rax
  float v105; // xmm6_4
  __m128 v106; // xmm7
  float v107; // xmm4_4
  float v108; // xmm5_4
  __m128 v109; // kr00_16
  __int64 v110; // rbx
  __int64 v113; // rax
  __int64 v114; // rcx
  __int64 v115; // rax
  __int64 v116; // rcx
  __int64 v117; // rax
  __int64 v118; // rbx
  __int64 v119; // rcx
  __int64 v120; // rax
  __int64 v121; // rcx
  __int64 v122; // rax
  __int64 *v123; // rsi
  __int64 v124; // rbx
  __int64 v125; // rax
  __int16 n4; // cx
  __int64 v127; // rbx
  __int64 v128; // rcx
  __int64 v129; // rax
  bool v130; // al
  __int64 pEntitySystem; // rsi
  float v132; // eax
  __int64 v133; // rcx
  char **v134; // rax
  char **v135; // r13
  __int64 v136; // rcx
  _QWORD *v137; // rax
  const char *v138; // rax
  char **v139; // rax
  __int64 v140; // rax
  __int64 v141; // rbx
  char *v142; // r15
  unsigned __int64 *v143; // rcx
  double *v144; // rax
  double v146; // xmm7_8
  int v147; // eax
  char n0xCC_2; // r15
  int v149; // r13d
  __int128 v152; // kr00_16
  const char *p_Success; // rax
  const char *p_unknown; // rbx
  const char *p_unknown_1; // rax
  __int64 v159; // rcx
  Server **p_Server; // rax
  __int64 v161; // rcx
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v163; // rcx
  __int64 v164; // rcx
  __int64 v165; // rcx
  int v167; // [rsp+20h] [rbp-120h]
  int v168; // [rsp+20h] [rbp-120h]
  int v169; // [rsp+20h] [rbp-120h]
  int v170; // [rsp+20h] [rbp-120h]
  __int64 *ThreadLogContextSlot; // [rsp+40h] [rbp-100h]
  double v172; // [rsp+C0h] [rbp-80h] BYREF
  __int128 v173; // [rsp+C8h] [rbp-78h] BYREF
  __int64 v174; // [rsp+D8h] [rbp-68h]
  float v175; // [rsp+E0h] [rbp-60h] BYREF
  float v176; // [rsp+E4h] [rbp-5Ch]
  float v177; // [rsp+E8h] [rbp-58h]
  float v178; // [rsp+ECh] [rbp-54h]
  __int128 v179; // [rsp+F0h] [rbp-50h] BYREF
  __m256 v180; // [rsp+100h] [rbp-40h] BYREF
  __int128 v181; // [rsp+120h] [rbp-20h] BYREF
  __int128 v182; // [rsp+130h] [rbp-10h]
  unsigned __int64 v183; // [rsp+140h] [rbp+0h] BYREF
  __int64 v184; // [rsp+148h] [rbp+8h] BYREF
  const char *p_CSCActorPhysicsController::Teleport; // [rsp+150h] [rbp+10h]
  const void *v186; // [rsp+158h] [rbp+18h]
  __int128 *v187; // [rsp+160h] [rbp+20h] BYREF
  __m256 v188; // [rsp+168h] [rbp+28h]
  __int128 v189; // [rsp+188h] [rbp+48h]
  __m256 v190; // [rsp+198h] [rbp+58h]
  double v191; // [rsp+1B8h] [rbp+78h]
  __int128 v192; // [rsp+1C0h] [rbp+80h]
  double v193; // [rsp+1D0h] [rbp+90h]
  int v194; // [rsp+1D8h] [rbp+98h]
  char v195; // [rsp+1DCh] [rbp+9Ch]
  char v196; // [rsp+1DDh] [rbp+9Dh]
  char v197; // [rsp+1DEh] [rbp+9Eh]
  char v198; // [rsp+1DFh] [rbp+9Fh]
  __int64 v199; // [rsp+1E0h] [rbp+A0h]
  unsigned __int64 v200; // [rsp+1F0h] [rbp+B0h] BYREF
  __int128 v201; // [rsp+1F8h] [rbp+B8h] BYREF
  double v202; // [rsp+208h] [rbp+C8h]
  unsigned __int64 v203; // [rsp+210h] [rbp+D0h] BYREF
  __m256 v204; // [rsp+218h] [rbp+D8h]
  float v205; // [rsp+238h] [rbp+F8h]
  float v206; // [rsp+23Ch] [rbp+FCh]
  unsigned int v207; // [rsp+240h] [rbp+100h]
  unsigned int v208; // [rsp+244h] [rbp+104h]
  int n0x80; // [rsp+248h] [rbp+108h]
  unsigned int v210; // [rsp+24Ch] [rbp+10Ch]
  __int64 v211; // [rsp+250h] [rbp+110h]
  unsigned int v212; // [rsp+260h] [rbp+120h]
  __int64 v213; // [rsp+268h] [rbp+128h]
  int v214; // [rsp+270h] [rbp+130h]
  float v215; // [rsp+274h] [rbp+134h]
  float v216; // [rsp+278h] [rbp+138h]
  float v217; // [rsp+27Ch] [rbp+13Ch]
  unsigned int v218; // [rsp+280h] [rbp+140h]
  int v219; // [rsp+284h] [rbp+144h]
  float v220; // [rsp+288h] [rbp+148h]
  float v221; // [rsp+28Ch] [rbp+14Ch]
  float v222; // [rsp+290h] [rbp+150h]
  __int64 v223; // [rsp+298h] [rbp+158h]
  int v224; // [rsp+2A0h] [rbp+160h]
  _QWORD v225[2]; // [rsp+2B0h] [rbp+170h] BYREF
  double v226; // [rsp+2C0h] [rbp+180h]
  _QWORD v227[2]; // [rsp+2C8h] [rbp+188h] BYREF
  const void *v228; // [rsp+2D8h] [rbp+198h]
  int n0x4300; // [rsp+2E0h] [rbp+1A0h] BYREF
  __int64 v230; // [rsp+2E4h] [rbp+1A4h]
  int v231; // [rsp+2ECh] [rbp+1ACh]
  unsigned __int64 v232; // [rsp+2F0h] [rbp+1B0h]
  unsigned __int64 v233; // [rsp+2F8h] [rbp+1B8h]
  __int64 v234; // [rsp+300h] [rbp+1C0h]
  __int64 v235; // [rsp+308h] [rbp+1C8h]
  _QWORD v236[2]; // [rsp+330h] [rbp+1F0h] BYREF
  const void *v237; // [rsp+340h] [rbp+200h]
  _QWORD v238[2]; // [rsp+348h] [rbp+208h] BYREF
  const void *v239; // [rsp+358h] [rbp+218h]
  _QWORD v240[2]; // [rsp+360h] [rbp+220h] BYREF
  const void *v241; // [rsp+370h] [rbp+230h]
  _QWORD v242[2]; // [rsp+378h] [rbp+238h] BYREF
  const void *v243; // [rsp+388h] [rbp+248h]
  _QWORD v244[2]; // [rsp+390h] [rbp+250h] BYREF
  __int64 v245[2]; // [rsp+3A0h] [rbp+260h] BYREF
  __int64 v246; // [rsp+3B0h] [rbp+270h] BYREF
  char v247[8]; // [rsp+3B8h] [rbp+278h] BYREF
  __int64 v248; // [rsp+3C0h] [rbp+280h] BYREF
  __int128 v249; // [rsp+3C8h] [rbp+288h]
  double v250; // [rsp+3D8h] [rbp+298h]
  __int64 v251; // [rsp+3E0h] [rbp+2A0h] BYREF
  __int128 v252; // [rsp+3E8h] [rbp+2A8h]
  double v253; // [rsp+3F8h] [rbp+2B8h]
  __int64 v254; // [rsp+400h] [rbp+2C0h] BYREF
  __int128 v255; // [rsp+408h] [rbp+2C8h]
  double v256; // [rsp+418h] [rbp+2D8h]
  __int64 v257; // [rsp+420h] [rbp+2E0h] BYREF
  __int128 v258; // [rsp+428h] [rbp+2E8h]
  __int64 v259; // [rsp+438h] [rbp+2F8h]
  char v260[32]; // [rsp+440h] [rbp+300h] BYREF
  __int128 v261; // [rsp+460h] [rbp+320h]
  __int64 v262; // [rsp+470h] [rbp+330h]
  __int128 v263; // [rsp+480h] [rbp+340h]
  __int128 v264; // [rsp+490h] [rbp+350h]
  __int128 v265; // [rsp+4A0h] [rbp+360h]
  __int128 v266; // [rsp+4B0h] [rbp+370h]
  __int128 v267; // [rsp+4C0h] [rbp+380h]
  __int128 v268; // [rsp+4D0h] [rbp+390h]
  __int128 v269; // [rsp+4E0h] [rbp+3A0h]
  __int128 v270; // [rsp+4F0h] [rbp+3B0h]
  unsigned __int64 n0xCC_1; // [rsp+570h] [rbp+430h] BYREF
  __int64 n0xCC; // [rsp+578h] [rbp+438h] BYREF
  __int64 v273; // [rsp+580h] [rbp+440h] BYREF
  const char *p_Success_1; // [rsp+588h] [rbp+448h] BYREF

  v270 = v2;
  v230 = 0;
  v231 = 0;
  v233 = 0;
  v234 = 0;
  v235 = 0;
  v269 = v3;
  n0x4300 = 0x4300;
  v232 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x4300,
    &word_149E68170,
    "CSCActorPhysicsController::Teleport",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorPhysicsController.cpp",
    0x5D6);
  HIWORD(n0x4300) = word_149E68170;
  if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
    v12 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
  else
    v12 = 0;
  v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x768LL))(v12);
  if ( v13 )
  {
    v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x30LL))(v13);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x90LL))(v14);
  }
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
    v15 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v15 = 0;
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x648LL))(v15);
  v17 = *(_QWORD *)v15;
  v273 = v16;
  (*(void (__fastcall **)(__int64, char *, __int64))(v17 + 0x1E8))(v15, v260, 2);
  LOBYTE(v167) = 0;
  v18 = (*(__int64 (__fastcall **)(__int64, __int128 **, _QWORD, _QWORD, int))(*(_QWORD *)v15 + 0x1E8LL))(
          v15,
          &v187,
          0,
          0,
          v167);
  v19 = (_QWORD *)(*(_QWORD *)(a1 + 0x128) & 0xFFFFFFFFFFFFLL);
  v20 = *(double *)(v18 + 0x30);
  _XMM8 = *(_OWORD *)(v18 + 0x20);
  v179 = _XMM8;
  *(double *)&n0xCC = v20;
  v226 = v20;
  CEntityTemplate::GetAttachmentOffsetVec3(v19, &v175);
  v22 = *(__int128 **)a2;
  v23 = 0;
  v24 = *(_OWORD *)(a2 + 0x28);
  v180 = *(__m256 *)(a2 + 8);
  v182 = *(_OWORD *)(a2 + 0x38);
  v181 = v24;
  if ( v22 )
  {
    __asm { vzeroupper }
    v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)::pEntitySystem + 0x118LL))(::pEntitySystem);
    v31 = v30;
    if ( v30 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x50LL))(v30) )
      {
        v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x668LL))(v31);
        goto LABEL_34;
      }
    }
    else
    {
      v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pGame + 0xA0LL))(pGame);
      v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x1D0LL))(v32);
      (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)v33 + 0x100LL))(
        v33,
        &v183,
        *(_QWORD *)(a1 + 8));
      if ( is_entity_descriptor_valid_or_accessible(&v183) )
      {
        if ( !*(_QWORD *)(a1 + 0x2E0)
          || fabs(*(double *)(a2 + 0x48) - *(double *)(a1 + 0x2E8)) > 0.05000000074505806
          || fabs(*(double *)(a2 + 0x50) - *(double *)(a1 + 0x2F0)) > 0.05000000074505806
          || fabs(*(double *)(a2 + 0x58) - *(double *)(a1 + 0x2F8)) > 0.05000000074505806 )
        {
          *(_OWORD *)(a1 + 0x2E8) = *(_OWORD *)(a2 + 0x48);
          *(double *)(a1 + 0x2F8) = *(double *)(a2 + 0x58);
          *(_QWORD *)(a1 + 0x300) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40
                                                                                          + 0x38LL))(
                                                 qword_149B4FC40,
                                                 0);
          v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)::pEntitySystem + 0x2D0LL))(::pEntitySystem);
          v35 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *, __int64, const char *, __int128 *))(*(_QWORD *)v34 + 0x30LL);
          v36 = (*(__int64 (__fastcall **)(unsigned __int64, double *))(*(_QWORD *)(v183 & 0xFFFFFFFFFFFFLL) + 8LL))(
                  v183 & 0xFFFFFFFFFFFFLL,
                  &v172);
          v37 = *(__m256 *)(a2 + 8);
          v38 = *(_OWORD *)(a2 + 0x28);
          v39 = *(__int128 **)a2;
          v40 = (__int64 *)v36;
          v194 = *(_DWORD *)(a2 + 0x78);
          v195 = *(_BYTE *)(a2 + 0x7C);
          LOBYTE(v36) = *(_BYTE *)(a2 + 0x7D);
          v188 = v37;
          v41 = *(__m256 *)(a2 + 0x38);
          v196 = v36;
          LOBYTE(v36) = *(_BYTE *)(a2 + 0x7E);
          v190 = v41;
          v42 = *(_OWORD *)(a2 + 0x60);
          v197 = v36;
          LOBYTE(v36) = *(_BYTE *)(a2 + 0x7F);
          v189 = v38;
          *(_QWORD *)&v38 = *(_QWORD *)(a2 + 0x58);
          v192 = v42;
          *(_QWORD *)&v42 = *(_QWORD *)(a2 + 0x70);
          v198 = v36;
          v43 = *v40;
          v187 = v39;
          v199 = v43;
          v191 = *(double *)&v38;
          v193 = *(double *)&v42;
          __asm { vzeroupper }
          v44 = sub_142F6ECE0((__int64)&v203, (__int64)&v187);
          v45 = allocWithProfilerInfo_w(0x88u);
          if ( v45 )
            v174 = sub_142F6ECE0(v45, v44);
          else
            v174 = 0;
          *(_QWORD *)&v173 = sub_145A281D0;
          *((_QWORD *)&v173 + 1) = sub_145A284B0;
          v46 = (_QWORD *)v35(v34, &n0xCC_1, 1, "Teleport", &v173);
          v47 = *(_QWORD *)(a1 + 0x2E0);
          v48 = v46;
          *(_QWORD *)(a1 + 0x2E0) = *v46;
          *v46 = v47;
          if ( v47 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v47 + 0x10LL))(v47);
          *v48 = 0;
          if ( n0xCC_1 )
            (*(void (__fastcall **)(unsigned __int64))(*(_QWORD *)n0xCC_1 + 0x10LL))(n0xCC_1);
          n0xCC_1 = 0;
          if ( *((_QWORD *)&v173 + 1) >= 2u )
            (*((void (__fastcall **)(__int64, __int128 *))&v173 + 1))(2, &v173);
        }
        v49 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                          qword_149B4FC40,
                          0);
        sub_1405975C0(v49, &v246, (_QWORD *)(a1 + 0x300));
        _XMM0 = sub_140597760();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        if ( *(float *)&_XMM1 > 10.0 )
        {
          v29 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v183 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v183 & 0xFFFFFFFFFFFFLL);
          v52 = *(double *)(a2 + 0x58);
          v181 = *(_OWORD *)(a2 + 0x48);
          *(double *)&v182 = v52;
          goto LABEL_34;
        }
      }
    }
    v57 = 0;
    goto LABEL_178;
  }
  __asm { vzeroupper }
  if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
    v25 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
  else
    v25 = 0;
  v26 = *(_QWORD *)(v25 + 8);
  v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pGame + 0xA0LL))(pGame);
  v28 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x1D0LL))(v27);
  (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v28 + 0x100LL))(v28, &v200, v26);
  if ( !is_entity_descriptor_valid_or_accessible(&v200) )
    goto LABEL_38;
  v29 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v200 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v200 & 0xFFFFFFFFFFFFLL);
LABEL_34:
  v23 = v29;
  if ( v29 )
  {
    v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x20LL))(v29);
    if ( v53 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x58LL))(v53) )
        v23 = 0;
    }
  }
LABEL_38:
  LOBYTE(n0xCC_1) = 0;
  CreateStringObjectFromString((void **)&p_Success_1, (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source);
  if ( *(_DWORD *)(a1 + 0x310) != 7
    || (is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8))
      ? (v54 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
      : (v54 = 0),
        (v55 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v54 + 0x150LL))(v54, v247),
         !is_entity_descriptor_valid_or_accessible(v55))
     || (is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8))
       ? (v56 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
       : (v56 = 0),
         (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v56 + 0x178LL))(v56) == 9)) )
  {
    if ( !v23 )
    {
      assignCStringToStringStructure(
        (void **)&p_Success_1,
        "Trying to teleport an actor to a position in an unknown zone, failing");
      v58 = v273;
LABEL_124:
      if ( *(_BYTE *)(a2 + 0x7C) )
      {
        v133 = is_valid_handle_typeA((__int64 *)(a1 + 0x118)) ? *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL : 0LL;
        if ( sub_1465D1DE0(v133) )
        {
          v140 = sub_144E30AE0();
          v141 = v140;
          if ( v140 )
          {
            if ( !(unsigned __int8)sub_144E31650(v140, 1) )
              sub_144E2E4E0(v141, 1, 0.0, 1, 1u);
          }
        }
      }
      v142 = off_149A44400;
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v143 = (unsigned __int64 *)(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
      else
        v143 = 0;
      if ( sub_144E5DE60(v143, v142) )
      {
        if ( v23 )
        {
          v144 = (double *)(*(__int64 (__fastcall **)(__int64, _QWORD *, __int128 *))(*(_QWORD *)v23 + 0x170LL))(
                             v23,
                             v227,
                             &v181);
        }
        else
        {
          v201 = v181;
          v202 = *(double *)&v182;
          v144 = (double *)&v201;
        }
        _XMM6 = *(_OWORD *)v144;
        v146 = v144[2];
        n0xCC = 0xCC;
        v244[0] = &n0xCC;
        v244[1] = &v273;
        v202 = v146;
        v147 = invokeGlobalCallbackAndMaskStatusBits(
                 5,
                 (__int64)v244,
                 (__int64)"Actor Teleport",
                 "$$: Teleporting actor '$$' [$$] ($$) from Z$$ W$$ [Zone $$] to Z$$ W$$ [Zone $$], distance = $$, base r"
                 "otation from $$ to $$ requested by '$$', result '$$'");
        n0xCC_2 = n0xCC_1;
        v149 = v147;
        if ( (v147 & 0xFFFFF) != 0 )
        {
          v204 = v180;
          *(double *)v188.m256_f32 = v175;
          *(double *)&v188.m256_f32[6] = v178;
          *(double *)&v188.m256_f32[4] = v177;
          *(double *)&v188.m256_f32[2] = v176;
          __asm
          {
            vunpckhpd xmm1, xmm8, xmm8
            vunpckhpd xmm0, xmm6, xmm6
          }
          *((_QWORD *)&v152 + 1) = *((_QWORD *)&_XMM1 + 1);
          v227[0] = 0;
          p_Success = "Success";
          v228 = 0;
          if ( !(_BYTE)n0xCC_1 )
            p_Success = p_Success_1;
          p_unknown = "unknown";
          v227[1] = p_Success;
          v242[0] = 0;
          v242[1] = &p_p_p_p_p_p_p_p_p_p_p_Source;
          v243 = 0;
          v203 = 0;
          v187 = 0;
          *(_QWORD *)&v179 = 0;
          *(double *)&v152 = (*(double *)&_XMM1 - *(double *)&_XMM0) * (*(double *)&_XMM1 - *(double *)&_XMM0)
                           + (*(double *)&_XMM8 - *(double *)&_XMM6) * (*(double *)&_XMM8 - *(double *)&_XMM6)
                           + (v226 - v202) * (v226 - v202);
          _XMM2 = v152;
          __asm
          {
            vmovddup xmm1, xmm2
            vsqrtpd xmm4, xmm1
            vmovhpd [rbp+420h+var_470+8], xmm4
          }
          if ( v23 )
          {
            __asm { vzeroupper }
            p_unknown_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x1F0LL))(v23);
          }
          else
          {
            p_unknown_1 = "unknown";
          }
          v225[0] = 0;
          v225[1] = p_unknown_1;
          v226 = 0.0;
          v248 = 0;
          v251 = 0;
          v252 = v181;
          v253 = *(double *)&v182;
          v249 = _XMM6;
          v250 = v146;
          if ( v58 )
          {
            __asm { vzeroupper }
            p_unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x1F0LL))(v58);
          }
          v258 = v261;
          v259 = v262;
          v240[0] = 0;
          v240[1] = p_unknown;
          v241 = 0;
          v254 = 0;
          v255 = _XMM8;
          v256 = v20;
          v257 = 0;
          __asm { vzeroupper }
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v159 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v159 = 0;
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v159 + 0x720LL))(v159) )
          {
            p_Server = "Authority";
          }
          else
          {
            p_Server = "Client";
            if ( byte_149B4FE80 )
              p_Server = "Server";
          }
          v238[0] = 0;
          v238[1] = p_Server;
          v239 = 0;
          sub_1403B0A70((unsigned __int64 *)(a1 + 8), &n0xCC);
          *((_QWORD *)&v201 + 1) = n0xCC;
          *(_QWORD *)&v201 = 0;
          LOBYTE(v202) = 0;
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v161 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v161 = 0;
          v236[1] = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v161 + 0x70LL))(v161);
          p_CSCActorPhysicsController::Teleport = "CSCActorPhysicsController::Teleport";
          v236[0] = 0;
          v237 = 0;
          v184 = 0;
          v186 = 0;
          ThreadLogContextSlot_1 = getThreadLogContextSlot();
          n0xCC_1 = 0xCC;
          v245[0] = (__int64)&n0xCC_1;
          v245[1] = (__int64)&n0xCC;
          v173 = 0;
          sub_145A23190(
            5u,
            v245,
            "Actor Teleport",
            "$$: Teleporting actor '$$' [$$] ($$) from Z$$ W$$ [Zone $$] to Z$$ W$$ [Zone $$], distance = $$, base rotati"
            "on from $$ to $$ requested by '$$', result '$$'",
            1,
            v149,
            &v173,
            0,
            ThreadLogContextSlot_1,
            &v184,
            v236,
            &v201,
            v238,
            &v257,
            &v254,
            v240,
            &v251,
            &v248,
            v225,
            &v179,
            &v187,
            &v203,
            v242,
            v227);
          sub_1402A3D30(v186);
          sub_1402A3D30(v237);
          sub_1402A3D30(v239);
          sub_1402A3D30(v241);
          sub_1402A3D30(*(const void **)&v226);
          sub_1402A3D30(v243);
          sub_1402A3D30(v228);
        }
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
          v163 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v163 = 0;
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v163 + 0x720LL))(v163) && n0xCC_2 && v23 )
        {
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v164 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v164 = 0;
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v164 + 0x648LL))(v164);
        }
      }
      v165 = *(_QWORD *)(a1 + 0x2E0);
      if ( v165 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v165 + 0x10LL))(v165);
        *(_QWORD *)(a1 + 0x2E0) = 0;
      }
      v57 = 1;
      goto LABEL_176;
    }
    v58 = v273;
    v268 = v4;
    v267 = v5;
    v266 = v6;
    v265 = v7;
    v264 = v8;
    v59 = is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8));
    if ( v23 == v58 )
    {
      if ( v59 )
        v60 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v60 = 0;
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v60 + 0x3B8LL))(v60, &n0xCC_1);
      if ( n0xCC_1
        && *(_QWORD *)((n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(n0xCC_1)
        && (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8LL))(n0xCC_1 & 0xFFFFFFFFFFFFLL) == 6 )
      {
        v61 = qword_149B4FC00;
        v215 = 0.0;
        v216 = 0.0;
        v217 = 0.0;
        v220 = 0.0;
        v221 = 0.0;
        v222 = 0.0;
        LODWORD(v184) = 0xFFBFFFFF;
        v203 = 0xFFBFFFFF0000000CuLL;
        v219 = 0;
        *(_QWORD *)v204.m256_f32 = 0xFFBFFFFFFFBFFFFFuLL;
        v205 = NAN;
        v210 = 0xFFF7FFFF;
        v212 = 0xFFBFFFFF;
        v218 = 0xFFBFFFFF;
        *(_QWORD *)&v204.m256_f32[2] = 0xFFBFFFFFFFBFFFFFuLL;
        v204.m256_f32[4] = NAN;
        v204.m256_f32[7] = NAN;
        v213 = 0;
        v214 = 0;
        v223 = 0;
        v224 = 0;
        v62 = *(void (__fastcall **)(__int64, __int128 *, __int64 *, unsigned __int64 *, int, unsigned int, __int128 *, _QWORD, __int64 *, int, _QWORD, _BYTE))(*(_QWORD *)qword_149B4FC00 + 0x390LL);
        ThreadLogContextSlot = *(__int64 **)(*(__int64 (__fastcall **)(__int64, double *))(*(_QWORD *)v23 + 0x18LL))(
                                              v23,
                                              &v172);
        *(float *)&v173 = 0.0;
        *((float *)&v173 + 1) = 0.0;
        *((float *)&v173 + 2) = 0.0;
        v62(v61, &v181, &v184, &v203, 1, 0xFFFFFFFF, &v173, 0, ThreadLogContextSlot, 0x1E, 0, 0);
        if ( v172 != 0.0 )
          sub_140522CF0(*(__int64 *)&v172);
        v63 = *(float *)&v184 == 0.0
           && *((float *)&v184 + 1) == 0.0
           && *(float *)&p_CSCActorPhysicsController::Teleport == 0.0;
        LOBYTE(v169) = 0;
        v64 = *(void (__fastcall **)(__int64, __m256 *, __int64, __int64, int, _QWORD))(*(_QWORD *)v15 + 0x1D8LL);
        if ( v63 )
        {
          v64(v15, &v180, 2, 0x2001002, v169, 0);
          *(double *)&v188.m256_f32[4] = *(double *)&v182;
          *(_OWORD *)v188.m256_f32 = v181;
          *((_QWORD *)&v76 + 1) = (LODWORD(v176) ^ (unsigned __int128)0x80000000) >> 0x40;
          v65 = COERCE_FLOAT(LODWORD(v176) ^ 0x80000000);
          v66 = COERCE_FLOAT(LODWORD(v177) ^ 0x80000000);
          v67 = COERCE_FLOAT(LODWORD(v175) ^ 0x80000000);
          _XMM2 = COERCE_UNSIGNED_INT64(
                    *(double *)&v180.m256_f32[6] * v178
                  - (*(double *)v180.m256_f32 * v67
                   + v65 * *(double *)&v180.m256_f32[2]
                   + *(double *)&v180.m256_f32[4] * v66));
          __asm { vcvtsd2ss xmm9, xmm2, xmm2 }
          _XMM2 = COERCE_UNSIGNED_INT64(
                    *(double *)&v180.m256_f32[2] * v66
                  - v65 * *(double *)&v180.m256_f32[4]
                  + *(double *)&v180.m256_f32[6] * v67
                  + *(double *)v180.m256_f32 * v178);
          __asm { vcvtsd2ss xmm5, xmm2, xmm2 }
          _XMM2 = COERCE_UNSIGNED_INT64(
                    *(double *)&v180.m256_f32[4] * v67
                  - *(double *)v180.m256_f32 * v66
                  + v65 * *(double *)&v180.m256_f32[6]
                  + *(double *)&v180.m256_f32[2] * v178);
          __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
          LODWORD(v187) = 0;
          *((_QWORD *)&v189 + 1) = 0x80000000FFBFFFFFuLL;
          LOBYTE(v190.m256_f32[1]) = LOBYTE(v190.m256_f32[1]) & 0xF0 | 8;
          v74 = *(_QWORD *)v23;
          *(double *)&v76 = v65 * *(double *)v180.m256_f32
                          - *(double *)&v180.m256_f32[2] * v67
                          + *(double *)&v180.m256_f32[6] * v66
                          + *(double *)&v180.m256_f32[4] * v178;
          _XMM2 = v76;
          __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
          *(float *)&v189 = *(float *)&_XMM1;
          v188.m256_f32[6] = *(float *)&_XMM5;
          v188.m256_f32[7] = *(float *)&_XMM4;
          *((float *)&v189 + 1) = *(float *)&_XMM9;
          LODWORD(v190.m256_f32[0]) = 0x80;
          *(_QWORD *)&v190.m256_f32[2] = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, double *))(v74 + 0x18))(
                                                      v23,
                                                      &v172);
          if ( v172 != 0.0 )
            sub_140522CF0(*(__int64 *)&v172);
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
            v78 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v78 = 0;
          (*(void (__fastcall **)(__int64, __int128 **, _QWORD, _QWORD))(*(_QWORD *)v78 + 0x3F8LL))(v78, &v187, 0, 0);
          _XMM8 = v179;
          v20 = *(double *)&n0xCC;
          v58 = v273;
        }
        else
        {
          v64(v15, &v180, 2, 0x2001006, v169, 0);
          v58 = v273;
        }
        goto LABEL_91;
      }
    }
    else
    {
      if ( v59 )
        v79 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v79 = 0;
      v80 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, double *))(*(_QWORD *)v79 + 0x150LL))(v79, &v172);
      if ( is_entity_descriptor_valid_or_accessible(v80) )
      {
        sub_14035B3E0(&n0xCC);
        v135 = v134;
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
          v136 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v136 = 0;
        v137 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v136 + 0x150LL))(v136, &v273);
        v138 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*v137 & 0xFFFFFFFFFFFFLL) + 0x70LL))(*v137 & 0xFFFFFFFFFFFFLL);
        v139 = sub_1403A9130(v135, "Trying to teleport an actor to a new zone while attached to [%s], failing", v138);
        copyStringStructure((char **)&p_Success_1, v139);
        sub_140370D10(&n0xCC);
        goto LABEL_124;
      }
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
        v81 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v81 = 0;
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v81 + 0x3B8LL))(v81, &n0xCC_1);
      if ( n0xCC_1
        && *(_QWORD *)((n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(n0xCC_1)
        && (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8LL))(n0xCC_1 & 0xFFFFFFFFFFFFLL) == 6 )
      {
        v82 = *(_QWORD *)v15;
        v263 = v9;
        v83 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD))(v82 + 0x680);
        v84 = (*(__int64 (__fastcall **)(__int64, __int128 **, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL))(
                qword_149B4FBE8,
                &v187,
                v58,
                v23);
        v83(v15, v23, v84, 0, 0);
        LOBYTE(v170) = 0;
        (*(void (__fastcall **)(__int64, __m256 *, __int64, __int64, int, _QWORD))(*(_QWORD *)v15 + 0x1D8LL))(
          v15,
          &v180,
          2,
          0x2001002,
          v170,
          0);
        LODWORD(v203) = 0;
        LOBYTE(v210) = v210 & 0xF0 | 8;
        v207 = 0xFFBFFFFF;
        v208 = 0x80000000;
        *(_OWORD *)v204.m256_f32 = v181;
        *(double *)&v204.m256_f32[4] = *(double *)&v182;
        v85 = (*(__int64 (__fastcall **)(__int64, __int128 **, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL))(
                qword_149B4FBE8,
                &v187,
                v58,
                v23);
        v86 = *(double *)(v85 + 8);
        v87 = *(double *)v85;
        v88 = *(double *)(v85 + 0x18);
        v89 = *(unsigned __int64 *)(v85 + 0x10);
        v172 = v88 * v178 - (*(double *)v85 * v175 + v86 * v176 + *(double *)&v89 * v177);
        *((_QWORD *)&v90 + 1) = *((_QWORD *)&v89 + 1);
        v91 = -(v177 * v86 - *(double *)&v89 * v176 + v175 * v88 + v87 * v178);
        v92 = -(*(double *)&v89 * v175 - v177 * v87 + v176 * v88 + v86 * v178);
        v93 = *(_QWORD *)v23;
        *(double *)&v89 = -(v87 * v176 - v175 * v86 + v177 * v88 + *(double *)&v89 * v178);
        _XMM2 = COERCE_UNSIGNED_INT64(
                  *(double *)&v180.m256_f32[6] * v172
                - (*(double *)v180.m256_f32 * v91
                 + v92 * *(double *)&v180.m256_f32[2]
                 + *(double *)&v180.m256_f32[4] * *(double *)&v89));
        __asm { vcvtsd2ss xmm9, xmm2, xmm2 }
        _XMM2 = COERCE_UNSIGNED_INT64(
                  *(double *)&v180.m256_f32[2] * *(double *)&v89
                - v92 * *(double *)&v180.m256_f32[4]
                + *(double *)&v180.m256_f32[6] * v91
                + *(double *)v180.m256_f32 * v172);
        __asm { vcvtsd2ss xmm5, xmm2, xmm2 }
        _XMM2 = COERCE_UNSIGNED_INT64(
                  *(double *)&v180.m256_f32[4] * v91
                - *(double *)v180.m256_f32 * *(double *)&v89
                + v92 * *(double *)&v180.m256_f32[6]
                + *(double *)&v180.m256_f32[2] * v172);
        __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
        *(double *)&v90 = v92 * *(double *)v180.m256_f32
                        - *(double *)&v180.m256_f32[2] * v91
                        + *(double *)&v180.m256_f32[6] * *(double *)&v89
                        + *(double *)&v180.m256_f32[4] * v172;
        _XMM2 = v90;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        n0x80 = 0x80;
        v205 = *(float *)&_XMM1;
        v204.m256_f32[6] = *(float *)&_XMM5;
        v204.m256_f32[7] = *(float *)&_XMM4;
        v206 = *(float *)&_XMM9;
        v211 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, double *))(v93 + 0x18))(v23, &v172);
        if ( v172 != 0.0 )
          sub_140522CF0(*(__int64 *)&v172);
        if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
          v102 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v102 = 0;
        (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD, _QWORD))(*(_QWORD *)v102 + 0x3F8LL))(
          v102,
          &v203,
          0,
          0);
        _XMM8 = v179;
        v20 = *(double *)&n0xCC;
        goto LABEL_91;
      }
      v103 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v15 + 0x680LL);
      v104 = (*(__int64 (__fastcall **)(__int64, __int128 **, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL))(
               qword_149B4FBE8,
               &v187,
               v58,
               v23);
      v103(v15, v23, v104, 0, 0);
    }
    LOBYTE(v168) = 0;
    (*(void (__fastcall **)(__int64, __m256 *, __int64, __int64, int, _QWORD))(*(_QWORD *)v15 + 0x1D8LL))(
      v15,
      &v180,
      2,
      0x2001006,
      v168,
      0);
LABEL_91:
    LOBYTE(n0xCC_1) = 1;
    sub_143825070(a1, &n0xCC);
    v105 = *(float *)(a2 + 0x64);
    v106 = (__m128)*(unsigned int *)(a2 + 0x68);
    v107 = *(float *)(a2 + 0x6C);
    v108 = *(float *)(a2 + 0x60);
    v109 = v106;
    v109.m128_f32[0] = (float)((float)(v106.m128_f32[0] * v106.m128_f32[0]) + (float)(v105 * v105))
                     + (float)((float)(v108 * v108) + (float)(v107 * v107));
    v110 = n0xCC & 0xFFFFFFFFFFFFLL;
    if ( v109.m128_f32[0] <= 0.0000000099999999 )
    {
      *((float *)&v173 + 3) = 1.0;
      *(float *)&v173 = 0.0;
      *((float *)&v173 + 1) = 0.0;
      *((float *)&v173 + 2) = 0.0;
    }
    else
    {
      _XMM0 = _mm_shuffle_ps(v109, v109, 0);
      __asm { vrsqrtps xmm3, xmm0 }
      _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
      _XMM3.m128_f32[0] = (float)(1.5
                                - (float)((float)((float)(v109.m128_f32[0] * _XMM3.m128_f32[0]) * _XMM3.m128_f32[0])
                                        * 0.5))
                        * _XMM3.m128_f32[0];
      *((float *)&v173 + 3) = _XMM3.m128_f32[0] * v107;
      *(float *)&v173 = _XMM3.m128_f32[0] * v108;
      *((float *)&v173 + 1) = _XMM3.m128_f32[0] * v105;
      *((float *)&v173 + 2) = _XMM3.m128_f32[0] * v106.m128_f32[0];
    }
    sub_1461F6D30(n0xCC & 0xFFFFFFFFFFFFLL, (float *)&v173);
    sub_1461E66C0(v110, (const void *)(a2 + 0x70));
    if ( v23 != v58 )
    {
      v113 = *(_QWORD *)v15;
      n0xCC = 0x100000003LL;
      (*(void (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(v113 + 0x408))(v15, &n0xCC, 0, 0);
    }
    if ( *(_BYTE *)(a2 + 0x7D) )
    {
      sub_145A3C120(a1, 0, 0.0);
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v114 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
      else
        v114 = 0;
      v115 = sub_1465EF570(v114);
      *(_BYTE *)(v115 + 0xC) = 0;
      *(_DWORD *)(v115 + 0x10) = 0;
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v116 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
      else
        v116 = 0;
      v117 = sub_1465EECD0(v116);
      LODWORD(n0xCC) = 0;
      v118 = v117;
      sub_14035C4A0(&n0xCC, 0xDE);
      sub_145ED3E20(v118, (int *)&n0xCC);
    }
    if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
      v119 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
    else
      v119 = 0;
    v120 = sub_1465EEE60(v119);
    sub_145847EE0(v120, a2);
    if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
      v121 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
    else
      v121 = 0;
    v122 = sub_1465EEEC0(v121);
    v123 = sub_145F4F9E0(v122, &n0xCC);
    v124 = *v123;
    if ( *v123 )
    {
      v125 = sub_1403B4B50(v124 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v125 + 4);
      if ( n4 != 4
        && *(_WORD *)(v125 + 2) == (HIWORD(v124) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_14031FE20(v123)) )
      {
        v127 = *v123 & 0xFFFFFFFFFFFFLL;
        if ( v127 )
        {
          *(_QWORD *)&v179 = 0;
          if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
            v128 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
          else
            v128 = 0;
          v129 = sub_1465EEE60(v128);
          v130 = sub_145843B60(v129);
          pEntitySystem = ::pEntitySystem;
          DWORD2(v179) = !v130 + 1;
          v187 = &v179;
          v132 = *(float *)&dword_149E65118;
          if ( !dword_149E65118 )
            LODWORD(v132) = get_event_key_from_source_location(
                              &dword_149E65118,
                              (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/Player/Items.h",
                              0x1B);
          v188.m256_f32[0] = v132;
          *(_QWORD *)&v188.m256_f32[2] = 0x10;
          *(_QWORD *)&v188.m256_f32[4] = "struct SPI_ThrusterPack_RequestAction";
          LOBYTE(v188.m256_f32[6]) = byte_149E68124;
          *(_QWORD *)&v189 = _StarEngineModule__;
          *((_QWORD *)&v189 + 1) = sub_14041E9D0;
          (*(void (__fastcall **)(__int64, __int64, __int128 **))(*(_QWORD *)pEntitySystem + 0x358LL))(
            pEntitySystem,
            v127,
            &v187);
        }
      }
    }
    v58 = v273;
    goto LABEL_124;
  }
  if ( !*(_BYTE *)(a2 + 0x7F) )
  {
    assignCStringToStringStructure((void **)&p_Success_1, "Trying to teleport an actor that is linked, failing");
    v58 = v273;
    goto LABEL_124;
  }
  v57 = 0;
LABEL_176:
  sub_140370D10(&p_Success_1);
LABEL_178:
  v233 = __rdtsc();
  qword_149B4B878(&n0x4300);
  return v57;
}

// --- End Function: sub_145A3D0F0 (0x145A3D0F0) ---

// --- Function: sub_145C25930 (0x145C25930) ---
bool __fastcall sub_145C25930(__int64 a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx
  unsigned __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  v1 = (_QWORD *)(a1 + 8);
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8)) )
    v2 = *v1 & 0xFFFFFFFFFFFFLL;
  else
    v2 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v2 + 0x3B8LL))(v2, &v4);
  return v4
      && *(_QWORD *)((v4 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v4)
      && (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 8LL))(v4 & 0xFFFFFFFFFFFFLL) == 6;
}

// --- End Function: sub_145C25930 (0x145C25930) ---

// --- Function: sub_145CCC9A0 (0x145CCC9A0) ---
bool __fastcall sub_145CCC9A0(unsigned __int64 a1, unsigned __int64 a2, __int64 **a3, char a4)
{
  _QWORD *v4; // rax
  __int64 v6; // r8
  __int64 v7; // r8
  double v12; // xmm0_8
  char v13; // [rsp+20h] [rbp-358h]
  int v14; // [rsp+20h] [rbp-358h]
  double *v15; // [rsp+38h] [rbp-340h]
  double v16; // [rsp+48h] [rbp-330h]
  double v17; // [rsp+50h] [rbp-328h]
  double v18; // [rsp+50h] [rbp-328h]
  double v19; // [rsp+58h] [rbp-320h]
  double v20; // [rsp+58h] [rbp-320h]
  int v21; // [rsp+60h] [rbp-318h] BYREF
  float v22; // [rsp+64h] [rbp-314h]
  double v23; // [rsp+68h] [rbp-310h]
  double *v24; // [rsp+70h] [rbp-308h]
  double *v25; // [rsp+78h] [rbp-300h]
  __int64 v26; // [rsp+80h] [rbp-2F8h]
  __int64 v27; // [rsp+88h] [rbp-2F0h]
  __int64 v28; // [rsp+90h] [rbp-2E8h]
  __int64 v29; // [rsp+98h] [rbp-2E0h]
  __int64 v30[3]; // [rsp+A0h] [rbp-2D8h] BYREF
  ULONG_PTR Parameter; // [rsp+B8h] [rbp-2C0h] BYREF
  __int64 v32; // [rsp+C0h] [rbp-2B8h]
  __int64 v33; // [rsp+C8h] [rbp-2B0h]
  __int64 v34; // [rsp+D0h] [rbp-2A8h]
  double v35; // [rsp+D8h] [rbp-2A0h]
  double v36; // [rsp+E0h] [rbp-298h]
  double v37; // [rsp+E8h] [rbp-290h]
  __int64 v38[2]; // [rsp+F0h] [rbp-288h] BYREF
  float v39[4]; // [rsp+100h] [rbp-278h] BYREF
  __int64 (__fastcall *v40)(__int64, _BYTE *); // [rsp+110h] [rbp-268h]
  unsigned __int64 *v41; // [rsp+118h] [rbp-260h]
  void (__fastcall *v42)(__int64, _BYTE *, const char *); // [rsp+120h] [rbp-258h]
  _BYTE v43[8]; // [rsp+128h] [rbp-250h] BYREF
  unsigned __int8 (__fastcall *v44)(__int64, _BYTE *, __int64); // [rsp+130h] [rbp-248h]
  __int64 v45; // [rsp+138h] [rbp-240h]
  __int64 *v46; // [rsp+140h] [rbp-238h]
  __int64 v47; // [rsp+148h] [rbp-230h]
  __int64 v48; // [rsp+150h] [rbp-228h]
  __int64 *v49; // [rsp+158h] [rbp-220h]
  __int64 v50; // [rsp+160h] [rbp-218h]
  __int64 **v51; // [rsp+168h] [rbp-210h]
  struct __crt_stdio_stream *v52; // [rsp+170h] [rbp-208h]
  _BYTE v53[8]; // [rsp+178h] [rbp-200h] BYREF
  Parameter *Parameter_1; // [rsp+180h] [rbp-1F8h]
  _QWORD *v55; // [rsp+188h] [rbp-1F0h]
  Parameter **p_Parameter; // [rsp+190h] [rbp-1E8h]
  void (__fastcall *v57)(__int64, unsigned int *, __int64); // [rsp+198h] [rbp-1E0h]
  __int64 (__fastcall *v58)(__int64, _BYTE *, _QWORD, _QWORD, char); // [rsp+1A0h] [rbp-1D8h]
  __int64 (__fastcall *v59)(__int64, _BYTE *, _QWORD, _QWORD, int); // [rsp+1A8h] [rbp-1D0h]
  double *v60; // [rsp+1B0h] [rbp-1C8h]
  double *src; // [rsp+1B8h] [rbp-1C0h]
  double v62; // [rsp+1C0h] [rbp-1B8h]
  double v63; // [rsp+1C8h] [rbp-1B0h]
  double v64; // [rsp+1D0h] [rbp-1A8h]
  __int64 (__fastcall *v65)(__int64, _BYTE *); // [rsp+1D8h] [rbp-1A0h]
  struct std::pmr::memory_resource *v66; // [rsp+1E0h] [rbp-198h]
  std::pmr::_Identity_equal_resource *v67; // [rsp+1E8h] [rbp-190h]
  __int64 (__fastcall *v68)(__int64, _BYTE *); // [rsp+1F0h] [rbp-188h]
  double v69; // [rsp+1F8h] [rbp-180h]
  double v70; // [rsp+200h] [rbp-178h]
  double v71; // [rsp+208h] [rbp-170h]
  double v72; // [rsp+210h] [rbp-168h]
  double v73; // [rsp+218h] [rbp-160h]
  double v74; // [rsp+220h] [rbp-158h]
  double src_[3]; // [rsp+228h] [rbp-150h] BYREF
  double dst_[3]; // [rsp+240h] [rbp-138h] BYREF
  __int64 v77; // [rsp+258h] [rbp-120h] BYREF
  __int64 v78; // [rsp+260h] [rbp-118h] BYREF
  _BYTE v79[8]; // [rsp+268h] [rbp-110h] BYREF
  _BYTE v80[8]; // [rsp+270h] [rbp-108h] BYREF
  _BYTE v81[8]; // [rsp+278h] [rbp-100h] BYREF
  __int64 v82; // [rsp+280h] [rbp-F8h] BYREF
  unsigned int v83[6]; // [rsp+288h] [rbp-F0h] BYREF
  _BYTE v84[64]; // [rsp+2A0h] [rbp-D8h] BYREF
  _BYTE v85[64]; // [rsp+2E0h] [rbp-98h] BYREF
  double v86[11]; // [rsp+320h] [rbp-58h] BYREF
  unsigned __int64 v87; // [rsp+380h] [rbp+8h] BYREF
  unsigned __int64 v88; // [rsp+388h] [rbp+10h] BYREF
  __int64 **v89; // [rsp+390h] [rbp+18h]
  char v90; // [rsp+398h] [rbp+20h]

  v90 = a4;
  v89 = a3;
  v88 = a2;
  v87 = a1;
  if ( !is_entity_descriptor_valid_or_accessible(&v87) )
    return 0;
  if ( !is_entity_descriptor_valid_or_accessible(&v88) )
    return 0;
  v26 = sub_14030ECF0(&v88);
  v68 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v26 + 0x18LL);
  v4 = (_QWORD *)v68(v26, v80);
  if ( !unknown_libname_23(&v87, v4) )
    return 0;
  if ( v90 )
  {
    v27 = sub_14030ECF0(&v88);
    v40 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v27 + 0x150LL);
    v41 = (unsigned __int64 *)v40(v27, v81);
    if ( j_is_entity_descriptor_valid_or_accessible(v41) )
      return 0;
  }
  v28 = *(_QWORD *)(identity((__int64)&pSystem) + 0x18);
  v42 = *(void (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)v28 + 0x28LL);
  v42(v28, v43, "Item.Inventory.Unlootable");
  v29 = sub_14030ECF0(&v88);
  v44 = *(unsigned __int8 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v29 + 0x628LL);
  LOBYTE(v6) = 1;
  if ( v44(v29, v43, v6) )
    return 0;
  v45 = sub_14030ECF0(&v88);
  v46 = sub_14156A5E0(v45, &v82);
  v47 = *v46;
  v38[0] = v47;
  if ( !is_valid_handle_typeA(v38) )
    return 0;
  v48 = sub_14030ECF0(&v88);
  v49 = sub_14033A530(v48, &v77);
  v50 = *v49;
  v30[0] = v50;
  if ( AssetMeta::HasActorSubresource(v30) )
  {
    v30[1] = v30[0] & 0xFFFFFFFFFFFFLL;
    v21 = *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v30[0] & 0xFFFFFFFFFFFFLL) + 0x570LL))(v30[0] & 0xFFFFFFFFFFFFLL)
                    + 8);
    if ( !v89[1] )
      goto LABEL_12;
    v51 = v89;
    v52 = (struct __crt_stdio_stream *)sub_142146330(v89, &v21);
    _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
      (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v53,
      v52);
    v55 = v53;
    v30[2] = (__int64)v89;
    Parameter_1 = *v89;
    Parameter = (ULONG_PTR)Parameter_1;
    _StarEngineModule__((ULONG_PTR)&Parameter);
    p_Parameter = &Parameter;
    if ( *v55 == Parameter )
    {
LABEL_12:
      v32 = sub_14030ECF0(&v87);
      v57 = *(void (__fastcall **)(__int64, unsigned int *, __int64))(*(_QWORD *)v32 + 0x220LL);
      LOBYTE(v7) = 1;
      v57(v32, v83, v7);
      v33 = sub_14030ECF0(&v88);
      v58 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD, char))(*(_QWORD *)v33 + 0x1E8LL);
      v13 = 1;
      v15 = (double *)(v58(v33, v84, 0, 0, v13) + 0x20);
      v34 = sub_14030ECF0(&v87);
      v59 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD, int))(*(_QWORD *)v34 + 0x1E8LL);
      LOBYTE(v14) = 1;
      v60 = (double *)v59(v34, v85, 0, 0, v14);
      v24 = sub_1404B6AF0(v60, v86);
      v37 = v24[1] * v15[2] - v24[2] * v15[1] + v24[3] * *v15;
      v36 = v24[2] * *v15 - *v24 * v15[2] + v24[3] * v15[1];
      v35 = *v24 * v15[1] - v24[1] * *v15 + v24[3] * v15[2];
      v16 = v35 * v24[1] - v36 * v24[2];
      v17 = v37 * v24[2] - v35 * *v24;
      v18 = v17 + v17 + v15[1];
      v19 = v36 * *v24 - v37 * v24[1];
      v20 = v19 + v19 + v15[2];
      src_[0] = v16 + v16 + *v15;
      src_[1] = v18;
      src_[2] = v20;
      src = src_;
      v23 = v24[7];
      qmemcpy(dst_, src_, sizeof(dst_));
      v69 = dst_[0] * v23;
      v70 = dst_[1] * v23;
      v71 = dst_[2] * v23;
      v25 = v24 + 4;
      v64 = dst_[2] * v23 + v24[6];
      v63 = dst_[1] * v23 + v24[5];
      v62 = dst_[0] * v23 + v24[4];
      v72 = v62;
      v73 = v63;
      _XMM0 = *(unsigned __int64 *)&v64;
      v74 = v64;
      __asm { vcvtsd2ss xmm0, xmm0, [rsp+378h+var_168] }
      v39[0] = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, [rsp+378h+var_160] }
      v39[1] = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, [rsp+378h+var_158] }
      v39[2] = *(float *)&_XMM0;
      *(_QWORD *)&v12 = sub_1418BBB60(v83, v39).m128_u64[0];
      v22 = sub_1403EAD10(v12).m128_f32[0];
      if ( v22 <= *(float *)(n2_174 + 0xC58) )
        return 1;
    }
  }
  v66 = (struct std::pmr::memory_resource *)*sub_1403B0A70(&v87, &v78);
  v38[1] = v38[0] & 0xFFFFFFFFFFFFLL;
  v65 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)(v38[0] & 0xFFFFFFFFFFFFLL) + 0x570LL);
  v67 = *(std::pmr::_Identity_equal_resource **)v65(v38[0] & 0xFFFFFFFFFFFFLL, v79);
  return std::pmr::_Identity_equal_resource::do_is_equal(v67, v66);
}

// --- End Function: sub_145CCC9A0 (0x145CCC9A0) ---

// --- Function: sub_145CDFF30 (0x145CDFF30) ---
__int64 __fastcall sub_145CDFF30(__int64 a1, unsigned __int64 a2)
{
  Parameter *Parameter_1; // rbx
  unsigned __int64 n0x30; // rax
  __int64 v5; // rcx
  __int64 v6; // rdi
  Parameter *Parameter_2; // rdx
  _QWORD *v9; // rsi
  __int64 v10; // rax
  __int128 Parameter; // [rsp+30h] [rbp-20h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h]
  unsigned __int64 v13; // [rsp+88h] [rbp+38h] BYREF
  __int64 v14; // [rsp+90h] [rbp+40h] BYREF
  unsigned __int64 v15; // [rsp+98h] [rbp+48h] BYREF

  v13 = a2;
  if ( !is_entity_descriptor_valid_or_accessible(&v13) )
    return 0;
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 0x80) + 8LL);
  if ( !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v14) )
    return 0;
  Parameter = 0;
  v12 = 0;
  sub_145C5B720(v14, v13, (__int64)&qword_149A6B078, (BB_ComparisonOperatorType *)&Parameter, 1);
  Parameter_1 = (_QWORD *)Parameter;
  if ( (_QWORD)Parameter == *((_QWORD *)&Parameter + 1) )
  {
LABEL_21:
    if ( Parameter_1 )
      sub_1403A3120((__int64)&Parameter, Parameter_1, (v12 - (_QWORD)Parameter_1) & 0xFFFFFFFFFFFFFFF8uLL);
    return 0;
  }
  if ( !sub_1459C3DC0()
    || !sub_145D28790(v13)
    || (n0x30 = (unsigned int)sub_145D1DFE0(v13) - 0x4F, (unsigned int)n0x30 > 0x30)
    || (v5 = 0x1000000008009LL, !_bittest64(&v5, n0x30)) )
  {
    if ( ((*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v13 & 0xFFFFFFFFFFFFLL) + 0x28LL))(v13 & 0xFFFFFFFFFFFFLL)
        & 0x10) != 0 )
    {
      Parameter_2 = (const void *)Parameter;
      v6 = *(_QWORD *)Parameter;
      goto LABEL_10;
    }
    v9 = (_QWORD *)*((_QWORD *)&Parameter + 1);
    Parameter_1 = (_QWORD *)Parameter;
    if ( (_QWORD)Parameter != *((_QWORD *)&Parameter + 1) )
    {
      while ( 1 )
      {
        v6 = *Parameter_1;
        v10 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*Parameter_1 + 0xD0LL))(*Parameter_1);
        if ( v10 )
        {
          v15 = *(_QWORD *)(v10 + 8);
          if ( is_entity_descriptor_valid_or_accessible(&v15)
            && ((*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v15 & 0xFFFFFFFFFFFFLL) + 0x28LL))(v15 & 0xFFFFFFFFFFFFLL)
              & 0x10) == 0 )
          {
            goto LABEL_9;
          }
        }
        if ( ++Parameter_1 == v9 )
        {
          Parameter_1 = (_QWORD *)Parameter;
          goto LABEL_21;
        }
      }
    }
    goto LABEL_21;
  }
  v6 = sub_145CDAEC0(a1, v13, (const __m128i **)&Parameter);
LABEL_9:
  Parameter_2 = (const void *)Parameter;
LABEL_10:
  if ( Parameter_2 )
    sub_1403A3120((__int64)&Parameter, Parameter_2, (v12 - (_QWORD)Parameter_2) & 0xFFFFFFFFFFFFFFF8uLL);
  return v6;
}

// --- End Function: sub_145CDFF30 (0x145CDFF30) ---

// --- Function: sub_145CE13C0 (0x145CE13C0) ---
_QWORD *__fastcall sub_145CE13C0(__int64 a1, _QWORD *a2, unsigned int n2)
{
  __int64 v5; // rax
  __int64 v6; // rax

  v5 = sub_1465EECD0(*(_QWORD *)(a1 + 0x80));
  v6 = sub_140814780(v5);
  sub_145F4E9C0(v6, a2, n2);
  return a2;
}

// --- End Function: sub_145CE13C0 (0x145CE13C0) ---

// --- Function: sub_145ED3E20 (0x145ED3E20) ---
double __fastcall sub_145ED3E20(__int64 a1, int *a2)
{
  sub_145ED3E50(a1, a2);
  return sub_145ED3FD0(a1, a2);
}

// --- End Function: sub_145ED3E20 (0x145ED3E20) ---

// --- Function: sub_145EE3FD0 (0x145EE3FD0) ---
_QWORD *__fastcall sub_145EE3FD0(_QWORD *a1, __int64 a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_145EE5D00(a1, a2);
  return a1;
}

// --- End Function: sub_145EE3FD0 (0x145EE3FD0) ---

// --- Function: sub_145EE4020 (0x145EE4020) ---
_QWORD *__fastcall sub_145EE4020(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_140393DA0(a1, (__int64)sub_145EE3C90);
  return a1;
}

// --- End Function: sub_145EE4020 (0x145EE4020) ---

// --- Function: sub_145EE69A0 (0x145EE69A0) ---
_QWORD *__fastcall sub_145EE69A0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // [rsp+30h] [rbp-18h] BYREF

  __crt_win32_buffer_no_resizing::deallocate(
    0,
    (const struct __crt_win32_buffer_empty_debug_info *)p_p_p_p_p_sub_140384A94);
  sub_144E8B590(&v3, *(_QWORD *)(a1 + 8));
  *a2 = v3;
  return a2;
}

// --- End Function: sub_145EE69A0 (0x145EE69A0) ---

// --- Function: sub_145EE6F70 (0x145EE6F70) ---
__int64 __fastcall sub_145EE6F70(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 n8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1427BA5F0)(__int64, __int64 *); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_142FB09B0();
  n8 = 8;
  v3 = sub_142F46820(&v5);
  v9 = sub_1402A2660((__int64)v3);
  v10 = byte_149E1A4A8;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427BA5F0 = sub_1427BA5F0;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_145EE6F70 (0x145EE6F70) ---

// --- Function: sub_145EEBD90 (0x145EEBD90) ---
__int64 __fastcall sub_145EEBD90(__int64 a1)
{
  sub_140370D10((_QWORD *)(a1 + 0x20));
  sub_145F43E00(a1 + 8);
  return 0;
}

// --- End Function: sub_145EEBD90 (0x145EEBD90) ---

// --- Function: sub_145EEE2C0 (0x145EEE2C0) ---
Parameter *__fastcall sub_145EEE2C0(Parameter *Parameter, Parameter *Parameter_1)
{
  if ( Parameter != Parameter_1 )
  {
    sub_145F43E00(Parameter);
    sub_14293F990(Parameter, Parameter_1);
  }
  return Parameter;
}

// --- End Function: sub_145EEE2C0 (0x145EEE2C0) ---

// --- Function: sub_145EEE3B0 (0x145EEE3B0) ---
__int64 __fastcall sub_145EEE3B0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  sub_145EEE2C0((Parameter *)(a1 + 8), (Parameter *)(a2 + 8));
  sub_140377F00((char **)(a1 + 0x20), (char **)(a2 + 0x20));
  qmemcpy((void *)(a1 + 0x28), (const void *)(a2 + 0x28), 0x10u);
  return a1;
}

// --- End Function: sub_145EEE3B0 (0x145EEE3B0) ---

// --- Function: sub_145EF7A80 (0x145EF7A80) ---
__int64 __fastcall sub_145EF7A80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  if ( *(_BYTE *)(sub_1402A2660(a3 + 0x200) + 0x58) && !*(_BYTE *)(a1 + 0xB0) )
    return sub_145F01F30(a1, a2, a3);
  result = *(unsigned __int8 *)(sub_1402A2660(a3 + 0x200) + 0x58);
  if ( !(_DWORD)result )
  {
    result = *(unsigned __int8 *)(a1 + 0xB0);
    if ( *(_BYTE *)(a1 + 0xB0) )
      return sub_145F057A0(a1, a2, a3);
  }
  return result;
}

// --- End Function: sub_145EF7A80 (0x145EF7A80) ---

// --- Function: sub_145EFDE60 (0x145EFDE60) ---
char __fastcall sub_145EFDE60(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // rax
  __int16 v4; // [rsp+52h] [rbp-406h]
  __int64 v5; // [rsp+58h] [rbp-400h] BYREF
  char v6; // [rsp+60h] [rbp-3F8h]
  char v7; // [rsp+61h] [rbp-3F7h]
  char v8; // [rsp+62h] [rbp-3F6h]
  char v9; // [rsp+63h] [rbp-3F5h]
  char v10; // [rsp+64h] [rbp-3F4h]
  unsigned __int64 v11; // [rsp+68h] [rbp-3F0h] BYREF
  BOOL v12; // [rsp+70h] [rbp-3E8h]
  __int64 v13; // [rsp+78h] [rbp-3E0h] BYREF
  __int64 v14; // [rsp+80h] [rbp-3D8h]
  __int64 v15; // [rsp+88h] [rbp-3D0h]
  __int64 v16; // [rsp+90h] [rbp-3C8h]
  __int64 v17; // [rsp+98h] [rbp-3C0h]
  __int64 v18; // [rsp+A0h] [rbp-3B8h]
  __int64 v19; // [rsp+A8h] [rbp-3B0h]
  __int64 v20; // [rsp+B0h] [rbp-3A8h]
  unsigned __int64 v21; // [rsp+B8h] [rbp-3A0h]
  unsigned __int64 v22; // [rsp+C0h] [rbp-398h]
  __int64 v23; // [rsp+C8h] [rbp-390h]
  void *v24; // [rsp+D0h] [rbp-388h] BYREF
  __int64 v25; // [rsp+D8h] [rbp-380h]
  __int64 v26; // [rsp+E0h] [rbp-378h]
  unsigned __int64 v27; // [rsp+E8h] [rbp-370h]
  __int64 v28; // [rsp+F0h] [rbp-368h]
  __int64 v29; // [rsp+F8h] [rbp-360h]
  __int64 v30; // [rsp+100h] [rbp-358h]
  unsigned __int64 v31; // [rsp+108h] [rbp-350h]
  __int64 *v32; // [rsp+110h] [rbp-348h]
  __int64 v33; // [rsp+118h] [rbp-340h]
  __int64 v34; // [rsp+120h] [rbp-338h]
  __int64 v35; // [rsp+128h] [rbp-330h]
  __int64 v36; // [rsp+130h] [rbp-328h]
  __int64 v37; // [rsp+138h] [rbp-320h]
  __int64 v38; // [rsp+140h] [rbp-318h]
  __int64 v39; // [rsp+148h] [rbp-310h]
  __int64 v40; // [rsp+150h] [rbp-308h]
  __int64 v41; // [rsp+158h] [rbp-300h]
  __int64 v42; // [rsp+160h] [rbp-2F8h]
  void (__fastcall *v43)(__int64, unsigned __int64 *, __int64); // [rsp+168h] [rbp-2F0h]
  __int64 v44; // [rsp+170h] [rbp-2E8h]
  __int64 *v45; // [rsp+178h] [rbp-2E0h]
  __int64 v46; // [rsp+180h] [rbp-2D8h]
  __int64 v47; // [rsp+188h] [rbp-2D0h]
  __int64 *v48; // [rsp+190h] [rbp-2C8h]
  __int64 v49; // [rsp+198h] [rbp-2C0h]
  __int64 v50; // [rsp+1A0h] [rbp-2B8h]
  __int64 v51; // [rsp+1A8h] [rbp-2B0h]
  __int64 v52; // [rsp+1B0h] [rbp-2A8h]
  __int64 v53; // [rsp+1B8h] [rbp-2A0h]
  __int64 v54; // [rsp+1C0h] [rbp-298h]
  _DWORD *v55; // [rsp+1C8h] [rbp-290h]
  __int64 (__fastcall *v56)(unsigned __int64, _BYTE *, __int64, _QWORD, _BYTE); // [rsp+1D0h] [rbp-288h]
  __int64 (__fastcall *v57)(__int64, _BYTE *); // [rsp+1D8h] [rbp-280h]
  __int64 v58; // [rsp+1E0h] [rbp-278h]
  __int64 v59; // [rsp+1E8h] [rbp-270h]
  void *v60; // [rsp+1F0h] [rbp-268h]
  _DWORD *v61; // [rsp+1F8h] [rbp-260h]
  __int64 v62; // [rsp+200h] [rbp-258h]
  __int64 v63; // [rsp+208h] [rbp-250h]
  __int64 *v64; // [rsp+210h] [rbp-248h]
  __int64 v65; // [rsp+218h] [rbp-240h]
  __int64 (__fastcall *v66)(__int64, _BYTE *); // [rsp+220h] [rbp-238h]
  unsigned __int64 *v67; // [rsp+228h] [rbp-230h]
  void (__fastcall *v68)(__int64, _QWORD, _QWORD); // [rsp+230h] [rbp-228h]
  __int64 v69; // [rsp+238h] [rbp-220h]
  __int64 actor_stat; // [rsp+240h] [rbp-218h]
  unsigned __int64 *v71; // [rsp+248h] [rbp-210h]
  __int64 v72; // [rsp+250h] [rbp-208h] BYREF
  __int64 (__fastcall *v73)(__int64, _BYTE *); // [rsp+258h] [rbp-200h]
  void (__fastcall *v74)(__int64, __int64); // [rsp+260h] [rbp-1F8h]
  __int64 v75; // [rsp+268h] [rbp-1F0h]
  __int64 v76; // [rsp+270h] [rbp-1E8h]
  __int64 v77; // [rsp+278h] [rbp-1E0h]
  __int64 v78; // [rsp+280h] [rbp-1D8h]
  __int64 v79; // [rsp+288h] [rbp-1D0h]
  __int64 v80; // [rsp+290h] [rbp-1C8h]
  __int64 v81; // [rsp+298h] [rbp-1C0h]
  __int64 v82; // [rsp+2A0h] [rbp-1B8h]
  __int64 v83; // [rsp+2A8h] [rbp-1B0h] BYREF
  _BYTE Parameter__1[24]; // [rsp+2B0h] [rbp-1A8h] BYREF
  __int64 v85; // [rsp+2C8h] [rbp-190h] BYREF
  __int64 v86; // [rsp+2D0h] [rbp-188h] BYREF
  _BYTE v87[8]; // [rsp+2D8h] [rbp-180h] BYREF
  _BYTE v88[8]; // [rsp+2E0h] [rbp-178h] BYREF
  __int64 v89; // [rsp+2E8h] [rbp-170h] BYREF
  _QWORD v90[3]; // [rsp+2F0h] [rbp-168h] BYREF
  _BYTE dst_[12]; // [rsp+308h] [rbp-150h] BYREF
  _DWORD v92[5]; // [rsp+314h] [rbp-144h] BYREF
  _BYTE v93[64]; // [rsp+328h] [rbp-130h] BYREF
  __int64 v94[16]; // [rsp+368h] [rbp-F0h] BYREF
  __int64 v95; // [rsp+3E8h] [rbp-70h] BYREF
  _BYTE Parameter_[24]; // [rsp+3F0h] [rbp-68h] BYREF
  __int64 v97; // [rsp+408h] [rbp-50h] BYREF
  _BYTE dst__1[16]; // [rsp+410h] [rbp-48h] BYREF
  _BYTE v99[16]; // [rsp+420h] [rbp-38h] BYREF

  v19 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
  v43 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v19 + 0x120LL);
  v43(v19, &v11, a1);
  if ( !is_entity_descriptor_valid_or_accessible(&v11) )
    return 0;
  v20 = sub_14030ECF0(&v11);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x50LL))(v20) )
    return 0;
  v44 = sub_14030ECF0(&v11);
  v45 = sub_14033AB40(v44, &v85);
  v46 = *v45;
  v13 = v46;
  if ( !AssetMeta::HasActorSubresource(&v13) )
    return 0;
  v47 = sub_14030ECF0(&v11);
  v48 = sub_1425D62E0(v47, &v86);
  v49 = *v48;
  v5 = v49;
  if ( !is_valid_handle_typeA(&v5) )
    return 0;
  v29 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*a2 + 0x730))(a2);
  if ( !v29 )
    return 0;
  v50 = v5 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1440A35D0(v5 & 0xFFFFFFFFFFFFLL);
  sub_1402AE3D0(&v83, "CSCActorCorpseUtils::Corpsify", v2, 1);
  sub_144E55DF0(a2, (__int64)"Running corpsify for corpse.");
  v51 = v5 & 0xFFFFFFFFFFFFLL;
  v52 = sub_1465CBFA0(v5 & 0xFFFFFFFFFFFFLL);
  sub_145A3A490(v52, 1, 1, 0);
  v53 = v5 & 0xFFFFFFFFFFFFLL;
  v65 = sub_1465CBFA0(v5 & 0xFFFFFFFFFFFFLL);
  unknown_libname_472(v90);
  CreateStringObjectFromString(&v24, "CSCActorCorpseUtils::Corpsify");
  v54 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*a2 + 0x770))(a2);
  v60 = sub_1461CAE70(v54, dst_);
  v55 = (_DWORD *)(*(__int64 (__fastcall **)(unsigned __int64 *))(*a2 + 0x770))(a2);
  v61 = sub_143E58000(v55, v92);
  v21 = sub_1403E6750(a2 + 1);
  v56 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int64, _QWORD, _BYTE))(*(_QWORD *)v21 + 0x1E8LL);
  v62 = v56(v21, v93, 2, 0, 0);
  v22 = sub_1403E6750(a2 + 1);
  v23 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v22 + 0x648LL))(v22);
  v57 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v23 + 0x40LL);
  v58 = *(_QWORD *)v57(v23, v87);
  v59 = v58;
  v63 = v58;
  v64 = sub_1412A8110(v94, v58, v62, v61, (__int64)v60, 0, (int)&v24, (int)v90, 0);
  sub_145A3A5E0(v65, (__int64)v64, 1);
  sub_140370D10(&v24);
  sub_1402A2AD0(v90);
  v25 = sub_14030ECF0(&v11);
  v66 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v25 + 0x150LL);
  v67 = (unsigned __int64 *)v66(v25, v88);
  if ( j_is_entity_descriptor_valid_or_accessible(v67) )
  {
    v6 = 0;
    v26 = sub_14030ECF0(&v11);
    v68 = *(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v26 + 0x138LL);
    v68(v26, 0, 0);
  }
  else
  {
    v7 = 0;
  }
  v69 = v5 & 0xFFFFFFFFFFFFLL;
  actor_stat = get_actor_stat(v5 & 0xFFFFFFFFFFFFLL);
  sub_14384CC10(actor_stat, a2);
  v95 = 0;
  sub_1426FC500((Parameter *)Parameter_);
  sub_14035B3E0(&v97);
  v71 = a2 + 1;
  sub_1403B0A70(a2 + 1, &v72);
  v95 = v72;
  v27 = sub_1403E6750(a2 + 1);
  v28 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v27 + 0x20LL))(v27);
  v73 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v28 + 0x10LL);
  qmemcpy(dst__1, (const void *)v73(v28, v99), sizeof(dst__1));
  sub_1426FC500((Parameter *)Parameter__1);
  if ( n2_127 > 0 && dword_149A44634 == 1 )
    sub_145F07390(a2, Parameter__1);
  if ( AssetMeta::HasActorSubresource(&v13) )
    v30 = v13 & 0xFFFFFFFFFFFFLL;
  else
    v30 = 0;
  sub_145F15E60(v30, v29, &v95, Parameter__1);
  if ( n2_127 > 0 )
  {
    v31 = sub_1403E6750(a2 + 1);
    if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v31 + 0x720LL))(v31) )
    {
      v8 = 0;
      v15 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*a2 + 0x8A0))(a2);
      if ( v15 )
      {
        v32 = sub_14161AEB0((__int64)a2, &v89);
        v14 = is_valid_handle_typeA(v32) ? *v32 & 0xFFFFFFFFFFFFLL : 0LL;
        if ( v14 && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x5D0LL))(v14) )
        {
          v9 = 0;
          v33 = v15 + 0x23E0;
          sub_14519DE80(v15 + 0x23E0);
          sub_145EEE3B0(v33 + 8, &v95);
          v34 = v15 + 0x23F0;
          v12 = *(_QWORD *)(v15 + 0x23F0) == *(_QWORD *)(v15 + 0x23F8);
          v4 = !v12;
          v35 = v15 + 0x2430;
          sub_142749980(v15 + 0x2430);
          *(_WORD *)(v35 + 8) = v4;
        }
      }
    }
  }
  v36 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*a2 + 0x6B8))(a2);
  v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x5A8LL))(v36);
  v41 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x30LL))(v37);
  if ( v41 )
  {
    v38 = v5 & 0xFFFFFFFFFFFFLL;
    v39 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x6B8LL))(v5 & 0xFFFFFFFFFFFFLL);
    v40 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x5A8LL))(v39);
    v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v40 + 0x30LL))(v40);
    if ( v16 )
    {
      v74 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v16 + 0x278LL);
      v74(v16, v41);
    }
  }
  v75 = v5 & 0xFFFFFFFFFFFFLL;
  v76 = sub_1465CBFA0(v5 & 0xFFFFFFFFFFFFLL);
  sub_145A3A490(v76, 3, 1, 0);
  v77 = sub_1465CBFA0((__int64)a2);
  sub_145A3A490(v77, 0, 1, 0);
  v17 = sub_1465EEE60((__int64)a2);
  v78 = v5 & 0xFFFFFFFFFFFFLL;
  v18 = sub_1465EEE60(v5 & 0xFFFFFFFFFFFFLL);
  v10 = 0;
  v80 = sub_145F0F980(v17 + 0x68);
  v79 = sub_14583F430(v17);
  sub_145F11810(v80, v17, v79);
  v82 = sub_145F0F980(v18 + 0x68);
  v81 = sub_14583F430(v18);
  sub_145F11870(v82, v18, v81);
  if ( AssetMeta::HasActorSubresource(&v13) )
    v42 = v13 & 0xFFFFFFFFFFFFLL;
  else
    v42 = 0;
  sub_145F26DA0(v42);
  sub_14277C8E0((Parameter *)Parameter__1);
  sub_140370D10(&v97);
  sub_145F43E00(Parameter_);
  sub_1402B1820(&v83);
  return 1;
}

// --- End Function: sub_145EFDE60 (0x145EFDE60) ---

// --- Function: sub_145F01F30 (0x145F01F30) ---
void __fastcall sub_145F01F30(__int64 a1, __crt_win32_buffer_debug_info *a2, __int64 a3)
{
  __int64 *v3; // rax
  __int64 v4; // rax
  AK::WriteBytesMem *v5; // rax
  unsigned __int8 *v6; // rax
  char v7; // [rsp+30h] [rbp-448h]
  char v8; // [rsp+33h] [rbp-445h] BYREF
  float v9; // [rsp+34h] [rbp-444h]
  int n6; // [rsp+38h] [rbp-440h]
  int v11; // [rsp+3Ch] [rbp-43Ch]
  __int64 v12; // [rsp+40h] [rbp-438h] BYREF
  __int64 v13; // [rsp+48h] [rbp-430h] BYREF
  unsigned __int64 *v14; // [rsp+50h] [rbp-428h]
  __int64 v15; // [rsp+58h] [rbp-420h]
  __int64 v16; // [rsp+60h] [rbp-418h]
  __int64 v17; // [rsp+68h] [rbp-410h] BYREF
  __int64 v18; // [rsp+70h] [rbp-408h]
  __int64 v19; // [rsp+78h] [rbp-400h]
  __int64 v20; // [rsp+80h] [rbp-3F8h] BYREF
  __int64 v21; // [rsp+88h] [rbp-3F0h]
  __int64 v22; // [rsp+90h] [rbp-3E8h] BYREF
  __int64 v23; // [rsp+98h] [rbp-3E0h]
  __int64 v24[3]; // [rsp+A0h] [rbp-3D8h] BYREF
  __int64 v25; // [rsp+B8h] [rbp-3C0h]
  const char *p_null; // [rsp+C0h] [rbp-3B8h]
  __int64 (__fastcall *v27)(__int64, _QWORD); // [rsp+C8h] [rbp-3B0h]
  _QWORD *v28; // [rsp+E0h] [rbp-398h]
  __int64 v29; // [rsp+E8h] [rbp-390h]
  __int64 v30; // [rsp+F0h] [rbp-388h]
  void (__fastcall *v31)(__int64, __int64 *, __int64); // [rsp+F8h] [rbp-380h]
  __int64 *v32; // [rsp+100h] [rbp-378h]
  __int64 v33; // [rsp+108h] [rbp-370h]
  __int64 v34; // [rsp+110h] [rbp-368h]
  __int64 v35; // [rsp+118h] [rbp-360h]
  unsigned __int64 v36; // [rsp+120h] [rbp-358h] BYREF
  void (__fastcall *v37)(__int64, __int64 *); // [rsp+128h] [rbp-350h]
  unsigned int (__fastcall *v38)(__int64, _DWORD *); // [rsp+130h] [rbp-348h]
  __int64 v39; // [rsp+138h] [rbp-340h]
  __int64 v40; // [rsp+140h] [rbp-338h]
  __int64 v41; // [rsp+148h] [rbp-330h]
  __int64 v42; // [rsp+150h] [rbp-328h]
  __int64 *v43; // [rsp+158h] [rbp-320h]
  __int64 v44; // [rsp+160h] [rbp-318h]
  __int64 v45; // [rsp+168h] [rbp-310h]
  __int64 v46; // [rsp+170h] [rbp-308h]
  __int64 v47; // [rsp+178h] [rbp-300h]
  __int64 v48; // [rsp+180h] [rbp-2F8h]
  __int64 v49; // [rsp+188h] [rbp-2F0h]
  __int64 v50; // [rsp+198h] [rbp-2E0h] BYREF
  _QWORD v51[3]; // [rsp+1A0h] [rbp-2D8h] BYREF
  __int64 v52; // [rsp+1B8h] [rbp-2C0h] BYREF
  _BYTE v53[16]; // [rsp+1C0h] [rbp-2B8h] BYREF
  _DWORD v54[28]; // [rsp+1D0h] [rbp-2A8h] BYREF
  _BYTE v55[544]; // [rsp+240h] [rbp-238h] BYREF

  v14 = (unsigned __int64 *)__crt_win32_buffer_debug_info::file_name(a2);
  *(_BYTE *)(a1 + 0xB0) = 1;
  *(_BYTE *)(a1 + 0xB2) = 0;
  *(_BYTE *)(a1 + 0xB1) = 0;
  v18 = *(_QWORD *)(identity((__int64)&pSystem) + 0x60);
  v27 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v18 + 0x38LL);
  *(_QWORD *)(a1 + 0xB8) = *(_QWORD *)v27(v18, 0);
  v28 = sub_1403BA0E0((__int64)a2, &v50);
  v29 = *v28 & 0xFFFFFFFFFFFFLL;
  sub_145A3A490(v29, 3, 0, 0);
  v19 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
  v31 = *(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v19 + 0x120LL);
  v30 = *(_QWORD *)sub_1402A2660(a3 + 0x200);
  v31(v19, &v13, v30);
  v32 = sub_1457B71D0((__int64)v14, v51);
  v33 = *v32;
  v20 = v33;
  if ( Handle::IsValid(&v20) )
  {
    v35 = v20 & 0xFFFFFFFFFFFFLL;
    v34 = v13;
    sub_1433852F0(v20 & 0xFFFFFFFFFFFFLL, v13);
  }
  v9 = 0.0;
  v36 = v14[1];
  v21 = sub_14030ECF0(&v36);
  v37 = *(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v21 + 0x3B8LL);
  v37(v21, &v22);
  if ( HIWORD_w(&v22) )
  {
    sub_1403708B0(v54);
    v23 = sub_14030ECF0(&v22);
    v38 = *(unsigned int (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)v23 + 0x20LL);
    if ( v38(v23, v54) )
      v9 = *(float *)&v54[0xF];
  }
  sub_145EE69A0((__int64)v14, &v12);
  if ( Handle::IsValid(&v12) )
  {
    v40 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
    v3 = (__int64 *)sub_1402A2660(a3 + 0x200);
    v39 = sub_144E9BE40((__int64)v53, v9, *v3);
    v15 = v51[1];
    if ( Handle::IsValid(&v12) )
      v15 = v12 & 0xFFFFFFFFFFFFLL;
    else
      v15 = 0;
    sub_144E8D7A0(v40, v15, v39);
    v41 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
    v16 = v51[2];
    if ( Handle::IsValid(&v12) )
      v16 = v12 & 0xFFFFFFFFFFFFLL;
    else
      v16 = 0;
    sub_144E8D900(v41, v16, (__int64)&v8);
  }
  sub_141EEDD20((__int64)v14, v24);
  if ( is_valid_handle_typeA(v24) )
  {
    v24[1] = v24[0] & 0xFFFFFFFFFFFFLL;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)(v24[0] & 0xFFFFFFFFFFFFLL) + 0x5C8LL))(v24[0] & 0xFFFFFFFFFFFFLL);
  }
  sub_1423357D0((__int64)a2, &v17);
  if ( Handle::IsValid(&v17) )
  {
    v7 = 0;
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v13) )
    {
      v42 = sub_14030ECF0(&v13);
      v43 = sub_1425D62E0(v42, &v52);
      v44 = *v43;
      v45 = v44;
      v46 = v44;
      v24[2] = v44 & 0xFFFFFFFFFFFFLL;
      v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v44 & 0xFFFFFFFFFFFFLL) + 0x660LL))(v44 & 0xFFFFFFFFFFFFLL);
    }
    v47 = v17 & 0xFFFFFFFFFFFFLL;
    if ( v7 )
      n6 = 6;
    else
      n6 = 1;
    sub_1457E2710(v47, n6, 1u, 1u);
    v48 = v17 & 0xFFFFFFFFFFFFLL;
    sub_1432639A0(v17 & 0xFFFFFFFFFFFFLL, 1, 1, 1);
  }
  if ( sub_14602B0E0(a3) )
    v11 = *(unsigned __int16 *)sub_143F2D0F0(a3 + 0x40);
  else
    v11 = 0;
  v4 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a3 + 0x40);
  sub_1458B8230(a1, a2, 0, v4, v11);
  v49 = sub_1402A2950((__int64)v55);
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v13) )
  {
    v25 = sub_14030ECF0(&v13);
    p_null = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x70LL))(v25);
  }
  else
  {
    p_null = "null";
  }
  v5 = (AK::WriteBytesMem *)sub_1402A3190(
                              v49,
                              "[%s] Enter drag by '%s'.",
                              "CSCActorResultHelperStateBodyDragged::Enter",
                              p_null);
  v6 = AK::WriteBytesMem::Bytes(v5);
  sub_144E55970(v14, (__int64)v6);
  sub_1402A2B40((__int64)v55);
}

// --- End Function: sub_145F01F30 (0x145F01F30) ---

// --- Function: sub_145F057A0 (0x145F057A0) ---
void __fastcall sub_145F057A0(__int64 a1, __crt_win32_buffer_debug_info *a2, __int64 a3)
{
  __int64 v3; // r8
  __int64 v4; // r8
  __int64 *v5; // rax
  const struct __crt_stdio_stream **v6; // rax
  AK::WriteBytesMem *v7; // rax
  unsigned __int8 *v8; // rax
  _BYTE v9[6]; // [rsp+32h] [rbp-386h] BYREF
  unsigned __int64 *v10; // [rsp+38h] [rbp-380h]
  __int64 v11; // [rsp+40h] [rbp-378h] BYREF
  unsigned __int64 v12; // [rsp+48h] [rbp-370h] BYREF
  __int64 v13; // [rsp+50h] [rbp-368h]
  __int64 v14; // [rsp+58h] [rbp-360h]
  __int64 v15; // [rsp+60h] [rbp-358h] BYREF
  __int64 v16; // [rsp+68h] [rbp-350h] BYREF
  __int64 v17; // [rsp+70h] [rbp-348h]
  __int64 v18; // [rsp+78h] [rbp-340h]
  __int64 v19; // [rsp+80h] [rbp-338h]
  __int64 v20; // [rsp+88h] [rbp-330h] BYREF
  __int64 v21[2]; // [rsp+90h] [rbp-328h] BYREF
  __int64 v22; // [rsp+A0h] [rbp-318h]
  const char *p_null; // [rsp+A8h] [rbp-310h]
  __int64 v24; // [rsp+B0h] [rbp-308h]
  __int64 v25; // [rsp+B8h] [rbp-300h]
  void (__fastcall *v26)(__int64, unsigned __int64 *, __int64); // [rsp+C0h] [rbp-2F8h]
  _QWORD v27[2]; // [rsp+C8h] [rbp-2F0h] BYREF
  void (__fastcall *v28)(__int64, unsigned __int64, __int64); // [rsp+D8h] [rbp-2E0h]
  unsigned __int64 v29; // [rsp+E0h] [rbp-2D8h]
  unsigned __int64 v30; // [rsp+E8h] [rbp-2D0h]
  void (__fastcall *v31)(__int64, unsigned __int64, __int64); // [rsp+F0h] [rbp-2C8h]
  __int64 *v32; // [rsp+F8h] [rbp-2C0h]
  __int64 v33; // [rsp+100h] [rbp-2B8h]
  void *v34; // [rsp+108h] [rbp-2B0h]
  __int64 v35; // [rsp+110h] [rbp-2A8h]
  __int64 v36; // [rsp+118h] [rbp-2A0h]
  __int64 v37; // [rsp+120h] [rbp-298h]
  _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *v38; // [rsp+128h] [rbp-290h]
  __int64 v39; // [rsp+130h] [rbp-288h]
  __int64 v40; // [rsp+138h] [rbp-280h]
  __int64 v41; // [rsp+140h] [rbp-278h]
  __int64 v42; // [rsp+148h] [rbp-270h]
  __int64 v43; // [rsp+150h] [rbp-268h] BYREF
  _QWORD v44[2]; // [rsp+158h] [rbp-260h] BYREF
  _BYTE v45[8]; // [rsp+168h] [rbp-250h] BYREF
  __int64 v46; // [rsp+170h] [rbp-248h]
  _BYTE v47[544]; // [rsp+180h] [rbp-238h] BYREF

  v10 = (unsigned __int64 *)__crt_win32_buffer_debug_info::file_name(a2);
  *(_BYTE *)(a1 + 0xB0) = 0;
  sub_1458B8910(a1, a2);
  sub_1403BA0E0((__int64)a2, &v16);
  if ( Handle::IsValid(&v16) )
  {
    v24 = v16 & 0xFFFFFFFFFFFFLL;
    sub_145A3A490(v16 & 0xFFFFFFFFFFFFLL, 3, 0, 0);
  }
  v17 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
  v26 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v17 + 0x120LL);
  v25 = *(_QWORD *)sub_1402A2660(a3 + 0x200);
  v26(v17, &v12, v25);
  if ( is_entity_descriptor_valid_or_accessible(&v12) )
  {
    v27[0] = v10[1];
    v18 = sub_14030ECF0(v27);
    v28 = *(void (__fastcall **)(__int64, unsigned __int64, __int64))(*(_QWORD *)v18 + 0x3E8LL);
    v27[1] = v12;
    LOBYTE(v3) = 1;
    v28(v18, v12, v3);
    v19 = sub_14030ECF0(&v12);
    v31 = *(void (__fastcall **)(__int64, unsigned __int64, __int64))(*(_QWORD *)v19 + 0x3E8LL);
    v29 = v10[1];
    v30 = v29;
    LOBYTE(v4) = 1;
    v31(v19, v29, v4);
  }
  v32 = sub_1457B71D0((__int64)v10, &v43);
  v33 = *v32;
  v20 = v33;
  if ( Handle::IsValid(&v20) )
  {
    v36 = v20 & 0xFFFFFFFFFFFFLL;
    v34 = v44;
    set_ptr_null(v44);
    v35 = *v5;
    sub_1433852F0(v36, v35);
  }
  sub_145EE69A0((__int64)v10, &v11);
  if ( Handle::IsValid(&v11) )
  {
    v37 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
    v13 = v44[1];
    if ( Handle::IsValid(&v11) )
      v13 = v11 & 0xFFFFFFFFFFFFLL;
    else
      v13 = 0;
    sub_144E8D850(v37, v13, (__int64)v9);
    v39 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
    v6 = (const struct __crt_stdio_stream **)sub_1402A2660(a3 + 0x200);
    v38 = _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
            (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v45,
            *v6);
    v14 = v46;
    if ( Handle::IsValid(&v11) )
      v14 = v11 & 0xFFFFFFFFFFFFLL;
    else
      v14 = 0;
    sub_145EE6F70(v39, v14, (__int64)v38);
  }
  sub_141EEDD20((__int64)v10, v21);
  if ( is_valid_handle_typeA(v21) )
  {
    v21[1] = v21[0] & 0xFFFFFFFFFFFFLL;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)(v21[0] & 0xFFFFFFFFFFFFLL) + 0x5D0LL))(v21[0] & 0xFFFFFFFFFFFFLL);
  }
  sub_1423357D0((__int64)a2, &v15);
  if ( Handle::IsValid(&v15) )
  {
    v40 = v15 & 0xFFFFFFFFFFFFLL;
    sub_1457E2710(v15 & 0xFFFFFFFFFFFFLL, 0, 1u, 0);
    v41 = v15 & 0xFFFFFFFFFFFFLL;
    sub_1432639A0(v15 & 0xFFFFFFFFFFFFLL, 1, 0, 0);
  }
  v42 = sub_1402A2950((__int64)v47);
  if ( is_entity_descriptor_valid_or_accessible(&v12) )
  {
    v22 = sub_14030ECF0(&v12);
    p_null = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 0x70LL))(v22);
  }
  else
  {
    p_null = "null";
  }
  v7 = (AK::WriteBytesMem *)sub_1402A3190(
                              v42,
                              "[%s] Exit drag from '%s'.",
                              "CSCActorResultHelperStateBodyDragged::Exit",
                              p_null);
  v8 = AK::WriteBytesMem::Bytes(v7);
  sub_144E55970(v10, (__int64)v8);
  sub_1402A2B40((__int64)v47);
}

// --- End Function: sub_145F057A0 (0x145F057A0) ---

// --- Function: sub_145F07390 (0x145F07390) ---
void __fastcall sub_145F07390(__int64 a1, Parameter *Parameter)
{
  unsigned __int64 v2; // [rsp+20h] [rbp-C8h] BYREF
  __int64 v3; // [rsp+28h] [rbp-C0h]
  unsigned __int64 v4; // [rsp+30h] [rbp-B8h] BYREF
  __int64 v5; // [rsp+38h] [rbp-B0h]
  __int64 v6; // [rsp+40h] [rbp-A8h]
  __int64 v7; // [rsp+48h] [rbp-A0h]
  __int64 **v8; // [rsp+50h] [rbp-98h]
  __int64 v9; // [rsp+58h] [rbp-90h]
  __int64 v10; // [rsp+60h] [rbp-88h]
  unsigned __int64 v11; // [rsp+68h] [rbp-80h]
  unsigned __int64 v12; // [rsp+70h] [rbp-78h]
  unsigned __int64 v13; // [rsp+78h] [rbp-70h]
  unsigned __int64 v14; // [rsp+80h] [rbp-68h]
  __int64 v15; // [rsp+88h] [rbp-60h]
  unsigned __int64 v16; // [rsp+90h] [rbp-58h]
  unsigned __int64 v17; // [rsp+98h] [rbp-50h]
  unsigned __int64 v18; // [rsp+A0h] [rbp-48h]
  unsigned __int64 v19; // [rsp+A8h] [rbp-40h]
  __int64 v20; // [rsp+B0h] [rbp-38h]
  _QWORD src_[2]; // [rsp+B8h] [rbp-30h] BYREF
  _QWORD src__1[4]; // [rsp+C8h] [rbp-20h] BYREF

  if ( n2_127 > 0 )
  {
    v3 = sub_1465EEEC0(a1);
    if ( v3 )
    {
      v7 = sub_1464E7A20(qword_149E7E438);
      v8 = (__int64 **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x110LL))(v7);
      v9 = sub_1404B0ED0(v3);
      sub_145CE13C0(v9, &v2, 1u);
      v10 = sub_1404B0ED0(v3);
      sub_145CE13C0(v10, &v4, 0);
      if ( is_entity_descriptor_valid_or_accessible(&v2) )
      {
        v12 = v2;
        v11 = *(_QWORD *)(a1 + 8);
        v13 = v11;
        if ( sub_145CCC9A0(v11, v2, v8, 0) )
        {
          v15 = sub_1404B0ED0(v3);
          v14 = v2;
          v5 = sub_145CDFF30(v15, v2);
          if ( v5 )
          {
            if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x60LL))(v5) )
            {
              src_[0] = v5;
              src_[1] = v2;
              sub_1426F0C90(Parameter, src_);
            }
          }
        }
      }
      if ( is_entity_descriptor_valid_or_accessible(&v4) && unknown_libname_23(&v2, &v4) )
      {
        v17 = v4;
        v16 = *(_QWORD *)(a1 + 8);
        v18 = v16;
        if ( sub_145CCC9A0(v16, v4, v8, 0) )
        {
          v20 = sub_1404B0ED0(v3);
          v19 = v4;
          v6 = sub_145CDFF30(v20, v4);
          if ( v6 )
          {
            if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x60LL))(v6) )
            {
              src__1[0] = v6;
              src__1[1] = v4;
              sub_1426F0C90(Parameter, src__1);
            }
          }
        }
      }
    }
  }
}

// --- End Function: sub_145F07390 (0x145F07390) ---

// --- Function: sub_145F0F980 (0x145F0F980) ---
__int64 __fastcall sub_145F0F980(__int64 a1)
{
  return a1 + 0x718;
}

// --- End Function: sub_145F0F980 (0x145F0F980) ---

// --- Function: sub_145F11810 (0x145F11810) ---
void __fastcall sub_145F11810(__int64 a1, __crt_win32_buffer_debug_info *a2)
{
  if ( !*(_BYTE *)(a1 + 0xF1) )
  {
    *(_BYTE *)(a1 + 0xF1) = 1;
    sub_144707640((_QWORD *)(a1 + 0xC8), a2);
  }
}

// --- End Function: sub_145F11810 (0x145F11810) ---

// --- Function: sub_145F11870 (0x145F11870) ---
void __fastcall sub_145F11870(__int64 a1, __crt_win32_buffer_debug_info *a2)
{
  if ( *(_BYTE *)(a1 + 0xF1) )
  {
    *(_BYTE *)(a1 + 0xF1) = 0;
    sub_144707EF0((__int64 *)(a1 + 0xC8), a2);
  }
}

// --- End Function: sub_145F11870 (0x145F11870) ---

// --- Function: sub_145F15E60 (0x145F15E60) ---
__int64 __fastcall sub_145F15E60(__int64 a1, __int64 a2, __int64 a3, Parameter *Parameter)
{
  unsigned __int8 v5; // [rsp+20h] [rbp-A8h] BYREF
  void (__fastcall *v6)(__int64, _QWORD, _QWORD *); // [rsp+28h] [rbp-A0h]
  _QWORD src_[4]; // [rsp+30h] [rbp-98h] BYREF
  _QWORD v8[4]; // [rsp+50h] [rbp-78h] BYREF
  _BYTE dst_[32]; // [rsp+70h] [rbp-58h] BYREF
  _BYTE dst__1[56]; // [rsp+90h] [rbp-38h] BYREF

  v5 = 0;
  v6 = *(void (__fastcall **)(__int64, _QWORD, _QWORD *))(*(_QWORD *)a2 + 0x630LL);
  src_[0] = a1;
  src_[1] = a3;
  src_[2] = Parameter;
  src_[3] = &v5;
  qmemcpy(dst_, src_, sizeof(dst_));
  qmemcpy(dst__1, dst_, 0x20u);
  sub_145EE3FD0(v8, (__int64)dst__1);
  v6(a2, 0, v8);
  sub_1402A2AD0(v8);
  return v5;
}

// --- End Function: sub_145F15E60 (0x145F15E60) ---

// --- Function: sub_145F1C5D0 (0x145F1C5D0) ---
void __fastcall sub_145F1C5D0(__int64 a1, __crt_win32_buffer_debug_info *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int16 v5; // [rsp+30h] [rbp-18h]

  if ( sub_14602B0E0(a4) )
    v5 = *(_WORD *)sub_143F2D0F0(a4 + 0x40);
  else
    v5 = 0;
  v4 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a4 + 0x40);
  sub_1459085B0(a1, a2, a3, 0, v4, v5);
}

// --- End Function: sub_145F1C5D0 (0x145F1C5D0) ---

// --- Function: sub_145F1C660 (0x145F1C660) ---
__int64 __fastcall sub_145F1C660(__int64 a1, __crt_win32_buffer_debug_info *a2, __int64 a3, __int64 a4)
{
  const char *v4; // rax
  __int64 v5; // rax
  __int64 result; // rax
  AK::WriteBytesMem *v7; // rax
  int v8; // [rsp+30h] [rbp-2A8h]
  int v9; // [rsp+34h] [rbp-2A4h]
  int v10; // [rsp+38h] [rbp-2A0h]
  __int64 v11; // [rsp+40h] [rbp-298h]
  __int64 v12; // [rsp+48h] [rbp-290h]
  __int64 v13; // [rsp+50h] [rbp-288h]
  unsigned __int64 *v14; // [rsp+68h] [rbp-270h]
  __int64 v15; // [rsp+70h] [rbp-268h]
  __int64 v16; // [rsp+78h] [rbp-260h]
  unsigned __int8 *v17; // [rsp+80h] [rbp-258h]
  unsigned __int64 *v18; // [rsp+88h] [rbp-250h]
  __int64 v19[2]; // [rsp+90h] [rbp-248h] BYREF
  _BYTE v20[544]; // [rsp+A0h] [rbp-238h] BYREF

  sub_145EF7A80(a1 + 8, a2, a4);
  if ( *(_BYTE *)(a1 + 0xB8) )
    sub_145F1C5D0(a1 + 8, a2, a3, a4);
  if ( sub_14046B610(a1 + 0xF8) )
  {
    v4 = __crt_win32_buffer_debug_info::file_name(a2);
    if ( (unsigned __int8)sub_145C25930(v4) )
    {
      v5 = sub_1404530C0((__int64)v19);
      sub_140469400(a1 + 0xF8, v5);
      sub_140463990(v19);
    }
  }
  result = *(unsigned __int8 *)(a1 + 0xF0);
  if ( !*(_BYTE *)(a1 + 0xF0) )
  {
    result = *(unsigned __int8 *)(sub_1402A2660(a4 + 0x60) + 0x112);
    if ( (_DWORD)result )
    {
      result = *(unsigned __int8 *)(sub_1402A2660(a4 + 0x60) + 0x121);
      if ( (_DWORD)result )
      {
        v14 = (unsigned __int64 *)__crt_win32_buffer_debug_info::file_name(a2);
        v15 = *(_QWORD *)(sub_1402A2660(a4 + 0x60) + 0x118);
        if ( !sub_145EFDE60(v15, v14) )
        {
          v16 = sub_1402A2950((__int64)v20);
          v11 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
          v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x2B0LL))(v11);
          v12 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
          v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x250LL))(v12);
          v13 = *(_QWORD *)(identity((__int64)&pSystem) + 0xA0);
          v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x258LL))(v13);
          v7 = (AK::WriteBytesMem *)sub_1402A3190(
                                      v16,
                                      "Corpsify failed as corpse has not yet streamed in, parallel spawn count: %d, queue"
                                      "d batch count: %d, pending finalise count: %u.",
                                      v10,
                                      v9,
                                      v8);
          v17 = AK::WriteBytesMem::Bytes(v7);
          v18 = (unsigned __int64 *)__crt_win32_buffer_debug_info::file_name(a2);
          sub_144E55DF0(v18, (__int64)v17);
          sub_1402A2B40((__int64)v20);
        }
        result = a1;
        *(_BYTE *)(a1 + 0xF0) = 1;
      }
    }
  }
  return result;
}

// --- End Function: sub_145F1C660 (0x145F1C660) ---

// --- Function: sub_145F26DA0 (0x145F26DA0) ---
__int64 __fastcall sub_145F26DA0(__int64 a1)
{
  void (__fastcall *v2)(__int64, _QWORD, _QWORD *); // [rsp+28h] [rbp-30h]
  _QWORD v3[5]; // [rsp+30h] [rbp-28h] BYREF

  v2 = *(void (__fastcall **)(__int64, _QWORD, _QWORD *))(*(_QWORD *)a1 + 0x630LL);
  sub_145EE4020(v3);
  v2(a1, 0, v3);
  return sub_1402A2AD0(v3);
}

// --- End Function: sub_145F26DA0 (0x145F26DA0) ---

// --- Function: sub_145F43E00 (0x145F43E00) ---
Parameter *__fastcall sub_145F43E00(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  __int64 i; // [rsp+30h] [rbp-48h]
  __int64 *v4; // [rsp+38h] [rbp-40h]
  Parameter *Parameter_2; // [rsp+40h] [rbp-38h]
  __int64 v6; // [rsp+48h] [rbp-30h]

  v4 = Parameter + 1;
  Parameter_2 = Parameter + 2;
  _StarEngineModule__((ULONG_PTR)Parameter);
  Parameter_1 = Parameter;
  if ( *Parameter )
  {
    v6 = *v4;
    for ( i = *Parameter; i != v6; i += 0x38 )
      sub_145EEBD90(i);
    std::_Deallocate<16,0>((_QWORD *)*Parameter, 0x38 * ((*Parameter_2 - *Parameter) / 0x38));
    *Parameter = 0;
    *v4 = 0;
    Parameter_1 = Parameter_2;
    *Parameter_2 = 0;
  }
  return Parameter_1;
}

// --- End Function: sub_145F43E00 (0x145F43E00) ---

// --- Function: sub_14601FAD0 (0x14601FAD0) ---
__int64 __fastcall sub_14601FAD0(__int64 a1)
{
  return sub_145F95D90(*(_QWORD *)a1, *(unsigned int *)(a1 + 8));
}

// --- End Function: sub_14601FAD0 (0x14601FAD0) ---

// --- Function: sub_14602B0E0 (0x14602B0E0) ---
_BOOL8 __fastcall sub_14602B0E0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x268) != 0;
}

// --- End Function: sub_14602B0E0 (0x14602B0E0) ---

// --- Function: sub_1461CAE70 (0x1461CAE70) ---
void *__fastcall sub_1461CAE70(__int64 a1, void *dst)
{
  qmemcpy(dst, (const void *)(a1 + 0x3B4), 0xCu);
  return dst;
}

// --- End Function: sub_1461CAE70 (0x1461CAE70) ---

// --- Function: sub_1464E7A20 (0x1464E7A20) ---
__int64 __fastcall sub_1464E7A20(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xDC0);
}

// --- End Function: sub_1464E7A20 (0x1464E7A20) ---

// --- Function: sub_1465CBFA0 (0x1465CBFA0) ---
__int64 __fastcall sub_1465CBFA0(__int64 a1)
{
  _QWORD *v2; // [rsp+20h] [rbp-18h]

  v2 = (_QWORD *)(a1 + 0x608);
  if ( Handle::IsValid((_QWORD *)(a1 + 0x608)) )
    return *v2 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1465CBFA0 (0x1465CBFA0) ---

// --- Function: sub_1465D1DE0 (0x1465D1DE0) ---
char __fastcall sub_1465D1DE0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v3[4]; // [rsp+28h] [rbp-20h] BYREF

  v3[0] = *(_QWORD *)(a1 + 0x6C8);
  if ( !is_valid_handle_typeA(v3) )
    return 0;
  v3[1] = v3[0] & 0xFFFFFFFFFFFFLL;
  v1 = sub_14644BB60(v3[0] & 0xFFFFFFFFFFFFLL);
  return sub_1413017D0(v1);
}

// --- End Function: sub_1465D1DE0 (0x1465D1DE0) ---

// --- Function: sub_1465EECD0 (0x1465EECD0) ---
__int64 __fastcall sub_1465EECD0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x2900LL;
}

// --- End Function: sub_1465EECD0 (0x1465EECD0) ---

// --- Function: sub_1465EEE60 (0x1465EEE60) ---
__int64 __fastcall sub_1465EEE60(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x2B98LL;
}

// --- End Function: sub_1465EEE60 (0x1465EEE60) ---

// --- Function: get_actor_stat (0x1465EEEA0) ---
__int64 __fastcall sub_1465EEEA0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x6F70LL;
}

// --- End Function: get_actor_stat (0x1465EEEA0) ---

// --- Function: sub_1465EEEC0 (0x1465EEEC0) ---
__int64 __fastcall sub_1465EEEC0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x6B60LL;
}

// --- End Function: sub_1465EEEC0 (0x1465EEEC0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 rotatedCookie; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  rotatedCookie = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)rotatedCookie )
  {
    StackCookie = __ROR8__(rotatedCookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

