// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1462971E0 (sub_1462971E0)
// Caller Depth: 0
// Callee/Ref Depth: 5
// Total Functions Found: 49
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A1370) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0LL;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A1370) ---

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: sub_1402A1E30 (0x1402A1E30) ---
__int64 __fastcall sub_1402A1E30(unsigned __int64 n0x6400000)
{
  return sub_14739AFC0(n0x6400000, 0LL);
}

// --- End Function: sub_1402A1E30 (0x1402A1E30) ---

// --- Function: sub_1402A2470 (0x1402A2470) ---
void *sub_1402A2470()
{
  return &unk_149808280;
}

// --- End Function: sub_1402A2470 (0x1402A2470) ---

// --- Function: sub_1402DE890 (0x1402DE890) ---
__int64 __fastcall sub_1402DE890(__int64 **a1, __int64 a2, __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  _QWORD *v19; // r8
  __int64 v20; // rcx
  _QWORD *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 24) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
    {
      *v4 = a3;
    }
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
    {
      v4[2] = a3;
    }
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 24LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 24) )
      {
        v13 = *(_QWORD **)(v9 + 16);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 16) = *v13;
          if ( !*(_BYTE *)(*v13 + 25LL) )
          {
            *(_QWORD *)(*v13 + 8LL) = v9;
          }
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
            {
              *v14 = v13;
            }
            else
            {
              v14[2] = v13;
            }
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 16LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 25) )
        {
          *(_QWORD *)(v17 + 8) = v15;
        }
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
          {
            v18[2] = v16;
          }
          else
          {
            *v18 = v16;
          }
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 24) )
      {
        v19 = *(_QWORD **)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = v19[2];
          v20 = v19[2];
          if ( !*(_BYTE *)(v20 + 25) )
          {
            *(_QWORD *)(v20 + 8) = v9;
          }
          v19[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v19;
          }
          else
          {
            v21 = *(_QWORD **)(v9 + 8);
            if ( v9 == v21[2] )
            {
              v21[2] = v19;
            }
            else
            {
              *v21 = v19;
            }
          }
          v19[2] = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 25LL) )
        {
          *(_QWORD *)(*v16 + 8LL) = v15;
        }
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
          {
            *v22 = v16;
          }
          else
          {
            v22[2] = v16;
          }
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v11 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 24) = 1;
  return a3;
}

// --- End Function: sub_1402DE890 (0x1402DE890) ---

// --- Function: unknown_libname_7 (0x1402DEE80) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402DEE80) ---

// --- Function: sub_1403577A0 (0x1403577A0) ---
_QWORD *__fastcall sub_1403577A0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149808ABC + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149808ABC + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_1403577A0 (0x1403577A0) ---

// --- Function: sub_1403577C0 (0x1403577C0) ---
void **__fastcall sub_1403577C0(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149808ABC + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)sub_14739AFC0(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
    {
      memcpy(*a1, *a2, Size);
    }
  }
  return a1;
}

// --- End Function: sub_1403577C0 (0x1403577C0) ---

// --- Function: CreateStringObjectFromString (0x140357920) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **__fastcall CreateStringObjectFromString(void **ppStringObjectData, _BYTE *pszInputString)
{
  __int64 inputStringLength; // rbx
  _DWORD *pAllocatedBuffer; // rax

  *ppStringObjectData = (char *)&qword_149808ABC + 4;
  if ( !pszInputString )
  {
    return ppStringObjectData;
  }
  inputStringLength = -1;
  do
  {
    ++inputStringLength;
  }
  while ( pszInputString[inputStringLength] );
  if ( (_DWORD)inputStringLength )
  {
    pAllocatedBuffer = (_DWORD *)sub_14739AFC0((int)inputStringLength + 9LL, 0);
    *ppStringObjectData = pAllocatedBuffer + 2;
    *pAllocatedBuffer = inputStringLength;
    pAllocatedBuffer[1] = inputStringLength;
    *((_BYTE *)*ppStringObjectData + (int)inputStringLength) = 0;
    if ( *ppStringObjectData != pszInputString )
    {
      memcpy(*ppStringObjectData, pszInputString, (int)inputStringLength);
    }
  }
  return ppStringObjectData;
}

// --- End Function: CreateStringObjectFromString (0x140357920) ---

// --- Function: DestroyStringObject (0x14036D270) ---
// Deallocates the memory buffer associated with a string object created by
// `CreateStringObjectFromString`.  It accesses metadata stored 8 bytes before the
// provided data pointer to get the allocation base pointer required by the
// deallocation function `sub_14739AF10`.  @param ppStringObjectData Pointer to the
// variable holding the pointer to the string object's data.
void __fastcall DestroyStringObject(_QWORD *ppStringObjectData)
{
  int *pStringMetadata; // rcx

  pStringMetadata = (int *)(*ppStringObjectData - 8LL);
  if ( pStringMetadata[1] > 0 )
  {
    sub_14739AF10(pStringMetadata);
  }
}

// --- End Function: DestroyStringObject (0x14036D270) ---

// --- Function: sub_140397520 (0x140397520) ---
FARPROC __fastcall sub_140397520(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
    {
      return result;
    }
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
  {
    return GetProcAddress(hModule_1, lpProcName);
  }
  else
  {
    return v7;
  }
}

// --- End Function: sub_140397520 (0x140397520) ---

// --- Function: sub_1403DFBE0 (0x1403DFBE0) ---
__int64 __fastcall sub_1403DFBE0(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
    {
      break;
    }
    ++v2;
    if ( !v4 )
    {
      return 0LL;
    }
  }
  return v4 < v2[v3] ? -1 : 1;
}

// --- End Function: sub_1403DFBE0 (0x1403DFBE0) ---

// --- Function: sub_140566BA0 (0x140566BA0) ---
char __fastcall sub_140566BA0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 12;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
      n2 = 26;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
    case 50:
    case 76:
      n2 = 11;
      break;
    case 54:
      n2 = 22;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 29;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 13;
      break;
    case 63:
    case 75:
      n2 = 28;
      break;
    case 64:
    case 78:
      n2 = 24;
      break;
    case 66:
    case 67:
      n2 = 27;
      break;
    case 70:
      n2 = 30;
      break;
    case 82:
    case 83:
      n2 = 15;
      break;
    case 88:
    case 89:
      n2 = 25;
      break;
    case 90:
    case 91:
      n2 = 16;
      break;
    case 92:
      n2 = 17;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 18;
      break;
    case 98:
    case 99:
      n2 = 19;
      break;
    case 100:
      n2 = 20;
      break;
    case 101:
    case 102:
      n2 = 21;
      break;
    case 103:
      n2 = 23;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_140566BA0 (0x140566BA0) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !Parameter_3 )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = -1;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[4095] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)Parameter_3 + 280LL))(
                      Parameter_3,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: sub_140996BE0 (0x140996BE0) ---
__int64 __fastcall sub_140996BE0(__int64 a1, __int64 a2, __int64 i)
{
  __int64 i_1; // rbx
  _QWORD *i_2; // rdi
  __int64 result; // rax

  i_1 = i;
  while ( !*(_BYTE *)(i_1 + 25) )
  {
    sub_140996BE0(a1, a2, *(_QWORD *)(i_1 + 16));
    i_2 = (_QWORD *)i_1;
    i_1 = *(_QWORD *)i_1;
    DestroyStringObject(i_2 + 4);
    free_memory_wrapper(i_2);
  }
  return result;
}

// --- End Function: sub_140996BE0 (0x140996BE0) ---

// --- Function: sub_1411CEE90 (0x1411CEE90) ---
__int64 __fastcall sub_1411CEE90(__int64 *a1, __int64 a2, __int64 *a3, unsigned __int8 **a4)
{
  __int64 v5; // rax
  __int64 v9; // rbx
  __int64 *v10; // rdx
  __int64 *v11; // rax
  __int64 j; // rbx
  __int64 k; // rax
  char v14; // cl
  __int64 result; // rax
  __int64 v16; // rbx
  __int64 *v17; // rax
  __int64 i; // rcx
  __int64 *v19; // rbp
  unsigned __int8 **v20; // rbx
  char v21; // cl
  __int128 v22; // [rsp+20h] [rbp-28h]

  v5 = *a1;
  if ( *((_BYTE *)a3 + 25) )
  {
    v9 = v5 + 16;
    if ( *(_BYTE *)(*(_QWORD *)(v5 + 8) + 25LL)
      || (int)sub_1403DFBE0((unsigned __int8 **)(*(_QWORD *)v9 + 32LL), a4) < 0 )
    {
      *(_QWORD *)a2 = *(_QWORD *)v9;
      *(_BYTE *)(a2 + 16) = 0;
LABEL_46:
      *(_DWORD *)(a2 + 8) = 0;
      return a2;
    }
LABEL_33:
    v19 = (__int64 *)*a1;
    DWORD2(v22) = 0;
    v20 = (unsigned __int8 **)v19[1];
    *(_QWORD *)&v22 = v20;
    while ( !*((_BYTE *)v20 + 25) )
    {
      *(_QWORD *)&v22 = v20;
      if ( (int)sub_1403DFBE0(v20 + 4, a4) >= 0 )
      {
        v19 = (__int64 *)v20;
        DWORD2(v22) = 1;
        v20 = (unsigned __int8 **)*v20;
      }
      else
      {
        v20 = (unsigned __int8 **)v20[2];
        DWORD2(v22) = 0;
      }
    }
    if ( *((_BYTE *)v19 + 25) || (int)sub_1403DFBE0(a4, v19 + 4) < 0 )
    {
      *(_OWORD *)a2 = v22;
      *(_BYTE *)(a2 + 16) = 0;
    }
    else
    {
      *(_QWORD *)a2 = v19;
      *(_DWORD *)(a2 + 8) = 2;
      *(_BYTE *)(a2 + 16) = 1;
    }
    return a2;
  }
  v10 = a3 + 4;
  if ( a3 == *(__int64 **)v5 )
  {
    if ( (int)sub_1403DFBE0(a4, v10) < 0 )
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 1;
      *(_BYTE *)(a2 + 16) = 0;
      return a2;
    }
    goto LABEL_33;
  }
  if ( (int)sub_1403DFBE0(a4, v10) >= 0 )
  {
    if ( (int)sub_1403DFBE0((unsigned __int8 **)a3 + 4, a4) >= 0 )
    {
      *(_QWORD *)a2 = a3;
      *(_BYTE *)(a2 + 16) = 1;
      goto LABEL_46;
    }
    v16 = a3[2];
    v17 = a3;
    if ( *(_BYTE *)(v16 + 25) )
    {
      v16 = a3[1];
      if ( *(_BYTE *)(v16 + 25) )
      {
LABEL_42:
        v21 = *(_BYTE *)(a3[2] + 25);
        result = a2;
        *(_BYTE *)(a2 + 16) = 0;
        if ( v21 )
        {
          *(_QWORD *)a2 = a3;
          *(_DWORD *)(a2 + 8) = 0;
        }
        else
        {
          *(_QWORD *)a2 = v16;
          *(_DWORD *)(a2 + 8) = 1;
        }
        return result;
      }
      do
      {
        if ( v17 != *(__int64 **)(v16 + 16) )
        {
          break;
        }
        v17 = (__int64 *)v16;
        v16 = *(_QWORD *)(v16 + 8);
      }
      while ( !*(_BYTE *)(v16 + 25) );
    }
    else
    {
      for ( i = *(_QWORD *)v16; !*(_BYTE *)(i + 25); i = *(_QWORD *)i )
      {
        v16 = i;
      }
    }
    if ( !*(_BYTE *)(v16 + 25) && (int)sub_1403DFBE0(a4, (_QWORD *)(v16 + 32)) >= 0 )
    {
      goto LABEL_33;
    }
    goto LABEL_42;
  }
  v11 = a3;
  if ( *((_BYTE *)a3 + 25) )
  {
    j = a3[2];
  }
  else
  {
    j = *a3;
    if ( *(_BYTE *)(*a3 + 25) )
    {
      for ( j = a3[1]; !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 8) )
      {
        if ( v11 != *(__int64 **)j )
        {
          break;
        }
        v11 = (__int64 *)j;
      }
      if ( *((_BYTE *)v11 + 25) )
      {
        j = (__int64)v11;
      }
    }
    else
    {
      for ( k = *(_QWORD *)(j + 16); !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 16) )
      {
        j = k;
      }
    }
  }
  if ( (int)sub_1403DFBE0((unsigned __int8 **)(j + 32), a4) >= 0 )
  {
    goto LABEL_33;
  }
  v14 = *(_BYTE *)(*(_QWORD *)(j + 16) + 25LL);
  result = a2;
  *(_BYTE *)(a2 + 16) = 0;
  if ( v14 )
  {
    *(_QWORD *)a2 = j;
    *(_DWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = a3;
    *(_DWORD *)(a2 + 8) = 1;
  }
  return result;
}

// --- End Function: sub_1411CEE90 (0x1411CEE90) ---

// --- Function: sub_1411F96D0 (0x1411F96D0) ---
__int64 __fastcall sub_1411F96D0(__int64 a1, __int64 *a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 *v6; // rbp
  __int64 v7; // r12
  __int64 v8; // rax
  _QWORD *v9; // rsi
  __int64 v10; // r14
  __int128 v11; // xmm0
  __int128 v13; // [rsp+20h] [rbp-68h] BYREF
  __int64 v14; // [rsp+40h] [rbp-48h]
  _BYTE v15[24]; // [rsp+48h] [rbp-40h] BYREF

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = sub_1402A1E30(0x30u);
  v5 = *a2;
  v6 = (__int64 *)v4;
  v7 = a2[1];
  *(_QWORD *)v4 = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)(v4 + 16) = v4;
  *(_WORD *)(v4 + 24) = 257;
  for ( *(_QWORD *)a1 = v4; v5 != v7; v5 += 16 )
  {
    v8 = sub_1411CEE90((_QWORD **)a1, (__int64)v15, v6, (unsigned __int8 **)v5);
    v13 = *(_OWORD *)v8;
    v14 = *(_QWORD *)(v8 + 16);
    if ( !(_BYTE)v14 )
    {
      if ( *(_QWORD *)(a1 + 8) == 0x555555555555555LL )
      {
        unknown_libname_7();
      }
      v9 = *(_QWORD **)a1;
      v10 = sub_1402A1E30(0x30u);
      sub_1403577C0((void **)(v10 + 32), (const void **)v5);
      v11 = v13;
      *(_DWORD *)(v10 + 40) = *(_DWORD *)(v5 + 8);
      *(_QWORD *)v10 = v9;
      *(_QWORD *)(v10 + 8) = v9;
      *(_QWORD *)(v10 + 16) = v9;
      *(_WORD *)(v10 + 24) = 0;
      v13 = v11;
      sub_1402DE890((__int64 **)a1, (__int64)&v13, v10);
    }
  }
  return a1;
}

// --- End Function: sub_1411F96D0 (0x1411F96D0) ---

// --- Function: sub_141201480 (0x141201480) ---
__int64 *__fastcall sub_141201480(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rdi
  __int64 v5; // rbx
  __int64 *v6; // rdi
  __int64 v7; // rsi
  __int128 v8; // xmm0
  __int128 v10; // [rsp+20h] [rbp-38h] BYREF

  v2 = *(__int64 **)a1;
  DWORD2(v10) = 0;
  v5 = v2[1];
  *(_QWORD *)&v10 = v5;
  while ( !*(_BYTE *)(v5 + 25) )
  {
    *(_QWORD *)&v10 = v5;
    if ( (int)sub_1403DFBE0((unsigned __int8 **)(v5 + 32), a2) >= 0 )
    {
      v2 = (__int64 *)v5;
      DWORD2(v10) = 1;
      v5 = *(_QWORD *)v5;
    }
    else
    {
      v5 = *(_QWORD *)(v5 + 16);
      DWORD2(v10) = 0;
    }
  }
  if ( *((_BYTE *)v2 + 25) || (int)sub_1403DFBE0((unsigned __int8 **)a2, v2 + 4) < 0 )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x492492492492492LL )
    {
      unknown_libname_7();
    }
    v6 = *(__int64 **)a1;
    v7 = sub_1402A1E30(0x38u);
    sub_1403577A0((_QWORD *)(v7 + 32), a2);
    v8 = v10;
    *(_QWORD *)(v7 + 40) = 0;
    *(_QWORD *)(v7 + 48) = 0;
    *(_QWORD *)v7 = v6;
    *(_QWORD *)(v7 + 8) = v6;
    *(_QWORD *)(v7 + 16) = v6;
    *(_WORD *)(v7 + 24) = 0;
    v10 = v8;
    v2 = (__int64 *)sub_1402DE890((__int64 **)a1, (__int64)&v10, v7);
  }
  return v2 + 5;
}

// --- End Function: sub_141201480 (0x141201480) ---

// --- Function: sub_1417C3450 (0x1417C3450) ---
_QWORD *__fastcall sub_1417C3450(_QWORD *pExceptionObject)
{
  pExceptionObject[1] = "bad allocation";
  *pExceptionObject = off_147F343E8;
  return pExceptionObject;
}

// --- End Function: sub_1417C3450 (0x1417C3450) ---

// --- Function: sub_1462971E0 (0x1462971E0) ---
void sub_1462971E0()
{
  __int64 v0; // rsi
  __int64 n12; // rdi
  _QWORD *v2; // rbx
  __int64 *v3; // rax
  void *v4[2]; // [rsp+20h] [rbp-89h] BYREF
  void *v5; // [rsp+30h] [rbp-79h] BYREF
  int v6; // [rsp+38h] [rbp-71h]
  void *v7; // [rsp+40h] [rbp-69h] BYREF
  int v8; // [rsp+48h] [rbp-61h]
  void *v9; // [rsp+50h] [rbp-59h] BYREF
  int n2; // [rsp+58h] [rbp-51h]
  void *v11; // [rsp+60h] [rbp-49h] BYREF
  int n3; // [rsp+68h] [rbp-41h]
  void *v13; // [rsp+70h] [rbp-39h] BYREF
  int n4; // [rsp+78h] [rbp-31h]
  void *v15; // [rsp+80h] [rbp-29h] BYREF
  int n5; // [rsp+88h] [rbp-21h]
  void *v17; // [rsp+90h] [rbp-19h] BYREF
  int n6; // [rsp+98h] [rbp-11h]
  void *v19; // [rsp+A0h] [rbp-9h] BYREF
  int n7; // [rsp+A8h] [rbp-1h]
  void *v21; // [rsp+B0h] [rbp+7h] BYREF
  int n8; // [rsp+B8h] [rbp+Fh]
  void *v23; // [rsp+C0h] [rbp+17h] BYREF
  int n9; // [rsp+C8h] [rbp+1Fh]
  void *v25; // [rsp+D0h] [rbp+27h] BYREF
  int n10; // [rsp+D8h] [rbp+2Fh]
  void *v27; // [rsp+E0h] [rbp+37h] BYREF
  int n11; // [rsp+E8h] [rbp+3Fh]
  _QWORD v29[2]; // [rsp+F0h] [rbp+47h] BYREF

  v0 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3);
  if ( (dword_149B3E090 & 1) == 0 )
  {
    dword_149B3E090 |= 1u;
    CreateStringObjectFromString(&v5, "None");
    v6 = 0;
    CreateStringObjectFromString(&v7, "Attach");
    v8 = 1;
    CreateStringObjectFromString(&v9, "AttachLanding");
    n2 = 2;
    CreateStringObjectFromString(&v11, "Detach");
    n3 = 3;
    CreateStringObjectFromString(&v13, &dword_147F51630);
    n4 = 4;
    CreateStringObjectFromString(&v15, "MoveForward");
    n5 = 5;
    CreateStringObjectFromString(&v17, "LedgeTraversal");
    n6 = 6;
    CreateStringObjectFromString(&v19, "IdleToTurn");
    n7 = 7;
    CreateStringObjectFromString(&v21, "KneeDrop");
    n8 = 8;
    CreateStringObjectFromString(&v23, "LaunchTurn");
    n9 = 9;
    CreateStringObjectFromString(&v25, "Launch");
    n10 = 10;
    CreateStringObjectFromString(&v27, "Sprint");
    n11 = 11;
    v4[0] = &v5;
    v4[1] = v29;
    sub_1411F96D0((__int64)&qword_149B3E080, (__int64 *)v4);
    n12 = 12;
    v2 = v29;
    do
    {
      v2 -= 2;
      DestroyStringObject(v2);
      --n12;
    }
    while ( n12 );
    atexit(sub_147EFBCA0);
  }
  CreateStringObjectFromString(v4, "ZeroGTraversalAction");
  v3 = sub_141201480(v0 + 288, (__int64 *)v4);
  v3[1] = (__int64)&qword_149B3E080;
  *v3 = 4;
  DestroyStringObject(v4);
}

// --- End Function: sub_1462971E0 (0x1462971E0) ---

// --- Function: sub_147273B30 (0x147273B30) ---
__int64 sub_147273B30()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3400LL);
  if ( result )
  {
    return *(unsigned __int8 *)(result + 1);
  }
  return result;
}

// --- End Function: sub_147273B30 (0x147273B30) ---

// --- Function: sub_147349F80 (0x147349F80) ---
int __fastcall sub_147349F80(char *Buffer, size_t BufferCount, unsigned __int64 n0x6400000)
{
  char *p_%u.%u_MB; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-A8h]
  int v11; // [rsp+28h] [rbp-A0h]
  __m256 Buffer_; // [rsp+40h] [rbp-88h] BYREF
  __m256 Buffer__1; // [rsp+60h] [rbp-68h] BYREF
  __m256 v14; // [rsp+80h] [rbp-48h]

  Buffer_ = (__m256)0LL;
  if ( n0x6400000 >= 0x10000000000LL )
  {
    p_%u.%u_MB = "%u.%u TB";
    v7 = (10 * (n0x6400000 & 0xFFFFFFFFFFLL)) >> 40;
    v8 = n0x6400000 >> 40;
LABEL_7:
    v11 = v7;
    v10 = v8;
    __asm { vzeroupper }
    sub_1403E8420((char *)&Buffer_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, p_%u.%u_MB, v10, v11);
    goto LABEL_11;
  }
  if ( n0x6400000 >= 0x40000000 )
  {
    p_%u.%u_MB = "%u.%u GB";
    v7 = (10 * (n0x6400000 & 0x3FFFFFFF)) >> 30;
    v8 = n0x6400000 >> 30;
    goto LABEL_7;
  }
  if ( n0x6400000 >= 0x100000 )
  {
    p_%u.%u_MB = "%u.%u MB";
    v7 = (10 * (n0x6400000 & 0xFFFFF)) >> 20;
    v8 = n0x6400000 >> 20;
    goto LABEL_7;
  }
  if ( n0x6400000 < 0x400 )
  {
    __asm { vzeroupper }
    sub_1403E8420((char *)&Buffer_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, "%u byte(s)", n0x6400000);
  }
  else
  {
    __asm { vzeroupper }
    sub_1403E8420(
      (char *)&Buffer_,
      0x20u,
      0xFFFFFFFFFFFFFFFFuLL,
      "%u.%u KB",
      n0x6400000 >> 10,
      (10 * (n0x6400000 & 0x3FF)) >> 10);
  }
LABEL_11:
  Buffer__1 = (__m256)0LL;
  v14 = (__m256)0LL;
  if ( byte_151371513 )
  {
    __asm { vzeroupper }
    sub_1403E8420(
      (char *)&Buffer__1,
      0x40u,
      0xFFFFFFFFFFFFFFFFuLL,
      " (Started with < %u GB of available system memory.)",
      8);
  }
  __asm { vzeroupper }
  return sub_1403E8420(
           Buffer,
           BufferCount,
           0xFFFFFFFFFFFFFFFFuLL,
           "Out of system memory. Failed to allocate %s (%zu).%s",
           (const char *)&Buffer_,
           n0x6400000,
           (const char *)&Buffer__1);
}

// --- End Function: sub_147349F80 (0x147349F80) ---

// --- Function: sub_1473755E0 (0x1473755E0) ---
void __fastcall sub_1473755E0(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_147349F80(Buffer, 0xA0uLL, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1473755E0 (0x1473755E0) ---

// --- Function: sub_147397F30 (0x147397F30) ---
void __fastcall sub_147397F30(__int64 a1)
{
  sub_147397F40(a1);
}

// --- End Function: sub_147397F30 (0x147397F30) ---

// --- Function: sub_147397F40 (0x147397F40) ---
void __fastcall sub_147397F40(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_1513BD0BC + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 3553) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_1513BD0BC + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &qword_1513BBF20[4 * *(_QWORD *)((unsigned int)dword_1513BD0BC + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 3552) )
        {
          *(_BYTE *)(v2 + 3552) = 1;
          v6 = *(_DWORD *)(v2 + 5824);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 5824) = v6 | 1;
            _tlregdtor((__int64)sub_147F0BEB0);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 16) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 16 * (n0x28 + 1) + 3552);
          n0x10 = *(_DWORD *)(v2 + 16 * (n0x28 + 1) + 3564) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 16 * (n0x28 + 1) + 3564) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &qword_1513BBF20[4 * n0x28];
      }
      sub_147399CD0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147398080((__int64)&qword_1513BBF10, a1);
    }
  }
}

// --- End Function: sub_147397F40 (0x147397F40) ---

// --- Function: sub_147398080 (0x147398080) ---
void __fastcall sub_147398080(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned __int32 v4; // eax
  __int64 v5; // r13
  int v6; // ebx
  unsigned int v7; // ebp
  unsigned __int32 v8; // r15d
  unsigned int v9; // ebx
  unsigned __int32 v10; // [rsp+20h] [rbp-88h]
  unsigned __int32 v11; // [rsp+20h] [rbp-88h]
  int n5632; // [rsp+30h] [rbp-78h] BYREF
  __int64 v13; // [rsp+34h] [rbp-74h]
  int v14; // [rsp+3Ch] [rbp-6Ch]
  __int64 v15; // [rsp+40h] [rbp-68h]
  unsigned __int64 v16; // [rsp+48h] [rbp-60h]
  __int64 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-50h]

  v3 = a1 + 4848;
  v4 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 4848), 1u);
  v5 = a1 + 4848 + 16 * (v4 & 0x1F);
  v6 = (v4 >> 5) & 0x7FFF;
  v7 = ((v4 - 32) >> 5) & 0x7FFF;
  v8 = *(_DWORD *)(v5 + 8);
  if ( (v8 & 0x7FFF) != v7 )
  {
    if ( qword_14981D3D8 )
    {
      n5632 = 5632;
      v13 = 0;
      v14 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v15 = 1;
      qword_149818EA0(
        &n5632,
        0,
        &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
        &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
        0);
      LOBYTE(v11) = 0;
      sub_1407DADE0(v3, (volatile signed __int32 *)(v5 + 8), v8, v7, v11);
      v16 = __rdtsc();
      qword_149818EA8(&n5632);
    }
    else
    {
      LOBYTE(v10) = 0;
      sub_1407DADE0(a1 + 4848, (volatile signed __int32 *)(v5 + 8), v8, v7, v10);
    }
  }
  *(_QWORD *)(v5 + 16) = a2;
  v9 = _InterlockedExchange((volatile __int32 *)(v5 + 12), v6);
  if ( (v9 & 0xFFFF8000) != 0 )
  {
    sub_1407DAF40(v3, v5 + 12, v9);
  }
}

// --- End Function: sub_147398080 (0x147398080) ---

// --- Function: sub_1473986B0 (0x1473986B0) ---
unsigned __int64 __fastcall sub_1473986B0(unsigned __int64 n0xE000, unsigned __int64 n0x10)
{
  return sub_1473986C0(n0xE000, n0x10);
}

// --- End Function: sub_1473986B0 (0x1473986B0) ---

// --- Function: sub_1473986C0 (0x1473986C0) ---
unsigned __int64 __fastcall sub_1473986C0(unsigned __int64 n0xE000, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000_1; // r11
  unsigned int v3; // r8d
  int n32; // eax
  unsigned int n32_1; // r8d
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 *v9; // r10
  __int64 v10; // r8
  __int64 v11; // rdi
  __int64 v12; // r11
  __int64 v13; // r8
  __int64 *v14; // rax
  __int64 v15; // rax
  unsigned __int64 v16; // r11
  unsigned __int64 result; // rax
  __int64 v18; // rcx
  _QWORD *v19; // r8
  _QWORD *v20; // r8

  n0xE000_1 = n0xE000;
  if ( n0x10 > 0x10 )
  {
    n0xE000_1 = ~(n0x10 - 1) & (n0x10 + n0xE000 - 1);
  }
  if ( n0xE000_1 > 0xE000 )
  {
    result = sub_147398850((__int64)&qword_1513BBF10, n0xE000_1);
  }
  else
  {
    _BitScanReverse(&v3, n0xE000_1 - 1);
    n32 = 32;
    n32_1 = v3 ^ 0x1F;
    if ( (_DWORD)n0xE000_1 != 1 )
    {
      n32 = n32_1;
    }
    v6 = 0;
    v7 = 0;
    v8 = (unsigned int)(32 - n32) - 8LL;
    if ( v8 >= 0 )
    {
      v7 = v8;
    }
    v9 = &qword_148A35270[3 * v7];
    LOBYTE(v6) = n0xE000_1 % *v9 == 0;
    v10 = n0xE000_1 / *v9 - v6;
    v11 = v10 + v9[1] - v9[2] / (unsigned __int64)*v9;
    v12 = *v9 * (v10 + 1);
    v13 = 16 * (v11 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3552;
    v14 = *(__int64 **)v13;
    if ( *(_QWORD *)v13 )
    {
      --*(_DWORD *)(v13 + 12);
      v18 = *v14;
      result = (unsigned __int64)v14 - v12 + 8;
      *(_QWORD *)v13 = v18;
    }
    else
    {
      v15 = sub_147399BF0(&qword_1513BBF20[4 * v11]);
      if ( v15 )
      {
        result = v15 - v16 + 8;
      }
      else
      {
        result = sub_147398A80((__int64)&qword_1513BBF10, v16, v11);
      }
    }
  }
  v19 = (_QWORD *)qword_1513BD1A0;
  if ( qword_1513BD1A0 )
  {
    while ( result < (unsigned __int64)v19 || result >= (unsigned __int64)v19 + v19[1] )
    {
      v19 = (_QWORD *)*v19;
      if ( !v19 )
      {
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    v20 = (_QWORD *)qword_1513BD0A0;
    if ( qword_1513BD0A0 )
    {
      while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
      {
        v20 = (_QWORD *)*v20;
        if ( !v20 )
        {
          goto LABEL_22;
        }
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1473986C0 (0x1473986C0) ---

// --- Function: sub_147398850 (0x147398850) ---
__int64 __fastcall sub_147398850(__int64 a1, unsigned __int64 n0xE000)
{
  unsigned __int64 n0xE000_2; // r13
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // rbx
  unsigned __int64 v5; // r12
  __int64 v6; // r15
  __int64 v7; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rsi
  unsigned __int64 v10; // r14
  __int64 v11; // r8
  __int64 v12; // rsi
  __int64 v13; // rax
  __int128 v15; // [rsp+30h] [rbp-40h] BYREF
  double v16; // [rsp+40h] [rbp-30h]
  __int64 v17; // [rsp+48h] [rbp-28h] BYREF
  __int128 v18; // [rsp+50h] [rbp-20h]
  double v19; // [rsp+60h] [rbp-10h]
  double v20; // [rsp+B0h] [rbp+40h] BYREF
  unsigned __int64 n0xE000_1; // [rsp+B8h] [rbp+48h]
  __int64 v22; // [rsp+C0h] [rbp+50h]

  n0xE000_1 = n0xE000;
  n0xE000_2 = n0xE000;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 4800);
  v5 = sub_147398FE0(n0xE000, 1);
  v6 = ~(*(unsigned int *)(a1 + 4740) - 1LL) & (*(unsigned int *)(a1 + 4740) + n0xE000_2 - 1);
  v22 = v6;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 4800));
  v20 = 0.0;
  v7 = sub_1473983D0(a1, v5, &v20);
  v8 = *(_QWORD **)(v7 + 8);
  if ( v8 )
  {
    *(_QWORD *)(v7 + 8) = *v8;
    v9 = v8[1];
    v8[1] = 0;
    *v8 = *(_QWORD *)(a1 + 4792);
    *(_QWORD *)(a1 + 4792) = v8;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 4752);
    if ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 )
    {
      do
      {
        v11 = *(unsigned int *)(a1 + 4780);
        v12 = (v11 + 23) & ~(v11 - 1);
        *(__m256i *)(a1 + 4760) = *(__m256i *)sub_14056A0D0((__int64)&v17, 0x8000000000LL, v11, &off_148A35268, 1, 0);// "StarAlloc-Large"
        v10 = (*(_QWORD *)(a1 + 4760) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
        __asm { vzeroupper }
        sub_140569F50(a1 + 4760, v10, v12);
        *(_WORD *)(v10 + 21) = 0;
        *(_BYTE *)(v10 + 23) = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)(v10 + 16) = 4919;
        *(_BYTE *)(v10 + 20) = 0;
        *(_QWORD *)(v10 + 8) = v12;
        *(_QWORD *)v10 = *(_QWORD *)(a1 + 4752);
        *(_QWORD *)(a1 + 4752) = v10;
      }
      while ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 );
      v6 = v22;
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 4800);
      n0xE000_2 = n0xE000_1;
    }
    v13 = *(_QWORD *)(v10 + 8);
    v9 = v13 + v10;
    *(_QWORD *)(v10 + 8) = v5 + v13;
  }
  sub_140569F50(a1 + 4720, v9, v6);
  v16 = v20;
  *(_QWORD *)&v15 = n0xE000_2;
  *((_QWORD *)&v15 + 1) = v6;
  v19 = v20;
  v17 = v9;
  v18 = v15;
  sub_147399AC0((__int64 *)(a1 + 4648), (__int64)&v15, &v17);
  LeaveCriticalSection(lpCriticalSection);
  return v9;
}

// --- End Function: sub_147398850 (0x147398850) ---

// --- Function: sub_147398A80 (0x147398A80) ---
// goomba: z3 proof timed out, simplification assumed correct
unsigned __int64 __fastcall sub_147398A80(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 i; // rax
  __int64 v8; // r11
  signed __int32 v9; // eax
  __int64 v10; // rcx
  __int64 v11; // rbp
  unsigned __int64 v12; // rsi
  __int64 v13; // rcx
  __int64 v14; // r12
  unsigned __int64 v15; // r15
  unsigned __int64 v16; // rax
  _QWORD *v17; // r8
  unsigned __int64 v18; // rax
  int v19; // r9d
  signed __int64 v20; // rdx
  int n2_1; // [rsp+20h] [rbp-48h] BYREF
  __int64 v23; // [rsp+28h] [rbp-40h]
  int n2; // [rsp+78h] [rbp+10h] BYREF
  __int64 v26; // [rsp+80h] [rbp+18h]

  v26 = a3;
  v3 = *(unsigned int *)(a1 + 4524);
  v23 = v3;
  v4 = 32 * a3 + a1 + 16;
  v5 = a3;
  for ( i = sub_147399BF0((volatile signed __int64 *)v4); !i; i = sub_147399BF0((volatile signed __int64 *)v4) )
  {
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 24), 1, 0) - 1;
    if ( v9 )
    {
      if ( v9 == 1 )
      {
        n2 = 2;
        qword_149808B88(v4 + 24, &n2, 4, 0xFFFFFFFFLL);
      }
      else
      {
        v10 = *(_QWORD *)(v4 + 16);
        if ( !v10 || 0x2000000LL - *(_QWORD *)(v10 + 32) - v3 < a2 )
        {
          sub_147397870(v8, a2, v5);
          v8 = a1;
        }
        v11 = *(_QWORD *)(v4 + 16);
        v12 = v11 - v3 + 0x2000000;
        v13 = *(_QWORD *)(v11 + 32);
        v14 = v13 + v11;
        if ( v11 + v13 + 32 * a2 < v12 )
        {
          v12 = v11 + v13 + 32 * a2;
        }
        v15 = ~(v23 - 1) & (v12 - v11 + v3 - 1);
        v16 = *(_QWORD *)(v11 + 24);
        if ( v15 > v16 )
        {
          sub_140569F50(v8 + 4504, v16 + v11, v15 - v16);
          *(_QWORD *)(v11 + 24) = v15;
        }
        *(_QWORD *)(v11 + 32) = v12 - v11;
        v17 = (_QWORD *)(v14 + a2 - 8);
        v18 = v14 + 2 * a2;
        v19 = 1;
        v20 = (signed __int64)v17;
        for ( *v17 = 0; v18 <= v12; v18 += a2 )
        {
          *(_QWORD *)(v18 - 8) = v20;
          ++v19;
          v20 = v18 - 8;
        }
        sub_147399DC0((volatile signed __int64 *)v4, v20, v17, v19);
        if ( _InterlockedExchange((volatile __int32 *)(v4 + 24), 0) == 2 )
        {
          qword_149808B98(v4 + 24);
        }
        v5 = v26;
        v3 = v23;
      }
    }
    else if ( (unsigned int)(_InterlockedCompareExchange((volatile signed __int32 *)(v4 + 24), 2, 1) - 1) <= 1 )
    {
      n2_1 = 2;
      qword_149808B88(v4 + 24, &n2_1, 4, 0xFFFFFFFFLL);
    }
  }
  return i - a2 + 8;
}

// --- End Function: sub_147398A80 (0x147398A80) ---

// --- Function: sub_147399BF0 (0x147399BF0) ---
__int64 __fastcall sub_147399BF0(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __int32 v5; // edx
  __m128i v6; // rt0
  signed __int64 v8; // [rsp+18h] [rbp-40h]
  __m128i v9; // [rsp+30h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
  {
    return 0;
  }
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    LODWORD(v8) = epi64 + 1;
    HIDWORD(v8) = HIDWORD(epi64) - 1;
    v6.m128i_i64[0] = v2.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v8, *(_QWORD *)v2.m128i_i64[0], v6.m128i_i64);
    v4 = v6.m128i_i64[0];
    v5 = v6.m128i_i32[2];
    v9 = v6;
    if ( v6.m128i_i64[0] == v2.m128i_i64[0] && v5 == (_DWORD)epi64 )
    {
      break;
    }
    v2 = v9;
    if ( !v4 )
    {
      return 0;
    }
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_147399BF0 (0x147399BF0) ---

// --- Function: sub_147399CD0 (0x147399CD0) ---
char __fastcall sub_147399CD0(volatile signed __int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __m128i v4; // rt0
  __m128i v5; // xmm0
  signed __int64 epi64; // r9
  __int64 v7; // rdx
  __m128i v8; // rt0
  signed __int64 v10; // [rsp+18h] [rbp-40h]
  __m128i v11; // [rsp+30h] [rbp-28h]

  v4 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v4.m128i_i64);
  v5 = v4;
  if ( (unsigned int)(v4.m128i_i32[3] + 1) >= a3 )
  {
    return 0;
  }
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v5, 1);
    *a2 = v5.m128i_i64[0];
    LODWORD(v10) = epi64 + 1;
    HIDWORD(v10) = HIDWORD(epi64) + 1;
    v8.m128i_i64[0] = v5.m128i_i64[0];
    v8.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v10, (signed __int64)a2, v8.m128i_i64);
    v7 = v8.m128i_i64[1];
    v11 = v8;
    if ( v8.m128i_i64[0] == v5.m128i_i64[0] && (_DWORD)v7 == (_DWORD)epi64 )
    {
      break;
    }
    v5 = v11;
    if ( (unsigned int)(HIDWORD(v7) + 1) >= a3 )
    {
      return 0;
    }
  }
  return 1;
}

// --- End Function: sub_147399CD0 (0x147399CD0) ---

// --- Function: sub_14739A8D0 (0x14739A8D0) ---
__int64 __fastcall sub_14739A8D0(unsigned __int64 n0x6400000)
{
  __int64 result; // rax
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1513BD53C == 1 )
  {
    sub_1417C3450(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_14981D4C4 = 1;
  ::n0x6400000 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
  {
    sub_1473755E0(n0x6400000);
  }
  n26880 = 26880;
  v5 = 0;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = 1;
  qword_149818EA0(
    &n26880,
    0,
    &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  sub_1473755E0(n0x6400000);
  v8 = __rdtsc();
  qword_149818EA8(&n26880);
  return result;
}

// --- End Function: sub_14739A8D0 (0x14739A8D0) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(const void *a1)
{
  if ( a1 )
  {
    if ( qword_14981D3D8 && pCZoneSystem && a1 == (const void *)pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)a1 < qword_1497CE098 || (unsigned __int64)a1 >= qword_1497CE098 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_1497CE078 && (unsigned __int64)a1 < qword_1497CE078 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      }
      sub_147397F30((__int64)a1);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: sub_14739AFC0 (0x14739AFC0) ---
__int64 __fastcall sub_14739AFC0(unsigned __int64 n0x6400000, struct _exception *n0x10)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( n0x6400000 )
  {
    v4 = sub_147273B30();
    sub_140566BA0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(n0x10);
    result = sub_1473986B0(v5 + n0x6400000, (unsigned __int64)n0x10);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(n0x6400000);
  }
  return 0LL;
}

// --- End Function: sub_14739AFC0 (0x14739AFC0) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---

// --- Function: _onexit (0x147DC774C) ---
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)(); // rdx

  if ( Table._first == (_PVFV *)-1LL )
  {
    v2 = crt_atexit((_PVFV)Func);
  }
  else
  {
    v2 = register_onexit_function(&Table, Func);
  }
  v3 = 0LL;
  if ( !v2 )
  {
    return Func;
  }
  return v3;
}

// --- End Function: _onexit (0x147DC774C) ---

// --- Function: atexit (0x147DC7788) ---
int __cdecl atexit(void (__cdecl *Func)())
{
  return (onexit((_onexit_t)Func) != 0LL) - 1;
}

// --- End Function: atexit (0x147DC7788) ---

// --- Function: __alloca_probe (0x147DC7830) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
  {
    StackLimit_1 = 0;
  }
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x147DC7830) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __tlregdtor (0x147DC7958) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6032);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6048);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6032) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100uLL);
    free_0(0LL);
    if ( !v3 )
    {
      return 0xFFFFFFFFLL;
    }
    v3[1] = *(_QWORD *)(v2 + 6032);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0LL;
}

// --- End Function: __tlregdtor (0x147DC7958) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memcpy (0x147E162BB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x147E162BB) ---

// --- Function: memset (0x147E162C7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x147E162C7) ---

// --- Function: _CxxThrowException (0x147E1630F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x147E1630F) ---

// --- Function: _register_onexit_function (0x147E164B9) ---
// attributes: thunk
int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function)
{
  return _register_onexit_function(Table, Function);
}

// --- End Function: _register_onexit_function (0x147E164B9) ---

// --- Function: _crt_atexit (0x147E164BF) ---
// attributes: thunk
int __cdecl crt_atexit(_PVFV Function)
{
  return _crt_atexit(Function);
}

// --- End Function: _crt_atexit (0x147E164BF) ---

// --- Function: sub_147EFBCA0 (0x147EFBCA0) ---
void __fastcall sub_147EFBCA0()
{
  const void *ptr_to_free_1; // rcx
  __int64 *ptr_to_free_2; // rbx
  _QWORD *ptr_to_free; // rdi

  ptr_to_free_1 = (const void *)qword_149B3E080;
  ptr_to_free_2 = *(__int64 **)(qword_149B3E080 + 8);
  if ( !*((_BYTE *)ptr_to_free_2 + 25) )
  {
    do
    {
      sub_140996BE0((__int64)&qword_149B3E080, (__int64)&qword_149B3E080, ptr_to_free_2[2]);
      ptr_to_free = ptr_to_free_2;
      ptr_to_free_2 = (__int64 *)*ptr_to_free_2;
      DestroyStringObject(ptr_to_free + 4);
      free_memory_wrapper(ptr_to_free);
    }
    while ( !*((_BYTE *)ptr_to_free_2 + 25) );
    ptr_to_free_1 = (const void *)qword_149B3E080;
  }
  free_memory_wrapper(ptr_to_free_1);
}

// --- End Function: sub_147EFBCA0 (0x147EFBCA0) ---

// --- Function: sub_147F0BEB0 (0x147F0BEB0) ---
_QWORD *sub_147F0BEB0()
{
  volatile signed __int64 *v0; // rdi
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 n140; // rsi
  __int64 v3; // rbp
  __int64 v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *v6; // rax
  int v7; // r9d
  _QWORD *v8; // r8

  v0 = qword_1513BBF20;
  ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
  n140 = 140;
  v3 = ThreadLocalStoragePointer[TlsIndex] + 3552LL;
  v4 = ThreadLocalStoragePointer[TlsIndex] + 3568LL;
  do
  {
    v5 = *(_QWORD **)v4;
    if ( *(_QWORD *)v4 )
    {
      v6 = (_QWORD *)*v5;
      v7 = 1;
      v8 = *(_QWORD **)v4;
      if ( *v5 )
      {
        do
        {
          ++v7;
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while ( v6 );
      }
      ThreadLocalStoragePointer = (_QWORD *)sub_147399DC0(v0, (signed __int64)v5, v8, v7);
      *(_QWORD *)v4 = 0;
      *(_DWORD *)(v4 + 12) = 0;
    }
    v4 += 16;
    v0 += 4;
    --n140;
  }
  while ( n140 );
  *(_BYTE *)(v3 + 1) = 1;
  return ThreadLocalStoragePointer;
}

// --- End Function: sub_147F0BEB0 (0x147F0BEB0) ---

