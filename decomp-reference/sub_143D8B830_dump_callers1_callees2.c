// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x143D8B830 (sub_143D8B830)
// Caller Depth: 1
// Callee/Ref Depth: 2
// Total Functions Found: 18
// ------------------------------------------------------------

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402AE7E0 (0x1402AE7E0) ---
__int64 __fastcall sub_1402AE7E0(__int64 a1)
{
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

// --- End Function: sub_1402AE7E0 (0x1402AE7E0) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: p_p_p_sub_140384A94 (0x140384A94) ---
void __fastcall p_p_p_sub_140384A94(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
}

// --- End Function: p_p_p_sub_140384A94 (0x140384A94) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403E6750 (0x1403E6750) ---
unsigned __int64 __fastcall sub_1403E6750(unsigned __int64 *a1)
{
  if ( sub_14030EC00(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6750 (0x1403E6750) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_14156A3A0 (0x14156A3A0) ---
_QWORD *__fastcall sub_14156A3A0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( sub_14030EC00(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_9;
    if ( n0xFFFF_9 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v9,
                            "IInteractableComponent");
      n0xFFFF_9 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_14156A3A0 (0x14156A3A0) ---

// --- Function: sub_1434922F0 (0x1434922F0) ---
_QWORD *__fastcall sub_1434922F0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( sub_14030EC00(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_16;
    if ( n0xFFFF_16 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v8,
                            "HarvestableComponent");
      n0xFFFF_16 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_1434922F0 (0x1434922F0) ---

// --- Function: sub_1434F6DB0 (0x1434F6DB0) ---
bool __fastcall sub_1434F6DB0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x1A8) != 0;
}

// --- End Function: sub_1434F6DB0 (0x1434F6DB0) ---

// --- Function: sub_143CED060 (0x143CED060) ---
double *__fastcall sub_143CED060(__int64 a1, double *a2, unsigned int a3)
{
  char v4; // [rsp+20h] [rbp-1D8h]
  double *v5; // [rsp+30h] [rbp-1C8h]
  double v6; // [rsp+40h] [rbp-1B8h]
  double v7; // [rsp+40h] [rbp-1B8h]
  double v8; // [rsp+48h] [rbp-1B0h]
  double v9; // [rsp+48h] [rbp-1B0h]
  double v10; // [rsp+50h] [rbp-1A8h]
  double v11; // [rsp+50h] [rbp-1A8h]
  float v12; // [rsp+68h] [rbp-190h]
  float v13; // [rsp+70h] [rbp-188h]
  unsigned __int64 v14; // [rsp+98h] [rbp-160h]
  double v15; // [rsp+A0h] [rbp-158h]
  double v16; // [rsp+A8h] [rbp-150h]
  double v17; // [rsp+B0h] [rbp-148h]
  float src_[4]; // [rsp+B8h] [rbp-140h] BYREF
  float dst_[8]; // [rsp+C8h] [rbp-130h] BYREF
  float *src; // [rsp+E8h] [rbp-110h]
  __int64 (__fastcall *v21)(unsigned __int64, _BYTE *, _QWORD, _QWORD, char); // [rsp+F0h] [rbp-108h]
  double v22; // [rsp+F8h] [rbp-100h]
  double v23; // [rsp+100h] [rbp-F8h]
  double v24; // [rsp+108h] [rbp-F0h]
  double v25; // [rsp+110h] [rbp-E8h]
  double v26; // [rsp+118h] [rbp-E0h]
  double v27; // [rsp+120h] [rbp-D8h]
  double v28; // [rsp+128h] [rbp-D0h]
  double v29; // [rsp+130h] [rbp-C8h]
  double v30; // [rsp+138h] [rbp-C0h]
  double src__1[3]; // [rsp+140h] [rbp-B8h] BYREF
  double v32; // [rsp+158h] [rbp-A0h]
  double v33; // [rsp+160h] [rbp-98h]
  double v34; // [rsp+168h] [rbp-90h]
  double v35; // [rsp+170h] [rbp-88h]
  double dst__1[3]; // [rsp+178h] [rbp-80h] BYREF
  double v37; // [rsp+190h] [rbp-68h]
  _BYTE v38[96]; // [rsp+198h] [rbp-60h] BYREF

  v13 = *(float *)(a1 + 0x2DC) + *(float *)(a1 + 0x2E8);
  v12 = *(float *)(a1 + 0x2D8) + *(float *)(a1 + 0x2E4);
  src_[0] = *(float *)(a1 + 0x2D4) + *(float *)(a1 + 0x2E0);
  src_[1] = v12;
  src_[2] = v13;
  src = src_;
  qmemcpy(dst_, src_, 0xCu);
  dst_[4] = dst_[0] * 0.5;
  dst_[5] = dst_[1] * 0.5;
  dst_[6] = dst_[2] * 0.5;
  src__1[0] = (float)(dst_[0] * 0.5);
  src__1[1] = (float)(dst_[1] * 0.5);
  src__1[2] = (float)(dst_[2] * 0.5);
  v30 = 1.0;
  v27 = 0.0;
  v28 = 0.0;
  v29 = 0.0;
  v32 = 0.0;
  v33 = 0.0;
  v34 = 0.0;
  v35 = 1.0;
  qmemcpy(dst__1, src__1, sizeof(dst__1));
  v37 = 1.0;
  v14 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  v21 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, _QWORD, _QWORD, char))(*(_QWORD *)v14 + 0x1E8LL);
  v4 = 0;
  v5 = (double *)v21(v14, v38, a3, 0, v4);
  v22 = v5[1] * v34 - v5[2] * v33 + v5[3] * v32 + *v5 * v35;
  v23 = v5[2] * v32 - *v5 * v34 + v5[3] * v33 + v5[1] * v35;
  v24 = *v5 * v33 - v5[1] * v32 + v5[3] * v34 + v5[2] * v35;
  v25 = v5[3] * v35 - *v5 * v32 - v5[1] * v33 - v5[2] * v34;
  v17 = v5[1] * dst__1[2] - v5[2] * dst__1[1] + v5[3] * dst__1[0];
  v16 = v5[2] * dst__1[0] - *v5 * dst__1[2] + v5[3] * dst__1[1];
  v15 = *v5 * dst__1[1] - v5[1] * dst__1[0] + v5[3] * dst__1[2];
  v6 = v15 * v5[1] - v16 * v5[2];
  v7 = (v6 + v6 + dst__1[0]) * v5[7] + v5[4];
  v8 = v17 * v5[2] - v15 * *v5;
  v9 = (v8 + v8 + dst__1[1]) * v5[7] + v5[5];
  v10 = v16 * *v5 - v17 * v5[1];
  v11 = (v10 + v10 + dst__1[2]) * v5[7] + v5[6];
  v26 = v5[7] * v37;
  *a2 = v22;
  a2[1] = v23;
  a2[2] = v24;
  a2[3] = v25;
  a2[4] = v7;
  a2[5] = v9;
  a2[6] = v11;
  a2[7] = v26;
  return a2;
}

// --- End Function: sub_143CED060 (0x143CED060) ---

// --- Function: sub_143D1EDF0 (0x143D1EDF0) ---
bool __fastcall sub_143D1EDF0(__int64 a1)
{
  _QWORD v2[2]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v3; // [rsp+38h] [rbp-10h] BYREF

  _StarEngineModule__(0);
  sub_14156A3A0(v2, *(_QWORD *)(a1 + 8));
  v2[1] = v2[0];
  v3 = v2[0];
  return is_valid_handle_typeA(&v3);
}

// --- End Function: sub_143D1EDF0 (0x143D1EDF0) ---

// --- Function: sub_143D8B830 (0x143D8B830) ---
__int64 __fastcall sub_143D8B830(__int64 a1)
{
  const char *v2; // rax
  bool v3; // [rsp+28h] [rbp-E0h]
  bool v4; // [rsp+30h] [rbp-D8h]
  bool v5; // [rsp+31h] [rbp-D7h]
  float v6; // [rsp+38h] [rbp-D0h]
  float v7; // [rsp+40h] [rbp-C8h]
  float v8; // [rsp+44h] [rbp-C4h]
  float v9; // [rsp+48h] [rbp-C0h]
  __int64 v10; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v11; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v12; // [rsp+60h] [rbp-A8h]
  __int64 v13; // [rsp+68h] [rbp-A0h]
  __int64 v14; // [rsp+70h] [rbp-98h]
  __int64 (__fastcall *v15)(__int64, _BYTE *, _BYTE *, _QWORD, _DWORD, bool); // [rsp+78h] [rbp-90h]
  __int64 v16; // [rsp+80h] [rbp-88h] BYREF
  _BYTE v17[16]; // [rsp+88h] [rbp-80h] BYREF
  _BYTE dst_[24]; // [rsp+98h] [rbp-70h] BYREF
  double v19[11]; // [rsp+B0h] [rbp-58h] BYREF

  v11 = *(_QWORD *)(a1 + 0x398);
  if ( is_valid_handle_typeA(&v11) )
  {
    qmemcpy(dst_, sub_143CED060(a1, v19, 2u) + 4, sizeof(dst_));
    v4 = 0;
    sub_1434922F0(a1, &v10);
    if ( is_valid_handle_typeA(&v10) )
    {
      v14 = v10 & 0xFFFFFFFFFFFFLL;
      v4 = sub_1434F6DB0(v10 & 0xFFFFFFFFFFFFLL);
    }
    v5 = sub_143D1EDF0(a1);
    v6 = *(float *)(a1 + 0x6F0);
    if ( v6 >= 0.0 )
    {
      if ( v6 >= 1.0 )
        v7 = 1.0;
      else
        v7 = *(float *)(a1 + 0x6F0);
      v8 = v7;
    }
    else
    {
      v8 = 0.0;
    }
    v12 = v11 & 0xFFFFFFFFFFFFLL;
    v15 = *(__int64 (__fastcall **)(__int64, _BYTE *, _BYTE *, _QWORD, _DWORD, bool))(*(_QWORD *)(v11 & 0xFFFFFFFFFFFFLL)
                                                                                    + 0x578LL);
    if ( v5 && dword_149A0A9E0 )
      v9 = v8;
    else
      v9 = 0.0;
    sub_1402AE7E0((__int64)v17);
    v3 = v4;
    return v15(v12, dst_, v17, 0, LODWORD(v9), v3);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 8);
    v13 = sub_14030ECF0(&v16);
    v2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x70LL))(v13);
    return sub_1405C0E00(
             0xAu,
             0,
             "[%s] Trying to break a rock into pieces, but no breakable component is found on the entity '%s'",
             "CEntityComponentMineable::SpawnChildRocks",
             v2);
  }
}

// --- End Function: sub_143D8B830 (0x143D8B830) ---

// --- Function: sub_143D915F0 (0x143D915F0) ---
__int64 __fastcall sub_143D915F0(__int64 a1, unsigned int n2)
{
  __int64 v2; // rax
  __int64 *v3; // rax
  __int64 result; // rax
  char v5; // [rsp+22h] [rbp-106h]
  char buf_; // [rsp+23h] [rbp-105h] BYREF
  _BYTE v7[4]; // [rsp+24h] [rbp-104h] BYREF
  BOOL v8; // [rsp+28h] [rbp-100h]
  ULONG_PTR Parameter; // [rsp+30h] [rbp-F8h] BYREF
  __int64 v10; // [rsp+38h] [rbp-F0h] BYREF
  __int64 v11; // [rsp+40h] [rbp-E8h]
  unsigned __int64 v12; // [rsp+48h] [rbp-E0h]
  unsigned __int64 v13; // [rsp+50h] [rbp-D8h]
  __int64 v14; // [rsp+58h] [rbp-D0h]
  __int64 v15; // [rsp+60h] [rbp-C8h]
  __int64 v16; // [rsp+68h] [rbp-C0h]
  _QWORD *v17; // [rsp+70h] [rbp-B8h]
  __int64 v18; // [rsp+78h] [rbp-B0h] BYREF
  unsigned __int8 (__fastcall *v19)(unsigned __int64, __int64); // [rsp+80h] [rbp-A8h]
  __int64 (__fastcall *v20)(__int64, _QWORD); // [rsp+88h] [rbp-A0h]
  __int64 v21; // [rsp+90h] [rbp-98h]
  __int64 v22; // [rsp+98h] [rbp-90h] BYREF
  _QWORD *v23; // [rsp+A0h] [rbp-88h]
  __int64 *v24; // [rsp+A8h] [rbp-80h]
  __int64 (__fastcall *v25)(__int64, _QWORD); // [rsp+B0h] [rbp-78h]
  __int64 v26; // [rsp+B8h] [rbp-70h]
  Parameter *Parameter_1; // [rsp+C0h] [rbp-68h]
  __int64 v28; // [rsp+C8h] [rbp-60h]
  __int64 *v29; // [rsp+D0h] [rbp-58h]
  __int64 v30; // [rsp+D8h] [rbp-50h]
  __int64 v31; // [rsp+E0h] [rbp-48h]
  __int64 v32; // [rsp+E8h] [rbp-40h]
  _QWORD v33[2]; // [rsp+F0h] [rbp-38h] BYREF
  _BYTE v34[40]; // [rsp+100h] [rbp-28h] BYREF

  v12 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  v19 = *(unsigned __int8 (__fastcall **)(unsigned __int64, __int64))(*(_QWORD *)v12 + 0x40LL);
  if ( v19(v12, 1) )
    return sub_1405C0E00(
             0xAu,
             0,
             "![Mineable] %s cannot destroy editor-unremovable entities.",
             "CEntityComponentMineable::SvTryDestroy");
  v13 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v13 + 0x720LL))(v13) )
    return sub_1405C0E00(
             0xAu,
             0,
             "![Mineable] %s should only be called by the authoritative process!",
             "CEntityComponentMineable::SvTryDestroy");
  v14 = a1 + 0x300;
  *(_BYTE *)(a1 + 0x308) = 1;
  sub_1403C3BF0(v14);
  sub_143CE5D60(a1, 0, 0);
  if ( n2 != 1 || *(_BYTE *)(a1 + 0x320) || sub_143D1EBA0(a1) )
  {
    sub_143D8F980(a1, n2);
  }
  else
  {
    if ( !sub_143D1E160(a1) )
    {
      v5 = *(float *)(a1 + 0x6F0) < 0.5;
      v15 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
      v20 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v15 + 0x38LL);
      v23 = (_QWORD *)v20(v15, 0);
      v21 = a1 + 8;
      sub_1403B0A70((unsigned __int64 *)(a1 + 8), &v22);
      v24 = &v22;
      v2 = sub_143C3FBD0((__int64)v34, &v22, v23, v5);
      sub_143B89AB0(a1, v2);
    }
    sub_143D791D0(a1);
    sub_143D8B830(a1);
  }
  v16 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
  v25 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 0x38LL);
  v3 = (__int64 *)v25(v16, 0);
  sub_143CD8500(a1, *v3);
  v26 = a1 + 0x3A8;
  Parameter_1 = **(_QWORD **)(a1 + 0x3A8);
  Parameter = Parameter_1;
  _StarEngineModule__((ULONG_PTR)&Parameter);
  memset(&buf_, 0, sizeof(buf_));
  while ( 1 )
  {
    v8 = *(_BYTE *)(Parameter + 0x19) != 0;
    result = v8;
    if ( v8 )
      break;
    v17 = (_QWORD *)(Parameter + 0x20);
    if ( sub_14030EC00((unsigned __int64 *)(Parameter + 0x20)) )
    {
      v28 = sub_14030ECF0(v17);
      v29 = sub_143193C30(v28, v33);
      v30 = *v29;
      v18 = v30;
      if ( Handle::IsValid(&v18) )
      {
        v31 = v18 & 0xFFFFFFFFFFFFLL;
        sub_1434CFCA0(v18 & 0xFFFFFFFFFFFFLL, &v10);
        if ( is_valid_handle_typeA(&v10) )
        {
          v32 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA0);
          v11 = v33[1];
          if ( is_valid_handle_typeA(&v10) )
            v11 = v10 & 0xFFFFFFFFFFFFLL;
          else
            v11 = 0;
          sub_143B7F9B0(v32, v11, (__int64)v7);
        }
      }
    }
    sub_142BB3820((__int64)&Parameter);
  }
  return result;
}

// --- End Function: sub_143D915F0 (0x143D915F0) ---

