// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1460B14E0 (sub_1460B14E0)
// Caller Depth: 2
// Callee/Ref Depth: 3
// Total Functions Found: 324
// ------------------------------------------------------------

// --- Function: sub_1402A4B80 (0x1402A4B80) ---
__int64 __fastcall sub_1402A4B80(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1402A4B80 (0x1402A4B80) ---

// --- Function: sub_1402A4CF0 (0x1402A4CF0) ---
__int64 __fastcall sub_1402A4CF0(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A4CF0 (0x1402A4CF0) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A4F00) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A4F00) ---

// --- Function: sub_1402A5160 (0x1402A5160) ---
__int64 __fastcall sub_1402A5160(_QWORD *a1)
{
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 result; // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *))a1[1];
  if ( (unsigned __int64)n2 < 2 )
  {
    result = 0;
    *a1 = 0;
  }
  else
  {
    n2(2, a1);
    result = 0;
    a1[1] = 0;
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_1402A5160 (0x1402A5160) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A5810) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A5810) ---

// --- Function: __StarEngineModule__ (0x1402A5B50) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A5B50) ---

// --- Function: sub_1402A63C0 (0x1402A63C0) ---
__int64 __fastcall sub_1402A63C0(__int64 a1)
{
  return sub_14753C530(a1, (unsigned int)dword_1497E7C00);
}

// --- End Function: sub_1402A63C0 (0x1402A63C0) ---

// --- Function: sub_1402A63D0 (0x1402A63D0) ---
__int64 __fastcall sub_1402A63D0(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: sub_1402A63D0 (0x1402A63D0) ---

// --- Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A6420) ---
unsigned __int8 *__fastcall AK::WriteBytesMem::Bytes(AK::WriteBytesMem *this)
{
  return (unsigned __int8 *)*((_QWORD *)this + 2);
}

// --- End Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A6420) ---

// --- Function: sub_1402A6A10 (0x1402A6A10) ---
__int64 *sub_1402A6A10()
{
  return &qword_1499FEA00;
}

// --- End Function: sub_1402A6A10 (0x1402A6A10) ---

// --- Function: ??$initialize_from_array@$$BY00Q6AXPEB_W00I_K@Z@?$dual_state_global@P6AXPEB_W00I_K@Z@__crt_state_management@@QEAAXAEAY00Q6AXPEB_W00I_K@Z@Z (0x1402A8480) ---
__int64 __fastcall __crt_state_management::dual_state_global<void (*)(wchar_t const *,wchar_t const *,wchar_t const *,unsigned int,unsigned __int64)>::initialize_from_array<void (*[1])(wchar_t const *,wchar_t const *,wchar_t const *,unsigned int,unsigned __int64)>(
        __int64 *a1,
        __int64 *a2)
{
  __int64 result; // rax

  result = *a2;
  *a1 = *a2;
  return result;
}

// --- End Function: ??$initialize_from_array@$$BY00Q6AXPEB_W00I_K@Z@?$dual_state_global@P6AXPEB_W00I_K@Z@__crt_state_management@@QEAAXAEAY00Q6AXPEB_W00I_K@Z@Z (0x1402A8480) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8DA0) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  __int64 v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10(this);
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)sub_1402A63D0(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E2610();
  v13 = sub_1402A63D0(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(_QWORD *)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A63C0(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8DA0) ---

// --- Function: sub_1402ABCE0 (0x1402ABCE0) ---
const void **__fastcall sub_1402ABCE0(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  size_t Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  size_t v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  __int64 v17; // rbx

  Size_1 = (size_t)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = Size_1 + a2;
  v11 = (Size_1 + a2) | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
        v15 = 0;
      else
        v15 = (_QWORD *)sub_1402A63D0(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 0x28;
    if ( v6 + 0x28 < (unsigned __int64)(v6 + 1) )
      sub_1402E2610();
  }
  v14 = sub_1402A63D0(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v15[0xFFFFFFFF] = v14;
LABEL_15:
  Src[2] = (const void *)v10;
  v16 = (char *)v15 + Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, Size_1);
    memcpy((char *)v15 + Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = (__int64)*Src;
  memcpy(v15, *Src, Size_1);
  memcpy((char *)v15 + Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v17 - *(_QWORD *)(v17 - 8) - 8) <= 0x1F )
    {
      v17 = *(_QWORD *)(v17 - 8);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A63C0(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402ABCE0 (0x1402ABCE0) ---

// --- Function: sub_1402AE1F0 (0x1402AE1F0) ---
// attributes: thunk
void __fastcall sub_1402AE1F0(void *a1)
{
  sub_1403727A0(a1);
}

// --- End Function: sub_1402AE1F0 (0x1402AE1F0) ---

// --- Function: unknown_libname_472 (0x1402B06C0) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_472(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_472 (0x1402B06C0) ---

// --- Function: sub_1402B07F0 (0x1402B07F0) ---
_QWORD *__fastcall sub_1402B07F0(_QWORD *a1, __int64 a2, __int64 a3, char a4)
{
  int v8; // esi
  unsigned __int32 v9; // eax

  *a1 = a3;
  v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a3 + 4) == v8 )
  {
    ++*(_DWORD *)(a3 + 8);
  }
  else
  {
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a3, 1, 0);
    if ( v9 )
      sub_1403C51B0((volatile signed __int32 *)a3, v9, a2, a4);
    *(_DWORD *)(a3 + 4) = v8;
  }
  return a1;
}

// --- End Function: sub_1402B07F0 (0x1402B07F0) ---

// --- Function: sub_1402B0CA0 (0x1402B0CA0) ---
__int64 __fastcall sub_1402B0CA0(__int64 a1)
{
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

// --- End Function: sub_1402B0CA0 (0x1402B0CA0) ---

// --- Function: sub_1402B39B0 (0x1402B39B0) ---
_QWORD *__fastcall sub_1402B39B0(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return a1;
}

// --- End Function: sub_1402B39B0 (0x1402B39B0) ---

// --- Function: sub_1402B3A40 (0x1402B3A40) ---
void __fastcall sub_1402B3A40(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: sub_1402B3A40 (0x1402B3A40) ---

// --- Function: sub_1402B3A70 (0x1402B3A70) ---
_QWORD *__fastcall sub_1402B3A70(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

// --- End Function: sub_1402B3A70 (0x1402B3A70) ---

// --- Function: sub_1402B3C20 (0x1402B3C20) ---
__int64 __fastcall sub_1402B3C20(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  __int64 result; // rax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 8);
  if ( v2 )
  {
    result = (unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 8) = result;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = 0xFFFFFFFF;
    result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( (_DWORD)result != 1 )
      return sub_1403DCC00((volatile signed __int32 *)v1, result);
  }
  return result;
}

// --- End Function: sub_1402B3C20 (0x1402B3C20) ---

// --- Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B6F20) ---
bool __fastcall std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B6F20) ---

// --- Function: ?_HasCapturedContext@_ContextCallback@details@Concurrency@@QEBA_NXZ (0x1402B7470) ---
bool __fastcall Concurrency::details::_ContextCallback::_HasCapturedContext(
        Concurrency::details::_ContextCallback *this)
{
  return *(_QWORD *)this != 0;
}

// --- End Function: ?_HasCapturedContext@_ContextCallback@details@Concurrency@@QEBA_NXZ (0x1402B7470) ---

// --- Function: NtCurrentTeb_w (0x1402C8360) ---
__int64 sub_1402C8360()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C8360) ---

// --- Function: sub_1402C90E0 (0x1402C90E0) ---
__int64 sub_1402C90E0()
{
  return qword_149A142B0;
}

// --- End Function: sub_1402C90E0 (0x1402C90E0) ---

// --- Function: sub_1402CC2B0 (0x1402CC2B0) ---
__int64 __fastcall sub_1402CC2B0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
      break;
    v4 = 0;
    if ( (int)result < 0 )
      v4 = a1;
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402CC2B0 (0x1402CC2B0) ---

// --- Function: sub_1402CEFE0 (0x1402CEFE0) ---
__int64 __fastcall sub_1402CEFE0(__int64 a1, __int64 a2, char a3)
{
  __int64 result; // rax
  int v7; // edi

  result = NtCurrentTeb_w();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 4) == v7 )
  {
    ++*(_DWORD *)(a1 + 8);
  }
  else
  {
    result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( (_DWORD)result )
      result = sub_1403C51B0((volatile signed __int32 *)a1, result, a2, a3);
    *(_DWORD *)(a1 + 4) = v7;
  }
  return result;
}

// --- End Function: sub_1402CEFE0 (0x1402CEFE0) ---

// --- Function: sub_1402D42F0 (0x1402D42F0) ---
__int64 __fastcall sub_1402D42F0(__int64 a1)
{
  __int64 result; // rax
  signed __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(result + 0x18) && (result = *(unsigned int *)(a1 + 0xC), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 0xC) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CD3A0(a1);
    }
  }
  return result;
}

// --- End Function: sub_1402D42F0 (0x1402D42F0) ---

// --- Function: sub_1402D4390 (0x1402D4390) ---
__int64 __fastcall sub_1402D4390(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
      break;
    ++a4;
    if ( (a1 & 1) != 0 )
      a3 |= 1 << (a2 - v4);
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D4390 (0x1402D4390) ---

// --- Function: sub_1402E3480 (0x1402E3480) ---
__int64 __fastcall sub_1402E3480(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
      break;
    v5 = v4 + 0x20;
    if ( (unsigned __int8)(v4 - 0x41) > 0x19u )
      v5 = v4;
    v6 = sub_1402D4390(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402CC2B0(0x4C11DB7, 1, (v6 << 0x19) ^ (unsigned int)((unsigned __int64)(v6 << 0x18) >> 0x1F) & 0x4C11DB7);
    v8 = sub_1402D4390(v7 >> 1, 0x20, v7 << 0x1F, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402E3480 (0x1402E3480) ---

// --- Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E38F0) ---
_QWORD *__fastcall std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
        _QWORD *a1,
        _QWORD *a2)
{
  *a2 = *a1;
  return a2;
}

// --- End Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E38F0) ---

// --- Function: NtCurrentTeb_ww (0x1402E3990) ---
bool __fastcall sub_1402E3990(__int64 a1)
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E3990) ---

// --- Function: NtCurrentTeb_ww_0 (0x1402E39B0) ---
__int64 sub_1402E39B0()
{
  return *(unsigned __int8 *)(NtCurrentTeb_w() + 0x25);
}

// --- End Function: NtCurrentTeb_ww_0 (0x1402E39B0) ---

// --- Function: fprintf (0x1402F8910) ---
int fprintf(FILE *File, const char *Format, ...)
{
  __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_1402A6A10();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F8910) ---

// --- Function: sub_1402FC640 (0x1402FC640) ---
void *__fastcall sub_1402FC640(_QWORD *a1, const void *a2, size_t Size)
{
  __int64 n0x16; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n0x16 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 0xF;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_1402A63D0(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    v10[0xFFFFFFFF] = v9;
    goto LABEL_17;
  }
  n0x16 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n0x16 = 0x16;
  if ( (unsigned __int64)(n0x16 + 1) >= 0x1000 )
  {
    allocSize = n0x16 + 0x28;
    if ( n0x16 + 0x28 < (unsigned __int64)(n0x16 + 1) )
      sub_1402E2610();
    goto LABEL_6;
  }
  if ( n0x16 == 0xFFFFFFFFFFFFFFFFuLL )
    v10 = 0;
  else
    v10 = (_QWORD *)sub_1402A63D0(n0x16 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n0x16;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FC640 (0x1402FC640) ---

// --- Function: sub_1402FF400 (0x1402FF400) ---
__int64 __fastcall sub_1402FF400(char *a1, char *a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n0x100; // rax
  char *v7; // r15
  char *v8; // rdi
  char *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  char *v30; // rsi
  int v31; // [rsp+20h] [rbp-48h]
  char *v32; // [rsp+30h] [rbp-38h] BYREF
  char *v33; // [rsp+38h] [rbp-30h]
  __int64 v34; // [rsp+70h] [rbp+8h] BYREF

  n0x100 = (a2 - a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( v8 != v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 0x50) < *(_QWORD *)(*(_QWORD *)v8 + 0x50LL) )
          {
            n0x100 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i + 0xFFFFFFFF);
              i += 0xFFFFFFF8;
              n0x100 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n0x100 )
              {
                if ( *(_QWORD *)(v14 + 8) != n0x100 )
                  break;
                n0x100 = *(_QWORD *)(v17 + 0x50);
                if ( *(_QWORD *)(v14 + 0x50) >= (unsigned __int64)n0x100 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FED20(&v32, v8, v7, a4);
      v9 = v32;
      v10 = v33;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((v32 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - v33) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FF400(v33, v7, a3, a4);
        v7 = v9;
      }
      else
      {
        sub_1402FF400(v8, v32, a3, a4);
        v8 = v10;
      }
      n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    v18 = (v7 - v8) >> 3;
    v19 = (v7 - v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 0x50) < *(_QWORD *)(v25 + 0x50) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 0x50) >= *(_QWORD *)(v21 + 0x50)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v30 = v7 + 0xFFFFFFF8;
      do
      {
        v34 = *(_QWORD *)v30;
        *(_QWORD *)v30 = *(_QWORD *)v8;
        LOBYTE(v31) = a4;
        sub_1402FEFE0(v8, 0, (v30 - v8) >> 3, &v34, v31);
        v30 += 0xFFFFFFF8;
        n0x100 = (unsigned __int64)&v30[8LL - (_QWORD)v8] & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n0x100 >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_1402FF400 (0x1402FF400) ---

// --- Function: sub_140300900 (0x140300900) ---
_QWORD *__fastcall sub_140300900(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __int64 p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __int64 p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)sub_1402A63D0(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)sub_1402A63D0(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    memset(&Src, 0, sizeof(Src));
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FC640(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402ABCE0((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(_QWORD *)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = (__m256 *)p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = sub_1402A63D0(0x30u);
      *(_QWORD *)(v23 + 0x20) = 0;
      *(_QWORD *)(v23 + 0x28) = 0;
      *(__m256 *)(v23 + 0x10) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 0xF;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x10LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x28LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(_QWORD *)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
        if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A63C0(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140300900 (0x140300900) ---

// --- Function: sub_1403011F0 (0x1403011F0) ---
bool __fastcall sub_1403011F0(__int64 a1, _QWORD *a2, __int64 *a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  __int64 __Val_0___1; // r10
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // bp
  __int64 v18; // rdi
  __int64 v19; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v21; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v23; // rdi
  unsigned __int64 v24; // r9
  char v25; // al
  __int64 v26; // r8
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rax
  unsigned __int64 v30; // [rsp+20h] [rbp-48h]
  bool v32; // [rsp+80h] [rbp+18h]

  v7 = sub_140301FF0(*((unsigned int *)a3 + 9), a2, a3[3], a1);
  if ( v9 + v7 > v10 )
    return 0;
  v13 = *((unsigned int *)a3 + 8);
  v17 = 0;
  if ( (_DWORD)v13 != 1 )
  {
    v14 = sub_140301FF0(v13, v8, v9, v10);
    if ( v15 + v14 < v16 )
      v17 = 1;
  }
  v18 = a3[1];
  v19 = *a3;
  v32 = v17;
  if ( (v18 - *a3) / 0x70 != _Newcapacity )
  {
    if ( v19 != v18 )
    {
      do
      {
        if ( *(_BYTE *)(v19 + 0x58) && *(_QWORD *)v19 )
          (*(void (**)(void))(v19 + 0x40))();
        v19 += 0x70;
      }
      while ( v19 != v18 );
      a3[1] = *a3;
    }
    sub_1402FF0D0(a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v17 = 1;
    v32 = 1;
  }
  _Newcapacity_2 = 0;
  v21 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v23 = __Val_0___1 + 0x30;
    v24 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v30 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v17 )
    {
      v21 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v23 + 0x18)
        && *(_QWORD *)v23 )
      {
        if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_1 )
          __debugbreak();
        v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v23)(*(_QWORD *)(v23 - 0x30), *(_QWORD *)(v24 + v23 + *a3));
        v24 = v30;
        v17 = v25 == 0;
        v32 = v25 == 0;
      }
      ++_Newcapacity_1;
      v23 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v17 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v27 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v21 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v27 + 0x38)
          && *(_QWORD *)(v27 + 0x20) )
        {
          if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_2 )
            __debugbreak();
          v28 = v27 + v26 + *a3;
          if ( *(_BYTE *)(v28 + 0x58) )
          {
            if ( *(_QWORD *)v28 )
              (*(void (**)(void))(v28 + 0x40))();
          }
          v29 = (*(__int64 (__fastcall **)(_QWORD))(v27 + 0x38))(*(_QWORD *)(v27 - 0x10));
          v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v28 = v29;
          *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 - 8);
          *(_QWORD *)(v28 + 0x10) = *(_QWORD *)v27;
          *(_QWORD *)(v28 + 0x18) = *(_QWORD *)(v27 + 8);
          *(_QWORD *)(v28 + 0x20) = *(_QWORD *)(v27 + 0x10);
          *(_QWORD *)(v28 + 0x30) = *(_QWORD *)(v27 + 0x20);
          *(_QWORD *)(v28 + 0x28) = *(_QWORD *)(v27 + 0x18);
          *(_QWORD *)(v28 + 0x38) = *(_QWORD *)(v27 + 0x28);
          *(_QWORD *)(v28 + 0x40) = *(_QWORD *)(v27 + 0x30);
          *(_QWORD *)(v28 + 0x48) = *(_QWORD *)(v27 + 0x38);
          *(_QWORD *)(v28 + 0x50) = *(_QWORD *)(v27 + 0x40);
          *(_QWORD *)(v28 + 0x60) = *(_QWORD *)(v27 + 0x50);
          *(_QWORD *)(v28 + 0x68) = *(_QWORD *)(v27 + 0x58);
          *(_BYTE *)(v28 + 0x58) = 1;
          *(_BYTE *)(v28 + 0x59) = *(_BYTE *)(v27 + 0x49);
        }
        ++_Newcapacity_2;
        v27 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v17 = v32;
    }
    a3[3] = a1;
  }
  return v17;
}

// --- End Function: sub_1403011F0 (0x1403011F0) ---

// --- Function: sub_140301EF0 (0x140301EF0) ---
__int64 __fastcall sub_140301EF0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", v3 - 0x3E8 * v7) + 0x13);
}

// --- End Function: sub_140301EF0 (0x140301EF0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140301FB0) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_1499FF110 )
    result = qword_1499FF110(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_1499FF128 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_1499FF130 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140301FB0) ---

// --- Function: sub_140303880 (0x140303880) ---
__int64 __fastcall sub_140303880(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        __int64 a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *a11,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  __int64 *v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *v26; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  __int64 v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *v66; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *v75; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  unsigned int v87[2]; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_1497E7708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_1497E7720[0];
  }
  else
  {
    v17 = off_1497E7728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = &off_1497E7738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_1497E7710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( a11 )
    {
      if ( off_1497E7710 )
      {
        memcpy(a11, off_1497E7710, Size_1);
        goto LABEL_15;
      }
      memset(a11, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&a11[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  a11[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_1402FFCB0((_DWORD)a11, Size, (int)Size_1 + 1, (unsigned int)v87, (__int64)v21, (__int64)&off_1497E7710, "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_1497E7710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_1497E7710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  v26 = a11;
  Size_3 = Size - Sizea_1;
  v28 = &a11[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_1497E7710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_1497E7710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    v26 = a11;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &v26[v29];
  Size_4 = Size - v29;
  if ( !&v26[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    v26 = a11;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_1497E7730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_1497E7730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &v26[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_1497E7730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_1497E7730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    v26 = a11;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &v26[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    v26 = a11;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_1497E7710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  *(_QWORD *)v87 = v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_1497E7710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &v26[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_1497E7710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_1497E7710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = *(_QWORD *)v87;
    v26 = a11;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &v26[v45];
  n2 = Size - v45;
  if ( &v26[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  v26 = a11;
LABEL_103:
  v48 = v45 + 2;
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( Size_11 + v48 >= Size )
    goto LABEL_124;
  v50 = &v26[v48];
  Size_12 = Size - v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140306940((_DWORD)a11, Size, Sizea_1, a7, (__int64)__Val_0__, _Newcapacity, a10, 0, (__int64)sub_1402FE850);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &a11[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_1497E7710;
      *(_QWORD *)v87 = qword_1499FEDC0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_1497E7710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      v66 = a11;
      Size_15 = Size - Sizea_1;
      v68 = &a11[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &v66[Size_13] )
            {
              if ( Size != Size_13 )
              {
                v66[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_1402FFCB0(
                        (_DWORD)a11,
                        Size,
                        (int)Size_13 + 1,
                        (unsigned int)&off_1497E7718,
                        *(_QWORD *)v87 + Sizec,
                        (__int64)&off_1497E7710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_1497E7710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_1497E7710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      v66 = a11;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  v75 = a11;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &a11[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    v75 = a11;
    v58 = 1;
  }
  else
  {
    a11[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &v75[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&v75[Size - 4] = 0x2E2E;
      v75[Size - 2] = 0x2E;
    }
  }
  else
  {
    v75[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  v75[Size - 1] = 0;
  if ( v78 )
    qword_1499FF128(a2, a3, n4, v75, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140303880 (0x140303880) ---

// --- Function: sub_140304380 (0x140304380) ---
__int64 __fastcall sub_140304380(
        __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        _BYTE *Src,
        __int64 a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        __int64 a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_27; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  int n0xF_8; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  int v76; // r15d
  int v77; // r14d
  int v78; // eax
  int v79; // eax
  int n0xF_10; // ebp
  int n0xF_11; // r14d
  int n0xF_12; // r15d
  int n0xF_13; // edx
  _BYTE *Src_2; // r14
  int v85; // eax
  int n0xF_14; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_15; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_16; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_17; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_23; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_19; // edx
  int n0xF_20; // ecx
  bool v109; // r15
  int n0xF_21; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_24; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_25; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_26; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  __int64 *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  int n0xF_9; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  int n0xF_18; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_22; // [rsp+98h] [rbp-D0h]
  __int64 n0xF_5; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  __int64 v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  _BYTE *Src_1; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, _BYTE *, _QWORD *, __int64, _QWORD, __int64, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  Src_1 = Src;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 0x80;
  LODWORD(n0xF_5) = n4;
  v159 = a6;
  n0xF_22 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_27 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_1402FFBF0(Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_27 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_27;
  if ( n0xF_27 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_27 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_1499FF138 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_1499FF138(
              v162,
              v161,
              n4_1,
              Src_1,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_1499FF130;
  v156 = v50;
  v51 = (a18 & 1) != 0 && ::n2 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_0 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_356;
  if ( qword_1499FF108 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_9 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_96;
    }
    v53 = qword_1499FF108((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_1499FF108, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_9 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_9 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_8 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_140300130(
            Buffer,
            n0xF_3,
            n0xF_2,
            (unsigned int)",\"@severity\":",
            &n0xF_5,
            ",\"severity\":\"",
            (__int64)&off_1497E7738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_97;
  }
LABEL_96:
  v47 = 1;
LABEL_97:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_146;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_135;
  do
  {
    LODWORD(n0xF_5) = n0xF_8;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_132;
    v63 = qword_1499FEDC0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_132;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_106:
      invalid_parameter_noinfo();
      goto LABEL_107;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_106;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_107:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_22 )
    {
LABEL_130:
      n0xF_3 = n0xF + 0x80;
LABEL_131:
      n0xF_6 = n0xF_7;
      n0xF_8 = n0xF_5;
      v62 = v160;
      v58 = v159;
      goto LABEL_132;
    }
    Size_7 = n0xF_22 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_112;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_120;
      }
      memset(v69, 0, n0xF_22 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_120;
        *errno() = 0x22;
      }
      else
      {
LABEL_112:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_120:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_130;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_22 )
      goto LABEL_131;
    n2 = n0xF_22 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_128;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_128:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_8 = n0xF_5;
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_133;
    }
LABEL_132:
    v47 = 1;
LABEL_133:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_9 = n0xF_8;
LABEL_135:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_149;
  v76 = qword_1499FEDC0;
  v77 = *(_DWORD *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_158;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_142;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_142:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_1402FFE60(Buffer, n0xF_3, n0xF_2 + 1, v76 + 8 * v77, "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_158:
    n0xF_10 = n0xF_8;
    n0xF_11 = n0xF_6;
    v47 = 1;
    n0xF_12 = n0xF_2;
    n0xF_13 = n0xF_2;
    goto LABEL_147;
  }
  n0xF_2 += v79;
  n0xF_9 = n0xF_8;
LABEL_146:
  n0xF_10 = n0xF_8;
  n0xF_11 = n0xF_6;
  n0xF_12 = n0xF_2;
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_149:
    v47 = 1;
  }
  else
  {
LABEL_147:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_13;
      n0xF_9 = n0xF_8;
      goto LABEL_149;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_164;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_164:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_9 = n0xF_10;
    n0xF_2 = n0xF_12 + 0xB;
    n0xF_6 = n0xF_11;
    n0xF_8 = n0xF_10;
  }
  if ( *Src_1 )
  {
    Src_2 = Src_1;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140302100((char *)Buffer + n0xF_2, n0xF - n0xF_2, (unsigned __int8)*Src_2);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_14 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_14 = n0xF_2;
        n0xF_2 = n0xF_14;
      }
      ++Src_2;
    }
    while ( *Src_2 );
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_172:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_9 = n0xF_8;
      goto LABEL_172;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_186;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_186:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_9 = n0xF_8;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140302100((char *)Buffer + n0xF_2, n0xF - n0xF_2, *(unsigned __int8 *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_15 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_15 = n0xF_2;
        n0xF_2 = n0xF_15;
      }
    }
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_209:
    v47 = 1;
    goto LABEL_210;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_200:
        ++n0xF_2;
        goto LABEL_201;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_200;
  }
  v47 = 1;
LABEL_201:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_209;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_208;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_208:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_210:
  n0xF_16 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140306940((_DWORD)Buffer, n0xF, n0xF_2, v164, __Val_0___1, _Newcapacity, a11, 1, (__int64)sub_1402FE890);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_16;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_224;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_224:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_17 = n0xF_29;
  v102 = 0;
  n0xF_5 = 0;
  v103 = 0;
  n0xF_23 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_23);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_8 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_18 = n0xF_8;
              n0xF_19 = n0xF_2;
              n0xF_20 = n0xF_8;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_21 = n0xF_2;
              goto LABEL_250;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_238;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_238:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_249:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_19 = n0xF_2;
            n0xF_18 = n0xF_8;
            n0xF_20 = n0xF_8;
            n0xF_21 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_8 )
            {
LABEL_250:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_22 )
              {
                v105 = v160;
                n0xF_8 = n0xF_20;
                n0xF_2 = n0xF_19;
                v102 = v109;
                v114 = v106;
                goto LABEL_285;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_257;
              }
              if ( n0xF_22 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_257:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_282;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_263;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_271;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_263:
                  *errno() = 0x16;
                  goto LABEL_270;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_270:
                  invalid_parameter_noinfo();
                }
LABEL_271:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_282:
                n0xF_8 = n0xF_18;
                n0xF_2 = n0xF_21;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_279;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_279:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_8 = n0xF_18;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_21;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_21;
                  goto LABEL_286;
                }
              }
              v105 = v160;
            }
LABEL_285:
            v47 = 1;
LABEL_286:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_8 && n0xF_2 + 1LL < n0xF_22 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_294;
                }
                if ( n0xF_22 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_294:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_308:
                Buffer_3 = Buffer;
                goto LABEL_309;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_23 = n0xF_5;
            goto LABEL_308;
          }
LABEL_284:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_285;
        }
        if ( n0xF_2 >= n0xF_8 )
          goto LABEL_284;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_20 = n0xF_8;
          n0xF_18 = n0xF_8;
          v47 = 1;
          n0xF_19 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_21 = n0xF_2;
          goto LABEL_250;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_247;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_247:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_249;
      }
      if ( !v103 || n0xF_23 >= n0xF_17 )
        goto LABEL_308;
      if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_308;
      }
      n0xF_24 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_24 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_309;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_309:
      n0xF_25 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_25;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_316;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_8 )
      {
        v47 = 1;
LABEL_316:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_22 )
        {
          v47 = 1;
          goto LABEL_317;
        }
        Size_15 = n0xF_22 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_333;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_333:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_317:
      n0xF_17 = n0xF_29;
      if ( (n0xF_23 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_338;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_338:
            invalid_parameter_noinfo();
            n0xF_17 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      n0xF_5 = ++n0xF_23;
      if ( n0xF_23 >= n0xF_17 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( (int)a19 <= 1 )
  {
LABEL_345:
    if ( v47 && n0xF_2 < n0xF_8 )
      goto LABEL_347;
  }
  else if ( n0xF_2 < n0xF_8 )
  {
    v137 = sub_1402FFFB0(Buffer, n0xF_3, n0xF_2, (unsigned int)",\"EVT_COUNT\":", (__int64)&a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_345;
    }
LABEL_347:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_353;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_353:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_356:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_1499FF140 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_1499FF140(
                 a18,
                 v162,
                 v161,
                 n4,
                 Src_1,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_371;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_370;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_368;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_368:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_371:
    n0xF_26 = n0xF_2;
  }
  else
  {
LABEL_370:
    n0xF_26 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (__int64 *)n0xF_26;
    v147 = v161;
    qword_1499FF130(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      Src_1,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140304380 (0x140304380) ---

// --- Function: sub_140305A10 (0x140305A10) ---
void __fastcall sub_140305A10(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)sub_1402A63D0(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E2610();
      v8 = sub_1402A63D0(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_140305A10 (0x140305A10) ---

// --- Function: sub_140305B00 (0x140305B00) ---
char __fastcall sub_140305B00(
        int n4_1,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 __Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // r14
  char result; // al
  unsigned __int64 n0x10; // rax
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v17; // r13
  char *v18; // r15
  __int64 v19; // r14
  const vraudio::AudioBuffer *__Val_0___2; // rdi
  unsigned __int8 v21; // si
  const vraudio::AudioBuffer *__Val_0___5; // r15
  __int64 *v23; // rax
  __int64 *v24; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v26; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v30; // r13
  __int64 (__fastcall *v31)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v32; // rax
  unsigned __int64 v33; // rcx
  __int64 *v34; // rdi
  _QWORD *v35; // r13
  bool v36; // zf
  _QWORD *v37; // rbx
  _QWORD *v38; // rax
  _BYTE *v39; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v42; // r9
  __int64 v43; // rcx
  __m256 *v44; // r14
  char *v45; // r14
  const vraudio::AudioBuffer *__Val_0___4; // r12
  unsigned __int64 n0xF; // r13
  __int64 Buf2_1; // r15
  _QWORD *v49; // r14
  _QWORD *v50; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v55; // rax
  __int64 *v56; // rcx
  __int64 v57; // rcx
  _QWORD *v58; // rbx
  __int64 v59; // rcx
  __int64 *v60; // r14
  __int64 Buf2_2; // rax
  __int64 *v62; // rax
  unsigned __int64 n0x400_3; // r15
  __int64 v64; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v68; // rax
  char *v69; // r11
  __int64 v70; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v72; // rdi
  int v73; // r13d
  __int64 v74; // rcx
  __int64 v75; // r9
  unsigned __int64 n0x400_4; // r8
  __int64 v77; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v82; // rax
  __int64 v83; // r15
  char *v84; // r14
  __int64 v85; // rax
  void *v86; // rsp
  __int64 (__fastcall *v87)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v88; // edx
  int v89; // r12d
  char v90; // cl
  int v91; // eax
  FILE *File; // rax
  int n2; // r8d
  FILE *File_1; // rax
  char v95; // al
  bool v96; // dl
  bool v97; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v99; // rax
  unsigned __int64 n0x8000_2; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v104; // rax
  void *v105; // rsp
  char v106; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v109; // rsi
  _QWORD **v110; // rcx
  _QWORD *v111; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v113; // rdi
  __int64 v114; // rcx
  __int64 *v115; // rbx
  __int64 v116; // rcx
  int v117; // [rsp+90h] [rbp-10h]
  unsigned __int8 v118; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0x400_2; // [rsp+A8h] [rbp+8h]
  __int64 *v120; // [rsp+B0h] [rbp+10h]
  __int64 v121; // [rsp+B8h] [rbp+18h]
  int n4; // [rsp+C0h] [rbp+20h]
  __int64 v123; // [rsp+C8h] [rbp+28h] BYREF
  unsigned __int64 v124; // [rsp+D0h] [rbp+30h]
  char *v125; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  __int64 __Val_0___7; // [rsp+F0h] [rbp+50h]
  int v129[2]; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0__; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v131; // [rsp+108h] [rbp+68h] BYREF
  __int64 __Val_0___3; // [rsp+110h] [rbp+70h]
  __int64 v133; // [rsp+118h] [rbp+78h]
  void *Src; // [rsp+120h] [rbp+80h]
  __int64 v135; // [rsp+128h] [rbp+88h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+130h] [rbp+90h]
  _QWORD *v137; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___1; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v142; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v143; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v144; // [rsp+170h] [rbp+D0h]
  __m256 v145; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v147[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v148[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v133 = a4;
  Src = Src_1;
  v135 = a2;
  n4 = n4_1;
  __Val_0___7 = __Val_0___8;
  if ( qword_1499FF0A8 )
  {
    v12 = qword_1499FF0A8();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  *(_QWORD *)v129 = v12;
  if ( v11 )
  {
    result = sub_1403011F0(v12, v10, v11, __Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_1499FF100 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_1499FF100)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1499FF170++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_140301EF0(Buffer, 0x20u, v12);
  v143 = (__int64 *)&v142;
  n0x10 = 0;
  v142 = 0;
  v15 = 0;
  v120 = 0;
  n0x400 = 0;
  n0x400_2 = 0;
  v17 = 0;
  v121 = 0;
  v18 = 0;
  n0x10_1 = 0;
  v19 = 0;
  v125 = 0;
  v123 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v72 = (char *)v148;
    goto LABEL_106;
  }
  __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___7;
  v21 = v118;
  __Val_0___3 = __Val_0___7;
  while ( 2 )
  {
    __Val_0___5 = __Val_0___2;
    if ( *((_BYTE *)__Val_0___2 + 0x59) && n0x10 < 0x10 )
    {
      v147[n0x10++] = __Val_0___2;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0__ = (unsigned __int64)__Val_0___2;
    if ( n0x400 < 0x400 )
    {
      v148[n0x400] = __Val_0___2;
LABEL_30:
      n0x400_2 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1497E7748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v23 = (__int64 *)sub_1402A63D0(0x18u);
        v15 = v23;
        v120 = v23;
        if ( v23 )
        {
          v24 = v23;
          *v23 = 0;
          n0x400_1 = 0;
          v23[1] = 0;
          v26 = (__int64)v23;
          v23[2] = 0;
        }
        else
        {
          v15 = 0;
          v24 = 0;
          n0x400_1 = 0;
          v120 = 0;
          v26 = 0;
        }
        sub_140305A10(v26, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v148;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v24[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v24[2] )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              (std::vector<vraudio::AudioBuffer const *> *)v15,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v24[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0x400_2;
        __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
        v19 = v123;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v15[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v15[2] )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          (std::vector<vraudio::AudioBuffer const *> *)v15,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0__);
      }
      else
      {
        *_Whereptr_1 = __Val_0___2;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v121 = *((_QWORD *)__Val_0___2 + 0xD) + v17;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___2 + 1) = sub_140300900(&v143, (__int64)__Val_0___2);
    v30 = v19;
    v31 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___2 + 7);
    v144 = v19++;
    v123 = v19;
    if ( !v31 )
    {
      v69 = v125;
      goto LABEL_98;
    }
    __Val_0__ = 0;
    v131 = 0;
    v32 = v31(*(_QWORD *)__Val_0___2, &v131, &__Val_0__);
    v33 = 0;
    v124 = 0;
    if ( !v131 )
      goto LABEL_94;
    v34 = v143;
    v35 = (_QWORD *)(v32 + 0x10);
    v137 = (_QWORD *)(v32 + 0x10);
    do
    {
      __Val_0___5 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      __Val_0___6 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      v36 = *v35 == 0;
      v123 = v19 + 1;
      v35[8] = v19;
      if ( v36 )
      {
        v58 = (_QWORD *)v35[0xFFFFFFFF];
        v60 = 0;
      }
      else
      {
        if ( !*v34 )
        {
          __asm { vzeroupper }
          v37 = (_QWORD *)sub_1402A63D0(0x10u);
          if ( v37 )
          {
            *v37 = 0;
            v37[1] = 0;
            v38 = (_QWORD *)sub_1402A63D0(0x30u);
            *v38 = v38;
            v38[1] = v38;
            *v37 = v38;
          }
          else
          {
            v37 = 0;
          }
          *v34 = (__int64)v37;
        }
        v39 = (_BYTE *)v35[0xFFFFFFFF];
        Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&v145, 0, sizeof(v145));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v39[Size_1] );
        __asm { vzeroupper }
        sub_1402FC640(&v145, v39, Size_1);
        v42 = (_BYTE *)*v35;
        do
          ++Size_2;
        while ( v42[Size_2] );
        v43 = *(_QWORD *)&v145.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v145.m256_f32[6] - *(_QWORD *)&v145.m256_f32[4] )
        {
          sub_1402ABCE0((const void **)&v145, Size_2, v21, v42, Size_2);
        }
        else
        {
          v44 = &v145;
          *(_QWORD *)&v145.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v145.m256_f32[6] > 0xFu )
            v44 = *(__m256 **)v145.m256_f32;
          v45 = (char *)v44 + v43;
          memmove(v45, v42, Size_2);
          v45[Size_2] = 0;
        }
        __Val_0___4 = (const vraudio::AudioBuffer *)*v34;
        n0xF = *(_QWORD *)&v145.m256_f32[6];
        Buf2_1 = *(_QWORD *)v145.m256_f32;
        __Val_0___1 = __Val_0___4;
        v49 = *(_QWORD **)__Val_0___4;
        v50 = **(_QWORD ***)__Val_0___4;
        if ( v50 == *(_QWORD **)__Val_0___4 )
          goto LABEL_59;
        Size_4 = *(_QWORD *)&v145.m256_f32[4];
        do
        {
          Size_3 = v50[4];
          Buf1 = v50 + 2;
          Buf2 = &v145;
          if ( n0xF > 0xF )
            Buf2 = (__m256 *)Buf2_1;
          if ( v50[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
            break;
          v50 = (_QWORD *)*v50;
        }
        while ( v50 != v49 );
        __Val_0___4 = __Val_0___1;
        if ( v50 == v49 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___4 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v55 = sub_1402A63D0(0x30u);
          *(_QWORD *)(v55 + 0x20) = 0;
          *(_QWORD *)(v55 + 0x28) = 0;
          *(__m256 *)(v55 + 0x10) = v145;
          *(_QWORD *)&v145.m256_f32[4] = 0;
          *(_QWORD *)&v145.m256_f32[6] = 0xF;
          LOBYTE(v145.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___4 + 1);
          v56 = (__int64 *)v49[1];
          *(_QWORD *)v55 = v49;
          *(_QWORD *)(v55 + 8) = v56;
          v49[1] = v55;
          *v56 = v55;
          v57 = *(_QWORD *)*v34;
          v58 = (_QWORD *)(*(_QWORD *)(v57 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v57 + 8) + 0x28LL) > 0xFu )
            v58 = (_QWORD *)*v58;
          if ( *(_QWORD *)&v145.m256_f32[6] > 0xFu )
          {
            v59 = *(_QWORD *)v145.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v145.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v59 = *(_QWORD *)(*(_QWORD *)v145.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v145.m256_f32 - v59 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A63C0(v59);
          }
LABEL_66:
          v15 = v120;
          v60 = 0;
          v35 = v137;
          __Val_0___5 = __Val_0___6;
          v33 = v124;
          *(_QWORD *)&v145.m256_f32[4] = 0;
          LOBYTE(v145.m256_f32[0]) = 0;
          *(_QWORD *)&v145.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v58 = v50 + 2;
        if ( v58[3] > 0xFu )
          v58 = (_QWORD *)*v58;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        Buf2_2 = Buf2_1;
        if ( n0xF + 1 >= 0x1000 )
        {
          Buf2_1 = *(_QWORD *)(Buf2_1 - 8);
          if ( (unsigned __int64)(Buf2_2 - Buf2_1 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A63C0(Buf2_1);
        v15 = v120;
        v60 = 0;
        v35 = v137;
        __Val_0___5 = __Val_0___6;
        v33 = v124;
        *(_QWORD *)&v145.m256_f32[4] = 0;
        LOBYTE(v145.m256_f32[0]) = 0;
        *(_QWORD *)&v145.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___5 + 1) = v58;
      n0x400 = n0x400_2;
      __Val_0___1 = __Val_0___5;
      if ( n0x400_2 >= 0x400 )
      {
        if ( !byte_1497E7748 )
          goto LABEL_92;
        if ( !v15 )
        {
          __asm { vzeroupper }
          v62 = (__int64 *)sub_1402A63D0(0x18u);
          n0x400_3 = 0;
          v120 = v62;
          v15 = v62;
          if ( v62 )
          {
            *v62 = 0;
            v64 = (__int64)v62;
            v62[1] = 0;
            v62[2] = 0;
            v60 = v62;
          }
          else
          {
            v15 = 0;
            v120 = 0;
            v64 = 0;
          }
          sub_140305A10(v64, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v148;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v60[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v60[2] )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                (std::vector<vraudio::AudioBuffer const *> *)v15,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v60[1] += 8;
            }
            ++n0x400_3;
            ++__Val_0__1;
          }
          while ( n0x400_3 < 0x400 );
          n0x400 = n0x400_2;
          __Val_0___5 = __Val_0___6;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v15[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v15[2] )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            (std::vector<vraudio::AudioBuffer const *> *)v15,
            _Whereptr_3,
            &__Val_0___1);
        }
        else
        {
          *_Whereptr_3 = __Val_0___5;
          v15[1] += 8;
        }
        v33 = v124;
      }
      else
      {
        v148[n0x400_2] = __Val_0___5;
      }
      n0x400_2 = ++n0x400;
LABEL_92:
      ++v33;
      v68 = v35[0xB] + v121;
      v35 += 0xE;
      v19 = v123;
      v121 = v68;
      v124 = v33;
      v137 = v35;
    }
    while ( v33 < v131 );
    __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
    v30 = v144;
LABEL_94:
    if ( __Val_0__ > 1 )
      v30 = 0xFFFFFFFFFFFFFFFFuLL;
    v69 = &v125[__Val_0__];
    v125 += __Val_0__;
LABEL_98:
    __Val_0___2 = (const vraudio::AudioBuffer *)((char *)__Val_0___2 + 0x70);
    v70 = v121;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___5 + 0xA) = v30;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___3 = (__int64)__Val_0___2;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v17 = v70;
      continue;
    }
    break;
  }
  v18 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  v125 = v69;
  if ( !v15 )
    goto LABEL_105;
  if ( !((v15[1] - *v15) >> 3) )
    __debugbreak();
  v72 = (char *)*v15;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v125 = v69;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FF400(v72, &v72[8 * n0x400], (__int64)(8 * n0x400) >> 3, v118);
  v73 = 0;
  v74 = 0;
  v75 = 0;
  for ( n0x400_4 = 0; n0x400_4 < n0x400; ++n0x400_4 )
  {
    v77 = *(_QWORD *)&v72[8 * n0x400_4];
    if ( v75 == *(_QWORD *)(v77 + 8) )
    {
      if ( ++v74 == 1 )
        *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 0x50LL) = v74;
    }
    else
    {
      v74 = 0;
      *(_QWORD *)(v77 + 0x50) = -(__int64)(*(_QWORD *)(v77 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v75 = *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
    n0x8000 = ::n0x8000;
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
    n0x100000 = ::n0x100000;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1497E7748 )
    p_n0x8000 = &n0x8000_1;
  if ( !Size_0 )
    Size = (_QWORD)(v18 + 1) << 0xA;
  if ( *p_n0x8000 < Size )
    Size = *p_n0x8000;
  if ( Size <= n0x8000 )
  {
    v83 = 0;
  }
  else
  {
    v82 = sub_1402A63D0(Size);
    v83 = v82;
    if ( v82 )
    {
      v84 = (char *)v82;
      goto LABEL_130;
    }
  }
  v85 = Size + 0xF;
  if ( Size + 0xF < Size )
    v85 = 0xFFFFFFFFFFFFFF0LL;
  v86 = alloca(v85 & 0xFFFFFFFFFFFFFFF0uLL);
  v84 = (char *)&v118;
LABEL_130:
  v87 = (__int64 (__fastcall *)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_1499FF118;
  v88 = 1;
  *v84 = 0;
  v89 = 0;
  LODWORD(v123) = 0;
  LODWORD(v124) = 1;
  if ( v87 && qword_1499FF120 && byte_1497E7748 )
  {
    v88 = v87(*(_QWORD *)v129, (unsigned int)n4, Src, v135, v133, __Val_0___7, _Newcapacity, v147, n0x10_1, &a8);
    LODWORD(v124) = v88;
  }
  v90 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v91 = sub_140303880(
            *(_QWORD *)&FileTime,
            *(__int64 *)v129,
            (__int64)String,
            n4,
            (__int64 *)v135,
            Src,
            v133,
            (_QWORD *)__Val_0___7,
            _Newcapacity,
            a7,
            v84,
            Size,
            (int *)&v123,
            v88,
            &a8);
    v90 = a8;
    v89 = v91;
    v73 = v123;
  }
  if ( ::n2 == 1 && (v90 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v84);
    v90 = a8;
  }
  n2 = n2_0;
  if ( n2_0 == 1 && (v90 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(n2_0 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v84);
    n2 = n2_0;
  }
  v84[v89] = 0;
  v95 = a8;
  v96 = (a8 & 1) != 0 && ::n2 == 2;
  v97 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v96 || v97 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_1497E7748 )
      p_n0x8000_1 = &n0x8000_1;
    v99 = qword_1499FF158;
    if ( !qword_1499FF158 )
      v99 = v121 + v89 + ((_QWORD)(v125 + 4) << 9);
    n0x8000_2 = v99 + 0x80;
    if ( *p_n0x8000_1 < v99 + 0x80 )
      n0x8000_2 = *p_n0x8000_1;
    if ( n0x8000_2 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = sub_1402A63D0(n0x8000_2);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v104 = n0x8000_2 + 0xF;
    if ( n0x8000_2 + 0xF < n0x8000_2 )
      v104 = 0xFFFFFFFFFFFFFF0LL;
    v105 = alloca(v104 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v118;
LABEL_166:
    v117 = v124;
    *(_BYTE *)Buffer_1 = 0;
    sub_140304380(
      *(_QWORD *)&FileTime,
      *(__int64 *)v129,
      Buffer,
      String,
      n4,
      (_QWORD *)v135,
      Src,
      v133,
      __Val_0___7,
      _Newcapacity,
      a7,
      (__int64)v72,
      n0x400_2,
      Buffer_1,
      n0x8000_2 - 0x80,
      (__int64)&v84[v73],
      v89 - v73,
      a8,
      v117);
    sub_1402A63C0(Buffer_3);
    v95 = a8;
  }
  v106 = byte_1499FEDC8;
  if ( byte_1499FEDC8 )
  {
    if ( (v95 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v95 = a8;
      v106 = byte_1499FEDC8;
    }
    if ( v106 )
    {
      if ( (v95 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A63C0(v83);
  v109 = v142;
  if ( v142 )
  {
    v110 = (_QWORD **)*v142;
    **(_QWORD **)(*v142 + 8) = 0;
    v111 = *v110;
    if ( *v110 )
    {
      do
      {
        n0xF_1 = v111[5];
        v113 = (_QWORD *)*v111;
        if ( n0xF_1 > 0xF )
        {
          v114 = v111[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v114 - *(_QWORD *)(v114 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v114 = *(_QWORD *)(v114 - 8);
          }
          sub_1402A63C0(v114);
        }
        v111[4] = 0;
        v111[5] = 0xF;
        *((_BYTE *)v111 + 0x10) = 0;
        sub_1402A63C0((__int64)v111);
        v111 = v113;
      }
      while ( v113 );
    }
    sub_1402A63C0(*v109);
    result = sub_1402A63C0((__int64)v109);
  }
  v115 = v120;
  if ( v120 )
  {
    v116 = *v120;
    if ( *v120 )
    {
      if ( ((v120[2] - v116) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v116 - *(_QWORD *)(v116 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v116 = *(_QWORD *)(v116 - 8);
      }
      sub_1402A63C0(v116);
      *v115 = 0;
      v115[1] = 0;
      v115[2] = 0;
    }
    return sub_1402A63C0((__int64)v115);
  }
  return result;
}

// --- End Function: sub_140305B00 (0x140305B00) ---

// --- Function: swprintf (0x140307350) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  __int64 *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A6A10();
  result = _stdio_common_vsprintf(*v6 | 2, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: swprintf (0x140307350) ---

// --- Function: sub_14030B770 (0x14030B770) ---
__int64 __fastcall sub_14030B770(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)a1 = off_1480E8AB8;
  result = a1;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  *(_WORD *)(a1 + 0x40) = 0xFFFF;
  return result;
}

// --- End Function: sub_14030B770 (0x14030B770) ---

// --- Function: sub_14030BA60 (0x14030BA60) ---
__int64 __fastcall sub_14030BA60(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)a1 = off_1480E8568;
  result = a1;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  return result;
}

// --- End Function: sub_14030BA60 (0x14030BA60) ---

// --- Function: sub_14030BAA0 (0x14030BAA0) ---
__int64 __fastcall sub_14030BAA0(__int64 a1)
{
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)a1 = off_1480E86C8;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  sub_14035CE20((_QWORD *)(a1 + 0x40));
  sub_14035CE20((_QWORD *)(a1 + 0x48));
  *(_QWORD *)a1 = off_1480E8828;
  return a1;
}

// --- End Function: sub_14030BAA0 (0x14030BAA0) ---

// --- Function: sub_14030D6A0 (0x14030D6A0) ---
__int64 __fastcall sub_14030D6A0(_QWORD *a1)
{
  __int64 result; // rax
  volatile signed __int32 *v3; // rcx

  *a1 = off_1480E8138;
  result = sub_140333100();
  v3 = (volatile signed __int32 *)a1[3];
  if ( v3 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v3 + 3, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8LL))(v3);
  }
  return result;
}

// --- End Function: sub_14030D6A0 (0x14030D6A0) ---

// --- Function: sub_14030D7B0 (0x14030D7B0) ---
__int64 __fastcall sub_14030D7B0(_QWORD *a1)
{
  __int64 result; // rax
  volatile signed __int32 *v3; // rcx

  sub_1403727A0(a1 + 9);
  sub_1403727A0(a1 + 8);
  *a1 = off_1480E8138;
  result = sub_140333100(a1);
  v3 = (volatile signed __int32 *)a1[3];
  if ( v3 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v3 + 3, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8LL))(v3);
  }
  return result;
}

// --- End Function: sub_14030D7B0 (0x14030D7B0) ---

// --- Function: sub_14030F6B0 (0x14030F6B0) ---
__int64 __fastcall sub_14030F6B0(__int64 a1)
{
  sub_1403252A0();
  return a1;
}

// --- End Function: sub_14030F6B0 (0x14030F6B0) ---

// --- Function: sub_14030F6D0 (0x14030F6D0) ---
__int64 __fastcall sub_14030F6D0(__int64 a1)
{
  sub_140325200();
  return a1;
}

// --- End Function: sub_14030F6D0 (0x14030F6D0) ---

// --- Function: is_valid_handle_typeA (0x140310230) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B6A80(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return check_handle_access_by_state(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x140310230) ---

// --- Function: is_valid_handle_typeB (0x1403102C0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x25) || (v8 = is_thread_flag_57_or_38_set()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || (unsigned __int8)sub_140393CF0(a1) != 0;
}

// --- End Function: is_valid_handle_typeB (0x1403102C0) ---

// --- Function: sub_1403103B0 (0x1403103B0) ---
__int64 __fastcall sub_1403103B0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403103B0 (0x1403103B0) ---

// --- Function: sub_1403103D0 (0x1403103D0) ---
__int64 __fastcall sub_1403103D0(__int64 a1)
{
  __int64 v1; // rdx
  signed __int32 v2; // eax
  signed __int32 v3; // ett
  __int64 v5; // rdi
  volatile signed __int32 *v6; // rbx

  v1 = *(_QWORD *)(a1 + 0x10);
  if ( !v1 )
    return 0;
  v2 = *(_DWORD *)(v1 + 8);
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v3 = v2;
    v2 = _InterlockedCompareExchange((volatile signed __int32 *)(v1 + 8), v2 + 1, v2);
    if ( v3 == v2 )
      break;
    if ( !v2 )
      return 0;
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(volatile signed __int32 **)(a1 + 0x10);
  if ( !v6 )
    return *(_QWORD *)(a1 + 8);
  if ( _InterlockedExchangeAdd(v6 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v6)(v6);
    if ( _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
  }
  return v5;
}

// --- End Function: sub_1403103D0 (0x1403103D0) ---

// --- Function: check_handle_access_by_state (0x140321630) ---
// Checks access permissions for the provided packed handle. Retrieves handle
// metadata using `get_handle_metadata`. Validates access based on the state field
// (metadata + 4): - State 0: Returns false (invalid). - State 1: Checks if the
// handle's payload exists in a thread-local list using
// `check_thread_list_contains_value`. - State 2: Returns true if specific thread
// flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3: Checks thread
// state and compares the payload value against a constant using
// `check_thread_state_and_value_not_equal`. - Other states: Return false.
char __fastcall check_handle_access_by_state(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B6A80(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B2980(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = sub_1403B2980(v1);
      return sub_140393B10(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x25) || is_thread_flag_57_or_38_set() )
    return 1;
  payload_ptr_state2 = sub_1403B2980(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: check_handle_access_by_state (0x140321630) ---

// --- Function: sub_1403216E0 (0x1403216E0) ---
__int64 __fastcall sub_1403216E0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 65);
}

// --- End Function: sub_1403216E0 (0x1403216E0) ---

// --- Function: sub_140324F60 (0x140324F60) ---
__int64 __fastcall sub_140324F60(__int64 a1)
{
  *(_WORD *)(a1 + 0x40) = 0xFFFF;
  return sub_140324EB0();
}

// --- End Function: sub_140324F60 (0x140324F60) ---

// --- Function: sub_140325200 (0x140325200) ---
__int64 __fastcall sub_140325200(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rcx
  __int64 v6; // rax

  if ( !*(_BYTE *)(a1 + 0x28) || (result = sub_140381220(a1 + 0x48), (_BYTE)result) )
  {
    sub_140379A10(a1 + 0x48, a2);
    result = *(unsigned __int8 *)(a1 + 0x2A);
    *(_BYTE *)(a1 + 0x28) = 1;
    v5 = *(_QWORD *)(a1 + 0x18);
    if ( v5 && *(_DWORD *)(v5 + 8) )
    {
      if ( !(_BYTE)result )
      {
        *(_BYTE *)(a1 + 0x2A) = 1;
        if ( *(_BYTE *)(a1 + 0x2B) )
        {
          v6 = sub_1403103D0(a1 + 8);
          return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x18LL))(v6, *(unsigned int *)(a1 + 8));
        }
      }
    }
    else if ( !(_BYTE)result )
    {
      *(_BYTE *)(a1 + 0x2A) = 1;
    }
  }
  return result;
}

// --- End Function: sub_140325200 (0x140325200) ---

// --- Function: sub_1403252A0 (0x1403252A0) ---
__int64 __fastcall sub_1403252A0(__int64 a1, __int64 *a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  unsigned int *v4; // rbx
  __int64 v5; // rax

  if ( !*(_BYTE *)(a1 + 0x28) || (result = *a2, *(_QWORD *)(a1 + 0x48) != *a2) )
  {
    *(_QWORD *)(a1 + 0x48) = *a2;
    result = *(unsigned __int8 *)(a1 + 0x2A);
    *(_BYTE *)(a1 + 0x28) = 1;
    v3 = *(_QWORD *)(a1 + 0x18);
    if ( v3 && *(_DWORD *)(v3 + 8) )
    {
      if ( !(_BYTE)result )
      {
        *(_BYTE *)(a1 + 0x2A) = 1;
        if ( *(_BYTE *)(a1 + 0x2B) )
        {
          v4 = (unsigned int *)(a1 + 8);
          v5 = sub_1403103D0(a1 + 8);
          return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0x18LL))(v5, *v4);
        }
      }
    }
    else if ( !(_BYTE)result )
    {
      *(_BYTE *)(a1 + 0x2A) = 1;
    }
  }
  return result;
}

// --- End Function: sub_1403252A0 (0x1403252A0) ---

// --- Function: map_flag_to_mask (0x140326230) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140326230) ---

// --- Function: sub_140330A10 (0x140330A10) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_140330A10(double a1)
{
  __int128 v2; // kr00_16

  v2 = *(_OWORD *)&a1;
  *(float *)&v2 = *(float *)&a1 * 57.295776;
  return (__m128)v2;
}

// --- End Function: sub_140330A10 (0x140330A10) ---

// --- Function: sub_140331AE0 (0x140331AE0) ---
__int64 __fastcall sub_140331AE0(__int64 a1, char a2)
{
  __int64 v4; // rcx
  __int64 result; // rax
  bool v6; // zf
  __int64 v7; // rax

  v4 = *(_QWORD *)(a1 + 0x18);
  result = *(unsigned __int8 *)(a1 + 0x2A);
  if ( v4 && *(_DWORD *)(v4 + 8) )
  {
    if ( !(_BYTE)result || a2 )
    {
      v6 = *(_BYTE *)(a1 + 0x2B) == 0;
      *(_BYTE *)(a1 + 0x2A) = 1;
      if ( !v6 )
      {
        v7 = sub_1403103D0(a1 + 8);
        result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 0x18LL))(v7, *(unsigned int *)(a1 + 8));
      }
      goto LABEL_10;
    }
  }
  else if ( !(_BYTE)result || a2 )
  {
    *(_BYTE *)(a1 + 0x2A) = 1;
LABEL_10:
    if ( a2 )
      *(_BYTE *)(a1 + 0x29) = 0;
  }
  return result;
}

// --- End Function: sub_140331AE0 (0x140331AE0) ---

// --- Function: sub_140334DC0 (0x140334DC0) ---
__int64 __fastcall sub_140334DC0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_140334DC0 (0x140334DC0) ---

// --- Function: sub_140339170 (0x140339170) ---
double *__fastcall sub_140339170(double *a1, double *a2, double *a3)
{
  double v3; // xmm4_8
  double *result; // rax
  double v5; // xmm9_8
  double v6; // xmm11_8
  double v7; // xmm12_8
  double v8; // xmm13_8
  double v9; // xmm8_8
  double v10; // xmm6_8
  double v11; // xmm4_8
  double v12; // xmm3_8
  double v13; // kr00_8
  double v14; // xmm2_8
  double v15; // xmm1_8
  double v16; // xmm2_8

  v3 = a2[3];
  result = a1;
  v5 = a2[2];
  v6 = a2[1];
  v7 = a3[1];
  v8 = a3[2];
  v9 = v8 * v6 - v7 * v5 + *a3 * v3;
  v10 = *a3 * v5 - *a2 * v8 + v3 * v7;
  v11 = *a2 * v7 - *a3 * v6 + v3 * v8;
  v12 = *a2 * v10 - v6 * v9;
  v13 = v5 * v9 - *a2 * v11;
  v14 = v13 + a2[5];
  *a1 = v6 * v11 - v5 * v10 + a2[4] + *a3 + v6 * v11 - v5 * v10;
  v15 = v14 + v7 + v13;
  v16 = v12 + a2[6];
  a1[1] = v15;
  a1[2] = v16 + v8 + v12;
  return result;
}

// --- End Function: sub_140339170 (0x140339170) ---

// --- Function: sub_14033C600 (0x14033C600) ---
_QWORD *__fastcall sub_14033C600(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_10;
  if ( n0xFFFF_10 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                          qword_149A14298,
                          &v9,
                          "ISCPlayer");
    n0xFFFF_10 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033C600 (0x14033C600) ---

// --- Function: sub_14033C8B0 (0x14033C8B0) ---
_QWORD *__fastcall sub_14033C8B0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_0;
  if ( n0xFFFF_0 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                          qword_149A14298,
                          &v9,
                          "IVehicle");
    n0xFFFF_0 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033C8B0 (0x14033C8B0) ---

// --- Function: sub_14033C930 (0x14033C930) ---
__int64 __fastcall sub_14033C930(__int64 a1, __int16 a2)
{
  __int64 *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v7; // rsi
  int *v8; // rbx
  int *v9; // rax
  int v10; // ebx
  int v11; // edi
  __int64 v12; // rdi
  unsigned __int8 (__fastcall *v13)(__int64, __int64, const char *); // rbx
  __int64 v14; // rax
  _BYTE v15[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v16; // [rsp+28h] [rbp-30h]
  _BYTE v17[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v18; // [rsp+40h] [rbp-18h]

  v3 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x60LL))(a1);
  v4 = *v3;
  v5 = v3[1];
  if ( *v3 == v5 )
    return 0;
  while ( *(_WORD *)v4 != a2 )
  {
    v4 += 0x20;
    if ( v4 == v5 )
      return 0;
  }
  v7 = *(_QWORD *)(v4 + 8);
  if ( !v7 )
    return 0;
  v8 = (int *)sub_1403DC5C0(v17);
  v9 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 0x18LL))(v7, v15);
  v10 = *v8;
  v11 = *v9;
  if ( v16 )
    sub_14753C530(v16);
  if ( v18 )
    sub_14753C530(v18);
  if ( v10 != v11 )
  {
    if ( !qword_149A142B0 )
      return 0;
    if ( !(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149A142B0 + 0x240LL))(qword_149A142B0) )
      return 0;
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149A142B0 + 0x240LL))(qword_149A142B0);
    v13 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v12 + 0x100LL);
    v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
    if ( !v13(v12, v14, "SCItemInventoryContainerComponentParams") )
      return 0;
  }
  return v7;
}

// --- End Function: sub_14033C930 (0x14033C930) ---

// --- Function: sub_140345A10 (0x140345A10) ---
__int64 __fastcall sub_140345A10(__int64 a1, _QWORD *a2)
{
  _QWORD *v3; // rdx
  __int64 result; // rax

  v3 = *(_QWORD **)(a1 + 8);
  if ( v3 == *(_QWORD **)(a1 + 0x10) )
    return sub_1402A9170(a1, v3, a2);
  *v3 = *a2;
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = result + 8;
  return result;
}

// --- End Function: sub_140345A10 (0x140345A10) ---

// --- Function: sub_1403463D0 (0x1403463D0) ---
int *__fastcall sub_1403463D0(__int64 a1, _BYTE *a2, int *a3)
{
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  int *v12; // rsi
  int *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  int *v16; // rbp
  size_t Size; // r8
  __int64 v18; // rcx
  int *result; // rax

  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 2;
  _Count = 0x3FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if ( v6 == 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 2;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x3FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<int>::allocate((std::allocator<int> *)a1, _Count);
  v12[v4] = *a3;
  v13 = v12;
  v14 = *(_BYTE **)(a1 + 8);
  v15 = *(_BYTE **)a1;
  v16 = &v12[v4];
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = v16 + 1;
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  v18 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - v18) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v18 = *(_QWORD *)(v18 - 8);
    }
    sub_1402A63C0(v18);
  }
  *(_QWORD *)a1 = v12;
  result = v16;
  *(_QWORD *)(a1 + 8) = &v12[v10];
  *(_QWORD *)(a1 + 0x10) = &v12[_Count];
  return result;
}

// --- End Function: sub_1403463D0 (0x1403463D0) ---

// --- Function: sub_140352B00 (0x140352B00) ---
signed __int64 __fastcall sub_140352B00(volatile signed __int64 *a1, __int64 *a2)
{
  _QWORD *v4; // rbx
  __int64 v5; // rdx
  unsigned __int64 v6; // rax
  signed __int64 v7; // rsi

  if ( *a1 )
    return *a1;
  v4 = (_QWORD *)sub_1402A63D0(8u);
  if ( v4 )
  {
    *v4 = (char *)&qword_1499FF28C + 4;
    v5 = *a2;
    if ( *a2 )
    {
      v6 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v6;
      while ( *(_BYTE *)(v5 + v6) );
      sub_1403DF8F0(v4, v5, (int)v6);
    }
    else
    {
      sub_1403DF8F0(v4, 0, 0);
    }
  }
  else
  {
    v4 = 0;
  }
  v7 = _InterlockedCompareExchange64(a1, (signed __int64)v4, 0);
  if ( !v7 )
    return *a1;
  if ( v4 )
  {
    if ( *(int *)(*v4 - 4LL) > 0 )
      sub_14753C530(*v4 - 8LL, (unsigned int)dword_1497E7C00);
    sub_1402A63C0((__int64)v4);
  }
  return v7;
}

// --- End Function: sub_140352B00 (0x140352B00) ---

// --- Function: sub_140355D10 (0x140355D10) ---
__int64 __fastcall sub_140355D10(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x18) = sub_1403ECB40;
  *(_QWORD *)(a1 + 0x20) = sub_1403EC6E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E8DD0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E6440;
  *(_QWORD *)(a1 + 0x48) = sub_1403E6140;
  result = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return result;
}

// --- End Function: sub_140355D10 (0x140355D10) ---

// --- Function: sub_14035C990 (0x14035C990) ---
void **__fastcall sub_14035C990(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_1499FF28C + 4;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035C990 (0x14035C990) ---

// --- Function: GetLocalizedNameFromKey (0x1403607E0) ---
_QWORD *__fastcall GetLocalizedNameFromKey(_QWORD *a1, unsigned __int8 **a2)
{
  __int64 *v4; // rax
  _QWORD *v5; // rax
  __int64 v6; // rdx
  unsigned __int8 *v7; // r8
  __int64 v8; // r9
  int v9; // eax
  int v10; // ecx
  __int64 v11; // rax

  *a1 = &qword_149A023A8;
  v4 = (__int64 *)sub_1403B0710();
  v5 = (_QWORD *)sub_140352B00(&qword_149A021B0, v4);
  v7 = *a2;
  v8 = *v5 - (_QWORD)*a2;
  do
  {
    v9 = v7[v8];
    v10 = *v7 - v9;
    if ( v10 )
      break;
    ++v7;
  }
  while ( v9 );
  if ( v10 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)qword_149A142B0 + 0x4E0LL))(
            qword_149A142B0,
            v6,
            v7);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD *, _QWORD))(*(_QWORD *)v11 + 0xA8LL))(v11, *a2, a1, 0);
  }
  return a1;
}

// --- End Function: GetLocalizedNameFromKey (0x1403607E0) ---

// --- Function: sub_140362B00 (0x140362B00) ---
__int64 __fastcall sub_140362B00(__int64 a1, __int64 **a2)
{
  __int64 *v3; // rsi
  __int64 *i; // rbx
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  *(_DWORD *)a1 = 0xF0000000;
  *(_DWORD *)(a1 + 4) = 0xF0000000;
  *(_DWORD *)(a1 + 8) = 0xF0000000;
  *(_DWORD *)(a1 + 0xC) = 0xF0000000;
  *(_DWORD *)(a1 + 0x10) = 0xF0000000;
  *(_DWORD *)(a1 + 0x14) = 0xF0000000;
  *(_DWORD *)(a1 + 0x18) = 0xF0000000;
  *(_DWORD *)(a1 + 0x1C) = 0xF0000000;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x28) = 1;
  v3 = a2[1];
  for ( i = *a2; i != v3; ++i )
  {
    v6 = *i;
    if ( (_WORD)v6 != 0xFFFF )
      (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)qword_149A14208 + 0x70LL))(
        qword_149A14208,
        a1,
        &v6);
  }
  return a1;
}

// --- End Function: sub_140362B00 (0x140362B00) ---

// --- Function: sub_1403644B0 (0x1403644B0) ---
__int64 __fastcall sub_1403644B0(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *a2;
  result = a1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

// --- End Function: sub_1403644B0 (0x1403644B0) ---

// --- Function: sub_14036BA30 (0x14036BA30) ---
_DWORD *__fastcall sub_14036BA30(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // rax

  *a1 = a2;
  result = a1;
  a1[1] = a3;
  return result;
}

// --- End Function: sub_14036BA30 (0x14036BA30) ---

// --- Function: sub_14036FC70 (0x14036FC70) ---
__int64 __fastcall sub_14036FC70(__int64 a1, double a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = off_1480ED488;
  result = a1;
  *(double *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14036FC70 (0x14036FC70) ---

// --- Function: sub_140370FC0 (0x140370FC0) ---
__int64 __fastcall sub_140370FC0(__int64 a1, __int16 a2, __int64 a3, char a4)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 2) &= 0xF0u;
  *(_DWORD *)(a1 + 0xC) = 0;
  *(_BYTE *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x14) = 0;
  *(_WORD *)a1 = 0;
  *(_QWORD *)(a1 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x160) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x158) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x150) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x278) = 0x3FF0000000000000LL;
  result = a1;
  *(_QWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1A8) = 0;
  *(_DWORD *)(a1 + 0x1B0) = 0;
  *(_QWORD *)(a1 + 0x1B4) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1BC) = 0;
  *(_DWORD *)(a1 + 0x1C4) = 0;
  *(_QWORD *)(a1 + 0x1C8) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1D0) = 0;
  *(_DWORD *)(a1 + 0x1D8) = 0;
  *(_DWORD *)(a1 + 0x1DC) = 0x3F800000;
  *(_QWORD *)(a1 + 0x1E0) = 0;
  *(_QWORD *)(a1 + 0x260) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = 0;
  *(_QWORD *)(a1 + 0x280) = 0;
  *(_QWORD *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x290) = 0;
  *(_QWORD *)(a1 + 0x298) = 0;
  *(_QWORD *)(a1 + 0x2A0) = 0;
  *(_QWORD *)(a1 + 0x2A8) = 0;
  *(_QWORD *)(a1 + 0x2B8) = 0;
  *(_QWORD *)(a1 + 0x2C0) = 0;
  *(_QWORD *)(a1 + 0x2C8) = 0;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_QWORD *)(a1 + 0x1F0) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x200) = 0;
  *(_QWORD *)(a1 + 0x208) = a3;
  *(_BYTE *)(a1 + 0x210) = 0;
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0;
  *(_QWORD *)(a1 + 0x228) = 0;
  *(_BYTE *)(a1 + 0x230) = 0;
  *(_DWORD *)(a1 + 0x234) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x250) = 0;
  *(_WORD *)(a1 + 0x258) = a2;
  *(_BYTE *)(a1 + 0x25A) = a4;
  *(_DWORD *)(a1 + 0x25C) = 0;
  *(_QWORD *)(a1 + 0x2B0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x2D0) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2D4) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2D8) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2DC) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2E0) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2E4) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2E8) = 0xF0000000;
  *(_DWORD *)(a1 + 0x2EC) = 0xF0000000;
  *(_QWORD *)(a1 + 0x2F0) = 0;
  *(_DWORD *)(a1 + 0x2F8) = 0;
  *(_QWORD *)(a1 + 0x300) = 0;
  *(_BYTE *)(a1 + 0x308) = 0;
  *(_QWORD *)(a1 + 0x30C) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x318) = 0;
  return result;
}

// --- End Function: sub_140370FC0 (0x140370FC0) ---

// --- Function: sub_1403711F0 (0x1403711F0) ---
__int64 sub_1403711F0(__int64 a1, __int16 a2, __int64 a3, char a4, char *Format, ...)
{
  __int64 *v6; // rax
  __int64 result; // rax
  va_list va; // [rsp+78h] [rbp+30h] BYREF

  va_start(va, Format);
  sub_140370FC0(a1, a2, a3, a4);
  v6 = sub_1402A6A10();
  _stdio_common_vsprintf(*v6 | 2, (char *)(a1 + 0x320), 0x3Fu, Format, 0, va);
  result = a1;
  *(_BYTE *)(a1 + 0x35F) = 0;
  return result;
}

// --- End Function: sub_1403711F0 (0x1403711F0) ---

// --- Function: sub_1403723E0 (0x1403723E0) ---
__int64 __fastcall sub_1403723E0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 0xA8) = 0x80000000;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  result = a1;
  *(_DWORD *)(a1 + 0xAC) = 0x80000000;
  *(_DWORD *)a1 = 8;
  return result;
}

// --- End Function: sub_1403723E0 (0x1403723E0) ---

// --- Function: sub_1403727A0 (0x1403727A0) ---
void __fastcall sub_1403727A0(_QWORD *a1)
{
  __int64 v1; // rcx

  v1 = *a1 - 8LL;
  if ( *(int *)(v1 + 4) > 0 )
    sub_14753C530(v1, (unsigned int)dword_1497E7C00);
}

// --- End Function: sub_1403727A0 (0x1403727A0) ---

// --- Function: sub_1403728F0 (0x1403728F0) ---
__int64 __fastcall sub_1403728F0(__int64 a1)
{
  __int64 (__fastcall ***v1)(_QWORD, __int64); // rcx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = *(__int64 (__fastcall ****)(_QWORD, __int64))a1;
    if ( v1 )
      return (**v1)(v1, 1);
  }
  return result;
}

// --- End Function: sub_1403728F0 (0x1403728F0) ---

// --- Function: sub_140374530 (0x140374530) ---
__int64 __fastcall sub_140374530(_DWORD *a1)
{
  __int64 result; // rax

  result = sub_1403D11A0();
  if ( a1[7] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 7);
  if ( a1[6] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 6);
  if ( a1[5] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 5);
  if ( a1[4] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 4);
  if ( a1[3] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 3);
  if ( a1[2] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 2);
  if ( a1[1] != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 1);
  if ( *a1 != 0xF0000000 )
    return (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_149A14208 + 0xF8LL))(qword_149A14208, a1);
  return result;
}

// --- End Function: sub_140374530 (0x140374530) ---

// --- Function: sub_140379010 (0x140379010) ---
__int64 (__fastcall *__fastcall sub_140379010(__int64 a1))(__int64, __int64, _QWORD)
{
  __int64 (__fastcall *n2)(__int64, __int64, _QWORD); // rax
  __int64 v3; // rcx

  sub_140374530((_DWORD *)(a1 + 0x2D0));
  n2 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a1 + 0x2C0);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2 = (__int64 (__fastcall *)(__int64, __int64, _QWORD))n2(2, a1 + 0x2B8, 0);
    *(_QWORD *)(a1 + 0x2C0) = 0;
  }
  *(_QWORD *)(a1 + 0x2B8) = 0;
  v3 = *(_QWORD *)(a1 + 0x298);
  if ( v3 )
  {
    if ( ((*(_QWORD *)(a1 + 0x2A8) - v3) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = *(_QWORD *)(v3 - 8);
    }
    n2 = (__int64 (__fastcall *)(__int64, __int64, _QWORD))sub_1402A63C0(v3);
    *(_QWORD *)(a1 + 0x298) = 0;
    *(_QWORD *)(a1 + 0x2A0) = 0;
    *(_QWORD *)(a1 + 0x2A8) = 0;
  }
  return n2;
}

// --- End Function: sub_140379010 (0x140379010) ---

// --- Function: sub_14037B580 (0x14037B580) ---
__int64 __fastcall sub_14037B580(__int64 a1, __int64 a2)
{
  unsigned __int16 n4; // ax
  unsigned __int64 n4_1; // rdi
  __int64 v6; // rbx
  __int64 v7; // r12
  __int64 v8; // r13
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 v11; // r14
  __int64 v12; // rbp
  __int64 v13; // r14
  __int64 v14; // rbp

  if ( a2 == a1 )
    return a1;
  sub_1403D11A0();
  n4 = *(_WORD *)(a2 + 0x28);
  *(_WORD *)(a1 + 0x28) = n4;
  if ( n4 > 4u )
    sub_1403939A0(a1);
  n4_1 = 0;
  if ( *(_WORD *)(a2 + 0x28) )
  {
    v6 = a1 + 4;
    v7 = a2 - a1;
    v8 = 0xFFFFFFFFFFFFFFFCuLL - a1;
    do
    {
      if ( n4_1 >= 4 )
      {
        v11 = v6 + v8 + *(_QWORD *)(a2 + 0x20) - 0x20LL;
        v12 = v6 + v8 + *(_QWORD *)(a1 + 0x20) - 0x20LL;
        if ( v12 != v11 )
        {
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
            qword_149A14208,
            v6 + v8 + *(_QWORD *)(a1 + 0x20) - 0x20LL);
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149A14208 + 0xE8LL))(
            qword_149A14208,
            v12,
            v11);
        }
        v13 = v11 + 4;
        v14 = v12 + 4;
        if ( v14 == v13 )
          goto LABEL_16;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(qword_149A14208, v14);
        v9 = v13;
        v10 = v14;
      }
      else
      {
        if ( v6 - 4 != v6 + v7 - 4 )
        {
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(qword_149A14208, v6 - 4);
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149A14208 + 0xE8LL))(
            qword_149A14208,
            v6 - 4,
            v6 + v7 - 4);
        }
        if ( v6 == v7 + v6 )
          goto LABEL_16;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(qword_149A14208, v6);
        v9 = v7 + v6;
        v10 = v6;
      }
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_149A14208 + 0xE8LL))(
        qword_149A14208,
        v10,
        v9);
LABEL_16:
      ++n4_1;
      v6 += 8;
    }
    while ( n4_1 < *(unsigned __int16 *)(a2 + 0x28) );
  }
  return a1;
}

// --- End Function: sub_14037B580 (0x14037B580) ---

// --- Function: sub_1403811B0 (0x1403811B0) ---
bool __fastcall sub_1403811B0(__int64 a1, __int64 a2)
{
  return a1 != a2;
}

// --- End Function: sub_1403811B0 (0x1403811B0) ---

// --- Function: j_is_valid_handle_typeB (0x140381300) ---
// attributes: thunk
bool __fastcall j_is_valid_handle_typeB(unsigned __int64 *a1)
{
  return is_valid_handle_typeB(a1);
}

// --- End Function: j_is_valid_handle_typeB (0x140381300) ---

// --- Function: AssetMeta::HasActorSubresource (0x140381750) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149A14290 + 0x128LL))(
         qword_149A14290,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return (unsigned __int8)sub_140393C30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x140381750) ---

// --- Function: ?Count@WriteBytesMem@AK@@UEBAHXZ (0x140381800) ---
__int64 __fastcall AK::WriteBytesMem::Count(AK::WriteBytesMem *this)
{
  return *((unsigned int *)this + 6);
}

// --- End Function: ?Count@WriteBytesMem@AK@@UEBAHXZ (0x140381800) ---

// --- Function: HIWORD_w (0x140381830) ---
bool __fastcall sub_140381830(_QWORD *a1)
{
  return *a1 && *(_QWORD *)((*a1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*a1);
}

// --- End Function: HIWORD_w (0x140381830) ---

// --- Function: sub_140386914 (0x140386914) ---
__int64 __fastcall sub_140386914(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
}

// --- End Function: sub_140386914 (0x140386914) ---

// --- Function: check_thread_list_contains_value (0x140393A50) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140393A50) ---

// --- Function: sub_140393B10 (0x140393B10) ---
bool __fastcall sub_140393B10(unsigned __int64 a1)
{
  __int64 v2; // r9
  unsigned __int64 *v3; // r10
  unsigned __int64 *v4; // r8
  unsigned __int64 v5; // rcx
  unsigned __int64 *v6; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) != 1 )
    return 0;
  v3 = *(unsigned __int64 **)(v2 + 0x30);
  v4 = *(unsigned __int64 **)(v2 + 0x28);
  v5 = v3 - v4;
  while ( (__int64)v5 > 0 )
  {
    if ( v4[v5 >> 1] >= a1 )
    {
      v5 >>= 1;
    }
    else
    {
      v4 += (v5 >> 1) + 1;
      v5 += 0xFFFFFFFFFFFFFFFFuLL - (v5 >> 1);
    }
  }
  if ( v4 == v3 || (v6 = v4 + 1, a1 < *v4) )
    v6 = v4;
  if ( v4 == v6 )
    v4 = *(unsigned __int64 **)(v2 + 0x30);
  return v4 != v3;
}

// --- End Function: sub_140393B10 (0x140393B10) ---

// --- Function: validate_access_with_virtual_calls (0x140393BB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  v3 = qword_149A14290;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149A14290 + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(v3, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140393BB0) ---

// --- Function: sub_140393C30 (0x140393C30) ---
char __fastcall sub_140393C30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149A14290 + 0x128LL))(
         qword_149A14290,
         v1,
         0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
      return sub_140393B10(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x25) || is_thread_flag_57_or_38_set() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140393C30 (0x140393C30) ---

// --- Function: sub_140393CF0 (0x140393CF0) ---
char __fastcall sub_140393CF0(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rbx
  __int64 v2; // rax

  payload_ptr_state1 = *a1 & 0xFFFFFFFFFFFFLL;
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
      return sub_140393B10(payload_ptr_state1);
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x25) || is_thread_flag_57_or_38_set() )
    return 1;
  else
    return validate_access_with_virtual_calls(payload_ptr_state1);
}

// --- End Function: sub_140393CF0 (0x140393CF0) ---

// --- Function: sub_1403A5650 (0x1403A5650) ---
__int64 __fastcall sub_1403A5650(volatile signed __int64 *a1)
{
  volatile signed __int64 v1; // rbx
  signed __int64 v2; // rax
  volatile signed __int64 v3; // rtt
  __int64 result; // rax
  __int64 v5; // rdi
  __int64 v6; // r8
  int v7; // ecx
  __int64 v8; // r8
  int v9; // [rsp+30h] [rbp+8h] BYREF
  __int64 v10; // [rsp+38h] [rbp+10h] BYREF

  v1 = *a1;
  v3 = *a1;
  v2 = _InterlockedCompareExchange64(a1, (*a1 & 0xFFFF0000FFCFFFFFuLL) + 1, *a1);
  if ( v3 != v2 )
  {
    do
    {
      v1 = v2;
      v2 = _InterlockedCompareExchange64(a1, (v2 & 0xFFFF0000FFCFFFFFuLL) + 1, v2);
    }
    while ( v2 != v1 );
  }
  if ( (v1 & 0x100000) != 0 )
    qword_1499FF3F8(a1);
  result = 0xFFFF00000000LL;
  if ( (v1 & 0xFFFF00000000LL) != 0 )
  {
    v5 = qword_149A14308;
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149A14308 + 0xF8LL))(
      qword_149A14308,
      &v10,
      &v9);
    v6 = v10 + 0xC0 * (WORD2(v1) & (unsigned __int64)(unsigned int)(v9 - 1));
    LODWORD(v1) = *(_DWORD *)(v6 + 0x24);
    *(_DWORD *)(v6 + 0x1C) = (unsigned __int16)(WORD2(v1) + v9);
    for ( result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0xD8LL))(v5);
          (_DWORD)v1 != 0xFFFFFFFF;
          result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0xD8LL))(v5) )
    {
      v7 = (unsigned __int16)(v1 + v9);
      v8 = v10 + 0xC0LL * ((unsigned int)v1 & (v9 - 1));
      LODWORD(v1) = *(_DWORD *)(v8 + 0x24);
      *(_DWORD *)(v8 + 0x1C) = v7;
    }
  }
  return result;
}

// --- End Function: sub_1403A5650 (0x1403A5650) ---

// --- Function: sub_1403A8120 (0x1403A8120) ---
void __fastcall sub_1403A8120(__int64 a1, __m256i *a2)
{
  *(_BYTE *)a1 |= 0x10u;
  *(__m256i *)(a1 + 0x70) = *a2;
  __asm { vzeroupper }
}

// --- End Function: sub_1403A8120 (0x1403A8120) ---

// --- Function: sub_1403A8130 (0x1403A8130) ---
__int64 __fastcall sub_1403A8130(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 2) |= 1u;
  return sub_14037B580(a1 + 0x2D0, a2);
}

// --- End Function: sub_1403A8130 (0x1403A8130) ---

// --- Function: sub_1403ADD60 (0x1403ADD60) ---
__int16 *__fastcall sub_1403ADD60(__int16 *a1)
{
  __int16 n0xFFFF; // cx
  __int16 *result; // rax
  char v4; // [rsp+30h] [rbp+8h] BYREF

  if ( n0xFFFF_11 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                          qword_149A14298,
                          &v4,
                          "InventoryContainerComponent");
    result = a1;
    n0xFFFF_11 = n0xFFFF;
    *a1 = n0xFFFF;
  }
  else
  {
    *a1 = n0xFFFF_11;
    return a1;
  }
  return result;
}

// --- End Function: sub_1403ADD60 (0x1403ADD60) ---

// --- Function: sub_1403B02B0 (0x1403B02B0) ---
double __fastcall sub_1403B02B0(__int64 a1)
{
  return *(double *)(a1 + 8);
}

// --- End Function: sub_1403B02B0 (0x1403B02B0) ---

// --- Function: sub_1403B0710 (0x1403B0710) ---
__int64 sub_1403B0710()
{
  __int64 result; // rax
  _QWORD *v1; // rcx
  signed __int64 v2; // rbx

  result = qword_149A021C8;
  if ( !qword_149A021C8 )
  {
    v1 = (_QWORD *)sub_1402A63D0(8u);
    if ( v1 )
      *v1 = "@LOC_EMPTY";
    else
      v1 = 0;
    v2 = _InterlockedCompareExchange64(&qword_149A021C8, (signed __int64)v1, 0);
    if ( v2 )
    {
      sub_1402A63C0((__int64)v1);
      return v2;
    }
    else
    {
      return qword_149A021C8;
    }
  }
  return result;
}

// --- End Function: sub_1403B0710 (0x1403B0710) ---

// --- Function: sub_1403B16C0 (0x1403B16C0) ---
__m128 __fastcall sub_1403B16C0(__int64 a1, unsigned int a2)
{
  __m128 result; // xmm0
  char v4; // [rsp+30h] [rbp+8h] BYREF

  (*(void (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)a1 + 0x60LL))(a1, &v4, a2);
  _XMM0 = sub_140598DA0();
  __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
  return result;
}

// --- End Function: sub_1403B16C0 (0x1403B16C0) ---

// --- Function: sub_1403B2980 (0x1403B2980) ---
__int64 __fastcall sub_1403B2980(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B2980 (0x1403B2980) ---

// --- Function: sub_1403B29B0 (0x1403B29B0) ---
_QWORD *__fastcall sub_1403B29B0(unsigned __int64 *a1, _QWORD *a2)
{
  if ( is_valid_handle_typeB(a1) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B29B0 (0x1403B29B0) ---

// --- Function: sub_1403B6A80 (0x1403B6A80) ---
__int64 __fastcall sub_1403B6A80(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149A14290 + 296LL))(
           qword_149A14290,
           a1,
           0);
}

// --- End Function: sub_1403B6A80 (0x1403B6A80) ---

// --- Function: get_event_key_from_source_location (0x1403BD8A0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149A014E0;
  if ( !qword_149A014E0 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149A014E0 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BD8A0) ---

// --- Function: sub_1403C3210 (0x1403C3210) ---
bool __fastcall sub_1403C3210(__int64 a1)
{
  return *(_DWORD *)(a1 + 0x18) != 0;
}

// --- End Function: sub_1403C3210 (0x1403C3210) ---

// --- Function: sub_1403C51B0 (0x1403C51B0) ---
__int64 __fastcall sub_1403C51B0(volatile signed __int32 *a1, unsigned __int32 a2, __int64 a3, char a4)
{
  __int64 result; // rax
  char v8; // r14
  signed __int32 v9; // ecx
  bool v10; // zf
  unsigned __int32 v11; // esi
  signed __int32 v12; // eax
  unsigned __int32 v13; // [rsp+30h] [rbp-69h] BYREF
  unsigned __int32 v14[3]; // [rsp+34h] [rbp-65h] BYREF
  int n0x1600; // [rsp+40h] [rbp-59h] BYREF
  __int64 v16; // [rsp+44h] [rbp-55h]
  int v17; // [rsp+4Ch] [rbp-4Dh]
  __int64 v18; // [rsp+50h] [rbp-49h]
  unsigned __int64 v19; // [rsp+58h] [rbp-41h]
  __int64 v20; // [rsp+60h] [rbp-39h]
  __int64 v21; // [rsp+68h] [rbp-31h]
  int n0x1600_1; // [rsp+90h] [rbp-9h] BYREF
  __int64 v23; // [rsp+94h] [rbp-5h]
  int v24; // [rsp+9Ch] [rbp+3h]
  __int64 v25; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v26; // [rsp+A8h] [rbp+Fh]
  __int64 v27; // [rsp+B0h] [rbp+17h]
  __int64 v28; // [rsp+B8h] [rbp+1Fh]

  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149A143C8 )
    return sub_1403C5370(a1, a2, a3);
  v8 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v8 )
      {
        n0x1600 = 0x1600;
        v16 = 0;
        v17 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v18 = 1;
        qword_149A0FD80(&n0x1600, 0, &Source, &Source, 0);
        v13 = a2;
        qword_1499FF3E8(a1, &v13, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        v19 = __rdtsc();
        qword_149A0FD88(&n0x1600);
      }
      else
      {
        v11 = a2 + 2;
        v12 = _InterlockedCompareExchange(a1, a2 + 2, a2);
        v10 = a2 == v12;
        a2 = v12;
        if ( v10 )
        {
          n0x1600_1 = 0x1600;
          v23 = 0;
          v24 = 0;
          v26 = 0;
          v8 = 1;
          v27 = 0;
          v28 = 0;
          v25 = 1;
          qword_149A0FD80(&n0x1600_1, 0, &Source, &Source, 0);
          v14[0] = v11;
          qword_1499FF3E8(a1, v14, 4, 0xFFFFFFFFLL);
          a2 = *a1;
          v26 = __rdtsc();
          qword_149A0FD88(&n0x1600_1);
        }
      }
    }
    v9 = (a2 | 1) - 2;
    if ( !v8 )
      v9 = a2 | 1;
    result = (unsigned int)_InterlockedCompareExchange(a1, v9, a2);
    v10 = a2 == (_DWORD)result;
    a2 = result;
  }
  while ( !v10 );
  return result;
}

// --- End Function: sub_1403C51B0 (0x1403C51B0) ---

// --- Function: sub_1403CD0A0 (0x1403CD0A0) ---
void __fastcall sub_1403CD0A0(volatile signed __int64 *a1, signed __int64 a2, __int64 a3, __int64 a4, char a5)
{
  int *p_n0x1600; // rcx
  int v10; // esi
  bool v11; // zf
  signed __int64 v12; // rax
  int v13; // [rsp+30h] [rbp-61h] BYREF
  _DWORD v14[3]; // [rsp+34h] [rbp-5Dh] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-51h] BYREF
  __int64 v16; // [rsp+44h] [rbp-4Dh]
  int v17; // [rsp+4Ch] [rbp-45h]
  __int64 v18; // [rsp+50h] [rbp-41h]
  unsigned __int64 v19; // [rsp+58h] [rbp-39h]
  __int64 v20; // [rsp+60h] [rbp-31h]
  __int64 v21; // [rsp+68h] [rbp-29h]
  int n0x1600; // [rsp+90h] [rbp-1h] BYREF
  __int64 v23; // [rsp+94h] [rbp+3h]
  int v24; // [rsp+9Ch] [rbp+Bh]
  __int64 v25; // [rsp+A0h] [rbp+Fh]
  unsigned __int64 v26; // [rsp+A8h] [rbp+17h]
  __int64 v27; // [rsp+B0h] [rbp+1Fh]
  __int64 v28; // [rsp+B8h] [rbp+27h]

  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149A143C8 )
  {
    sub_1403CD260(a1, a2, a3, a4);
    return;
  }
  if ( (a2 & 0x200000) != 0 )
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, volatile signed __int64 *))(*(_QWORD *)qword_149A14308 + 0x128LL))(
          qword_149A14308,
          a1);
      if ( (a2 & 0x100000) != 0 )
        break;
      v10 = a2 | 0x100000;
      v12 = _InterlockedCompareExchange64(a1, a2 | 0x100000, a2);
      v11 = a2 == v12;
      a2 = v12;
      if ( v11 )
      {
        n0x1600 = 0x1600;
        v23 = 0;
        v24 = 0;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        v25 = 1;
        qword_149A0FD80(&n0x1600, 0, &Source, &Source, 0);
        v14[0] = v10;
        qword_1499FF3E8(a1, v14, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        p_n0x1600 = &n0x1600;
        v26 = __rdtsc();
        goto LABEL_12;
      }
LABEL_13:
      if ( (a2 & 0x200000) == 0 )
        return;
    }
    n0x1600_1 = 0x1600;
    v16 = 0;
    v17 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v18 = 1;
    qword_149A0FD80(&n0x1600_1, 0, &Source, &Source, 0);
    v13 = a2;
    qword_1499FF3E8(a1, &v13, 4, 0xFFFFFFFFLL);
    a2 = *a1;
    p_n0x1600 = &n0x1600_1;
    v19 = __rdtsc();
LABEL_12:
    qword_149A0FD88(p_n0x1600);
    goto LABEL_13;
  }
}

// --- End Function: sub_1403CD0A0 (0x1403CD0A0) ---

// --- Function: sub_1403D11A0 (0x1403D11A0) ---
__int64 __fastcall sub_1403D11A0(__int64 a1)
{
  unsigned __int64 n4; // rdi
  __int64 v3; // rdx
  bool v4; // zf
  unsigned __int64 v5; // rdx
  __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  __int64 result; // rax

  n4 = 4;
  if ( *(_WORD *)(a1 + 0x28) > 4u )
  {
    do
    {
      v3 = *(_QWORD *)(a1 + 0x20) - 0x20LL;
      v4 = *(_DWORD *)(v3 + 8 * n4) == 0xF0000000;
      v5 = v3 + 8 * n4;
      if ( !v4 )
        (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(qword_149A14208, v5);
      v6 = *(_QWORD *)(a1 + 0x20) - 0x1CLL;
      v4 = *(_DWORD *)(v6 + 8 * n4) == 0xF0000000;
      v7 = v6 + 8 * n4;
      if ( !v4 )
        (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(qword_149A14208, v7);
      ++n4;
    }
    while ( n4 < *(unsigned __int16 *)(a1 + 0x28) );
  }
  sub_14753C530(*(const void **)(a1 + 0x20));
  result = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x28) = 0;
  if ( *(_DWORD *)a1 != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(qword_149A14208, a1);
  if ( *(_DWORD *)(a1 + 4) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 4);
  if ( *(_DWORD *)(a1 + 8) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 8);
  if ( *(_DWORD *)(a1 + 0xC) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 0xC);
  if ( *(_DWORD *)(a1 + 0x10) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 0x10);
  if ( *(_DWORD *)(a1 + 0x14) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 0x14);
  if ( *(_DWORD *)(a1 + 0x18) != 0xF0000000 )
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
               qword_149A14208,
               a1 + 0x18);
  if ( *(_DWORD *)(a1 + 0x1C) != 0xF0000000 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14208 + 0xF8LL))(
             qword_149A14208,
             a1 + 0x1C);
  return result;
}

// --- End Function: sub_1403D11A0 (0x1403D11A0) ---

// --- Function: sub_1403DC5C0 (0x1403DC5C0) ---
__int64 __fastcall sub_1403DC5C0(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  double *v6; // rax
  __int64 result; // rax

  v1 = dword_149A01F3C;
  if ( !dword_149A01F3C )
  {
    v3 = sub_1402D4390(0x46u, 8, 0, 2);
    v4 = sub_1402CC2B0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D4390(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402E3480((unsigned __int8 *)"CItemInventoryContainerComponentParams", v5 ^ 0xFFFFFFu);
    v6 = (double *)allocWithProfilerInfo(0x28u, 0);
    *(__m256i *)v6 = *(__m256i *)"SCItemInventoryContainerComponentParams";
    v6[4] = *(double *)"tParams";
    dword_149A01F3C = v1;
    if ( v6 )
    {
      __asm { vzeroupper }
      sub_14753C530(v6);
      v1 = dword_149A01F3C;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1403DC5C0 (0x1403DC5C0) ---

// --- Function: sub_1403DCC00 (0x1403DCC00) ---
__int64 __fastcall sub_1403DCC00(volatile signed __int32 *a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  __int64 result; // rax
  int v7; // [rsp+50h] [rbp+8h] BYREF
  int v8; // [rsp+58h] [rbp+10h] BYREF
  __int64 v9; // [rsp+60h] [rbp+18h] BYREF
  __int64 v10; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149A14308 + 0xF8LL))(
        qword_149A14308,
        &v9,
        &v8);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(0xC0 * (((unsigned __int64)a2 >> 0x10) & (unsigned int)(v8 - 1)) + v9 + 0x24);
      if ( v5 != 0xFFFFFFFF )
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
    }
    result = (unsigned int)_InterlockedCompareExchange(a1, v4, a2);
    if ( a2 == (_DWORD)result )
      break;
    a2 = result;
  }
  if ( (a2 & 0xFFFE) != 0 )
    return qword_1499FF3F0(a1);
  if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149A14308 + 0xF8LL))(
      qword_149A14308,
      &v10,
      &v7);
    *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned __int64)(unsigned int)(v7 - 1)) + v10 + 0x1C) = (unsigned __int16)(HIWORD(a2) + v7);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149A14308 + 0xD8LL))(qword_149A14308);
  }
  return result;
}

// --- End Function: sub_1403DCC00 (0x1403DCC00) ---

// --- Function: sub_1403DE750 (0x1403DE750) ---
__int64 __fastcall sub_1403DE750(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, char a6)
{
  if ( a6 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149A143C8 )
    return sub_1403DE7E0(a1, a2, a3, a4, a5);
  else
    return sub_1403DE9B0(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DE750 (0x1403DE750) ---

// --- Function: sub_1403DEBA0 (0x1403DEBA0) ---
__int64 __fastcall sub_1403DEBA0(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rdi
  __int64 v9; // r8
  int v10; // ecx
  __int64 v11; // r8
  unsigned __int64 v12; // rbx
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149A14308 + 0xF8LL))(
        qword_149A14308,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned int)(v14 - 1)) + v16 + 0x24);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    v6 = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
      qword_1499FF3F8(a1);
    result = 0xFFFF00000000LL;
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v8 = qword_149A14308;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149A14308 + 0xF8LL))(
        qword_149A14308,
        &v15,
        &v13);
      v9 = v15 + 0xC0 * (WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1));
      LODWORD(a2) = *(_DWORD *)(v9 + 0x24);
      *(_DWORD *)(v9 + 0x1C) = (unsigned __int16)(WORD2(a2) + v13);
      for ( result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8);
            (_DWORD)a2 != 0xFFFFFFFF;
            result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8) )
      {
        v10 = (unsigned __int16)(a2 + v13);
        v11 = v15 + 0xC0LL * ((unsigned int)a2 & (v13 - 1));
        LODWORD(a2) = *(_DWORD *)(v11 + 0x24);
        *(_DWORD *)(v11 + 0x1C) = v10;
      }
    }
  }
  else
  {
    result = 0xFFC00000LL;
    if ( (a2 & 0xFFC00000) != 0 )
    {
      return qword_1499FF3F0(a1);
    }
    else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149A14308 + 0xF8LL))(
        qword_149A14308,
        &v15,
        &v13);
      v12 = HIWORD(a2);
      *(_DWORD *)(0xC0LL * ((unsigned int)v12 & (v13 - 1)) + v15 + 0x1C) = (unsigned __int16)(v12 + v13);
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149A14308 + 0xD8LL))(
               qword_149A14308,
               (unsigned int)v12);
    }
  }
  return result;
}

// --- End Function: sub_1403DEBA0 (0x1403DEBA0) ---

// --- Function: sub_1403E4B00 (0x1403E4B00) ---
__int64 __fastcall sub_1403E4B00(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __m128i v4; // rax
  __m128i v5; // rt0
  __m128i v7; // [rsp+10h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    v5.m128i_i64[0] = v2.m128i_i64[0];
    v5.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, epi64 + 1, *(_QWORD *)v2.m128i_i64[0], v5.m128i_i64);
    v4 = v5;
    v7 = v5;
    if ( *(_OWORD *)&v5 == __PAIR128__(epi64, v2.m128i_u64[0]) )
      break;
    v2 = v7;
    if ( !v4.m128i_i64[0] )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_1403E4B00 (0x1403E4B00) ---

// --- Function: sub_1403E58B0 (0x1403E58B0) ---
__int64 __fastcall sub_1403E58B0(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( *a1 != a1[1] )
    a1[1] = result;
  return result;
}

// --- End Function: sub_1403E58B0 (0x1403E58B0) ---

// --- Function: sub_1403E6140 (0x1403E6140) ---
__int64 sub_1403E6140()
{
  return sub_1402A63D0(1u);
}

// --- End Function: sub_1403E6140 (0x1403E6140) ---

// --- Function: sub_1403E6440 (0x1403E6440) ---
__int64 __fastcall sub_1403E6440(__int64 a1)
{
  return sub_1402A63C0(a1);
}

// --- End Function: sub_1403E6440 (0x1403E6440) ---

// --- Function: sub_1403E7D30 (0x1403E7D30) ---
__int64 __fastcall sub_1403E7D30(unsigned __int64 *a1)
{
  if ( is_valid_handle_typeB(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E7D30 (0x1403E7D30) ---

// --- Function: sub_1403E8DD0 (0x1403E8DD0) ---
char __fastcall sub_1403E8DD0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E8DD0 (0x1403E8DD0) ---

// --- Function: sub_1403EC6E0 (0x1403EC6E0) ---
__int64 __fastcall sub_1403EC6E0(__int64 a1, __int64 a2, unsigned __int64 n0xC_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n0xC_1 > 0 )
  {
    if ( n0xC_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n0xC_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F5A60(a1, (unsigned int)n0xC + a2, n0xC_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F5400(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F5650(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F52B0(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n0xC_1 )
    {
LABEL_46:
      if ( n0xC_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EC6E0 (0x1403EC6E0) ---

// --- Function: sub_1403ECB40 (0x1403ECB40) ---
// attributes: thunk
__int64 __fastcall sub_1403ECB40(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1404F5A60(a1, a2, a3);
}

// --- End Function: sub_1403ECB40 (0x1403ECB40) ---

// --- Function: is_valid_handle_typeB_w (0x1403F9130) ---
bool __fastcall sub_1403F9130(unsigned __int64 *a1)
{
  return !is_valid_handle_typeB(a1);
}

// --- End Function: is_valid_handle_typeB_w (0x1403F9130) ---

// --- Function: sub_140420260 (0x140420260) ---
void __fastcall sub_140420260(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
}

// --- End Function: sub_140420260 (0x140420260) ---

// --- Function: sub_140424A80 (0x140424A80) ---
_QWORD *__fastcall sub_140424A80(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( is_valid_handle_typeB(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = ::n0xFFFF_1;
    if ( ::n0xFFFF_1 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                            qword_149A14298,
                            &v9,
                            "IAttachableComponent");
      ::n0xFFFF_1 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_140424A80 (0x140424A80) ---

// --- Function: sub_1404251A0 (0x1404251A0) ---
_QWORD *__fastcall sub_1404251A0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_12;
  if ( n0xFFFF_12 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                          qword_149A14298,
                          &v9,
                          "IInteractableComponent");
    n0xFFFF_12 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1404251A0 (0x1404251A0) ---

// --- Function: sub_140456A20 (0x140456A20) ---
__int64 __fastcall sub_140456A20(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_DWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_DWORD *)(a1 + 0x5C) = 0;
  result = a1;
  *(_DWORD *)(a1 + 0x4C) = 8;
  *(_DWORD *)(a1 + 0x58) = 0xFFFFFFFF;
  return result;
}

// --- End Function: sub_140456A20 (0x140456A20) ---

// --- Function: sub_140456C10 (0x140456C10) ---
__int64 __fastcall sub_140456C10(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        __int64 a6,
        void *a7,
        unsigned __int8 n4_1,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int8 n4; // dl
  __int64 v13; // rcx

  *(_OWORD *)a1 = *(_OWORD *)a3;
  *(double *)(a1 + 0x10) = *(double *)(a3 + 0x10);
  *(double *)(a1 + 0x18) = *(double *)a4;
  n4 = 4;
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a4 + 8);
  *(_QWORD *)(a1 + 0x28) = a6;
  *(_DWORD *)(a1 + 0x30) = a5;
  *(_QWORD *)(a1 + 0x38) = a9;
  *(_BYTE *)(a1 + 0x34) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_DWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_DWORD *)(a1 + 0x9C) = 0;
  *(_DWORD *)(a1 + 0x8C) = 8;
  *(_DWORD *)(a1 + 0x98) = 0xFFFFFFFF;
  if ( n4_1 <= 4u )
    n4 = n4_1;
  *(_BYTE *)(a1 + 0xA0) = n4;
  v13 = *a10;
  *(_QWORD *)(a1 + 0xA8) = *a10;
  if ( v13 )
    sub_140524420(v13);
  *(_QWORD *)(a1 + 0xB0) = a2;
  if ( a7 )
    sub_14046B1B0((void *)(a1 + 0x40), a7);
  if ( *a10 )
    sub_140524440(*a10, 0);
  return a1;
}

// --- End Function: sub_140456C10 (0x140456C10) ---

// --- Function: sub_14045EEE0 (0x14045EEE0) ---
__int64 __fastcall sub_14045EEE0(__int64 a1)
{
  *(_QWORD *)(a1 + 0x1C) = 3;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_DWORD *)(a1 + 0x18) = 0;
  *(_DWORD *)(a1 + 0x24) = 0;
  return a1;
}

// --- End Function: sub_14045EEE0 (0x14045EEE0) ---

// --- Function: sub_1404659E0 (0x1404659E0) ---
signed __int64 __fastcall sub_1404659E0(__int64 a1)
{
  __int64 v2; // rbx
  signed __int64 n0x200000; // rax
  int v4; // edi
  const void *v5; // rcx
  int v6; // eax

  v2 = a1 + 0x50;
  n0x200000 = NtCurrentTeb_w();
  v4 = *(_DWORD *)(n0x200000 + 0x18);
  if ( *(_DWORD *)(v2 + 8) == v4 )
  {
    ++*(_DWORD *)(v2 + 0xC);
  }
  else
  {
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( n0x200000 )
      n0x200000 = sub_1403DE750(v2, n0x200000, 0, (__int64)&Source, (__int64)&Source, 0);
    *(_DWORD *)(v2 + 8) = v4;
  }
  v5 = *(const void **)(a1 + 0x40);
  if ( v5 )
    n0x200000 = sub_14753C530(v5);
  if ( v2 )
  {
    v6 = *(_DWORD *)(v2 + 0xC);
    if ( v6 )
    {
      n0x200000 = (unsigned int)(v6 - 1);
      *(_DWORD *)(v2 + 0xC) = n0x200000;
    }
    else
    {
      *(_DWORD *)(v2 + 8) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0, 0x200000);
      if ( n0x200000 != 0x200000 )
        return sub_1403DEBA0((volatile signed __int64 *)v2, n0x200000);
    }
  }
  return n0x200000;
}

// --- End Function: sub_1404659E0 (0x1404659E0) ---

// --- Function: sub_140465AE0 (0x140465AE0) ---
__int64 __fastcall sub_140465AE0(__int64 a1)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 0xA8);
  if ( v2 )
    sub_140524440(v2, 0);
  return sub_1404659E0(a1 + 0x40);
}

// --- End Function: sub_140465AE0 (0x140465AE0) ---

// --- Function: sub_140469AA0 (0x140469AA0) ---
__int64 *__fastcall sub_140469AA0(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v4; // rcx

  v2 = *a2;
  *a2 = 0;
  v4 = *a1;
  *a1 = v2;
  if ( v4 )
    sub_140524440(v4, 0);
  return a1;
}

// --- End Function: sub_140469AA0 (0x140469AA0) ---

// --- Function: sub_140469D50 (0x140469D50) ---
__int64 *__fastcall sub_140469D50(__int64 *a1, __int64 *a2)
{
  __int64 v3; // r9
  unsigned __int64 v4; // rdx

  if ( a1 != a2 )
  {
    v3 = *a2;
    v4 = (__int64)((unsigned __int128)((a2[1] - *a2) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 2;
    sub_14042F3A0(a1, v3, v4 + (v4 >> 0x3F));
  }
  return a1;
}

// --- End Function: sub_140469D50 (0x140469D50) ---

// --- Function: sub_1404A1180 (0x1404A1180) ---
__int64 __fastcall sub_1404A1180(char *a1, char *Src, int n8_1, int n8_4)
{
  __int64 n8_3; // r14
  char *v5; // rdi
  char *v8; // rbx
  int v9; // r15d
  __int64 v10; // rax
  int n8; // eax
  int n8_2; // eax
  void *v13; // rax
  void *v14; // rbp
  const void *v15; // rcx
  unsigned __int8 v16; // bl
  int *v17; // rdx
  __int64 v18; // rcx
  int v19; // ecx
  signed __int64 v20; // rsi
  int v21; // ecx
  unsigned __int64 n0x200000; // rax

  n8_3 = n8_4;
  v5 = a1 + 0x50;
  v8 = a1;
  v9 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *((_DWORD *)v5 + 2) == v9 )
  {
    ++*((_DWORD *)v5 + 3);
  }
  else
  {
    v10 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
    if ( v10 )
      sub_1403DE750((__int64)v5, v10, 0, (__int64)&Source, (__int64)&Source, 0);
    *((_DWORD *)v5 + 2) = v9;
  }
  n8 = *((_DWORD *)v8 + 0x13);
  if ( (int)n8_3 <= n8 )
  {
    v17 = (int *)(v8 + 0x48);
    if ( n8 < n8_1 )
      n8_1 = *((_DWORD *)v8 + 0x13);
    *v17 = n8_1;
    if ( n8 > 8 )
      v8 = (char *)*((_QWORD *)v8 + 8);
    if ( n8_1 > 8 || (v18 = 8LL * n8_1, v8 <= &Src[v18]) && Src <= &v8[v18] )
    {
      memmove(v8, Src, 8LL * n8_1);
    }
    else
    {
      v19 = 0;
      if ( n8_1 > 0 )
      {
        v20 = Src - v8;
        do
        {
          ++v19;
          *(_QWORD *)v8 = *(_QWORD *)&v8[v20];
          v8 += 8;
        }
        while ( v19 < *v17 );
      }
    }
  }
  else
  {
    n8_2 = n8_3;
    *((_DWORD *)v8 + 0x13) = n8_3;
    if ( (int)n8_3 >= n8_1 )
      n8_2 = n8_1;
    *((_DWORD *)v8 + 0x12) = n8_2;
    v13 = (void *)allocWithProfilerInfo(8 * n8_3, 0);
    v14 = v13;
    if ( !v13 )
    {
      v16 = 0;
      goto LABEL_27;
    }
    memcpy(v13, Src, 8LL * *((int *)v8 + 0x12));
    v15 = (const void *)*((_QWORD *)v8 + 8);
    if ( v15 )
      sub_14753C530(v15);
    *((_QWORD *)v8 + 8) = v14;
  }
  v16 = 1;
LABEL_27:
  if ( v5 )
  {
    v21 = *((_DWORD *)v5 + 3);
    if ( v21 )
    {
      *((_DWORD *)v5 + 3) = v21 - 1;
    }
    else
    {
      *((_DWORD *)v5 + 2) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
      if ( n0x200000 != 0x200000 )
        sub_1403DEBA0((volatile signed __int64 *)v5, n0x200000);
    }
  }
  return v16;
}

// --- End Function: sub_1404A1180 (0x1404A1180) ---

// --- Function: sub_1404B5860 (0x1404B5860) ---
_QWORD *sub_1404B5860()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( !v0 )
  {
    sub_14053B400("fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A63D0(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_147FF5D90);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B5860 (0x1404B5860) ---

// --- Function: getThreadLogContextSlot (0x1404BF640) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
int *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n0xF; // rax

  v0 = sub_1404B5860();
  v1 = v0;
  if ( !v0 )
    return &qword_149A09EF0;
  n0xF = *v0;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (int *)&v1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BF640) ---

// --- Function: sub_1404C8CA0 (0x1404C8CA0) ---
bool __fastcall sub_1404C8CA0(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 0x24) - 1) <= 1;
}

// --- End Function: sub_1404C8CA0 (0x1404C8CA0) ---

// --- Function: j_acosf (0x140500500) ---
// attributes: thunk
float __cdecl j_acosf(float X)
{
  return acosf(X);
}

// --- End Function: j_acosf (0x140500500) ---

// --- Function: sub_140524440 (0x140524440) ---
__int64 __fastcall sub_140524440(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149A14210 + 0x228LL))(qword_149A14210, a1);
}

// --- End Function: sub_140524440 (0x140524440) ---

// --- Function: sub_140526950 (0x140526950) ---
unsigned __int64 __fastcall sub_140526950(__int64 a1)
{
  unsigned __int64 result; // rax

  result = (*(_QWORD *)(a1 + 8) + 0x47LL) & 0xFFFFFFFFFFFFFFF8uLL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_140526950 (0x140526950) ---

// --- Function: sub_140526B10 (0x140526B10) ---
void __fastcall sub_140526B10(__int64 a1)
{
  ++*(_QWORD *)(a1 + 8);
}

// --- End Function: sub_140526B10 (0x140526B10) ---

// --- Function: is_thread_flag_57_or_38_set (0x14053B450) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x39) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x26) != 0;
}

// --- End Function: is_thread_flag_57_or_38_set (0x14053B450) ---

// --- Function: sub_14056BB30 (0x14056BB30) ---
char __fastcall sub_14056BB30(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 86:
    case 87:
    case 88:
    case 89:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 66:
      n2 = 9;
      break;
    case 33:
    case 44:
    case 45:
    case 48:
    case 50:
    case 52:
    case 53:
    case 57:
    case 58:
    case 60:
    case 68:
    case 69:
    case 76:
      n2 = 21;
      break;
    case 34:
    case 77:
    case 98:
    case 99:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 63:
      n2 = 29;
      break;
    case 38:
    case 74:
      n2 = 5;
      break;
    case 39:
      n2 = 6;
      break;
    case 40:
      n2 = 8;
      break;
    case 41:
    case 42:
      n2 = 24;
      break;
    case 43:
    case 47:
    case 62:
    case 65:
      n2 = 27;
      break;
    case 46:
      n2 = 28;
      break;
    case 49:
    case 55:
    case 59:
    case 64:
    case 71:
    case 72:
    case 73:
    case 79:
      n2 = 23;
      break;
    case 51:
    case 54:
    case 70:
    case 80:
      n2 = 26;
      break;
    case 56:
    case 61:
    case 81:
    case 82:
      n2 = 25;
      break;
    case 67:
      n2 = 17;
      break;
    case 78:
      n2 = 19;
      break;
    case 83:
      n2 = 22;
      break;
    case 84:
    case 85:
      n2 = 10;
      break;
    case 90:
    case 91:
      n2 = 20;
      break;
    case 92:
    case 93:
      n2 = 11;
      break;
    case 94:
      n2 = 12;
      break;
    case 95:
    case 96:
    case 97:
      n2 = 13;
      break;
    case 100:
    case 101:
      n2 = 14;
      break;
    case 102:
      n2 = 15;
      break;
    case 103:
    case 104:
      n2 = 16;
      break;
    case 105:
      n2 = 18;
      break;
    case 106:
      n2 = 30;
      break;
    case 107:
      n2 = 50;
      break;
    case 108:
      n2 = 51;
      break;
    case 109:
      n2 = 52;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056BB30 (0x14056BB30) ---

// --- Function: sub_140598C00 (0x140598C00) ---
_QWORD *__fastcall sub_140598C00(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_140598C00 (0x140598C00) ---

// --- Function: sub_140598DA0 (0x140598DA0) ---
__m128 sub_140598DA0()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_140598DA0 (0x140598DA0) ---

// --- Function: sub_1405B14C0 (0x1405B14C0) ---
__int64 __fastcall sub_1405B14C0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_1405B14C0 (0x1405B14C0) ---

// --- Function: LogFatalError (0x1405C2190) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  __int64 *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149A14170;
  if ( !qword_149A14170 )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&qword_149A14170);
    v1 = (__int64 (*)(void))qword_149A14170;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149A143C8 || !qword_149A142B0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A6A10();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149A142B0 + 0x118LL))(
                      qword_149A142B0,
                      &format_string_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C2190) ---

// --- Function: sub_1409144C0 (0x1409144C0) ---
__int64 __fastcall sub_1409144C0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x330);
}

// --- End Function: sub_1409144C0 (0x1409144C0) ---

// --- Function: sub_1411D16B0 (0x1411D16B0) ---
__int64 __fastcall sub_1411D16B0(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))a1)(a2, *(_QWORD *)(a1 + 0x10), *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1411D16B0 (0x1411D16B0) ---

// --- Function: sub_14121F840 (0x14121F840) ---
__int64 __fastcall sub_14121F840(__int64 a1, __int64 a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(double *)(a1 + 0x10) = *(double *)(a2 + 0x10);
  return a1;
}

// --- End Function: sub_14121F840 (0x14121F840) ---

// --- Function: sub_14121F860 (0x14121F860) ---
__int64 __fastcall sub_14121F860(__int64 a1, int a2, _OWORD *a3)
{
  *(_OWORD *)(a1 + 8) = *a3;
  *(_DWORD *)a1 = a2;
  return a1;
}

// --- End Function: sub_14121F860 (0x14121F860) ---

// --- Function: sub_14128E500 (0x14128E500) ---
__int64 __fastcall sub_14128E500(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  char *ResourceTypeVolatility; // rcx

  v1 = dword_149B838C0;
  if ( !dword_149B838C0 )
  {
    v3 = sub_1402D4390(0x46u, 8, 0x80u, 2);
    v4 = sub_1402CC2B0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D4390(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402E3480((unsigned __int8 *)"esourceTypeVolatility", v5 ^ 0xFFFFFFu);
    ResourceTypeVolatility = (char *)allocWithProfilerInfo(0x17u, 0);
    strcpy(ResourceTypeVolatility, "ResourceTypeVolatility");
    dword_149B838C0 = v1;
    if ( ResourceTypeVolatility )
    {
      sub_14753C530(ResourceTypeVolatility);
      v1 = dword_149B838C0;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_14128E500 (0x14128E500) ---

// --- Function: sub_141298CE0 (0x141298CE0) ---
_QWORD *__fastcall sub_141298CE0(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v5)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+50h] [rbp+18h] BYREF
  char v9; // [rsp+58h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149A14290 + 0x118LL))(qword_149A14290);
  v3 = v2;
  if ( v2 )
  {
    n0xFFFF = ::n0xFFFF_1;
    v5 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v2 + 0x340LL);
    if ( ::n0xFFFF_1 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                            qword_149A14298,
                            &v8,
                            "IAttachableComponent");
      ::n0xFFFF_1 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v5(v3, &v9, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_141298CE0 (0x141298CE0) ---

// --- Function: sub_14132EBA0 (0x14132EBA0) ---
__int64 __fastcall sub_14132EBA0(char *Src, char *Src_3)
{
  unsigned __int8 v2; // bp
  char *Src_4; // rdi
  char *v5; // rsi
  int v6; // r14d
  __int64 v7; // rax
  volatile signed __int64 *v8; // r15
  signed __int64 v9; // rdx
  int *v10; // rdx
  int n8; // r8d
  __int64 n8_1; // r14
  int v13; // ecx
  bool v14; // sf
  int v15; // ecx
  int v16; // eax
  int n8_2; // eax
  char *Src_1; // rdx
  char *Src_2; // rcx
  __int64 v20; // r10
  __int64 i; // r8
  __int64 v22; // rax
  int v23; // ecx
  unsigned __int64 n0x200000; // rax

  v2 = 0;
  Src_4 = Src_3;
  if ( Src_3 && Src_3 != Src )
  {
    v5 = Src + 0x50;
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *((_DWORD *)v5 + 2) == v6 )
    {
      ++*((_DWORD *)v5 + 3);
    }
    else
    {
      v7 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
      if ( v7 )
        sub_1403DE750((__int64)v5, v7, 0, (__int64)&Source, (__int64)&Source, 0);
      *((_DWORD *)v5 + 2) = v6;
    }
    v8 = (volatile signed __int64 *)(Src_4 + 0x50);
    if ( *((_DWORD *)Src_4 + 0x16) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*((_DWORD *)Src_4 + 0x17);
    }
    else
    {
      v9 = _InterlockedIncrement64(v8);
      if ( (v9 & 0x200000) != 0 )
        sub_1403CD0A0((volatile signed __int64 *)Src_4 + 0xA, v9, (__int64)&Source, (__int64)&Source, 0);
    }
    v10 = (int *)(Src_4 + 0x48);
    n8 = *((_DWORD *)Src + 0x13);
    n8_1 = *((int *)Src + 0x12);
    v13 = *((_DWORD *)Src_4 + 0x12) - n8;
    v14 = (int)n8_1 + v13 < 0;
    v15 = n8_1 + v13;
    v16 = 0;
    if ( !v14 )
      v16 = v15;
    if ( v16 )
    {
      n8_2 = n8 + (((((v16 + 0xF) >> 0x1F) & 0xF) + v16 + 0xF) & 0xFFFFFFF0);
      if ( n8 <= 8 )
        Src_1 = Src;
      else
        Src_1 = (char *)*((_QWORD *)Src + 8);
      sub_1404A1180(Src, Src_1, n8_1, n8_2);
      v10 = (int *)(Src_4 + 0x48);
    }
    if ( *((int *)Src + 0x13) <= 8 )
      Src_2 = Src;
    else
      Src_2 = (char *)*((_QWORD *)Src + 8);
    if ( *((int *)Src_4 + 0x13) > 8 )
      Src_4 = (char *)*((_QWORD *)Src_4 + 8);
    v20 = *v10;
    if ( v20 > 0 )
    {
      for ( i = 0; i < v20; ++i )
      {
        v22 = 0;
        if ( n8_1 <= 0 )
        {
LABEL_29:
          v2 = 1;
          *(_QWORD *)&Src_2[8 * (*((_DWORD *)Src + 0x12))++] = *(_QWORD *)&Src_4[8 * i];
        }
        else
        {
          while ( *(_QWORD *)&Src_2[8 * v22] != *(_QWORD *)&Src_4[8 * i] )
          {
            if ( ++v22 >= n8_1 )
              goto LABEL_29;
          }
        }
      }
    }
    sub_1402D42F0((__int64)v8);
    if ( v5 )
    {
      v23 = *((_DWORD *)v5 + 3);
      if ( v23 )
      {
        *((_DWORD *)v5 + 3) = v23 - 1;
      }
      else
      {
        *((_DWORD *)v5 + 2) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
        if ( n0x200000 != 0x200000 )
          sub_1403DEBA0((volatile signed __int64 *)v5, n0x200000);
      }
    }
  }
  return v2;
}

// --- End Function: sub_14132EBA0 (0x14132EBA0) ---

// --- Function: sub_1414F2610 (0x1414F2610) ---
_QWORD *__fastcall sub_1414F2610(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( is_valid_handle_typeB(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_13;
    if ( n0xFFFF_13 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                            qword_149A14298,
                            &v8,
                            "IActor");
      n0xFFFF_13 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_1414F2610 (0x1414F2610) ---

// --- Function: sub_1414F3F40 (0x1414F3F40) ---
_QWORD *__fastcall sub_1414F3F40(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rcx
  _QWORD *result; // rax
  __int64 v5; // [rsp+38h] [rbp+10h] BYREF

  v3 = *sub_1414F2610(a1, &v5);
  result = a2;
  *a2 = v3;
  return result;
}

// --- End Function: sub_1414F3F40 (0x1414F3F40) ---

// --- Function: sub_1414FBA20 (0x1414FBA20) ---
_QWORD *__fastcall sub_1414FBA20(_QWORD *a1, __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  a1[2] = a2;
  if ( a2 )
  {
    memcpy(a1, a4, Size);
    if ( Size < 8 )
      memset((char *)a1 + Size, 0, 8 - Size);
    return a1;
  }
  else
  {
    *a1 = a3;
    return a1;
  }
}

// --- End Function: sub_1414FBA20 (0x1414FBA20) ---

// --- Function: sub_1414FD2D0 (0x1414FD2D0) ---
// attributes: thunk
__int64 __fastcall sub_1414FD2D0(_QWORD *a1)
{
  return sub_14030D6A0(a1);
}

// --- End Function: sub_1414FD2D0 (0x1414FD2D0) ---

// --- Function: sub_1414FDE20 (0x1414FDE20) ---
float __fastcall sub_1414FDE20(__int64 a1)
{
  return *(float *)(a1 + 0x44);
}

// --- End Function: sub_1414FDE20 (0x1414FDE20) ---

// --- Function: sub_141504DB0 (0x141504DB0) ---
__int64 __fastcall sub_141504DB0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 0x10) + 0x18LL))(*(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_141504DB0 (0x141504DB0) ---

// --- Function: sub_141505CB0 (0x141505CB0) ---
void __fastcall sub_141505CB0(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __m256i *v5; // rdi
  __m256i *v6; // rax
  __m256i *v7; // rcx

  if ( !a1 )
  {
    v5 = (__m256i *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
        __asm { vzeroupper }
        return;
      }
      v6 = (__m256i *)sub_1402A63D0(0x20u);
      v7 = v6;
      if ( v6 )
        *v6 = *v5;
      else
        v7 = 0;
      a2[2] = (__int64 (__fastcall *)(__int64))v7;
      *a2 = sub_141504DB0;
      a2[1] = (__int64 (__fastcall *)(__int64))sub_141505CB0;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      sub_1402A63C0((__int64)a2[2]);
      a2[2] = 0;
      *a2 = 0;
      a2[1] = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
  {
    a2[2] = 0;
    *a2 = *a3;
    a2[1] = (__int64 (__fastcall *)(__int64))1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    a2[2] = a3[2];
    *a2 = *a3;
    a2[1] = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_141505CB0 (0x141505CB0) ---

// --- Function: sub_1415321E0 (0x1415321E0) ---
_QWORD *__fastcall sub_1415321E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_9;
  if ( n0xFFFF_9 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                          qword_149A14298,
                          &v9,
                          "IGreenZoneObedience");
    n0xFFFF_9 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1415321E0 (0x1415321E0) ---

// --- Function: sub_14153E400 (0x14153E400) ---
unsigned __int64 __fastcall sub_14153E400(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbx
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r15
  unsigned __int64 allocSize; // rcx
  unsigned __int64 v12; // rcx
  __int64 v13; // rax
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // r13
  __int64 v16; // rbp
  __int64 v17; // rbx
  _DWORD *v18; // r14
  __int16 v19; // dx
  __int16 v20; // ax
  __int64 v21; // rbx
  __int64 i; // rbp
  __int64 v23; // r8
  unsigned __int64 result; // rax
  __int64 v25; // [rsp+50h] [rbp+8h]

  v6 = (a2 - *a1) / 0x110;
  v7 = (a1[1] - *a1) / 0x110;
  if ( v7 == 0xF0F0F0F0F0F0F0LL )
    unknown_libname_10();
  v8 = v7 + 1;
  v25 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x110;
  if ( v9 <= 0xF0F0F0F0F0F0F0LL - (v9 >> 1) )
  {
    v12 = v8;
    if ( (v9 >> 1) + v9 >= v8 )
      v12 = (v9 >> 1) + v9;
    if ( v12 > 0xF0F0F0F0F0F0F0LL )
      goto LABEL_30;
    v10 = 0x110 * v12;
    if ( 0x110 * v12 < 0x1000 )
    {
      if ( v10 )
        v14 = sub_1402A63D0(0x110 * v12);
      else
        v14 = 0;
      goto LABEL_14;
    }
    allocSize = v10 + 0x27;
    if ( v10 + 0x27 < v10 )
LABEL_30:
      sub_1402E2610();
  }
  else
  {
    v10 = 0xFFFFFFFFFFFFFF00uLL;
    allocSize = 0xFFFFFFFFFFFFFF27uLL;
  }
  v13 = sub_1402A63D0(allocSize);
  if ( !v13 )
    goto LABEL_28;
  v14 = (v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_14:
  v15 = v14 + 0x110 * v6;
  sub_141541620(a1, v15, a3);
  v16 = a1[1];
  v17 = *a1;
  if ( a2 == v16 )
  {
    if ( v17 != v16 )
    {
      v18 = (_DWORD *)(v14 + 0x100);
      do
      {
        *((_QWORD *)v18 + 0xFFFFFFE0) = *(_QWORD *)v17;
        sub_1415458D0(v18 + 0xFFFFFFC2, v17 + 8);
        *v18 = *(_DWORD *)(v17 + 0x100);
        v18 += 0x44;
        v18[0xFFFFFFBD] = *(_DWORD *)(v17 + 0x104);
        v18[0xFFFFFFBE] = *(_DWORD *)(v17 + 0x108);
        v19 = *(_WORD *)(v17 + 0x10C);
        *((_WORD *)v18 + 0xFFFFFF7E) ^= (v19 ^ *((_WORD *)v18 + 0xFFFFFF7E)) & 0x7FFF;
        v20 = *(_WORD *)(v17 + 0x10C);
        v17 += 0x110;
        *((_WORD *)v18 + 0xFFFFFF7E) = v20 ^ (v19 ^ v20) & 0x7FFF;
      }
      while ( v17 != v16 );
      v8 = v25;
    }
  }
  else
  {
    sub_141540D00(*a1, a2, v14, a1);
    sub_141540D00(a2, a1[1], v15 + 0x110, a1);
  }
  v21 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v21 != i; v21 += 0x110 )
      sub_14154A110(v21 + 8);
    v23 = *a1;
    if ( (unsigned __int64)(0x110 * ((a1[2] - *a1) / 0x110)) < 0x1000 )
      goto LABEL_26;
    if ( (unsigned __int64)(v23 - *(_QWORD *)(v23 - 8) - 8) <= 0x1F )
    {
      v23 = *(_QWORD *)(v23 - 8);
LABEL_26:
      sub_1402A63C0(v23);
      goto LABEL_27;
    }
LABEL_28:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_27:
  *a1 = v14;
  result = v15;
  a1[1] = v14 + 0x110 * v8;
  a1[2] = v10 + v14;
  return result;
}

// --- End Function: sub_14153E400 (0x14153E400) ---

// --- Function: sub_141541620 (0x141541620) ---
__int64 __fastcall sub_141541620(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v5; // rdx
  _QWORD *v6; // rbx
  void (__fastcall *v7)(__int64, _QWORD *, __int64); // rax
  void (__fastcall *n2)(__int64, __int64); // rax
  __int16 v9; // cx
  __int16 v10; // dx
  __int64 result; // rax

  *(_QWORD *)a2 = *(_QWORD *)a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  sub_141545990(a2 + 0x10, a3 + 0x10);
  sub_14035C600(a2 + 0xC8, a3 + 0xC8);
  v5 = (_QWORD *)(a2 + 0xE0);
  v6 = (_QWORD *)(a3 + 0xE0);
  *(_QWORD *)(a2 + 0xE0) = 0;
  *(_QWORD *)(a2 + 0xE8) = 0;
  *(_QWORD *)(a2 + 0xF0) = 0;
  v7 = *(void (__fastcall **)(__int64, _QWORD *, __int64))(a3 + 0xE8);
  if ( v7 == (void (__fastcall *)(__int64, _QWORD *, __int64))1 )
  {
    *v5 = *v6;
    *(_QWORD *)(a2 + 0xE8) = *(_QWORD *)(a3 + 0xE8);
  }
  else
  {
    if ( !v7 )
      goto LABEL_8;
    v7(1, v5, a3 + 0xE0);
  }
  n2 = *(void (__fastcall **)(__int64, __int64))(a3 + 0xE8);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a3 + 0xE0);
    *(_QWORD *)(a3 + 0xE8) = 0;
  }
  *v6 = 0;
LABEL_8:
  *(_BYTE *)(a2 + 0xF8) = *(_BYTE *)(a3 + 0xF8);
  v9 = *(_WORD *)(a2 + 0x10C);
  *(_DWORD *)(a2 + 0x100) = *(_DWORD *)(a3 + 0x100);
  *(_DWORD *)(a2 + 0x104) = *(_DWORD *)(a3 + 0x104);
  *(_DWORD *)(a2 + 0x108) = *(_DWORD *)(a3 + 0x108);
  v10 = *(_WORD *)(a3 + 0x10C);
  *(_WORD *)(a2 + 0x10C) = v9 ^ (v10 ^ v9) & 0x7FFF;
  result = *(unsigned __int16 *)(a3 + 0x10C);
  *(_WORD *)(a2 + 0x10C) = result ^ (result ^ v10) & 0x7FFF;
  return result;
}

// --- End Function: sub_141541620 (0x141541620) ---

// --- Function: sub_141542C60 (0x141542C60) ---
__int64 __fastcall sub_141542C60(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)a1 = off_1480E8408;
  result = a1;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  return result;
}

// --- End Function: sub_141542C60 (0x141542C60) ---

// --- Function: sub_141542CA0 (0x141542CA0) ---
__int64 __fastcall sub_141542CA0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)a1 = off_14834BA30;
  result = a1;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  return result;
}

// --- End Function: sub_141542CA0 (0x141542CA0) ---

// --- Function: sub_1415458D0 (0x1415458D0) ---
__int64 __fastcall sub_1415458D0(__int64 a1, __int64 a2)
{
  void (__fastcall *v4)(_QWORD); // rax
  void (__fastcall *v5)(_QWORD); // rax

  *(_DWORD *)a1 = *(_DWORD *)a2;
  sub_141545990(a1 + 8, a2 + 8);
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0;
  v4 = *(void (__fastcall **)(_QWORD))(a2 + 0xC8);
  if ( v4 == (void (__fastcall *)(_QWORD))1 )
  {
    *(_QWORD *)(a1 + 0xC0) = *(_QWORD *)(a2 + 0xC0);
    *(_QWORD *)(a1 + 0xC8) = *(_QWORD *)(a2 + 0xC8);
  }
  else if ( v4 )
  {
    v4(0);
  }
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = 0;
  *(_QWORD *)(a1 + 0xE8) = 0;
  v5 = *(void (__fastcall **)(_QWORD))(a2 + 0xE0);
  if ( v5 == (void (__fastcall *)(_QWORD))1 )
  {
    *(_QWORD *)(a1 + 0xD8) = *(_QWORD *)(a2 + 0xD8);
    *(_QWORD *)(a1 + 0xE0) = *(_QWORD *)(a2 + 0xE0);
  }
  else if ( v5 )
  {
    v5(0);
  }
  *(_BYTE *)(a1 + 0xF0) = *(_BYTE *)(a2 + 0xF0);
  return a1;
}

// --- End Function: sub_1415458D0 (0x1415458D0) ---

// --- Function: sub_14154A110 (0x14154A110) ---
signed __int64 __fastcall sub_14154A110(_QWORD *a1)
{
  void (__fastcall *n2)(__int64, _QWORD *, _QWORD); // rax
  void (__fastcall *n2_1)(__int64, _QWORD *); // rax
  __int64 v4; // rcx

  n2 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))a1[0x1C];
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1 + 0x1B, 0);
    a1[0x1C] = 0;
  }
  a1[0x1B] = 0;
  n2_1 = (void (__fastcall *)(__int64, _QWORD *))a1[0x19];
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, a1 + 0x18);
    a1[0x19] = 0;
  }
  a1[0x18] = 0;
  v4 = a1[0x16];
  if ( v4 )
    sub_140524440(v4);
  return sub_1404659E0((__int64)(a1 + 9));
}

// --- End Function: sub_14154A110 (0x14154A110) ---

// --- Function: sub_14154B820 (0x14154B820) ---
__int64 __fastcall sub_14154B820(__int64 a1, _BYTE *a2)
{
  if ( !*(_BYTE *)(a1 + 0x28) || *(_BYTE *)(a1 + 0x41) != *a2 )
  {
    *(_BYTE *)(a1 + 0x41) = *a2;
    *(_BYTE *)(a1 + 0x28) = 1;
    sub_140331AE0(a1, 0);
  }
  return a1;
}

// --- End Function: sub_14154B820 (0x14154B820) ---

// --- Function: sub_14154B860 (0x14154B860) ---
__int64 __fastcall sub_14154B860(__int64 a1, _DWORD *a2)
{
  if ( !*(_BYTE *)(a1 + 0x28) || *(float *)a2 != *(float *)(a1 + 0x44) )
  {
    *(_DWORD *)(a1 + 0x44) = *a2;
    *(_BYTE *)(a1 + 0x28) = 1;
    sub_140331AE0(a1, 0);
  }
  return a1;
}

// --- End Function: sub_14154B860 (0x14154B860) ---

// --- Function: sub_14154B990 (0x14154B990) ---
__int64 __fastcall sub_14154B990(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rcx

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(double *)(a1 + 0x10) = *(double *)(a2 + 0x10);
  *(double *)(a1 + 0x18) = *(double *)(a2 + 0x18);
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x20);
  *(_QWORD *)(a1 + 0x28) = *(_QWORD *)(a2 + 0x28);
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x30);
  *(_BYTE *)(a1 + 0x34) = *(_BYTE *)(a2 + 0x34);
  *(_QWORD *)(a1 + 0x38) = *(_QWORD *)(a2 + 0x38);
  sub_14046B1B0((void *)(a1 + 0x40), (void *)(a2 + 0x40));
  *(_BYTE *)(a1 + 0xA0) = *(_BYTE *)(a2 + 0xA0);
  v4 = *(_QWORD *)(a2 + 0xA8);
  if ( v4 )
    sub_140524420(*(_QWORD *)(a2 + 0xA8));
  v5 = *(_QWORD *)(a1 + 0xA8);
  *(_QWORD *)(a1 + 0xA8) = v4;
  if ( v5 )
    sub_140524440(v5);
  *(_QWORD *)(a1 + 0xB0) = *(_QWORD *)(a2 + 0xB0);
  return a1;
}

// --- End Function: sub_14154B990 (0x14154B990) ---

// --- Function: sub_14154DC80 (0x14154DC80) ---
__int64 __fastcall sub_14154DC80(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rbx
  __int64 *v5; // rbx
  __int16 v6; // dx
  __int64 v7; // rax
  __int64 result; // rax
  unsigned int v9; // ebx
  void (__fastcall *v10)(int *, __int64, _QWORD); // rax
  unsigned __int8 v11; // [rsp+30h] [rbp-29h] BYREF
  _BYTE v12[8]; // [rsp+38h] [rbp-21h] BYREF
  void *(__fastcall **v13)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+40h] [rbp-19h] BYREF
  __int64 v14; // [rsp+48h] [rbp-11h]
  _QWORD v15[2]; // [rsp+50h] [rbp-9h] BYREF
  _QWORD v16[4]; // [rsp+60h] [rbp+7h] BYREF
  int v17; // [rsp+80h] [rbp+27h] BYREF
  __int128 v18; // [rsp+88h] [rbp+2Fh]
  __int64 v19; // [rsp+C8h] [rbp+6Fh] BYREF

  v19 = a2;
  v11 = a3;
  v17 = 0;
  v18 = xmmword_148353A28;
  v4 = *(_QWORD *)(a1 + 0x20);
  v12[0] = 0;
  v5 = (__int64 *)(v4 & 0xFFFFFFFFFFFFLL);
  if ( !v5 )
    return 1;
  v14 = 0;
  v13 = &off_1480EC218;
  sub_140526950((__int64)&v13);
  sub_140526B10((__int64)&v13);
  v6 = *(_WORD *)(a1 + 0x28);
  v7 = *v5;
  v16[0] = sub_1415B7490;
  v16[1] = &v11;
  v16[2] = &v19;
  v15[0] = v16;
  v15[1] = sub_1411D16B0;
  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, int *, __int64, _QWORD *, _BYTE *))(v7 + 8))(
             v5,
             v6 & 0x3FFF,
             &v17,
             v14,
             v15,
             v12);
  v9 = result;
  if ( v12[0] )
  {
    v10 = *(void (__fastcall **)(int *, __int64, _QWORD))(a1 + 8);
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
      v10(&v17, v19, v11);
    else
      ((void (__fastcall *)(__int64, int *, __int64, _QWORD))v10)(a1 + 8, &v17, v19, v11);
    return v9;
  }
  return result;
}

// --- End Function: sub_14154DC80 (0x14154DC80) ---

// --- Function: sub_141557C20 (0x141557C20) ---
__int64 __fastcall sub_141557C20(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)(a1 + 0x10) + 0x18LL))();
}

// --- End Function: sub_141557C20 (0x141557C20) ---

// --- Function: sub_14155A580 (0x14155A580) ---
void __fastcall sub_14155A580(int a1, __int64 (__fastcall **a2)(__int64 a1), __int64 (__fastcall **a3)(__int64 a1))
{
  int v4; // ecx
  __m256i *v5; // rdi
  __m256i *v6; // rax
  __m256i *v7; // rcx

  if ( !a1 )
  {
    v5 = (__m256i *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64))1;
        __asm { vzeroupper }
        return;
      }
      v6 = (__m256i *)sub_1402A63D0(0x20u);
      v7 = v6;
      if ( v6 )
        *v6 = *v5;
      else
        v7 = 0;
      a2[2] = (__int64 (__fastcall *)(__int64))v7;
      *a2 = sub_141557C20;
      a2[1] = (__int64 (__fastcall *)(__int64))sub_14155A580;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      sub_1402A63C0((__int64)a2[2]);
      a2[2] = 0;
      *a2 = 0;
      a2[1] = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == (__int64 (__fastcall *)(__int64))1 )
  {
    a2[2] = 0;
    *a2 = *a3;
    a2[1] = (__int64 (__fastcall *)(__int64))1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    a2[2] = a3[2];
    *a2 = *a3;
    a2[1] = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_14155A580 (0x14155A580) ---

// --- Function: sub_1415B7490 (0x1415B7490) ---
__int64 __fastcall sub_1415B7490(__int64 a1, __int64 *a2, __int64 a3)
{
  _QWORD v5[3]; // [rsp+20h] [rbp-18h] BYREF

  v5[1] = a1;
  v5[0] = &off_1480EC218;
  serialize_int64((__int64)v5, (__int64)"variable", a2);
  return sub_140527370(v5, "variable", a3);
}

// --- End Function: sub_1415B7490 (0x1415B7490) ---

// --- Function: sub_1415BCC70 (0x1415BCC70) ---
__int64 __fastcall sub_1415BCC70(__int64 a1, __int64 a2)
{
  signed __int64 v4; // rdx
  __int64 v5; // rbx
  int v6; // ebx
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rbx
  __int64 v10; // rdx
  __int64 *v11; // rcx
  int v12; // ebx
  __int64 v13; // rax
  _BYTE *v14; // rdx
  int v15; // eax
  unsigned __int64 n0x200000; // rax
  unsigned int v18[4]; // [rsp+30h] [rbp-168h] BYREF
  __int64 v19; // [rsp+40h] [rbp-158h] BYREF
  _QWORD v20[31]; // [rsp+48h] [rbp-150h] BYREF
  float v21; // [rsp+140h] [rbp-58h]
  float v22; // [rsp+144h] [rbp-54h]
  int v23; // [rsp+148h] [rbp-50h]
  __int16 v24; // [rsp+14Ch] [rbp-4Ch]

  if ( *(_DWORD *)(a1 + 0x18) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x1C);
  }
  else
  {
    v4 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x10));
    if ( (v4 & 0x200000) != 0 )
      sub_1403CD0A0((volatile signed __int64 *)(a1 + 0x10), v4, (__int64)&Source, (__int64)&Source, 1);
  }
  v5 = sub_1403E4B00((volatile signed __int64 *)(a1 + 0x40));
  if ( !v5 )
  {
    sub_1402D42F0(a1 + 0x10);
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x18) == v6 )
    {
      ++*(_DWORD *)(a1 + 0x1C);
    }
    else
    {
      v7 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0x10), 0x200000, 0);
      if ( v7 )
        sub_1403DE750(a1 + 0x10, v7, 0, (__int64)&Source, (__int64)&Source, 1);
      *(_DWORD *)(a1 + 0x18) = v6;
    }
    v5 = sub_1403E4B00((volatile signed __int64 *)(a1 + 0x40));
    if ( !v5 )
    {
      if ( *(_QWORD *)(a1 + 0x40) )
        __debugbreak();
      v8 = (unsigned __int128)((__int64)(*(_QWORD *)(a1 + 0x28) - *(_QWORD *)(a1 + 0x20))
                             * (__int128)0x7878787878787879LL) >> 0x40;
      v19 = 0;
      v9 = ((unsigned __int64)v8 >> 0x3F) + (v8 >> 7);
      sub_1415458D0((__int64)v20, a2);
      v10 = *(_QWORD *)(a1 + 0x28);
      v11 = (__int64 *)(a1 + 0x20);
      v21 = 0.0;
      v22 = 0.0;
      v23 = v9;
      v24 = 0x8000;
      if ( v10 == *(_QWORD *)(a1 + 0x30) )
      {
        sub_14153E400(v11, v10, (__int64)&v19);
      }
      else
      {
        sub_141541620((__int64)v11, v10, (__int64)&v19);
        *(_QWORD *)(a1 + 0x28) += 0x110LL;
      }
      sub_14154A110(v20);
      v5 = *(_QWORD *)(a1 + 0x28) - 0x110LL;
    }
    *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFF;
    sub_1403A5650((volatile signed __int64 *)(a1 + 0x10));
  }
  sub_1415BE730(v5, a2);
  v18[0] = (*(_DWORD *)(v5 + 0x108) + 1) & 0x1FFFF | (*(unsigned __int16 *)(v5 + 0x10C) << 0x11);
  v12 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 8) == v12 )
  {
    ++*(_DWORD *)(a1 + 0xC);
  }
  else
  {
    v13 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0x200000, 0);
    if ( v13 )
      sub_1403DE750(
        a1,
        v13,
        0,
        (__int64)"CigAgePriorityQueue<struct DeferredActionQueue<struct DefaultRayCaster<47>,struct RayCastRequest,struct"
                 " RayCastResult,struct DefaultContention>::QueuedRequest,float,float>::push_back_TS",
        (__int64)"m_queueLock",
        1);
    *(_DWORD *)(a1 + 8) = v12;
  }
  v14 = *(_BYTE **)(a1 + 0x58);
  if ( v14 == *(_BYTE **)(a1 + 0x60) )
  {
    sub_1403463D0(a1 + 0x50, v14, (int *)v18);
  }
  else
  {
    *(_DWORD *)v14 = v18[0];
    *(_QWORD *)(a1 + 0x58) += 4LL;
  }
  if ( a1 )
  {
    v15 = *(_DWORD *)(a1 + 0xC);
    if ( v15 )
    {
      *(_DWORD *)(a1 + 0xC) = v15 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0, 0x200000);
      if ( n0x200000 != 0x200000 )
        sub_1403DEBA0((volatile signed __int64 *)a1, n0x200000);
    }
  }
  sub_1402D42F0(a1 + 0x10);
  return v18[0];
}

// --- End Function: sub_1415BCC70 (0x1415BCC70) ---

// --- Function: sub_1415BE730 (0x1415BE730) ---
__int64 __fastcall sub_1415BE730(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rcx
  _QWORD *v6; // rbx
  void (__fastcall *n2)(__int64, __int64); // rax
  void (__fastcall *v8)(_QWORD, __int64, __int64); // rax
  _QWORD *v9; // rbx
  void (__fastcall *n2_1)(__int64, __int64); // rax
  void (__fastcall *v11)(_QWORD, __int64, __int64); // rax
  __int64 result; // rax

  *(_WORD *)(a1 + 0x10C) = (*(_WORD *)(a1 + 0x10C) + 1) & 0x7FFF;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 0x10) = *(_OWORD *)(a2 + 8);
  *(double *)(a1 + 0x20) = *(double *)(a2 + 0x18);
  *(double *)(a1 + 0x28) = *(double *)(a2 + 0x20);
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x28);
  *(_QWORD *)(a1 + 0x38) = *(_QWORD *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x40) = *(_DWORD *)(a2 + 0x38);
  *(_BYTE *)(a1 + 0x44) = *(_BYTE *)(a2 + 0x3C);
  *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(a2 + 0x40);
  sub_14046B1B0((void *)(a1 + 0x50), (void *)(a2 + 0x48));
  *(_BYTE *)(a1 + 0xB0) = *(_BYTE *)(a2 + 0xA8);
  v4 = *(_QWORD *)(a2 + 0xB0);
  if ( v4 )
    sub_140524420(*(_QWORD *)(a2 + 0xB0));
  v5 = *(_QWORD *)(a1 + 0xB8);
  *(_QWORD *)(a1 + 0xB8) = v4;
  if ( v5 )
    sub_140524440(v5);
  v6 = (_QWORD *)(a1 + 0xC8);
  *(_QWORD *)(a1 + 0xC0) = *(_QWORD *)(a2 + 0xB8);
  n2 = *(void (__fastcall **)(__int64, __int64))(a1 + 0xD0);
  if ( (unsigned __int64)n2 >= 2 )
  {
    n2(2, a1 + 0xC8);
    *(_QWORD *)(a1 + 0xD0) = 0;
  }
  *v6 = 0;
  v8 = *(void (__fastcall **)(_QWORD, __int64, __int64))(a2 + 0xC8);
  if ( v8 == (void (__fastcall *)(_QWORD, __int64, __int64))1 )
  {
    *v6 = *(_QWORD *)(a2 + 0xC0);
    *(_QWORD *)(a1 + 0xD0) = *(_QWORD *)(a2 + 0xC8);
  }
  else if ( v8 )
  {
    v8(0, a1 + 0xC8, a2 + 0xC0);
  }
  v9 = (_QWORD *)(a1 + 0xE0);
  n2_1 = *(void (__fastcall **)(__int64, __int64))(a1 + 0xE8);
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    n2_1(2, a1 + 0xE0);
    *(_QWORD *)(a1 + 0xE8) = 0;
  }
  *v9 = 0;
  v11 = *(void (__fastcall **)(_QWORD, __int64, __int64))(a2 + 0xE0);
  if ( v11 == (void (__fastcall *)(_QWORD, __int64, __int64))1 )
  {
    *v9 = *(_QWORD *)(a2 + 0xD8);
    *(_QWORD *)(a1 + 0xE8) = *(_QWORD *)(a2 + 0xE0);
  }
  else if ( v11 )
  {
    v11(0, a1 + 0xE0, a2 + 0xD8);
  }
  result = *(unsigned __int8 *)(a2 + 0xF0);
  *(_BYTE *)(a1 + 0xF8) = result;
  return result;
}

// --- End Function: sub_1415BE730 (0x1415BE730) ---

// --- Function: sub_1415C62D0 (0x1415C62D0) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_1415C62D0(double a1, __int64 a2)
{
  __int128 v3; // kr00_16

  v3 = *(_OWORD *)&a1;
  *(float *)&v3 = *(float *)&a1 * *(float *)(a2 + 8);
  return (__m128)v3;
}

// --- End Function: sub_1415C62D0 (0x1415C62D0) ---

// --- Function: sub_141882E30 (0x141882E30) ---
float __fastcall sub_141882E30(__int64 a1)
{
  return *(float *)(a1 + 0x154);
}

// --- End Function: sub_141882E30 (0x141882E30) ---

// --- Function: sub_141CCFBF0 (0x141CCFBF0) ---
// attributes: thunk
__int64 __fastcall sub_141CCFBF0(__int64 a1)
{
  return sub_140334DC0(a1);
}

// --- End Function: sub_141CCFBF0 (0x141CCFBF0) ---

// --- Function: sub_1420F1E00 (0x1420F1E00) ---
_QWORD *__fastcall sub_1420F1E00(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( is_valid_handle_typeB(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_14;
    if ( n0xFFFF_14 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                            qword_149A14298,
                            &v9,
                            "IItemResourceComponent");
      n0xFFFF_14 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1420F1E00 (0x1420F1E00) ---

// --- Function: sub_1422A3490 (0x1422A3490) ---
_QWORD *__fastcall sub_1422A3490(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( is_valid_handle_typeB(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_15;
    if ( n0xFFFF_15 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                            qword_149A14298,
                            &v9,
                            "IEntityComponentPowerConnection");
      n0xFFFF_15 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1422A3490 (0x1422A3490) ---

// --- Function: ??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ (0x142684EB0) ---
void _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator()()
{
  ;
}

// --- End Function: ??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ (0x142684EB0) ---

// --- Function: sub_142685070 (0x142685070) ---
void *__fastcall sub_142685070(__int64 a1, const void *src)
{
  void *dst; // rax

  dst = (void *)sub_1402A5210(0x20, a1);
  qmemcpy(dst, src, 0x20u);
  return dst;
}

// --- End Function: sub_142685070 (0x142685070) ---

// --- Function: sub_142685DF0 (0x142685DF0) ---
_BOOL8 __fastcall sub_142685DF0(_QWORD *a1, _QWORD *a2)
{
  return *a1 != *a2;
}

// --- End Function: sub_142685DF0 (0x142685DF0) ---

// --- Function: ?deallocate@__crt_win32_buffer_no_resizing@@SAXQEAXAEBV__crt_win32_buffer_empty_debug_info@@@Z (0x142686950) ---
// Microsoft VisualC v14 64bit runtime
void __fastcall __crt_win32_buffer_no_resizing::deallocate(
        void *const a1,
        const struct __crt_win32_buffer_empty_debug_info *a2)
{
  ;
}

// --- End Function: ?deallocate@__crt_win32_buffer_no_resizing@@SAXQEAXAEBV__crt_win32_buffer_empty_debug_info@@@Z (0x142686950) ---

// --- Function: Handle::IsValid (0x1426B3790) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int64 v2; // rcx
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v4; // [rsp+24h] [rbp-24h]
  __int64 v5; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v4 = HIWORD(*a1);
  v5 = sub_1403B6A80(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v5 + 4);
  if ( n4 == 4 )
    return 0;
  v2 = v4 & 0xFFF;
  if ( *(unsigned __int16 *)(v5 + 2) != (_DWORD)v2 )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww(v2) || sub_1426BADC0(a1);
}

// --- End Function: Handle::IsValid (0x1426B3790) ---

// --- Function: sub_1426BADC0 (0x1426BADC0) ---
char __fastcall sub_1426BADC0(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  unsigned __int64 v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B6A80(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B2980(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || is_thread_flag_57_or_38_set() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B2980(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = sub_1403B2980(v7);
      return sub_140393B10(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_1426BADC0 (0x1426BADC0) ---

// --- Function: sub_1426D6DE0 (0x1426D6DE0) ---
__int64 __fastcall sub_1426D6DE0(unsigned __int8 a1)
{
  return (unsigned int)a1 + 200;
}

// --- End Function: sub_1426D6DE0 (0x1426D6DE0) ---

// --- Function: sub_1427439D0 (0x1427439D0) ---
__int64 __fastcall sub_1427439D0(__int64 a1)
{
  return sub_1402A5210(1, a1);
}

// --- End Function: sub_1427439D0 (0x1427439D0) ---

// --- Function: sub_142745650 (0x142745650) ---
_QWORD *__fastcall sub_142745650(__int64 a1, _QWORD *a2)
{
  _QWORD src_[2]; // [rsp+28h] [rbp-40h] BYREF
  _BYTE dst_[16]; // [rsp+40h] [rbp-28h] BYREF

  src_[0] = sub_140386914;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, sizeof(dst_));
  _StarEngineModule__(0);
  sub_1427456C0(a2, *(_QWORD *)(a1 + 8));
  return a2;
}

// --- End Function: sub_142745650 (0x142745650) ---

// --- Function: sub_1427456C0 (0x1427456C0) ---
_QWORD *__fastcall sub_1427456C0(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-68h]
  __int64 v4; // [rsp+28h] [rbp-60h]
  _QWORD v5[2]; // [rsp+30h] [rbp-58h] BYREF
  _BYTE v6[8]; // [rsp+40h] [rbp-48h] BYREF
  _QWORD src_[2]; // [rsp+48h] [rbp-40h] BYREF
  _BYTE dst_[16]; // [rsp+60h] [rbp-28h] BYREF
  unsigned __int64 v10; // [rsp+98h] [rbp+10h] BYREF

  v10 = a2;
  src_[0] = sub_140386914;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, sizeof(dst_));
  _StarEngineModule__(0);
  if ( is_valid_handle_typeB(&v10) )
  {
    v4 = sub_1403103B0(&v10);
    v3 = (_QWORD *)sub_1425A2710(v4, v6);
  }
  else
  {
    v5[0] = 0;
    v3 = v5;
  }
  v5[1] = v3;
  *a1 = *v3;
  return a1;
}

// --- End Function: sub_1427456C0 (0x1427456C0) ---

// --- Function: sub_1427459B0 (0x1427459B0) ---
_QWORD *__fastcall sub_1427459B0(__int64 a1, _QWORD *a2)
{
  _BYTE v3[8]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v4; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int64); // [rsp+30h] [rbp-28h]
  __int64 *v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  _BYTE v8[16]; // [rsp+48h] [rbp-10h] BYREF

  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)a1 + 0x340LL);
  v4 = sub_142766E60(v3);
  v6 = (__int64 *)v5(a1, v8, v4);
  v7 = *v6;
  *a2 = v7;
  return a2;
}

// --- End Function: sub_1427459B0 (0x1427459B0) ---

// --- Function: sub_1427489C0 (0x1427489C0) ---
_QWORD *__fastcall sub_1427489C0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // [rsp+28h] [rbp-50h] BYREF
  _QWORD src_[2]; // [rsp+38h] [rbp-40h] BYREF
  _BYTE dst_[16]; // [rsp+50h] [rbp-28h] BYREF

  src_[0] = sub_140386914;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, sizeof(dst_));
  _StarEngineModule__(0);
  sub_1427456C0(&v3, *(_QWORD *)(a1 + 8));
  *a2 = v3;
  return a2;
}

// --- End Function: sub_1427489C0 (0x1427489C0) ---

// --- Function: sub_142784F50 (0x142784F50) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_142784F50(double _XMM0_8)
{
  __m128 result; // xmm0

  __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
  return result;
}

// --- End Function: sub_142784F50 (0x142784F50) ---

// --- Function: sub_142787F70 (0x142787F70) ---
_QWORD *__fastcall sub_142787F70(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-68h]
  __int64 v4; // [rsp+28h] [rbp-60h]
  _QWORD v5[2]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v6; // [rsp+40h] [rbp-48h] BYREF
  _QWORD src_[2]; // [rsp+48h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+60h] [rbp-28h] BYREF
  unsigned __int64 v10; // [rsp+98h] [rbp+10h] BYREF

  v10 = a2;
  src_[0] = sub_140386914;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  if ( is_valid_handle_typeB(&v10) )
  {
    v4 = sub_1403103B0(&v10);
    v3 = sub_1427459B0(v4, &v6);
  }
  else
  {
    v5[0] = 0;
    v3 = v5;
  }
  v5[1] = v3;
  *a1 = *v3;
  return a1;
}

// --- End Function: sub_142787F70 (0x142787F70) ---

// --- Function: sub_142788790 (0x142788790) ---
_QWORD *__fastcall sub_142788790(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-68h]
  __int64 v4; // [rsp+28h] [rbp-60h]
  _QWORD v5[2]; // [rsp+30h] [rbp-58h] BYREF
  _BYTE v6[8]; // [rsp+40h] [rbp-48h] BYREF
  _QWORD src_[2]; // [rsp+48h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+60h] [rbp-28h] BYREF
  unsigned __int64 v10; // [rsp+98h] [rbp+10h] BYREF

  v10 = a2;
  src_[0] = sub_140386914;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  if ( is_valid_handle_typeB(&v10) )
  {
    v4 = sub_1403103B0(&v10);
    v3 = (_QWORD *)sub_1425A2E10(v4, v6);
  }
  else
  {
    v5[0] = 0;
    v3 = v5;
  }
  v5[1] = v3;
  *a1 = *v3;
  return a1;
}

// --- End Function: sub_142788790 (0x142788790) ---

// --- Function: sub_14278A0B0 (0x14278A0B0) ---
_QWORD *__fastcall sub_14278A0B0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // [rsp+28h] [rbp-50h] BYREF
  _QWORD src_[2]; // [rsp+38h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+50h] [rbp-28h] BYREF

  src_[0] = sub_140386914;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  sub_142787F70(&v3, *(_QWORD *)(a1 + 8));
  *a2 = v3;
  return a2;
}

// --- End Function: sub_14278A0B0 (0x14278A0B0) ---

// --- Function: sub_14278A310 (0x14278A310) ---
_QWORD *__fastcall sub_14278A310(__int64 a1, _QWORD *a2)
{
  __int64 v3; // [rsp+28h] [rbp-50h] BYREF
  _QWORD src_[2]; // [rsp+38h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+50h] [rbp-28h] BYREF

  src_[0] = sub_140386914;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  sub_142788790(&v3, *(_QWORD *)(a1 + 8));
  *a2 = v3;
  return a2;
}

// --- End Function: sub_14278A310 (0x14278A310) ---

// --- Function: sub_14299C760 (0x14299C760) ---
__int64 __fastcall sub_14299C760(__int64 a1)
{
  int *v2; // rbx
  int *v3; // rax
  int v4; // ebx
  int v5; // edi
  __int64 v6; // rdi
  __int64 (__fastcall *v7)(__int64, __int64, const char *); // rbx
  __int64 v8; // rax
  char v9; // al
  __int64 v10; // rcx
  _BYTE v12[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v13; // [rsp+28h] [rbp-30h]
  _BYTE v14[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v15; // [rsp+40h] [rbp-18h]

  if ( !a1 )
    return 0;
  v2 = (int *)sub_14128E500((__int64)v14);
  v3 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 0x18LL))(a1, v12);
  v4 = *v2;
  v5 = *v3;
  if ( v13 )
    sub_14753C530(v13);
  if ( v15 )
    sub_14753C530(v15);
  if ( v4 == v5 )
    return a1;
  if ( !qword_149A142B0 || !(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149A142B0 + 0x240LL))(qword_149A142B0) )
    return 0;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149A142B0 + 0x240LL))(qword_149A142B0);
  v7 = *(__int64 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v6 + 0x100LL);
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
  v9 = v7(v6, v8, "ResourceTypeVolatility");
  v10 = 0;
  if ( v9 )
    return a1;
  return v10;
}

// --- End Function: sub_14299C760 (0x14299C760) ---

// --- Function: sub_1429AAF80 (0x1429AAF80) ---
_QWORD *__fastcall sub_1429AAF80(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_16;
  if ( n0xFFFF_16 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                          qword_149A14298,
                          &v9,
                          "EntityComponentMineable");
    n0xFFFF_16 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1429AAF80 (0x1429AAF80) ---

// --- Function: sub_142A20CE0 (0x142A20CE0) ---
double __fastcall sub_142A20CE0(__int64 a1, __int128 *a2)
{
  unsigned __int64 n0xC; // r9
  _DWORD *n0x2C; // r8
  __int64 v5; // rbx
  __int64 v6; // rax
  __int16 n4; // dx
  __int64 v8; // r8
  double result; // xmm0_8
  __int128 v10; // [rsp+20h] [rbp-18h] BYREF
  __int64 v11; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_QWORD *)a2 )
  {
    n0xC = 0;
    n0x2C = (_DWORD *)(a1 + 0x16B4);
    while ( *(_QWORD *)(n0x2C + 0xFFFFFFFD) != *(_QWORD *)a2
         || n0x2C[0xFFFFFFFF] != *((_DWORD *)a2 + 2)
         || *n0x2C != *((_DWORD *)a2 + 3) )
    {
      ++n0xC;
      n0x2C += 0x4C;
      if ( n0xC >= 0xC )
        goto LABEL_7;
    }
    if ( n0x2C != (_DWORD *)0x2C )
    {
      *(_QWORD *)&result = (unsigned int)n0x2C[0x1B];
      return result;
    }
LABEL_7:
    v5 = *(_QWORD *)(a1 + 0x1A8);
    v11 = v5;
    if ( v5 )
    {
      v6 = sub_1403B6A80(v5 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v6 + 4);
      if ( n4 != 4
        && *(_WORD *)(v6 + 2) == (HIWORD(v5) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || check_handle_access_by_state(&v11)) )
      {
        LOBYTE(v8) = 4;
        v10 = *a2;
        if ( (*(unsigned __int8 (__fastcall **)(__int64, __int128 *, __int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL)
                                                                             + 0x798LL))(
               v5 & 0xFFFFFFFFFFFFLL,
               &v10,
               v8) )
        {
          *(_QWORD *)&result = 0x3F800000;
          return result;
        }
      }
    }
  }
  return 0.0;
}

// --- End Function: sub_142A20CE0 (0x142A20CE0) ---

// --- Function: sub_142AE3EA0 (0x142AE3EA0) ---
__int64 __fastcall sub_142AE3EA0(_LocaleUpdate *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 *v4; // rax
  __int16 v5; // [rsp+20h] [rbp-2C8h]
  _QWORD *v6; // [rsp+38h] [rbp-2B0h]
  __int64 v7; // [rsp+40h] [rbp-2A8h]
  _BYTE v8[8]; // [rsp+48h] [rbp-2A0h] BYREF
  __int64 (__fastcall *v9)(__int64, _BYTE *); // [rsp+50h] [rbp-298h]
  __int64 (__fastcall *v10)(__int64, _BYTE *); // [rsp+58h] [rbp-290h]
  _QWORD *v11; // [rsp+60h] [rbp-288h]
  unsigned __int8 *v12; // [rsp+68h] [rbp-280h]
  struct __crt_locale_pointers *LocaleT; // [rsp+70h] [rbp-278h]
  _QWORD *v14; // [rsp+78h] [rbp-270h]
  __int64 v15; // [rsp+80h] [rbp-268h]
  void (__fastcall *v16)(__int64, __int64, __int64, _QWORD *, __int16); // [rsp+88h] [rbp-260h]
  _BYTE v17[8]; // [rsp+90h] [rbp-258h] BYREF
  _BYTE v18[8]; // [rsp+98h] [rbp-250h] BYREF
  __int64 v19; // [rsp+A0h] [rbp-248h] BYREF
  _BYTE v20[544]; // [rsp+B0h] [rbp-238h] BYREF

  result = (unsigned __int8)sub_140310380((char *)a1 + 8);
  if ( (_BYTE)result )
  {
    sub_1402A4FE0((__int64)v20);
    sub_1402A5820((__int64)v20, "[%04llu]", a3);
    v7 = sub_1403103D0((__int64)a1 + 8);
    v16 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD *, __int16))(*(_QWORD *)v7 + 8LL);
    v9 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a2 + 0x20LL);
    v4 = (__int64 *)v9(a2, v17);
    if ( is_valid_handle_typeA(v4) )
    {
      v10 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a2 + 0x20LL);
      v6 = (_QWORD *)v10(a2, v18);
    }
    else
    {
      v6 = sub_14032AFF0((__int64)a1, &v19);
    }
    v11 = v6;
    v14 = v6;
    LocaleT = _LocaleUpdate::GetLocaleT(a1);
    v12 = AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)v20);
    v15 = sub_14030B820(v8, LocaleT, v12);
    v5 = a3;
    v16(v7, a2, v15, v14, v5);
    return sub_1402A51D0((__int64)v20);
  }
  return result;
}

// --- End Function: sub_142AE3EA0 (0x142AE3EA0) ---

// --- Function: sub_142BC3B20 (0x142BC3B20) ---
__int64 __fastcall sub_142BC3B20(_QWORD *a1)
{
  return *(_QWORD *)(*(_QWORD *)(*a1 + 8LL) + 8 * ((*(_QWORD *)(*a1 + 0x10LL) - 1LL) & a1[1]));
}

// --- End Function: sub_142BC3B20 (0x142BC3B20) ---

// --- Function: sub_142C7C5C0 (0x142C7C5C0) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_142C7C5C0(double a1, __int64 a2)
{
  __int128 v3; // kr00_16

  v3 = *(_OWORD *)&a1;
  *(float *)&v3 = *(float *)&a1 + *(float *)(a2 + 8);
  return (__m128)v3;
}

// --- End Function: sub_142C7C5C0 (0x142C7C5C0) ---

// --- Function: sub_142C80620 (0x142C80620) ---
_QWORD *__fastcall sub_142C80620(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( is_valid_handle_typeB(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_17;
    if ( n0xFFFF_17 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149A14298 + 0x10LL))(
                            qword_149A14298,
                            &v9,
                            "AtmosphericFlightData");
      n0xFFFF_17 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_142C80620 (0x142C80620) ---

// --- Function: sub_142EDFBC0 (0x142EDFBC0) ---
__int64 __fastcall sub_142EDFBC0(volatile signed __int32 *a1)
{
  __int64 v1; // xmm0_8
  __int64 result; // rax
  _QWORD *v4; // rdi
  const void *v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  const void *v8; // rcx
  const void *v9; // rcx
  __int64 v10; // rcx
  const void *v11; // rcx
  const void *v12; // rcx
  _QWORD *v13; // rdx

  result = (unsigned int)_InterlockedExchangeAdd(a1 + 7, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    switch ( *((_BYTE *)a1 + 0x18) )
    {
      case 6:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_4;
        break;
      case 0xA:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v5 = (const void *)v4[0xC];
        if ( v5 )
          sub_14753C530(v5);
        sub_1403727A0(v4 + 0xA);
        v4[5] = &off_1480DE538;
        goto LABEL_67;
      case 0xE:
      case 0x60:
      case 0x7C:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x13:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x17:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_4:
        sub_1403727A0(v4 + 1);
        goto LABEL_67;
      case 0x18:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_141940E80(v4 + 8);
        goto LABEL_67;
      case 0x1A:
      case 0x82:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x1B:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x1C:
      case 0x83:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x1D:
      case 0x27:
      case 0x28:
      case 0x53:
      case 0x6D:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x21:
      case 0x22:
      case 0x24:
      case 0x25:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_20;
        break;
      case 0x23:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_20:
        sub_141940E80(*(_QWORD *)a1);
        goto LABEL_67;
      case 0x2B:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x2C:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x2D:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x2E:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v7 = v4[1];
        if ( !v7 )
          goto LABEL_67;
        if ( ((v4[3] - v7) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
          goto LABEL_31;
        if ( (unsigned __int64)(v7 - *(_QWORD *)(v7 - 8) - 8) > 0x1F )
LABEL_50:
          invalid_parameter_noinfo_noreturn();
        v7 = *(_QWORD *)(v7 - 8);
LABEL_31:
        sub_1402A63C0(v7);
        v4[1] = 0;
        v4[2] = 0;
        v4[3] = 0;
LABEL_67:
        v6 = (__int64)v4;
LABEL_68:
        sub_1402A63C0(v6);
        break;
      case 0x2F:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x46:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x4C:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x4E:
      case 0x6E:
      case 0x6F:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x54:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v8 = (const void *)v4[5];
        if ( v8 )
          sub_14753C530(v8);
        v9 = (const void *)v4[2];
        if ( v9 )
          sub_14753C530(v9);
        goto LABEL_67;
      case 0x55:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x57:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_44;
        break;
      case 0x58:
        v10 = *(_QWORD *)a1;
        if ( !*(_QWORD *)a1 )
          break;
        if ( ((*((_QWORD *)a1 + 2) - v10) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
          goto LABEL_49;
        if ( (unsigned __int64)(v10 - *(_QWORD *)(v10 - 8) - 8) > 0x1F )
          goto LABEL_50;
        v10 = *(_QWORD *)(v10 - 8);
LABEL_49:
        sub_1402A63C0(v10);
        *(_QWORD *)a1 = 0;
        *((_QWORD *)a1 + 1) = 0;
        *((_QWORD *)a1 + 2) = 0;
        break;
      case 0x5C:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_1403727A0(v4 + 5);
        goto LABEL_67;
      case 0x5F:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_44:
        sub_1403727A0(v4 + 6);
        goto LABEL_67;
      case 0x63:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x65:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x6A:
      case 0x71:
      case 0x74:
      case 0x7A:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x7E:
        v6 = *(_QWORD *)a1;
        goto LABEL_68;
      case 0x7F:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v11 = (const void *)v4[0xF];
        if ( v11 )
          sub_14753C530(v11);
        v12 = (const void *)v4[0xC];
        if ( v12 )
          sub_14753C530(v12);
        goto LABEL_67;
      case 0x88:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_145E40840(*(_QWORD *)a1);
        goto LABEL_67;
      default:
        break;
    }
    v13 = (_QWORD *)*((_QWORD *)a1 + 4);
    if ( (unsigned __int64)a1 < *v13 || (unsigned __int64)a1 >= v13[5] + *v13 )
      __debugbreak();
    *(__m256 *)a1 = ymmword_14859CE20;
    *((_QWORD *)a1 + 4) = v1;
    __asm { vzeroupper }
    return sub_1403E4BC0(v13 + 0xA, a1);
  }
  return result;
}

// --- End Function: sub_142EDFBC0 (0x142EDFBC0) ---

// --- Function: sub_14303E790 (0x14303E790) ---
__int64 __fastcall sub_14303E790(__int64 a1, char a2, _DWORD *a3, __m256 *a4, __m256 *a5, __int64 a6)
{
  __m256 *v10; // rax
  __m256 v11; // ymm0
  __m256 *v12; // rax
  unsigned int v13; // ebx
  __int64 (__fastcall *p_sub_141504DB0)(__int64); // [rsp+20h] [rbp-E0h] BYREF
  void (__fastcall *p_sub_141505CB0)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+28h] [rbp-D8h]
  __m256 *v17; // [rsp+30h] [rbp-D0h]
  __int64 (__fastcall *p_sub_141557C20)(__int64); // [rsp+38h] [rbp-C8h] BYREF
  void (__fastcall *p_sub_14155A580)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+40h] [rbp-C0h]
  __m256 *v20; // [rsp+48h] [rbp-B8h]
  __m256 v21; // [rsp+50h] [rbp-B0h]
  _DWORD v22[15]; // [rsp+70h] [rbp-90h] BYREF
  char v23; // [rsp+ACh] [rbp-54h]
  __int64 v24; // [rsp+B0h] [rbp-50h]
  _QWORD v25[9]; // [rsp+B8h] [rbp-48h] BYREF
  int v26; // [rsp+100h] [rbp+0h]
  int n8; // [rsp+104h] [rbp+4h]
  __int64 v28; // [rsp+108h] [rbp+8h]
  unsigned int v29; // [rsp+110h] [rbp+10h]
  int v30; // [rsp+114h] [rbp+14h]
  char v31; // [rsp+118h] [rbp+18h]
  __int64 v32; // [rsp+120h] [rbp+20h]
  __int64 v33; // [rsp+128h] [rbp+28h]
  __int64 (__fastcall *p_sub_141504DB0_1)(__int64); // [rsp+130h] [rbp+30h] BYREF
  void (__fastcall *p_sub_141505CB0_1)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)); // [rsp+138h] [rbp+38h]
  __int64 v36; // [rsp+140h] [rbp+40h]
  __int64 (__fastcall *p_sub_141557C20_1)(__int64); // [rsp+148h] [rbp+48h] BYREF
  __int128 n2; // [rsp+150h] [rbp+50h]
  char v39; // [rsp+160h] [rbp+60h]

  v21 = *a5;
  __asm { vzeroupper }
  v10 = (__m256 *)sub_1402A63D0(0x20u);
  if ( v10 )
  {
    *v10 = v21;
    v20 = v10;
  }
  else
  {
    v20 = 0;
  }
  v11 = *a4;
  p_sub_141505CB0 = 0;
  p_sub_141557C20 = sub_141557C20;
  p_sub_14155A580 = sub_14155A580;
  v21 = v11;
  __asm { vzeroupper }
  v12 = (__m256 *)sub_1402A63D0(0x20u);
  if ( v12 )
  {
    *v12 = v21;
    v17 = v12;
  }
  else
  {
    v17 = 0;
  }
  v22[0] = *a3;
  v33 = a6;
  p_sub_141504DB0 = sub_141504DB0;
  p_sub_141505CB0 = sub_141505CB0;
  v23 = 0;
  v24 = 0;
  memset(v25, 0, sizeof(v25));
  v26 = 0;
  n8 = 8;
  v28 = 0;
  v29 = 0xFFFFFFFF;
  v30 = 0;
  v31 = 1;
  v32 = 0;
  p_sub_141504DB0_1 = 0;
  p_sub_141505CB0_1 = 0;
  v36 = 0;
  if ( sub_141505CB0 == (void (__fastcall *)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)))1 )
  {
    p_sub_141504DB0_1 = sub_141504DB0;
    p_sub_141505CB0_1 = sub_141505CB0;
  }
  else
  {
    __asm { vzeroupper }
    sub_141505CB0(0, &p_sub_141504DB0_1, &p_sub_141504DB0);
  }
  p_sub_141557C20_1 = 0;
  n2 = 0;
  if ( p_sub_14155A580 == (void (__fastcall *)(int, __int64 (__fastcall **)(__int64), __int64 (__fastcall **)(__int64)))1 )
  {
    p_sub_141557C20_1 = p_sub_141557C20;
    *(_QWORD *)&n2 = 1;
  }
  else if ( p_sub_14155A580 )
  {
    __asm { vzeroupper }
    p_sub_14155A580(0, &p_sub_141557C20_1, &p_sub_141557C20);
  }
  v39 = a2;
  __asm { vzeroupper }
  v13 = sub_1415BCC70(a1 + 0x250, (__int64)v22);
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2)(2, &p_sub_141557C20_1);
    *(_QWORD *)&n2 = 0;
  }
  p_sub_141557C20_1 = 0;
  if ( (unsigned __int64)p_sub_141505CB0_1 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))p_sub_141505CB0_1)(2, &p_sub_141504DB0_1);
    p_sub_141505CB0_1 = 0;
  }
  p_sub_141504DB0_1 = 0;
  if ( v32 )
    sub_140524440(v32);
  sub_1404659E0((__int64)v25);
  if ( (unsigned __int64)p_sub_141505CB0 >= 2 )
  {
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))p_sub_141505CB0)(2, &p_sub_141504DB0);
    p_sub_141505CB0 = 0;
  }
  p_sub_141504DB0 = 0;
  if ( (unsigned __int64)p_sub_14155A580 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))p_sub_14155A580)(2, &p_sub_141557C20);
  return v13;
}

// --- End Function: sub_14303E790 (0x14303E790) ---

// --- Function: sub_14308C740 (0x14308C740) ---
__int64 __fastcall sub_14308C740(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  _BYTE v5[8]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1427439D0)(__int64); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_14310A8D0();
  v8 = 1;
  v3 = sub_14308A4B0(v5);
  v9 = sub_1402A4CF0(v3);
  v10 = byte_149CDAC94;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427439D0 = sub_1427439D0;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_14308C740 (0x14308C740) ---

// --- Function: sub_14308C980 (0x14308C980) ---
__int64 __fastcall sub_14308C980(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  _BYTE v5[8]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 n0x18; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1427851B0)(); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_14310A990();
  n0x18 = 0x18;
  v3 = sub_14308A510(v5);
  v9 = sub_1402A4CF0(v3);
  v10 = byte_149CDACBC;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427851B0 = sub_1427851B0;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_14308C980 (0x14308C980) ---

// --- Function: sub_1430EBF80 (0x1430EBF80) ---
char __fastcall sub_1430EBF80(__int64 a1)
{
  char result; // al

  switch ( *(_DWORD *)(a1 + 0x108) )
  {
    case 0:
    case 1:
    case 6:
      result = 0;
      break;
    case 2:
    case 3:
    case 4:
    case 5:
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

// --- End Function: sub_1430EBF80 (0x1430EBF80) ---

// --- Function: sub_143100820 (0x143100820) ---
__int64 __fastcall sub_143100820(__int64 a1)
{
  __int64 v1; // rax
  _BYTE v3[8]; // [rsp+20h] [rbp-18h] BYREF

  v1 = sub_1402A4B80((__int64)&qword_149A141F0);
  return sub_14308C740(*(_QWORD *)(v1 + 0xA0), a1, (__int64)v3);
}

// --- End Function: sub_143100820 (0x143100820) ---

// --- Function: sub_1431009E0 (0x1431009E0) ---
__int64 __fastcall sub_1431009E0(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+20h] [rbp-38h]
  __int64 v4; // [rsp+28h] [rbp-30h]
  _BYTE v5[40]; // [rsp+30h] [rbp-28h] BYREF

  v4 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
  v3 = sub_14121F840((__int64)v5, a2);
  return sub_14308C980(v4, a1, v3);
}

// --- End Function: sub_1431009E0 (0x1431009E0) ---

// --- Function: sub_143103750 (0x143103750) ---
_QWORD *__fastcall sub_143103750(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x278);
  return a2;
}

// --- End Function: sub_143103750 (0x143103750) ---

// --- Function: sub_143103900 (0x143103900) ---
double *__fastcall sub_143103900(__int64 a1, unsigned __int8 dst_3, int a3, double *dst, double *dst_1)
{
  double *dst_2; // rax
  double v10; // [rsp+40h] [rbp-168h]
  unsigned __int64 v11; // [rsp+48h] [rbp-160h]
  __int64 v12; // [rsp+58h] [rbp-150h]
  __int64 v13; // [rsp+60h] [rbp-148h]
  double v14; // [rsp+68h] [rbp-140h]
  double v15; // [rsp+70h] [rbp-138h]
  double v16; // [rsp+78h] [rbp-130h]
  float v17; // [rsp+80h] [rbp-128h]
  float v18; // [rsp+84h] [rbp-124h]
  double v19; // [rsp+90h] [rbp-118h] BYREF
  double v20; // [rsp+98h] [rbp-110h]
  double v21; // [rsp+A0h] [rbp-108h]
  double v22; // [rsp+A8h] [rbp-100h]
  double v23; // [rsp+C8h] [rbp-E0h]
  double v24; // [rsp+D0h] [rbp-D8h]
  double v25; // [rsp+D8h] [rbp-D0h]
  double v26; // [rsp+E0h] [rbp-C8h]
  double v27; // [rsp+E8h] [rbp-C0h]
  double v28; // [rsp+F0h] [rbp-B8h]
  void (__fastcall *v29)(__int64, double *, _QWORD); // [rsp+F8h] [rbp-B0h]
  double v30; // [rsp+100h] [rbp-A8h]
  double v31; // [rsp+108h] [rbp-A0h]
  double v32; // [rsp+110h] [rbp-98h]
  double src__1[3]; // [rsp+118h] [rbp-90h] BYREF
  double src_[3]; // [rsp+130h] [rbp-78h] BYREF
  double src__2[3]; // [rsp+148h] [rbp-60h] BYREF
  double src__3[3]; // [rsp+160h] [rbp-48h] BYREF
  double v37[6]; // [rsp+178h] [rbp-30h] BYREF

  dst_2 = (double *)dst_3;
  if ( dst_3 )
  {
    if ( dst_3 == 1 )
    {
      qmemcpy(dst, (const void *)(a1 + 0x1B0), 0x18u);
      v28 = 2.0
          * (*(double *)(a1 + 0x1A0) * *(double *)(a1 + 0x198) + *(double *)(a1 + 0x190) * *(double *)(a1 + 0x1A8));
      v27 = 2.0
          * (*(double *)(a1 + 0x198) * *(double *)(a1 + 0x198) + *(double *)(a1 + 0x1A8) * *(double *)(a1 + 0x1A8))
          - 1.0;
      v26 = 2.0
          * (*(double *)(a1 + 0x190) * *(double *)(a1 + 0x198) - *(double *)(a1 + 0x1A0) * *(double *)(a1 + 0x1A8));
      src_[0] = v26;
      src_[1] = v27;
      src_[2] = v28;
      dst_2 = src_;
      qmemcpy(dst_1, src_, 0x18u);
    }
  }
  else
  {
    qmemcpy(dst, (const void *)(a1 + 0x178), 0x18u);
    v25 = 2.0 * (*(double *)(a1 + 0x168) * *(double *)(a1 + 0x160) + *(double *)(a1 + 0x158) * *(double *)(a1 + 0x170));
    v24 = 2.0 * (*(double *)(a1 + 0x160) * *(double *)(a1 + 0x160) + *(double *)(a1 + 0x170) * *(double *)(a1 + 0x170))
        - 1.0;
    v23 = 2.0 * (*(double *)(a1 + 0x158) * *(double *)(a1 + 0x160) - *(double *)(a1 + 0x168) * *(double *)(a1 + 0x170));
    src__1[0] = v23;
    src__1[1] = v24;
    src__1[2] = v25;
    dst_2 = src__1;
    qmemcpy(dst_1, src__1, 0x18u);
  }
  if ( !a3 )
  {
    if ( is_valid_handle_typeB((unsigned __int64 *)(a1 + 0x3F0)) )
    {
      v12 = sub_1403103B0((_QWORD *)(a1 + 0x3F0));
      v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x648LL))(v12);
      v29 = *(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v13 + 0x68LL);
      v29(v13, &v19, 0);
      qmemcpy(dst, sub_140339170(v37, &v19, dst), 0x18u);
      v16 = v20 * dst_1[2] - v21 * dst_1[1] + v22 * *dst_1;
      v15 = v21 * *dst_1 - v19 * dst_1[2] + v22 * dst_1[1];
      v14 = v19 * dst_1[1] - v20 * *dst_1 + v22 * dst_1[2];
      v10 = v16 * v21 - v14 * v19 + v16 * v21 - v14 * v19 + dst_1[1];
      *(double *)&v11 = v15 * v19 - v16 * v20 + v15 * v19 - v16 * v20 + dst_1[2];
      v30 = v14 * v20 - v15 * v21 + v14 * v20 - v15 * v21 + *dst_1;
      v31 = v10;
      _XMM0 = v11;
      v32 = *(double *)&v11;
      __asm { vcvtsd2ss xmm0, xmm0, [rsp+1A8h+var_A8] }
      v17 = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, [rsp+1A8h+var_A0] }
      v18 = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, [rsp+1A8h+var_98] }
      src__2[0] = v17;
      src__2[1] = v18;
      src__2[2] = *(float *)&_XMM0;
      dst_2 = src__2;
      qmemcpy(dst_1, src__2, 0x18u);
    }
    else
    {
      src__3[0] = *(float *)&qword_1497F5BB8;
      src__3[1] = *((float *)&qword_1497F5BB8 + 1);
      src__3[2] = *(float *)&dword_1497F5BC0;
      qmemcpy(dst_1, src__3, 0x18u);
      dst[2] = 0;
      dst[1] = 0;
      dst_2 = dst;
      *dst = 0;
    }
  }
  return dst_2;
}

// --- End Function: sub_143103900 (0x143103900) ---

// --- Function: sub_143109950 (0x143109950) ---
float __fastcall sub_143109950(__int64 a1)
{
  __int64 v1; // rdx
  float result; // xmm0_4

  if ( !Handle::IsValid((_QWORD *)(a1 + 0xD8)) )
    return 1500.0;
  LOBYTE(v1) = 0x13;
  sub_1460565A0(*(_QWORD *)(a1 + 0xD8) & 0xFFFFFFFFFFFFLL, v1, 0, 0, *(_QWORD *)(a1 + 0xD8) & 0xFFFFFFFFFFFFLL);
  return result;
}

// --- End Function: sub_143109950 (0x143109950) ---

// --- Function: sub_14310AAB0 (0x14310AAB0) ---
__int64 sub_14310AAB0()
{
  __int64 result; // rax

  result = (unsigned int)dword_149CDA4B0;
  if ( !dword_149CDA4B0 )
    return get_event_key_from_source_location(
             &dword_149CDA4B0,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/Vehicle/Weapons.h",
             0x173);
  return result;
}

// --- End Function: sub_14310AAB0 (0x14310AAB0) ---

// --- Function: sub_1433CA960 (0x1433CA960) ---
float __fastcall sub_1433CA960(__int64 a1)
{
  if ( is_valid_handle_typeA((__int64 *)(a1 + 0xA8))
    && (unsigned int)sub_146050F00(*(_QWORD *)(a1 + 0xA8) & 0xFFFFFFFFFFFFLL) == 2 )
  {
    return 1.0;
  }
  else
  {
    return *(float *)(a1 + 0x80);
  }
}

// --- End Function: sub_1433CA960 (0x1433CA960) ---

// --- Function: sub_1433D6EF0 (0x1433D6EF0) ---
char __fastcall sub_1433D6EF0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4_1; // dx
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rax
  __int16 n4; // cx
  int event_key_from_source_location; // eax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int16 n4_2; // dx
  __int64 v13; // rsi
  double v14; // xmm0_8
  float v15; // xmm6_4
  float v16; // xmm6_4
  double v17; // xmm0_8
  __int64 v18; // r14
  __int64 v19; // rax
  __int16 n2; // cx
  char v21; // al
  __int64 v22; // rbx
  bool v23; // zf
  int event_key_from_source_location_2; // eax
  __int64 v25; // rax
  __int16 v26; // rbx^6
  __int64 v27; // rsi
  __int16 n2_1; // cx
  __int64 v29; // rdi
  __int64 v30; // rax
  __int64 v31; // r8
  __int16 n4_3; // cx
  int v34; // [rsp+20h] [rbp-60h] BYREF
  __int64 v35; // [rsp+28h] [rbp-58h]
  __int64 *v36; // [rsp+30h] [rbp-50h] BYREF
  int event_key_from_source_location_1; // [rsp+38h] [rbp-48h]
  __int64 n0x10; // [rsp+40h] [rbp-40h]
  const char *p_struct_SCEvtControl_PowerSetThrottle; // [rsp+48h] [rbp-38h]
  char v40; // [rsp+50h] [rbp-30h]
  void (__fastcall *__StarEngineModule_)(ULONG_PTR); // [rsp+58h] [rbp-28h]
  void *p_??$initialize_from_array@$$BY00Q6AXPEB_W00I_K@Z@?$dual_state_; // [rsp+60h] [rbp-20h]
  __int64 v43; // [rsp+B0h] [rbp+30h] BYREF
  __int64 v44; // [rsp+B8h] [rbp+38h] BYREF

  v1 = *(_QWORD *)(a1 + 0xA8);
  v43 = v1;
  if ( v1 )
  {
    v3 = sub_1403B6A80(v1 & 0xFFFFFFFFFFFFLL);
    n4_1 = *(_WORD *)(v3 + 4);
    if ( n4_1 != 4
      && *(_WORD *)(v3 + 2) == (HIWORD(v1) & 0xFFF)
      && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || check_handle_access_by_state(&v43)) )
    {
      v5 = qword_149A14290;
      sub_1403B29B0((unsigned __int64 *)(a1 + 8), &v44);
      v35 = v44;
      v34 = *(_DWORD *)(a1 + 0x80);
      v6 = v1 & 0xFFFFFFFFFFFFLL;
      v7 = sub_1403B6A80(v1 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v7 + 4);
      if ( n4 == 4
        || *(_WORD *)(v7 + 2) != (HIWORD(v1) & 0xFFF)
        || (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !check_handle_access_by_state(&v43) )
      {
        v6 = 0;
      }
      v36 = (__int64 *)&v34;
      event_key_from_source_location = ::event_key_from_source_location_2;
      if ( !::event_key_from_source_location_2 )
        event_key_from_source_location = get_event_key_from_source_location(
                                           &::event_key_from_source_location_2,
                                           (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ISC/Mining.h",
                                           0x63);
      event_key_from_source_location_1 = event_key_from_source_location;
      n0x10 = 0x10;
      p_struct_SCEvtControl_PowerSetThrottle = "struct SCEvtNotify_OnLaserThrottleChanged";
      v40 = byte_149CDF992;
      __StarEngineModule_ = _StarEngineModule__;
      p_??$initialize_from_array@$$BY00Q6AXPEB_W00I_K@Z@?$dual_state_ = sub_140420260;
      (*(void (__fastcall **)(__int64, __int64, __int64 **))(*(_QWORD *)v5 + 0x358LL))(v5, v6, &v36);
    }
  }
  v10 = *(_QWORD *)(a1 + 0xA0);
  v44 = v10;
  if ( v10 )
  {
    v11 = sub_1403B6A80(v10 & 0xFFFFFFFFFFFFLL);
    n4_2 = *(_WORD *)(v11 + 4);
    if ( n4_2 != 4
      && *(_WORD *)(v11 + 2) == (HIWORD(v10) & 0xFFF)
      && (n4_2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || check_handle_access_by_state(&v44)) )
    {
      if ( *(_BYTE *)(sub_140334DC0(a1) + 0xD0) )
      {
        v13 = v10 & 0xFFFFFFFFFFFFLL;
        v14 = (*(double (__fastcall **)(__int64))(*(_QWORD *)(v10 & 0xFFFFFFFFFFFFLL) + 0x610LL))(v10 & 0xFFFFFFFFFFFFLL);
        v15 = *(float *)&v14
            - (*(float (__fastcall **)(__int64))(*(_QWORD *)(v10 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v10 & 0xFFFFFFFFFFFFLL);
        v16 = sub_1433CA960(a1) * v15;
        v17 = (*(double (__fastcall **)(__int64))(*(_QWORD *)(v10 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v10 & 0xFFFFFFFFFFFFLL);
        v18 = qword_149A14290;
        WORD2(v43) = 0x100;
        *(float *)&v43 = *(float *)&v17 + v16;
        v19 = sub_1403B6A80(v10 & 0xFFFFFFFFFFFFLL);
        n2 = *(_WORD *)(v19 + 4);
        if ( n2 == 4 )
        {
          v21 = 0;
        }
        else if ( *(_WORD *)(v19 + 2) == (HIWORD(v10) & 0xFFF) )
        {
          if ( n2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || (v21 = check_handle_access_by_state(&v44)) != 0 )
            v21 = 1;
        }
        else
        {
          v21 = 0;
        }
        v22 = 0;
        v23 = v21 == 0;
        v36 = &v43;
        event_key_from_source_location_2 = event_key_from_source_location_3;
        if ( !v23 )
          v22 = v13;
        if ( !event_key_from_source_location_3 )
          event_key_from_source_location_2 = get_event_key_from_source_location(
                                               &event_key_from_source_location_3,
                                               (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ISC/Power.h",
                                               0x7B);
        event_key_from_source_location_1 = event_key_from_source_location_2;
        n0x10 = 8;
        p_struct_SCEvtControl_PowerSetThrottle = "struct SCEvtControl_PowerSetThrottle";
        v40 = byte_149CDFADC;
        __StarEngineModule_ = _StarEngineModule__;
        p_??$initialize_from_array@$$BY00Q6AXPEB_W00I_K@Z@?$dual_state_ = __crt_state_management::dual_state_global<void (*)(wchar_t const *,wchar_t const *,wchar_t const *,unsigned int,unsigned __int64)>::initialize_from_array<void (*[1])(wchar_t const *,wchar_t const *,wchar_t const *,unsigned int,unsigned __int64)>;
        (*(void (__fastcall **)(__int64, __int64, __int64 **))(*(_QWORD *)v18 + 0x358LL))(v18, v22, &v36);
      }
    }
  }
  LOBYTE(v25) = (unsigned __int8)sub_14278A310(a1, &v43);
  v26 = HIWORD(v43);
  if ( v43 )
  {
    v27 = v43 & 0xFFFFFFFFFFFFLL;
    v25 = sub_1403B6A80(v43 & 0xFFFFFFFFFFFFLL);
    n2_1 = *(_WORD *)(v25 + 4);
    if ( n2_1 != 4 && *(_WORD *)(v25 + 2) == (v26 & 0xFFF) )
    {
      if ( n2_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || (LOBYTE(v25) = check_handle_access_by_state(&v43), (_BYTE)v25) )
      {
        sub_1433CA960(a1);
        v29 = *(_QWORD *)(sub_140334DC0(a1) + 0x28);
        v30 = sub_1403B6A80(v27);
        n4_3 = *(_WORD *)(v30 + 4);
        if ( n4_3 == 4
          || *(_WORD *)(v30 + 2) != (v26 & 0xFFF)
          || (n4_3 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !check_handle_access_by_state(&v43) )
        {
          v27 = 0;
        }
        LOBYTE(v25) = sub_14595DF30(v27, v29 + 0x20, v31, 0, v34, v35, v36);
      }
    }
  }
  return v25;
}

// --- End Function: sub_1433D6EF0 (0x1433D6EF0) ---

// --- Function: sub_143504C40 (0x143504C40) ---
bool __fastcall sub_143504C40(__int64 a1)
{
  return *(_DWORD *)(a1 + 0xA0) == 1;
}

// --- End Function: sub_143504C40 (0x143504C40) ---

// --- Function: sub_1436541A0 (0x1436541A0) ---
bool __fastcall sub_1436541A0(__int64 a1, float *a2)
{
  return *a2 != *(float *)(a1 + 0x44);
}

// --- End Function: sub_1436541A0 (0x1436541A0) ---

// --- Function: sub_1436746B0 (0x1436746B0) ---
_QWORD *__fastcall sub_1436746B0(int n2, _QWORD *a2, _QWORD *a3)
{
  _QWORD *result; // rax

  if ( n2 )
  {
    if ( n2 != 1 )
    {
      if ( n2 != 2 )
        return 0;
      sub_1402A63C0(a2[2]);
      a2[2] = 0;
      *a2 = 0;
      result = a2;
      a2[1] = 0;
      return result;
    }
  }
  else
  {
    LogFatalError("Can not request a copy for a CigMoveOnlyFunction, something's broken in the implementation");
  }
  result = a3;
  if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      a2[1] = 1;
    }
    else
    {
      a2[2] = a3[2];
      *a2 = *a3;
      a2[1] = a3[1];
    }
    a3[2] = 0;
    *a3 = 0;
    result = a3;
    a3[1] = 0;
  }
  return result;
}

// --- End Function: sub_1436746B0 (0x1436746B0) ---

// --- Function: sub_1436DC5C0 (0x1436DC5C0) ---
unsigned __int64 __fastcall sub_1436DC5C0(_LocaleUpdate *a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+20h] [rbp-38h]
  unsigned __int64 v3; // [rsp+30h] [rbp-28h]

  result = (unsigned __int8)sub_140310380((char *)a1 + 8);
  if ( (_BYTE)result )
  {
    v3 = (*((_QWORD *)a1 + 0xD) - *((_QWORD *)a1 + 0xC)) / 0x1C0LL;
    for ( i = 0; ; ++i )
    {
      result = v3;
      if ( i >= v3 )
        break;
      sub_142AE3EA0(a1, *((_QWORD *)a1 + 0xC) + 0x1C0 * i, i);
    }
  }
  return result;
}

// --- End Function: sub_1436DC5C0 (0x1436DC5C0) ---

// --- Function: sub_1436F5140 (0x1436F5140) ---
__int64 __fastcall sub_1436F5140(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+20h] [rbp-38h]
  __int64 v3; // [rsp+30h] [rbp-28h]
  __int64 v4; // [rsp+38h] [rbp-20h]

  result = (unsigned __int8)sub_140310380(a1 + 8);
  if ( (_BYTE)result )
  {
    v2 = *(_QWORD *)(a1 + 0x60);
    v4 = *(_QWORD *)(a1 + 0x68);
    while ( 1 )
    {
      result = v4;
      if ( v2 == v4 )
        break;
      v3 = sub_1403103D0(a1 + 8);
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 0x10LL))(v3, v2);
      v2 += 0x1C0;
    }
  }
  return result;
}

// --- End Function: sub_1436F5140 (0x1436F5140) ---

// --- Function: sub_1439E7780 (0x1439E7780) ---
__int64 __fastcall sub_1439E7780(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x330);
  if ( v1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1);
  else
    return 0;
}

// --- End Function: sub_1439E7780 (0x1439E7780) ---

// --- Function: sub_1439F0460 (0x1439F0460) ---
bool __fastcall sub_1439F0460(__int64 a1)
{
  return (*(_BYTE *)(a1 + 0x348) & 2) != 0;
}

// --- End Function: sub_1439F0460 (0x1439F0460) ---

// --- Function: sub_1439F0470 (0x1439F0470) ---
bool __fastcall sub_1439F0470(__int64 a1)
{
  return (*(_BYTE *)(a1 + 0x348) & 4) != 0;
}

// --- End Function: sub_1439F0470 (0x1439F0470) ---

// --- Function: sub_1439F05A0 (0x1439F05A0) ---
char __fastcall sub_1439F05A0(__int64 a1)
{
  return *(_BYTE *)(a1 + 0x348) & 1;
}

// --- End Function: sub_1439F05A0 (0x1439F05A0) ---

// --- Function: sub_143BB2D80 (0x143BB2D80) ---
__m128 __fastcall sub_143BB2D80(__crt_win32_buffer_debug_info *this, float *a2, __int64 a3)
{
  __int128 v6; // xmm8
  __int128 v7; // xmm7
  __int64 v8; // rdi
  const char *i; // rbx
  float v10; // xmm6_4
  __int128 v11; // kr00_16
  double v12; // xmm0_8
  __int128 v13; // kr00_16
  __int128 v14; // xmm0
  float v15; // xmm6_4
  __int128 v16; // kr00_16

  v6 = 0;
  v7 = 0;
  v8 = sub_1402A4CF0((__int64)this);
  for ( i = __crt_win32_buffer_debug_info::file_name(this); (const char *)v8 != i; v7 = v13 )
  {
    v10 = (float)(0.0099999998 * *(float *)(v8 + 0x28)) * *a2;
    v11 = v6;
    *(float *)&v11 = *(float *)&v6 + v10;
    v6 = v11;
    v12 = sub_1403B19A0(v8 + 0x38);
    v8 += 0x50;
    v13 = v7;
    *(float *)&v13 = *(float *)&v7 + (float)(*(float *)&v12 * v10);
  }
  v14 = *(unsigned int *)a2;
  v15 = *(float *)&v14 - *(float *)&v6;
  *(double *)&v14 = sub_1403B19A0(a3);
  v16 = v14;
  *(float *)&v16 = (float)(*(float *)&v14 * v15) + *(float *)&v7;
  return (__m128)v16;
}

// --- End Function: sub_143BB2D80 (0x143BB2D80) ---

// --- Function: sub_143BD68A0 (0x143BD68A0) ---
char __fastcall sub_143BD68A0(unsigned __int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rax
  __int64 v3; // r8
  char v5; // [rsp+28h] [rbp-30h]
  char v6; // [rsp+30h] [rbp-28h]
  __int128 v7; // [rsp+40h] [rbp-18h] BYREF
  unsigned __int64 v8; // [rsp+60h] [rbp+8h] BYREF
  char v9; // [rsp+68h] [rbp+10h] BYREF

  v8 = a1;
  LOBYTE(v1) = is_valid_handle_typeB(&v8);
  if ( (_BYTE)v1 )
  {
    v2 = sub_14033BF70(v8 & 0xFFFFFFFFFFFFLL, &v9);
    v1 = (__int64 *)sub_1403E7D00(v2);
    if ( v1 )
    {
      v3 = *v1;
      v7 = 0;
      v6 = 1;
      v5 = 1;
      LOBYTE(v1) = (*(__int64 (__fastcall **)(__int64 *, __int128 *, __int64, _QWORD, int, char, char))(v3 + 0x648))(
                     v1,
                     &v7,
                     v3,
                     0,
                     0x3F800000,
                     v5,
                     v6);
    }
  }
  return (char)v1;
}

// --- End Function: sub_143BD68A0 (0x143BD68A0) ---

// --- Function: sub_143C05E50 (0x143C05E50) ---
float __fastcall sub_143C05E50(__int64 a1)
{
  return *(float *)(a1 + 0x688);
}

// --- End Function: sub_143C05E50 (0x143C05E50) ---

// --- Function: sub_143C0D8C0 (0x143C0D8C0) ---
__int64 __fastcall sub_143C0D8C0(__int64 a1)
{
  return a1 + 0x638;
}

// --- End Function: sub_143C0D8C0 (0x143C0D8C0) ---

// --- Function: sub_143C0F9D0 (0x143C0F9D0) ---
__m128 __fastcall sub_143C0F9D0(__int64 a1)
{
  __int128 v2; // kr00_16

  v2 = *(unsigned int *)(a1 + 0x2EC);
  *(float *)&v2 = *(float *)(a1 + 0x2EC) * *(float *)(a1 + 0xE0);
  return (__m128)v2;
}

// --- End Function: sub_143C0F9D0 (0x143C0F9D0) ---

// --- Function: sub_143C0F9F0 (0x143C0F9F0) ---
__m128 __fastcall sub_143C0F9F0(__int64 a1)
{
  __int128 v2; // kr00_16

  v2 = *(unsigned int *)(a1 + 0x2E8);
  *(float *)&v2 = *(float *)(a1 + 0x2E8) * *(float *)(a1 + 0xC0);
  return (__m128)v2;
}

// --- End Function: sub_143C0F9F0 (0x143C0F9F0) ---

// --- Function: sub_143C0FA10 (0x143C0FA10) ---
float __fastcall sub_143C0FA10(__int64 a1, char a2)
{
  double v2; // xmm0_8
  float v4; // [rsp+20h] [rbp-28h]

  if ( !a2 )
    return *(float *)(a1 + 0x2C0);
  *(_QWORD *)&v2 = sub_1415C62D0(COERCE_DOUBLE((unsigned __int64)*(_DWORD *)(a1 + 0x2C0)), a1 + 0x138).m128_u64[0];
  v4 = sub_142C7C5C0(v2, a1 + 0x158).m128_f32[0];
  if ( v4 < 0.0 )
    return 0.0;
  if ( v4 >= 1.0 )
    return 1.0;
  else
    return v4;
}

// --- End Function: sub_143C0FA10 (0x143C0FA10) ---

// --- Function: sub_143C13E60 (0x143C13E60) ---
float __fastcall sub_143C13E60(__int64 a1, char a2)
{
  double v2; // xmm0_8
  float v4; // [rsp+20h] [rbp-48h]

  if ( a2 )
  {
    *(_QWORD *)&v2 = sub_1415C62D0(COERCE_DOUBLE((unsigned __int64)*(_DWORD *)(a1 + 0x2B8)), a1 + 0xF8).m128_u64[0];
    LODWORD(v4) = sub_142C7C5C0(v2, a1 + 0x118).m128_u32[0];
  }
  else
  {
    v4 = *(float *)(a1 + 0x2B8);
  }
  if ( *(_QWORD *)(sub_141CCFBF0(a1) + 0x28) )
    v4 = v4 * (float)(*(float *)(a1 + 0x2E4) / *(float *)(*(_QWORD *)(sub_141CCFBF0(a1) + 0x28) + 0x224LL));
  if ( v4 >= 0.0 )
    return v4;
  else
    return 0.0;
}

// --- End Function: sub_143C13E60 (0x143C13E60) ---

// --- Function: sub_143C16120 (0x143C16120) ---
__int64 __fastcall sub_143C16120(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  __int128 v4; // kr00_16

  if ( *(_QWORD *)(sub_141CCFBF0(a1) + 0x28) )
  {
    v3 = sub_141CCFBF0(a1);
    v4 = *(unsigned int *)(a1 + 0x2E4);
    *(double *)&v4 = (float)((float)(*(float *)(a1 + 0x2E4) * *(float *)(*(_QWORD *)(v3 + 0x28) + 0x22CLL)) / 100.0);
    _XMM0 = v4;
    __asm { vmovupd xmm1, xmm0 }
    sub_14036FC70(a2, *(double *)&_XMM1);
  }
  else
  {
    sub_14036FC70(a2, 0.0);
  }
  return a2;
}

// --- End Function: sub_143C16120 (0x143C16120) ---

// --- Function: sub_143C161F0 (0x143C161F0) ---
float __fastcall sub_143C161F0(__int64 a1)
{
  float v2; // [rsp+24h] [rbp-34h]

  if ( !*(_QWORD *)(sub_141CCFBF0(a1) + 0x28) )
    return 1.0;
  v2 = sub_143BB2D80((__crt_win32_buffer_debug_info *)(a1 + 0x638), (float *)(a1 + 0x2E4), a1 + 0x3B8).m128_f32[0];
  if ( v2 <= 0.0 )
    return 1.0;
  else
    return v2;
}

// --- End Function: sub_143C161F0 (0x143C161F0) ---

// --- Function: sub_143C32520 (0x143C32520) ---
__int64 __fastcall sub_143C32520(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 0x318);
}

// --- End Function: sub_143C32520 (0x143C32520) ---

// --- Function: sub_143C978C0 (0x143C978C0) ---
char __fastcall sub_143C978C0(unsigned __int64 a1, char a2, float *a3, __int64 a4, int a5)
{
  __int128 v5; // xmm7
  _QWORD *v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 *v11; // rax
  __int64 v12; // rax
  __int64 v13; // r9
  char v15; // [rsp+28h] [rbp-50h]
  char v16; // [rsp+30h] [rbp-48h]
  __int64 v17[2]; // [rsp+40h] [rbp-38h] BYREF
  __int128 v18; // [rsp+50h] [rbp-28h]
  unsigned __int64 v19; // [rsp+80h] [rbp+8h] BYREF

  v19 = a1;
  v18 = v5;
  LOBYTE(v8) = is_valid_handle_typeB(&v19);
  if ( (_BYTE)v8 )
  {
    sub_140839780(v19 & 0xFFFFFFFFFFFFLL, v17);
    if ( !is_valid_handle_typeA(v17)
      || (v9 = sub_1403103B0(v17),
          LOBYTE(v8) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x5A0LL))(v9),
          !(_BYTE)v8)
      || *a3 == 0.0 && a3[1] == 0.0 && a3[2] == 0.0 && a3[3] == 0.0 )
    {
      sub_1429AAF80(v19 & 0xFFFFFFFFFFFFLL, v17);
      if ( !is_valid_handle_typeA(v17)
        || (v10 = sub_1403103B0(v17), LOBYTE(v8) = sub_143C325B0(v10), !(_BYTE)v8)
        || *a3 == 0.0 && a3[1] == 0.0 && a3[2] == 0.0 && a3[3] == 0.0 )
      {
        if ( !a2
          || (v11 = sub_1404251A0(v19 & 0xFFFFFFFFFFFFLL, v17), LOBYTE(v8) = is_valid_handle_typeA_w(v11), !(_BYTE)v8) )
        {
          v12 = sub_14033BF70(v19 & 0xFFFFFFFFFFFFLL, v17);
          v8 = (_QWORD *)sub_1403E7D00(v12);
          if ( v8 )
          {
            LOBYTE(v13) = 1;
            v16 = 1;
            v15 = 1;
            LOBYTE(v8) = (*(__int64 (__fastcall **)(_QWORD *, float *, _QWORD, __int64, int, char, char))(*v8 + 0x648LL))(
                           v8,
                           a3,
                           *v8,
                           v13,
                           a5,
                           v15,
                           v16);
          }
        }
      }
    }
  }
  return (char)v8;
}

// --- End Function: sub_143C978C0 (0x143C978C0) ---

// --- Function: sub_143DF1FC0 (0x143DF1FC0) ---
__int64 __fastcall sub_143DF1FC0(AK::WriteBytesMem *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned __int8 *v5; // [rsp+28h] [rbp-30h]

  v5 = AK::WriteBytesMem::Bytes(a1);
  v3 = sub_1402A4B80((__int64)a1);
  return (*(__int64 (__fastcall **)(unsigned __int8 *, __int64, __int64))v3)(&v5[*(int *)(v3 + 8)], a2, a3);
}

// --- End Function: sub_143DF1FC0 (0x143DF1FC0) ---

// --- Function: sub_144297F80 (0x144297F80) ---
__int64 __fastcall sub_144297F80(__int64 a1, float a2)
{
  _BYTE v3[8]; // [rsp+20h] [rbp-78h] BYREF
  float v4; // [rsp+28h] [rbp-70h]
  void (__fastcall **v5)(_QWORD); // [rsp+30h] [rbp-68h]
  unsigned int v6; // [rsp+38h] [rbp-60h]
  void (__fastcall *v7)(_QWORD); // [rsp+40h] [rbp-58h]
  void (__fastcall *v8)(_QWORD); // [rsp+48h] [rbp-50h]
  __int128 dst_; // [rsp+50h] [rbp-48h] BYREF
  _BYTE v10[24]; // [rsp+60h] [rbp-38h] BYREF
  float v12; // [rsp+A8h] [rbp+10h] BYREF

  v12 = a2;
  qmemcpy(&dst_, src__2, sizeof(dst_));
  sub_14121F860((__int64)v10, 0, &dst_);
  v3[0] = 0;
  v6 = sub_1442B1810(a1, v3, v10, &v12);
  if ( v3[0] )
  {
    v5 = (void (__fastcall **)(_QWORD))(a1 + 8);
    v4 = v12;
    v3[1] = 0;
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
    {
      v7 = *v5;
      v7(v10);
    }
    else
    {
      v8 = *v5;
      ((void (__fastcall *)(void (__fastcall **)(_QWORD), _BYTE *))v8)(v5, v10);
    }
  }
  return v6;
}

// --- End Function: sub_144297F80 (0x144297F80) ---

// --- Function: sub_1442B1810 (0x1442B1810) ---
__int64 __fastcall sub_1442B1810(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v5; // [rsp+34h] [rbp-B4h]
  __int64 v6; // [rsp+40h] [rbp-A8h]
  ULONG_PTR Parameter; // [rsp+58h] [rbp-90h] BYREF
  __int64 v8; // [rsp+60h] [rbp-88h]
  __int64 v9; // [rsp+68h] [rbp-80h]
  __int64 (__fastcall *p_sub_144307710)(); // [rsp+70h] [rbp-78h]
  __int64 *v11; // [rsp+78h] [rbp-70h]
  __int64 v12; // [rsp+80h] [rbp-68h]
  __int64 (__fastcall **p_p_sub_144307710)(); // [rsp+88h] [rbp-60h]
  __int64 v14; // [rsp+90h] [rbp-58h]
  __int64 (__fastcall *v15)(__int64, _QWORD, __int64, __int64, _BYTE *, __int64); // [rsp+98h] [rbp-50h]
  _QWORD v16[2]; // [rsp+A0h] [rbp-48h] BYREF
  _BYTE v17[16]; // [rsp+B0h] [rbp-38h] BYREF
  __int64 (__fastcall *p_sub_144307710_1)(); // [rsp+C0h] [rbp-28h] BYREF
  __int64 v19; // [rsp+C8h] [rbp-20h] BYREF
  __int64 v20; // [rsp+D0h] [rbp-18h] BYREF

  v6 = ((__int64)(*(_QWORD *)(a1 + 0x20) << 0x10) >> 0x10) & 0xFFFFFFFFFFFFLL;
  if ( !v6 )
    return 1;
  sub_14035C5F0(&Parameter);
  Parameter = (ULONG_PTR)&off_1480EC218;
  v8 = 0;
  sub_140526930(&Parameter, "variable", a4);
  v14 = v8;
  p_sub_144307710 = sub_144307710;
  v15 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _BYTE *, __int64))(*(_QWORD *)v6 + 8LL);
  v12 = sub_1402A4B80((__int64)v16);
  v9 = a4;
  p_sub_144307710_1 = p_sub_144307710;
  sub_1402A4B80((__int64)&v19);
  v11 = &v19;
  v19 = a4;
  v16[1] = &v20;
  p_p_sub_144307710 = &p_sub_144307710_1;
  sub_142BADB30(v17, &p_sub_144307710_1, v12);
  v5 = v15(v6, *(_WORD *)(a1 + 0x28) & 0x3FFF, a3, v14, v17, a2);
  sub_1402A5200(v16);
  _StarEngineModule__((ULONG_PTR)&Parameter);
  return v5;
}

// --- End Function: sub_1442B1810 (0x1442B1810) ---

// --- Function: sub_144A49240 (0x144A49240) ---
__int64 __fastcall sub_144A49240(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 0x1A0);
}

// --- End Function: sub_144A49240 (0x144A49240) ---

// --- Function: sub_144DDDCB0 (0x144DDDCB0) ---
__int64 *__fastcall sub_144DDDCB0(__int64 *a1)
{
  *a1 = sub_1402A4B80((__int64)"struct SCPlayerInventoryEvt_RequestInventoryData");
  return a1;
}

// --- End Function: sub_144DDDCB0 (0x144DDDCB0) ---

// --- Function: sub_144DDDDD0 (0x144DDDDD0) ---
__int64 *__fastcall sub_144DDDDD0(__int64 *a1)
{
  *a1 = sub_1402A4B80((__int64)"struct SVI_Weapon_StopFire");
  return a1;
}

// --- End Function: sub_144DDDDD0 (0x144DDDDD0) ---

// --- Function: sub_144DDF510 (0x144DDF510) ---
__int64 __fastcall sub_144DDF510(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 *v3; // rax
  __int64 v5; // [rsp+28h] [rbp-50h] BYREF
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  int v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1427439D0)(__int64); // [rsp+60h] [rbp-18h]

  v6 = a3;
  v7 = sub_14310AAB0();
  v8 = 1;
  v3 = sub_144DDDDD0(&v5);
  v9 = sub_1402A4CF0((__int64)v3);
  v10 = byte_149D05FA9;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_1427439D0 = sub_1427439D0;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v6);
}

// --- End Function: sub_144DDF510 (0x144DDF510) ---

// --- Function: sub_1453A9890 (0x1453A9890) ---
__int64 __fastcall sub_1453A9890(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp-20h]
  _QWORD v3[3]; // [rsp+30h] [rbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 0x18);
  v3[0] = a1;
  v3[1] = v2;
  return sub_142BC3B20(v3);
}

// --- End Function: sub_1453A9890 (0x1453A9890) ---

// --- Function: sub_1458BA2A0 (0x1458BA2A0) ---
__int64 __fastcall sub_1458BA2A0(__int64 a1)
{
  return sub_140502620(a1 + 0xB0);
}

// --- End Function: sub_1458BA2A0 (0x1458BA2A0) ---

// --- Function: sub_14595DF30 (0x14595DF30) ---
__int64 __fastcall sub_14595DF30(__int64 a1, AK::WriteBytesMem *a2, __int64 a3, unsigned __int8 a4)
{
  __int64 result; // rax
  unsigned int v5; // eax
  __int64 v6; // r8

  result = sub_1403C3210((__int64)a2);
  if ( (_BYTE)result )
  {
    v5 = AK::WriteBytesMem::Count(a2);
    return sub_145C0C260(a1, v5, v6, a4);
  }
  return result;
}

// --- End Function: sub_14595DF30 (0x14595DF30) ---

// --- Function: sub_145A19860 (0x145A19860) ---
__int64 __fastcall sub_145A19860(__int64 a1)
{
  unsigned __int16 v2; // [rsp+20h] [rbp-18h]

  do
    v2 = sub_14050A670(a1 + 0x220);
  while ( !v2 );
  return v2;
}

// --- End Function: sub_145A19860 (0x145A19860) ---

// --- Function: sub_145BC8320 (0x145BC8320) ---
double *__fastcall sub_145BC8320(__int64 a1, double *a2, unsigned __int8 a3)
{
  __int64 v4; // rax
  __int64 v5; // [rsp+28h] [rbp-B0h] BYREF
  int v6; // [rsp+30h] [rbp-A8h]
  __int64 v7; // [rsp+38h] [rbp-A0h]
  __int64 v8; // [rsp+40h] [rbp-98h]
  __int64 v9; // [rsp+48h] [rbp-90h]
  __int64 v10; // [rsp+50h] [rbp-88h]
  __int64 *v11; // [rsp+58h] [rbp-80h]
  __int64 v12; // [rsp+60h] [rbp-78h]
  unsigned __int8 (__fastcall *v13)(__int64, double *, _QWORD); // [rsp+68h] [rbp-70h]
  __int64 v14; // [rsp+70h] [rbp-68h]
  char *v15; // [rsp+78h] [rbp-60h]
  __int64 v16; // [rsp+80h] [rbp-58h]
  _BYTE v17[72]; // [rsp+90h] [rbp-48h] BYREF

  a2[3] = 0x3FF0000000000000LL;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[4] = 0;
  a2[5] = 0;
  a2[6] = 0;
  if ( *(unsigned __int8 *)(a1 + 0x1FD0) == 0xFF )
    v6 = 0;
  else
    v6 = *(unsigned __int8 *)(a1 + 0x1FD0);
  v8 = a1 + 0x1FA0;
  if ( (unsigned __int8)v6 < (unsigned __int64)((__int64)(*(_QWORD *)(a1 + 0x1FA8) - *(_QWORD *)(a1 + 0x1FA0)) >> 3) )
  {
    v9 = a1 + 0x1FA0;
    v10 = a1 + 0x1FA0;
    v11 = (__int64 *)(*(_QWORD *)(a1 + 0x1FA0) + 8LL * (unsigned __int8)v6);
    v5 = *v11;
    if ( v5 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
    v12 = v5;
    if ( v5 )
    {
      v7 = v5;
      v13 = *(unsigned __int8 (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v5 + 0x70LL);
      if ( v13(v5, a2, a3) )
      {
        sub_1403730D0(&v5);
        return a2;
      }
    }
    sub_1403730D0(&v5);
  }
  v15 = off_149938418;                          // "muzzle_flash"
  v14 = *(_QWORD *)(a1 + 8);
  v16 = v14;
  v4 = sub_145C6FE70(
         v17,
         v14,
         off_149938418,                         // "muzzle_flash"
         a3);
  sub_14030F510(a2, v4);
  return a2;
}

// --- End Function: sub_145BC8320 (0x145BC8320) ---

// --- Function: sub_145C0C260 (0x145C0C260) ---
__int64 __fastcall sub_145C0C260(__int64 a1, unsigned int a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // r8
  int v6; // [rsp+34h] [rbp-A4h]
  __int64 v7; // [rsp+38h] [rbp-A0h] BYREF
  __int64 v8; // [rsp+40h] [rbp-98h]
  double (__fastcall *v9)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+48h] [rbp-90h]
  __int64 v10; // [rsp+50h] [rbp-88h]
  __int64 v11[3]; // [rsp+58h] [rbp-80h] BYREF
  __int64 v12; // [rsp+70h] [rbp-68h]
  __int64 (__fastcall *v13)(_QWORD); // [rsp+78h] [rbp-60h]
  _QWORD v14[11]; // [rsp+80h] [rbp-58h] BYREF

  sub_1402B39B0(v14);
  v14[2] = 1;
  LOWORD(v14[0]) = 0x6200;
  v9 = qword_149A0FD80;
  qword_149A0FD80(v14, 0, &Source, &Source, 0);
  sub_145C10EC0(a1, a2, v4, a4);
  v8 = sub_145BBF590(a1);
  v7 = *(_QWORD *)(v8 + 8);
  if ( Handle::IsValid(&v7) )
  {
    v12 = v7 & 0xFFFFFFFFFFFFLL;
    v6 = *(_DWORD *)(v8 + 0x10);
    v10 = a1 + 8;
    sub_1403B29B0((unsigned __int64 *)(a1 + 8), v11);
    v11[1] = v11[0];
    v11[2] = v11[0];
    CEntityComponentLocalPlayerVisorAudio::SetRtpcValue(v12, v11[0], v6, a2);
  }
  v14[3] = __rdtsc();
  v13 = qword_149A0FD88;
  return qword_149A0FD88(v14);
}

// --- End Function: sub_145C0C260 (0x145C0C260) ---

// --- Function: sub_145C72BF0 (0x145C72BF0) ---
char __fastcall sub_145C72BF0(__int64 a1, char *a2, char a3)
{
  char result; // al
  char *v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rdi
  bool v10; // al
  char *v11; // rax
  __int64 v12; // [rsp+40h] [rbp+8h] BYREF

  result = is_valid_handle_typeB((unsigned __int64 *)(a1 + 8));
  if ( result && (*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) != 0 )
  {
    v7 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) + 0x3D0LL))(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL);
    result = sub_14132EBA0(a2, v7);
  }
  if ( a3 )
  {
    result = sub_145BCD6B0(a1, &v12);
    v8 = v12;
    if ( v12 )
    {
      v9 = (v12 & 0xF000000000000000uLL) != 0 ? v12 & 0xFFFFFF000000LL : (v12 & 0xFFFFFFFFFFFFLL) - 6;
      result = BYTE6(v12);
      if ( *(_WORD *)(v9 + 2) == (HIWORD(v12) & 0xFFF) )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x25) || (v10 = is_thread_flag_57_or_38_set(), v8 = v12, v10) )
          v10 = 1;
        if ( *(_WORD *)(v9 + 4) != 2 || !v10 )
        {
          result = sub_140393CF0(&v12);
          if ( !result )
            return result;
          v8 = v12;
        }
        v11 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x3D0LL))(v8 & 0xFFFFFFFFFFFFLL);
        return sub_14132EBA0(a2, v11);
      }
    }
  }
  return result;
}

// --- End Function: sub_145C72BF0 (0x145C72BF0) ---

// --- Function: sub_145C739C0 (0x145C739C0) ---
__int64 __fastcall sub_145C739C0(__int64 a1)
{
  unsigned __int64 v3; // [rsp+38h] [rbp+10h] BYREF
  unsigned __int64 v4; // [rsp+40h] [rbp+18h] BYREF

  sub_145BCD6B0(a1, &v3);
  if ( is_valid_handle_typeB(&v3) )
    return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v3 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v3 & 0xFFFFFFFFFFFFLL);
  v4 = *(_QWORD *)(a1 + 8);
  if ( is_valid_handle_typeB(&v4) )
    return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v4 & 0xFFFFFFFFFFFFLL);
  else
    return 0;
}

// --- End Function: sub_145C739C0 (0x145C739C0) ---

// --- Function: sub_145CB97E0 (0x145CB97E0) ---
__int64 __fastcall sub_145CB97E0(__int64 a1, __int64 a2)
{
  _BYTE v4[16]; // [rsp+40h] [rbp-28h] BYREF
  __int64 v5; // [rsp+50h] [rbp-18h]

  sub_1411EF6A0(a1, v4, a2);
  if ( !*(_BYTE *)(v5 + 0x19) && !(unsigned __int8)sub_1403821F0(a2, v5 + 0x20) )
    return v5;
  else
    return *(_QWORD *)a1;
}

// --- End Function: sub_145CB97E0 (0x145CB97E0) ---

// --- Function: sub_145E96A60 (0x145E96A60) ---
__int64 __fastcall sub_145E96A60(__int64 a1)
{
  __int64 result; // rax

  if ( --*(_QWORD *)(a1 + 0x20) )
  {
    result = *(_QWORD *)(a1 + 0x18) + 1LL;
    *(_QWORD *)(a1 + 0x18) = result;
  }
  else
  {
    result = a1;
    *(_QWORD *)(a1 + 0x18) = 0;
  }
  return result;
}

// --- End Function: sub_145E96A60 (0x145E96A60) ---

// --- Function: sub_145FCB6C0 (0x145FCB6C0) ---
_QWORD *__fastcall sub_145FCB6C0(_QWORD *a1, __int64 a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_145FCDD00(a1, a2);
  return a1;
}

// --- End Function: sub_145FCB6C0 (0x145FCB6C0) ---

// --- Function: sub_145FCB9F0 (0x145FCB9F0) ---
_QWORD *__fastcall sub_145FCB9F0(_QWORD *a1, __int64 a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_145FCE0F0(a1, a2);
  return a1;
}

// --- End Function: sub_145FCB9F0 (0x145FCB9F0) ---

// --- Function: sub_145FCBA90 (0x145FCBA90) ---
_QWORD *__fastcall sub_145FCBA90(_QWORD *a1, _BYTE *dst)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_145FCE210(a1, dst);
  return a1;
}

// --- End Function: sub_145FCBA90 (0x145FCBA90) ---

// --- Function: sub_145FCCF00 (0x145FCCF00) ---
__int64 __fastcall sub_145FCCF00(_QWORD *a1, volatile signed __int32 **a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  volatile signed __int32 **v5; // [rsp+28h] [rbp-40h]
  volatile signed __int32 *v6; // [rsp+50h] [rbp-18h]

  v5 = (volatile signed __int32 **)(a1 + 0x32);
  if ( a1[0x32] )
  {
    LOBYTE(a4) = 1;
    return sub_142E7ECF0(v5, a2, *a1, a4, 1);
  }
  else
  {
    v6 = *v5;
    *v5 = *a2;
    *a2 = v6;
    if ( *a2 )
      sub_142EDFBC0(*a2);
    result = (__int64)a2;
    *a2 = 0;
  }
  return result;
}

// --- End Function: sub_145FCCF00 (0x145FCCF00) ---

// --- Function: sub_145FCCFD0 (0x145FCCFD0) ---
__int64 *__fastcall sub_145FCCFD0(__int64 a1, __int64 *a2, __int16 a3, __int64 a4)
{
  char v5; // [rsp+30h] [rbp-28h] BYREF
  __int64 v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  __int16 v9; // [rsp+70h] [rbp+18h] BYREF
  __int64 v10; // [rsp+78h] [rbp+20h]

  v10 = a4;
  v9 = a3;
  v6 = sub_142E9CA80(a1);
  v7 = sub_145FD0540(v6, (unsigned int)&v5, (unsigned int)&v9, v6, v10);
  *a2 = v7;
  if ( *a2 )
    sub_142E71120(*a2);
  return a2;
}

// --- End Function: sub_145FCCFD0 (0x145FCCFD0) ---

// --- Function: sub_145FCDD00 (0x145FCDD00) ---
_QWORD *__fastcall sub_145FCDD00(_QWORD *a1, const void *src)
{
  _QWORD *result; // rax
  void *dst; // [rsp+20h] [rbp-28h]
  void *dst_1; // [rsp+28h] [rbp-20h]

  sub_1402A5160(a1);
  dst = (void *)sub_1402A63D0(0x30u);
  if ( dst )
  {
    qmemcpy(dst, src, 0x30u);
    dst_1 = dst;
  }
  else
  {
    dst_1 = 0;
  }
  a1[2] = dst_1;
  *a1 = sub_146038FC0;
  result = a1;
  a1[1] = sub_14603C7C0;
  return result;
}

// --- End Function: sub_145FCDD00 (0x145FCDD00) ---

// --- Function: sub_145FCE210 (0x145FCE210) ---
_QWORD *__fastcall sub_145FCE210(_QWORD *a1, _BYTE *dst)
{
  _QWORD *result; // rax
  void *dst_1; // [rsp+20h] [rbp-28h]
  void *dst_2; // [rsp+28h] [rbp-20h]

  sub_1402A5160(a1);
  dst_1 = (void *)sub_1402A63D0(0x18u);
  if ( dst_1 )
  {
    qmemcpy(dst_1, dst, 0x18u);
    dst_2 = dst_1;
  }
  else
  {
    dst_2 = 0;
  }
  a1[2] = dst_2;
  *a1 = sub_1460391F0;
  result = a1;
  a1[1] = sub_1436746B0;
  return result;
}

// --- End Function: sub_145FCE210 (0x145FCE210) ---

// --- Function: sub_145FD7E90 (0x145FD7E90) ---
char __fastcall sub_145FD7E90(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 *v4; // rax
  int event_key_from_source_location; // [rsp+20h] [rbp-58h]
  __int64 v6; // [rsp+30h] [rbp-48h] BYREF
  __int64 v7; // [rsp+38h] [rbp-40h] BYREF
  int event_key_from_source_location_1; // [rsp+40h] [rbp-38h]
  __int64 n0x20; // [rsp+48h] [rbp-30h]
  __int64 v10; // [rsp+50h] [rbp-28h]
  char v11; // [rsp+58h] [rbp-20h]
  void (*p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ)(); // [rsp+60h] [rbp-18h]
  void *(__fastcall *p_sub_142685070)(__int64, const void *); // [rsp+68h] [rbp-10h]
  unsigned __int64 v15; // [rsp+88h] [rbp+10h] BYREF
  __int64 v16; // [rsp+90h] [rbp+18h]

  v16 = a3;
  v15 = a2;
  if ( is_valid_handle_typeB_w(&v15) )
    return 0;
  v7 = v16;
  if ( event_key_from_source_location_4 )
    event_key_from_source_location = event_key_from_source_location_4;
  else
    event_key_from_source_location = get_event_key_from_source_location(
                                       &event_key_from_source_location_4,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\GameInventory/InventoryEvents.h",
                                       0x4D8);
  event_key_from_source_location_1 = event_key_from_source_location;
  n0x20 = 0x20;
  v4 = sub_144DDDCB0(&v6);
  v10 = sub_1402A4CF0((__int64)v4);
  v11 = byte_149D06022;
  p_??R_lambda_daad5f71a1db84f3475a074fd2d177ad_@@QEBA@XZ = _lambda_daad5f71a1db84f3475a074fd2d177ad_::operator();
  p_sub_142685070 = sub_142685070;
  return (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64 *))(*(_QWORD *)a1 + 0x360LL))(a1, v15, &v7);
}

// --- End Function: sub_145FD7E90 (0x145FD7E90) ---

// --- Function: sub_145FDD880 (0x145FDD880) ---
__int64 __fastcall sub_145FDD880(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned __int16 v5; // [rsp+20h] [rbp-38h]
  volatile signed __int32 *v6[3]; // [rsp+28h] [rbp-30h] BYREF
  __int64 v7[3]; // [rsp+40h] [rbp-18h] BYREF

  v5 = sub_145A19860(a1);
  v6[1] = (volatile signed __int32 *)(a1 + 0x1160);
  sub_145FCCFD0(a1 + 0x1160, (__int64 *)v6, v5, a2);
  sub_1402B07F0(v7, (__int64)"CSCActorActionHandler::Request", a1 + 0x1668, 1);
  v6[2] = (volatile signed __int32 *)(a1 + 0x1160);
  sub_145FCCF00((_QWORD *)(a1 + 0x1160), v6, v2, v3);
  sub_1402B3C20(v7);
  if ( v6[0] )
    sub_142EDFBC0(v6[0]);
  return v5;
}

// --- End Function: sub_145FDD880 (0x145FDD880) ---

// --- Function: sub_145FE9580 (0x145FE9580) ---
__int64 __fastcall sub_145FE9580(__int64 a1, __int64 a2)
{
  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 0x10) )
    return sub_145FEBDC0(a1, *(_QWORD *)(a1 + 8), a2);
  else
    return sub_145FE86D0(a1, a2);
}

// --- End Function: sub_145FE9580 (0x145FE9580) ---

// --- Function: sub_14600D280 (0x14600D280) ---
_QWORD *__fastcall sub_14600D280(_QWORD *a1)
{
  sub_14030B770((__int64)a1);
  *a1 = off_148A3A130;
  sub_141542CA0((__int64)(a1 + 9));
  sub_141542CA0((__int64)(a1 + 0x12));
  sub_14030BAA0((__int64)(a1 + 0x1B));
  sub_141542C60((__int64)(a1 + 0x25));
  sub_14030BA60((__int64)(a1 + 0x2E));
  return a1;
}

// --- End Function: sub_14600D280 (0x14600D280) ---

// --- Function: sub_1460169E0 (0x1460169E0) ---
__int64 __fastcall sub_1460169E0(_QWORD *a1)
{
  sub_14030D6A0(a1 + 0x2E);
  sub_14030D6A0(a1 + 0x25);
  sub_14030D7B0(a1 + 0x1B);
  sub_1414FD2D0(a1 + 0x12);
  sub_1414FD2D0(a1 + 9);
  return sub_14030D6A0(a1);
}

// --- End Function: sub_1460169E0 (0x1460169E0) ---

// --- Function: sub_146038250 (0x146038250) ---
float __fastcall sub_146038250(__int64 a1)
{
  __int64 v1; // rax
  float v3; // [rsp+20h] [rbp-A8h]
  float v4; // [rsp+24h] [rbp-A4h]
  float v5; // [rsp+28h] [rbp-A0h]
  float v6; // [rsp+2Ch] [rbp-9Ch]
  float v7; // [rsp+34h] [rbp-94h]
  float v8; // [rsp+38h] [rbp-90h]
  float *v9; // [rsp+40h] [rbp-88h]
  __int64 v10; // [rsp+48h] [rbp-80h] BYREF
  float v11; // [rsp+50h] [rbp-78h]
  float v12; // [rsp+54h] [rbp-74h]
  __int64 v13; // [rsp+58h] [rbp-70h] BYREF
  __int64 v14; // [rsp+60h] [rbp-68h]
  __int64 v15[3]; // [rsp+68h] [rbp-60h] BYREF
  __int64 v16; // [rsp+80h] [rbp-48h]
  __int64 v18; // [rsp+90h] [rbp-38h]
  __int64 v19; // [rsp+98h] [rbp-30h]
  __int64 v20; // [rsp+A0h] [rbp-28h]
  __int64 v21; // [rsp+A8h] [rbp-20h]
  __int64 v22; // [rsp+B0h] [rbp-18h]

  v6 = 0.0;
  v10 = *(_QWORD *)(a1 + 0x2E0);
  if ( is_valid_handle_typeA(&v10) )
  {
    v13 = *(_QWORD *)(a1 + 0x2F8);
    if ( Handle::IsValid(&v13) )
    {
      v15[1] = v13 & 0xFFFFFFFFFFFFLL;
      v14 = sub_1439E7780(v13 & 0xFFFFFFFFFFFFLL);
      if ( v14 )
      {
        sub_1427489C0(v14, v15);
        if ( is_valid_handle_typeA(v15) )
        {
          v15[2] = v15[0] & 0xFFFFFFFFFFFFLL;
          v1 = sub_14654BC00(v15[0] & 0xFFFFFFFFFFFFLL);
          if ( !(unsigned __int8)sub_144A49240(v1) )
          {
            if ( (unsigned __int8)sub_1403216E0(a1 + 0x9F0) )
            {
              v16 = sub_140334DC0(a1);
              if ( *(_QWORD *)(v16 + 0x50) )
              {
                v18 = sub_140334DC0(a1);
                v19 = *(_QWORD *)(v18 + 0x50);
                v9 = (float *)(v19 + 0x78);
                v20 = v10 & 0xFFFFFFFFFFFFLL;
                v4 = sub_143C05E50(v10 & 0xFFFFFFFFFFFFLL);
                v21 = v10 & 0xFFFFFFFFFFFFLL;
                v3 = sub_143C0F9F0(v10 & 0xFFFFFFFFFFFFLL).m128_f32[0];
                v22 = v10 & 0xFFFFFFFFFFFFLL;
                LODWORD(v5) = sub_143C0F9D0(v10 & 0xFFFFFFFFFFFFLL).m128_u32[0];
                if ( v4 >= v3 )
                {
                  if ( v4 >= v5 )
                  {
                    if ( v5 >= 1.0 )
                      v8 = 1.0;
                    else
                      v8 = (float)(v4 - v5) / (float)(1.0 - v5);
                    v12 = v8;
                    return v9[0x16] + (float)(v8 * (float)(1.0 - v9[0x16]));
                  }
                  else
                  {
                    return v9[0x15];
                  }
                }
                else
                {
                  if ( v3 <= 0.0 )
                    v7 = 0.0;
                  else
                    v7 = (float)(v3 - v4) / v3;
                  v11 = v7;
                  return v9[0x14] + (float)(v7 * (float)(0.0 - v9[0x14]));
                }
              }
            }
          }
        }
      }
    }
  }
  return v6;
}

// --- End Function: sub_146038250 (0x146038250) ---

// --- Function: sub_1460391F0 (0x1460391F0) ---
__int64 __fastcall sub_1460391F0(__int64 a1, __int64 a2, unsigned int a3)
{
  return sub_146020820(*(_QWORD *)(a1 + 0x10), a2, a3);
}

// --- End Function: sub_1460391F0 (0x1460391F0) ---

// --- Function: sub_146041970 (0x146041970) ---
bool __fastcall sub_146041970(_QWORD *a1)
{
  bool result; // al
  __int64 v2; // [rsp+28h] [rbp-1A0h] BYREF
  __int64 v3; // [rsp+30h] [rbp-198h] BYREF
  unsigned __int64 v4; // [rsp+38h] [rbp-190h] BYREF
  __int64 v5; // [rsp+40h] [rbp-188h]
  __int64 v6; // [rsp+48h] [rbp-180h]
  __int64 v7[2]; // [rsp+50h] [rbp-178h] BYREF
  __int64 v8[2]; // [rsp+60h] [rbp-168h] BYREF
  __int64 v9[2]; // [rsp+70h] [rbp-158h] BYREF
  __int64 v10[2]; // [rsp+80h] [rbp-148h] BYREF
  __int64 v11[5]; // [rsp+90h] [rbp-138h] BYREF
  __int64 v13; // [rsp+C0h] [rbp-108h]
  unsigned __int64 v14; // [rsp+C8h] [rbp-100h]
  _QWORD v15[2]; // [rsp+D0h] [rbp-F8h] BYREF
  __int64 v16; // [rsp+E0h] [rbp-E8h]
  unsigned __int64 v17; // [rsp+E8h] [rbp-E0h]
  _QWORD v18[3]; // [rsp+F0h] [rbp-D8h] BYREF
  void (__fastcall *v19)(__int64, _QWORD, _BYTE *); // [rsp+108h] [rbp-C0h]
  __int64 v20; // [rsp+110h] [rbp-B8h]
  unsigned __int64 v21; // [rsp+118h] [rbp-B0h]
  _QWORD v22[2]; // [rsp+120h] [rbp-A8h] BYREF
  void (__fastcall *v23)(__int64, unsigned __int64 *); // [rsp+130h] [rbp-98h]
  __int64 v24; // [rsp+138h] [rbp-90h]
  __int64 *v25; // [rsp+140h] [rbp-88h]
  __int64 v26; // [rsp+148h] [rbp-80h]
  __int64 v27; // [rsp+150h] [rbp-78h] BYREF
  __int64 v28; // [rsp+158h] [rbp-70h]
  __int64 *v29; // [rsp+160h] [rbp-68h]
  __int64 v30; // [rsp+168h] [rbp-60h]
  unsigned __int8 (__fastcall *v31)(__int64, __int64); // [rsp+170h] [rbp-58h]
  unsigned __int8 (__fastcall *v32)(__int64, __int64); // [rsp+178h] [rbp-50h]
  __int64 v33; // [rsp+180h] [rbp-48h] BYREF
  __int64 v34; // [rsp+188h] [rbp-40h] BYREF
  _BYTE v35[56]; // [rsp+190h] [rbp-38h] BYREF

  v2 = a1[0x5F];
  if ( !Handle::IsValid(&v2) )
    return 0;
  v11[2] = v2 & 0xFFFFFFFFFFFFLL;
  if ( !sub_1439F05A0(v2 & 0xFFFFFFFFFFFFLL) )
    return 0;
  v11[3] = v2 & 0xFFFFFFFFFFFFLL;
  if ( !sub_1439F0470(v2 & 0xFFFFFFFFFFFFLL) )
    return 0;
  v11[4] = v2 & 0xFFFFFFFFFFFFLL;
  if ( !sub_1439E7780(v2 & 0xFFFFFFFFFFFFLL) )
    return 0;
  v3 = a1[0x59];
  if ( !is_valid_handle_typeA(&v3) )
    return 0;
  v5 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x98);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0xA0LL))(v5);
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x420LL))(v6) )
  {
    v13 = v3 & 0xFFFFFFFFFFFFLL;
    _StarEngineModule__(0);
    v14 = *(_QWORD *)(v13 + 8);
    sub_1420F1E00(v15, v14);
    v15[1] = v15[0];
    v7[0] = v15[0];
    if ( is_valid_handle_typeA(v7) )
    {
      v7[1] = v7[0] & 0xFFFFFFFFFFFFLL;
      if ( (*(float (__fastcall **)(__int64))(*(_QWORD *)(v7[0] & 0xFFFFFFFFFFFFLL) + 0x610LL))(v7[0] & 0xFFFFFFFFFFFFLL) < 0.00000011920929 )
        return 0;
    }
  }
  else
  {
    v16 = v3 & 0xFFFFFFFFFFFFLL;
    _StarEngineModule__(0);
    v17 = *(_QWORD *)(v16 + 8);
    sub_1422A3490(v18, v17);
    v18[1] = v18[0];
    v8[0] = v18[0];
    if ( is_valid_handle_typeA(v8) )
    {
      sub_14045EEE0((__int64)v35);
      v8[1] = v8[0] & 0xFFFFFFFFFFFFLL;
      v19 = *(void (__fastcall **)(__int64, _QWORD, _BYTE *))(*(_QWORD *)(v8[0] & 0xFFFFFFFFFFFFLL) + 0x658LL);
      v18[2] = v3 & 0xFFFFFFFFFFFFLL;
      v19(v8[0] & 0xFFFFFFFFFFFFLL, *(unsigned __int16 *)((v3 & 0xFFFFFFFFFFFFLL) + 0x10), v35);
      if ( !sub_1404C8CA0((__int64)v35) )
        return 0;
    }
  }
  if ( Handle::IsValid(a1 + 0x58) )
  {
    v20 = a1[0x58] & 0xFFFFFFFFFFFFLL;
    if ( !sub_1430EBF80(v20) )
      return 0;
  }
  _StarEngineModule__(0);
  v21 = a1[1];
  sub_140424A80(v22, v21);
  v22[1] = v22[0];
  v9[0] = v22[0];
  if ( !AssetMeta::HasActorSubresource(v9) )
    goto LABEL_25;
  v9[1] = v9[0] & 0xFFFFFFFFFFFFLL;
  v23 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)(v9[0] & 0xFFFFFFFFFFFFLL) + 0x658LL);
  v23(v9[0] & 0xFFFFFFFFFFFFLL, &v4);
  if ( !is_valid_handle_typeB(&v4) )
    goto LABEL_25;
  v24 = sub_1403103B0(&v4);
  v25 = sub_14033C8B0(v24, &v33);
  v26 = *v25;
  v27 = v26;
  if ( AssetMeta::HasActorSubresource(&v27) )
    goto LABEL_25;
  v28 = sub_1403103B0(&v4);
  v29 = sub_1415321E0(v28, &v34);
  v30 = *v29;
  v10[0] = v30;
  if ( is_valid_handle_typeA(v10) )
  {
    v10[1] = v10[0] & 0xFFFFFFFFFFFFLL;
    v31 = *(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)(v10[0] & 0xFFFFFFFFFFFFLL) + 0x580LL);
    if ( v31(v10[0] & 0xFFFFFFFFFFFFLL, 1) )
      return 0;
  }
LABEL_25:
  v11[0] = a1[0x5B];
  result = 1;
  if ( AssetMeta::HasActorSubresource(v11) )
  {
    v11[1] = v11[0] & 0xFFFFFFFFFFFFLL;
    v32 = *(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)(v11[0] & 0xFFFFFFFFFFFFLL) + 0x8A8LL);
    if ( v32(v11[0] & 0xFFFFFFFFFFFFLL, 3) )
      return 0;
  }
  return result;
}

// --- End Function: sub_146041970 (0x146041970) ---

// --- Function: sub_146042A40 (0x146042A40) ---
void __fastcall sub_146042A40(__int64 a1)
{
  _BYTE buf_[4]; // [rsp+20h] [rbp-48h] BYREF
  ULONG_PTR Parameter; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v4[2]; // [rsp+30h] [rbp-38h] BYREF
  Parameter *Parameter_1; // [rsp+40h] [rbp-28h]
  __int64 v6; // [rsp+48h] [rbp-20h]
  _QWORD v7[3]; // [rsp+50h] [rbp-18h] BYREF

  v4[1] = a1 + 0x370;
  Parameter_1 = **(_QWORD **)(a1 + 0x370);
  Parameter = Parameter_1;
  _StarEngineModule__((ULONG_PTR)&Parameter);
  memset(buf_, 0, 1u);
  while ( *(_BYTE *)(Parameter + 0x19) == 0 )
  {
    v4[0] = *(_QWORD *)(Parameter + 0x20);
    if ( !is_valid_handle_typeA((__int64 *)(a1 + 0x2E8))
      || (v6 = *(_QWORD *)(a1 + 0x2E8) & 0xFFFFFFFFFFFFLL,
          v7[0] = *(_QWORD *)(v6 + 8),
          v7[1] = v7,
          !std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(v7, v4)) )
    {
      sub_143BD68A0(v4[0]);
    }
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string>>>>>,std::_Iterator_base0>::operator++((std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::string const ,AK::WwiseAuthoringAPI::AkJsonBase<AK::WwiseAuthoringAPI::AkVariant,std::string,std::less<std::string > > > > >,std::_Iterator_base0> *)&Parameter);
  }
  std::_Tree<std::_Tmap_traits<float,int,std::less<float>,std::allocator<std::pair<float const,int>>,0>>::clear((std::_Tree<std::_Tmap_traits<float,int,std::less<float>,std::allocator<std::pair<float const ,int> >,0> > *)(a1 + 0x370));
}

// --- End Function: sub_146042A40 (0x146042A40) ---

// --- Function: sub_14604E0C0 (0x14604E0C0) ---
__int64 __fastcall sub_14604E0C0(__int64 a1, char a2, __int64 a3)
{
  char v3; // al
  char v4; // al
  void *v5; // rsp
  __int64 v6; // r8
  __int64 v8; // [rsp+18h] [rbp-88h]
  _BYTE v9[32]; // [rsp+30h] [rbp-70h] BYREF
  int v11; // [rsp+A4h] [rbp+4h]
  unsigned __int64 v12; // [rsp+A8h] [rbp+8h] BYREF
  _DWORD v13[2]; // [rsp+B0h] [rbp+10h] BYREF
  char v14; // [rsp+B8h] [rbp+18h] BYREF
  _DWORD v15[2]; // [rsp+C0h] [rbp+20h] BYREF
  char v16; // [rsp+C8h] [rbp+28h] BYREF
  _BYTE *v17; // [rsp+D0h] [rbp+30h]
  _BYTE *__Val_0__; // [rsp+D8h] [rbp+38h]
  __int64 v19[2]; // [rsp+E0h] [rbp+40h] BYREF
  __int64 v20; // [rsp+F0h] [rbp+50h]
  unsigned __int64 v21; // [rsp+F8h] [rbp+58h] BYREF
  __int64 v22; // [rsp+100h] [rbp+60h]
  __int64 v23; // [rsp+108h] [rbp+68h]
  __int64 *v24; // [rsp+110h] [rbp+70h]
  __int64 v25; // [rsp+118h] [rbp+78h]
  void (__fastcall *v26)(__int64, unsigned __int64 *); // [rsp+120h] [rbp+80h]
  __int64 v27; // [rsp+128h] [rbp+88h]
  __int64 *v28; // [rsp+130h] [rbp+90h]
  __int64 v29; // [rsp+138h] [rbp+98h]
  __int64 v30[4]; // [rsp+140h] [rbp+A0h] BYREF
  __int64 v31; // [rsp+160h] [rbp+C0h]
  void (__fastcall *v32)(__int64, unsigned __int64 *, __int64); // [rsp+168h] [rbp+C8h]
  void (__fastcall *v33)(__int64, _QWORD, __int64, _QWORD); // [rsp+170h] [rbp+D0h]
  __int64 v34; // [rsp+178h] [rbp+D8h]
  __int64 v35; // [rsp+180h] [rbp+E0h] BYREF
  __int64 v36; // [rsp+188h] [rbp+E8h]
  int *ThreadLogContextSlot; // [rsp+190h] [rbp+F0h]
  _QWORD v38[2]; // [rsp+198h] [rbp+F8h] BYREF
  _QWORD src_[2]; // [rsp+1A8h] [rbp+108h] BYREF
  _QWORD src__1[2]; // [rsp+1B8h] [rbp+118h] BYREF
  _QWORD v41[2]; // [rsp+1C8h] [rbp+128h] BYREF
  __int64 v42; // [rsp+1D8h] [rbp+138h] BYREF
  __int64 v43; // [rsp+1E0h] [rbp+140h] BYREF
  _BYTE dst_[16]; // [rsp+1E8h] [rbp+148h] BYREF
  _BYTE dst__1[16]; // [rsp+1F8h] [rbp+158h] BYREF
  _QWORD dst__2[3]; // [rsp+208h] [rbp+168h] BYREF
  int v47; // [rsp+220h] [rbp+180h] BYREF
  _BYTE dst__4[24]; // [rsp+228h] [rbp+188h] BYREF
  _BYTE dst__3[24]; // [rsp+240h] [rbp+1A0h] BYREF

  sub_1402B07F0(&v35, (__int64)"CSCItemMiningController::FinishMoveToInventory", a1 + 0x678, 1);
  if ( *(_QWORD *)(a1 + 0x6A8) != 0 )
  {
    v36 = *(_QWORD *)sub_1453A9890(a1 + 0x688);
    if ( sub_1403811B0(v36, a3) )
    {
      v3 = sub_14056BB30(0x40);
      v13[0] = sub_1426D6DE0(v3);
      v13[1] = 0x63;
      src_[0] = v13;
      src_[1] = &v14;
      qmemcpy(dst_, src_, sizeof(dst_));
      v11 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)dst_,
              (__int64)"Invalid absorb queue",
              "[CWeaponActionGatheringBeam::FinishMoveToInventory]: Finished moving entity to inventory but the entity is"
              " not at front of absorb queue.");
      if ( (v11 & 0xFFFFF) != 0 )
      {
        ThreadLogContextSlot = getThreadLogContextSlot();
        v38[0] = 0;
        v38[1] = 0;
        v4 = sub_14056BB30(0x40);
        v15[0] = sub_1426D6DE0(v4);
        v15[1] = 0x63;
        src__1[0] = v15;
        src__1[1] = &v16;
        qmemcpy(dst__1, src__1, sizeof(dst__1));
        v41[1] = 1;
        v5 = alloca(0x70);
        v17 = v9;
        __Val_0__ = v9;
        sub_140355D10((__int64)v9, (__int64)ThreadLogContextSlot);
        LODWORD(v8) = v11;
        sub_140305B00(
          3,
          (__int64)dst__1,
          "Invalid absorb queue",
          (__int64)"[CWeaponActionGatheringBeam::FinishMoveToInventory]: Finished moving entity to inventory but the enti"
                   "ty is not at front of absorb queue.",
          (__int64)__Val_0__,
          1u,
          1,
          v8,
          v38,
          0);
      }
    }
    else
    {
      qmemcpy(dst__2, (const void *)(sub_1453A9890(a1 + 0x688) + 8), sizeof(dst__2));
      v23 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
               dst__2,
               &v42);
      v24 = sub_141298CE0(v41);
      v25 = *v24;
      v19[0] = v25;
      if ( AssetMeta::HasActorSubresource(v19) )
      {
        v19[1] = v19[0] & 0xFFFFFFFFFFFFLL;
        v26 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)(v19[0] & 0xFFFFFFFFFFFFLL) + 0x658LL);
        v26(v19[0] & 0xFFFFFFFFFFFFLL, &v12);
        if ( is_valid_handle_typeB(&v12) )
        {
          v27 = sub_1403103B0(&v12);
          v28 = sub_14033C600(v27, &v43);
          v29 = *v28;
          v30[0] = v29;
          if ( AssetMeta::HasActorSubresource(v30) )
          {
            v31 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
            qmemcpy(dst__3, dst__2, sizeof(dst__3));
            v47 = 0;
            qmemcpy(dst__4, dst__3, sizeof(dst__4));
            v30[2] = (__int64)&v47;
            v30[1] = v12;
            v30[3] = v12;
            sub_145FD7E90(v31, v12, (__int64)&v47);
          }
        }
      }
      sub_145E96A60(a1 + 0x688);
    }
    if ( !a2 )
    {
      v20 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
      v32 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v20 + 0x120LL);
      v32(v20, &v21, a3);
      if ( is_valid_handle_typeB(&v21) )
      {
        v22 = sub_1403103B0(&v21);
        v33 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)v22 + 0x310LL);
        LOBYTE(v6) = 1;
        v33(v22, 0, v6, 0);
        v34 = a1 + 0x648;
        sub_14154DC80(a1 + 0x648, a3, 0);
      }
    }
  }
  *(_BYTE *)(a1 + 0x6B0) = 0;
  return sub_1402B3C20(&v35);
}

// --- End Function: sub_14604E0C0 (0x14604E0C0) ---

// --- Function: sub_146050F00 (0x146050F00) ---
__int64 __fastcall sub_146050F00(__int64 a1)
{
  __int64 v2[2]; // [rsp+20h] [rbp-28h] BYREF

  v2[0] = *(_QWORD *)(a1 + 0x2C8);
  if ( !is_valid_handle_typeA(v2) )
    return 0;
  v2[1] = v2[0] & 0xFFFFFFFFFFFFLL;
  return sub_143C0C5C0(*(_QWORD *)((v2[0] & 0xFFFFFFFFFFFFLL) + 8));
}

// --- End Function: sub_146050F00 (0x146050F00) ---

// --- Function: sub_1460565A0 (0x1460565A0) ---
float __fastcall sub_1460565A0(__int64 a1, char n0x13, bool *a3, bool *a4)
{
  bool is_equal; // [rsp+20h] [rbp-68h]
  bool v6; // [rsp+21h] [rbp-67h]
  float v7; // [rsp+24h] [rbp-64h]
  __int64 v8; // [rsp+30h] [rbp-58h]
  const struct std::pmr::memory_resource *v9; // [rsp+38h] [rbp-50h]
  _QWORD v10[2]; // [rsp+50h] [rbp-38h] BYREF
  std::pmr::_Identity_equal_resource *v11; // [rsp+60h] [rbp-28h]
  __int64 v12; // [rsp+68h] [rbp-20h]
  __int64 v13; // [rsp+70h] [rbp-18h]

  v9 = 0;
  if ( Handle::IsValid((_QWORD *)(a1 + 0x2A8)) )
  {
    v8 = sub_1439E7780(*(_QWORD *)(a1 + 0x2A8) & 0xFFFFFFFFFFFFLL);
    if ( v8 )
    {
      sub_1403B29B0((unsigned __int64 *)(v8 + 8), v10);
      v9 = (const struct std::pmr::memory_resource *)v10[0];
    }
  }
  v7 = 0.0;
  is_equal = 0;
  v6 = 0;
  if ( n0x13 == 0x13 )
  {
    v7 = *(float *)(a1 + 0x1B40);
    v10[1] = v9;
    v11 = *(std::pmr::_Identity_equal_resource **)(a1 + 0x1B48);
    is_equal = std::pmr::_Identity_equal_resource::do_is_equal(v11, v9);
    v12 = 0;
    v13 = *(_QWORD *)(a1 + 0x1B48);
    v6 = sub_1403811B0(v13, 0);
  }
  if ( a3 )
    *a3 = is_equal;
  if ( a4 )
    *a4 = v6;
  return v7;
}

// --- End Function: sub_1460565A0 (0x1460565A0) ---

// --- Function: sub_146058C30 (0x146058C30) ---
_QWORD *__fastcall sub_146058C30(__int64 a1, _QWORD *a2)
{
  __int64 v3; // [rsp+20h] [rbp-58h] BYREF
  __int64 v4; // [rsp+28h] [rbp-50h] BYREF
  __int64 v5; // [rsp+30h] [rbp-48h]
  __int64 v6; // [rsp+38h] [rbp-40h]
  __int64 v7; // [rsp+40h] [rbp-38h]
  __int64 v8; // [rsp+48h] [rbp-30h]
  _QWORD v9[2]; // [rsp+50h] [rbp-28h] BYREF
  void (__fastcall *v10)(__int64, _QWORD *, _QWORD); // [rsp+60h] [rbp-18h]

  v3 = *(_QWORD *)(a1 + 0x2F8);
  if ( Handle::IsValid(&v3)
    && (v7 = v3 & 0xFFFFFFFFFFFFLL, (v5 = sub_1439E7780(v3 & 0xFFFFFFFFFFFFLL)) != 0)
    && (v4 = *(_QWORD *)(a1 + 0x2D0), is_valid_handle_typeA(&v4)) )
  {
    v6 = v4 & 0xFFFFFFFFFFFFLL;
    v10 = *(void (__fastcall **)(__int64, _QWORD *, _QWORD))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 0x6E0LL);
    v8 = v5 + 8;
    sub_1403B29B0((unsigned __int64 *)(v5 + 8), v9);
    v9[1] = v9[0];
    v10(v6, a2, v9[0]);
    return a2;
  }
  else
  {
    sub_1402B3A70(a2);
    return a2;
  }
}

// --- End Function: sub_146058C30 (0x146058C30) ---

// --- Function: sub_146058D60 (0x146058D60) ---
double __fastcall sub_146058D60(__int64 a1)
{
  _QWORD v2[2]; // [rsp+20h] [rbp-28h] BYREF
  __int128 v3; // [rsp+30h] [rbp-18h] BYREF

  sub_146058C30(a1, &v3);
  if ( !Concurrency::details::_ContextCallback::_HasCapturedContext((Concurrency::details::_ContextCallback *)&v3) )
    return 0.0;
  v2[0] = *(_QWORD *)(a1 + 0x300);
  if ( !Handle::IsValid(v2) )
    return 0.0;
  v2[1] = v2[0] & 0xFFFFFFFFFFFFLL;
  return sub_142A20CE0(v2[0] & 0xFFFFFFFFFFFFLL, &v3);
}

// --- End Function: sub_146058D60 (0x146058D60) ---

// --- Function: sub_146067EB0 (0x146067EB0) ---
_BOOL8 __fastcall sub_146067EB0(__int64 a1)
{
  bool is_valid_handle_typeB; // [rsp+20h] [rbp-28h]
  __int64 v3[4]; // [rsp+28h] [rbp-20h] BYREF

  v3[0] = a1 + 0x5F0;
  v3[1] = a1 + 0x5F0;
  sub_1402CEFE0(a1 + 0x5F0, (__int64)"CSCItemMiningController::HasRegisteredGatheringBeam", 1);
  v3[2] = a1 + 0x600;
  is_valid_handle_typeB = j_is_valid_handle_typeB((unsigned __int64 *)(a1 + 0x600));
  sub_1402B3C20(v3);
  return is_valid_handle_typeB;
}

// --- End Function: sub_146067EB0 (0x146067EB0) ---

// --- Function: sub_14606E9E0 (0x14606E9E0) ---
__int64 __fastcall sub_14606E9E0(__int64 a1)
{
  return sub_1460B14E0(a1);
}

// --- End Function: sub_14606E9E0 (0x14606E9E0) ---

// --- Function: sub_1460793B0 (0x1460793B0) ---
__int64 __fastcall sub_1460793B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // [rsp+20h] [rbp-A8h] BYREF
  __int64 v5; // [rsp+28h] [rbp-A0h]
  __int64 v6; // [rsp+30h] [rbp-98h]
  __int64 v7; // [rsp+38h] [rbp-90h]
  __int64 v8; // [rsp+40h] [rbp-88h]
  __int64 v9; // [rsp+48h] [rbp-80h]
  void (__fastcall *v10)(__int64, unsigned __int64 *, __int64); // [rsp+50h] [rbp-78h]
  __int64 v11; // [rsp+58h] [rbp-70h]
  __int64 *v12; // [rsp+60h] [rbp-68h]
  __int64 v13; // [rsp+68h] [rbp-60h]
  __int64 v14; // [rsp+70h] [rbp-58h] BYREF
  __int64 v15; // [rsp+78h] [rbp-50h]
  __int64 *v16; // [rsp+80h] [rbp-48h]
  __int64 v17; // [rsp+88h] [rbp-40h]
  __int64 v18[2]; // [rsp+90h] [rbp-38h] BYREF
  __int64 (__fastcall *v19)(__int64, __int64, _QWORD, _QWORD); // [rsp+A0h] [rbp-28h]
  __int64 v20; // [rsp+A8h] [rbp-20h] BYREF
  _QWORD v21[3]; // [rsp+B0h] [rbp-18h] BYREF

  *(_DWORD *)(a1 + 0x3D4) = 0;
  result = *(unsigned __int8 *)(a3 + 0x184);
  if ( *(_BYTE *)(a3 + 0x184) )
  {
    result = sub_1402A4B80(a3);
    if ( *(_QWORD *)result )
    {
      v5 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
      v10 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v5 + 0x180LL);
      v9 = *(_QWORD *)sub_1402A4B80(a3);
      v10(v5, &v4, v9);
      result = is_valid_handle_typeB(&v4);
      if ( (_BYTE)result )
      {
        v11 = sub_1403103B0(&v4);
        v12 = sub_1429AAF80(v11, &v20);
        v13 = *v12;
        v14 = v13;
        result = is_valid_handle_typeA(&v14);
        if ( (_BYTE)result )
        {
          v15 = sub_1403103B0(&v4);
          v16 = sub_1404251A0(v15, v21);
          v17 = *v16;
          v18[0] = v17;
          result = is_valid_handle_typeA(v18);
          if ( (_BYTE)result )
          {
            v6 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x98);
            v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xA0LL))(v6);
            v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x268LL))(v7);
            v19 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v8 + 0x18LL);
            v18[1] = 0;
            return v19(v8, 0x46, 0, 0);
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1460793B0 (0x1460793B0) ---

// --- Function: sub_1460795C0 (0x1460795C0) ---
char __fastcall sub_1460795C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v7; // rax
  __int64 v9; // [rsp+60h] [rbp-298h] BYREF
  __int64 v10; // [rsp+68h] [rbp-290h]
  __int64 v11; // [rsp+70h] [rbp-288h]
  __int64 v12; // [rsp+78h] [rbp-280h]
  float src_[4]; // [rsp+80h] [rbp-278h] BYREF
  float dst_[3]; // [rsp+90h] [rbp-268h] BYREF
  float v15[4]; // [rsp+A0h] [rbp-258h] BYREF
  __int64 v16; // [rsp+B0h] [rbp-248h]
  __int64 v17; // [rsp+B8h] [rbp-240h]
  void (__fastcall *v18)(__int64, double *, double *); // [rsp+C0h] [rbp-238h]
  _BYTE *v19; // [rsp+C8h] [rbp-230h]
  __int64 (__fastcall *v20)(__int64, _BYTE *); // [rsp+D0h] [rbp-228h]
  __int64 v21; // [rsp+D8h] [rbp-220h]
  double v22; // [rsp+E0h] [rbp-218h]
  double v23; // [rsp+E8h] [rbp-210h]
  double v24; // [rsp+F0h] [rbp-208h]
  float *src; // [rsp+F8h] [rbp-200h]
  _QWORD *v26; // [rsp+100h] [rbp-1F8h]
  __int64 v27; // [rsp+108h] [rbp-1F0h]
  float *v28; // [rsp+110h] [rbp-1E8h]
  double v29; // [rsp+118h] [rbp-1E0h]
  double v30; // [rsp+120h] [rbp-1D8h]
  double v31; // [rsp+128h] [rbp-1D0h]
  _BYTE v32[8]; // [rsp+130h] [rbp-1C8h] BYREF
  int v33; // [rsp+138h] [rbp-1C0h] BYREF
  double v34; // [rsp+140h] [rbp-1B8h] BYREF
  double v35; // [rsp+148h] [rbp-1B0h]
  double v36; // [rsp+150h] [rbp-1A8h]
  double v37; // [rsp+158h] [rbp-1A0h]
  _BYTE v38[24]; // [rsp+160h] [rbp-198h] BYREF
  double v39[7]; // [rsp+178h] [rbp-180h] BYREF
  char v40[96]; // [rsp+1B0h] [rbp-148h] BYREF
  _BYTE v41[192]; // [rsp+210h] [rbp-E8h] BYREF

  v9 = *(_QWORD *)(a1 + 0x2C8);
  if ( is_valid_handle_typeA(&v9) )
  {
    v16 = v9 & 0xFFFFFFFFFFFFLL;
    v11 = sub_1403E7D30((unsigned __int64 *)((v9 & 0xFFFFFFFFFFFFLL) + 8));
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x648LL))(v11);
    v17 = v9 & 0xFFFFFFFFFFFFLL;
    sub_145BC8320(v9 & 0xFFFFFFFFFFFFLL, v39, 0);
    v18 = *(void (__fastcall **)(__int64, double *, double *))(*(_QWORD *)v10 + 0xD8LL);
    v18(v10, &v34, v39);
    sub_140456A20((__int64)v40);
    if ( is_valid_handle_typeA(&v9) )
      v12 = v9 & 0xFFFFFFFFFFFFLL;
    else
      v12 = 0;
    sub_145C72BF0(v12, v40, 1);
    v19 = v32;
    v20 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v10 + 0x18LL);
    v26 = (_QWORD *)v20(v10, v32);
    v21 = *(_QWORD *)sub_14036BA30(&v33, 0, 0);
    v27 = v21;
    v24 = 2.0 * (v36 * v35 + v34 * v37);
    v23 = 2.0 * (v35 * v35 + v37 * v37) - 1.0;
    v22 = 2.0 * (v34 * v35 - v36 * v37);
    v29 = v22;
    v30 = v23;
    _XMM0 = *(unsigned __int64 *)&v24;
    v31 = v24;
    __asm { vcvtsd2ss xmm0, xmm0, [rsp+2F8h+var_1E0] }
    src_[0] = *(float *)&_XMM0;
    __asm { vcvtsd2ss xmm0, xmm0, [rsp+2F8h+var_1D8] }
    src_[1] = *(float *)&_XMM0;
    __asm { vcvtsd2ss xmm0, xmm0, [rsp+2F8h+var_1D0] }
    src_[2] = *(float *)&_XMM0;
    src = src_;
    qmemcpy(dst_, src_, sizeof(dst_));
    v15[0] = dst_[0] * 10.0;
    v15[1] = dst_[1] * 10.0;
    v15[2] = dst_[2] * 10.0;
    v28 = v15;
    v7 = sub_140456C10(
           (__int64)v41,
           (__int64)"CSCItemMiningController::OnFPSRaycastSubmit",
           (__int64)v38,
           (__int64)v15,
           0x11F,
           0x40F,
           v40,
           1u,
           v21,
           v26);
    sub_14154B990(a3, v7);
    sub_140465AE0((__int64)v41);
    sub_1404659E0((__int64)v40);
    return 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x3D4) = 0;
    return 0;
  }
}

// --- End Function: sub_1460795C0 (0x1460795C0) ---

// --- Function: sub_146088900 (0x146088900) ---
__int64 __fastcall sub_146088900(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // [rsp+20h] [rbp-88h] BYREF
  __int64 v6; // [rsp+28h] [rbp-80h] BYREF
  __int64 v7; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+38h] [rbp-70h] BYREF
  unsigned __int64 v9[2]; // [rsp+40h] [rbp-68h] BYREF
  __int64 v10; // [rsp+50h] [rbp-58h]
  __int64 v11; // [rsp+58h] [rbp-50h]
  __int64 v12; // [rsp+60h] [rbp-48h]
  unsigned __int64 *v13; // [rsp+68h] [rbp-40h]
  __int64 v14; // [rsp+70h] [rbp-38h]
  void (__fastcall *v15)(__int64, unsigned __int64 *, __int64); // [rsp+78h] [rbp-30h]
  __int64 v16; // [rsp+80h] [rbp-28h]
  _QWORD v17[2]; // [rsp+88h] [rbp-20h] BYREF
  __int64 v18; // [rsp+98h] [rbp-10h] BYREF

  *(_DWORD *)(a1 + 0x3D0) = 0;
  v6 = *(_QWORD *)(a1 + 0x2F8);
  result = Handle::IsValid(&v6);
  if ( (_BYTE)result )
  {
    v9[1] = v6 & 0xFFFFFFFFFFFFLL;
    result = sub_1439F0470(v6 & 0xFFFFFFFFFFFFLL);
    if ( (_BYTE)result )
    {
      v5 = *(_QWORD *)(a1 + 0x3C8);
      if ( is_valid_handle_typeA(&v5) )
      {
        if ( *(int *)(a3 + 0x180) <= 0 )
        {
          v12 = v5 & 0xFFFFFFFFFFFFLL;
          v13 = sub_143103750(v5 & 0xFFFFFFFFFFFFLL, &v18);
          if ( is_valid_handle_typeB_w(v13) )
            sub_143100820(v5 & 0xFFFFFFFFFFFFLL);
        }
        else
        {
          v11 = v5 & 0xFFFFFFFFFFFFLL;
          v10 = sub_1402A4B80(a3) + 0x30;
          sub_1431009E0(v11, v10);
        }
      }
      result = a3;
      if ( *(int *)(a3 + 0x180) > 0 )
      {
        v8 = *(_QWORD *)(a1 + 0x2E0);
        result = is_valid_handle_typeA(&v8);
        if ( (_BYTE)result )
        {
          v7 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
          v15 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v7 + 0x180LL);
          v14 = *(_QWORD *)sub_1402A4B80(a3);
          v15(v7, v9, v14);
          result = is_valid_handle_typeB(v9);
          if ( (_BYTE)result )
          {
            v16 = v8 & 0xFFFFFFFFFFFFLL;
            v17[0] = *(_QWORD *)((v8 & 0xFFFFFFFFFFFFLL) + 8);
            v17[1] = v17;
            result = std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(v17, v9);
            if ( (_BYTE)result )
            {
              v4 = sub_1402A4B80(a3);
              return sub_1460B9CA0(a1, v4 + 0x30);
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_146088900 (0x146088900) ---

// --- Function: sub_146088B90 (0x146088B90) ---
char __fastcall sub_146088B90(__int64 a1, __int64 a2, __int64 dst)
{
  __int64 *v8; // rax
  char *v13; // rax
  unsigned __int64 *v15; // rax
  __int64 *v21; // rax
  char *v26; // rax
  float *v27; // [rsp+30h] [rbp-518h]
  float v28; // [rsp+44h] [rbp-504h]
  double v29; // [rsp+48h] [rbp-500h]
  double v30; // [rsp+50h] [rbp-4F8h]
  double v31; // [rsp+58h] [rbp-4F0h]
  float v32; // [rsp+68h] [rbp-4E0h]
  float v33; // [rsp+6Ch] [rbp-4DCh]
  float v34; // [rsp+70h] [rbp-4D8h]
  float v35; // [rsp+78h] [rbp-4D0h]
  float v36; // [rsp+7Ch] [rbp-4CCh]
  float v37; // [rsp+80h] [rbp-4C8h]
  float v38; // [rsp+84h] [rbp-4C4h]
  double dst_[3]; // [rsp+90h] [rbp-4B8h] BYREF
  __int64 v40; // [rsp+A8h] [rbp-4A0h] BYREF
  unsigned __int64 v41[2]; // [rsp+B0h] [rbp-498h] BYREF
  double v42; // [rsp+C0h] [rbp-488h] BYREF
  double v43; // [rsp+C8h] [rbp-480h]
  double v44; // [rsp+D0h] [rbp-478h]
  double v45; // [rsp+D8h] [rbp-470h]
  double v46; // [rsp+E0h] [rbp-468h]
  double v47; // [rsp+E8h] [rbp-460h]
  double v48; // [rsp+F0h] [rbp-458h]
  double v49; // [rsp+F8h] [rbp-450h]
  __int64 v50[3]; // [rsp+100h] [rbp-448h] BYREF
  unsigned __int64 v51[3]; // [rsp+118h] [rbp-430h] BYREF
  __int64 v52; // [rsp+130h] [rbp-418h]
  double v53; // [rsp+138h] [rbp-410h]
  __int64 v54; // [rsp+140h] [rbp-408h]
  __int64 v55; // [rsp+148h] [rbp-400h] BYREF
  __int64 v56; // [rsp+150h] [rbp-3F8h]
  __int64 v57; // [rsp+158h] [rbp-3F0h] BYREF
  __int64 v58; // [rsp+160h] [rbp-3E8h]
  __int64 v59; // [rsp+168h] [rbp-3E0h]
  __int64 *v60; // [rsp+170h] [rbp-3D8h]
  unsigned __int64 *v61; // [rsp+178h] [rbp-3D0h]
  __int64 v62; // [rsp+180h] [rbp-3C8h]
  __int64 v63; // [rsp+188h] [rbp-3C0h]
  __int64 v64; // [rsp+190h] [rbp-3B8h] BYREF
  double v65; // [rsp+198h] [rbp-3B0h]
  double v66; // [rsp+1A0h] [rbp-3A8h]
  __int64 v67; // [rsp+1A8h] [rbp-3A0h]
  __int64 v68; // [rsp+1B0h] [rbp-398h]
  double v69; // [rsp+1B8h] [rbp-390h]
  double v70; // [rsp+1C0h] [rbp-388h]
  __int64 v71; // [rsp+1C8h] [rbp-380h] BYREF
  __int64 v72; // [rsp+1D0h] [rbp-378h]
  __int64 v73; // [rsp+1D8h] [rbp-370h]
  __int64 v74; // [rsp+1E0h] [rbp-368h]
  float src_[3]; // [rsp+1E8h] [rbp-360h] BYREF
  float src__3[3]; // [rsp+1F4h] [rbp-354h] BYREF
  double v77; // [rsp+200h] [rbp-348h]
  __int64 (__fastcall *v78)(__int64, __int64 *); // [rsp+208h] [rbp-340h]
  __int64 v79; // [rsp+210h] [rbp-338h]
  void *Src; // [rsp+218h] [rbp-330h]
  __int64 v81; // [rsp+220h] [rbp-328h]
  __int64 *v82; // [rsp+228h] [rbp-320h]
  __int64 v83; // [rsp+230h] [rbp-318h]
  __int64 v84; // [rsp+238h] [rbp-310h] BYREF
  _QWORD v85[3]; // [rsp+240h] [rbp-308h] BYREF
  _QWORD v86[2]; // [rsp+258h] [rbp-2F0h] BYREF
  void (__fastcall *v87)(__int64, double *, __int64, _QWORD, _BYTE); // [rsp+268h] [rbp-2E0h]
  __int64 (__fastcall *v88)(__int64, _BYTE *, _QWORD); // [rsp+270h] [rbp-2D8h]
  double v89; // [rsp+278h] [rbp-2D0h]
  double v90; // [rsp+280h] [rbp-2C8h]
  double v91; // [rsp+288h] [rbp-2C0h]
  double v92; // [rsp+290h] [rbp-2B8h]
  double v93; // [rsp+298h] [rbp-2B0h]
  __int64 v94; // [rsp+2A0h] [rbp-2A8h]
  __int64 v96; // [rsp+2B0h] [rbp-298h]
  __int64 v97; // [rsp+2B8h] [rbp-290h]
  double v98; // [rsp+2C0h] [rbp-288h]
  double v99; // [rsp+2C8h] [rbp-280h]
  double v100; // [rsp+2D0h] [rbp-278h]
  double v101; // [rsp+2D8h] [rbp-270h]
  __int64 (__fastcall *v102)(__int64, __int64 *); // [rsp+2E0h] [rbp-268h]
  __int64 v103; // [rsp+2E8h] [rbp-260h]
  void *v104; // [rsp+2F0h] [rbp-258h]
  unsigned __int64 v105[10]; // [rsp+2F8h] [rbp-250h] BYREF
  double dst__4[3]; // [rsp+348h] [rbp-200h] BYREF
  double dst__2[3]; // [rsp+360h] [rbp-1E8h] BYREF
  double src__2[3]; // [rsp+378h] [rbp-1D0h] BYREF
  double dst__5[3]; // [rsp+390h] [rbp-1B8h] BYREF
  double dst__6[3]; // [rsp+3A8h] [rbp-1A0h] BYREF
  double v111; // [rsp+3C0h] [rbp-188h]
  double v112; // [rsp+3C8h] [rbp-180h]
  double v113; // [rsp+3D0h] [rbp-178h]
  double v114; // [rsp+3D8h] [rbp-170h]
  double src__1[4]; // [rsp+3E0h] [rbp-168h] BYREF
  int v123; // [rsp+470h] [rbp-D8h] BYREF
  __int64 v124; // [rsp+478h] [rbp-D0h] BYREF
  int v125; // [rsp+480h] [rbp-C8h] BYREF
  double dst__1[3]; // [rsp+488h] [rbp-C0h] BYREF
  __int64 v127; // [rsp+4A0h] [rbp-A8h] BYREF
  _BYTE dst__3[24]; // [rsp+4C0h] [rbp-88h] BYREF
  _BYTE v130[40]; // [rsp+4D8h] [rbp-70h] BYREF
  __int128 v131; // [rsp+500h] [rbp-48h]
  __int128 v132; // [rsp+510h] [rbp-38h]

  v105[0] = *(_QWORD *)(a1 + 8);
  if ( !is_valid_handle_typeB(v105) )
    goto LABEL_44;
  v50[0] = *(_QWORD *)(a1 + 0x3C8);
  if ( is_valid_handle_typeA(v50) )
  {
    v64 = *(_QWORD *)(a1 + 0x2D8);
    if ( AssetMeta::HasActorSubresource(&v64) )
    {
      v105[1] = v64 & 0xFFFFFFFFFFFFLL;
      v51[0] = *(_QWORD *)((v64 & 0xFFFFFFFFFFFFLL) + 8);
      if ( is_valid_handle_typeB(v51) )
      {
        v105[2] = v50[0] & 0xFFFFFFFFFFFFLL;
        v28 = sub_143109950(v50[0] & 0xFFFFFFFFFFFFLL);
        v73 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x20);
        v32 = *(float *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v73 + 0xF0LL))(v73) + 0x228) - 1.0;
        if ( v28 >= 0.0099999998 )
        {
          if ( v28 >= v32 )
            v33 = v32;
          else
            v33 = v28;
          v34 = v33;
        }
        else
        {
          v34 = 0.0099999998;
        }
        v52 = sub_1403103B0(v51);
        v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 0x648LL))(v52);
        *(_QWORD *)(dst + 0x38) = *(_QWORD *)sub_14036BA30(&v123, 0, 0);
        unknown_libname_472(dst__1);
        qmemcpy(dst_, &::src__3, sizeof(dst_));
        v105[9] = v50[0] & 0xFFFFFFFFFFFFLL;
        sub_143103900(v50[0] & 0xFFFFFFFFFFFFLL, 1u, 2, dst__1, dst_);
        v53 = dst_[0] * dst_[0] + dst_[1] * dst_[1] + dst_[2] * dst_[2];
        if ( v53 <= 0.0 )
        {
          qmemcpy(dst_, &src__4, sizeof(dst_));
        }
        else
        {
          __asm
          {
            vmovddup xmm0, [rsp+548h+var_410]
            vmovupd [rsp+548h+var_148], xmm0
            vmovupd xmm0, [rsp+548h+var_148]
            vmovupd [rsp+548h+var_138], xmm0
            vsqrtpd xmm0, [rsp+548h+var_138]
            vmovupd [rsp+548h+var_128], xmm0
            vmovupd xmm0, [rsp+548h+var_128]
            vmovupd [rsp+548h+var_118], xmm0
            vmovupd xmm0, [rsp+548h+var_118]
            vmovupd [rsp+548h+var_48], xmm0
          }
          v77 = *((double *)&v131 + 1);
          *(double *)&v50[1] = 1.0 / *((double *)&v131 + 1);
          dst_[0] = dst_[0] * (1.0 / *((double *)&v131 + 1));
          dst_[1] = dst_[1] * (1.0 / *((double *)&v131 + 1));
          dst_[2] = dst_[2] * (1.0 / *((double *)&v131 + 1));
        }
        *(_QWORD *)(dst + 0x28) = 0x40F;
        *(_BYTE *)(dst + 0x34) = 0;
        *(_BYTE *)(dst + 0xA0) = 1;
        *(_QWORD *)(dst + 0xB0) = "CSCItemMiningController::OnVehicleRaycastSubmit";
        *(_DWORD *)(dst + 0x30) = 0x11F;
        v78 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v54 + 0x18LL);
        v8 = (__int64 *)v78(v54, &v55);
        sub_140469AA0((__int64 *)(dst + 0xA8), v8);
        v79 = 0;
        if ( v55 )
          sub_140524440(v55);
        qmemcpy((void *)dst, dst__1, 0x18u);
        *(double *)&v50[2] = v34;
        qmemcpy(dst__2, dst_, sizeof(dst__2));
        *(double *)&v105[3] = dst__2[0] * v34;
        *(double *)&v105[4] = dst__2[1] * v34;
        _XMM0 = COERCE_UNSIGNED_INT64(dst__2[2] * v34);
        *(double *)&v105[5] = dst__2[2] * v34;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_238] }
        src_[0] = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_230] }
        src_[1] = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_228] }
        src_[2] = *(float *)&_XMM0;
        qmemcpy((void *)(dst + 0x18), src_, 0xCu);
        Src = (void *)(dst + 0x40);
        v56 = sub_1403103B0(v51);
        v13 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v56 + 0x3D0LL))(v56);
        sub_14132EBA0((char *)Src, v13);
        return 1;
      }
    }
  }
  if ( !is_valid_handle_typeA((__int64 *)(a1 + 0x318)) )
    goto LABEL_44;
  v57 = *(_QWORD *)(a1 + 0x2F8);
  if ( Handle::IsValid(&v57) )
  {
    v81 = v57 & 0xFFFFFFFFFFFFLL;
    v58 = sub_1439E7780(v57 & 0xFFFFFFFFFFFFLL);
  }
  else
  {
    v58 = 0;
  }
  v59 = v58;
  if ( v58 )
  {
    v82 = sub_142745650(v59, &v127);
    v83 = *v82;
    v84 = v83;
    v60 = &v84;
  }
  else
  {
    v85[0] = 0;
    v60 = v85;
  }
  v85[1] = v60;
  v40 = *v60;
  if ( is_valid_handle_typeA(&v40) )
  {
    v85[2] = v40 & 0xFFFFFFFFFFFFLL;
    v86[0] = *(_QWORD *)((v40 & 0xFFFFFFFFFFFFLL) + 8);
    v61 = v86;
  }
  else
  {
    sub_1402B3A40(&v124);
    v61 = v15;
  }
  v86[1] = v61;
  v41[0] = *v61;
  if ( !is_valid_handle_typeA(&v40) || !is_valid_handle_typeB(v41) )
  {
LABEL_44:
    *(_DWORD *)(a1 + 0x3D0) = 0;
    return 0;
  }
  v62 = sub_1403103B0(v41);
  v87 = *(void (__fastcall **)(__int64, double *, __int64, _QWORD, _BYTE))(*(_QWORD *)v62 + 0x1E8LL);
  v87(v62, &v42, 2, 0, 0);
  v63 = v40 & 0xFFFFFFFFFFFFLL;
  v88 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)(v40 & 0xFFFFFFFFFFFFLL) + 0x5D8LL);
  v27 = (float *)v88(v40 & 0xFFFFFFFFFFFFLL, v130, 0);
  v89 = v43 * v27[2] - v44 * v27[1] + v45 * *v27 + v42 * v27[3];
  v90 = v44 * *v27 - v42 * v27[2] + v45 * v27[1] + v43 * v27[3];
  v91 = v42 * v27[1] - v43 * *v27 + v45 * v27[2] + v44 * v27[3];
  v92 = v45 * v27[3] - v42 * *v27 - v43 * v27[1] - v44 * v27[2];
  v66 = v43 * v27[6] - v44 * v27[5] + v45 * v27[4];
  v65 = v44 * v27[4] - v42 * v27[6] + v45 * v27[5];
  v70 = v42 * v27[5] - v43 * v27[4] + v45 * v27[6];
  v29 = (v70 * v43 - v65 * v44 + v70 * v43 - v65 * v44 + v27[4]) * v49 + v46;
  v30 = (v66 * v44 - v70 * v42 + v66 * v44 - v70 * v42 + v27[5]) * v49 + v47;
  v31 = (v65 * v42 - v66 * v43 + v65 * v42 - v66 * v43 + v27[6]) * v49 + v48;
  v93 = v49;
  v111 = v89;
  v112 = v90;
  v113 = v91;
  v114 = v92;
  src__1[0] = v29;
  src__1[1] = v30;
  src__1[2] = v31;
  src__1[3] = v49;
  v67 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x20);
  v36 = *(float *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v67 + 0xF0LL))(v67) + 0x228) - 1.0;
  v94 = sub_140334DC0(a1);
  if ( *(_QWORD *)(v94 + 0x50) )
  {
    v96 = sub_140334DC0(a1);
    v97 = *(_QWORD *)(v96 + 0x50);
    v35 = *(float *)(v97 + 0xE8);
  }
  else
  {
    v35 = 1500.0;
  }
  if ( v35 >= 0.0099999998 )
  {
    if ( v35 >= v36 )
      v37 = v36;
    else
      v37 = v35;
    v38 = v37;
  }
  else
  {
    v38 = 0.0099999998;
  }
  v68 = sub_1403103B0(v41);
  v74 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v68 + 0x648LL))(v68);
  qmemcpy(dst__3, src__1, sizeof(dst__3));
  v100 = 2.0 * (v113 * v112 + v111 * v114);
  v99 = 2.0 * (v112 * v112 + v114 * v114) - 1.0;
  v98 = 2.0 * (v111 * v112 - v113 * v114);
  src__2[0] = v98;
  src__2[1] = v99;
  src__2[2] = v100;
  v69 = src__2[0] * src__2[0] + src__2[1] * src__2[1] + src__2[2] * src__2[2];
  if ( v69 <= 0.0 )
  {
    qmemcpy(dst__4, &src__0, sizeof(dst__4));
  }
  else
  {
    __asm
    {
      vmovddup xmm0, [rsp+548h+var_390]
      vmovupd [rsp+548h+var_108], xmm0
      vmovupd xmm0, [rsp+548h+var_108]
      vmovupd [rsp+548h+var_F8], xmm0
      vsqrtpd xmm0, [rsp+548h+var_F8]
      vmovupd [rsp+548h+var_E8], xmm0
      vmovupd xmm0, [rsp+548h+var_E8]
      vmovupd [rsp+548h+var_98], xmm0
      vmovupd xmm0, [rsp+548h+var_98]
      vmovupd [rsp+548h+var_38], xmm0
    }
    v101 = *((double *)&v132 + 1);
    *(double *)&v51[1] = 1.0 / *((double *)&v132 + 1);
    qmemcpy(dst__5, src__2, sizeof(dst__5));
    dst__4[0] = dst__5[0] * (1.0 / *((double *)&v132 + 1));
    dst__4[1] = dst__5[1] * (1.0 / *((double *)&v132 + 1));
    dst__4[2] = dst__5[2] * (1.0 / *((double *)&v132 + 1));
  }
  *(_QWORD *)(dst + 0x38) = *(_QWORD *)sub_14036BA30(&v125, 0, 0);
  *(_QWORD *)(dst + 0x28) = 0x40F;
  *(_BYTE *)(dst + 0x34) = 0;
  *(_BYTE *)(dst + 0xA0) = 1;
  *(_QWORD *)(dst + 0xB0) = "CSCItemMiningController::OnVehicleRaycastSubmit";
  *(_DWORD *)(dst + 0x30) = 0x11F;
  v102 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v74 + 0x18LL);
  v21 = (__int64 *)v102(v74, &v71);
  sub_140469AA0((__int64 *)(dst + 0xA8), v21);
  v103 = 0;
  if ( v71 )
    sub_140524440(v71);
  qmemcpy((void *)dst, dst__3, 0x18u);
  *(double *)&v51[2] = v38;
  qmemcpy(dst__6, dst__4, sizeof(dst__6));
  *(double *)&v105[6] = dst__6[0] * v38;
  *(double *)&v105[7] = dst__6[1] * v38;
  _XMM0 = COERCE_UNSIGNED_INT64(dst__6[2] * v38);
  *(double *)&v105[8] = dst__6[2] * v38;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_220] }
  src__3[0] = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_218] }
  src__3[1] = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_210] }
  src__3[2] = *(float *)&_XMM0;
  qmemcpy((void *)(dst + 0x18), src__3, 0xCu);
  v104 = (void *)(dst + 0x40);
  v72 = sub_1403103B0(v41);
  v26 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v72 + 0x3D0LL))(v72);
  sub_14132EBA0((char *)v104, v26);
  return 1;
}

// --- End Function: sub_146088B90 (0x146088B90) ---

// --- Function: sub_1460A4E40 (0x1460A4E40) ---
__int64 __fastcall sub_1460A4E40(__int64 a1)
{
  __int128 v1; // xmm0
  __int128 v2; // kr00_16
  const char *v3; // rax
  float v5; // kr00_4
  float v6; // kr00_4
  __int64 v7; // rax
  __int64 v8; // rax
  int v11; // edx
  int v12; // r8d
  int v13; // r9d
  _BYTE v14[4]; // [rsp+40h] [rbp-308h] BYREF
  BOOL v15; // [rsp+44h] [rbp-304h]
  BOOL v16; // [rsp+48h] [rbp-300h]
  __int64 v17; // [rsp+50h] [rbp-2F8h]
  char *src; // [rsp+58h] [rbp-2F0h]
  __int64 v19; // [rsp+60h] [rbp-2E8h]
  float v20[4]; // [rsp+68h] [rbp-2E0h] BYREF
  char *src_2; // [rsp+78h] [rbp-2D0h]
  __int64 v22; // [rsp+80h] [rbp-2C8h]
  __int64 v23; // [rsp+88h] [rbp-2C0h]
  unsigned __int64 v24; // [rsp+90h] [rbp-2B8h] BYREF
  const void *v25; // [rsp+98h] [rbp-2B0h] BYREF
  const void *v26[5]; // [rsp+A0h] [rbp-2A8h] BYREF
  __int64 v27; // [rsp+C8h] [rbp-280h]
  __int64 v28; // [rsp+D0h] [rbp-278h] BYREF
  __int64 v29[2]; // [rsp+D8h] [rbp-270h] BYREF
  __int64 v30; // [rsp+E8h] [rbp-260h]
  __int64 v31; // [rsp+F0h] [rbp-258h]
  __int64 v32; // [rsp+F8h] [rbp-250h] BYREF
  __int64 v33; // [rsp+100h] [rbp-248h]
  __int64 v34; // [rsp+108h] [rbp-240h]
  _BYTE *v35; // [rsp+110h] [rbp-238h]
  __int64 v36; // [rsp+118h] [rbp-230h]
  __int64 v37; // [rsp+120h] [rbp-228h] BYREF
  _BYTE v38[16]; // [rsp+128h] [rbp-220h] BYREF
  __int64 v39; // [rsp+138h] [rbp-210h]
  char *src_3; // [rsp+140h] [rbp-208h]
  char *src_4; // [rsp+148h] [rbp-200h]
  __int64 v42; // [rsp+150h] [rbp-1F8h]
  __int64 v43; // [rsp+158h] [rbp-1F0h]
  struct __crt_stdio_stream *v44; // [rsp+160h] [rbp-1E8h]
  _QWORD v45[4]; // [rsp+168h] [rbp-1E0h] BYREF
  struct __crt_stdio_stream *v46; // [rsp+188h] [rbp-1C0h]
  _QWORD v47[2]; // [rsp+190h] [rbp-1B8h] BYREF
  char *src_5; // [rsp+1A0h] [rbp-1A8h]
  __int64 v49; // [rsp+1A8h] [rbp-1A0h]
  __int64 v50; // [rsp+1B0h] [rbp-198h]
  __int64 v51; // [rsp+1B8h] [rbp-190h]
  __int64 v52; // [rsp+1C0h] [rbp-188h]
  struct __crt_stdio_stream *v53; // [rsp+1C8h] [rbp-180h]
  _QWORD v54[2]; // [rsp+1D0h] [rbp-178h] BYREF
  void **StringObjectFromString; // [rsp+1E0h] [rbp-168h]
  __int64 v56; // [rsp+1E8h] [rbp-160h]
  __int64 v57; // [rsp+1F0h] [rbp-158h] BYREF
  void *v58[3]; // [rsp+1F8h] [rbp-150h] BYREF
  __int64 v59; // [rsp+210h] [rbp-138h] BYREF
  void (__fastcall *v60)(__int64, unsigned __int64 *); // [rsp+218h] [rbp-130h]
  __int64 v61; // [rsp+220h] [rbp-128h]
  __int64 *v62; // [rsp+228h] [rbp-120h]
  __int64 v63; // [rsp+230h] [rbp-118h]
  _QWORD v64[4]; // [rsp+238h] [rbp-110h] BYREF
  __int64 (__fastcall *v65)(__int64, _QWORD); // [rsp+258h] [rbp-F0h]
  _QWORD *v66; // [rsp+260h] [rbp-E8h]
  _QWORD *v67; // [rsp+268h] [rbp-E0h]
  __int64 v68; // [rsp+270h] [rbp-D8h]
  void *v69; // [rsp+278h] [rbp-D0h]
  void *v70; // [rsp+280h] [rbp-C8h]
  int v71[2]; // [rsp+288h] [rbp-C0h]
  char *src_1; // [rsp+290h] [rbp-B8h]
  __int64 v73; // [rsp+298h] [rbp-B0h] BYREF
  char v74; // [rsp+2A0h] [rbp-A8h]
  __int64 v75; // [rsp+2A8h] [rbp-A0h]
  _BYTE v76[8]; // [rsp+2B0h] [rbp-98h] BYREF
  void *v77; // [rsp+2B8h] [rbp-90h] BYREF
  void *v78; // [rsp+2C0h] [rbp-88h] BYREF
  __int64 v79; // [rsp+2C8h] [rbp-80h] BYREF
  _BYTE v80[16]; // [rsp+2D0h] [rbp-78h] BYREF
  __int128 dst_; // [rsp+2E0h] [rbp-68h] BYREF
  __int64 v82; // [rsp+2F0h] [rbp-58h]
  char v83; // [rsp+2F8h] [rbp-50h]
  _BYTE v84[16]; // [rsp+300h] [rbp-48h] BYREF
  __int128 v85; // [rsp+310h] [rbp-38h] BYREF
  __int64 v86; // [rsp+320h] [rbp-28h]

  sub_142A9D4D0(v38);
  v22 = 0;
  v19 = 0;
  v26[1] = (const void *)(a1 + 0x758);
  src = *(char **)(a1 + 0x758);
  src_1 = *(char **)(a1 + 0x760);
  while ( src != src_1 )
  {
    src_2 = src;
    qmemcpy(&dst_, src, sizeof(dst_));
    sub_14035D760(&v85, &dst_);
    v86 = sub_1404C80A0(&v85);
    v39 = v86;
    v15 = v86 != 0;
    if ( v86 )
    {
      v17 = *((_QWORD *)src_2 + 2);
      v22 += v17;
      src_3 = src_2;
      src_4 = src_2;
      src_5 = src_2;
      v42 = a1 + 0x770;
      v26[2] = (const void *)(a1 + 0x770);
      v43 = a1 + 0x770;
      v44 = *(struct __crt_stdio_stream **)(a1 + 0x778);
      _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v45,
        v44);
      v45[1] = v45[0];
      v49 = v45[0];
      v45[2] = a1 + 0x770;
      v26[3] = (const void *)(a1 + 0x770);
      v45[3] = a1 + 0x770;
      v46 = *(struct __crt_stdio_stream **)(a1 + 0x770);
      _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v47,
        v46);
      v47[1] = v47[0];
      v50 = v47[0];
      v27 = *(_QWORD *)sub_1460035C0(v80, v47[0], v49, src_5);
      v51 = a1 + 0x770;
      v26[4] = (const void *)(a1 + 0x770);
      v52 = a1 + 0x770;
      v53 = *(struct __crt_stdio_stream **)(a1 + 0x778);
      _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v54,
        v53);
      v16 = v27 == v54[0];
      if ( v27 != v54[0] )
      {
        v54[1] = v27;
        v17 -= *(_QWORD *)(v27 + 0x10);
      }
      v19 += v17;
      v2 = v1;
      *(float *)&v2 = (float)v17;
      *(float *)&v2 = *(float *)&v2 / 1000000.0;
      v1 = v2;
      v20[0] = *(float *)&v2;
      v75 = v86;
      v3 = (const char *)sub_1404F7870();
      StringObjectFromString = CreateStringObjectFromString(v58, v3);
      sub_145FE6B20(v38, &v73, StringObjectFromString, v20);
      v56 = v73;
      std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
        &v57,
        v73,
        v38);
      v82 = v57;
      v83 = v74;
      sub_1403727A0(v58);
    }
    src += 0x18;
  }
  if ( v19 <= 0 )
    return sub_143B5FC10(v38);
  v5 = (float)(*(_QWORD *)(a1 + 0x788) - v22);
  v20[1] = v5 / 1000000.0;
  v6 = (float)v19;
  v20[2] = v6 / 1000000.0;
  v37 = 0;
  sub_14035CC10(v26);
  v28 = *(_QWORD *)(a1 + 0x2F8);
  if ( Handle::IsValid(&v28) )
  {
    v58[1] = (void *)(v28 & 0xFFFFFFFFFFFFLL);
    v23 = sub_1439E7780(v28 & 0xFFFFFFFFFFFFLL);
    if ( v23 )
    {
      v58[2] = (void *)(v23 + 8);
      sub_1403B29B0((unsigned __int64 *)(v23 + 8), &v59);
      v37 = v59;
      sub_1427489C0(v23, v29);
      if ( is_valid_handle_typeA(v29) )
      {
        v29[1] = v29[0] & 0xFFFFFFFFFFFFLL;
        v60 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)(v29[0] & 0xFFFFFFFFFFFFLL) + 0x618LL);
        v60(v29[0] & 0xFFFFFFFFFFFFLL, &v24);
        if ( is_valid_handle_typeB(&v24) )
        {
          v61 = sub_1403103B0(&v24);
          v62 = (__int64 *)sub_142689020(v61, v76);
          v63 = *v62;
          v64[0] = v63;
          if ( Handle::IsValid(v64) )
          {
            v30 = sub_1403103B0(&v24);
            v31 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x20LL))(v30);
            v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x18LL))(v31);
            assignCStringToStringStructure((__int64)v26, v7);
          }
        }
      }
    }
  }
  sub_14035CC10(&v25);
  sub_14605C150(a1, &v32);
  if ( AssetMeta::HasActorSubresource(&v32) )
  {
    v64[1] = v32 & 0xFFFFFFFFFFFFLL;
    v33 = sub_1403E7D30((unsigned __int64 *)((v32 & 0xFFFFFFFFFFFFLL) + 8));
    v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v33 + 0x20LL))(v33);
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x18LL))(v34);
    assignCStringToStringStructure((__int64)&v25, v8);
  }
  *(_QWORD *)v71 = sub_144868AC0();
  v35 = v84;
  sub_143A65130(v84, v38, v14);
  v68 = (__int64)v35;
  v64[2] = &v77;
  v69 = sub_14035C990(&v77, v26);
  v64[3] = &v78;
  v70 = sub_14035C990(&v78, &v25);
  v36 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x60);
  v65 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v36 + 0x38LL);
  v66 = (_QWORD *)v65(v36, 0);
  v67 = sub_140598C00(v66, &v79, (_QWORD *)(a1 + 0x750));
  _XMM0 = sub_140598DA0();
  __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
  v20[3] = *(float *)&_XMM0;
  sub_144895310(v71[0], v11, v12, v13, v70, v69, (__int64)&v37, v68);
  sub_1403727A0(&v25);
  sub_1403727A0(v26);
  return sub_143B5FC10(v38);
}

// --- End Function: sub_1460A4E40 (0x1460A4E40) ---

// --- Function: sub_1460ABB70 (0x1460ABB70) ---
__int64 __fastcall sub_1460ABB70(__int64 a1)
{
  __int64 result; // rax
  char v2; // [rsp+20h] [rbp-98h] BYREF
  char v3; // [rsp+21h] [rbp-97h] BYREF
  char v4; // [rsp+22h] [rbp-96h] BYREF
  _BYTE v5[5]; // [rsp+23h] [rbp-95h] BYREF
  __int64 v6; // [rsp+28h] [rbp-90h] BYREF
  __int64 v7; // [rsp+30h] [rbp-88h]
  __int64 v8; // [rsp+38h] [rbp-80h] BYREF
  __int64 v9; // [rsp+40h] [rbp-78h]
  __int64 v10; // [rsp+48h] [rbp-70h] BYREF
  __int64 v11; // [rsp+50h] [rbp-68h] BYREF
  __int64 v12; // [rsp+58h] [rbp-60h]
  __int64 v13; // [rsp+60h] [rbp-58h] BYREF
  __int64 v14; // [rsp+68h] [rbp-50h]
  __int64 v15; // [rsp+70h] [rbp-48h]
  __int64 v16; // [rsp+78h] [rbp-40h]
  __int64 v17; // [rsp+80h] [rbp-38h]
  __int64 v18; // [rsp+88h] [rbp-30h]
  __int64 v19; // [rsp+90h] [rbp-28h]
  __int64 v20; // [rsp+98h] [rbp-20h]
  __int64 v21; // [rsp+A0h] [rbp-18h]
  __int64 v22; // [rsp+A8h] [rbp-10h]

  if ( AssetMeta::HasActorSubresource((__int64 *)(a1 + 0x2D8)) || is_valid_handle_typeA((__int64 *)(a1 + 0x318)) )
  {
    v6 = *(_QWORD *)(a1 + 0x2C8);
    if ( is_valid_handle_typeA(&v6) )
    {
      v14 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
      v7 = v21;
      if ( is_valid_handle_typeA(&v6) )
        v7 = v6 & 0xFFFFFFFFFFFFLL;
      else
        v7 = 0;
      sub_144DDF510(v14, v7, (__int64)&v4);
    }
    v8 = *(_QWORD *)(a1 + 0x2C0);
    if ( Handle::IsValid(&v8) )
    {
      v15 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
      v9 = v22;
      if ( Handle::IsValid(&v8) )
        v9 = v8 & 0xFFFFFFFFFFFFLL;
      else
        v9 = 0;
      sub_144DDF510(v15, v9, (__int64)v5);
    }
    v10 = *(_QWORD *)(a1 + 0x2F8);
    if ( Handle::IsValid(&v10) )
    {
      v16 = v10 & 0xFFFFFFFFFFFFLL;
      if ( sub_1439F0470(v10 & 0xFFFFFFFFFFFFLL) )
      {
        v17 = a1 + 0x1C0;
        sub_144297F80(a1 + 0x1C0, 0.0);
      }
    }
    v2 = 0;
    sub_14154B820(a1 + 0x9F0, &v2);
    result = *(unsigned __int8 *)(a1 + 0x748);
    if ( *(_BYTE *)(a1 + 0x748) )
      return sub_1460AEB10(a1, 0);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 0x2F8);
    result = Handle::IsValid(&v11);
    if ( (_BYTE)result )
    {
      v18 = v11 & 0xFFFFFFFFFFFFLL;
      result = sub_1439E7780(v11 & 0xFFFFFFFFFFFFLL);
      v12 = result;
      if ( result )
      {
        sub_1427489C0(v12, &v13);
        result = is_valid_handle_typeA(&v13);
        if ( (_BYTE)result )
        {
          v19 = v13 & 0xFFFFFFFFFFFFLL;
          v20 = sub_14654B900(v13 & 0xFFFFFFFFFFFFLL);
          v3 = 1;
          return sub_145FDD880(v20, (__int64)&v3);
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1460ABB70 (0x1460ABB70) ---

// --- Function: sub_1460AEB10 (0x1460AEB10) ---
__int64 *__fastcall sub_1460AEB10(__int64 a1, char a2)
{
  __int64 v2; // rax
  __int64 *result; // rax

  if ( a2 )
  {
    *(_BYTE *)(a1 + 0x748) = 1;
    v2 = sub_1402A4B80((__int64)&qword_149A141F0);
    result = *(__int64 **)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 0x60) + 0x38LL))(
                            *(_QWORD *)(v2 + 0x60),
                            0);
    *(_QWORD *)(a1 + 0x750) = result;
  }
  else
  {
    sub_1460A4E40(a1);
    *(_BYTE *)(a1 + 0x748) = 0;
    return sub_140469D50((__int64 *)(a1 + 0x770), (__int64 *)(a1 + 0x758));
  }
  return result;
}

// --- End Function: sub_1460AEB10 (0x1460AEB10) ---

// --- Function: sub_1460B14E0 (0x1460B14E0) ---
__int64 __fastcall sub_1460B14E0(__int64 a1)
{
  int v1; // edx
  unsigned __int64 *v2; // rax
  double v23; // xmm0_8
  double v24; // xmm0_8
  __int64 v25; // r9
  unsigned __int16 *v26; // rax
  _QWORD *v27; // rax
  _QWORD *v30; // rax
  int v32; // [rsp+20h] [rbp-AF8h]
  float *v33; // [rsp+30h] [rbp-AE8h]
  char v34; // [rsp+39h] [rbp-ADFh]
  char v35; // [rsp+3Bh] [rbp-ADDh] BYREF
  char v36; // [rsp+3Ch] [rbp-ADCh] BYREF
  char v37; // [rsp+3Dh] [rbp-ADBh] BYREF
  char v38; // [rsp+3Eh] [rbp-ADAh] BYREF
  char v39; // [rsp+3Fh] [rbp-AD9h] BYREF
  double *v40; // [rsp+40h] [rbp-AD8h]
  double *v41; // [rsp+48h] [rbp-AD0h]
  double *v42; // [rsp+50h] [rbp-AC8h]
  double *v43; // [rsp+58h] [rbp-AC0h]
  float dst__4[3]; // [rsp+60h] [rbp-AB8h] BYREF
  double v45; // [rsp+70h] [rbp-AA8h]
  double v46; // [rsp+78h] [rbp-AA0h]
  double v47; // [rsp+80h] [rbp-A98h]
  float v48; // [rsp+88h] [rbp-A90h]
  float v49; // [rsp+8Ch] [rbp-A8Ch]
  float v50; // [rsp+90h] [rbp-A88h]
  float v51; // [rsp+94h] [rbp-A84h]
  float v52; // [rsp+98h] [rbp-A80h]
  float v53; // [rsp+A0h] [rbp-A78h]
  float v54; // [rsp+A8h] [rbp-A70h]
  float v55; // [rsp+ACh] [rbp-A6Ch]
  float v56; // [rsp+B0h] [rbp-A68h]
  float X_3; // [rsp+B4h] [rbp-A64h]
  float *src; // [rsp+B8h] [rbp-A60h]
  char v59; // [rsp+C0h] [rbp-A58h]
  float *src_1; // [rsp+C8h] [rbp-A50h]
  double *src_2; // [rsp+D0h] [rbp-A48h]
  float *src_3; // [rsp+D8h] [rbp-A40h]
  float v63; // [rsp+E0h] [rbp-A38h]
  float dst__8[3]; // [rsp+E8h] [rbp-A30h] BYREF
  float dst__2[3]; // [rsp+F8h] [rbp-A20h] BYREF
  float X_1; // [rsp+108h] [rbp-A10h]
  BOOL v67; // [rsp+10Ch] [rbp-A0Ch]
  unsigned __int32 v68; // [rsp+110h] [rbp-A08h]
  BOOL v69; // [rsp+114h] [rbp-A04h]
  BOOL v70; // [rsp+118h] [rbp-A00h]
  BOOL v71; // [rsp+11Ch] [rbp-9FCh]
  unsigned int v72; // [rsp+120h] [rbp-9F8h]
  float v73; // [rsp+124h] [rbp-9F4h]
  BOOL v75; // [rsp+12Ch] [rbp-9ECh]
  __int64 v76; // [rsp+130h] [rbp-9E8h] BYREF
  float X; // [rsp+138h] [rbp-9E0h]
  double v78; // [rsp+140h] [rbp-9D8h] BYREF
  double v79; // [rsp+148h] [rbp-9D0h]
  double v80; // [rsp+150h] [rbp-9C8h]
  double v81; // [rsp+158h] [rbp-9C0h]
  double v82; // [rsp+160h] [rbp-9B8h]
  double v83; // [rsp+168h] [rbp-9B0h]
  double v84; // [rsp+170h] [rbp-9A8h]
  double v85; // [rsp+178h] [rbp-9A0h]
  __int64 v86; // [rsp+180h] [rbp-998h] BYREF
  __int64 v87; // [rsp+188h] [rbp-990h]
  _QWORD *v88; // [rsp+190h] [rbp-988h]
  double *dst_1; // [rsp+198h] [rbp-980h]
  float v90; // [rsp+1A0h] [rbp-978h]
  float v91; // [rsp+1A4h] [rbp-974h] BYREF
  float v92; // [rsp+1A8h] [rbp-970h] BYREF
  float v93[2]; // [rsp+1ACh] [rbp-96Ch] BYREF
  float v94; // [rsp+1B4h] [rbp-964h]
  unsigned int v95; // [rsp+1B8h] [rbp-960h] BYREF
  char v96[4]; // [rsp+1BCh] [rbp-95Ch] BYREF
  int n2; // [rsp+1C0h] [rbp-958h] BYREF
  float v98; // [rsp+1C8h] [rbp-950h]
  float v99; // [rsp+1D0h] [rbp-948h]
  float v100; // [rsp+1D4h] [rbp-944h]
  float v101; // [rsp+1D8h] [rbp-940h]
  float v102; // [rsp+1E0h] [rbp-938h]
  float v103; // [rsp+1E8h] [rbp-930h]
  double v104; // [rsp+1F0h] [rbp-928h]
  double *v105; // [rsp+1F8h] [rbp-920h]
  __int64 v106; // [rsp+200h] [rbp-918h]
  __int64 v107; // [rsp+208h] [rbp-910h] BYREF
  __int64 v108; // [rsp+210h] [rbp-908h] BYREF
  unsigned __int64 v109; // [rsp+218h] [rbp-900h] BYREF
  float v110; // [rsp+220h] [rbp-8F8h]
  float v111; // [rsp+228h] [rbp-8F0h]
  float v112; // [rsp+230h] [rbp-8E8h]
  float X_2; // [rsp+238h] [rbp-8E0h]
  float v114; // [rsp+240h] [rbp-8D8h]
  float v115; // [rsp+244h] [rbp-8D4h]
  float v116; // [rsp+248h] [rbp-8D0h]
  float v117; // [rsp+250h] [rbp-8C8h]
  float v118; // [rsp+254h] [rbp-8C4h]
  float v119; // [rsp+258h] [rbp-8C0h]
  __int64 v120; // [rsp+260h] [rbp-8B8h]
  __int64 v121; // [rsp+268h] [rbp-8B0h]
  double v122; // [rsp+270h] [rbp-8A8h]
  double v123; // [rsp+278h] [rbp-8A0h]
  double v124; // [rsp+280h] [rbp-898h]
  double v125; // [rsp+288h] [rbp-890h]
  __int64 v126; // [rsp+290h] [rbp-888h] BYREF
  __int64 v127; // [rsp+298h] [rbp-880h] BYREF
  __int64 v128; // [rsp+2A0h] [rbp-878h]
  __int64 v129; // [rsp+2A8h] [rbp-870h]
  __int64 v130; // [rsp+2B0h] [rbp-868h]
  __int64 v131; // [rsp+2B8h] [rbp-860h]
  __int64 v132; // [rsp+2C0h] [rbp-858h]
  __int64 v133; // [rsp+2C8h] [rbp-850h]
  __int64 v134; // [rsp+2D0h] [rbp-848h] BYREF
  __int64 v135; // [rsp+2D8h] [rbp-840h]
  __int64 v136; // [rsp+2E0h] [rbp-838h]
  __int64 v137; // [rsp+2E8h] [rbp-830h]
  __int64 v138; // [rsp+2F0h] [rbp-828h]
  __int64 v139; // [rsp+2F8h] [rbp-820h]
  __int64 v140; // [rsp+300h] [rbp-818h]
  __int64 v141; // [rsp+308h] [rbp-810h]
  __int64 v142; // [rsp+310h] [rbp-808h]
  __int64 v143; // [rsp+318h] [rbp-800h]
  __int64 v144; // [rsp+320h] [rbp-7F8h]
  __int64 v145; // [rsp+328h] [rbp-7F0h]
  __int64 v146; // [rsp+330h] [rbp-7E8h]
  __int64 v147; // [rsp+338h] [rbp-7E0h]
  __int64 *v148; // [rsp+340h] [rbp-7D8h]
  unsigned __int64 *v149; // [rsp+348h] [rbp-7D0h]
  unsigned __int64 v150; // [rsp+350h] [rbp-7C8h] BYREF
  __int64 v151; // [rsp+358h] [rbp-7C0h]
  float dst__3[3]; // [rsp+360h] [rbp-7B8h] BYREF
  float v153; // [rsp+370h] [rbp-7A8h] BYREF
  float v154; // [rsp+374h] [rbp-7A4h]
  float v155; // [rsp+378h] [rbp-7A0h]
  float dst__5[3]; // [rsp+380h] [rbp-798h] BYREF
  float v157; // [rsp+390h] [rbp-788h] BYREF
  float v158; // [rsp+394h] [rbp-784h]
  float v159; // [rsp+398h] [rbp-780h]
  float dst__9[3]; // [rsp+3A0h] [rbp-778h] BYREF
  float v161; // [rsp+3B0h] [rbp-768h] BYREF
  float v162; // [rsp+3B4h] [rbp-764h]
  float v163; // [rsp+3B8h] [rbp-760h]
  _QWORD v164[2]; // [rsp+3C0h] [rbp-758h] BYREF
  void (__fastcall *v165)(__int64, double *, __int64, _QWORD, int); // [rsp+3D0h] [rbp-748h]
  __int64 (__fastcall *v166)(__int64, char *, _QWORD); // [rsp+3D8h] [rbp-740h]
  double v167; // [rsp+3E0h] [rbp-738h]
  double v168; // [rsp+3E8h] [rbp-730h]
  double v169; // [rsp+3F0h] [rbp-728h]
  double v170; // [rsp+3F8h] [rbp-720h]
  double v171; // [rsp+400h] [rbp-718h]
  double v172; // [rsp+408h] [rbp-710h]
  double v173; // [rsp+410h] [rbp-708h]
  double v174; // [rsp+418h] [rbp-700h]
  double v175; // [rsp+420h] [rbp-6F8h]
  double v176; // [rsp+428h] [rbp-6F0h]
  double v177; // [rsp+430h] [rbp-6E8h]
  double v178; // [rsp+438h] [rbp-6E0h]
  double v179; // [rsp+440h] [rbp-6D8h]
  double v180; // [rsp+448h] [rbp-6D0h]
  double v181; // [rsp+450h] [rbp-6C8h]
  double v182; // [rsp+458h] [rbp-6C0h]
  double v183; // [rsp+460h] [rbp-6B8h]
  double v184; // [rsp+468h] [rbp-6B0h]
  __int64 v185; // [rsp+470h] [rbp-6A8h]
  __int64 v186; // [rsp+478h] [rbp-6A0h]
  __int64 v187; // [rsp+480h] [rbp-698h]
  _QWORD v188[3]; // [rsp+488h] [rbp-690h] BYREF
  void (__fastcall *v189)(__int64, __int64, _QWORD, _QWORD); // [rsp+4A0h] [rbp-678h]
  __int64 v190; // [rsp+4A8h] [rbp-670h]
  __int64 v191; // [rsp+4B0h] [rbp-668h]
  void (__fastcall *v192)(__int64, __int64, _QWORD, _QWORD); // [rsp+4B8h] [rbp-660h]
  __int64 v193; // [rsp+4C0h] [rbp-658h]
  __int64 v194; // [rsp+4C8h] [rbp-650h]
  _QWORD *v195; // [rsp+4D0h] [rbp-648h]
  __int64 v196; // [rsp+4D8h] [rbp-640h]
  void (__fastcall *v197)(__int64, unsigned __int64 *, __int64); // [rsp+4E0h] [rbp-638h]
  __int64 v198; // [rsp+4E8h] [rbp-630h]
  __int64 *v199; // [rsp+4F0h] [rbp-628h]
  __int64 v200; // [rsp+4F8h] [rbp-620h]
  __int64 v201; // [rsp+500h] [rbp-618h]
  __int64 v202; // [rsp+508h] [rbp-610h]
  unsigned __int8 (__fastcall *v203)(__int64, __int64, __int64); // [rsp+510h] [rbp-608h]
  __int64 v204; // [rsp+518h] [rbp-600h]
  char *v205; // [rsp+520h] [rbp-5F8h]
  _QWORD v206[5]; // [rsp+528h] [rbp-5F0h] BYREF
  __int64 v207; // [rsp+550h] [rbp-5C8h]
  __int64 v208; // [rsp+558h] [rbp-5C0h]
  __int64 v209; // [rsp+560h] [rbp-5B8h]
  __int64 v210; // [rsp+568h] [rbp-5B0h]
  __int64 (__fastcall *v211)(__int64, char *); // [rsp+570h] [rbp-5A8h]
  void **v212; // [rsp+578h] [rbp-5A0h]
  __int64 v213; // [rsp+580h] [rbp-598h]
  __int64 v214; // [rsp+588h] [rbp-590h]
  __int64 (__fastcall *v215)(__int64, _BYTE *, __int64, __int64, _QWORD *, void **, float *); // [rsp+590h] [rbp-588h]
  char v216[8]; // [rsp+598h] [rbp-580h] BYREF
  __int64 v217; // [rsp+5A0h] [rbp-578h]
  __int64 v218; // [rsp+5A8h] [rbp-570h]
  __int64 v219; // [rsp+5B0h] [rbp-568h]
  __int64 (__fastcall *v220)(__int64, _QWORD); // [rsp+5B8h] [rbp-560h]
  _QWORD *v221; // [rsp+5C0h] [rbp-558h]
  _QWORD *v222; // [rsp+5C8h] [rbp-550h]
  _QWORD buf_[4]; // [rsp+5D0h] [rbp-548h] BYREF
  _BYTE *v224; // [rsp+5F0h] [rbp-528h]
  _BYTE *v225; // [rsp+5F8h] [rbp-520h]
  __int64 v226; // [rsp+600h] [rbp-518h]
  __int64 v227; // [rsp+608h] [rbp-510h]
  __int64 *v228; // [rsp+610h] [rbp-508h]
  __int64 v229; // [rsp+618h] [rbp-500h]
  __int64 v230; // [rsp+620h] [rbp-4F8h] BYREF
  _QWORD v231[8]; // [rsp+628h] [rbp-4F0h] BYREF
  double dst__6[4]; // [rsp+668h] [rbp-4B0h] BYREF
  _QWORD src__1[2]; // [rsp+688h] [rbp-490h] BYREF
  _QWORD src_[2]; // [rsp+698h] [rbp-480h] BYREF
  double v235[3]; // [rsp+6A8h] [rbp-470h] BYREF
  double dst__7[3]; // [rsp+6C0h] [rbp-458h] BYREF
  double v237; // [rsp+6D8h] [rbp-440h] BYREF
  double v238; // [rsp+6E0h] [rbp-438h]
  double v239; // [rsp+6E8h] [rbp-430h]
  _QWORD src__2[3]; // [rsp+6F0h] [rbp-428h] BYREF
  double v241; // [rsp+710h] [rbp-408h] BYREF
  double v242; // [rsp+718h] [rbp-400h]
  double v243; // [rsp+720h] [rbp-3F8h]
  double v244; // [rsp+728h] [rbp-3F0h]
  double v245; // [rsp+730h] [rbp-3E8h]
  double v246; // [rsp+738h] [rbp-3E0h]
  double v247; // [rsp+740h] [rbp-3D8h]
  double v248; // [rsp+748h] [rbp-3D0h]
  char v249[8]; // [rsp+750h] [rbp-3C8h] BYREF
  char v250[8]; // [rsp+758h] [rbp-3C0h] BYREF
  _BYTE dst_[16]; // [rsp+760h] [rbp-3B8h] BYREF
  _BYTE dst__1[16]; // [rsp+770h] [rbp-3A8h] BYREF
  __m128 v253; // [rsp+780h] [rbp-398h]
  __m128 v254; // [rsp+790h] [rbp-388h]
  __int128 v255; // [rsp+7A0h] [rbp-378h]
  __int128 v256; // [rsp+7B0h] [rbp-368h]
  __m128 v257; // [rsp+7C0h] [rbp-358h]
  __m128 v258; // [rsp+7D0h] [rbp-348h]
  __int128 v259; // [rsp+7E0h] [rbp-338h]
  __int128 v260; // [rsp+7F0h] [rbp-328h]
  __m128 v265; // [rsp+840h] [rbp-2D8h]
  __m128 v266; // [rsp+850h] [rbp-2C8h]
  __m128 v267; // [rsp+860h] [rbp-2B8h]
  __m128 v268; // [rsp+870h] [rbp-2A8h]
  char v269[16]; // [rsp+880h] [rbp-298h] BYREF
  __m128 v270; // [rsp+890h] [rbp-288h]
  __m128 v271; // [rsp+8A0h] [rbp-278h]
  __int128 v272; // [rsp+8B0h] [rbp-268h]
  __int128 v273; // [rsp+8C0h] [rbp-258h]
  char v274[8]; // [rsp+8D0h] [rbp-248h] BYREF
  char v275[8]; // [rsp+8D8h] [rbp-240h] BYREF
  char v276[8]; // [rsp+8E0h] [rbp-238h] BYREF
  _QWORD v277[4]; // [rsp+8E8h] [rbp-230h] BYREF
  char v278[8]; // [rsp+908h] [rbp-210h] BYREF
  _BYTE v279[24]; // [rsp+910h] [rbp-208h] BYREF
  __int64 (__fastcall *p_sub_143DF1FC0)(); // [rsp+928h] [rbp-1F0h]
  _BYTE v281[24]; // [rsp+930h] [rbp-1E8h] BYREF
  __int64 (__fastcall *p_sub_143DF1FC0_1)(); // [rsp+948h] [rbp-1D0h]
  _QWORD v283[10]; // [rsp+950h] [rbp-1C8h] BYREF
  _BYTE dst__10[24]; // [rsp+9A0h] [rbp-178h] BYREF
  _BYTE dst__11[24]; // [rsp+9C0h] [rbp-158h] BYREF
  _BYTE dst__12[24]; // [rsp+9D8h] [rbp-140h] BYREF
  _BYTE dst__13[24]; // [rsp+9F0h] [rbp-128h] BYREF
  _BYTE dst__14[24]; // [rsp+A08h] [rbp-110h] BYREF
  _BYTE dst__15[32]; // [rsp+A20h] [rbp-F8h] BYREF
  char dst[32]; // [rsp+A40h] [rbp-D8h] BYREF
  char v291[24]; // [rsp+A60h] [rbp-B8h] BYREF
  char v292[40]; // [rsp+A78h] [rbp-A0h] BYREF
  __int128 v293; // [rsp+AA0h] [rbp-78h]
  __int128 v294; // [rsp+AB0h] [rbp-68h]
  __m128 v295; // [rsp+AC0h] [rbp-58h]
  __int128 v296; // [rsp+AD0h] [rbp-48h]
  __int128 v297; // [rsp+AE0h] [rbp-38h]

  sub_1402B39B0(v283);
  v283[2] = 1;
  LOWORD(v283[0]) = 0x4000;
  buf_[2] = qword_149A0FD80;
  qword_149A0FD80(v283, 0, &Source, &Source, 0);
  v76 = *(_QWORD *)(a1 + 0x2F8);
  if ( Handle::IsValid(&v76) )
  {
    v129 = sub_1403E7D30((unsigned __int64 *)(a1 + 8));
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v129 + 0x720LL))(v129)
      || (buf_[3] = v76 & 0xFFFFFFFFFFFFLL, sub_1439F0470(v76 & 0xFFFFFFFFFFFFLL)) )
    {
      if ( *(_BYTE *)(a1 + 0x3B0) && !*(_DWORD *)(a1 + 0x3D0) )
      {
        v226 = sub_14643C990(qword_149D36798);
        src_[0] = sub_146088B90;
        LODWORD(src_[1]) = 0;
        qmemcpy(dst_, src_, sizeof(dst_));
        sub_1414FBA20(v279, a1, 0, dst_, 0x10);
        p_sub_143DF1FC0 = sub_143DF1FC0;
        v224 = v279;
        src__1[0] = sub_146088900;
        LODWORD(src__1[1]) = 0;
        qmemcpy(dst__1, src__1, sizeof(dst__1));
        sub_1414FBA20(v281, a1, 0, dst__1, 0x10);
        p_sub_143DF1FC0_1 = sub_143DF1FC0;
        v225 = v281;
        n2 = 2;
        LOBYTE(v1) = 0x40;
        *(_DWORD *)(a1 + 0x3D0) = sub_14303E790(
                                    v226,
                                    v1,
                                    (unsigned int)&n2,
                                    (unsigned int)v281,
                                    (__int64)v224,
                                    (__int64)"CSCItemMiningController::Update");
      }
    }
    if ( is_valid_handle_typeA((__int64 *)(a1 + 0x318)) )
    {
      if ( Handle::IsValid(&v76) )
      {
        v227 = v76 & 0xFFFFFFFFFFFFLL;
        v146 = sub_1439E7780(v76 & 0xFFFFFFFFFFFFLL);
      }
      else
      {
        v146 = 0;
      }
      v147 = v146;
      if ( v146 )
      {
        v228 = (__int64 *)sub_142745650(v147, v278);
        v229 = *v228;
        v230 = v229;
        v148 = &v230;
      }
      else
      {
        v231[0] = 0;
        v148 = v231;
      }
      v231[1] = v148;
      v86 = *v148;
      if ( is_valid_handle_typeA(&v86) )
      {
        *(_QWORD *)&dst__6[3] = v86 & 0xFFFFFFFFFFFFLL;
        v164[0] = *(_QWORD *)((v86 & 0xFFFFFFFFFFFFLL) + 8);
        v149 = v164;
      }
      else
      {
        sub_1402B3A40(v249);
        v149 = v2;
      }
      v164[1] = v149;
      v150 = *v149;
      if ( is_valid_handle_typeA(&v86) && is_valid_handle_typeB(&v150) )
      {
        v120 = sub_1403103B0(&v150);
        v165 = *(void (__fastcall **)(__int64, double *, __int64, _QWORD, int))(*(_QWORD *)v120 + 0x1E8LL);
        LOBYTE(v32) = 0;
        v165(v120, &v78, 2, 0, v32);
        v121 = v86 & 0xFFFFFFFFFFFFLL;
        v166 = *(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)(v86 & 0xFFFFFFFFFFFFLL) + 0x5D8LL);
        v33 = (float *)v166(v86 & 0xFFFFFFFFFFFFLL, v292, 0);
        v167 = v79 * v33[2] - v80 * v33[1] + v81 * *v33 + v78 * v33[3];
        v168 = v80 * *v33 - v78 * v33[2] + v81 * v33[1] + v79 * v33[3];
        v169 = v78 * v33[1] - v79 * *v33 + v81 * v33[2] + v80 * v33[3];
        v170 = v81 * v33[3] - v78 * *v33 - v79 * v33[1] - v80 * v33[2];
        v124 = v79 * v33[6] - v80 * v33[5] + v81 * v33[4];
        v123 = v80 * v33[4] - v78 * v33[6] + v81 * v33[5];
        v122 = v78 * v33[5] - v79 * v33[4] + v81 * v33[6];
        v45 = v122 * v79 - v123 * v80;
        v45 = (v45 + v45 + v33[4]) * v85 + v82;
        v47 = v124 * v80 - v122 * v78;
        v47 = (v47 + v47 + v33[5]) * v85 + v83;
        v46 = v123 * v78 - v124 * v79;
        v46 = (v46 + v46 + v33[6]) * v85 + v84;
        v171 = v85;
        v241 = v167;
        v242 = v168;
        v243 = v169;
        v244 = v170;
        v245 = v45;
        v246 = v47;
        v247 = v46;
        v248 = v85;
        v43 = &v241;
        v174 = 2.0 * (v169 * v168 + v167 * v170);
        v173 = 2.0 * (v242 * v242 + v244 * v244) - 1.0;
        v172 = 2.0 * (v167 * v168 - v169 * v170);
        *(double *)&v231[2] = v172;
        *(double *)&v231[3] = v173;
        _XMM0 = *(unsigned __int64 *)&v174;
        *(double *)&v231[4] = v174;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+0B18h+var_4E0] }
        v161 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+0B18h+var_4D8] }
        v162 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+0B18h+var_4D0] }
        v163 = *(float *)&_XMM0;
        src = &v161;
        v63 = (float)((float)(v161 * v161) + (float)(v162 * v162)) + (float)(v163 * v163);
        v71 = v63 > 0.00000011920929;
        if ( v63 <= 0.00000011920929 )
        {
          qmemcpy(dst__2, &::src_, sizeof(dst__2));
        }
        else
        {
          v253 = _mm_shuffle_ps((__m128)LODWORD(v63), (__m128)LODWORD(v63), 0);
          v254 = v253;
          __asm { vrsqrtps xmm0, [rsp+0B18h+var_388] }
          v255 = _XMM0;
          v256 = _XMM0;
          v293 = _XMM0;
          v48 = *((float *)&_XMM0 + 3);
          v49 = *((float *)&_XMM0 + 3)
              * (float)(1.5 - (float)((float)((float)(v63 * *((float *)&_XMM0 + 3)) * *((float *)&_XMM0 + 3)) * 0.5));
          qmemcpy(dst__3, src, sizeof(dst__3));
          dst__2[0] = dst__3[0] * v49;
          dst__2[1] = dst__3[1] * v49;
          dst__2[2] = dst__3[2] * v49;
        }
        v42 = &v78;
        v177 = 2.0 * (v80 * v78 - v79 * v81);
        v176 = 2.0 * (v79 * v78 + v80 * v81);
        v175 = 2.0 * (v78 * v78 + v81 * v81) - 1.0;
        *(double *)&v231[5] = v175;
        *(double *)&v231[6] = v176;
        _XMM0 = *(unsigned __int64 *)&v177;
        *(double *)&v231[7] = v177;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+0B18h+var_4C8] }
        v153 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+0B18h+var_4C0] }
        v154 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+0B18h+var_4B8] }
        v155 = *(float *)&_XMM0;
        src_1 = &v153;
        v50 = (float)((float)(v153 * v153) + (float)(v154 * v154)) + (float)(v155 * v155);
        v70 = v50 > 0.00000011920929;
        if ( v50 <= 0.00000011920929 )
        {
          qmemcpy(dst__4, &::src_, sizeof(dst__4));
        }
        else
        {
          v257 = _mm_shuffle_ps((__m128)LODWORD(v50), (__m128)LODWORD(v50), 0);
          v258 = v257;
          __asm { vrsqrtps xmm0, [rsp+0B18h+var_348] }
          v259 = _XMM0;
          v260 = _XMM0;
          v297 = _XMM0;
          v51 = *((float *)&_XMM0 + 3);
          v52 = *((float *)&_XMM0 + 3)
              * (float)(1.5 - (float)((float)((float)(v50 * *((float *)&_XMM0 + 3)) * *((float *)&_XMM0 + 3)) * 0.5));
          qmemcpy(dst__5, src_1, sizeof(dst__5));
          dst__4[0] = dst__5[0] * v52;
          dst__4[1] = dst__5[1] * v52;
          dst__4[2] = dst__5[2] * v52;
        }
        v41 = &v78;
        v180 = 2.0 * (v80 * v79 + v78 * v81);
        v179 = 2.0 * (v79 * v79 + v81 * v81) - 1.0;
        v178 = 2.0 * (v78 * v79 - v80 * v81);
        v237 = v178;
        v238 = v179;
        v239 = v180;
        src_2 = &v237;
        v125 = v237 * v237 + v238 * v238 + v239 * v239;
        _XMM0 = *(unsigned __int64 *)&v125;
        v69 = v125 > 0.0;
        if ( v125 <= 0.0 )
        {
          qmemcpy(dst__6, &src__0, 0x18u);
        }
        else
        {
          __asm
          {
            vmovddup xmm0, [rsp+0B18h+var_890]
            vmovupd [rsp+0B18h+var_318], xmm0
            vmovupd xmm0, [rsp+0B18h+var_318]
            vmovupd [rsp+0B18h+var_308], xmm0
            vsqrtpd xmm0, [rsp+0B18h+var_308]
            vmovupd [rsp+0B18h+var_2F8], xmm0
            vmovupd xmm0, [rsp+0B18h+var_2F8]
            vmovupd [rsp+0B18h+var_2E8], xmm0
            vmovupd xmm0, [rsp+0B18h+var_2E8]
            vmovupd [rsp+0B18h+var_48], xmm0
          }
          v181 = *((double *)&v296 + 1);
          v104 = 1.0 / *((double *)&v296 + 1);
          qmemcpy(dst__7, src_2, sizeof(dst__7));
          dst__6[0] = dst__7[0] * (1.0 / *((double *)&v296 + 1));
          dst__6[1] = dst__7[1] * (1.0 / *((double *)&v296 + 1));
          _XMM0 = COERCE_UNSIGNED_INT64(dst__7[2] * (1.0 / *((double *)&v296 + 1)));
          dst__6[2] = dst__7[2] * (1.0 / *((double *)&v296 + 1));
        }
        dst_1 = dst__6;
        __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax] }
        v117 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+8] }
        v118 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+10h] }
        v119 = *(float *)&_XMM0;
        v99 = (float)((float)(dst__2[0] * dst__4[0]) + (float)(dst__2[1] * dst__4[1])) + (float)(dst__2[2] * dst__4[2]);
        v98 = (float)((float)(dst__4[0] * dst__4[0]) + (float)(dst__4[1] * dst__4[1])) + (float)(dst__4[2] * dst__4[2]);
        v265 = _mm_shuffle_ps((__m128)LODWORD(v98), (__m128)LODWORD(v98), 0);
        v266 = v265;
        v267 = _mm_sqrt_ps(v265);
        v268 = v267;
        v295 = v267;
        v100 = v267.m128_f32[3];
        v53 = v99 / v267.m128_f32[3];
        v103 = (float)(v99 / v267.m128_f32[3]) * dst__4[2];
        v102 = (float)(v99 / v267.m128_f32[3]) * dst__4[1];
        v101 = (float)(v99 / v267.m128_f32[3]) * dst__4[0];
        v114 = v101;
        v115 = v102;
        v116 = v103;
        v112 = dst__2[2] - v103;
        v111 = dst__2[1] - v102;
        v110 = dst__2[0] - v101;
        v157 = dst__2[0] - v101;
        v158 = dst__2[1] - v102;
        v159 = dst__2[2] - v103;
        src_3 = &v157;
        v54 = (float)((float)(v157 * v157) + (float)(v158 * v158)) + (float)(v159 * v159);
        v67 = v54 > 0.00000011920929;
        if ( v54 <= 0.00000011920929 )
        {
          qmemcpy(dst__8, &::src_, sizeof(dst__8));
        }
        else
        {
          v270 = _mm_shuffle_ps((__m128)LODWORD(v54), (__m128)LODWORD(v54), 0);
          v271 = v270;
          __asm { vrsqrtps xmm0, [rsp+0B18h+var_278] }
          v272 = _XMM0;
          v273 = _XMM0;
          v294 = _XMM0;
          v55 = *((float *)&_XMM0 + 3);
          v56 = *((float *)&_XMM0 + 3)
              * (float)(1.5 - (float)((float)((float)(v54 * *((float *)&_XMM0 + 3)) * *((float *)&_XMM0 + 3)) * 0.5));
          qmemcpy(dst__9, src_3, sizeof(dst__9));
          dst__8[0] = dst__9[0] * v56;
          dst__8[1] = dst__9[1] * v56;
          dst__8[2] = dst__9[2] * v56;
        }
        X_3 = (float)((float)(v117 * dst__8[0]) + (float)(v118 * dst__8[1])) + (float)(v119 * dst__8[2]);
        if ( X_3 >= -1.0 )
        {
          if ( X_3 >= 1.0 )
            X_1 = 1.0;
          else
            X_1 = X_3;
          X = X_1;
        }
        else
        {
          X = -1.0;
        }
        X_2 = X;
        v90 = j_acosf(X);
        v68 = sub_140330A10(COERCE_DOUBLE((unsigned __int64)LODWORD(v90))).m128_u32[0];
        v40 = &v78;
        v184 = 2.0 * (v80 * v80 + v81 * v81) - 1.0;
        v183 = 2.0 * (v79 * v80 - v78 * v81);
        v182 = 2.0 * (v78 * v80 + v79 * v81);
        v235[0] = v182;
        v235[1] = v183;
        v235[2] = v184;
        v105 = v235;
        if ( v182 * dst__8[0] + v183 * dst__8[1] + v184 * dst__8[2] >= 0.0 )
          v72 = v68;
        else
          v72 = v68 ^ 0x80000000;
        v95 = v72;
        sub_14154B860(a1 + 0x12A8, &v95);
      }
    }
    sub_1460C4720(a1);
    v185 = v76 & 0xFFFFFFFFFFFFLL;
    v106 = sub_1439E7780(v76 & 0xFFFFFFFFFFFFLL);
    if ( v106 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v106 + 0x5F8LL))(v106) )
    {
      v126 = *(_QWORD *)(a1 + 0x2D8);
      if ( AssetMeta::HasActorSubresource(&v126) )
      {
        v186 = v126 & 0xFFFFFFFFFFFFLL;
        _StarEngineModule__(0);
        v187 = *(_QWORD *)(v186 + 8);
        sub_142C80620(v188, v187);
        v188[1] = v188[0];
        v127 = v188[0];
        v87 = Handle::IsValid(&v127) ? v127 & 0xFFFFFFFFFFFFLL : 0LL;
        if ( v87 && (unsigned __int8)sub_143504C40(v87) && sub_141882E30(v87) <= 1000.0 )
        {
          v128 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x98);
          v143 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v128 + 0xA0LL))(v128);
          v130 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v143 + 0x268LL))(v143);
          v189 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v130 + 0x18LL);
          v188[2] = 0;
          v189(v130, 0x95, 0, 0);
        }
      }
      if ( (unsigned __int8)sub_1403216E0(a1 + 0x9F0) && !(unsigned __int8)sub_146041970(a1) )
        sub_1460ABB70(a1);
      sub_1460C4720(a1);
      sub_1460B8870(a1);
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x2E0)) )
      {
        if ( !(unsigned __int8)sub_1403216E0(a1 + 0xA38) )
        {
          v23 = sub_146058D60(a1);
          if ( *(float *)&v23 >= 1.0 )
          {
            v35 = 1;
            sub_14154B820(a1 + 0xA38, &v35);
            sub_1460C61F0(a1);
          }
        }
        if ( (unsigned __int8)sub_1403216E0(a1 + 0xA38) )
        {
          v73 = 1.0;
        }
        else
        {
          v24 = sub_146058D60(a1);
          v73 = *(float *)&v24;
        }
        v91 = v73;
        sub_14154B860(a1 + 0xBE8, &v91);
        v190 = a1 + 0xBE8;
        v92 = 0.0;
        v36 = sub_1436541A0(a1 + 0xBE8, &v92);
        sub_14154B820(a1 + 0x7F8, &v36);
        if ( *(_BYTE *)(a1 + 0x3DC) && sub_1414FDE20(a1 + 0xBE8) >= 1.0 )
        {
          v131 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x98);
          v132 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v131 + 0xA0LL))(v131);
          v133 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v132 + 0x268LL))(v132);
          v192 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v133 + 0x18LL);
          v191 = 0;
          v192(v133, 0x40, 0, 0);
        }
      }
      else
      {
        v37 = 0;
        sub_14154B820(a1 + 0x7F8, &v37);
        v93[0] = 0.0;
        sub_14154B860(a1 + 0xBE8, v93);
      }
      sub_1460C5070(a1);
      sub_1460BFFE0(a1);
      if ( !*(_BYTE *)(a1 + 0x400) )
      {
        v107 = *(_QWORD *)(a1 + 0x2B8);
        if ( Handle::IsValid(&v107) )
        {
          v193 = v107 & 0xFFFFFFFFFFFFLL;
          sub_14278A0B0(v107 & 0xFFFFFFFFFFFFLL, &v134);
          if ( Handle::IsValid(&v134) )
          {
            v194 = v134 & 0xFFFFFFFFFFFFLL;
            if ( sub_1439F0460(v134 & 0xFFFFFFFFFFFFLL) )
            {
              *(_BYTE *)(a1 + 0x400) = 1;
              sub_1433D6EF0(v107 & 0xFFFFFFFFFFFFLL);
            }
          }
        }
      }
    }
    sub_1460C0230(a1);
    v135 = sub_1403E7D30((unsigned __int64 *)(a1 + 8));
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v135 + 0x720LL))(v135) && !*(_BYTE *)(a1 + 0x6B0) )
    {
      LOBYTE(v25) = 1;
      sub_1402B07F0(v216, "CSCItemMiningController::Update", a1 + 0x678, v25);
      if ( *(_QWORD *)(a1 + 0x6A8) != 0 )
      {
        v88 = (_QWORD *)sub_1453A9890(a1 + 0x688);
        v34 = 1;
        v136 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
        v197 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v136 + 0x120LL);
        v195 = v88 + 1;
        v196 = *(_QWORD *)std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
                            v88 + 1,
                            v250);
        v197(v136, &v109, v196);
        if ( is_valid_handle_typeB(&v109) )
        {
          v198 = *v88;
          v199 = (__int64 *)sub_141298CE0(v269, v198);
          v200 = *v199;
          v108 = v200;
          if ( AssetMeta::HasActorSubresource(&v108) )
          {
            v141 = 0;
            v137 = sub_1403103B0(&v109);
            v138 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v137 + 0x20LL))(v137);
            if ( v138 )
            {
              v26 = (unsigned __int16 *)sub_1403ADD60(v96);
              v139 = sub_14033C930(v138, *v26);
              if ( v139 )
              {
                v201 = *(_QWORD *)(v139 + 0x48);
                v141 = v201;
              }
            }
            v142 = sub_14643BF40(qword_149D36798);
            v203 = *(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v142 + 0x118LL);
            v140 = v108 & 0xFFFFFFFFFFFFLL;
            v202 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v108 & 0xFFFFFFFFFFFFLL) + 0x570LL))(v108 & 0xFFFFFFFFFFFFLL);
            if ( v203(v142, v141, v202) )
            {
              v34 = 0;
              v204 = a1 + 8;
              sub_1403B29B0((unsigned __int64 *)(a1 + 8), v206);
              *(_BYTE *)(a1 + 0x6B0) = 1;
              v144 = sub_14643BF40(qword_149D36798);
              v215 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64, __int64, _QWORD *, void **, float *))(*(_QWORD *)v144 + 8LL);
              v205 = v274;
              v212 = sub_14035C990((void **)v274, (const void **)&qword_149D2F568);
              src__2[0] = *v88;
              src__2[1] = v206[0];
              src__2[2] = a1;
              qmemcpy(dst__10, src__2, sizeof(dst__10));
              qmemcpy(dst, dst__10, 0x18u);
              sub_145FCBA90(v277, dst);
              memset(&v206[1], 0, 0x18);
              v213 = 0;
              v206[4] = v108 & 0xFFFFFFFFFFFFLL;
              v207 = *(_QWORD *)((v108 & 0xFFFFFFFFFFFFLL) + 8);
              v208 = v207;
              v209 = v207;
              v210 = v207;
              v214 = v207;
              v151 = sub_1403103B0(&v109);
              v211 = *(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v151 + 8LL);
              v27 = (_QWORD *)v211(v151, v275);
              qmemcpy(dst__11, (const void *)sub_1405B14C0(v291, *v27), sizeof(dst__11));
              qmemcpy(dst__12, dst__11, sizeof(dst__12));
              qmemcpy(dst__13, dst__12, sizeof(dst__13));
              qmemcpy(dst__14, dst__13, sizeof(dst__14));
              qmemcpy(dst__15, dst__14, 0x18u);
              v277[3] = v215(v144, dst__15, v214, v213, v277, v212, v33);
              sub_1402A5160(v277);
            }
          }
        }
        if ( v34 )
          sub_14604E0C0(a1, 0, *v88);
      }
      sub_1402B3C20(v216);
    }
    v217 = *(_QWORD *)(a1 + 0x7A8);
    v75 = v217 == 0;
    if ( v217 )
    {
      v218 = sub_140334DC0(a1);
      v219 = *(_QWORD *)(v218 + 0x50);
      v94 = *(float *)(v219 + 0xE4);
      v145 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x60);
      v220 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v145 + 0x38LL);
      v221 = (_QWORD *)v220(v145, 0);
      v222 = sub_140598C00(v221, v276, (_QWORD *)(a1 + 0x7A8));
      _XMM0 = sub_140598DA0();
      __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
      v93[1] = *(float *)&_XMM0;
      if ( *(float *)&_XMM0 > v94 )
      {
        v38 = 0;
        sub_14154B820(a1 + 0xB58, &v38);
        v39 = 0;
        sub_14154B820(a1 + 0xBA0, &v39);
        memset(buf_, 0, 8u);
        sub_1402B3A40(buf_);
        *(_QWORD *)(a1 + 0x7A8) = *v30;
      }
    }
  }
  v59 = 0;
  v283[3] = __rdtsc();
  buf_[1] = qword_149A0FD88;
  return qword_149A0FD88(v283);
}

// --- End Function: sub_1460B14E0 (0x1460B14E0) ---

// --- Function: sub_1460B8870 (0x1460B8870) ---
__int64 __fastcall sub_1460B8870(__int64 a1, float a2)
{
  __int64 result; // rax
  float v3; // [rsp+20h] [rbp-148h]
  float v4; // [rsp+28h] [rbp-140h]
  float v5; // [rsp+30h] [rbp-138h]
  float v6; // [rsp+3Ch] [rbp-12Ch]
  float v7; // [rsp+40h] [rbp-128h]
  __int64 v8; // [rsp+48h] [rbp-120h]
  float v9; // [rsp+50h] [rbp-118h]
  _DWORD *v10; // [rsp+60h] [rbp-108h]
  __int64 v11; // [rsp+68h] [rbp-100h]
  __int64 v12; // [rsp+70h] [rbp-F8h] BYREF
  __int64 v13; // [rsp+78h] [rbp-F0h]
  __int64 v14[2]; // [rsp+80h] [rbp-E8h] BYREF
  __int64 v15; // [rsp+90h] [rbp-D8h]
  __int64 v16; // [rsp+98h] [rbp-D0h]
  _DWORD src_[4]; // [rsp+A0h] [rbp-C8h] BYREF
  float dst_[3]; // [rsp+B0h] [rbp-B8h] BYREF
  float v19[4]; // [rsp+C0h] [rbp-A8h] BYREF
  float dst__1[3]; // [rsp+D0h] [rbp-98h] BYREF
  float v21[4]; // [rsp+E0h] [rbp-88h] BYREF
  __int64 v22; // [rsp+F0h] [rbp-78h]
  __int64 v23; // [rsp+F8h] [rbp-70h]
  __int64 v24; // [rsp+100h] [rbp-68h]
  __int64 v25; // [rsp+108h] [rbp-60h]
  __int64 v26; // [rsp+110h] [rbp-58h]
  __int64 v27; // [rsp+118h] [rbp-50h]
  __int64 v28; // [rsp+120h] [rbp-48h]
  _DWORD *src; // [rsp+128h] [rbp-40h]
  _DWORD *v30; // [rsp+130h] [rbp-38h]
  float *v31; // [rsp+138h] [rbp-30h]
  float *v32; // [rsp+140h] [rbp-28h]
  __int64 (__fastcall *v33)(__int64, __int64, float *, float *); // [rsp+148h] [rbp-20h]

  v12 = *(_QWORD *)(a1 + 0x2F8);
  if ( Handle::IsValid(&v12) )
  {
    v22 = v12 & 0xFFFFFFFFFFFFLL;
    v13 = sub_1439E7780(v12 & 0xFFFFFFFFFFFFLL);
  }
  else
  {
    v13 = 0;
  }
  result = v13;
  v8 = v13;
  if ( v13 )
  {
    result = (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x5F8LL))(v13);
    if ( (_BYTE)result )
    {
      sub_1414F3F40(v8, v14);
      if ( AssetMeta::HasActorSubresource(v14) )
      {
        v14[1] = v14[0] & 0xFFFFFFFFFFFFLL;
        v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v14[0] & 0xFFFFFFFFFFFFLL) + 0x860LL))(v14[0] & 0xFFFFFFFFFFFFLL);
        v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x28LL))(v15);
      }
      else
      {
        v16 = 0;
      }
      result = v16;
      v11 = v16;
      if ( v16 )
      {
        v23 = sub_140334DC0(a1);
        v24 = *(_QWORD *)(v23 + 0x50);
        result = v24 != 0;
        if ( v24 )
        {
          v25 = sub_140334DC0(a1);
          v26 = *(_QWORD *)(v25 + 0x50);
          v10 = (_DWORD *)(v26 + 0x78);
          result = *(unsigned __int8 *)(v26 + 0xB4);
          if ( *(_BYTE *)(v26 + 0xB4) )
          {
            v9 = sub_146038250(a1);
            v27 = sub_140334DC0(a1);
            v28 = *(_QWORD *)(v27 + 0x50);
            v3 = a2 * *(float *)(v28 + 0xD4);
            if ( v3 >= 0.0 )
            {
              if ( v3 >= 1.0 )
                v6 = 1.0;
              else
                v6 = a2 * *(float *)(v28 + 0xD4);
              v7 = v6;
            }
            else
            {
              v7 = 0.0;
            }
            *(float *)(a1 + 0x39C) = *(float *)(a1 + 0x39C) + (float)(v7 * (float)(v9 - *(float *)(a1 + 0x39C)));
            v33 = *(__int64 (__fastcall **)(__int64, __int64, float *, float *))(*(_QWORD *)v11 + 0x138LL);
            src_[0] = v10[4];
            src_[1] = v10[5];
            src_[2] = v10[6];
            src = src_;
            v4 = *(float *)(a1 + 0x39C);
            qmemcpy(dst_, src_, sizeof(dst_));
            v19[0] = dst_[0] * v4;
            v19[1] = dst_[1] * v4;
            v19[2] = dst_[2] * v4;
            v31 = v19;
            v30 = v10 + 0xA;
            v5 = *(float *)(a1 + 0x39C);
            qmemcpy(dst__1, v10 + 0xA, sizeof(dst__1));
            v21[0] = dst__1[0] * v5;
            v21[1] = dst__1[1] * v5;
            v21[2] = dst__1[2] * v5;
            v32 = v21;
            return v33(v11, a1 + 0x3A0, v21, v19);
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1460B8870 (0x1460B8870) ---

// --- Function: sub_1460B9CA0 (0x1460B9CA0) ---
__int64 __fastcall sub_1460B9CA0(__int64 a1, double *a2)
{
  __int64 result; // rax
  char v13; // [rsp+20h] [rbp-218h]
  __int64 v14; // [rsp+30h] [rbp-208h] BYREF
  unsigned __int32 v15; // [rsp+38h] [rbp-200h] BYREF
  unsigned __int32 v16; // [rsp+3Ch] [rbp-1FCh] BYREF
  __int64 v17; // [rsp+40h] [rbp-1F8h]
  __int64 v18; // [rsp+48h] [rbp-1F0h]
  __int64 v19; // [rsp+50h] [rbp-1E8h]
  double dst_[4]; // [rsp+58h] [rbp-1E0h] BYREF
  void (__fastcall *v21)(__int64, _BYTE *, double *); // [rsp+78h] [rbp-1C0h]
  double v22; // [rsp+80h] [rbp-1B8h]
  double v23; // [rsp+88h] [rbp-1B0h]
  __int64 v24; // [rsp+90h] [rbp-1A8h]
  __int64 v25; // [rsp+98h] [rbp-1A0h] BYREF
  __int64 (__fastcall *v26)(__int64, _BYTE *, _QWORD, _QWORD, char); // [rsp+A0h] [rbp-198h]
  double v27; // [rsp+A8h] [rbp-190h]
  double v28; // [rsp+B0h] [rbp-188h]
  _BYTE v37[32]; // [rsp+140h] [rbp-F8h] BYREF
  double v38; // [rsp+160h] [rbp-D8h]
  double v39; // [rsp+168h] [rbp-D0h]
  double v40; // [rsp+170h] [rbp-C8h]
  double v41[7]; // [rsp+178h] [rbp-C0h] BYREF
  _BYTE v42[64]; // [rsp+1B0h] [rbp-88h] BYREF
  __int128 v43; // [rsp+1F0h] [rbp-48h]
  __int128 v44; // [rsp+200h] [rbp-38h]

  v14 = *(_QWORD *)(a1 + 0x2C8);
  if ( is_valid_handle_typeA(&v14) )
  {
    if ( is_valid_handle_typeA(&v14) )
      v17 = v14 & 0xFFFFFFFFFFFFLL;
    else
      v17 = 0;
    v18 = sub_145C739C0(v17);
    *(_QWORD *)&dst_[3] = v14 & 0xFFFFFFFFFFFFLL;
    sub_145BC8320(v14 & 0xFFFFFFFFFFFFLL, v41, 0);
    v21 = *(void (__fastcall **)(__int64, _BYTE *, double *))(*(_QWORD *)v18 + 0xD8LL);
    v21(v18, v37, v41);
    v22 = (*a2 - v38) * (*a2 - v38) + (a2[1] - v39) * (a2[1] - v39) + (a2[2] - v40) * (a2[2] - v40);
    __asm
    {
      vmovddup xmm0, [rsp+238h+var_1B8]
      vmovupd [rsp+238h+var_178], xmm0
      vmovupd xmm0, [rsp+238h+var_178]
      vmovupd [rsp+238h+var_168], xmm0
      vsqrtpd xmm0, [rsp+238h+var_168]
      vmovupd [rsp+238h+var_158], xmm0
      vmovupd xmm0, [rsp+238h+var_158]
      vmovupd [rsp+238h+var_148], xmm0
      vmovupd xmm0, [rsp+238h+var_148]
      vmovupd [rsp+238h+var_48], xmm0
    }
    v23 = *((double *)&v43 + 1);
    v15 = sub_142784F50(*((double *)&v43 + 1)).m128_u32[0];
    return sub_14154B860(a1 + 0x11D0, &v15);
  }
  else
  {
    result = AssetMeta::HasActorSubresource((__int64 *)(a1 + 0x2D8));
    if ( (_BYTE)result )
    {
      v24 = *(_QWORD *)(a1 + 0x2D8) & 0xFFFFFFFFFFFFLL;
      v25 = *(_QWORD *)(v24 + 8);
      v19 = sub_1403103B0(&v25);
      v26 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD, char))(*(_QWORD *)v19 + 0x1E8LL);
      v13 = 0;
      qmemcpy(dst_, (const void *)(v26(v19, v42, 0, 0, v13) + 0x20), 0x18u);
      v27 = (*a2 - dst_[0]) * (*a2 - dst_[0])
          + (a2[1] - dst_[1]) * (a2[1] - dst_[1])
          + (a2[2] - dst_[2]) * (a2[2] - dst_[2]);
      __asm
      {
        vmovddup xmm0, [rsp+238h+var_190]
        vmovupd [rsp+238h+var_138], xmm0
        vmovupd xmm0, [rsp+238h+var_138]
        vmovupd [rsp+238h+var_128], xmm0
        vsqrtpd xmm0, [rsp+238h+var_128]
        vmovupd [rsp+238h+var_118], xmm0
        vmovupd xmm0, [rsp+238h+var_118]
        vmovupd [rsp+238h+var_108], xmm0
        vmovupd xmm0, [rsp+238h+var_108]
        vmovupd [rsp+238h+var_38], xmm0
      }
      v28 = *((double *)&v44 + 1);
      v16 = sub_142784F50(*((double *)&v44 + 1)).m128_u32[0];
      return sub_14154B860(a1 + 0x11D0, &v16);
    }
  }
  return result;
}

// --- End Function: sub_1460B9CA0 (0x1460B9CA0) ---

// --- Function: sub_1460BA0E0 (0x1460BA0E0) ---
__int64 __fastcall sub_1460BA0E0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rax
  bool v3; // [rsp+20h] [rbp-178h]
  __int64 v4; // [rsp+28h] [rbp-170h] BYREF
  __int64 v5; // [rsp+30h] [rbp-168h]
  float v6; // [rsp+38h] [rbp-160h]
  float v7; // [rsp+3Ch] [rbp-15Ch]
  __int64 v8; // [rsp+40h] [rbp-158h]
  __int64 v9; // [rsp+48h] [rbp-150h] BYREF
  __int64 v10; // [rsp+50h] [rbp-148h] BYREF
  __int64 v11; // [rsp+58h] [rbp-140h]
  __int64 v12; // [rsp+60h] [rbp-138h]
  __int64 v13; // [rsp+68h] [rbp-130h]
  __int64 v14; // [rsp+70h] [rbp-128h]
  __int64 v15; // [rsp+78h] [rbp-120h]
  __int64 v16; // [rsp+80h] [rbp-118h]
  __int64 v17; // [rsp+88h] [rbp-110h]
  __int64 v18; // [rsp+90h] [rbp-108h]
  __int64 v19; // [rsp+98h] [rbp-100h]
  __int64 v20; // [rsp+A0h] [rbp-F8h]
  __int64 v21; // [rsp+A8h] [rbp-F0h] BYREF
  void (__fastcall *v22)(__int64, _BYTE *, _QWORD); // [rsp+B0h] [rbp-E8h]
  void (__fastcall *v23)(__int64, _QWORD *); // [rsp+B8h] [rbp-E0h]
  _QWORD v24[3]; // [rsp+C0h] [rbp-D8h] BYREF
  _QWORD src__1[5]; // [rsp+D8h] [rbp-C0h] BYREF
  _BYTE src_[32]; // [rsp+100h] [rbp-98h] BYREF
  _BYTE dst_[40]; // [rsp+120h] [rbp-78h] BYREF
  _BYTE dst__1[72]; // [rsp+150h] [rbp-48h] BYREF

  v13 = sub_140334DC0(a1);
  result = *(_QWORD *)(v13 + 0x50);
  v14 = result;
  if ( result )
  {
    v15 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x60);
    v7 = sub_1403B16C0(v15, 0).m128_f32[0];
    v6 = *(float *)(a1 + 0x368);
    *(float *)(a1 + 0x368) = v6 - v7;
    result = a1;
    if ( *(float *)(a1 + 0x368) < 0.00000011920929 )
    {
      *(float *)(a1 + 0x368) = 0x3F800000;
      sub_146042A40(a1);
      v4 = *(_QWORD *)(a1 + 0x2F8);
      result = Handle::IsValid(&v4);
      if ( (_BYTE)result )
      {
        v3 = 0;
        v16 = v4 & 0xFFFFFFFFFFFFLL;
        v8 = sub_1409144C0(v4 & 0xFFFFFFFFFFFFLL);
        if ( v8 )
          v3 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x40LL))(v8) == 6;
        v17 = v4 & 0xFFFFFFFFFFFFLL;
        if ( sub_1439F0470(v4 & 0xFFFFFFFFFFFFLL) || (result = v3) != 0 )
        {
          v18 = v4 & 0xFFFFFFFFFFFFLL;
          result = sub_1439E7780(v4 & 0xFFFFFFFFFFFFLL);
          v5 = result;
          if ( result )
          {
            result = (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x5F8LL))(v5);
            if ( (_BYTE)result )
            {
              sub_1427489C0(v5, &v9);
              result = is_valid_handle_typeA(&v9);
              if ( (_BYTE)result )
              {
                v19 = v9 & 0xFFFFFFFFFFFFLL;
                v2 = sub_14654BC00(v9 & 0xFFFFFFFFFFFFLL);
                result = (unsigned __int8)sub_144A49240(v2);
                if ( !(_BYTE)result )
                {
                  v10 = *(_QWORD *)(a1 + 0x2D0);
                  result = is_valid_handle_typeA(&v10);
                  if ( (_BYTE)result )
                  {
                    v20 = v9 & 0xFFFFFFFFFFFFLL;
                    v21 = *(_QWORD *)((v9 & 0xFFFFFFFFFFFFLL) + 8);
                    v11 = sub_1403103B0(&v21);
                    v22 = *(void (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v11 + 0x2C8LL);
                    v22(v11, src_, 0);
                    v12 = v10 & 0xFFFFFFFFFFFFLL;
                    v23 = *(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)(v10 & 0xFFFFFFFFFFFFLL) + 0x648LL);
                    src__1[0] = v10;
                    src__1[1] = a1;
                    qmemcpy(&src__1[2], src_, 0x18u);
                    qmemcpy(dst_, src__1, sizeof(dst_));
                    qmemcpy(dst__1, dst_, 0x28u);
                    sub_145FCB9F0(v24, (__int64)dst__1);
                    v23(v12, v24);
                    return sub_1402A5160(v24);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1460BA0E0 (0x1460BA0E0) ---

// --- Function: sub_1460BFFE0 (0x1460BFFE0) ---
__int64 __fastcall sub_1460BFFE0(__int64 a1, float a2)
{
  __int64 result; // rax
  int v3; // [rsp+30h] [rbp-C8h] BYREF
  _QWORD v4[2]; // [rsp+38h] [rbp-C0h] BYREF
  __m256 *v5; // [rsp+48h] [rbp-B0h]
  __m256 *v6; // [rsp+50h] [rbp-A8h]
  __int64 v7; // [rsp+58h] [rbp-A0h]
  _QWORD src_[2]; // [rsp+60h] [rbp-98h] BYREF
  _QWORD src__1[2]; // [rsp+70h] [rbp-88h] BYREF
  _BYTE dst_[16]; // [rsp+80h] [rbp-78h] BYREF
  _BYTE dst__1[16]; // [rsp+90h] [rbp-68h] BYREF
  _QWORD v12[4]; // [rsp+A0h] [rbp-58h] BYREF
  __m256 v13; // [rsp+C0h] [rbp-38h] BYREF

  v4[0] = *(_QWORD *)(a1 + 0x2F8);
  result = Handle::IsValid(v4);
  if ( (_BYTE)result )
  {
    result = *(unsigned __int8 *)(a1 + 0x3DC);
    if ( *(_BYTE *)(a1 + 0x3DC) )
    {
      v4[1] = v4[0] & 0xFFFFFFFFFFFFLL;
      result = sub_1439F0470(v4[0] & 0xFFFFFFFFFFFFLL);
      if ( !(_BYTE)result )
      {
        *(float *)(a1 + 0x3D8) = *(float *)(a1 + 0x3D8) - a2;
        result = a1;
        if ( *(float *)(a1 + 0x3D8) < 0.0 )
        {
          *(float *)(a1 + 0x3D8) = *(float *)(a1 + 0x3D8) + 2.0;
          result = a1;
          if ( !*(_DWORD *)(a1 + 0x3D4) )
          {
            v7 = sub_14643C990(qword_149D36798);
            src_[0] = sub_1460795C0;
            LODWORD(src_[1]) = 0;
            qmemcpy(dst_, src_, sizeof(dst_));
            sub_1414FBA20(v12, a1, 0, dst_, 0x10u);
            v12[3] = sub_143DF1FC0;
            v5 = (__m256 *)v12;
            src__1[0] = sub_1460793B0;
            LODWORD(src__1[1]) = 0;
            qmemcpy(dst__1, src__1, sizeof(dst__1));
            sub_1414FBA20(&v13, a1, 0, dst__1, 0x10u);
            *(_QWORD *)&v13.m256_f32[6] = sub_143DF1FC0;
            v6 = &v13;
            v3 = 0;
            result = sub_14303E790(v7, 0x53, &v3, &v13, v5, (__int64)"CSCItemMiningController::UpdateFPSTargetHint");
            *(_DWORD *)(a1 + 0x3D4) = result;
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1460BFFE0 (0x1460BFFE0) ---

// --- Function: sub_1460C0230 (0x1460C0230) ---
__int64 __fastcall sub_1460C0230(__int64 a1, float a2)
{
  __int64 v2; // rax
  float v3; // xmm0_4
  float v4; // kr00_4
  __int64 v6; // r8
  unsigned __int64 *v9; // [rsp+48h] [rbp-5D0h]
  double v10; // [rsp+50h] [rbp-5C8h]
  float v11; // [rsp+58h] [rbp-5C0h] BYREF
  float v12; // [rsp+5Ch] [rbp-5BCh]
  float v13; // [rsp+60h] [rbp-5B8h]
  float v14; // [rsp+68h] [rbp-5B0h]
  float v15; // [rsp+70h] [rbp-5A8h]
  float *v16; // [rsp+78h] [rbp-5A0h]
  double dst__5[3]; // [rsp+80h] [rbp-598h] BYREF
  float v18; // [rsp+98h] [rbp-580h]
  float v19; // [rsp+9Ch] [rbp-57Ch]
  float v20; // [rsp+A0h] [rbp-578h]
  float v21; // [rsp+A4h] [rbp-574h]
  float v22; // [rsp+A8h] [rbp-570h]
  double v23; // [rsp+B0h] [rbp-568h]
  double v24; // [rsp+B8h] [rbp-560h]
  double v25; // [rsp+C0h] [rbp-558h]
  float v26[4]; // [rsp+C8h] [rbp-550h] BYREF
  unsigned __int64 *v27; // [rsp+D8h] [rbp-540h]
  float *src; // [rsp+E0h] [rbp-538h]
  float dst__4[3]; // [rsp+E8h] [rbp-530h] BYREF
  float v30; // [rsp+F8h] [rbp-520h]
  float v31; // [rsp+100h] [rbp-518h]
  float v32; // [rsp+104h] [rbp-514h]
  float v33; // [rsp+108h] [rbp-510h]
  float v34; // [rsp+10Ch] [rbp-50Ch] BYREF
  float v35; // [rsp+110h] [rbp-508h] BYREF
  float v36; // [rsp+118h] [rbp-500h]
  float v37; // [rsp+120h] [rbp-4F8h]
  float v38; // [rsp+128h] [rbp-4F0h]
  float v39; // [rsp+130h] [rbp-4E8h]
  float v40; // [rsp+138h] [rbp-4E0h]
  double v41; // [rsp+140h] [rbp-4D8h]
  double v42; // [rsp+148h] [rbp-4D0h]
  char *v43; // [rsp+150h] [rbp-4C8h]
  unsigned __int64 *v44; // [rsp+158h] [rbp-4C0h]
  double *dst; // [rsp+160h] [rbp-4B8h]
  double *dst_2; // [rsp+168h] [rbp-4B0h]
  double *dst_1; // [rsp+170h] [rbp-4A8h]
  double v48; // [rsp+178h] [rbp-4A0h]
  float v49; // [rsp+180h] [rbp-498h]
  double v50; // [rsp+188h] [rbp-490h]
  __int64 v51; // [rsp+1A8h] [rbp-470h] BYREF
  __int64 v52; // [rsp+1B0h] [rbp-468h]
  __int64 v53; // [rsp+1B8h] [rbp-460h]
  double v54; // [rsp+1C0h] [rbp-458h]
  __int64 v55; // [rsp+1C8h] [rbp-450h] BYREF
  __int64 v56; // [rsp+1D0h] [rbp-448h]
  __int64 v57; // [rsp+1D8h] [rbp-440h]
  __int64 v58; // [rsp+1E0h] [rbp-438h]
  __int64 v59; // [rsp+1E8h] [rbp-430h]
  float v60[4]; // [rsp+1F0h] [rbp-428h] BYREF
  double v61; // [rsp+200h] [rbp-418h]
  double v62; // [rsp+208h] [rbp-410h]
  double v63; // [rsp+210h] [rbp-408h]
  double v64; // [rsp+218h] [rbp-400h]
  double v65; // [rsp+220h] [rbp-3F8h]
  double v66; // [rsp+228h] [rbp-3F0h]
  double *src_3; // [rsp+230h] [rbp-3E8h]
  double v68; // [rsp+238h] [rbp-3E0h]
  double v69; // [rsp+240h] [rbp-3D8h]
  double v70; // [rsp+248h] [rbp-3D0h]
  double *src_4; // [rsp+250h] [rbp-3C8h]
  double *src_2; // [rsp+258h] [rbp-3C0h]
  unsigned __int64 *v73; // [rsp+260h] [rbp-3B8h]
  unsigned __int64 *v74; // [rsp+268h] [rbp-3B0h]
  void (__fastcall *v75)(__int64, __int64 *); // [rsp+270h] [rbp-3A8h]
  unsigned int (__fastcall *v76)(__int64, _BYTE *); // [rsp+278h] [rbp-3A0h]
  float *src_5; // [rsp+280h] [rbp-398h]
  void (__fastcall *v78)(__int64, double *, __int64); // [rsp+288h] [rbp-390h]
  double v79; // [rsp+290h] [rbp-388h]
  double v80; // [rsp+298h] [rbp-380h]
  double v81; // [rsp+2A0h] [rbp-378h]
  double v82; // [rsp+2A8h] [rbp-370h]
  double v83; // [rsp+2B0h] [rbp-368h]
  double v84; // [rsp+2B8h] [rbp-360h]
  double v85; // [rsp+2C0h] [rbp-358h]
  double v86; // [rsp+2C8h] [rbp-350h]
  double v87; // [rsp+2D0h] [rbp-348h]
  double v88; // [rsp+2D8h] [rbp-340h]
  double v89; // [rsp+2E0h] [rbp-338h]
  double v90; // [rsp+2E8h] [rbp-330h]
  double v91; // [rsp+2F0h] [rbp-328h]
  double v92; // [rsp+2F8h] [rbp-320h]
  double v93; // [rsp+300h] [rbp-318h]
  double v94; // [rsp+308h] [rbp-310h]
  void (__fastcall *v95)(__int64, double *, _QWORD, _QWORD, char); // [rsp+310h] [rbp-308h]
  double v96; // [rsp+318h] [rbp-300h]
  double v97; // [rsp+320h] [rbp-2F8h]
  double v98; // [rsp+328h] [rbp-2F0h]
  double *src_1; // [rsp+330h] [rbp-2E8h]
  double v100; // [rsp+338h] [rbp-2E0h]
  double v101; // [rsp+340h] [rbp-2D8h]
  double v102; // [rsp+348h] [rbp-2D0h]
  double v103; // [rsp+350h] [rbp-2C8h]
  double v104; // [rsp+358h] [rbp-2C0h]
  double v105; // [rsp+360h] [rbp-2B8h]
  double v106; // [rsp+368h] [rbp-2B0h]
  double v107; // [rsp+370h] [rbp-2A8h]
  double v108; // [rsp+378h] [rbp-2A0h]
  double src_[3]; // [rsp+380h] [rbp-298h] BYREF
  double dst_[3]; // [rsp+398h] [rbp-280h] BYREF
  double src__3[3]; // [rsp+3B0h] [rbp-268h] BYREF
  double src__1[3]; // [rsp+3C8h] [rbp-250h] BYREF
  double dst__1[3]; // [rsp+3E0h] [rbp-238h] BYREF
  double src__2[3]; // [rsp+3F8h] [rbp-220h] BYREF
  double v115; // [rsp+410h] [rbp-208h] BYREF
  double v116; // [rsp+418h] [rbp-200h]
  double v117; // [rsp+420h] [rbp-1F8h]
  double src__6[3]; // [rsp+428h] [rbp-1F0h] BYREF
  double src__5[3]; // [rsp+440h] [rbp-1D8h] BYREF
  double v120; // [rsp+460h] [rbp-1B8h] BYREF
  double v121; // [rsp+468h] [rbp-1B0h]
  double v122; // [rsp+470h] [rbp-1A8h]
  double v123; // [rsp+478h] [rbp-1A0h]
  double v124; // [rsp+480h] [rbp-198h]
  double v125; // [rsp+488h] [rbp-190h]
  double v126; // [rsp+490h] [rbp-188h]
  __m128 v127; // [rsp+4A0h] [rbp-178h]
  __m128 v128; // [rsp+4C0h] [rbp-158h]
  __m128 v129; // [rsp+4D0h] [rbp-148h]
  __m128 v130; // [rsp+4E0h] [rbp-138h]
  double dst__2[3]; // [rsp+4F0h] [rbp-128h] BYREF
  double dst__3[3]; // [rsp+508h] [rbp-110h] BYREF
  _BYTE v133[16]; // [rsp+520h] [rbp-F8h] BYREF
  _BYTE v134[32]; // [rsp+530h] [rbp-E8h] BYREF
  _BYTE src__4[12]; // [rsp+550h] [rbp-C8h] BYREF
  __m128 v136; // [rsp+5E0h] [rbp-38h]

  sub_1402B07F0(&v55, (__int64)"CSCItemMiningController::UpdateGatheringBeamMovements", a1 + 0x5F0, 1);
  v53 = a1 + 0x630;
  v2 = (*(_QWORD *)(a1 + 0x638) - *(_QWORD *)(a1 + 0x630)) / 0x28LL;
  if ( v2 < 0 )
  {
    v4 = (float)(v2 & 1 | ((unsigned __int64)v2 >> 1));
    v3 = v4 + v4;
  }
  else
  {
    v3 = (float)v2;
  }
  v14 = v3;
  v19 = (float)*(int *)(a1 + 0x628);
  v50 = *(double *)(a1 + 0x610) * *(double *)(a1 + 0x610);
  if ( !sub_146067EB0(a1) || v14 < 0.00000011920929 || v19 < 0.00000011920929 || v50 < 2.220446049250313e-16 )
    return sub_1402B3C20(&v55);
  v56 = sub_1403103B0((_QWORD *)(a1 + 0x600));
  v95 = *(void (__fastcall **)(__int64, double *, _QWORD, _QWORD, char))(*(_QWORD *)v56 + 0x1E8LL);
  v95(v56, &v120, 0, 0, 1);
  v98 = 2.0 * (v122 * v121 + v120 * v123);
  v97 = 2.0 * (v121 * v121 + v123 * v123) - 1.0;
  v96 = 2.0 * (v120 * v121 - v122 * v123);
  src_[0] = v96;
  src_[1] = v97;
  src_[2] = v98;
  src_1 = src_;
  v41 = *(double *)(a1 + 0x618);
  qmemcpy(dst_, src_, sizeof(dst_));
  v100 = dst_[0] * v41;
  v101 = dst_[1] * v41;
  v102 = dst_[2] * v41;
  v63 = v126 + dst_[2] * v41;
  v62 = v125 + dst_[1] * v41;
  v61 = v124 + dst_[0] * v41;
  src__3[0] = v61;
  src__3[1] = v62;
  src__3[2] = v63;
  src_2 = src__3;
  v66 = v98;
  v65 = v97;
  v64 = v96;
  src__1[0] = v96;
  src__1[1] = v97;
  src__1[2] = v98;
  src_3 = src__1;
  v42 = *(double *)(a1 + 0x620);
  qmemcpy(dst__1, src__1, sizeof(dst__1));
  v103 = dst__1[0] * v42;
  v104 = dst__1[1] * v42;
  v105 = dst__1[2] * v42;
  v70 = v126 + dst__1[2] * v42;
  v69 = v125 + dst__1[1] * v42;
  v68 = v124 + dst__1[0] * v42;
  src__2[0] = v68;
  src__2[1] = v69;
  src__2[2] = v70;
  src_4 = src__2;
  qmemcpy(dst__2, src__2, sizeof(dst__2));
  qmemcpy(dst__3, src__3, sizeof(dst__3));
  v11 = 0.0;
  v12 = 0.0;
  v57 = a1 + 0x630;
  v27 = *(unsigned __int64 **)(a1 + 0x630);
  v73 = *(unsigned __int64 **)(a1 + 0x638);
  while ( v27 != v73 )
  {
    v9 = v27;
    v74 = v27;
    if ( is_valid_handle_typeB_w(v27) )
      goto LABEL_10;
    v58 = sub_1403103B0(v9);
    v75 = *(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v58 + 0x3B8LL);
    v75(v58, &v51);
    if ( HIWORD_w(&v51) )
    {
      sub_1403723E0((__int64)v134);
      v52 = sub_1403103B0(&v51);
      v76 = *(unsigned int (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v52 + 0x28LL);
      if ( !v76(v52, v134) )
        goto LABEL_10;
      qmemcpy(v9 + 1, v9 + 1, 0xCu);
      qmemcpy((char *)v9 + 0x14, src__4, 0xCu);
      if ( a2 <= 0.0 )
      {
        src = (float *)sub_1402B0CA0((__int64)v133);
      }
      else
      {
        v44 = v9 + 1;
        v43 = (char *)v9 + 0x14;
        v39 = *((float *)v9 + 7) - *((float *)v9 + 4);
        v38 = *((float *)v9 + 6) - *((float *)v9 + 3);
        v37 = *((float *)v9 + 5) - *((float *)v9 + 2);
        v60[0] = v37;
        v60[1] = v38;
        v60[2] = v39;
        v16 = v60;
        v49 = v39 * (float)(1.0 / a2);
        v40 = v38 * (float)(1.0 / a2);
        v36 = v37 * (float)(1.0 / a2);
        v26[0] = v36;
        v26[1] = v40;
        v26[2] = v49;
        src = v26;
      }
      src_5 = src;
      qmemcpy(dst__4, src, sizeof(dst__4));
      v30 = (float)((float)(dst__4[0] * dst__4[0]) + (float)(dst__4[1] * dst__4[1])) + (float)(dst__4[2] * dst__4[2]);
      v128 = _mm_shuffle_ps((__m128)LODWORD(v30), (__m128)LODWORD(v30), 0);
      v129 = v128;
      v130 = _mm_sqrt_ps(v128);
      v127 = v130;
      v136 = v130;
      v31 = v130.m128_f32[3];
      v33 = *((float *)v9 + 8) * v130.m128_f32[3];
      v32 = v11;
      v11 = v11 + v33;
    }
    v59 = sub_1403103B0(v9);
    v78 = *(void (__fastcall **)(__int64, double *, __int64))(*(_QWORD *)v59 + 0x2C8LL);
    LOBYTE(v6) = 1;
    v78(v59, &v115, v6);
    dst = dst__2;
    v81 = v117 - dst__2[2];
    v80 = v116 - dst__2[1];
    v79 = v115 - dst__2[0];
    dst__5[0] = v115 - dst__2[0];
    dst__5[1] = v116 - dst__2[1];
    dst__5[2] = v117 - dst__2[2];
    dst_1 = dst__2;
    dst_2 = dst__3;
    v84 = dst__3[2] - dst__2[2];
    v83 = dst__3[1] - dst__2[1];
    v82 = dst__3[0] - dst__2[0];
    v23 = dst__3[0] - dst__2[0];
    v24 = dst__3[1] - dst__2[1];
    v25 = dst__3[2] - dst__2[2];
    v10 = (v115 - dst__2[0]) * (dst__3[0] - dst__2[0])
        + (v116 - dst__2[1]) * (dst__3[1] - dst__2[1])
        + (v117 - dst__2[2]) * (dst__3[2] - dst__2[2]);
    if ( v10 > 0.0 )
    {
      v54 = v23 * v23 + v24 * v24 + v25 * v25;
      if ( v10 < v54 )
      {
        v48 = v10 / v54;
        v90 = v10 / v54 * v25;
        v89 = v10 / v54 * v24;
        v88 = v10 / v54 * v23;
        v106 = v88;
        v107 = v89;
        v108 = v90;
        v93 = dst__5[2] - v90;
        v92 = dst__5[1] - v89;
        v91 = dst__5[0] - v88;
        src__5[0] = dst__5[0] - v88;
        src__5[1] = dst__5[1] - v89;
        src__5[2] = dst__5[2] - v90;
        qmemcpy(dst__5, src__5, sizeof(dst__5));
      }
      else
      {
        v87 = dst__5[2] - v25;
        v86 = dst__5[1] - v24;
        v85 = dst__5[0] - v23;
        src__6[0] = dst__5[0] - v23;
        src__6[1] = dst__5[1] - v24;
        src__6[2] = dst__5[2] - v25;
        qmemcpy(dst__5, src__6, sizeof(dst__5));
      }
    }
    v94 = dst__5[0] * dst__5[0] + dst__5[1] * dst__5[1] + dst__5[2] * dst__5[2];
    if ( v50 > 0.0 )
    {
      _XMM0 = COERCE_UNSIGNED_INT64(v94 / v50);
      __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
      v12 = v12 + *(float *)&_XMM0;
    }
LABEL_10:
    v27 += 5;
  }
  sub_14154B860(a1 + 0x10B0, &v11);
  v13 = 1.0 - (float)(v12 / v14);
  if ( v13 >= 0.0 )
  {
    if ( v13 >= 1.0 )
      v18 = 1.0;
    else
      v18 = v13;
    v22 = v18;
  }
  else
  {
    v22 = 0.0;
  }
  v34 = v22;
  sub_14154B860(a1 + 0x10F8, &v34);
  v15 = v14 / v19;
  if ( (float)(v14 / v19) >= 0.0 )
  {
    if ( v15 >= 1.0 )
      v20 = 1.0;
    else
      v20 = v15;
    v21 = v20;
  }
  else
  {
    v21 = 0.0;
  }
  v35 = v21;
  sub_14154B860(a1 + 0x1140, &v35);
  return sub_1402B3C20(&v55);
}

// --- End Function: sub_1460C0230 (0x1460C0230) ---

// --- Function: sub_1460C4720 (0x1460C4720) ---
__int64 __fastcall sub_1460C4720(__int64 a1)
{
  sub_1460C8CF0(a1);
  return sub_1460BA0E0(a1);
}

// --- End Function: sub_1460C4720 (0x1460C4720) ---

// --- Function: sub_1460C5070 (0x1460C5070) ---
__int64 __fastcall sub_1460C5070(__int64 a1, float a2)
{
  __int64 result; // rax
  int Format; // [rsp+20h] [rbp-5C8h]
  char v4; // [rsp+30h] [rbp-5B8h] BYREF
  float v5; // [rsp+34h] [rbp-5B4h]
  __int64 v6; // [rsp+38h] [rbp-5B0h] BYREF
  __int64 v7; // [rsp+40h] [rbp-5A8h] BYREF
  __int64 v8; // [rsp+48h] [rbp-5A0h]
  __int64 v9; // [rsp+50h] [rbp-598h]
  __int64 v10; // [rsp+58h] [rbp-590h]
  __int64 v11; // [rsp+60h] [rbp-588h]
  __int64 v12; // [rsp+68h] [rbp-580h]
  __int64 v13; // [rsp+70h] [rbp-578h]
  __int64 v14; // [rsp+78h] [rbp-570h]
  __int64 v15; // [rsp+80h] [rbp-568h]
  __int64 v16; // [rsp+88h] [rbp-560h]
  _BYTE v17[8]; // [rsp+90h] [rbp-558h] BYREF
  char v18; // [rsp+98h] [rbp-550h] BYREF
  __int64 v19; // [rsp+A0h] [rbp-548h]
  __int64 v20; // [rsp+A8h] [rbp-540h] BYREF
  void (__fastcall *v21)(__int64, int *); // [rsp+B0h] [rbp-538h]
  int v22[2]; // [rsp+B8h] [rbp-530h] BYREF
  __int64 v23; // [rsp+C0h] [rbp-528h]
  __int64 (__fastcall *v24)(__int64, _BYTE *, _QWORD, _QWORD, int); // [rsp+C8h] [rbp-520h]
  void (__fastcall *v25)(__int64, _BYTE *, const char *); // [rsp+D0h] [rbp-518h]
  __int64 v26; // [rsp+D8h] [rbp-510h]
  void (__fastcall *v27)(__int64, int *, _QWORD *, _QWORD); // [rsp+E0h] [rbp-508h]
  __int64 v28; // [rsp+E8h] [rbp-500h]
  void (__fastcall *v29)(__int64, __int64, _QWORD, _QWORD); // [rsp+F0h] [rbp-4F8h]
  __int64 v30; // [rsp+F8h] [rbp-4F0h]
  __int64 *v31[2]; // [rsp+100h] [rbp-4E8h] BYREF
  _BYTE dst_[24]; // [rsp+110h] [rbp-4D8h] BYREF
  _QWORD v33[3]; // [rsp+128h] [rbp-4C0h] BYREF
  _QWORD dst__2[6]; // [rsp+140h] [rbp-4A8h] BYREF
  __m256i dst__1; // [rsp+170h] [rbp-478h] BYREF
  _BYTE dst__3[48]; // [rsp+190h] [rbp-458h] BYREF
  _BYTE dst__4[48]; // [rsp+1C0h] [rbp-428h] BYREF
  _BYTE v38[64]; // [rsp+1F0h] [rbp-3F8h] BYREF
  _DWORD v39[12]; // [rsp+230h] [rbp-3B8h] BYREF
  int v40[216]; // [rsp+260h] [rbp-388h] BYREF

  result = *(unsigned __int8 *)(a1 + 0x3DC);
  if ( *(_BYTE *)(a1 + 0x3DC) )
  {
    *(float *)(a1 + 0x3E0) = *(float *)(a1 + 0x3E0) - a2;
    result = a1;
    if ( *(float *)(a1 + 0x3E0) < 0.0 )
    {
      *(float *)(a1 + 0x3E0) = *(float *)(a1 + 0x3E0) + 2.0;
      v7 = *(_QWORD *)(a1 + 0x2F8);
      result = Handle::IsValid(&v7);
      if ( (_BYTE)result )
      {
        v30 = v7 & 0xFFFFFFFFFFFFLL;
        result = sub_1439E7780(v7 & 0xFFFFFFFFFFFFLL);
        v8 = result;
        if ( result )
        {
          sub_1427489C0(v8, &v6);
          result = is_valid_handle_typeA(&v6);
          if ( (_BYTE)result )
          {
            v19 = v6 & 0xFFFFFFFFFFFFLL;
            v20 = *(_QWORD *)((v6 & 0xFFFFFFFFFFFFLL) + 8);
            v9 = sub_1403103B0(&v20);
            v21 = *(void (__fastcall **)(__int64, int *))(*(_QWORD *)v9 + 0x650LL);
            v21(v9, v22);
            sub_1403711F0((__int64)v40, 0x7832, *(__int64 *)v22, 0x40, "UpdateNearbyFPSMineableHint");
            v5 = 6.0;
            v23 = v6 & 0xFFFFFFFFFFFFLL;
            v10 = sub_1403E7D30((unsigned __int64 *)((v6 & 0xFFFFFFFFFFFFLL) + 8));
            v24 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD, int))(*(_QWORD *)v10 + 0x1E8LL);
            LOBYTE(Format) = 1;
            qmemcpy(dst_, (const void *)(v24(v10, v38, 0, 0, Format) + 0x20), sizeof(dst_));
            qmemcpy(&dst__1, dst_, 0x18u);
            *(double *)&dst__1.m256i_i64[3] = 6.0;
            sub_1403A8120((__int64)v40, &dst__1);
            v11 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x18);
            v25 = *(void (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)v11 + 0x28LL);
            v25(v11, v17, "Engine.Components.EntityComponentMineable");
            v31[0] = (__int64 *)v17;
            v31[1] = (__int64 *)&v18;
            sub_140362B00((__int64)v39, v31);
            sub_1403A8130((__int64)v40, (__int64)v39);
            sub_140374530(v39);
            v12 = sub_1402C90E0();
            v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x3D0LL))(v12);
            v4 = 0;
            v13 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0xA0);
            v27 = *(void (__fastcall **)(__int64, int *, _QWORD *, _QWORD))(*(_QWORD *)v13 + 0x1C0LL);
            qmemcpy(dst__2, dst_, 0x18u);
            *(float *)&dst__2[3] = 6.0;
            dst__2[4] = v26;
            dst__2[5] = &v4;
            qmemcpy(dst__3, dst__2, sizeof(dst__3));
            qmemcpy(dst__4, dst__3, sizeof(dst__4));
            sub_145FCB6C0(v33, (__int64)dst__4);
            v27(v13, v40, v33, 0);
            sub_1402A5160(v33);
            if ( v4 )
            {
              v14 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x98);
              v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0xA0LL))(v14);
              v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x268LL))(v15);
              v29 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v16 + 0x18LL);
              v28 = 0;
              v29(v16, 0x43, 0, 0);
            }
            return (__int64)sub_140379010((__int64)v40);
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1460C5070 (0x1460C5070) ---

// --- Function: sub_1460C61F0 (0x1460C61F0) ---
__int64 __fastcall sub_1460C61F0(__int64 a1)
{
  __int64 result; // rax
  __int128 n0x42C80000; // xmm0
  __int64 v3; // rax
  bool v5; // [rsp+20h] [rbp-518h]
  bool v6; // [rsp+21h] [rbp-517h] BYREF
  char v7; // [rsp+22h] [rbp-516h] BYREF
  char v8; // [rsp+23h] [rbp-515h] BYREF
  char v9; // [rsp+24h] [rbp-514h] BYREF
  char v10; // [rsp+25h] [rbp-513h] BYREF
  char v11; // [rsp+26h] [rbp-512h] BYREF
  char v12; // [rsp+27h] [rbp-511h] BYREF
  float v13; // [rsp+28h] [rbp-510h] BYREF
  __int64 v14; // [rsp+30h] [rbp-508h]
  __int64 v15; // [rsp+38h] [rbp-500h]
  _QWORD *v16; // [rsp+40h] [rbp-4F8h]
  float v17; // [rsp+48h] [rbp-4F0h] BYREF
  float v18; // [rsp+4Ch] [rbp-4ECh] BYREF
  float v19; // [rsp+50h] [rbp-4E8h] BYREF
  float v20; // [rsp+54h] [rbp-4E4h] BYREF
  float v21; // [rsp+58h] [rbp-4E0h] BYREF
  float v22; // [rsp+5Ch] [rbp-4DCh] BYREF
  float v23; // [rsp+60h] [rbp-4D8h] BYREF
  float v24; // [rsp+64h] [rbp-4D4h] BYREF
  float v25; // [rsp+68h] [rbp-4D0h] BYREF
  unsigned __int32 v26; // [rsp+6Ch] [rbp-4CCh] BYREF
  unsigned __int32 v27; // [rsp+70h] [rbp-4C8h] BYREF
  float v28; // [rsp+74h] [rbp-4C4h] BYREF
  float v29; // [rsp+78h] [rbp-4C0h] BYREF
  __int64 v30; // [rsp+80h] [rbp-4B8h]
  __int64 v31; // [rsp+88h] [rbp-4B0h]
  __int64 v32; // [rsp+90h] [rbp-4A8h]
  __int64 v33; // [rsp+98h] [rbp-4A0h]
  __int64 *v34; // [rsp+A0h] [rbp-498h]
  __int64 v35; // [rsp+A8h] [rbp-490h]
  __int64 v36; // [rsp+B0h] [rbp-488h]
  __int64 v37; // [rsp+B8h] [rbp-480h]
  __int64 v38; // [rsp+C0h] [rbp-478h]
  __int64 v39; // [rsp+C8h] [rbp-470h]
  __int64 v40; // [rsp+D0h] [rbp-468h]
  __int64 v41; // [rsp+D8h] [rbp-460h]
  __int64 v42; // [rsp+E0h] [rbp-458h]
  __int64 v43; // [rsp+E8h] [rbp-450h]
  __int64 v44; // [rsp+F0h] [rbp-448h]
  __int64 (__fastcall *v45)(__int64, _QWORD); // [rsp+F8h] [rbp-440h]
  __int64 *v46; // [rsp+100h] [rbp-438h]
  __int64 v47; // [rsp+108h] [rbp-430h]
  __int64 v48; // [rsp+110h] [rbp-428h]
  __int64 v49; // [rsp+118h] [rbp-420h]
  __int64 v50; // [rsp+120h] [rbp-418h]
  __int64 v51; // [rsp+128h] [rbp-410h]
  __int64 v52; // [rsp+130h] [rbp-408h]
  __int64 v53; // [rsp+138h] [rbp-400h] BYREF
  _QWORD *v54; // [rsp+140h] [rbp-3F8h]
  __int64 v55; // [rsp+148h] [rbp-3F0h]
  __int64 v57; // [rsp+158h] [rbp-3E0h]
  __int64 v58; // [rsp+160h] [rbp-3D8h]
  __int64 v59; // [rsp+168h] [rbp-3D0h]
  __int64 v60; // [rsp+170h] [rbp-3C8h]
  __int64 v61; // [rsp+178h] [rbp-3C0h]
  _QWORD v62[2]; // [rsp+180h] [rbp-3B8h] BYREF
  __int64 v63[2]; // [rsp+190h] [rbp-3A8h] BYREF
  _BYTE v64[16]; // [rsp+1A0h] [rbp-398h] BYREF
  _QWORD v65[9]; // [rsp+1B0h] [rbp-388h] BYREF
  _BYTE v66[72]; // [rsp+1F8h] [rbp-340h] BYREF
  _BYTE v67[72]; // [rsp+240h] [rbp-2F8h] BYREF
  _BYTE v68[80]; // [rsp+288h] [rbp-2B0h] BYREF
  _BYTE v69[72]; // [rsp+2D8h] [rbp-260h] BYREF
  _BYTE v70[80]; // [rsp+320h] [rbp-218h] BYREF
  _QWORD v71[9]; // [rsp+370h] [rbp-1C8h] BYREF
  _BYTE v72[72]; // [rsp+3B8h] [rbp-180h] BYREF
  _BYTE v73[72]; // [rsp+400h] [rbp-138h] BYREF
  _BYTE v74[80]; // [rsp+448h] [rbp-F0h] BYREF
  _BYTE v75[72]; // [rsp+498h] [rbp-A0h] BYREF
  _BYTE v76[88]; // [rsp+4E0h] [rbp-58h] BYREF

  v5 = !(unsigned __int8)sub_1403216E0(a1 + 0x9F0) || !(unsigned __int8)sub_1403216E0(a1 + 0x840);
  v6 = v5;
  sub_14154B820(a1 + 0xA80, &v6);
  result = (unsigned __int8)sub_1403216E0(a1 + 0x840);
  if ( (_BYTE)result )
  {
    result = is_valid_handle_typeA((__int64 *)(a1 + 0x2E0));
    if ( (_BYTE)result )
    {
      v17 = 1.0;
      sub_14154B860(a1 + 0xBE8, &v17);
      v7 = 0;
      sub_14154B820(a1 + 0x7F8, &v7);
      v18 = 1.0;
      sub_14154B860(a1 + 0x1188, &v18);
      v37 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      v19 = sub_143C161F0(v37);
      sub_14154B860(a1 + 0xE28, &v19);
      v38 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      v20 = sub_143C0FA10(v38, 1);
      sub_14154B860(a1 + 0xF00, &v20);
      v39 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      v21 = sub_143C0FA10(v39, 0);
      sub_14154B860(a1 + 0xF90, &v21);
      v8 = 1;
      sub_14154B820(a1 + 0x918, &v8);
      v40 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      v22 = sub_143C13E60(v40, 1);
      sub_14154B860(a1 + 0xEB8, &v22);
      v41 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      v23 = sub_143C13E60(v41, 0);
      sub_14154B860(a1 + 0xF48, &v23);
      v9 = 1;
      sub_14154B820(a1 + 0x8D0, &v9);
      v42 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      if ( (unsigned __int8)sub_143C32520(v42) )
      {
        v24 = 0.0;
        sub_14154B860(a1 + 0xFD8, &v24);
        v25 = 0.0;
        sub_14154B860(a1 + 0x1020, &v25);
      }
      else
      {
        v43 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
        v26 = sub_143C0F9F0(v43).m128_u32[0];
        sub_14154B860(a1 + 0xFD8, &v26);
        v44 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
        v27 = sub_143C0F9D0(v44).m128_u32[0];
        sub_14154B860(a1 + 0x1020, &v27);
      }
      sub_1460D9360(a1 + 0x27C0);
      n0x42C80000 = 0x42C80000u;
      v13 = 100.0;
      if ( sub_1414FDE20(a1 + 0xBE8) == 0.0 )
      {
        v33 = 0;
      }
      else
      {
        v32 = *(_QWORD *)(sub_1402A4B80((__int64)&qword_149A141F0) + 0x60);
        v45 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v32 + 0x38LL);
        v46 = (__int64 *)v45(v32, 0);
        v47 = *v46;
        v33 = v47;
      }
      v36 = v33;
      v48 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      v3 = sub_143C16120(v48, (__int64)v64);
      *(double *)&n0x42C80000 = sub_1403B02B0(v3);
      __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
      v28 = *(float *)&_XMM0;
      sub_14154B860(a1 + 0xE70, &v28);
      v49 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
      v34 = (__int64 *)sub_143C0D8C0(v49);
      v14 = *v34;
      v50 = v34[1];
      while ( 1 )
      {
        result = v50;
        if ( v14 == v50 )
          break;
        v15 = v14;
        sub_14600D280(v65);
        sub_14154B860((__int64)v66, (_DWORD *)(v15 + 0x28));
        v13 = v13 - *(float *)(v15 + 0x28);
        sub_14154B860((__int64)v67, (_DWORD *)(v15 + 0x2C));
        v10 = 0;
        sub_14154B820((__int64)v69, &v10);
        v51 = *(_QWORD *)(v15 + 0x20);
        v52 = *(_QWORD *)(v51 + 0x18);
        v30 = v52;
        if ( v52 )
        {
          GetLocalizedNameFromKey(&v53, (unsigned __int8 **)(v30 + 8));
          sub_14030F6D0((__int64)v68);
          sub_1402AE1F0(&v53);
          v31 = v30 + 0x38;
          v16 = *(_QWORD **)(v30 + 0x48);
          v54 = (_QWORD *)(*(_QWORD *)(v30 + 0x48) + 0x10LL * *(_QWORD *)(v30 + 0x50));
          while ( v16 != v54 )
          {
            sub_1403644B0((__int64)v63, v16);
            v55 = v63[0];
            if ( sub_14299C760(v63[0]) )
            {
              v11 = 1;
              sub_14154B820((__int64)v69, &v11);
              sub_1403728F0((__int64)v63);
              break;
            }
            sub_1403728F0((__int64)v63);
            v16 += 2;
          }
        }
        sub_14030F6B0((__int64)v70);
        v57 = a1 + 0x27C0;
        sub_1460E16B0(a1 + 0x27C0, v65);
        sub_1460169E0(v65);
        v14 += 0x50;
      }
      if ( v13 > 0.0 )
      {
        sub_14600D280(v71);
        v58 = *(_QWORD *)(a1 + 0x2E0) & 0xFFFFFFFFFFFFLL;
        v59 = sub_140334DC0(v58);
        v60 = *(_QWORD *)(v59 + 0x28);
        v35 = v60;
        if ( v60 )
        {
          v61 = *(_QWORD *)(v35 + 0x2F0);
          GetLocalizedNameFromKey(v62, (unsigned __int8 **)(v61 + 8));
          sub_14030F6D0((__int64)v74);
          sub_1402AE1F0(v62);
        }
        sub_14154B860((__int64)v72, &v13);
        v29 = 0.0;
        sub_14154B860((__int64)v73, &v29);
        v12 = 0;
        sub_14154B820((__int64)v75, &v12);
        sub_14030F6B0((__int64)v76);
        v62[1] = a1 + 0x27C0;
        sub_1460E16B0(a1 + 0x27C0, v71);
        return sub_1460169E0(v71);
      }
    }
  }
  return result;
}

// --- End Function: sub_1460C61F0 (0x1460C61F0) ---

// --- Function: sub_1460C8CF0 (0x1460C8CF0) ---
char __fastcall sub_1460C8CF0(__int64 a1)
{
  char result; // al
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // r9
  __int64 v5; // r9
  bool v6; // [rsp+30h] [rbp-208h]
  char v7; // [rsp+31h] [rbp-207h]
  char v8; // [rsp+32h] [rbp-206h]
  __int64 v9; // [rsp+40h] [rbp-1F8h] BYREF
  __int64 v10; // [rsp+48h] [rbp-1F0h]
  __int64 v11[2]; // [rsp+50h] [rbp-1E8h] BYREF
  int v12; // [rsp+60h] [rbp-1D8h]
  int v13; // [rsp+64h] [rbp-1D4h]
  int v14; // [rsp+68h] [rbp-1D0h]
  int v15; // [rsp+6Ch] [rbp-1CCh]
  __int64 v16; // [rsp+70h] [rbp-1C8h]
  __int64 v17; // [rsp+78h] [rbp-1C0h] BYREF
  unsigned __int64 v18; // [rsp+80h] [rbp-1B8h] BYREF
  __int64 v19; // [rsp+88h] [rbp-1B0h] BYREF
  __int64 v20[3]; // [rsp+90h] [rbp-1A8h] BYREF
  float *v21; // [rsp+A8h] [rbp-190h]
  float v22[4]; // [rsp+B0h] [rbp-188h] BYREF
  __int64 v23; // [rsp+C0h] [rbp-178h]
  __int64 v24; // [rsp+C8h] [rbp-170h]
  __int64 v25; // [rsp+D0h] [rbp-168h]
  __int64 v26; // [rsp+D8h] [rbp-160h]
  __int64 *v27; // [rsp+E0h] [rbp-158h]
  __int64 v28; // [rsp+E8h] [rbp-150h]
  __int64 v29; // [rsp+F0h] [rbp-148h]
  __int64 v30; // [rsp+F8h] [rbp-140h]
  __int64 v31; // [rsp+100h] [rbp-138h]
  __int64 v32; // [rsp+108h] [rbp-130h]
  __int64 v33; // [rsp+110h] [rbp-128h]
  __int64 v34; // [rsp+118h] [rbp-120h]
  __int64 v35; // [rsp+120h] [rbp-118h]
  struct __crt_stdio_stream *v36; // [rsp+128h] [rbp-110h]
  __int64 v37; // [rsp+130h] [rbp-108h]
  struct __crt_stdio_stream *v38; // [rsp+138h] [rbp-100h]
  __int64 v39; // [rsp+140h] [rbp-F8h] BYREF
  __int64 v40; // [rsp+148h] [rbp-F0h] BYREF
  __int64 v41; // [rsp+150h] [rbp-E8h]
  __int64 v42; // [rsp+158h] [rbp-E0h]
  __int64 v43; // [rsp+160h] [rbp-D8h]
  __int64 v44; // [rsp+168h] [rbp-D0h]
  __int64 v45; // [rsp+170h] [rbp-C8h]
  __int64 v46; // [rsp+178h] [rbp-C0h]
  unsigned __int64 v47; // [rsp+180h] [rbp-B8h]
  unsigned __int64 v48; // [rsp+188h] [rbp-B0h]
  __int64 v49; // [rsp+190h] [rbp-A8h]
  unsigned __int64 v50; // [rsp+198h] [rbp-A0h]
  __int64 v51; // [rsp+1A0h] [rbp-98h]
  __int64 v52; // [rsp+1A8h] [rbp-90h]
  __int64 v53; // [rsp+1B0h] [rbp-88h]
  __int64 v54; // [rsp+1B8h] [rbp-80h]
  __int64 v55; // [rsp+1C0h] [rbp-78h]
  __int64 v56; // [rsp+1C8h] [rbp-70h]
  float *v57; // [rsp+1D0h] [rbp-68h]
  __int64 v58; // [rsp+1D8h] [rbp-60h]
  __int64 v59; // [rsp+1E0h] [rbp-58h]
  __int64 v60; // [rsp+1E8h] [rbp-50h]
  __int64 v61; // [rsp+1F0h] [rbp-48h]
  __int64 v62; // [rsp+1F8h] [rbp-40h]
  unsigned __int64 v63; // [rsp+200h] [rbp-38h]
  unsigned __int64 v64; // [rsp+208h] [rbp-30h]
  unsigned __int64 v65; // [rsp+210h] [rbp-28h]
  unsigned __int64 v66; // [rsp+218h] [rbp-20h]
  __int64 v67; // [rsp+220h] [rbp-18h]
  __int64 v68; // [rsp+228h] [rbp-10h] BYREF

  v52 = sub_140334DC0(a1);
  v23 = *(_QWORD *)(v52 + 0x50);
  result = v23 != 0;
  if ( v23 )
  {
    v20[0] = *(_QWORD *)(a1 + 0x2E0);
    v11[0] = 0;
    v9 = *(_QWORD *)(a1 + 0x2F8);
    if ( Handle::IsValid(&v9) )
    {
      v6 = 0;
      v24 = v9 & 0xFFFFFFFFFFFFLL;
      v16 = sub_1409144C0(v9 & 0xFFFFFFFFFFFFLL);
      if ( v16 )
        v6 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x40LL))(v16) == 6;
      v25 = v9 & 0xFFFFFFFFFFFFLL;
      v10 = sub_1439E7780(v9 & 0xFFFFFFFFFFFFLL);
      if ( v10 )
      {
        if ( is_valid_handle_typeA(v20) )
        {
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x5F8LL))(v10) )
          {
            v26 = v9 & 0xFFFFFFFFFFFFLL;
            if ( sub_1439F0470(v9 & 0xFFFFFFFFFFFFLL) || v6 )
            {
              v27 = sub_142745650(v10, &v68);
              v28 = *v27;
              v17 = v28;
              if ( is_valid_handle_typeA(&v17) )
              {
                v29 = v17 & 0xFFFFFFFFFFFFLL;
                AssetMeta::OpenActorSubresource(v17 & 0xFFFFFFFFFFFFLL, &v19);
                if ( is_valid_handle_typeA(&v19) )
                {
                  v30 = v17 & 0xFFFFFFFFFFFFLL;
                  v2 = sub_14654BC00(v17 & 0xFFFFFFFFFFFFLL);
                  if ( !(unsigned __int8)sub_144A49240(v2) )
                  {
                    v31 = v19 & 0xFFFFFFFFFFFFLL;
                    v3 = sub_1458BA2A0(v19 & 0xFFFFFFFFFFFFLL);
                    if ( !(unsigned __int8)sub_14612C0F0(v3) )
                      v11[0] = v20[0];
                  }
                }
              }
            }
          }
        }
      }
    }
    result = sub_142685DF0(v11, (_QWORD *)(a1 + 0x2E8));
    if ( result )
    {
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x2E8)) )
      {
        v32 = *(_QWORD *)(a1 + 0x2E8) & 0xFFFFFFFFFFFFLL;
        v18 = *(_QWORD *)(v32 + 8);
        sub_143BD68A0(v18);
        v33 = sub_140334DC0(a1);
        v34 = *(_QWORD *)(v33 + 0x50);
        if ( *(float *)(v34 + 0x70) > 0.0 )
        {
          v20[1] = a1 + 0x370;
          v35 = a1 + 0x370;
          v36 = (struct __crt_stdio_stream *)sub_145CB97E0(a1 + 0x370, (__int64)&v18);
          _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
            (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&v40,
            v36);
          v37 = a1 + 0x370;
          v20[2] = a1 + 0x370;
          v38 = *(struct __crt_stdio_stream **)(a1 + 0x370);
          _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
            (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&v39,
            v38);
          if ( v40 != v39 )
          {
            v41 = sub_140334DC0(a1);
            v42 = *(_QWORD *)(v41 + 0x50);
            v12 = *(_DWORD *)(v42 + 0x6C);
            v43 = sub_140334DC0(a1);
            v44 = *(_QWORD *)(v43 + 0x50);
            v13 = *(_DWORD *)(v44 + 0x68);
            v45 = sub_140334DC0(a1);
            v46 = *(_QWORD *)(v45 + 0x50);
            v49 = v46 + 0x40;
            v7 = *(_BYTE *)(a1 + 0x3DC);
            v47 = v18;
            v48 = v18;
            v50 = v18;
            sub_143C978C0(v18, v7, (float *)(v46 + 0x40), v4, v12);
          }
        }
        v51 = a1 + 0x2E8;
        *(_QWORD *)(a1 + 0x2E8) = 0;
      }
      result = is_valid_handle_typeA(v11);
      if ( result )
      {
        *(_QWORD *)(a1 + 0x2E8) = v11[0];
        v60 = *(_QWORD *)(a1 + 0x2E8) & 0xFFFFFFFFFFFFLL;
        if ( (unsigned __int8)sub_143C32520(v60) )
        {
          v53 = sub_140334DC0(a1);
          v54 = *(_QWORD *)(v53 + 0x50);
          v21 = (float *)(v54 + 0x20);
        }
        else
        {
          v55 = sub_140334DC0(a1);
          v56 = *(_QWORD *)(v55 + 0x50);
          v21 = (float *)(v56 + 8);
        }
        v57 = v21;
        v11[1] = (__int64)(v21 + 2);
        v22[0] = v21[2];
        v22[1] = v21[3];
        v22[2] = v21[4];
        v22[3] = v21[5];
        v58 = sub_140334DC0(a1);
        v59 = *(_QWORD *)(v58 + 0x50);
        v14 = *(_DWORD *)(v59 + 0x6C);
        v67 = sub_140334DC0(a1);
        v61 = *(_QWORD *)(v67 + 0x50);
        v15 = *(_DWORD *)(v61 + 0x68);
        v8 = *(_BYTE *)(a1 + 0x3DC);
        v62 = *(_QWORD *)(a1 + 0x2E8) & 0xFFFFFFFFFFFFLL;
        v63 = *(_QWORD *)(v62 + 8);
        v64 = v63;
        v65 = v63;
        v66 = v63;
        return sub_143C978C0(v63, v8, v22, v5, v14);
      }
    }
  }
  return result;
}

// --- End Function: sub_1460C8CF0 (0x1460C8CF0) ---

// --- Function: sub_1460D9360 (0x1460D9360) ---
__int64 __fastcall sub_1460D9360(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 0x60) == *(_QWORD *)(a1 + 0x68);
  if ( *(_QWORD *)(a1 + 0x60) != *(_QWORD *)(a1 + 0x68) )
  {
    if ( *(_BYTE *)(a1 + 0x58) )
      sub_1403E58B0((__int64 *)(a1 + 0x40));
    sub_1460D9860(a1 + 0x60);
    return sub_140331AE0(a1, 0);
  }
  return result;
}

// --- End Function: sub_1460D9360 (0x1460D9360) ---

// --- Function: sub_1460D9860 (0x1460D9860) ---
Parameter *__fastcall sub_1460D9860(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  void (__fastcall ***i)(_QWORD, _QWORD); // [rsp+20h] [rbp-48h]
  Parameter *Parameter_2; // [rsp+30h] [rbp-38h]
  void (__fastcall ***v5)(_QWORD, _QWORD); // [rsp+48h] [rbp-20h]

  Parameter_2 = Parameter + 1;
  Parameter_1 = Parameter;
  if ( *Parameter != Parameter[1] )
  {
    _StarEngineModule__((ULONG_PTR)Parameter);
    v5 = (void (__fastcall ***)(_QWORD, _QWORD))*Parameter_2;
    for ( i = (void (__fastcall ***)(_QWORD, _QWORD))*Parameter; i != v5; i += 0x38 )
      (**i)(i, 0);
    Parameter_1 = Parameter_2;
    *Parameter_2 = *Parameter;
  }
  return Parameter_1;
}

// --- End Function: sub_1460D9860 (0x1460D9860) ---

// --- Function: sub_1460E16B0 (0x1460E16B0) ---
__int64 __fastcall sub_1460E16B0(__int64 a1, __int64 a2)
{
  _QWORD v3[2]; // [rsp+50h] [rbp-68h] BYREF
  unsigned __int64 v4; // [rsp+60h] [rbp-58h]
  __int64 v5; // [rsp+68h] [rbp-50h]
  __int64 v6; // [rsp+70h] [rbp-48h]
  __int64 v7; // [rsp+78h] [rbp-40h]
  __int64 v8; // [rsp+80h] [rbp-38h]
  __int64 v9; // [rsp+88h] [rbp-30h]
  __int64 v10; // [rsp+90h] [rbp-28h]
  __int64 v11; // [rsp+98h] [rbp-20h]
  __int64 v12; // [rsp+A0h] [rbp-18h]
  __int64 v13; // [rsp+A8h] [rbp-10h]

  if ( *(_BYTE *)(a1 + 0x58) )
  {
    v3[1] = a1 + 0x40;
    v3[0] = (__int64)(*(_QWORD *)(a1 + 0x48) - *(_QWORD *)(a1 + 0x40)) >> 3;
    sub_140345A10(a1 + 0x40, v3);
  }
  v4 = (*(_QWORD *)(a1 + 0x68) - *(_QWORD *)(a1 + 0x60)) / 0x1C0LL;
  if ( v4 >= (*(_QWORD *)(a1 + 0x70) - *(_QWORD *)(a1 + 0x60)) / 0x1C0LL )
  {
    sub_1436F5140(a1);
    v11 = a1 + 0x60;
    sub_145FE9580(a1 + 0x60, a2);
    v12 = a1 + 0x60;
    v13 = *(_QWORD *)(a1 + 0x68) - 0x1C0LL;
    sub_140324F60(v13);
    sub_1436DC5C0((_LocaleUpdate *)a1);
  }
  else
  {
    v5 = a1 + 0x60;
    sub_145FE9580(a1 + 0x60, a2);
    v6 = a1 + 0x60;
    v7 = *(_QWORD *)(a1 + 0x68) - 0x1C0LL;
    sub_140324F60(v7);
    v9 = (*(_QWORD *)(a1 + 0x68) - *(_QWORD *)(a1 + 0x60)) / 0x1C0LL - 1;
    v8 = a1 + 0x60;
    v10 = *(_QWORD *)(a1 + 0x68) - 0x1C0LL;
    sub_142AE3EA0((_LocaleUpdate *)a1, v10, v9);
  }
  return sub_140331AE0(a1, 0);
}

// --- End Function: sub_1460E16B0 (0x1460E16B0) ---

// --- Function: sub_14612C0F0 (0x14612C0F0) ---
_BOOL8 __fastcall sub_14612C0F0(__int64 a1)
{
  return (unsigned __int8)sub_14612D3F0(a1) || (unsigned __int8)sub_14612DBA0(a1);
}

// --- End Function: sub_14612C0F0 (0x14612C0F0) ---

// --- Function: sub_14643BF40 (0x14643BF40) ---
__int64 __fastcall sub_14643BF40(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xDC0);
}

// --- End Function: sub_14643BF40 (0x14643BF40) ---

// --- Function: sub_14643C990 (0x14643C990) ---
__int64 __fastcall sub_14643C990(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xC58);
}

// --- End Function: sub_14643C990 (0x14643C990) ---

// --- Function: sub_14654B900 (0x14654B900) ---
__int64 __fastcall sub_14654B900(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x258);
}

// --- End Function: sub_14654B900 (0x14654B900) ---

// --- Function: sub_14654BC00 (0x14654BC00) ---
__int64 __fastcall sub_14654BC00(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x258) + 0x68E0LL;
}

// --- End Function: sub_14654BC00 (0x14654BC00) ---

// --- Function: AssetMeta::OpenActorSubresource (0x14654BCA0) ---
_QWORD *__fastcall AssetMeta::OpenActorSubresource(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x5B8);
  return a2;
}

// --- End Function: AssetMeta::OpenActorSubresource (0x14654BCA0) ---

// --- Function: get_tls_byte_at_offset_3401 (0x14741AC00) ---
// Retrieves a byte value from a structure stored in the TLS slot indexed by the
// global `TlsIndex`. Reads a pointer from offset 0xD48 (3400) within the TLS data
// block associated with the slot. If this pointer is valid, returns the byte value
// located at offset +1 relative to this pointer (i.e., at offset 0xD49 or 3401
// relative to the start of the TLS data block). Returns 0 if the pointer at offset
// 0xD48 is NULL.
__int64 get_tls_byte_at_offset_3401()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xD48LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: get_tls_byte_at_offset_3401 (0x14741AC00) ---

// --- Function: sub_147539550 (0x147539550) ---
__int64 __fastcall sub_147539550(__int64 a1)
{
  return sub_147539560(a1, 0);
}

// --- End Function: sub_147539550 (0x147539550) ---

// --- Function: sub_147539CD0 (0x147539CD0) ---
__int64 __fastcall sub_147539CD0(__int64 a1, struct _exception *profilerInfo, __int64 a3)
{
  return sub_147539CE0(a1, profilerInfo, a3, 0);
}

// --- End Function: sub_147539CD0 (0x147539CD0) ---

// --- Function: sub_14753BEF0 (0x14753BEF0) ---
__int64 __fastcall sub_14753BEF0(unsigned __int64 n0x6400000)
{
  char n0x6400000_1; // bl
  _BYTE pExceptionObject[16]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6B00; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  n0x6400000_1 = n0x6400000;
  if ( byte_1515B9F3C == 1 )
  {
    sub_14180FAF0(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149A144B4 = 1;
  ::n0x6400000 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_147517B80(n0x6400000);
  n0x6B00 = 0x6B00;
  v5 = 0;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = 1;
  qword_149A0FD80(&n0x6B00, 0, &Source, &Source, 0);
  sub_147517B80(n0x6400000_1);
  v8 = __rdtsc();
  return qword_149A0FD88(&n0x6B00);
}

// --- End Function: sub_14753BEF0 (0x14753BEF0) ---

// --- Function: sub_14753C530 (0x14753C530) ---
__int64 __fastcall sub_14753C530(const void *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( qword_149A143C8 && qword_149A141F8 && a1 == (const void *)qword_149A141F8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_1499C4808
      || (result = qword_1499C4808 + 0x8000000000LL, (unsigned __int64)a1 >= qword_1499C4808 + 0x8000000000LL) )
    {
      if ( (unsigned __int64)a1 >= qword_1499C47E8 && (unsigned __int64)a1 < qword_1499C47E8 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      return sub_147539550((__int64)a1);
    }
  }
  return result;
}

// --- End Function: sub_14753C530 (0x14753C530) ---

// --- Function: allocWithProfilerInfo (0x14753C5E0) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char tls_byte_at_offset_3401; // al
  unsigned __int8 v5; // bl
  __int64 v6; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    tls_byte_at_offset_3401 = get_tls_byte_at_offset_3401();
    v5 = sub_14056BB30(tls_byte_at_offset_3401);
    v6 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_147539CD0(v6 + allocSize, profilerInfo, v5);
    if ( result )
      return result;
    sub_14753BEF0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x14753C5E0) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147F6990E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147F6990E) ---

// --- Function: __alloca_probe (0x147F6A820) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x147F6A820) ---

// --- Function: __security_check_cookie (0x147F6A880) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x147F6A880) ---

// --- Function: __report_gsfailure (0x147F6AA7C) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_1515EE080 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1515EE070 = 0xC0000409;
  dword_1515EE074 = 1;
  dword_1515EE088 = 1;
  qword_1515EE090[0] = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147F6AA7C) ---

// --- Function: memcpy (0x147FB92AB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x147FB92AB) ---

// --- Function: memmove (0x147FB92B1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x147FB92B1) ---

// --- Function: memset (0x147FB92B7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x147FB92B7) ---

// --- Function: memcmp (0x147FB92D5) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x147FB92D5) ---

// --- Function: acosf (0x147FB93FB) ---
// attributes: thunk
float __cdecl acosf(float X)
{
  return __imp_acosf(X);
}

// --- End Function: acosf (0x147FB93FB) ---

