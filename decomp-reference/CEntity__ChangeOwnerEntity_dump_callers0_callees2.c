// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1468C1420 (CEntity::ChangeOwnerEntity)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 75
// ------------------------------------------------------------

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: sub_1402A2470 (0x1402A2470) ---
void *sub_1402A2470()
{
  return &unk_149808280;
}

// --- End Function: sub_1402A2470 (0x1402A2470) ---

// --- Function: LogTraceConditional (0x1402BED30) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list varargs; // [rsp+38h] [rbp+10h] BYREF

  va_start(varargs, format_string);
  if ( qword_14981D3D8 && CSystem )
  {
    if ( qword_14981D2D0 )
    {
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_14981D2D0 + 8LL))(
        qword_14981D2D0,
        3,
        format_string,
        (__int64 *)varargs);
    }
  }
}

// --- End Function: LogTraceConditional (0x1402BED30) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1402D0950 (0x1402D0950) ---
unsigned __int64 __fastcall sub_1402D0950(__int64 a1)
{
  unsigned __int64 tls_data_offset_784; // rax
  unsigned __int64 v3; // rdx

  tls_data_offset_784 = get_tls_data_offset_784();
  if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(tls_data_offset_784 + 0x18)
    && (tls_data_offset_784 = *(unsigned int *)(a1 + 0xC), (_DWORD)tls_data_offset_784) )
  {
    tls_data_offset_784 = (unsigned int)(tls_data_offset_784 - 1);
    *(_DWORD *)(a1 + 0xC) = tls_data_offset_784;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      tls_data_offset_784 = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
      {
        return sub_1403C6F70((volatile signed __int64 *)a1, v3);
      }
    }
  }
  return tls_data_offset_784;
}

// --- End Function: sub_1402D0950 (0x1402D0950) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !off_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !off_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 ptr_to_free_29,
        __int64 _Newcapacity_1,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 _Newcapacity; // r13
  char result; // al
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  unsigned __int64 v18; // r15
  _QWORD *ptr_to_free_25; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_16; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 ptr_to_free_17; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, unsigned __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *ptr_to_free_20; // r14
  __int64 *p_ptr_to_free_1; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  const vraudio::AudioBuffer *ptr_to_free_18; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *ptr_to_free_1; // r15
  _QWORD *v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *ptr_to_free; // rcx
  __m256 *ptr_to_free_10; // rax
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_21; // rax
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_22; // r14
  __int64 ptr_to_free_23; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  char *v64; // r10
  char *v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 ptr_to_free_11; // rax
  const void *ptr_to_free_3; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  FILE *Stream; // rax
  int n2; // r8d
  FILE *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 ptr_to_free_12; // rax
  const void *ptr_to_free_2; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  FILE *Stream_2; // rax
  FILE *Stream_3; // rax
  const void **ptr_to_free_7; // rsi
  _QWORD **v104; // rcx
  _QWORD *ptr_to_free_5; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *ptr_to_free_6; // rdi
  _QWORD *ptr_to_free_4; // rcx
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_9; // rbx
  _QWORD *ptr_to_free_8; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *ptr_to_free_14; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  char *v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *ptr_to_free_28; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 ptr_to_free_26; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *ptr_to_free_27; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  const vraudio::AudioBuffer *ptr_to_free_19; // [rsp+128h] [rbp+88h] BYREF
  __int64 *p_ptr_to_free; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *ptr_to_free_24; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **ptr_to_free_13; // [rsp+158h] [rbp+B8h] BYREF
  unsigned __int64 v136; // [rsp+160h] [rbp+C0h]
  unsigned __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  ptr_to_free_28 = (_QWORD *)ptr_to_free_29;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  _Newcapacity = _Newcapacity_1;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, ptr_to_free_29, _Newcapacity_1);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  ptr_to_free_13 = 0;
  ptr_to_free_15 = 0;
  p_ptr_to_free = (__int64 *)&ptr_to_free_13;
  n0x400 = 0;
  ptr_to_free_14 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !_Newcapacity_1 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  ptr_to_free_25 = ptr_to_free_28;
  v20 = v112;
  ptr_to_free_27 = ptr_to_free_28;
  while ( 2 )
  {
    v21 = *((_BYTE *)ptr_to_free_25 + 0x59) == 0;
    ptr_to_free_24 = ptr_to_free_25;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = ptr_to_free_25;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    ptr_to_free_26 = (unsigned __int64)ptr_to_free_25;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = ptr_to_free_25;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !ptr_to_free_15 )
      {
        __asm { vzeroupper }
        ptr_to_free_14 = (std::vector<vraudio::AudioBuffer const *> *)allocWithoutProfiling(0x18u);
        ptr_to_free_15 = ptr_to_free_14;
        if ( ptr_to_free_14 )
        {
          ptr_to_free_16 = ptr_to_free_14;
          *(_QWORD *)ptr_to_free_14 = 0;
          n0x400_1 = 0;
          *((_QWORD *)ptr_to_free_15 + 1) = 0;
          ptr_to_free_17 = (__int64)ptr_to_free_15;
          *((_QWORD *)ptr_to_free_15 + 2) = 0;
        }
        else
        {
          ptr_to_free_15 = 0;
          ptr_to_free_16 = 0;
          n0x400_1 = 0;
          ptr_to_free_14 = 0;
          ptr_to_free_17 = 0;
        }
        sub_140302260(ptr_to_free_17, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v141;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_16 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)ptr_to_free_16 + 2) )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              ptr_to_free_15,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)ptr_to_free_16 + 1) += 8LL;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        ptr_to_free_25 = ptr_to_free_27;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_15 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)ptr_to_free_15 + 2) )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          ptr_to_free_15,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&ptr_to_free_26);
      }
      else
      {
        *_Whereptr_1 = (const vraudio::AudioBuffer *)ptr_to_free_25;
        *((_QWORD *)ptr_to_free_15 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    ptr_to_free_25[1] = sub_1402FD110(&p_ptr_to_free, ptr_to_free_25);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, unsigned __int64))ptr_to_free_25[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    ptr_to_free_26 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*ptr_to_free_25, &v124, &ptr_to_free_26, v28);
    ptr_to_free_20 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    p_ptr_to_free_1 = p_ptr_to_free;
    do
    {
      ptr_to_free_24 = ptr_to_free_20;
      ptr_to_free_20[0xA] = v18;
      v21 = ptr_to_free_20[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)ptr_to_free_20[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*p_ptr_to_free_1 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)allocWithoutProfiling(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)allocWithoutProfiling(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *p_ptr_to_free_1 = (__int64)v33;
        }
        v35 = (_BYTE *)ptr_to_free_20[1];
        Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&v138, 0, sizeof(v138));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)ptr_to_free_20[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        ptr_to_free_18 = (const vraudio::AudioBuffer *)*p_ptr_to_free_1;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        ptr_to_free_1 = *(__m256 **)v138.m256_f32;
        ptr_to_free_19 = ptr_to_free_18;
        v45 = *(_QWORD **)ptr_to_free_18;
        v46 = **(_QWORD ***)ptr_to_free_18;
        if ( v46 == *(_QWORD **)ptr_to_free_18 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = ptr_to_free_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        ptr_to_free_18 = ptr_to_free_19;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *((_QWORD *)ptr_to_free_18 + 1) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = allocWithoutProfiling(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 0x20) = 0;
          *(_QWORD *)(v51 + 0x28) = 0;
          *(__m256 *)(v51 + 0x10) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*((_QWORD *)ptr_to_free_18 + 1);
          v53 = (__int64 *)v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = v51;
          *v53 = v51;
          v54 = *(_QWORD *)*p_ptr_to_free_1;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 0x28LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            ptr_to_free = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              ptr_to_free = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)ptr_to_free - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(ptr_to_free);
          }
          ptr_to_free_15 = ptr_to_free_14;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            ptr_to_free_10 = ptr_to_free_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              ptr_to_free_1 = *(__m256 **)&ptr_to_free_1[0xFFFFFFFF].m256_f32[6];
              if ( (unsigned __int64)((char *)ptr_to_free_10 - (char *)ptr_to_free_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(ptr_to_free_1);
          }
          ptr_to_free_15 = ptr_to_free_14;
          n0x400_2 = 0;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
        }
      }
      ptr_to_free_20[1] = v55;
      n0x400 = n0xF;
      ptr_to_free_19 = (const vraudio::AudioBuffer *)ptr_to_free_20;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !ptr_to_free_15 )
        {
          __asm { vzeroupper }
          ptr_to_free_21 = (std::vector<vraudio::AudioBuffer const *> *)allocWithoutProfiling(0x18u);
          ptr_to_free_15 = ptr_to_free_21;
          ptr_to_free_14 = ptr_to_free_21;
          if ( ptr_to_free_21 )
          {
            *(_QWORD *)ptr_to_free_21 = 0;
            ptr_to_free_22 = ptr_to_free_21;
            *((_QWORD *)ptr_to_free_21 + 1) = 0;
            ptr_to_free_23 = (__int64)ptr_to_free_21;
            *((_QWORD *)ptr_to_free_21 + 2) = 0;
          }
          else
          {
            ptr_to_free_15 = 0;
            ptr_to_free_14 = 0;
            ptr_to_free_22 = 0;
            ptr_to_free_23 = 0;
          }
          sub_140302260(ptr_to_free_23, _Newcapacity_1);
          __Val_0__1 = (const vraudio::AudioBuffer **)v141;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_22 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)ptr_to_free_22 + 2) )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                ptr_to_free_15,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)ptr_to_free_22 + 1) += 8LL;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          ptr_to_free_20 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)ptr_to_free_15 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)ptr_to_free_15 + 2) )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            ptr_to_free_15,
            _Whereptr_3,
            &ptr_to_free_19);
        }
        else
        {
          *_Whereptr_3 = (const vraudio::AudioBuffer *)ptr_to_free_20;
          *((_QWORD *)ptr_to_free_15 + 1) += 8LL;
        }
      }
      else
      {
        v141[n0xF] = ptr_to_free_20;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      ptr_to_free_20 += 0xD;
      a13 = v30;
      *(_QWORD *)v116 = ptr_to_free_20;
    }
    while ( v30 < v124 );
    ptr_to_free_25 = ptr_to_free_27;
LABEL_94:
    v28 = v137;
    _Newcapacity = _Newcapacity_1;
    if ( ptr_to_free_26 > 1 )
    {
      v28 = 0xFFFFFFFFFFFFFFFFuLL;
    }
    v64 = &v117[ptr_to_free_26];
    v117 += ptr_to_free_26;
LABEL_98:
    ptr_to_free_25 += 0xD;
    ptr_to_free_27 = ptr_to_free_25;
    ptr_to_free_24[0xA] = v28;
    if ( ++v132 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  v117 = v64;
  if ( !ptr_to_free_15 )
  {
    goto LABEL_106;
  }
  if ( !((__int64)(*((_QWORD *)ptr_to_free_15 + 1) - *(_QWORD *)ptr_to_free_15) >> 3) )
  {
    __debugbreak();
  }
  i = *(char **)ptr_to_free_15;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 0x50LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 0x50LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 0x50) = -(__int64)(*(_QWORD *)(v71 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (_QWORD)(v65 + 1) << 0xA;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    ptr_to_free_3 = 0;
  }
  else
  {
    ptr_to_free_11 = allocWithoutProfiling(Size);
    ptr_to_free_3 = (const void *)ptr_to_free_11;
    if ( ptr_to_free_11 )
    {
      Buffer_1 = (char *)ptr_to_free_11;
      goto LABEL_131;
    }
  }
  v79 = Size + 0xF;
  if ( Size + 0xF < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && off_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, ptr_to_free_28, _Newcapacity_1, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            ptr_to_free_28,
            _Newcapacity_1,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    fprintf(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    fprintf(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((_QWORD)&v117[2 * (_QWORD)v117 + 0x20 + n0xF] << 7);
    }
    n0x8000_2 = v93 + 0x80;
    if ( *p_n0x8000_1 < v93 + 0x80 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      ptr_to_free_2 = 0;
    }
    else
    {
      ptr_to_free_12 = allocWithoutProfiling(n0x8000_2);
      ptr_to_free_2 = (const void *)ptr_to_free_12;
      if ( ptr_to_free_12 )
      {
        Buffer_2 = (double *)ptr_to_free_12;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 0xF;
    if ( n0x8000_2 + 0xF < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      ptr_to_free_28,
      _Newcapacity_1,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 0x80,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(ptr_to_free_2);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  free_memory_wrapper(ptr_to_free_3);
  ptr_to_free_7 = ptr_to_free_13;
  if ( ptr_to_free_13 )
  {
    v104 = (_QWORD **)*ptr_to_free_13;
    **((_QWORD **)*ptr_to_free_13 + 1) = 0;
    ptr_to_free_5 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = ptr_to_free_5[5];
        ptr_to_free_6 = (_QWORD *)*ptr_to_free_5;
        if ( n0xF_2 > 0xF )
        {
          ptr_to_free_4 = (_QWORD *)ptr_to_free_5[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)ptr_to_free_4 - ptr_to_free_4[0xFFFFFFFF] - 8 > 0x1F )
            {
              goto LABEL_191;
            }
            ptr_to_free_4 = (_QWORD *)ptr_to_free_4[0xFFFFFFFF];
          }
          free_memory_wrapper(ptr_to_free_4);
        }
        ptr_to_free_5[4] = 0;
        ptr_to_free_5[5] = 0xF;
        *((_BYTE *)ptr_to_free_5 + 0x10) = 0;
        free_memory_wrapper(ptr_to_free_5);
        ptr_to_free_5 = ptr_to_free_6;
      }
      while ( ptr_to_free_6 );
    }
    free_memory_wrapper(*ptr_to_free_7);
    free_memory_wrapper(ptr_to_free_7);
  }
  ptr_to_free_9 = ptr_to_free_14;
  if ( ptr_to_free_14 )
  {
    ptr_to_free_8 = *(_QWORD **)ptr_to_free_14;
    if ( *(_QWORD *)ptr_to_free_14 )
    {
      if ( ((*((_QWORD *)ptr_to_free_14 + 2) - (_QWORD)ptr_to_free_8) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)ptr_to_free_8 - ptr_to_free_8[0xFFFFFFFF] - 8 > 0x1F )
        {
LABEL_191:
          invalid_parameter_noinfo_noreturn();
        }
        ptr_to_free_8 = (_QWORD *)ptr_to_free_8[0xFFFFFFFF];
      }
      free_memory_wrapper(ptr_to_free_8);
      *(_QWORD *)ptr_to_free_9 = 0;
      *((_QWORD *)ptr_to_free_9 + 1) = 0;
      *((_QWORD *)ptr_to_free_9 + 2) = 0;
    }
    free_memory_wrapper(ptr_to_free_9);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: is_valid_handle_typeB (0x14030C8B0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *packed_handle_ptr)
{
  unsigned __int64 packed_handle_value; // r9
  __int64 handle_ptr; // r10
  unsigned __int64 handle_flags; // r9
  __int64 mask_from_flag; // rax
  __int64 handle_ptr_copy; // r10
  __int64 metadata_ptr; // rbx
  bool is_thread_state_ok; // al

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_ptr = packed_handle_value & 0xFFFFFFFFFFFFLL;
  handle_flags = HIWORD(packed_handle_value);
  if ( (handle_flags & 0xF000) != 0 )
  {
    mask_from_flag = map_flag_to_mask(0x2000u);
    metadata_ptr = handle_ptr_copy & ~(mask_from_flag - 1);
  }
  else
  {
    metadata_ptr = handle_ptr - 6;
  }
  if ( *(_WORD *)(metadata_ptr + 2) != (handle_flags & 0xFFF) )
  {
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (is_thread_state_ok = is_thread_flag_57_or_38_set()) )
  {
    is_thread_state_ok = 1;
  }
  return *(_WORD *)(metadata_ptr + 4) == 2 && is_thread_state_ok
      || check_handle_access_by_state_extended(packed_handle_ptr) != 0;
}

// --- End Function: is_valid_handle_typeB (0x14030C8B0) ---

// --- Function: map_flag_to_mask (0x140322940) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
      {
        return 0;
      }
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( input_flag == 0x6000 )
        {
          return 0x4000000;
        }
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140322940) ---

// --- Function: sub_14033D280 (0x14033D280) ---
_QWORD *__fastcall sub_14033D280(unsigned __int64 tls_data_offset_784, _QWORD *a2)
{
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)tls_data_offset_784 + 0x338LL);
  n0xFFFF = n0xFFFF_86;
  if ( n0xFFFF_86 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                 + 0x10LL))(
                          global_dispatcher_ptr,
                          &v9,
                          "IEntityComponentNetwork");
    n0xFFFF_86 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(tls_data_offset_784, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033D280 (0x14033D280) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037C210) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
  {
    return 0;
  }
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
         global_validator_object,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
  {
    return 0;
  }
  if ( n4 != 2 || *(_QWORD *)get_tls_data_offset_784() )
  {
    return check_indirect_handle_access_by_state(a1) != 0;
  }
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037C210) ---

// --- Function: check_thread_list_contains_value (0x14038E3B0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 thread_data; // rbx
  unsigned __int64 *v3; // rax
  char *list_begin_1; // r10
  char *list_begin; // rcx
  unsigned __int64 search_value; // rdx
  unsigned __int64 search_range_count; // r8
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) )
  {
    return 0;
  }
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &vf_output_temp);
  list_begin_1 = *(char **)(thread_data + 0x18);
  list_begin = *(char **)(thread_data + 0x10);
  search_value = *v3;
  search_range_count = (list_begin_1 - list_begin) >> 4;
  while ( search_range_count )
  {
    if ( *(_QWORD *)&list_begin[0x10 * (search_range_count >> 1)] >= search_value )
    {
      search_range_count >>= 1;
    }
    else
    {
      list_begin += 0x10 * (search_range_count >> 1) + 0x10;
      search_range_count += 0xFFFFFFFFFFFFFFFFuLL - (search_range_count >> 1);
    }
  }
  if ( list_begin == list_begin_1 )
  {
    return 0;
  }
  if ( search_value < *(_QWORD *)list_begin )
  {
    list_begin = *(char **)(thread_data + 0x18);
  }
  return list_begin != list_begin_1;
}

// --- End Function: check_thread_list_contains_value (0x14038E3B0) ---

// --- Function: validate_access_with_virtual_calls (0x14038E4B0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 thread_data; // rax
  __int64 global_validator_object; // rdi
  __int64 (__fastcall *global_validator_vtable)(__int64, _QWORD); // rbx
  _QWORD *value_from_object_ptr; // rax
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_tls_data_offset_784() )
  {
    return 1;
  }
  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) || !is_illegal_entity_access_check_enabled() )
  {
    return 1;
  }
  global_validator_object = ::global_validator_object;
  global_validator_vtable = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::global_validator_object + 0x3D8LL);
  value_from_object_ptr = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                                      payload_ptr_state2,
                                      &vf_output_temp);
  return global_validator_vtable(global_validator_object, *value_from_object_ptr);
}

// --- End Function: validate_access_with_virtual_calls (0x14038E4B0) ---

// --- Function: check_indirect_handle_access_by_state (0x14038E530) ---
// Checks access permissions for a handle stored indirectly. Takes a pointer `a1`
// to a structure containing a primary packed handle. Extracts the primary handle
// `v1 = *a1 & 0xFFFFFFFFFFFFLL`. Retrieves metadata for `v1` using
// `get_handle_metadata`. Validates access based on the state field (metadata + 4):
// - State 0: Returns false. - State 1: Extracts payload handle from `*(v1 + 8)`
// and calls `check_thread_list_contains_value`. - State 2: Extracts payload handle
// from `*(v1 + 8)`; returns true if thread flags set, otherwise calls
// `validate_access_with_virtual_calls` on payload handle. - State 3: Extracts
// payload handle from `*(v1 + 8)`; checks thread state and compares payload handle
// value against 0x13374770CLL. - Other states: Return false.
char __fastcall check_indirect_handle_access_by_state(_QWORD *packed_handle_owner_ptr)
{
  __int64 primary_handle_value; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  primary_handle_value = *packed_handle_owner_ptr & 0xFFFFFFFFFFFFLL;
  metadata_ptr = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
                   global_validator_object,
                   primary_handle_value,
                   0);
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( *(_WORD *)(metadata_ptr + 4) == 3 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *(_QWORD *)(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL);
  }
}

// --- End Function: check_indirect_handle_access_by_state (0x14038E530) ---

// --- Function: check_handle_access_by_state_extended (0x14038E620) ---
// Checks access permissions for the provided packed handle using extended logic.
// Calculates the metadata pointer based on high bits in the packed handle.
// Validates access based on the state field (metadata + 4): - State 0: Returns
// false (invalid). - State 1: Checks if the handle's payload exists in a thread-
// local list using `check_thread_list_contains_value`. - State 2: Returns true if
// specific thread flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3 or 4: Returns
// true if thread data exists, its status field at +8 is 1, and the payload value
// is not equal to the constant 0x13374770CLL. - Other states: Return false.
char __fastcall check_handle_access_by_state_extended(_QWORD *packed_handle_ptr)
{
  _QWORD *handle_payload_ptr; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  handle_payload_ptr = (_QWORD *)(*packed_handle_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*packed_handle_ptr & 0xF000000000000000uLL) != 0 )
  {
    metadata_ptr = *packed_handle_ptr & 0xFFFFFF000000LL;
  }
  else
  {
    metadata_ptr = (__int64)handle_payload_ptr + 0xFFFFFFFA;
  }
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value((__int64)handle_payload_ptr);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(metadata_ptr + 4) - 3 <= 1 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *handle_payload_ptr != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls((__int64)handle_payload_ptr);
  }
}

// --- End Function: check_handle_access_by_state_extended (0x14038E620) ---

// --- Function: sub_140397520 (0x140397520) ---
FARPROC __fastcall sub_140397520(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
    {
      return result;
    }
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
  {
    return GetProcAddress(hModule_1, lpProcName);
  }
  else
  {
    return v7;
  }
}

// --- End Function: sub_140397520 (0x140397520) ---

// --- Function: sub_1403C6C70 (0x1403C6C70) ---
void __fastcall sub_1403C6C70(volatile signed __int64 *a1, signed __int64 a2, __int64 a3, __int64 a4, char a5)
{
  int *p_n0x1600; // rcx
  int v8; // esi
  bool v9; // zf
  signed __int64 v10; // rax
  int v11; // [rsp+30h] [rbp-61h] BYREF
  _DWORD v12[3]; // [rsp+34h] [rbp-5Dh] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-51h] BYREF
  __int64 v14; // [rsp+44h] [rbp-4Dh]
  int v15; // [rsp+4Ch] [rbp-45h]
  __int64 v16; // [rsp+50h] [rbp-41h]
  unsigned __int64 v17; // [rsp+58h] [rbp-39h]
  __int64 v18; // [rsp+60h] [rbp-31h]
  __int64 v19; // [rsp+68h] [rbp-29h]
  int n0x1600; // [rsp+90h] [rbp-1h] BYREF
  __int64 v21; // [rsp+94h] [rbp+3h]
  int v22; // [rsp+9Ch] [rbp+Bh]
  __int64 v23; // [rsp+A0h] [rbp+Fh]
  unsigned __int64 v24; // [rsp+A8h] [rbp+17h]
  __int64 v25; // [rsp+B0h] [rbp+1Fh]
  __int64 v26; // [rsp+B8h] [rbp+27h]

  if ( a5 && *(_BYTE *)(get_tls_data_offset_784() + 0x1C) && qword_14981D3D8 )
  {
    sub_1403C6E30(a1, a2);
    return;
  }
  if ( (a2 & 0x200000) != 0 )
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
      {
        (*(void (__fastcall **)(__int64, volatile signed __int64 *))(*(_QWORD *)qword_14981D318 + 0x128LL))(
          qword_14981D318,
          a1);
      }
      if ( (a2 & 0x100000) != 0 )
      {
        break;
      }
      v8 = a2 | 0x100000;
      v10 = _InterlockedCompareExchange64(a1, a2 | 0x100000, a2);
      v9 = a2 == v10;
      a2 = v10;
      if ( v9 )
      {
        n0x1600 = 0x1600;
        v21 = 0;
        v22 = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v23 = 1;
        psub_7FF6AAB938D0(
          &n0x1600,
          0,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          0);
        v12[0] = v8;
        off_149808B88(a1, v12, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        p_n0x1600 = &n0x1600;
        v24 = __rdtsc();
        goto LABEL_12;
      }
LABEL_13:
      if ( (a2 & 0x200000) == 0 )
      {
        return;
      }
    }
    n0x1600_1 = 0x1600;
    v14 = 0;
    v15 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v16 = 1;
    psub_7FF6AAB938D0(
      &n0x1600_1,
      0,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      0);
    v11 = a2;
    off_149808B88(a1, &v11, 4, 0xFFFFFFFFLL);
    a2 = *a1;
    p_n0x1600 = &n0x1600_1;
    v17 = __rdtsc();
LABEL_12:
    psub_7FF6AAB93930(p_n0x1600);
    goto LABEL_13;
  }
}

// --- End Function: sub_1403C6C70 (0x1403C6C70) ---

// --- Function: sub_1403C6E30 (0x1403C6E30) ---
double __fastcall sub_1403C6E30(volatile signed __int64 *a1, signed __int64 a2)
{
  __int64 v2; // r14
  __int64 tls_data_offset_784; // rax
  __int64 v6; // rsi
  unsigned int v7; // r15d
  unsigned __int64 v8; // rdx
  signed __int64 v9; // rax
  unsigned __int64 v10; // rcx
  signed __int64 v11; // rax
  signed __int64 v12; // rtt
  double result; // xmm0_8
  _BYTE v14[16]; // [rsp+30h] [rbp-19h] BYREF
  int n0x1600; // [rsp+40h] [rbp-9h] BYREF
  __int64 v16; // [rsp+44h] [rbp-5h]
  int v17; // [rsp+4Ch] [rbp+3h]
  __int64 v18; // [rsp+50h] [rbp+7h]
  unsigned __int64 v19; // [rsp+58h] [rbp+Fh]
  __int64 v20; // [rsp+60h] [rbp+17h]
  __int64 v21; // [rsp+68h] [rbp+1Fh]
  char v22; // [rsp+B8h] [rbp+6Fh] BYREF

  v2 = qword_14981D318;
  tls_data_offset_784 = get_tls_data_offset_784();
  v6 = *(_QWORD *)tls_data_offset_784;
  v7 = *(_DWORD *)(*(_QWORD *)tls_data_offset_784 + 0x1CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v2 + 0xF8LL))(v2, v14, &v22);
  if ( (a2 & 0x200000) != 0 )
  {
    v8 = (unsigned __int64)v7 << 0x20;
    while ( 1 )
    {
      v9 = a2;
      if ( (a2 & 0xFFFF00000000LL) != 0 )
      {
        *(_DWORD *)(v6 + 0x24) = WORD2(a2);
        v10 = v8 | a2 & 0xFFFF0000FFFFFFFFuLL;
        v9 = a2;
      }
      else
      {
        *(_DWORD *)(v6 + 0x24) = 0xFFFFFFFF;
        v10 = a2 | v8;
      }
      v12 = v9;
      v11 = _InterlockedCompareExchange64(a1, v10, v9);
      a2 = v11;
      if ( v12 == v11 )
      {
        break;
      }
      if ( (v11 & 0x200000) == 0 )
      {
        return result;
      }
    }
    n0x1600 = 0x1600;
    v16 = 0;
    v17 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v18 = 1;
    psub_7FF6AAB938D0(
      &n0x1600,
      0,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      0);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0xE8LL))(v2, v7);
    v19 = __rdtsc();
    return psub_7FF6AAB93930(&n0x1600);
  }
  return result;
}

// --- End Function: sub_1403C6E30 (0x1403C6E30) ---

// --- Function: sub_1403C6F70 (0x1403C6F70) ---
__int64 __fastcall sub_1403C6F70(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned int)(v8 - 1)) + v10 + 0x24);
      if ( v5 != 0xFFFFFFFF )
      {
        v4 |= (unsigned __int64)v5 << 0x30;
      }
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
    {
      break;
    }
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
    {
      return result;
    }
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
  {
    return off_149808B90(a1);
  }
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
      qword_14981D318,
      &v11,
      &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(0xC0LL * ((unsigned int)v7 & (v9 - 1)) + v11 + 0x1C) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D318 + 0xD8LL))(
             qword_14981D318,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: sub_1403C6F70 (0x1403C6F70) ---

// --- Function: sub_1403D85B0 (0x1403D85B0) ---
unsigned __int64 __fastcall sub_1403D85B0(
        volatile signed __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_tls_data_offset_784() + 0x1C) && qword_14981D3D8 )
  {
    return sub_1403D8640(a1, a2);
  }
  else
  {
    return sub_1403D8810(a1, a2);
  }
}

// --- End Function: sub_1403D85B0 (0x1403D85B0) ---

// --- Function: sub_1403D8640 (0x1403D8640) ---
signed __int64 __fastcall sub_1403D8640(volatile signed __int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // r15
  __int64 tls_data_offset_784; // rax
  __int64 v6; // rsi
  unsigned int v7; // r14d
  bool v8; // zf
  signed __int64 result; // rax
  unsigned __int64 v10; // rdx
  signed __int64 v11; // rax
  signed __int64 v12; // rax
  int n0x1600; // [rsp+30h] [rbp-81h] BYREF
  __int64 v14; // [rsp+34h] [rbp-7Dh]
  int v15; // [rsp+3Ch] [rbp-75h]
  __int64 v16; // [rsp+40h] [rbp-71h]
  unsigned __int64 v17; // [rsp+48h] [rbp-69h]
  __int64 v18; // [rsp+50h] [rbp-61h]
  __int64 v19; // [rsp+58h] [rbp-59h]
  int n0x1600_1; // [rsp+80h] [rbp-31h] BYREF
  __int64 v21; // [rsp+84h] [rbp-2Dh]
  int v22; // [rsp+8Ch] [rbp-25h]
  __int64 v23; // [rsp+90h] [rbp-21h]
  unsigned __int64 v24; // [rsp+98h] [rbp-19h]
  __int64 v25; // [rsp+A0h] [rbp-11h]
  __int64 v26; // [rsp+A8h] [rbp-9h]
  char v27; // [rsp+110h] [rbp+5Fh] BYREF
  char v28; // [rsp+118h] [rbp+67h] BYREF

  v2 = qword_14981D318;
  tls_data_offset_784 = get_tls_data_offset_784();
  v6 = *(_QWORD *)tls_data_offset_784;
  v7 = *(_DWORD *)(*(_QWORD *)tls_data_offset_784 + 0x1CLL);
  (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v2 + 0xF8LL))(v2, &v28, &v27);
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v10 = (unsigned __int64)v7 << 0x30;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v6 + 0x24) = HIWORD(a2);
        v11 = _InterlockedCompareExchange64(a1, v10 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v8 = a2 == v11;
        a2 = v11;
        if ( v8 )
        {
          n0x1600 = 0x1600;
          v14 = 0;
          v15 = 0;
          v17 = 0;
          v18 = 0;
          v19 = 0;
          v16 = 1;
          psub_7FF6AAB938D0(
            &n0x1600,
            0,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0xE8LL))(v2, v7);
          a2 = *a1;
          v7 = *(_DWORD *)(v6 + 0x1C);
          v17 = __rdtsc();
          psub_7FF6AAB93930(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v6 + 0x24) = 0xFFFFFFFF;
        v12 = _InterlockedCompareExchange64(a1, a2 | v10, a2);
        v8 = a2 == v12;
        a2 = v12;
        if ( v8 )
        {
          n0x1600_1 = 0x1600;
          v21 = 0;
          v22 = 0;
          v24 = 0;
          v25 = 0;
          v26 = 0;
          v23 = 1;
          psub_7FF6AAB938D0(
            &n0x1600_1,
            0,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0xE8LL))(v2, v7);
          a2 = *a1;
          v7 = *(_DWORD *)(v6 + 0x1C);
          v24 = __rdtsc();
          psub_7FF6AAB93930(&n0x1600_1);
        }
      }
    }
    result = _InterlockedCompareExchange64(a1, a2 | 0x200000, a2);
    v8 = a2 == result;
    a2 = result;
  }
  while ( !v8 );
  return result;
}

// --- End Function: sub_1403D8640 (0x1403D8640) ---

// --- Function: sub_1403D8810 (0x1403D8810) ---
signed __int64 __fastcall sub_1403D8810(volatile signed __int64 *a1, signed __int64 a2)
{
  char v2; // r14
  signed __int64 v5; // rcx
  bool v6; // zf
  signed __int64 result; // rax
  int v8; // esi
  signed __int64 v9; // rax
  int v10; // [rsp+38h] [rbp-71h] BYREF
  _DWORD v11[3]; // [rsp+3Ch] [rbp-6Dh] BYREF
  int n0x1600; // [rsp+48h] [rbp-61h] BYREF
  __int64 v13; // [rsp+4Ch] [rbp-5Dh]
  int v14; // [rsp+54h] [rbp-55h]
  __int64 v15; // [rsp+58h] [rbp-51h]
  unsigned __int64 v16; // [rsp+60h] [rbp-49h]
  __int64 v17; // [rsp+68h] [rbp-41h]
  __int64 v18; // [rsp+70h] [rbp-39h]
  int n0x1600_1; // [rsp+98h] [rbp-11h] BYREF
  __int64 v20; // [rsp+9Ch] [rbp-Dh]
  int v21; // [rsp+A4h] [rbp-5h]
  __int64 v22; // [rsp+A8h] [rbp-1h]
  unsigned __int64 v23; // [rsp+B0h] [rbp+7h]
  __int64 v24; // [rsp+B8h] [rbp+Fh]
  __int64 v25; // [rsp+C0h] [rbp+17h]

  v2 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
      {
        (*(void (__fastcall **)(__int64, volatile signed __int64 *))(*(_QWORD *)qword_14981D318 + 0x128LL))(
          qword_14981D318,
          a1);
      }
      if ( (a2 & 0x2003FF) == 0 )
      {
        break;
      }
      if ( v2 )
      {
        n0x1600 = 0x1600;
        v13 = 0;
        v14 = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v15 = 1;
        psub_7FF6AAB938D0(
          &n0x1600,
          0,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          0);
        v10 = a2;
        off_149808B88(a1, &v10, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        v16 = __rdtsc();
        psub_7FF6AAB93930(&n0x1600);
      }
      else
      {
        v8 = a2 + 0x400000;
        v9 = _InterlockedCompareExchange64(a1, a2 + 0x400000, a2);
        v6 = a2 == v9;
        a2 = v9;
        if ( v6 )
        {
          n0x1600_1 = 0x1600;
          v20 = 0;
          v21 = 0;
          v23 = 0;
          v2 = 1;
          v24 = 0;
          v25 = 0;
          v22 = 1;
          psub_7FF6AAB938D0(
            &n0x1600_1,
            0,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          v11[0] = v8;
          off_149808B88(a1, v11, 4, 0xFFFFFFFFLL);
          a2 = *a1;
          v23 = __rdtsc();
          psub_7FF6AAB93930(&n0x1600_1);
        }
      }
    }
    v5 = (a2 | 0x200000) - 0x400000;
    if ( !v2 )
    {
      v5 = a2 | 0x200000;
    }
    result = _InterlockedCompareExchange64(a1, v5, a2);
    v6 = a2 == result;
    a2 = result;
  }
  while ( !v6 );
  return result;
}

// --- End Function: sub_1403D8810 (0x1403D8810) ---

// --- Function: sub_1403D8A00 (0x1403D8A00) ---
__int64 __fastcall sub_1403D8A00(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rdi
  __int64 v9; // r8
  int v10; // ecx
  __int64 v11; // r8
  unsigned __int64 v12; // rbx
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned int)(v14 - 1)) + v16 + 0x24);
      if ( v5 != 0xFFFFFFFF )
      {
        v4 |= (unsigned __int64)v5 << 0x30;
      }
    }
    v6 = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == v6 )
    {
      break;
    }
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
    {
      off_149808B98(a1);
    }
    result = 0xFFFF00000000LL;
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v8 = qword_14981D318;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v15,
        &v13);
      v9 = v15 + 0xC0 * (WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1));
      LODWORD(a2) = *(_DWORD *)(v9 + 0x24);
      *(_DWORD *)(v9 + 0x1C) = (unsigned __int16)(WORD2(a2) + v13);
      for ( result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8);
            (_DWORD)a2 != 0xFFFFFFFF;
            result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8) )
      {
        v10 = (unsigned __int16)(a2 + v13);
        v11 = v15 + 0xC0LL * ((unsigned int)a2 & (v13 - 1));
        LODWORD(a2) = *(_DWORD *)(v11 + 0x24);
        *(_DWORD *)(v11 + 0x1C) = v10;
      }
    }
  }
  else
  {
    result = 0xFFC00000LL;
    if ( (a2 & 0xFFC00000) != 0 )
    {
      return off_149808B90(a1);
    }
    else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v15,
        &v13);
      v12 = HIWORD(a2);
      *(_DWORD *)(0xC0LL * ((unsigned int)v12 & (v13 - 1)) + v15 + 0x1C) = (unsigned __int16)(v12 + v13);
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D318 + 0xD8LL))(
               qword_14981D318,
               (unsigned int)v12);
    }
  }
  return result;
}

// --- End Function: sub_1403D8A00 (0x1403D8A00) ---

// --- Function: allocWithoutProfiling_w (0x1403DFFB0) ---
__int64 allocWithoutProfiling_w()
{
  return allocWithoutProfiling(1u);
}

// --- End Function: allocWithoutProfiling_w (0x1403DFFB0) ---

// --- Function: sub_1403DFFC0 (0x1403DFFC0) ---
_OWORD *__fastcall sub_1403DFFC0(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)allocWithoutProfiling(0x10u);
  if ( result )
  {
    *result = *a1;
  }
  return result;
}

// --- End Function: sub_1403DFFC0 (0x1403DFFC0) ---

// --- Function: sub_1403DFFF0 (0x1403DFFF0) ---
_QWORD *__fastcall sub_1403DFFF0(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithoutProfiling(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    free_memory_wrapper(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
    {
      ;
    }
    Size = v5 + 1;
    v8 = (void *)allocWithoutProfiling(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403DFFF0 (0x1403DFFF0) ---

// --- Function: sub_1403E00D0 (0x1403E00D0) ---
__int64 __fastcall sub_1403E00D0(__int64 a1)
{
  __int64 result; // rax

  result = allocWithoutProfiling(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 0x10) = *(double *)(a1 + 0x10);
  }
  return result;
}

// --- End Function: sub_1403E00D0 (0x1403E00D0) ---

// --- Function: free_memory_wrapper_w_1 (0x1403E02C0) ---
void __fastcall free_memory_wrapper_w_1(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w_1 (0x1403E02C0) ---

// --- Function: free_memory_wrapper_w_2 (0x1403E02D0) ---
void __fastcall free_memory_wrapper_w_2(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w_2 (0x1403E02D0) ---

// --- Function: sub_1403E02E0 (0x1403E02E0) ---
void __fastcall sub_1403E02E0(const void **ptr_to_free)
{
  if ( ptr_to_free )
  {
    free_memory_wrapper(ptr_to_free[2]);
    free_memory_wrapper(ptr_to_free);
  }
}

// --- End Function: sub_1403E02E0 (0x1403E02E0) ---

// --- Function: free_memory_wrapper_w (0x1403E0310) ---
void __fastcall free_memory_wrapper_w(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w (0x1403E0310) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---

// --- Function: sub_1403E2AB0 (0x1403E2AB0) ---
bool __fastcall sub_1403E2AB0(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
  {
    return 1;
  }
  if ( !v2 || !v3 )
  {
    return 0;
  }
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
    {
      break;
    }
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E2AB0 (0x1403E2AB0) ---

// --- Function: sub_1403E2C50 (0x1403E2C50) ---
char __fastcall sub_1403E2C50(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1403E2C50 (0x1403E2C50) ---

// --- Function: sub_1403E6420 (0x1403E6420) ---
__int64 __fastcall sub_1403E6420(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 0x10) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 0x22;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      v6 = sub_1403570D0((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FC400((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
  {
    return 0xFFFFFFFFLL;
  }
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
  {
    return 0xFFFFFFFFLL;
  }
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 0x22;
    }
    else
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403E6420 (0x1403E6420) ---

// --- Function: sub_1403E6550 (0x1403E6550) ---
__int64 __fastcall sub_1403E6550(__int64 a1, double *a2, unsigned __int64 n9)
{
  __int64 v4; // r8

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    return sub_1402FEA60(a2, n9, v4, 1);
  }
  if ( n9 <= 9 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 0x7274706C6C756E22LL;
    *((_BYTE *)a2 + 8) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  return 9;
}

// --- End Function: sub_1403E6550 (0x1403E6550) ---

// --- Function: sub_1403E65D0 (0x1403E65D0) ---
__int64 __fastcall sub_1403E65D0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1403570D0(a2, a3, 0, *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1403E65D0 (0x1403E65D0) ---

// --- Function: sub_1403E6700 (0x1403E6700) ---
__int64 __fastcall sub_1403E6700(__int64 a1, __int64 a2, unsigned __int64 n12)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n12 > 0 )
  {
    if ( n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n12 <= 0xC )
      {
        goto LABEL_52;
      }
    }
    v8 = sub_1404EEAB0((unsigned __int8 *)a1, (_BYTE *)((unsigned int)n0xC + a2), n12 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v10 = sub_1404EE450((unsigned __int8 *)a1, (_BYTE *)(n0xC + a2), n12 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v12 = sub_1404EE6A0((unsigned __int8 *)a1, (_BYTE *)(n0xC + a2), n12 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v14 = sub_1404EE300((unsigned __int8 *)a1, (_BYTE *)(n0xC + a2), n12 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n12 )
    {
LABEL_46:
      if ( n12 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
  {
    return 0xFFFFFFFF;
  }
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403E6700 (0x1403E6700) ---

// --- Function: sub_1403E6A60 (0x1403E6A60) ---
__int64 __fastcall sub_1403E6A60(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 0x10) )
  {
    return sub_1403570D0(a2, a3, 0, v3);
  }
  else
  {
    return sub_1402FC400(a2, a3, 0, v3);
  }
}

// --- End Function: sub_1403E6A60 (0x1403E6A60) ---

// --- Function: sub_1403E6A90 (0x1403E6A90) ---
__int64 __fastcall sub_1403E6A90(__int64 a1, __int64 a2, unsigned __int64 Size, __int64 a4, char a5)
{
  _BYTE *v6; // rdx
  __int64 result; // rax
  size_t Size_1; // rbx

  v6 = *(_BYTE **)(a1 + 8);
  if ( v6 )
  {
    if ( a5 )
    {
      return sub_1402FEA60((_BYTE *)a2, Size, *(_QWORD *)(a1 + 8), 0);
    }
    result = 0xFFFFFFFFFFFFFFFFuLL;
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
    {
      ++Size_1;
    }
    while ( v6[Size_1] );
    if ( Size_1 < Size )
    {
      if ( Size_1 )
      {
        if ( !a2 )
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
          return (unsigned int)Size_1;
        }
        memcpy((void *)a2, v6, Size_1);
      }
      return (unsigned int)Size_1;
    }
  }
  else if ( Size > 7 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 0x6C6C756E;
      *(_WORD *)(a2 + 4) = 0x7470;
      *(_BYTE *)(a2 + 6) = 0x72;
    }
    else
    {
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return 7;
  }
  else
  {
    return 0xFFFFFFFFFFFFFFFFuLL;
  }
  return result;
}

// --- End Function: sub_1403E6A90 (0x1403E6A90) ---

// --- Function: sub_1403E6C00 (0x1403E6C00) ---
// attributes: thunk
__int64 __fastcall sub_1403E6C00(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404EEAB0(a1, a2, n0x21);
}

// --- End Function: sub_1403E6C00 (0x1403E6C00) ---

// --- Function: sub_1404AE300 (0x1404AE300) ---
_QWORD *sub_1404AE300()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  if ( !v0 )
  {
    sub_140535CF0((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithoutProfiling(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_147E52AF0);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404AE300 (0x1404AE300) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 0xF;
  }
  return (__int64 *)&tls_log_structure_1[0x16 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: is_thread_flag_57_or_38_set (0x140535D40) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 thread_data_ptr_offset_16; // rcx

  thread_data_ptr_offset_16 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  if ( thread_data_ptr_offset_16 )
  {
    return *(_BYTE *)(thread_data_ptr_offset_16 + 0x39) != 0;
  }
  else
  {
    return *(_BYTE *)(get_tls_data_offset_784() + 0x26) != 0;
  }
}

// --- End Function: is_thread_flag_57_or_38_set (0x140535D40) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !CSystem )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = 0xFFFFFFFF;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[0xFFF] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)CSystem + 0x118LL))(
                      CSystem,
                      &fmt,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: sub_1467C3410 (0x1467C3410) ---
unsigned __int64 *__fastcall sub_1467C3410(unsigned __int64 tls_data_offset_784, unsigned __int64 *a2)
{
  char v4; // r8
  unsigned __int64 v5; // rcx
  unsigned __int16 v6; // ax

  v4 = sub_1468E7840(tls_data_offset_784);
  if ( v4 )
  {
    v5 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
  }
  else
  {
    v5 = tls_data_offset_784 - 6;
  }
  v6 = *(_WORD *)(v5 + 2) | 0x2000;
  if ( !v4 )
  {
    v6 = *(_WORD *)(v5 + 2);
  }
  *a2 = tls_data_offset_784 | ((unsigned __int64)v6 << 0x30);
  return a2;
}

// --- End Function: sub_1467C3410 (0x1467C3410) ---

// --- Function: sub_1467CDA70 (0x1467CDA70) ---
char __fastcall sub_1467CDA70(
        __int64 tls_data_offset_784,
        __int64 p_p_sub_1467B7D90,
        _QWORD *a3,
        __int64 *a4,
        __int64 *a5)
{
  __int64 v9; // rax
  unsigned __int64 v10; // rax
  _QWORD *v11; // rax
  __int64 v12; // rcx
  signed __int64 v13; // rdx
  __int64 (__fastcall *p_sub_1467B7D90_1)(_QWORD, _QWORD); // rbx
  __int64 v15; // rdi
  __int64 v16; // rsi
  unsigned __int64 v17; // rdx
  __int64 (__fastcall *p_sub_1467B7D90)(_QWORD, _QWORD); // [rsp+30h] [rbp-38h] BYREF
  __int64 (__fastcall *p_sub_1467B89B0)(); // [rsp+38h] [rbp-30h]
  __int64 v21; // [rsp+40h] [rbp-28h]
  __int64 (__fastcall **p_p_sub_1467B7D90_1)(_QWORD, _QWORD); // [rsp+48h] [rbp-20h]

  if ( !(unsigned __int8)sub_1467DB120(a3) )
  {
    __debugbreak();
  }
  if ( !(unsigned __int8)sub_1467DB120(a4) )
  {
    __debugbreak();
  }
  v9 = sub_1467DAEC0(p_p_sub_1467B7D90);
  LOBYTE(v11) = v9
             && ((*(_WORD *)(p_p_sub_1467B7D90 + 6) & 0xF000) == 0 ? (v10 = v9 - 6) : (v10 = v9 & 0xFFFFFFFFFF000000uLL),
                 *(_WORD *)(v10 + 4) == 1);
  if ( (_BYTE)v11 )
  {
    *(_QWORD *)((*(_QWORD *)p_p_sub_1467B7D90 & 0xFFFFFFFFFFFFLL) + 0x4B8) = *a3;
    v12 = *a5;
    p_p_sub_1467B7D90_1 = &p_sub_1467B7D90;
    p_sub_1467B7D90 = (__int64 (__fastcall *)(_QWORD, _QWORD))sub_1467B7D90;
    v21 = v12;
    p_sub_1467B89B0 = sub_1467B89B0;
    if ( sub_1467B89B0 == (__int64 (__fastcall *)())1 )
    {
      sub_1467B7D90((__int64 (__fastcall **)(_QWORD, _QWORD))p_p_sub_1467B7D90, (unsigned __int64 *)0xFFFFFFFFFFFFLL);
    }
    else
    {
      sub_1467B7D90(&p_sub_1467B7D90, (unsigned __int64 *)p_p_sub_1467B7D90);
    }
    LOBYTE(v11) = (_BYTE)p_sub_1467B89B0;
    if ( (unsigned __int64)p_sub_1467B89B0 >= 2 )
    {
      LOBYTE(v11) = ((__int64 (__fastcall *)(__int64, _QWORD))p_sub_1467B89B0)(2, &p_sub_1467B7D90);
    }
  }
  else if ( *(_BYTE *)((*(_QWORD *)p_p_sub_1467B7D90 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
  {
    v13 = _InterlockedIncrement64((volatile signed __int64 *)(tls_data_offset_784 + 0x16C878));
    if ( (v13 & 0x200000) != 0 )
    {
      sub_1403C6C70(
        (volatile signed __int64 *)(tls_data_offset_784 + 0x16C878),
        v13,
        (__int64)"CEntityComponentUpdateScheduler::OnECUSGroupEntityParentChanged",
        (__int64)"m_arDeferredECUSGroupsHierarchyUpdateLock",
        1);
    }
    p_sub_1467B7D90_1 = *(__int64 (__fastcall **)(_QWORD, _QWORD))p_p_sub_1467B7D90;
    v15 = *a3;
    v16 = *a4;
    v11 = (_QWORD *)sub_1403C5FA0(tls_data_offset_784 + 0x16C880, 0x18u, 0);
    *v11 = p_sub_1467B7D90_1;
    v11[1] = v15;
    v11[2] = v16;
    v17 = _InterlockedDecrement64((volatile signed __int64 *)(tls_data_offset_784 + 0x16C878));
    if ( (v17 & 0x3FF) == 0 )
    {
      LOBYTE(v11) = 0;
      if ( (v17 & 0xFFFF0000FFC00000uLL) != 0 )
      {
        LOBYTE(v11) = sub_1403C6F70((volatile signed __int64 *)(tls_data_offset_784 + 0x16C878), v17);
      }
    }
  }
  return (char)v11;
}

// --- End Function: sub_1467CDA70 (0x1467CDA70) ---

// --- Function: sub_14683B580 (0x14683B580) ---
__int64 sub_14683B580(const char *a1, ...)
{
  __int64 result; // rax

  if ( a1 )
  {
    return (*(__int64 (__fastcall **)(Parameter *, __int64, __int64))(*(_QWORD *)CSystem + 0x158LL))(CSystem, 6, 2);
  }
  return result;
}

// --- End Function: sub_14683B580 (0x14683B580) ---

// --- Function: sub_14689FFD0 (0x14689FFD0) ---
__int64 __fastcall sub_14689FFD0(__int64 *a1, __int64 a2)
{
  __int64 result; // rax

  result = *a1;
  *(_QWORD *)((a2 & 0xFFFFFFFFFFFFLL) + 0x318) = *a1;
  return result;
}

// --- End Function: sub_14689FFD0 (0x14689FFD0) ---

// --- Function: sub_1468A5EB0 (0x1468A5EB0) ---
char *__fastcall sub_1468A5EB0(unsigned __int64 *a1, char *a2, _QWORD *a3)
{
  char *v3; // rbx
  __int64 v5; // rbp
  __int64 v6; // rax
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r14
  unsigned __int64 size; // r14
  __int64 v13; // rax
  unsigned __int64 v14; // rdi
  char *v15; // rbp
  _QWORD *v16; // rdx
  char *v17; // r8
  char *v18; // rax
  __int64 v19; // rcx
  char *v20; // rcx
  signed __int64 v21; // rdx
  _QWORD *ptr_to_free; // rcx
  char *result; // rax

  v3 = a2;
  v5 = (__int64)&a2[-*a1] >> 3;
  v6 = (__int64)(a1[1] - *a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = v6 + 1;
  v9 = (__int64)(a1[2] - *a1) >> 3;
  v10 = v9 >> 1;
  if ( v9 > 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    goto LABEL_30;
  }
  v11 = v6 + 1;
  if ( v10 + v9 >= v8 )
  {
    v11 = v10 + v9;
  }
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_30;
  }
  size = 8 * v11;
  if ( size < 0x1000 )
  {
    if ( size )
    {
      v14 = allocWithoutProfiling(size);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_13;
  }
  if ( size + 0x27 < size )
  {
LABEL_30:
    sub_1402DEE40();
  }
  v13 = allocWithoutProfiling(size + 0x27);
  if ( !v13 )
  {
    goto LABEL_28;
  }
  v14 = (v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_13:
  v15 = (char *)(v14 + 8 * v5);
  *(_QWORD *)v15 = *a3;
  v16 = (_QWORD *)v14;
  *a3 = 0;
  v17 = (char *)a1[1];
  v18 = (char *)*a1;
  if ( v3 == v17 )
  {
    for ( ; v18 != v17; ++v16 )
    {
      v19 = *(_QWORD *)v18;
      v18 += 8;
      *v16 = v19;
    }
  }
  else
  {
    for ( ; v18 != v3; v18 += 8 )
    {
      *v16++ = *(_QWORD *)v18;
      *(_QWORD *)v18 = 0;
    }
    v20 = (char *)a1[1];
    if ( v3 != v20 )
    {
      v21 = v15 - v3;
      do
      {
        *(_QWORD *)&v3[v21 + 8] = *(_QWORD *)v3;
        *(_QWORD *)v3 = 0;
        v3 += 8;
      }
      while ( v3 != v20 );
    }
  }
  ptr_to_free = (_QWORD *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)ptr_to_free) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_26:
      free_memory_wrapper(ptr_to_free);
      goto LABEL_27;
    }
    if ( (unsigned __int64)ptr_to_free - ptr_to_free[0xFFFFFFFF] - 8 <= 0x1F )
    {
      ptr_to_free = (_QWORD *)ptr_to_free[0xFFFFFFFF];
      goto LABEL_26;
    }
LABEL_28:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_27:
  result = v15;
  *a1 = v14;
  a1[1] = v14 + 8 * v8;
  a1[2] = size + v14;
  return result;
}

// --- End Function: sub_1468A5EB0 (0x1468A5EB0) ---

// --- Function: sub_1468AB010 (0x1468AB010) ---
char __fastcall sub_1468AB010(
        int n3,
        __int64 a2,
        void *p_Entities_that_cannot_be_replicated_must_not_change_parent_(exce, __int64 a4, __int64 a7, __int64 a6, __int128 *a9, __int64 *a10, __int64 *ThreadLogContextSlot, _QWORD *arg48, _QWORD *a11, _QWORD *a12, _QWORD *a13, _QWORD *a14)
{
  void *v14; // rsp
  __int64 v15; // rax
  __int64 a8; // [rsp+18h] [rbp-288h]
  __int64 a5[11]; // [rsp+30h] [rbp-270h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-218h]
  __int64 n0xB0; // [rsp+90h] [rbp-210h]
  _QWORD *v21; // [rsp+98h] [rbp-208h]
  const char *p_UInt; // [rsp+A0h] [rbp-200h]
  __int64 v23; // [rsp+A8h] [rbp-1F8h]
  __int64 (__fastcall *p_sub_1403E65D0)(__int64, __int64, __int64); // [rsp+B0h] [rbp-1F0h]
  __int64 (__fastcall *p_sub_1403E65D0_1)(__int64, __int64, __int64); // [rsp+B8h] [rbp-1E8h]
  __int64 v26; // [rsp+C0h] [rbp-1E0h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+C8h] [rbp-1D8h]
  __int64 v28; // [rsp+D0h] [rbp-1D0h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+D8h] [rbp-1C8h]
  _OWORD *(__fastcall *p_sub_1403DFFC0)(_OWORD *); // [rsp+E0h] [rbp-1C0h]
  unsigned __int64 v31; // [rsp+E8h] [rbp-1B8h]
  char v32; // [rsp+F0h] [rbp-1B0h]
  char v33; // [rsp+F1h] [rbp-1AFh]
  __int64 n0x10; // [rsp+F8h] [rbp-1A8h]
  _QWORD *v35; // [rsp+100h] [rbp-1A0h]
  const char *p_Name; // [rsp+108h] [rbp-198h]
  __int64 v37; // [rsp+110h] [rbp-190h]
  __int64 (__fastcall *p_sub_1403E6A90)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+118h] [rbp-188h]
  __int64 (__fastcall *p_sub_1403E6550)(__int64, double *, unsigned __int64); // [rsp+120h] [rbp-180h]
  __int64 v40; // [rsp+128h] [rbp-178h]
  bool (__fastcall *p_sub_1403E2AB0)(__int64, __int64); // [rsp+130h] [rbp-170h]
  __int64 v42; // [rsp+138h] [rbp-168h]
  void (__fastcall *p_sub_1403E02E0)(const void **); // [rsp+140h] [rbp-160h]
  _QWORD *(__fastcall *p_sub_1403DFFF0)(_QWORD *); // [rsp+148h] [rbp-158h]
  unsigned __int64 v45; // [rsp+150h] [rbp-150h]
  char v46; // [rsp+158h] [rbp-148h]
  char v47; // [rsp+159h] [rbp-147h]
  __int64 n0x18; // [rsp+160h] [rbp-140h]
  _QWORD *v49; // [rsp+168h] [rbp-138h]
  uint64_t **p_EntityId; // [rsp+170h] [rbp-130h]
  __int64 v51; // [rsp+178h] [rbp-128h]
  __int64 (__fastcall *p_sub_1403E6A60)(__int64, __int64, __int64); // [rsp+180h] [rbp-120h]
  __int64 (__fastcall *p_sub_1403E6420)(__int64, _BYTE *, unsigned __int64); // [rsp+188h] [rbp-118h]
  __int64 v54; // [rsp+190h] [rbp-110h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z_1)(__int64, __int64); // [rsp+198h] [rbp-108h]
  __int64 v56; // [rsp+1A0h] [rbp-100h]
  void (__fastcall *p_free_memory_wrapper_w_1)(const void *); // [rsp+1A8h] [rbp-F8h]
  __int64 (__fastcall *p_sub_1403E00D0)(__int64); // [rsp+1B0h] [rbp-F0h]
  unsigned __int64 v59; // [rsp+1B8h] [rbp-E8h]
  char v60; // [rsp+1C0h] [rbp-E0h]
  char v61; // [rsp+1C1h] [rbp-DFh]
  __int64 n0x18_1; // [rsp+1C8h] [rbp-D8h]
  _QWORD *v63; // [rsp+1D0h] [rbp-D0h]
  const char *p_Name_1; // [rsp+1D8h] [rbp-C8h]
  __int64 v65; // [rsp+1E0h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1403E6A90_1)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+1E8h] [rbp-B8h]
  __int64 (__fastcall *p_sub_1403E6550_1)(__int64, double *, unsigned __int64); // [rsp+1F0h] [rbp-B0h]
  __int64 v68; // [rsp+1F8h] [rbp-A8h]
  bool (__fastcall *p_sub_1403E2AB0_1)(__int64, __int64); // [rsp+200h] [rbp-A0h]
  __int64 v70; // [rsp+208h] [rbp-98h]
  void (__fastcall *p_sub_1403E02E0_1)(const void **); // [rsp+210h] [rbp-90h]
  _QWORD *(__fastcall *p_sub_1403DFFF0_1)(_QWORD *); // [rsp+218h] [rbp-88h]
  unsigned __int64 v73; // [rsp+220h] [rbp-80h]
  char v74; // [rsp+228h] [rbp-78h]
  char v75; // [rsp+229h] [rbp-77h]
  __int64 n0x18_2; // [rsp+230h] [rbp-70h]
  _QWORD *v77; // [rsp+238h] [rbp-68h]
  uint64_t **p_EntityId_1; // [rsp+240h] [rbp-60h]
  __int64 v79; // [rsp+248h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6A60_1)(__int64, __int64, __int64); // [rsp+250h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E6420_1)(__int64, _BYTE *, unsigned __int64); // [rsp+258h] [rbp-48h]
  __int64 v82; // [rsp+260h] [rbp-40h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z_2)(__int64, __int64); // [rsp+268h] [rbp-38h]
  __int64 v84; // [rsp+270h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w_2)(const void *); // [rsp+278h] [rbp-28h]
  __int64 (__fastcall *p_sub_1403E00D0_1)(__int64); // [rsp+280h] [rbp-20h]
  unsigned __int64 v87; // [rsp+288h] [rbp-18h]
  char v88; // [rsp+290h] [rbp-10h]
  char v89; // [rsp+291h] [rbp-Fh]
  __int64 n0x18_3; // [rsp+298h] [rbp-8h]

  v14 = alloca(0x270);
  a5[0] = (__int64)ThreadLogContextSlot;
  p_UInt = "UInt";
  a5[2] = 0;
  a5[1] = (__int64)"TraceContext";
  a5[5] = 0;
  a5[3] = (__int64)sub_1403E6C00;
  a5[7] = 0;
  a5[4] = (__int64)sub_1403E6700;
  v33 = 0;
  a5[6] = (__int64)sub_1403E2C50;
  n0x100 = 0x100;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v21 = arg48;
  n0xB0 = 0xB0;
  v23 = *arg48;
  p_sub_1403E65D0 = sub_1403E65D0;
  p_sub_1403E65D0_1 = sub_1403E65D0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w_2;
  p_sub_1403DFFC0 = sub_1403DFFC0;
  v35 = a11;
  v26 = 0;
  v28 = 0;
  v32 = 0;
  v47 = 0;
  v31 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x10 = 0x10;
  p_Name = "Name";
  v37 = *a11;
  p_sub_1403E6A90 = sub_1403E6A90;
  p_sub_1403E6550 = sub_1403E6550;
  p_sub_1403E2AB0 = sub_1403E2AB0;
  v40 = 0;
  v42 = 0;
  v46 = 0;
  p_sub_1403E02E0 = sub_1403E02E0;
  p_sub_1403DFFF0 = sub_1403DFFF0;
  v45 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x18 = 0x18;
  v49 = a12;
  p_EntityId = "EntityId";
  v61 = 1;
  v15 = *a12;
  v54 = 0;
  v56 = 0;
  v51 = v15;
  p_sub_1403E6A60 = sub_1403E6A60;
  p_sub_1403E6420 = sub_1403E6420;
  p_??8error_category@std@@QEBA_NAEBV01@@Z_1 = std::error_category::operator==;
  v63 = a13;
  p_Name_1 = "Name";
  p_free_memory_wrapper_w_1 = free_memory_wrapper_w;
  p_sub_1403E00D0 = sub_1403E00D0;
  v59 = 0xFFFFFFFFFFFFFFFFuLL;
  v60 = 0;
  n0x18_1 = 0x18;
  v75 = 0;
  v65 = *a13;
  p_sub_1403E6A90_1 = sub_1403E6A90;
  p_sub_1403E6550_1 = sub_1403E6550;
  p_sub_1403E2AB0_1 = sub_1403E2AB0;
  v77 = a14;
  v68 = 0;
  v70 = 0;
  p_sub_1403E02E0_1 = sub_1403E02E0;
  p_sub_1403DFFF0_1 = sub_1403DFFF0;
  v73 = 0xFFFFFFFFFFFFFFFFuLL;
  v74 = 0;
  n0x18_2 = 0x18;
  p_EntityId_1 = "EntityId";
  v89 = 1;
  v79 = *a14;
  v82 = 0;
  v84 = 0;
  v88 = 0;
  LODWORD(a8) = a6;
  p_sub_1403E6A60_1 = sub_1403E6A60;
  p_sub_1403E6420_1 = sub_1403E6420;
  p_??8error_category@std@@QEBA_NAEBV01@@Z_2 = std::error_category::operator==;
  p_free_memory_wrapper_w_2 = free_memory_wrapper_w;
  p_sub_1403E00D0_1 = sub_1403E00D0;
  v87 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x18_3 = 0x18;
  return sub_140302350(
           n3,
           a2,
           p_Entities_that_cannot_be_replicated_must_not_change_parent_(exce,
           a4,
           (__int64)a5,
           6,
           a7,
           a8,
           a9,
           a10);
}

// --- End Function: sub_1468AB010 (0x1468AB010) ---

// --- Function: __crtLCMapStringA_169 (0x1468AB410) ---
char __fastcall _crtLCMapStringA_169(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        _QWORD *arg48,
        _QWORD *a11,
        _QWORD *a12)
{
  void *v12; // rsp
  __int64 a8; // [rsp+18h] [rbp-1B8h]
  __int64 a5[11]; // [rsp+30h] [rbp-1A0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-148h]
  __int64 n0xB0; // [rsp+90h] [rbp-140h]
  _QWORD *v18; // [rsp+98h] [rbp-138h]
  const char *p_Name; // [rsp+A0h] [rbp-130h]
  __int64 v20; // [rsp+A8h] [rbp-128h]
  __int64 (__fastcall *p_sub_1403E6A90)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+B0h] [rbp-120h]
  __int64 (__fastcall *p_sub_1403E6550)(__int64, double *, unsigned __int64); // [rsp+B8h] [rbp-118h]
  __int64 v23; // [rsp+C0h] [rbp-110h]
  bool (__fastcall *p_sub_1403E2AB0)(__int64, __int64); // [rsp+C8h] [rbp-108h]
  __int64 v25; // [rsp+D0h] [rbp-100h]
  void (__fastcall *p_sub_1403E02E0)(const void **); // [rsp+D8h] [rbp-F8h]
  _QWORD *(__fastcall *p_sub_1403DFFF0)(_QWORD *); // [rsp+E0h] [rbp-F0h]
  unsigned __int64 v28; // [rsp+E8h] [rbp-E8h]
  char v29; // [rsp+F0h] [rbp-E0h]
  char v30; // [rsp+F1h] [rbp-DFh]
  __int64 n0x18; // [rsp+F8h] [rbp-D8h]
  _QWORD *v32; // [rsp+100h] [rbp-D0h]
  const char *p_Name_1; // [rsp+108h] [rbp-C8h]
  __int64 v34; // [rsp+110h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1403E6A90_1)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+118h] [rbp-B8h]
  __int64 (__fastcall *p_sub_1403E6550_1)(__int64, double *, unsigned __int64); // [rsp+120h] [rbp-B0h]
  __int64 v37; // [rsp+128h] [rbp-A8h]
  bool (__fastcall *p_sub_1403E2AB0_1)(__int64, __int64); // [rsp+130h] [rbp-A0h]
  __int64 v39; // [rsp+138h] [rbp-98h]
  void (__fastcall *p_sub_1403E02E0_1)(const void **); // [rsp+140h] [rbp-90h]
  _QWORD *(__fastcall *p_sub_1403DFFF0_1)(_QWORD *); // [rsp+148h] [rbp-88h]
  unsigned __int64 v42; // [rsp+150h] [rbp-80h]
  char v43; // [rsp+158h] [rbp-78h]
  char v44; // [rsp+159h] [rbp-77h]
  __int64 n0x18_1; // [rsp+160h] [rbp-70h]
  _QWORD *v46; // [rsp+168h] [rbp-68h]
  const char *p_Number; // [rsp+170h] [rbp-60h]
  __int64 v48; // [rsp+178h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E65D0)(__int64, __int64, __int64); // [rsp+180h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E65D0_1)(__int64, __int64, __int64); // [rsp+188h] [rbp-48h]
  __int64 v51; // [rsp+190h] [rbp-40h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+198h] [rbp-38h]
  __int64 v53; // [rsp+1A0h] [rbp-30h]
  void (__fastcall *p_free_memory_wrapper_w)(const void *); // [rsp+1A8h] [rbp-28h]
  _OWORD *(__fastcall *p_sub_1403DFFC0)(_OWORD *); // [rsp+1B0h] [rbp-20h]
  unsigned __int64 v56; // [rsp+1B8h] [rbp-18h]
  char v57; // [rsp+1C0h] [rbp-10h]
  char v58; // [rsp+1C1h] [rbp-Fh]
  __int64 n0x10; // [rsp+1C8h] [rbp-8h]

  v12 = alloca(0x1A0);
  a5[0] = arg40;
  n0x100 = 0x100;
  a5[2] = 0;
  a5[1] = (__int64)"TraceContext";
  a5[5] = 0;
  a5[3] = (__int64)sub_1403E6C00;
  a5[7] = 0;
  a5[4] = (__int64)sub_1403E6700;
  a5[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  a5[6] = (__int64)sub_1403E2C50;
  n0xB0 = 0xB0;
  a5[8] = (__int64)free_memory_wrapper_w_1;
  a5[9] = (__int64)allocWithoutProfiling_w;
  v18 = arg48;
  p_Name = "Name";
  v30 = 0;
  v20 = *arg48;
  v32 = a11;
  p_sub_1403DFFF0 = sub_1403DFFF0;
  p_sub_1403E6A90 = sub_1403E6A90;
  p_sub_1403E6550 = sub_1403E6550;
  v23 = 0;
  p_sub_1403E2AB0 = sub_1403E2AB0;
  v25 = 0;
  p_sub_1403E02E0 = sub_1403E02E0;
  v28 = 0xFFFFFFFFFFFFFFFFuLL;
  v29 = 0;
  n0x18 = 0x18;
  p_Name_1 = "Name";
  v44 = 0;
  v34 = *a11;
  v46 = a12;
  p_sub_1403DFFF0_1 = sub_1403DFFF0;
  p_sub_1403E6A90_1 = sub_1403E6A90;
  p_sub_1403E6550_1 = sub_1403E6550;
  v37 = 0;
  p_sub_1403E2AB0_1 = sub_1403E2AB0;
  v39 = 0;
  p_sub_1403E02E0_1 = sub_1403E02E0;
  v42 = 0xFFFFFFFFFFFFFFFFuLL;
  v43 = 0;
  n0x18_1 = 0x18;
  p_Number = "Number";
  v58 = 0;
  v48 = *a12;
  p_sub_1403E65D0 = sub_1403E65D0;
  p_sub_1403E65D0_1 = sub_1403E65D0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_free_memory_wrapper_w = free_memory_wrapper_w_2;
  p_sub_1403DFFC0 = sub_1403DFFC0;
  v51 = 0;
  v53 = 0;
  v56 = 0xFFFFFFFFFFFFFFFFuLL;
  v57 = 0;
  n0x10 = 0x10;
  LODWORD(a8) = a6;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 4, a7, a8, a9, a10);
}

// --- End Function: __crtLCMapStringA_169 (0x1468AB410) ---

// --- Function: CEntity::ChangeOwnerEntity (0x1468C1420) ---
double __fastcall CEntity::ChangeOwnerEntity(
        unsigned __int64 tls_data_offset_784_12,
        unsigned __int64 tls_data_offset_784_11,
        signed int n4_1)
{
  __int64 n4_2; // r13
  unsigned __int64 tls_data_offset_784; // rdi
  unsigned __int64 entity; // rbx
  int v6; // esi
  __int64 v7; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  _QWORD *v9; // rax
  volatile signed __int32 *v10; // rsi
  volatile signed __int32 *v11; // r14
  signed __int64 v12; // rdx
  char v13; // cl
  unsigned __int64 v14; // rdx
  unsigned __int16 v15; // ax
  int v16; // esi
  unsigned __int64 v17; // rax
  __int64 tls_data_offset_784_4; // r8
  char v19; // dl
  unsigned __int64 v20; // rcx
  unsigned __int16 v21; // ax
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  unsigned __int16 v24; // ax
  __int64 p_tls_data_offset_784_1; // rsi
  __int64 tls_data_offset_784_10; // r15
  __int64 tls_data_offset_784_8; // r14
  int v28; // eax
  unsigned __int64 *v29; // r12
  unsigned __int64 v30; // rax
  __int64 v31; // r13
  unsigned __int64 v32; // rax
  __int64 v33; // r13
  __int64 v34; // rax
  char v35; // dl
  unsigned __int64 v36; // rcx
  unsigned __int16 v37; // ax
  bool v38; // al
  unsigned __int64 v39; // rdi
  unsigned __int64 tls_data_offset_784_6; // r13
  __int64 v41; // rcx
  unsigned __int64 p_tls_data_offset_784_2; // r12
  char v43; // dl
  unsigned __int64 v44; // rcx
  unsigned __int16 v45; // ax
  unsigned __int64 tls_data_offset_784_7; // rdi
  char v47; // dl
  unsigned __int64 v48; // rcx
  unsigned __int16 v49; // ax
  __int64 v50; // rbx
  int v51; // eax
  int v52; // ecx
  const char *p_No_Owner; // rax
  __int64 *ThreadLogContextSlot; // rax
  unsigned __int64 n0x200000; // rax
  __int64 *v57; // [rsp+28h] [rbp-D8h]
  unsigned __int64 tls_data_offset_784_1; // [rsp+78h] [rbp-88h]
  __int64 v59; // [rsp+80h] [rbp-80h]
  int v60; // [rsp+80h] [rbp-80h]
  unsigned __int64 tls_data_offset_784_5; // [rsp+88h] [rbp-78h] BYREF
  unsigned int n4; // [rsp+90h] [rbp-70h]
  __int64 tls_data_offset_784_3; // [rsp+98h] [rbp-68h] BYREF
  __int64 v64[3]; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int64 v65; // [rsp+B8h] [rbp-48h] BYREF
  __int64 tls_data_offset_784_9; // [rsp+C8h] [rbp-38h] BYREF
  __int64 p_tls_data_offset_784; // [rsp+D0h] [rbp-30h] BYREF
  unsigned int v68[2]; // [rsp+D8h] [rbp-28h] BYREF
  unsigned int v69[2]; // [rsp+E0h] [rbp-20h] BYREF
  unsigned int v70[2]; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v71[2]; // [rsp+F0h] [rbp-10h] BYREF
  char v72; // [rsp+100h] [rbp+0h]
  int n0xF00; // [rsp+110h] [rbp+10h] BYREF
  __int64 v74; // [rsp+114h] [rbp+14h]
  int v75; // [rsp+11Ch] [rbp+1Ch]
  __int64 v76; // [rsp+120h] [rbp+20h]
  unsigned __int64 v77; // [rsp+128h] [rbp+28h]
  __int64 v78; // [rsp+130h] [rbp+30h]
  __int64 v79; // [rsp+138h] [rbp+38h]
  _QWORD v80[2]; // [rsp+160h] [rbp+60h] BYREF
  const void *ptr_to_free; // [rsp+170h] [rbp+70h]
  _QWORD v82[2]; // [rsp+178h] [rbp+78h] BYREF
  const void *ptr_to_free_1; // [rsp+188h] [rbp+88h]
  __int64 v84[2]; // [rsp+190h] [rbp+90h] BYREF
  const void *ptr_to_free_2; // [rsp+1A0h] [rbp+A0h]
  __int64 v86[2]; // [rsp+1A8h] [rbp+A8h] BYREF
  const void *ptr_to_free_3; // [rsp+1B8h] [rbp+B8h]
  _QWORD v88[2]; // [rsp+1C0h] [rbp+C0h] BYREF
  _QWORD v89[2]; // [rsp+1D0h] [rbp+D0h] BYREF
  _QWORD v90[2]; // [rsp+1E0h] [rbp+E0h] BYREF
  _QWORD v91[2]; // [rsp+1F0h] [rbp+F0h] BYREF
  __int64 v92[2]; // [rsp+200h] [rbp+100h] BYREF
  unsigned int v93[2]; // [rsp+210h] [rbp+110h] BYREF
  char *v94; // [rsp+218h] [rbp+118h]
  __int64 v95[2]; // [rsp+220h] [rbp+120h] BYREF
  char v96; // [rsp+230h] [rbp+130h]
  char v97[8]; // [rsp+238h] [rbp+138h] BYREF
  __int128 v98; // [rsp+240h] [rbp+140h] BYREF
  char v99[8]; // [rsp+250h] [rbp+150h] BYREF
  volatile signed __int32 *v100; // [rsp+258h] [rbp+158h]
  __int128 v101; // [rsp+260h] [rbp+160h] BYREF
  _DWORD v102[3]; // [rsp+270h] [rbp+170h] BYREF
  char v103; // [rsp+27Ch] [rbp+17Ch] BYREF
  _DWORD v104[3]; // [rsp+280h] [rbp+180h] BYREF
  char v105; // [rsp+28Ch] [rbp+18Ch] BYREF
  _DWORD v106[3]; // [rsp+290h] [rbp+190h] BYREF
  char v107; // [rsp+29Ch] [rbp+19Ch] BYREF
  _DWORD v108[3]; // [rsp+2A0h] [rbp+1A0h] BYREF
  char v109; // [rsp+2ACh] [rbp+1ACh] BYREF

  n4_2 = n4_1;
  tls_data_offset_784 = tls_data_offset_784_11;
  tls_data_offset_784_1 = tls_data_offset_784_11;
  entity = tls_data_offset_784_12;
  tls_data_offset_784_3 = tls_data_offset_784_12;
  n4 = n4_1;
  v74 = 0;
  v75 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  n0xF00 = 0xF00;
  v76 = 1;
  psub_7FF6AAB938D0(
    &n0xF00,
    0,
    &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  if ( (_DWORD)n4_2 == 4 )
  {
    CEntity::ClearAllOwners(entity);
    goto LABEL_141;
  }
  if ( (int)n4_2 >= 3 )
  {
    LogFatalError("Invalid entity ownership reason");
  }
  if ( *(_BYTE *)(entity + 0xD) < 5u )
  {
    if ( tls_data_offset_784 )
    {
      if ( !(_BYTE)isEditor
        && (*(_BYTE *)(tls_data_offset_784 + 0xD) >= 5u
         || (*(_BYTE *)(tls_data_offset_784 + 8) & 8) != 0 && (*(_BYTE *)(entity + 8) & 8) == 0) )
      {
        v106[0] = 0xD2;
        v88[0] = v106;
        v106[1] = 0x2C;
        v88[1] = &v107;
        v106[2] = 0x31;
        v6 = invokeGlobalCallbackAndMaskStatusBits(
               2,
               (__int64)v88,
               (__int64)"Attaching to an already removing owner - will crash later",
               "Attaching $$ to an already removing owner ($$). reason ($$)");
        if ( (v6 & 0xFFFFF) != 0 )
        {
          v7 = *(_QWORD *)(entity + 0x290);
          v89[1] = (unsigned int)n4_2;
          v82[1] = *(_QWORD *)(tls_data_offset_784 + 0x290);
          v89[0] = 0;
          v82[0] = 0;
          ptr_to_free_1 = 0;
          v80[0] = 0;
          v80[1] = v7;
          ptr_to_free = 0;
          ThreadLogContextSlot_1 = getThreadLogContextSlot();
          v108[0] = 0xD2;
          v90[0] = v108;
          v90[1] = &v109;
          v98 = 0;
          v108[1] = 0x2C;
          v108[2] = 0x31;
          _crtLCMapStringA_169(
            2,
            (unsigned int)v90,
            (unsigned int)"Attaching to an already removing owner - will crash later",
            (unsigned int)"Attaching $$ to an already removing owner ($$). reason ($$)",
            1,
            v6,
            &v98,
            0,
            (__int64)ThreadLogContextSlot_1,
            (__int64)v80,
            (__int64)v82,
            (__int64)v89);
          free_memory_wrapper(ptr_to_free);
          free_memory_wrapper(ptr_to_free_1);
        }
      }
      if ( *(_BYTE *)(entity + 0xD) < 4u )
      {
        v9 = (_QWORD *)sub_1468DEFD0(entity, v99);
        v10 = (volatile signed __int32 *)v9[1];
        v9[1] = 0;
        *v9 = 0;
        v11 = v100;
        if ( v100 )
        {
          if ( _InterlockedExchangeAdd(v100 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
            if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
            {
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
            }
          }
        }
        if ( v10 )
        {
          if ( _InterlockedExchangeAdd(v10 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
            if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
            {
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
            }
          }
        }
      }
    }
    if ( dword_1497929D8 == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
    {
      ++dword_1497929DC;
    }
    else
    {
      v12 = _InterlockedIncrement64(&qword_1497929D0);
      if ( (v12 & 0x200000) != 0 )
      {
        sub_1403C6C70(
          &qword_1497929D0,
          v12,
          (__int64)"CEntity::ChangeOwnerEntity",
          (__int64)"s_aggregateHierarchyLock",
          1);
      }
    }
    if ( !is_valid_handle_typeB((unsigned __int64 *)(entity + 0x4D8 + 8 * n4_2)) && !tls_data_offset_784 )
    {
      goto LABEL_36;
    }
    sub_146900A50(entity, 0x16);
    if ( tls_data_offset_784 )
    {
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v13 = 0;
        v14 = tls_data_offset_784 - 6;
      }
      else
      {
        v13 = 1;
        v14 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v15 = *(_WORD *)(v14 + 2) | 0x2000;
      if ( !v13 )
      {
        v15 = *(_WORD *)(v14 + 2);
      }
      if ( *(_QWORD *)(entity + 8 * n4_2 + 0x4D8) == (tls_data_offset_784 | ((unsigned __int64)v15 << 0x30)) )
      {
LABEL_36:
        sub_1402D0950((__int64)&qword_1497929D0);
        goto LABEL_141;
      }
    }
    sub_1402D0950((__int64)&qword_1497929D0);
    v16 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
    if ( dword_1497929D8 == v16 )
    {
      ++dword_1497929DC;
    }
    else
    {
      v17 = _InterlockedCompareExchange64(&qword_1497929D0, 0x200000, 0);
      if ( v17 )
      {
        sub_1403D85B0(
          &qword_1497929D0,
          v17,
          0,
          (__int64)"CEntity::ChangeOwnerEntity",
          (__int64)"s_aggregateHierarchyLock",
          1);
      }
      dword_1497929D8 = v16;
    }
    if ( tls_data_offset_784 )
    {
      tls_data_offset_784_4 = ::tls_data_offset_784_1;
      if ( ::tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v19 = 0;
        v20 = entity - 6;
      }
      else
      {
        v19 = 1;
        v20 = entity & 0xFFFFFFFFFF000000uLL;
      }
      v21 = *(_WORD *)(v20 + 2) | 0x2000;
      if ( !v19 )
      {
        v21 = *(_WORD *)(v20 + 2);
      }
      v22 = entity | ((unsigned __int64)v21 << 0x30);
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        tls_data_offset_784_4 = 0;
        v23 = tls_data_offset_784 - 6;
      }
      else
      {
        LOBYTE(tls_data_offset_784_4) = 1;
        v23 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v24 = *(_WORD *)(v23 + 2) | 0x2000;
      if ( !(_BYTE)tls_data_offset_784_4 )
      {
        v24 = *(_WORD *)(v23 + 2);
      }
      if ( !(unsigned __int8)sub_1468C20C0(
                               tls_data_offset_784 | ((unsigned __int64)v24 << 0x30),
                               v22,
                               tls_data_offset_784_4,
                               qword_15126E3D8) )
      {
        if ( byte_14981D4A0 )
        {
          goto LABEL_128;
        }
        sub_14033D280(entity, v64);
        if ( !AssetMeta::HasActorSubresource(v64)
          || !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v64[0] & 0xFFFFFFFFFFFFLL) + 0x578LL))(v64[0] & 0xFFFFFFFFFFFFLL) )
        {
          goto LABEL_128;
        }
        sub_14683B580(
          "%s setting reason=%u owner to nullptr due to non-authoritative client ownership change on entityId=%llu entity"
          "Name=\"%s\" entityState=%u",
          "CEntity::ChangeOwnerEntity",
          n4_2,
          *(_QWORD *)(entity + 0x10),
          *(const char **)(entity + 0x290),
          *(unsigned __int8 *)(entity + 0xD));
        goto LABEL_60;
      }
      if ( dword_15126E238 == 1 )
      {
        v34 = sub_1467C3410(tls_data_offset_784, v97);
        if ( (unsigned __int8)sub_1468C2120(entity, v34) )
        {
          LogTraceConditional(
            "%s: Trying to set cyclic entity ownership - eReason=%d entity {name =\"%s\" id=%llu} newOwner {name=\"%s\" id=%llu}",
            "CEntity::ChangeOwnerEntity",
            n4_2,
            *(const char **)(entity + 0x290),
            *(_QWORD *)(entity + 0x10),
            *(const char **)(tls_data_offset_784 + 0x290),
            *(_QWORD *)(tls_data_offset_784 + 0x10));
          CEntity::DumpOwnerInfo(entity);
          if ( (_BYTE)isEditor )
          {
            sub_14683B580(
              "Cyclic Entity ownership - attempting to set entity as being owned by itself or one of the entities owned by it!!!");
          }
          else
          {
            LogFatalError(
              "Cyclic Entity ownership - attempting to set entity as being owned by itself or one of the entities owned by it!!!");
          }
LABEL_60:
          p_tls_data_offset_784_1 = *(_QWORD *)(entity + 0x318);
          tls_data_offset_784 = 0;
          tls_data_offset_784_10 = *(_QWORD *)(entity + 0x310);
          tls_data_offset_784_1 = 0;
          tls_data_offset_784_8 = *(_QWORD *)(entity + 0x320);
          goto LABEL_61;
        }
      }
    }
    p_tls_data_offset_784_1 = *(_QWORD *)(entity + 0x318);
    tls_data_offset_784_8 = *(_QWORD *)(entity + 0x320);
    tls_data_offset_784_10 = *(_QWORD *)(entity + 0x310);
    if ( tls_data_offset_784 )
    {
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v35 = 0;
        v36 = tls_data_offset_784 - 6;
      }
      else
      {
        v35 = 1;
        v36 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v37 = *(_WORD *)(v36 + 2) | 0x2000;
      tls_data_offset_784_1 = tls_data_offset_784;
      if ( !v35 )
      {
        v37 = *(_WORD *)(v36 + 2);
      }
      *(_QWORD *)(entity + 8 * n4_2 + 0x4D8) = tls_data_offset_784 | ((unsigned __int64)v37 << 0x30);
      v28 = *(_DWORD *)(entity + 0x4F0) | (1 << n4_2);
      goto LABEL_62;
    }
LABEL_61:
    *(_QWORD *)(entity + 8 * n4_2 + 0x4D8) = 0;
    v28 = *(_DWORD *)(entity + 0x4F0) & ~(1 << n4_2);
LABEL_62:
    *(_DWORD *)(entity + 0x4F0) = v28;
    v59 = 0;
    v29 = (unsigned __int64 *)(entity + 0x4D8);
    do
    {
      v30 = *v29;
      if ( *v29 )
      {
        v31 = v30 & 0xFFFFFFFFFFFFLL;
        v32 = HIWORD(v30);
        v33 = (v32 & 0xF000) != 0 ? v31 & 0xFFFFFF000000LL : v31 - 6;
        tls_data_offset_784_1 = tls_data_offset_784;
        if ( *(_WORD *)(v33 + 2) == (v32 & 0xFFF) )
        {
          if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v38 = is_thread_flag_57_or_38_set()) )
          {
            v38 = 1;
          }
          if ( (tls_data_offset_784_1 = tls_data_offset_784, *(_WORD *)(v33 + 4) == 2) && v38
            || check_handle_access_by_state_extended(v29) )
          {
            tls_data_offset_784_5 = tls_data_offset_784;
            v39 = *v29;
            if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(entity & 0xFFFFFFFFFFFFLL) + 0x58LL))(entity & 0xFFFFFFFFFFFFLL)
              || (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v39 & 0xFFFFFFFFFFFFLL) + 0x58LL))(v39 & 0xFFFFFFFFFFFFLL) )
            {
              tls_data_offset_784 = tls_data_offset_784_1;
            }
            else
            {
              tls_data_offset_784 = tls_data_offset_784_5;
              v65 = *v29;
              tls_data_offset_784_1 = tls_data_offset_784_5;
              if ( !(unsigned __int8)sub_1468C2120(entity, &v65) )
              {
                tls_data_offset_784_6 = *v29;
                tls_data_offset_784_1 = tls_data_offset_784_5;
                goto LABEL_94;
              }
            }
          }
        }
      }
      v41 = v59;
      *v29++ = 0;
      *(_DWORD *)(entity + 0x4F0) &= ~(1 << v59++);
    }
    while ( (unsigned __int64)(v41 + 1) < 3 );
    tls_data_offset_784_6 = 0;
LABEL_94:
    if ( (*(_BYTE *)(entity + 0x4F0) & 3) != 0
      && (is_valid_handle_typeB((unsigned __int64 *)(entity + 0x4D8))
       || *(_QWORD *)(entity + 0x4E0) != *(_QWORD *)(entity + 0x18)) )
    {
      for ( p_tls_data_offset_784_2 = tls_data_offset_784_6;
            (*(_BYTE *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x4F0) & 3) != 0
         && (is_valid_handle_typeB((unsigned __int64 *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x4D8))
          || *(_QWORD *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x4E0) != *(_QWORD *)((p_tls_data_offset_784_2
                                                                                             & 0xFFFFFFFFFFFFLL)
                                                                                            + 0x18));
            p_tls_data_offset_784_2 = *(_QWORD *)((p_tls_data_offset_784_2 & 0xFFFFFFFFFFFFLL) + 0x310) )
      {
        ;
      }
    }
    else
    {
      if ( ::tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v43 = 0;
        v44 = entity - 6;
      }
      else
      {
        v43 = 1;
        v44 = entity & 0xFFFFFFFFFF000000uLL;
      }
      v45 = *(_WORD *)(v44 + 2) | 0x2000;
      if ( !v43 )
      {
        v45 = *(_WORD *)(v44 + 2);
      }
      p_tls_data_offset_784_2 = entity | ((unsigned __int64)v45 << 0x30);
    }
    tls_data_offset_784_5 = tls_data_offset_784_6;
    if ( sub_1468E7C70(entity) )
    {
      if ( !is_valid_handle_typeB(&tls_data_offset_784_5)
        || (tls_data_offset_784_7 = tls_data_offset_784_5,
            (*(_DWORD *)((tls_data_offset_784_5 & 0xFFFFFFFFFFFFLL) + 0x110) & 0x2000) != 0) )
      {
        if ( ::tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + ::tls_data_offset_784_1 )
        {
          v47 = 0;
          v48 = entity - 6;
        }
        else
        {
          v47 = 1;
          v48 = entity & 0xFFFFFFFFFF000000uLL;
        }
        v49 = *(_WORD *)(v48 + 2) | 0x2000;
        if ( !v47 )
        {
          v49 = *(_WORD *)(v48 + 2);
        }
        tls_data_offset_784_7 = entity | ((unsigned __int64)v49 << 0x30);
        goto LABEL_125;
      }
    }
    else
    {
      tls_data_offset_784_7 = tls_data_offset_784_5;
    }
    if ( !sub_1468E7C70(tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL) )
    {
      v50 = tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL;
      do
      {
        tls_data_offset_784_7 = *(_QWORD *)(v50 + 0x310);
        v50 = tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL;
      }
      while ( !sub_1468E7C70(tls_data_offset_784_7 & 0xFFFFFFFFFFFFLL) );
      entity = tls_data_offset_784_3;
    }
LABEL_125:
    if ( tls_data_offset_784_10 != tls_data_offset_784_6
      || p_tls_data_offset_784_2 != p_tls_data_offset_784_1
      || tls_data_offset_784_8 != tls_data_offset_784_7 )
    {
      if ( *(_BYTE *)(entity + 0xD) >= 4u )
      {
        v52 = *(_DWORD *)(entity + 0x110);
        if ( (v52 & 0x10) == 0 && (v52 & 0x1800) != 0x1000 )
        {
          v102[0] = 0xD2;
          v91[0] = v102;
          v102[1] = 0x2C;
          v91[1] = &v103;
          v102[2] = 0x31;
          v60 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)v91,
                  (__int64)"Entities that cannot be replicated must not change parent (except during spawn or removal)",
                  "Entities that cannot be replicated must not change parent (except during spawn or removal) - reason=$$"
                  ", parent {name =\"$$\" id=$$}, child {name =\"$$\" id=$$}");
          if ( (v60 & 0xFFFFF) != 0 )
          {
            v95[1] = *(_QWORD *)(entity + 0x10);
            v86[1] = *(_QWORD *)(entity + 0x290);
            v95[0] = 0;
            v96 = 0;
            v86[0] = 0;
            ptr_to_free_3 = 0;
            v72 = 0;
            if ( tls_data_offset_784_1 )
            {
              v71[1] = *(_QWORD *)(tls_data_offset_784_1 + 0x10);
              p_No_Owner = *(const char **)(tls_data_offset_784_1 + 0x290);
              v71[0] = 0;
            }
            else
            {
              *(_OWORD *)v71 = 0;
              p_No_Owner = "No Owner";
            }
            v84[1] = (__int64)p_No_Owner;
            v92[1] = n4;
            v84[0] = 0;
            ptr_to_free_2 = 0;
            v92[0] = 0;
            ThreadLogContextSlot = getThreadLogContextSlot();
            v104[0] = 0xD2;
            *(_QWORD *)v93 = v104;
            v104[1] = 0x2C;
            v94 = &v105;
            v104[2] = 0x31;
            LODWORD(v57) = v60;
            v101 = 0;
            sub_1468AB010(
              3,
              (unsigned int)v93,
              (unsigned int)"Entities that cannot be replicated must not change parent (except during spawn or removal)",
              (unsigned int)"Entities that cannot be replicated must not change parent (except during spawn or removal) -"
                            " reason=$$, parent {name =\"$$\" id=$$}, child {name =\"$$\" id=$$}",
              1,
              (__int64)v57,
              &v101,
              0,
              ThreadLogContextSlot,
              (__int64)v92,
              (__int64)v84,
              (__int64)v71,
              (__int64)v86,
              (__int64)v95);
            free_memory_wrapper(ptr_to_free_2);
            free_memory_wrapper(ptr_to_free_3);
          }
        }
      }
      tls_data_offset_784_3 = tls_data_offset_784_8;
      tls_data_offset_784_9 = tls_data_offset_784_7;
      p_tls_data_offset_784 = p_tls_data_offset_784_1;
      *(_QWORD *)v68 = p_tls_data_offset_784_2;
      *(_QWORD *)v69 = tls_data_offset_784_10;
      *(_QWORD *)v70 = tls_data_offset_784_6;
      CEntity::OnAggregateHierarchyChanged(
        entity,
        (unsigned int)v70,
        (unsigned int)v69,
        (unsigned int)v68,
        &p_tls_data_offset_784,
        &tls_data_offset_784_9,
        &tls_data_offset_784_3,
        n4);
      v51 = dword_1497929DC;
      if ( dword_1497929DC )
      {
        goto LABEL_129;
      }
LABEL_139:
      dword_1497929D8 = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(&qword_1497929D0, 0, 0x200000);
      if ( n0x200000 != 0x200000 )
      {
        sub_1403D8A00(&qword_1497929D0, n0x200000);
      }
      goto LABEL_141;
    }
LABEL_128:
    v51 = dword_1497929DC;
    if ( dword_1497929DC )
    {
LABEL_129:
      dword_1497929DC = v51 - 1;
      goto LABEL_141;
    }
    goto LABEL_139;
  }
LABEL_141:
  v77 = __rdtsc();
  return psub_7FF6AAB93930(&n0xF00);
}

// --- End Function: CEntity::ChangeOwnerEntity (0x1468C1420) ---

// --- Function: sub_1468C20C0 (0x1468C20C0) ---
bool __fastcall sub_1468C20C0(__int64 a1, __int64 a2, __int64 tls_data_offset_784)
{
  return !(*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL) + 0x58LL))(
            a2 & 0xFFFFFFFFFFFFLL,
            a2 & 0xFFFFFFFFFFFFLL,
            tls_data_offset_784)
      && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x58LL))(a1 & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_1468C20C0 (0x1468C20C0) ---

// --- Function: sub_1468C2120 (0x1468C2120) ---
char __fastcall sub_1468C2120(unsigned __int64 tls_data_offset_784, __int64 *a2)
{
  __int64 i; // r8
  __int64 v4; // rbx
  bool v5; // al
  char v6; // dl
  unsigned __int64 v7; // rcx
  unsigned __int16 v8; // ax
  __int64 v10; // [rsp+48h] [rbp+10h] BYREF

  for ( i = *a2; ; i = *(_QWORD *)((v10 & 0xFFFFFFFFFFFFLL) + 0x310) )
  {
    v10 = i;
    if ( !i )
    {
      break;
    }
    v4 = (i & 0xF000000000000000uLL) != 0 ? i & 0xFFFFFF000000LL : (i & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v4 + 2) != (HIWORD(i) & 0xFFF) )
    {
      break;
    }
    if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v5 = is_thread_flag_57_or_38_set()) )
    {
      v5 = 1;
    }
    if ( (*(_WORD *)(v4 + 4) != 2 || !v5) && !check_handle_access_by_state_extended(&v10) )
    {
      break;
    }
    if ( tls_data_offset_784_1 > tls_data_offset_784 || tls_data_offset_784 >= qword_15126E3D8 + tls_data_offset_784_1 )
    {
      v6 = 0;
      v7 = tls_data_offset_784 - 6;
    }
    else
    {
      v6 = 1;
      v7 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
    }
    v8 = *(_WORD *)(v7 + 2) | 0x2000;
    if ( !v6 )
    {
      v8 = *(_WORD *)(v7 + 2);
    }
    if ( v10 == (tls_data_offset_784 | ((unsigned __int64)v8 << 0x30)) )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1468C2120 (0x1468C2120) ---

// --- Function: CEntity::ClearAllOwners (0x1468C23F0) ---
unsigned __int64 __fastcall CEntity::ClearAllOwners(unsigned __int64 tls_data_offset_784)
{
  int v2; // edi
  unsigned __int64 v3; // rax
  __int64 p_tls_data_offset_784_1; // rcx
  __int64 tls_data_offset_784_3; // rdx
  __int64 v6; // r8
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r9
  char v9; // bp
  unsigned __int64 v10; // r11
  unsigned __int16 v11; // ax
  unsigned __int64 v12; // rax
  char v13; // r10
  unsigned __int16 v14; // dx
  unsigned __int64 n0x200000; // rax
  unsigned int v16[2]; // [rsp+50h] [rbp-58h] BYREF
  unsigned int v17[2]; // [rsp+58h] [rbp-50h] BYREF
  __int64 v18; // [rsp+60h] [rbp-48h] BYREF
  __int64 tls_data_offset_784_2; // [rsp+B0h] [rbp+8h] BYREF
  __int64 tls_data_offset_784_1; // [rsp+B8h] [rbp+10h] BYREF
  __int64 p_tls_data_offset_784; // [rsp+C0h] [rbp+18h] BYREF
  unsigned __int64 v22; // [rsp+C8h] [rbp+20h] BYREF

  v2 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( dword_1497929D8 == v2 )
  {
    ++dword_1497929DC;
  }
  else
  {
    v3 = _InterlockedCompareExchange64(&qword_1497929D0, 0x200000, 0);
    if ( v3 )
    {
      sub_1403D85B0(&qword_1497929D0, v3, 0, (__int64)"CEntity::ClearAllOwners", (__int64)"s_aggregateHierarchyLock", 1);
    }
    dword_1497929D8 = v2;
  }
  p_tls_data_offset_784_1 = *(_QWORD *)(tls_data_offset_784 + 0x318);
  tls_data_offset_784_3 = *(_QWORD *)(tls_data_offset_784 + 0x320);
  v6 = *(_QWORD *)(tls_data_offset_784 + 0x310);
  *(_DWORD *)(tls_data_offset_784 + 0x4F0) = 0;
  *(_QWORD *)(tls_data_offset_784 + 0x4D8) = 0;
  *(_QWORD *)(tls_data_offset_784 + 0x4E0) = 0;
  *(_QWORD *)(tls_data_offset_784 + 0x4E8) = 0;
  if ( ::tls_data_offset_784_1 > tls_data_offset_784 || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
  {
    v9 = 0;
    v8 = tls_data_offset_784 - 6;
    v7 = tls_data_offset_784 - 6;
    v10 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
  }
  else
  {
    v7 = tls_data_offset_784 - 6;
    v8 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
    v9 = 1;
    v10 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
  }
  v11 = *(_WORD *)(v8 + 2) | 0x2000;
  if ( !v9 )
  {
    v11 = *(_WORD *)(v8 + 2);
  }
  v12 = tls_data_offset_784 | ((unsigned __int64)v11 << 0x30);
  if ( ::tls_data_offset_784_1 > tls_data_offset_784 || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
  {
    v13 = 0;
    v10 = v7;
  }
  else
  {
    v13 = 1;
  }
  tls_data_offset_784_2 = tls_data_offset_784_3;
  v14 = *(_WORD *)(v10 + 2) | 0x2000;
  v22 = v12;
  if ( !v13 )
  {
    v14 = *(_WORD *)(v10 + 2);
  }
  tls_data_offset_784_1 = tls_data_offset_784 | ((unsigned __int64)v14 << 0x30);
  p_tls_data_offset_784 = p_tls_data_offset_784_1;
  *(_QWORD *)v16 = v6;
  *(_QWORD *)v17 = 0;
  CEntity::OnAggregateHierarchyChanged(
    tls_data_offset_784,
    (unsigned int)v17,
    (unsigned int)v16,
    (unsigned int)&v22,
    &p_tls_data_offset_784,
    &tls_data_offset_784_1,
    &tls_data_offset_784_2,
    4u);
  v18 = 0;
  sub_1468E9770(tls_data_offset_784, &v18, 4);
  if ( dword_1497929DC )
  {
    return (unsigned int)--dword_1497929DC;
  }
  else
  {
    dword_1497929D8 = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64(&qword_1497929D0, 0, 0x200000);
    if ( n0x200000 != 0x200000 )
    {
      return sub_1403D8A00(&qword_1497929D0, n0x200000);
    }
  }
  return n0x200000;
}

// --- End Function: CEntity::ClearAllOwners (0x1468C23F0) ---

// --- Function: CEntity::DumpOwnerInfo (0x1468D1660) ---
unsigned __int64 __fastcall CEntity::DumpOwnerInfo(unsigned __int64 entity)
{
  signed __int64 v2; // rdx
  char v3; // dl
  unsigned __int64 v4; // rcx
  unsigned __int16 v5; // ax
  unsigned __int64 i; // rcx
  __int64 v7; // rbx
  bool v8; // al
  unsigned __int64 v10; // [rsp+40h] [rbp+8h] BYREF

  if ( dword_1497929D8 == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
  {
    ++dword_1497929DC;
  }
  else
  {
    v2 = _InterlockedIncrement64(&qword_1497929D0);
    if ( (v2 & 0x200000) != 0 )
    {
      sub_1403C6C70(&qword_1497929D0, v2, (__int64)"CEntity::DumpOwnerInfo", (__int64)"s_aggregateHierarchyLock", 1);
    }
  }
  if ( tls_data_offset_784_1 > entity || entity >= qword_15126E3D8 + tls_data_offset_784_1 )
  {
    v3 = 0;
    v4 = entity - 6;
  }
  else
  {
    v3 = 1;
    v4 = entity & 0xFFFFFFFFFF000000uLL;
  }
  v5 = *(_WORD *)(v4 + 2) | 0x2000;
  if ( !v3 )
  {
    v5 = *(_WORD *)(v4 + 2);
  }
  for ( i = entity | ((unsigned __int64)v5 << 0x30); ; i = *(_QWORD *)((v10 & 0xFFFFFFFFFFFFLL) + 0x310) )
  {
    v10 = i;
    if ( !i )
    {
      break;
    }
    v7 = (i & 0xF000000000000000uLL) != 0 ? i & 0xFFFFFF000000LL : (i & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v7 + 2) != (HIWORD(i) & 0xFFF) )
    {
      break;
    }
    if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v8 = is_thread_flag_57_or_38_set()) )
    {
      v8 = 1;
    }
    if ( (*(_WORD *)(v7 + 4) != 2 || !v8) && !check_handle_access_by_state_extended(&v10) )
    {
      break;
    }
    sub_1468F26E0(v10 & 0xFFFFFFFFFFFFLL);
  }
  return sub_1402D0950((__int64)&qword_1497929D0);
}

// --- End Function: CEntity::DumpOwnerInfo (0x1468D1660) ---

// --- Function: sub_1468D5530 (0x1468D5530) ---
unsigned __int64 __fastcall sub_1468D5530(unsigned __int64 a1, __int64 a2)
{
  signed __int64 v4; // rdx
  char v5; // dl
  unsigned __int64 v6; // rcx
  unsigned __int16 v7; // ax
  _QWORD *v8; // rsi
  _QWORD *i; // rbx

  if ( dword_1497929D8 == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
  {
    ++dword_1497929DC;
  }
  else
  {
    v4 = _InterlockedIncrement64(&qword_1497929D0);
    if ( (v4 & 0x200000) != 0 )
    {
      sub_1403C6C70(
        &qword_1497929D0,
        v4,
        (__int64)"CEntity::ForEachEntityInAggregate",
        (__int64)"s_aggregateHierarchyLock",
        1);
    }
  }
  if ( tls_data_offset_784_1 > a1 || a1 >= qword_15126E3D8 + tls_data_offset_784_1 )
  {
    v5 = 0;
    v6 = a1 - 6;
  }
  else
  {
    v5 = 1;
    v6 = a1 & 0xFFFFFFFFFF000000uLL;
  }
  v7 = *(_WORD *)(v6 + 2) | 0x2000;
  if ( !v5 )
  {
    v7 = *(_WORD *)(v6 + 2);
  }
  (*(void (__fastcall **)(_QWORD, unsigned __int64))(a2 + 8))(*(_QWORD *)a2, a1 | ((unsigned __int64)v7 << 0x30));
  v8 = *(_QWORD **)(a1 + 0x300);
  for ( i = *(_QWORD **)(a1 + 0x2F8); i != v8; ++i )
  {
    sub_1468D5650(*i & 0xFFFFFFFFFFFFLL, a2);
  }
  return sub_1402D0950((__int64)&qword_1497929D0);
}

// --- End Function: sub_1468D5530 (0x1468D5530) ---

// --- Function: sub_1468D8EC0 (0x1468D8EC0) ---
__int64 __fastcall sub_1468D8EC0(unsigned __int64 *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rcx

  if ( is_valid_handle_typeB(a1) )
  {
    if ( a2 == *(_QWORD *)(*(_QWORD *)((*a1 & 0xFFFFFFFFFFFFLL) + 0x328) + 0xB8LL) )
    {
      if ( is_valid_handle_typeB(a1) )
      {
        return *a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 0x20LL))(a2);
      v5 = result;
      if ( result )
      {
        if ( *(_BYTE *)(result + 0xD) >= 5u )
        {
          return 0;
        }
        return v5;
      }
    }
  }
  else if ( a2 == (*(__int64 (__fastcall **)(FH4 *))(*(_QWORD *)pCZoneSystem + 0x10LL))(pCZoneSystem) )
  {
    return 0;
  }
  else
  {
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 0x20LL))(a2);
  }
  return result;
}

// --- End Function: sub_1468D8EC0 (0x1468D8EC0) ---

// --- Function: sub_1468DEFD0 (0x1468DEFD0) ---
_QWORD *__fastcall sub_1468DEFD0(unsigned __int64 tls_data_offset_784, _QWORD *a2)
{
  __int64 v2; // rax
  volatile signed __int32 *v4; // r8
  __int64 v5; // r9
  signed __int32 v6; // eax
  signed __int32 v7; // ett

  v2 = *(_QWORD *)(tls_data_offset_784 + 0x2C8);
  if ( v2 && (v4 = *(volatile signed __int32 **)(v2 + 0x28)) != 0 )
  {
    v5 = *(_QWORD *)(v2 + 0x20);
    _InterlockedIncrement(v4 + 3);
    *a2 = 0;
    a2[1] = 0;
    v6 = *((_DWORD *)v4 + 2);
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = v6;
        v6 = _InterlockedCompareExchange(v4 + 2, v6 + 1, v6);
        if ( v7 == v6 )
        {
          break;
        }
        if ( !v6 )
        {
          goto LABEL_8;
        }
      }
      *a2 = v5;
      a2[1] = v4;
    }
LABEL_8:
    if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
    {
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
      return a2;
    }
  }
  else
  {
    a2[1] = 0;
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1468DEFD0 (0x1468DEFD0) ---

// --- Function: sub_1468E7840 (0x1468E7840) ---
bool __fastcall sub_1468E7840(unsigned __int64 tls_data_offset_784)
{
  return tls_data_offset_784_1 <= tls_data_offset_784 && tls_data_offset_784 < qword_15126E3D8 + tls_data_offset_784_1;
}

// --- End Function: sub_1468E7840 (0x1468E7840) ---

// --- Function: sub_1468E7C70 (0x1468E7C70) ---
bool __fastcall sub_1468E7C70(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  if ( (*(_DWORD *)(a1 + 0x110) & 0x1800) == 0x1000
    && is_valid_handle_typeB((unsigned __int64 *)(a1 + 0x310))
    && (((unsigned __int8)(*(_DWORD *)(a1 + 0x110) >> 0xD)
       ^ (unsigned __int8)(*(_DWORD *)((*(_QWORD *)(a1 + 0x310) & 0xFFFFFFFFFFFFLL) + 0x110) >> 0xD))
      & 1) != 0 )
  {
    return 1;
  }
  if ( (*(_BYTE *)(a1 + 0x4F0) & 3) == 0 )
  {
    v4 = *(_QWORD *)(a1 + 0x4E8);
    if ( is_valid_handle_typeB(&v4) )
    {
      v2 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 0x658LL))(v4 & 0xFFFFFFFFFFFFLL);
      if ( v2 )
      {
        return (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x48LL))(v2) != 2;
      }
    }
    return 1;
  }
  return 0;
}

// --- End Function: sub_1468E7C70 (0x1468E7C70) ---

// --- Function: sub_1468E9770 (0x1468E9770) ---
void __fastcall sub_1468E9770(unsigned __int64 tls_data_offset_784, unsigned __int64 *a2, int n4)
{
  int v6; // r13d
  __int64 v7; // r14
  __int64 v8; // r15
  const char *_no_owner; // rbp
  const char *_no_owner_1; // rdi
  void **v11; // rax
  void **v12; // rbx
  _QWORD *v13; // rax
  void **v14; // rax
  void **v15; // rax
  void **v16; // rbx
  _QWORD *v17; // rax
  void **v18; // rax
  void **v19; // rax
  void **v20; // rbx
  _QWORD *v21; // rax
  void **v22; // rax
  __int64 string_struct_ptr__1; // [rsp+60h] [rbp-38h] BYREF
  __int64 v24; // [rsp+68h] [rbp-30h] BYREF
  void *string_struct_ptr_; // [rsp+B8h] [rbp+20h] BYREF

  if ( BYTE1(isEditor) && dword_15126E23C )
  {
    initializeEmptyStringStructure(&string_struct_ptr_);
    v6 = *(_DWORD *)(tls_data_offset_784 + 0x4F0);
    v7 = 0;
    if ( is_valid_handle_typeB((unsigned __int64 *)(tls_data_offset_784 + 0x310)) )
    {
      v8 = *(_QWORD *)((*(_QWORD *)(tls_data_offset_784 + 0x310) & 0xFFFFFFFFFFFFLL) + 0x10);
    }
    else
    {
      v8 = 0;
    }
    _no_owner = "<no owner>";
    if ( is_valid_handle_typeB((unsigned __int64 *)(tls_data_offset_784 + 0x310)) )
    {
      _no_owner_1 = *(const char **)((*(_QWORD *)(tls_data_offset_784 + 0x310) & 0xFFFFFFFFFFFFLL) + 0x290);
    }
    else
    {
      _no_owner_1 = "<no owner>";
    }
    if ( is_valid_handle_typeB(a2) )
    {
      v7 = *(_QWORD *)((*a2 & 0xFFFFFFFFFFFFLL) + 0x10);
    }
    if ( is_valid_handle_typeB(a2) )
    {
      _no_owner = *(const char **)((*a2 & 0xFFFFFFFFFFFFLL) + 0x290);
    }
    sub_1403A5050(
      &string_struct_ptr_,
      "%s: eReason=%d entity {name =\"%s\" id=%llu} owner {name=\"%s\" id=%llu} actual owner {name=\"%s\" id=%llu} mask=0x%08x",
      "CEntity::LogAggregateParentChange",
      n4,
      *(const char **)(tls_data_offset_784 + 0x290),
      *(_QWORD *)(tls_data_offset_784 + 0x10),
      _no_owner,
      v7,
      _no_owner_1,
      v8,
      v6);
    initializeEmptyStringStructure(&string_struct_ptr__1);
    v12 = v11;
    v13 = sub_1403AC900((unsigned __int64 *)(tls_data_offset_784 + 0x4D8), &v24);
    v14 = sub_1403A5050(v12, " reasonOwner[%s=%zu]=%llu", "ITEM_PORT", 0, *v13);
    sub_140380E40(&string_struct_ptr_, (char **)v14);
    DestroyStringObject(&string_struct_ptr__1);
    initializeEmptyStringStructure(&string_struct_ptr__1);
    v16 = v15;
    v17 = sub_1403AC900((unsigned __int64 *)(tls_data_offset_784 + 0x4E0), &v24);
    v18 = sub_1403A5050(v16, " reasonOwner[%s=%zu]=%llu", "ATTACHMENT", 1u, *v17);
    sub_140380E40(&string_struct_ptr_, (char **)v18);
    DestroyStringObject(&string_struct_ptr__1);
    initializeEmptyStringStructure(&string_struct_ptr__1);
    v20 = v19;
    v21 = sub_1403AC900((unsigned __int64 *)(tls_data_offset_784 + 0x4E8), &v24);
    v22 = sub_1403A5050(v20, " reasonOwner[%s=%zu]=%llu", "ZONE", 2u, *v21);
    sub_140380E40(&string_struct_ptr_, (char **)v22);
    DestroyStringObject(&string_struct_ptr__1);
    LogTraceConditional((const char *)&fmt, string_struct_ptr_);
    DestroyStringObject(&string_struct_ptr_);
  }
}

// --- End Function: sub_1468E9770 (0x1468E9770) ---

// --- Function: CEntity::OnAggregateHierarchyChanged (0x1468ED340) ---
double __fastcall CEntity::OnAggregateHierarchyChanged(
        unsigned __int64 tls_data_offset_784,
        unsigned __int64 *a2,
        __int64 *a3,
        __int64 *a4,
        __int64 *p_tls_data_offset_784,
        __int64 *p_tls_data_offset_784a,
        __int64 *tls_data_offset_784a_2,
        unsigned int n4)
{
  __int64 v9; // rcx
  unsigned __int64 *p_tls_data_offset_784a_1; // rdi
  unsigned __int64 *tls_data_offset_784a; // r15
  unsigned __int64 v15; // r12
  unsigned __int64 v16; // r13
  __int64 *tls_data_offset_784a_3; // rcx
  __int64 *tls_data_offset_784a_1; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // rdx
  __int64 v22; // rax
  unsigned __int64 v23; // r9
  char v24; // dl
  unsigned __int64 v25; // rcx
  unsigned __int16 v26; // ax
  bool v27; // zf
  unsigned __int64 *v28; // rdx
  __int64 tls_data_offset_784_3; // rax
  __int64 tls_data_offset_784_4; // rax
  __int64 *tls_data_offset_784a_5; // rax
  __int64 *v32; // rdi
  __int64 tls_data_offset_784_5; // r15
  char v34; // dl
  unsigned __int64 v35; // rcx
  unsigned __int16 v36; // ax
  int v37; // ebx
  unsigned __int64 v38; // rax
  unsigned __int64 n0x200000; // rax
  __int64 v40; // rdi
  __int64 tls_data_offset_784_6; // rbx
  __int64 v42; // rsi
  _QWORD *v43; // r14
  _QWORD *i; // rsi
  double result; // xmm0_8
  __int64 tls_data_offset_784_1; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v47; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v48; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v49; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v50; // [rsp+50h] [rbp-B0h] BYREF
  _QWORD v51[2]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 tls_data_offset_784a_4; // [rsp+68h] [rbp-98h] BYREF
  unsigned int v53[2]; // [rsp+70h] [rbp-90h] BYREF
  unsigned int v54[2]; // [rsp+78h] [rbp-88h] BYREF
  unsigned int v55[2]; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v56[2]; // [rsp+88h] [rbp-78h] BYREF
  unsigned __int64 v57; // [rsp+90h] [rbp-70h] BYREF
  __int64 p_p_sub_1467B7D90; // [rsp+98h] [rbp-68h] BYREF
  __int64 v59; // [rsp+A0h] [rbp-60h]
  _QWORD v60[3]; // [rsp+A8h] [rbp-58h] BYREF
  int n0xF00; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v62; // [rsp+C4h] [rbp-3Ch]
  int v63; // [rsp+CCh] [rbp-34h]
  __int64 v64; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v65; // [rsp+D8h] [rbp-28h]
  __int64 v66; // [rsp+E0h] [rbp-20h]
  __int64 v67; // [rsp+E8h] [rbp-18h]
  unsigned __int64 v68; // [rsp+160h] [rbp+60h] BYREF
  unsigned __int64 v69; // [rsp+168h] [rbp+68h] BYREF
  __int64 *v70; // [rsp+170h] [rbp+70h] BYREF
  __int64 tls_data_offset_784_2; // [rsp+178h] [rbp+78h] BYREF

  v70 = a3;
  v9 = *(_QWORD *)(tls_data_offset_784 + 0x2A8);
  v59 = v9;
  if ( n4 == 4 )
  {
    v48 = 0;
  }
  else
  {
    v49 = *a2;
    v48 = sub_1468D8EC0(&v49, v9);
  }
  p_tls_data_offset_784a_1 = (unsigned __int64 *)p_tls_data_offset_784a;
  tls_data_offset_784a = (unsigned __int64 *)tls_data_offset_784a_2;
  v15 = *a2;
  v16 = *a3;
  tls_data_offset_784_2 = *a4;
  tls_data_offset_784a_3 = (__int64 *)*tls_data_offset_784a_2;
  tls_data_offset_784a_2 = (__int64 *)*tls_data_offset_784a_2;
  tls_data_offset_784_1 = *p_tls_data_offset_784;
  tls_data_offset_784a_1 = (__int64 *)*p_tls_data_offset_784a;
  p_tls_data_offset_784a = (__int64 *)*p_tls_data_offset_784a;
  if ( v15 != v16 )
  {
    v68 = v16;
    v69 = v15;
    if ( is_valid_handle_typeB(&v68) )
    {
      v19 = v68;
      v20 = *(unsigned int *)(tls_data_offset_784 + 0x2EC);
      v21 = (__int64)(*(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x300) - *(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x2F8)) >> 3;
      if ( v20 != v21 - 1 )
      {
        v22 = *(_QWORD *)(*(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x300) - 8LL);
        if ( v21 <= v20 )
        {
          __debugbreak();
        }
        *(_QWORD *)(*(_QWORD *)((v68 & 0xFFFFFFFFFFFFLL) + 0x2F8) + 8 * v20) = v22;
        *(_DWORD *)((v22 & 0xFFFFFFFFFFFFLL) + 0x2EC) = *(_DWORD *)(tls_data_offset_784 + 0x2EC);
        v19 = v68;
      }
      *(_QWORD *)((v19 & 0xFFFFFFFFFFFFLL) + 0x300) -= 8LL;
      *(_DWORD *)(tls_data_offset_784 + 0x2EC) = 0xFFFFFFFF;
      *(_QWORD *)(tls_data_offset_784 + 0x310) = 0;
    }
    if ( is_valid_handle_typeB(&v69) )
    {
      v23 = (v69 & 0xFFFFFFFFFFFFLL) + 0x2F8;
      *(_DWORD *)(tls_data_offset_784 + 0x2EC) = (__int64)(*(_QWORD *)((v69 & 0xFFFFFFFFFFFFLL) + 0x300)
                                                         - *(_QWORD *)((v69 & 0xFFFFFFFFFFFFLL) + 0x2F8)) >> 3;
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v24 = 0;
        v25 = tls_data_offset_784 - 6;
      }
      else
      {
        v24 = 1;
        v25 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v26 = *(_WORD *)(v25 + 2) | 0x2000;
      v27 = v24 == 0;
      v28 = *(unsigned __int64 **)(v23 + 8);
      if ( v27 )
      {
        v26 = *(_WORD *)(v25 + 2);
      }
      v47 = tls_data_offset_784 | ((unsigned __int64)v26 << 0x30);
      if ( v28 == *(unsigned __int64 **)(v23 + 0x10) )
      {
        sub_1468A5EB0(v23, v28, &v47);
      }
      else
      {
        *v28 = tls_data_offset_784 | ((unsigned __int64)v26 << 0x30);
        *(_QWORD *)(v23 + 8) += 8LL;
        v47 = 0;
      }
      *(_QWORD *)(tls_data_offset_784 + 0x310) = v69;
    }
    tls_data_offset_784a_3 = tls_data_offset_784a_2;
    tls_data_offset_784a_1 = p_tls_data_offset_784a;
  }
  if ( tls_data_offset_784_2 == tls_data_offset_784_1 )
  {
    if ( tls_data_offset_784a_1 == tls_data_offset_784a_3 )
    {
      goto LABEL_37;
    }
  }
  else
  {
    v50 = *a4;
    v60[0] = &v50;
    v60[1] = sub_14689FFD0;
    sub_1468D5530(tls_data_offset_784, (__int64)v60);
    v60[0] = 0xFFFFFFFFFFFFFFFFuLL;
  }
  v51[0] = *p_tls_data_offset_784;
  sub_1468EDEA0(qword_15126E2D8, tls_data_offset_784, a4, v51, p_tls_data_offset_784a_1);
  tls_data_offset_784a_1 = p_tls_data_offset_784a;
  tls_data_offset_784a_3 = tls_data_offset_784a_2;
  if ( p_tls_data_offset_784a != tls_data_offset_784a_2 )
  {
    v51[1] = *tls_data_offset_784a;
    tls_data_offset_784a_4 = *p_tls_data_offset_784a_1;
    sub_1468F0740(tls_data_offset_784, &tls_data_offset_784a_4);
    if ( is_valid_handle_typeB(p_tls_data_offset_784a_1) )
    {
      tls_data_offset_784_3 = *p_tls_data_offset_784a_1 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      tls_data_offset_784_3 = 0;
    }
    if ( tls_data_offset_784_3 == tls_data_offset_784
      || (is_valid_handle_typeB(tls_data_offset_784a)
        ? (tls_data_offset_784_4 = *tls_data_offset_784a & 0xFFFFFFFFFFFFLL)
        : (tls_data_offset_784_4 = 0),
          tls_data_offset_784_4 == tls_data_offset_784) )
    {
      sub_146900A50(tls_data_offset_784, 0xC0);
    }
    tls_data_offset_784a_3 = tls_data_offset_784a_2;
    tls_data_offset_784a_1 = p_tls_data_offset_784a;
  }
LABEL_37:
  if ( v15 == v16 && tls_data_offset_784a_1 == tls_data_offset_784a_3 )
  {
    v32 = v70;
LABEL_46:
    tls_data_offset_784_5 = tls_data_offset_784_2;
    if ( tls_data_offset_784_2 == tls_data_offset_784_1 )
    {
      goto LABEL_52;
    }
    goto LABEL_41;
  }
  p_tls_data_offset_784a = (__int64 *)*tls_data_offset_784a;
  tls_data_offset_784a_5 = (__int64 *)*p_tls_data_offset_784a_1;
  v32 = v70;
  tls_data_offset_784a_2 = tls_data_offset_784a_5;
  v70 = (__int64 *)*v70;
  *(_QWORD *)v53 = *a2;
  sub_1468ED950(
    tls_data_offset_784,
    (unsigned int)v53,
    (unsigned int)&v70,
    (unsigned int)&tls_data_offset_784a_2,
    &p_tls_data_offset_784a);
  if ( v15 == v16 )
  {
    goto LABEL_46;
  }
  tls_data_offset_784_5 = tls_data_offset_784_2;
LABEL_41:
  tls_data_offset_784_2 = *p_tls_data_offset_784;
  *(_QWORD *)v54 = *a4;
  *(_QWORD *)v55 = *v32;
  *(_QWORD *)v56 = *a2;
  sub_1468EDCA0(tls_data_offset_784, (unsigned int)v56, (unsigned int)v55, (unsigned int)v54, &tls_data_offset_784_2);
  if ( v15 != v16 )
  {
    v57 = *a2;
    sub_1468E9770(tls_data_offset_784, &v57, n4);
    if ( ::tls_data_offset_784_1 > tls_data_offset_784
      || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
    {
      v34 = 0;
      v35 = tls_data_offset_784 - 6;
    }
    else
    {
      v34 = 1;
      v35 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
    }
    v36 = *(_WORD *)(v35 + 2) | 0x2000;
    if ( !v34 )
    {
      v36 = *(_WORD *)(v35 + 2);
    }
    p_p_sub_1467B7D90 = tls_data_offset_784 | ((unsigned __int64)v36 << 0x30);
    sub_1467CDA70(::tls_data_offset_784, (__int64)&p_p_sub_1467B7D90, a2, v32, a4);
  }
LABEL_52:
  v37 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( dword_1497929C8 == v37 )
  {
    ++dword_1497929CC;
  }
  else
  {
    v38 = _InterlockedCompareExchange64(&qword_1497929C0, 0x200000, 0);
    if ( v38 )
    {
      sub_1403D85B0(
        &qword_1497929C0,
        v38,
        0,
        (__int64)"CEntity::OnAggregateHierarchyChanged",
        (__int64)"CEntityAggregateRadius::s_aggregateRadiusHierarchyLock",
        1);
    }
    dword_1497929C8 = v37;
  }
  sub_1469080C0(tls_data_offset_784, v48, v59);
  if ( *(_BYTE *)(tls_data_offset_784 + 0xD) >= 5u
    && *(_DWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x40LL) != 0xFFFFFFFF )
  {
    __debugbreak();
  }
  if ( dword_1497929CC )
  {
    --dword_1497929CC;
  }
  else
  {
    dword_1497929C8 = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64(&qword_1497929C0, 0, 0x200000);
    if ( n0x200000 != 0x200000 )
    {
      sub_1403D8A00(&qword_1497929C0, n0x200000);
    }
  }
  if ( *(_BYTE *)(tls_data_offset_784 + 0xD) >= 5u
    && *(_DWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x40LL) != 0xFFFFFFFF )
  {
    __debugbreak();
  }
  if ( tls_data_offset_784_5 != tls_data_offset_784_1 )
  {
    v40 = *a4;
    v65 = 0;
    v66 = 0;
    tls_data_offset_784_6 = *p_tls_data_offset_784;
    n0xF00 = 0xF00;
    v62 = 0;
    v63 = 0;
    v67 = 0;
    v64 = 1;
    psub_7FF6AAB938D0(
      &n0xF00,
      0,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      0);
    v42 = *(_QWORD *)(tls_data_offset_784 + 0x330);
    if ( v42 )
    {
      v43 = *(_QWORD **)(v42 + 8);
      for ( i = *(_QWORD **)v42; i != v43; ++i )
      {
        (*(void (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*i + 0x508LL))(*i, v40, tls_data_offset_784_6);
      }
    }
    v65 = __rdtsc();
    return psub_7FF6AAB93930(&n0xF00);
  }
  return result;
}

// --- End Function: CEntity::OnAggregateHierarchyChanged (0x1468ED340) ---

// --- Function: sub_1468ED950 (0x1468ED950) ---
char __fastcall sub_1468ED950(
        unsigned __int64 tls_data_offset_784,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 *p_tls_data_offset_784a,
        __int64 **p_p_tls_data_offset_784a)
{
  __int64 tls_data_offset_784_2; // rbp
  unsigned __int64 v10; // rax
  __int64 *v11; // rsi
  __int64 *i; // rbx
  __int64 __Val_0__; // rdi
  unsigned int v14; // r15d
  __int64 v15; // rbp
  bool v16; // al
  __int64 v17; // rbp
  bool v18; // al
  unsigned __int64 tls_data_offset_784_1; // [rsp+20h] [rbp-38h]
  __int64 tls_data_offset_784_3; // [rsp+60h] [rbp+8h]

  tls_data_offset_784_2 = 0;
  tls_data_offset_784_3 = 0;
  if ( is_valid_handle_typeB((unsigned __int64 *)p_p_tls_data_offset_784a) )
  {
    tls_data_offset_784_1 = (unsigned __int64)*p_p_tls_data_offset_784a & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    tls_data_offset_784_1 = 0;
  }
  LOBYTE(v10) = is_valid_handle_typeB(p_tls_data_offset_784a);
  if ( (_BYTE)v10 )
  {
    tls_data_offset_784_2 = *p_tls_data_offset_784a & 0xFFFFFFFFFFFFLL;
    tls_data_offset_784_3 = tls_data_offset_784_2;
  }
  v11 = *(__int64 **)(tls_data_offset_784 + 0x358);
  for ( i = *(__int64 **)(tls_data_offset_784 + 0x350); i != v11; ++i )
  {
    __Val_0__ = *i;
    v14 = HIDWORD(*i);
    if ( tls_data_offset_784_1 != tls_data_offset_784 )
    {
      v10 = *a3;
      if ( *a3 )
      {
        v10 >>= 0x30;
        if ( (v10 & 0xF000) != 0 )
        {
          v15 = *a3 & 0xFFFFFF000000LL;
        }
        else
        {
          v15 = (*a3 & 0xFFFFFFFFFFFFLL) - 6;
        }
        LOWORD(v10) = v10 & 0xFFF;
        if ( *(_WORD *)(v15 + 2) == (_WORD)v10 )
        {
          if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v16 = is_thread_flag_57_or_38_set()) )
          {
            v16 = 1;
          }
          if ( *(_WORD *)(v15 + 4) == 2 && v16 || (LOBYTE(v10) = check_handle_access_by_state_extended(a3), (_BYTE)v10) )
          {
            LOBYTE(v10) = CEntity::UpdateComponentEventHandlers_OnEntityComponentUnregister(
                            (_QWORD *)(*a3 & 0xFFFFFFFFFFFFLL),
                            __Val_0__,
                            v14);
          }
        }
        tls_data_offset_784_2 = tls_data_offset_784_3;
      }
    }
    if ( tls_data_offset_784_2 != tls_data_offset_784 )
    {
      v10 = *a2;
      if ( *a2 )
      {
        v10 >>= 0x30;
        if ( (v10 & 0xF000) != 0 )
        {
          v17 = *a2 & 0xFFFFFF000000LL;
        }
        else
        {
          v17 = (*a2 & 0xFFFFFFFFFFFFLL) - 6;
        }
        LOWORD(v10) = v10 & 0xFFF;
        if ( *(_WORD *)(v17 + 2) == (_WORD)v10 )
        {
          if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v18 = is_thread_flag_57_or_38_set()) )
          {
            v18 = 1;
          }
          if ( *(_WORD *)(v17 + 4) == 2 && v18 || (LOBYTE(v10) = check_handle_access_by_state_extended(a2), (_BYTE)v10) )
          {
            LOBYTE(v10) = CEntity::UpdateComponentEventHandlers_OnEntityComponentRegister(
                            *a2 & 0xFFFFFFFFFFFFLL,
                            __Val_0__,
                            v14);
          }
          tls_data_offset_784_2 = tls_data_offset_784_3;
        }
        else
        {
          tls_data_offset_784_2 = tls_data_offset_784_3;
        }
      }
    }
  }
  return v10;
}

// --- End Function: sub_1468ED950 (0x1468ED950) ---

// --- Function: sub_1468EDCA0 (0x1468EDCA0) ---
char __fastcall sub_1468EDCA0(
        unsigned __int64 tls_data_offset_784,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 *a4,
        __int64 *p_tls_data_offset_784)
{
  __int64 tls_data_offset_784_2; // r12
  __int64 tls_data_offset_784_1; // r13
  unsigned __int64 v11; // rax
  __int64 *v12; // rcx
  __int64 *v13; // rdi
  __int64 v14; // rsi
  __int64 v15; // rbx
  bool v16; // al
  __int64 v17; // rbx
  bool v18; // al
  __int64 *i; // [rsp+50h] [rbp+8h]

  tls_data_offset_784_2 = 0;
  if ( is_valid_handle_typeB((unsigned __int64 *)p_tls_data_offset_784) )
  {
    tls_data_offset_784_1 = *p_tls_data_offset_784 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    tls_data_offset_784_1 = 0;
  }
  if ( is_valid_handle_typeB(a4) )
  {
    tls_data_offset_784_2 = *a4 & 0xFFFFFFFFFFFFLL;
  }
  v11 = *(_QWORD *)(tls_data_offset_784 + 0x330);
  if ( v11 )
  {
    v12 = *(__int64 **)(v11 + 8);
    v13 = *(__int64 **)v11;
    for ( i = v12; v13 != v12; ++v13 )
    {
      v14 = *v13;
      if ( tls_data_offset_784_1 != tls_data_offset_784 )
      {
        v11 = *a3;
        if ( *a3 )
        {
          v11 >>= 0x30;
          v15 = (v11 & 0xF000) != 0 ? *a3 & 0xFFFFFF000000LL : (*a3 & 0xFFFFFFFFFFFFLL) - 6;
          LOWORD(v11) = v11 & 0xFFF;
          if ( *(_WORD *)(v15 + 2) == (_WORD)v11 )
          {
            if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v16 = is_thread_flag_57_or_38_set()) )
            {
              v16 = 1;
            }
            if ( *(_WORD *)(v15 + 4) == 2 && v16
              || (LOBYTE(v11) = check_handle_access_by_state_extended(a3), (_BYTE)v11) )
            {
              LOBYTE(v11) = sub_14690A180(*a3 & 0xFFFFFFFFFFFFLL, v14);
            }
            v12 = i;
          }
        }
      }
      if ( tls_data_offset_784_2 != tls_data_offset_784 )
      {
        v11 = *a2;
        if ( *a2 )
        {
          v11 >>= 0x30;
          v17 = (v11 & 0xF000) != 0 ? *a2 & 0xFFFFFF000000LL : (*a2 & 0xFFFFFFFFFFFFLL) - 6;
          LOWORD(v11) = v11 & 0xFFF;
          if ( *(_WORD *)(v17 + 2) == (_WORD)v11 )
          {
            if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v18 = is_thread_flag_57_or_38_set()) )
            {
              v18 = 1;
            }
            if ( *(_WORD *)(v17 + 4) == 2 && v18
              || (LOBYTE(v11) = check_handle_access_by_state_extended(a2), (_BYTE)v11) )
            {
              LOBYTE(v11) = sub_14690A090(*a2 & 0xFFFFFFFFFFFFLL, v14);
            }
            v12 = i;
          }
        }
      }
    }
  }
  return v11;
}

// --- End Function: sub_1468EDCA0 (0x1468EDCA0) ---

// --- Function: sub_1468EDEA0 (0x1468EDEA0) ---
double __fastcall sub_1468EDEA0(
        __int64 a1,
        unsigned __int64 tls_data_offset_784,
        unsigned __int64 *a3,
        unsigned __int64 *a4)
{
  char v8; // dl
  unsigned __int64 v9; // rcx
  unsigned __int16 v10; // ax
  volatile signed __int64 *v11; // r15
  int v12; // ebx
  unsigned __int64 v13; // rax
  __int64 tls_data_offset_784_2; // rbx
  __int64 tls_data_offset_784_1; // rax
  __int64 v16; // rcx
  __int64 v17; // r13
  char v18; // bl
  __int64 v19; // rsi
  __int64 v20; // rdx
  int v21; // eax
  __int64 v22; // rdx
  char v23; // bl
  __int64 v24; // rcx
  __int64 v25; // rbx
  char v26; // al
  __int64 v27; // rdx
  __int64 v28; // rax
  __int64 v29; // rcx
  __int64 v30; // r13
  char v31; // bl
  __int64 v32; // rsi
  __int64 v33; // rdx
  int v34; // eax
  __int64 v35; // rdx
  __int64 v36; // rdx
  __int64 v37; // rbx
  char v38; // al
  __int64 v39; // rdx
  __int64 v40; // r8
  __int64 v41; // rdx
  char v42; // al
  __int64 v43; // rsi
  __int64 v44; // rdx
  int v45; // eax
  __int64 v46; // rdx
  char v47; // bl
  __int64 v48; // rcx
  __int64 v49; // rbx
  char v50; // al
  __int64 v51; // rdx
  __int64 v52; // rax
  __int64 v53; // rbx
  char v54; // r14
  __int64 v55; // rax
  char v56; // al
  __int64 v57; // rdx
  char v58; // r14
  __int64 v59; // rdx
  int v60; // eax
  unsigned __int64 n0x200000; // rax
  char v63; // [rsp+30h] [rbp-D0h] BYREF
  char v64; // [rsp+31h] [rbp-CFh] BYREF
  char v65; // [rsp+32h] [rbp-CEh] BYREF
  char v66; // [rsp+33h] [rbp-CDh] BYREF
  char v67; // [rsp+34h] [rbp-CCh] BYREF
  char v68; // [rsp+35h] [rbp-CBh] BYREF
  unsigned __int64 v69; // [rsp+38h] [rbp-C8h] BYREF
  __int128 *v70; // [rsp+40h] [rbp-C0h] BYREF
  _OWORD *v71; // [rsp+48h] [rbp-B8h] BYREF
  _OWORD *v72; // [rsp+50h] [rbp-B0h] BYREF
  int n0x1000; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v74; // [rsp+64h] [rbp-9Ch]
  int v75; // [rsp+6Ch] [rbp-94h]
  __int64 v76; // [rsp+70h] [rbp-90h]
  unsigned __int64 v77; // [rsp+78h] [rbp-88h]
  __int64 v78; // [rsp+80h] [rbp-80h]
  __int64 v79; // [rsp+88h] [rbp-78h]
  _QWORD v80[2]; // [rsp+B0h] [rbp-50h] BYREF
  _QWORD v81[2]; // [rsp+C0h] [rbp-40h] BYREF
  _QWORD v82[2]; // [rsp+D0h] [rbp-30h] BYREF
  _DWORD v83[4]; // [rsp+E0h] [rbp-20h] BYREF
  char v84; // [rsp+F0h] [rbp-10h]
  _DWORD v85[4]; // [rsp+118h] [rbp+18h] BYREF
  char v86; // [rsp+128h] [rbp+28h]
  _DWORD v87[4]; // [rsp+150h] [rbp+50h] BYREF
  char v88; // [rsp+160h] [rbp+60h]
  _DWORD v89[4]; // [rsp+188h] [rbp+88h] BYREF
  char v90; // [rsp+198h] [rbp+98h]
  _DWORD v91[4]; // [rsp+1C0h] [rbp+C0h] BYREF
  char v92; // [rsp+1D0h] [rbp+D0h]
  _DWORD v93[4]; // [rsp+1F8h] [rbp+F8h] BYREF
  char v94; // [rsp+208h] [rbp+108h]
  _DWORD v95[4]; // [rsp+230h] [rbp+130h] BYREF
  char v96; // [rsp+240h] [rbp+140h]
  _DWORD v97[4]; // [rsp+268h] [rbp+168h] BYREF
  char v98; // [rsp+278h] [rbp+178h]
  __int128 v99; // [rsp+2A0h] [rbp+1A0h] BYREF
  __int128 v100; // [rsp+2B0h] [rbp+1B0h] BYREF
  __int128 v101; // [rsp+2C0h] [rbp+1C0h]
  __int128 v102; // [rsp+2D0h] [rbp+1D0h] BYREF
  __int128 v103; // [rsp+2E0h] [rbp+1E0h] BYREF
  __int128 v104; // [rsp+2F0h] [rbp+1F0h]
  __int64 v105; // [rsp+300h] [rbp+200h]
  __int64 v106; // [rsp+308h] [rbp+208h]
  __int64 v107; // [rsp+310h] [rbp+210h]
  __int16 v108; // [rsp+318h] [rbp+218h]
  _OWORD v109[6]; // [rsp+320h] [rbp+220h] BYREF
  __int64 v110; // [rsp+380h] [rbp+280h]
  __int64 v111; // [rsp+388h] [rbp+288h]
  __int64 v112; // [rsp+390h] [rbp+290h]
  __int16 v113; // [rsp+398h] [rbp+298h]
  _OWORD v114[6]; // [rsp+3A0h] [rbp+2A0h] BYREF
  __int64 v115; // [rsp+400h] [rbp+300h]
  __int64 v116; // [rsp+408h] [rbp+308h]
  __int64 v117; // [rsp+410h] [rbp+310h]
  __int16 v118; // [rsp+418h] [rbp+318h]

  n0x1000 = 0x1000;
  v74 = 0;
  v75 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v76 = 1;
  psub_7FF6AAB938D0(
    &n0x1000,
    0,
    &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  if ( (*(_DWORD *)(tls_data_offset_784 + 8) & 0x100) != 0 )
  {
    if ( (*(_DWORD *)((*a4 & 0xFFFFFFFFFFFFLL) + 8) & 0x100) == 0 )
    {
      if ( ::tls_data_offset_784_1 > tls_data_offset_784
        || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v8 = 0;
        v9 = tls_data_offset_784 - 6;
      }
      else
      {
        v8 = 1;
        v9 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
      }
      v10 = *(_WORD *)(v9 + 2) | 0x2000;
      if ( !v8 )
      {
        v10 = *(_WORD *)(v9 + 2);
      }
      *a4 = tls_data_offset_784 | ((unsigned __int64)v10 << 0x30);
    }
    v11 = (volatile signed __int64 *)(a1 + 8);
    v12 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
    if ( *(_DWORD *)(a1 + 0x10) == v12 )
    {
      ++*(_DWORD *)(a1 + 0x14);
    }
    else
    {
      v13 = _InterlockedCompareExchange64(v11, 0x200000, 0);
      if ( v13 )
      {
        sub_1403D85B0(
          (volatile signed __int64 *)(a1 + 8),
          v13,
          0,
          (__int64)"CEntityAggregateManager::OnAggregateRootsChanged",
          (__int64)"m_UpdateQueueLock",
          1);
      }
      *(_DWORD *)(a1 + 0x10) = v12;
    }
    sub_146913C90((int *)a1);
    if ( is_valid_handle_typeB(a4) )
    {
      tls_data_offset_784_2 = *a4 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      tls_data_offset_784_2 = 0;
    }
    if ( is_valid_handle_typeB(a3) )
    {
      tls_data_offset_784_1 = *a3 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      tls_data_offset_784_1 = 0;
    }
    if ( tls_data_offset_784 == tls_data_offset_784_2 )
    {
      if ( tls_data_offset_784 == tls_data_offset_784_1 )
      {
        v52 = *(unsigned int *)(tls_data_offset_784 + 0x2E8);
        v53 = *(_QWORD *)(a1 + 0x100) + 0xC0 * v52;
        v54 = *(_BYTE *)(v53 + 0xBC);
        if ( (v54 & 1) == 0 && (unsigned __int8)sub_1468E1B90(*(_QWORD *)(a1 + 0x100) + 0xC0 * v52) == 1 )
        {
          v95[0] = 0;
          *(_BYTE *)(v53 + 0xBC) = v54 | 1;
          *(_QWORD *)(v53 + 0x28) = *(_QWORD *)(tls_data_offset_784 + 0x2A8);
          *(_QWORD *)(v53 + 0x60) = *(_QWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x18LL);
          *(_QWORD *)(v53 + 0x68) = *(_QWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x10LL);
          v55 = *(_QWORD *)(tls_data_offset_784 + 0x328);
          *(_OWORD *)(v53 + 0x48) = *(_OWORD *)(v55 + 0xA0);
          *(double *)(v53 + 0x58) = *(double *)(v55 + 0xB0);
          v95[2] = *(_DWORD *)(tls_data_offset_784 + 0x2E8);
          v95[3] = *(_DWORD *)(tls_data_offset_784 + 0x2B0);
          v56 = sub_1468D8FB0(v53);
          v57 = *(_QWORD *)(tls_data_offset_784 + 0x2A8);
          v96 = v56;
          sub_1468D9A90(a1, v57);
          sub_1468E62F0(a1, v95);
        }
        v58 = *(_BYTE *)(v53 + 0xBC);
        if ( (v58 & 1) != 0 && !(unsigned __int8)sub_1468E1B90(v53) )
        {
          v97[0] = 1;
          *(_BYTE *)(v53 + 0xBC) = v58 & 0xFE;
          v59 = *(_QWORD *)(tls_data_offset_784 + 0x2A8);
          v97[2] = *(_DWORD *)(tls_data_offset_784 + 0x2E8);
          v97[3] = *(_DWORD *)(tls_data_offset_784 + 0x2B0);
          v98 = 0;
          sub_1468D9A90(a1, v59);
          sub_1468FCC80(a1, v97);
        }
      }
      else
      {
        v115 = 0;
        v72 = v114;
        v116 = 0;
        v82[0] = &v72;
        v117 = 0;
        v82[1] = sub_1468A0010;
        memset(v114, 0, sizeof(v114));
        v118 = 0;
        sub_1468D5530(tls_data_offset_784, (__int64)v82);
        v66 = 0;
        sub_1468EB7D0(a1, (unsigned int)v114, (_DWORD)a4, (unsigned int)&v68, (__int64)a3, (__int64)&v66);
        v41 = *(_QWORD *)(a1 + 0x100) + 0xC0LL * *(unsigned int *)((*a4 & 0xFFFFFFFFFFFFLL) + 0x2E8);
        v42 = *(_BYTE *)(v41 + 0xBC);
        v43 = *(_QWORD *)(a1 + 0x100) + 0xC0LL * *(unsigned int *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x2E8);
        if ( (v42 & 1) != 0 )
        {
          v91[0] = 1;
          *(_BYTE *)(v41 + 0xBC) = v42 & 0xFE;
          v44 = *a4 & 0xFFFFFFFFFFFFLL;
          v92 = 1;
          v91[2] = *(_DWORD *)(v44 + 0x2E8);
          v45 = *(_DWORD *)(v44 + 0x2B0);
          v46 = *(_QWORD *)(v44 + 0x2A8);
          v91[3] = v45;
          sub_1468D9A90(a1, v46);
          sub_1468FCC80(a1, v91);
        }
        else
        {
          LOBYTE(v40) = 1;
          sub_1468D5FD0(a1 + 0x100, v41, v40);
        }
        *(_DWORD *)((*a4 & 0xFFFFFFFFFFFFLL) + 0x2E8) = 0xFFFFFFFF;
        if ( *(_DWORD *)((*a4 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF )
        {
          sub_1468FCBA0(a1 + 0x298);
        }
        v47 = *(_BYTE *)(v43 + 0xBC);
        if ( (v47 & 1) == 0 && (unsigned __int8)sub_1468E1B90(v43) == 1 )
        {
          v93[0] = 0;
          *(_BYTE *)(v43 + 0xBC) = v47 | 1;
          *(_QWORD *)(v43 + 0x28) = *(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x2A8);
          *(_QWORD *)(v43 + 0x60) = *(_QWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328) + 0x18LL);
          *(_QWORD *)(v43 + 0x68) = *(_QWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328) + 0x10LL);
          v48 = *(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328);
          *(_OWORD *)(v43 + 0x48) = *(_OWORD *)(v48 + 0xA0);
          *(double *)(v43 + 0x58) = *(double *)(v48 + 0xB0);
          v49 = *a3 & 0xFFFFFFFFFFFFLL;
          v93[2] = *(_DWORD *)(v49 + 0x2E8);
          v93[3] = *(_DWORD *)(v49 + 0x2B0);
          v50 = sub_1468D8FB0(v43);
          v51 = *(_QWORD *)(v49 + 0x2A8);
          v94 = v50;
          sub_1468D9A90(a1, v51);
          sub_1468E62F0(a1, v93);
        }
        if ( v66 && (*(_BYTE *)(v43 + 0xBC) & 1) != 0 )
        {
          sub_14690E550(a1, a3);
        }
        sub_1468B1390(v114);
      }
    }
    else if ( tls_data_offset_784 == tls_data_offset_784_1 )
    {
      v69 = 0xFFFFFFFFFFFFFFFFuLL;
      v28 = sub_1468F3470(a1 + 0x100, &v69);
      *(_QWORD *)(v28 + 0x20) = tls_data_offset_784;
      *(_QWORD *)(v28 + 0x28) = *(_QWORD *)(tls_data_offset_784 + 0x2A8);
      *(_QWORD *)(v28 + 0x60) = *(_QWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x18LL);
      *(_QWORD *)(v28 + 0x68) = *(_QWORD *)(*(_QWORD *)(tls_data_offset_784 + 0x328) + 0x10LL);
      v29 = *(_QWORD *)(tls_data_offset_784 + 0x328);
      *(_OWORD *)(v28 + 0x48) = *(_OWORD *)(v29 + 0xA0);
      *(double *)(v28 + 0x58) = *(double *)(v29 + 0xB0);
      *(_DWORD *)(tls_data_offset_784 + 0x2E8) = v69;
      v71 = v109;
      v81[0] = &v71;
      v81[1] = sub_1468A0220;
      memset(v109, 0, sizeof(v109));
      v110 = 0;
      v111 = 0;
      v112 = 0;
      v113 = 0;
      sub_1468D5530(tls_data_offset_784, (__int64)v81);
      v65 = 0;
      sub_1468EB7D0(a1, (unsigned int)v109, (_DWORD)a4, (unsigned int)&v65, (__int64)a3, (__int64)&v67);
      v30 = *(_QWORD *)(a1 + 0x100) + 0xC0LL * *(unsigned int *)((*a4 & 0xFFFFFFFFFFFFLL) + 0x2E8);
      v31 = *(_BYTE *)(v30 + 0xBC);
      v32 = *(_QWORD *)(a1 + 0x100) + 0xC0LL * *(unsigned int *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x2E8);
      if ( (v31 & 1) != 0
        && !(unsigned __int8)sub_1468E1B90(*(_QWORD *)(a1 + 0x100) + 0xC0LL
                                                                   * *(unsigned int *)((*a4 & 0xFFFFFFFFFFFFLL) + 0x2E8)) )
      {
        v87[0] = 1;
        v88 = 0;
        *(_BYTE *)(v30 + 0xBC) = v31 & 0xFE;
        v33 = *a4 & 0xFFFFFFFFFFFFLL;
        v87[2] = *(_DWORD *)(v33 + 0x2E8);
        v34 = *(_DWORD *)(v33 + 0x2B0);
        v35 = *(_QWORD *)(v33 + 0x2A8);
        v87[3] = v34;
        sub_1468D9A90(a1, v35);
        sub_1468FCC80(a1, v87);
      }
      if ( (unsigned __int8)sub_1468E1B90(v32) == 1 )
      {
        *(_BYTE *)(v32 + 0xBC) |= 1u;
        *(_QWORD *)(v32 + 0x28) = *(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x2A8);
        *(_QWORD *)(v32 + 0x60) = *(_QWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328) + 0x18LL);
        *(_QWORD *)(v32 + 0x68) = *(_QWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328) + 0x10LL);
        v36 = *(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328);
        v89[0] = 0;
        *(_OWORD *)(v32 + 0x48) = *(_OWORD *)(v36 + 0xA0);
        *(double *)(v32 + 0x58) = *(double *)(v36 + 0xB0);
        v37 = *a3 & 0xFFFFFFFFFFFFLL;
        v89[2] = *(_DWORD *)(v37 + 0x2E8);
        v89[3] = *(_DWORD *)(v37 + 0x2B0);
        v38 = sub_1468D8FB0(v32);
        v39 = *(_QWORD *)(v37 + 0x2A8);
        v90 = v38;
        sub_1468D9A90(a1, v39);
        sub_1468E62F0(a1, v89);
      }
      if ( v65 && (*(_BYTE *)(v30 + 0xBC) & 1) != 0 )
      {
        sub_14690E550(a1, a4);
      }
      sub_1468B1390(v109);
    }
    else if ( *a4 != *a3 )
    {
      v105 = 0;
      v70 = &v99;
      v106 = 0;
      v80[0] = &v70;
      v107 = 0;
      v80[1] = sub_1468A0220;
      v99 = 0;
      v100 = 0;
      v101 = 0;
      v102 = 0;
      v103 = 0;
      v104 = 0;
      v108 = 0;
      sub_1468D5530(tls_data_offset_784, (__int64)v80);
      v63 = 0;
      v64 = 0;
      sub_1468EB7D0(a1, (unsigned int)&v99, (_DWORD)a4, (unsigned int)&v63, (__int64)a3, (__int64)&v64);
      v16 = *(_QWORD *)(a1 + 0x100);
      v17 = v16 + 0xC0LL * *(unsigned int *)((*a4 & 0xFFFFFFFFFFFFLL) + 0x2E8);
      v18 = *(_BYTE *)(v17 + 0xBC);
      v19 = v16 + 0xC0LL * *(unsigned int *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x2E8);
      if ( (v18 & 1) != 0
        && !(unsigned __int8)sub_1468E1B90(v16 + 0xC0LL * *(unsigned int *)((*a4 & 0xFFFFFFFFFFFFLL) + 0x2E8)) )
      {
        v83[0] = 1;
        v84 = 0;
        *(_BYTE *)(v17 + 0xBC) = v18 & 0xFE;
        v20 = *a4 & 0xFFFFFFFFFFFFLL;
        v83[2] = *(_DWORD *)(v20 + 0x2E8);
        v21 = *(_DWORD *)(v20 + 0x2B0);
        v22 = *(_QWORD *)(v20 + 0x2A8);
        v83[3] = v21;
        sub_1468D9A90(a1, v22);
        sub_1468FCC80(a1, v83);
      }
      v23 = *(_BYTE *)(v19 + 0xBC);
      if ( (v23 & 1) == 0 && (unsigned __int8)sub_1468E1B90(v19) == 1 )
      {
        *(_BYTE *)(v19 + 0xBC) = v23 | 1;
        *(_QWORD *)(v19 + 0x28) = *(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x2A8);
        *(_QWORD *)(v19 + 0x60) = *(_QWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328) + 0x18LL);
        *(_QWORD *)(v19 + 0x68) = *(_QWORD *)(*(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328) + 0x10LL);
        v24 = *(_QWORD *)((*a3 & 0xFFFFFFFFFFFFLL) + 0x328);
        v85[0] = 0;
        *(_OWORD *)(v19 + 0x48) = *(_OWORD *)(v24 + 0xA0);
        *(double *)(v19 + 0x58) = *(double *)(v24 + 0xB0);
        v25 = *a3 & 0xFFFFFFFFFFFFLL;
        v85[2] = *(_DWORD *)(v25 + 0x2E8);
        v85[3] = *(_DWORD *)(v25 + 0x2B0);
        v26 = sub_1468D8FB0(v19);
        v27 = *(_QWORD *)(v25 + 0x2A8);
        v86 = v26;
        sub_1468D9A90(a1, v27);
        sub_1468E62F0(a1, v85);
      }
      if ( v63 && (*(_BYTE *)(v17 + 0xBC) & 1) != 0 )
      {
        sub_14690E550(a1, a4);
      }
      if ( v64 && (*(_BYTE *)(v19 + 0xBC) & 1) != 0 )
      {
        sub_14690E550(a1, a3);
      }
      if ( *((_QWORD *)&v103 + 1) )
      {
        sub_14039EFB0(
          (__int64)&v103 + 8,
          *((const void **)&v103 + 1),
          (*((_QWORD *)&v104 + 1) - *((_QWORD *)&v103 + 1)) & 0xFFFFFFFFFFFFFFF8uLL);
        *((_QWORD *)&v103 + 1) = 0;
        v104 = 0;
      }
      if ( (_QWORD)v102 )
      {
        sub_14039EFB0((__int64)&v102, (const void *)v102, (v103 - v102) & 0xFFFFFFFFFFFFFFF8uLL);
        v102 = 0;
        *(_QWORD *)&v103 = 0;
      }
      if ( *((_QWORD *)&v100 + 1) )
      {
        sub_14039EFB0(
          (__int64)&v100 + 8,
          *((const void **)&v100 + 1),
          0x38 * ((*((_QWORD *)&v101 + 1) - *((_QWORD *)&v100 + 1)) / 0x38LL));
        v101 = 0;
        *((_QWORD *)&v100 + 1) = 0;
      }
      if ( (_QWORD)v99 )
      {
        sub_14039EFB0((__int64)&v99, (const void *)v99, (v100 - v99) & 0xFFFFFFFFFFFFFFE0uLL);
      }
    }
    if ( a1 != 0xFFFFFFFFFFFFFFF8uLL )
    {
      v60 = *(_DWORD *)(a1 + 0x14);
      if ( v60 )
      {
        *(_DWORD *)(a1 + 0x14) = v60 - 1;
      }
      else
      {
        *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64(v11, 0, 0x200000);
        if ( n0x200000 != 0x200000 )
        {
          sub_1403D8A00((volatile signed __int64 *)(a1 + 8), n0x200000);
        }
      }
    }
  }
  v77 = __rdtsc();
  return psub_7FF6AAB93930(&n0x1000);
}

// --- End Function: sub_1468EDEA0 (0x1468EDEA0) ---

// --- Function: sub_1468F0740 (0x1468F0740) ---
unsigned __int64 __fastcall sub_1468F0740(unsigned __int64 tls_data_offset_784, __int64 *p_tls_data_offset_784a)
{
  __int64 *p_tls_data_offset_784a_2; // rbx
  __int64 (__fastcall *p_sub_14689FFF0)(); // rdi
  signed __int64 v5; // rdx
  char v6; // dl
  unsigned __int64 v7; // rcx
  unsigned __int16 v8; // ax
  _QWORD *v9; // rbp
  _QWORD *i; // rsi
  unsigned __int64 tls_data_offset_784_1; // rbx
  char v12; // dl
  unsigned __int64 v13; // rcx
  unsigned __int16 v14; // ax
  _QWORD *v15; // rdi
  _QWORD *j; // rbx
  __int64 *p_tls_data_offset_784a_1; // [rsp+30h] [rbp-38h] BYREF
  __int64 (__fastcall *p_sub_14689FFF0_1)(); // [rsp+38h] [rbp-30h]
  __int64 tls_data_offset_784a; // [rsp+70h] [rbp+8h] BYREF

  p_tls_data_offset_784a_2 = &tls_data_offset_784a;
  tls_data_offset_784a = *p_tls_data_offset_784a;
  p_tls_data_offset_784a_1 = &tls_data_offset_784a;
  p_sub_14689FFF0 = sub_14689FFF0;
  p_sub_14689FFF0_1 = sub_14689FFF0;
  if ( dword_1497929D8 == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
  {
    ++dword_1497929DC;
  }
  else
  {
    v5 = _InterlockedIncrement64(&qword_1497929D0);
    if ( (v5 & 0x200000) != 0 )
    {
      sub_1403C6C70(
        &qword_1497929D0,
        v5,
        (__int64)"CEntity::ForEachEntityInStreamingGroup",
        (__int64)"s_aggregateHierarchyLock",
        1);
    }
    p_tls_data_offset_784a_2 = p_tls_data_offset_784a_1;
    p_sub_14689FFF0 = p_sub_14689FFF0_1;
  }
  if ( ::tls_data_offset_784_1 > tls_data_offset_784 || tls_data_offset_784 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
  {
    v6 = 0;
    v7 = tls_data_offset_784 - 6;
  }
  else
  {
    v6 = 1;
    v7 = tls_data_offset_784 & 0xFFFFFFFFFF000000uLL;
  }
  v8 = *(_WORD *)(v7 + 2) | 0x2000;
  if ( !v6 )
  {
    v8 = *(_WORD *)(v7 + 2);
  }
  if ( p_sub_14689FFF0 == sub_14689FFF0 )
  {
    *(_QWORD *)((tls_data_offset_784 & 0xFFFFFFFFFFFFLL) + 0x320) = *p_tls_data_offset_784a_2;
  }
  else
  {
    ((void (__fastcall *)(__int64 *, unsigned __int64))p_sub_14689FFF0)(
      p_tls_data_offset_784a_2,
      tls_data_offset_784 | ((unsigned __int64)v8 << 0x30));
  }
  v9 = *(_QWORD **)(tls_data_offset_784 + 0x300);
  for ( i = *(_QWORD **)(tls_data_offset_784 + 0x2F8); i != v9; ++i )
  {
    tls_data_offset_784_1 = *i & 0xFFFFFFFFFFFFLL;
    if ( !sub_1468E7C70(tls_data_offset_784_1) )
    {
      if ( ::tls_data_offset_784_1 > tls_data_offset_784_1
        || tls_data_offset_784_1 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
      {
        v12 = 0;
        v13 = tls_data_offset_784_1 - 6;
      }
      else
      {
        v12 = 1;
        v13 = tls_data_offset_784_1 & 0xFFFFFFFFFF000000uLL;
      }
      v14 = *(_WORD *)(v13 + 2) | 0x2000;
      if ( !v12 )
      {
        v14 = *(_WORD *)(v13 + 2);
      }
      if ( p_sub_14689FFF0_1 == sub_14689FFF0 )
      {
        *(_QWORD *)((tls_data_offset_784_1 & 0xFFFFFFFFFFFFLL) + 0x320) = *p_tls_data_offset_784a_1;
      }
      else
      {
        ((void (__fastcall *)(__int64 *, unsigned __int64))p_sub_14689FFF0_1)(
          p_tls_data_offset_784a_1,
          tls_data_offset_784_1 | ((unsigned __int64)v14 << 0x30));
      }
      v15 = *(_QWORD **)(tls_data_offset_784_1 + 0x300);
      for ( j = *(_QWORD **)(tls_data_offset_784_1 + 0x2F8); j != v15; ++j )
      {
        sub_1468D5BA0(*j & 0xFFFFFFFFFFFFLL, &p_tls_data_offset_784a_1);
      }
    }
  }
  return sub_1402D0950((__int64)&qword_1497929D0);
}

// --- End Function: sub_1468F0740 (0x1468F0740) ---

// --- Function: sub_1468F26E0 (0x1468F26E0) ---
void __fastcall sub_1468F26E0(__int64 a1)
{
  void **v2; // rax
  void **v3; // rbx
  _QWORD *v4; // rax
  void **v5; // rax
  void **v6; // rax
  void **v7; // rbx
  _QWORD *v8; // rax
  void **v9; // rax
  void **v10; // rax
  void **v11; // rbx
  _QWORD *v12; // rax
  void **v13; // rax
  void *string_struct_ptr_; // [rsp+40h] [rbp+8h] BYREF
  __int64 string_struct_ptr__1; // [rsp+48h] [rbp+10h] BYREF
  __int64 v16; // [rsp+50h] [rbp+18h] BYREF

  initializeEmptyStringStructure(&string_struct_ptr_);
  sub_1403A5050(
    &string_struct_ptr_,
    "entity {name =\"%s\" id=%llu} mask=0x%08x",
    *(const char **)(a1 + 0x290),
    *(_QWORD *)(a1 + 0x10),
    *(_DWORD *)(a1 + 0x4F0));
  initializeEmptyStringStructure(&string_struct_ptr__1);
  v3 = v2;
  v4 = sub_1403AC900((unsigned __int64 *)(a1 + 0x4D8), &v16);
  v5 = sub_1403A5050(v3, " reasonOwner[%s=%zu]=%llu", "ITEM_PORT", 0, *v4);
  sub_140380E40(&string_struct_ptr_, (char **)v5);
  DestroyStringObject(&string_struct_ptr__1);
  initializeEmptyStringStructure(&string_struct_ptr__1);
  v7 = v6;
  v8 = sub_1403AC900((unsigned __int64 *)(a1 + 0x4E0), &v16);
  v9 = sub_1403A5050(v7, " reasonOwner[%s=%zu]=%llu", "ATTACHMENT", 1u, *v8);
  sub_140380E40(&string_struct_ptr_, (char **)v9);
  DestroyStringObject(&string_struct_ptr__1);
  initializeEmptyStringStructure(&string_struct_ptr__1);
  v11 = v10;
  v12 = sub_1403AC900((unsigned __int64 *)(a1 + 0x4E8), &v16);
  v13 = sub_1403A5050(v11, " reasonOwner[%s=%zu]=%llu", "ZONE", 2u, *v12);
  sub_140380E40(&string_struct_ptr_, (char **)v13);
  DestroyStringObject(&string_struct_ptr__1);
  LogTraceConditional((const char *)&fmt, string_struct_ptr_);
  DestroyStringObject(&string_struct_ptr_);
}

// --- End Function: sub_1468F26E0 (0x1468F26E0) ---

// --- Function: sub_146900A50 (0x146900A50) ---
char __fastcall sub_146900A50(unsigned __int64 tls_data_offset_784, __int16 a2)
{
  unsigned int v2; // eax
  unsigned __int16 v3; // r9
  bool v4; // r10
  __int16 v5; // tt
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_DWORD *)(tls_data_offset_784 + 8);
  if ( (v2 & 8) == 0 )
  {
    v3 = a2 & 0x7FFF;
    if ( (a2 & 0x7FFF) != 0 )
    {
      v4 = (v2 & 0x400) != 0 && (((unsigned __int16)(0xFEFF * ((v2 >> 4) & 1)) | 0x100) & v3) != 0;
      _m_prefetchw((const void *)(tls_data_offset_784 + 0x120));
      LOWORD(v2) = *(_WORD *)(tls_data_offset_784 + 0x120);
      do
      {
        v5 = v2;
        LOWORD(v2) = _InterlockedCompareExchange16(
                       (volatile signed __int16 *)(tls_data_offset_784 + 0x120),
                       v3 | (v4 << 0xF) | v2,
                       v2);
      }
      while ( v5 != (_WORD)v2 );
      if ( (v2 & 0x8000u) == 0 && v4 )
      {
        sub_14033D280(tls_data_offset_784, &v7);
        LOBYTE(v2) = AssetMeta::HasActorSubresource(&v7);
        if ( (_BYTE)v2 )
        {
          LOBYTE(v2) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v7 & 0xFFFFFFFFFFFFLL) + 0x590LL))(v7 & 0xFFFFFFFFFFFFLL);
        }
      }
    }
  }
  return v2;
}

// --- End Function: sub_146900A50 (0x146900A50) ---

// --- Function: sub_1469080C0 (0x1469080C0) ---
__int64 __fastcall sub_1469080C0(
        unsigned __int64 tls_data_offset_784,
        unsigned __int64 tls_data_offset_784_1,
        __int64 a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  int v8; // ebx
  unsigned __int64 v9; // rax
  __int64 v10; // rbx
  int n2; // r14d
  __int64 tls_data_offset_784_3; // rax
  unsigned __int64 v13; // rax
  __int64 v14; // rdi
  unsigned __int64 v15; // rax
  __int64 v16; // rdi
  bool v17; // al
  unsigned __int8 v18; // bl
  unsigned __int64 v19; // rax
  __int64 v20; // rbp
  unsigned __int64 v21; // rax
  __int64 v22; // rbp
  bool v23; // al
  unsigned __int64 tls_data_offset_784_2; // rsi
  __int64 v25; // rax
  unsigned int v26; // r13d
  unsigned int v27; // r12d
  __int64 v28; // r9
  _QWORD *v29; // rbp
  __int64 v30; // r8
  __int64 v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rax
  __int64 v34; // rcx
  __int64 v35; // rax
  __int128 v36; // xmm7
  double v37; // xmm6_8
  __int64 v38; // rax
  unsigned __int8 v39; // al
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 *v42; // r9
  _BYTE **v43; // r8
  _QWORD *v44; // r10
  int v45; // eax
  char v46; // dl
  unsigned __int64 v47; // rcx
  unsigned __int16 v48; // ax
  __int64 result; // rax
  unsigned __int64 n0x200000; // rax
  _OWORD v53[4]; // [rsp+30h] [rbp-68h] BYREF

  v8 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( dword_1497929C8 == v8 )
  {
    ++dword_1497929CC;
  }
  else
  {
    v9 = _InterlockedCompareExchange64(&qword_1497929C0, 0x200000, 0);
    if ( v9 )
    {
      sub_1403D85B0(
        &qword_1497929C0,
        v9,
        0,
        (__int64)"CEntity::UpdateAggregateRadius_OnAggregateRadiusHostChanged",
        (__int64)"CEntityAggregateRadius::s_aggregateRadiusHierarchyLock",
        1);
    }
    dword_1497929C8 = v8;
  }
  v10 = *(_QWORD *)(tls_data_offset_784 + 0x328);
  if ( tls_data_offset_784_1 )
  {
    n2 = sub_1468E7310(tls_data_offset_784_1, tls_data_offset_784, a3);
  }
  else
  {
    n2 = 0;
  }
  if ( is_valid_handle_typeB((unsigned __int64 *)(v10 + 0x48)) )
  {
    tls_data_offset_784_3 = *(_QWORD *)(v10 + 0x48) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    tls_data_offset_784_3 = 0;
  }
  if ( tls_data_offset_784_3 == tls_data_offset_784_1 && n2 == *(_DWORD *)(v10 + 0x44) )
  {
    v13 = *(_QWORD *)(v10 + 0x48);
    if ( !v13 )
    {
      goto LABEL_26;
    }
    v14 = v13 & 0xFFFFFFFFFFFFLL;
    v15 = HIWORD(v13);
    v16 = (v15 & 0xF000) != 0 ? v14 & 0xFFFFFF000000LL : v14 - 6;
    if ( *(_WORD *)(v16 + 2) != (v15 & 0xFFF) )
    {
      goto LABEL_26;
    }
    if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v17 = is_thread_flag_57_or_38_set()) )
    {
      v17 = 1;
    }
    if ( (*(_WORD *)(v16 + 4) != 2 || !v17) && !check_handle_access_by_state_extended((_QWORD *)(v10 + 0x48))
      || *(_BYTE *)((*(_QWORD *)(v10 + 0x48) & 0xFFFFFFFFFFFFLL) + 0xD) >= 5u )
    {
LABEL_26:
      *(_QWORD *)(v10 + 0x48) = 0;
      *(_DWORD *)(v10 + 0x40) = 0xFFFFFFFF;
      *(_DWORD *)(v10 + 0x44) = 0;
    }
    v18 = 0;
  }
  else
  {
    if ( is_valid_handle_typeB((unsigned __int64 *)(v10 + 0x48)) )
    {
      v19 = *(_QWORD *)(v10 + 0x48);
      v20 = v19 & 0xFFFFFFFFFFFFLL;
      if ( *(_BYTE *)((v19 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
      {
        if ( !v19 )
        {
          goto LABEL_42;
        }
        v21 = HIWORD(v19);
        v22 = (v21 & 0xF000) != 0 ? v20 & 0xFFFFFF000000LL : v20 - 6;
        if ( *(_WORD *)(v22 + 2) != (v21 & 0xFFF) )
        {
          goto LABEL_42;
        }
        if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v23 = is_thread_flag_57_or_38_set()) )
        {
          v23 = 1;
        }
        if ( *(_WORD *)(v22 + 4) == 2 && v23 || check_handle_access_by_state_extended((_QWORD *)(v10 + 0x48)) )
        {
          tls_data_offset_784_2 = *(_QWORD *)(v10 + 0x48) & 0xFFFFFFFFFFFFLL;
        }
        else
        {
LABEL_42:
          tls_data_offset_784_2 = 0;
        }
        v25 = *(_QWORD *)(tls_data_offset_784_2 + 0x328);
        v26 = *(_DWORD *)(v10 + 0x40);
        v27 = v26;
        v28 = v26;
        v29 = (_QWORD *)(v25 + 0x70);
        if ( *(_DWORD *)(v10 + 0x44) != 1 )
        {
          v29 = (_QWORD *)(v25 + 0x58);
        }
        if ( v26 >= 0x80000000 )
        {
          v28 = v26 + 0x80000000;
        }
        v30 = v29[1];
        v31 = v30 - *v29;
        v32 = (__int64)((unsigned __int128)(v31 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 2;
        if ( v28 != v32
                  + ((unsigned __int64)((unsigned __int128)(v31 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F)
                  - 1 )
        {
          v33 = *(_QWORD *)(v30 - 0x18);
          v53[3] = v3;
          v53[2] = v4;
          v34 = *(_QWORD *)(v33 + 0x328);
          v27 = *(_DWORD *)(v34 + 0x40);
          *(_DWORD *)(v34 + 0x40) = v26;
          v35 = v29[1];
          v36 = *(_OWORD *)(v35 - 0x18);
          v37 = *(double *)(v35 - 8);
          v38 = sub_14037C180(v29, (unsigned int)v28);
          *(_OWORD *)v38 = v36;
          *(double *)(v38 + 0x10) = v37;
        }
        v29[1] -= 0x18LL;
        *(_DWORD *)(v10 + 0x44) = 0;
        *(_DWORD *)(v10 + 0x40) = 0xFFFFFFFF;
        *(_QWORD *)(v10 + 0x48) = 0;
        v39 = sub_146901F20(tls_data_offset_784, v32, v30, v28);
        sub_146907F60(tls_data_offset_784_2, v26, v27, v39);
      }
    }
    *(_QWORD *)(v10 + 0x48) = 0;
    *(_DWORD *)(v10 + 0x40) = 0xFFFFFFFF;
    *(_DWORD *)(v10 + 0x44) = 0;
    if ( tls_data_offset_784_1 )
    {
      if ( n2 == 2
        || (v40 = *(_QWORD *)(tls_data_offset_784_1 + 0x2B8)) == 0
        || (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v40 + 0x48LL))(v40) == 2 )
      {
        v41 = *(_QWORD *)(tls_data_offset_784_1 + 0x328);
        if ( n2 == 1 )
        {
          v42 = (__int64 *)(v41 + 0x70);
          v43 = (_BYTE **)(v41 + 0x78);
          v44 = (_QWORD *)(v41 + 0x80);
        }
        else
        {
          v42 = (__int64 *)(v41 + 0x58);
          v43 = (_BYTE **)(v41 + 0x60);
          v44 = (_QWORD *)(v41 + 0x68);
        }
        v45 = (v42[1] - *v42) / 0x18 + 0x80000000;
        if ( n2 != 1 )
        {
          v45 = (v42[1] - *v42) / 0x18;
        }
        *(_DWORD *)(v10 + 0x40) = v45;
        if ( ::tls_data_offset_784_1 > tls_data_offset_784_1
          || tls_data_offset_784_1 >= qword_15126E3D8 + ::tls_data_offset_784_1 )
        {
          v46 = 0;
          v47 = tls_data_offset_784_1 - 6;
        }
        else
        {
          v46 = 1;
          v47 = tls_data_offset_784_1 & 0xFFFFFFFFFF000000uLL;
        }
        v48 = *(_WORD *)(v47 + 2) | 0x2000;
        *(_QWORD *)&v53[0] = tls_data_offset_784;
        _XMM1 = 0;
        if ( !v46 )
        {
          v48 = *(_WORD *)(v47 + 2);
        }
        *(_DWORD *)(v10 + 0x44) = n2;
        *(_QWORD *)(v10 + 0x48) = tls_data_offset_784_1 | ((unsigned __int64)v48 << 0x30);
        _RDX = *v43;
        __asm { vmovupd xmmword ptr [rsp+98h+var_68+8], xmm1 }
        if ( _RDX == (_BYTE *)*v44 )
        {
          sub_1402A56E0(v42, _RDX, (__int64)v53);
        }
        else
        {
          *(_OWORD *)_RDX = v53[0];
          __asm { vmovhpd qword ptr [rdx+10h], xmm1 }
          v42[1] += 0x18;
        }
        sub_146907B30(tls_data_offset_784_1, tls_data_offset_784);
      }
    }
    v18 = 1;
  }
  if ( dword_1497929CC )
  {
    result = v18;
    --dword_1497929CC;
  }
  else
  {
    dword_1497929C8 = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64(&qword_1497929C0, 0, 0x200000);
    if ( n0x200000 != 0x200000 )
    {
      sub_1403D8A00(&qword_1497929C0, n0x200000);
    }
    return v18;
  }
  return result;
}

// --- End Function: sub_1469080C0 (0x1469080C0) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(FH4 *pCZoneSystem)
{
  if ( pCZoneSystem )
  {
    if ( qword_14981D3D8 && ::pCZoneSystem && pCZoneSystem == ::pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)pCZoneSystem < pCZoneSystem_1
      || (unsigned __int64)pCZoneSystem >= pCZoneSystem_1 + 0x8000000000LL )
    {
      if ( (unsigned __int64)pCZoneSystem >= pCZoneSystem_0
        && (unsigned __int64)pCZoneSystem < pCZoneSystem_0 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", pCZoneSystem);
      }
      sub_147397F30((__int64)pCZoneSystem);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: __alloca_probe (0x147DC7830) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
  {
    StackLimit_1 = 0;
  }
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x147DC7830) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 0x10);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = 0xC0000409;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

