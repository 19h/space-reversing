// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x147098860 (display_camera_and_location_info)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 12
// ------------------------------------------------------------

// --- Function: sub_1402A2470 (0x1402A2470) ---
void *sub_1402A2470()
{
  return &unk_149808280;
}

// --- End Function: sub_1402A2470 (0x1402A2470) ---

// --- Function: sub_1402F8060 (0x1402F8060) ---
int sub_1402F8060(char *Buffer, char *Format, ...)
{
  _QWORD *v4; // rax
  int result; // eax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_1402A2470();
  result = _stdio_common_vsprintf(*v4 | 1LL, Buffer, 0xFFFFFFFFFFFFFFFFuLL, Format, 0LL, va);
  if ( result < 0 )
  {
    return -1;
  }
  return result;
}

// --- End Function: sub_1402F8060 (0x1402F8060) ---

// --- Function: sub_1403FA840 (0x1403FA840) ---
__m128 __fastcall sub_1403FA840(__int64 pCameraData)
{
  __int128 n0x3BDB0DD8_1; // xmm0
  __int128 n0x3BDB0DD8; // kr00_16
  __m128 result; // xmm0

  n0x3BDB0DD8 = 0x3BDB0DD8u;
  *(float *)&n0x3BDB0DD8 = 0.0066849999
                         / (float)(tanf(*(float *)(pCameraData + 240) * 0.5) * *(float *)(pCameraData + 820));
  n0x3BDB0DD8_1 = n0x3BDB0DD8;
  __asm { vminss  xmm0, xmm0, cs:dword_147F49DA4 }
  return result;
}

// --- End Function: sub_1403FA840 (0x1403FA840) ---

// --- Function: sub_1404002C0 (0x1404002C0) ---
float __fastcall sub_1404002C0(__int64 a1)
{
  return *(float *)(a1 + 824);
}

// --- End Function: sub_1404002C0 (0x1404002C0) ---

// --- Function: display_camera_and_location_info (0x147098860) ---
// Calculates and displays camera orientation, parameters, and relative position to
// nearby locations/zones.  This function reads camera orientation and position
// data from the structure pointed to by pCameraState. It calculates the camera's
// pitch, yaw, and roll angles in degrees. If displayMode is non-zero, it iterates
// through a list of locations/zones obtained from a global iterator source
// (`qword_14981D208`). For each location, it calculates the relative position (X,
// Y, Z) from the camera and formats it into strings (converting large distances to
// kilometers). If displayMode is 2 or greater, it also retrieves and formats
// detailed camera parameters (FOV, Focal Length, F-Stop) for the first location in
// the list. It then calls sub_14709B430 to display the formatted strings (camera
// direction, parameters, zone name, relative position) at screen coordinates
// specified and updated via pDisplayPos.  Parameters:  a1 (pCameraState): Pointer
// to a structure containing camera state (orientation, position, FOV, etc.).  a2
// (pDisplayPos): Pointer to a structure holding screen coordinates {float x, float
// y, float y_increment} for text display.  n2 (displayMode): Integer flag
// controlling display; 0 = off, 1 = basic info, >=2 = detailed info.  Return
// Value:  void
void __fastcall display_camera_and_location_info(unsigned __int64 *pCameraState, __int64 pDisplayPos, int displayMode)
{
  unsigned __int64 *pCameraData; // rdi
  float pitchRad; // xmm9_4
  float yawRad; // xmm0_4
  float yawDeg; // xmm11_4
  float rollRad; // xmm0_4
  int currentLocationIndex; // edx
  float rollDeg; // xmm13_4
  double v28; // xmm0_8
  __int64 pLocationIteratorStart_1; // rbx
  __int64 pLocationIteratorStart; // r15
  double relativePosX_1; // xmm2_8
  char *p_%.4fkm; // rdx
  double relativePosY_1; // xmm2_8
  char *p_%.4fkm_1; // rdx
  double relativePosZ_1; // xmm2_8
  char *p_%.4fkm_2; // rdx
  double fStopValue; // kr00_8
  float focalLengthValue; // xmm0_4
  float fovValueDeg; // xmm1_4
  double v40; // xmm3_8
  const char *p_Unknown; // rax
  float v42; // kr00_4
  float fovValueDeg_1; // xmm1_4
  double fStopValue_1; // [rsp+48h] [rbp-1B0h]
  _QWORD cameraPosVec[3]; // [rsp+50h] [rbp-1A8h] BYREF
  double relativePosX; // [rsp+68h] [rbp-190h] BYREF
  double relativePosY; // [rsp+70h] [rbp-188h]
  double relativePosZ; // [rsp+78h] [rbp-180h]
  char formattedPosBuffer[192]; // [rsp+80h] [rbp-178h] BYREF

  if ( displayMode )
  {
    pCameraData = pCameraState + 154;
    _XMM0 = pCameraState[162];
    _XMM7 = pCameraState[158];
    _XMM8 = pCameraState[159];
    _XMM10 = pCameraState[155];
    _XMM11 = pCameraState[163];
    _XMM12 = pCameraState[164];
    __asm { vcvtpd2ps xmm0, xmm0 }
    _XMM1 = _XMM0 ^ 0x80000000;
    LODWORD(_XMM0) = -1082130432;
    __asm
    {
      vminss  xmm2, xmm1, xmm3
      vmaxss  xmm4, xmm2, xmm0
    }
    __asm
    {
      vcvtpd2ps xmm10, xmm10
      vcvtpd2ps xmm7, xmm7
      vcvtpd2ps xmm11, xmm11
      vcvtpd2ps xmm12, xmm12
    }
    if ( *(float *)&_XMM4 >= -1.0 )
    {
      __asm { vminss  xmm0, xmm4, xmm3; X }
    }
    pitchRad = asinf(*(float *)&_XMM0);
    if ( fabs(COERCE_FLOAT(LODWORD(pitchRad) & 0x7FFFFFFF) - 1.5707964) >= 0.0099999998 )
    {
      yawRad = atan2f(*(float *)&_XMM11, *(float *)&_XMM12);
      _XMM8 = *pCameraData;
    }
    else
    {
      yawRad = 0.0;
      LODWORD(_XMM7) = _XMM10 ^ 0x80000000;
    }
    yawDeg = yawRad * 57.295776;
    __asm { vcvtsd2ss xmm1, xmm8, xmm8; X }
    rollRad = atan2f(*(float *)&_XMM7, *(float *)&_XMM1);
    currentLocationIndex = *((_DWORD *)pCameraData + 42);
    cameraPosVec[0] = pCameraData[3];
    rollDeg = rollRad * 57.295776;
    v28 = *((double *)pCameraData + 7);
    cameraPosVec[2] = pCameraData[11];
    *(double *)&cameraPosVec[1] = v28;
    if ( currentLocationIndex != -1 )
    {
      pLocationIteratorStart_1 = (*(__int64 (**)(void))(*(_QWORD *)pCZoneSystem + 104LL))();
      for ( pLocationIteratorStart = pLocationIteratorStart_1;
            pLocationIteratorStart_1;
            pLocationIteratorStart_1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pLocationIteratorStart_1 + 8LL))(pLocationIteratorStart_1) )
      {
        (*(void (__fastcall **)(__int64, double *, _QWORD *))(*(_QWORD *)pLocationIteratorStart_1 + 248LL))(
          pLocationIteratorStart_1,
          &relativePosX,
          cameraPosVec);
        memset(formattedPosBuffer, 0, sizeof(formattedPosBuffer));
        relativePosX_1 = relativePosX;
        if ( COERCE_DOUBLE(*(_QWORD *)&relativePosX & 0x7FFFFFFFFFFFFFFFLL) >= 10000.0 )
        {
          relativePosX_1 = relativePosX * 0.001;
        }
        p_%.4fkm = "%.2fm";
        if ( COERCE_DOUBLE(*(_QWORD *)&relativePosX & 0x7FFFFFFFFFFFFFFFLL) >= 10000.0 )
        {
          p_%.4fkm = "%.4fkm";
        }
        sub_1402F8060(formattedPosBuffer, p_%.4fkm, relativePosX_1);
        relativePosY_1 = relativePosY;
        if ( COERCE_DOUBLE(*(_QWORD *)&relativePosY & 0x7FFFFFFFFFFFFFFFLL) >= 10000.0 )
        {
          relativePosY_1 = relativePosY * 0.001;
        }
        p_%.4fkm_1 = "%.2fm";
        if ( COERCE_DOUBLE(*(_QWORD *)&relativePosY & 0x7FFFFFFFFFFFFFFFLL) >= 10000.0 )
        {
          p_%.4fkm_1 = "%.4fkm";
        }
        sub_1402F8060(&formattedPosBuffer[64], p_%.4fkm_1, relativePosY_1);
        relativePosZ_1 = relativePosZ;
        if ( COERCE_DOUBLE(*(_QWORD *)&relativePosZ & 0x7FFFFFFFFFFFFFFFLL) >= 10000.0 )
        {
          relativePosZ_1 = relativePosZ * 0.001;
        }
        p_%.4fkm_2 = "%.2fm";
        if ( COERCE_DOUBLE(*(_QWORD *)&relativePosZ & 0x7FFFFFFFFFFFFFFFLL) >= 10000.0 )
        {
          p_%.4fkm_2 = "%.4fkm";
        }
        sub_1402F8060(&formattedPosBuffer[128], p_%.4fkm_2, relativePosZ_1);
        if ( displayMode >= 2 && pLocationIteratorStart_1 == pLocationIteratorStart )
        {
          fStopValue = sub_1403FA840((__int64)pCameraData).m128_f32[0];
          focalLengthValue = sub_1404002C0((__int64)pCameraData);
          fStopValue_1 = fStopValue;
          fovValueDeg = *(float *)pDisplayPos;
          v40 = (float)(*((float *)pCameraData + 60) * 57.295776);
          *(float *)&fStopValue = *(float *)(pDisplayPos + 4) + *(float *)(pDisplayPos + 8);
          *(float *)(pDisplayPos + 4) = *(float *)&fStopValue;
          sub_14709B430(
            pCameraState,
            fovValueDeg,
            *(float *)&fStopValue,
            "CamDir: %3d %3d %4d FOV: %.0f Focal: %.2f FStop: %.1f",
            (int)yawDeg,
            (int)(float)(pitchRad * 57.295776),
            (int)rollDeg,
            v40,
            focalLengthValue,
            fStopValue_1);
        }
        if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pLocationIteratorStart_1 + 496LL))(pLocationIteratorStart_1) )
        {
          p_Unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pLocationIteratorStart_1 + 496LL))(pLocationIteratorStart_1);
        }
        else
        {
          p_Unknown = "Unknown";
        }
        v42 = *(float *)(pDisplayPos + 4) + *(float *)(pDisplayPos + 8);
        fovValueDeg_1 = *(float *)pDisplayPos;
        *(float *)(pDisplayPos + 4) = v42;
        sub_14709B430(
          pCameraState,
          fovValueDeg_1,
          v42,
          "Zone: %s Pos: %s %s %s",
          p_Unknown,
          formattedPosBuffer,
          &formattedPosBuffer[64],
          &formattedPosBuffer[128]);
      }
    }
  }
}

// --- End Function: display_camera_and_location_info (0x147098860) ---

// --- Function: sub_14709B430 (0x14709B430) ---
double sub_14709B430(
        __int64 pCameraState,
        float fovValueDeg,
        float a3,
        const char *CamDir:_%3d_%3d_%4d_FOV:_%.0f_Focal:_%.2f_FStop:_%.1f,
        ...)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int64 v6; // rax
  double result; // xmm0_8
  double v8[3]; // [rsp+30h] [rbp-68h] BYREF
  int n178; // [rsp+48h] [rbp-50h] BYREF
  __int128 v10; // [rsp+4Ch] [rbp-4Ch]
  float v11; // [rsp+5Ch] [rbp-3Ch]
  float v12; // [rsp+60h] [rbp-38h]
  __int128 v13; // [rsp+70h] [rbp-28h]
  __int128 v14; // [rsp+80h] [rbp-18h]
  va_list va; // [rsp+C0h] [rbp+28h] BYREF

  va_start(va, CamDir:_%3d_%3d_%4d_FOV:_%.0f_Focal:_%.2f_FStop:_%.1f);
  v14 = v4;
  v13 = v5;
  v12 = 1.0;
  v10 = xmmword_147F38600;
  n178 = 178;
  v12 = (*(float (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_14981D2F8 + 520LL))(qword_14981D2F8) * 1.25;
  v11 = v12;
  v6 = *(_QWORD *)qword_14981D2F8;
  v8[0] = fovValueDeg;
  result = 1.0;
  v8[2] = 1.0;
  v8[1] = a3;
  (*(void (__fastcall **)(_LocaleUpdate *, double *, int *, const char *, __int64 *))(v6 + 1376))(
    qword_14981D2F8,
    v8,
    &n178,
    CamDir:_%3d_%3d_%4d_FOV:_%.0f_Focal:_%.2f_FStop:_%.1f,
    (__int64 *)va);
  return result;
}

// --- End Function: sub_14709B430 (0x14709B430) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memset (0x147E162C7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x147E162C7) ---

// --- Function: asinf (0x147E163B7) ---
// attributes: thunk
float __cdecl asinf(float X)
{
  return __imp_asinf(X);
}

// --- End Function: asinf (0x147E163B7) ---

// --- Function: atan2f (0x147E163BD) ---
// attributes: thunk
float __cdecl atan2f(float Y, float X)
{
  return __imp_atan2f(Y, X);
}

// --- End Function: atan2f (0x147E163BD) ---

// --- Function: tanf (0x147E16405) ---
// attributes: thunk
float __cdecl tanf(float X)
{
  return __imp_tanf(X);
}

// --- End Function: tanf (0x147E16405) ---

