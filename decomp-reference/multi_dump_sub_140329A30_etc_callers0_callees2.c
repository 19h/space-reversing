// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x140329A30 (sub_140329A30)
//   - 0x14036BF80 (DataCore::InitializeDataCoreStructData)
//   - 0x1403B6150 (sub_1403B6150)
//   - 0x14096EAD0 (sub_14096EAD0)
//   - 0x1474810D0 (sub_1474810D0)
//   - 0x1474858F0 (sub_1474858F0)
//   - 0x147489850 (sub_147489850)
//   - 0x147490D70 (sub_147490D70)
//   - 0x147491120 (sub_147491120)
//   - 0x1474A10F0 (sub_1474A10F0)
//   - 0x1474A1490 (sub_1474A1490)
//   - 0x1474A33B0 (sub_1474A33B0)
//   - 0x1474A3450 (sub_1474A3450)
//   - 0x1474A36D0 (sub_1474A36D0)
//   - 0x1474A3870 (sub_1474A3870)
//   - 0x1474A39D0 (sub_1474A39D0)
//   - 0x1474A3B00 (sub_1474A3B00)
//   - 0x1474A3BA0 (sub_1474A3BA0)
//   - 0x1474A3F50 (sub_1474A3F50)
//   - 0x1474A4240 (sub_1474A4240)
//   - 0x1474A4540 (sub_1474A4540)
//   - 0x1474A4770 (sub_1474A4770)
//   - 0x1474A4920 (sub_1474A4920)
//   - 0x1474A4B20 (sub_1474A4B20)
//   - 0x1474A4C10 (sub_1474A4C10)
//   - 0x1474A4E70 (sub_1474A4E70)
//   - 0x1474A4F20 (sub_1474A4F20)
//   - 0x1474A4FA0 (sub_1474A4FA0)
//   - 0x1474A4FC0 (sub_1474A4FC0)
//   - 0x1474A50B0 (sub_1474A50B0)
//   - 0x1474A5370 (sub_1474A5370)
//   - 0x1474A5750 (DataCore::LookupDCStructDescByName)
//   - 0x1474A5850 (sub_1474A5850)
//   - 0x1474A5C30 (sub_1474A5C30)
//   - 0x1474A65F0 (sub_1474A65F0)
//   - 0x1474A6C50 (sub_1474A6C50)
//   - 0x1474A9090 (sub_1474A9090)
//   - 0x1474B4EB0 (sub_1474B4EB0)
//   - 0x1474B7320 (sub_1474B7320)
//   - 0x1474C27E0 (DataCore::RegisterDataCoreStruct)
//   - 0x1474C44D0 (sub_1474C44D0)
//   - 0x1474C44F0 (sub_1474C44F0)
//   - 0x1474CD780 (sub_1474CD780)
//   - 0x1474CEDE0 (sub_1474CEDE0)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 225
// ------------------------------------------------------------

// --- Function: sub_1402A24F0 (0x1402A24F0) ---
__int64 __fastcall sub_1402A24F0(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1402A24F0 (0x1402A24F0) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3B50 (0x1402A3B50) ---
_BYTE *__fastcall sub_1402A3B50(__int64 *a1, __int64 n511_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n511; // rcx

  result = a1 + 3;
  if ( n511_1 )
  {
    allocSize = n511_1 + 1;
    if ( (unsigned __int64)(n511_1 + 1) <= 0x200 )
    {
      n511 = 511;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3AB68 += allocSize;
      n511 = n511_1;
    }
    a1[1] = n511;
    *a1 = n511_1;
    a1[2] = (__int64)result;
    result[n511_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 511;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A3B50 (0x1402A3B50) ---

// --- Function: sub_1402A3C90 (0x1402A3C90) ---
void __fastcall sub_1402A3C90(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _BYTE *v3; // rsi

  v2 = (_QWORD *)a1[2];
  v3 = a1 + 3;
  if ( v2 != a1 + 3 )
  {
    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
    sub_147605980(v2);
  }
  a1[2] = v3;
  *v3 = 0;
  *a1 = 0;
  a1[1] = 0x1FF;
}

// --- End Function: sub_1402A3C90 (0x1402A3C90) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: sub_1402A6620 (0x1402A6620) ---
char *__fastcall sub_1402A6620(__int64 a1, _QWORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _QWORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  char *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 0x10);
  if ( v2 == v4 )
  {
    v7 = 0x1FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*(_QWORD *)a1] >> 3;
    if ( v8 == 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = (__int64)&v4[-*(_QWORD *)a1] >> 3;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_QWORD *)sub_140391AB0(a1, 8 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = *(char **)(a1 + 8);
    v16 = *(char **)a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 8;
      Size = *(_QWORD *)(a1 + 8) - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *(_QWORD *)a1 )
      sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_QWORD *)a1 = v13;
    result = v17;
    *(_QWORD *)(a1 + 8) = &v13[v11];
    *(_QWORD *)(a1 + 0x10) = &v13[v12];
  }
  else
  {
    *(_QWORD *)v2 = *a2;
    result = *(char **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result + 8;
  }
  return result;
}

// --- End Function: sub_1402A6620 (0x1402A6620) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 39 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 39);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 - 1) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---

// --- Function: sub_1402A6B30 (0x1402A6B30) ---
char *__fastcall sub_1402A6B30(__int64 a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  std::array<int,2> *v12; // rsi
  std::array<int,2> *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  char *v16; // rbp
  size_t Size; // r8
  _QWORD *v18; // rcx
  char *result; // rax

  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 3;
  _Count = 0x1FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<std::array<int,2>>::allocate((std::allocator<std::array<int,2> > *)a1, _Count);
  *((_QWORD *)v12 + v4) = *a3;
  v13 = v12;
  v14 = *(_BYTE **)(a1 + 8);
  v15 = *(_BYTE **)a1;
  v16 = (char *)v12 + 8 * v4;
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = (std::array<int,2> *)(v16 + 8);
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  v18 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v18) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v18 - v18[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v18 = (_QWORD *)v18[0xFFFFFFFF];
    }
    sub_1402A3D30(v18);
  }
  *(_QWORD *)a1 = v12;
  result = v16;
  *(_QWORD *)(a1 + 8) = (char *)v12 + 8 * v10;
  *(_QWORD *)(a1 + 0x10) = (char *)v12 + 8 * _Count;
  return result;
}

// --- End Function: sub_1402A6B30 (0x1402A6B30) ---

// --- Function: sub_1402A7670 (0x1402A7670) ---
char *__fastcall sub_1402A7670(__int64 *a1, _BYTE *a2, __int64 a3)
{
  __int64 v6; // r12
  __int64 v7; // rdx
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  _QWORD *v13; // rbx
  void *v14; // rcx
  double *v15; // rbp
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  size_t Size; // r8
  _BYTE *v19; // r8
  char *result; // rax

  v6 = (__int64)&a2[-*a1] / 0x18;
  v7 = (a1[1] - *a1) / 0x18;
  if ( v7 == 0xAAAAAAAAAAAAAAALL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x18;
  if ( v9 > 0xAAAAAAAAAAAAAAALL - (v9 >> 1) )
    goto LABEL_24;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0xAAAAAAAAAAAAAAALL )
    goto LABEL_24;
  v11 = 0x18 * v10;
  if ( 0x18 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = (_QWORD *)allocWithProfilerInfo_w(0x18 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_24:
    sub_1402E1170();
  v12 = allocWithProfilerInfo_w(v11 + 0x27);
  if ( !v12 )
    goto LABEL_22;
  v13 = (_QWORD *)((v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v13[0xFFFFFFFF] = v12;
LABEL_13:
  v14 = v13;
  *(_OWORD *)&v13[3 * v6] = *(_OWORD *)a3;
  v15 = (double *)&v13[3 * v6];
  v15[2] = *(double *)(a3 + 0x10);
  v16 = (_BYTE *)a1[1];
  v17 = (_BYTE *)*a1;
  if ( a2 == v16 )
  {
    Size = v16 - v17;
  }
  else
  {
    memmove(v13, v17, a2 - v17);
    v14 = v15 + 3;
    Size = a1[1] - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v14, v17, Size);
  v19 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(0x18 * ((a1[2] - (__int64)v19) / 0x18)) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v19);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v19[-*((_QWORD *)v19 + 0xFFFFFFFF) - 8] <= 0x1F )
    {
      v19 = (_BYTE *)*((_QWORD *)v19 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v13;
  a1[1] = (__int64)&v13[3 * v8];
  result = (char *)&v13[3 * v6];
  a1[2] = (__int64)&v13[v11 / 8];
  return result;
}

// --- End Function: sub_1402A7670 (0x1402A7670) ---

// --- Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PEAVListener@Logger@gte@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@1@PEAU?$_Tree_node@PEAVListener@Logger@gte@@PEAX@1@@Z (0x1402A7F70) ---
void __fastcall std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
        std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *this,
        std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *_Al,
        std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode)
{
  std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode_1; // rbx
  std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode_2; // rcx

  _Rootnode_1 = _Rootnode;
  while ( !*((_BYTE *)_Rootnode_1 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      this,
      _Al,
      *((std::_Tree_node<gte::Logger::Listener *,void *> **)_Rootnode_1 + 2));
    _Rootnode_2 = _Rootnode_1;
    _Rootnode_1 = *(std::_Tree_node<gte::Logger::Listener *,void *> **)_Rootnode_1;
    sub_1402A3D30(_Rootnode_2);
  }
}

// --- End Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PEAVListener@Logger@gte@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@1@PEAU?$_Tree_node@PEAVListener@Logger@gte@@PEAX@1@@Z (0x1402A7F70) ---

// --- Function: sub_1402AAA30 (0x1402AAA30) ---
__int64 __fastcall sub_1402AAA30(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 *v5; // r15
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 *v8; // rbx
  __int64 *v9; // rbp
  __int64 *v10; // rcx
  __int64 **v12; // r13
  _QWORD *v13; // r12
  __int64 v14; // rdi
  __int64 v15; // rcx
  float v16; // xmm1_4
  float v17; // kr00_4
  unsigned __int64 n8_2; // rdx
  float v19; // xmm0_4
  float v20; // kr00_4
  unsigned __int64 v23; // rcx
  unsigned __int64 n8_1; // rax
  unsigned __int64 n8; // rcx
  unsigned __int64 v26; // r8
  __int64 v27; // rdx
  __int64 *v28; // rax
  __int64 *v29; // rdx
  int v30; // ecx
  __int64 *v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // rax
  __int64 *v34; // r8
  unsigned __int64 v35; // [rsp+70h] [rbp+8h]

  v5 = *(__int64 **)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 0x18);
  v35 = 0x100000001B3LL
      * (a3[3]
       ^ (0x100000001B3LL * (a3[2] ^ (0x100000001B3LL * (a3[1] ^ (0x100000001B3LL * (*a3 ^ 0xCBF29CE484222325uLL)))))));
  v7 = 2 * (v35 & *(_QWORD *)(a1 + 0x30));
  v8 = *(__int64 **)(v6 + 8 * v7 + 8);
  if ( v8 == v5 )
  {
    v8 = v5;
    v9 = v5;
  }
  else
  {
    v10 = *(__int64 **)(v6 + 8 * v7);
    if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
    {
LABEL_6:
      *(_QWORD *)a2 = v8;
      *(_BYTE *)(a2 + 8) = 0;
      return a2;
    }
    while ( v8 != v10 )
    {
      v8 = (__int64 *)v8[1];
      if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
        goto LABEL_6;
    }
    v5 = v8;
    v9 = v8;
  }
  v12 = (__int64 **)(a1 + 8);
  v13 = (_QWORD *)(a1 + 0x30);
  if ( *(_QWORD *)(a1 + 0x10) == 0x7FFFFFFFFFFFFFFLL )
    std::_Xlength_error("unordered_map/set too long");
  v14 = allocWithProfilerInfo_w(0x20u);
  *(_DWORD *)(v14 + 0x10) = *(_DWORD *)a3;
  *(_QWORD *)(v14 + 0x18) = 0;
  v15 = *(_QWORD *)(a1 + 0x10) + 1LL;
  if ( v15 < 0 )
  {
    v17 = (float)(v15 & 1 | ((unsigned __int64)v15 >> 1));
    v16 = v17 + v17;
  }
  else
  {
    v16 = (float)v15;
  }
  n8_2 = *(_QWORD *)(a1 + 0x38);
  if ( (n8_2 & 0x8000000000000000uLL) != 0LL )
  {
    v20 = (float)(*(_QWORD *)(a1 + 0x38) & 1LL | (n8_2 >> 1));
    v19 = v20 + v20;
  }
  else
  {
    v19 = (float)(__int64)n8_2;
  }
  if ( *(float *)a1 >= (float)(v16 / v19) )
  {
    v26 = v35;
  }
  else
  {
    _XMM1 = 0;
    __asm { vroundss xmm1, xmm1, xmm0, 2 }
    v23 = 0;
    if ( *(float *)&_XMM1 >= 9.223372e18 )
    {
      *(float *)&_XMM1 = *(float *)&_XMM1 - 9.223372e18;
      if ( *(float *)&_XMM1 < 9.223372e18 )
        v23 = 0x8000000000000000uLL;
    }
    n8_1 = v23 + (unsigned int)(int)*(float *)&_XMM1;
    n8 = 8;
    if ( n8_1 > 8 )
      n8 = n8_1;
    if ( n8_2 < n8 )
    {
      if ( n8_2 >= 0x200 || (n8_2 *= 8LL, n8_2 < n8) )
        n8_2 = n8;
    }
    std::_Hash<std::_Umap_traits<int,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>>>,0>>::_Forced_rehash(
      (unsigned __int64 **)a1,
      n8_2);
    v26 = v35;
    v27 = *(_QWORD *)(a1 + 0x18);
    v8 = *(__int64 **)(a1 + 8);
    v28 = *(__int64 **)(v27 + 0x10 * (v35 & *(_QWORD *)(a1 + 0x30)) + 8);
    if ( v28 != v8 )
    {
      v29 = *(__int64 **)(v27 + 0x10 * (v35 & *(_QWORD *)(a1 + 0x30)));
      v30 = *(_DWORD *)(v14 + 0x10);
      if ( v30 != *((_DWORD *)v28 + 4) )
      {
        while ( 1 )
        {
          v8 = v28;
          if ( v28 == v29 )
            break;
          v28 = (__int64 *)v28[1];
          if ( v30 == *((_DWORD *)v28 + 4) )
            goto LABEL_30;
        }
        v13 = (_QWORD *)(a1 + 0x30);
        v12 = (__int64 **)(a1 + 8);
        v9 = v28;
        v5 = v28;
        goto LABEL_34;
      }
LABEL_30:
      v8 = (__int64 *)*v28;
    }
    v13 = (_QWORD *)(a1 + 0x30);
    v9 = v8;
    v12 = (__int64 **)(a1 + 8);
    v5 = v8;
  }
LABEL_34:
  v31 = (__int64 *)v8[1];
  ++*(_QWORD *)(a1 + 0x10);
  *(_QWORD *)v14 = v5;
  *(_QWORD *)(v14 + 8) = v31;
  *v31 = v14;
  v8[1] = v14;
  v32 = *(_QWORD *)(a1 + 0x18);
  v33 = 2 * (v26 & *v13);
  v34 = *(__int64 **)(v32 + 0x10 * (v26 & *v13));
  if ( v34 == *v12 )
  {
    *(_QWORD *)(v32 + 8 * v33) = v14;
    goto LABEL_39;
  }
  if ( v34 != v9 )
  {
    if ( *(__int64 **)(v32 + 8 * v33 + 8) != v31 )
    {
LABEL_40:
      *(_QWORD *)a2 = v14;
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
LABEL_39:
    *(_QWORD *)(v32 + 8 * v33 + 8) = v14;
    goto LABEL_40;
  }
  *(_QWORD *)(v32 + 8 * v33) = v14;
  *(_QWORD *)a2 = v14;
  *(_BYTE *)(a2 + 8) = 1;
  return a2;
}

// --- End Function: sub_1402AAA30 (0x1402AAA30) ---

// --- Function: ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@0@0AEBV10@@Z (0x1402AD370) ---
void __fastcall std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>>>(
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *const _First,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *const _Last,
        const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *_Val)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *_First_1; // r9
  unsigned __int64 n2; // rdx
  char *_Val_1; // rcx
  unsigned __int64 v7; // rdx

  _First_1 = _First;
  n2 = (unsigned __int64)(_Last - _First + 7) >> 3;
  if ( _First > _Last )
    n2 = 0;
  if ( n2 >= 2 )
  {
    _Val_1 = (char *)_First + 8 * n2 + 0xFFFFFFF8;
    if ( _First_1 > _Val || _Val_1 < (char *)_Val )
    {
      v7 = 8 * (n2 & 0xFFFFFFFFFFFFFFFEuLL);
      memset64(_First_1, *(_QWORD *)_Val, v7 >> 3);
      _First_1 = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)((char *)_First_1 + v7);
    }
  }
  for ( ;
        _First_1 != _Last;
        _First_1 = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)((char *)_First_1 + 8) )
  {
    *(_QWORD *)_First_1 = *(_QWORD *)_Val;
  }
}

// --- End Function: ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@0@0AEBV10@@Z (0x1402AD370) ---

// --- Function: sub_1402B1960 (0x1402B1960) ---
__int64 __fastcall sub_1402B1960(__int64 *a1)
{
  _QWORD *v2; // rcx
  __int64 v3; // rcx
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx

  v2 = (_QWORD *)a1[3];
  if ( v2 )
  {
    if ( ((a1[5] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[3] = 0;
    a1[4] = 0;
    a1[5] = 0;
  }
  v3 = a1[1];
  **(_QWORD **)(v3 + 8) = 0;
  v4 = *(_QWORD **)v3;
  if ( v4 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      sub_1402A3D30(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  return sub_1402A3D30((const void *)a1[1]);
}

// --- End Function: sub_1402B1960 (0x1402B1960) ---

// --- Function: std::vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____::_vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____ (0x1402B2320) ---
__int64 __fastcall std::vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____::_vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____(
        __int64 a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: std::vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____::_vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____ (0x1402B2320) ---

// --- Function: ?_Tidy@?$vector@V?$Vector@$02N@gte@@V?$allocator@V?$Vector@$02N@gte@@@std@@@std@@AEAAXXZ (0x1402B2380) ---
void __fastcall std::vector<gte::Vector<3,double>>::_Tidy(std::vector<gte::Vector<3,double>> *this)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)this;
  if ( v2 )
  {
    if ( (unsigned __int64)(24 * ((*((_QWORD *)this + 2) - (_QWORD)v2) / 24LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)*(v2 - 1);
    }
    sub_1402A3D30(v2);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
  }
}

// --- End Function: ?_Tidy@?$vector@V?$Vector@$02N@gte@@V?$allocator@V?$Vector@$02N@gte@@@std@@@std@@AEAAXXZ (0x1402B2380) ---

// --- Function: ??0_lambda_17b8e77e04f0039ff1429d79b8271fa1_@@QEAA@AEBQEB_W@Z (0x1402B4B70) ---
// Microsoft VisualC v14 64bit runtime
_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *__fastcall _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
        _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *this,
        const wchar_t **a2)
{
  *(_QWORD *)this = *a2;
  return this;
}

// --- End Function: ??0_lambda_17b8e77e04f0039ff1429d79b8271fa1_@@QEAA@AEBQEB_W@Z (0x1402B4B70) ---

// --- Function: ??_H@YAXPEAX_K1P6APEAX0@Z@Z (0x1402B8050) ---
void __fastcall `vector constructor iterator'(
        char *__t,
        unsigned __int64 __s,
        unsigned __int64 __n,
        void *(__fastcall *__f)(void *))
{
  unsigned __int64 __n_1; // rbx

  if ( __n )
  {
    __n_1 = __n;
    do
    {
      __f(__t);
      __t += __s;
      --__n_1;
    }
    while ( __n_1 );
  }
}

// --- End Function: ??_H@YAXPEAX_K1P6APEAX0@Z@Z (0x1402B8050) ---

// --- Function: sub_1402BC380 (0x1402BC380) ---
__int64 *__fastcall sub_1402BC380(__int64 *a1, char *a2)
{
  __int64 n0x7B; // r8
  __int64 n0x5A; // r8
  __int64 v6; // r8
  __int64 n0x5A_1; // rcx
  __int64 v8; // r8
  __int64 v9; // rcx
  __int64 n0x5A_2; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r8
  __int64 n0x5A_3; // rcx
  __int64 v15; // rdx
  __int64 n0x5A_4; // rcx
  __int64 v17; // rdx
  __int64 v18; // rax
  __int64 n0x5A_5; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  __int64 n0x5A_6; // rcx
  __int64 v23; // rdx
  __int64 v24; // rax
  __int64 n0x5A_7; // rcx
  __int64 v26; // rdx
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 n0x7A; // rcx
  __int64 v30; // rax
  __int64 n0x5A_8; // rcx
  __int64 v32; // rdx
  __int64 v33; // rax
  __int64 n0x5A_9; // rcx
  __int64 v35; // rdx
  __int64 v36; // rax
  __int64 n0x5A_10; // rcx
  __int64 v38; // rdx
  __int64 v39; // rax
  __int64 v40; // rdx
  __int64 n0x7A_1; // rcx
  __int64 v42; // rax
  __int64 n0x5A_11; // rcx
  __int64 v44; // rdx
  __int64 v45; // rax
  __int64 n0x5A_12; // rcx
  __int64 v47; // rdx
  __int64 v48; // rax
  __int64 n0x5A_13; // rcx
  __int64 v50; // rdx
  __int64 v51; // rax
  __int64 v52; // rdx
  __int64 n0x7A_2; // rcx
  __int64 v54; // rcx
  __int64 n0x5A_14; // r8
  __int64 v56; // rcx
  __int64 v57; // rax
  __int64 n0x5A_15; // r8
  __int64 v59; // rcx
  __int64 v60; // r8
  __int64 v61; // r8
  __int64 n0x5A_16; // rcx
  __int64 v63; // rcx
  __int64 v64; // rcx
  __int64 n0x7A_3; // r8
  __int64 v66; // r8
  __int64 v67; // r8
  __int64 n0x5A_17; // rcx
  __int64 v69; // rcx
  __int64 v70; // rcx
  __int64 n0x5A_18; // r8
  __int64 v72; // r8
  __int64 v73; // r8
  __int64 n0x5A_19; // rcx
  __int64 v75; // rcx
  __int64 v76; // rcx
  __int64 n0x5A_20; // r8
  __int64 v78; // r8
  __int64 v79; // r8
  __int64 n0x5A_21; // rcx
  __int64 v81; // rcx
  __int64 v82; // rcx
  __int64 n0x5A_22; // r8
  __int64 v84; // r8
  __int64 v85; // r8
  __int64 n0x5A_23; // rcx
  __int64 v87; // rcx
  __int64 v88; // rcx
  __int64 n0x5A_24; // r8
  __int64 v90; // rax
  __int64 n0x5A_25; // r8
  __int64 v92; // rcx
  __int64 v93; // rax
  __int64 n0x5A_26; // r8
  __int64 v95; // rcx
  __int64 v96; // rax
  __int64 n0x61; // r8
  __int64 v98; // rcx
  __int64 v99; // rax
  __int64 v100; // rcx
  __int64 *result; // rax
  __int64 v102; // rdx
  __int64 n0x7A_4; // rcx
  __int64 v104; // rdx
  __int64 v105; // rax
  __int64 n0x7A_5; // rcx
  __int64 v107; // rdx
  __int64 v108; // rax
  __int64 n0x7A_6; // rcx
  __int64 v110; // rdx
  __int64 v111; // rax
  __int64 n0x7A_7; // rcx
  __int64 v113; // rdx
  __int64 v114; // rax
  __int64 n0x7A_8; // rcx
  __int64 v116; // rdx
  __int64 v117; // rax
  __int64 n0x7A_9; // rcx
  __int64 v119; // rdx
  __int64 v120; // rax
  __int64 n0x7A_10; // rcx
  __int64 v122; // rdx
  __int64 v123; // rax
  __int64 v124; // rdx
  __int64 n0x7A_11; // rcx
  __int64 v126; // rax
  __int64 n0x7A_12; // rcx
  __int64 v128; // rdx
  __int64 v129; // rax
  __int64 n0x7A_13; // rcx
  __int64 v131; // rdx
  __int64 v132; // rax
  __int64 n0x7A_14; // rcx
  __int64 v134; // rdx
  __int64 v135; // rax
  __int64 v136; // rdx
  __int64 n0x7A_15; // rcx
  __int64 v138; // rax
  __int64 n0x7A_16; // rcx
  __int64 v140; // rdx
  __int64 v141; // rax
  __int64 n0x7A_17; // rcx
  __int64 v143; // rdx
  __int64 v144; // rax
  __int64 n0x7A_18; // rcx
  __int64 v146; // rdx
  __int64 v147; // rax
  __int64 n0x7A_19; // rcx
  __int64 v149; // r8
  __int64 n0x7A_20; // rcx
  __int64 v151; // r8
  __int64 v152; // rax
  __int64 n0x7A_21; // rcx
  __int64 v154; // r8
  __int64 v155; // rax
  __int64 n0x7A_22; // rcx
  __int64 v157; // r8
  __int64 v158; // rax
  __int64 v159; // r8
  __int64 n0x7A_23; // rcx
  __int64 v161; // rax
  __int64 n0x7A_24; // rcx
  __int64 v163; // r8
  __int64 v164; // rax
  __int64 n0x7A_25; // rcx
  __int64 v166; // r8
  __int64 v167; // rax
  __int64 n0x7A_26; // rcx
  __int64 v169; // r8
  __int64 v170; // rax
  __int64 n0x7A_27; // rcx
  __int64 v172; // r8
  __int64 v173; // rax
  __int64 n0x7A_28; // rcx
  __int64 v175; // r8
  __int64 v176; // rax
  __int64 n0x7A_29; // rcx
  __int64 v178; // r8
  __int64 v179; // rax
  __int64 n0x7A_30; // rcx
  __int64 v181; // r8
  __int64 v182; // rax
  __int64 n0x7A_31; // rcx
  __int64 v184; // r8
  __int64 v185; // rax
  __int64 n0x7A_32; // rcx
  __int64 v187; // r8
  __int64 v188; // rax
  __int64 n0x7A_33; // rcx
  __int64 v190; // r8
  __int64 v191; // rax
  __int64 n0x7A_34; // rcx
  __int64 v193; // r8

  n0x7B = *a2;
  if ( (_BYTE)n0x7B == 0x7B )
  {
    n0x5A = a2[1];
    if ( (char)n0x5A <= 0x7A )
    {
      if ( (char)n0x5A < 0x61 )
      {
        if ( (char)n0x5A > 0x5A )
          goto LABEL_263;
        if ( (char)n0x5A < 0x41 )
        {
          if ( (unsigned __int8)(n0x5A - 0x30) > 9u )
            goto LABEL_263;
          v6 = n0x5A - 0x30;
        }
        else
        {
          v6 = n0x5A - 0x37;
        }
      }
      else
      {
        v6 = n0x5A - 0x57;
      }
      n0x5A_1 = a2[2];
      v8 = v6 << 0x1C;
      if ( (char)n0x5A_1 <= 0x7A )
      {
        if ( (char)n0x5A_1 < 0x61 )
        {
          if ( (char)n0x5A_1 > 0x5A )
            goto LABEL_263;
          if ( (char)n0x5A_1 < 0x41 )
          {
            if ( (unsigned __int8)(n0x5A_1 - 0x30) > 9u )
              goto LABEL_263;
            v9 = n0x5A_1 - 0x30;
          }
          else
          {
            v9 = n0x5A_1 - 0x37;
          }
        }
        else
        {
          v9 = n0x5A_1 - 0x57;
        }
        n0x5A_2 = a2[3];
        v11 = v8 | (v9 << 0x18);
        if ( (char)n0x5A_2 <= 0x7A )
        {
          if ( (char)n0x5A_2 < 0x61 )
          {
            if ( (char)n0x5A_2 > 0x5A )
              goto LABEL_263;
            if ( (char)n0x5A_2 < 0x41 )
            {
              if ( (unsigned __int8)(n0x5A_2 - 0x30) > 9u )
                goto LABEL_263;
              v12 = n0x5A_2 - 0x30;
            }
            else
            {
              v12 = n0x5A_2 - 0x37;
            }
          }
          else
          {
            v12 = n0x5A_2 - 0x57;
          }
          v13 = v11 | (v12 << 0x14);
          n0x5A_3 = a2[4];
          if ( (char)n0x5A_3 <= 0x7A )
          {
            if ( (char)n0x5A_3 < 0x61 )
            {
              if ( (char)n0x5A_3 > 0x5A )
                goto LABEL_263;
              if ( (char)n0x5A_3 < 0x41 )
              {
                if ( (unsigned __int8)(n0x5A_3 - 0x30) > 9u )
                  goto LABEL_263;
                v15 = n0x5A_3 - 0x30;
              }
              else
              {
                v15 = n0x5A_3 - 0x37;
              }
            }
            else
            {
              v15 = n0x5A_3 - 0x57;
            }
            n0x5A_4 = a2[5];
            v17 = v13 | (v15 << 0x10);
            if ( (char)n0x5A_4 <= 0x7A )
            {
              if ( (char)n0x5A_4 < 0x61 )
              {
                if ( (char)n0x5A_4 > 0x5A )
                  goto LABEL_263;
                if ( (char)n0x5A_4 < 0x41 )
                {
                  if ( (unsigned __int8)(n0x5A_4 - 0x30) > 9u )
                    goto LABEL_263;
                  v18 = n0x5A_4 - 0x30;
                }
                else
                {
                  v18 = n0x5A_4 - 0x37;
                }
              }
              else
              {
                v18 = n0x5A_4 - 0x57;
              }
              n0x5A_5 = a2[6];
              v20 = (v18 << 0xC) | v17;
              if ( (char)n0x5A_5 <= 0x7A )
              {
                if ( (char)n0x5A_5 < 0x61 )
                {
                  if ( (char)n0x5A_5 > 0x5A )
                    goto LABEL_263;
                  if ( (char)n0x5A_5 < 0x41 )
                  {
                    if ( (unsigned __int8)(n0x5A_5 - 0x30) > 9u )
                      goto LABEL_263;
                    v21 = n0x5A_5 - 0x30;
                  }
                  else
                  {
                    v21 = n0x5A_5 - 0x37;
                  }
                }
                else
                {
                  v21 = n0x5A_5 - 0x57;
                }
                n0x5A_6 = a2[7];
                v23 = (v21 << 8) | v20;
                if ( (char)n0x5A_6 <= 0x7A )
                {
                  if ( (char)n0x5A_6 < 0x61 )
                  {
                    if ( (char)n0x5A_6 > 0x5A )
                      goto LABEL_263;
                    if ( (char)n0x5A_6 < 0x41 )
                    {
                      if ( (unsigned __int8)(n0x5A_6 - 0x30) > 9u )
                        goto LABEL_263;
                      v24 = n0x5A_6 - 0x30;
                    }
                    else
                    {
                      v24 = n0x5A_6 - 0x37;
                    }
                  }
                  else
                  {
                    v24 = n0x5A_6 - 0x57;
                  }
                  n0x5A_7 = a2[8];
                  v26 = (0x10 * v24) | v23;
                  if ( (char)n0x5A_7 <= 0x7A )
                  {
                    if ( (char)n0x5A_7 < 0x61 )
                    {
                      if ( (char)n0x5A_7 > 0x5A )
                        goto LABEL_263;
                      if ( (char)n0x5A_7 < 0x41 )
                      {
                        if ( (unsigned __int8)(n0x5A_7 - 0x30) > 9u )
                          goto LABEL_263;
                        v27 = n0x5A_7 - 0x30;
                      }
                      else
                      {
                        v27 = n0x5A_7 - 0x37;
                      }
                    }
                    else
                    {
                      v27 = n0x5A_7 - 0x57;
                    }
                    v28 = v27 | v26;
                    if ( a2[9] != 0x2D )
                      goto LABEL_263;
                    n0x7A = a2[0xA];
                    if ( (char)n0x7A > 0x7A )
                      goto LABEL_263;
                    if ( (char)n0x7A < 0x61 )
                    {
                      if ( (char)n0x7A > 0x5A )
                        goto LABEL_263;
                      if ( (char)n0x7A < 0x41 )
                      {
                        if ( (unsigned __int8)(n0x7A - 0x30) > 9u )
                          goto LABEL_263;
                        v30 = n0x7A - 0x30;
                      }
                      else
                      {
                        v30 = n0x7A - 0x37;
                      }
                    }
                    else
                    {
                      v30 = n0x7A - 0x57;
                    }
                    n0x5A_8 = a2[0xB];
                    v32 = (v30 << 0x2C) | v28;
                    if ( (char)n0x5A_8 <= 0x7A )
                    {
                      if ( (char)n0x5A_8 < 0x61 )
                      {
                        if ( (char)n0x5A_8 > 0x5A )
                          goto LABEL_263;
                        if ( (char)n0x5A_8 < 0x41 )
                        {
                          if ( (unsigned __int8)(n0x5A_8 - 0x30) > 9u )
                            goto LABEL_263;
                          v33 = n0x5A_8 - 0x30;
                        }
                        else
                        {
                          v33 = n0x5A_8 - 0x37;
                        }
                      }
                      else
                      {
                        v33 = n0x5A_8 - 0x57;
                      }
                      n0x5A_9 = a2[0xC];
                      v35 = (v33 << 0x28) | v32;
                      if ( (char)n0x5A_9 <= 0x7A )
                      {
                        if ( (char)n0x5A_9 < 0x61 )
                        {
                          if ( (char)n0x5A_9 > 0x5A )
                            goto LABEL_263;
                          if ( (char)n0x5A_9 < 0x41 )
                          {
                            if ( (unsigned __int8)(n0x5A_9 - 0x30) > 9u )
                              goto LABEL_263;
                            v36 = n0x5A_9 - 0x30;
                          }
                          else
                          {
                            v36 = n0x5A_9 - 0x37;
                          }
                        }
                        else
                        {
                          v36 = n0x5A_9 - 0x57;
                        }
                        n0x5A_10 = a2[0xD];
                        v38 = (v36 << 0x24) | v35;
                        if ( (char)n0x5A_10 <= 0x7A )
                        {
                          if ( (char)n0x5A_10 < 0x61 )
                          {
                            if ( (char)n0x5A_10 > 0x5A )
                              goto LABEL_263;
                            if ( (char)n0x5A_10 < 0x41 )
                            {
                              if ( (unsigned __int8)(n0x5A_10 - 0x30) > 9u )
                                goto LABEL_263;
                              v39 = n0x5A_10 - 0x30;
                            }
                            else
                            {
                              v39 = n0x5A_10 - 0x37;
                            }
                          }
                          else
                          {
                            v39 = n0x5A_10 - 0x57;
                          }
                          v40 = (v39 << 0x20) | v38;
                          if ( a2[0xE] != 0x2D )
                            goto LABEL_263;
                          n0x7A_1 = a2[0xF];
                          if ( (char)n0x7A_1 > 0x7A )
                            goto LABEL_263;
                          if ( (char)n0x7A_1 < 0x61 )
                          {
                            if ( (char)n0x7A_1 > 0x5A )
                              goto LABEL_263;
                            if ( (char)n0x7A_1 < 0x41 )
                            {
                              if ( (unsigned __int8)(n0x7A_1 - 0x30) > 9u )
                                goto LABEL_263;
                              v42 = a2[0xF];
                            }
                            else
                            {
                              v42 = n0x7A_1 - 7;
                            }
                          }
                          else
                          {
                            v42 = n0x7A_1 - 7;
                          }
                          n0x5A_11 = a2[0x10];
                          v44 = (v42 << 0x3C) | v40;
                          if ( (char)n0x5A_11 <= 0x7A )
                          {
                            if ( (char)n0x5A_11 < 0x61 )
                            {
                              if ( (char)n0x5A_11 > 0x5A )
                                goto LABEL_263;
                              if ( (char)n0x5A_11 < 0x41 )
                              {
                                if ( (unsigned __int8)(n0x5A_11 - 0x30) > 9u )
                                  goto LABEL_263;
                                v45 = n0x5A_11 - 0x30;
                              }
                              else
                              {
                                v45 = n0x5A_11 - 0x37;
                              }
                            }
                            else
                            {
                              v45 = n0x5A_11 - 0x57;
                            }
                            n0x5A_12 = a2[0x11];
                            v47 = (v45 << 0x38) | v44;
                            if ( (char)n0x5A_12 <= 0x7A )
                            {
                              if ( (char)n0x5A_12 < 0x61 )
                              {
                                if ( (char)n0x5A_12 > 0x5A )
                                  goto LABEL_263;
                                if ( (char)n0x5A_12 < 0x41 )
                                {
                                  if ( (unsigned __int8)(n0x5A_12 - 0x30) > 9u )
                                    goto LABEL_263;
                                  v48 = n0x5A_12 - 0x30;
                                }
                                else
                                {
                                  v48 = n0x5A_12 - 0x37;
                                }
                              }
                              else
                              {
                                v48 = n0x5A_12 - 0x57;
                              }
                              n0x5A_13 = a2[0x12];
                              v50 = (v48 << 0x34) | v47;
                              if ( (char)n0x5A_13 <= 0x7A )
                              {
                                if ( (char)n0x5A_13 < 0x61 )
                                {
                                  if ( (char)n0x5A_13 > 0x5A )
                                    goto LABEL_263;
                                  if ( (char)n0x5A_13 < 0x41 )
                                  {
                                    if ( (unsigned __int8)(n0x5A_13 - 0x30) > 9u )
                                      goto LABEL_263;
                                    v51 = n0x5A_13 - 0x30;
                                  }
                                  else
                                  {
                                    v51 = n0x5A_13 - 0x37;
                                  }
                                }
                                else
                                {
                                  v51 = n0x5A_13 - 0x57;
                                }
                                v52 = (v51 << 0x30) | v50;
                                if ( a2[0x13] != 0x2D )
                                  goto LABEL_263;
                                n0x7A_2 = a2[0x14];
                                if ( (char)n0x7A_2 > 0x7A )
                                  goto LABEL_263;
                                if ( (char)n0x7A_2 < 0x61 )
                                {
                                  if ( (char)n0x7A_2 > 0x5A )
                                    goto LABEL_263;
                                  if ( (char)n0x7A_2 < 0x41 )
                                  {
                                    if ( (unsigned __int8)(n0x7A_2 - 0x30) > 9u )
                                      goto LABEL_263;
                                    v54 = n0x7A_2 - 0x30;
                                  }
                                  else
                                  {
                                    v54 = n0x7A_2 - 0x37;
                                  }
                                }
                                else
                                {
                                  v54 = n0x7A_2 - 0x57;
                                }
                                n0x5A_14 = a2[0x15];
                                v56 = 0x10 * v54;
                                if ( (char)n0x5A_14 <= 0x7A )
                                {
                                  if ( (char)n0x5A_14 < 0x61 )
                                  {
                                    if ( (char)n0x5A_14 > 0x5A )
                                      goto LABEL_263;
                                    if ( (char)n0x5A_14 < 0x41 )
                                    {
                                      if ( (unsigned __int8)(n0x5A_14 - 0x30) > 9u )
                                        goto LABEL_263;
                                      v57 = n0x5A_14 - 0x30;
                                    }
                                    else
                                    {
                                      v57 = n0x5A_14 - 0x37;
                                    }
                                  }
                                  else
                                  {
                                    v57 = n0x5A_14 - 0x57;
                                  }
                                  n0x5A_15 = a2[0x16];
                                  v59 = v57 | v56;
                                  if ( (char)n0x5A_15 <= 0x7A )
                                  {
                                    if ( (char)n0x5A_15 < 0x61 )
                                    {
                                      if ( (char)n0x5A_15 > 0x5A )
                                        goto LABEL_263;
                                      if ( (char)n0x5A_15 < 0x41 )
                                      {
                                        if ( (unsigned __int8)(n0x5A_15 - 0x30) > 9u )
                                          goto LABEL_263;
                                        v60 = n0x5A_15 - 0x30;
                                      }
                                      else
                                      {
                                        v60 = n0x5A_15 - 0x37;
                                      }
                                    }
                                    else
                                    {
                                      v60 = n0x5A_15 - 0x57;
                                    }
                                    v61 = v59 | (v60 << 0xC);
                                    n0x5A_16 = a2[0x17];
                                    if ( (char)n0x5A_16 <= 0x7A )
                                    {
                                      if ( (char)n0x5A_16 < 0x61 )
                                      {
                                        if ( (char)n0x5A_16 > 0x5A )
                                          goto LABEL_263;
                                        if ( (char)n0x5A_16 < 0x41 )
                                        {
                                          if ( (unsigned __int8)(n0x5A_16 - 0x30) > 9u )
                                            goto LABEL_263;
                                          v63 = n0x5A_16 - 0x30;
                                        }
                                        else
                                        {
                                          v63 = n0x5A_16 - 0x37;
                                        }
                                      }
                                      else
                                      {
                                        v63 = n0x5A_16 - 0x57;
                                      }
                                      v64 = v61 | (v63 << 8);
                                      if ( a2[0x18] != 0x2D )
                                        goto LABEL_263;
                                      n0x7A_3 = a2[0x19];
                                      if ( (char)n0x7A_3 > 0x7A )
                                        goto LABEL_263;
                                      if ( (char)n0x7A_3 < 0x61 )
                                      {
                                        if ( (char)n0x7A_3 > 0x5A )
                                          goto LABEL_263;
                                        if ( (char)n0x7A_3 < 0x41 )
                                        {
                                          if ( (unsigned __int8)(n0x7A_3 - 0x30) > 9u )
                                            goto LABEL_263;
                                          v66 = n0x7A_3 - 0x30;
                                        }
                                        else
                                        {
                                          v66 = n0x7A_3 - 0x37;
                                        }
                                      }
                                      else
                                      {
                                        v66 = n0x7A_3 - 0x57;
                                      }
                                      v67 = v64 | (v66 << 0x14);
                                      n0x5A_17 = a2[0x1A];
                                      if ( (char)n0x5A_17 <= 0x7A )
                                      {
                                        if ( (char)n0x5A_17 < 0x61 )
                                        {
                                          if ( (char)n0x5A_17 > 0x5A )
                                            goto LABEL_263;
                                          if ( (char)n0x5A_17 < 0x41 )
                                          {
                                            if ( (unsigned __int8)(n0x5A_17 - 0x30) > 9u )
                                              goto LABEL_263;
                                            v69 = n0x5A_17 - 0x30;
                                          }
                                          else
                                          {
                                            v69 = n0x5A_17 - 0x37;
                                          }
                                        }
                                        else
                                        {
                                          v69 = n0x5A_17 - 0x57;
                                        }
                                        v70 = v67 | (v69 << 0x10);
                                        n0x5A_18 = a2[0x1B];
                                        if ( (char)n0x5A_18 <= 0x7A )
                                        {
                                          if ( (char)n0x5A_18 < 0x61 )
                                          {
                                            if ( (char)n0x5A_18 > 0x5A )
                                              goto LABEL_263;
                                            if ( (char)n0x5A_18 < 0x41 )
                                            {
                                              if ( (unsigned __int8)(n0x5A_18 - 0x30) > 9u )
                                                goto LABEL_263;
                                              v72 = n0x5A_18 - 0x30;
                                            }
                                            else
                                            {
                                              v72 = n0x5A_18 - 0x37;
                                            }
                                          }
                                          else
                                          {
                                            v72 = n0x5A_18 - 0x57;
                                          }
                                          v73 = v70 | (v72 << 0x1C);
                                          n0x5A_19 = a2[0x1C];
                                          if ( (char)n0x5A_19 <= 0x7A )
                                          {
                                            if ( (char)n0x5A_19 < 0x61 )
                                            {
                                              if ( (char)n0x5A_19 > 0x5A )
                                                goto LABEL_263;
                                              if ( (char)n0x5A_19 < 0x41 )
                                              {
                                                if ( (unsigned __int8)(n0x5A_19 - 0x30) > 9u )
                                                  goto LABEL_263;
                                                v75 = n0x5A_19 - 0x30;
                                              }
                                              else
                                              {
                                                v75 = n0x5A_19 - 0x37;
                                              }
                                            }
                                            else
                                            {
                                              v75 = n0x5A_19 - 0x57;
                                            }
                                            v76 = v73 | (v75 << 0x18);
                                            n0x5A_20 = a2[0x1D];
                                            if ( (char)n0x5A_20 <= 0x7A )
                                            {
                                              if ( (char)n0x5A_20 < 0x61 )
                                              {
                                                if ( (char)n0x5A_20 > 0x5A )
                                                  goto LABEL_263;
                                                if ( (char)n0x5A_20 < 0x41 )
                                                {
                                                  if ( (unsigned __int8)(n0x5A_20 - 0x30) > 9u )
                                                    goto LABEL_263;
                                                  v78 = n0x5A_20 - 0x30;
                                                }
                                                else
                                                {
                                                  v78 = n0x5A_20 - 0x37;
                                                }
                                              }
                                              else
                                              {
                                                v78 = n0x5A_20 - 0x57;
                                              }
                                              v79 = v76 | (v78 << 0x24);
                                              n0x5A_21 = a2[0x1E];
                                              if ( (char)n0x5A_21 <= 0x7A )
                                              {
                                                if ( (char)n0x5A_21 < 0x61 )
                                                {
                                                  if ( (char)n0x5A_21 > 0x5A )
                                                    goto LABEL_263;
                                                  if ( (char)n0x5A_21 < 0x41 )
                                                  {
                                                    if ( (unsigned __int8)(n0x5A_21 - 0x30) > 9u )
                                                      goto LABEL_263;
                                                    v81 = n0x5A_21 - 0x30;
                                                  }
                                                  else
                                                  {
                                                    v81 = n0x5A_21 - 0x37;
                                                  }
                                                }
                                                else
                                                {
                                                  v81 = n0x5A_21 - 0x57;
                                                }
                                                v82 = v79 | (v81 << 0x20);
                                                n0x5A_22 = a2[0x1F];
                                                if ( (char)n0x5A_22 <= 0x7A )
                                                {
                                                  if ( (char)n0x5A_22 < 0x61 )
                                                  {
                                                    if ( (char)n0x5A_22 > 0x5A )
                                                      goto LABEL_263;
                                                    if ( (char)n0x5A_22 < 0x41 )
                                                    {
                                                      if ( (unsigned __int8)(n0x5A_22 - 0x30) > 9u )
                                                        goto LABEL_263;
                                                      v84 = n0x5A_22 - 0x30;
                                                    }
                                                    else
                                                    {
                                                      v84 = n0x5A_22 - 0x37;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v84 = n0x5A_22 - 0x57;
                                                  }
                                                  v85 = v82 | (v84 << 0x2C);
                                                  n0x5A_23 = a2[0x20];
                                                  if ( (char)n0x5A_23 <= 0x7A )
                                                  {
                                                    if ( (char)n0x5A_23 < 0x61 )
                                                    {
                                                      if ( (char)n0x5A_23 > 0x5A )
                                                        goto LABEL_263;
                                                      if ( (char)n0x5A_23 < 0x41 )
                                                      {
                                                        if ( (unsigned __int8)(n0x5A_23 - 0x30) > 9u )
                                                          goto LABEL_263;
                                                        v87 = n0x5A_23 - 0x30;
                                                      }
                                                      else
                                                      {
                                                        v87 = n0x5A_23 - 0x37;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v87 = n0x5A_23 - 0x57;
                                                    }
                                                    v88 = v85 | (v87 << 0x28);
                                                    n0x5A_24 = a2[0x21];
                                                    if ( (char)n0x5A_24 <= 0x7A )
                                                    {
                                                      if ( (char)n0x5A_24 < 0x61 )
                                                      {
                                                        if ( (char)n0x5A_24 > 0x5A )
                                                          goto LABEL_263;
                                                        if ( (char)n0x5A_24 < 0x41 )
                                                        {
                                                          if ( (unsigned __int8)(n0x5A_24 - 0x30) > 9u )
                                                            goto LABEL_263;
                                                          v90 = n0x5A_24 - 0x30;
                                                        }
                                                        else
                                                        {
                                                          v90 = n0x5A_24 - 0x37;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v90 = n0x5A_24 - 0x57;
                                                      }
                                                      n0x5A_25 = a2[0x22];
                                                      v92 = (v90 << 0x34) | v88;
                                                      if ( (char)n0x5A_25 <= 0x7A )
                                                      {
                                                        if ( (char)n0x5A_25 < 0x61 )
                                                        {
                                                          if ( (char)n0x5A_25 > 0x5A )
                                                            goto LABEL_263;
                                                          if ( (char)n0x5A_25 < 0x41 )
                                                          {
                                                            if ( (unsigned __int8)(n0x5A_25 - 0x30) > 9u )
                                                              goto LABEL_263;
                                                            v93 = n0x5A_25 - 0x30;
                                                          }
                                                          else
                                                          {
                                                            v93 = n0x5A_25 - 0x37;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          v93 = n0x5A_25 - 0x57;
                                                        }
                                                        n0x5A_26 = a2[0x23];
                                                        v95 = (v93 << 0x30) | v92;
                                                        if ( (char)n0x5A_26 <= 0x7A )
                                                        {
                                                          if ( (char)n0x5A_26 < 0x61 )
                                                          {
                                                            if ( (char)n0x5A_26 > 0x5A )
                                                              goto LABEL_263;
                                                            if ( (char)n0x5A_26 < 0x41 )
                                                            {
                                                              if ( (unsigned __int8)(n0x5A_26 - 0x30) > 9u )
                                                                goto LABEL_263;
                                                              v96 = a2[0x23];
                                                            }
                                                            else
                                                            {
                                                              v96 = n0x5A_26 - 7;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            v96 = n0x5A_26 - 7;
                                                          }
                                                          n0x61 = a2[0x24];
                                                          v98 = (v96 << 0x3C) | v95;
                                                          if ( (char)n0x61 <= 0x7A )
                                                          {
                                                            if ( (char)n0x61 >= 0x61 )
                                                            {
                                                              v99 = n0x61 - 0x57;
                                                              goto LABEL_262;
                                                            }
                                                            if ( (char)n0x61 <= 0x5A )
                                                            {
                                                              if ( (char)n0x61 >= 0x41 )
                                                              {
                                                                v99 = n0x61 - 0x37;
                                                                goto LABEL_262;
                                                              }
                                                              if ( (unsigned __int8)(n0x61 - 0x30) <= 9u )
                                                              {
                                                                v99 = n0x61 - 0x30;
LABEL_262:
                                                                v100 = (v99 << 0x38) | v98;
                                                                if ( a2[0x25] != 0x7D )
                                                                  goto LABEL_263;
                                                                goto LABEL_524;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_263:
    *a1 = 0;
    a1[1] = 0;
    return a1;
  }
  if ( (char)n0x7B > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7B < 0x61 )
  {
    if ( (char)n0x7B > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7B < 0x41 )
    {
      if ( (unsigned __int8)(n0x7B - 0x30) > 9u )
        goto LABEL_263;
      v102 = *a2;
    }
    else
    {
      v102 = n0x7B - 7;
    }
  }
  else
  {
    v102 = n0x7B - 7;
  }
  n0x7A_4 = a2[1];
  v104 = v102 << 0x3C;
  if ( (char)n0x7A_4 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_4 < 0x61 )
  {
    if ( (char)n0x7A_4 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_4 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_4 - 0x30) > 9u )
        goto LABEL_263;
      v105 = n0x7A_4 - 0x30;
    }
    else
    {
      v105 = n0x7A_4 - 0x37;
    }
  }
  else
  {
    v105 = n0x7A_4 - 0x57;
  }
  n0x7A_5 = a2[2];
  v107 = (v105 << 0x38) | v104;
  if ( (char)n0x7A_5 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_5 < 0x61 )
  {
    if ( (char)n0x7A_5 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_5 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_5 - 0x30) > 9u )
        goto LABEL_263;
      v108 = n0x7A_5 - 0x30;
    }
    else
    {
      v108 = n0x7A_5 - 0x37;
    }
  }
  else
  {
    v108 = n0x7A_5 - 0x57;
  }
  n0x7A_6 = a2[3];
  v110 = (v108 << 0x34) | v107;
  if ( (char)n0x7A_6 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_6 < 0x61 )
  {
    if ( (char)n0x7A_6 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_6 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_6 - 0x30) > 9u )
        goto LABEL_263;
      v111 = n0x7A_6 - 0x30;
    }
    else
    {
      v111 = n0x7A_6 - 0x37;
    }
  }
  else
  {
    v111 = n0x7A_6 - 0x57;
  }
  n0x7A_7 = a2[4];
  v113 = (v111 << 0x30) | v110;
  if ( (char)n0x7A_7 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_7 < 0x61 )
  {
    if ( (char)n0x7A_7 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_7 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_7 - 0x30) > 9u )
        goto LABEL_263;
      v114 = n0x7A_7 - 0x30;
    }
    else
    {
      v114 = n0x7A_7 - 0x37;
    }
  }
  else
  {
    v114 = n0x7A_7 - 0x57;
  }
  n0x7A_8 = a2[5];
  v116 = (v114 << 0x2C) | v113;
  if ( (char)n0x7A_8 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_8 < 0x61 )
  {
    if ( (char)n0x7A_8 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_8 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_8 - 0x30) > 9u )
        goto LABEL_263;
      v117 = n0x7A_8 - 0x30;
    }
    else
    {
      v117 = n0x7A_8 - 0x37;
    }
  }
  else
  {
    v117 = n0x7A_8 - 0x57;
  }
  n0x7A_9 = a2[6];
  v119 = (v117 << 0x28) | v116;
  if ( (char)n0x7A_9 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_9 < 0x61 )
  {
    if ( (char)n0x7A_9 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_9 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_9 - 0x30) > 9u )
        goto LABEL_263;
      v120 = n0x7A_9 - 0x30;
    }
    else
    {
      v120 = n0x7A_9 - 0x37;
    }
  }
  else
  {
    v120 = n0x7A_9 - 0x57;
  }
  n0x7A_10 = a2[7];
  v122 = (v120 << 0x24) | v119;
  if ( (char)n0x7A_10 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_10 < 0x61 )
  {
    if ( (char)n0x7A_10 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_10 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_10 - 0x30) > 9u )
        goto LABEL_263;
      v123 = n0x7A_10 - 0x30;
    }
    else
    {
      v123 = n0x7A_10 - 0x37;
    }
  }
  else
  {
    v123 = n0x7A_10 - 0x57;
  }
  v124 = (v123 << 0x20) | v122;
  if ( a2[8] != 0x2D )
    goto LABEL_263;
  n0x7A_11 = a2[9];
  if ( (char)n0x7A_11 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_11 < 0x61 )
  {
    if ( (char)n0x7A_11 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_11 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_11 - 0x30) > 9u )
        goto LABEL_263;
      v126 = n0x7A_11 - 0x30;
    }
    else
    {
      v126 = n0x7A_11 - 0x37;
    }
  }
  else
  {
    v126 = n0x7A_11 - 0x57;
  }
  n0x7A_12 = a2[0xA];
  v128 = (v126 << 0x1C) | v124;
  if ( (char)n0x7A_12 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_12 < 0x61 )
  {
    if ( (char)n0x7A_12 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_12 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_12 - 0x30) > 9u )
        goto LABEL_263;
      v129 = n0x7A_12 - 0x30;
    }
    else
    {
      v129 = n0x7A_12 - 0x37;
    }
  }
  else
  {
    v129 = n0x7A_12 - 0x57;
  }
  n0x7A_13 = a2[0xB];
  v131 = (v129 << 0x18) | v128;
  if ( (char)n0x7A_13 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_13 < 0x61 )
  {
    if ( (char)n0x7A_13 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_13 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_13 - 0x30) > 9u )
        goto LABEL_263;
      v132 = n0x7A_13 - 0x30;
    }
    else
    {
      v132 = n0x7A_13 - 0x37;
    }
  }
  else
  {
    v132 = n0x7A_13 - 0x57;
  }
  n0x7A_14 = a2[0xC];
  v134 = (v132 << 0x14) | v131;
  if ( (char)n0x7A_14 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_14 < 0x61 )
  {
    if ( (char)n0x7A_14 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_14 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_14 - 0x30) > 9u )
        goto LABEL_263;
      v135 = n0x7A_14 - 0x30;
    }
    else
    {
      v135 = n0x7A_14 - 0x37;
    }
  }
  else
  {
    v135 = n0x7A_14 - 0x57;
  }
  v136 = (v135 << 0x10) | v134;
  if ( a2[0xD] != 0x2D )
    goto LABEL_263;
  n0x7A_15 = a2[0xE];
  if ( (char)n0x7A_15 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_15 < 0x61 )
  {
    if ( (char)n0x7A_15 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_15 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_15 - 0x30) > 9u )
        goto LABEL_263;
      v138 = n0x7A_15 - 0x30;
    }
    else
    {
      v138 = n0x7A_15 - 0x37;
    }
  }
  else
  {
    v138 = n0x7A_15 - 0x57;
  }
  n0x7A_16 = a2[0xF];
  v140 = (v138 << 0xC) | v136;
  if ( (char)n0x7A_16 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_16 < 0x61 )
  {
    if ( (char)n0x7A_16 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_16 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_16 - 0x30) > 9u )
        goto LABEL_263;
      v141 = n0x7A_16 - 0x30;
    }
    else
    {
      v141 = n0x7A_16 - 0x37;
    }
  }
  else
  {
    v141 = n0x7A_16 - 0x57;
  }
  n0x7A_17 = a2[0x10];
  v143 = (v141 << 8) | v140;
  if ( (char)n0x7A_17 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_17 < 0x61 )
  {
    if ( (char)n0x7A_17 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_17 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_17 - 0x30) > 9u )
        goto LABEL_263;
      v144 = n0x7A_17 - 0x30;
    }
    else
    {
      v144 = n0x7A_17 - 0x37;
    }
  }
  else
  {
    v144 = n0x7A_17 - 0x57;
  }
  n0x7A_18 = a2[0x11];
  v146 = (0x10 * v144) | v143;
  if ( (char)n0x7A_18 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_18 < 0x61 )
  {
    if ( (char)n0x7A_18 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_18 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_18 - 0x30) > 9u )
        goto LABEL_263;
      v147 = n0x7A_18 - 0x30;
    }
    else
    {
      v147 = n0x7A_18 - 0x37;
    }
  }
  else
  {
    v147 = n0x7A_18 - 0x57;
  }
  v52 = v147 | v146;
  if ( a2[0x12] != 0x2D )
    goto LABEL_263;
  n0x7A_19 = a2[0x13];
  if ( (char)n0x7A_19 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_19 < 0x61 )
  {
    if ( (char)n0x7A_19 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_19 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_19 - 0x30) > 9u )
        goto LABEL_263;
      v149 = a2[0x13];
    }
    else
    {
      v149 = n0x7A_19 - 7;
    }
  }
  else
  {
    v149 = n0x7A_19 - 7;
  }
  n0x7A_20 = a2[0x14];
  v151 = v149 << 0x3C;
  if ( (char)n0x7A_20 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_20 < 0x61 )
  {
    if ( (char)n0x7A_20 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_20 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_20 - 0x30) > 9u )
        goto LABEL_263;
      v152 = n0x7A_20 - 0x30;
    }
    else
    {
      v152 = n0x7A_20 - 0x37;
    }
  }
  else
  {
    v152 = n0x7A_20 - 0x57;
  }
  n0x7A_21 = a2[0x15];
  v154 = (v152 << 0x38) | v151;
  if ( (char)n0x7A_21 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_21 < 0x61 )
  {
    if ( (char)n0x7A_21 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_21 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_21 - 0x30) > 9u )
        goto LABEL_263;
      v155 = n0x7A_21 - 0x30;
    }
    else
    {
      v155 = n0x7A_21 - 0x37;
    }
  }
  else
  {
    v155 = n0x7A_21 - 0x57;
  }
  n0x7A_22 = a2[0x16];
  v157 = (v155 << 0x34) | v154;
  if ( (char)n0x7A_22 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_22 < 0x61 )
  {
    if ( (char)n0x7A_22 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_22 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_22 - 0x30) > 9u )
        goto LABEL_263;
      v158 = n0x7A_22 - 0x30;
    }
    else
    {
      v158 = n0x7A_22 - 0x37;
    }
  }
  else
  {
    v158 = n0x7A_22 - 0x57;
  }
  v159 = (v158 << 0x30) | v157;
  if ( a2[0x17] != 0x2D )
    goto LABEL_263;
  n0x7A_23 = a2[0x18];
  if ( (char)n0x7A_23 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_23 < 0x61 )
  {
    if ( (char)n0x7A_23 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_23 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_23 - 0x30) > 9u )
        goto LABEL_263;
      v161 = n0x7A_23 - 0x30;
    }
    else
    {
      v161 = n0x7A_23 - 0x37;
    }
  }
  else
  {
    v161 = n0x7A_23 - 0x57;
  }
  n0x7A_24 = a2[0x19];
  v163 = (v161 << 0x2C) | v159;
  if ( (char)n0x7A_24 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_24 < 0x61 )
  {
    if ( (char)n0x7A_24 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_24 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_24 - 0x30) > 9u )
        goto LABEL_263;
      v164 = n0x7A_24 - 0x30;
    }
    else
    {
      v164 = n0x7A_24 - 0x37;
    }
  }
  else
  {
    v164 = n0x7A_24 - 0x57;
  }
  n0x7A_25 = a2[0x1A];
  v166 = (v164 << 0x28) | v163;
  if ( (char)n0x7A_25 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_25 < 0x61 )
  {
    if ( (char)n0x7A_25 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_25 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_25 - 0x30) > 9u )
        goto LABEL_263;
      v167 = n0x7A_25 - 0x30;
    }
    else
    {
      v167 = n0x7A_25 - 0x37;
    }
  }
  else
  {
    v167 = n0x7A_25 - 0x57;
  }
  n0x7A_26 = a2[0x1B];
  v169 = (v167 << 0x24) | v166;
  if ( (char)n0x7A_26 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_26 < 0x61 )
  {
    if ( (char)n0x7A_26 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_26 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_26 - 0x30) > 9u )
        goto LABEL_263;
      v170 = n0x7A_26 - 0x30;
    }
    else
    {
      v170 = n0x7A_26 - 0x37;
    }
  }
  else
  {
    v170 = n0x7A_26 - 0x57;
  }
  n0x7A_27 = a2[0x1C];
  v172 = (v170 << 0x20) | v169;
  if ( (char)n0x7A_27 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_27 < 0x61 )
  {
    if ( (char)n0x7A_27 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_27 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_27 - 0x30) > 9u )
        goto LABEL_263;
      v173 = n0x7A_27 - 0x30;
    }
    else
    {
      v173 = n0x7A_27 - 0x37;
    }
  }
  else
  {
    v173 = n0x7A_27 - 0x57;
  }
  n0x7A_28 = a2[0x1D];
  v175 = (v173 << 0x1C) | v172;
  if ( (char)n0x7A_28 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_28 < 0x61 )
  {
    if ( (char)n0x7A_28 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_28 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_28 - 0x30) > 9u )
        goto LABEL_263;
      v176 = n0x7A_28 - 0x30;
    }
    else
    {
      v176 = n0x7A_28 - 0x37;
    }
  }
  else
  {
    v176 = n0x7A_28 - 0x57;
  }
  n0x7A_29 = a2[0x1E];
  v178 = (v176 << 0x18) | v175;
  if ( (char)n0x7A_29 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_29 < 0x61 )
  {
    if ( (char)n0x7A_29 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_29 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_29 - 0x30) > 9u )
        goto LABEL_263;
      v179 = n0x7A_29 - 0x30;
    }
    else
    {
      v179 = n0x7A_29 - 0x37;
    }
  }
  else
  {
    v179 = n0x7A_29 - 0x57;
  }
  n0x7A_30 = a2[0x1F];
  v181 = (v179 << 0x14) | v178;
  if ( (char)n0x7A_30 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_30 < 0x61 )
  {
    if ( (char)n0x7A_30 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_30 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_30 - 0x30) > 9u )
        goto LABEL_263;
      v182 = n0x7A_30 - 0x30;
    }
    else
    {
      v182 = n0x7A_30 - 0x37;
    }
  }
  else
  {
    v182 = n0x7A_30 - 0x57;
  }
  n0x7A_31 = a2[0x20];
  v184 = (v182 << 0x10) | v181;
  if ( (char)n0x7A_31 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_31 < 0x61 )
  {
    if ( (char)n0x7A_31 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_31 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_31 - 0x30) > 9u )
        goto LABEL_263;
      v185 = n0x7A_31 - 0x30;
    }
    else
    {
      v185 = n0x7A_31 - 0x37;
    }
  }
  else
  {
    v185 = n0x7A_31 - 0x57;
  }
  n0x7A_32 = a2[0x21];
  v187 = (v185 << 0xC) | v184;
  if ( (char)n0x7A_32 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_32 < 0x61 )
  {
    if ( (char)n0x7A_32 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_32 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_32 - 0x30) > 9u )
        goto LABEL_263;
      v188 = n0x7A_32 - 0x30;
    }
    else
    {
      v188 = n0x7A_32 - 0x37;
    }
  }
  else
  {
    v188 = n0x7A_32 - 0x57;
  }
  n0x7A_33 = a2[0x22];
  v190 = (v188 << 8) | v187;
  if ( (char)n0x7A_33 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_33 < 0x61 )
  {
    if ( (char)n0x7A_33 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_33 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_33 - 0x30) > 9u )
        goto LABEL_263;
      v191 = n0x7A_33 - 0x30;
    }
    else
    {
      v191 = n0x7A_33 - 0x37;
    }
  }
  else
  {
    v191 = n0x7A_33 - 0x57;
  }
  n0x7A_34 = a2[0x23];
  v193 = (0x10 * v191) | v190;
  if ( (char)n0x7A_34 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_34 >= 0x61 )
  {
    *a1 = v52;
    result = a1;
    a1[1] = v193 | (n0x7A_34 - 0x57);
    return result;
  }
  if ( (char)n0x7A_34 > 0x5A )
    goto LABEL_263;
  if ( (char)n0x7A_34 >= 0x41 )
  {
    *a1 = v52;
    result = a1;
    a1[1] = v193 | (n0x7A_34 - 0x37);
    return result;
  }
  if ( (unsigned __int8)(n0x7A_34 - 0x30) > 9u )
    goto LABEL_263;
  v100 = v193 | (n0x7A_34 - 0x30);
LABEL_524:
  *a1 = v52;
  result = a1;
  a1[1] = v100;
  return result;
}

// --- End Function: sub_1402BC380 (0x1402BC380) ---

// --- Function: LogTraceConditional (0x1402C1000) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
        qword_149B4FCB0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C1000) ---

// --- Function: sub_1402C4680 (0x1402C4680) ---
__int64 __fastcall sub_1402C4680(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0x24;
  sub_1402C61F0(
    a1,
    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    *(unsigned __int8 *)(a2 + 7),
    *(unsigned __int8 *)(a2 + 6),
    *(unsigned __int8 *)(a2 + 5),
    *(unsigned __int8 *)(a2 + 4),
    HIBYTE(*(_DWORD *)a2),
    (unsigned __int8)BYTE2(*(_DWORD *)a2),
    BYTE1(*(_DWORD *)a2),
    (unsigned __int8)*(_DWORD *)a2,
    *(unsigned __int8 *)(a2 + 0xF),
    *(unsigned __int8 *)(a2 + 0xE),
    *(unsigned __int8 *)(a2 + 0xD),
    *(unsigned __int8 *)(a2 + 0xC),
    HIBYTE(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)BYTE2(*(_DWORD *)(a2 + 8)),
    BYTE1(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)*(_DWORD *)(a2 + 8));
  return a1;
}

// --- End Function: sub_1402C4680 (0x1402C4680) ---

// --- Function: sub_1402C61F0 (0x1402C61F0) ---
__int64 sub_1402C61F0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n36; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n36 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n36;
  while ( Buffer[n36] );
  sub_1402DE5F0(a1, Buffer, n36);
  return a1;
}

// --- End Function: sub_1402C61F0 (0x1402C61F0) ---

// --- Function: ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@2@@Z (0x1402DE6E0) ---
unsigned __int64 __fastcall std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
        unsigned __int64 **a1,
        unsigned __int64 a2,
        unsigned __int64 buf)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *_Last; // rcx
  unsigned __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int64 *v8; // rdi
  unsigned __int64 *v9; // rcx
  signed __int64 v10; // rax
  unsigned __int64 result; // rax
  unsigned __int64 buf_1; // [rsp+40h] [rbp+18h] BYREF

  buf_1 = buf;
  _Last = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)a1[1];
  if ( (_Last
      - (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)*a1) >> 3 >= a2 )
  {
    std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>>>(
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *const)*a1,
      _Last,
      (const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)&buf_1);
    return result;
  }
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_20;
  v6 = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( v6 )
      v8 = (unsigned __int64 *)allocWithProfilerInfo_w(8 * a2);
    else
      v8 = 0;
    goto LABEL_10;
  }
  if ( v6 + 0x27 < v6 )
LABEL_20:
    sub_1402E1170();
  v7 = allocWithProfilerInfo_w(v6 + 0x27);
  if ( !v7 )
    goto LABEL_18;
  v8 = (unsigned __int64 *)((v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v8[0xFFFFFFFF] = v7;
LABEL_10:
  v9 = *a1;
  v10 = a1[2] - *a1;
  if ( !v10 )
    goto LABEL_15;
  if ( (unsigned __int64)(8 * v10) >= 0x1000 )
  {
    if ( (unsigned __int64)v9 - v9[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v9 = (unsigned __int64 *)v9[0xFFFFFFFF];
      goto LABEL_14;
    }
LABEL_18:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_14:
  sub_1402A3D30(v9);
LABEL_15:
  result = (unsigned __int64)&v8[v6 / 8];
  *a1 = v8;
  a1[1] = &v8[v6 / 8];
  a1[2] = &v8[v6 / 8];
  if ( v8 != &v8[v6 / 8] )
  {
    do
      *v8++ = buf;
    while ( v8 != (unsigned __int64 *)result );
  }
  return result;
}

// --- End Function: ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@2@@Z (0x1402DE6E0) ---

// --- Function: sub_1402DECA0 (0x1402DECA0) ---
void __fastcall sub_1402DECA0(unsigned __int64 *a1, const void *a2, size_t Size)
{
  unsigned __int64 *v5; // rsi
  size_t Size_1; // r14
  unsigned __int64 v8; // rbp
  unsigned __int64 n8; // rdx
  unsigned __int64 v10; // rax

  if ( Size )
  {
    v5 = (unsigned __int64 *)a1[2];
    Size_1 = *a1;
    v8 = *a1 + Size;
    if ( v8 <= a1[1] )
    {
      memcpy((char *)v5 + Size_1, a2, Size);
      *a1 += Size;
      *(_BYTE *)(*a1 + a1[2]) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= v8 )
        n8 = *a1 + Size;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        sub_1402A3B50((__int64 *)a1, n8);
        memcpy((void *)a1[2], v5, Size_1);
        memcpy((void *)(Size_1 + a1[2]), a2, Size);
        v10 = a1[2];
        *a1 = v8;
        *(_BYTE *)(Size_1 + Size + v10) = 0;
      }
      if ( v5 != a1 + 3 )
      {
        qword_149B3AB68 += -1LL - a1[1];
        sub_147605980(v5);
      }
    }
  }
}

// --- End Function: sub_1402DECA0 (0x1402DECA0) ---

// --- Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
        __int64 **a1,
        __int64 a2,
        __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 0x18) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 0x18LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 0x18) )
      {
        v13 = *(_QWORD **)(v9 + 0x10);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 0x10) = *v13;
          if ( !*(_BYTE *)(*v13 + 0x19LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 0x10LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 0x19) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v12 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 0x18) )
      {
        v19 = *(_QWORD *)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = *(_QWORD *)(v19 + 0x10);
          v20 = *(_QWORD *)(v19 + 0x10);
          if ( !*(_BYTE *)(v20 + 0x19) )
            *(_QWORD *)(v20 + 8) = v9;
          *(_QWORD *)(v19 + 8) = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(__int64 **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          *(_QWORD *)(v19 + 0x10) = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 0x19LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v11 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 0x18) = 1;
  return a3;
}

// --- End Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_7 (0x1402E11B0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402E11B0) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: sub_1402E1FE0 (0x1402E1FE0) ---
__int64 __fastcall sub_1402E1FE0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
      break;
    v5 = v4 + 0x20;
    if ( (unsigned __int8)(v4 - 0x41) > 0x19u )
      v5 = v4;
    v6 = sub_1402D2830(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402CA4C0(0x4C11DB7, 1, (v6 << 0x19) ^ (unsigned int)((unsigned __int64)(v6 << 0x18) >> 0x1F) & 0x4C11DB7);
    v8 = sub_1402D2830(v7 >> 1, 0x20, v7 << 0x1F, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402E1FE0 (0x1402E1FE0) ---

// --- Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---
std::array<int,2> *__fastcall std::allocator<std::array<int,2>>::allocate(
        std::allocator<std::array<int,2> > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  std::array<int,2> *result; // rax

  if ( _Count > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  allocSize = 8 * _Count;
  if ( 8 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (std::array<int,2> *)allocWithProfilerInfo_w(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E1170();
  v3 = allocWithProfilerInfo_w(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (std::array<int,2> *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---

// --- Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---
void __fastcall std::vector<vraudio::AudioBuffer const *>::_Change_array(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  _QWORD *v6; // rcx

  v6 = *(_QWORD **)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)*(v6 - 1);
    }
    sub_1402A3D30(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149B3B1F0 )
    result = qword_149B3B1F0(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149B3B208 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_1403090E0 (0x1403090E0) ---
_QWORD *__fastcall sub_1403090E0(_QWORD *a1, _QWORD *a2, const char **a3, unsigned __int64 a4)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // r12
  unsigned __int64 v6; // rdi
  __int64 v14; // rsi
  __int64 v15; // rsi
  const char **v19; // [rsp+90h] [rbp+18h]

  v19 = a3;
  v4 = a1[3];
  v5 = 0;
  v6 = v4 & (a4 >> 7);
  _XMM7 = a4 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v6 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
      break;
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = *a1 + a1[3];
      return a2;
    }
    v5 += 0x10LL;
    v6 = v4 & (v5 + v6);
    if ( v5 > a1[3] )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v14, _EBX);
    v15 = v4 & (v6 + v14);
    if ( !_stricmp(*(const char **)(0x20 * v15 + a1[1]), *a3) )
      break;
    a3 = v19;
    _EBX &= _EBX - 1;
    if ( !_EBX )
      goto LABEL_5;
  }
  *a2 = v15 + *a1;
  a2[1] = 0x20 * v15 + a1[1];
  return a2;
}

// --- End Function: sub_1403090E0 (0x1403090E0) ---

// --- Function: sub_1403093C0 (0x1403093C0) ---
unsigned __int64 __fastcall sub_1403093C0(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        int *a4,
        unsigned __int64 n4,
        unsigned __int8 a6)
{
  __int64 v6; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rax
  _DWORD *v12; // rdx
  _DWORD *v13; // rdx
  unsigned __int64 n4_1; // rdx
  __int64 n8; // r8
  __int64 v16; // rdi
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v19; // [rsp+48h] [rbp+10h] BYREF

  v6 = *a4;
  if ( (_DWORD)v6 )
  {
    v19 = 4 * v6;
    v10 = sub_140332BC0(a1, 0, &v19, n4, a6);
    v11 = v19 >> 2;
    *a4 = v19 >> 2;
  }
  else
  {
    v10 = 0;
    LODWORD(v11) = 0;
  }
  if ( a2 )
  {
    if ( v10 )
    {
      if ( a3 < (int)v11 )
        LODWORD(v11) = a3;
      if ( a2 != v10 )
      {
        v11 = (int)v11;
        if ( a2 > v10 || a2 + 4LL * (int)v11 <= v10 )
        {
          if ( (_DWORD)v11 )
          {
            v13 = (_DWORD *)v10;
            do
            {
              *v13 = *(_DWORD *)((char *)v13 + a2 - v10);
              ++v13;
              --v11;
            }
            while ( v11 );
          }
        }
        else if ( (_DWORD)v11 )
        {
          v12 = (_DWORD *)(v10 + 4 * ((int)v11 - 1LL));
          do
          {
            *v12 = *(_DWORD *)((char *)v12 + a2 - v10);
            v12 += 0xFFFFFFFF;
            --v11;
          }
          while ( v11 );
        }
      }
    }
    n4_1 = 4;
    v19 = 0;
    n8 = 8;
    if ( n4 > 4 )
      n4_1 = n4;
    v16 = a2 - ((n4_1 + 3) & ~(n4_1 - 1));
    n8_1 = 8;
    if ( n4_1 > 8 )
      n8_1 = n4_1;
    if ( v16 )
    {
      if ( n8_1 > 8 )
        n8 = n8_1;
      (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64, _QWORD))(v16 - 8))(
        v16 - ((n8 + 7) & ~(n8 - 1)),
        &v19,
        n8,
        0);
    }
  }
  return v10;
}

// --- End Function: sub_1403093C0 (0x1403093C0) ---

// --- Function: sub_140329A30 (0x140329A30) ---
const char *sub_140329A30()
{
  return "<unknown>";
}

// --- End Function: sub_140329A30 (0x140329A30) ---

// --- Function: vector_dword_set_size (0x1403332C0) ---
// Sets the size of a dynamic array (vector) of DWORDs, reallocating the underlying
// buffer if necessary.  This function manages a vector-like structure where
// metadata is stored 4 bytes before the data pointer. The metadata DWORD contains
// the current size in the lower 31 bits and a flag in the high bit. If the high
// bit flag is set, the buffer's capacity (in elements) is stored in a DWORD
// immediately following the last used element.  @param ppVectorData Pointer to the
// variable holding the data pointer for the dynamic array. @param
// newSizeInElements The desired new size of the array in elements. @param
// resizeIfGrowing Flag controlling resize behavior:                        - If 1
// (true): Resizes only if the new size `newSizeInElements` is greater than the
// current capacity.                        - If 0 (false): Resizes if the new size
// `newSizeInElements` is different from the current capacity. @return Returns the
// minimum required size in bytes for the new data and its metadata (4 *
// newSizeInElements + 4). Returns a default pointer (`&unk_149808B07`) via
// `ppVectorData` on allocation failure.
unsigned __int64 __fastcall vector_dword_set_size(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // r10
  int v6; // ecx
  int v7; // eax
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rdx
  int v10; // eax
  unsigned __int64 v11; // rax
  unsigned __int64 result; // rax
  __int64 v13; // rdx
  int v14; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v6 = *(_DWORD *)(*a1 - 4);
  v7 = 4 * v6;
  if ( v6 >= 0 )
    v8 = (unsigned __int64)v7 >> 2;
  else
    LODWORD(v8) = *(_DWORD *)(v7 + v3);
  v9 = 0;
  v10 = 0;
  if ( a3 )
    LOBYTE(v10) = a2 > (int)v8;
  else
    LOBYTE(v10) = a2 != (_DWORD)v8;
  if ( v10 )
  {
    v14 = a2;
    if ( v6 )
      v9 = v3;
    v11 = sub_1403093C0((__int64)a1, v9, v6 & 0x7FFFFFFF, &v14, 4u, a3);
    *a1 = v11;
    v3 = v11;
    if ( !v11 )
    {
      result = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
      *a1 = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
      return result;
    }
    LODWORD(v8) = v14;
  }
  v13 = 4 * a2;
  *(_DWORD *)(v3 - 4) = a2;
  result = v13 + 4;
  if ( 4LL * (int)v8 >= (unsigned __int64)(v13 + 4) )
  {
    *(_DWORD *)(v3 - 4) = a2 | 0x80000000;
    *(_DWORD *)(v13 + v3) = v8;
  }
  return result;
}

// --- End Function: vector_dword_set_size (0x1403332C0) ---

// --- Function: sub_1403360E0 (0x1403360E0) ---
__int64 __fastcall sub_1403360E0(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *p_sub_1403E1870)(unsigned int, __int64, __int64); // rax

  sub_1403E30D0();
  if ( (dword_149B3D560 & 0x100000) != 0 )
  {
    p_sub_1403E1870 = (__int64 (__fastcall *)(unsigned int, __int64, __int64))sub_1403E15D0;
  }
  else
  {
    sub_1403E19B0();
    p_sub_1403E1870 = (__int64 (__fastcall *)(unsigned int, __int64, __int64))sub_1403E1870;
  }
  psub_1403360E0 = p_sub_1403E1870;
  return p_sub_1403E1870(a1, a2, a3);
}

// --- End Function: sub_1403360E0 (0x1403360E0) ---

// --- Function: sub_140336140 (0x140336140) ---
__int64 __fastcall sub_140336140(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *p_sub_1403E1790)(); // rax

  sub_1403E30D0();
  if ( (dword_149B3D560 & 0x100000) != 0 )
  {
    p_sub_1403E1790 = (__int64 (__fastcall *)())sub_1403E1630;
  }
  else
  {
    sub_1403E19B0();
    p_sub_1403E1790 = (__int64 (__fastcall *)())sub_1403E1790;
  }
  off_149924C30[0] = p_sub_1403E1790;
  return ((__int64 (__fastcall *)(_QWORD, __int64, __int64))p_sub_1403E1790)(a1, a2, a3);
}

// --- End Function: sub_140336140 (0x140336140) ---

// --- Function: sub_140336210 (0x140336210) ---
__int64 __fastcall sub_140336210(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  int C; // ecx

  sub_1403E1B10();
  for ( psub_140336210 = sub_1403E1800; a3; --a3 )
  {
    C = *a2++;
    a1 = unk_149B3DAA0[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_140336210 (0x140336210) ---

// --- Function: sub_140344170 (0x140344170) ---
char *__fastcall sub_140344170(__int64 a1, _DWORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _DWORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  char *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 0x10);
  if ( v2 == v4 )
  {
    v7 = 0x3FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*(_QWORD *)a1] >> 2;
    if ( v8 == 0x3FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = (__int64)&v4[-*(_QWORD *)a1] >> 2;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x3FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_DWORD *)sub_140391AB0(a1, 4 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = *(char **)(a1 + 8);
    v16 = *(char **)a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 4;
      Size = *(_QWORD *)(a1 + 8) - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *(_QWORD *)a1 )
      sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFFCuLL);
    *(_QWORD *)a1 = v13;
    result = v17;
    *(_QWORD *)(a1 + 8) = &v13[v11];
    *(_QWORD *)(a1 + 0x10) = &v13[v12];
  }
  else
  {
    *(_DWORD *)v2 = *a2;
    result = *(char **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result + 4;
  }
  return result;
}

// --- End Function: sub_140344170 (0x140344170) ---

// --- Function: sub_140344F60 (0x140344F60) ---
char *__fastcall sub_140344F60(__int64 a1, _BYTE *a2, _DWORD *a3)
{
  _BYTE *v3; // r9
  __int64 v4; // rsi
  __int64 v6; // rax
  __int64 v7; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // r8
  __int64 v13; // r15
  _DWORD *v14; // rdi
  void *v15; // rcx
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  char *v18; // rsi
  size_t Size; // r8
  char *result; // rax

  v3 = *(_BYTE **)a1;
  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 2;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  v7 = 0x3FFFFFFFFFFFFFFFLL;
  if ( v6 == 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v10 = (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v3) >> 2;
  v11 = v6 + 1;
  v12 = v10 >> 1;
  if ( v10 <= 0x3FFFFFFFFFFFFFFFLL - (v10 >> 1) )
  {
    v7 = v12 + v10;
    if ( v12 + v10 < v11 )
      v7 = v6 + 1;
  }
  v13 = v7;
  v14 = (_DWORD *)sub_140391AB0(a1, 4 * v7);
  v14[v4] = *a3;
  v15 = v14;
  v16 = *(_BYTE **)(a1 + 8);
  v17 = *(_BYTE **)a1;
  v18 = (char *)&v14[v4];
  if ( a2 == v16 )
  {
    Size = v16 - v17;
  }
  else
  {
    memmove(v14, v17, a2 - v17);
    v15 = v18 + 4;
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v15, v17, Size);
  if ( *(_QWORD *)a1 )
    sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFFCuLL);
  *(_QWORD *)a1 = v14;
  result = v18;
  *(_QWORD *)(a1 + 8) = &v14[v11];
  *(_QWORD *)(a1 + 0x10) = &v14[v13];
  return result;
}

// --- End Function: sub_140344F60 (0x140344F60) ---

// --- Function: sub_140348410 (0x140348410) ---
__int64 __fastcall sub_140348410(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  const void *v6; // rdx
  __int64 result; // rax

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 0x19) )
  {
    do
    {
      sub_140348410(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      result = sub_1403A3120(a2, v6, 0x30u);
    }
    while ( !*((_BYTE *)v3 + 0x19) );
  }
  return result;
}

// --- End Function: sub_140348410 (0x140348410) ---

// --- Function: sub_14034F880 (0x14034F880) ---
_QWORD *__fastcall sub_14034F880(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  __int64 v4; // rdi

  v3 = a1;
  if ( *a3 )
  {
    for ( ; a2; --a2 )
      *v3++ = *a3;
    return v3;
  }
  else
  {
    v4 = a2;
    memset(a1, 0, 8 * a2);
    return &v3[v4];
  }
}

// --- End Function: sub_14034F880 (0x14034F880) ---

// --- Function: sub_1403515F0 (0x1403515F0) ---
char __fastcall sub_1403515F0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v10; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n256; // [rsp+88h] [rbp-18h]
  __int64 n176; // [rsp+90h] [rbp-10h]
  __int64 n168; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  LODWORD(v10) = a6;
  n256 = 256;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[10] = -1;
  n176 = 176;
  n168 = 168;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 1u, a5, v10, a7, a8);
}

// --- End Function: sub_1403515F0 (0x1403515F0) ---

// --- Function: sub_14035B120 (0x14035B120) ---
_QWORD *__fastcall sub_14035B120(_QWORD *a1, _QWORD *a2)
{
  *a1 = (char *)&qword_149B3B33C + 4;
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_14035B120 (0x14035B120) ---

// --- Function: sub_14035B140 (0x14035B140) ---
_QWORD *__fastcall sub_14035B140(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149B3B33C + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035B140 (0x14035B140) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B360 (0x14035B360) ---
void **__fastcall sub_14035B360(void **a1, void *a2, size_t Size)
{
  _DWORD *v6; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( Size )
  {
    v6 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v6 + 2;
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B360 (0x14035B360) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_140361D60 (0x140361D60) ---
__int64 __fastcall sub_140361D60(__int64 a1, _BYTE *a2)
{
  size_t Size; // rbx
  void *v5; // rax

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( Size )
  {
    v5 = (void *)allocWithProfilerInfo_w(Size + 1);
    *(_QWORD *)a1 = v5;
    memcpy(v5, a2, Size);
    *(_BYTE *)(Size + *(_QWORD *)a1) = 0;
  }
  return a1;
}

// --- End Function: sub_140361D60 (0x140361D60) ---

// --- Function: sub_140361E00 (0x140361E00) ---
_QWORD *__fastcall sub_140361E00(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

// --- End Function: sub_140361E00 (0x140361E00) ---

// --- Function: sub_140362C80 (0x140362C80) ---
__int64 __fastcall sub_140362C80(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *a2;
  result = a1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

// --- End Function: sub_140362C80 (0x140362C80) ---

// --- Function: sub_140362C90 (0x140362C90) ---
__int64 __fastcall sub_140362C90(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  result = a1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

// --- End Function: sub_140362C90 (0x140362C90) ---

// --- Function: DataCore::InitializeDataCoreStructData (0x14036BF80) ---
// Initializes a 64-byte structure buffer with the provided data.  Structure
// Layout: - Offset 0x00 (QWORD): `field_0` - Offset 0x08 (QWORD): `field_8` -
// Offset 0x10 (QWORD): `field_16` - Offset 0x18 (QWORD): `field_24` - Offset 0x20
// (BYTE):  `field_32` - Offset 0x28 (QWORD): `field_40` - Offset 0x30 (QWORD): 0 -
// Offset 0x38 (QWORD): Masked address related to `unk_149808B07` (potentially type
// info or default array pointer).  @param pStructData Pointer to the 64-byte
// structure buffer to initialize. @param field_0 Value for offset 0x00. @param
// field_8 Value for offset 0x08. @param field_16 Value for offset 0x10. @param
// field_24 Value for offset 0x18. @param field_32 Value for offset 0x20. @param
// field_40 Value for offset 0x28. @return Returns the pointer to the initialized
// structure (`pStructData`).
__int64 __fastcall DataCore::InitializeDataCoreStructData(
        __int64 structDataBuffer,
        __int64 pDataParam2,
        __int64 pDataParam3,
        __int64 pDataParam1,
        __int64 pDataParam4,
        char pDataParam5,
        __int64 pDataParam6)
{
  __int64 structDataBuffer_1; // rax

  *(_QWORD *)(structDataBuffer + 0x18) = pDataParam4;
  *(_BYTE *)(structDataBuffer + 0x20) = pDataParam5;
  *(_QWORD *)(structDataBuffer + 0x28) = pDataParam6;
  *(_QWORD *)structDataBuffer = pDataParam2;
  *(_QWORD *)(structDataBuffer + 0x38) = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
  structDataBuffer_1 = structDataBuffer;
  *(_QWORD *)(structDataBuffer + 8) = pDataParam3;
  *(_QWORD *)(structDataBuffer + 0x10) = pDataParam1;
  *(_QWORD *)(structDataBuffer + 0x30) = 0;
  return structDataBuffer_1;
}

// --- End Function: DataCore::InitializeDataCoreStructData (0x14036BF80) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140370E60 (0x140370E60) ---
__int64 __fastcall sub_140370E60(__int64 a1)
{
  __int64 (__fastcall ***v1)(_QWORD, __int64); // rcx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = *(__int64 (__fastcall ****)(_QWORD, __int64))a1;
    if ( v1 )
      return (**v1)(v1, 1);
  }
  return result;
}

// --- End Function: sub_140370E60 (0x140370E60) ---

// --- Function: sub_140372C00 (0x140372C00) ---
__int64 __fastcall sub_140372C00(__int64 a1)
{
  const void *v2; // rcx
  __int64 result; // rax

  v2 = *(const void **)a1;
  if ( v2 )
  {
    if ( !*(_BYTE *)(a1 + 8) )
      result = sub_1402A3D30(v2);
    *(_QWORD *)a1 = 0;
  }
  return result;
}

// --- End Function: sub_140372C00 (0x140372C00) ---

// --- Function: sub_140377F00 (0x140377F00) ---
char **__fastcall sub_140377F00(char **a1, char **a2)
{
  char *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E9810(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377F00 (0x140377F00) ---

// --- Function: copyStringStructure (0x140377F40) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
char **__fastcall copyStringStructure(char **a1, char **a2)
{
  unsigned __int64 Size; // rdi

  Size = *((int *)*a2 + 0xFFFFFFFE);
  sub_1403E9810(a1, Size, 0x20);
  if ( Size && *a1 != *a2 )
    memcpy(*a1, *a2, Size);
  return a1;
}

// --- End Function: copyStringStructure (0x140377F40) ---

// --- Function: assignCStringToStringStructure (0x140377FA0) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **a1, _BYTE *a2)
{
  __int64 Size; // rax

  if ( a2 )
  {
    Size = -1;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DE230(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DE230(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x140377FA0) ---

// --- Function: sub_140379DA0 (0x140379DA0) ---
__int64 *__fastcall sub_140379DA0(__int64 *a1, __int64 *a2)
{
  __int64 v2; // r8
  char v3; // al
  __int64 *result; // rax

  v2 = *a1;
  *a1 = *a2;
  v3 = *((_BYTE *)a2 + 8);
  *a2 = v2;
  LOBYTE(v2) = *((_BYTE *)a1 + 8);
  *((_BYTE *)a1 + 8) = v3;
  result = a1;
  *((_BYTE *)a2 + 8) = v2;
  return result;
}

// --- End Function: sub_140379DA0 (0x140379DA0) ---

// --- Function: sub_140379DC0 (0x140379DC0) ---
__int64 __fastcall sub_140379DC0(__int64 a1, ULONG_PTR **a2)
{
  ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rax
  bool v4; // zf
  ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx

  p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *a2;
  v4 = *a2 == 0;
  p_p_p_p_p_p_p_p_p_p_p_p_Source = (ULONG_PTR *)&p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( !v4 )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
  sub_140393550(a1, p_p_p_p_p_p_p_p_p_p_p_p_Source);
  return a1;
}

// --- End Function: sub_140379DC0 (0x140379DC0) ---

// --- Function: sub_140379DF0 (0x140379DF0) ---
__int64 __fastcall sub_140379DF0(__int64 a1, _BYTE *p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source)
{
  sub_140393550(a1, p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
  return a1;
}

// --- End Function: sub_140379DF0 (0x140379DF0) ---

// --- Function: sub_1403847F0 (0x1403847F0) ---
void **__fastcall sub_1403847F0(void **a1, char **a2)
{
  sub_1403DFF30(a1, *a2, *((int *)*a2 + 0xFFFFFFFE));
  return a1;
}

// --- End Function: sub_1403847F0 (0x1403847F0) ---

// --- Function: sub_140384840 (0x140384840) ---
void **__fastcall sub_140384840(void **a1, char *a2)
{
  unsigned __int64 Size; // rax

  if ( a2 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DFF30(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DFF30(a1, 0, 0);
    return a1;
  }
}

// --- End Function: sub_140384840 (0x140384840) ---

// --- Function: sub_140391AB0 (0x140391AB0) ---
__int64 __fastcall sub_140391AB0(__int64 a1, unsigned __int64 allocSize)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  unsigned __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403B38D0();
  n0x40 = (allocSize >> 8) + ((_BYTE)allocSize != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
      goto LABEL_7;
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 0x40LL;
      if ( n0x4000 >= 0x4000 )
        goto LABEL_2;
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
        n0x40_1 = 0xFFFFFFFFFFFFFFFFuLL;
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
          goto LABEL_2;
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ;
          n0x4000_2 + 0x40 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL);
          v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = 0xFFFFFFFFFFFFFFFFuLL )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 0x40LL;
    }
    if ( n0x4000_2 < n0x4000 )
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 0x40)) - 1;
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056DB80((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056DBC0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_14056DA40((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(allocSize, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140391AB0 (0x140391AB0) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403A3120 (0x1403A3120) ---
void __fastcall sub_1403A3120(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403B38D0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 0x20) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ; v7 + 0x40 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 0x28) = 0 )
    {
      v11 = v7;
      v7 += 0x40LL;
    }
    if ( v7 < v8 )
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~((1LL << ((__int64)v8 % 0x40)) - 1);
  }
  else
  {
    sub_147605980(a2);
  }
}

// --- End Function: sub_1403A3120 (0x1403A3120) ---

// --- Function: sub_1403A9130 (0x1403A9130) ---
char **sub_1403A9130(char **a1, const char *Format_1, ...)
{
  _QWORD *v4; // rdi
  int BufferCount_2; // eax
  int BufferCount_1; // ecx
  size_t BufferCount; // rbx
  va_list va; // [rsp+70h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = sub_1402A4380();
  BufferCount_2 = _stdio_common_vsprintf(*v4 | 2LL, 0, 0, Format_1, 0, va);
  if ( BufferCount_2 < 0 )
    BufferCount_2 = -1;
  BufferCount_1 = 0;
  if ( BufferCount_2 >= 0 )
    BufferCount_1 = BufferCount_2;
  BufferCount = BufferCount_1;
  sub_1403E9810(a1, BufferCount_1, 32);
  _stdio_common_vsprintf(*v4 | 1LL, *a1, BufferCount, Format_1, 0, va);
  return a1;
}

// --- End Function: sub_1403A9130 (0x1403A9130) ---

// --- Function: sub_1403B38D0 (0x1403B38D0) ---
__int64 sub_1403B38D0()
{
  __int64 *v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(__int64 **)(NtCurrentTeb_w() + 0x10);
  result = *v0;
  if ( !*v0 )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0x828u);
    if ( v2 )
    {
      v2[3] = &p_p_p_p_p_p_p_p_p_p_p_Source;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *v0 = (__int64)v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 0xC0);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 0xC0) = v6 | 1;
      _tlregdtor((__int64)sub_1480BD400);
    }
    return *v0;
  }
  return result;
}

// --- End Function: sub_1403B38D0 (0x1403B38D0) ---

// --- Function: sub_1403B6150 (0x1403B6150) ---
__int64 __fastcall sub_1403B6150(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  int v5; // eax
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // r14
  unsigned __int128 v8; // rax
  __int64 v9; // r10
  __int64 v12; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  _QWORD *v18; // r8
  __int64 v21; // rdx
  __int64 v22; // r9
  _QWORD *v24; // [rsp+28h] [rbp-30h]

  v2 = a2 + 1;
  if ( !*a2 && !*v2 )
    return 0;
  v5 = psub_1403360E0(0xFFFFFFFF, (__int64)a2, 0x10);
  v6 = a1[4];
  v7 = 0;
  v8 = (unsigned int)~v5 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v9 = v6 & ((*((_QWORD *)&v8 + 1) + (_QWORD)v8) >> 7);
  _XMM2 = (BYTE8(v8) + (_BYTE)v8) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v12 = a1[1];
    _XMM1 = *(_OWORD *)(v12 + v9);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_9:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      v18 = v24;
      v22 = v12 + v6;
      v21 = v12;
      goto LABEL_14;
    }
    v7 += 0x10LL;
    v9 = v6 & (v7 + v9);
    if ( v7 > v6 )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v16, _EAX);
    v17 = v6 & (v9 + v16);
    v18 = (_QWORD *)(a1[2] + 0x18 * v17);
    if ( *v18 == *a2 && v18[1] == *v2 )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v12 = a1[1];
      goto LABEL_9;
    }
  }
  v21 = a1[1];
  v22 = v21 + v17;
LABEL_14:
  if ( v22 != v21 + v6 )
    return v18[2];
  else
    return 0;
}

// --- End Function: sub_1403B6150 (0x1403B6150) ---

// --- Function: sub_1403C3960 (0x1403C3960) ---
char **__fastcall sub_1403C3960(char **a1)
{
  char *v1; // r9
  char v3; // al
  char v4; // cl

  v1 = *a1;
  v3 = **a1;
  if ( v3 )
  {
    do
    {
      ++v1;
      v4 = v3 + 0x20;
      if ( (unsigned __int8)(v3 - 0x41) > 0x19u )
        v4 = v3;
      v1[0xFFFFFFFF] = v4;
      v3 = *v1;
    }
    while ( *v1 );
  }
  return a1;
}

// --- End Function: sub_1403C3960 (0x1403C3960) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403E0AA0 (0x1403E0AA0) ---
char *__fastcall sub_1403E0AA0(_QWORD *a1)
{
  char *result; // rax

  result = (char *)&qword_149B3B33C + 4;
  *a1 = (char *)&qword_149B3B33C + 4;
  return result;
}

// --- End Function: sub_1403E0AA0 (0x1403E0AA0) ---

// --- Function: sub_1403E1630 (0x1403E1630) ---
unsigned __int64 __fastcall sub_1403E1630(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r14
  __m128i v11; // xmm3
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // r15
  unsigned __int8 *v15; // rbx
  unsigned __int8 v16; // al
  unsigned __int64 result; // rax
  unsigned __int8 v18[16]; // [rsp+20h] [rbp-48h] BYREF

  _XMM5 = xmmword_1481B6CF0;
  v4 = 0;
  v6 = 0;
  v7 = a1;
  if ( (a3 & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
  {
    do
    {
      _XMM3 = *(__m128i *)(a2 + v6);
      __asm
      {
        vpcmpgtb xmm1, xmm5, xmm3
        vpcmpgtb xmm0, xmm3, xmm4
      }
      v11 = _mm_add_epi8((__m128i)(_XMM1 & _XMM0 & xmmword_1481B6C40), _XMM3);
      v6 += 0x10LL;
      LODWORD(v7) = _mm_crc32_u64(_mm_crc32_u64(v7, v11.m128i_u64[0]), _mm_extract_epi64(v11, 1));
    }
    while ( v6 < (a3 & 0xFFFFFFFFFFFFFFF0uLL) );
  }
  v12 = 0;
  v13 = a3 - v6;
  if ( v13 )
  {
    v14 = a2 - (_QWORD)v18 + v6;
    do
    {
      v15 = &v18[v12];
      v16 = tolower(v18[v12 + v14]);
      ++v12;
      *v15 = v16;
    }
    while ( v12 < v13 );
  }
  result = (unsigned int)v7;
  if ( (v13 & 0xFFFFFFFFFFFFFFF8uLL) != 0 )
  {
    do
    {
      result = _mm_crc32_u64(result, *(_QWORD *)&v18[v4]);
      v4 += 8LL;
    }
    while ( v4 < (v13 & 0xFFFFFFFFFFFFFFF8uLL) );
  }
  if ( (v13 & 4) != 0 )
  {
    result = _mm_crc32_u32(result, *(_DWORD *)&v18[v4]);
    v4 += 4LL;
  }
  if ( (v13 & 2) != 0 )
  {
    result = _mm_crc32_u16(result, *(_WORD *)&v18[v4]);
    v4 += 2LL;
  }
  if ( (v13 & 1) != 0 )
    return _mm_crc32_u8(result, v18[v4]);
  return result;
}

// --- End Function: sub_1403E1630 (0x1403E1630) ---

// --- Function: sub_1403E1790 (0x1403E1790) ---
__int64 __fastcall sub_1403E1790(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 i; // rdi
  int C; // ecx

  for ( i = a3; i; --i )
  {
    C = *a2++;
    a1 = unk_149B3D6A0[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403E1790 (0x1403E1790) ---

// --- Function: sub_1403E1800 (0x1403E1800) ---
__int64 __fastcall sub_1403E1800(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 i; // rdi
  int C; // ecx

  for ( i = a3; i; --i )
  {
    C = *a2++;
    a1 = unk_149B3DAA0[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403E1800 (0x1403E1800) ---

// --- Function: sub_1403E1870 (0x1403E1870) ---
__int64 __fastcall sub_1403E1870(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v3; // rax

  for ( ; a3; --a3 )
  {
    v3 = *a2++;
    a1 = unk_149B3D6A0[v3 ^ (unsigned __int8)a1] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403E1870 (0x1403E1870) ---

// --- Function: sub_1403E19B0 (0x1403E19B0) ---
__int64 sub_1403E19B0()
{
  int n0xFF; // r10d
  _DWORD *v1; // r11
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  __int64 result; // rax
  int v13; // r9d
  signed int n0x1E; // r8d
  unsigned int v15; // eax

  n0xFF = 0;
  v1 = unk_149B3D6A0;
  do
  {
    v2 = ((n0xFF & 1) << 7) | 0x40;
    if ( (n0xFF & 2) == 0 )
      v2 = (n0xFF & 1) << 7;
    v3 = v2 | 0x20;
    if ( (n0xFF & 4) == 0 )
      v3 = v2;
    v4 = v3 | 0x10;
    if ( (n0xFF & 8) == 0 )
      v4 = v3;
    v5 = v4 | 8;
    if ( (n0xFF & 0x10) == 0 )
      v5 = v4;
    v6 = v5 | 4;
    if ( (n0xFF & 0x20) == 0 )
      v6 = v5;
    v7 = v6 | 2;
    if ( (n0xFF & 0x40) == 0 )
      v7 = v6;
    v8 = v7 | 1;
    if ( (((unsigned int)n0xFF >> 6) & 2) == 0 )
      v8 = v7;
    v9 = (((2
          * ((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41) >> 0x1F)
           & 0x1EDC6F41))
         ^ (((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41) >> 0x1F)
           & 0x1EDC6F41) >> 0x1F)
         & 0x1EDC6F41) >> 0x1F)
       & 0x1EDC6F41;
    v10 = (2
         * ((2
           * ((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41) >> 0x1F)
            & 0x1EDC6F41))
          ^ (((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41) >> 0x1F)
            & 0x1EDC6F41) >> 0x1F)
          & 0x1EDC6F41))
        ^ v9;
    v11 = (2 * ((2 * v10) ^ (v10 >> 0x1F) & 0x1EDC6F41))
        ^ (((2 * v10) ^ (v10 >> 0x1F) & 0x1EDC6F41) >> 0x1F)
        & 0x1EDC6F41;
    LODWORD(result) = (2 * v11) ^ (v11 >> 0x1F) & 0x1EDC6F41;
    v13 = 0;
    n0x1E = 0x1E;
    do
    {
      if ( (result & 1) != 0 )
        v13 |= 1 << (n0x1E + 1);
      v15 = (unsigned int)result >> 1;
      if ( (v15 & 1) != 0 )
        v13 |= 1 << n0x1E;
      result = v15 >> 1;
      n0x1E -= 2;
    }
    while ( n0x1E > (int)0xFFFFFFFE );
    *v1 = v13;
    ++n0xFF;
    ++v1;
  }
  while ( n0xFF <= 0xFF );
  return result;
}

// --- End Function: sub_1403E19B0 (0x1403E19B0) ---

// --- Function: sub_1403E1B10 (0x1403E1B10) ---
__int64 sub_1403E1B10()
{
  int n0xFF; // r10d
  _DWORD *v1; // r11
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  __int64 result; // rax
  int v13; // r9d
  signed int n0x1E; // r8d
  unsigned int v15; // eax

  n0xFF = 0;
  v1 = unk_149B3DAA0;
  do
  {
    v2 = ((n0xFF & 1) << 7) | 0x40;
    if ( (n0xFF & 2) == 0 )
      v2 = (n0xFF & 1) << 7;
    v3 = v2 | 0x20;
    if ( (n0xFF & 4) == 0 )
      v3 = v2;
    v4 = v3 | 0x10;
    if ( (n0xFF & 8) == 0 )
      v4 = v3;
    v5 = v4 | 8;
    if ( (n0xFF & 0x10) == 0 )
      v5 = v4;
    v6 = v5 | 4;
    if ( (n0xFF & 0x20) == 0 )
      v6 = v5;
    v7 = v6 | 2;
    if ( (n0xFF & 0x40) == 0 )
      v7 = v6;
    v8 = v7 | 1;
    if ( (((unsigned int)n0xFF >> 6) & 2) == 0 )
      v8 = v7;
    v9 = (((2
          * ((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
             & 0x4C11DB7))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
             & 0x4C11DB7) >> 0x1F)
           & 0x4C11DB7))
         ^ (((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
             & 0x4C11DB7))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
             & 0x4C11DB7) >> 0x1F)
           & 0x4C11DB7) >> 0x1F)
         & 0x4C11DB7) >> 0x1F)
       & 0x4C11DB7;
    v10 = (2
         * ((2
           * ((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
              & 0x4C11DB7))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
              & 0x4C11DB7) >> 0x1F)
            & 0x4C11DB7))
          ^ (((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
              & 0x4C11DB7))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 0x1F)
              & 0x4C11DB7) >> 0x1F)
            & 0x4C11DB7) >> 0x1F)
          & 0x4C11DB7))
        ^ v9;
    v11 = (2 * ((2 * v10) ^ (v10 >> 0x1F) & 0x4C11DB7)) ^ (((2 * v10) ^ (v10 >> 0x1F) & 0x4C11DB7) >> 0x1F) & 0x4C11DB7;
    LODWORD(result) = (2 * v11) ^ (v11 >> 0x1F) & 0x4C11DB7;
    v13 = 0;
    n0x1E = 0x1E;
    do
    {
      if ( (result & 1) != 0 )
        v13 |= 1 << (n0x1E + 1);
      v15 = (unsigned int)result >> 1;
      if ( (v15 & 1) != 0 )
        v13 |= 1 << n0x1E;
      result = v15 >> 1;
      n0x1E -= 2;
    }
    while ( n0x1E > (int)0xFFFFFFFE );
    *v1 = v13;
    ++n0xFF;
    ++v1;
  }
  while ( n0xFF <= 0xFF );
  return result;
}

// --- End Function: sub_1403E1B10 (0x1403E1B10) ---

// --- Function: sub_1403E1FA0 (0x1403E1FA0) ---
void *__fastcall sub_1403E1FA0(void *a1, const void *a2, size_t Size)
{
  void *result; // rax

  if ( a1 != a2 )
    return memcpy(a1, a2, Size);
  return result;
}

// --- End Function: sub_1403E1FA0 (0x1403E1FA0) ---

// --- Function: sub_1403E20D0 (0x1403E20D0) ---
__int64 __fastcall sub_1403E20D0(__int64 a1)
{
  __int64 result; // rax

  if ( !a1 )
    return 0;
  result = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++result;
  while ( *(_BYTE *)(a1 + result) );
  return (int)result;
}

// --- End Function: sub_1403E20D0 (0x1403E20D0) ---

// --- Function: sub_1403E30D0 (0x1403E30D0) ---
void sub_1403E30D0()
{
  __int64 n7; // rax
  __int64 Relationship; // rcx
  unsigned int v25; // r8d
  __int64 Relationship_1; // rcx
  __int64 Relationship_2; // rcx
  __int64 Relationship_3; // rcx
  __int64 v41; // rbx
  unsigned __int64 NodeNumber; // rcx
  unsigned __int64 size; // rcx
  void *v44; // rsp
  void *v45; // rsp
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *p_Buffer; // r15
  unsigned __int64 v47; // r12
  int v48; // r13d
  unsigned __int8 v49; // cl
  unsigned __int8 v50; // r14
  unsigned __int8 v51; // cl
  unsigned __int8 v52; // si
  unsigned __int8 v53; // cl
  unsigned __int8 v54; // di
  unsigned __int8 v55; // cl
  unsigned __int8 v56; // r10
  unsigned __int8 v57; // cl
  unsigned __int8 v58; // r9
  unsigned __int8 v59; // cl
  unsigned __int8 v60; // r8
  unsigned __int8 v61; // cl
  unsigned __int8 v62; // al
  __int64 v63; // rcx
  _BYTE *v64; // rax
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer; // [rsp+20h] [rbp+0h] BYREF

  if ( !byte_149B3B502 )
  {
    _RAX = 1;
    __asm { cpuid }
    dword_149B3D558 = _RAX;
    n7 = 7;
    dword_149B3D560 = _RCX;
    dword_149B3D55C = _RBX;
    dword_149B3D564 = _RDX;
    __asm { cpuid }
    dword_149B3D56C = _RAX;
    _RAX = 0x80000007LL;
    dword_149B3D574 = _RCX;
    dword_149B3D570 = _RBX;
    dword_149B3D578 = _RDX;
    __asm { cpuid }
    dword_149B3D57C = _RAX;
    _RAX = 0x80000001LL;
    dword_149B3D584 = _RCX;
    dword_149B3D580 = _RBX;
    dword_149B3D588 = _RDX;
    __asm { cpuid }
    _RAX = 0x80000000LL;
    dword_149B3D58C = _RCX;
    dword_149B3D590 = _RDX;
    __asm { cpuid }
    LODWORD(Buffer.ProcessorMask) = 0xFFFFFFFF;
    v25 = _RAX;
    HIDWORD(Buffer.ProcessorMask) = _RBX;
    Buffer.Relationship = Relationship;
    *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
    if ( (unsigned int)_RAX > 0x80000002 )
    {
      _RAX = 0x80000002LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_1;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149B3D5A0 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000003 )
    {
      _RAX = 0x80000003LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_2;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149B3D5B0 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000004 )
    {
      _RAX = 0x80000004LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_3;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149B3D5C0 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    v41 = 0;
    Buffer.NumaNode.NodeNumber = 0;
    if ( GetLogicalProcessorInformation(0, &Buffer.NumaNode.NodeNumber) || GetLastError() != ERROR_INSUFFICIENT_BUFFER )
      __debugbreak();
    NodeNumber = Buffer.NumaNode.NodeNumber + 0xFLL;
    if ( NodeNumber <= Buffer.NumaNode.NodeNumber )
      NodeNumber = 0xFFFFFFFFFFFFFF0LL;
    size = NodeNumber & 0xFFFFFFFFFFFFFFF0uLL;
    v44 = alloca(size);
    v45 = alloca(size);
    p_Buffer = &Buffer;
    if ( !GetLogicalProcessorInformation(&Buffer, &Buffer.NumaNode.NodeNumber) )
      __debugbreak();
    v47 = (unsigned __int64)Buffer.NumaNode.NodeNumber >> 5;
    if ( v47 )
    {
      v48 = dword_149B3D568;
      do
      {
        if ( p_Buffer->Relationship == RelationProcessorCore )
        {
          v49 = (p_Buffer->ProcessorMask & 0x55) + (((unsigned __int8)p_Buffer->ProcessorMask >> 1) & 0x55);
          v50 = (v49 & 0x33) + ((v49 >> 2) & 0x33);
          v51 = (BYTE1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE1(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v52 = (v51 & 0x33) + ((v51 >> 2) & 0x33);
          v53 = (WORD1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE2(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v54 = (v53 & 0x33) + ((v53 >> 2) & 0x33);
          v55 = (BYTE3(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE3(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v56 = (v55 & 0x33) + ((v55 >> 2) & 0x33);
          v57 = (HIDWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE4(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v58 = (v57 & 0x33) + ((v57 >> 2) & 0x33);
          v59 = (((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) & 0x55)
              + (((unsigned __int8)((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) >> 1) & 0x55);
          v60 = (v59 & 0x33) + ((v59 >> 2) & 0x33);
          v61 = (HIWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE6(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v62 = (HIBYTE(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)HIBYTE(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v48 += (unsigned __int8)((v50 >> 4)
                                 + (v50 & 0xF)
                                 + (v52 >> 4)
                                 + (v52 & 0xF)
                                 + (v54 >> 4)
                                 + (v54 & 0xF)
                                 + (v56 >> 4)
                                 + (v56 & 0xF)
                                 + (v58 >> 4)
                                 + (v58 & 0xF)
                                 + (v60 >> 4)
                                 + (v60 & 0xF)
                                 + ((unsigned __int8)((v61 & 0x33) + ((v61 >> 2) & 0x33)) >> 4)
                                 + (((v61 & 0x33) + ((v61 >> 2) & 0x33)) & 0xF)
                                 + ((unsigned __int8)((v62 & 0x33) + ((v62 >> 2) & 0x33)) >> 4)
                                 + (((v62 & 0x33) + ((v62 >> 2) & 0x33)) & 0xF));
        }
        ++p_Buffer;
        --v47;
      }
      while ( v47 );
      dword_149B3D568 = v48;
    }
    v63 = 0;
    if ( (_BYTE)xmmword_149B3D5A0 )
    {
      do
      {
        for ( ; *((_BYTE *)&xmmword_149B3D5A0 + v41) == 0x20; ++v41 )
          ;
        *((_BYTE *)&xmmword_149B3D5A0 + v63) = *((_BYTE *)&xmmword_149B3D5A0 + v41);
        if ( *((_BYTE *)&xmmword_149B3D5A0 + v41) )
        {
          while ( 1 )
          {
            v64 = (char *)&xmmword_149B3D5A0 + v41;
            ++v63;
            ++v41;
            if ( *v64 == 0x20 )
              break;
            *((_BYTE *)&xmmword_149B3D5A0 + v63) = *((_BYTE *)&xmmword_149B3D5A0 + v41);
            if ( !*((_BYTE *)&xmmword_149B3D5A0 + v41) )
              goto LABEL_27;
          }
        }
        else
        {
LABEL_27:
          if ( v63 )
          {
            if ( *((_BYTE *)&xmmword_149B3D5A0 + v63 - 1) == 0x20 )
              *((_BYTE *)&xmmword_149B3D5A0 + v63 - 1) = 0;
          }
        }
      }
      while ( *((_BYTE *)&xmmword_149B3D5A0 + v41) );
    }
    byte_149B3B502 = 1;
  }
}

// --- End Function: sub_1403E30D0 (0x1403E30D0) ---

// --- Function: sub_1403E4780 (0x1403E4780) ---
__int64 __fastcall sub_1403E4780(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E4780 (0x1403E4780) ---

// --- Function: sub_1403E47B0 (0x1403E47B0) ---
__int64 __fastcall sub_1403E47B0(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // rdx
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E47B0 (0x1403E47B0) ---

// --- Function: sub_1403E61D0 (0x1403E61D0) ---
char *__fastcall sub_1403E61D0(__int64 *a1, char Control_1, unsigned __int64 a3)
{
  __int64 v4; // rcx
  char *v5; // rax
  char Control; // [rsp+30h] [rbp+8h] BYREF
  char v8; // [rsp+31h] [rbp+9h]

  v4 = *a1;
  if ( a3 <= *(int *)(v4 - 8) && (Control = Control_1, v8 = 0, (v5 = strpbrk((const char *)(a3 + v4), &Control)) != 0) )
    return &v5[-*a1];
  else
    return (char *)0xFFFFFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403E61D0 (0x1403E61D0) ---

// --- Function: sub_1403E7A60 (0x1403E7A60) ---
__int64 __fastcall sub_1403E7A60(_QWORD *a1)
{
  return *(int *)(*a1 - 8LL);
}

// --- End Function: sub_1403E7A60 (0x1403E7A60) ---

// --- Function: sub_1403E8AB0 (0x1403E8AB0) ---
char **__fastcall sub_1403E8AB0(char **a1, const char *SubStr, char *a3)
{
  unsigned __int64 v6; // rax
  __int64 v7; // r14
  size_t Size_1; // r15
  unsigned __int64 Size_2; // rax
  const char *v10; // rbx
  __int64 v11; // rdi
  char *v12; // rsi
  char *v13; // rax
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  char *v16; // rsi
  __int64 v17; // rbp
  unsigned __int64 v18; // rcx
  char **v19; // rsi
  const char *v20; // rbx
  char *v21; // rax
  char *v22; // rdi
  size_t Size; // rsi
  unsigned __int64 v24; // rax
  __int64 v25; // rcx
  char *v28; // [rsp+68h] [rbp+10h]
  int v29; // [rsp+78h] [rbp+20h]

  if ( !SubStr )
    return a1;
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v6;
  while ( SubStr[v6] );
  v7 = (int)v6;
  if ( !(_DWORD)v6 )
    return a1;
  if ( a3 )
  {
    Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_2;
    while ( a3[Size_2] );
    Size_1 = (int)Size_2;
  }
  else
  {
    Size_1 = 0;
  }
  v10 = *a1;
  v11 = 0;
  v12 = &(*a1)[*((int *)*a1 + 0xFFFFFFFE)];
  if ( *a1 >= v12 )
    return a1;
  do
  {
    while ( 1 )
    {
      if ( !v10 )
      {
        v15 = 0;
        goto LABEL_18;
      }
      v13 = strstr(v10, SubStr);
      if ( !v13 )
        break;
      ++v11;
      v10 = &v13[v7];
    }
    v14 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v14;
    while ( v10[v14] );
    v15 = (int)v14;
LABEL_18:
    v10 += v15 + 1;
  }
  while ( v10 < v12 );
  if ( !v11 )
    return a1;
  v16 = *a1;
  v17 = *((int *)*a1 + 0xFFFFFFFE);
  v18 = v17 + v11 * (Size_1 - v7);
  v29 = v17 + v11 * (Size_1 - v7);
  if ( *((int *)v16 + 0xFFFFFFFF) < v18 )
  {
    sub_1403DE0C0(a1, v18);
    if ( *a1 != v16 )
      memcpy(*a1, v16, *((int *)v16 + 0xFFFFFFFE));
    if ( *((int *)v16 + 0xFFFFFFFF) > 0 )
      sub_147605980(v16 + 0xFFFFFFF8);
  }
  v19 = a1;
  v20 = *a1;
  v28 = &(*a1)[*((int *)*a1 + 0xFFFFFFFE)];
  if ( *a1 < v28 )
  {
    do
    {
      while ( 2 )
      {
        if ( v20 )
        {
          v21 = strstr(v20, SubStr);
          v22 = v21;
          if ( v21 )
          {
            v20 = &v21[Size_1];
            Size = v17 + *v19 - v21 - v7;
            memmove(&v21[Size_1], &v21[v7], Size);
            if ( v22 != a3 )
              memcpy(v22, a3, Size_1);
            v20[Size] = 0;
            v19 = a1;
            v17 += Size_1 - v7;
            continue;
          }
          v24 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++v24;
          while ( v20[v24] );
          v25 = (int)v24;
        }
        else
        {
          v25 = 0;
        }
        break;
      }
      v20 += v25 + 1;
    }
    while ( v20 < v28 );
  }
  *((_DWORD *)*v19 + 0xFFFFFFFE) = v29;
  return v19;
}

// --- End Function: sub_1403E8AB0 (0x1403E8AB0) ---

// --- Function: sub_1403E90A0 (0x1403E90A0) ---
void __fastcall sub_1403E90A0(void **a1, unsigned __int64 a2)
{
  _BYTE *v2; // rdi
  unsigned __int64 v5; // rcx
  _DWORD *v6; // rax

  v2 = *a1;
  v5 = *((int *)*a1 + 0xFFFFFFFF);
  if ( a2 > v5 )
  {
    if ( a2 )
    {
      v6 = (_DWORD *)allocWithProfilerInfo(a2 + 9, 0);
      *a1 = v6 + 2;
      *v6 = a2;
      v6[1] = a2;
      *((_BYTE *)*a1 + a2) = 0;
    }
    else
    {
      *a1 = (char *)&qword_149B3B33C + 4;
    }
    if ( *a1 != v2 )
      memcpy(*a1, v2, *((int *)v2 + 0xFFFFFFFE));
    *((_DWORD *)*a1 + 0xFFFFFFFE) = *((_DWORD *)v2 + 0xFFFFFFFE);
    *((_BYTE *)*a1 + *((int *)v2 + 0xFFFFFFFE)) = 0;
LABEL_12:
    if ( *((int *)v2 + 0xFFFFFFFF) > 0 )
      sub_147605980(v2 + 0xFFFFFFF8);
    return;
  }
  if ( !a2 && *((_DWORD *)v2 + 0xFFFFFFFE) != (_DWORD)v5 )
  {
    sub_1403DE0C0((char **)a1, *((int *)v2 + 0xFFFFFFFE));
    if ( *a1 != v2 )
      memcpy(*a1, v2, *((int *)v2 + 0xFFFFFFFE));
    goto LABEL_12;
  }
}

// --- End Function: sub_1403E90A0 (0x1403E90A0) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 - 1) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 - 2)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 - 2));
  memset(&(*a1)[*((int *)v3 - 2)], Val_1, Size);
  if ( *((int *)v3 - 1) > 0 )
    sub_147605980(v3 - 8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1403EAE30 (0x1403EAE30) ---
void **__fastcall sub_1403EAE30(__int64 *a1, void **a2, size_t a3, size_t Size_1)
{
  __int64 v6; // rdx
  size_t v7; // rcx
  size_t Size; // r8

  v6 = *a1;
  v7 = *(int *)(*a1 - 8);
  if ( a3 < v7 )
  {
    Size = v7 - a3;
    if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
      Size_1 = v7 - a3;
    if ( a3 + Size_1 <= v7 )
      Size = Size_1;
    sub_14035B360(a2, (void *)(a3 + v6), Size);
    return a2;
  }
  else
  {
    *a2 = (char *)&qword_149B3B33C + 4;
    return a2;
  }
}

// --- End Function: sub_1403EAE30 (0x1403EAE30) ---

// --- Function: sub_14043EFE0 (0x14043EFE0) ---
_QWORD *__fastcall sub_14043EFE0(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  __int64 *i; // rbx

  for ( i = a1; i != a2; ++i )
    sub_14035B140(a3++, i);
  return a3;
}

// --- End Function: sub_14043EFE0 (0x14043EFE0) ---

// --- Function: sub_140444D10 (0x140444D10) ---
char __fastcall sub_140444D10(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int64 v11; // rax
  const char *p_null; // rdx
  __int64 v14; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v19; // [rsp+A0h] [rbp-70h]
  const char *p_Text; // [rsp+A8h] [rbp-68h]
  __int64 v21; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+C0h] [rbp-50h]
  __int64 v24; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v26; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4E80)(__int64); // [rsp+E0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v29; // [rsp+F0h] [rbp-20h]
  char v30; // [rsp+F8h] [rbp-18h]
  char v31; // [rsp+F9h] [rbp-17h]
  __int64 n0x18; // [rsp+100h] [rbp-10h]
  unsigned __int64 v33; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  p_Text = "Text";
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  v19 = a10;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v31 = 0;
  v21 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v24 = 0;
  v26 = 0;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v30 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  do
    ++v11;
  while ( p_null[v11] );
  v33 = v11;
  LODWORD(v14) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 2u, a5, v14, a7, a8);
}

// --- End Function: sub_140444D10 (0x140444D10) ---

// --- Function: sub_14044EB10 (0x14044EB10) ---
unsigned __int64 __fastcall sub_14044EB10(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        int *a4,
        unsigned __int64 n4,
        unsigned __int8 a6)
{
  __int64 v6; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rax
  __int64 v12; // rcx
  _OWORD *v13; // rax
  _OWORD *v14; // rax
  unsigned __int64 n4_1; // rdx
  __int64 n8; // r8
  __int64 v17; // rdi
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v20; // [rsp+48h] [rbp+10h] BYREF

  v6 = *a4;
  if ( (_DWORD)v6 )
  {
    v20 = 0x10 * v6;
    v10 = sub_140332BC0(a1, 0, &v20, n4, a6);
    v11 = v20 >> 4;
    *a4 = v20 >> 4;
  }
  else
  {
    v10 = 0;
    LODWORD(v11) = 0;
  }
  if ( a2 )
  {
    if ( v10 )
    {
      if ( a3 < (int)v11 )
        LODWORD(v11) = a3;
      if ( a2 != v10 )
      {
        v12 = (int)v11;
        if ( a2 > v10 || 0x10LL * (int)v11 + a2 <= v10 )
        {
          if ( (_DWORD)v11 )
          {
            v14 = (_OWORD *)v10;
            do
            {
              *v14 = *(_OWORD *)((char *)v14 + a2 - v10);
              ++v14;
              --v12;
            }
            while ( v12 );
          }
        }
        else if ( (_DWORD)v11 )
        {
          v13 = (_OWORD *)(v10 + 0x10LL * (int)v11 - 0x10);
          do
          {
            *v13 = *(_OWORD *)((char *)v13 + a2 - v10);
            v13 += 0xFFFFFFFF;
            --v12;
          }
          while ( v12 );
        }
      }
    }
    n4_1 = 4;
    v20 = 0;
    n8 = 8;
    if ( n4 > 4 )
      n4_1 = n4;
    v17 = a2 - ((n4_1 + 3) & ~(n4_1 - 1));
    n8_1 = 8;
    if ( n4_1 > 8 )
      n8_1 = n4_1;
    if ( v17 )
    {
      if ( n8_1 > 8 )
        n8 = n8_1;
      (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64, _QWORD))(v17 - 8))(
        v17 - ((n8 + 7) & ~(n8 - 1)),
        &v20,
        n8,
        0);
    }
  }
  return v10;
}

// --- End Function: sub_14044EB10 (0x14044EB10) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n15; // rax

  v0 = sub_1404B3EA0();
  v1 = v0;
  if ( !v0 )
    return &dword_149B45F40;
  n15 = *v0;
  if ( n15 > 0xF )
    n15 = 15;
  return (__int64 *)&v1[22 * n15 + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_1404FBC30 (0x1404FBC30) ---
__int64 __fastcall sub_1404FBC30(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rsi
  __int64 result; // rax

  v4 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(_QWORD **)(a1 + 8); v4 != i; ++v4 )
      sub_140370D10(v4);
    sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 8 * a3;
  result = a2 + 8 * a4;
  *(_QWORD *)(a1 + 0x10) = result;
  return result;
}

// --- End Function: sub_1404FBC30 (0x1404FBC30) ---

// --- Function: sub_140500E00 (0x140500E00) ---
unsigned __int8 ***__fastcall sub_140500E00(unsigned __int8 ***a1, unsigned __int8 ***a2, unsigned __int8 **a3)
{
  unsigned __int8 **v3; // rdi
  unsigned __int8 **v7; // rbx

  v3 = *a1;
  v7 = (unsigned __int8 **)(*a1)[1];
  while ( !*((_BYTE *)v7 + 0x19) )
  {
    if ( (int)sub_1403E4780(v7 + 4, a3) >= 0 )
    {
      v3 = v7;
      v7 = (unsigned __int8 **)*v7;
    }
    else
    {
      v7 = (unsigned __int8 **)v7[2];
    }
  }
  if ( *((_BYTE *)v3 + 0x19) || (int)sub_1403E4780(a3, v3 + 4) < 0 )
    *a2 = *a1;
  else
    *a2 = v3;
  return a2;
}

// --- End Function: sub_140500E00 (0x140500E00) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10(a3);
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DB80 (0x14056DB80) ---
__int64 __fastcall sub_14056DB80(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 0x1000 )
        return 0x1000;
      if ( ++v1 == v2 )
        return 0x1000;
    }
  }
  return 0x1000;
}

// --- End Function: sub_14056DB80 (0x14056DB80) ---

// --- Function: sub_14056DBC0 (0x14056DBC0) ---
__int64 __fastcall sub_14056DBC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E2E40(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056DBC0 (0x14056DBC0) ---

// --- Function: sub_1405975C0 (0x1405975C0) ---
_QWORD *__fastcall sub_1405975C0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_1405975C0 (0x1405975C0) ---

// --- Function: sub_140597760 (0x140597760) ---
__m128 sub_140597760()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_140597760 (0x140597760) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_1405D9570 (0x1405D9570) ---
_QWORD *__fastcall sub_1405D9570(_QWORD *a1)
{
  *a1 = 0;
  return a1;
}

// --- End Function: sub_1405D9570 (0x1405D9570) ---

// --- Function: sub_14089E6C0 (0x14089E6C0) ---
char *__fastcall sub_14089E6C0(__int64 a1, _DWORD *a2)
{
  _BYTE *v3; // rdx
  char *result; // rax

  v3 = *(_BYTE **)(a1 + 8);
  if ( v3 == *(_BYTE **)(a1 + 0x10) )
    return sub_140344F60(a1, v3, a2);
  *(_DWORD *)v3 = *a2;
  result = *(char **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = result + 4;
  return result;
}

// --- End Function: sub_14089E6C0 (0x14089E6C0) ---

// --- Function: ensureCapacityAndZeroFill (0x1408EBE30) ---
char *__fastcall ensureCapacityAndZeroFill(char **pOutFieldPtrsVec, unsigned __int64 totalFieldCount)
{
  char *v2; // rbp
  char *result; // rax
  unsigned __int64 totalFieldCount_3; // rsi
  unsigned __int64 totalFieldCount_2; // rcx
  unsigned __int64 totalFieldCount_1; // rdx
  unsigned __int64 v9; // r8
  __int64 v10; // r15
  char *v11; // r14
  size_t Size; // rbx

  v2 = pOutFieldPtrsVec[1];
  result = *pOutFieldPtrsVec;
  totalFieldCount_3 = (v2 - *pOutFieldPtrsVec) >> 3;
  if ( totalFieldCount >= totalFieldCount_3 )
  {
    if ( totalFieldCount > totalFieldCount_3 )
    {
      totalFieldCount_2 = (pOutFieldPtrsVec[2] - result) >> 3;
      if ( totalFieldCount <= totalFieldCount_2 )
      {
        Size = 8 * (totalFieldCount - totalFieldCount_3);
        memset(v2, 0, Size);
        result = &v2[Size];
        pOutFieldPtrsVec[1] = &v2[Size];
      }
      else
      {
        totalFieldCount_1 = 0x1FFFFFFFFFFFFFFFLL;
        if ( totalFieldCount > 0x1FFFFFFFFFFFFFFFLL )
          unknown_libname_10();
        v9 = totalFieldCount_2 >> 1;
        if ( totalFieldCount_2 <= 0x1FFFFFFFFFFFFFFFLL - (totalFieldCount_2 >> 1) )
        {
          totalFieldCount_1 = v9 + totalFieldCount_2;
          if ( v9 + totalFieldCount_2 < totalFieldCount )
            totalFieldCount_1 = totalFieldCount;
        }
        v10 = 8 * totalFieldCount_1;
        v11 = (char *)sub_140391AB0((__int64)pOutFieldPtrsVec, 8 * totalFieldCount_1);
        memset(&v11[8 * totalFieldCount_3], 0, 8 * (totalFieldCount - totalFieldCount_3));
        memmove(v11, *pOutFieldPtrsVec, pOutFieldPtrsVec[1] - *pOutFieldPtrsVec);
        if ( *pOutFieldPtrsVec )
          sub_1403A3120(
            (__int64)pOutFieldPtrsVec,
            *pOutFieldPtrsVec,
            (pOutFieldPtrsVec[2] - *pOutFieldPtrsVec) & 0xFFFFFFFFFFFFFFF8uLL);
        *pOutFieldPtrsVec = v11;
        pOutFieldPtrsVec[1] = &v11[8 * totalFieldCount];
        result = &v11[v10];
        pOutFieldPtrsVec[2] = &v11[v10];
      }
    }
  }
  else
  {
    result += 8 * totalFieldCount;
    pOutFieldPtrsVec[1] = result;
  }
  return result;
}

// --- End Function: ensureCapacityAndZeroFill (0x1408EBE30) ---

// --- Function: sub_14096EAD0 (0x14096EAD0) ---
__int64 __fastcall sub_14096EAD0(__int64 a1)
{
  return *(unsigned int *)(a1 + 0x2D0);
}

// --- End Function: sub_14096EAD0 (0x14096EAD0) ---

// --- Function: sub_1409A0230 (0x1409A0230) ---
__int64 __fastcall sub_1409A0230(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *i; // rbx
  _QWORD *v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*((_BYTE *)i + 0x19); result = sub_1402A3D30(v6) )
  {
    sub_1409A0230(a1, a2, i[2]);
    v6 = i;
    i = (__int64 *)*i;
    sub_140370D10(v6 + 4);
  }
  return result;
}

// --- End Function: sub_1409A0230 (0x1409A0230) ---

// --- Function: sub_140BA1C30 (0x140BA1C30) ---
__int64 __fastcall sub_140BA1C30(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rdi
  _QWORD *v4; // rcx
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 2 )
      sub_140370D10(v1 + 1);
    v4 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140BA1C30 (0x140BA1C30) ---

// --- Function: sub_1419110C0 (0x1419110C0) ---
__int64 __fastcall sub_1419110C0(__int64 a1, unsigned __int64 *a2)
{
  __int64 *v2; // rbx
  __int64 inserted; // r8
  __int64 v6; // rax
  unsigned __int64 v7; // r9
  __int64 v8; // rax
  __int64 v10; // [rsp+20h] [rbp-28h] BYREF
  int v11; // [rsp+28h] [rbp-20h]

  v2 = *(__int64 **)a1;
  v11 = 0;
  inserted = (__int64)v2;
  v6 = v2[1];
  v10 = v6;
  if ( !*(_BYTE *)(v6 + 0x19) )
  {
    v7 = *a2;
    do
    {
      v10 = v6;
      if ( *(_QWORD *)(v6 + 0x20) >= v7 )
      {
        inserted = v6;
        v11 = 1;
        v6 = *(_QWORD *)v6;
      }
      else
      {
        v6 = *(_QWORD *)(v6 + 0x10);
        v11 = 0;
      }
    }
    while ( !*(_BYTE *)(v6 + 0x19) );
  }
  if ( *(_BYTE *)(inserted + 0x19) || *a2 < *(_QWORD *)(inserted + 0x20) )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x555555555555555LL )
      unknown_libname_7();
    v8 = sub_140391AB0(a1, 0x30u);
    *(_QWORD *)(v8 + 0x20) = *a2;
    *(_QWORD *)(v8 + 0x28) = 0;
    *(_QWORD *)v8 = v2;
    *(_QWORD *)(v8 + 8) = v2;
    *(_QWORD *)(v8 + 0x10) = v2;
    *(_WORD *)(v8 + 0x18) = 0;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 (__int64 **)a1,
                 (__int64)&v10,
                 v8);
  }
  return inserted + 0x28;
}

// --- End Function: sub_1419110C0 (0x1419110C0) ---

// --- Function: sub_141E46F60 (0x141E46F60) ---
_QWORD *__fastcall sub_141E46F60(unsigned __int64 *a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v4; // rbx
  __int64 v5; // r15
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r14
  unsigned __int64 allocSize; // r14
  __int64 v13; // rax
  unsigned __int64 v14; // rdi
  _QWORD *v15; // r12
  unsigned __int64 v16; // rdx
  _QWORD *v17; // r8
  _QWORD *v18; // rcx
  unsigned __int64 v19; // rbx
  unsigned __int64 i; // rbp
  _QWORD *v21; // rcx
  _QWORD *result; // rax

  v4 = (__int64)a2 - *a1;
  v5 = (__int64)(a1[1] - *a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = v5 + 1;
  v9 = (__int64)(a1[2] - *a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_25;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  allocSize = 0x10 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_25:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_23;
  v14 = (v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_13:
  v15 = (_QWORD *)((v4 & 0xFFFFFFFFFFFFFFF0uLL) + v14);
  *v15 = *a3;
  sub_14035B140(v15 + 1, a3 + 1);
  v16 = a1[1];
  v17 = (_QWORD *)v14;
  v18 = (_QWORD *)*a1;
  if ( a2 != (_QWORD *)v16 )
  {
    sub_140B8EF80(v18, a2, v14, a1);
    v16 = a1[1];
    v17 = v15 + 2;
    v18 = a2;
  }
  sub_140B8EF80(v18, v16, v17, a1);
  v19 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v19 != i; v19 += 0x10LL )
      sub_140370D10((_QWORD *)(v19 + 8));
    v21 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
      goto LABEL_21;
    if ( (unsigned __int64)v21 - v21[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v21 = (_QWORD *)v21[0xFFFFFFFF];
LABEL_21:
      sub_1402A3D30(v21);
      goto LABEL_22;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  *a1 = v14;
  result = v15;
  a1[1] = v14 + 0x10 * v8;
  a1[2] = allocSize + v14;
  return result;
}

// --- End Function: sub_141E46F60 (0x141E46F60) ---

// --- Function: ??$_Find@PEAX@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@AEBQEAX@Z (0x142EA2940) ---
__int64 __fastcall std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
        __int64 *a1,
        _QWORD *a2)
{
  _BYTE v3[16]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v4; // [rsp+30h] [rbp-18h]

  std::_Tree<std::_Tmap_traits<std::string,unsigned __int64,std::less<std::string>,std::allocator<std::pair<std::string const,unsigned __int64>>,0>>::_Find_lower_bound<std::string>(
    a1,
    (__int64)v3,
    a2);
  if ( (unsigned __int8)sub_1411FC6E0(a1, v4, a2) )
    return v4;
  else
    return *(_QWORD *)sub_1402A24F0((__int64)a1);
}

// --- End Function: ??$_Find@PEAX@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@AEBQEAX@Z (0x142EA2940) ---

// --- Function: ?find@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@AEBQEAX@Z (0x142F34020) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::find(
        __int64 *a1,
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *a2,
        _QWORD *a3)
{
  struct __crt_stdio_stream *v4; // [rsp+28h] [rbp-10h]

  sub_1402A24F0((__int64)a1);
  v4 = (struct __crt_stdio_stream *)std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
                                      a1,
                                      a3);
  _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(a2, v4);
  return a2;
}

// --- End Function: ?find@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@AEBQEAX@Z (0x142F34020) ---

// --- Function: sub_143429A20 (0x143429A20) ---
__int64 *__fastcall sub_143429A20(__int64 a1, __int64 *a2)
{
  __int64 *inserted; // rdi
  __int64 v5; // rbx
  __int64 *v6; // rdi
  __int64 v7; // rsi
  __int128 v8; // xmm0
  __int128 v10; // [rsp+20h] [rbp-38h] BYREF

  inserted = *(__int64 **)a1;
  DWORD2(v10) = 0;
  v5 = inserted[1];
  *(_QWORD *)&v10 = v5;
  while ( !*(_BYTE *)(v5 + 0x19) )
  {
    *(_QWORD *)&v10 = v5;
    if ( (int)sub_1403E4780((unsigned __int8 **)(v5 + 0x20), a2) >= 0 )
    {
      inserted = (__int64 *)v5;
      DWORD2(v10) = 1;
      v5 = *(_QWORD *)v5;
    }
    else
    {
      v5 = *(_QWORD *)(v5 + 0x10);
      DWORD2(v10) = 0;
    }
  }
  if ( *((_BYTE *)inserted + 0x19) || (int)sub_1403E4780((unsigned __int8 **)a2, inserted + 4) < 0 )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFLL )
      unknown_libname_7();
    v6 = *(__int64 **)a1;
    v7 = allocWithProfilerInfo_w(0x40u);
    sub_14035B140((_QWORD *)(v7 + 0x20), a2);
    v8 = v10;
    *(_QWORD *)(v7 + 0x28) = 0;
    *(_QWORD *)(v7 + 0x30) = 0;
    *(_QWORD *)(v7 + 0x38) = 0;
    *(_QWORD *)v7 = v6;
    *(_QWORD *)(v7 + 8) = v6;
    *(_QWORD *)(v7 + 0x10) = v6;
    *(_WORD *)(v7 + 0x18) = 0;
    v10 = v8;
    inserted = (__int64 *)std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                            (__int64 **)a1,
                            (__int64)&v10,
                            v7);
  }
  return inserted + 5;
}

// --- End Function: sub_143429A20 (0x143429A20) ---

// --- Function: ??0?$_Yarn@_W@std@@QEAA@XZ (0x143824020) ---
__int64 __fastcall std::_Yarn<wchar_t>::_Yarn<wchar_t>(__int64 a1)
{
  *(_QWORD *)a1 = 0;
  *(_WORD *)(a1 + 8) = 0;
  return a1;
}

// --- End Function: ??0?$_Yarn@_W@std@@QEAA@XZ (0x143824020) ---

// --- Function: sub_146C1A480 (0x146C1A480) ---
char __fastcall sub_146C1A480(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v11; // rsp
  __int64 v13; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  _QWORD *v18; // [rsp+A0h] [rbp-E0h]
  const char *p_Int; // [rsp+A8h] [rbp-D8h]
  __int64 v20; // [rsp+B0h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1405048A0)(__int64, __int64, __int64); // [rsp+B8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1405048A0_1)(__int64, __int64, __int64); // [rsp+C0h] [rbp-C0h]
  __int64 v23; // [rsp+C8h] [rbp-B8h]
  __int64 (__fastcall *p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z)(); // [rsp+D0h] [rbp-B0h]
  __int64 v25; // [rsp+D8h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E4E70)(__int64); // [rsp+E0h] [rbp-A0h]
  _OWORD *(__fastcall *p_sub_1403E4B60)(_OWORD *); // [rsp+E8h] [rbp-98h]
  unsigned __int64 v28; // [rsp+F0h] [rbp-90h]
  char v29; // [rsp+F8h] [rbp-88h]
  char v30; // [rsp+F9h] [rbp-87h]
  __int64 n0x10; // [rsp+100h] [rbp-80h]
  __int64 n0x15; // [rsp+108h] [rbp-78h]
  _QWORD *v33; // [rsp+110h] [rbp-70h]
  const char *p_Int_1; // [rsp+118h] [rbp-68h]
  __int64 v35; // [rsp+120h] [rbp-60h]
  __int64 (__fastcall *p_sub_1405048A0_2)(__int64, __int64, __int64); // [rsp+128h] [rbp-58h]
  __int64 (__fastcall *p_sub_1405048A0_3)(__int64, __int64, __int64); // [rsp+130h] [rbp-50h]
  __int64 v38; // [rsp+138h] [rbp-48h]
  __int64 (__fastcall *p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z_1)(); // [rsp+140h] [rbp-40h]
  __int64 v40; // [rsp+148h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4E70_1)(__int64); // [rsp+150h] [rbp-30h]
  _OWORD *(__fastcall *p_sub_1403E4B60_1)(_OWORD *); // [rsp+158h] [rbp-28h]
  unsigned __int64 v43; // [rsp+160h] [rbp-20h]
  char v44; // [rsp+168h] [rbp-18h]
  char v45; // [rsp+169h] [rbp-17h]
  __int64 n0x10_1; // [rsp+170h] [rbp-10h]
  __int64 n0x15_1; // [rsp+178h] [rbp-8h]

  v11 = alloca(0x150);
  __Val_0___[0] = a9;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[1] = "TraceContext";
  __Val_0___[5] = 0;
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[7] = 0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[6] = sub_1403E77F0;
  n0xB0 = 0xB0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v18 = a10;
  n0xA8 = 0xA8;
  p_Int = "Int";
  v30 = 0;
  v20 = *a10;
  v33 = a11;
  p_sub_1405048A0 = sub_1405048A0;
  p_sub_1405048A0_1 = sub_1405048A0;
  v23 = 0;
  p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z = FH4::HandlerMap4::iterator::operator==;
  v25 = 0;
  p_sub_1403E4E70 = sub_1403E4E70;
  p_sub_1403E4B60 = sub_1403E4B60;
  v28 = 0xFFFFFFFFFFFFFFFFuLL;
  v29 = 0;
  n0x10 = 0x10;
  n0x15 = 0x15;
  p_Int_1 = "Int";
  v45 = 0;
  v35 = *a11;
  LODWORD(v13) = a6;
  p_sub_1405048A0_2 = sub_1405048A0;
  p_sub_1405048A0_3 = sub_1405048A0;
  v38 = 0;
  p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z_1 = FH4::HandlerMap4::iterator::operator==;
  v40 = 0;
  p_sub_1403E4E70_1 = sub_1403E4E70;
  p_sub_1403E4B60_1 = sub_1403E4B60;
  v43 = 0xFFFFFFFFFFFFFFFFuLL;
  v44 = 0;
  n0x10_1 = 0x10;
  n0x15_1 = 0x15;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 3u, a5, v13, a7, a8);
}

// --- End Function: sub_146C1A480 (0x146C1A480) ---

// --- Function: sub_14747A5F0 (0x14747A5F0) ---
unsigned __int64 __fastcall sub_14747A5F0(unsigned __int64 *a1, _QWORD *a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5; // r15
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r14
  unsigned __int64 allocSize; // r14
  __int64 v13; // rax
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // r12
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // r8
  _QWORD *v18; // rcx
  unsigned __int64 v19; // rbx
  unsigned __int64 i; // rbp
  _QWORD *v21; // rcx
  unsigned __int64 result; // rax

  v4 = (__int64)a2 - *a1;
  v5 = (__int64)(a1[1] - *a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = v5 + 1;
  v9 = (__int64)(a1[2] - *a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_25;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  allocSize = 0x10 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_25:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_23;
  v14 = (v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_13:
  v15 = (v4 & 0xFFFFFFFFFFFFFFF0uLL) + v14;
  *(_QWORD *)v15 = *(_QWORD *)a3;
  sub_14035B160((void **)(v15 + 8), (const void **)(a3 + 8));
  v16 = a1[1];
  v17 = v14;
  v18 = (_QWORD *)*a1;
  if ( a2 != (_QWORD *)v16 )
  {
    sub_140B8EF80(v18, a2, v14, a1);
    v16 = a1[1];
    v17 = v15 + 0x10;
    v18 = a2;
  }
  sub_140B8EF80(v18, v16, v17, a1);
  v19 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v19 != i; v19 += 0x10LL )
      sub_140370D10((_QWORD *)(v19 + 8));
    v21 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
      goto LABEL_21;
    if ( (unsigned __int64)v21 - v21[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v21 = (_QWORD *)v21[0xFFFFFFFF];
LABEL_21:
      sub_1402A3D30(v21);
      goto LABEL_22;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  *a1 = v14;
  result = v15;
  a1[1] = v14 + 0x10 * v8;
  a1[2] = allocSize + v14;
  return result;
}

// --- End Function: sub_14747A5F0 (0x14747A5F0) ---

// --- Function: sub_14747B6F0 (0x14747B6F0) ---
void __fastcall sub_14747B6F0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  const void *v6; // rdi

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 0x19) )
  {
    do
    {
      sub_14747B6F0(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      sub_140370E60((__int64)v6 + 0x20);
      sub_1403A3120(a2, v6, 0x38u);
    }
    while ( !*((_BYTE *)v3 + 0x19) );
  }
}

// --- End Function: sub_14747B6F0 (0x14747B6F0) ---

// --- Function: sub_14747C610 (0x14747C610) ---
char *__fastcall sub_14747C610(__int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // r10
  char *result; // rax
  unsigned __int64 v7; // rsi
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // r8
  __int64 v12; // r12
  char *v13; // r15
  unsigned __int64 v14; // rdx
  char *v15; // rcx

  v3 = *(_QWORD **)(a1 + 8);
  result = *(char **)a1;
  v7 = ((__int64)v3 - *(_QWORD *)a1) >> 3;
  if ( a2 >= v7 )
  {
    if ( a2 > v7 )
    {
      v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)result) >> 3;
      if ( a2 <= v9 )
      {
        result = (char *)sub_14034F880(v3, a2 - v7, a3);
        *(_QWORD *)(a1 + 8) = result;
      }
      else
      {
        v10 = 0x1FFFFFFFFFFFFFFFLL;
        if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
          unknown_libname_10();
        v11 = v9 >> 1;
        if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
        {
          v10 = v11 + v9;
          if ( v11 + v9 < a2 )
            v10 = a2;
        }
        v12 = 8 * v10;
        v13 = (char *)sub_140391AB0(a1, 8 * v10);
        v14 = a2 - v7;
        v15 = &v13[8 * v7];
        if ( *a3 )
        {
          for ( ; v14; --v14 )
          {
            *(_QWORD *)v15 = *a3;
            v15 += 8;
          }
        }
        else
        {
          memset(v15, 0, 8 * v14);
        }
        memmove(v13, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
        if ( *(_QWORD *)a1 )
          sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
        *(_QWORD *)a1 = v13;
        *(_QWORD *)(a1 + 8) = &v13[8 * a2];
        result = &v13[v12];
        *(_QWORD *)(a1 + 0x10) = &v13[v12];
      }
    }
  }
  else
  {
    result += 8 * a2;
    *(_QWORD *)(a1 + 8) = result;
  }
  return result;
}

// --- End Function: sub_14747C610 (0x14747C610) ---

// --- Function: sub_14747D980 (0x14747D980) ---
unsigned __int64 __fastcall sub_14747D980(_QWORD *a1, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v3; // rbp
  unsigned __int64 v4; // rsi
  __int64 i; // r14
  __int64 v13; // rdi
  __int64 v14; // rdi

  v3 = a1[3];
  v4 = v3 & (a3 >> 7);
  _XMM7 = a3 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  for ( i = 0; ; v4 = v3 & (i + v4) )
  {
    _XMM6 = *(_OWORD *)(v4 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
      break;
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      return 0xFFFFFFFFFFFFFFFFuLL;
    i += 0x10;
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v13, _EBX);
    v14 = v3 & (v4 + v13);
    if ( !(unsigned int)sub_1403E4780((unsigned __int8 **)(a1[1] + 0x10 * v14), a2) )
      return v14;
    _EBX &= _EBX - 1;
    if ( !_EBX )
      goto LABEL_5;
  }
}

// --- End Function: sub_14747D980 (0x14747D980) ---

// --- Function: sub_14747DB80 (0x14747DB80) ---
char __fastcall sub_14747DB80(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14)
{
  void *v18; // rsp
  __int64 v20; // [rsp+18h] [rbp-2B8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-2A0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-248h]
  __int64 n0xB0; // [rsp+90h] [rbp-240h]
  __int64 n0xA8; // [rsp+98h] [rbp-238h]
  __int64 v25; // [rsp+A0h] [rbp-230h] BYREF

  v18 = alloca(0x2A0);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_14747E440((unsigned int)&v25, a10, a11, a12, a13, a14);
  LODWORD(v20) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 6u, a5, v20, a7, a8);
}

// --- End Function: sub_14747DB80 (0x14747DB80) ---

// --- Function: FindOrInsertHashMapEntry (0x14747EA90) ---
// Finds an entry in a custom hash map based on a key (string object) and derived
// hash, or inserts the key and associated value data if not found.  Uses a hash
// map structure with separate control and data blocks. Probing is accelerated
// using SIMD instructions to compare the low 7 bits of the derived hash against 16
// control bytes at a time.  @param pHashMap Pointer to the hash map structure.
// @param pResultPair Output pointer to a structure receiving the result:
// {pointer_to_control_entry, pointer_to_data_entry, inserted_flag (byte)}. @param
// ppKeyString Pointer to the key (string object) used for comparison via
// `sub_1403DFBE0`. @param derivedHash A hash value derived from the original key.
// @param comparisonContext Context parameter, potentially unused or passed down.
// @param pppKeyString Pointer to the pointer to the key string object, used during
// insertion by `sub_1403577A0`. @param pValueData Pointer to the value data to be
// inserted if the key is not found (copied by `sub_14721B460`). @return Pointer to
// the output result structure `pResultPair`.
_OWORD *__fastcall FindOrInsertHashMapEntry(
        __int64 *a1,
        __int64 mapLookupResult,
        _QWORD *p_pStructNameStringObj,
        unsigned __int64 a4,
        int a5,
        __int64 **p_p_pStructNameStringObj,
        __int64 *p_copiedStructData)
{
  __int64 v7; // rbp
  __int64 v8; // r14
  __int64 v9; // rsi
  __int64 *v14; // r15
  __int64 v18; // rdi
  __int64 v19; // rdi
  __int64 v22; // rcx
  _OWORD *mapLookupResult_1; // rax
  __int64 v24; // rsi
  _QWORD *v25; // rdi
  __int64 copiedStructData; // rbx
  __int128 v27; // [rsp+20h] [rbp-68h]

  v7 = a1[3];
  v8 = 0;
  v9 = v7 & (a4 >> 7);
  _XMM7 = a4 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    v14 = a1 + 1;
    _XMM6 = *(_OWORD *)(v9 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
      break;
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      goto LABEL_9;
    v8 += 0x10;
    v9 = v7 & (v8 + v9);
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v18, _EBX);
    v19 = v7 & (v9 + v18);
    if ( !(unsigned int)sub_1403E4780((unsigned __int8 **)(*v14 + 0x48 * v19), p_pStructNameStringObj) )
      break;
    _EBX &= _EBX - 1;
    if ( !_EBX )
      goto LABEL_5;
  }
  if ( v19 != 0xFFFFFFFFFFFFFFFFuLL )
  {
    *(_QWORD *)&v27 = v19 + *a1;
    v22 = *v14 + 0x48 * v19;
    mapLookupResult_1 = (_OWORD *)mapLookupResult;
    *(_BYTE *)(mapLookupResult + 0x10) = 0;
    goto LABEL_10;
  }
LABEL_9:
  v24 = sub_1474D2320(a1, a4);
  v25 = (_QWORD *)(0x48 * v24 + *v14);
  copiedStructData = *p_copiedStructData;
  sub_14035B140(v25, *p_p_pStructNameStringObj);
  sub_147481E00(v25 + 1, copiedStructData);
  *(_BYTE *)(v24 + *a1) = a4 & 0x7F;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v24 - 0x10)) + *a1 + 1) = a4 & 0x7F;
  mapLookupResult_1 = (_OWORD *)mapLookupResult;
  *(_QWORD *)&v27 = v24 + *a1;
  v22 = 0x48 * v24 + *v14;
  *(_BYTE *)(mapLookupResult + 0x10) = 1;
LABEL_10:
  *((_QWORD *)&v27 + 1) = v22;
  *mapLookupResult_1 = v27;
  return mapLookupResult_1;
}

// --- End Function: FindOrInsertHashMapEntry (0x14747EA90) ---

// --- Function: sub_14747EFF0 (0x14747EFF0) ---
unsigned __int64 *__fastcall sub_14747EFF0(__int64 *a1, unsigned __int64 *a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // r10
  unsigned __int64 v11; // rdi
  __int64 v12; // rcx
  __int64 v16; // rcx
  unsigned __int64 v17; // rcx
  _QWORD *v18; // r8
  unsigned __int64 v21; // rdx

  v4 = a1[3];
  v5 = v4 & (a4 >> 7);
  _XMM2 = a4 & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  v11 = 0;
  while ( 1 )
  {
    v12 = *a1;
    _XMM1 = *(_OWORD *)(*a1 + v5);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = v4 + v12;
      return a2;
    }
    v11 += 0x10LL;
    v5 = v4 & (v11 + v5);
    if ( v11 > v4 )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v16, _EAX);
    v17 = v4 & (v5 + v16);
    v18 = (_QWORD *)(a1[1] + 0x18 * v17);
    if ( *v18 == *a3 && v18[1] == a3[1] )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v12 = *a1;
      goto LABEL_7;
    }
  }
  v21 = v17 + *a1;
  a2[1] = (unsigned __int64)v18;
  *a2 = v21;
  return a2;
}

// --- End Function: sub_14747EFF0 (0x14747EFF0) ---

// --- Function: sub_14747F0E0 (0x14747F0E0) ---
_OWORD *__fastcall sub_14747F0E0(_QWORD *a1, _OWORD *a2, __int64 *a3)
{
  __int64 v3; // r10
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx
  __int64 i; // rdx
  __int64 v9; // rax
  __int64 v10; // rbp
  unsigned __int128 v11; // rax
  unsigned __int64 v12; // r12
  __int64 v13; // rsi
  __int64 v19; // rdi
  __int64 v20; // rdi
  _OWORD *result; // rax
  __int128 v24; // [rsp+20h] [rbp-68h]

  v3 = *a3;
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v6;
  while ( *(_BYTE *)(v3 + v6) );
  v7 = 0;
  for ( i = 0xCBF29CE484222325uLL; v7 < v6; i = 0x100000001B3LL * (v9 ^ i) )
  {
    v9 = *(unsigned __int8 *)(v7 + v3);
    ++v7;
  }
  v10 = a1[3];
  v11 = (unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v12 = 0;
  v13 = v10 & (((_QWORD)v11 + *((_QWORD *)&v11 + 1)) >> 7);
  _XMM7 = ((_BYTE)v11 + BYTE8(v11)) & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v13 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
      break;
LABEL_9:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *(_QWORD *)&v24 = *a1 + a1[3];
      goto LABEL_14;
    }
    v12 += 0x10LL;
    v13 = v10 & (v12 + v13);
    if ( v12 > a1[3] )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v19, _EBX);
    v20 = v10 & (v13 + v19);
    if ( !(unsigned int)sub_1403E4780((unsigned __int8 **)(0x10 * v20 + a1[1]), a3) )
      break;
    _EBX &= _EBX - 1;
    if ( !_EBX )
      goto LABEL_9;
  }
  *(_QWORD *)&v24 = v20 + *a1;
  *((_QWORD *)&v24 + 1) = 0x10 * v20 + a1[1];
LABEL_14:
  result = a2;
  *a2 = v24;
  return result;
}

// --- End Function: sub_14747F0E0 (0x14747F0E0) ---

// --- Function: sub_14747F260 (0x14747F260) ---
_QWORD *__fastcall sub_14747F260(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // r15
  unsigned __int64 v6; // rsi
  __int64 v14; // rdi
  __int64 v15; // rdi
  _QWORD *v19; // [rsp+90h] [rbp+18h]

  v19 = a3;
  v4 = a1[3];
  v5 = 0;
  v6 = v4 & (a4 >> 7);
  _XMM7 = a4 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v6 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
      break;
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = *a1 + a1[3];
      return a2;
    }
    v5 += 0x10LL;
    v6 = v4 & (v5 + v6);
    if ( v5 > a1[3] )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v14, _EBX);
    v15 = v4 & (v6 + v14);
    if ( !(unsigned int)sub_1403E4780((unsigned __int8 **)(0x48 * v15 + a1[1]), a3) )
      break;
    a3 = v19;
    _EBX &= _EBX - 1;
    if ( !_EBX )
      goto LABEL_5;
  }
  *a2 = v15 + *a1;
  a2[1] = 0x48 * v15 + a1[1];
  return a2;
}

// --- End Function: sub_14747F260 (0x14747F260) ---

// --- Function: sub_14747F390 (0x14747F390) ---
_QWORD *__fastcall sub_14747F390(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 *v3; // rdi
  __int64 v7; // r15
  __int64 *v8; // rbx
  __int64 v9; // rbx
  __int64 v11; // [rsp+20h] [rbp-38h] BYREF
  int v12; // [rsp+28h] [rbp-30h]

  v3 = *(__int64 **)a1;
  v7 = sub_140391AB0(a1, 0x38u);
  sub_140362C80(v7 + 0x20, a3);
  *(_QWORD *)(v7 + 0x30) = a3[2];
  *(_QWORD *)v7 = v3;
  *(_QWORD *)(v7 + 8) = v3;
  *(_QWORD *)(v7 + 0x10) = v3;
  *(_WORD *)(v7 + 0x18) = 0;
  v8 = *(__int64 **)a1;
  v12 = 0;
  v9 = v8[1];
  v11 = v9;
  while ( !*(_BYTE *)(v9 + 0x19) )
  {
    v11 = v9;
    if ( sub_140380650((_QWORD *)(v7 + 0x20), (_QWORD *)(v9 + 0x20)) )
    {
      v9 = *(_QWORD *)v9;
      v12 = 1;
    }
    else
    {
      v9 = *(_QWORD *)(v9 + 0x10);
      v12 = 0;
    }
  }
  if ( *(_QWORD *)(a1 + 8) == 0x492492492492492LL )
    unknown_libname_7();
  *a2 = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
          (__int64 **)a1,
          (__int64)&v11,
          v7);
  return a2;
}

// --- End Function: sub_14747F390 (0x14747F390) ---

// --- Function: sub_14747F5C0 (0x14747F5C0) ---
__int64 __fastcall sub_14747F5C0(__int64 *a1, __int64 a2, _QWORD *a3)
{
  int v6; // eax
  __int64 v7; // rdi
  __int64 v8; // r15
  __int64 v9; // rsi
  unsigned __int128 v10; // rax
  __int64 v11; // r12
  __int64 v12; // r9
  __int64 v18; // r10
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v23; // rcx
  __int64 v24; // rax
  __int128 v25; // xmm0
  char v26; // r12
  __int64 v27; // r8
  __int64 v28; // rcx
  __int64 result; // rax
  __int128 v30; // [rsp+20h] [rbp-38h]

  v6 = psub_1403360E0(0xFFFFFFFF, (__int64)a3, 0x10);
  v7 = a1[3];
  v8 = *a1;
  v9 = 0;
  v10 = (unsigned int)~v6 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v11 = *((_QWORD *)&v10 + 1) + v10;
  v12 = v7 & ((*((_QWORD *)&v10 + 1) + (_QWORD)v10) >> 7);
  _XMM2 = (BYTE8(v10) + (_BYTE)v10) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    _XMM1 = *(_OWORD *)(v8 + v12);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      goto LABEL_11;
    v9 += 0x10;
    v12 = v7 & (v9 + v12);
  }
  v18 = a1[1];
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v19, _EAX);
    v20 = v7 & (v12 + v19);
    if ( *(_QWORD *)(v18 + 0x18 * v20) == *a3 && *(_QWORD *)(v18 + 0x18 * v20 + 8) == a3[1] )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
      goto LABEL_7;
  }
  if ( v20 != 0xFFFFFFFFFFFFFFFFuLL )
  {
    *(_BYTE *)(a2 + 0x10) = 0;
    *(_QWORD *)&v30 = v20 + v8;
    v23 = v18 + 0x18 * v20;
    goto LABEL_12;
  }
LABEL_11:
  v24 = sub_1422DC6B0(a1, v11);
  v25 = *(_OWORD *)a3;
  *(_BYTE *)(a2 + 0x10) = 1;
  v26 = v11 & 0x7F;
  v27 = 0x18 * v24;
  v28 = a1[1];
  *(_OWORD *)(v27 + v28) = v25;
  *(_QWORD *)(v27 + v28 + 0x10) = 0;
  *(_BYTE *)(v24 + *a1) = v26;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v24 - 0x10)) + *a1 + 1) = v26;
  *(_QWORD *)&v30 = v24 + *a1;
  v23 = 0x18 * v24 + a1[1];
LABEL_12:
  result = a2;
  *((_QWORD *)&v30 + 1) = v23;
  *(_OWORD *)a2 = v30;
  return result;
}

// --- End Function: sub_14747F5C0 (0x14747F5C0) ---

// --- Function: sub_14747F760 (0x14747F760) ---
__int64 __fastcall sub_14747F760(__int64 *a1, __int64 a2, _QWORD *a3)
{
  int v6; // eax
  __int64 v7; // rbx
  __int64 v8; // r15
  __int64 v9; // rdi
  unsigned __int128 v10; // rax
  __int64 v11; // r12
  __int64 v12; // r9
  __int64 v18; // r10
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v23; // rcx
  __int64 v24; // rbx
  __int64 v25; // rcx
  __int64 v26; // rax
  char v27; // r12
  __int64 result; // rax
  __int128 v29; // [rsp+20h] [rbp-38h]

  v6 = psub_1403360E0(0xFFFFFFFF, (__int64)a3, 0x10);
  v7 = a1[3];
  v8 = *a1;
  v9 = 0;
  v10 = (unsigned int)~v6 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v11 = *((_QWORD *)&v10 + 1) + v10;
  v12 = v7 & ((*((_QWORD *)&v10 + 1) + (_QWORD)v10) >> 7);
  _XMM2 = (BYTE8(v10) + (_BYTE)v10) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    _XMM1 = *(_OWORD *)(v8 + v12);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      goto LABEL_11;
    v9 += 0x10;
    v12 = v7 & (v9 + v12);
  }
  v18 = a1[1];
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v19, _EAX);
    v20 = v7 & (v12 + v19);
    if ( *(_QWORD *)(v18 + 0x18 * v20) == *a3 && *(_QWORD *)(v18 + 0x18 * v20 + 8) == a3[1] )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
      goto LABEL_7;
  }
  if ( v20 != 0xFFFFFFFFFFFFFFFFuLL )
  {
    *(_BYTE *)(a2 + 0x10) = 0;
    *(_QWORD *)&v29 = v20 + v8;
    v23 = v18 + 0x18 * v20;
    goto LABEL_12;
  }
LABEL_11:
  v24 = sub_1474D1F90(a1, v11);
  v25 = a1[1];
  *(_OWORD *)(0x18 * v24 + v25) = *(_OWORD *)a3;
  sub_14035B3E0((_QWORD *)(0x18 * v24 + v25 + 0x10));
  v26 = *a1;
  v27 = v11 & 0x7F;
  *(_BYTE *)(a2 + 0x10) = 1;
  *(_BYTE *)(v24 + v26) = v27;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v24 - 0x10)) + *a1 + 1) = v27;
  *(_QWORD *)&v29 = v24 + *a1;
  v23 = 0x18 * v24 + a1[1];
LABEL_12:
  result = a2;
  *((_QWORD *)&v29 + 1) = v23;
  *(_OWORD *)a2 = v29;
  return result;
}

// --- End Function: sub_14747F760 (0x14747F760) ---

// --- Function: sub_14747FA70 (0x14747FA70) ---
__int64 __fastcall sub_14747FA70(_QWORD *a1, __int64 a2, const char **a3)
{
  const char *v3; // r11
  unsigned int n0x9E37; // r10d
  char v8; // al
  int v9; // ecx
  unsigned __int128 v10; // rax
  __int64 v11; // r12
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rbx
  __int64 v16; // rdi
  char v17; // r12
  __int64 v18; // rcx
  __int128 v20; // [rsp+20h] [rbp-28h]

  v3 = *a3;
  n0x9E37 = 0x9E37;
  v8 = **a3;
  if ( v8 )
  {
    do
    {
      ++v3;
      v9 = v8 + 0x20;
      if ( (unsigned __int8)(v8 - 0x41) > 0x19u )
        v9 = v8;
      n0x9E37 = ((0x401 * (n0x9E37 + v9)) >> 6) ^ (0x401 * (n0x9E37 + v9));
      v8 = *v3;
    }
    while ( *v3 );
  }
  v10 = 0x8001 * ((9 * n0x9E37) ^ ((9 * n0x9E37) >> 0xB)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v11 = *((_QWORD *)&v10 + 1) + v10;
  v12 = sub_14747DA80(a1, a3, *((_QWORD *)&v10 + 1) + v10);
  if ( v12 == 0xFFFFFFFFFFFFFFFFuLL )
  {
    v13 = sub_1474D21F0(a1, v11);
    v14 = 0x20 * v13;
    v15 = 0x20 * v13 + a1[1];
    v16 = v13;
    sub_14035B140((_QWORD *)v15, (__int64 *)a3);
    *(_QWORD *)(v15 + 8) = 0;
    v17 = v11 & 0x7F;
    *(_BYTE *)(a2 + 0x10) = 1;
    *(_OWORD *)(v15 + 0x10) = 0;
    *(_BYTE *)(v16 + *a1) = v17;
    *(_BYTE *)((a1[3] & 0xFLL) + (a1[3] & (v16 - 0x10)) + *a1 + 1) = v17;
    *(_QWORD *)&v20 = v16 + *a1;
    *((_QWORD *)&v20 + 1) = v14 + a1[1];
  }
  else
  {
    v18 = v12 + *a1;
    *(_BYTE *)(a2 + 0x10) = 0;
    *((_QWORD *)&v20 + 1) = a1[1] + 0x20 * v12;
    *(_QWORD *)&v20 = v18;
  }
  *(_OWORD *)a2 = v20;
  return a2;
}

// --- End Function: sub_14747FA70 (0x14747FA70) ---

// --- Function: sub_1474810D0 (0x1474810D0) ---
__int64 __fastcall sub_1474810D0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rax
  __int64 result; // rax

  *(_QWORD *)a1 = off_148D30298;
  *(_QWORD *)(a1 + 8) = &unk_1481A06E0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = &unk_1481A06E0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = &unk_1481A06E0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = &unk_1481A06E0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xE0) = 0;
  *(_QWORD *)(a1 + 0xE8) = &unk_1481A06E0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0x128) = 0;
  v2 = allocWithProfilerInfo_w(0x38u);
  *(_QWORD *)v2 = v2;
  *(_QWORD *)(v2 + 8) = v2;
  *(_QWORD *)(v2 + 0x10) = v2;
  *(_WORD *)(v2 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x120) = v2;
  *(_QWORD *)a1 = off_148D30408;
  *(_QWORD *)(a1 + 0x130) = &unk_1481A06E0;
  *(_QWORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_QWORD *)(a1 + 0x170) = 0;
  v3 = allocWithProfilerInfo_w(0x30u);
  *(_QWORD *)v3 = v3;
  *(_QWORD *)(v3 + 8) = v3;
  *(_QWORD *)(v3 + 0x10) = v3;
  *(_WORD *)(v3 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x168) = v3;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0;
  *(_QWORD *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0;
  *(_QWORD *)(a1 + 0x1B8) = 0;
  *(_QWORD *)(a1 + 0x1C0) = 0;
  *(_QWORD *)(a1 + 0x1C8) = 0;
  *(_QWORD *)(a1 + 0x1D0) = 0;
  *(_QWORD *)(a1 + 0x1D8) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x1E0) = 0;
  sub_14035B3E0((_QWORD *)(a1 + 0x1E8));
  *(_DWORD *)(a1 + 0x1F0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x1F4) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x200) = 0;
  *(_QWORD *)(a1 + 0x208) = 0;
  *(_QWORD *)(a1 + 0x210) = 0;
  *(_QWORD *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0;
  *(_QWORD *)(a1 + 0x228) = 0;
  *(_QWORD *)(a1 + 0x230) = 0;
  *(_QWORD *)(a1 + 0x238) = 0;
  *(_QWORD *)(a1 + 0x240) = 0;
  *(_QWORD *)(a1 + 0x248) = 0;
  *(_QWORD *)(a1 + 0x250) = 0;
  *(_QWORD *)(a1 + 0x258) = 0;
  *(_QWORD *)(a1 + 0x260) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = 0;
  *(_QWORD *)(a1 + 0x278) = 0;
  *(_QWORD *)(a1 + 0x280) = 0;
  *(_QWORD *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x290) = 0;
  *(_QWORD *)(a1 + 0x298) = 0;
  *(_QWORD *)(a1 + 0x2A0) = 0;
  *(_QWORD *)(a1 + 0x2A8) = 0;
  *(_QWORD *)(a1 + 0x2B0) = 0;
  *(_QWORD *)(a1 + 0x2B8) = 0;
  *(_QWORD *)(a1 + 0x2C0) = 0;
  *(_QWORD *)(a1 + 0x2C8) = 0;
  *(_DWORD *)(a1 + 0x2D0) = 0;
  *(_QWORD *)(a1 + 0x2D8) = 0;
  *(_QWORD *)(a1 + 0x2E0) = 0;
  *(_QWORD *)(a1 + 0x2E8) = 0;
  *(_QWORD *)(a1 + 0x2F0) = 0;
  *(_QWORD *)(a1 + 0x2F8) = 0;
  *(_QWORD *)(a1 + 0x300) = 0;
  v4 = allocWithProfilerInfo_w(0x28u);
  *(_QWORD *)v4 = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)(v4 + 0x10) = v4;
  *(_WORD *)(v4 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x2F8) = v4;
  *(_QWORD *)(a1 + 0x308) = 0;
  *(_QWORD *)(a1 + 0x310) = 0;
  v5 = allocWithProfilerInfo_w(0x28u);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 0x10) = v5;
  *(_WORD *)(v5 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x308) = v5;
  *(_DWORD *)(a1 + 0x318) = 0;
  *(_QWORD *)(a1 + 0x320) = 0;
  *(_QWORD *)(a1 + 0x328) = 0;
  v6 = (_QWORD *)allocWithProfilerInfo_w(0x20u);
  *v6 = v6;
  v6[1] = v6;
  *(_QWORD *)(a1 + 0x320) = v6;
  *(_QWORD *)(a1 + 0x330) = 0;
  *(_QWORD *)(a1 + 0x338) = 0;
  *(_QWORD *)(a1 + 0x340) = 0;
  *(_QWORD *)(a1 + 0x348) = 7;
  *(_QWORD *)(a1 + 0x350) = 8;
  *(_DWORD *)(a1 + 0x318) = 0x3F800000;
  std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
    (unsigned __int64 **)(a1 + 0x330),
    0x10u,
    *(_QWORD *)(a1 + 0x320));
  *(_DWORD *)(a1 + 0x358) = 0;
  *(_QWORD *)(a1 + 0x360) = 0;
  *(_QWORD *)(a1 + 0x368) = 0;
  v7 = (_QWORD *)allocWithProfilerInfo_w(0x20u);
  *v7 = v7;
  v7[1] = v7;
  *(_QWORD *)(a1 + 0x360) = v7;
  *(_QWORD *)(a1 + 0x370) = 0;
  *(_QWORD *)(a1 + 0x378) = 0;
  *(_QWORD *)(a1 + 0x380) = 0;
  *(_QWORD *)(a1 + 0x388) = 7;
  *(_QWORD *)(a1 + 0x390) = 8;
  *(_DWORD *)(a1 + 0x358) = 0x3F800000;
  std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
    (unsigned __int64 **)(a1 + 0x370),
    0x10u,
    *(_QWORD *)(a1 + 0x360));
  *(_BYTE *)(a1 + 0x398) = 0;
  result = a1;
  if ( BYTE2(qword_149B501D6) )
    *(_BYTE *)(a1 + 0x1F4) = 1;
  return result;
}

// --- End Function: sub_1474810D0 (0x1474810D0) ---

// --- Function: sub_147481D20 (0x147481D20) ---
__int64 __fastcall sub_147481D20(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 0;
  result = a1;
  *(_OWORD *)(a1 + 4) = 0;
  return result;
}

// --- End Function: sub_147481D20 (0x147481D20) ---

// --- Function: sub_147481D40 (0x147481D40) ---
__int64 __fastcall sub_147481D40(__int64 a1)
{
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 0xC) = 0;
  return a1;
}

// --- End Function: sub_147481D40 (0x147481D40) ---

// --- Function: sub_147481D50 (0x147481D50) ---
_DWORD *__fastcall sub_147481D50(_DWORD *a1)
{
  *a1 = 0;
  a1[7] = 0;
  return a1;
}

// --- End Function: sub_147481D50 (0x147481D50) ---

// --- Function: sub_147481E00 (0x147481E00) ---
__int64 __fastcall sub_147481E00(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rsi
  int *v4; // rbx
  int v5; // ecx
  int v6; // r8d
  __int64 v7; // rbp
  int v8; // eax
  int v9; // edi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // rcx
  __int64 v16; // rax
  _DWORD *v17; // rax
  _DWORD *i; // r8
  int v19; // ecx
  int v21; // [rsp+50h] [rbp+8h] BYREF

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v2 = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  *(_BYTE *)(a1 + 0x20) = *(_BYTE *)(a2 + 0x20);
  *(_QWORD *)(a1 + 0x28) = *(_QWORD *)(a2 + 0x28);
  *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
  v4 = *(int **)(a2 + 0x38);
  v5 = *(_DWORD *)(((unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL) - 4);
  v6 = v5 & 0x7FFFFFFF;
  v7 = (unsigned int)v4[0xFFFFFFFF];
  LODWORD(v7) = v7 & 0x7FFFFFFF;
  v8 = 4 * v5;
  v9 = (v5 & 0x7FFFFFFF) + v7;
  if ( v5 >= 0 )
    v10 = (unsigned __int64)v8 >> 2;
  else
    LODWORD(v10) = *(_DWORD *)(v2 + v8);
  v11 = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
  if ( v9 != (_DWORD)v10 )
  {
    v12 = 0;
    v21 = v6 + v7;
    if ( v5 )
      v12 = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
    v13 = sub_1403093C0(a1 + 0x38, v12, v6, &v21, 4u, 0);
    *(_QWORD *)(a1 + 0x38) = v13;
    v11 = v13;
    if ( !v13 )
    {
      *(_QWORD *)(a1 + 0x38) = v2;
      goto LABEL_12;
    }
    LODWORD(v10) = v21;
  }
  v14 = 4 * v9;
  *(_DWORD *)(v11 - 4) = v9;
  if ( 4LL * (int)v10 >= (unsigned __int64)(v14 + 4) )
  {
    *(_DWORD *)(v11 - 4) = v9 | 0x80000000;
    *(_DWORD *)(v14 + v11) = v10;
  }
LABEL_12:
  v15 = *(_QWORD *)(a1 + 0x38);
  v16 = *(unsigned int *)(v15 - 4);
  LODWORD(v16) = v16 & 0x7FFFFFFF;
  v17 = (_DWORD *)(v15 + 4 * (v16 - (unsigned int)v7));
  for ( i = &v17[v7]; v17 != i; ++v17 )
  {
    v19 = *v4++;
    *v17 = v19;
  }
  return a1;
}

// --- End Function: sub_147481E00 (0x147481E00) ---

// --- Function: sub_147485310 (0x147485310) ---
void *__fastcall sub_147485310(__int64 a1)
{
  __int64 v2; // rsi
  __int64 v3; // r14
  _QWORD *v4; // rdi
  void *result; // rax

  if ( *(_QWORD *)(a1 + 0x18) )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      if ( *(char *)(v2 + *(_QWORD *)a1) >= 0 )
      {
        v4 = (_QWORD *)(v3 + *(_QWORD *)(a1 + 8));
        vector_dword_set_size(v4 + 8, 0, 0);
        sub_140370D10(v4);
      }
      ++v2;
      v3 += 0x48;
    }
    while ( v2 != *(_QWORD *)(a1 + 0x18) );
    sub_1402A3D30(*(const void **)a1);
    result = &unk_1481A06E0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
    *(_QWORD *)(a1 + 0x18) = 0;
    *(_QWORD *)(a1 + 0x30) = 0;
    *(_QWORD *)a1 = &unk_1481A06E0;
  }
  return result;
}

// --- End Function: sub_147485310 (0x147485310) ---

// --- Function: sub_1474858F0 (0x1474858F0) ---
__int64 __fastcall sub_1474858F0(__int64 a1)
{
  _QWORD *v2; // rsi
  _QWORD *i; // rbx
  __int64 v4; // rax
  const void *v5; // rcx
  const void *v6; // rcx
  const void *v7; // rcx
  const void *v8; // rcx
  const void *v9; // rcx
  const void *v10; // rcx
  const void *v11; // rcx
  const void *v12; // rcx
  const void *v13; // rcx
  const void *v14; // rcx
  const void *v15; // rcx
  const void *v16; // rcx
  const void *v17; // rcx
  const void *v18; // rcx
  const void *v19; // rcx
  const void *v20; // rcx
  const void *v21; // rcx
  const void *v22; // rcx
  const void *v23; // rcx
  const void *v24; // rcx
  const void *v25; // rcx
  const void *v26; // rcx
  const void *v27; // rcx
  const void *v28; // rcx
  const void *v29; // rcx
  const void *v30; // rcx
  const void *v31; // rcx
  unsigned int Error; // eax
  unsigned int v33; // eax
  unsigned int v34; // eax
  unsigned int v35; // eax
  _QWORD *v36; // rbx
  const void *v37; // rcx
  _QWORD *v38; // rbx
  const void *v39; // rcx
  _QWORD *v40; // rcx
  const void *v41; // rcx

  *(_QWORD *)a1 = off_148D30408;
  v2 = *(_QWORD **)(a1 + 0x180);
  for ( i = *(_QWORD **)(a1 + 0x178); i != v2; ++i )
  {
    if ( *i )
      (**(void (__fastcall ***)(_QWORD, __int64))*i)(*i, 1);
  }
  v4 = *(_QWORD *)(a1 + 0x178);
  if ( v4 != *(_QWORD *)(a1 + 0x180) )
    *(_QWORD *)(a1 + 0x180) = v4;
  v5 = *(const void **)(a1 + 0x1F8);
  if ( v5 )
  {
    sub_1402A3D30(v5);
    *(_QWORD *)(a1 + 0x1F8) = 0;
  }
  v6 = *(const void **)(a1 + 0x200);
  if ( v6 )
  {
    sub_1402A3D30(v6);
    *(_QWORD *)(a1 + 0x200) = 0;
  }
  v7 = *(const void **)(a1 + 0x208);
  if ( v7 )
  {
    sub_1402A3D30(v7);
    *(_QWORD *)(a1 + 0x208) = 0;
  }
  v8 = *(const void **)(a1 + 0x210);
  if ( v8 )
  {
    sub_1402A3D30(v8);
    *(_QWORD *)(a1 + 0x210) = 0;
  }
  v9 = *(const void **)(a1 + 0x218);
  if ( v9 )
  {
    sub_1402A3D30(v9);
    *(_QWORD *)(a1 + 0x218) = 0;
  }
  v10 = *(const void **)(a1 + 0x220);
  if ( v10 )
  {
    sub_1402A3D30(v10);
    *(_QWORD *)(a1 + 0x220) = 0;
  }
  v11 = *(const void **)(a1 + 0x228);
  if ( v11 )
  {
    sub_1402A3D30(v11);
    *(_QWORD *)(a1 + 0x228) = 0;
  }
  v12 = *(const void **)(a1 + 0x230);
  if ( v12 )
  {
    sub_1402A3D30(v12);
    *(_QWORD *)(a1 + 0x230) = 0;
  }
  v13 = *(const void **)(a1 + 0x238);
  if ( v13 )
  {
    sub_1402A3D30(v13);
    *(_QWORD *)(a1 + 0x238) = 0;
  }
  v14 = *(const void **)(a1 + 0x240);
  if ( v14 )
  {
    sub_1402A3D30(v14);
    *(_QWORD *)(a1 + 0x240) = 0;
  }
  v15 = *(const void **)(a1 + 0x248);
  if ( v15 )
  {
    sub_1402A3D30(v15);
    *(_QWORD *)(a1 + 0x248) = 0;
  }
  v16 = *(const void **)(a1 + 0x250);
  if ( v16 )
  {
    sub_1402A3D30(v16);
    *(_QWORD *)(a1 + 0x250) = 0;
  }
  v17 = *(const void **)(a1 + 0x258);
  if ( v17 )
  {
    sub_1402A3D30(v17);
    *(_QWORD *)(a1 + 0x258) = 0;
  }
  v18 = *(const void **)(a1 + 0x260);
  if ( v18 )
  {
    sub_1402A3D30(v18);
    *(_QWORD *)(a1 + 0x260) = 0;
  }
  v19 = *(const void **)(a1 + 0x268);
  if ( v19 )
  {
    sub_1402A3D30(v19);
    *(_QWORD *)(a1 + 0x268) = 0;
  }
  v20 = *(const void **)(a1 + 0x270);
  if ( v20 )
  {
    sub_1402A3D30(v20);
    *(_QWORD *)(a1 + 0x270) = 0;
  }
  v21 = *(const void **)(a1 + 0x278);
  if ( v21 )
  {
    sub_1402A3D30(v21);
    *(_QWORD *)(a1 + 0x278) = 0;
  }
  v22 = *(const void **)(a1 + 0x280);
  if ( v22 )
  {
    sub_1402A3D30(v22);
    *(_QWORD *)(a1 + 0x280) = 0;
  }
  v23 = *(const void **)(a1 + 0x290);
  if ( v23 )
  {
    sub_1402A3D30(v23);
    *(_QWORD *)(a1 + 0x290) = 0;
  }
  v24 = *(const void **)(a1 + 0x298);
  if ( v24 )
  {
    sub_1402A3D30(v24);
    *(_QWORD *)(a1 + 0x298) = 0;
  }
  v25 = *(const void **)(a1 + 0x288);
  if ( v25 )
  {
    sub_1402A3D30(v25);
    *(_QWORD *)(a1 + 0x288) = 0;
  }
  v26 = *(const void **)(a1 + 0x2B0);
  if ( v26 )
  {
    sub_1402A3D30(v26);
    *(_QWORD *)(a1 + 0x2B0) = 0;
  }
  v27 = *(const void **)(a1 + 0x2B8);
  if ( v27 )
  {
    sub_1402A3D30(v27);
    *(_QWORD *)(a1 + 0x2B8) = 0;
  }
  v28 = *(const void **)(a1 + 0x2C0);
  if ( v28 )
  {
    sub_1402A3D30(v28);
    *(_QWORD *)(a1 + 0x2C0) = 0;
  }
  v29 = *(const void **)(a1 + 0x2C8);
  if ( v29 )
  {
    sub_1402A3D30(v29);
    *(_QWORD *)(a1 + 0x2C8) = 0;
  }
  v30 = *(const void **)(a1 + 0x2A0);
  if ( v30 )
  {
    sub_1402A3D30(v30);
    *(_QWORD *)(a1 + 0x2A0) = 0;
  }
  v31 = *(const void **)(a1 + 0x2A8);
  if ( v31 )
  {
    sub_1402A3D30(v31);
    *(_QWORD *)(a1 + 0x2A8) = 0;
  }
  if ( shutdown(*(int *)(a1 + 0x1DC), 2) == 0xFFFFFFFF )
  {
    Error = WSAGetLastError();
    sub_1474CE4C0(Error);
  }
  if ( closesocket(*(int *)(a1 + 0x1DC)) == 0xFFFFFFFF )
  {
    v33 = WSAGetLastError();
    sub_1474CE4C0(v33);
  }
  if ( closesocket(*(int *)(a1 + 0x1D8)) == 0xFFFFFFFF )
  {
    v34 = WSAGetLastError();
    sub_1474CE4C0(v34);
  }
  if ( closesocket(*(int *)(a1 + 0x1F0)) == 0xFFFFFFFF )
  {
    v35 = WSAGetLastError();
    sub_1474CE4C0(v35);
  }
  sub_1402B1960((__int64 *)(a1 + 0x358));
  sub_1402B1960((__int64 *)(a1 + 0x318));
  v36 = *(_QWORD **)(*(_QWORD *)(a1 + 0x308) + 8LL);
  while ( !*((_BYTE *)v36 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *)(a1 + 0x308),
      (std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *)(a1 + 0x308),
      (std::_Tree_node<gte::Logger::Listener *,void *> *)v36[2]);
    v37 = v36;
    v36 = (_QWORD *)*v36;
    sub_1402A3D30(v37);
  }
  sub_1402A3D30(*(const void **)(a1 + 0x308));
  v38 = *(_QWORD **)(*(_QWORD *)(a1 + 0x2F8) + 8LL);
  while ( !*((_BYTE *)v38 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *)(a1 + 0x2F8),
      (std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *)(a1 + 0x2F8),
      (std::_Tree_node<gte::Logger::Listener *,void *> *)v38[2]);
    v39 = v38;
    v38 = (_QWORD *)*v38;
    sub_1402A3D30(v39);
  }
  sub_1402A3D30(*(const void **)(a1 + 0x2F8));
  sub_140370D10((_QWORD *)(a1 + 0x1E8));
  sub_140BA1C30((_QWORD *)(a1 + 0x1C0));
  std::vector<gte::Vector<3,double>>::_Tidy((std::vector<gte::Vector<3,double>> *)(a1 + 0x1A8));
  v40 = *(_QWORD **)(a1 + 0x190);
  if ( v40 )
  {
    if ( ((*(_QWORD *)(a1 + 0x1A0) - (_QWORD)v40) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v40 - v40[0xFFFFFFFF] - 8 > 0x1F )
        goto LABEL_84;
      v40 = (_QWORD *)v40[0xFFFFFFFF];
    }
    sub_1402A3D30(v40);
    *(_QWORD *)(a1 + 0x190) = 0;
    *(_QWORD *)(a1 + 0x198) = 0;
    *(_QWORD *)(a1 + 0x1A0) = 0;
  }
  v41 = *(const void **)(a1 + 0x178);
  if ( v41 )
  {
    if ( ((*(_QWORD *)(a1 + 0x188) - (_QWORD)v41) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_82:
      sub_1402A3D30(v41);
      *(_QWORD *)(a1 + 0x178) = 0;
      *(_QWORD *)(a1 + 0x180) = 0;
      *(_QWORD *)(a1 + 0x188) = 0;
      goto LABEL_83;
    }
    if ( (unsigned __int64)v41 - *((_QWORD *)v41 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v41 = (const void *)*((_QWORD *)v41 + 0xFFFFFFFF);
      goto LABEL_82;
    }
LABEL_84:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_83:
  sub_1409A0230(a1 + 0x168, a1 + 0x168, *(__int64 **)(*(_QWORD *)(a1 + 0x168) + 8LL));
  sub_1402A3D30(*(const void **)(a1 + 0x168));
  sub_147485310(a1 + 0x130);
  return sub_147486090(a1);
}

// --- End Function: sub_1474858F0 (0x1474858F0) ---

// --- Function: sub_147486090 (0x147486090) ---
__int64 __fastcall sub_147486090(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = off_148D30298;
  sub_141FBB160(a1 + 0x120, a1 + 0x120, *(_QWORD *)(*(_QWORD *)(a1 + 0x120) + 8LL));
  sub_1402A3D30(*(const void **)(a1 + 0x120));
  sub_1474851F0(a1 + 0xE8);
  sub_147485160(a1 + 0xB0);
  sub_147485160(a1 + 0x78);
  result = sub_147485290(a1 + 0x40);
  if ( *(_QWORD *)(a1 + 0x20) )
  {
    sub_1402A3D30(*(const void **)(a1 + 8));
    *(_QWORD *)(a1 + 8) = &unk_1481A06E0;
    result = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
    *(_QWORD *)(a1 + 0x18) = 0;
    *(_QWORD *)(a1 + 0x20) = 0;
    *(_QWORD *)(a1 + 0x38) = 0;
  }
  return result;
}

// --- End Function: sub_147486090 (0x147486090) ---

// --- Function: sub_1474893E0 (0x1474893E0) ---
char *__fastcall sub_1474893E0(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  __int64 i; // rbx

  if ( (a2 & 2) != 0 )
  {
    v4 = a1[0xFFFFFFFF];
    for ( i = (__int64)&a1[2 * v4]; v4; --v4 )
    {
      i -= 0x10;
      sub_140370E60(i);
    }
    if ( (a2 & 1) != 0 )
      sub_1402A3D30(a1 + 0xFFFFFFFF);
    return (char *)(a1 + 0xFFFFFFFF);
  }
  else
  {
    sub_140370E60((__int64)a1);
    if ( (a2 & 1) != 0 )
      sub_1402A3D30(a1);
    return (char *)a1;
  }
}

// --- End Function: sub_1474893E0 (0x1474893E0) ---

// --- Function: sub_147489850 (0x147489850) ---
const void *__fastcall sub_147489850(const void *a1, char a2)
{
  sub_1474858F0((__int64)a1);
  if ( (a2 & 1) != 0 )
    sub_1402A3D30(a1);
  return a1;
}

// --- End Function: sub_147489850 (0x147489850) ---

// --- Function: sub_14748FB60 (0x14748FB60) ---
char *__fastcall sub_14748FB60(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // rsi
  unsigned __int64 v8; // r12
  __int64 v9; // r13
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r14
  __int64 v13; // r15
  __int64 n2; // rdx
  __int64 v15; // rdi
  char v16; // cl
  __int64 v17; // rax
  __int64 v18; // rdi
  __int64 v19; // rsi
  __int64 v20; // rbx
  __int64 v21; // rcx
  __int64 v22; // rax
  __int128 v23; // xmm1
  double v24; // xmm0_8
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // r14
  __int64 v28; // r13
  unsigned __int64 v29; // rsi
  __int64 v30; // rax
  bool v31; // cf
  unsigned __int64 allocSize; // rax
  _QWORD *v33; // rax
  __int64 v34; // rdi
  unsigned __int64 v35; // rbx
  __int64 v36; // rbx
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *v37; // rdi
  char *result; // rax
  _QWORD *v39; // rbx
  __int64 v40; // rax
  __int64 v41; // rcx
  __m128i v42; // xmm0
  __int64 v43; // rbx
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *v44; // rbx
  __int64 v45; // rax
  __int64 v46; // rdi
  __int64 v47; // rsi
  unsigned __int64 allocSize_1; // rbx
  void *v49; // rax
  size_t allocSize_2; // r8
  __int64 v51; // rax
  unsigned __int64 v52; // rbx
  __int64 v53; // rax
  unsigned __int64 v54; // rbx
  __int64 v55; // rax
  unsigned __int64 v56; // rbx
  __int64 v57; // rax
  __int64 v58; // r14
  __int64 v59; // rsi
  __int64 v60; // rdi
  __int64 v61; // rbx
  __int64 v62; // rax
  __int64 v63; // rdi
  __int64 v64; // rbx
  __int64 v65; // rax
  unsigned __int64 allocSize_4; // rsi
  void *v67; // rax
  __int64 v68; // rax
  __int64 v69; // rdi
  __int64 v70; // rsi
  unsigned __int64 v71; // rax
  __int64 v72; // rbx
  unsigned __int64 allocSize_3; // rax
  unsigned __int64 v74; // kr10_8
  __int64 v75; // rcx
  __int64 v76; // rax
  __int64 v77; // r14
  __int64 v78; // rsi
  unsigned __int64 v79; // rdi
  unsigned __int64 j; // rbx
  __int64 v81; // rax
  unsigned __int64 v82; // rbx
  __int64 v83; // r13
  __int64 v84; // r15
  __int64 v85; // rsi
  __int64 v86; // r12
  unsigned __int64 *v87; // r14
  unsigned __int64 v88; // rax
  unsigned __int64 v89; // rdx
  _QWORD *v90; // rbx
  __int64 v91; // r8
  __int64 v92; // rcx
  __m128i v93; // xmm0
  signed __int64 epi64; // rdi
  __int64 v95; // rax
  __int64 v96; // rcx
  __int64 v97; // rsi
  __int64 v98; // r14
  unsigned __int64 v99; // rdx
  __int64 v100; // rcx
  _QWORD *v101; // rbx
  unsigned __int64 v102; // r8
  __int64 v103; // rax
  __m128i v104; // xmm0
  signed __int64 v105; // r15
  unsigned __int64 v106; // rdi
  __int64 v107; // rax
  __int64 v108; // rbx
  __int64 v109; // rbx
  const char *v110; // rbx
  const char *v111; // rax
  const char *v112; // rbx
  const char *v113; // rax
  const char *v114; // rbx
  const char *v115; // rax
  const char *v116; // rbx
  const char *v117; // rax
  const char *v118; // rbx
  const char *v119; // rax
  const char *v120; // rbx
  const char *v121; // rax
  const char *v122; // rbx
  const char *v123; // rax
  const char *v124; // rbx
  const char *v125; // rax
  const char *v126; // rbx
  const char *v127; // rax
  const char *v128; // rbx
  const char *v129; // rax
  const char *v130; // rbx
  const char *v131; // rax
  const char *v132; // rbx
  const char *v133; // rax
  const char *v134; // rbx
  const char *v135; // rax
  const char *v136; // rbx
  const char *v137; // rax
  __int64 v138; // rax
  __int64 v139; // r14
  unsigned __int64 *v140; // rsi
  unsigned __int64 v141; // rdx
  __int64 v142; // rcx
  _QWORD *v143; // rbx
  unsigned __int64 v144; // r8
  __int64 v145; // rax
  __m128i v146; // xmm0
  signed __int64 v147; // rdi
  __int64 v148; // rax
  __int64 v149; // rcx
  int v150; // edi
  unsigned __int64 v151; // rdx
  __int64 v152; // rcx
  _QWORD *v153; // rbx
  unsigned __int64 v154; // r8
  __int64 v155; // rax
  __m128i v156; // xmm0
  __int64 v158; // [rsp+50h] [rbp-B8h] BYREF
  char *v159; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int64 v160; // [rsp+60h] [rbp-A8h] BYREF
  __m128i v161; // [rsp+68h] [rbp-A0h] BYREF
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *v162; // [rsp+78h] [rbp-90h]
  __int64 v163; // [rsp+80h] [rbp-88h] BYREF
  char *v164; // [rsp+88h] [rbp-80h] BYREF
  __int64 v165; // [rsp+90h] [rbp-78h] BYREF
  char *v166; // [rsp+98h] [rbp-70h] BYREF
  __int64 v167; // [rsp+A0h] [rbp-68h] BYREF
  char *v168; // [rsp+A8h] [rbp-60h] BYREF
  unsigned __int64 v169; // [rsp+B0h] [rbp-58h]
  unsigned __int64 i; // [rsp+B8h] [rbp-50h]
  wchar_t *v171[2]; // [rsp+C0h] [rbp-48h] BYREF
  __int64 v172; // [rsp+D0h] [rbp-38h]
  unsigned __int64 v173; // [rsp+D8h] [rbp-30h]
  __int64 v174; // [rsp+E0h] [rbp-28h] BYREF
  __int64 v175; // [rsp+E8h] [rbp-20h] BYREF
  _QWORD v176[2]; // [rsp+F0h] [rbp-18h] BYREF
  __int64 v177; // [rsp+100h] [rbp-8h] BYREF
  __int64 v178; // [rsp+110h] [rbp+8h] BYREF
  _QWORD v179[3]; // [rsp+120h] [rbp+18h] BYREF
  __int64 v182; // [rsp+198h] [rbp+90h] BYREF
  __int64 v183; // [rsp+1A0h] [rbp+98h]

  v183 = a4;
  v182 = a3;
  v7 = a2;
  v8 = 0;
  v9 = a1;
  v10 = *(int *)(a4 + 8);
  v11 = 0;
  v169 = 0;
  v12 = 0xFFFFFFFFFFFFFFFFuLL;
  v13 = a3;
  v173 = v10;
  for ( i = 0xCBF29CE484222325uLL; v11 < v173; v169 = v11 )
  {
    n2 = *(unsigned __int8 *)(*(_QWORD *)a4 + 0x28 * v11 + 0x19);
    v15 = *(_QWORD *)a4 + 0x28 * v11;
    v16 = *(_BYTE *)(v15 + 0x1A);
    if ( (_BYTE)n2 == 3 )
    {
      v17 = *(_QWORD *)(v15 + 8);
      v18 = v7 + v17;
      if ( v16 )
      {
        v19 = v17 + v13;
        if ( v18 )
        {
          if ( v19 )
          {
            v20 = *(_QWORD *)(v18 + 0x18);
            if ( v20 )
            {
              sub_1474D24F0(v17 + v13, *(_QWORD *)(v18 + 0x18), 0x140000000uLL);
              v21 = 0;
              do
              {
                v22 = *(_QWORD *)(v18 + 0x10);
                v21 += 0x18;
                v23 = *(_OWORD *)(v21 + v22 - 0x18);
                v24 = *(double *)(v21 + v22 - 8);
                v25 = *(_QWORD *)(v19 + 0x10);
                *(_OWORD *)(v25 + v21 - 0x18) = v23;
                *(double *)(v25 + v21 - 8) = v24;
                --v20;
              }
              while ( v20 );
            }
          }
        }
LABEL_9:
        v7 = a2;
      }
      else
      {
        *(_OWORD *)(v17 + v13) = *(_OWORD *)v18;
        *(double *)(v17 + v13 + 0x10) = *(double *)(v18 + 0x10);
      }
    }
    else
    {
      if ( (_BYTE)n2 == 2 )
      {
        v26 = *(_QWORD *)(v15 + 8);
        v27 = v7 + v26;
        if ( v16 )
        {
          v28 = v26 + v13;
          if ( v27 && v28 )
          {
            v29 = *(_QWORD *)(v27 + 0x18);
            if ( v29 )
            {
              *(_QWORD *)(v28 + 0x18) = v29;
              *(_QWORD *)(v28 + 0x20) = v29;
              v30 = 0x10 * v29;
              if ( !is_mul_ok(v29, 0x10u) )
                v30 = 0xFFFFFFFFFFFFFFFFuLL;
              v31 = __CFADD__(v30, 8);
              allocSize = v30 + 8;
              if ( v31 )
                allocSize = 0xFFFFFFFFFFFFFFFFuLL;
              v33 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
              if ( v33 )
              {
                v8 = (unsigned __int64)(v33 + 1);
                *v33 = v29;
                v34 = (__int64)(v33 + 1);
                v35 = v29;
                do
                {
                  sub_140362C90(v34);
                  v34 += 0x10;
                  --v35;
                }
                while ( v35 );
              }
              *(_QWORD *)(v28 + 0x10) = v8;
              v8 = 0;
              v36 = 0;
              *(_BYTE *)(v28 + 8) = 1;
              do
              {
                sub_140362C80((__int64)v171, (_QWORD *)(v36 + *(_QWORD *)(v27 + 0x10)));
                v37 = (_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *)(v36 + *(_QWORD *)(v28 + 0x10));
                if ( v171[0] )
                {
                  sub_140362C80((__int64)&v161, v171);
                  v162 = v37;
                  sub_14747F390(a5, &v174, &v161);
                  sub_140370E60((__int64)&v161);
                }
                _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
                  v37,
                  (const wchar_t **)v171);
                sub_140370E60((__int64)v171);
                v36 += 0x10;
                --v29;
              }
              while ( v29 );
              v7 = a2;
              v13 = a3;
            }
            else
            {
              v7 = a2;
            }
          }
LABEL_28:
          v9 = a1;
        }
        else
        {
          v44 = (_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *)(v26 + v13);
          sub_140362C80((__int64)&v161, (_QWORD *)(v7 + v26));
          v162 = v44;
          sub_14747F390(a5, &v175, &v161);
          sub_140370E60((__int64)&v161);
          if ( *(_QWORD *)v27 )
            _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
              v44,
              (const wchar_t **)v27);
        }
      }
      else
      {
        if ( v16 )
        {
          switch ( *(_BYTE *)(v15 + 0x18) )
          {
            case 1:
            case 2:
            case 6:
              v45 = *(_QWORD *)(v15 + 8);
              v46 = v45 + v13;
              v47 = v45 + v7;
              if ( !v47 )
                goto LABEL_9;
              if ( !v46 )
                goto LABEL_9;
              allocSize_1 = *(_QWORD *)(v47 + 0x18);
              if ( !allocSize_1 )
                goto LABEL_9;
              *(_QWORD *)(v46 + 0x18) = allocSize_1;
              *(_QWORD *)(v46 + 0x20) = allocSize_1;
              v49 = (void *)allocWithProfilerInfo_w(allocSize_1);
              allocSize_2 = allocSize_1;
              goto LABEL_51;
            case 3:
            case 7:
              v51 = *(_QWORD *)(v15 + 8);
              v46 = v51 + v13;
              v47 = v51 + v7;
              if ( !v47 )
                goto LABEL_9;
              if ( !v46 )
                goto LABEL_9;
              v52 = *(_QWORD *)(v47 + 0x18);
              if ( !v52 )
                goto LABEL_9;
              *(_QWORD *)(v46 + 0x18) = v52;
              *(_QWORD *)(v46 + 0x20) = v52;
              v49 = (void *)allocWithProfilerInfo_w(saturated_mul(v52, 2u));
              allocSize_2 = 2 * v52;
              goto LABEL_51;
            case 4:
            case 8:
            case 0xB:
              v53 = *(_QWORD *)(v15 + 8);
              v46 = v53 + v13;
              v47 = v53 + v7;
              if ( !v47 )
                goto LABEL_9;
              if ( !v46 )
                goto LABEL_9;
              v54 = *(_QWORD *)(v47 + 0x18);
              if ( !v54 )
                goto LABEL_9;
              *(_QWORD *)(v46 + 0x18) = v54;
              *(_QWORD *)(v46 + 0x20) = v54;
              v49 = (void *)allocWithProfilerInfo_w(saturated_mul(v54, 4u));
              allocSize_2 = 4 * v54;
              goto LABEL_51;
            case 5:
            case 9:
            case 0xC:
              v55 = *(_QWORD *)(v15 + 8);
              v46 = v55 + v13;
              v47 = v55 + v7;
              if ( !v47 )
                goto LABEL_9;
              if ( !v46 )
                goto LABEL_9;
              v56 = *(_QWORD *)(v47 + 0x18);
              if ( !v56 )
                goto LABEL_9;
              *(_QWORD *)(v46 + 0x18) = v56;
              *(_QWORD *)(v46 + 0x20) = v56;
              v49 = (void *)allocWithProfilerInfo_w(saturated_mul(v56, 8u));
              allocSize_2 = 8 * v56;
LABEL_51:
              *(_QWORD *)(v46 + 0x10) = v49;
              *(_BYTE *)(v46 + 8) = 1;
              memcpy(v49, *(const void **)(v47 + 0x10), allocSize_2);
              v7 = a2;
              goto LABEL_30;
            case 0xA:
              v57 = *(_QWORD *)(v15 + 8);
              v58 = v57 + v7;
              v59 = v57 + v13;
              if ( v58 )
              {
                if ( v59 )
                {
                  v60 = *(_QWORD *)(v58 + 0x18);
                  if ( v60 )
                  {
                    sub_1474D2450(v57 + v13, *(_QWORD *)(v58 + 0x18), 0x140000000uLL);
                    v61 = 0;
                    do
                    {
                      sub_140379DC0(v61 + *(_QWORD *)(v59 + 0x10), (ULONG_PTR **)(v61 + *(_QWORD *)(v58 + 0x10)));
                      v61 += 0x10;
                      --v60;
                    }
                    while ( v60 );
                  }
                }
              }
              break;
            case 0xD:
              v76 = *(_QWORD *)(v15 + 8);
              v77 = v76 + v7;
              v78 = v76 + v13;
              if ( !v77 )
                break;
              if ( !v78 )
                break;
              v79 = *(_QWORD *)(v77 + 0x18);
              if ( !v79 )
                break;
              sub_1474D2620(v76 + v13, *(_QWORD *)(v77 + 0x18), 0x140000000uLL);
              for ( j = 0; j < v79; ++j )
                copyStringStructure(
                  (char **)(*(_QWORD *)(v78 + 0x10) + 8 * j),
                  (char **)(*(_QWORD *)(v77 + 0x10) + 8 * j));
              v7 = a2;
              goto LABEL_29;
            case 0xE:
              v68 = *(_QWORD *)(v15 + 8);
              v69 = v68 + v13;
              v70 = v68 + v7;
              if ( !v70 )
                goto LABEL_9;
              if ( !v69 )
                goto LABEL_9;
              v71 = *(int *)(v70 + 0x18);
              if ( (int)v71 <= 0 )
                goto LABEL_9;
              v72 = *(int *)(v70 + 0x18);
              *(_QWORD *)(v69 + 0x18) = v71;
              *(_QWORD *)(v69 + 0x20) = v71;
              v74 = v71;
              allocSize_3 = 0x10 * v71;
              if ( !is_mul_ok(v74, 0x10u) )
                allocSize_3 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)(v69 + 0x10) = allocWithProfilerInfo_w(allocSize_3);
              *(_BYTE *)(v69 + 8) = 1;
              if ( !v72 )
                goto LABEL_9;
              v75 = 0;
              do
              {
                v75 += 0x10;
                *(_OWORD *)(v75 + *(_QWORD *)(v69 + 0x10) - 0x10) = *(_OWORD *)(v75 + *(_QWORD *)(v70 + 0x10) - 0x10);
                --v72;
              }
              while ( v72 );
              v7 = a2;
              goto LABEL_30;
            case 0xF:
              v62 = *(_QWORD *)(v15 + 8);
              v63 = v62 + v7;
              v64 = v62 + v13;
              if ( !(v62 + v7) || !v64 )
                goto LABEL_30;
              v65 = *(_QWORD *)(v63 + 0x18);
              if ( !v65 )
                goto LABEL_9;
              allocSize_4 = v65 * *(_QWORD *)(v63 + 0x28);
              *(_QWORD *)(v64 + 0x18) = v65;
              *(_QWORD *)(v64 + 0x20) = v65;
              v67 = (void *)allocWithProfilerInfo_w(allocSize_4);
              *(_QWORD *)(v64 + 0x10) = v67;
              *(_BYTE *)(v64 + 8) = 1;
              memcpy(v67, *(const void **)(v63 + 0x10), allocSize_4);
              v7 = a2;
              goto LABEL_30;
            case 0x10:
              v81 = *(_QWORD *)(v15 + 8);
              if ( (_BYTE)n2 == 1 )
              {
                v82 = v81 + v7;
                v83 = v81 + v13;
                v160 = v81 + v7;
                v84 = *(_QWORD *)(v81 + v7 + 0x18);
                v172 = v83;
                if ( !v84 )
                {
                  v9 = a1;
                  v13 = a3;
                  goto LABEL_30;
                }
                sub_1474D2580(v83, v84, 0x140000000uLL);
                v85 = 0;
                do
                {
                  v86 = *(_QWORD *)(v83 + 0x10);
                  v87 = (unsigned __int64 *)(v85 + *(_QWORD *)(v82 + 0x10));
                  if ( *v87 )
                  {
                    v163 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)*v87 + 8LL))(*v87);
                    sub_14035B120(&v164, &v163);
                    v88 = 0xFFFFFFFFFFFFFFFFuLL;
                    do
                      ++v88;
                    while ( v164[v88] );
                    v89 = 0;
                    v90 = (_QWORD *)(a1 + 0x130);
                    v91 = 0xCBF29CE484222325uLL;
                    if ( v88 )
                    {
                      do
                      {
                        v92 = (unsigned __int8)v164[v89++];
                        v91 = 0x100000001B3LL * (v92 ^ v91);
                      }
                      while ( v89 < v88 );
                      v83 = v172;
                      v90 = (_QWORD *)(a1 + 0x130);
                    }
                    v93 = *(__m128i *)sub_14747F260(
                                        (_QWORD *)(a1 + 0x130),
                                        &v177,
                                        &v164,
                                        0xDE5FB9D2630458E9uLL * v91
                                      + (((unsigned __int64)v91 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                    v164 = (char *)&qword_149B3B33C + 4;
                    v161 = v93;
                    sub_140370D10(&v164);
                    if ( v161.m128i_i64[0] != *v90 + v90[3] )
                    {
                      epi64 = _mm_extract_epi64(v161, 1);
                      v95 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(epi64 + 0x18))(*(_QWORD *)(epi64 + 0x18), 0);
                      v96 = a6;
                      *(_QWORD *)(v86 + v85) = v95;
                      *(_BYTE *)(v86 + v85 + 8) = 1;
                      *(_QWORD *)sub_1419110C0(v96, v87) = v95;
                      sub_14748FB60(a1, *v87, *(_QWORD *)(v86 + v85), epi64 + 8, a5, a6, a7);
                    }
                    v82 = v160;
                  }
                  v85 += 0x10;
                  --v84;
                }
                while ( v84 );
                v7 = a2;
                v8 = 0;
                v13 = a3;
                goto LABEL_28;
              }
              v97 = v81 + v7;
              v98 = v81 + v13;
              if ( *(int *)(v97 + 0x18) > 0 )
              {
                v165 = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int64))(**(_QWORD **)(v97 + 0x10) + 8LL))(
                         *(_QWORD *)(v97 + 0x10),
                         n2,
                         0x140000000uLL);
                sub_14035B120(&v166, &v165);
                v99 = 0xFFFFFFFFFFFFFFFFuLL;
                do
                  ++v99;
                while ( v166[v99] );
                v100 = 0xCBF29CE484222325uLL;
                v101 = (_QWORD *)(v9 + 0x130);
                v102 = 0;
                if ( v99 )
                {
                  do
                  {
                    v103 = (unsigned __int8)v166[v102++];
                    v100 = 0x100000001B3LL * (v103 ^ v100);
                  }
                  while ( v102 < v99 );
                  v13 = a3;
                  v101 = (_QWORD *)(v9 + 0x130);
                }
                v104 = *(__m128i *)sub_14747F260(
                                     (_QWORD *)(v9 + 0x130),
                                     &v178,
                                     &v166,
                                     0xDE5FB9D2630458E9uLL * v100
                                   + (((unsigned __int64)v100 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                v166 = (char *)&qword_149B3B33C + 4;
                v161 = v104;
                sub_140370D10(&v166);
                if ( v161.m128i_i64[0] != *v101 + v101[3] )
                {
                  v105 = _mm_extract_epi64(v161, 1);
                  *(_QWORD *)(v98 + 0x10) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v105 + 0x18))(
                                              *(_QWORD *)(v105 + 0x18),
                                              *(_QWORD *)(v97 + 0x18));
                  v106 = 0;
                  v107 = *(_QWORD *)(v97 + 0x18);
                  *(_QWORD *)(v98 + 0x18) = v107;
                  *(_QWORD *)(v98 + 0x20) = v107;
                  *(_QWORD *)(v98 + 0x28) = *(_QWORD *)(v97 + 0x28);
                  for ( *(_BYTE *)(v98 + 8) = 1; v106 < *(_QWORD *)(v97 + 0x18); ++v106 )
                  {
                    v108 = *(_QWORD *)(v98 + 0x28) * v106;
                    v160 = *(_QWORD *)(v97 + 0x10) + *(_QWORD *)(v97 + 0x28) * v106;
                    v109 = *(_QWORD *)(v98 + 0x10) + v108;
                    *(_QWORD *)sub_1419110C0(a6, &v160) = v109;
                    sub_14748FB60(v9, v160, v109, v105 + 8, a5, a6, a7);
                  }
                  v7 = a2;
                  v13 = a3;
                  goto LABEL_29;
                }
              }
              break;
            default:
              goto LABEL_30;
          }
        }
        else
        {
          switch ( *(_BYTE *)(v15 + 0x18) )
          {
            case 1:
              if ( *(_QWORD *)(v15 + 0x10) != 1 )
              {
                v130 = *(const char **)v15;
                v131 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v131,
                  v130);
              }
              goto LABEL_146;
            case 2:
              if ( *(_QWORD *)(v15 + 0x10) != 1 )
              {
                v110 = *(const char **)v15;
                v111 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v111,
                  v110);
              }
              goto LABEL_146;
            case 3:
              if ( *(_QWORD *)(v15 + 0x10) != 2 )
              {
                v112 = *(const char **)v15;
                v113 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v113,
                  v112);
              }
              goto LABEL_146;
            case 4:
              if ( *(_QWORD *)(v15 + 0x10) != 4 )
              {
                v114 = *(const char **)v15;
                v115 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v115,
                  v114);
              }
              goto LABEL_146;
            case 5:
              if ( *(_QWORD *)(v15 + 0x10) != 8 )
              {
                v116 = *(const char **)v15;
                v117 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v117,
                  v116);
              }
              goto LABEL_146;
            case 6:
              if ( *(_QWORD *)(v15 + 0x10) != 1 )
              {
                v118 = *(const char **)v15;
                v119 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v119,
                  v118);
              }
              goto LABEL_146;
            case 7:
              if ( *(_QWORD *)(v15 + 0x10) != 2 )
              {
                v120 = *(const char **)v15;
                v121 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v121,
                  v120);
              }
              goto LABEL_146;
            case 8:
              if ( *(_QWORD *)(v15 + 0x10) != 4 )
              {
                v122 = *(const char **)v15;
                v123 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v123,
                  v122);
              }
              goto LABEL_146;
            case 9:
              if ( *(_QWORD *)(v15 + 0x10) != 8 )
              {
                v124 = *(const char **)v15;
                v125 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v125,
                  v124);
              }
              goto LABEL_146;
            case 0xA:
              if ( *(_QWORD *)(v15 + 0x10) != 0x10 )
              {
                v132 = *(const char **)v15;
                v133 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Strings must be const char*",
                  v133,
                  v132);
              }
              sub_140379DC0(*(_QWORD *)(v15 + 8) + v13, (ULONG_PTR **)(*(_QWORD *)(v15 + 8) + v7));
              goto LABEL_30;
            case 0xB:
              if ( *(_QWORD *)(v15 + 0x10) != 4 )
              {
                v126 = *(const char **)v15;
                v127 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v127,
                  v126);
              }
              goto LABEL_146;
            case 0xC:
              if ( *(_QWORD *)(v15 + 0x10) != 8 )
              {
                v128 = *(const char **)v15;
                v129 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v129,
                  v128);
              }
              goto LABEL_146;
            case 0xD:
              if ( *(_QWORD *)(v15 + 0x10) != 8 )
              {
                v136 = *(const char **)v15;
                v137 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Localisation fie"
                  "lds must be type CLocIdentifier",
                  v137,
                  v136);
              }
              copyStringStructure((char **)(*(_QWORD *)(v15 + 8) + v13), (char **)(*(_QWORD *)(v15 + 8) + v7));
              goto LABEL_30;
            case 0xE:
              if ( *(_QWORD *)(v15 + 0x10) != 0x10 )
              {
                v134 = *(const char **)v15;
                v135 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)v7 + 8LL))(
                                       v7,
                                       n2,
                                       0x140000000uLL);
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore structure '%s' field '%s'. GUIDs must be CryGUID",
                  v135,
                  v134);
              }
              *(_OWORD *)(*(_QWORD *)(v15 + 8) + v13) = *(_OWORD *)(*(_QWORD *)(v15 + 8) + v7);
              goto LABEL_30;
            case 0xF:
LABEL_146:
              memcpy(
                (void *)(*(_QWORD *)(v15 + 8) + v13),
                (const void *)(*(_QWORD *)(v15 + 8) + v7),
                *(_QWORD *)(v15 + 0x10));
              goto LABEL_30;
            case 0x10:
              v138 = *(_QWORD *)(v15 + 8);
              v139 = v138 + v13;
              if ( (_BYTE)n2 == 1 )
              {
                v140 = (unsigned __int64 *)(v138 + v7);
                if ( *v140 )
                {
                  v167 = (*(__int64 (__fastcall **)(unsigned __int64, __int64, unsigned __int64))(*(_QWORD *)*v140 + 8LL))(
                           *v140,
                           n2,
                           0x140000000uLL);
                  sub_14035B120(&v168, &v167);
                  v141 = 0xFFFFFFFFFFFFFFFFuLL;
                  do
                    ++v141;
                  while ( v168[v141] );
                  v142 = 0xCBF29CE484222325uLL;
                  v143 = (_QWORD *)(v9 + 0x130);
                  v144 = 0;
                  if ( v141 )
                  {
                    do
                    {
                      v145 = (unsigned __int8)v168[v144++];
                      v142 = 0x100000001B3LL * (v145 ^ v142);
                    }
                    while ( v144 < v141 );
                    v13 = a3;
                    v143 = (_QWORD *)(v9 + 0x130);
                  }
                  v146 = *(__m128i *)sub_14747F260(
                                       (_QWORD *)(v9 + 0x130),
                                       v179,
                                       &v168,
                                       0xDE5FB9D2630458E9uLL * v142
                                     + (((unsigned __int64)v142 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                  v168 = (char *)&qword_149B3B33C + 4;
                  v161 = v146;
                  sub_140370D10(&v168);
                  if ( v161.m128i_i64[0] != *v143 + v143[3] )
                  {
                    v147 = _mm_extract_epi64(v161, 1);
                    v148 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v147 + 0x18))(*(_QWORD *)(v147 + 0x18), 0);
                    v149 = a6;
                    *(_QWORD *)v139 = v148;
                    *(_BYTE *)(v139 + 8) = 1;
                    *(_QWORD *)sub_1419110C0(v149, v140) = v148;
                    sub_14748FB60(v9, *v140, *(_QWORD *)v139, v147 + 8, a5, a6, a7);
                    v7 = a2;
                    goto LABEL_29;
                  }
                }
              }
              else
              {
                v150 = v138 + v7;
                v158 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)(v138 + v7) + 8LL))(
                         v138 + v7,
                         n2,
                         0x140000000uLL);
                sub_14035B120(&v159, &v158);
                v151 = 0xFFFFFFFFFFFFFFFFuLL;
                do
                  ++v151;
                while ( v159[v151] );
                v152 = 0xCBF29CE484222325uLL;
                v153 = (_QWORD *)(v9 + 0x130);
                v154 = 0;
                if ( v151 )
                {
                  do
                  {
                    v155 = (unsigned __int8)v159[v154++];
                    v152 = 0x100000001B3LL * (v155 ^ v152);
                  }
                  while ( v154 < v151 );
                  v13 = a3;
                  v153 = (_QWORD *)(v9 + 0x130);
                }
                v156 = *(__m128i *)sub_14747F260(
                                     (_QWORD *)(v9 + 0x130),
                                     v176,
                                     &v159,
                                     0xDE5FB9D2630458E9uLL * v152
                                   + (((unsigned __int64)v152 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                v159 = (char *)&qword_149B3B33C + 4;
                v161 = v156;
                sub_140370D10(&v159);
                if ( v161.m128i_i64[0] != *v153 + v153[3] )
                {
                  sub_14748FB60(v9, v150, v139, _mm_extract_epi64(v161, 1) + 8, a5, a6, a7);
                  v7 = a2;
                  goto LABEL_29;
                }
              }
              break;
            default:
              goto LABEL_30;
          }
        }
        v7 = a2;
      }
LABEL_29:
      v12 = 0xFFFFFFFFFFFFFFFFuLL;
    }
LABEL_30:
    a4 = v183;
    v11 = v169 + 1;
  }
  result = *(char **)(a4 + 0x18);
  if ( !result )
    goto LABEL_40;
  v158 = *(_QWORD *)(a4 + 0x18);
  sub_14035B120(&v159, &v158);
  do
    ++v12;
  while ( v159[v12] );
  v39 = (_QWORD *)(v9 + 0x130);
  if ( v12 )
  {
    v40 = 0xCBF29CE484222325uLL;
    do
    {
      v41 = (unsigned __int8)v159[v8++];
      v40 = 0x100000001B3LL * (v41 ^ v40);
    }
    while ( v8 < v12 );
    LODWORD(v13) = a3;
    v39 = (_QWORD *)(v9 + 0x130);
    i = v40;
  }
  v42 = *(__m128i *)sub_14747F260(
                      (_QWORD *)(v9 + 0x130),
                      v176,
                      &v159,
                      (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 0x40);
  v159 = (char *)&qword_149B3B33C + 4;
  v161 = v42;
  sub_140370D10(&v159);
  if ( v161.m128i_i64[0] == *v39 + v39[3] )
  {
    result = (char *)sub_1405C0E00(
                       8u,
                       0,
                       "structure inherited class [%s] is not registered",
                       *(const char **)(v183 + 0x18));
    a4 = v183;
LABEL_40:
    v43 = a7;
    goto LABEL_41;
  }
  v43 = a7;
  result = (char *)sub_14748FB60(v9, v7, v13, (unsigned int)_mm_extract_epi64(v161, 1) + 8, a5, a6, a7);
  a4 = v183;
LABEL_41:
  if ( *(_BYTE *)(a4 + 0x20) )
    return sub_1402A6620(v43, &v182);
  return result;
}

// --- End Function: sub_14748FB60 (0x14748FB60) ---

// --- Function: sub_147490D70 (0x147490D70) ---
__int64 __fastcall sub_147490D70(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rax
  signed __int64 v5; // rax
  __int64 v6; // rsi
  __int64 v7; // r15
  __int64 v8; // rax
  __int64 inserted; // rax
  __int64 v10; // rdi
  __int64 v11; // rcx
  __int64 v12; // rax
  __int128 v13; // xmm0
  __int64 *v14; // rdi
  __int64 *j; // rbx
  __int64 *v16; // rcx
  __int64 v17; // rax
  __int64 **v18; // rax
  __int64 *i; // rax
  __int64 *v20; // rcx
  _QWORD *v21; // rdi
  _QWORD *v22; // rbx
  __int64 *v23; // rdx
  __int64 v24; // rbx
  const void *v25; // rdx
  const void *v26; // rdx
  _QWORD *v27; // rdi
  const void *v28; // rbx
  __int64 *v30; // [rsp+40h] [rbp-19h] BYREF
  __int64 v31; // [rsp+48h] [rbp-11h]
  __int128 v32; // [rsp+50h] [rbp-9h] BYREF
  _OWORD v33[2]; // [rsp+60h] [rbp+7h] BYREF
  __int128 v34; // [rsp+80h] [rbp+27h] BYREF
  __int64 v35; // [rsp+90h] [rbp+37h]

  if ( !a2 )
    return 0;
  v4 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)a2 + 8LL))(a2);
  v5 = DataCore::LookupDCStructDescByName(a1, v4);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v5 + 0x10))(*(_QWORD *)(v5 + 0x10), 0);
  if ( !v7 )
    return 0;
  v32 = 0;
  v8 = sub_140391AB0((__int64)&v32, 0x38u);
  *(_QWORD *)v8 = v8;
  *(_QWORD *)(v8 + 8) = v8;
  *(_QWORD *)(v8 + 0x10) = v8;
  *(_WORD *)(v8 + 0x18) = 0x101;
  *(_QWORD *)&v32 = v8;
  v30 = 0;
  v31 = 0;
  inserted = sub_140391AB0((__int64)&v30, 0x30u);
  v10 = inserted;
  DWORD2(v33[0]) = 0;
  *(_QWORD *)inserted = inserted;
  *(_QWORD *)(inserted + 8) = inserted;
  *(_QWORD *)(inserted + 0x10) = inserted;
  *(_WORD *)(inserted + 0x18) = 0x101;
  v30 = (__int64 *)inserted;
  v34 = 0;
  v35 = 0;
  v11 = *(_QWORD *)(inserted + 8);
  *(_QWORD *)&v33[0] = v11;
  while ( !*(_BYTE *)(v11 + 0x19) )
  {
    *(_QWORD *)&v33[0] = v11;
    if ( *(_QWORD *)(v11 + 0x20) >= a2 )
    {
      inserted = v11;
      DWORD2(v33[0]) = 1;
      v11 = *(_QWORD *)v11;
    }
    else
    {
      v11 = *(_QWORD *)(v11 + 0x10);
      DWORD2(v33[0]) = 0;
    }
  }
  if ( *(_BYTE *)(inserted + 0x19) || a2 < *(_QWORD *)(inserted + 0x20) )
  {
    if ( v31 == 0x555555555555555LL )
      unknown_libname_7();
    v12 = sub_140391AB0((__int64)&v30, 0x30u);
    v13 = v33[0];
    *(_QWORD *)(v12 + 0x20) = a2;
    *(_QWORD *)(v12 + 0x28) = 0;
    *(_QWORD *)v12 = v10;
    *(_QWORD *)(v12 + 8) = v10;
    *(_QWORD *)(v12 + 0x10) = v10;
    *(_WORD *)(v12 + 0x18) = 0;
    v33[0] = v13;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 &v30,
                 (__int64)v33,
                 v12);
  }
  *(_QWORD *)(inserted + 0x28) = v7;
  sub_14748FB60(a1, a2, v7, v6, (__int64)&v32, (__int64)&v30, (__int64)&v34);
  v14 = (__int64 *)v32;
  j = *(__int64 **)v32;
  while ( j != v14 )
  {
    sub_140362C80((__int64)v33, j + 4);
    v16 = v30;
    v17 = v30[1];
    while ( !*(_BYTE *)(v17 + 0x19) )
    {
      if ( *(_QWORD *)(v17 + 0x20) >= *(_QWORD *)&v33[0] )
      {
        v16 = (__int64 *)v17;
        v17 = *(_QWORD *)v17;
      }
      else
      {
        v17 = *(_QWORD *)(v17 + 0x10);
      }
    }
    if ( *((_BYTE *)v16 + 0x19) || *(_QWORD *)&v33[0] < (unsigned __int64)v16[4] )
      v16 = v30;
    if ( v16 != v30 )
      *(_QWORD *)j[6] = v16[5];
    sub_140370E60((__int64)v33);
    v18 = (__int64 **)j[2];
    if ( *((_BYTE *)v18 + 0x19) )
    {
      for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
      {
        if ( j != (__int64 *)i[2] )
          break;
        j = i;
      }
      j = i;
    }
    else
    {
      v20 = *v18;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v20 + 0x19); v20 = (__int64 *)*v20 )
        j = v20;
    }
  }
  v21 = (_QWORD *)*((_QWORD *)&v34 + 1);
  v22 = (_QWORD *)v34;
  if ( (_QWORD)v34 != *((_QWORD *)&v34 + 1) )
  {
    do
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v22 + 0x28LL))(*v22);
      ++v22;
    }
    while ( v22 != v21 );
    v22 = (_QWORD *)v34;
  }
  if ( v22 )
  {
    sub_1403A3120((__int64)&v34, v22, (v35 - (_QWORD)v22) & 0xFFFFFFFFFFFFFFF8uLL);
    v34 = 0;
    v35 = 0;
  }
  v23 = v30;
  v24 = v30[1];
  if ( !*(_BYTE *)(v24 + 0x19) )
  {
    do
    {
      sub_140348410((__int64)&v30, (__int64)&v30, *(_QWORD *)(v24 + 0x10));
      v25 = (const void *)v24;
      v24 = *(_QWORD *)v24;
      sub_1403A3120((__int64)&v30, v25, 0x30u);
    }
    while ( !*(_BYTE *)(v24 + 0x19) );
    v23 = v30;
  }
  sub_1403A3120((__int64)&v30, v23, 0x30u);
  v26 = (const void *)v32;
  v27 = *(_QWORD **)(v32 + 8);
  if ( !*((_BYTE *)v27 + 0x19) )
  {
    do
    {
      sub_14747B6F0((__int64)&v32, (__int64)&v32, v27[2]);
      v28 = v27;
      v27 = (_QWORD *)*v27;
      sub_140370E60((__int64)v28 + 0x20);
      sub_1403A3120((__int64)&v32, v28, 0x38u);
    }
    while ( !*((_BYTE *)v27 + 0x19) );
    v26 = (const void *)v32;
  }
  sub_1403A3120((__int64)&v32, v26, 0x38u);
  return v7;
}

// --- End Function: sub_147490D70 (0x147490D70) ---

// --- Function: sub_147491120 (0x147491120) ---
void __fastcall sub_147491120(__int64 a1, _QWORD *a2, __int64 *a3)
{
  unsigned __int64 v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rax
  unsigned __int64 v9; // rdi
  __int64 v10; // rcx
  __int64 v11; // rax
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  signed __int64 v14; // rax
  __int64 v15; // r14
  __int64 v16; // rax
  __int64 *v17; // rsi
  __int64 v18; // r15
  __int64 *inserted; // rax
  __int64 v20; // rcx
  __int64 v21; // rax
  __int128 v22; // xmm0
  __int64 *v23; // rdi
  __int64 *j; // rbx
  __int64 *v25; // rcx
  __int64 v26; // rax
  __int64 **v27; // rax
  __int64 *i; // rax
  __int64 *v29; // rcx
  _QWORD *v30; // rdi
  _QWORD *v31; // rbx
  __int64 v32; // rbx
  const void *v33; // rdx
  const void *v34; // rdx
  _QWORD *v35; // rdi
  const void *v36; // rbx
  __int64 *v37; // [rsp+40h] [rbp-39h] BYREF
  __int64 v38; // [rsp+48h] [rbp-31h]
  __int128 v39; // [rsp+50h] [rbp-29h] BYREF
  _OWORD v40[2]; // [rsp+60h] [rbp-19h] BYREF
  __int128 v41; // [rsp+80h] [rbp+7h] BYREF
  __int64 v42; // [rsp+90h] [rbp+17h]
  __int64 v44; // [rsp+F0h] [rbp+77h] BYREF

  v6 = (a3[1] - *a3) >> 3;
  v44 = 0;
  sub_14747C610((__int64)a2, v6, &v44);
  v39 = 0;
  v7 = sub_140391AB0((__int64)&v39, 0x38u);
  *(_QWORD *)v7 = v7;
  *(_QWORD *)(v7 + 8) = v7;
  *(_QWORD *)(v7 + 0x10) = v7;
  *(_WORD *)(v7 + 0x18) = 0x101;
  *(_QWORD *)&v39 = v7;
  v37 = 0;
  v38 = 0;
  v8 = sub_140391AB0((__int64)&v37, 0x30u);
  v9 = 0;
  *(_QWORD *)v8 = v8;
  *(_QWORD *)(v8 + 8) = v8;
  *(_QWORD *)(v8 + 0x10) = v8;
  *(_WORD *)(v8 + 0x18) = 0x101;
  v10 = *a3;
  v37 = (__int64 *)v8;
  v11 = a3[1] - v10;
  v42 = 0;
  v41 = 0;
  if ( v11 >> 3 )
  {
    do
    {
      v12 = *(_QWORD *)(v10 + 8 * v9);
      if ( v12 )
      {
        v13 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v12 + 8LL))(*(_QWORD *)(v10 + 8 * v9));
        v14 = DataCore::LookupDCStructDescByName(a1, v13);
        v15 = v14;
        if ( v14 )
        {
          v16 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v14 + 0x10))(*(_QWORD *)(v14 + 0x10), 0);
          v17 = v37;
          v18 = v16;
          DWORD2(v40[0]) = 0;
          inserted = v37;
          v20 = v37[1];
          *(_QWORD *)&v40[0] = v20;
          while ( !*(_BYTE *)(v20 + 0x19) )
          {
            *(_QWORD *)&v40[0] = v20;
            if ( *(_QWORD *)(v20 + 0x20) >= v12 )
            {
              inserted = (__int64 *)v20;
              DWORD2(v40[0]) = 1;
              v20 = *(_QWORD *)v20;
            }
            else
            {
              v20 = *(_QWORD *)(v20 + 0x10);
              DWORD2(v40[0]) = 0;
            }
          }
          if ( *((_BYTE *)inserted + 0x19) || v12 < inserted[4] )
          {
            if ( v38 == 0x555555555555555LL )
              unknown_libname_7();
            v21 = sub_140391AB0((__int64)&v37, 0x30u);
            v22 = v40[0];
            *(_QWORD *)(v21 + 0x20) = v12;
            *(_QWORD *)(v21 + 0x28) = 0;
            *(_QWORD *)v21 = v17;
            *(_QWORD *)(v21 + 8) = v17;
            *(_QWORD *)(v21 + 0x10) = v17;
            *(_WORD *)(v21 + 0x18) = 0;
            v40[0] = v22;
            inserted = (__int64 *)std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                                    &v37,
                                    (__int64)v40,
                                    v21);
          }
          inserted[5] = v18;
          sub_14748FB60(a1, v12, v18, v15, (__int64)&v39, (__int64)&v37, (__int64)&v41);
          *(_QWORD *)(*a2 + 8 * v9) = v18;
        }
      }
      v10 = *a3;
      ++v9;
    }
    while ( v9 < (a3[1] - *a3) >> 3 );
  }
  v23 = (__int64 *)v39;
  j = *(__int64 **)v39;
  while ( j != v23 )
  {
    sub_140362C80((__int64)v40, j + 4);
    v25 = v37;
    v26 = v37[1];
    while ( !*(_BYTE *)(v26 + 0x19) )
    {
      if ( *(_QWORD *)(v26 + 0x20) >= *(_QWORD *)&v40[0] )
      {
        v25 = (__int64 *)v26;
        v26 = *(_QWORD *)v26;
      }
      else
      {
        v26 = *(_QWORD *)(v26 + 0x10);
      }
    }
    if ( *((_BYTE *)v25 + 0x19) || *(_QWORD *)&v40[0] < (unsigned __int64)v25[4] )
      v25 = v37;
    if ( v25 != v37 )
      *(_QWORD *)j[6] = v25[5];
    sub_140370E60((__int64)v40);
    v27 = (__int64 **)j[2];
    if ( *((_BYTE *)v27 + 0x19) )
    {
      for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
      {
        if ( j != (__int64 *)i[2] )
          break;
        j = i;
      }
      j = i;
    }
    else
    {
      v29 = *v27;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v29 + 0x19); v29 = (__int64 *)*v29 )
        j = v29;
    }
  }
  v30 = (_QWORD *)*((_QWORD *)&v41 + 1);
  v31 = (_QWORD *)v41;
  if ( (_QWORD)v41 != *((_QWORD *)&v41 + 1) )
  {
    do
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v31 + 0x28LL))(*v31);
      ++v31;
    }
    while ( v31 != v30 );
    v31 = (_QWORD *)v41;
  }
  if ( v31 )
  {
    sub_1403A3120((__int64)&v41, v31, (v42 - (_QWORD)v31) & 0xFFFFFFFFFFFFFFF8uLL);
    v41 = 0;
    v42 = 0;
  }
  v32 = v37[1];
  while ( !*(_BYTE *)(v32 + 0x19) )
  {
    sub_140348410((__int64)&v37, (__int64)&v37, *(_QWORD *)(v32 + 0x10));
    v33 = (const void *)v32;
    v32 = *(_QWORD *)v32;
    sub_1403A3120((__int64)&v37, v33, 0x30u);
  }
  sub_1403A3120((__int64)&v37, v37, 0x30u);
  v34 = (const void *)v39;
  v35 = *(_QWORD **)(v39 + 8);
  if ( !*((_BYTE *)v35 + 0x19) )
  {
    do
    {
      sub_14747B6F0((__int64)&v39, (__int64)&v39, v35[2]);
      v36 = v35;
      v35 = (_QWORD *)*v35;
      sub_140370E60((__int64)v36 + 0x20);
      sub_1403A3120((__int64)&v39, v36, 0x38u);
    }
    while ( !*((_BYTE *)v35 + 0x19) );
    v34 = (const void *)v39;
  }
  sub_1403A3120((__int64)&v39, v34, 0x38u);
}

// --- End Function: sub_147491120 (0x147491120) ---

// --- Function: sub_14749DAD0 (0x14749DAD0) ---
__int64 __fastcall sub_14749DAD0(__int64 a1, __int64 a2, unsigned __int8 a3, char a4)
{
  __int64 result; // rax
  const void *v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rsi
  const void *v10; // r14
  __int64 j; // rdi
  __int64 v12; // rax
  __int64 v13; // rsi
  __int64 i; // rdi
  __int64 v15; // rax

  result = a3 - 1;
  switch ( a3 )
  {
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
    case 0xBu:
    case 0xCu:
    case 0xEu:
      return sub_1474D05B0(a2);
    case 0xAu:
      return sub_1474D05F0(a2);
    case 0xDu:
      return sub_1474D0680(a2);
    case 0xFu:
      if ( *(_QWORD *)(a2 + 0x28) == 1 )
        return sub_1474D05B0(a2);
      result = *(_QWORD *)(a2 + 0x28) - 2LL;
      if ( *(_QWORD *)(a2 + 0x28) == 2 || *(_QWORD *)(a2 + 0x28) == 4 )
        return sub_1474D05B0(a2);
      return result;
    case 0x10u:
      switch ( a4 )
      {
        case 0:
          if ( *(_BYTE *)(a2 + 8) )
          {
            v15 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 0x10) + 8LL))(*(_QWORD *)(a2 + 0x10));
            result = DataCore::LookupDCStructDescByName(a1, v15);
            if ( result )
            {
              (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(result + 0x10) + 8LL))(
                *(_QWORD *)(result + 0x10),
                *(_QWORD *)(a2 + 0x10));
              result = 0;
              *(_QWORD *)(a2 + 0x10) = 0;
              *(_QWORD *)(a2 + 0x18) = 0;
              *(_QWORD *)(a2 + 0x20) = 0;
              *(_BYTE *)(a2 + 8) = 0;
            }
          }
          return result;
        case 1:
          if ( !*(_BYTE *)(a2 + 8) )
            return result;
          v12 = *(_QWORD *)(a2 + 0x10);
          if ( !v12 )
            goto LABEL_25;
          v13 = *(_QWORD *)(v12 - 8);
          v10 = (const void *)(v12 - 8);
          for ( i = v12 + 0x10 * v13; v13; --v13 )
          {
            i -= 0x10;
            sub_140370E60(i);
          }
LABEL_24:
          sub_1402A3D30(v10);
          goto LABEL_25;
        case 2:
          if ( !*(_BYTE *)(a2 + 8) )
            return result;
          v8 = *(_QWORD *)(a2 + 0x10);
          if ( !v8 )
            goto LABEL_25;
          v9 = *(_QWORD *)(v8 - 8);
          v10 = (const void *)(v8 - 8);
          for ( j = v8 + 0x10 * v9; v9; --v9 )
          {
            j -= 0x10;
            sub_140370E60(j);
          }
          goto LABEL_24;
        case 3:
          v7 = *(const void **)(a2 + 0x10);
          if ( v7 )
          {
            if ( *(_BYTE *)(a2 + 8) )
            {
              sub_1402A3D30(v7);
LABEL_25:
              result = 0;
              *(_QWORD *)(a2 + 0x20) = 0;
              *(_QWORD *)(a2 + 0x18) = 0;
              *(_QWORD *)(a2 + 0x10) = 0;
              *(_BYTE *)(a2 + 8) = 0;
            }
          }
          break;
      }
      return result;
    default:
      return (unsigned int)a3 - 1;
  }
}

// --- End Function: sub_14749DAD0 (0x14749DAD0) ---

// --- Function: sub_14749FB70 (0x14749FB70) ---
bool __fastcall sub_14749FB70(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, const char *))(*(_QWORD *)qword_149B4FC18
                                                                                              + 0x150LL))(
           qword_149B4FC18,
           a1,
           a2,
           a3,
           a4,
           "FReadRawWithLog") == a3;
}

// --- End Function: sub_14749FB70 (0x14749FB70) ---

// --- Function: sub_1474A10F0 (0x1474A10F0) ---
void __fastcall sub_1474A10F0(_QWORD *a1, unsigned int *a2, __int64 a3, __int64 a4)
{
  __int64 v7; // rbp
  const char *v8; // rbp
  __int64 *v9; // rdi
  unsigned __int8 **v10; // rbx
  unsigned __int64 v11; // rcx
  __int64 **v12; // r12
  unsigned int *v13; // r13
  unsigned int *v14; // rdi
  __int64 v15; // r14
  __int64 v16; // rbp
  char *v17; // rbx
  _QWORD *v18; // r9
  unsigned __int64 v19; // rcx
  __int64 v20; // r14
  __int64 v21; // rbp
  char *v22; // rbx
  int v23; // r14d
  __int64 v24; // rbp
  const char *v25; // rbp
  __int64 *v26; // rdi
  unsigned __int8 **v27; // rbx
  const char *v28; // [rsp+20h] [rbp-58h] BYREF
  unsigned __int8 *v29; // [rsp+28h] [rbp-50h] BYREF
  const char *v30; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int8 *v31; // [rsp+38h] [rbp-40h] BYREF

  if ( a2 )
  {
    if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
      v7 = a1[0x55];
    else
      v7 = a1[0x54];
    v8 = (const char *)(*a2 + v7);
    v28 = v8;
    sub_14035B120(&v29, &v28);
    v9 = (__int64 *)a1[0x24];
    v10 = (unsigned __int8 **)v9[1];
    while ( !*((_BYTE *)v10 + 0x19) )
    {
      if ( (int)sub_1403E4780(v10 + 4, &v29) >= 0 )
      {
        v9 = (__int64 *)v10;
        v10 = (unsigned __int8 **)*v10;
      }
      else
      {
        v10 = (unsigned __int8 **)v10[2];
      }
    }
    if ( *((_BYTE *)v9 + 0x19) || (int)sub_1403E4780(&v29, v9 + 4) < 0 )
      v9 = (__int64 *)a1[0x24];
    v29 = (unsigned __int8 *)&qword_149B3B33C + 4;
    sub_140370D10(&v29);
    if ( v9 == (__int64 *)a1[0x24] )
    {
      sub_1405C0E00(8u, 2u, "[DataCore] Cannot get enum enumerable \"%s\" does not exist.", v8);
    }
    else
    {
      v11 = *((unsigned __int16 *)a2 + 2);
      v12 = (__int64 **)v9[6];
      v13 = a2 + 1;
      v14 = a2 + 1;
      if ( v11 > (__int64)(*(_QWORD *)(a3 + 0x10) - *(_QWORD *)a3) >> 3 )
      {
        v15 = 8 * v11;
        v16 = (__int64)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3;
        v17 = (char *)sub_140391AB0(a3, 8 * v11);
        memmove(v17, *(const void **)a3, *(_QWORD *)(a3 + 8) - *(_QWORD *)a3);
        v18 = (_QWORD *)a3;
        if ( *(_QWORD *)a3 )
        {
          sub_1403A3120(a3, *(const void **)a3, (*(_QWORD *)(a3 + 0x10) - *(_QWORD *)a3) & 0xFFFFFFFFFFFFFFF8uLL);
          v18 = (_QWORD *)a3;
          v14 = a2 + 1;
        }
        *v18 = v17;
        v18[1] = &v17[8 * v16];
        v18[2] = &v17[v15];
      }
      v19 = *(unsigned __int16 *)v13;
      if ( v19 > (__int64)(*(_QWORD *)(a4 + 0x10) - *(_QWORD *)a4) >> 2 )
      {
        v20 = 4 * v19;
        v21 = (__int64)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2;
        v22 = (char *)sub_140391AB0(a4, 4 * v19);
        memmove(v22, *(const void **)a4, *(_QWORD *)(a4 + 8) - *(_QWORD *)a4);
        if ( *(_QWORD *)a4 )
          sub_1403A3120(a4, *(const void **)a4, (*(_QWORD *)(a4 + 0x10) - *(_QWORD *)a4) & 0xFFFFFFFFFFFFFFFCuLL);
        *(_QWORD *)a4 = v22;
        *(_QWORD *)(a4 + 8) = &v22[4 * v21];
        v13 = v14;
        *(_QWORD *)(a4 + 0x10) = &v22[v20];
      }
      v23 = 0;
      if ( *(_WORD *)v13 )
      {
        do
        {
          if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
            v24 = a1[0x55];
          else
            v24 = a1[0x54];
          v25 = (const char *)(*(unsigned int *)(a1[0x59] + 4LL * (v23 + *((unsigned __int16 *)a2 + 3))) + v24);
          v28 = v25;
          sub_1402A6620(a3, &v28);
          v30 = v25;
          sub_14035B120(&v31, &v30);
          v26 = *v12;
          v27 = (unsigned __int8 **)(*v12)[1];
          while ( !*((_BYTE *)v27 + 0x19) )
          {
            if ( (int)sub_1403E4780(v27 + 4, &v31) >= 0 )
            {
              v26 = (__int64 *)v27;
              v27 = (unsigned __int8 **)*v27;
            }
            else
            {
              v27 = (unsigned __int8 **)v27[2];
            }
          }
          if ( *((_BYTE *)v26 + 0x19) || (int)sub_1403E4780(&v31, v26 + 4) < 0 )
            v26 = *v12;
          v31 = (unsigned __int8 *)&qword_149B3B33C + 4;
          sub_140370D10(&v31);
          if ( v26 == *v12 )
          {
            LODWORD(v28) = 0xFFFFFFFF;
            sub_14089E6C0(a4, &v28);
            sub_1405C0E00(8u, 2u, "[DataCore] Cannot get enum value \"%s\" does not exist.", v25);
          }
          else
          {
            sub_140344170(a4, (_DWORD *)v26 + 0xA);
          }
          ++v23;
        }
        while ( v23 < *(unsigned __int16 *)v13 );
      }
    }
  }
}

// --- End Function: sub_1474A10F0 (0x1474A10F0) ---

// --- Function: sub_1474A1490 (0x1474A1490) ---
__int64 __fastcall sub_1474A1490(__int64 a1, const char *a2, const char *a3)
{
  __int64 *v6; // rbx
  const char *v8; // [rsp+20h] [rbp-18h] BYREF
  unsigned __int8 *v9[2]; // [rsp+28h] [rbp-10h] BYREF
  unsigned __int8 **v10; // [rsp+48h] [rbp+10h] BYREF

  if ( a2 && *a2 )
  {
    v8 = a2;
    sub_14035B120(v9, &v8);
    sub_140500E00((unsigned __int8 ***)(a1 + 0x120), &v10, v9);
    v9[0] = (unsigned __int8 *)&qword_149B3B33C + 4;
    sub_140370D10(v9);
    if ( v10 == *(unsigned __int8 ***)(a1 + 0x120) )
    {
      sub_1405C0E00(8u, 2u, "[DataCore] Cannot get enum enumerable \"%s\" does not exist.", a2);
    }
    else
    {
      v6 = (__int64 *)v10[6];
      v8 = a3;
      sub_14035B120(v9, &v8);
      std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::find(
        v6,
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&v10,
        v9);
      v9[0] = (unsigned __int8 *)&qword_149B3B33C + 4;
      sub_140370D10(v9);
      if ( v10 != (unsigned __int8 **)*v6 )
        return *((unsigned int *)v10 + 0xA);
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1474A1490 (0x1474A1490) ---

// --- Function: sub_1474A33B0 (0x1474A33B0) ---
const ULONG_PTR *__fastcall sub_1474A33B0(__int64 a1, _QWORD *a2)
{
  int v4; // eax
  __m128i *v5; // rax
  unsigned __int64 v7[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = psub_1403360E0(0xFFFFFFFF, (__int64)a2, 0x10);
  v5 = (__m128i *)sub_14747EFF0(
                    (__int64 *)(a1 + 0xB0),
                    v7,
                    a2,
                    (__PAIR128__((unsigned int)~v4, (unsigned int)~v4) * 0xDE5FB9D2630458E9uLL) >> 0x40);
  if ( v5->m128i_i64[0] == *(_QWORD *)(a1 + 0xB0) + *(_QWORD *)(a1 + 0xC8) )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(_mm_extract_epi64(*v5, 1) + 0x10);
}

// --- End Function: sub_1474A33B0 (0x1474A33B0) ---

// --- Function: sub_1474A3450 (0x1474A3450) ---
__int64 __fastcall sub_1474A3450(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v6; // rdx
  int v7; // r14d
  __int64 *v8; // rsi
  __int64 v9; // rax
  _QWORD *v10; // rdi
  int v11; // eax
  __m128i *v12; // rax
  __int64 *v13; // rbp
  __int64 *v14; // r8
  signed __int64 epi64; // r13
  __int64 v16; // rdi
  unsigned __int64 v17; // r12
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // rcx
  __int64 v20; // rsi
  _QWORD *v21; // r15
  void **v22; // rdi
  __int64 *v23; // rdx
  _QWORD *v24; // r8
  __int64 *v25; // rcx
  unsigned __int64 v26; // [rsp+20h] [rbp-48h] BYREF
  __int64 v27; // [rsp+28h] [rbp-40h] BYREF
  __int128 v28; // [rsp+30h] [rbp-38h] BYREF
  __int64 *v29; // [rsp+70h] [rbp+8h]

  v26 = a2;
  sub_14035B120(&v27, &v26);
  sub_14747F0E0(a1 + 0x1D, &v28, &v27);
  v27 = (__int64)&qword_149B3B33C + 4;
  sub_140370D10(&v27);
  result = a1[0x1D] + a1[0x20];
  if ( (_QWORD)v28 != result )
  {
    v6 = *((_QWORD *)&v28 + 1);
    v7 = 0;
    result = *(_QWORD *)(*((_QWORD *)&v28 + 1) + 8LL);
    if ( (*(_DWORD *)(result - 4) & 0x7FFFFFFF) != 0 )
    {
      v8 = a1 + 0x16;
      v29 = v8;
      do
      {
        v9 = *(_QWORD *)(v6 + 8);
        if ( v7 >= (*(_DWORD *)(v9 - 4) & 0x7FFFFFFF) )
          __debugbreak();
        v10 = (_QWORD *)(v9 + 0x10LL * v7);
        v11 = psub_1403360E0(0xFFFFFFFF, (__int64)v10, 0x10);
        v12 = (__m128i *)sub_14747EFF0(
                           v8,
                           &v26,
                           v10,
                           (__PAIR128__((unsigned int)~v11, (unsigned int)~v11) * 0xDE5FB9D2630458E9uLL) >> 0x40);
        if ( v12->m128i_i64[0] != *v8 + v8[3] )
        {
          v13 = *(__int64 **)(a3 + 8);
          v14 = *(__int64 **)(a3 + 0x10);
          epi64 = _mm_extract_epi64(*v12, 1);
          if ( v13 == v14 )
          {
            v16 = ((__int64)v13 - *(_QWORD *)a3) >> 3;
            if ( v16 == 0x1FFFFFFFFFFFFFFFLL )
              unknown_libname_10();
            v17 = v16 + 1;
            v18 = ((__int64)v14 - *(_QWORD *)a3) >> 3;
            v19 = v18 >> 1;
            if ( v18 <= 0x1FFFFFFFFFFFFFFFLL - (v18 >> 1) )
            {
              v20 = v19 + v18;
              if ( v19 + v18 < v17 )
                v20 = v16 + 1;
            }
            else
            {
              v20 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v21 = (_QWORD *)sub_140391AB0(a3, 8 * v20);
            v22 = (void **)&v21[v16];
            sub_14035B160(v22, (const void **)(epi64 + 0x10));
            v23 = *(__int64 **)(a3 + 8);
            v24 = v21;
            v25 = *(__int64 **)a3;
            if ( v13 != v23 )
            {
              sub_14043EFE0(v25, v13, v21);
              v23 = *(__int64 **)(a3 + 8);
              v24 = v22 + 1;
              v25 = v13;
            }
            sub_14043EFE0(v25, v23, v24);
            sub_1404FBC30(a3, (__int64)v21, v17, v20);
            v8 = v29;
          }
          else
          {
            sub_14035B160(*(void ***)(a3 + 8), (const void **)(epi64 + 0x10));
            *(_QWORD *)(a3 + 8) += 8LL;
          }
        }
        v6 = *((_QWORD *)&v28 + 1);
        ++v7;
        result = *(_QWORD *)(*((_QWORD *)&v28 + 1) + 8LL);
      }
      while ( v7 < (*(_DWORD *)(result - 4) & 0x7FFFFFFF) );
    }
  }
  return result;
}

// --- End Function: sub_1474A3450 (0x1474A3450) ---

// --- Function: sub_1474A36D0 (0x1474A36D0) ---
void **__fastcall sub_1474A36D0(__int64 a1, void **a2, __int64 a3)
{
  const char *v5; // r9
  unsigned int n0x9E37; // r8d
  char i; // al
  int v8; // edx
  unsigned __int128 v9; // rax
  __m128i v10; // xmm0
  __int64 v11; // rsi
  size_t Size; // rdi
  __int64 v14; // [rsp+20h] [rbp-78h] BYREF
  const char *v15; // [rsp+28h] [rbp-70h] BYREF
  __m128i v16; // [rsp+30h] [rbp-68h] BYREF
  _BYTE v17[8]; // [rsp+40h] [rbp-58h] BYREF
  __int64 v18; // [rsp+48h] [rbp-50h]
  char *v19; // [rsp+50h] [rbp-48h]
  char v20; // [rsp+58h] [rbp-40h] BYREF

  v14 = a3;
  sub_14035B120(&v15, &v14);
  v5 = v15;
  n0x9E37 = 0x9E37;
  for ( i = *v15; *v5; i = *v5 )
  {
    ++v5;
    v8 = i + 0x20;
    if ( (unsigned __int8)(i - 0x41) > 0x19u )
      v8 = i;
    n0x9E37 = ((0x401 * (n0x9E37 + v8)) >> 6) ^ (0x401 * (n0x9E37 + v8));
  }
  v9 = 0x8001 * ((9 * n0x9E37) ^ ((9 * n0x9E37) >> 0xB)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = *(__m128i *)sub_1403090E0((_QWORD *)(a1 + 0x40), &v16, &v15, *((_QWORD *)&v9 + 1) + v9);
  v15 = (char *)&qword_149B3B33C + 4;
  v16 = v10;
  sub_140370D10(&v15);
  if ( v16.m128i_i64[0] == *(_QWORD *)(a1 + 0x40) + *(_QWORD *)(a1 + 0x58) )
  {
    CreateStringObjectFromString(a2, (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  else
  {
    v11 = sub_1402C4680((__int64)v17, _mm_extract_epi64(v16, 1) + 0x10);
    sub_1403E0AA0(a2);
    Size = *(_QWORD *)v11;
    if ( *(_QWORD *)v11 )
    {
      sub_1403DE0C0((char **)a2, *(_QWORD *)v11);
      sub_1403E1FA0(*a2, *(const void **)(v11 + 0x10), Size);
    }
    if ( v19 != &v20 )
    {
      qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - v18;
      sub_147605980(v19);
    }
  }
  return a2;
}

// --- End Function: sub_1474A36D0 (0x1474A36D0) ---

// --- Function: sub_1474A3870 (0x1474A3870) ---
const ULONG_PTR *__fastcall sub_1474A3870(_QWORD *a1, char *a2)
{
  int v3; // eax
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // rsi
  unsigned __int128 v6; // rax
  __int64 v7; // r9
  __int64 v10; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v19; // rdx
  __int64 v20; // rax
  __int128 v22; // [rsp+28h] [rbp-30h] BYREF

  v22 = *(_OWORD *)sub_1402BC380((__int64 *)&v22, a2);
  v3 = psub_1403360E0(0xFFFFFFFF, (__int64)&v22, 0x10);
  v4 = a1[0x12];
  v5 = 0;
  v6 = (unsigned int)~v3 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v7 = v4 & ((*((_QWORD *)&v6 + 1) + (_QWORD)v6) >> 7);
  _XMM2 = (BYTE8(v6) + (_BYTE)v6) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v10 = a1[0xF];
    _XMM1 = *(_OWORD *)(v10 + v7);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
    {
      do
      {
        _BitScanForward((unsigned int *)&v14, _EAX);
        v15 = v4 & (v7 + v14);
        v16 = a1[0x10] + 0x18 * v15;
        if ( *(_OWORD *)v16 == v22 )
        {
          v19 = a1[0xF];
          v20 = v19 + v15;
          goto LABEL_11;
        }
        _EAX &= _EAX - 1;
      }
      while ( _EAX );
      v10 = a1[0xF];
    }
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
      break;
    v5 += 0x10LL;
    v7 = v4 & (v5 + v7);
    if ( v5 > v4 )
      __debugbreak();
  }
  v16 = *((_QWORD *)&v22 + 1);
  v20 = v10 + v4;
  v19 = v10;
LABEL_11:
  if ( v20 == v4 + v19 )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(v16 + 0x10);
}

// --- End Function: sub_1474A3870 (0x1474A3870) ---

// --- Function: sub_1474A39D0 (0x1474A39D0) ---
const ULONG_PTR *__fastcall sub_1474A39D0(__int64 *a1, __int64 a2, int a3)
{
  __int64 v4; // rsi
  __int64 v5; // rax
  _QWORD *v6; // rbx
  int v7; // eax
  __m128i v8; // xmm0
  __int64 v10; // [rsp+20h] [rbp-28h] BYREF
  __int64 v11; // [rsp+28h] [rbp-20h] BYREF
  __int128 v12; // [rsp+30h] [rbp-18h] BYREF

  v10 = a2;
  v4 = a3;
  sub_14035B120(&v11, &v10);
  sub_14747F0E0(a1 + 0x1D, &v12, &v11);
  v11 = (__int64)&qword_149B3B33C + 4;
  sub_140370D10(&v11);
  if ( (_QWORD)v12 == a1[0x1D] + a1[0x20] )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( (int)v4 < 0 )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  v5 = *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8LL);
  if ( (int)v4 >= (*(_DWORD *)(v5 - 4) & 0x7FFFFFFF) )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  v6 = (_QWORD *)(v5 + 0x10 * v4);
  v7 = psub_1403360E0(0xFFFFFFFF, (__int64)v6, 0x10);
  v8 = *(__m128i *)sub_14747EFF0(
                     a1 + 0xF,
                     (unsigned __int64 *)&v12,
                     v6,
                     (__PAIR128__((unsigned int)~v7, (unsigned int)~v7) * 0xDE5FB9D2630458E9uLL) >> 0x40);
  if ( v8.m128i_i64[0] == a1[0xF] + a1[0x12] )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(_mm_extract_epi64(v8, 1) + 0x10);
}

// --- End Function: sub_1474A39D0 (0x1474A39D0) ---

// --- Function: sub_1474A3B00 (0x1474A3B00) ---
const ULONG_PTR *__fastcall sub_1474A3B00(__int64 a1, _QWORD *a2)
{
  int v4; // eax
  __m128i *v5; // rax
  unsigned __int64 v7[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = psub_1403360E0(0xFFFFFFFF, (__int64)a2, 0x10);
  v5 = (__m128i *)sub_14747EFF0(
                    (__int64 *)(a1 + 0x78),
                    v7,
                    a2,
                    (__PAIR128__((unsigned int)~v4, (unsigned int)~v4) * 0xDE5FB9D2630458E9uLL) >> 0x40);
  if ( v5->m128i_i64[0] == *(_QWORD *)(a1 + 0x78) + *(_QWORD *)(a1 + 0x90) )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(_mm_extract_epi64(*v5, 1) + 0x10);
}

// --- End Function: sub_1474A3B00 (0x1474A3B00) ---

// --- Function: sub_1474A3BA0 (0x1474A3BA0) ---
__int64 __fastcall sub_1474A3BA0(__int64 *a1, _QWORD *a2, __int64 **a3, __int64 **a4)
{
  __int64 *v4; // r15
  __int64 result; // rax
  __int64 v8; // rdx
  int v9; // r13d
  __int64 v10; // rax
  _QWORD *v11; // rbp
  int v12; // eax
  __m128i *v13; // rax
  __int64 *v14; // r14
  __int64 *v15; // r8
  const void **v16; // rax
  __int64 v17; // rdi
  unsigned __int64 v18; // r12
  unsigned __int64 v19; // r8
  __int64 v20; // rbp
  unsigned __int64 v21; // rcx
  _QWORD *v22; // r15
  void **v23; // rdi
  __int64 *v24; // rdx
  _QWORD *v25; // r8
  __int64 *v26; // rcx
  int v27; // eax
  __m128i *v28; // rax
  __int64 *v29; // r14
  __int64 *v30; // r8
  const void **v31; // rax
  __int64 v32; // rdi
  unsigned __int64 v33; // r12
  unsigned __int64 v34; // r8
  __int64 v35; // rbp
  unsigned __int64 v36; // rcx
  _QWORD *v37; // r15
  void **v38; // rdi
  __int64 *v39; // rdx
  _QWORD *v40; // r8
  __int64 *v41; // rcx
  _QWORD *v42; // [rsp+20h] [rbp-78h] BYREF
  __int64 v43; // [rsp+28h] [rbp-70h] BYREF
  __int128 v44; // [rsp+30h] [rbp-68h] BYREF
  unsigned __int64 v45; // [rsp+40h] [rbp-58h] BYREF
  unsigned __int64 v46; // [rsp+50h] [rbp-48h] BYREF
  const void **v48; // [rsp+A8h] [rbp+10h]
  const void **v49; // [rsp+A8h] [rbp+10h]

  v4 = a1;
  v42 = a2;
  sub_14035B120(&v43, &v42);
  sub_14747F0E0(v4 + 0x1D, &v44, &v43);
  v43 = (__int64)&qword_149B3B33C + 4;
  sub_140370D10(&v43);
  result = v4[0x1D] + v4[0x20];
  if ( (_QWORD)v44 != result )
  {
    v8 = *((_QWORD *)&v44 + 1);
    v9 = 0;
    result = *(_QWORD *)(*((_QWORD *)&v44 + 1) + 8LL);
    if ( (*(_DWORD *)(result - 4) & 0x7FFFFFFF) != 0 )
    {
      do
      {
        v10 = *(_QWORD *)(v8 + 8);
        if ( v9 >= (*(_DWORD *)(v10 - 4) & 0x7FFFFFFF) )
          __debugbreak();
        v11 = (_QWORD *)(v10 + 0x10LL * v9);
        v42 = v11;
        v12 = psub_1403360E0(0xFFFFFFFF, (__int64)v11, 0x10);
        v13 = (__m128i *)sub_14747EFF0(
                           v4 + 0xF,
                           &v45,
                           v11,
                           (__PAIR128__((unsigned int)~v12, (unsigned int)~v12) * 0xDE5FB9D2630458E9uLL) >> 0x40);
        if ( v13->m128i_i64[0] != v4[0xF] + v4[0x12] )
        {
          v14 = a3[1];
          v15 = a3[2];
          v16 = (const void **)(_mm_extract_epi64(*v13, 1) + 0x10);
          v48 = v16;
          if ( v14 == v15 )
          {
            v17 = v14 - *a3;
            if ( v17 == 0x1FFFFFFFFFFFFFFFLL )
              goto LABEL_27;
            v18 = v17 + 1;
            v19 = v15 - *a3;
            v20 = 0x1FFFFFFFFFFFFFFFLL;
            v21 = v19 >> 1;
            if ( v19 <= 0x1FFFFFFFFFFFFFFFLL - (v19 >> 1) )
            {
              v20 = v21 + v19;
              if ( v21 + v19 < v18 )
                v20 = v17 + 1;
            }
            v22 = (_QWORD *)sub_140391AB0((__int64)a3, 8 * v20);
            v23 = (void **)&v22[v17];
            sub_14035B160(v23, v48);
            v24 = a3[1];
            v25 = v22;
            v26 = *a3;
            if ( v14 != v24 )
            {
              sub_14043EFE0(v26, v14, v22);
              v24 = a3[1];
              v25 = v23 + 1;
              v26 = v14;
            }
            sub_14043EFE0(v26, v24, v25);
            sub_1404FBC30((__int64)a3, (__int64)v22, v18, v20);
            v11 = v42;
            v4 = a1;
          }
          else
          {
            sub_14035B160((void **)v14, v16);
            ++a3[1];
          }
        }
        v27 = psub_1403360E0(0xFFFFFFFF, (__int64)v11, 0x10);
        v28 = (__m128i *)sub_14747EFF0(
                           v4 + 0x16,
                           &v46,
                           v11,
                           (__PAIR128__((unsigned int)~v27, (unsigned int)~v27) * 0xDE5FB9D2630458E9uLL) >> 0x40);
        if ( v28->m128i_i64[0] != v4[0x16] + v4[0x19] )
        {
          v29 = a4[1];
          v30 = a4[2];
          v31 = (const void **)(_mm_extract_epi64(*v28, 1) + 0x10);
          v49 = v31;
          if ( v29 == v30 )
          {
            v32 = v29 - *a4;
            if ( v32 == 0x1FFFFFFFFFFFFFFFLL )
LABEL_27:
              unknown_libname_10();
            v33 = v32 + 1;
            v34 = v30 - *a4;
            v35 = 0x1FFFFFFFFFFFFFFFLL;
            v36 = v34 >> 1;
            if ( v34 <= 0x1FFFFFFFFFFFFFFFLL - (v34 >> 1) )
            {
              v35 = v36 + v34;
              if ( v36 + v34 < v33 )
                v35 = v32 + 1;
            }
            v37 = (_QWORD *)sub_140391AB0((__int64)a4, 8 * v35);
            v38 = (void **)&v37[v32];
            sub_14035B160(v38, v49);
            v39 = a4[1];
            v40 = v37;
            v41 = *a4;
            if ( v29 != v39 )
            {
              sub_14043EFE0(v41, v29, v37);
              v39 = a4[1];
              v40 = v38 + 1;
              v41 = v29;
            }
            sub_14043EFE0(v41, v39, v40);
            sub_1404FBC30((__int64)a4, (__int64)v37, v33, v35);
            v4 = a1;
          }
          else
          {
            sub_14035B160((void **)v29, v31);
            ++a4[1];
          }
        }
        v8 = *((_QWORD *)&v44 + 1);
        ++v9;
        result = *(_QWORD *)(*((_QWORD *)&v44 + 1) + 8LL);
      }
      while ( v9 < (*(_DWORD *)(result - 4) & 0x7FFFFFFF) );
    }
  }
  return result;
}

// --- End Function: sub_1474A3BA0 (0x1474A3BA0) ---

// --- Function: sub_1474A3F50 (0x1474A3F50) ---
__int64 __fastcall sub_1474A3F50(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 *v3; // rsi
  __int64 result; // rax
  __int64 v6; // r15
  __int64 v7; // r12
  __int64 v8; // rbp
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 *v11; // r14
  __int64 v12; // r13
  __int64 *v13; // rdi
  _QWORD *i; // rsi
  int v15; // r14d
  __int64 *v16; // rsi
  __int64 v17; // rax
  _QWORD *v18; // rdi
  int v19; // eax
  __m128i *v20; // rax
  __int64 *v21; // rsi
  __int64 *v22; // r8
  signed __int64 epi64; // r13
  __int64 v24; // rdi
  unsigned __int64 v25; // r12
  unsigned __int64 v26; // r8
  unsigned __int64 v27; // rcx
  __int64 v28; // rbp
  _QWORD *v29; // r15
  void **v30; // rdi
  __int64 *v31; // rdx
  _QWORD *v32; // r8
  __int64 *v33; // rcx
  unsigned __int64 v34; // [rsp+20h] [rbp-48h] BYREF
  __int64 v35; // [rsp+28h] [rbp-40h] BYREF
  __int128 v36; // [rsp+30h] [rbp-38h] BYREF
  __int64 *v38; // [rsp+70h] [rbp+8h]

  v3 = a1;
  v34 = a2;
  sub_14035B120(&v35, &v34);
  sub_14747F0E0(v3 + 0x1D, &v36, &v35);
  v35 = (__int64)&qword_149B3B33C + 4;
  sub_140370D10(&v35);
  result = v3[0x1D] + v3[0x20];
  if ( (_QWORD)v36 != result )
  {
    v6 = *((_QWORD *)&v36 + 1);
    v7 = (__int64)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3;
    v8 = *(unsigned int *)(*(_QWORD *)(*((_QWORD *)&v36 + 1) + 8LL) - 4LL);
    LODWORD(v8) = v8 & 0x7FFFFFFF;
    v9 = v7 + v8;
    if ( v9 > (__int64)(*(_QWORD *)(a3 + 0x10) - *(_QWORD *)a3) >> 3 )
    {
      if ( v9 > 0x1FFFFFFFFFFFFFFFLL )
LABEL_25:
        unknown_libname_10();
      v10 = sub_140391AB0(a3, 8 * v9);
      v11 = *(__int64 **)(a3 + 8);
      v12 = v10;
      v13 = *(__int64 **)a3;
      for ( i = (_QWORD *)v10; v13 != v11; ++v13 )
        sub_14035B140(i++, v13);
      sub_1404FBC30(a3, v12, v7, v9);
      v3 = a1;
    }
    result = *(_QWORD *)(v6 + 8);
    v15 = 0;
    if ( (*(_DWORD *)(result - 4) & 0x7FFFFFFF) != 0 )
    {
      v16 = v3 + 0xF;
      v38 = v16;
      do
      {
        v17 = *(_QWORD *)(v6 + 8);
        if ( v15 >= (*(_DWORD *)(v17 - 4) & 0x7FFFFFFF) )
          __debugbreak();
        v18 = (_QWORD *)(v17 + 0x10LL * v15);
        v19 = psub_1403360E0(0xFFFFFFFF, (__int64)v18, 0x10);
        v20 = (__m128i *)sub_14747EFF0(
                           v16,
                           &v34,
                           v18,
                           (__PAIR128__((unsigned int)~v19, (unsigned int)~v19) * 0xDE5FB9D2630458E9uLL) >> 0x40);
        if ( v20->m128i_i64[0] != *v16 + v16[3] )
        {
          v21 = *(__int64 **)(a3 + 8);
          v22 = *(__int64 **)(a3 + 0x10);
          epi64 = _mm_extract_epi64(*v20, 1);
          if ( v21 == v22 )
          {
            v24 = ((__int64)v21 - *(_QWORD *)a3) >> 3;
            if ( v24 == 0x1FFFFFFFFFFFFFFFLL )
              goto LABEL_25;
            v25 = v24 + 1;
            v26 = ((__int64)v22 - *(_QWORD *)a3) >> 3;
            v27 = v26 >> 1;
            if ( v26 <= 0x1FFFFFFFFFFFFFFFLL - (v26 >> 1) )
            {
              v28 = v27 + v26;
              if ( v27 + v26 < v25 )
                v28 = v24 + 1;
            }
            else
            {
              v28 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v29 = (_QWORD *)sub_140391AB0(a3, 8 * v28);
            v30 = (void **)&v29[v24];
            sub_14035B160(v30, (const void **)(epi64 + 0x10));
            v31 = *(__int64 **)(a3 + 8);
            v32 = v29;
            v33 = *(__int64 **)a3;
            if ( v21 != v31 )
            {
              sub_14043EFE0(v33, v21, v29);
              v31 = *(__int64 **)(a3 + 8);
              v32 = v30 + 1;
              v33 = v21;
            }
            sub_14043EFE0(v33, v31, v32);
            sub_1404FBC30(a3, (__int64)v29, v25, v28);
            v6 = *((_QWORD *)&v36 + 1);
          }
          else
          {
            sub_14035B160(*(void ***)(a3 + 8), (const void **)(epi64 + 0x10));
            *(_QWORD *)(a3 + 8) += 8LL;
          }
          v16 = v38;
        }
        result = *(_QWORD *)(v6 + 8);
        ++v15;
      }
      while ( v15 < (*(_DWORD *)(result - 4) & 0x7FFFFFFF) );
    }
  }
  return result;
}

// --- End Function: sub_1474A3F50 (0x1474A3F50) ---

// --- Function: sub_1474A4240 (0x1474A4240) ---
_QWORD *__fastcall sub_1474A4240(__int64 a1, _QWORD *a2, __int64 a3)
{
  const char *v5; // r9
  unsigned int n0x9E37; // r8d
  char i; // al
  int v8; // edx
  unsigned __int128 v9; // rax
  __m128i v10; // xmm0
  __int64 v12; // [rsp+20h] [rbp-28h] BYREF
  const char *v13; // [rsp+28h] [rbp-20h] BYREF
  __m128i v14; // [rsp+30h] [rbp-18h] BYREF

  v12 = a3;
  sub_14035B120(&v13, &v12);
  v5 = v13;
  n0x9E37 = 0x9E37;
  for ( i = *v13; *v5; i = *v5 )
  {
    ++v5;
    v8 = i + 0x20;
    if ( (unsigned __int8)(i - 0x41) > 0x19u )
      v8 = i;
    n0x9E37 = ((0x401 * (n0x9E37 + v8)) >> 6) ^ (0x401 * (n0x9E37 + v8));
  }
  v9 = 0x8001 * ((9 * n0x9E37) ^ ((9 * n0x9E37) >> 0xB)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = *(__m128i *)sub_1403090E0((_QWORD *)(a1 + 0x40), &v14, &v13, *((_QWORD *)&v9 + 1) + v9);
  v13 = (char *)&qword_149B3B33C + 4;
  v14 = v10;
  sub_140370D10(&v13);
  if ( v14.m128i_i64[0] == *(_QWORD *)(a1 + 0x40) + *(_QWORD *)(a1 + 0x58) )
  {
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(_mm_extract_epi64(v14, 1) + 0x10);
  }
  return a2;
}

// --- End Function: sub_1474A4240 (0x1474A4240) ---

// --- Function: sub_1474A4540 (0x1474A4540) ---
__int64 __fastcall sub_1474A4540(_QWORD *a1, __int64 a2)
{
  __int64 v3; // r8
  int v4; // eax
  int v5; // r8d
  __int64 v6; // rdx
  __int64 *v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx

  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v3;
  while ( *(_BYTE *)(a2 + v3) );
  v4 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(0xFFFFFFFF, a2, v3);
  v5 = ~v4;
  v6 = a1[0x6C];
  v7 = (__int64 *)(a1[0x6E]
                 + 0x10
                 * ((0x100000001B3LL
                   * (((unsigned __int64)(unsigned int)~v4 >> 0x18)
                    ^ (0x100000001B3LL
                     * ((unsigned __int8)((unsigned int)~v4 >> 0x10)
                      ^ (0x100000001B3LL
                       * ((0x100000001B3LL * ((unsigned __int8)~(_BYTE)v4 ^ 0xCBF29CE484222325uLL))
                        ^ (unsigned __int8)((unsigned __int16)~(_WORD)v4 >> 8)))))))
                  & a1[0x71]));
  v8 = v7[1];
  if ( v8 != v6 )
  {
    v9 = *v7;
    if ( v5 == *(_DWORD *)(v8 + 0x10) )
      goto LABEL_9;
    while ( v8 != v9 )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( v5 == *(_DWORD *)(v8 + 0x10) )
        goto LABEL_9;
    }
  }
  v8 = 0;
LABEL_9:
  if ( !v8 )
    v8 = a1[0x6C];
  if ( v8 == v6 )
    return 0;
  else
    return *(_QWORD *)(v8 + 0x18);
}

// --- End Function: sub_1474A4540 (0x1474A4540) ---

// --- Function: sub_1474A4630 (0x1474A4630) ---
_BYTE *__fastcall sub_1474A4630(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int8 ***v7; // rdi
  size_t n511; // rbx
  unsigned __int8 **v9; // r11
  unsigned __int64 v10; // r9
  unsigned __int8 **v11; // r10
  unsigned __int8 *v12; // rax
  int v13; // ecx
  int v14; // edx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdi
  _BYTE *result; // rax

  v7 = (unsigned __int8 ***)DataCore::LookupDCStructDescByName(a1, a3);
  if ( v7 )
  {
    n511 = 0;
    while ( 1 )
    {
      v9 = v7[1];
      v10 = 0;
      if ( v9 )
        break;
LABEL_10:
      v7 = (unsigned __int8 ***)DataCore::LookupDCStructDescByName(a1, (__int64)v7[3]);
      if ( !v7 )
        goto LABEL_11;
    }
    v11 = *v7;
    while ( 1 )
    {
      v12 = *v11;
      do
      {
        v13 = v12[a4 - (_QWORD)*v11];
        v14 = *v12 - v13;
        if ( v14 )
          break;
        ++v12;
      }
      while ( v13 );
      if ( !v14 )
        break;
      ++v10;
      v11 += 5;
      if ( v10 >= (unsigned __int64)v9 )
        goto LABEL_10;
    }
    if ( (unsigned __int8)(*((_BYTE *)v11 + 0x18) - 0xF) > 1u )
    {
      result = *(_BYTE **)(a2 + 0x10);
      *(_QWORD *)a2 = 0;
      *result = 0;
      return result;
    }
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)v11[4];
    if ( p_p_p_p_p_p_p_p_p_p_p_p_Source )
    {
      n511 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++n511;
      while ( *((_BYTE *)p_p_p_p_p_p_p_p_p_p_p_p_Source + n511) );
    }
  }
  else
  {
LABEL_11:
    p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
    n511 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n511;
    while ( *((_BYTE *)&p_p_p_p_p_p_p_p_p_p_p_Source + n511) );
  }
  if ( n511 > *(_QWORD *)(a2 + 8) )
  {
    sub_1402A3C90((_QWORD *)a2);
    sub_1402A3B50((__int64 *)a2, n511);
  }
  memmove(*(void **)(a2 + 0x10), p_p_p_p_p_p_p_p_p_p_p_p_Source, n511);
  result = *(_BYTE **)(a2 + 0x10);
  *(_QWORD *)a2 = n511;
  result[n511] = 0;
  return result;
}

// --- End Function: sub_1474A4630 (0x1474A4630) ---

// --- Function: sub_1474A4770 (0x1474A4770) ---
__int64 __fastcall sub_1474A4770(_QWORD *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  __int64 v7; // r8
  unsigned int v8; // eax
  __int64 v9; // r8
  unsigned int v10; // eax
  unsigned int v11; // ebp
  __int64 v12; // r8
  int v13; // eax
  __int64 *v14; // r8
  unsigned int v15; // eax
  __int64 *v16; // rdx
  __int64 *v17; // rcx
  signed __int64 i; // rbx
  unsigned __int8 *v20; // rdx
  __int64 v21; // r8
  int v22; // eax
  unsigned int v23; // eax
  __int64 *v24; // r8
  __int64 *v25; // rcx

  if ( a1[0x5B] )
  {
    v7 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v7;
    while ( a4[v7] );
    v8 = psub_140336210(0xFFFFFFFF, a4, v7);
    v9 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v9;
    while ( a3[v9] );
    v10 = psub_140336210(v8, a3, v9);
    v11 = v10;
    v12 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v12;
    while ( a2[v12] );
    v13 = psub_140336210(v10, a2, v12);
    v14 = (__int64 *)a1[0x61];
    v15 = ~v13;
    v16 = v14;
    v17 = (__int64 *)v14[1];
    while ( !*((_BYTE *)v17 + 0x19) )
    {
      if ( *((_DWORD *)v17 + 7) >= v15 )
      {
        v16 = v17;
        v17 = (__int64 *)*v17;
      }
      else
      {
        v17 = (__int64 *)v17[2];
      }
    }
    if ( !*((_BYTE *)v16 + 0x19) && v15 >= *((_DWORD *)v16 + 7) && v16 != v14 )
      return a1[0x5E] + *((unsigned int *)v16 + 8);
    for ( i = DataCore::LookupDCStructDescByName((__int64)a1, (__int64)a2);
          i;
          i = DataCore::LookupDCStructDescByName((__int64)a1, *(_QWORD *)(i + 0x18)) )
    {
      v20 = *(unsigned __int8 **)(i + 0x18);
      if ( !v20 )
        break;
      v21 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v21;
      while ( v20[v21] );
      v22 = psub_140336210(v11, v20, v21);
      v16 = (__int64 *)a1[0x61];
      v23 = ~v22;
      v24 = v16;
      v25 = (__int64 *)v16[1];
      if ( !*((_BYTE *)v25 + 0x19) )
      {
        do
        {
          if ( *((_DWORD *)v25 + 7) >= v23 )
          {
            v16 = v25;
            v25 = (__int64 *)*v25;
          }
          else
          {
            v25 = (__int64 *)v25[2];
          }
        }
        while ( !*((_BYTE *)v25 + 0x19) );
        v24 = (__int64 *)a1[0x61];
      }
      if ( !*((_BYTE *)v16 + 0x19) && v23 >= *((_DWORD *)v16 + 7) && v16 != v24 )
        return a1[0x5E] + *((unsigned int *)v16 + 8);
    }
  }
  return 0;
}

// --- End Function: sub_1474A4770 (0x1474A4770) ---

// --- Function: sub_1474A4920 (0x1474A4920) ---
__int64 __fastcall sub_1474A4920(_QWORD *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  __int64 v9; // rdi
  size_t n0x1FF_1; // rbx
  _BYTE *v11; // rax
  size_t Size; // r8
  size_t Size_1; // r8
  int v14; // eax
  __int64 *v15; // r8
  unsigned int v16; // eax
  __int64 *v17; // rdx
  __int64 *v18; // rcx
  __int64 n0x1FF_2; // [rsp+20h] [rbp-268h] BYREF
  __int64 n0x1FF; // [rsp+28h] [rbp-260h]
  void *v21; // [rsp+30h] [rbp-258h]
  _BYTE v22[520]; // [rsp+38h] [rbp-250h] BYREF

  if ( !a1[0x5B] )
    return 0;
  v9 = 0;
  v22[0] = 0;
  v21 = v22;
  n0x1FF_2 = 0;
  n0x1FF = 0x1FF;
  if ( a2 )
  {
    n0x1FF_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++n0x1FF_1;
    while ( a2[n0x1FF_1] );
    if ( n0x1FF_1 )
    {
      v11 = v22;
      if ( n0x1FF_1 + 1 > 0x200 )
      {
        v11 = (_BYTE *)allocWithProfilerInfo(n0x1FF_1 + 1, 0);
        qword_149B3AB68 += n0x1FF_1 + 1;
        n0x1FF = n0x1FF_1;
      }
      v21 = v11;
      n0x1FF_2 = n0x1FF_1;
      v11[n0x1FF_1] = 0;
      memcpy(v21, a2, n0x1FF_1);
    }
  }
  if ( a3 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a3[Size] );
  }
  else
  {
    Size = 0;
  }
  sub_1402DECA0((unsigned __int64 *)&n0x1FF_2, a3, Size);
  if ( a4 )
  {
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( a4[Size_1] );
  }
  else
  {
    Size_1 = 0;
  }
  sub_1402DECA0((unsigned __int64 *)&n0x1FF_2, a4, Size_1);
  v14 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(0xFFFFFFFF, (__int64)v21, n0x1FF_2);
  v15 = (__int64 *)a1[0x5F];
  v16 = ~v14;
  v17 = v15;
  v18 = (__int64 *)v15[1];
  while ( !*((_BYTE *)v18 + 0x19) )
  {
    if ( *((_DWORD *)v18 + 7) >= v16 )
    {
      v17 = v18;
      v18 = (__int64 *)*v18;
    }
    else
    {
      v18 = (__int64 *)v18[2];
    }
  }
  if ( !*((_BYTE *)v17 + 0x19) && v16 >= *((_DWORD *)v17 + 7) && v17 != v15 )
    v9 = a1[0x5E] + *((unsigned int *)v17 + 8);
  if ( v21 != v22 )
  {
    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
    sub_147605980(v21);
  }
  return v9;
}

// --- End Function: sub_1474A4920 (0x1474A4920) ---

// --- Function: sub_1474A4B20 (0x1474A4B20) ---
__int64 __fastcall sub_1474A4B20(_QWORD *a1, __int64 a2)
{
  __int64 v3; // r8
  int v4; // eax
  int v5; // r8d
  __int64 v6; // rdx
  __int64 *v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx

  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v3;
  while ( *(_BYTE *)(a2 + v3) );
  v4 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(0xFFFFFFFF, a2, v3);
  v5 = ~v4;
  v6 = a1[0x64];
  v7 = (__int64 *)(a1[0x66]
                 + 0x10
                 * ((0x100000001B3LL
                   * (((unsigned __int64)(unsigned int)~v4 >> 0x18)
                    ^ (0x100000001B3LL
                     * ((unsigned __int8)((unsigned int)~v4 >> 0x10)
                      ^ (0x100000001B3LL
                       * ((0x100000001B3LL * ((unsigned __int8)~(_BYTE)v4 ^ 0xCBF29CE484222325uLL))
                        ^ (unsigned __int8)((unsigned __int16)~(_WORD)v4 >> 8)))))))
                  & a1[0x69]));
  v8 = v7[1];
  if ( v8 != v6 )
  {
    v9 = *v7;
    if ( v5 == *(_DWORD *)(v8 + 0x10) )
      goto LABEL_9;
    while ( v8 != v9 )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( v5 == *(_DWORD *)(v8 + 0x10) )
        goto LABEL_9;
    }
  }
  v8 = 0;
LABEL_9:
  if ( !v8 )
    v8 = a1[0x64];
  if ( v8 == v6 )
    return 0;
  else
    return *(_QWORD *)(v8 + 0x18);
}

// --- End Function: sub_1474A4B20 (0x1474A4B20) ---

// --- Function: sub_1474A4C10 (0x1474A4C10) ---
void __fastcall sub_1474A4C10(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  int v4; // r12d
  unsigned int v5; // r15d
  __int64 v6; // rax
  char *v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // r14
  void *v10; // rdi
  signed __int64 v11; // rsi
  unsigned __int64 v12; // r13
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  char *v16; // rcx
  const void *v17; // rdx
  char *Size; // r8
  __int64 v19; // rdi
  __int64 v20; // [rsp+20h] [rbp-60h] BYREF
  void *Src[2]; // [rsp+28h] [rbp-58h] BYREF
  char *v22; // [rsp+38h] [rbp-48h]
  __int64 v23; // [rsp+90h] [rbp+10h]
  __int64 v24; // [rsp+98h] [rbp+18h]
  __int64 v25; // [rsp+A0h] [rbp+20h]
  char v26; // [rsp+A8h] [rbp+28h]

  if ( a2 )
  {
    v26 = a4;
    v25 = a3;
    v24 = a2;
    v23 = a1;
    v4 = 0;
    v5 = 0;
    v6 = *(_QWORD *)(a1 + 0x1F8);
    *(_OWORD *)Src = 0;
    v7 = 0;
    v22 = 0;
    if ( *(_DWORD *)(v6 + 0x10) )
    {
      do
      {
        v8 = *(_QWORD *)(a1 + 0x200);
        v9 = v8 + 0x10LL * (int)v5;
        v20 = v9;
        if ( v8 + 0x10LL * *(unsigned int *)(v9 + 4) == a2 )
        {
          sub_1402A6620(a3, &v20);
          v10 = Src[1];
          if ( Src[1] == v22 )
          {
            v11 = ((char *)Src[1] - (char *)Src[0]) >> 3;
            if ( v11 == 0x1FFFFFFFFFFFFFFFLL )
              unknown_libname_10();
            v12 = v11 + 1;
            v13 = (v22 - (char *)Src[0]) >> 3;
            v14 = v13 >> 1;
            if ( v13 <= 0x1FFFFFFFFFFFFFFFLL - (v13 >> 1) )
            {
              v15 = v14 + v13;
              if ( v14 + v13 < v12 )
                v15 = v11 + 1;
            }
            else
            {
              v15 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v20 = 8 * v15;
            v7 = (char *)sub_140391AB0((__int64)Src, 8 * v15);
            v16 = v7;
            *(_QWORD *)&v7[8 * v11] = v9;
            v17 = Src[0];
            if ( v10 == Src[1] )
            {
              Size = (char *)((char *)Src[1] - (char *)Src[0]);
            }
            else
            {
              memmove(v7, Src[0], (size_t)v10 - (unsigned __int64)Src[0]);
              v16 = &v7[8 * v11 + 8];
              Size = (char *)((char *)Src[1] - (char *)v10);
              v17 = v10;
            }
            memmove(v16, v17, (size_t)Size);
            if ( Src[0] )
              sub_1403A3120((__int64)Src, Src[0], (v22 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
            Src[0] = v7;
            Src[1] = &v7[8 * v12];
            v22 = &v7[v20];
          }
          else
          {
            *(_QWORD *)Src[1] = v9;
            Src[1] = (char *)Src[1] + 8;
            v7 = (char *)Src[0];
          }
          a2 = v24;
          a3 = v25;
        }
        a1 = v23;
        ++v5;
      }
      while ( v5 < *(_DWORD *)(*(_QWORD *)(v23 + 0x1F8) + 0x10LL) );
      a4 = v26;
    }
    if ( a4 && ((char *)Src[1] - (char *)v7) >> 3 )
    {
      v19 = 0;
      do
      {
        sub_1474A4C10(a1, *(_QWORD *)&v7[v19]);
        v19 += 8;
        v7 = (char *)Src[0];
        ++v4;
        a1 = v23;
      }
      while ( v4 < (unsigned __int64)(((char *)Src[1] - (char *)Src[0]) >> 3) );
    }
    if ( v7 )
      sub_1403A3120((__int64)Src, v7, (v22 - v7) & 0xFFFFFFFFFFFFFFF8uLL);
  }
}

// --- End Function: sub_1474A4C10 (0x1474A4C10) ---

// --- Function: sub_1474A4E70 (0x1474A4E70) ---
__int64 __fastcall sub_1474A4E70(_QWORD *a1, __int64 a2, const char *s1)
{
  int v3; // ebx
  int v4; // r9d
  __int64 v7; // rdi
  int v8; // r14d
  unsigned int n6; // esi
  __int64 v10; // rax

  v3 = *(unsigned __int16 *)(a2 + 8);
  v4 = 0;
  if ( !*(_WORD *)(a2 + 8) )
    return 0;
  v7 = a1[0x41];
  v8 = *(unsigned __int16 *)(a2 + 0xA);
  n6 = *(_DWORD *)(a1[0x3F] + 4LL);
  while ( 1 )
  {
    v10 = n6 >= 6 ? a1[0x55] : a1[0x54];
    if ( !strcmp(s1, (const char *)(*(unsigned int *)(v7 + 0xCLL * (v8 + v4)) + v10)) )
      break;
    if ( ++v4 >= v3 )
      return 0;
  }
  return v7 + 0xCLL * (v8 + v4);
}

// --- End Function: sub_1474A4E70 (0x1474A4E70) ---

// --- Function: sub_1474A4F20 (0x1474A4F20) ---
__int64 __fastcall sub_1474A4F20(_QWORD *a1, __int64 a2)
{
  char n0xF; // al
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v7; // rdx
  __int64 v8; // rax

  n0xF = *(_BYTE *)(a2 + 6);
  if ( n0xF == 0x10 )
  {
    v4 = *(unsigned int *)(a1[0x40] + 0x10LL * *(unsigned __int16 *)(a2 + 4));
    if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
      v5 = a1[0x55];
    else
      v5 = a1[0x54];
    return v4 + v5;
  }
  else if ( n0xF == 0xF )
  {
    v7 = *(unsigned int *)(a1[0x42] + 8LL * *(unsigned __int16 *)(a2 + 4));
    if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
      v8 = a1[0x55];
    else
      v8 = a1[0x54];
    return v7 + v8;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_1474A4F20 (0x1474A4F20) ---

// --- Function: sub_1474A4FA0 (0x1474A4FA0) ---
__int64 __fastcall sub_1474A4FA0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  if ( !a2 )
    return 0;
  v2 = *(unsigned int *)(a2 + 4);
  if ( (_DWORD)v2 == 0xFFFFFFFF )
    return 0;
  else
    return *(_QWORD *)(a1 + 0x200) + 0x10 * v2;
}

// --- End Function: sub_1474A4FA0 (0x1474A4FA0) ---

// --- Function: sub_1474A4FC0 (0x1474A4FC0) ---
__int64 __fastcall sub_1474A4FC0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned int v6; // esi
  unsigned int v7; // r10d
  __int64 v8; // rax
  __int64 v9; // rbx
  unsigned int *v10; // r9
  unsigned int *i; // r11
  __int64 v12; // rcx
  unsigned __int8 *v13; // rax
  __int64 v14; // r8
  int v15; // ecx
  int v16; // edx
  unsigned __int8 *v17; // rax
  __int64 v18; // r8
  int v19; // ecx
  int v20; // edx

  v3 = a1[0x5B];
  if ( !v3 )
    return 0;
  v6 = *(_DWORD *)(v3 + 4);
  v7 = 0;
  if ( !v6 )
    return 0;
  v8 = a1[0x5C];
  v9 = a1[0x5E];
  v10 = (unsigned int *)(v8 + 8);
  for ( i = (unsigned int *)(v8 + 4); ; i += 4 )
  {
    v12 = *i;
    v13 = (unsigned __int8 *)(v9 + v10[0xFFFFFFFE]);
    if ( (_DWORD)v12 == 0xFFFFFFFF || !(v9 + v12) )
    {
      v14 = a2 - (_QWORD)v13;
      do
      {
        v15 = v13[v14];
        v16 = *v13 - v15;
        if ( v16 )
          break;
        ++v13;
      }
      while ( v15 );
      if ( !v16 )
      {
        v17 = (unsigned __int8 *)(v9 + *v10);
        v18 = a3 - (_QWORD)v17;
        do
        {
          v19 = v17[v18];
          v20 = *v17 - v19;
          if ( v20 )
            break;
          ++v17;
        }
        while ( v19 );
        if ( !v20 )
          break;
      }
    }
    ++v7;
    v10 += 4;
    if ( v7 >= v6 )
      return 0;
  }
  return v9 + v10[1];
}

// --- End Function: sub_1474A4FC0 (0x1474A4FC0) ---

// --- Function: sub_1474A50B0 (0x1474A50B0) ---
__int64 __fastcall sub_1474A50B0(_QWORD *a1, unsigned int *a2)
{
  __int64 v3; // rax

  if ( !a2 )
    return 0;
  if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
    v3 = a1[0x55];
  else
    v3 = a1[0x54];
  return *a2 + v3;
}

// --- End Function: sub_1474A50B0 (0x1474A50B0) ---

// --- Function: sub_1474A5370 (0x1474A5370) ---
signed __int64 __fastcall sub_1474A5370(__int64 a1, __int64 a2, unsigned __int64 pOutFieldPtrsVec, char a4)
{
  signed __int64 totalFieldCount_4; // rax
  char *v7; // rbx
  unsigned __int64 v8; // r14
  signed __int64 v9; // rax
  int v10; // r15d
  __int64 *ThreadLogContextSlot; // rax
  unsigned __int64 totalFieldCount; // r15
  __int64 v13; // rbx
  unsigned __int64 i; // rax
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 totalFieldCount_6; // r11
  _QWORD *v18; // r9
  unsigned __int64 totalFieldCount_8; // r10
  int totalFieldCount_7; // r8d
  _QWORD *pOutFieldPtrsVec_3; // r14
  unsigned __int64 totalFieldCount_1; // rbx
  __m128i v23; // xmm5
  unsigned int totalFieldCount_2; // edi
  char *pOutFieldPtrsVec_1; // rdx
  unsigned __int64 pOutFieldPtrsVec_2; // rax
  __int64 n0x20; // rcx
  unsigned int n4; // r9d
  __int128 totalFieldCount_3; // xmm0
  __int128 n4_1; // xmm0
  __int64 v50; // r8
  int n0xE9; // [rsp+50h] [rbp-B0h] BYREF
  int n0x1F; // [rsp+54h] [rbp-ACh]
  int *p_n0xE9; // [rsp+58h] [rbp-A8h] BYREF
  int **p_p_n0xE9; // [rsp+60h] [rbp-A0h]
  __int128 v55; // [rsp+68h] [rbp-98h] BYREF
  signed __int64 totalFieldCount_5; // [rsp+80h] [rbp-80h]
  __m256 v57; // [rsp+88h] [rbp-78h]
  __m256 v58; // [rsp+A8h] [rbp-58h]
  __m256 v59; // [rsp+C8h] [rbp-38h]
  __int128 v60; // [rsp+E8h] [rbp-18h]
  __int64 v61; // [rsp+F8h] [rbp-8h]

  if ( *(_QWORD *)pOutFieldPtrsVec != *(_QWORD *)(pOutFieldPtrsVec + 8) )
    *(_QWORD *)(pOutFieldPtrsVec + 8) = *(_QWORD *)pOutFieldPtrsVec;
  if ( a4 )
  {
    totalFieldCount_4 = DataCore::LookupDCStructDescByName(a1, a2);
    if ( totalFieldCount_4 )
    {
      v7 = *(char **)(totalFieldCount_4 + 0x18);
      v61 = 0;
      totalFieldCount_5 = totalFieldCount_4;
      v8 = 1;
      v57 = (__m256)0LL;
      v58 = (__m256)0LL;
      v59 = (__m256)0LL;
      v60 = 0;
      if ( v7 )
      {
        while ( 1 )
        {
          __asm { vzeroupper }
          v9 = DataCore::LookupDCStructDescByName(a1, (__int64)v7);
          if ( !v9 )
            break;
          v7 = *(char **)(v9 + 0x18);
          *(&totalFieldCount_5 + v8++) = v9;
          if ( !v7 )
            goto LABEL_11;
        }
        n0xE9 = 0xE9;
        p_n0xE9 = &n0xE9;
        n0x1F = 0x1F;
        p_p_n0xE9 = &p_n0xE9;
        v10 = invokeGlobalCallbackAndMaskStatusBits(
                3,
                (__int64)&p_n0xE9,
                (__int64)"[DataCore] CDataCore::GetStructDataFields - [%s] has no DCStructDesc",
                v7);
        if ( (v10 & 0xFFFFF) != 0 )
        {
          ThreadLogContextSlot = getThreadLogContextSlot();
          p_n0xE9 = &n0xE9;
          p_p_n0xE9 = &p_n0xE9;
          n0xE9 = 0xE9;
          v55 = 0;
          n0x1F = 0x1F;
          sub_1403515F0(
            3u,
            (__int64 *)&p_n0xE9,
            "[DataCore] CDataCore::GetStructDataFields - [%s] has no DCStructDesc",
            v7,
            1,
            v10,
            &v55,
            0,
            (__int64)ThreadLogContextSlot);
        }
      }
LABEL_11:
      totalFieldCount = 0;
      v13 = 0;
      for ( i = 0; i < v8; ++i )
      {
        v15 = *(&totalFieldCount_5 + i);
        if ( v15 )
          v16 = *(_QWORD *)(v15 + 8);
        else
          v16 = 0;
        totalFieldCount += v16;
      }
      __asm { vzeroupper }
      totalFieldCount_4 = (signed __int64)ensureCapacityAndZeroFill((char **)pOutFieldPtrsVec, totalFieldCount);
      if ( totalFieldCount )
      {
        totalFieldCount_4 = (unsigned int)(v8 - 1);
        for ( totalFieldCount_6 = (int)totalFieldCount_4; totalFieldCount_6 >= 0; --totalFieldCount_6 )
        {
          v18 = (_QWORD *)*(&totalFieldCount_5 + totalFieldCount_6);
          if ( v18 )
          {
            totalFieldCount_8 = v18[1];
            totalFieldCount_7 = 0;
            if ( totalFieldCount_8 )
            {
              totalFieldCount_4 = 0;
              do
              {
                ++totalFieldCount_7;
                *(_QWORD *)(*(_QWORD *)pOutFieldPtrsVec + 8 * v13++) = *v18 + 0x28 * totalFieldCount_4;
                totalFieldCount_4 = totalFieldCount_7;
              }
              while ( totalFieldCount_7 < totalFieldCount_8 );
            }
          }
        }
      }
    }
  }
  else
  {
    totalFieldCount_4 = DataCore::LookupDCStructDescByName(a1, a2);
    pOutFieldPtrsVec_3 = (_QWORD *)totalFieldCount_4;
    if ( totalFieldCount_4 )
    {
      totalFieldCount_1 = *(_QWORD *)(totalFieldCount_4 + 8);
      ensureCapacityAndZeroFill((char **)pOutFieldPtrsVec, totalFieldCount_1);
      totalFieldCount_2 = 0;
      if ( totalFieldCount_1 >= 8 && n5 >= 6 )
      {
        pOutFieldPtrsVec_1 = *(char **)pOutFieldPtrsVec;
        __asm { vbroadcastsd ymm5, qword ptr [r14] }
        pOutFieldPtrsVec_2 = *(_QWORD *)pOutFieldPtrsVec + 8LL * ((int)totalFieldCount_1 - 1);
        if ( (*(_QWORD *)pOutFieldPtrsVec > (unsigned __int64)pOutFieldPtrsVec_3
           || pOutFieldPtrsVec_2 < (unsigned __int64)pOutFieldPtrsVec_3)
          && ((unsigned __int64)pOutFieldPtrsVec_1 > pOutFieldPtrsVec || pOutFieldPtrsVec_2 < pOutFieldPtrsVec) )
        {
          n0x20 = 0x20;
          n4 = 4;
          do
          {
            totalFieldCount_3 = totalFieldCount_2;
            __asm { vpshufd xmm0, xmm0, 0 }
            _XMM0 = _mm_add_epi32(_XMM0, (__m128i)0x100000000uLL);
            __asm
            {
              vpmovsxdq xmm1, xmm0
              vpmullq xmm2, xmm1, xmm6
            }
            *(__m128i *)&pOutFieldPtrsVec_1[n0x20 - 0x20] = _mm_add_epi64(_XMM2, v23);
            _XMM0 = n4 - 2;
            __asm { vpshufd xmm0, xmm0, 0 }
            _XMM0 = _mm_add_epi32(_XMM0, (__m128i)0x100000000uLL);
            __asm
            {
              vpmovsxdq xmm1, xmm0
              vpmullq xmm2, xmm1, xmm6
            }
            *(__m128i *)&pOutFieldPtrsVec_1[n0x20 - 0x10] = _mm_add_epi64(_XMM2, v23);
            totalFieldCount_2 += 8;
            n4_1 = n4;
            __asm { vpshufd xmm0, xmm0, 0 }
            _XMM0 = _mm_add_epi32(_XMM0, (__m128i)0x100000000uLL);
            __asm
            {
              vpmovsxdq xmm1, xmm0
              vpmullq xmm2, xmm1, xmm6
            }
            *(__m128i *)&pOutFieldPtrsVec_1[n0x20] = _mm_add_epi64(_XMM2, v23);
            _XMM0 = n4 + 2;
            __asm { vpshufd xmm0, xmm0, 0 }
            _XMM0 = _mm_add_epi32(_XMM0, (__m128i)0x100000000uLL);
            __asm
            {
              vpmovsxdq xmm1, xmm0
              vpmullq xmm2, xmm1, xmm6
            }
            n4 += 8;
            *(__m128i *)&pOutFieldPtrsVec_1[n0x20 + 0x10] = _mm_add_epi64(_XMM2, v23);
            n0x20 += 0x40;
          }
          while ( (int)totalFieldCount_2 < (totalFieldCount_1 & 0xFFFFFFFFFFFFFFF8uLL) );
        }
      }
      totalFieldCount_4 = (int)totalFieldCount_2;
      if ( (int)totalFieldCount_2 < totalFieldCount_1 )
      {
        v50 = 8LL * (int)totalFieldCount_2;
        do
        {
          ++totalFieldCount_2;
          v50 += 8;
          *(_QWORD *)(v50 + *(_QWORD *)pOutFieldPtrsVec - 8) = *pOutFieldPtrsVec_3 + 0x28 * totalFieldCount_4;
          totalFieldCount_4 = (int)totalFieldCount_2;
        }
        while ( (int)totalFieldCount_2 < totalFieldCount_1 );
      }
    }
  }
  __asm { vzeroupper }
  return totalFieldCount_4;
}

// --- End Function: sub_1474A5370 (0x1474A5370) ---

// --- Function: DataCore::LookupDCStructDescByName (0x1474A5750) ---
signed __int64 __fastcall DataCore::LookupDCStructDescByName(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rdx
  __int64 i; // r8
  __int64 v6; // rcx
  __m128i v7; // xmm0
  __int64 v9; // [rsp+20h] [rbp-28h] BYREF
  char *v10; // [rsp+28h] [rbp-20h] BYREF
  __m128i v11; // [rsp+30h] [rbp-18h] BYREF

  v9 = a2;
  sub_14035B120(&v10, &v9);
  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v3;
  while ( v10[v3] );
  v4 = 0;
  for ( i = 0xCBF29CE484222325uLL; v4 < v3; i = 0x100000001B3LL * (v6 ^ i) )
    v6 = (unsigned __int8)v10[v4++];
  v7 = *(__m128i *)sub_14747F260(
                     a1 + 0x130,
                     &v11,
                     &v10,
                     0xDE5FB9D2630458E9uLL * i
                   + (((unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
  v10 = (char *)&qword_149B3B33C + 4;
  v11 = v7;
  sub_140370D10(&v10);
  if ( v11.m128i_i64[0] == *(_QWORD *)(a1 + 0x130) + *(_QWORD *)(a1 + 0x148) )
    return 0;
  else
    return _mm_extract_epi64(v11, 1) + 8;
}

// --- End Function: DataCore::LookupDCStructDescByName (0x1474A5750) ---

// --- Function: sub_1474A5850 (0x1474A5850) ---
__int64 __fastcall sub_1474A5850(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v6; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rbx
  unsigned __int64 v9; // r9
  __int64 v10; // rcx
  _QWORD *v11; // rax
  unsigned __int64 v12; // rcx
  __int64 *v13; // rax
  __int64 v15; // rbx
  __int128 pOutFieldPtrsVec_; // [rsp+20h] [rbp-28h] BYREF
  __int64 v17; // [rsp+30h] [rbp-18h]

  v6 = (_QWORD *)DataCore::LookupDCStructDescByName(a1, a2);
  if ( !v6 )
    return 0;
  v7 = v6[1];
  v8 = 0;
  v9 = 0;
  if ( !v7 )
  {
LABEL_6:
    v17 = 0;
    pOutFieldPtrsVec_ = 0;
    sub_1474A5370(a1, a2, (unsigned __int64)&pOutFieldPtrsVec_, 1);
    v12 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
    if ( v12 )
    {
      while ( 1 )
      {
        v13 = *(__int64 **)(pOutFieldPtrsVec_ + 8 * v8);
        if ( v13[1] == a3 )
          break;
        if ( ++v8 >= v12 )
          goto LABEL_9;
      }
      v15 = *v13;
      if ( (_QWORD)pOutFieldPtrsVec_ )
        sub_1403A3120(
          (__int64)&pOutFieldPtrsVec_,
          (const void *)pOutFieldPtrsVec_,
          (v17 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
      return v15;
    }
LABEL_9:
    if ( (_QWORD)pOutFieldPtrsVec_ )
      sub_1403A3120(
        (__int64)&pOutFieldPtrsVec_,
        (const void *)pOutFieldPtrsVec_,
        (v17 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
    return 0;
  }
  v10 = *v6;
  v11 = (_QWORD *)(*v6 + 8LL);
  while ( *v11 != a3 )
  {
    ++v9;
    v11 += 5;
    if ( v9 >= v7 )
      goto LABEL_6;
  }
  return *(_QWORD *)(v10 + 0x28 * v9);
}

// --- End Function: sub_1474A5850 (0x1474A5850) ---

// --- Function: sub_1474A5C30 (0x1474A5C30) ---
__int64 __fastcall sub_1474A5C30(int a1, int a2, int a3, int a4, char a5)
{
  __int64 result; // rax
  const void *v6; // rcx
  __int128 v7; // [rsp+30h] [rbp-28h] BYREF
  __int64 v8; // [rsp+40h] [rbp-18h]

  v7 = 0;
  v8 = 0;
  result = sub_1474A5CB0(a1, a2, a3, a4, (__int64)&v7, a5);
  v6 = (const void *)v7;
  if ( (_QWORD)v7 )
  {
    if ( ((v8 - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      v6 = *(const void **)(v7 - 8);
      if ( (unsigned __int64)(v7 - (_QWORD)v6 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    return sub_1402A3D30(v6);
  }
  return result;
}

// --- End Function: sub_1474A5C30 (0x1474A5C30) ---

// --- Function: sub_1474A5CB0 (0x1474A5CB0) ---
const vraudio::AudioBuffer **__fastcall sub_1474A5CB0(
        __int64 a1,
        __int64 a2,
        unsigned __int8 *a3,
        __int64 a4,
        _QWORD *a5,
        char a6)
{
  int v7; // ebx
  __int64 v8; // r12
  unsigned __int8 *v9; // r15
  __int64 v10; // r14
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  __int64 i; // r8
  __int64 v14; // rax
  __m128i v15; // xmm0
  const vraudio::AudioBuffer **_Whereptr_1; // rax
  const vraudio::AudioBuffer *__Val_0___1; // rdi
  _QWORD *v18; // r13
  const vraudio::AudioBuffer **_Whereptr; // rdx
  __int64 v20; // rsi
  __int64 v21; // rsi
  int v22; // edi
  void *v23; // rax
  unsigned __int64 v24; // rdi
  unsigned __int64 allocSize; // rdi
  char n3; // dl
  _QWORD *v27; // r13
  unsigned __int64 v28; // r12
  __int64 v29; // r15
  __int64 v30; // r14
  __int64 v31; // rsi
  unsigned __int8 (__fastcall *v32)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v33; // rax
  bool v34; // di
  unsigned __int64 v35; // r15
  __int64 v36; // r14
  bool v37; // zf
  __int64 v38; // r14
  __int64 v39; // rsi
  unsigned __int8 (__fastcall *v40)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v41; // rax
  bool v42; // di
  unsigned __int64 v43; // r12
  __int64 v44; // r15
  __int64 v45; // r14
  __int64 v46; // rsi
  unsigned __int8 (__fastcall *v47)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v48; // rax
  bool v49; // di
  _QWORD *v50; // r14
  __int64 v51; // rsi
  unsigned __int8 (__fastcall *v52)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v53; // rax
  bool v54; // di
  int v55; // [rsp+30h] [rbp-59h]
  __int64 v56; // [rsp+38h] [rbp-51h] BYREF
  char *v57; // [rsp+40h] [rbp-49h] BYREF
  const vraudio::AudioBuffer *__Val_0__; // [rsp+48h] [rbp-41h] BYREF
  const void *v59; // [rsp+50h] [rbp-39h]
  const vraudio::AudioBuffer **_Whereptr_2; // [rsp+58h] [rbp-31h]
  __m128i v61; // [rsp+60h] [rbp-29h] BYREF
  _BYTE v62[8]; // [rsp+70h] [rbp-19h] BYREF
  const void *v63; // [rsp+78h] [rbp-11h]
  int v64; // [rsp+E0h] [rbp+57h]

  v64 = a1;
  v7 = 0;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
  sub_14035B120(&v57, &v56);
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v11;
  while ( v57[v11] );
  v12 = 0;
  for ( i = 0xCBF29CE484222325uLL; v12 < v11; i = 0x100000001B3LL * (v14 ^ i) )
    v14 = (unsigned __int8)v57[v12++];
  v15 = *(__m128i *)sub_14747F260(
                      (_QWORD *)(a1 + 0x130),
                      &v61,
                      &v57,
                      0xDE5FB9D2630458E9uLL * i
                    + (((unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
  v57 = (char *)&qword_149B3B33C + 4;
  v61 = v15;
  sub_140370D10(&v57);
  _Whereptr_1 = (const vraudio::AudioBuffer **)v61.m128i_i64[0];
  if ( v61.m128i_i64[0] != *(_QWORD *)(a1 + 0x130) + *(_QWORD *)(a1 + 0x148) )
  {
    __Val_0___1 = (const vraudio::AudioBuffer *)(_mm_extract_epi64(v61, 1) + 8);
    v18 = a5;
    __Val_0__ = __Val_0___1;
    _Whereptr_1 = (const vraudio::AudioBuffer **)unknown_libname_248(*a5, a5[1], __Val_0___1);
    _Whereptr = (const vraudio::AudioBuffer **)a5[1];
    if ( _Whereptr_1 == _Whereptr )
    {
      if ( _Whereptr == (const vraudio::AudioBuffer **)a5[2] )
      {
        _Whereptr_1 = std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                        (std::vector<vraudio::AudioBuffer const *> *)a5,
                        _Whereptr,
                        &__Val_0__);
      }
      else
      {
        *_Whereptr = __Val_0___1;
        a5[1] += 8LL;
      }
      _Whereptr_2 = 0;
      if ( *((_QWORD *)__Val_0___1 + 1) )
      {
        v20 = 0;
        v61.m128i_i64[0] = 0;
        while ( 1 )
        {
          v21 = *(_QWORD *)__Val_0___1 + v20;
          if ( *(_BYTE *)(v21 + 0x18) == 0x10 )
            break;
LABEL_44:
          _Whereptr_1 = (const vraudio::AudioBuffer **)((char *)_Whereptr_2 + 1);
          v20 = v61.m128i_i64[0] + 0x28;
          _Whereptr_2 = _Whereptr_1;
          v61.m128i_i64[0] += 0x28;
          if ( (unsigned __int64)_Whereptr_1 >= *((_QWORD *)__Val_0___1 + 1) )
            return _Whereptr_1;
        }
        v22 = sub_1402E1FE0(v9, 0xFFFFFFFF);
        v55 = v22;
        v23 = 0;
        v59 = 0;
        if ( v9 )
        {
          v24 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++v24;
          while ( v9[v24] );
          allocSize = v24 + 1;
          if ( allocSize )
          {
            v23 = (void *)allocWithProfilerInfo(allocSize, 0);
            v59 = v23;
          }
          memcpy(v23, v9, allocSize);
          v22 = v55;
        }
        n3 = *(_BYTE *)(v21 + 0x19);
        if ( !*(_BYTE *)(v21 + 0x1A) )
        {
          if ( (unsigned __int8)(n3 - 1) <= 1u )
          {
            v50 = *(_QWORD **)(v10 + *(_QWORD *)(v21 + 8));
          }
          else
          {
            v50 = (_QWORD *)(*(_QWORD *)(v21 + 8) + v10);
            if ( n3 == 3 )
              v50 = (_QWORD *)v50[2];
          }
          v56 = (__int64)v50;
          v54 = 0;
          if ( v50 )
          {
            v7 |= 8u;
            if ( *(_DWORD *)(*(__int64 (__fastcall **)(_QWORD *, _BYTE *))(*v50 + 0x18LL))(v50, v62) == v22
              || (v51 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0),
                  v52 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v51 + 0x100LL),
                  v53 = (*(__int64 (__fastcall **)(_QWORD *))(*v50 + 8LL))(v50),
                  v52(v51, v53, v9)) )
            {
              v54 = 1;
            }
          }
          if ( (v7 & 8) != 0 )
          {
            v7 &= ~8u;
            if ( v63 )
              sub_147605980(v63);
          }
          if ( v54 )
            sub_1402A6620(v8, &v56);
          if ( a6 && v50 )
            sub_1474A5CB0(v64, (_DWORD)v50, (_DWORD)v9, v8, (__int64)v18, a6);
          goto LABEL_40;
        }
        v27 = (_QWORD *)(v10 + *(_QWORD *)(v21 + 8));
        if ( (unsigned __int8)(n3 - 1) <= 1u )
        {
          v43 = 0;
          if ( v27[3] )
          {
            v44 = 0;
            do
            {
              v45 = *(_QWORD *)(v44 + v27[2]);
              v56 = v45;
              v49 = 0;
              if ( v45 )
              {
                v7 |= 1u;
                if ( *(_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v45 + 0x18LL))(v45, v62) == v22
                  || (v46 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0),
                      v47 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v46
                                                                                                  + 0x100LL),
                      v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 8LL))(v45),
                      v47(v46, v48, a3)) )
                {
                  v49 = 1;
                }
              }
              if ( (v7 & 1) != 0 )
              {
                v7 &= ~1u;
                if ( v63 )
                  sub_147605980(v63);
              }
              if ( v49 )
                sub_1402A6620(a4, &v56);
              if ( a6 && v45 )
                sub_1474A5CB0(v64, v45, (_DWORD)a3, a4, (__int64)a5, a6);
              v22 = v55;
              ++v43;
              v44 += 0x10;
            }
            while ( v43 < v27[3] );
            goto LABEL_38;
          }
        }
        else
        {
          if ( n3 != 3 )
          {
            v35 = 0;
            if ( !v27[3] )
            {
              v9 = a3;
              v18 = a5;
              goto LABEL_41;
            }
            do
            {
              v36 = v27[5] * v35;
              v37 = v27[2] + v36 == 0;
              v38 = v27[2] + v36;
              v56 = v38;
              v42 = 0;
              if ( !v37 )
              {
                v7 |= 4u;
                if ( *(_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v38 + 0x18LL))(v38, v62) == v22
                  || (v39 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0),
                      v40 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v39
                                                                                                  + 0x100LL),
                      v41 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 8LL))(v38),
                      v40(v39, v41, a3)) )
                {
                  v42 = 1;
                }
              }
              if ( (v7 & 4) != 0 )
              {
                v7 &= ~4u;
                if ( v63 )
                  sub_147605980(v63);
              }
              if ( v42 )
                sub_1402A6620(v8, &v56);
              if ( a6 && v38 )
                sub_1474A5CB0(v64, v38, (_DWORD)a3, v8, (__int64)a5, a6);
              v22 = v55;
              ++v35;
            }
            while ( v35 < v27[3] );
            goto LABEL_39;
          }
          v28 = 0;
          if ( v27[3] )
          {
            v29 = 0;
            do
            {
              v30 = *(_QWORD *)(v27[2] + v29 + 0x10);
              v56 = v30;
              v34 = 0;
              if ( v30 )
              {
                v7 |= 2u;
                if ( *(_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v30 + 0x18LL))(v30, v62) == v22
                  || (v31 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0),
                      v32 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v31
                                                                                                  + 0x100LL),
                      v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v30 + 8LL))(v30),
                      v32(v31, v33, a3)) )
                {
                  v34 = 1;
                }
              }
              if ( (v7 & 2) != 0 )
              {
                v7 &= ~2u;
                if ( v63 )
                  sub_147605980(v63);
              }
              if ( v34 )
                sub_1402A6620(a4, &v56);
              if ( a6 && v30 )
                sub_1474A5CB0(v64, v30, (_DWORD)a3, a4, (__int64)a5, a6);
              v22 = v55;
              ++v28;
              v29 += 0x18;
            }
            while ( v28 < v27[3] );
LABEL_38:
            v8 = a4;
LABEL_39:
            v18 = a5;
            v9 = a3;
LABEL_40:
            v10 = a2;
LABEL_41:
            if ( v59 )
              sub_147605980(v59);
            __Val_0___1 = __Val_0__;
            goto LABEL_44;
          }
        }
        v8 = a4;
        v18 = a5;
        goto LABEL_41;
      }
    }
  }
  return _Whereptr_1;
}

// --- End Function: sub_1474A5CB0 (0x1474A5CB0) ---

// --- Function: sub_1474A65F0 (0x1474A65F0) ---
__int64 __fastcall sub_1474A65F0(_QWORD *a1, unsigned int *a2)
{
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 *v6; // rdi
  unsigned __int8 **v7; // rbx
  __int64 v9; // [rsp+20h] [rbp-18h] BYREF
  unsigned __int8 *v10[2]; // [rsp+28h] [rbp-10h] BYREF

  if ( !a2 )
    return 0;
  v3 = a1[0x3F];
  v4 = *a2;
  if ( *(_DWORD *)(v3 + 4) >= 6u )
    v5 = a1[0x55];
  else
    v5 = a1[0x54];
  v9 = v4 + v5;
  sub_14035B120(v10, &v9);
  v6 = (__int64 *)a1[0x24];
  v7 = (unsigned __int8 **)v6[1];
  while ( !*((_BYTE *)v7 + 0x19) )
  {
    if ( (int)sub_1403E4780(v7 + 4, v10) >= 0 )
    {
      v6 = (__int64 *)v7;
      v7 = (unsigned __int8 **)*v7;
    }
    else
    {
      v7 = (unsigned __int8 **)v7[2];
    }
  }
  if ( *((_BYTE *)v6 + 0x19) || (int)sub_1403E4780(v10, v6 + 4) < 0 )
    v6 = (__int64 *)a1[0x24];
  v10[0] = (unsigned __int8 *)&qword_149B3B33C + 4;
  sub_140370D10(v10);
  if ( v6 == (__int64 *)a1[0x24] )
    return 0;
  else
    return v6[5];
}

// --- End Function: sub_1474A65F0 (0x1474A65F0) ---

// --- Function: sub_1474A6C50 (0x1474A6C50) ---
char __fastcall sub_1474A6C50(__int64 a1, const char *s2, const char *s1)
{
  _QWORD *v4; // rdi
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 i; // r8
  __int64 v9; // rax
  const char *s2_1; // [rsp+20h] [rbp-48h] BYREF
  char *v12; // [rsp+28h] [rbp-40h] BYREF
  __m128i v13; // [rsp+30h] [rbp-38h]
  _QWORD v14[5]; // [rsp+40h] [rbp-28h] BYREF

  v4 = (_QWORD *)(a1 + 0x130);
  while ( 1 )
  {
    s2_1 = s2;
    sub_14035B120(&v12, &s2_1);
    v6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v6;
    while ( v12[v6] );
    v7 = 0;
    for ( i = 0xCBF29CE484222325uLL; v7 < v6; i = 0x100000001B3LL * (v9 ^ i) )
      v9 = (unsigned __int8)v12[v7++];
    v13 = *(__m128i *)sub_14747F260(
                        v4,
                        v14,
                        &v12,
                        0xDE5FB9D2630458E9uLL * i
                      + (((unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
    v12 = (char *)&qword_149B3B33C + 4;
    sub_140370D10(&v12);
    if ( v13.m128i_i64[0] == *v4 + v4[3] )
      break;
    s2 = *(const char **)(_mm_extract_epi64(v13, 1) + 0x20);
    if ( !s2 )
      break;
    if ( !strcmp(s1, s2) )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1474A6C50 (0x1474A6C50) ---

// --- Function: sub_1474A9090 (0x1474A9090) ---
__int64 __fastcall sub_1474A9090(__int64 a1)
{
  const void **v2; // rdx
  __int64 v3; // r8
  const void **v4; // rdi
  unsigned __int8 v5; // bp
  _BYTE *v6; // rsi
  __int64 _Count; // rsi
  std::array<int,2> *_Newvec_1; // rax
  __int64 v9; // r8
  const vraudio::AudioBuffer **_Newvec; // rbx
  void *v12[2]; // [rsp+30h] [rbp-68h] BYREF
  int n0x2900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v14; // [rsp+44h] [rbp-54h]
  int v15; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v16; // [rsp+50h] [rbp-48h]
  unsigned __int64 v17; // [rsp+58h] [rbp-40h]
  __int64 v18; // [rsp+60h] [rbp-38h]
  __int64 v19; // [rsp+68h] [rbp-30h]

  n0x2900 = 0x2900;
  v14 = 1;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v16 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_15160EEC8,
    "CDataCore::Initialize",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\DataCore.cpp",
    0x210);
  v2 = (const void **)&unk_15160EE48;
  HIWORD(n0x2900) = word_15160EEC8;
  if ( dword_149AFFF98 )
    v2 = (const void **)&unk_15160EE58;
  sub_14035B160(v12, v2);
  LOBYTE(v3) = 1;
  v4 = (const void **)(a1 + 0x190);
  v5 = sub_1474A9490(a1, v12, v3);
  v6 = *(_BYTE **)(a1 + 0x198);
  if ( v6 != *(_BYTE **)(a1 + 0x1A0) )
  {
    if ( *v4 == v6 )
    {
      std::vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____::_vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____((__int64)v4);
    }
    else
    {
      _Count = (v6 - (_BYTE *)*v4) >> 3;
      _Newvec_1 = std::allocator<std::array<int,2>>::allocate(
                    (std::allocator<std::array<int,2> > *)(a1 + 0x190),
                    _Count);
      v9 = *(_QWORD *)(a1 + 0x198);
      _Newvec = (const vraudio::AudioBuffer **)_Newvec_1;
      memmove(_Newvec_1, *v4, v9 - (_QWORD)*v4);
      std::vector<vraudio::AudioBuffer const *>::_Change_array(
        (std::vector<vraudio::AudioBuffer const *> *)v4,
        _Newvec,
        _Count,
        _Count);
    }
  }
  sub_140370D10(v12);
  v17 = __rdtsc();
  qword_149B4B878(&n0x2900);
  return v5;
}

// --- End Function: sub_1474A9090 (0x1474A9090) ---

// --- Function: sub_1474A9490 (0x1474A9490) ---
__int64 __fastcall sub_1474A9490(__int64 a1, char **a2)
{
  __int128 v2; // xmm6
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // r12
  int v8; // ebx
  __int64 *ThreadLogContextSlot; // rax
  unsigned __int8 v10; // bl
  _QWORD *v11; // rax
  _QWORD *v12; // rdx
  int v13; // ebx
  __int64 *ThreadLogContextSlot_1; // rax
  char *p_Failed_to_read_DCB__file_is_too_small; // r9
  __int64 v16; // rax
  int v17; // ebx
  __int64 v18; // rcx
  int v19; // edx
  __int64 *ThreadLogContextSlot_2; // rax
  unsigned __int64 v21; // rcx
  char v22; // di
  unsigned int __n; // edi
  __int64 v24; // rax
  char *__t; // rax
  __int64 __t_8; // rbx
  __int64 v27; // rax
  unsigned int v28; // eax
  unsigned int __n_1; // esi
  __int64 v30; // rax
  unsigned __int64 v31; // kr00_8
  char *__t_1; // rax
  __int64 __t_9; // rbx
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned __int64 v36; // rcx
  unsigned int __n_2; // esi
  __int64 v38; // rax
  char *__t_2; // rax
  __int64 __t_10; // rbx
  __int64 v41; // rax
  __int64 v42; // rax
  unsigned __int64 v43; // rcx
  unsigned int __n_3; // esi
  __int64 v45; // rax
  char *__t_3; // rax
  __int64 __t_11; // rbx
  __int64 v48; // rax
  __int64 v49; // rax
  unsigned __int64 v50; // rcx
  unsigned int __n_4; // esi
  __int64 v52; // rax
  char *__t_4; // rax
  __int64 __t_12; // rbx
  __int64 v55; // rax
  __int64 v56; // rcx
  __int64 v57; // rax
  __int64 v58; // rcx
  __int64 v59; // rax
  unsigned __int64 v60; // rcx
  __int64 v61; // rax
  __int64 v62; // rax
  __int64 v63; // rcx
  __int64 v64; // rax
  unsigned __int64 v65; // rcx
  __int64 v66; // rax
  __int64 v67; // rax
  __int64 v68; // rcx
  __int64 v69; // rax
  unsigned __int64 v70; // rcx
  __int64 v71; // rax
  __int64 v72; // rax
  __int64 v73; // rcx
  __int64 v74; // rcx
  __int64 v75; // rax
  __int64 v76; // rcx
  __int64 v77; // rax
  unsigned __int64 v78; // rcx
  __int64 v79; // rax
  __int64 v80; // rax
  __int64 v81; // rcx
  __int64 v82; // rax
  unsigned __int64 v83; // rcx
  __int64 v84; // rax
  __int64 v85; // rax
  __int64 v86; // rcx
  __int64 v87; // rax
  unsigned __int64 v88; // rcx
  __int64 v89; // rax
  __int64 v90; // rax
  __int64 v91; // rcx
  __int64 v92; // rcx
  __int64 v93; // rax
  __int64 v94; // rcx
  __int64 v95; // rax
  unsigned __int64 v96; // rcx
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 v99; // rcx
  __int64 v100; // rax
  char v101; // si
  unsigned __int64 v102; // rcx
  __int64 v103; // rax
  __int64 v104; // rax
  __int64 v105; // rcx
  __int64 v106; // rbx
  __int64 v107; // rax
  unsigned __int64 v108; // rcx
  __int64 v109; // rax
  __int64 v110; // rax
  __int64 v111; // rcx
  __int64 v112; // rax
  unsigned __int64 v113; // rcx
  __int64 v114; // rax
  __int64 v115; // rax
  __int64 v116; // rcx
  __int64 v117; // rax
  unsigned __int64 v118; // rcx
  __int64 v119; // rax
  __int64 v120; // rax
  __int64 v121; // rcx
  __int64 v122; // rax
  unsigned __int64 v123; // rcx
  __int64 v124; // rax
  __int64 v125; // rax
  __int64 v126; // rcx
  __int64 v127; // rax
  unsigned __int64 v128; // rcx
  unsigned int __n_5; // esi
  __int64 v130; // rax
  char *__t_5; // rax
  __int64 __t_13; // rbx
  __int64 v133; // rax
  __int64 v134; // rax
  unsigned __int64 v135; // rcx
  unsigned int __n_6; // esi
  __int64 v137; // rax
  char *__t_6; // rax
  __int64 __t_14; // rbx
  __int64 v140; // rax
  __int64 v141; // rax
  unsigned __int64 v142; // rcx
  unsigned int __n_7; // esi
  __int64 v144; // rax
  char *__t_7; // rax
  __int64 __t_15; // rbx
  __int64 v147; // rax
  __int64 v148; // rax
  unsigned __int64 v149; // rcx
  __int64 v150; // rax
  __int64 v151; // rax
  __int64 v152; // rcx
  __int64 v153; // rcx
  __int64 v154; // rax
  __int64 v155; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v157; // rax
  __int64 v158; // rcx
  _DWORD *v159; // rdx
  unsigned int v160; // r12d
  __int64 v161; // rdi
  __int64 v162; // rsi
  __int64 v163; // rcx
  _QWORD *v164; // rbx
  unsigned __int64 v165; // rcx
  __int64 v166; // rdx
  unsigned __int64 v167; // r8
  __int64 v168; // rax
  __int64 v169; // rbx
  bool v170; // zf
  _QWORD *v171; // rbx
  __int64 v172; // r12
  unsigned int *v173; // rsi
  unsigned __int64 allocSize_1; // r13
  bool v175; // cf
  __int64 v176; // rcx
  __int64 v177; // rax
  unsigned __int64 v178; // rcx
  __int64 v179; // rdx
  unsigned __int64 m; // r8
  __int64 v181; // rax
  __int64 v182; // rdi
  __int64 v183; // rbx
  __int64 v184; // rax
  unsigned int v185; // ebx
  _BYTE *v186; // rdx
  _BYTE *v187; // rax
  int v188; // ebx
  __int64 *ThreadLogContextSlot_3; // rax
  char *p_DCB_file_is_smaller_than_expected; // r9
  _QWORD *v191; // r12
  unsigned __int64 allocSize_3; // rdi
  __int64 v193; // rbx
  __int64 v194; // r8
  __int64 v195; // r9
  __int64 v196; // rsi
  char *v197; // r13
  const char *v198; // rsi
  _BYTE *v199; // rax
  unsigned __int64 v200; // rcx
  __int64 v201; // rdx
  unsigned __int64 v202; // r8
  __int64 v203; // rax
  __int64 v204; // r12
  __int64 v205; // r12
  __int64 v206; // rdi
  const void **StringObjectFromString; // rax
  __int128 v208; // xmm0
  const void **v209; // rbx
  __int128 v210; // xmm6
  __int64 v211; // rax
  _QWORD *v212; // r13
  unsigned __int64 v213; // rdx
  __int64 v214; // r8
  unsigned __int64 v215; // r9
  __int64 v216; // rcx
  unsigned __int64 v217; // r12
  unsigned __int64 v218; // rax
  __int64 v219; // rdi
  _QWORD *v220; // rbx
  char v221; // r12
  __int64 v222; // rax
  unsigned __int64 v223; // rcx
  unsigned __int64 *v224; // rdi
  int v225; // r9d
  int v226; // r8d
  int v227; // eax
  int v228; // ebx
  unsigned __int64 v229; // rdx
  unsigned __int64 v230; // rax
  unsigned __int64 v231; // r8
  __int64 v232; // r9
  __int64 v233; // rdx
  __int64 v234; // rdx
  _OWORD *v235; // rax
  unsigned int i; // edi
  unsigned int *v237; // rbx
  __int64 v238; // rdx
  __int64 v239; // rdx
  __int64 v240; // r8
  unsigned int j; // ebx
  unsigned int *v242; // rdi
  __int64 v243; // rdx
  __int64 v244; // rdx
  __int64 v245; // r8
  char *v246; // rbx
  __int64 *v247; // rdi
  __int64 v251; // rcx
  __int64 v252; // rdx
  __int64 v253; // r8
  unsigned int v254; // r8d
  __int64 v255; // rcx
  __int64 v256; // rdx
  __int64 v257; // rax
  __int64 v258; // rdx
  __int64 v262; // rcx
  _QWORD *v263; // rax
  __int64 *v266; // rax
  _QWORD *v267; // rdi
  _QWORD *v268; // rbx
  __int64 v269; // rax
  _QWORD *v270; // rax
  __int64 v274; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v275; // [rsp+68h] [rbp-98h] BYREF
  __int64 *v276; // [rsp+70h] [rbp-90h] BYREF
  char *v277; // [rsp+78h] [rbp-88h] BYREF
  __int128 v278; // [rsp+80h] [rbp-80h] BYREF
  const void *v279; // [rsp+90h] [rbp-70h]
  __int128 v280; // [rsp+98h] [rbp-68h] BYREF
  _BYTE *v281; // [rsp+A8h] [rbp-58h] BYREF
  void *v282; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 allocSize_2; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v284; // [rsp+C0h] [rbp-40h]
  _BYTE *v285; // [rsp+C8h] [rbp-38h] BYREF
  __int64 k; // [rsp+D0h] [rbp-30h] BYREF
  char v287[8]; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v288; // [rsp+E0h] [rbp-20h]
  _OWORD v289[6]; // [rsp+F0h] [rbp-10h] BYREF

  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149B4FC40 + 0x48LL))(qword_149B4FC40, &k);
  sub_14035B3E0(&v282);
  v5 = sub_1403E7A60(a2);
  v6 = sub_1403E20D0((__int64)"Data/");
  sub_1403E90A0(&v282, v6 + v5);
  sub_140384840(&v282, "Data/");
  sub_1403847F0(&v282, a2);
  v284 = (*(__int64 (__fastcall **)(__int64, void *, const char *, _QWORD))(*(_QWORD *)qword_149B4FC18 + 0x138LL))(
           qword_149B4FC18,
           v282,
           "rb",
           0);
  v7 = v284;
  if ( !v284 )
  {
    v274 = 0x1C000000CFLL;
    *(_QWORD *)&v289[0] = &v274;
    *((_QWORD *)&v289[0] + 1) = &v275;
    v8 = invokeGlobalCallbackAndMaskStatusBits(2, (__int64)v289, (__int64)"DataCore Load Failure", "Failed to find $$");
    if ( (v8 & 0xFFFFF) != 0 )
    {
      *((_QWORD *)&v278 + 1) = v282;
      *(_QWORD *)&v278 = 0;
      v279 = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v274 = 0x1C000000CFLL;
      *(_QWORD *)&v289[0] = &v274;
      *((_QWORD *)&v289[0] + 1) = &v275;
      v280 = 0;
      sub_140444D10(
        2u,
        (__int64 *)v289,
        "DataCore Load Failure",
        "Failed to find $$",
        1,
        v8,
        &v280,
        0,
        (__int64)ThreadLogContextSlot,
        &v278);
      sub_1402A3D30(v279);
    }
    *(_DWORD *)(a1 + 0x2D0) = 0;
    v10 = 0;
    goto LABEL_262;
  }
  *(_DWORD *)(a1 + 0x2D0) = (*(__int64 (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)qword_149B4FC18 + 0x2D0LL))(
                              qword_149B4FC18,
                              v282,
                              0);
  v11 = (_QWORD *)allocWithProfilerInfo_w(0x78u);
  v12 = v11;
  if ( v11 )
  {
    v11[2] = 0;
    v11[3] = 0;
    v11[4] = 0;
    v11[5] = 0;
    v11[6] = 0;
    v11[7] = 0;
    v11[8] = 0;
    v11[9] = 0;
    v11[0xA] = 0;
    v11[0xB] = 0;
    v11[0xC] = 0;
    v11[0xD] = 0;
    v11[0xE] = 0;
  }
  else
  {
    v12 = 0;
  }
  *(_QWORD *)(a1 + 0x1F8) = v12;
  if ( (*(__int64 (__fastcall **)(__int64, _QWORD *, __int64))(*(_QWORD *)qword_149B4FC18 + 0x150LL))(
         qword_149B4FC18,
         v12,
         0x78) != 1 )
  {
    v274 = 0x1C000000CFLL;
    *(_QWORD *)&v289[0] = &v274;
    *((_QWORD *)&v289[0] + 1) = &v275;
    v13 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v289,
            (__int64)"DataCore Load Failure",
            "Failed to read header, DCB too small");
    if ( (v13 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      p_Failed_to_read_DCB__file_is_too_small = "Failed to read header, DCB too small";
LABEL_136:
      *(_QWORD *)&v289[0] = &v274;
      *((_QWORD *)&v289[0] + 1) = &v275;
      v280 = 0;
      v274 = 0x1C000000CFLL;
      sub_1403515F0(
        2u,
        (__int64 *)v289,
        "DataCore Load Failure",
        p_Failed_to_read_DCB__file_is_too_small,
        1,
        v13,
        &v280,
        0,
        (__int64)ThreadLogContextSlot_1);
      goto LABEL_137;
    }
    goto LABEL_137;
  }
  v16 = *(_QWORD *)(a1 + 0x1F8);
  if ( *(_DWORD *)(v16 + 4) < 5u )
  {
    v274 = 0x1C000000CFLL;
    *(_QWORD *)&v289[0] = &v274;
    *((_QWORD *)&v289[0] + 1) = &v275;
    v17 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v289,
            (__int64)"DataCore Load Failure",
            "Unsupported version DCB:$$ Game:$$");
    if ( (v17 & 0xFFFFF) != 0 )
    {
      v18 = *(_QWORD *)(a1 + 0x1F8);
      *(_QWORD *)&v289[0] = 0;
      DWORD2(v289[0]) = 5;
      v19 = *(_DWORD *)(v18 + 4);
      *(_QWORD *)&v278 = 0;
      DWORD2(v278) = v19;
      ThreadLogContextSlot_2 = getThreadLogContextSlot();
      v274 = 0x1C000000CFLL;
      v276 = &v274;
      v277 = (char *)&v275;
      v280 = 0;
      sub_146C1A480(
        2u,
        (__int64 *)&v276,
        "DataCore Load Failure",
        "Unsupported version DCB:$$ Game:$$",
        1,
        v17,
        &v280,
        0,
        (__int64)ThreadLogContextSlot_2,
        &v278,
        v289);
    }
    goto LABEL_137;
  }
  v21 = *(unsigned int *)(v16 + 0x10);
  v22 = 1;
  if ( (_DWORD)v21 )
  {
    __n = *(_DWORD *)(v16 + 0x10);
    v24 = 0x10LL * __n;
    if ( !is_mul_ok(v21, 0x10u) )
      v24 = 0xFFFFFFFFFFFFFFFFuLL;
    __t = (char *)qword_149B4F998(v24, 0);
    __t_8 = (__int64)__t;
    if ( __t )
      `vector constructor iterator'(__t, 0x10u, __n, (void *(__fastcall *)(void *))sub_147481D40);
    else
      __t_8 = 0;
    v27 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x200) = __t_8;
    v22 = sub_14749FB70(__t_8, 0x10, *(unsigned int *)(v27 + 0x10), v7);
  }
  v28 = *(_DWORD *)(*(_QWORD *)(a1 + 0x1F8) + 0x14LL);
  if ( v28 )
  {
    __n_1 = *(_DWORD *)(*(_QWORD *)(a1 + 0x1F8) + 0x14LL);
    v31 = v28;
    v30 = 0xCLL * v28;
    if ( !is_mul_ok(v31, 0xCu) )
      v30 = 0xFFFFFFFFFFFFFFFFuLL;
    __t_1 = (char *)qword_149B4F998(v30, 0);
    __t_9 = (__int64)__t_1;
    if ( __t_1 )
      `vector constructor iterator'(
        __t_1,
        0xCu,
        __n_1,
        (void *(__fastcall *)(void *))std::_Yarn<wchar_t>::_Yarn<wchar_t>);
    else
      __t_9 = 0;
    v34 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x208) = __t_9;
    v22 &= sub_14749FB70(__t_9, 0xC, *(unsigned int *)(v34 + 0x14), v7);
  }
  v35 = *(_QWORD *)(a1 + 0x1F8);
  v36 = *(unsigned int *)(v35 + 0x18);
  if ( (_DWORD)v36 )
  {
    __n_2 = *(_DWORD *)(v35 + 0x18);
    v38 = 8LL * __n_2;
    if ( !is_mul_ok(v36, 8u) )
      v38 = 0xFFFFFFFFFFFFFFFFuLL;
    __t_2 = (char *)qword_149B4F998(v38, 0);
    __t_10 = (__int64)__t_2;
    if ( __t_2 )
      `vector constructor iterator'(__t_2, 8u, __n_2, (void *(__fastcall *)(void *))sub_1405D9570);
    else
      __t_10 = 0;
    v41 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x210) = __t_10;
    v22 &= sub_14749FB70(__t_10, 8, *(unsigned int *)(v41 + 0x18), v7);
  }
  v42 = *(_QWORD *)(a1 + 0x1F8);
  v43 = *(unsigned int *)(v42 + 0x1C);
  if ( (_DWORD)v43 )
  {
    __n_3 = *(_DWORD *)(v42 + 0x1C);
    v45 = 8LL * __n_3;
    if ( !is_mul_ok(v43, 8u) )
      v45 = 0xFFFFFFFFFFFFFFFFuLL;
    __t_3 = (char *)qword_149B4F998(v45, 0);
    __t_11 = (__int64)__t_3;
    if ( __t_3 )
      `vector constructor iterator'(__t_3, 8u, __n_3, (void *(__fastcall *)(void *))sub_1405D9570);
    else
      __t_11 = 0;
    v48 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x220) = __t_11;
    v22 &= sub_14749FB70(__t_11, 8, *(unsigned int *)(v48 + 0x1C), v7);
  }
  v49 = *(_QWORD *)(a1 + 0x1F8);
  v50 = *(unsigned int *)(v49 + 0x20);
  if ( (_DWORD)v50 )
  {
    __n_4 = *(_DWORD *)(v49 + 0x20);
    v52 = 0x20LL * __n_4;
    if ( !is_mul_ok(v50, 0x20u) )
      v52 = 0xFFFFFFFFFFFFFFFFuLL;
    __t_4 = (char *)qword_149B4F998(v52, 0);
    __t_12 = (__int64)__t_4;
    if ( __t_4 )
      `vector constructor iterator'(__t_4, 0x20u, __n_4, (void *(__fastcall *)(void *))sub_147481D50);
    else
      __t_12 = 0;
    v55 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x218) = __t_12;
    v22 &= sub_14749FB70(__t_12, 0x20, *(unsigned int *)(v55 + 0x20), v7);
  }
  v56 = *(unsigned int *)(*(_QWORD *)(a1 + 0x1F8) + 0x28LL);
  if ( (_DWORD)v56 )
  {
    v57 = qword_149B4F998(v56, 0);
    v58 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x230) = v57;
    v22 &= sub_14749FB70(v57, 1, *(unsigned int *)(v58 + 0x28), v7);
  }
  v59 = *(_QWORD *)(a1 + 0x1F8);
  v60 = *(unsigned int *)(v59 + 0x2C);
  if ( (_DWORD)v60 )
  {
    v61 = 2LL * *(unsigned int *)(v59 + 0x2C);
    if ( !is_mul_ok(v60, 2u) )
      v61 = 0xFFFFFFFFFFFFFFFFuLL;
    v62 = qword_149B4F998(v61, 0);
    v63 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x238) = v62;
    v22 &= sub_14749FB70(v62, 2, *(unsigned int *)(v63 + 0x2C), v7);
  }
  v64 = *(_QWORD *)(a1 + 0x1F8);
  v65 = *(unsigned int *)(v64 + 0x30);
  if ( (_DWORD)v65 )
  {
    v66 = 4LL * *(unsigned int *)(v64 + 0x30);
    if ( !is_mul_ok(v65, 4u) )
      v66 = 0xFFFFFFFFFFFFFFFFuLL;
    v67 = qword_149B4F998(v66, 0);
    v68 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x240) = v67;
    v22 &= sub_14749FB70(v67, 4, *(unsigned int *)(v68 + 0x30), v7);
  }
  v69 = *(_QWORD *)(a1 + 0x1F8);
  v70 = *(unsigned int *)(v69 + 0x34);
  if ( (_DWORD)v70 )
  {
    v71 = 8LL * *(unsigned int *)(v69 + 0x34);
    if ( !is_mul_ok(v70, 8u) )
      v71 = 0xFFFFFFFFFFFFFFFFuLL;
    v72 = qword_149B4F998(v71, 0);
    v73 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x248) = v72;
    v22 &= sub_14749FB70(v72, 8, *(unsigned int *)(v73 + 0x34), v7);
  }
  v74 = *(unsigned int *)(*(_QWORD *)(a1 + 0x1F8) + 0x38LL);
  if ( (_DWORD)v74 )
  {
    v75 = qword_149B4F998(v74, 0);
    v76 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x250) = v75;
    v22 &= sub_14749FB70(v75, 1, *(unsigned int *)(v76 + 0x38), v7);
  }
  v77 = *(_QWORD *)(a1 + 0x1F8);
  v78 = *(unsigned int *)(v77 + 0x3C);
  if ( (_DWORD)v78 )
  {
    v79 = 2LL * *(unsigned int *)(v77 + 0x3C);
    if ( !is_mul_ok(v78, 2u) )
      v79 = 0xFFFFFFFFFFFFFFFFuLL;
    v80 = qword_149B4F998(v79, 0);
    v81 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x258) = v80;
    v22 &= sub_14749FB70(v80, 2, *(unsigned int *)(v81 + 0x3C), v7);
  }
  v82 = *(_QWORD *)(a1 + 0x1F8);
  v83 = *(unsigned int *)(v82 + 0x40);
  if ( (_DWORD)v83 )
  {
    v84 = 4LL * *(unsigned int *)(v82 + 0x40);
    if ( !is_mul_ok(v83, 4u) )
      v84 = 0xFFFFFFFFFFFFFFFFuLL;
    v85 = qword_149B4F998(v84, 0);
    v86 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x260) = v85;
    v22 &= sub_14749FB70(v85, 4, *(unsigned int *)(v86 + 0x40), v7);
  }
  v87 = *(_QWORD *)(a1 + 0x1F8);
  v88 = *(unsigned int *)(v87 + 0x44);
  if ( (_DWORD)v88 )
  {
    v89 = 8LL * *(unsigned int *)(v87 + 0x44);
    if ( !is_mul_ok(v88, 8u) )
      v89 = 0xFFFFFFFFFFFFFFFFuLL;
    v90 = qword_149B4F998(v89, 0);
    v91 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x268) = v90;
    v22 &= sub_14749FB70(v90, 8, *(unsigned int *)(v91 + 0x44), v7);
  }
  v92 = *(unsigned int *)(*(_QWORD *)(a1 + 0x1F8) + 0x24LL);
  if ( (_DWORD)v92 )
  {
    v93 = qword_149B4F998(v92, 0);
    v94 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x228) = v93;
    v22 &= sub_14749FB70(v93, 1, *(unsigned int *)(v94 + 0x24), v7);
  }
  v95 = *(_QWORD *)(a1 + 0x1F8);
  v96 = *(unsigned int *)(v95 + 0x48);
  if ( (_DWORD)v96 )
  {
    v97 = 4LL * *(unsigned int *)(v95 + 0x48);
    if ( !is_mul_ok(v96, 4u) )
      v97 = 0xFFFFFFFFFFFFFFFFuLL;
    v98 = qword_149B4F998(v97, 0);
    v99 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x270) = v98;
    v22 &= sub_14749FB70(v98, 4, *(unsigned int *)(v99 + 0x48), v7);
  }
  v100 = *(_QWORD *)(a1 + 0x1F8);
  v101 = v22;
  v102 = *(unsigned int *)(v100 + 0x4C);
  if ( (_DWORD)v102 )
  {
    v103 = 8LL * *(unsigned int *)(v100 + 0x4C);
    if ( !is_mul_ok(v102, 8u) )
      v103 = 0xFFFFFFFFFFFFFFFFuLL;
    v104 = qword_149B4F998(v103, 0);
    v105 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x278) = v104;
    v106 = *(unsigned int *)(v105 + 0x4C);
    v22 = 0;
    if ( (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64, const char *))(*(_QWORD *)qword_149B4FC18
                                                                                             + 0x150LL))(
           qword_149B4FC18,
           v104,
           8,
           (unsigned int)v106,
           v7,
           "FReadRawWithLog") == v106 )
      v22 = v101;
  }
  v107 = *(_QWORD *)(a1 + 0x1F8);
  v108 = *(unsigned int *)(v107 + 0x50);
  if ( (_DWORD)v108 )
  {
    v109 = 0x10LL * *(unsigned int *)(v107 + 0x50);
    if ( !is_mul_ok(v108, 0x10u) )
      v109 = 0xFFFFFFFFFFFFFFFFuLL;
    v110 = qword_149B4F998(v109, 0);
    v111 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x280) = v110;
    v22 &= sub_14749FB70(v110, 0x10, *(unsigned int *)(v111 + 0x50), v7);
  }
  v112 = *(_QWORD *)(a1 + 0x1F8);
  v113 = *(unsigned int *)(v112 + 0x54);
  if ( (_DWORD)v113 )
  {
    v114 = 4LL * *(unsigned int *)(v112 + 0x54);
    if ( !is_mul_ok(v113, 4u) )
      v114 = 0xFFFFFFFFFFFFFFFFuLL;
    v115 = qword_149B4F998(v114, 0);
    v116 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x290) = v115;
    v22 &= sub_14749FB70(v115, 4, *(unsigned int *)(v116 + 0x54), v7);
  }
  v117 = *(_QWORD *)(a1 + 0x1F8);
  v118 = *(unsigned int *)(v117 + 0x58);
  if ( (_DWORD)v118 )
  {
    v119 = 4LL * *(unsigned int *)(v117 + 0x58);
    if ( !is_mul_ok(v118, 4u) )
      v119 = 0xFFFFFFFFFFFFFFFFuLL;
    v120 = qword_149B4F998(v119, 0);
    v121 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x298) = v120;
    v22 &= sub_14749FB70(v120, 4, *(unsigned int *)(v121 + 0x58), v7);
  }
  v122 = *(_QWORD *)(a1 + 0x1F8);
  v123 = *(unsigned int *)(v122 + 0x5C);
  if ( (_DWORD)v123 )
  {
    v124 = 4LL * *(unsigned int *)(v122 + 0x5C);
    if ( !is_mul_ok(v123, 4u) )
      v124 = 0xFFFFFFFFFFFFFFFFuLL;
    v125 = qword_149B4F998(v124, 0);
    v126 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x288) = v125;
    v22 &= sub_14749FB70(v125, 4, *(unsigned int *)(v126 + 0x5C), v7);
  }
  v127 = *(_QWORD *)(a1 + 0x1F8);
  v128 = *(unsigned int *)(v127 + 0x60);
  if ( (_DWORD)v128 )
  {
    __n_5 = *(_DWORD *)(v127 + 0x60);
    v130 = 8LL * __n_5;
    if ( !is_mul_ok(v128, 8u) )
      v130 = 0xFFFFFFFFFFFFFFFFuLL;
    __t_5 = (char *)qword_149B4F998(v130, 0);
    __t_13 = (__int64)__t_5;
    if ( __t_5 )
      `vector constructor iterator'(__t_5, 8u, __n_5, (void *(__fastcall *)(void *))sub_1405D9570);
    else
      __t_13 = 0;
    v133 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x2B0) = __t_13;
    v22 &= sub_14749FB70(__t_13, 8, *(unsigned int *)(v133 + 0x60), v7);
  }
  v134 = *(_QWORD *)(a1 + 0x1F8);
  v135 = *(unsigned int *)(v134 + 0x64);
  if ( (_DWORD)v135 )
  {
    __n_6 = *(_DWORD *)(v134 + 0x64);
    v137 = 8LL * __n_6;
    if ( !is_mul_ok(v135, 8u) )
      v137 = 0xFFFFFFFFFFFFFFFFuLL;
    __t_6 = (char *)qword_149B4F998(v137, 0);
    __t_14 = (__int64)__t_6;
    if ( __t_6 )
      `vector constructor iterator'(__t_6, 8u, __n_6, (void *(__fastcall *)(void *))sub_1405D9570);
    else
      __t_14 = 0;
    v140 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x2B8) = __t_14;
    v22 &= sub_14749FB70(__t_14, 8, *(unsigned int *)(v140 + 0x64), v7);
  }
  v141 = *(_QWORD *)(a1 + 0x1F8);
  v142 = *(unsigned int *)(v141 + 0x68);
  if ( (_DWORD)v142 )
  {
    __n_7 = *(_DWORD *)(v141 + 0x68);
    v144 = 0x14LL * __n_7;
    if ( !is_mul_ok(v142, 0x14u) )
      v144 = 0xFFFFFFFFFFFFFFFFuLL;
    __t_7 = (char *)qword_149B4F998(v144, 0);
    __t_15 = (__int64)__t_7;
    if ( __t_7 )
      `vector constructor iterator'(__t_7, 0x14u, __n_7, (void *(__fastcall *)(void *))sub_147481D20);
    else
      __t_15 = 0;
    v147 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x2C0) = __t_15;
    v22 &= sub_14749FB70(__t_15, 0x14, *(unsigned int *)(v147 + 0x68), v7);
  }
  v148 = *(_QWORD *)(a1 + 0x1F8);
  v149 = *(unsigned int *)(v148 + 0x6C);
  if ( (_DWORD)v149 )
  {
    v150 = 4LL * *(unsigned int *)(v148 + 0x6C);
    if ( !is_mul_ok(v149, 4u) )
      v150 = 0xFFFFFFFFFFFFFFFFuLL;
    v151 = qword_149B4F998(v150, 0);
    v152 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x2C8) = v151;
    v22 &= sub_14749FB70(v151, 4, *(unsigned int *)(v152 + 0x6C), v7);
  }
  v153 = *(unsigned int *)(*(_QWORD *)(a1 + 0x1F8) + 0x70LL);
  if ( (_DWORD)v153 )
  {
    v154 = qword_149B4F998(v153, 0);
    v155 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x2A0) = v154;
    v22 &= sub_14749FB70(v154, 1, *(unsigned int *)(v155 + 0x70), v7);
  }
  allocSize = *(unsigned int *)(*(_QWORD *)(a1 + 0x1F8) + 0x74LL);
  if ( (_DWORD)allocSize )
  {
    v157 = allocWithProfilerInfo_w(allocSize);
    v158 = *(_QWORD *)(a1 + 0x1F8);
    *(_QWORD *)(a1 + 0x2A8) = v157;
    v22 &= sub_14749FB70(v157, 1, *(unsigned int *)(v158 + 0x74), v7);
  }
  if ( !v22 )
  {
    v274 = 0x1C000000CFLL;
    *(_QWORD *)&v289[0] = &v274;
    *((_QWORD *)&v289[0] + 1) = &v275;
    v13 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v289,
            (__int64)"DataCore Load Failure",
            "Failed to read DCB, file is too small");
    if ( (v13 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      p_Failed_to_read_DCB__file_is_too_small = "Failed to read DCB, file is too small";
      goto LABEL_136;
    }
LABEL_137:
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC18 + 0x1D0LL))(qword_149B4FC18, v7);
    v10 = 0;
    goto LABEL_262;
  }
  v159 = *(_DWORD **)(a1 + 0x1F8);
  v160 = 0;
  if ( v159[7] )
  {
    v161 = 0;
    do
    {
      v162 = *(_QWORD *)(a1 + 0x220);
      if ( *(_DWORD *)(v161 + v162) )
      {
        if ( v159[1] >= 6u )
          v163 = *(_QWORD *)(a1 + 0x2A8);
        else
          v163 = *(_QWORD *)(a1 + 0x2A0);
        v276 = (__int64 *)(*(unsigned int *)(*(_QWORD *)(a1 + 0x200) + 0x10LL * *(unsigned __int16 *)(v161 + v162 + 4))
                         + v163);
        v164 = (_QWORD *)(a1 + 0x130);
        sub_14035B120(&v277, &v276);
        v165 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++v165;
        while ( v277[v165] );
        v166 = 0xCBF29CE484222325uLL;
        v167 = 0;
        if ( v165 )
        {
          do
          {
            v168 = (unsigned __int8)v277[v167++];
            v166 = 0x100000001B3LL * (v168 ^ v166);
          }
          while ( v167 < v165 );
          v164 = (_QWORD *)(a1 + 0x130);
        }
        sub_14747F260(v164, v289, &v277, (__PAIR128__(v166, v166) * 0xDE5FB9D2630458E9uLL) >> 0x40);
        v277 = (char *)&qword_149B3B33C + 4;
        sub_140370D10(&v277);
        if ( *(_QWORD *)&v289[0] != *v164 + v164[3] )
        {
          v169 = *((_QWORD *)&v289[0] + 1);
          *(_QWORD *)(v169 + 0x38) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(*((_QWORD *)&v289[0] + 1) + 0x18LL))(
                                       *(_QWORD *)(*((_QWORD *)&v289[0] + 1) + 0x18LL),
                                       *(unsigned int *)(v161 + v162));
        }
      }
      v159 = *(_DWORD **)(a1 + 0x1F8);
      ++v160;
      v161 += 8;
    }
    while ( v160 < v159[7] );
  }
  v170 = v159[7] == 0;
  LODWORD(v281) = 0;
  if ( v170 )
  {
LABEL_183:
    v170 = v159[8] == 0;
    LODWORD(v275) = 0;
    if ( !v170 )
    {
      v191 = (_QWORD *)(a1 + 0x130);
      allocSize_2 = 0;
      allocSize_3 = 0;
      v289[2] = v2;
      while ( 1 )
      {
        v193 = *(_QWORD *)(a1 + 0x218);
        v194 = *(_QWORD *)(a1 + 0x2A0);
        v195 = *(unsigned int *)(allocSize_3 + v193);
        v196 = *(unsigned int *)(*(_QWORD *)(a1 + 0x200) + 0x10LL * *(unsigned int *)(allocSize_3 + v193 + 8));
        if ( v159[1] >= 6u )
        {
          v197 = (char *)(v195 + *(_QWORD *)(a1 + 0x2A8));
          v198 = (const char *)(*(_QWORD *)(a1 + 0x2A8) + v196);
        }
        else
        {
          v197 = (char *)(v195 + v194);
          v198 = (const char *)(v194 + v196);
        }
        v199 = (_BYTE *)(v194 + *(unsigned int *)(allocSize_3 + v193 + 4));
        *(_QWORD *)&v278 = v198;
        v281 = v199;
        sub_14035B120((_QWORD *)&v278 + 1, &v278);
        v200 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++v200;
        while ( *(_BYTE *)(*((_QWORD *)&v278 + 1) + v200) );
        v201 = 0xCBF29CE484222325uLL;
        v202 = 0;
        if ( v200 )
        {
          do
          {
            v203 = *(unsigned __int8 *)(v202 + *((_QWORD *)&v278 + 1));
            ++v202;
            v201 = 0x100000001B3LL * (v203 ^ v201);
          }
          while ( v202 < v200 );
          v191 = (_QWORD *)(a1 + 0x130);
        }
        sub_14747F260(v191, &v280, (_QWORD *)&v278 + 1, (__PAIR128__(v201, v201) * 0xDE5FB9D2630458E9uLL) >> 0x40);
        *((_QWORD *)&v278 + 1) = (char *)&qword_149B3B33C + 4;
        sub_140370D10((_QWORD *)&v278 + 1);
        if ( (_QWORD)v280 != *v191 + v191[3] )
          break;
        sub_1405C0E00(
          8u,
          2u,
          "[DataCore] BinaryLoad: Record was not loaded as structure %s could not be located in the game but has been exp"
          "orted from DataCore.",
          v198);
LABEL_220:
        allocSize_3 += 0x20LL;
        v159 = *(_DWORD **)(a1 + 0x1F8);
        LODWORD(v275) = v275 + 1;
        allocSize_2 = allocSize_3;
        if ( (unsigned int)v275 >= v159[8] )
          goto LABEL_221;
      }
      v204 = *(unsigned __int16 *)(allocSize_3 + v193 + 0x1C);
      v289[0] = *(_OWORD *)(allocSize_3 + v193 + 0xC);
      v205 = *(_QWORD *)(*((_QWORD *)&v280 + 1) + 0x38LL) + *(_QWORD *)(*((_QWORD *)&v280 + 1) + 0x30LL) * v204;
      v206 = allocWithProfilerInfo_w(0x28u);
      if ( v206 )
      {
        StringObjectFromString = (const void **)CreateStringObjectFromString((void **)&v276, v197);
        v208 = v289[0];
        v209 = StringObjectFromString;
        *(_QWORD *)(v206 + 8) = v205;
        *(_QWORD *)v206 = &off_148D303E8;
        *(_OWORD *)(v206 + 0x10) = v208;
        sub_14035B160((void **)(v206 + 0x20), StringObjectFromString);
        sub_140370D10(v209);
      }
      else
      {
        v206 = 0;
      }
      sub_14747F5C0((__int64 *)(a1 + 8), (__int64)v287, v289);
      *(_QWORD *)(v288 + 0x10) = v206;
      v210 = v289[0];
      CreateStringObjectFromString((void **)&v285, v197);
      sub_14747FA70((_QWORD *)(a1 + 0x40), (__int64)v287, (const char **)&v285);
      v211 = v288;
      *(_QWORD *)(v288 + 8) = v206;
      *(_OWORD *)(v211 + 0x10) = v210;
      sub_140370D10(&v285);
      sub_14747F760((__int64 *)(a1 + 0x78), (__int64)v287, v289);
      assignCStringToStringStructure((void **)(v288 + 0x10), v197);
      sub_14747F760((__int64 *)(a1 + 0xB0), (__int64)v287, v289);
      assignCStringToStringStructure((void **)(v288 + 0x10), v281);
      v212 = (_QWORD *)(a1 + 0xE8);
      CreateStringObjectFromString((void **)&v274, v198);
      v213 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v213;
      while ( *(_BYTE *)(v274 + v213) );
      v214 = 0xCBF29CE484222325uLL;
      v215 = 0;
      if ( v213 )
      {
        do
        {
          v216 = *(unsigned __int8 *)(v274 + v215++);
          v214 = 0x100000001B3LL * (v216 ^ v214);
        }
        while ( v215 < v213 );
        v212 = (_QWORD *)(a1 + 0xE8);
      }
      v217 = (__PAIR128__(v214, v214) * 0xDE5FB9D2630458E9uLL) >> 0x40;
      v218 = sub_14747D980(v212, &v274, v217);
      if ( v218 == 0xFFFFFFFFFFFFFFFFuLL )
      {
        v219 = sub_1474D20C0(v212, v217);
        v220 = (_QWORD *)(0x10 * v219 + v212[1]);
        sub_14035B140(v220, &v274);
        v221 = v217 & 0x7F;
        v220[1] = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
        *(_BYTE *)(v219 + *v212) = v221;
        *(_BYTE *)((v212[3] & 0xFLL) + (v212[3] & (v219 - 0x10)) + *v212 + 1) = v221;
        v222 = 0x10 * v219 + v212[1];
      }
      else
      {
        v222 = v212[1] + 0x10 * v218;
      }
      v223 = *(_QWORD *)(v222 + 8);
      v224 = (unsigned __int64 *)(v222 + 8);
      v225 = *(_DWORD *)(v223 - 4);
      v226 = v225 & 0x7FFFFFFF;
      v227 = 0x10 * v225;
      v228 = (v225 & 0x7FFFFFFF) + 1;
      if ( v225 >= 0 )
        v229 = (unsigned __int64)v227 >> 4;
      else
        LODWORD(v229) = *(_DWORD *)(v227 + v223);
      if ( v228 > (int)v229 )
      {
        LODWORD(v281) = v226 + 1;
        if ( !v225 )
          v223 = 0;
        v230 = sub_14044EB10((__int64)v224, v223, v226, (int *)&v281, 8u, 1u);
        *v224 = v230;
        if ( !v230 )
        {
          *v224 = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
LABEL_216:
          v233 = *(unsigned int *)(*v224 - 4);
          LODWORD(v233) = v233 & 0x7FFFFFFF;
          v234 = *v224 + 0x10 * v233;
          v235 = (_OWORD *)(v234 - 0x10);
          do
            *v235++ = v289[0];
          while ( v235 != (_OWORD *)v234 );
          sub_140370D10(&v274);
          allocSize_3 = allocSize_2;
          v191 = (_QWORD *)(a1 + 0x130);
          goto LABEL_220;
        }
        LODWORD(v229) = (_DWORD)v281;
      }
      v231 = *v224;
      v232 = 0x10 * v228;
      *(_DWORD *)(*v224 - 4) = v228;
      if ( 0x10LL * (int)v229 >= (unsigned __int64)(v232 + 4) )
      {
        *(_DWORD *)(v231 - 4) = v228 | 0x80000000;
        *(_DWORD *)(v232 + v231) = v229;
      }
      goto LABEL_216;
    }
LABEL_221:
    for ( i = 0; i < v159[4]; v159 = *(_DWORD **)(a1 + 0x1F8) )
    {
      v237 = (unsigned int *)(*(_QWORD *)(a1 + 0x200) + 0x10LL * i);
      if ( v159[1] >= 6u )
        v238 = *(_QWORD *)(a1 + 0x2A8);
      else
        v238 = *(_QWORD *)(a1 + 0x2A0);
      v239 = *v237 + v238;
      v240 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v240;
      while ( *(_BYTE *)(v239 + v240) );
      LODWORD(v275) = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(
                         0xFFFFFFFF,
                         v239,
                         v240);
      ++i;
      *(_QWORD *)(*(_QWORD *)sub_1402AAA30(a1 + 0x318, (__int64)&v280, (unsigned __int8 *)&v275) + 0x18LL) = v237;
    }
    for ( j = 0; j < v159[6]; v159 = *(_DWORD **)(a1 + 0x1F8) )
    {
      v242 = (unsigned int *)(*(_QWORD *)(a1 + 0x210) + 8LL * j);
      if ( v159[1] >= 6u )
        v243 = *(_QWORD *)(a1 + 0x2A8);
      else
        v243 = *(_QWORD *)(a1 + 0x2A0);
      v244 = *v242 + v243;
      v245 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v245;
      while ( *(_BYTE *)(v244 + v245) );
      LODWORD(v275) = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(
                         0xFFFFFFFF,
                         v244,
                         v245);
      ++j;
      *(_QWORD *)(*(_QWORD *)sub_1402AAA30(a1 + 0x358, (__int64)&v280, (unsigned __int8 *)&v275) + 0x18LL) = v242;
    }
    v246 = *(char **)(a1 + 0x130);
    v247 = *(__int64 **)(a1 + 0x138);
    if ( *v246 < (char)0xFFFFFFFF )
    {
      _XMM1 = xmmword_14819F440;
      do
      {
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [rbx]
          vpmovmskb eax, xmm0
        }
        _BitScanForward((unsigned int *)&v251, _EAX + 1);
        v246 += (unsigned int)v251;
        v247 += 9 * v251;
      }
      while ( *v246 < (char)0xFFFFFFFF );
    }
    if ( v246 == (char *)(*(_QWORD *)(a1 + 0x148) + *(_QWORD *)(a1 + 0x130)) )
    {
LABEL_257:
      sub_1474C42F0(a1);
      sub_1474C4780(a1);
      v263 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 **))(*(_QWORD *)qword_149B4FC40 + 0x48LL))(
                         qword_149B4FC40,
                         &v276);
      sub_1405975C0(v263, &allocSize_2, &k);
      _XMM0 = sub_140597760();
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      LogTraceConditional("[DataCore] Binary Data Loaded. Total Time took %fs", *(float *)&_XMM1);
      v266 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64 **))(*(_QWORD *)qword_149B4FC40 + 0x48LL))(
                          qword_149B4FC40,
                          &v276);
      v267 = *(_QWORD **)(a1 + 0x198);
      v268 = *(_QWORD **)(a1 + 0x190);
      for ( k = *v266; v268 != v267; ++v268 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v268 + 0x28LL))(*v268);
      v269 = *(_QWORD *)(a1 + 0x190);
      if ( v269 != *(_QWORD *)(a1 + 0x198) )
        *(_QWORD *)(a1 + 0x198) = v269;
      v270 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 **))(*(_QWORD *)qword_149B4FC40 + 0x48LL))(
                         qword_149B4FC40,
                         &v276);
      sub_1405975C0(v270, &allocSize_2, &k);
      _XMM0 = sub_140597760();
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      LogTraceConditional("[DataCore] Game Post Load. Total Time took %fs", *(float *)&_XMM1);
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC18 + 0x1D0LL))(qword_149B4FC18, v284);
      v10 = 1;
      goto LABEL_262;
    }
    while ( 1 )
    {
      v252 = *v247;
      v253 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v253;
      while ( *(_BYTE *)(v252 + v253) );
      v254 = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(0xFFFFFFFF, v252, v253);
      v255 = *(_QWORD *)(a1 + 0x320);
      v256 = *(_QWORD *)(a1 + 0x330);
      v257 = *(_QWORD *)(v256
                       + 0x10
                       * ((0x100000001B3LL
                         * (((unsigned __int64)v254 >> 0x18)
                          ^ (0x100000001B3LL
                           * (BYTE2(v254)
                            ^ (0x100000001B3LL
                             * (BYTE1(v254) ^ (0x100000001B3LL * ((unsigned __int8)v254 ^ 0xCBF29CE484222325uLL))))))))
                        & *(_QWORD *)(a1 + 0x348))
                       + 8);
      if ( v257 == v255 )
        goto LABEL_247;
      v258 = *(_QWORD *)(v256
                       + 0x10
                       * ((0x100000001B3LL
                         * (((unsigned __int64)v254 >> 0x18)
                          ^ (0x100000001B3LL
                           * (BYTE2(v254)
                            ^ (0x100000001B3LL
                             * (BYTE1(v254) ^ (0x100000001B3LL * ((unsigned __int8)v254 ^ 0xCBF29CE484222325uLL))))))))
                        & *(_QWORD *)(a1 + 0x348)));
      if ( v254 != *(_DWORD *)(v257 + 0x10) )
        break;
LABEL_248:
      if ( !v257 )
        v257 = v255;
      if ( v257 != v255 && *(_QWORD *)(v257 + 0x18) )
        sub_1474AAF40(a1, v247 + 1);
      ++v246;
      v247 += 9;
      if ( *v246 < (char)0xFFFFFFFF )
      {
        _XMM1 = xmmword_14819F440;
        do
        {
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [rbx]
            vpmovmskb eax, xmm0
          }
          _BitScanForward((unsigned int *)&v262, _EAX + 1);
          v246 += (unsigned int)v262;
          v247 += 9 * v262;
        }
        while ( *v246 < (char)0xFFFFFFFF );
      }
      if ( v246 == (char *)(*(_QWORD *)(a1 + 0x148) + *(_QWORD *)(a1 + 0x130)) )
        goto LABEL_257;
    }
    while ( v257 != v258 )
    {
      v257 = *(_QWORD *)(v257 + 8);
      if ( v254 == *(_DWORD *)(v257 + 0x10) )
      {
        v255 = *(_QWORD *)(a1 + 0x320);
        goto LABEL_248;
      }
    }
    v255 = *(_QWORD *)(a1 + 0x320);
LABEL_247:
    v257 = 0;
    goto LABEL_248;
  }
  v171 = (_QWORD *)(a1 + 0x130);
  v172 = 0;
  while ( 1 )
  {
    v274 = *(_QWORD *)(a1 + 0x220);
    v173 = (unsigned int *)(*(_QWORD *)(a1 + 0x200) + 0x10LL * *(unsigned __int16 *)(v172 + v274 + 4));
    allocSize_1 = *(_DWORD *)(v172 + v274) * (unsigned int)*((unsigned __int16 *)v173 + 6);
    v175 = v159[1] < 6u;
    v176 = *v173;
    allocSize_2 = allocSize_1;
    if ( v175 )
      v177 = *(_QWORD *)(a1 + 0x2A0);
    else
      v177 = *(_QWORD *)(a1 + 0x2A8);
    v275 = v176 + v177;
    v276 = (__int64 *)(v176 + v177);
    sub_14035B120(&v277, &v276);
    v178 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v178;
    while ( v277[v178] );
    v179 = 0xCBF29CE484222325uLL;
    for ( m = 0; m < v178; v179 = 0x100000001B3LL * (v181 ^ v179) )
      v181 = (unsigned __int8)v277[m++];
    sub_14747F260(v171, v289, &v277, (__PAIR128__(v179, v179) * 0xDE5FB9D2630458E9uLL) >> 0x40);
    v277 = (char *)&qword_149B3B33C + 4;
    sub_140370D10(&v277);
    if ( *(_QWORD *)&v289[0] == *v171 + v171[3] )
    {
      (*(void (__fastcall **)(__int64, __int64, _QWORD, __int64))(*(_QWORD *)qword_149B4FC18 + 0x1C0LL))(
        qword_149B4FC18,
        v284,
        (unsigned int)allocSize_1,
        1);
      goto LABEL_172;
    }
    v182 = *((_QWORD *)&v289[0] + 1);
    v279 = 0;
    v278 = 0;
    if ( allocSize_1 )
    {
      *(_QWORD *)&v278 = sub_140391AB0((__int64)&v278, allocSize_1);
      v183 = v278 + allocSize_1;
      v279 = (const void *)(v278 + allocSize_1);
      memset((void *)v278, 0, allocSize_1);
      *((_QWORD *)&v278 + 1) = v183;
    }
    v184 = *(_QWORD *)qword_149B4FC18;
    v285 = (_BYTE *)v278;
    if ( (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, unsigned __int64, __int64, const char *))(v184 + 0x150))(
           qword_149B4FC18,
           v278,
           1,
           allocSize_1,
           v284,
           "FReadRawWithLog") != allocSize_1 )
      break;
    v185 = 0;
    v186 = v285;
    v187 = v285;
    if ( *(_DWORD *)(v172 + v274) )
    {
      do
        v187 = (_BYTE *)sub_1474B3870(
                          a1,
                          *(_DWORD *)(v182 + 0x38) + *(_DWORD *)(v182 + 0x30) * v185++,
                          v275,
                          (int)v182 + 8,
                          (__int64)v173,
                          (__int64)v187);
      while ( v185 < *(_DWORD *)(v172 + v274) );
      allocSize_1 = allocSize_2;
      v186 = v285;
    }
    if ( v187 - v186 != allocSize_1 )
    {
      v274 = 0x1C000000CFLL;
      *(_QWORD *)&v289[0] = &v274;
      *((_QWORD *)&v289[0] + 1) = &v275;
      v188 = invokeGlobalCallbackAndMaskStatusBits(
               2,
               (__int64)v289,
               (__int64)"DataCore Load Failure",
               "DCB file is larger than expected");
      if ( (v188 & 0xFFFFF) == 0 )
        goto LABEL_180;
      ThreadLogContextSlot_3 = getThreadLogContextSlot();
      p_DCB_file_is_smaller_than_expected = "DCB file is larger than expected";
      goto LABEL_179;
    }
    if ( (_QWORD)v278 )
      sub_1403A3120((__int64)&v278, (const void *)v278, (unsigned __int64)v279 - v278);
    v171 = (_QWORD *)(a1 + 0x130);
LABEL_172:
    v172 += 8;
    v159 = *(_DWORD **)(a1 + 0x1F8);
    LODWORD(v281) = (_DWORD)v281 + 1;
    if ( (unsigned int)v281 >= v159[7] )
      goto LABEL_183;
  }
  v274 = 0x1C000000CFLL;
  *(_QWORD *)&v289[0] = &v274;
  *((_QWORD *)&v289[0] + 1) = &v275;
  v188 = invokeGlobalCallbackAndMaskStatusBits(
           2,
           (__int64)v289,
           (__int64)"DataCore Load Failure",
           "DCB file is smaller than expected");
  if ( (v188 & 0xFFFFF) == 0 )
    goto LABEL_180;
  ThreadLogContextSlot_3 = getThreadLogContextSlot();
  p_DCB_file_is_smaller_than_expected = "DCB file is smaller than expected";
LABEL_179:
  *(_QWORD *)&v289[0] = &v274;
  *((_QWORD *)&v289[0] + 1) = &v275;
  v280 = 0;
  v274 = 0x1C000000CFLL;
  sub_1403515F0(
    2u,
    (__int64 *)v289,
    "DataCore Load Failure",
    p_DCB_file_is_smaller_than_expected,
    1,
    v188,
    &v280,
    0,
    (__int64)ThreadLogContextSlot_3);
LABEL_180:
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC18 + 0x1D0LL))(qword_149B4FC18, v284);
  if ( (_QWORD)v278 )
    sub_1403A3120((__int64)&v278, (const void *)v278, (unsigned __int64)v279 - v278);
  v10 = 0;
LABEL_262:
  sub_140370D10(&v282);
  return v10;
}

// --- End Function: sub_1474A9490 (0x1474A9490) ---

// --- Function: sub_1474AAF40 (0x1474AAF40) ---
_QWORD *__fastcall sub_1474AAF40(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v3; // r13
  _QWORD *result; // rax
  __int64 v6; // r15
  unsigned __int8 **v7; // r12
  char n0xF; // r15
  int v9; // r11d
  int v10; // r9d
  __int64 v11; // rbx
  int v12; // r14d
  __int64 v13; // r10
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int8 *v16; // rax
  __int64 v17; // r8
  int v18; // ecx
  int v19; // edx
  char n0xF_1; // al
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rbx
  _QWORD *v25; // rbx
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rdx
  __int64 v28; // r8
  __int64 v29; // rax
  __int64 v30; // [rsp+20h] [rbp-68h] BYREF
  char *v31; // [rsp+28h] [rbp-60h] BYREF
  __int64 v32; // [rsp+30h] [rbp-58h] BYREF
  char *v33; // [rsp+38h] [rbp-50h] BYREF
  _QWORD v34[2]; // [rsp+40h] [rbp-48h] BYREF
  __int64 v36; // [rsp+A0h] [rbp+18h]
  __int64 i; // [rsp+A8h] [rbp+20h]

  v36 = a3;
  v3 = 0;
  result = a2;
  if ( a2[1] )
  {
    v6 = 0;
    for ( i = 0; ; i += 0x28 )
    {
      v7 = (unsigned __int8 **)(v6 + *result);
      n0xF = *((_BYTE *)v7 + 0x18);
      if ( (unsigned __int8)(n0xF - 0xF) <= 1u )
      {
        v9 = *(unsigned __int16 *)(a3 + 8);
        v10 = 0;
        if ( *(_WORD *)(a3 + 8) )
          break;
      }
LABEL_35:
      ++v3;
      result = a2;
      v6 = i + 0x28;
      if ( v3 >= a2[1] )
        return result;
    }
    v11 = a1[0x41];
    v12 = *(unsigned __int16 *)(a3 + 0xA);
    while ( 1 )
    {
      v13 = v11 + 0xCLL * (v12 + v10);
      v14 = *(_DWORD *)(a1[0x3F] + 4LL) >= 6u ? a1[0x55] : a1[0x54];
      v15 = *(unsigned int *)(v11 + 0xCLL * (v12 + v10)) + v14;
      v16 = *v7;
      v17 = v15 - (_QWORD)*v7;
      do
      {
        v18 = v16[v17];
        v19 = *v16 - v18;
        if ( v19 )
          break;
        ++v16;
      }
      while ( v18 );
      if ( !v19 )
        break;
      if ( ++v10 >= v9 )
        goto LABEL_34;
    }
    n0xF_1 = *(_BYTE *)(v13 + 6);
    if ( n0xF_1 == 0x10 )
    {
      v21 = *(unsigned int *)(a1[0x40] + 0x10LL * *(unsigned __int16 *)(v13 + 4));
    }
    else
    {
      if ( n0xF_1 != 0xF )
      {
        v23 = 0;
LABEL_24:
        if ( n0xF != 0xF )
        {
          v30 = v23;
          v25 = a1 + 0x26;
          sub_14035B120(&v31, &v30);
          v26 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++v26;
          while ( v31[v26] );
          v27 = 0;
          v28 = 0xCBF29CE484222325uLL;
          if ( v26 )
          {
            do
            {
              v29 = (unsigned __int8)v31[v27++];
              v28 = 0x100000001B3LL * (v29 ^ v28);
            }
            while ( v27 < v26 );
            v25 = a1 + 0x26;
          }
          sub_14747F260(
            v25,
            v34,
            &v31,
            0xDE5FB9D2630458E9uLL * v28 + (((unsigned __int64)v28 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
          v31 = (char *)&qword_149B3B33C + 4;
          sub_140370D10(&v31);
          if ( v34[0] != *v25 + v25[3] )
            v7[4] = *(unsigned __int8 **)v34[1];
LABEL_34:
          a3 = v36;
          goto LABEL_35;
        }
        v32 = v23;
        sub_14035B120(&v33, &v32);
        v24 = sub_140CB7F10(a1 + 0x24, &v33);
        v33 = (char *)&qword_149B3B33C + 4;
        sub_140370D10(&v33);
        a3 = v36;
        if ( v24 != a1[0x24] )
          v7[4] = *(unsigned __int8 **)(v24 + 0x20);
        goto LABEL_35;
      }
      v21 = *(unsigned int *)(a1[0x42] + 8LL * *(unsigned __int16 *)(v13 + 4));
    }
    if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
      v22 = a1[0x55];
    else
      v22 = a1[0x54];
    v23 = v21 + v22;
    goto LABEL_24;
  }
  return result;
}

// --- End Function: sub_1474AAF40 (0x1474AAF40) ---

// --- Function: sub_1474ABF20 (0x1474ABF20) ---
char *__fastcall sub_1474ABF20(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  char *result; // rax
  __int64 n7; // rcx
  Record **p_Record; // r8
  __int64 v9; // rdx
  __int64 v10; // rcx
  _QWORD *v11; // rax
  char *v12; // [rsp+20h] [rbp-38h] BYREF
  __int64 v13; // [rsp+28h] [rbp-30h]
  __int128 v14; // [rsp+30h] [rbp-28h] BYREF

  result = (char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a4 + 0x38LL))(*a4);
  n7 = 0;
  p_Record = "Record";
  while ( 1 )
  {
    v9 = (unsigned __int8)result[n7++];
    if ( (_BYTE)v9 != aRecord[n7 - 1] )
      break;
    if ( n7 == 7 )
    {
      result = (char *)(*(__int64 (__fastcall **)(_QWORD, const char *, const char *))(*(_QWORD *)*a4 + 0x110LL))(
                         *a4,
                         "__guid",
                         "Record");
      if ( (result && *result && (*result != 0x30 || result[1])
         || (result = (char *)(*(__int64 (__fastcall **)(_QWORD, int *))(*(_QWORD *)*a4 + 0x110LL))(
                                *a4,
                                &dword_1481A2E70)) != 0)
        && *result
        && (*result != 0x30 || result[1]) )
      {
        v14 = *(_OWORD *)sub_1402BC380((__int64 *)&v14, result);
        sub_14747EED0(a1 + 8, &v12, &v14);
        result = (char *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 0x20));
        if ( v12 != result )
        {
          result = (char *)v13;
          v10 = *(_QWORD *)(v13 + 0x10);
          if ( v10 )
          {
            v11 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x10LL))(v10);
            result = (char *)sub_1474C2A60(a1, *v11, a4);
          }
        }
      }
      break;
    }
  }
  if ( *a4 )
    return (char *)(*(__int64 (__fastcall **)(_QWORD, __int64, const char *))(*(_QWORD *)*a4 + 0x28LL))(
                     *a4,
                     v9,
                     p_Record);
  return result;
}

// --- End Function: sub_1474ABF20 (0x1474ABF20) ---

// --- Function: sub_1474AC380 (0x1474AC380) ---
void __fastcall sub_1474AC380(__int64 a1, __int64 a2, const char **a3, _QWORD *a4)
{
  char **v8; // rax
  char **v9; // rax
  __int64 *v10; // rdi
  unsigned __int8 **v11; // rbx
  char *v12; // r13
  __int64 v13; // r15
  __int64 *inserted; // rdi
  __int64 v15; // rbx
  __int64 *v16; // rdi
  __int64 v17; // rsi
  __int128 v18; // xmm0
  size_t Size; // r8
  const char *v20; // rax
  const char *v21; // rax
  unsigned __int8 *v22; // [rsp+30h] [rbp-30h] BYREF
  void *v23; // [rsp+38h] [rbp-28h] BYREF
  __int128 v24; // [rsp+40h] [rbp-20h] BYREF
  __int64 Src; // [rsp+B0h] [rbp+50h] BYREF
  const char *v26; // [rsp+B8h] [rbp+58h] BYREF

  sub_14035B3E0(&Src);
  v9 = sub_1403A9130(v8, "__%s__type", *a3);
  sub_14035B160(&v23, (const void **)v9);
  sub_140370D10(&Src);
  sub_14035B3E0(&v26);
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a4 + 0x118LL))(*a4, *a3)
    && (*(unsigned __int8 (__fastcall **)(_QWORD, void *))(*(_QWORD *)*a4 + 0x118LL))(*a4, v23) )
  {
    (*(void (__fastcall **)(_QWORD, void *, const char **))(*(_QWORD *)*a4 + 0x80LL))(*a4, v23, &v26);
    v10 = *(__int64 **)(a1 + 0x120);
    v11 = (unsigned __int8 **)v10[1];
    while ( !*((_BYTE *)v11 + 0x19) )
    {
      if ( (int)sub_1403E4780(v11 + 4, &v26) >= 0 )
      {
        v10 = (__int64 *)v11;
        v11 = (unsigned __int8 **)*v11;
      }
      else
      {
        v11 = (unsigned __int8 **)v11[2];
      }
    }
    if ( *((_BYTE *)v10 + 0x19)
      || (int)sub_1403E4780((unsigned __int8 **)&v26, v10 + 4) < 0
      || v10 == *(__int64 **)(a1 + 0x120) )
    {
      v21 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
      sub_1405C0E00(
        8u,
        2u,
        "[DataCore] Field \"%s\" enum \"%s\" was not found. Did you register it (see DataCore_GamePreInitialize())? \"%s\"",
        *a3,
        v26,
        v21);
    }
    else
    {
      v12 = (char *)&a3[1][a2];
      v13 = *(_QWORD *)(sub_147487040(a1 + 0x120, &v26) + 8);
      sub_14035B3E0(&v22);
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a4 + 0x118LL))(*a4, *a3) )
      {
        (*(void (__fastcall **)(_QWORD, const char *, unsigned __int8 **))(*(_QWORD *)*a4 + 0x80LL))(*a4, *a3, &v22);
        inserted = *(__int64 **)v13;
        DWORD2(v24) = 0;
        v15 = inserted[1];
        *(_QWORD *)&v24 = v15;
        while ( !*(_BYTE *)(v15 + 0x19) )
        {
          *(_QWORD *)&v24 = v15;
          if ( (int)sub_1403E4780((unsigned __int8 **)(v15 + 0x20), &v22) >= 0 )
          {
            inserted = (__int64 *)v15;
            DWORD2(v24) = 1;
            v15 = *(_QWORD *)v15;
          }
          else
          {
            v15 = *(_QWORD *)(v15 + 0x10);
            DWORD2(v24) = 0;
          }
        }
        if ( *((_BYTE *)inserted + 0x19) || (int)sub_1403E4780(&v22, inserted + 4) < 0 )
        {
          if ( *(_QWORD *)(v13 + 8) == 0x555555555555555LL )
            unknown_libname_7();
          v16 = *(__int64 **)v13;
          v17 = allocWithProfilerInfo_w(0x30u);
          sub_14035B160((void **)(v17 + 0x20), (const void **)&v22);
          v18 = v24;
          *(_DWORD *)(v17 + 0x28) = 0;
          *(_QWORD *)v17 = v16;
          *(_QWORD *)(v17 + 8) = v16;
          *(_QWORD *)(v17 + 0x10) = v16;
          *(_WORD *)(v17 + 0x18) = 0;
          v24 = v18;
          inserted = (__int64 *)std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                                  (__int64 **)v13,
                                  (__int64)&v24,
                                  v17);
        }
        Size = (size_t)a3[2];
        LODWORD(Src) = *((_DWORD *)inserted + 0xA);
        memcpy(v12, &Src, Size);
        sub_140370D10(&v22);
      }
      else
      {
        v20 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
        sub_1405C0E00(
          8u,
          0,
          "[DataCore] Cannot locate default enum value for field '%s' in record '%s'. Please provide default value within"
          " the schema. Value will be UNINITIALIZED!",
          *a3,
          v20);
        sub_140370D10(&v22);
      }
    }
  }
  sub_140370D10(&v26);
  sub_140370D10(&v23);
}

// --- End Function: sub_1474AC380 (0x1474AC380) ---

// --- Function: sub_1474AC650 (0x1474AC650) ---
void __fastcall sub_1474AC650(__int64 a1, __int64 a2, const char **a3, _QWORD *a4)
{
  const char *v7; // r14
  char **v8; // rax
  char **v9; // rax
  int v10; // eax
  __int64 v11; // r13
  __int64 *v12; // rdi
  unsigned __int8 **v13; // rbx
  size_t *v14; // rax
  __int64 *v15; // rdi
  size_t Size; // r15
  const void *v17; // rcx
  int v18; // esi
  __int64 v19; // r14
  const char *v20; // r13
  __int64 *v21; // rbx
  __int64 v22; // rax
  __int64 v23; // rbx
  __int64 v24; // rdi
  const char *v25; // rax
  unsigned __int8 *v26; // [rsp+30h] [rbp-39h] BYREF
  __int64 v27; // [rsp+38h] [rbp-31h] BYREF
  int Src; // [rsp+40h] [rbp-29h] BYREF
  void *v29; // [rsp+48h] [rbp-21h] BYREF
  __int64 v30; // [rsp+50h] [rbp-19h] BYREF
  __int64 *v31; // [rsp+58h] [rbp-11h]
  void *v32; // [rsp+60h] [rbp-9h] BYREF
  __int64 *v33; // [rsp+68h] [rbp-1h]
  __int64 v34; // [rsp+70h] [rbp+7h] BYREF
  char *v35; // [rsp+78h] [rbp+Fh] BYREF
  void *v36; // [rsp+80h] [rbp+17h]
  __int64 v39; // [rsp+E8h] [rbp+7Fh] BYREF

  (*(void (__fastcall **)(_QWORD, __int64 *, const char *))(*(_QWORD *)*a4 + 0x168LL))(*a4, &v27, *a3);
  v7 = &a3[1][a2];
  if ( v27 )
  {
    sub_14035B3E0(&v39);
    v9 = sub_1403A9130(v8, "__%s__type", *a3);
    sub_14035B160(&v29, (const void **)v9);
    sub_140370D10(&v39);
    sub_14035B3E0(&v26);
    if ( (*(unsigned __int8 (__fastcall **)(__int64, void *))(*(_QWORD *)v27 + 0x118LL))(v27, v29) )
    {
      (*(void (__fastcall **)(__int64, void *, unsigned __int8 **))(*(_QWORD *)v27 + 0x80LL))(v27, v29, &v26);
      v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x158LL))(v27);
      v11 = v10;
      LODWORD(v39) = v10;
      if ( v10 > 0 )
      {
        v12 = *(__int64 **)(a1 + 0x120);
        v13 = (unsigned __int8 **)v12[1];
        while ( !*((_BYTE *)v13 + 0x19) )
        {
          if ( (int)sub_1403E4780(v13 + 4, &v26) >= 0 )
          {
            v12 = (__int64 *)v13;
            v13 = (unsigned __int8 **)*v13;
          }
          else
          {
            v13 = (unsigned __int8 **)v13[2];
          }
        }
        if ( !*((_BYTE *)v12 + 0x19) && (int)sub_1403E4780(&v26, v12 + 4) >= 0 && v12 != *(__int64 **)(a1 + 0x120) )
        {
          v14 = (size_t *)sub_147487040(a1 + 0x120, &v26);
          v15 = (__int64 *)(v7 + 0x10);
          v33 = (__int64 *)(v7 + 0x10);
          Size = *v14;
          v31 = (__int64 *)v14[1];
          v17 = (const void *)*((_QWORD *)v7 + 2);
          *((_QWORD *)v7 + 3) = v11;
          if ( v17 )
          {
            sub_1402A3D30(v17);
            *v15 = 0;
          }
          v18 = 0;
          v19 = 0;
          *v15 = allocWithProfilerInfo(Size * v11, 0);
          do
          {
            (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v27 + 0x160LL))(
              v27,
              &v30,
              (unsigned int)v18);
            v36 = (void *)(v19 + *v15);
            Src = 0;
            if ( v30
              && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v30 + 0x118LL))(v30, &dword_1481A2E70) )
            {
              v34 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v30 + 0x110LL))(v30, &dword_1481A2E70);
              v20 = (const char *)v34;
              sub_14035B120(&v35, &v34);
              v21 = v31;
              v22 = std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
                      v31,
                      &v35);
              v23 = *v21;
              v24 = v22;
              v35 = (char *)&qword_149B3B33C + 4;
              sub_140370D10(&v35);
              if ( v24 != v23 )
              {
                CreateStringObjectFromString(&v32, v20);
                Src = *(_DWORD *)sub_1409AABD0(v31, &v32);
                sub_140370D10(&v32);
              }
              LODWORD(v11) = v39;
              v15 = v33;
            }
            else
            {
              v25 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Cannot locate default enum array value for field '%s' in record '%s'. Please provide default "
                "value within the schema. Value will be UNINITIALIZED!",
                *a3,
                v25);
            }
            memcpy(v36, &Src, Size);
            if ( v30 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x28LL))(v30);
            ++v18;
            v19 += Size;
          }
          while ( v18 < (int)v11 );
        }
      }
    }
    sub_140370D10(&v26);
    sub_140370D10(&v29);
    if ( v27 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x28LL))(v27);
  }
}

// --- End Function: sub_1474AC650 (0x1474AC650) ---

// --- Function: sub_1474AC970 (0x1474AC970) ---
__int64 __fastcall sub_1474AC970(
        _QWORD *a1,
        const char *a2,
        __int64 **a3,
        const char *a4,
        __int64 a5,
        __int64 a6,
        char *a7)
{
  __int128 v7; // xmm6
  __int128 v8; // xmm7
  char *v9; // rsi
  const char *v10; // r13
  __int64 v11; // r12
  __int64 **v12; // rdi
  __int64 v13; // r9
  const char *v14; // r14
  _QWORD *v15; // r15
  unsigned int Src_5; // ebx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rax
  char n3; // r8
  const char **v20; // r13
  char v21; // dl
  __int64 v22; // rax
  double v23; // rbx
  int v24; // eax
  __int64 v25; // r8
  int v26; // r15d
  int v27; // esi
  __int64 v28; // r14
  __int64 v29; // rdi
  _QWORD *v30; // rdi
  char *v31; // rax
  __int64 *v32; // rax
  __int64 v35; // rcx
  __int64 result; // rax
  unsigned __int64 v37; // rdx
  _QWORD *v38; // rbx
  __int64 v39; // rcx
  unsigned __int64 v40; // r8
  __int64 v41; // rax
  const char *v42; // rcx
  int v43; // r14d
  int i; // esi
  int v45; // edi
  unsigned int j; // ebx
  const char *v47; // rdi
  char *v48; // rax
  char *v49; // rdx
  __int64 n5; // rcx
  char v51; // al
  __int64 *v52; // rax
  double v55; // rbx
  int v56; // eax
  __int64 v57; // r8
  int v58; // r15d
  int v59; // edi
  __int64 v60; // r14
  _QWORD *v61; // rsi
  __int64 v62; // rax
  char **v63; // rbx
  const void **v64; // rax
  _QWORD *v65; // rdx
  const char *v66; // rdi
  __int64 v67; // rax
  char **v68; // rbx
  const void **v69; // rax
  const char **v70; // rdx
  const char *v71; // r14
  int allocSize_1; // eax
  int allocSize_14; // esi
  int allocSize_15; // ebx
  __int64 v75; // rdi
  char v76; // al
  char v77; // dl
  const char *v78; // rax
  const char *v79; // r14
  int v80; // eax
  unsigned __int64 v81; // rsi
  unsigned __int64 allocSize_2; // rax
  int v83; // ebx
  __int64 v84; // rdi
  char v85; // al
  __int16 v86; // cx
  const char *v87; // rax
  const char *v88; // r14
  int v89; // eax
  unsigned __int64 v90; // rsi
  unsigned __int64 allocSize_3; // rax
  int v92; // ebx
  __int64 v93; // rdi
  const char *v94; // rax
  const char *v95; // r14
  int v96; // eax
  unsigned __int64 v97; // rsi
  unsigned __int64 allocSize_4; // rax
  int v99; // ebx
  __int64 v100; // rdi
  const char *v101; // rax
  const char *v102; // r14
  int allocSize_5; // eax
  int allocSize_16; // esi
  int allocSize_17; // ebx
  __int64 v106; // rdi
  char v107; // al
  char v108; // dl
  const char *v109; // rax
  const char *v110; // r14
  int v111; // eax
  unsigned __int64 v112; // rsi
  unsigned __int64 allocSize_6; // rax
  int v114; // ebx
  __int64 v115; // rdi
  char v116; // al
  __int16 v117; // cx
  const char *v118; // rax
  const char *v119; // r14
  int v120; // eax
  unsigned __int64 v121; // rsi
  unsigned __int64 allocSize_7; // rax
  int v123; // ebx
  __int64 v124; // rdi
  const char *v125; // rax
  const char *v126; // r14
  int v127; // eax
  unsigned __int64 v128; // rsi
  unsigned __int64 allocSize_8; // rax
  int v130; // ebx
  __int64 v131; // rdi
  const char *v132; // rax
  const char *v133; // r14
  int v134; // eax
  unsigned __int64 v135; // rsi
  unsigned __int64 allocSize_9; // rax
  int v137; // ebx
  __int64 v138; // rdi
  const char *v139; // rax
  const char *v140; // r14
  int v141; // eax
  unsigned __int64 v142; // rsi
  unsigned __int64 allocSize_10; // rax
  int v144; // ebx
  __int64 v145; // rdi
  const char *v146; // rax
  const char *v147; // rsi
  int allocSize; // eax
  int allocSize_12; // r14d
  int allocSize_13; // ebx
  __int64 v151; // rdi
  const char *v152; // rax
  const char *v153; // r14
  int v154; // eax
  __int64 v155; // r8
  int v156; // esi
  int v157; // ebx
  __int64 v158; // rdi
  _BYTE *v159; // rax
  const char *v160; // rax
  int v161; // eax
  unsigned __int64 v162; // rsi
  const char *v163; // r14
  unsigned __int64 allocSize_11; // rax
  int v165; // ebx
  __int64 v166; // rdi
  int v167; // eax
  __int64 v168; // r8
  int v169; // esi
  const char *v170; // r14
  int v171; // ebx
  __int64 v172; // rdi
  float Src_3; // eax
  __int64 v174; // r8
  double v175; // rdi
  int v176; // r12d
  double v177; // rbx
  _BYTE *v178; // rax
  void **v179; // rdi
  __int64 v180; // rbx
  __int64 v181; // rax
  char **v182; // r15
  char **v183; // rax
  char **v184; // r14
  void **v185; // rax
  char *v186; // rdi
  void **v187; // rsi
  __int64 v188; // rbx
  __int64 v189; // rax
  _BYTE *v190; // rax
  _BYTE *v191; // rdi
  unsigned __int64 v192; // rdx
  __int64 v193; // rcx
  unsigned __int64 v194; // r8
  _QWORD *v195; // rbx
  __int64 v196; // rax
  __int64 v197; // rax
  __int64 *v198; // rbx
  __int64 *v199; // rax
  _BYTE *v200; // rdx
  _QWORD *v201; // rax
  const char *v202; // rsi
  const char *v203; // r14
  unsigned __int64 v204; // rdx
  _QWORD *v205; // rbx
  __int64 v206; // rcx
  unsigned __int64 v207; // r8
  __int64 v208; // rax
  __int64 v209; // rbx
  int v210; // esi
  void **v211; // rdi
  __int64 v212; // rbx
  __int64 v213; // rax
  char **v214; // r15
  char **v215; // rax
  char **v216; // r14
  void **v217; // rax
  char *v218; // rdi
  void **v219; // rsi
  __int64 v220; // rbx
  __int64 v221; // rax
  double v222; // rbx
  __int64 v223; // rdi
  __int64 *v224; // rax
  __int64 *v225; // rax
  const char *v226; // rbx
  const char *v227; // rax
  __int64 *v228; // rcx
  const char *v229; // rdx
  char v230; // al
  char v231; // dl
  const char *v232; // rbx
  const char *v233; // rax
  __int64 *v234; // rcx
  const char *v235; // rdx
  char v236; // al
  __int16 v237; // cx
  const char *v238; // rax
  const char *v239; // rbx
  const char *v240; // rax
  __int64 *v241; // rcx
  const char *v242; // rdx
  __int64 *v243; // rcx
  const char *v244; // rdx
  const char *v245; // rbx
  const char *v246; // rax
  __int64 *v247; // rcx
  const char *v248; // rdx
  __int64 *v249; // rcx
  const char *v250; // rdx
  const char *v251; // rbx
  const char *v252; // rax
  __int64 *v253; // rcx
  const char *v254; // rdx
  char v255; // al
  char v256; // dl
  const char *v257; // rbx
  const char *v258; // rax
  __int64 *v259; // rcx
  const char *v260; // rdx
  char v261; // al
  __int16 v262; // cx
  const char *v263; // rbx
  const char *v264; // rax
  __int64 *v265; // rcx
  const char *v266; // rdx
  __int64 *v267; // rcx
  const char *v268; // rdx
  const char *v269; // rbx
  const char *v270; // rax
  __int64 *v271; // rcx
  const char *v272; // rdx
  __int64 *v273; // rcx
  const char *v274; // rdx
  const char *v275; // rbx
  const char *v276; // rax
  __int64 *v277; // rcx
  const char *v278; // rdx
  __int64 *v279; // rcx
  const char *v280; // rdx
  const char *v281; // rax
  const char *v282; // rbx
  const char *v283; // rax
  __int64 *v284; // rcx
  const char *v285; // rdx
  __int64 *v286; // rcx
  const char *v287; // rdx
  const char *v288; // rax
  const char *v289; // rbx
  const char *v290; // rax
  __int64 *v291; // rcx
  const char *v292; // rdx
  __int64 *v293; // rcx
  const char *v294; // rdx
  const char *v295; // rbx
  const char *v296; // rax
  __int64 v297; // rbx
  const char *v298; // rax
  const char *v299; // rbx
  const char *v300; // rax
  char *v301; // rax
  const char *v302; // rdi
  unsigned __int64 n0x24; // rcx
  const char *v304; // rbx
  const char *v305; // rax
  const char *v306; // rbx
  const char *v307; // rax
  _BYTE *v308; // rax
  char *v309; // r15
  __int64 v310; // rcx
  __int64 v311; // rbx
  const char *v312; // rax
  const char *v313; // r14
  unsigned __int64 v314; // rdx
  _QWORD *v315; // rbx
  __int64 v316; // rcx
  unsigned __int64 v317; // r8
  __int64 v318; // rax
  char *v319; // rsi
  void **v320; // rdi
  __int64 v321; // rbx
  __int64 v322; // rax
  void **v323; // rax
  int Src_2; // ebx
  __int64 *v325; // rax
  _BYTE *v326; // rdx
  int v327; // r14d
  char *v328; // rsi
  void **v329; // rdi
  __int64 v330; // rbx
  __int64 v331; // rax
  void **v332; // rax
  int Src_1; // ebx
  const char *v334; // rdx
  __int64 *v335; // rax
  __int64 *v336; // rax
  int v337; // r8d
  float Src; // [rsp+38h] [rbp-D0h] BYREF
  unsigned int Src_4; // [rsp+3Ch] [rbp-CCh]
  double v340; // [rsp+40h] [rbp-C8h] BYREF
  double v341; // [rsp+48h] [rbp-C0h] BYREF
  _BYTE *p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source; // [rsp+50h] [rbp-B8h] BYREF
  void *v343; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v344; // [rsp+60h] [rbp-A8h] BYREF
  void *v345; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v346; // [rsp+70h] [rbp-98h] BYREF
  void *v347; // [rsp+78h] [rbp-90h] BYREF
  double v348; // [rsp+80h] [rbp-88h] BYREF
  void *v349; // [rsp+88h] [rbp-80h] BYREF
  void *v350; // [rsp+90h] [rbp-78h] BYREF
  __int64 v351; // [rsp+98h] [rbp-70h] BYREF
  void *v352; // [rsp+A0h] [rbp-68h] BYREF
  void *v353; // [rsp+A8h] [rbp-60h] BYREF
  char *v354; // [rsp+B0h] [rbp-58h] BYREF
  void *v355; // [rsp+B8h] [rbp-50h] BYREF
  const char *v356; // [rsp+C0h] [rbp-48h] BYREF
  __int16 v357[2]; // [rsp+C8h] [rbp-40h] BYREF
  char v358[4]; // [rsp+CCh] [rbp-3Ch] BYREF
  __int16 v359[2]; // [rsp+D0h] [rbp-38h] BYREF
  char v360[4]; // [rsp+D4h] [rbp-34h] BYREF
  __int16 v361[2]; // [rsp+D8h] [rbp-30h] BYREF
  char v362[4]; // [rsp+DCh] [rbp-2Ch] BYREF
  __int16 v363; // [rsp+E0h] [rbp-28h] BYREF
  double v364; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v365; // [rsp+F0h] [rbp-18h] BYREF
  void *v366; // [rsp+F8h] [rbp-10h] BYREF
  void *v367; // [rsp+100h] [rbp-8h] BYREF
  double v368; // [rsp+108h] [rbp+0h] BYREF
  __int64 v369; // [rsp+110h] [rbp+8h] BYREF
  void *v370; // [rsp+118h] [rbp+10h] BYREF
  void *v371; // [rsp+120h] [rbp+18h] BYREF
  __int64 v372; // [rsp+128h] [rbp+20h] BYREF
  __int64 v373; // [rsp+130h] [rbp+28h] BYREF
  __int64 v374; // [rsp+138h] [rbp+30h] BYREF
  __int64 v375; // [rsp+140h] [rbp+38h] BYREF
  __int64 v376; // [rsp+148h] [rbp+40h] BYREF
  __int64 v377; // [rsp+150h] [rbp+48h] BYREF
  __int64 v378; // [rsp+158h] [rbp+50h] BYREF
  __int64 v379; // [rsp+160h] [rbp+58h] BYREF
  __int64 v380; // [rsp+168h] [rbp+60h] BYREF
  __int64 v381; // [rsp+170h] [rbp+68h] BYREF
  __int64 v382; // [rsp+178h] [rbp+70h] BYREF
  __int64 v383; // [rsp+180h] [rbp+78h] BYREF
  __int64 v384; // [rsp+188h] [rbp+80h] BYREF
  __int64 v385; // [rsp+190h] [rbp+88h] BYREF
  __int64 v386; // [rsp+198h] [rbp+90h] BYREF
  __int64 v387; // [rsp+1A0h] [rbp+98h] BYREF
  __int64 v388; // [rsp+1A8h] [rbp+A0h] BYREF
  __int64 v389; // [rsp+1B0h] [rbp+A8h] BYREF
  __int64 v390; // [rsp+1B8h] [rbp+B0h] BYREF
  __int64 v391; // [rsp+1C0h] [rbp+B8h] BYREF
  __int64 v392; // [rsp+1C8h] [rbp+C0h] BYREF
  __int64 v393; // [rsp+1D0h] [rbp+C8h] BYREF
  __int64 v394; // [rsp+1D8h] [rbp+D0h] BYREF
  __int64 v395; // [rsp+1E0h] [rbp+D8h] BYREF
  __int64 v396; // [rsp+1E8h] [rbp+E0h] BYREF
  __int64 v397; // [rsp+1F0h] [rbp+E8h] BYREF
  _BYTE *v398; // [rsp+1F8h] [rbp+F0h] BYREF
  __int64 v399; // [rsp+200h] [rbp+F8h] BYREF
  __int64 v400; // [rsp+208h] [rbp+100h] BYREF
  void *v401; // [rsp+210h] [rbp+108h] BYREF
  void *v402; // [rsp+218h] [rbp+110h] BYREF
  void *v403; // [rsp+220h] [rbp+118h] BYREF
  void *v404; // [rsp+228h] [rbp+120h] BYREF
  _BYTE *v405; // [rsp+230h] [rbp+128h] BYREF
  void *v406; // [rsp+238h] [rbp+130h] BYREF
  void *v407; // [rsp+240h] [rbp+138h] BYREF
  char *v408; // [rsp+248h] [rbp+140h] BYREF
  char v409[8]; // [rsp+250h] [rbp+148h] BYREF
  _BYTE *v410; // [rsp+258h] [rbp+150h] BYREF
  __int64 *v411; // [rsp+260h] [rbp+158h]
  const char *v412; // [rsp+268h] [rbp+160h] BYREF
  _QWORD *v413; // [rsp+270h] [rbp+168h] BYREF
  char *v414; // [rsp+278h] [rbp+170h] BYREF
  const char *v415; // [rsp+280h] [rbp+178h] BYREF
  char *v416; // [rsp+288h] [rbp+180h] BYREF
  _BYTE *v417; // [rsp+290h] [rbp+188h] BYREF
  char *v418; // [rsp+298h] [rbp+190h] BYREF
  const char *v419; // [rsp+2A0h] [rbp+198h] BYREF
  char *v420; // [rsp+2A8h] [rbp+1A0h] BYREF
  const char *v421; // [rsp+2B0h] [rbp+1A8h] BYREF
  char *v422; // [rsp+2B8h] [rbp+1B0h] BYREF
  __int64 v423; // [rsp+2C0h] [rbp+1B8h] BYREF
  char *v424; // [rsp+2C8h] [rbp+1C0h] BYREF
  double v425; // [rsp+2D0h] [rbp+1C8h] BYREF
  char *v426; // [rsp+2D8h] [rbp+1D0h] BYREF
  __int64 v427; // [rsp+2E0h] [rbp+1D8h] BYREF
  unsigned __int64 v428; // [rsp+2E8h] [rbp+1E0h]
  _BYTE v429[24]; // [rsp+2F0h] [rbp+1E8h] BYREF
  void *v430; // [rsp+308h] [rbp+200h] BYREF
  __int64 v431; // [rsp+310h] [rbp+208h] BYREF
  void *v432; // [rsp+318h] [rbp+210h] BYREF
  void *v433; // [rsp+320h] [rbp+218h] BYREF
  __int64 v434; // [rsp+328h] [rbp+220h] BYREF
  void *v435; // [rsp+330h] [rbp+228h] BYREF
  void *v436; // [rsp+338h] [rbp+230h] BYREF
  void *v437; // [rsp+340h] [rbp+238h] BYREF
  void *v438; // [rsp+348h] [rbp+240h] BYREF
  void *v439; // [rsp+350h] [rbp+248h] BYREF
  unsigned __int64 v440; // [rsp+358h] [rbp+250h]
  void *v441; // [rsp+360h] [rbp+258h] BYREF
  void *v442; // [rsp+368h] [rbp+260h] BYREF
  void *v443; // [rsp+370h] [rbp+268h] BYREF
  void *v444; // [rsp+378h] [rbp+270h] BYREF
  void *v445; // [rsp+380h] [rbp+278h] BYREF
  __int64 v446; // [rsp+388h] [rbp+280h] BYREF
  void *v447; // [rsp+390h] [rbp+288h] BYREF
  __int64 v448; // [rsp+398h] [rbp+290h] BYREF
  __int64 v449; // [rsp+3A0h] [rbp+298h]
  __int64 v450; // [rsp+3A8h] [rbp+2A0h] BYREF
  __int64 v451; // [rsp+3B0h] [rbp+2A8h]
  __int64 v452; // [rsp+3B8h] [rbp+2B0h] BYREF
  __int64 v453; // [rsp+3C0h] [rbp+2B8h]
  __int64 v454; // [rsp+3C8h] [rbp+2C0h] BYREF
  __int64 v455; // [rsp+3D0h] [rbp+2C8h]
  __int64 v456[2]; // [rsp+3D8h] [rbp+2D0h] BYREF
  __int64 v457; // [rsp+3E8h] [rbp+2E0h] BYREF
  __int64 v458; // [rsp+3F8h] [rbp+2F0h] BYREF
  __int64 v459; // [rsp+408h] [rbp+300h] BYREF
  __int64 v460; // [rsp+418h] [rbp+310h] BYREF
  _OWORD v461[6]; // [rsp+428h] [rbp+320h]
  const char *v465; // [rsp+4B0h] [rbp+3A8h]

  v465 = a4;
  v9 = a7;
  v10 = a4;
  v11 = a5;
  v12 = a3;
  v13 = a6;
  v14 = a2;
  v461[1] = v7;
  v15 = a1;
  v461[0] = v8;
  while ( 2 )
  {
    LODWORD(v340) = 0;
    Src_5 = 0;
    v17 = *(int *)(v13 + 8);
    v18 = 0;
    Src_4 = 0;
    v428 = 0;
    v440 = v17;
    if ( !v17 )
      goto LABEL_28;
    do
    {
      n3 = *(_BYTE *)(*(_QWORD *)v13 + 0x28 * v18 + 0x19);
      v20 = (const char **)(*(_QWORD *)v13 + 0x28 * v18);
      v21 = *((_BYTE *)v20 + 0x1A);
      if ( n3 == 3 )
      {
        v22 = **v12;
        if ( !v21 )
        {
          if ( (*(int (**)(void))(v22 + 0x158))() > 0 )
          {
            v43 = (*(__int64 (__fastcall **)(__int64 *))(**v12 + 0x158))(*v12);
            if ( v43 > 0 )
            {
              for ( i = 0; i < v43; ++i )
              {
                (*(void (__fastcall **)(__int64 *, double *, _QWORD))(**v12 + 0x160))(*v12, &v348, (unsigned int)i);
                if ( (*(int (__fastcall **)(double))(**(_QWORD **)&v348 + 0x158LL))(COERCE_DOUBLE(*(_QWORD *)&v348)) > 0 )
                {
                  v341 = v348;
                  if ( v348 != 0.0 )
                    (*(void (__fastcall **)(double))(**(_QWORD **)&v348 + 0x20LL))(COERCE_DOUBLE(*(_QWORD *)&v348));
                  sub_1474ABF20((__int64)v15, (__int64)a7, (__int64)v20, &v341);
                  v45 = (*(__int64 (__fastcall **)(double))(**(_QWORD **)&v348 + 0x158LL))(COERCE_DOUBLE(*(_QWORD *)&v348));
                  for ( j = 0; (int)j < v45; ++j )
                  {
                    (*(void (__fastcall **)(double, double *, _QWORD))(**(_QWORD **)&v348 + 0x160LL))(
                      COERCE_DOUBLE(*(_QWORD *)&v348),
                      &v425,
                      j);
                    if ( v425 != 0.0 )
                    {
                      v341 = v425;
                      (*(void (__fastcall **)(double))(**(_QWORD **)&v425 + 0x20LL))(COERCE_DOUBLE(*(_QWORD *)&v425));
                      sub_1474ABF20((__int64)v15, (__int64)a7, (__int64)v20, &v341);
                      if ( v425 != 0.0 )
                        (*(void (__fastcall **)(double))(**(_QWORD **)&v425 + 0x28LL))(COERCE_DOUBLE(*(_QWORD *)&v425));
                    }
                  }
                  v12 = a3;
                }
                if ( v348 != 0.0 )
                  (*(void (__fastcall **)(double))(**(_QWORD **)&v348 + 0x28LL))(COERCE_DOUBLE(*(_QWORD *)&v348));
              }
              v11 = a5;
            }
          }
          v47 = &v20[1][v11];
          v48 = (char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(**a3 + 0x110))(*a3, *v20);
          v49 = v48;
          if ( v48 && *v48 )
          {
            n5 = 0;
            while ( 1 )
            {
              v51 = v49[n5++];
              if ( v51 != aNull[n5 - 1] )
                break;
              if ( n5 == 5 )
                goto LABEL_57;
            }
            v52 = sub_1402BC380(&v458, v49);
            _RDX = (_BYTE *)v15[0x36];
            *(_QWORD *)v429 = v47;
            _XMM1 = *(_OWORD *)v52;
            *(_OWORD *)&v429[8] = *(_OWORD *)v52;
            if ( _RDX == (_BYTE *)v15[0x37] )
            {
              sub_1402A7670(v15 + 0x35, _RDX, (__int64)v429);
            }
            else
            {
              *(_OWORD *)_RDX = *(_OWORD *)v429;
              __asm { vmovhpd qword ptr [rdx+10h], xmm1 }
              v15[0x36] += 0x18LL;
            }
          }
          else
          {
LABEL_57:
            *(_QWORD *)v47 = 0;
            *((_QWORD *)v47 + 1) = 0;
          }
          goto LABEL_25;
        }
        (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(v22 + 0x168))(*v12, &v365, *v20);
        *(_QWORD *)&v23 = &v20[1][v11];
        v340 = v23;
        if ( v365 )
        {
          v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v365 + 0x158LL))(v365);
          v26 = v24;
          if ( v24 > 0 )
          {
            sub_1474D24F0(*(_QWORD *)&v23, v24, v25);
            v27 = 0;
            v28 = 0;
            do
            {
              (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v365 + 0x160LL))(
                v365,
                &v364,
                (unsigned int)v27);
              if ( v364 != 0.0 )
              {
                v29 = *(_QWORD *)(*(_QWORD *)&v23 + 0x10LL);
                v341 = v364;
                v30 = (_QWORD *)(v28 + v29);
                (*(void (__fastcall **)(double))(**(_QWORD **)&v364 + 0x20LL))(COERCE_DOUBLE(*(_QWORD *)&v364));
                sub_1474ABF20((__int64)a1, (__int64)a7, (__int64)v20, &v341);
                v31 = (char *)(*(__int64 (__fastcall **)(double, int *))(**(_QWORD **)&v364 + 0x110LL))(
                                COERCE_DOUBLE(*(_QWORD *)&v364),
                                &dword_1481A2E70);
                if ( v31 && *v31 && (*v31 != 0x30 || v31[1]) )
                {
                  v32 = sub_1402BC380(&v457, v31);
                  _RDX = (_BYTE *)a1[0x36];
                  *(_QWORD *)v429 = v30;
                  _XMM1 = *(_OWORD *)v32;
                  *(_OWORD *)&v429[8] = *(_OWORD *)v32;
                  if ( _RDX == (_BYTE *)a1[0x37] )
                  {
                    sub_1402A7670(a1 + 0x35, _RDX, (__int64)v429);
                    v23 = v340;
                  }
                  else
                  {
                    v23 = v340;
                    *(_OWORD *)_RDX = *(_OWORD *)v429;
                    __asm { vmovhpd qword ptr [rdx+10h], xmm1 }
                    a1[0x36] += 0x18LL;
                  }
                }
                else
                {
                  *v30 = 0;
                  v30[1] = 0;
                }
                if ( v364 != 0.0 )
                  (*(void (__fastcall **)(double))(**(_QWORD **)&v364 + 0x28LL))(COERCE_DOUBLE(*(_QWORD *)&v364));
              }
              ++v27;
              v28 += 0x18;
            }
            while ( v27 < v26 );
            v11 = a5;
          }
          v35 = v365;
          goto LABEL_22;
        }
        goto LABEL_25;
      }
      if ( n3 == 2 )
      {
        if ( v21 )
        {
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v369, *v20);
          *(_QWORD *)&v55 = &v20[1][v11];
          v340 = v55;
          if ( v369 )
          {
            v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v369 + 0x158LL))(v369);
            v58 = v56;
            if ( v56 > 0 )
            {
              sub_1474D2580(*(_QWORD *)&v55, v56, v57);
              v59 = 0;
              v60 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v369 + 0x160LL))(
                  v369,
                  &v368,
                  (unsigned int)v59);
                if ( v368 != 0.0 )
                {
                  v341 = v368;
                  (*(void (__fastcall **)(double))(**(_QWORD **)&v368 + 0x20LL))(COERCE_DOUBLE(*(_QWORD *)&v368));
                  sub_1474ABF20((__int64)a1, (__int64)v9, (__int64)v20, &v341);
                  v61 = (_QWORD *)(v60 + *(_QWORD *)(*(_QWORD *)&v55 + 0x10LL));
                  v62 = (*(__int64 (__fastcall **)(double, int *))(**(_QWORD **)&v368 + 0x110LL))(
                          COERCE_DOUBLE(*(_QWORD *)&v368),
                          &dword_1481A2E70);
                  if ( *(_BYTE *)v62 != 0x30 || *(_BYTE *)(v62 + 1) )
                  {
                    v63 = (char **)CreateStringObjectFromString(&v439, (const char *)v62);
                    v64 = (const void **)CreateStringObjectFromString(&v442, a2);
                    sub_14035B160(&v366, v64);
                    sub_140384840(&v366, ".");
                    sub_14035B160(&v367, (const void **)&v366);
                    sub_1403847F0(&v367, v63);
                    sub_140370D10(&v366);
                    sub_140370D10(&v442);
                    sub_140370D10(&v439);
                    v413 = v61;
                    sub_14035B3E0(&v414);
                    copyStringStructure(&v414, (char **)&v367);
                    sub_1403C3960(&v414);
                    v65 = (_QWORD *)a1[0x39];
                    if ( v65 == (_QWORD *)a1[0x3A] )
                    {
                      sub_141E46F60(a1 + 0x38, v65, &v413);
                    }
                    else
                    {
                      *v65 = v413;
                      sub_14035B140(v65 + 1, (__int64 *)&v414);
                      a1[0x39] += 0x10LL;
                    }
                    sub_140370D10(&v414);
                    sub_140370D10(&v367);
                    v55 = v340;
                  }
                  else
                  {
                    *v61 = 0;
                  }
                  if ( v368 != 0.0 )
                    (*(void (__fastcall **)(double))(**(_QWORD **)&v368 + 0x28LL))(COERCE_DOUBLE(*(_QWORD *)&v368));
                  v9 = a7;
                }
                ++v59;
                v60 += 0x10;
              }
              while ( v59 < v58 );
              v11 = a5;
            }
            v35 = v369;
LABEL_22:
            if ( v35 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 0x28LL))(v35);
LABEL_24:
            v15 = a1;
          }
        }
        else
        {
          v66 = &v20[1][v11];
          v67 = (*(__int64 (__fastcall **)(__int64 *, const char *))(**a3 + 0x110))(*a3, *v20);
          if ( *(_BYTE *)v67 != 0x30 || *(_BYTE *)(v67 + 1) )
          {
            v68 = (char **)CreateStringObjectFromString(&v443, (const char *)v67);
            v69 = (const void **)CreateStringObjectFromString(&v441, v14);
            sub_14035B160(&v370, v69);
            sub_140384840(&v370, ".");
            sub_14035B160(&v371, (const void **)&v370);
            sub_1403847F0(&v371, v68);
            sub_140370D10(&v370);
            sub_140370D10(&v441);
            sub_140370D10(&v443);
            v415 = v66;
            sub_14035B3E0(&v416);
            copyStringStructure(&v416, (char **)&v371);
            sub_1403C3960(&v416);
            v70 = (const char **)v15[0x39];
            if ( v70 == (const char **)v15[0x3A] )
            {
              sub_141E46F60(v15 + 0x38, v70, &v415);
            }
            else
            {
              *v70 = v415;
              sub_14035B140(v70 + 1, (__int64 *)&v416);
              v15[0x39] += 0x10LL;
            }
            sub_140370D10(&v416);
            sub_140370D10(&v371);
          }
          else
          {
            *(_QWORD *)v66 = 0;
          }
        }
LABEL_25:
        v13 = a6;
        goto LABEL_26;
      }
      if ( !v21 )
      {
        switch ( *((_BYTE *)v20 + 0x18) )
        {
          case 1:
            if ( v20[2] != (const char *)1 )
            {
              v289 = *v20;
              v290 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v290,
                v289);
            }
            v291 = *v12;
            v292 = *v20;
            LOBYTE(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v291 + 0x118))(v291, v292) )
              goto LABEL_349;
            v293 = *v12;
            v294 = *v20;
            LOBYTE(Src) = 0;
            (*(void (__fastcall **)(__int64 *, const char *, float *))(*v293 + 0x90))(v293, v294, &Src);
            goto LABEL_350;
          case 2:
            if ( v20[2] != (const char *)1 )
            {
              v226 = *v20;
              v227 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v227,
                v226);
            }
            v228 = *v12;
            v229 = *v20;
            LOBYTE(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v228 + 0x118))(v228, v229) )
              goto LABEL_349;
            v230 = (*(__int64 (__fastcall **)(__int64 *, const char *, char *))(**v12 + 0x100))(*v12, *v20, v360);
            v231 = 0;
            if ( v230 )
              v231 = v360[0];
            LOBYTE(Src) = v231;
            goto LABEL_350;
          case 3:
            if ( v20[2] != (const char *)2 )
            {
              v232 = *v20;
              v233 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v233,
                v232);
            }
            v234 = *v12;
            v235 = *v20;
            LOWORD(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v234 + 0x118))(v234, v235) )
              goto LABEL_349;
            v236 = (*(__int64 (__fastcall **)(__int64 *, const char *, __int16 *))(**v12 + 0x100))(*v12, *v20, v361);
            v237 = 0;
            if ( v236 )
              v237 = v361[0];
            LOWORD(Src) = v237;
            goto LABEL_350;
          case 4:
            if ( v20[2] != (const char *)4 )
            {
              v239 = *v20;
              v240 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v240,
                v239);
            }
            v241 = *v12;
            v242 = *v20;
            LODWORD(v340) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v241 + 0x118))(v241, v242) )
              goto LABEL_383;
            v243 = *v12;
            v244 = *v20;
            LODWORD(v340) = 0;
            (*(void (__fastcall **)(__int64 *, const char *, double *))(*v243 + 0x100))(v243, v244, &v340);
            goto LABEL_384;
          case 5:
            if ( v20[2] != (const char *)8 )
            {
              v245 = *v20;
              v246 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v246,
                v245);
            }
            v247 = *v12;
            v248 = *v20;
            v341 = 0.0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v247 + 0x118))(v247, v248) )
              goto LABEL_389;
            v249 = *v12;
            v250 = *v20;
            v341 = 0.0;
            (*(void (__fastcall **)(__int64 *, const char *, double *))(*v249 + 0xF0))(v249, v250, &v341);
            goto LABEL_390;
          case 6:
            if ( v20[2] != (const char *)1 )
            {
              v251 = *v20;
              v252 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v252,
                v251);
            }
            v253 = *v12;
            v254 = *v20;
            LOBYTE(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v253 + 0x118))(v253, v254) )
              goto LABEL_349;
            v255 = (*(__int64 (__fastcall **)(__int64 *, const char *, char *))(**v12 + 0xF8))(*v12, *v20, v362);
            v256 = 0;
            if ( v255 )
              v256 = v362[0];
            LOBYTE(Src) = v256;
            goto LABEL_350;
          case 7:
            if ( v20[2] != (const char *)2 )
            {
              v257 = *v20;
              v258 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v258,
                v257);
            }
            v259 = *v12;
            v260 = *v20;
            LOWORD(Src) = 0;
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v259 + 0x118))(v259, v260) )
            {
              v261 = (*(__int64 (__fastcall **)(__int64 *, const char *, __int16 *))(**v12 + 0xF8))(*v12, *v20, &v363);
              v262 = 0;
              if ( v261 )
                v262 = v363;
              LOWORD(Src) = v262;
            }
            else
            {
LABEL_349:
              v238 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Cannot locate default atomic value for field '%s' in record '%s'. Please provide default valu"
                "e within the schema. Value will be UNINITIALIZED!",
                *v20,
                v238);
            }
LABEL_350:
            memcpy((void *)&v20[1][v11], &Src, (size_t)v20[2]);
            goto LABEL_25;
          case 8:
            if ( v20[2] != (const char *)4 )
            {
              v263 = *v20;
              v264 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v264,
                v263);
            }
            v265 = *v12;
            v266 = *v20;
            LODWORD(v340) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v265 + 0x118))(v265, v266) )
              goto LABEL_383;
            v267 = *v12;
            v268 = *v20;
            LODWORD(v340) = 0;
            (*(void (__fastcall **)(__int64 *, const char *, double *))(*v267 + 0xF8))(v267, v268, &v340);
            goto LABEL_384;
          case 9:
            if ( v20[2] != (const char *)8 )
            {
              v269 = *v20;
              v270 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v270,
                v269);
            }
            v271 = *v12;
            v272 = *v20;
            v341 = 0.0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v271 + 0x118))(v271, v272) )
              goto LABEL_389;
            v273 = *v12;
            v274 = *v20;
            v341 = 0.0;
            (*(void (__fastcall **)(__int64 *, const char *, double *, _QWORD))(*v273 + 0xE8))(v273, v274, &v341, 0);
            goto LABEL_390;
          case 0xA:
            if ( v20[2] != (const char *)0x10 )
            {
              v295 = *v20;
              v296 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Strings must be const char*",
                v296,
                v295);
            }
            v297 = (__int64)&v20[1][v11];
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(**v12 + 0x118))(*v12, *v20) )
            {
              v298 = (const char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(**v12 + 0x110))(*v12, *v20);
              if ( v298 )
              {
                if ( *v298 )
                {
                  CreateStringObjectFromString((void **)&p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source, v298);
                  sub_1403E8AB0(&p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source, (const char *)&SubStr__0, "&");
                  sub_1403E8AB0(&p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source, "&quot;", "\"");
                  sub_1403E8AB0(&p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source, "&apos;", "'");
                  sub_1403E8AB0(&p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source, (const char *)&SubStr__1, "<");
                  sub_1403E8AB0(&p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source, (const char *)&SubStr__2, ">");
                  sub_140379DF0(v297, p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
                  sub_140370D10(&p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
                }
              }
            }
            goto LABEL_25;
          case 0xB:
            if ( v20[2] != (const char *)4 )
            {
              v275 = *v20;
              v276 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v276,
                v275);
            }
            v277 = *v12;
            v278 = *v20;
            *(float *)&v340 = 0.0;
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v277 + 0x118))(v277, v278) )
            {
              v279 = *v12;
              v280 = *v20;
              *(float *)&v340 = 0.0;
              (*(void (__fastcall **)(__int64 *, const char *, double *))(*v279 + 0xE0))(v279, v280, &v340);
            }
            else
            {
LABEL_383:
              v281 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Cannot locate default atomic value for field '%s' in record '%s'. Please provide default valu"
                "e within the schema. Value will be UNINITIALIZED!",
                *v20,
                v281);
            }
LABEL_384:
            memcpy((void *)&v20[1][v11], &v340, (size_t)v20[2]);
            goto LABEL_25;
          case 0xC:
            if ( v20[2] != (const char *)8 )
            {
              v282 = *v20;
              v283 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v283,
                v282);
            }
            v284 = *v12;
            v285 = *v20;
            v341 = 0.0;
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v284 + 0x118))(v284, v285) )
            {
              v286 = *v12;
              v287 = *v20;
              v341 = 0.0;
              (*(void (__fastcall **)(__int64 *, const char *, double *))(*v286 + 0xD8))(v286, v287, &v341);
            }
            else
            {
LABEL_389:
              v288 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Cannot locate default atomic value for field '%s' in record '%s'. Please provide default valu"
                "e within the schema. Value will be UNINITIALIZED!",
                *v20,
                v288);
            }
LABEL_390:
            memcpy((void *)&v20[1][v11], &v341, (size_t)v20[2]);
            goto LABEL_25;
          case 0xD:
            if ( v20[2] != (const char *)8 )
            {
              v306 = *v20;
              v307 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Localisation field"
                "s must be type CLocIdentifier",
                v307,
                v306);
            }
            v308 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, const char *))(**v12 + 0x110))(*v12, *v20);
            if ( v308 && *v308 == 0x40 )
              assignCStringToStringStructure((void **)&v20[1][v11], v308);
            goto LABEL_25;
          case 0xE:
            if ( v20[2] != (const char *)0x10 )
            {
              v299 = *v20;
              v300 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore structure '%s' field '%s'. GUIDs must be CryGUID",
                v300,
                v299);
            }
            v301 = (char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(**v12 + 0x110))(*v12, *v20);
            v302 = v301;
            n0x24 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++n0x24;
            while ( v301[n0x24] );
            if ( n0x24 == 0x24 )
            {
              *(_OWORD *)&v20[1][v11] = *(_OWORD *)sub_1402BC380(&v460, v301);
            }
            else
            {
              v304 = *v20;
              v305 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] DataCore structure '%s' field '%s': Incoming field GUID '%s' is invalid (size is wrong).",
                v305,
                v304,
                v302);
            }
            goto LABEL_25;
          case 0xF:
            sub_1474AC380((__int64)v15, v11, v20, v12);
            goto LABEL_25;
          case 0x10:
            v309 = (char *)&v20[1][v11];
            if ( n3 != 1 )
            {
              (*(void (__fastcall **)(__int64 *, const char **, const char *))(**v12 + 0x168))(*v12, &v356, *v20);
              if ( v356 )
              {
                v327 = (*(__int64 (__fastcall **)(const char *, const char *))(*(_QWORD *)v356 + 0x110LL))(
                         v356,
                         "__type");
                if ( v9 )
                {
                  v328 = (char *)*v20;
                  Src_4 = Src_5 | 0x10;
                  v329 = CreateStringObjectFromString(&v447, ".");
                  sub_14035B3E0(&v347);
                  v330 = sub_1403E20D0((__int64)a7);
                  v331 = sub_1403E7A60(v329);
                  sub_1403E90A0(&v347, v331 + v330);
                  sub_140384840(&v347, a7);
                  sub_1403847F0(&v347, (char **)v329);
                  sub_14035B160(&v407, (const void **)&v347);
                  sub_140384840(&v407, v328);
                  v332 = &v407;
                  Src_1 = Src_4 | 0x60;
                  Src_4 |= 0x60u;
                }
                else
                {
                  v334 = *v20;
                  Src_1 = Src_5 | 0x80;
                  Src_4 = Src_1;
                  v332 = CreateStringObjectFromString(&v438, v334);
                }
                sub_14035B140(&v408, (__int64 *)v332);
                if ( (Src_1 & 0x80u) != 0 )
                {
                  Src_1 &= ~0x80u;
                  Src_4 = Src_1;
                  sub_140370D10(&v438);
                }
                if ( (Src_1 & 0x40) != 0 )
                {
                  Src_1 &= ~0x40u;
                  Src_4 = Src_1;
                  sub_140370D10(&v407);
                }
                if ( (Src_1 & 0x20) != 0 )
                {
                  Src_1 &= ~0x20u;
                  Src_4 = Src_1;
                  sub_140370D10(&v347);
                }
                if ( (Src_1 & 0x10) != 0 )
                {
                  Src_4 = Src_1 & 0xFFFFFFEF;
                  sub_140370D10(&v447);
                }
                v412 = v356;
                if ( v356 )
                  (*(void (__fastcall **)(const char *))(*(_QWORD *)v356 + 0x20LL))(v356);
                v335 = (__int64 *)sub_1403C3960(&v408);
                sub_1474ABF20((__int64)a1, *v335, (__int64)v20, &v412);
                v336 = (__int64 *)sub_1403C3960(&v408);
                v337 = (int)v309;
                v15 = a1;
                sub_1474B4EB0((_DWORD)a1, (_DWORD)a2, v337, v327, *v336, (__int64)&v356);
                sub_140370D10(&v408);
              }
              else
              {
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Non optional field \"%s\" doesn't exist in the source record \"%s\". Please add this field "
                  "to the schema and re-export the source record.",
                  *v20,
                  v14);
                v15 = a1;
              }
              if ( v356 )
                (*(void (__fastcall **)(const char *))(*(_QWORD *)v356 + 0x28LL))(v356);
              goto LABEL_25;
            }
            *(_QWORD *)v309 = 0;
            (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v346, *v20);
            if ( !v346 )
              goto LABEL_24;
            (*(void (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)v346 + 0x168LL))(v346, &v427, "null");
            v310 = v427;
            if ( v427 )
              goto LABEL_443;
            v311 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v346 + 0x110LL))(v346, "__type");
            v312 = (const char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v346 + 0x110LL))(
                                   v346,
                                   "__polymorphicType");
            v313 = v312;
            if ( !v312 || !*v312 )
              v313 = (const char *)v311;
            v421 = v313;
            sub_14035B120(&v422, &v421);
            v314 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++v314;
            while ( v422[v314] );
            v315 = a1 + 0x26;
            v316 = 0xCBF29CE484222325uLL;
            v317 = 0;
            if ( v314 )
            {
              do
              {
                v318 = (unsigned __int8)v422[v317++];
                v316 = 0x100000001B3LL * (v318 ^ v316);
              }
              while ( v317 < v314 );
              v11 = a5;
              v315 = a1 + 0x26;
            }
            sub_14747F260(
              a1 + 0x26,
              &v452,
              &v422,
              0xDE5FB9D2630458E9uLL * v316
            + (((unsigned __int64)v316 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
            v422 = (char *)&qword_149B3B33C + 4;
            sub_140370D10(&v422);
            if ( v452 == *v315 + v315[3] )
            {
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Structure of type \"%s\" is not a game-registered structure. Is this defined in DataCorePreIn"
                "it.cpp or DataCoreGame.cpp?",
                v313);
            }
            else
            {
              v319 = (char *)*v20;
              if ( a7 )
              {
                Src_4 |= 1u;
                v320 = CreateStringObjectFromString(&v437, ".");
                sub_14035B3E0(&v345);
                v321 = sub_1403E20D0((__int64)a7);
                v322 = sub_1403E7A60(v320);
                sub_1403E90A0(&v345, v322 + v321);
                sub_140384840(&v345, a7);
                sub_1403847F0(&v345, (char **)v320);
                sub_14035B160(&v406, (const void **)&v345);
                sub_140384840(&v406, v319);
                v323 = &v406;
                Src_2 = Src_4 | 6;
                Src_4 |= 6u;
              }
              else
              {
                Src_2 = Src_4 | 8;
                Src_4 |= 8u;
                v323 = CreateStringObjectFromString(&v436, v319);
              }
              sub_14035B140(&v426, (__int64 *)v323);
              if ( (Src_2 & 8) != 0 )
              {
                Src_2 &= ~8u;
                Src_4 = Src_2;
                sub_140370D10(&v436);
              }
              if ( (Src_2 & 4) != 0 )
              {
                Src_2 &= ~4u;
                Src_4 = Src_2;
                sub_140370D10(&v406);
              }
              if ( (Src_2 & 2) != 0 )
              {
                Src_2 &= ~2u;
                Src_4 = Src_2;
                sub_140370D10(&v345);
              }
              if ( (Src_2 & 1) != 0 )
              {
                Src_4 = Src_2 & 0xFFFFFFFE;
                sub_140370D10(&v437);
              }
              *(_QWORD *)v309 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v453 + 0x18))(
                                  *(_QWORD *)(v453 + 0x18),
                                  0);
              v325 = (__int64 *)sub_1403C3960(&v426);
              sub_1474B4EB0((_DWORD)a1, (_DWORD)a2, *(_QWORD *)v309, (_DWORD)v313, *v325, (__int64)&v346);
              v326 = (_BYTE *)a1[0x30];
              if ( v326 == (_BYTE *)a1[0x31] )
              {
                sub_1402A6B30((__int64)(a1 + 0x2F), v326, v309);
              }
              else
              {
                *(_QWORD *)v326 = *(_QWORD *)v309;
                a1[0x30] += 8LL;
              }
              sub_140370D10(&v426);
            }
            v310 = v427;
            if ( v427 )
LABEL_443:
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v310 + 0x28LL))(v310);
            v35 = v346;
            break;
          default:
            goto LABEL_26;
        }
        goto LABEL_22;
      }
      switch ( *((_BYTE *)v20 + 0x18) )
      {
        case 1:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v393, *v20);
          v147 = v20[1];
          if ( v393 )
          {
            allocSize = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v393 + 0x158LL))(v393);
            allocSize_12 = allocSize;
            if ( allocSize > 0 )
            {
              *(_QWORD *)&v147[v11 + 0x18] = allocSize;
              *(_QWORD *)&v147[v11 + 0x20] = allocSize;
              *(_QWORD *)&v147[v11 + 0x10] = allocWithProfilerInfo_w(allocSize);
              allocSize_13 = 0;
              v147[v11 + 8] = 1;
              v151 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v393 + 0x160LL))(
                  v393,
                  &v392,
                  (unsigned int)allocSize_13);
                if ( v392
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v392 + 0x118LL))(
                       v392,
                       &dword_1481A2E70) )
                {
                  LOBYTE(Src) = 0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v392 + 0x90LL))(
                    v392,
                    &dword_1481A2E70,
                    &Src);
                  *(_BYTE *)(v151 + *(_QWORD *)&v147[v11 + 0x10]) = LOBYTE(Src);
                }
                else
                {
                  v152 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v152);
                }
                if ( v392 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v392 + 0x28LL))(v392);
                ++allocSize_13;
                ++v151;
              }
              while ( allocSize_13 < allocSize_12 );
            }
            if ( v393 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v393 + 0x28LL))(v393);
          }
          goto LABEL_25;
        case 2:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v373, *v20);
          v71 = v20[1];
          if ( v373 )
          {
            allocSize_1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v373 + 0x158LL))(v373);
            allocSize_14 = allocSize_1;
            if ( allocSize_1 > 0 )
            {
              *(_QWORD *)&v71[v11 + 0x18] = allocSize_1;
              *(_QWORD *)&v71[v11 + 0x20] = allocSize_1;
              *(_QWORD *)&v71[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_1);
              allocSize_15 = 0;
              v71[v11 + 8] = 1;
              v75 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v373 + 0x160LL))(
                  v373,
                  &v372,
                  (unsigned int)allocSize_15);
                if ( v372
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v372 + 0x118LL))(
                       v372,
                       &dword_1481A2E70) )
                {
                  v76 = (*(__int64 (__fastcall **)(__int64, int *, char *))(*(_QWORD *)v372 + 0x100LL))(
                          v372,
                          &dword_1481A2E70,
                          v409);
                  v77 = 0;
                  if ( v76 )
                    v77 = v409[0];
                  *(_BYTE *)(v75 + *(_QWORD *)&v71[v11 + 0x10]) = v77;
                }
                else
                {
                  v78 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v78);
                }
                if ( v372 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v372 + 0x28LL))(v372);
                ++allocSize_15;
                ++v75;
              }
              while ( allocSize_15 < allocSize_14 );
            }
            if ( v373 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v373 + 0x28LL))(v373);
          }
          goto LABEL_25;
        case 3:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v375, *v20);
          v79 = v20[1];
          if ( v375 )
          {
            v80 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v375 + 0x158LL))(v375);
            v81 = v80;
            if ( v80 > 0 )
            {
              *(_QWORD *)&v79[v11 + 0x18] = v80;
              *(_QWORD *)&v79[v11 + 0x20] = v80;
              allocSize_2 = 2LL * v80;
              if ( !is_mul_ok(v81, 2u) )
                allocSize_2 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v79[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_2);
              v83 = 0;
              v79[v11 + 8] = 1;
              v84 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v375 + 0x160LL))(
                  v375,
                  &v374,
                  (unsigned int)v83);
                if ( v374
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v374 + 0x118LL))(
                       v374,
                       &dword_1481A2E70) )
                {
                  v85 = (*(__int64 (__fastcall **)(__int64, int *, __int16 *))(*(_QWORD *)v374 + 0x100LL))(
                          v374,
                          &dword_1481A2E70,
                          v357);
                  v86 = 0;
                  if ( v85 )
                    v86 = v357[0];
                  *(_WORD *)(v84 + *(_QWORD *)&v79[v11 + 0x10]) = v86;
                }
                else
                {
                  v87 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v87);
                }
                if ( v374 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v374 + 0x28LL))(v374);
                ++v83;
                v84 += 2;
              }
              while ( v83 < (int)v81 );
              v15 = a1;
            }
            if ( v375 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v375 + 0x28LL))(v375);
          }
          goto LABEL_25;
        case 4:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v377, *v20);
          v88 = v20[1];
          if ( v377 )
          {
            v89 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v377 + 0x158LL))(v377);
            v90 = v89;
            if ( v89 > 0 )
            {
              *(_QWORD *)&v88[v11 + 0x18] = v89;
              *(_QWORD *)&v88[v11 + 0x20] = v89;
              allocSize_3 = 4LL * v89;
              if ( !is_mul_ok(v90, 4u) )
                allocSize_3 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v88[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_3);
              v92 = 0;
              v88[v11 + 8] = 1;
              v93 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v377 + 0x160LL))(
                  v377,
                  &v376,
                  (unsigned int)v92);
                if ( v376
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v376 + 0x118LL))(
                       v376,
                       &dword_1481A2E70) )
                {
                  Src = 0.0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v376 + 0x100LL))(
                    v376,
                    &dword_1481A2E70,
                    &Src);
                  *(float *)(v93 + *(_QWORD *)&v88[v11 + 0x10]) = Src;
                }
                else
                {
                  v94 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v94);
                }
                if ( v376 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v376 + 0x28LL))(v376);
                ++v92;
                v93 += 4;
              }
              while ( v92 < (int)v90 );
              v15 = a1;
            }
            if ( v377 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v377 + 0x28LL))(v377);
          }
          goto LABEL_25;
        case 5:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v379, *v20);
          v95 = v20[1];
          if ( v379 )
          {
            v96 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v379 + 0x158LL))(v379);
            v97 = v96;
            if ( v96 > 0 )
            {
              *(_QWORD *)&v95[v11 + 0x18] = v96;
              *(_QWORD *)&v95[v11 + 0x20] = v96;
              allocSize_4 = 8LL * v96;
              if ( !is_mul_ok(v97, 8u) )
                allocSize_4 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v95[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_4);
              v99 = 0;
              v95[v11 + 8] = 1;
              v100 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v379 + 0x160LL))(
                  v379,
                  &v378,
                  (unsigned int)v99);
                if ( v378
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v378 + 0x118LL))(
                       v378,
                       &dword_1481A2E70) )
                {
                  v340 = 0.0;
                  (*(void (__fastcall **)(__int64, int *, double *))(*(_QWORD *)v378 + 0xF0LL))(
                    v378,
                    &dword_1481A2E70,
                    &v340);
                  *(double *)(v100 + *(_QWORD *)&v95[v11 + 0x10]) = v340;
                }
                else
                {
                  v101 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v101);
                }
                if ( v378 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v378 + 0x28LL))(v378);
                ++v99;
                v100 += 8;
              }
              while ( v99 < (int)v97 );
              v15 = a1;
            }
            if ( v379 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v379 + 0x28LL))(v379);
          }
          goto LABEL_25;
        case 6:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v381, *v20);
          v102 = v20[1];
          if ( v381 )
          {
            allocSize_5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v381 + 0x158LL))(v381);
            allocSize_16 = allocSize_5;
            if ( allocSize_5 > 0 )
            {
              *(_QWORD *)&v102[v11 + 0x18] = allocSize_5;
              *(_QWORD *)&v102[v11 + 0x20] = allocSize_5;
              *(_QWORD *)&v102[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_5);
              allocSize_17 = 0;
              v102[v11 + 8] = 1;
              v106 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 0x160LL))(
                  v381,
                  &v380,
                  (unsigned int)allocSize_17);
                if ( v380
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v380 + 0x118LL))(
                       v380,
                       &dword_1481A2E70) )
                {
                  v107 = (*(__int64 (__fastcall **)(__int64, int *, char *))(*(_QWORD *)v380 + 0xF8LL))(
                           v380,
                           &dword_1481A2E70,
                           v358);
                  v108 = 0;
                  if ( v107 )
                    v108 = v358[0];
                  *(_BYTE *)(v106 + *(_QWORD *)&v102[v11 + 0x10]) = v108;
                }
                else
                {
                  v109 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v109);
                }
                if ( v380 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v380 + 0x28LL))(v380);
                ++allocSize_17;
                ++v106;
              }
              while ( allocSize_17 < allocSize_16 );
            }
            if ( v381 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v381 + 0x28LL))(v381);
          }
          goto LABEL_25;
        case 7:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v383, *v20);
          v110 = v20[1];
          if ( v383 )
          {
            v111 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v383 + 0x158LL))(v383);
            v112 = v111;
            if ( v111 > 0 )
            {
              *(_QWORD *)&v110[v11 + 0x18] = v111;
              *(_QWORD *)&v110[v11 + 0x20] = v111;
              allocSize_6 = 2LL * v111;
              if ( !is_mul_ok(v112, 2u) )
                allocSize_6 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v110[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_6);
              v114 = 0;
              v110[v11 + 8] = 1;
              v115 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                  v383,
                  &v382,
                  (unsigned int)v114);
                if ( v382
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v382 + 0x118LL))(
                       v382,
                       &dword_1481A2E70) )
                {
                  v116 = (*(__int64 (__fastcall **)(__int64, int *, __int16 *))(*(_QWORD *)v382 + 0xF8LL))(
                           v382,
                           &dword_1481A2E70,
                           v359);
                  v117 = 0;
                  if ( v116 )
                    v117 = v359[0];
                  *(_WORD *)(v115 + *(_QWORD *)&v110[v11 + 0x10]) = v117;
                }
                else
                {
                  v118 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v118);
                }
                if ( v382 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v382 + 0x28LL))(v382);
                ++v114;
                v115 += 2;
              }
              while ( v114 < (int)v112 );
              v15 = a1;
            }
            if ( v383 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v383 + 0x28LL))(v383);
          }
          goto LABEL_25;
        case 8:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v385, *v20);
          v119 = v20[1];
          if ( v385 )
          {
            v120 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v385 + 0x158LL))(v385);
            v121 = v120;
            if ( v120 > 0 )
            {
              *(_QWORD *)&v119[v11 + 0x18] = v120;
              *(_QWORD *)&v119[v11 + 0x20] = v120;
              allocSize_7 = 4LL * v120;
              if ( !is_mul_ok(v121, 4u) )
                allocSize_7 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v119[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_7);
              v123 = 0;
              v119[v11 + 8] = 1;
              v124 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v385 + 0x160LL))(
                  v385,
                  &v384,
                  (unsigned int)v123);
                if ( v384
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v384 + 0x118LL))(
                       v384,
                       &dword_1481A2E70) )
                {
                  Src = 0.0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v384 + 0xF8LL))(
                    v384,
                    &dword_1481A2E70,
                    &Src);
                  *(float *)(v124 + *(_QWORD *)&v119[v11 + 0x10]) = Src;
                }
                else
                {
                  v125 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v125);
                }
                if ( v384 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v384 + 0x28LL))(v384);
                ++v123;
                v124 += 4;
              }
              while ( v123 < (int)v121 );
              v15 = a1;
            }
            if ( v385 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v385 + 0x28LL))(v385);
          }
          goto LABEL_25;
        case 9:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v387, *v20);
          v126 = v20[1];
          if ( v387 )
          {
            v127 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v387 + 0x158LL))(v387);
            v128 = v127;
            if ( v127 > 0 )
            {
              *(_QWORD *)&v126[v11 + 0x18] = v127;
              *(_QWORD *)&v126[v11 + 0x20] = v127;
              allocSize_8 = 8LL * v127;
              if ( !is_mul_ok(v128, 8u) )
                allocSize_8 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v126[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_8);
              v130 = 0;
              v126[v11 + 8] = 1;
              v131 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v387 + 0x160LL))(
                  v387,
                  &v386,
                  (unsigned int)v130);
                if ( v386
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v386 + 0x118LL))(
                       v386,
                       &dword_1481A2E70) )
                {
                  v340 = 0.0;
                  (*(void (__fastcall **)(__int64, int *, double *, _QWORD))(*(_QWORD *)v386 + 0xE8LL))(
                    v386,
                    &dword_1481A2E70,
                    &v340,
                    0);
                  *(double *)(v131 + *(_QWORD *)&v126[v11 + 0x10]) = v340;
                }
                else
                {
                  v132 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v132);
                }
                if ( v386 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v386 + 0x28LL))(v386);
                ++v130;
                v131 += 8;
              }
              while ( v130 < (int)v128 );
              v15 = a1;
            }
            if ( v387 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v387 + 0x28LL))(v387);
          }
          goto LABEL_25;
        case 0xA:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v395, *v20);
          v153 = &v20[1][v11];
          if ( v395 )
          {
            v154 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v395 + 0x158LL))(v395);
            v156 = v154;
            if ( v154 > 0 )
            {
              sub_1474D2450(v153, v154, v155);
              v157 = 0;
              v158 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v395 + 0x160LL))(
                  v395,
                  &v394,
                  (unsigned int)v157);
                if ( v394
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v394 + 0x118LL))(
                       v394,
                       &dword_1481A2E70) )
                {
                  v159 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v394 + 0x110LL))(
                                    v394,
                                    &dword_1481A2E70);
                  sub_140361D60((__int64)v456, v159);
                  sub_140379DA0((__int64 *)(v158 + *((_QWORD *)v153 + 2)), v456);
                  sub_140372C00((__int64)v456);
                }
                else
                {
                  v160 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v160);
                }
                if ( v394 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v394 + 0x28LL))(v394);
                ++v157;
                v158 += 0x10;
              }
              while ( v157 < v156 );
            }
            if ( v395 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v395 + 0x28LL))(v395);
          }
          goto LABEL_25;
        case 0xB:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v389, *v20);
          v133 = v20[1];
          if ( v389 )
          {
            v134 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v389 + 0x158LL))(v389);
            v135 = v134;
            if ( v134 > 0 )
            {
              *(_QWORD *)&v133[v11 + 0x18] = v134;
              *(_QWORD *)&v133[v11 + 0x20] = v134;
              allocSize_9 = 4LL * v134;
              if ( !is_mul_ok(v135, 4u) )
                allocSize_9 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v133[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_9);
              v137 = 0;
              v133[v11 + 8] = 1;
              v138 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v389 + 0x160LL))(
                  v389,
                  &v388,
                  (unsigned int)v137);
                if ( v388
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v388 + 0x118LL))(
                       v388,
                       &dword_1481A2E70) )
                {
                  Src = 0.0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v388 + 0xE0LL))(
                    v388,
                    &dword_1481A2E70,
                    &Src);
                  *(float *)(v138 + *(_QWORD *)&v133[v11 + 0x10]) = Src;
                }
                else
                {
                  v139 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v139);
                }
                if ( v388 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v388 + 0x28LL))(v388);
                ++v137;
                v138 += 4;
              }
              while ( v137 < (int)v135 );
            }
            if ( v389 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v389 + 0x28LL))(v389);
          }
          goto LABEL_25;
        case 0xC:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v391, *v20);
          v140 = v20[1];
          if ( v391 )
          {
            v141 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v391 + 0x158LL))(v391);
            v142 = v141;
            if ( v141 > 0 )
            {
              *(_QWORD *)&v140[v11 + 0x18] = v141;
              *(_QWORD *)&v140[v11 + 0x20] = v141;
              allocSize_10 = 8LL * v141;
              if ( !is_mul_ok(v142, 8u) )
                allocSize_10 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v140[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_10);
              v144 = 0;
              v140[v11 + 8] = 1;
              v145 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v391 + 0x160LL))(
                  v391,
                  &v390,
                  (unsigned int)v144);
                if ( v390
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v390 + 0x118LL))(
                       v390,
                       &dword_1481A2E70) )
                {
                  v340 = 0.0;
                  (*(void (__fastcall **)(__int64, int *, double *))(*(_QWORD *)v390 + 0xD8LL))(
                    v390,
                    &dword_1481A2E70,
                    &v340);
                  *(double *)(v145 + *(_QWORD *)&v140[v11 + 0x10]) = v340;
                }
                else
                {
                  v146 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405C0E00(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v146);
                }
                if ( v390 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v390 + 0x28LL))(v390);
                ++v144;
                v145 += 8;
              }
              while ( v144 < (int)v142 );
            }
            if ( v391 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v391 + 0x28LL))(v391);
          }
          goto LABEL_25;
        case 0xD:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v400, *v20);
          if ( v400 )
          {
            v167 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v400 + 0x158LL))(v400);
            v169 = v167;
            if ( v167 > 0 )
            {
              v170 = &v20[1][v11];
              sub_1474D2620(v170, v167, v168);
              v171 = 0;
              v172 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v400 + 0x160LL))(
                  v400,
                  &v399,
                  (unsigned int)v171);
                if ( v399 )
                {
                  CreateStringObjectFromString((void **)&v398, 0);
                  (*(void (__fastcall **)(__int64, int *, _BYTE **))(*(_QWORD *)v399 + 0x80LL))(
                    v399,
                    &dword_1481A2E70,
                    &v398);
                  if ( v398 && *v398 == 0x40 )
                    assignCStringToStringStructure((void **)(v172 + *((_QWORD *)v170 + 2)), v398);
                  sub_140370D10(&v398);
                  if ( v399 )
                    (*(void (__fastcall **)(__int64))(*(_QWORD *)v399 + 0x28LL))(v399);
                }
                ++v171;
                v172 += 8;
              }
              while ( v171 < v169 );
            }
            if ( v400 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v400 + 0x28LL))(v400);
          }
          goto LABEL_25;
        case 0xE:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v397, *v20);
          if ( v397 )
          {
            v161 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v397 + 0x158LL))(v397);
            v162 = v161;
            if ( v161 > 0 )
            {
              v163 = v20[1];
              allocSize_11 = 0x10LL * v161;
              *(_QWORD *)&v163[v11 + 0x18] = v162;
              *(_QWORD *)&v163[v11 + 0x20] = v162;
              if ( !is_mul_ok(v162, 0x10u) )
                allocSize_11 = 0xFFFFFFFFFFFFFFFFuLL;
              *(_QWORD *)&v163[v11 + 0x10] = allocWithProfilerInfo_w(allocSize_11);
              v165 = 0;
              v163[v11 + 8] = 1;
              v166 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v397 + 0x160LL))(
                  v397,
                  &v396,
                  (unsigned int)v165);
                if ( v396 )
                {
                  CreateStringObjectFromString((void **)&v354, 0);
                  (*(void (__fastcall **)(__int64, int *, char **))(*(_QWORD *)v396 + 0x80LL))(
                    v396,
                    &dword_1481A2E70,
                    &v354);
                  if ( sub_1403E7A60(&v354) == 0x24 )
                    *(_OWORD *)(*(_QWORD *)&v163[v11 + 0x10] + v166) = *(_OWORD *)sub_1402BC380(&v459, v354);
                  sub_140370D10(&v354);
                  if ( v396 )
                    (*(void (__fastcall **)(__int64))(*(_QWORD *)v396 + 0x28LL))(v396);
                }
                ++v165;
                v166 += 0x10;
              }
              while ( v165 < (int)v162 );
            }
            if ( v397 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v397 + 0x28LL))(v397);
          }
          goto LABEL_25;
        case 0xF:
          sub_1474AC650((__int64)v15, v11, v20, v12);
          goto LABEL_25;
        case 0x10:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 0x168))(*v12, &v344, *v20);
          if ( v344 )
          {
            LODWORD(Src_3) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v344 + 0x158LL))(v344);
            Src = Src_3;
            if ( SLODWORD(Src_3) > 0 )
            {
              if ( *((_BYTE *)v20 + 0x19) == 1 )
              {
                *(_QWORD *)&v341 = &v20[1][v11];
                v175 = v341;
                sub_1474D2580(*(_QWORD *)&v341, SLODWORD(Src_3), v174);
                v176 = 0;
                v340 = 0.0;
                v177 = 0.0;
                do
                {
                  (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v344 + 0x160LL))(
                    v344,
                    &v351,
                    (unsigned int)v176);
                  v178 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v351 + 0x110LL))(
                                    v351,
                                    "__type");
                  v410 = v178;
                  if ( v178 && *v178 )
                  {
                    v411 = (__int64 *)(*(_QWORD *)&v177 + *(_QWORD *)(*(_QWORD *)&v175 + 0x10LL));
                    sub_14035B3E0(&v355);
                    if ( v9 )
                    {
                      v179 = CreateStringObjectFromString(&v444, ".");
                      sub_14035B3E0(&v349);
                      v180 = sub_1403E7A60(v179);
                      v181 = sub_1403E20D0((__int64)v9);
                      sub_1403E90A0(&v349, v181 + v180);
                      sub_140384840(&v349, v9);
                      sub_1403847F0(&v349, (char **)v179);
                      sub_1403847F0(&v355, (char **)&v349);
                      sub_140370D10(&v349);
                      sub_140370D10(&v444);
                    }
                    v182 = (char **)CreateStringObjectFromString(&v430, "]");
                    sub_14035B3E0(&v446);
                    v184 = sub_1403A9130(v183, "%i", v176);
                    v185 = CreateStringObjectFromString(&v445, "[");
                    v186 = (char *)*v20;
                    v187 = v185;
                    sub_14035B3E0(&v350);
                    v188 = sub_1403E7A60(v187);
                    v189 = sub_1403E20D0((__int64)v186);
                    sub_1403E90A0(&v350, v189 + v188);
                    sub_140384840(&v350, v186);
                    sub_1403847F0(&v350, (char **)v187);
                    sub_14035B160(&v402, (const void **)&v350);
                    sub_1403847F0(&v402, v184);
                    sub_14035B160(&v401, (const void **)&v402);
                    sub_1403847F0(&v401, v182);
                    sub_1403847F0(&v355, (char **)&v401);
                    sub_140370D10(&v401);
                    sub_140370D10(&v402);
                    sub_140370D10(&v350);
                    sub_140370D10(&v445);
                    sub_140370D10(&v446);
                    sub_140370D10(&v430);
                    v190 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v351 + 0x110LL))(
                                      v351,
                                      "__polymorphicType");
                    v191 = v190;
                    if ( !v190 || !*v190 )
                      v191 = v410;
                    v15 = a1;
                    v417 = v191;
                    sub_14035B120(&v418, &v417);
                    v192 = 0xFFFFFFFFFFFFFFFFuLL;
                    do
                      ++v192;
                    while ( v418[v192] );
                    v193 = 0xCBF29CE484222325uLL;
                    v194 = 0;
                    v195 = a1 + 0x26;
                    if ( v192 )
                    {
                      do
                      {
                        v196 = (unsigned __int8)v418[v194++];
                        v193 = 0x100000001B3LL * (v196 ^ v193);
                      }
                      while ( v194 < v192 );
                      v15 = a1;
                      v195 = a1 + 0x26;
                    }
                    sub_14747F260(
                      a1 + 0x26,
                      &v448,
                      &v418,
                      0xDE5FB9D2630458E9uLL * v193
                    + (((unsigned __int64)v193 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                    v418 = (char *)&qword_149B3B33C + 4;
                    sub_140370D10(&v418);
                    if ( v448 != *v195 + v195[3] )
                    {
                      v197 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v449 + 0x18))(*(_QWORD *)(v449 + 0x18), 0);
                      v198 = v411;
                      *v411 = v197;
                      v199 = (__int64 *)sub_1403C3960((char **)&v355);
                      sub_1474B4EB0((_DWORD)v15, (_DWORD)a2, *v198, (_DWORD)v191, *v199, (__int64)&v351);
                      v200 = (_BYTE *)v15[0x30];
                      if ( v200 == (_BYTE *)v15[0x31] )
                      {
                        sub_1402A6B30((__int64)(v15 + 0x2F), v200, v198);
                      }
                      else
                      {
                        *(_QWORD *)v200 = *v198;
                        v15[0x30] += 8LL;
                      }
                    }
                    sub_140370D10(&v355);
                    if ( v351 )
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v351 + 0x28LL))(v351);
                    v9 = a7;
                    v175 = v341;
                    v177 = v340;
                  }
                  else if ( v351 )
                  {
                    (*(void (__fastcall **)(__int64))(*(_QWORD *)v351 + 0x28LL))(v351);
                  }
                  *(_QWORD *)&v177 += 0x10LL;
                  ++v176;
                  v340 = v177;
                }
                while ( v176 < SLODWORD(Src) );
                v11 = a5;
              }
              else
              {
                v201 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v344 + 0x160LL))(
                                   v344,
                                   &v431,
                                   0);
                v202 = (const char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*v201 + 0x110LL))(
                                       *v201,
                                       "__type");
                v412 = v202;
                if ( v431 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v431 + 0x28LL))(v431);
                v203 = v20[1];
                v411 = (__int64 *)v203;
                v419 = v202;
                sub_14035B120(&v420, &v419);
                v204 = 0xFFFFFFFFFFFFFFFFuLL;
                do
                  ++v204;
                while ( v420[v204] );
                v205 = v15 + 0x26;
                v206 = 0xCBF29CE484222325uLL;
                v207 = 0;
                if ( v204 )
                {
                  do
                  {
                    v208 = (unsigned __int8)v420[v207++];
                    v206 = 0x100000001B3LL * (v208 ^ v206);
                  }
                  while ( v207 < v204 );
                  v11 = a5;
                  v205 = v15 + 0x26;
                }
                sub_14747F260(
                  v15 + 0x26,
                  &v450,
                  &v420,
                  0xDE5FB9D2630458E9uLL * v206
                + (((unsigned __int64)v206 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                v420 = (char *)&qword_149B3B33C + 4;
                sub_140370D10(&v420);
                if ( v450 == *v205 + v205[3] )
                {
                  sub_1405C0E00(
                    8u,
                    2u,
                    "[DataCore] Type %s was determined for Array \"%s\" but this type does not exist in the game-side str"
                    "uctures. Has it been removed or renamed?",
                    v202,
                    *v20);
                }
                else
                {
                  v209 = SLODWORD(Src);
                  *(_QWORD *)&v203[v11 + 0x10] = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v451 + 0x18))(
                                                   *(_QWORD *)(v451 + 0x18),
                                                   SLODWORD(Src));
                  v210 = 0;
                  LODWORD(v340) = 0;
                  v341 = 0.0;
                  *(_QWORD *)&v203[v11 + 0x18] = v209;
                  do
                  {
                    (*(void (__fastcall **)(__int64, _BYTE **, _QWORD))(*(_QWORD *)v344 + 0x160LL))(
                      v344,
                      &v405,
                      (unsigned int)v210);
                    sub_14035B3E0(&v343);
                    if ( a7 )
                    {
                      v211 = CreateStringObjectFromString(&v432, ".");
                      sub_14035B3E0(&v352);
                      v212 = sub_1403E20D0((__int64)a7);
                      v213 = sub_1403E7A60(v211);
                      sub_1403E90A0(&v352, v213 + v212);
                      sub_140384840(&v352, a7);
                      sub_1403847F0(&v352, (char **)v211);
                      sub_1403847F0(&v343, (char **)&v352);
                      sub_140370D10(&v352);
                      sub_140370D10(&v432);
                    }
                    v214 = (char **)CreateStringObjectFromString(&v435, "]");
                    sub_14035B3E0(&v434);
                    v216 = sub_1403A9130(v215, "%i", v210);
                    v217 = CreateStringObjectFromString(&v433, "[");
                    v218 = (char *)*v20;
                    v219 = v217;
                    sub_14035B3E0(&v353);
                    v220 = sub_1403E7A60(v219);
                    v221 = sub_1403E20D0((__int64)v218);
                    sub_1403E90A0(&v353, v221 + v220);
                    sub_140384840(&v353, v218);
                    sub_1403847F0(&v353, (char **)v219);
                    sub_14035B160(&v404, (const void **)&v353);
                    sub_1403847F0(&v404, v216);
                    sub_14035B160(&v403, (const void **)&v404);
                    sub_1403847F0(&v403, v214);
                    sub_1403847F0(&v343, (char **)&v403);
                    sub_140370D10(&v403);
                    sub_140370D10(&v404);
                    sub_140370D10(&v353);
                    sub_140370D10(&v433);
                    sub_140370D10(&v434);
                    sub_140370D10(&v435);
                    v222 = v341;
                    v410 = v405;
                    v223 = *(__int64 *)((char *)v411 + v11 + 0x10)
                         + *(__int64 *)((char *)v411 + v11 + 0x28) * *(_QWORD *)&v341;
                    if ( v405 )
                      (*(void (__fastcall **)(_BYTE *))(*(_QWORD *)v405 + 0x20LL))(v405);
                    v224 = (__int64 *)sub_1403C3960((char **)&v343);
                    v15 = a1;
                    sub_1474ABF20((__int64)a1, *v224, (__int64)v20, &v410);
                    v225 = (__int64 *)sub_1403C3960((char **)&v343);
                    sub_1474B4EB0((_DWORD)a1, (_DWORD)a2, v223, (_DWORD)v412, *v225, (__int64)&v405);
                    sub_140370D10(&v343);
                    if ( v405 )
                      (*(void (__fastcall **)(_BYTE *))(*(_QWORD *)v405 + 0x28LL))(v405);
                    v210 = LODWORD(v340) + 1;
                    *(_QWORD *)&v341 = *(_QWORD *)&v222 + 1LL;
                    LODWORD(v340) = v210;
                  }
                  while ( v210 < SLODWORD(Src) );
                }
              }
            }
            if ( v344 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v344 + 0x28LL))(v344);
          }
          goto LABEL_25;
        default:
          break;
      }
LABEL_26:
      v9 = a7;
      v18 = v428 + 1;
      v12 = a3;
      v14 = a2;
      Src_5 = Src_4;
      v428 = v18;
    }
    while ( v18 < v440 );
    v10 = v465;
LABEL_28:
    result = *(_QWORD *)(v13 + 0x18);
    if ( result )
    {
      v423 = *(_QWORD *)(v13 + 0x18);
      sub_14035B120(&v424, &v423);
      v37 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v37;
      while ( v424[v37] );
      v38 = v15 + 0x26;
      v39 = 0xCBF29CE484222325uLL;
      v40 = 0;
      if ( v37 )
      {
        do
        {
          v41 = (unsigned __int8)v424[v40++];
          v39 = 0x100000001B3LL * (v41 ^ v39);
        }
        while ( v40 < v37 );
        v11 = a5;
        v38 = v15 + 0x26;
      }
      sub_14747F260(
        v15 + 0x26,
        &v454,
        &v424,
        0xDE5FB9D2630458E9uLL * v39 + (((unsigned __int64)v39 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
      v424 = (char *)&qword_149B3B33C + 4;
      sub_140370D10(&v424);
      v42 = *(const char **)(a6 + 0x18);
      if ( v454 != *v38 + v38[3] )
      {
        v10 = *(const char **)(a6 + 0x18);
        v12 = a3;
        v13 = v455 + 8;
        a6 = v455 + 8;
        v465 = v42;
        continue;
      }
      return sub_1405C0E00(
               8u,
               0,
               "[DataCore] structure [%s] inherited class [%s] is not registered",
               v10,
               *(const char **)(a6 + 0x18));
    }
    return result;
  }
}

// --- End Function: sub_1474AC970 (0x1474AC970) ---

// --- Function: sub_1474B3870 (0x1474B3870) ---
unsigned int *sub_1474B3870(_QWORD *a1, ...)
{
  __int64 v1; // r13
  int v2; // r15d
  _BYTE *v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r14
  unsigned int v7; // eax
  unsigned int *v8; // rbx
  __int64 v9; // rdi
  const char *v10; // rdi
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 i; // r8
  __int64 v14; // rax
  const char *v15; // rax
  signed __int64 v16; // r8
  int v17; // ecx
  int v18; // edx
  unsigned int v19; // eax
  unsigned int *v20; // r12
  _QWORD *v21; // r15
  unsigned __int64 v22; // rdi
  __int64 v23; // rbx
  unsigned __int64 v24; // r11
  unsigned __int8 *v25; // rbx
  unsigned __int64 v26; // r9
  _QWORD *v27; // r10
  unsigned __int8 *v28; // rax
  int v29; // ecx
  int v30; // edx
  const char **v31; // r8
  __int64 v32; // rdi
  __int64 v33; // r11
  unsigned __int64 v34; // r8
  __int64 v35; // rax
  __int64 v36; // r9
  unsigned int *Src_1; // r13
  __int64 v38; // rax
  char v39; // r10
  __int64 v40; // rcx
  __int64 v41; // r14
  const char *v42; // r14
  __int64 v43; // r15
  __int64 n3; // r8
  unsigned __int64 v45; // r12
  __int64 v46; // r14
  unsigned __int64 v47; // rbx
  unsigned int *v48; // rcx
  __int64 v49; // r13
  __int64 v50; // rdx
  __int64 *v51; // rdi
  unsigned __int8 **v52; // rbx
  size_t *v53; // rax
  size_t Size; // r14
  size_t v55; // r15
  unsigned int v56; // ebx
  __int64 v57; // rdi
  _QWORD *v58; // r15
  __int64 v59; // rdi
  __int64 v60; // rbx
  __int64 v61; // rdi
  unsigned int v62; // ebx
  _BYTE *v63; // rdx
  __int64 v64; // r14
  unsigned int v65; // edi
  __int64 v66; // rbx
  __int64 v67; // rcx
  unsigned __int64 v68; // rcx
  __int64 v69; // r8
  unsigned __int64 v70; // rdx
  __int64 v71; // rax
  unsigned int *v72; // r8
  __int128 v73; // xmm0
  __int64 v74; // r13
  unsigned int v75; // edi
  __int64 v76; // rbx
  unsigned int *v77; // r14
  __int64 v78; // rcx
  unsigned __int64 v79; // rcx
  __int64 v80; // r8
  unsigned __int64 v81; // rdx
  __int64 v82; // rax
  __int64 v83; // r13
  unsigned int v84; // r14d
  __int64 v85; // rdi
  unsigned int *v86; // r15
  __int64 v87; // rcx
  unsigned __int64 v88; // rcx
  __int64 v89; // r8
  unsigned __int64 v90; // rdx
  __int64 v91; // rax
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rax
  unsigned __int64 v95; // rcx
  _QWORD *v96; // rbx
  __int64 v97; // r8
  unsigned __int64 v98; // rdx
  __int64 v99; // rax
  __int64 v100; // rdx
  __int64 v101; // rcx
  __int64 v102; // rdx
  void **Src_2; // r12
  __int64 v104; // rcx
  __int64 v105; // rcx
  __int64 v106; // rcx
  __int64 v107; // rcx
  __int64 n8; // rcx
  unsigned int *v109; // rcx
  unsigned int *v110; // rcx
  unsigned int *v111; // rcx
  unsigned int *v112; // rcx
  __int64 v113; // r12
  const char *v114; // r12
  unsigned int v115; // r13d
  __int64 v116; // rbx
  __int64 *v117; // rdi
  __int64 v118; // rbx
  _BYTE *v119; // rdx
  __int64 v120; // rax
  __int64 v121; // r14
  __int64 v122; // rcx
  unsigned int v123; // r8d
  __int64 v124; // rax
  _QWORD *v125; // rbx
  _QWORD *v126; // rdi
  unsigned __int64 v127; // rcx
  __int64 v128; // r8
  unsigned __int64 v129; // rdx
  __int64 v130; // rax
  __int64 v131; // rax
  unsigned int v132; // eax
  __int64 v133; // rdi
  unsigned int *v134; // rcx
  __int64 v135; // rcx
  unsigned __int64 v136; // rcx
  __int64 v137; // r8
  unsigned __int64 v138; // rdx
  __int64 v139; // rax
  __int64 v140; // rax
  unsigned int *v141; // rdi
  __int64 v142; // rbx
  __int64 v143; // rbx
  unsigned __int64 v144; // rcx
  __int64 v145; // r8
  unsigned __int64 v146; // rdx
  __int64 v147; // rax
  unsigned int *v148; // rax
  unsigned int v149; // eax
  _QWORD *v151; // [rsp+30h] [rbp-D0h]
  unsigned int v152; // [rsp+38h] [rbp-C8h] BYREF
  const char *v153; // [rsp+40h] [rbp-C0h] BYREF
  unsigned int *Src; // [rsp+48h] [rbp-B8h] BYREF
  const char *v155; // [rsp+50h] [rbp-B0h] BYREF
  const char *v156; // [rsp+58h] [rbp-A8h] BYREF
  char *v157; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v158; // [rsp+68h] [rbp-98h] BYREF
  char *v159; // [rsp+70h] [rbp-90h] BYREF
  __int64 v160; // [rsp+78h] [rbp-88h] BYREF
  char *v161; // [rsp+80h] [rbp-80h] BYREF
  __int64 v162; // [rsp+88h] [rbp-78h] BYREF
  char *v163; // [rsp+90h] [rbp-70h] BYREF
  __int64 v164; // [rsp+98h] [rbp-68h] BYREF
  char *v165; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v166; // [rsp+A8h] [rbp-58h] BYREF
  char *v167; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v168; // [rsp+B8h] [rbp-48h] BYREF
  char *v169; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v170; // [rsp+C8h] [rbp-38h] BYREF
  char *v171; // [rsp+D0h] [rbp-30h] BYREF
  void *v172; // [rsp+D8h] [rbp-28h] BYREF
  unsigned __int64 v173; // [rsp+E0h] [rbp-20h]
  const char *v174; // [rsp+E8h] [rbp-18h] BYREF
  char *v175; // [rsp+F0h] [rbp-10h] BYREF
  const char *v176; // [rsp+F8h] [rbp-8h] BYREF
  char *v177; // [rsp+100h] [rbp+0h] BYREF
  __int128 v178; // [rsp+108h] [rbp+8h] BYREF
  __int64 v179; // [rsp+118h] [rbp+18h]
  __int64 v180; // [rsp+120h] [rbp+20h] BYREF
  __int64 v181; // [rsp+128h] [rbp+28h]
  __int128 v182; // [rsp+130h] [rbp+30h]
  __int64 v183; // [rsp+140h] [rbp+40h] BYREF
  __int64 v184; // [rsp+148h] [rbp+48h]
  __int64 v185; // [rsp+150h] [rbp+50h] BYREF
  __int64 v186; // [rsp+158h] [rbp+58h]
  _QWORD v187[2]; // [rsp+160h] [rbp+60h] BYREF
  __int64 v188; // [rsp+170h] [rbp+70h] BYREF
  __int64 v189; // [rsp+178h] [rbp+78h]
  __int64 v190; // [rsp+180h] [rbp+80h] BYREF
  __int64 v191; // [rsp+188h] [rbp+88h]
  __int64 v192; // [rsp+190h] [rbp+90h] BYREF
  __int64 v193; // [rsp+198h] [rbp+98h]
  __int64 v194; // [rsp+1E8h] [rbp+E8h] BYREF
  va_list va; // [rsp+1E8h] [rbp+E8h]
  const char *v196; // [rsp+1F0h] [rbp+F0h]
  __int64 v197; // [rsp+1F8h] [rbp+F8h]
  __int64 v198; // [rsp+200h] [rbp+100h]
  unsigned int *v199; // [rsp+208h] [rbp+108h]
  va_list va1; // [rsp+210h] [rbp+110h] BYREF

  va_start(va1, a1);
  va_start(va, a1);
  v194 = va_arg(va1, _QWORD);
  v196 = va_arg(va1, const char *);
  v197 = va_arg(va1, _QWORD);
  v198 = va_arg(va1, _QWORD);
  v199 = va_arg(va1, unsigned int *);
  v1 = v197;
  v2 = v194;
  if ( *(_BYTE *)(v197 + 0x20) )
  {
    v4 = (_BYTE *)a1[0x33];
    v5 = (__int64)(a1 + 0x32);
    if ( v4 == (_BYTE *)a1[0x34] )
    {
      sub_1402A6B30(v5, v4, (__int64 *)va);
    }
    else
    {
      *(_QWORD *)v4 = v194;
      a1[0x33] += 8LL;
    }
  }
  v6 = v198;
  v7 = *(_DWORD *)(v198 + 4);
  if ( v7 == 0xFFFFFFFF )
  {
    v20 = v199;
    goto LABEL_24;
  }
  v8 = (unsigned int *)(a1[0x40] + 0x10LL * v7);
  if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
    v9 = a1[0x55];
  else
    v9 = a1[0x54];
  v10 = (const char *)(*v8 + v9);
  v156 = v10;
  sub_14035B120(&v157, &v156);
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v11;
  while ( v157[v11] );
  v12 = 0xCBF29CE484222325uLL;
  for ( i = 0; i < v11; v12 = 0x100000001B3LL * (v14 ^ v12) )
    v14 = (unsigned __int8)v157[i++];
  sub_14747F260(a1 + 0x26, &v178, &v157, (__PAIR128__(v12, v12) * 0xDE5FB9D2630458E9uLL) >> 0x40);
  v157 = (char *)&qword_149B3B33C + 4;
  sub_140370D10(&v157);
  if ( (_QWORD)v178 == a1[0x26] + a1[0x29] )
  {
    sub_1405C0E00(
      8u,
      2u,
      "[DataCore] Inherited structure [%s] is not a registered structure, data will not be loaded.",
      v10);
  }
  else
  {
    v15 = *(const char **)(v1 + 0x18);
    if ( v15 || !*v10 )
    {
      v16 = v10 - v15;
      do
      {
        v17 = (unsigned __int8)v15[v16];
        v18 = *(unsigned __int8 *)v15 - v17;
        if ( v18 )
          break;
        ++v15;
      }
      while ( v17 );
      if ( !v18 )
      {
        v20 = (unsigned int *)sub_1474B3870((_DWORD)a1, v2, (_DWORD)v10, DWORD2(v178) + 8, (__int64)v8, (__int64)v199);
        v199 = v20;
        goto LABEL_24;
      }
    }
  }
  v19 = sub_14748D470(a1, v8);
  v20 = (unsigned int *)((char *)v199 + v19);
  v199 = v20;
LABEL_24:
  v21 = (_QWORD *)(v1 + 0x38);
  v151 = (_QWORD *)(v1 + 0x38);
  if ( (*(_DWORD *)(*(_QWORD *)(v1 + 0x38) - 4LL) & 0x7FFFFFFF) == 0 && *(_WORD *)(v6 + 8) )
  {
    v22 = 0;
    do
    {
      if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
        v23 = a1[0x55];
      else
        v23 = a1[0x54];
      v24 = *(_QWORD *)(v1 + 8);
      v25 = (unsigned __int8 *)(*(unsigned int *)(a1[0x41] + 0xC * (v22 + *(unsigned __int16 *)(v6 + 0xA))) + v23);
      v26 = 0;
      if ( v24 )
      {
        v27 = *(_QWORD **)v1;
        while ( 1 )
        {
          v28 = v25;
          do
          {
            v29 = v28[*v27 - (_QWORD)v25];
            v30 = *v28 - v29;
            if ( v30 )
              break;
            ++v28;
          }
          while ( v29 );
          if ( !v30 )
            break;
          ++v26;
          v27 += 5;
          if ( v26 >= v24 )
            goto LABEL_37;
        }
        LODWORD(v153) = v26;
        v31 = &v153;
      }
      else
      {
LABEL_37:
        v152 = 0xFFFFFFFF;
        v31 = (const char **)&v152;
      }
      sub_142523570(v1 + 0x38, 1, v31, v26);
      ++v22;
    }
    while ( v22 < *(unsigned __int16 *)(v6 + 8) );
    v20 = v199;
  }
  v32 = v194;
  v33 = v194;
  v179 = v194;
  v34 = 0;
  v173 = 0;
  if ( *(_WORD *)(v6 + 8) )
  {
    while ( 1 )
    {
      v35 = a1[0x41];
      v36 = *(unsigned __int8 *)(v35 + 0xC * (v34 + *(unsigned __int16 *)(v6 + 0xA)) + 6);
      Src_1 = (unsigned int *)(v35 + 0xC * (v34 + *(unsigned __int16 *)(v6 + 0xA)));
      v38 = a1[0x3F];
      v39 = *((_BYTE *)Src_1 + 8);
      v40 = *Src_1;
      Src = Src_1;
      if ( *(_DWORD *)(v38 + 4) >= 6u )
        v41 = a1[0x55];
      else
        v41 = a1[0x54];
      v42 = (const char *)(v40 + v41);
      if ( (int)v34 >= (*(_DWORD *)(*v21 - 4LL) & 0x7FFFFFFF) )
        __debugbreak();
      if ( *(_DWORD *)(4LL * (int)v34 + *v21) == 0xFFFFFFFF )
      {
        v20 = (unsigned int *)((char *)v20 + (unsigned int)sub_14748D3A0(a1, Src_1));
        v199 = v20;
        goto LABEL_96;
      }
      if ( (int)v34 >= (*(_DWORD *)(*v21 - 4LL) & 0x7FFFFFFF) )
        __debugbreak();
      v43 = *(_QWORD *)v197 + 0x28LL * *(int *)(*v21 + 4LL * (int)v34);
      if ( *(_BYTE *)(v43 + 0x18) != (_BYTE)v36 )
        break;
      n3 = *(unsigned __int8 *)(v43 + 0x19);
      if ( (_BYTE)n3 != *((_BYTE *)Src_1 + 7) )
      {
        sub_1405C0E00(
          8u,
          2u,
          "[DataCore] Field Option Mismatch (Reference, Optional, Pointer). Check registration of DataCore Struct name: \""
          "%s\" field name \"%s\"",
          v196,
          v42);
        goto LABEL_53;
      }
      if ( *(_BYTE *)(v43 + 0x1A) )
      {
        if ( !v39 )
          goto LABEL_170;
        v45 = *v20;
        v46 = v33 + *(_QWORD *)(v43 + 8);
        LODWORD(v153) = v45;
        v47 = v199[1];
        v48 = v199 + 2;
        v152 = v199[1];
        v199 += 2;
        *(_QWORD *)(v46 + 0x10) = 0;
        switch ( (int)v36 )
        {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 0xB:
          case 0xC:
          case 0xE:
            *(_QWORD *)(v46 + 0x18) = v45;
            if ( (_DWORD)v45 )
            {
              switch ( (int)v36 )
              {
                case 1:
                  *(_QWORD *)(v46 + 0x10) = a1[0x45] + v47;
                  break;
                case 2:
                  *(_QWORD *)(v46 + 0x10) = a1[0x46] + v47;
                  break;
                case 3:
                  *(_QWORD *)(v46 + 0x10) = a1[0x47] + 2 * v47;
                  break;
                case 4:
                  *(_QWORD *)(v46 + 0x10) = a1[0x48] + 4 * v47;
                  break;
                case 5:
                  *(_QWORD *)(v46 + 0x10) = a1[0x49] + 8 * v47;
                  break;
                case 6:
                  *(_QWORD *)(v46 + 0x10) = a1[0x4A] + v47;
                  break;
                case 7:
                  *(_QWORD *)(v46 + 0x10) = a1[0x4B] + 2 * v47;
                  break;
                case 8:
                  *(_QWORD *)(v46 + 0x10) = a1[0x4C] + 4 * v47;
                  break;
                case 9:
                  *(_QWORD *)(v46 + 0x10) = a1[0x4D] + 8 * v47;
                  break;
                case 0xB:
                  *(_QWORD *)(v46 + 0x10) = a1[0x4E] + 4 * v47;
                  break;
                case 0xC:
                  *(_QWORD *)(v46 + 0x10) = a1[0x4F] + 8 * v47;
                  break;
                case 0xE:
                  *(_QWORD *)(v46 + 0x10) = a1[0x50] + 0x10 * v47;
                  break;
                default:
                  goto LABEL_94;
              }
            }
            goto LABEL_94;
          case 0xA:
            v58 = (_QWORD *)v45;
            sub_1474D2450(v46, v45, n3);
            if ( !(_DWORD)v45 )
              goto LABEL_94;
            v59 = 0;
            v60 = 4 * v47;
            do
            {
              sub_140393E20(v59 + *(_QWORD *)(v46 + 0x10), a1[0x54] + *(unsigned int *)(a1[0x52] + v60));
              v59 += 0x10;
              v60 += 4;
              v58 = (_QWORD *)((char *)v58 + 0xFFFFFFFF);
            }
            while ( v58 );
            goto LABEL_93;
          case 0xD:
            v61 = *(_QWORD *)(v43 + 8) + v32;
            sub_1474D2620(v61, v45, n3);
            v62 = 0;
            if ( !(_DWORD)v45 )
              goto LABEL_88;
            do
            {
              v63 = (_BYTE *)(a1[0x54] + *(unsigned int *)(a1[0x53] + 4LL * (v62 + v152)));
              if ( v63 && *v63 == 0x40 )
                assignCStringToStringStructure((void **)(*(_QWORD *)(v61 + 0x10) + 8LL * v62), v63);
              ++v62;
            }
            while ( v62 < (unsigned int)v45 );
            goto LABEL_93;
          case 0xF:
            v49 = v32 + *(_QWORD *)(v43 + 8);
            v50 = *(unsigned int *)(a1[0x42] + 8LL * *((unsigned __int16 *)Src + 2));
            if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
              CreateStringObjectFromString((void **)&v155, (const char *)(a1[0x55] + v50));
            else
              CreateStringObjectFromString((void **)&v155, (const char *)(a1[0x54] + v50));
            v51 = (__int64 *)a1[0x24];
            v52 = (unsigned __int8 **)v51[1];
            while ( !*((_BYTE *)v52 + 0x19) )
            {
              if ( (int)sub_1403E4780(v52 + 4, &v155) >= 0 )
              {
                v51 = (__int64 *)v52;
                v52 = (unsigned __int8 **)*v52;
              }
              else
              {
                v52 = (unsigned __int8 **)v52[2];
              }
            }
            if ( *((_BYTE *)v51 + 0x19)
              || (int)sub_1403E4780((unsigned __int8 **)&v155, v51 + 4) < 0
              || v51 == (__int64 *)a1[0x24] )
            {
              *(_BYTE *)(v49 + 8) = 1;
              *(_QWORD *)(v49 + 0x18) = 0;
              *(_QWORD *)(v49 + 0x10) = 0;
              sub_1405C0E00(8u, 2u, "[DataCore] Enum named \"%s\" is not registered. This will be ignored.", v155);
              sub_140370D10(&v155);
              v32 = v194;
            }
            else
            {
              v53 = (size_t *)sub_147487040(a1 + 0x24, &v155);
              Size = *v53;
              v55 = v53[1];
              *(_BYTE *)(v49 + 8) = 1;
              *(_QWORD *)(v49 + 0x18) = v45;
              if ( (_DWORD)v45 )
              {
                *(_QWORD *)(v49 + 0x10) = allocWithProfilerInfo(Size * v45, 0);
                v56 = 0;
                v57 = 0;
                do
                {
                  CreateStringObjectFromString(
                    &v172,
                    (const char *)(a1[0x54] + *(unsigned int *)(a1[0x51] + 4LL * (v56 + v152))));
                  LODWORD(Src) = *(_DWORD *)sub_1409AABD0(v55, &v172);
                  sub_140370D10(&v172);
                  memcpy((void *)(v57 + *(_QWORD *)(v49 + 0x10)), &Src, Size);
                  ++v56;
                  v57 += Size;
                }
                while ( v56 < (unsigned int)v45 );
              }
              sub_140370D10(&v155);
LABEL_88:
              v32 = v194;
            }
            goto LABEL_94;
          case 0x10:
            if ( *(_BYTE *)(v43 + 0x19) )
            {
              switch ( *(_BYTE *)(v43 + 0x19) )
              {
                case 1:
                  v83 = v32 + *(_QWORD *)(v43 + 8);
                  sub_1474D2580(v83, v45, n3);
                  v84 = 0;
                  if ( (_DWORD)v45 )
                  {
                    v85 = 0;
                    do
                    {
                      v86 = (unsigned int *)(a1[0x56] + 8LL * (v84 + (unsigned int)v47));
                      if ( v86[1] == 0xFFFFFFFF )
                      {
                        *(_QWORD *)(v85 + *(_QWORD *)(v83 + 0x10)) = 0;
                      }
                      else
                      {
                        if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
                          v87 = a1[0x55];
                        else
                          v87 = a1[0x54];
                        v45 = (unsigned __int64)(a1 + 0x26);
                        v162 = *(unsigned int *)(a1[0x40] + 0x10LL * *v86) + v87;
                        sub_14035B120(&v163, &v162);
                        v88 = 0xFFFFFFFFFFFFFFFFuLL;
                        do
                          ++v88;
                        while ( v163[v88] );
                        v89 = 0xCBF29CE484222325uLL;
                        v90 = 0;
                        v47 = (unsigned __int64)(a1 + 0x26);
                        if ( v88 )
                        {
                          do
                          {
                            v91 = (unsigned __int8)v163[v90++];
                            v89 = 0x100000001B3LL * (v91 ^ v89);
                          }
                          while ( v90 < v88 );
                          v47 = (unsigned __int64)(a1 + 0x26);
                          v45 = (unsigned __int64)(a1 + 0x26);
                        }
                        sub_14747F260(
                          (_QWORD *)v45,
                          &v185,
                          &v163,
                          (((unsigned __int64)v89 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40)
                        - 0x21A0462D9CFBA717LL * v89);
                        v163 = (char *)&qword_149B3B33C + 4;
                        sub_140370D10(&v163);
                        v92 = *(_QWORD *)v47 + *(_QWORD *)(v47 + 0x18);
                        LODWORD(v45) = (_DWORD)v153;
                        LODWORD(v47) = v152;
                        if ( v185 != v92 )
                          *(_QWORD *)(v85 + *(_QWORD *)(v83 + 0x10)) = *(_QWORD *)(v186 + 0x38)
                                                                     + *(_QWORD *)(v186 + 0x30) * v86[1];
                      }
                      ++v84;
                      v85 += 0x10;
                    }
                    while ( v84 < (unsigned int)v45 );
                    goto LABEL_93;
                  }
                  break;
                case 2:
                  v74 = v32 + *(_QWORD *)(v43 + 8);
                  sub_1474D2580(v74, v45, n3);
                  v75 = 0;
                  if ( (_DWORD)v45 )
                  {
                    v76 = 0;
                    do
                    {
                      v77 = (unsigned int *)(a1[0x57] + 8LL * (v75 + v152));
                      if ( v77[1] == 0xFFFFFFFF )
                      {
                        *(_QWORD *)(v76 + *(_QWORD *)(v74 + 0x10)) = 0;
                      }
                      else
                      {
                        if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
                          v78 = a1[0x55];
                        else
                          v78 = a1[0x54];
                        v160 = *(unsigned int *)(a1[0x40] + 0x10LL * *v77) + v78;
                        sub_14035B120(&v161, &v160);
                        v79 = 0xFFFFFFFFFFFFFFFFuLL;
                        do
                          ++v79;
                        while ( v161[v79] );
                        v80 = 0xCBF29CE484222325uLL;
                        v81 = 0;
                        if ( v79 )
                        {
                          do
                          {
                            v82 = (unsigned __int8)v161[v81++];
                            v80 = 0x100000001B3LL * (v82 ^ v80);
                          }
                          while ( v81 < v79 );
                          LODWORD(v45) = (_DWORD)v153;
                        }
                        sub_14747F260(
                          a1 + 0x26,
                          &v183,
                          &v161,
                          0xDE5FB9D2630458E9uLL * v80
                        + (((unsigned __int64)v80 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                        v161 = (char *)&qword_149B3B33C + 4;
                        sub_140370D10(&v161);
                        if ( v183 != a1[0x26] + a1[0x29] )
                          *(_QWORD *)(v76 + *(_QWORD *)(v74 + 0x10)) = *(_QWORD *)(v184 + 0x38)
                                                                     + *(_QWORD *)(v184 + 0x30) * v77[1];
                      }
                      ++v75;
                      v76 += 0x10;
                    }
                    while ( v75 < (unsigned int)v45 );
                  }
                  goto LABEL_93;
                case 3:
                  v64 = v32 + *(_QWORD *)(v43 + 8);
                  v182 = 0u;
                  sub_1474D24F0(v64, v45, n3);
                  v65 = 0;
                  if ( (_DWORD)v45 )
                  {
                    v66 = 0;
                    do
                    {
                      if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
                        v67 = a1[0x55];
                      else
                        v67 = a1[0x54];
                      v158 = *(unsigned int *)(a1[0x40] + 0x10LL * *((unsigned __int16 *)Src_1 + 2)) + v67;
                      sub_14035B120(&v159, &v158);
                      v68 = 0xFFFFFFFFFFFFFFFFuLL;
                      do
                        ++v68;
                      while ( v159[v68] );
                      v69 = 0xCBF29CE484222325uLL;
                      v70 = 0;
                      if ( v68 )
                      {
                        do
                        {
                          v71 = (unsigned __int8)v159[v70++];
                          v69 = 0x100000001B3LL * (v71 ^ v69);
                        }
                        while ( v70 < v68 );
                        LODWORD(v45) = (_DWORD)v153;
                      }
                      sub_14747F260(
                        a1 + 0x26,
                        &v180,
                        &v159,
                        0xDE5FB9D2630458E9uLL * v69
                      + (((unsigned __int64)v69 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                      v159 = (char *)&qword_149B3B33C + 4;
                      sub_140370D10(&v159);
                      if ( v180 != a1[0x26] + a1[0x29] )
                      {
                        v72 = (unsigned int *)(a1[0x58] + 0x14LL * (v65 + v152));
                        if ( *v72 == 0xFFFFFFFF )
                        {
                          v73 = v182;
                          *(_QWORD *)(v66 + *(_QWORD *)(v64 + 0x10) + 0x10) = 0;
                        }
                        else
                        {
                          *(_QWORD *)(v66 + *(_QWORD *)(v64 + 0x10) + 0x10) = *(_QWORD *)(v181 + 0x38)
                                                                            + *(_QWORD *)(v181 + 0x30) * *v72;
                          v73 = *(_OWORD *)(v72 + 1);
                        }
                        *(_OWORD *)(*(_QWORD *)(v64 + 0x10) + v66) = v73;
                      }
                      ++v65;
                      v66 += 0x18;
                    }
                    while ( v65 < (unsigned int)v45 );
                  }
LABEL_93:
                  v32 = v194;
                  break;
              }
            }
            else
            {
              v93 = *(unsigned int *)(a1[0x40] + 0x10LL * *((unsigned __int16 *)Src_1 + 2));
              if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
                v94 = a1[0x55] + v93;
              else
                v94 = a1[0x54] + v93;
              v164 = v94;
              sub_14035B120(&v165, &v164);
              v95 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++v95;
              while ( v165[v95] );
              v96 = a1 + 0x26;
              v97 = 0xCBF29CE484222325uLL;
              v98 = 0;
              if ( v95 )
              {
                do
                {
                  v99 = (unsigned __int8)v165[v98++];
                  v97 = 0x100000001B3LL * (v99 ^ v97);
                }
                while ( v98 < v95 );
                LODWORD(v45) = (_DWORD)v153;
                v96 = a1 + 0x26;
              }
              sub_14747F260(
                a1 + 0x26,
                v187,
                &v165,
                0xDE5FB9D2630458E9uLL * v97
              + (((unsigned __int64)v97 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
              v165 = (char *)&qword_149B3B33C + 4;
              sub_140370D10(&v165);
              if ( v187[0] == *v96 + v96[3] )
                goto LABEL_93;
              v100 = *(_QWORD *)(v43 + 8);
              v32 = v194;
              v101 = v187[1];
              *(_QWORD *)(v100 + v194 + 0x18) = (unsigned int)v45;
              if ( (_DWORD)v45 )
                *(_QWORD *)(v100 + v32 + 0x10) = *(_QWORD *)(v101 + 0x38) + *(_QWORD *)(v101 + 0x30) * v152;
              else
                *(_QWORD *)(v100 + v32 + 0x10) = 0;
            }
LABEL_94:
            v20 = v199;
            break;
          default:
            v21 = v151;
            v20 = v48;
            goto LABEL_96;
        }
      }
      else
      {
        if ( v39 )
        {
LABEL_170:
          sub_1405C0E00(
            8u,
            2u,
            "[DataCore] Field Storage Type Mismatch. Check registration of DataCore Struct name: \"%s\" field name \"%s\"",
            v196,
            v42);
          goto LABEL_53;
        }
        v102 = *(_QWORD *)(v43 + 8);
        Src_2 = (void **)(v102 + v33);
        Src = (unsigned int *)(v102 + v33);
        switch ( (int)v36 )
        {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 0xB:
          case 0xC:
          case 0xE:
            v104 = *(_QWORD *)(v43 + 0x10);
            if ( v104 != qword_149AFEBF0[v36] )
            {
              sub_1405C0E00(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Struct %s field %s",
                v196,
                v42);
              return 0;
            }
            v105 = v104 - 1;
            if ( !v105 )
            {
              *(_BYTE *)Src_2 = *(_BYTE *)v199;
LABEL_183:
              v20 = (unsigned int *)((char *)v199 + *(_QWORD *)(v43 + 0x10));
              v199 = v20;
              break;
            }
            v106 = v105 - 1;
            if ( v106 )
            {
              v107 = v106 - 2;
              if ( v107 )
              {
                n8 = v107 - 4;
                if ( n8 )
                {
                  if ( n8 != 8 )
                    goto LABEL_183;
                  v109 = v199;
                  *(_OWORD *)Src_2 = *(_OWORD *)v199;
                  v20 = (unsigned int *)((char *)v109 + *(_QWORD *)(v43 + 0x10));
                  v199 = v20;
                }
                else
                {
                  v110 = v199;
                  *Src_2 = *(void **)v199;
                  v20 = (unsigned int *)((char *)v110 + *(_QWORD *)(v43 + 0x10));
                  v199 = v20;
                }
              }
              else
              {
                v111 = v199;
                *(_DWORD *)Src_2 = *v199;
                v20 = (unsigned int *)((char *)v111 + *(_QWORD *)(v43 + 0x10));
                v199 = v20;
              }
            }
            else
            {
              v112 = v199;
              *(_WORD *)Src_2 = *(_WORD *)v199;
              v20 = (unsigned int *)((char *)v112 + *(_QWORD *)(v43 + 0x10));
              v199 = v20;
            }
            break;
          case 0xA:
            sub_140393E20(Src_2, a1[0x54] + *v199);
            v20 = ++v199;
            break;
          case 0xD:
            v119 = (_BYTE *)(a1[0x54] + *v199);
            if ( v119 && *v119 == 0x40 )
              assignCStringToStringStructure(Src_2, v119);
            v20 = ++v199;
            break;
          case 0xF:
            v113 = *(unsigned int *)(a1[0x42] + 8LL * *((unsigned __int16 *)Src_1 + 2));
            if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
              v114 = (const char *)(a1[0x55] + v113);
            else
              v114 = (const char *)(a1[0x54] + v113);
            v115 = 0xFFFFFFFF;
            v174 = v114;
            v153 = (const char *)(a1[0x54] + *v199);
            sub_14035B120(&v175, &v174);
            v116 = sub_140CB7F10(a1 + 0x24, &v175);
            v175 = (char *)&qword_149B3B33C + 4;
            sub_140370D10(&v175);
            if ( v116 == a1[0x24] )
            {
              sub_1405C0E00(8u, 0, "[DataCore] Field Enum [%s] does not exist, field name [%s].", v114, v42);
            }
            else
            {
              v117 = *(__int64 **)(v116 + 0x30);
              v176 = v153;
              sub_14035B120(&v177, &v176);
              v118 = std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
                       v117,
                       &v177);
              v177 = (char *)&qword_149B3B33C + 4;
              sub_140370D10(&v177);
              if ( v118 == *v117 )
                sub_1405C0E00(
                  8u,
                  0,
                  "[DataCore] Field Enum option [%s] does not exist in enum [%s], for field name %s.",
                  v153,
                  v114,
                  v42);
              else
                v115 = *(_DWORD *)(v118 + 0x28);
            }
            switch ( *(_QWORD *)(v43 + 0x10) )
            {
              case 1LL:
                *(_BYTE *)Src = v115;
                break;
              case 2LL:
                *(_WORD *)Src = v115;
                break;
              case 4LL:
                *Src = v115;
                break;
            }
            v32 = v194;
            v20 = ++v199;
            break;
          case 0x10:
            if ( !(_BYTE)n3 )
            {
              v141 = (unsigned int *)(a1[0x40] + 0x10LL * *((unsigned __int16 *)Src_1 + 2));
              v142 = *v141;
              if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
                v143 = a1[0x55] + v142;
              else
                v143 = a1[0x54] + v142;
              v170 = v143;
              sub_14035B120(&v171, &v170);
              v144 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++v144;
              while ( v171[v144] );
              v145 = 0xCBF29CE484222325uLL;
              v146 = 0;
              if ( v144 )
              {
                do
                {
                  v147 = (unsigned __int8)v171[v146++];
                  v145 = 0x100000001B3LL * (v147 ^ v145);
                }
                while ( v146 < v144 );
                LODWORD(Src_2) = (_DWORD)Src;
              }
              sub_14747F260(
                a1 + 0x26,
                &v192,
                &v171,
                0xDE5FB9D2630458E9uLL * v145
              + (((unsigned __int64)v145 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
              v171 = (char *)&qword_149B3B33C + 4;
              sub_140370D10(&v171);
              if ( v192 == a1[0x26] + a1[0x29] )
              {
                v149 = sub_14748D470(a1, v141);
                v32 = v194;
                v20 = (unsigned int *)((char *)v199 + v149);
                v199 = v20;
              }
              else
              {
                v148 = (unsigned int *)sub_1474B3870(
                                         (_DWORD)a1,
                                         (_DWORD)Src_2,
                                         v143,
                                         (int)v193 + 8,
                                         (__int64)v141,
                                         (__int64)v199);
                v32 = v194;
                v20 = v148;
                v199 = v148;
              }
              break;
            }
            if ( (_DWORD)n3 != 1 && (_DWORD)n3 != 2 )
            {
              v20 = v199;
              if ( (_DWORD)n3 == 3 )
              {
                v120 = a1[0x40];
                v121 = *v199;
                v122 = 2LL * *((unsigned __int16 *)Src_1 + 2);
                v20 = v199 + 5;
                v178 = *(_OWORD *)(v199 + 1);
                v199 += 5;
                v123 = *(_DWORD *)(v120 + 8 * v122);
                if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
                  v124 = a1[0x55] + v123;
                else
                  v124 = a1[0x54] + v123;
                v125 = (_QWORD *)(v102 + v32);
                v166 = v124;
                v126 = a1 + 0x26;
                sub_14035B120(&v167, &v166);
                v127 = 0xFFFFFFFFFFFFFFFFuLL;
                do
                  ++v127;
                while ( v167[v127] );
                v128 = 0xCBF29CE484222325uLL;
                v129 = 0;
                if ( v127 )
                {
                  do
                  {
                    v130 = (unsigned __int8)v167[v129++];
                    v128 = 0x100000001B3LL * (v130 ^ v128);
                  }
                  while ( v129 < v127 );
                  v126 = a1 + 0x26;
                }
                sub_14747F260(
                  v126,
                  &v188,
                  &v167,
                  0xDE5FB9D2630458E9uLL * v128
                + (((unsigned __int64)v128 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
                v167 = (char *)&qword_149B3B33C + 4;
                sub_140370D10(&v167);
                if ( v188 == *v126 + v126[3] )
                {
                  v125[2] = 0;
                  *v125 = 0;
                  v125[1] = 0;
                  v32 = v194;
                }
                else
                {
                  if ( (_DWORD)v121 == 0xFFFFFFFF )
                    v131 = 0;
                  else
                    v131 = *(_QWORD *)(v189 + 0x38) + *(_QWORD *)(v189 + 0x30) * v121;
                  v32 = v194;
                  *(_OWORD *)v125 = v178;
                  v125[2] = v131;
                }
              }
              break;
            }
            v132 = *v199;
            v133 = v199[1];
            v134 = v199 + 2;
            v199 += 2;
            if ( v132 == 0xFFFFFFFF || (_DWORD)v133 == 0xFFFFFFFF )
            {
              v32 = v194;
              *Src_2 = 0;
              v20 = v134;
              break;
            }
            if ( *(_DWORD *)(a1[0x3F] + 4LL) >= 6u )
              v135 = a1[0x55];
            else
              v135 = a1[0x54];
            v168 = *(unsigned int *)(a1[0x40] + 0x10LL * v132) + v135;
            sub_14035B120(&v169, &v168);
            v136 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++v136;
            while ( v169[v136] );
            v137 = 0xCBF29CE484222325uLL;
            v138 = 0;
            if ( v136 )
            {
              do
              {
                v139 = (unsigned __int8)v169[v138++];
                v137 = 0x100000001B3LL * (v139 ^ v137);
              }
              while ( v138 < v136 );
              Src_2 = (void **)Src;
            }
            sub_14747F260(
              a1 + 0x26,
              &v190,
              &v169,
              0xDE5FB9D2630458E9uLL * v137
            + (((unsigned __int64)v137 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 0x40));
            v169 = (char *)&qword_149B3B33C + 4;
            sub_140370D10(&v169);
            v21 = v151;
            *Src_2 = 0;
            if ( v190 == a1[0x26] + a1[0x29] )
            {
              v20 = v199;
              v32 = v194;
            }
            else
            {
              v140 = v133;
              v32 = v194;
              *Src_2 = (void *)(*(_QWORD *)(v191 + 0x38) + *(_QWORD *)(v191 + 0x30) * v140);
              v20 = v199;
            }
            goto LABEL_96;
          default:
            goto LABEL_94;
        }
      }
LABEL_95:
      v21 = v151;
LABEL_96:
      v6 = v198;
      v34 = v173 + 1;
      v173 = v34;
      if ( v34 >= *(unsigned __int16 *)(v198 + 8) )
        return v20;
      v33 = v179;
    }
    sub_1405C0E00(
      8u,
      2u,
      "[DataCore] Field Type Mismatch. Check registration of  DataCore Struct name: \"%s\" field name \"%s\"",
      v196,
      v42);
LABEL_53:
    v20 = (unsigned int *)((char *)v20 + (unsigned int)sub_14748D3A0(a1, Src_1));
    v199 = v20;
    goto LABEL_95;
  }
  return v20;
}

// --- End Function: sub_1474B3870 (0x1474B3870) ---

// --- Function: sub_1474B4EB0 (0x1474B4EB0) ---
__int64 __fastcall sub_1474B4EB0(__int64 a1, const char *a2, __int64 a3, const char *a4, char *a5, __int64 **a6)
{
  __int64 v9; // r14
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r9
  __int64 i; // rdx
  __int64 v13; // rcx
  __int64 v15; // r13
  __int64 v16; // rax
  __int64 v17; // rbx
  __int64 v18; // rax
  _BYTE *v19; // rdx
  __int64 v20; // rax
  const char *v21; // rcx
  int v22; // edx
  int v23; // r8d
  const char *v24; // rax
  __int64 v25; // rax
  const char *v26; // rbx
  __int64 inserted; // rdi
  __int64 v28; // rbx
  __int64 v29; // rdi
  __int64 v30; // rsi
  __int128 v31; // xmm0
  _BYTE *v32; // rdx
  _OWORD v33[2]; // [rsp+40h] [rbp-28h] BYREF
  _BYTE *v34; // [rsp+A0h] [rbp+38h] BYREF
  __int64 v35; // [rsp+B0h] [rbp+48h] BYREF

  v35 = a3;
  v9 = a3;
  CreateStringObjectFromString((void **)&v34, a4);
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( v34[v10] );
  v11 = 0;
  for ( i = 0xCBF29CE484222325uLL; v11 < v10; i = 0x100000001B3LL * (v13 ^ i) )
    v13 = (unsigned __int8)v34[v11++];
  sub_14747F260((_QWORD *)(a1 + 0x130), v33, &v34, (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 0x40);
  sub_140370D10(&v34);
  if ( *(_QWORD *)&v33[0] == *(_QWORD *)(a1 + 0x130) + *(_QWORD *)(a1 + 0x148) )
  {
    sub_1405C0E00(8u, 2u, "[DataCore] %s was not a game-registered structure. Ignoring.", a4);
    return 0;
  }
  else
  {
    v15 = *((_QWORD *)&v33[0] + 1) + 8LL;
    v16 = (*(__int64 (**)(void))(*(_QWORD *)qword_149B4FCA0 + 0x248LL))();
    v17 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v16 + 0x1D8LL))(v16, a4);
    if ( !v9 )
    {
      v18 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v15 + 0x10))(*(_QWORD *)(v15 + 0x10), 0);
      v19 = *(_BYTE **)(a1 + 0x180);
      v9 = v18;
      v35 = v18;
      if ( v19 == *(_BYTE **)(a1 + 0x188) )
      {
        sub_1402A6B30(a1 + 0x178, v19, &v35);
      }
      else
      {
        *(_QWORD *)v19 = v18;
        *(_QWORD *)(a1 + 0x180) += 8LL;
      }
      if ( !v9 )
        goto LABEL_17;
    }
    v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 8LL))(v9) - (_QWORD)a4;
    v21 = a4;
    do
    {
      v22 = (unsigned __int8)v21[v20];
      v23 = *(unsigned __int8 *)v21 - v22;
      if ( v23 )
        break;
      ++v21;
    }
    while ( v22 );
    if ( v23 )
    {
      v24 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 8LL))(v9);
      sub_1405C0E00(8u, 2u, "[DataCore] Type \"%s\" does not match type \"%s\" in schema. Record \"%s\".", v24, a4, a2);
      return 0;
    }
    else
    {
LABEL_17:
      v25 = (*(__int64 (**)(void))(*(_QWORD *)qword_149B4FCA0 + 0x248LL))();
      (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v25 + 0x200LL))(v25, v17, 0, 0);
      v26 = a5;
      sub_1474AC970((_QWORD *)a1, a2, a6, a4, v9, v15, a5);
      CreateStringObjectFromString((void **)&v34, v26);
      inserted = *(_QWORD *)(a1 + 0x168);
      DWORD2(v33[0]) = 0;
      v28 = *(_QWORD *)(inserted + 8);
      *(_QWORD *)&v33[0] = v28;
      while ( !*(_BYTE *)(v28 + 0x19) )
      {
        *(_QWORD *)&v33[0] = v28;
        if ( (int)sub_1403E4780((unsigned __int8 **)(v28 + 0x20), &v34) >= 0 )
        {
          inserted = v28;
          DWORD2(v33[0]) = 1;
          v28 = *(_QWORD *)v28;
        }
        else
        {
          v28 = *(_QWORD *)(v28 + 0x10);
          DWORD2(v33[0]) = 0;
        }
      }
      if ( *(_BYTE *)(inserted + 0x19) || (int)sub_1403E4780(&v34, (_QWORD *)(inserted + 0x20)) < 0 )
      {
        if ( *(_QWORD *)(a1 + 0x170) == 0x555555555555555LL )
          unknown_libname_7();
        v29 = *(_QWORD *)(a1 + 0x168);
        v30 = allocWithProfilerInfo_w(0x30u);
        sub_14035B140((_QWORD *)(v30 + 0x20), (__int64 *)&v34);
        v31 = v33[0];
        *(_QWORD *)(v30 + 0x28) = 0;
        *(_QWORD *)v30 = v29;
        *(_QWORD *)(v30 + 8) = v29;
        *(_QWORD *)(v30 + 0x10) = v29;
        *(_WORD *)(v30 + 0x18) = 0;
        v33[0] = v31;
        inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                     (__int64 **)(a1 + 0x168),
                     (__int64)v33,
                     v30);
      }
      *(_QWORD *)(inserted + 0x28) = v9;
      sub_140370D10(&v34);
      if ( *(_BYTE *)(v15 + 0x20) )
      {
        v32 = *(_BYTE **)(a1 + 0x198);
        if ( v32 == *(_BYTE **)(a1 + 0x1A0) )
        {
          sub_1402A6B30(a1 + 0x190, v32, &v35);
        }
        else
        {
          *(_QWORD *)v32 = v9;
          *(_QWORD *)(a1 + 0x198) += 8LL;
        }
      }
      return v9;
    }
  }
}

// --- End Function: sub_1474B4EB0 (0x1474B4EB0) ---

// --- Function: sub_1474B7320 (0x1474B7320) ---
double sub_1474B7320()
{
  int n0x2700; // [rsp+30h] [rbp-58h] BYREF
  __int64 v2; // [rsp+34h] [rbp-54h]
  int v3; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v4; // [rsp+40h] [rbp-48h]
  unsigned __int64 v5; // [rsp+48h] [rbp-40h]
  __int64 v6; // [rsp+50h] [rbp-38h]
  __int64 v7; // [rsp+58h] [rbp-30h]

  n0x2700 = 0x2700;
  v2 = 1;
  v3 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v4 = __rdtsc();
  qword_149B4B870(
    &n0x2700,
    &word_15160EECC,
    "CDataCore::NetUpdate",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\DataCore.cpp",
    0xC08);
  HIWORD(n0x2700) = word_15160EECC;
  v5 = __rdtsc();
  return qword_149B4B878(&n0x2700);
}

// --- End Function: sub_1474B7320 (0x1474B7320) ---

// --- Function: sub_1474B7EA0 (0x1474B7EA0) ---
void __fastcall sub_1474B7EA0(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int64 a5)
{
  int v8; // r13d
  const char *s1; // rbx
  char v10; // r9
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int64 v12; // rdi
  signed __int64 v13; // rax
  _QWORD *v14; // rax
  _QWORD *v15; // r14
  __int64 v16; // rdx
  __int64 v17; // rax
  unsigned __int64 v18; // rbp
  __int64 v19; // rcx
  _BYTE *v20; // rdx
  __int64 v21; // r8
  __int64 v22; // r8
  __int64 n2; // r8
  __int64 v24; // rdi
  __int64 v25; // rax
  int v26; // ecx
  int v27; // r8d
  __int128 pOutFieldPtrsVec_; // [rsp+30h] [rbp-58h] BYREF
  __int64 v29; // [rsp+40h] [rbp-48h]
  char v30; // [rsp+98h] [rbp+10h] BYREF
  __int64 v31; // [rsp+A8h] [rbp+20h]

  v31 = a4;
  v30 = 0;
  v8 = a4;
  (*(void (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*a3 + 0x90LL))(*a3, "__fullyInstanced", &v30);
  s1 = (const char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a3 + 0x110LL))(*a3, "__type");
  if ( v30 )
  {
    v10 = *((_BYTE *)a2 + 8);
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( v10 && *a2 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 8LL))(*a2);
      v10 = *((_BYTE *)a2 + 8);
    }
    if ( strcmp(s1, p_p_p_p_p_p_p_p_p_p_p_p_Source) )
    {
      v12 = 0;
      if ( v10 )
      {
        if ( *a2 )
        {
          (**(void (__fastcall ***)(_QWORD, __int64))*a2)(*a2, 1);
          *a2 = 0;
        }
        *((_BYTE *)a2 + 8) = 0;
      }
      v13 = DataCore::LookupDCStructDescByName(a1, (__int64)s1);
      if ( v13 )
      {
        v14 = (_QWORD *)(***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v13 + 0x10))(*(_QWORD *)(v13 + 0x10), 0);
        *a2 = v14;
        v15 = v14;
        if ( v14 )
        {
          v16 = *v14;
          pOutFieldPtrsVec_ = 0;
          v29 = 0;
          v17 = (*(__int64 (__fastcall **)(_QWORD *))(v16 + 8))(v14);
          sub_1474A5370(a1, v17, (unsigned __int64)&pOutFieldPtrsVec_, 1);
          v18 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
          if ( v18 )
          {
            do
            {
              v19 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v12);
              v20 = (char *)v15 + *(_QWORD *)(v19 + 8);
              v21 = *(_QWORD *)(v19 + 0x10);
              if ( !*(_BYTE *)(v19 + 0x1A) )
              {
                switch ( *(_BYTE *)(v19 + 0x18) )
                {
                  case 1:
                  case 2:
                  case 6:
                    *v20 = 0;
                    break;
                  case 3:
                  case 7:
                    *(_WORD *)v20 = 0;
                    break;
                  case 4:
                  case 8:
                  case 0xB:
                    *(_DWORD *)v20 = 0;
                    break;
                  case 5:
                  case 9:
                  case 0xC:
                    *(_QWORD *)v20 = 0;
                    break;
                  case 0xF:
                    v22 = v21 - 1;
                    if ( v22 )
                    {
                      n2 = v22 - 1;
                      if ( n2 )
                      {
                        if ( n2 == 2 )
                          *(_DWORD *)v20 = 0xFFFFFFFF;
                      }
                      else
                      {
                        *(_WORD *)v20 = 0xFFFF;
                      }
                    }
                    else
                    {
                      *v20 = 0xFF;
                    }
                    break;
                  case 0x10:
                    if ( !*(_BYTE *)(v19 + 0x19) )
                      sub_1474CFE80(a1, v20, v21);
                    break;
                  default:
                    break;
                }
              }
              ++v12;
            }
            while ( v12 < v18 );
            v8 = v31;
          }
          if ( (_QWORD)pOutFieldPtrsVec_ )
            sub_1403A3120(
              (__int64)&pOutFieldPtrsVec_,
              (const void *)pOutFieldPtrsVec_,
              (v29 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
        }
        *((_BYTE *)a2 + 8) = 1;
      }
    }
  }
  if ( *((_BYTE *)a2 + 8) )
  {
    v24 = *a2;
    if ( *a2 )
    {
      v25 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v24 + 8LL))(*a2) - (_QWORD)s1;
      do
      {
        v26 = (unsigned __int8)s1[v25];
        v27 = *(unsigned __int8 *)s1 - v26;
        if ( v27 )
          break;
        ++s1;
      }
      while ( v26 );
      if ( !v27 )
        sub_1474B8180(a1, v24, (_DWORD)a3, v8, a5);
    }
  }
}

// --- End Function: sub_1474B7EA0 (0x1474B7EA0) ---

// --- Function: sub_1474B8180 (0x1474B8180) ---
double __fastcall sub_1474B8180(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int64 v7; // rbx
  _QWORD *v8; // r13
  __int64 v10; // rdi
  __int64 v11; // r14
  const char *s1_1; // rax
  __int128 String1_3; // xmm0
  unsigned __int64 v14; // rcx
  __int64 pOutFieldPtrsVec__1; // rax
  __int64 v16; // rax
  __int64 v17; // r14
  __int64 v18; // rsi
  int n0x10; // ebx
  int n3; // r12d
  char v21; // di
  __int64 v22; // r15
  const char *s2; // rax
  int v24; // r8d
  __int64 v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rbx
  _QWORD *v28; // rbx
  int v29; // eax
  int v30; // ebx
  __int64 *ThreadLogContextSlot; // rax
  char v32; // al
  __int64 v34; // r9
  int v35; // eax
  __int64 v36; // r15
  __int64 n2; // r15
  __int64 *v38; // rax
  __int64 (__fastcall ***v39)(_QWORD); // rax
  __int64 v40; // rax
  char *String1_4; // rdi
  unsigned __int64 v42; // rcx
  const char *p_Str; // rdx
  size_t n511_8; // rbx
  const char *v45; // r15
  const char *p_Str_2; // rbx
  int v47; // r14d
  int v48; // eax
  unsigned __int64 v49; // rdi
  const char *v50; // r8
  int n511_12; // eax
  size_t n511_9; // rbx
  signed int v53; // r14d
  const char *v54; // rdi
  size_t Size; // rbx
  unsigned __int64 *v56; // rbx
  unsigned __int64 v57; // rdx
  const char *v58; // rdi
  int String1_1; // eax
  unsigned __int64 allocSize; // r15
  unsigned __int64 v61; // r13
  const void *v62; // rcx
  __int64 v63; // rax
  __int64 v64; // rbx
  _BYTE *v65; // r9
  _BYTE *v66; // rdx
  unsigned __int64 allocSize_1; // rbx
  _QWORD *v68; // rax
  const void *v69; // rcx
  __int64 v70; // rax
  __int64 v71; // rbx
  _BYTE *v72; // r8
  _BYTE *v73; // rcx
  char v74; // di
  unsigned __int64 allocSize_2; // rbx
  _QWORD *v76; // rax
  const void *v77; // rcx
  __int64 v78; // rax
  __int64 v79; // rbx
  char *v80; // r9
  unsigned __int64 v81; // rdx
  _WORD *v82; // rcx
  __int16 v83; // di
  unsigned __int64 allocSize_3; // rbx
  _QWORD *v85; // rax
  const void *v86; // rcx
  __int64 v87; // rax
  __int64 v88; // rbx
  char *v89; // r9
  unsigned __int64 v90; // rdx
  _DWORD *v91; // rcx
  unsigned __int64 allocSize_4; // rbx
  _QWORD *v93; // rax
  const void *v94; // rcx
  __int64 v95; // rax
  __int64 v96; // rbx
  char *v97; // r9
  unsigned __int64 v98; // rdx
  _QWORD *v99; // rcx
  unsigned __int64 allocSize_5; // rbx
  _QWORD *v101; // rax
  const void *v102; // rcx
  __int64 v103; // rax
  __int64 v104; // rbx
  _BYTE *v105; // r8
  _BYTE *v106; // rcx
  char v107; // di
  unsigned __int64 allocSize_6; // rbx
  _QWORD *v109; // rax
  const void *v110; // rcx
  __int64 v111; // rax
  __int64 v112; // rbx
  char *v113; // r9
  unsigned __int64 v114; // rdx
  _WORD *v115; // rcx
  __int16 v116; // di
  unsigned __int64 allocSize_7; // rbx
  _QWORD *v118; // rax
  const void *v119; // rcx
  __int64 v120; // rax
  __int64 v121; // rbx
  char *v122; // r9
  unsigned __int64 v123; // rdx
  _DWORD *v124; // rcx
  unsigned __int64 allocSize_8; // rbx
  _QWORD *v126; // rax
  const void *v127; // rcx
  __int64 v128; // rax
  __int64 v129; // rbx
  char *v130; // r9
  unsigned __int64 v131; // rdx
  _QWORD *v132; // rcx
  unsigned __int64 allocSize_9; // rbx
  _QWORD *v134; // rax
  __int64 v135; // r9
  const void *v136; // rcx
  __int64 v137; // rax
  __int64 v138; // rbx
  char *v139; // r9
  unsigned __int64 v140; // rdx
  _DWORD *v141; // rcx
  unsigned __int64 allocSize_13; // rbx
  _QWORD *v143; // rax
  const void *v144; // rcx
  __int64 v145; // rax
  __int64 v146; // rbx
  char *v147; // r9
  unsigned __int64 v148; // rdx
  _QWORD *v149; // rcx
  unsigned __int64 allocSize_14; // rbx
  _QWORD *v151; // rax
  __int64 v152; // r9
  __int64 v153; // rdi
  const void *v154; // rcx
  __int64 v155; // rax
  __int64 v156; // rbx
  char *v157; // r9
  unsigned __int64 v158; // rdx
  _DWORD *v159; // rcx
  const void *v160; // rcx
  __int64 v161; // rax
  __int64 v162; // rbx
  char *v163; // r9
  unsigned __int64 v164; // rdx
  _WORD *v165; // rcx
  const void *v166; // rcx
  __int64 v167; // rax
  __int64 v168; // rbx
  _BYTE *v169; // r8
  _BYTE *v170; // rcx
  unsigned __int64 allocSize_19; // rbx
  _QWORD *v172; // rax
  int v173; // eax
  const char *v174; // rcx
  unsigned __int64 v175; // rax
  __int64 v176; // r14
  __int64 v177; // rdi
  __int64 i; // rbx
  __int64 v179; // rax
  bool v180; // cf
  unsigned __int64 allocSize_10; // rax
  _QWORD *v182; // rax
  unsigned __int64 allocSize_11; // rdx
  _QWORD *v184; // rcx
  _QWORD *v185; // r12
  unsigned __int64 v186; // rdi
  __int64 v187; // r15
  __int64 v188; // rbx
  __int64 v189; // rdi
  __int64 j; // rbx
  unsigned __int64 allocSize_12; // rbx
  __int64 v192; // rdi
  _QWORD *v193; // rax
  __int64 v194; // r14
  __int64 v195; // rbx
  _QWORD *k; // rdi
  __int64 v197; // rax
  unsigned __int64 allocSize_15; // rax
  _QWORD *v199; // rax
  _QWORD *v200; // r14
  unsigned __int64 allocSize_16; // rbx
  _QWORD *v202; // rdi
  char **v203; // r12
  unsigned __int64 v204; // rdi
  __int64 v205; // r15
  char **v206; // rbx
  __int64 v207; // rbx
  _QWORD *m; // rdi
  unsigned __int64 allocSize_17; // rbx
  _QWORD *v210; // rax
  const void *v211; // rcx
  __int64 v212; // rbx
  char *v213; // rax
  unsigned __int64 v214; // rdx
  _OWORD *v215; // rcx
  unsigned __int64 allocSize_18; // rbx
  __int64 v217; // rdi
  _QWORD *v218; // rax
  __int64 *v219; // rax
  const void *v220; // rcx
  __int64 v221; // rax
  __int64 v222; // r14
  unsigned __int64 allocSize_24; // rbx
  _QWORD *v224; // rdi
  unsigned __int64 v225; // rcx
  char *v226; // r8
  __int64 v227; // rax
  char *v228; // rdx
  unsigned __int64 allocSize_25; // r14
  __int64 v230; // rbx
  _QWORD *v231; // rax
  __int64 *v232; // rax
  __int64 v233; // rdi
  __int64 (__fastcall ***v234)(_QWORD); // rax
  _QWORD *v235; // rcx
  size_t n0x1FF_3; // rbx
  __int64 v237; // rax
  unsigned __int64 allocSize_26; // rax
  _QWORD *v239; // rax
  _QWORD *v240; // r14
  unsigned __int64 allocSize_27; // rbx
  __int64 v242; // rdi
  _QWORD *v243; // rax
  unsigned __int64 String1_2; // r13
  __int64 v245; // rax
  const void *v246; // rdi
  char *v247; // rax
  char *v248; // rdx
  unsigned __int64 n0x1FF_5; // rcx
  char *v250; // rbx
  char *v251; // r15
  int n0x1FF_10; // r14d
  int n0x1FF_11; // eax
  char *v254; // r8
  int n0x1FF_20; // eax
  size_t n0x1FF_7; // rbx
  unsigned int v257; // r12d
  _BYTE *p_Src; // r14
  size_t n0x1FF_9; // rdi
  char *v260; // r15
  _BYTE *p_Src_2; // rax
  _BYTE *v262; // rax
  const char *v263; // rdi
  unsigned __int64 v264; // rbx
  unsigned __int64 *v265; // r14
  unsigned __int64 v266; // rdx
  char *v267; // rcx
  unsigned __int64 v268; // rax
  _QWORD *v269; // rcx
  __int64 v270; // rax
  unsigned __int64 allocSize_21; // rax
  _QWORD *v272; // rax
  _QWORD *v273; // r14
  unsigned __int64 allocSize_22; // rbx
  __int64 v275; // rdi
  _QWORD *v276; // rax
  unsigned __int64 allocSize_23; // rbx
  __int64 v278; // rdi
  __int64 v279; // rax
  __int64 v280; // r9
  __int64 v281; // rax
  _QWORD *v282; // rax
  __int64 v283; // rbx
  signed __int64 v284; // rax
  _QWORD *v285; // rbx
  unsigned __int64 allocSize_20; // rdi
  unsigned __int64 v287; // rbx
  __int64 v288; // r8
  unsigned __int64 allocSize_28; // rbx
  _QWORD *v290; // rax
  _QWORD *v291; // rax
  char v292; // di
  unsigned __int64 allocSize_29; // rbx
  _QWORD *v294; // rax
  _QWORD *v295; // rax
  __int16 v296; // di
  unsigned __int64 allocSize_30; // rbx
  _QWORD *v298; // rax
  _QWORD *v299; // rax
  unsigned __int64 allocSize_31; // rbx
  _QWORD *v301; // rax
  _QWORD *v302; // rax
  unsigned __int64 allocSize_32; // rbx
  _QWORD *v304; // rax
  _QWORD *v305; // rax
  char v306; // di
  unsigned __int64 allocSize_33; // rbx
  _QWORD *v308; // rax
  _QWORD *v309; // rax
  __int16 v310; // di
  unsigned __int64 allocSize_34; // rbx
  _QWORD *v312; // rax
  _QWORD *v313; // rax
  unsigned __int64 allocSize_35; // rbx
  _QWORD *v315; // rax
  _QWORD *v316; // rax
  unsigned __int64 allocSize_36; // rbx
  _QWORD *v318; // rax
  _QWORD *v319; // rax
  __int64 v320; // r9
  unsigned __int64 allocSize_38; // rbx
  _QWORD *v322; // rax
  _QWORD *v323; // rax
  unsigned __int64 allocSize_39; // rbx
  _QWORD *v325; // rax
  _QWORD *v326; // rax
  __int64 v327; // r9
  __int64 v328; // rdi
  unsigned __int64 allocSize_42; // rbx
  _QWORD *v330; // rax
  _QWORD *v331; // rax
  int v332; // eax
  unsigned __int64 allocSize_37; // rbx
  _QWORD *v334; // rax
  _QWORD *v335; // rax
  unsigned __int64 allocSize_40; // rbx
  _QWORD *v337; // rax
  _QWORD *v338; // rax
  unsigned __int64 allocSize_41; // rdi
  _QWORD *v340; // rax
  _QWORD *v341; // rax
  __int64 v342; // rbx
  __int64 *v343; // rax
  unsigned __int64 allocSize_45; // r14
  __int64 *v345; // rax
  __int64 v346; // rdi
  __int64 v347; // rbx
  __int64 (__fastcall ***v348)(_QWORD); // rax
  unsigned __int64 allocSize_46; // r13
  __int64 v350; // rcx
  __int64 v351; // rax
  const void *v352; // rdi
  unsigned __int64 n511; // rbx
  char *v354; // rdx
  unsigned __int64 n511_2; // rcx
  char *v356; // rbx
  char *v357; // r15
  int n511_4; // r14d
  int n511_5; // eax
  char *v360; // r8
  int n511_10; // eax
  size_t n511_3; // rbx
  unsigned int v363; // r12d
  _BYTE *v364; // r14
  unsigned __int64 n511_6; // rdi
  char *v366; // r15
  __int64 v367; // rbx
  const char *v368; // rdi
  unsigned __int64 *v369; // r14
  unsigned __int64 v370; // rdx
  unsigned __int64 allocSize_44; // rbx
  __int64 v372; // rdi
  __int64 v373; // rax
  __int64 v374; // rax
  _QWORD *v375; // rax
  __int64 v376; // rbx
  unsigned __int64 allocSize_43; // rbx
  __int64 v378; // rax
  signed __int64 v379; // rax
  __int64 v383; // [rsp+80h] [rbp-80h] BYREF
  char v384[8]; // [rsp+88h] [rbp-78h] BYREF
  __int64 v385; // [rsp+90h] [rbp-70h] BYREF
  char *String1; // [rsp+98h] [rbp-68h] BYREF
  __int64 v387; // [rsp+A0h] [rbp-60h]
  __int64 v388; // [rsp+A8h] [rbp-58h]
  char v389; // [rsp+B0h] [rbp-50h] BYREF
  char v390[7]; // [rsp+B1h] [rbp-4Fh] BYREF
  __int64 v391; // [rsp+B8h] [rbp-48h] BYREF
  int v392; // [rsp+C0h] [rbp-40h] BYREF
  int v393; // [rsp+C4h] [rbp-3Ch] BYREF
  float v394; // [rsp+C8h] [rbp-38h] BYREF
  __int64 v395; // [rsp+D0h] [rbp-30h] BYREF
  char *v396; // [rsp+D8h] [rbp-28h] BYREF
  const char *s1; // [rsp+E0h] [rbp-20h]
  __int16 v398[2]; // [rsp+E8h] [rbp-18h] BYREF
  __int16 v399; // [rsp+ECh] [rbp-14h] BYREF
  char v400[4]; // [rsp+F0h] [rbp-10h] BYREF
  __int16 v401; // [rsp+F4h] [rbp-Ch] BYREF
  __int16 v402[2]; // [rsp+F8h] [rbp-8h] BYREF
  __int16 v403; // [rsp+FCh] [rbp-4h] BYREF
  char v404[4]; // [rsp+100h] [rbp+0h] BYREF
  __int16 v405; // [rsp+104h] [rbp+4h] BYREF
  _DWORD v406[2]; // [rsp+108h] [rbp+8h] BYREF
  _DWORD v407[2]; // [rsp+110h] [rbp+10h] BYREF
  __int64 v408; // [rsp+118h] [rbp+18h] BYREF
  _QWORD *v409; // [rsp+120h] [rbp+20h]
  __int64 v410; // [rsp+128h] [rbp+28h] BYREF
  const char *String1_6; // [rsp+130h] [rbp+30h] BYREF
  __int64 v412; // [rsp+138h] [rbp+38h] BYREF
  const char *String1_8; // [rsp+140h] [rbp+40h] BYREF
  __int64 v414; // [rsp+148h] [rbp+48h] BYREF
  __int64 v415; // [rsp+150h] [rbp+50h] BYREF
  __int64 v416; // [rsp+158h] [rbp+58h] BYREF
  unsigned __int64 v417; // [rsp+160h] [rbp+60h] BYREF
  __int128 pOutFieldPtrsVec_; // [rsp+168h] [rbp+68h] BYREF
  __int64 v419; // [rsp+178h] [rbp+78h]
  __int64 v420; // [rsp+180h] [rbp+80h] BYREF
  double v421; // [rsp+188h] [rbp+88h] BYREF
  void *v422; // [rsp+190h] [rbp+90h] BYREF
  __int64 v423; // [rsp+198h] [rbp+98h] BYREF
  __int64 v424; // [rsp+1A0h] [rbp+A0h] BYREF
  __int64 v425; // [rsp+1A8h] [rbp+A8h] BYREF
  unsigned __int64 v426; // [rsp+1B0h] [rbp+B0h]
  __int64 v427; // [rsp+1B8h] [rbp+B8h] BYREF
  void *v428; // [rsp+1C0h] [rbp+C0h] BYREF
  unsigned __int64 v429; // [rsp+1C8h] [rbp+C8h] BYREF
  void *v430; // [rsp+1D0h] [rbp+D0h] BYREF
  __int64 v431; // [rsp+1D8h] [rbp+D8h] BYREF
  void *v432; // [rsp+1E0h] [rbp+E0h] BYREF
  void *v433; // [rsp+1E8h] [rbp+E8h] BYREF
  __int64 v434; // [rsp+1F0h] [rbp+F0h] BYREF
  __int64 v435; // [rsp+1F8h] [rbp+F8h] BYREF
  __int64 v436; // [rsp+200h] [rbp+100h] BYREF
  __int64 v437; // [rsp+208h] [rbp+108h] BYREF
  __int64 v438; // [rsp+210h] [rbp+110h] BYREF
  __int64 v439; // [rsp+218h] [rbp+118h] BYREF
  __int64 v440; // [rsp+220h] [rbp+120h] BYREF
  __int64 v441; // [rsp+228h] [rbp+128h] BYREF
  __int64 v442; // [rsp+230h] [rbp+130h] BYREF
  __int64 v443; // [rsp+238h] [rbp+138h] BYREF
  __int64 v444; // [rsp+240h] [rbp+140h] BYREF
  __int64 v445; // [rsp+248h] [rbp+148h] BYREF
  __int64 v446; // [rsp+250h] [rbp+150h] BYREF
  _BYTE *p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source; // [rsp+258h] [rbp+158h] BYREF
  __int64 v448; // [rsp+260h] [rbp+160h] BYREF
  _BYTE *v449; // [rsp+268h] [rbp+168h] BYREF
  __int64 v450; // [rsp+270h] [rbp+170h] BYREF
  char *v451; // [rsp+278h] [rbp+178h] BYREF
  __int64 v452; // [rsp+280h] [rbp+180h] BYREF
  char *v453; // [rsp+288h] [rbp+188h] BYREF
  __int64 v454; // [rsp+290h] [rbp+190h] BYREF
  __int64 v455; // [rsp+298h] [rbp+198h] BYREF
  __int64 v456; // [rsp+2A0h] [rbp+1A0h] BYREF
  __int64 v457; // [rsp+2A8h] [rbp+1A8h] BYREF
  __int64 v458; // [rsp+2B0h] [rbp+1B0h] BYREF
  __int64 v459; // [rsp+2B8h] [rbp+1B8h] BYREF
  __int64 v460; // [rsp+2C0h] [rbp+1C0h] BYREF
  __int64 v461; // [rsp+2C8h] [rbp+1C8h] BYREF
  __int64 v462; // [rsp+2D0h] [rbp+1D0h] BYREF
  __int64 v463; // [rsp+2D8h] [rbp+1D8h] BYREF
  __int64 v464; // [rsp+2E0h] [rbp+1E0h] BYREF
  __int64 v465; // [rsp+2E8h] [rbp+1E8h] BYREF
  __int64 v466; // [rsp+2F0h] [rbp+1F0h] BYREF
  __int64 v467; // [rsp+2F8h] [rbp+1F8h] BYREF
  __int64 v468; // [rsp+300h] [rbp+200h] BYREF
  __int64 v469; // [rsp+308h] [rbp+208h] BYREF
  __int64 v470; // [rsp+310h] [rbp+210h] BYREF
  __int64 v471; // [rsp+318h] [rbp+218h] BYREF
  __int64 v472; // [rsp+320h] [rbp+220h] BYREF
  __int64 v473; // [rsp+328h] [rbp+228h] BYREF
  __int64 v474; // [rsp+330h] [rbp+230h] BYREF
  __int64 v475; // [rsp+338h] [rbp+238h] BYREF
  __int64 v476; // [rsp+340h] [rbp+240h] BYREF
  __int64 v477; // [rsp+348h] [rbp+248h] BYREF
  __int64 v478; // [rsp+350h] [rbp+250h] BYREF
  __int64 v479; // [rsp+358h] [rbp+258h] BYREF
  __int64 v480; // [rsp+360h] [rbp+260h] BYREF
  _BYTE *p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // [rsp+368h] [rbp+268h] BYREF
  __int64 v482; // [rsp+370h] [rbp+270h] BYREF
  __int64 v483; // [rsp+378h] [rbp+278h] BYREF
  _BYTE *v484; // [rsp+380h] [rbp+280h] BYREF
  __int64 v485; // [rsp+388h] [rbp+288h] BYREF
  __int64 v486; // [rsp+390h] [rbp+290h] BYREF
  char *v487; // [rsp+398h] [rbp+298h] BYREF
  char *v488; // [rsp+3A0h] [rbp+2A0h] BYREF
  __int64 v489; // [rsp+3A8h] [rbp+2A8h] BYREF
  unsigned __int64 v490; // [rsp+3B0h] [rbp+2B0h]
  __int64 v491; // [rsp+3B8h] [rbp+2B8h] BYREF
  __int64 v492; // [rsp+3C0h] [rbp+2C0h] BYREF
  __int64 v493; // [rsp+3C8h] [rbp+2C8h] BYREF
  const char *s1_2; // [rsp+3D0h] [rbp+2D0h] BYREF
  __int64 v495; // [rsp+3D8h] [rbp+2D8h] BYREF
  int n0x1600; // [rsp+3E0h] [rbp+2E0h] BYREF
  __int64 v497; // [rsp+3E4h] [rbp+2E4h]
  int v498; // [rsp+3ECh] [rbp+2ECh]
  unsigned __int64 v499; // [rsp+3F0h] [rbp+2F0h]
  unsigned __int64 v500; // [rsp+3F8h] [rbp+2F8h]
  __int64 v501; // [rsp+400h] [rbp+300h]
  __int64 v502; // [rsp+408h] [rbp+308h]
  __int64 v503[2]; // [rsp+430h] [rbp+330h] BYREF
  _QWORD v504[2]; // [rsp+440h] [rbp+340h] BYREF
  __int128 v505; // [rsp+450h] [rbp+350h] BYREF
  __int64 v506; // [rsp+460h] [rbp+360h] BYREF
  __int64 v507; // [rsp+470h] [rbp+370h] BYREF
  __int64 v508; // [rsp+480h] [rbp+380h] BYREF
  __int64 v509; // [rsp+490h] [rbp+390h] BYREF
  __int64 v510; // [rsp+4A0h] [rbp+3A0h] BYREF
  __int64 v511; // [rsp+4B0h] [rbp+3B0h] BYREF
  __int128 String1_5; // [rsp+4C0h] [rbp+3C0h] BYREF
  __int128 String1_7; // [rsp+4D0h] [rbp+3D0h] BYREF
  __int128 String1_9; // [rsp+4E0h] [rbp+3E0h] BYREF
  size_t n0x1FF_4; // [rsp+4F0h] [rbp+3F0h]
  unsigned __int64 n0x1FF_1; // [rsp+4F8h] [rbp+3F8h]
  char *v517; // [rsp+500h] [rbp+400h]
  _BYTE v518[520]; // [rsp+508h] [rbp+408h] BYREF
  size_t n0x1FF_8; // [rsp+710h] [rbp+610h]
  __int64 n0x1FF_6; // [rsp+718h] [rbp+618h]
  void *p_Src_1; // [rsp+720h] [rbp+620h]
  _BYTE Src[520]; // [rsp+728h] [rbp+628h] BYREF
  size_t n0x1FF_12; // [rsp+930h] [rbp+830h]
  unsigned __int64 n0x1FF_2; // [rsp+938h] [rbp+838h]
  void *v525; // [rsp+940h] [rbp+840h]
  _BYTE v526[520]; // [rsp+948h] [rbp+848h] BYREF
  size_t Size_1; // [rsp+B50h] [rbp+A50h] BYREF
  __int64 n0x1FF_19; // [rsp+B58h] [rbp+A58h]
  void *v529; // [rsp+B60h] [rbp+A60h]
  _BYTE v530[520]; // [rsp+B68h] [rbp+A68h] BYREF
  unsigned __int64 n511_11; // [rsp+D70h] [rbp+C70h] BYREF
  __int64 n0x1FF_16; // [rsp+D78h] [rbp+C78h]
  void *v533; // [rsp+D80h] [rbp+C80h]
  _BYTE v534[520]; // [rsp+D88h] [rbp+C88h] BYREF
  unsigned __int64 n511_1; // [rsp+F90h] [rbp+E90h] BYREF
  unsigned __int64 n0x1FF_14; // [rsp+F98h] [rbp+E98h]
  char *v537; // [rsp+FA0h] [rbp+EA0h]
  _BYTE v538[520]; // [rsp+FA8h] [rbp+EA8h] BYREF
  unsigned __int64 v539; // [rsp+11B0h] [rbp+10B0h] BYREF
  __int64 n0x1FF_18; // [rsp+11B8h] [rbp+10B8h]
  void *p_Str_1; // [rsp+11C0h] [rbp+10C0h]
  char Str[520]; // [rsp+11C8h] [rbp+10C8h] BYREF
  unsigned __int64 n511_7; // [rsp+13D0h] [rbp+12D0h] BYREF
  unsigned __int64 n0x1FF_15; // [rsp+13D8h] [rbp+12D8h]
  void *v545; // [rsp+13E0h] [rbp+12E0h]
  _BYTE v546[520]; // [rsp+13E8h] [rbp+12E8h] BYREF
  __int64 v547; // [rsp+15F0h] [rbp+14F0h] BYREF
  __int64 n0x1FF_17; // [rsp+15F8h] [rbp+14F8h]
  const char *v549; // [rsp+1600h] [rbp+1500h]
  _BYTE v550[520]; // [rsp+1608h] [rbp+1508h] BYREF
  __int64 v551; // [rsp+1810h] [rbp+1710h] BYREF
  __int64 n0x1FF; // [rsp+1818h] [rbp+1718h]
  const char *v553; // [rsp+1820h] [rbp+1720h]
  _BYTE v554[520]; // [rsp+1828h] [rbp+1728h] BYREF
  __int64 v555; // [rsp+1A30h] [rbp+1930h] BYREF
  __int64 n0x1FF_13; // [rsp+1A38h] [rbp+1938h]
  const char *v557; // [rsp+1A40h] [rbp+1940h]
  _BYTE v558[520]; // [rsp+1A48h] [rbp+1948h] BYREF
  __int128 v559; // [rsp+1C60h] [rbp+1B60h]
  __int128 v560; // [rsp+1C70h] [rbp+1B70h]

  v7 = a5;
  v387 = a5;
  v8 = a4;
  v498 = 0;
  v500 = 0;
  v10 = a2;
  v501 = 0;
  v11 = (__int64)a1;
  v502 = 0;
  v409 = a3;
  v388 = a2;
  v491 = a2;
  n0x1600 = 0x1600;
  v497 = 1;
  v499 = __rdtsc();
  qword_149B4B870(
    &n0x1600,
    &word_15160EED0,
    "CDataCore::OverwriteStruct",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CrySystem\\DataCoreSerialize.cpp",
    0x2A3);
  HIWORD(n0x1600) = word_15160EED0;
  if ( v10 )
  {
    s1_1 = (const char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a3 + 0x110LL))(*a3, "__type");
    s1 = s1_1;
    s1_2 = s1_1;
    if ( s1_1 )
    {
      if ( *s1_1 )
      {
        String1_3 = 0;
        v419 = 0;
        pOutFieldPtrsVec_ = 0;
        sub_1474A5370(v11, (__int64)s1_1, (unsigned __int64)&pOutFieldPtrsVec_, 1);
        v14 = 0;
        pOutFieldPtrsVec__1 = pOutFieldPtrsVec_;
        v426 = 0;
        v490 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
        if ( v490 )
        {
          v560 = v5;
          v559 = v6;
          while ( 1 )
          {
            v16 = *(_QWORD *)(pOutFieldPtrsVec__1 + 8 * v14);
            v17 = *(_QWORD *)v16;
            v18 = v388 + *(_QWORD *)(v16 + 8);
            n0x10 = *(unsigned __int8 *)(v16 + 0x18);
            n3 = *(unsigned __int8 *)(v16 + 0x19);
            v21 = *(_BYTE *)(v16 + 0x1A);
            v22 = *(_QWORD *)(v16 + 0x10);
            s2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v388 + 8LL))(v388);
            v24 = strcmp(s1, s2);
            v25 = *v409;
            if ( v24 )
            {
              (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v25 + 0x188LL))(v25, &v391);
LABEL_8:
              v26 = v391;
              while ( 1 )
              {
                v27 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v26 + 0x188LL))(v26, &v492);
                if ( v492 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v492 + 0x28LL))(v492);
                if ( !v27 )
                  break;
                v28 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v391 + 0x188LL))(v391, &v493);
                if ( *v28 )
                  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v28 + 0x20LL))(*v28);
                if ( v391 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v391 + 0x28LL))(v391);
                v26 = *v28;
                v391 = *v28;
                if ( v493 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v493 + 0x28LL))(v493);
                  goto LABEL_8;
                }
              }
              v406[0] = 0xE9;
              v504[0] = v406;
              v406[1] = 0x1F;
              v504[1] = v407;
              v29 = invokeGlobalCallbackAndMaskStatusBits(
                      4,
                      (__int64)v504,
                      (__int64)"Level data loss: Polymorphic type changed",
                      "Data type for a polymorphic was changed in DataForge and no longer matches DataCore Instanced Prop"
                      "erties in the layer. There is no way to translate between the two, so the Instanced Properties hav"
                      "e been ignored and may be lost on saving the level. The entity may need updating to account for th"
                      "e DataForge changes. Affected Entity : $$, class: $$, GUID: $$. New structure $$, old structure $.");
              v10 = v388;
              v30 = v29;
              if ( (v29 & 0xFFFFF) != 0 )
              {
                *(double *)&String1 = COERCE_DOUBLE((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v388 + 8LL))(v388));
                v385 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v391 + 0x110LL))(
                         v391,
                         "EntityClassGUID");
                v495 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v391 + 0x110LL))(
                         v391,
                         "EntityClass");
                v417 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v391 + 0x110LL))(v391, "Name");
                ThreadLogContextSlot = getThreadLogContextSlot();
                v407[0] = 0xE9;
                v407[1] = 0x1F;
                v503[0] = (__int64)v407;
                v503[1] = (__int64)&v408;
                String1_3 = 0;
                v505 = 0;
                sub_14747DB80(
                  4u,
                  v503,
                  "Level data loss: Polymorphic type changed",
                  "Data type for a polymorphic was changed in DataForge and no longer matches DataCore Instanced Properti"
                  "es in the layer. There is no way to translate between the two, so the Instanced Properties have been i"
                  "gnored and may be lost on saving the level. The entity may need updating to account for the DataForge "
                  "changes. Affected Entity : $$, class: $$, GUID: $$. New structure $$, old structure $.",
                  1,
                  v30,
                  &v505,
                  0,
                  (__int64)ThreadLogContextSlot,
                  (__int64)&v417,
                  (__int64)&v495,
                  (__int64)&v385,
                  (__int64)&s1_2,
                  (__int64)&String1);
              }
              if ( v391 )
                (*(void (__fastcall **)(__int64))(*(_QWORD *)v391 + 0x28LL))(v391);
              v11 = (__int64)a1;
              v7 = v387;
            }
            else if ( v21 )
            {
              (*(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v25 + 0x168LL))(v25, &v383, v17);
              if ( !v383 )
                goto LABEL_33;
              String1_1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v383 + 0x158LL))(v383);
              allocSize = String1_1;
              v389 = 0;
              String1 = (char *)String1_1;
              (*(void (__fastcall **)(__int64, const char *, char *))(*(_QWORD *)v383 + 0x90LL))(
                v383,
                "__fullyInstanced",
                &v389);
              v61 = *(_QWORD *)(v18 + 0x18);
              v417 = v61;
              if ( !allocSize )
              {
                v11 = (__int64)a1;
                if ( v389 && v61 )
                  sub_14749DAD0((__int64)a1, v18, n0x10, n3);
                if ( v383 )
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v383 + 0x28LL))(v383);
                v8 = a4;
                goto LABEL_34;
              }
              if ( v389 )
              {
                switch ( n0x10 )
                {
                  case 1:
                    v62 = *(const void **)(v18 + 0x10);
                    if ( v62 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v62);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v63 = allocWithProfilerInfo_w(allocSize);
                      v64 = v63;
                      v65 = *(_BYTE **)(v18 + 0x10);
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v66 = (_BYTE *)v63;
                        do
                        {
                          *v66 = v65[(_QWORD)v66 - v63];
                          ++v66;
                        }
                        while ( (unsigned __int64)&v66[-v63] < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v65);
                      *(_QWORD *)(v18 + 0x10) = v64;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    allocSize_1 = 0;
                    v390[0] = 0;
                    do
                    {
                      v68 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                        v383,
                                        &v434,
                                        (unsigned int)allocSize_1);
                      (*(void (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v68 + 0x90LL))(
                        *v68,
                        "value",
                        v390);
                      if ( v434 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v434 + 0x28LL))(v434);
                      *(_BYTE *)(allocSize_1 + *(_QWORD *)(v18 + 0x10)) = v390[0];
                      ++allocSize_1;
                    }
                    while ( allocSize_1 < allocSize );
                    break;
                  case 2:
                    v69 = *(const void **)(v18 + 0x10);
                    if ( v69 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v69);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v70 = allocWithProfilerInfo_w(allocSize);
                      v71 = v70;
                      v72 = *(_BYTE **)(v18 + 0x10);
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v73 = (_BYTE *)v70;
                        do
                        {
                          *v73 = v72[(_QWORD)v73 - v70];
                          ++v73;
                        }
                        while ( (unsigned __int64)&v73[-v70] < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v72);
                      *(_QWORD *)(v18 + 0x10) = v71;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    sub_1474D2FE0(v18, allocSize);
                    v74 = 0;
                    for ( allocSize_2 = 0; allocSize_2 < allocSize; ++allocSize_2 )
                    {
                      v76 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                        v383,
                                        &v435,
                                        (unsigned int)allocSize_2);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v76 + 0x100LL))(
                             *v76,
                             "value",
                             v398) )
                      {
                        v74 = v398[0];
                      }
                      if ( v435 )
                        (*(void (**)(void))(*(_QWORD *)v435 + 0x28LL))();
                      *(_BYTE *)(allocSize_2 + *(_QWORD *)(v18 + 0x10)) = v74;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 3:
                    v77 = *(const void **)(v18 + 0x10);
                    if ( v77 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v77);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v78 = allocWithProfilerInfo_w(saturated_mul(allocSize, 2u));
                      v79 = v78;
                      v80 = *(char **)(v18 + 0x10);
                      v81 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v82 = (_WORD *)v78;
                        do
                        {
                          ++v81;
                          *v82 = *(_WORD *)&v80[(_QWORD)v82 - v78];
                          ++v82;
                        }
                        while ( v81 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v80);
                      *(_QWORD *)(v18 + 0x10) = v79;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    sub_1474D30B0(v18, allocSize);
                    v83 = 0;
                    for ( allocSize_3 = 0; allocSize_3 < allocSize; ++allocSize_3 )
                    {
                      v85 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                        v383,
                                        &v436,
                                        (unsigned int)allocSize_3);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v85 + 0x100LL))(
                             *v85,
                             "value",
                             &v399) )
                      {
                        v83 = v399;
                      }
                      if ( v436 )
                        (*(void (**)(void))(*(_QWORD *)v436 + 0x28LL))();
                      *(_WORD *)(*(_QWORD *)(v18 + 0x10) + 2 * allocSize_3) = v83;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 4:
                    v86 = *(const void **)(v18 + 0x10);
                    if ( v86 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v86);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v87 = allocWithProfilerInfo_w(saturated_mul(allocSize, 4u));
                      v88 = v87;
                      v89 = *(char **)(v18 + 0x10);
                      v90 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v91 = (_DWORD *)v87;
                        do
                        {
                          ++v90;
                          *v91 = *(_DWORD *)&v89[(_QWORD)v91 - v87];
                          ++v91;
                        }
                        while ( v90 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v89);
                      *(_QWORD *)(v18 + 0x10) = v88;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    sub_1474D3190(v18, allocSize);
                    v392 = 0;
                    for ( allocSize_4 = 0; allocSize_4 < allocSize; ++allocSize_4 )
                    {
                      v93 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                        v383,
                                        &v437,
                                        (unsigned int)allocSize_4);
                      (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v93 + 0x100LL))(
                        *v93,
                        "value",
                        &v392);
                      if ( v437 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v437 + 0x28LL))(v437);
                      *(_DWORD *)(*(_QWORD *)(v18 + 0x10) + 4 * allocSize_4) = v392;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 5:
                    v94 = *(const void **)(v18 + 0x10);
                    if ( v94 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v94);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v95 = allocWithProfilerInfo_w(saturated_mul(allocSize, 8u));
                      v96 = v95;
                      v97 = *(char **)(v18 + 0x10);
                      v98 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v99 = (_QWORD *)v95;
                        do
                        {
                          ++v98;
                          *v99 = *(_QWORD *)&v97[(_QWORD)v99 - v95];
                          ++v99;
                        }
                        while ( v98 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v97);
                      *(_QWORD *)(v18 + 0x10) = v96;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    allocSize_5 = 0;
                    v425 = 0;
                    do
                    {
                      v101 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v438,
                                         (unsigned int)allocSize_5);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v101 + 0xF0LL))(
                        *v101,
                        "value",
                        &v425);
                      if ( v438 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v438 + 0x28LL))(v438);
                      *(_QWORD *)(*(_QWORD *)(v18 + 0x10) + 8 * allocSize_5++) = v425;
                    }
                    while ( allocSize_5 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 6:
                    v102 = *(const void **)(v18 + 0x10);
                    if ( v102 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v102);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v103 = allocWithProfilerInfo_w(allocSize);
                      v104 = v103;
                      v105 = *(_BYTE **)(v18 + 0x10);
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v106 = (_BYTE *)v103;
                        do
                        {
                          *v106 = v105[(_QWORD)v106 - v103];
                          ++v106;
                        }
                        while ( (unsigned __int64)&v106[-v103] < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v105);
                      *(_QWORD *)(v18 + 0x10) = v104;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    v107 = 0;
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    for ( allocSize_6 = 0; allocSize_6 < allocSize; ++allocSize_6 )
                    {
                      v109 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v439,
                                         (unsigned int)allocSize_6);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v109 + 0xF8LL))(
                             *v109,
                             "value",
                             v400) )
                      {
                        v107 = v400[0];
                      }
                      if ( v439 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v439 + 0x28LL))(v439);
                      *(_BYTE *)(allocSize_6 + *(_QWORD *)(v18 + 0x10)) = v107;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 7:
                    v110 = *(const void **)(v18 + 0x10);
                    if ( v110 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v110);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v111 = allocWithProfilerInfo_w(saturated_mul(allocSize, 2u));
                      v112 = v111;
                      v113 = *(char **)(v18 + 0x10);
                      v114 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v115 = (_WORD *)v111;
                        do
                        {
                          ++v114;
                          *v115 = *(_WORD *)&v113[(_QWORD)v115 - v111];
                          ++v115;
                        }
                        while ( v114 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v113);
                      *(_QWORD *)(v18 + 0x10) = v112;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    v116 = 0;
                    for ( allocSize_7 = 0; allocSize_7 < allocSize; ++allocSize_7 )
                    {
                      v118 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v440,
                                         (unsigned int)allocSize_7);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v118 + 0xF8LL))(
                             *v118,
                             "value",
                             &v401) )
                      {
                        v116 = v401;
                      }
                      if ( v440 )
                        (*(void (**)(void))(*(_QWORD *)v440 + 0x28LL))();
                      *(_WORD *)(*(_QWORD *)(v18 + 0x10) + 2 * allocSize_7) = v116;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 8:
                    v119 = *(const void **)(v18 + 0x10);
                    if ( v119 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v119);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v120 = allocWithProfilerInfo_w(saturated_mul(allocSize, 4u));
                      v121 = v120;
                      v122 = *(char **)(v18 + 0x10);
                      v123 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v124 = (_DWORD *)v120;
                        do
                        {
                          ++v123;
                          *v124 = *(_DWORD *)&v122[(_QWORD)v124 - v120];
                          ++v124;
                        }
                        while ( v123 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v122);
                      *(_QWORD *)(v18 + 0x10) = v121;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    allocSize_8 = 0;
                    v393 = 0;
                    do
                    {
                      v126 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v441,
                                         (unsigned int)allocSize_8);
                      (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v126 + 0xF8LL))(
                        *v126,
                        "value",
                        &v393);
                      if ( v441 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v441 + 0x28LL))(v441);
                      *(_DWORD *)(*(_QWORD *)(v18 + 0x10) + 4 * allocSize_8++) = v393;
                    }
                    while ( allocSize_8 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 9:
                    v127 = *(const void **)(v18 + 0x10);
                    if ( v127 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v127);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v128 = allocWithProfilerInfo_w(saturated_mul(allocSize, 8u));
                      v129 = v128;
                      v130 = *(char **)(v18 + 0x10);
                      v131 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v132 = (_QWORD *)v128;
                        do
                        {
                          ++v131;
                          *v132 = *(_QWORD *)&v130[(_QWORD)v132 - v128];
                          ++v132;
                        }
                        while ( v131 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v130);
                      *(_QWORD *)(v18 + 0x10) = v129;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    allocSize_9 = 0;
                    v420 = 0;
                    do
                    {
                      v134 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v442,
                                         (unsigned int)allocSize_9);
                      LOBYTE(v135) = 1;
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *, __int64))(*(_QWORD *)*v134 + 0xE8LL))(
                        *v134,
                        "value",
                        &v420,
                        v135);
                      if ( v442 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v442 + 0x28LL))(v442);
                      *(_QWORD *)(*(_QWORD *)(v18 + 0x10) + 8 * allocSize_9++) = v420;
                    }
                    while ( allocSize_9 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xA:
                    v176 = *(_QWORD *)(v18 + 0x10);
                    if ( v176 && *(_BYTE *)(v18 + 8) )
                    {
                      v177 = *(_QWORD *)(v176 - 8);
                      for ( i = v176 + 0x10 * v177; v177; --v177 )
                      {
                        i -= 0x10;
                        sub_140372C00(i);
                      }
                      sub_1402A3D30((const void *)(v176 - 8));
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v179 = 0x10 * allocSize;
                      if ( !is_mul_ok(allocSize, 0x10u) )
                        v179 = 0xFFFFFFFFFFFFFFFFuLL;
                      v180 = __CFADD__(v179, 8);
                      allocSize_10 = v179 + 8;
                      if ( v180 )
                        allocSize_10 = 0xFFFFFFFFFFFFFFFFuLL;
                      v182 = (_QWORD *)allocWithProfilerInfo_w(allocSize_10);
                      if ( v182 )
                      {
                        *v182 = allocSize;
                        allocSize_11 = allocSize;
                        v184 = v182 + 1;
                        do
                        {
                          *v184 = 0;
                          *((_BYTE *)v184 + 8) = 0;
                          v184 += 2;
                          --allocSize_11;
                        }
                        while ( allocSize_11 );
                        v185 = v182 + 1;
                      }
                      else
                      {
                        v185 = 0;
                      }
                      v186 = 0;
                      v187 = *(_QWORD *)(v18 + 0x10);
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v188 = (__int64)v185;
                        do
                        {
                          sub_140379DC0(v188, (ULONG_PTR **)(v187 - (_QWORD)v185 + v188));
                          ++v186;
                          v188 += 0x10;
                        }
                        while ( v186 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) && v187 )
                      {
                        v189 = *(_QWORD *)(v187 - 8);
                        for ( j = v187 + 0x10 * v189; v189; --v189 )
                        {
                          j -= 0x10;
                          sub_140372C00(j);
                        }
                        sub_1402A3D30((const void *)(v187 - 8));
                      }
                      allocSize = (unsigned __int64)String1;
                      *(double *)(v18 + 0x20) = *(double *)&String1;
                      *(_QWORD *)(v18 + 0x10) = v185;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    sub_1474D3270(v18, allocSize);
                    allocSize_12 = 0;
                    if ( !allocSize )
                      break;
                    v192 = 0;
                    do
                    {
                      v193 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v446,
                                         (unsigned int)allocSize_12);
                      (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v193 + 0x108LL))(
                        *v193,
                        "value",
                        &p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
                      if ( v446 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v446 + 0x28LL))(v446);
                      sub_140379DF0(v192 + *(_QWORD *)(v18 + 0x10), p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source);
                      ++allocSize_12;
                      v192 += 0x10;
                    }
                    while ( allocSize_12 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xB:
                    v136 = *(const void **)(v18 + 0x10);
                    if ( v136 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v136);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v137 = allocWithProfilerInfo_w(saturated_mul(allocSize, 4u));
                      v138 = v137;
                      v139 = *(char **)(v18 + 0x10);
                      v140 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v141 = (_DWORD *)v137;
                        do
                        {
                          ++v140;
                          *v141 = *(_DWORD *)&v139[(_QWORD)v141 - v137];
                          ++v141;
                        }
                        while ( v140 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v139);
                      *(_QWORD *)(v18 + 0x10) = v138;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    allocSize_13 = 0;
                    v394 = 0.0;
                    do
                    {
                      v143 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v443,
                                         (unsigned int)allocSize_13);
                      (*(void (__fastcall **)(_QWORD, const char *, float *))(*(_QWORD *)*v143 + 0xE0LL))(
                        *v143,
                        "value",
                        &v394);
                      if ( v443 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v443 + 0x28LL))(v443);
                      String1_3 = LODWORD(v394);
                      *(float *)(*(_QWORD *)(v18 + 0x10) + 4 * allocSize_13++) = v394;
                    }
                    while ( allocSize_13 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xC:
                    v144 = *(const void **)(v18 + 0x10);
                    if ( v144 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v144);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v145 = allocWithProfilerInfo_w(saturated_mul(allocSize, 8u));
                      v146 = v145;
                      v147 = *(char **)(v18 + 0x10);
                      v148 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v149 = (_QWORD *)v145;
                        do
                        {
                          ++v148;
                          *v149 = *(_QWORD *)&v147[(_QWORD)v149 - v145];
                          ++v149;
                        }
                        while ( v148 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v147);
                      *(_QWORD *)(v18 + 0x10) = v146;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    allocSize_14 = 0;
                    v421 = 0.0;
                    do
                    {
                      v151 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v444,
                                         (unsigned int)allocSize_14);
                      (*(void (__fastcall **)(_QWORD, const char *, double *))(*(_QWORD *)*v151 + 0xD8LL))(
                        *v151,
                        "value",
                        &v421);
                      if ( v444 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v444 + 0x28LL))(v444);
                      String1_3 = *(unsigned __int64 *)&v421;
                      *(double *)(*(_QWORD *)(v18 + 0x10) + 8 * allocSize_14++) = v421;
                    }
                    while ( allocSize_14 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xD:
                    v194 = *(_QWORD *)(v18 + 0x10);
                    if ( v194 && *(_BYTE *)(v18 + 8) )
                    {
                      v195 = *(_QWORD *)(v194 - 8);
                      for ( k = (_QWORD *)(v194 + 8 * v195); v195; --v195 )
                      {
                        k += 0xFFFFFFFF;
                        sub_140370D10(k);
                      }
                      sub_1402A3D30((const void *)(v194 - 8));
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v197 = 8 * allocSize;
                      if ( !is_mul_ok(allocSize, 8u) )
                        v197 = 0xFFFFFFFFFFFFFFFFuLL;
                      v180 = __CFADD__(v197, 8);
                      allocSize_15 = v197 + 8;
                      if ( v180 )
                        allocSize_15 = 0xFFFFFFFFFFFFFFFFuLL;
                      v199 = (_QWORD *)allocWithProfilerInfo_w(allocSize_15);
                      v200 = v199;
                      if ( v199 )
                      {
                        *v199 = allocSize;
                        allocSize_16 = allocSize;
                        v202 = v199 + 1;
                        do
                        {
                          sub_14035B3E0(v202++);
                          --allocSize_16;
                        }
                        while ( allocSize_16 );
                        v203 = (char **)(v200 + 1);
                      }
                      else
                      {
                        v203 = 0;
                      }
                      v204 = 0;
                      v205 = *(_QWORD *)(v18 + 0x10);
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v206 = v203;
                        do
                        {
                          copyStringStructure(v206, (char **)((char *)v206 + v205 - (_QWORD)v203));
                          ++v204;
                          ++v206;
                        }
                        while ( v204 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) && v205 )
                      {
                        v207 = *(_QWORD *)(v205 - 8);
                        for ( m = (_QWORD *)(v205 + 8 * v207); v207; --v207 )
                        {
                          m += 0xFFFFFFFF;
                          sub_140370D10(m);
                        }
                        sub_1402A3D30((const void *)(v205 - 8));
                      }
                      allocSize = (unsigned __int64)String1;
                      *(double *)(v18 + 0x20) = *(double *)&String1;
                      *(_QWORD *)(v18 + 0x10) = v203;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    sub_1474D33E0(v18, allocSize);
                    allocSize_17 = 0;
                    if ( !allocSize )
                      break;
                    do
                    {
                      v210 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v448,
                                         (unsigned int)allocSize_17);
                      (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v210 + 0x108LL))(
                        *v210,
                        "value",
                        &v449);
                      if ( v448 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v448 + 0x28LL))(v448);
                      if ( v449 && *v449 == 0x40 )
                        assignCStringToStringStructure((void **)(*(_QWORD *)(v18 + 0x10) + 8 * allocSize_17), v449);
                      ++allocSize_17;
                    }
                    while ( allocSize_17 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xE:
                    v211 = *(const void **)(v18 + 0x10);
                    if ( v211 && *(_BYTE *)(v18 + 8) )
                    {
                      sub_1402A3D30(v211);
                      *(_QWORD *)(v18 + 0x18) = 0;
                      *(_QWORD *)(v18 + 0x20) = 0;
                      *(_QWORD *)(v18 + 0x10) = 0;
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                    {
                      v212 = allocWithProfilerInfo_w(saturated_mul(allocSize, 0x10u));
                      v213 = *(char **)(v18 + 0x10);
                      v214 = 0;
                      if ( *(_QWORD *)(v18 + 0x18) )
                      {
                        v215 = (_OWORD *)v212;
                        do
                        {
                          *v215 = *(_OWORD *)&v213[(_QWORD)v215 - v212];
                          ++v214;
                          ++v215;
                        }
                        while ( v214 < *(_QWORD *)(v18 + 0x18) );
                      }
                      if ( *(_BYTE *)(v18 + 8) )
                        sub_1402A3D30(v213);
                      *(_QWORD *)(v18 + 0x10) = v212;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                    }
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    allocSize_18 = 0;
                    v217 = 0;
                    do
                    {
                      v218 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v450,
                                         (unsigned int)allocSize_18);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v218 + 0x108LL))(
                        *v218,
                        "value",
                        &v451);
                      if ( v450 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v450 + 0x28LL))(v450);
                      v219 = sub_1402BC380(&v508, v451);
                      ++allocSize_18;
                      String1_3 = *(_OWORD *)v219;
                      *(_OWORD *)(*(_QWORD *)(v18 + 0x10) + v217) = *(_OWORD *)v219;
                      v217 += 0x10;
                    }
                    while ( allocSize_18 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xF:
                    v152 = v17;
                    v554[0] = 0;
                    v11 = (__int64)a1;
                    v553 = v554;
                    v551 = 0;
                    n0x1FF = 0x1FF;
                    sub_1474A4630((__int64)a1, (__int64)&v551, (__int64)s1, v152);
                    v153 = *(_QWORD *)(v18 + 0x28);
                    if ( v153 == 1 )
                    {
                      v166 = *(const void **)(v18 + 0x10);
                      if ( v166 && *(_BYTE *)(v18 + 8) )
                      {
                        sub_1402A3D30(v166);
                        *(_QWORD *)(v18 + 0x18) = 0;
                        *(_QWORD *)(v18 + 0x20) = 0;
                        *(_QWORD *)(v18 + 0x10) = 0;
                        *(_BYTE *)(v18 + 8) = 0;
                      }
                      if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                      {
                        v167 = allocWithProfilerInfo_w(allocSize);
                        v168 = v167;
                        v169 = *(_BYTE **)(v18 + 0x10);
                        if ( *(_QWORD *)(v18 + 0x18) )
                        {
                          v170 = (_BYTE *)v167;
                          do
                          {
                            *v170 = v169[(_QWORD)v170 - v167];
                            ++v170;
                          }
                          while ( (unsigned __int64)&v170[-v167] < *(_QWORD *)(v18 + 0x18) );
                        }
                        if ( *(_BYTE *)(v18 + 8) )
                          sub_1402A3D30(v169);
                        *(_QWORD *)(v18 + 0x10) = v168;
                        *(_QWORD *)(v18 + 0x20) = allocSize;
                        *(_BYTE *)(v18 + 8) = 1;
                      }
                      sub_1474D2FE0(v18, allocSize);
                    }
                    else if ( *(_QWORD *)(v18 + 0x28) == 2 )
                    {
                      v160 = *(const void **)(v18 + 0x10);
                      if ( v160 && *(_BYTE *)(v18 + 8) )
                      {
                        sub_1402A3D30(v160);
                        *(_QWORD *)(v18 + 0x18) = 0;
                        *(_QWORD *)(v18 + 0x20) = 0;
                        *(_QWORD *)(v18 + 0x10) = 0;
                        *(_BYTE *)(v18 + 8) = 0;
                      }
                      if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                      {
                        v161 = allocWithProfilerInfo_w(saturated_mul(allocSize, 2u));
                        v162 = v161;
                        v163 = *(char **)(v18 + 0x10);
                        v164 = 0;
                        if ( *(_QWORD *)(v18 + 0x18) )
                        {
                          v165 = (_WORD *)v161;
                          do
                          {
                            ++v164;
                            *v165 = *(_WORD *)&v163[(_QWORD)v165 - v161];
                            ++v165;
                          }
                          while ( v164 < *(_QWORD *)(v18 + 0x18) );
                        }
                        if ( *(_BYTE *)(v18 + 8) )
                          sub_1402A3D30(v163);
                        *(_QWORD *)(v18 + 0x10) = v162;
                        *(_QWORD *)(v18 + 0x20) = allocSize;
                        *(_BYTE *)(v18 + 8) = 1;
                      }
                      sub_1474D30B0(v18, allocSize);
                    }
                    else if ( *(_QWORD *)(v18 + 0x28) == 4 )
                    {
                      v154 = *(const void **)(v18 + 0x10);
                      if ( v154 && *(_BYTE *)(v18 + 8) )
                      {
                        sub_1402A3D30(v154);
                        *(_QWORD *)(v18 + 0x18) = 0;
                        *(_QWORD *)(v18 + 0x20) = 0;
                        *(_QWORD *)(v18 + 0x10) = 0;
                        *(_BYTE *)(v18 + 8) = 0;
                      }
                      if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                      {
                        v155 = allocWithProfilerInfo_w(saturated_mul(allocSize, 4u));
                        v156 = v155;
                        v157 = *(char **)(v18 + 0x10);
                        v158 = 0;
                        if ( *(_QWORD *)(v18 + 0x18) )
                        {
                          v159 = (_DWORD *)v155;
                          do
                          {
                            ++v158;
                            *v159 = *(_DWORD *)&v157[(_QWORD)v159 - v155];
                            ++v159;
                          }
                          while ( v158 < *(_QWORD *)(v18 + 0x18) );
                        }
                        if ( *(_BYTE *)(v18 + 8) )
                          sub_1402A3D30(v157);
                        *(_QWORD *)(v18 + 0x10) = v156;
                        *(_QWORD *)(v18 + 0x20) = allocSize;
                        *(_BYTE *)(v18 + 8) = 1;
                      }
                      sub_1474D3190(v18, allocSize);
                    }
                    sub_14035B3E0(&String1_6);
                    for ( allocSize_19 = 0; allocSize_19 < allocSize; ++allocSize_19 )
                    {
                      v172 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v445,
                                         (unsigned int)allocSize_19);
                      (*(void (__fastcall **)(_QWORD, const char *, const char **))(*(_QWORD *)*v172 + 0x80LL))(
                        *v172,
                        "value",
                        &String1_6);
                      if ( v445 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v445 + 0x28LL))(v445);
                      v173 = sub_1474A1490((__int64)a1, v553, String1_6);
                      switch ( v153 )
                      {
                        case 1LL:
                          *(_BYTE *)(allocSize_19 + *(_QWORD *)(v18 + 0x10)) = v173;
                          break;
                        case 2LL:
                          *(_WORD *)(*(_QWORD *)(v18 + 0x10) + 2 * allocSize_19) = v173;
                          break;
                        case 4LL:
                          *(_DWORD *)(*(_QWORD *)(v18 + 0x10) + 4 * allocSize_19) = v173;
                          break;
                      }
                    }
                    sub_140370D10(&String1_6);
                    v174 = v553;
                    if ( v553 == v554 )
                      goto LABEL_767;
                    v175 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
                    goto LABEL_339;
                  case 0x10:
                    if ( !(_BYTE)n3 )
                    {
                      v282 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v454,
                                         0);
                      v283 = (*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*v282 + 0x110LL))(
                               *v282,
                               "__type");
                      if ( v454 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v454 + 0x28LL))(v454);
                      v11 = (__int64)a1;
                      v284 = DataCore::LookupDCStructDescByName((__int64)a1, v283);
                      if ( v284 )
                      {
                        v285 = (_QWORD *)(v284 + 0x10);
                        if ( *(_BYTE *)(v18 + 8) )
                          (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v285 + 8LL))(
                            *v285,
                            *(_QWORD *)(v18 + 0x10));
                        v8 = a4;
                        *(_QWORD *)(v18 + 0x10) = (**(__int64 (__fastcall ***)(_QWORD, unsigned __int64))*v285)(
                                                    *v285,
                                                    allocSize);
                        allocSize_20 = 0;
                        *(_QWORD *)(v18 + 0x18) = allocSize;
                        *(_QWORD *)(v18 + 0x20) = allocSize;
                        *(_BYTE *)(v18 + 8) = 1;
                        do
                        {
                          (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                            v383,
                            &v424,
                            (unsigned int)allocSize_20);
                          v287 = *(_QWORD *)(v18 + 0x10) + *(_QWORD *)(v18 + 0x28) * allocSize_20;
                          sub_1474CFE80(a1, v287, v288);
                          sub_1474B8180((_DWORD)a1, v287, (unsigned int)&v424, (_DWORD)a4, v387);
                          if ( v424 )
                            (*(void (__fastcall **)(__int64))(*(_QWORD *)v424 + 0x28LL))(v424);
                          ++allocSize_20;
                        }
                        while ( allocSize_20 < allocSize );
                        goto LABEL_768;
                      }
                      goto LABEL_767;
                    }
                    if ( n3 == 1 )
                    {
                      if ( *(_BYTE *)(v18 + 8) )
                      {
                        v269 = *(_QWORD **)(v18 + 0x10);
                        if ( v269 )
                          sub_1474893E0(v269, 3);
                        *(_BYTE *)(v18 + 8) = 0;
                      }
                      v270 = 0x10 * allocSize;
                      if ( !is_mul_ok(allocSize, 0x10u) )
                        v270 = 0xFFFFFFFFFFFFFFFFuLL;
                      v180 = __CFADD__(v270, 8);
                      allocSize_21 = v270 + 8;
                      if ( v180 )
                        allocSize_21 = 0xFFFFFFFFFFFFFFFFuLL;
                      v272 = (_QWORD *)allocWithProfilerInfo_w(allocSize_21);
                      v273 = v272;
                      if ( v272 )
                      {
                        *v272 = allocSize;
                        allocSize_22 = allocSize;
                        v275 = (__int64)(v272 + 1);
                        do
                        {
                          sub_140362C90(v275);
                          v275 += 0x10;
                          --allocSize_22;
                        }
                        while ( allocSize_22 );
                        v276 = v273 + 1;
                      }
                      else
                      {
                        v276 = 0;
                      }
                      v11 = (__int64)a1;
                      allocSize_23 = 0;
                      *(_QWORD *)(v18 + 0x10) = v276;
                      *(_QWORD *)(v18 + 0x18) = allocSize;
                      *(_QWORD *)(v18 + 0x20) = allocSize;
                      *(_BYTE *)(v18 + 8) = 1;
                      v278 = v387;
                      do
                      {
                        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                          v383,
                          &v412,
                          (unsigned int)allocSize_23);
                        v279 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v412 + 0x110LL))(
                                 v412,
                                 "__type");
                        LOBYTE(v280) = 1;
                        v281 = sub_1474C4090(
                                 a1,
                                 *(_QWORD *)(v18 + 0x10) + *(_QWORD *)(v18 + 0x28) * allocSize_23,
                                 v279,
                                 v280);
                        if ( v281 )
                          sub_1474B8180((_DWORD)a1, v281, (unsigned int)&v412, (_DWORD)a4, v278);
                        if ( v412 )
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v412 + 0x28LL))(v412);
                        ++allocSize_23;
                      }
                      while ( allocSize_23 < allocSize );
                      v8 = a4;
                      goto LABEL_768;
                    }
                    if ( n3 != 2 )
                    {
                      if ( n3 != 3 )
                        goto LABEL_766;
                      v220 = *(const void **)(v18 + 0x10);
                      if ( v220 && *(_BYTE *)(v18 + 8) )
                      {
                        sub_1402A3D30(v220);
                        *(_QWORD *)(v18 + 0x18) = 0;
                        *(_QWORD *)(v18 + 0x20) = 0;
                        *(_QWORD *)(v18 + 0x10) = 0;
                        *(_BYTE *)(v18 + 8) = 0;
                      }
                      if ( allocSize > *(_QWORD *)(v18 + 0x20) )
                      {
                        v221 = allocWithProfilerInfo_w(saturated_mul(allocSize, 0x18u));
                        v222 = v221;
                        if ( v221 )
                        {
                          allocSize_24 = allocSize;
                          v224 = (_QWORD *)v221;
                          do
                          {
                            sub_140361E00(v224);
                            v224 += 3;
                            --allocSize_24;
                          }
                          while ( allocSize_24 );
                        }
                        else
                        {
                          v222 = 0;
                        }
                        v225 = 0;
                        v226 = *(char **)(v18 + 0x10);
                        if ( *(_QWORD *)(v18 + 0x18) )
                        {
                          v227 = v222;
                          v228 = &v226[-v222];
                          do
                          {
                            *(_OWORD *)v227 = *(_OWORD *)&v228[v227];
                            *(double *)(v227 + 0x10) = *(double *)&v228[v227 + 0x10];
                            ++v225;
                            v227 += 0x18;
                          }
                          while ( v225 < *(_QWORD *)(v18 + 0x18) );
                        }
                        if ( *(_BYTE *)(v18 + 8) )
                          sub_1402A3D30(v226);
                        *(_QWORD *)(v18 + 0x10) = v222;
                        *(_QWORD *)(v18 + 0x20) = allocSize;
                        *(_BYTE *)(v18 + 8) = 1;
                      }
                      *(_QWORD *)(v18 + 0x18) = allocSize;
                      allocSize_25 = 0;
                      v230 = 0;
                      do
                      {
                        v231 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383
                                                                                               + 0x160LL))(
                                           v383,
                                           &v452,
                                           (unsigned int)allocSize_25);
                        (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v231 + 0x108LL))(
                          *v231,
                          "value",
                          &v453);
                        if ( v452 )
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v452 + 0x28LL))(v452);
                        v232 = sub_1402BC380(&v509, v453);
                        v233 = *(_QWORD *)(v18 + 0x10);
                        String1_3 = *(_OWORD *)v232;
                        String1_7 = *(_OWORD *)v232;
                        v234 = (__int64 (__fastcall ***)(_QWORD))sub_1403B6150(a1, &String1_7);
                        if ( v234 )
                        {
                          *((_QWORD *)&String1_3 + 1) = *((_QWORD *)&String1_7 + 1);
                          *(_OWORD *)(v230 + v233) = String1_7;
                          v234 = (__int64 (__fastcall ***)(_QWORD))(**v234)(v234);
                        }
                        else
                        {
                          *(_QWORD *)(v230 + v233) = 0;
                          *(_QWORD *)(v230 + v233 + 8) = 0;
                        }
                        *(_QWORD *)(v230 + v233 + 0x10) = v234;
                        ++allocSize_25;
                        v230 += 0x18;
                      }
                      while ( allocSize_25 < allocSize );
                      v11 = (__int64)a1;
                      goto LABEL_767;
                    }
                    v518[0] = 0;
                    n0x1FF_4 = 0;
                    v517 = v518;
                    v525 = v526;
                    n0x1FF_1 = 0x1FF;
                    v526[0] = 0;
                    n0x1FF_12 = 0;
                    n0x1FF_2 = 0x1FF;
                    if ( *(_BYTE *)(v18 + 8) )
                    {
                      v235 = *(_QWORD **)(v18 + 0x10);
                      if ( v235 )
                        sub_1474893E0(v235, 3);
                      *(_BYTE *)(v18 + 8) = 0;
                    }
                    n0x1FF_3 = 0xFFFFFFFFFFFFFFFFuLL;
                    v237 = 0x10 * allocSize;
                    if ( !is_mul_ok(allocSize, 0x10u) )
                      v237 = 0xFFFFFFFFFFFFFFFFuLL;
                    v180 = __CFADD__(v237, 8);
                    allocSize_26 = v237 + 8;
                    if ( v180 )
                      allocSize_26 = 0xFFFFFFFFFFFFFFFFuLL;
                    v239 = (_QWORD *)allocWithProfilerInfo_w(allocSize_26);
                    v240 = v239;
                    if ( v239 )
                    {
                      *v239 = allocSize;
                      allocSize_27 = allocSize;
                      v242 = (__int64)(v239 + 1);
                      do
                      {
                        sub_140362C90(v242);
                        v242 += 0x10;
                        --allocSize_27;
                      }
                      while ( allocSize_27 );
                      v243 = v240 + 1;
                      n0x1FF_3 = 0xFFFFFFFFFFFFFFFFuLL;
                    }
                    else
                    {
                      v243 = 0;
                    }
                    *(_QWORD *)(v18 + 0x10) = v243;
                    String1_2 = 0;
                    *(_QWORD *)(v18 + 0x18) = allocSize;
                    *(_QWORD *)(v18 + 0x20) = allocSize;
                    *(_BYTE *)(v18 + 8) = 1;
                    do
                    {
                      ++*a4;
                      (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                        v383,
                        &v423,
                        (unsigned int)String1_2);
                      v245 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v423 + 0x110LL))(
                               v423,
                               "value");
                      v246 = (const void *)v245;
                      if ( v245 )
                      {
                        do
                          ++n0x1FF_3;
                        while ( *(_BYTE *)(v245 + n0x1FF_3) );
                        if ( n0x1FF_3 > n0x1FF_1 )
                        {
                          if ( v517 != v518 )
                          {
                            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
                            sub_147605980(v517);
                          }
                          v518[0] = 0;
                          v517 = v518;
                          n0x1FF_4 = 0;
                          n0x1FF_1 = 0x1FF;
                          if ( n0x1FF_3 )
                          {
                            v247 = v518;
                            if ( n0x1FF_3 + 1 > 0x200 )
                            {
                              v247 = (char *)allocWithProfilerInfo(n0x1FF_3 + 1, 0);
                              qword_149B3AB68 += n0x1FF_3 + 1;
                              n0x1FF_1 = n0x1FF_3;
                            }
                            n0x1FF_4 = n0x1FF_3;
                            v517 = v247;
                            v247[n0x1FF_3] = 0;
                          }
                        }
                      }
                      else
                      {
                        n0x1FF_3 = 0;
                      }
                      memmove(v517, v246, n0x1FF_3);
                      n0x1FF_4 = n0x1FF_3;
                      v517[n0x1FF_3] = 0;
                      v248 = v517;
                      n0x1FF_5 = n0x1FF_4;
                      v250 = v517;
                      v251 = &v517[n0x1FF_4];
                      if ( v517 >= &v517[n0x1FF_4]
                        || (v517
                          ? (n0x1FF_11 = strspn(v517, "."), v248 = v517, n0x1FF_10 = n0x1FF_11, n0x1FF_5 = n0x1FF_4)
                          : (n0x1FF_10 = 0),
                            v254 = &v250[n0x1FF_10],
                            v254 >= v251) )
                      {
                        Src[0] = 0;
                        n0x1FF_8 = 0;
                        p_Src = Src;
                        n0x1FF_6 = 0x1FF;
                        v257 = 0xFFFFFFFF;
                        p_Src_1 = Src;
                        n0x1FF_9 = 0;
                      }
                      else
                      {
                        if ( v254 )
                        {
                          n0x1FF_20 = strcspn(&v250[n0x1FF_10], ".");
                          v248 = v517;
                          n0x1FF_5 = n0x1FF_4;
                        }
                        else
                        {
                          n0x1FF_20 = 0;
                        }
                        n0x1FF_7 = n0x1FF_20;
                        v257 = n0x1FF_10 + n0x1FF_20 + 1;
                        if ( n0x1FF_10 < n0x1FF_5 )
                        {
                          if ( n0x1FF_20 == 0xFFFFFFFFFFFFFFFFuLL )
                            n0x1FF_7 = n0x1FF_5 - n0x1FF_10;
                          if ( n0x1FF_7 + n0x1FF_10 > n0x1FF_5 )
                            n0x1FF_7 = n0x1FF_5 - n0x1FF_10;
                          v260 = &v248[n0x1FF_10];
                          Src[0] = 0;
                          n0x1FF_6 = 0x1FF;
                          n0x1FF_8 = 0;
                          p_Src = Src;
                          p_Src_1 = Src;
                          n0x1FF_9 = 0;
                          if ( n0x1FF_7 )
                          {
                            p_Src_2 = Src;
                            if ( n0x1FF_7 + 1 > 0x200 )
                            {
                              p_Src_2 = (_BYTE *)allocWithProfilerInfo(n0x1FF_7 + 1, 0);
                              qword_149B3AB68 += n0x1FF_7 + 1;
                              n0x1FF_6 = n0x1FF_7;
                            }
                            p_Src_1 = p_Src_2;
                            n0x1FF_8 = n0x1FF_7;
                            p_Src_2[n0x1FF_7] = 0;
                            memcpy(p_Src_1, v260, n0x1FF_7);
                            p_Src = p_Src_1;
                            n0x1FF_9 = n0x1FF_8;
                          }
                        }
                        else
                        {
                          Src[0] = 0;
                          p_Src = Src;
                          n0x1FF_8 = 0;
                          p_Src_1 = Src;
                          n0x1FF_9 = 0;
                          n0x1FF_6 = 0x1FF;
                        }
                      }
                      if ( n0x1FF_9 > n0x1FF_2 )
                      {
                        if ( v525 != v526 )
                        {
                          qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_2;
                          sub_147605980(v525);
                        }
                        v526[0] = 0;
                        v525 = v526;
                        n0x1FF_12 = 0;
                        n0x1FF_2 = 0x1FF;
                        if ( n0x1FF_9 )
                        {
                          v262 = v526;
                          if ( n0x1FF_9 + 1 > 0x200 )
                          {
                            v262 = (_BYTE *)allocWithProfilerInfo(n0x1FF_9 + 1, 0);
                            qword_149B3AB68 += n0x1FF_9 + 1;
                            n0x1FF_2 = n0x1FF_9;
                          }
                          n0x1FF_12 = n0x1FF_9;
                          v525 = v262;
                          v262[n0x1FF_9] = 0;
                        }
                      }
                      memmove(v525, p_Src, n0x1FF_9);
                      n0x1FF_12 = n0x1FF_9;
                      *((_BYTE *)v525 + n0x1FF_9) = 0;
                      if ( p_Src_1 != Src )
                      {
                        qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_6;
                        sub_147605980(p_Src_1);
                      }
                      v263 = &v517[v257];
                      v264 = *(_QWORD *)(v18 + 0x10) + *(_QWORD *)(v18 + 0x28) * String1_2;
                      CreateStringObjectFromString(&v422, (const char *)v525);
                      v265 = (unsigned __int64 *)sub_143429A20((__int64)(a4 + 1), (__int64 *)&v422);
                      sub_140370D10(&v422);
                      v429 = v264;
                      CreateStringObjectFromString(&v430, v263);
                      v266 = v265[1];
                      if ( v266 == v265[2] )
                      {
                        sub_14747A5F0(v265, (_QWORD *)v266, (__int64)&v429);
                      }
                      else
                      {
                        *(_QWORD *)v266 = v429;
                        sub_14035B160((void **)(v266 + 8), (const void **)&v430);
                        v265[1] += 0x10LL;
                      }
                      sub_140370D10(&v430);
                      if ( v423 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v423 + 0x28LL))(v423);
                      n0x1FF_3 = 0xFFFFFFFFFFFFFFFFuLL;
                      ++String1_2;
                    }
                    while ( String1_2 < (unsigned __int64)String1 );
                    if ( v525 != v526 )
                    {
                      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_2;
                      sub_147605980(v525);
                    }
                    v267 = v517;
                    if ( v517 != v518 )
                    {
                      v268 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
                      goto LABEL_506;
                    }
                    break;
                  default:
                    goto LABEL_766;
                }
              }
              else
              {
                LODWORD(v385) = 0;
                switch ( n0x10 )
                {
                  case 1:
                    v384[0] = 0;
                    for ( allocSize_28 = 0; allocSize_28 < allocSize; ++allocSize_28 )
                    {
                      v290 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v455,
                                         (unsigned int)allocSize_28);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v290 + 0x100LL))(
                        *v290,
                        "__index",
                        &v385);
                      if ( v455 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v455 + 0x28LL))(v455);
                      v291 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v456,
                                         (unsigned int)allocSize_28);
                      (*(void (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v291 + 0x90LL))(
                        *v291,
                        "value",
                        v384);
                      if ( v456 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v456 + 0x28LL))(v456);
                      if ( (int)v385 < v61 )
                        *(_BYTE *)((int)v385 + *(_QWORD *)(v18 + 0x10)) = v384[0];
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 2:
                    v292 = 0;
                    for ( allocSize_29 = 0; allocSize_29 < allocSize; ++allocSize_29 )
                    {
                      v294 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v457,
                                         (unsigned int)allocSize_29);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v294 + 0x100LL))(
                        *v294,
                        "__index",
                        &v385);
                      if ( v457 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v457 + 0x28LL))(v457);
                      v295 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v458,
                                         (unsigned int)allocSize_29);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v295
                                                                                              + 0x100LL))(
                             *v295,
                             "value",
                             v402) )
                      {
                        v292 = v402[0];
                      }
                      if ( v458 )
                        (*(void (**)(void))(*(_QWORD *)v458 + 0x28LL))();
                      if ( (int)v385 < v61 )
                        *(_BYTE *)((int)v385 + *(_QWORD *)(v18 + 0x10)) = v292;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 3:
                    v296 = 0;
                    for ( allocSize_30 = 0; allocSize_30 < allocSize; ++allocSize_30 )
                    {
                      v298 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v459,
                                         (unsigned int)allocSize_30);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v298 + 0x100LL))(
                        *v298,
                        "__index",
                        &v385);
                      if ( v459 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v459 + 0x28LL))(v459);
                      v299 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v460,
                                         (unsigned int)allocSize_30);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v299
                                                                                              + 0x100LL))(
                             *v299,
                             "value",
                             &v403) )
                      {
                        v296 = v403;
                      }
                      if ( v460 )
                        (*(void (**)(void))(*(_QWORD *)v460 + 0x28LL))();
                      if ( (int)v385 < v61 )
                        *(_WORD *)(*(_QWORD *)(v18 + 0x10) + 2LL * (int)v385) = v296;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 4:
                    LODWORD(String1) = 0;
                    for ( allocSize_31 = 0; allocSize_31 < allocSize; ++allocSize_31 )
                    {
                      v301 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v461,
                                         (unsigned int)allocSize_31);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v301 + 0x100LL))(
                        *v301,
                        "__index",
                        &v385);
                      if ( v461 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v461 + 0x28LL))(v461);
                      v302 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v462,
                                         (unsigned int)allocSize_31);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v302 + 0x100LL))(
                        *v302,
                        "value",
                        &String1);
                      if ( v462 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v462 + 0x28LL))(v462);
                      if ( (int)v385 < v61 )
                        *(_DWORD *)(*(_QWORD *)(v18 + 0x10) + 4LL * (int)v385) = (_DWORD)String1;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 5:
                    *(double *)&String1 = 0.0;
                    for ( allocSize_32 = 0; allocSize_32 < allocSize; ++allocSize_32 )
                    {
                      v304 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v463,
                                         (unsigned int)allocSize_32);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v304 + 0x100LL))(
                        *v304,
                        "__index",
                        &v385);
                      if ( v463 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v463 + 0x28LL))(v463);
                      v305 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v464,
                                         (unsigned int)allocSize_32);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v305 + 0xF0LL))(
                        *v305,
                        "value",
                        &String1);
                      if ( v464 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v464 + 0x28LL))(v464);
                      if ( (int)v385 < v61 )
                        *(double *)(*(_QWORD *)(v18 + 0x10) + 8LL * (int)v385) = *(double *)&String1;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 6:
                    v306 = 0;
                    for ( allocSize_33 = 0; allocSize_33 < allocSize; ++allocSize_33 )
                    {
                      v308 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v465,
                                         (unsigned int)allocSize_33);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v308 + 0x100LL))(
                        *v308,
                        "__index",
                        &v385);
                      if ( v465 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v465 + 0x28LL))(v465);
                      v309 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v466,
                                         (unsigned int)allocSize_33);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v309 + 0xF8LL))(
                             *v309,
                             "value",
                             v404) )
                      {
                        v306 = v404[0];
                      }
                      if ( v466 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v466 + 0x28LL))(v466);
                      if ( (int)v385 < v61 )
                        *(_BYTE *)((int)v385 + *(_QWORD *)(v18 + 0x10)) = v306;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 7:
                    v310 = 0;
                    for ( allocSize_34 = 0; allocSize_34 < allocSize; ++allocSize_34 )
                    {
                      v312 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v467,
                                         (unsigned int)allocSize_34);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v312 + 0x100LL))(
                        *v312,
                        "__index",
                        &v385);
                      if ( v467 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v467 + 0x28LL))(v467);
                      v313 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v468,
                                         (unsigned int)allocSize_34);
                      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v313 + 0xF8LL))(
                             *v313,
                             "value",
                             &v405) )
                      {
                        v310 = v405;
                      }
                      if ( v468 )
                        (*(void (**)(void))(*(_QWORD *)v468 + 0x28LL))();
                      if ( (int)v385 < v61 )
                        *(_WORD *)(*(_QWORD *)(v18 + 0x10) + 2LL * (int)v385) = v310;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 8:
                    LODWORD(String1) = 0;
                    for ( allocSize_35 = 0; allocSize_35 < allocSize; ++allocSize_35 )
                    {
                      v315 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v469,
                                         (unsigned int)allocSize_35);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v315 + 0x100LL))(
                        *v315,
                        "__index",
                        &v385);
                      if ( v469 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v469 + 0x28LL))(v469);
                      v316 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v470,
                                         (unsigned int)allocSize_35);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v316 + 0xF8LL))(
                        *v316,
                        "value",
                        &String1);
                      if ( v470 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v470 + 0x28LL))(v470);
                      if ( (int)v385 < v61 )
                        *(_DWORD *)(*(_QWORD *)(v18 + 0x10) + 4LL * (int)v385) = (_DWORD)String1;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 9:
                    *(double *)&String1 = 0.0;
                    for ( allocSize_36 = 0; allocSize_36 < allocSize; ++allocSize_36 )
                    {
                      v318 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v471,
                                         (unsigned int)allocSize_36);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v318 + 0x100LL))(
                        *v318,
                        "__index",
                        &v385);
                      if ( v471 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v471 + 0x28LL))(v471);
                      v319 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v472,
                                         (unsigned int)allocSize_36);
                      LOBYTE(v320) = 1;
                      (*(void (__fastcall **)(_QWORD, const char *, char **, __int64))(*(_QWORD *)*v319 + 0xE8LL))(
                        *v319,
                        "value",
                        &String1,
                        v320);
                      if ( v472 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v472 + 0x28LL))(v472);
                      if ( (int)v385 < v61 )
                        *(double *)(*(_QWORD *)(v18 + 0x10) + 8LL * (int)v385) = *(double *)&String1;
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xA:
                    for ( allocSize_37 = 0; allocSize_37 < allocSize; ++allocSize_37 )
                    {
                      v334 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v479,
                                         (unsigned int)allocSize_37);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v334 + 0x100LL))(
                        *v334,
                        "__index",
                        &v385);
                      if ( v479 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v479 + 0x28LL))(v479);
                      v335 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v480,
                                         (unsigned int)allocSize_37);
                      (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v335 + 0x108LL))(
                        *v335,
                        "value",
                        &p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
                      if ( v480 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v480 + 0x28LL))(v480);
                      if ( (int)v385 < v61 )
                        sub_140379DF0(
                          *(_QWORD *)(v18 + 0x10) + 0x10LL * (int)v385,
                          p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xB:
                    allocSize_38 = 0;
                    *(float *)&String1 = 0.0;
                    do
                    {
                      v322 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v473,
                                         (unsigned int)allocSize_38);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v322 + 0x100LL))(
                        *v322,
                        "__index",
                        &v385);
                      if ( v473 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v473 + 0x28LL))(v473);
                      v323 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v474,
                                         (unsigned int)allocSize_38);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v323 + 0xE0LL))(
                        *v323,
                        "value",
                        &String1);
                      if ( v474 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v474 + 0x28LL))(v474);
                      if ( (int)v385 < v61 )
                      {
                        String1_3 = (unsigned int)String1;
                        *(float *)(*(_QWORD *)(v18 + 0x10) + 4LL * (int)v385) = *(float *)&String1;
                      }
                      ++allocSize_38;
                    }
                    while ( allocSize_38 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xC:
                    allocSize_39 = 0;
                    *(double *)&String1 = 0.0;
                    do
                    {
                      v325 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v475,
                                         (unsigned int)allocSize_39);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v325 + 0x100LL))(
                        *v325,
                        "__index",
                        &v385);
                      if ( v475 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v475 + 0x28LL))(v475);
                      v326 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v476,
                                         (unsigned int)allocSize_39);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v326 + 0xD8LL))(
                        *v326,
                        "value",
                        &String1);
                      if ( v476 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v476 + 0x28LL))(v476);
                      if ( (int)v385 < v61 )
                      {
                        String1_3 = (unsigned __int64)String1;
                        *(double *)(*(_QWORD *)(v18 + 0x10) + 8LL * (int)v385) = *(double *)&String1;
                      }
                      ++allocSize_39;
                    }
                    while ( allocSize_39 < allocSize );
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xD:
                    for ( allocSize_40 = 0; allocSize_40 < allocSize; ++allocSize_40 )
                    {
                      v337 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v482,
                                         (unsigned int)allocSize_40);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v337 + 0x100LL))(
                        *v337,
                        "__index",
                        &v385);
                      if ( v482 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v482 + 0x28LL))(v482);
                      v338 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v483,
                                         (unsigned int)allocSize_40);
                      (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v338 + 0x108LL))(
                        *v338,
                        "value",
                        &v484);
                      if ( v483 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v483 + 0x28LL))(v483);
                      if ( (int)v385 < v61 && v484 && *v484 == 0x40 )
                        assignCStringToStringStructure((void **)(*(_QWORD *)(v18 + 0x10) + 8LL * (int)v385), v484);
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xE:
                    for ( allocSize_41 = 0; allocSize_41 < allocSize; ++allocSize_41 )
                    {
                      v340 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v485,
                                         (unsigned int)allocSize_41);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v340 + 0x100LL))(
                        *v340,
                        "__index",
                        &v385);
                      if ( v485 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v485 + 0x28LL))(v485);
                      v341 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v486,
                                         (unsigned int)allocSize_41);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v341 + 0x108LL))(
                        *v341,
                        "value",
                        &v487);
                      if ( v486 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v486 + 0x28LL))(v486);
                      v342 = (int)v385;
                      if ( (int)v385 < v61 )
                      {
                        v343 = sub_1402BC380(&v510, v487);
                        String1_3 = *(_OWORD *)v343;
                        *(_OWORD *)(*(_QWORD *)(v18 + 0x10) + 0x10 * v342) = *(_OWORD *)v343;
                      }
                    }
                    v11 = (__int64)a1;
                    goto LABEL_767;
                  case 0xF:
                    v327 = v17;
                    v558[0] = 0;
                    v11 = (__int64)a1;
                    v557 = v558;
                    v555 = 0;
                    n0x1FF_13 = 0x1FF;
                    sub_1474A4630((__int64)a1, (__int64)&v555, (__int64)s1, v327);
                    sub_14035B3E0(&String1_8);
                    v328 = *(_QWORD *)(v18 + 0x28);
                    for ( allocSize_42 = 0; allocSize_42 < allocSize; ++allocSize_42 )
                    {
                      v330 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v477,
                                         (unsigned int)allocSize_42);
                      (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v330 + 0x100LL))(
                        *v330,
                        "__index",
                        &v385);
                      if ( v477 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v477 + 0x28LL))(v477);
                      v331 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v478,
                                         (unsigned int)allocSize_42);
                      (*(void (__fastcall **)(_QWORD, const char *, const char **))(*(_QWORD *)*v331 + 0x80LL))(
                        *v331,
                        "value",
                        &String1_8);
                      if ( v478 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v478 + 0x28LL))(v478);
                      if ( (int)v385 < v61 )
                      {
                        v332 = sub_1474A1490((__int64)a1, v557, String1_8);
                        switch ( v328 )
                        {
                          case 1LL:
                            *(_BYTE *)((int)v385 + *(_QWORD *)(v18 + 0x10)) = v332;
                            break;
                          case 2LL:
                            *(_WORD *)(*(_QWORD *)(v18 + 0x10) + 2LL * (int)v385) = v332;
                            break;
                          case 4LL:
                            *(_DWORD *)(*(_QWORD *)(v18 + 0x10) + 4LL * (int)v385) = v332;
                            break;
                        }
                      }
                    }
                    sub_140370D10(&String1_8);
                    v174 = v557;
                    if ( v557 != v558 )
                    {
                      v175 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_13;
LABEL_339:
                      qword_149B3AB68 += v175;
                      sub_147605980(v174);
                    }
                    goto LABEL_767;
                  case 0x10:
                    if ( !(_BYTE)n3 )
                    {
                      v375 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                                         v383,
                                         &v489,
                                         0);
                      v376 = (*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*v375 + 0x110LL))(
                               *v375,
                               "__type");
                      if ( v489 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v489 + 0x28LL))(v489);
                      v11 = (__int64)a1;
                      if ( DataCore::LookupDCStructDescByName((__int64)a1, v376) )
                      {
                        for ( allocSize_43 = 0; allocSize_43 < allocSize; ++allocSize_43 )
                        {
                          (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                            v383,
                            &v416,
                            (unsigned int)allocSize_43);
                          if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v416 + 0x100LL))(
                                 v416,
                                 "__index",
                                 &v385)
                            && (int)v385 < v61 )
                          {
                            sub_1474B8180(
                              (_DWORD)a1,
                              *(_DWORD *)(v18 + 0x10) + *(_DWORD *)(v18 + 0x28) * v385,
                              (unsigned int)&v416,
                              (_DWORD)a4,
                              v387);
                          }
                          if ( v416 )
                            (*(void (__fastcall **)(__int64))(*(_QWORD *)v416 + 0x28LL))(v416);
                        }
                        v8 = a4;
                        goto LABEL_768;
                      }
                      goto LABEL_767;
                    }
                    if ( n3 == 1 )
                    {
                      v384[0] = 0;
                      allocSize_44 = 0;
                      v372 = v387;
                      do
                      {
                        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                          v383,
                          &v395,
                          (unsigned int)allocSize_44);
                        if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v395
                                                                                                 + 0x100LL))(
                               v395,
                               "__index",
                               &v385)
                          && (int)v385 < v61 )
                        {
                          (*(void (__fastcall **)(__int64, const char *, char *))(*(_QWORD *)v395 + 0x90LL))(
                            v395,
                            "__fullyInstanced",
                            v384);
                          v373 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v395 + 0x110LL))(
                                   v395,
                                   "__type");
                          v11 = (__int64)a1;
                          v374 = sub_1474C4090(
                                   a1,
                                   *(_QWORD *)(v18 + 0x10) + *(_QWORD *)(v18 + 0x28) * (int)v385,
                                   v373,
                                   (unsigned __int8)v384[0]);
                          if ( v374 )
                            sub_1474B8180((_DWORD)a1, v374, (unsigned int)&v395, (_DWORD)a4, v372);
                        }
                        else
                        {
                          v11 = (__int64)a1;
                        }
                        if ( v395 )
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v395 + 0x28LL))(v395);
                        ++allocSize_44;
                      }
                      while ( allocSize_44 < allocSize );
                      v8 = a4;
                      goto LABEL_768;
                    }
                    if ( n3 != 2 )
                    {
                      if ( n3 != 3 )
                        break;
                      for ( allocSize_45 = 0; allocSize_45 < allocSize; ++allocSize_45 )
                      {
                        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                          v383,
                          &v414,
                          (unsigned int)allocSize_45);
                        if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v414
                                                                                                 + 0x100LL))(
                               v414,
                               "__index",
                               &v385)
                          && (int)v385 < v61 )
                        {
                          (*(void (__fastcall **)(__int64, const char *, char **))(*(_QWORD *)v414 + 0x108LL))(
                            v414,
                            "value",
                            &v488);
                          v345 = sub_1402BC380(&v511, v488);
                          v346 = *(_QWORD *)(v18 + 0x10);
                          v347 = *(_QWORD *)(v18 + 0x28) * (int)v385;
                          String1_3 = *(_OWORD *)v345;
                          String1_9 = *(_OWORD *)v345;
                          v348 = (__int64 (__fastcall ***)(_QWORD))sub_1403B6150(a1, &String1_9);
                          if ( v348 )
                          {
                            *((_QWORD *)&String1_3 + 1) = *((_QWORD *)&String1_9 + 1);
                            *(_OWORD *)(v347 + v346) = String1_9;
                            v348 = (__int64 (__fastcall ***)(_QWORD))(**v348)(v348);
                          }
                          else
                          {
                            *(_QWORD *)(v347 + v346) = 0;
                            *(_QWORD *)(v347 + v346 + 8) = 0;
                          }
                          *(_QWORD *)(v347 + v346 + 0x10) = v348;
                        }
                        if ( v414 )
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v414 + 0x28LL))(v414);
                      }
                      v11 = (__int64)a1;
                      goto LABEL_767;
                    }
                    v538[0] = 0;
                    n511_1 = 0;
                    v537 = v538;
                    n0x1FF_14 = 0x1FF;
                    v546[0] = 0;
                    allocSize_46 = 0;
                    v545 = v546;
                    n511_7 = 0;
                    n0x1FF_15 = 0x1FF;
                    do
                    {
                      (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v383 + 0x160LL))(
                        v383,
                        &v415,
                        (unsigned int)allocSize_46);
                      if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, __int64 *))(*(_QWORD *)v415
                                                                                               + 0x100LL))(
                             v415,
                             "__index",
                             &v385)
                        && (int)v385 < v417 )
                      {
                        v350 = v415;
                        ++*a4;
                        v351 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v350 + 0x110LL))(
                                 v350,
                                 "value");
                        v352 = (const void *)v351;
                        if ( v351 )
                        {
                          n511 = 0xFFFFFFFFFFFFFFFFuLL;
                          do
                            ++n511;
                          while ( *(_BYTE *)(v351 + n511) );
                          if ( n511 > n0x1FF_14 )
                          {
                            sub_1402A3C90(&n511_1);
                            sub_1402A3B50((__int64 *)&n511_1, n511);
                          }
                        }
                        else
                        {
                          n511 = 0;
                        }
                        memmove(v537, v352, n511);
                        n511_1 = n511;
                        v537[n511] = 0;
                        v354 = v537;
                        n511_2 = n511_1;
                        v356 = v537;
                        v357 = &v537[n511_1];
                        if ( v537 >= &v537[n511_1]
                          || (v537
                            ? (n511_5 = strspn(v537, "."), v354 = v537, n511_4 = n511_5, n511_2 = n511_1)
                            : (n511_4 = 0),
                              v360 = &v356[n511_4],
                              v360 >= v357) )
                        {
                          v534[0] = 0;
                          n511_11 = 0;
                          v364 = v534;
                          n0x1FF_16 = 0x1FF;
                          v363 = 0xFFFFFFFF;
                          v533 = v534;
                          n511_6 = 0;
                        }
                        else
                        {
                          if ( v360 )
                          {
                            n511_10 = strcspn(&v356[n511_4], ".");
                            v354 = v537;
                            n511_2 = n511_1;
                          }
                          else
                          {
                            n511_10 = 0;
                          }
                          n511_3 = n511_10;
                          v363 = n511_4 + n511_10 + 1;
                          if ( n511_4 < n511_2 )
                          {
                            if ( n511_10 == 0xFFFFFFFFFFFFFFFFuLL )
                              n511_3 = n511_2 - n511_4;
                            if ( n511_4 + n511_3 > n511_2 )
                              n511_3 = n511_2 - n511_4;
                            v366 = &v354[n511_4];
                            v534[0] = 0;
                            n0x1FF_16 = 0x1FF;
                            n511_11 = 0;
                            v364 = v534;
                            v533 = v534;
                            n511_6 = 0;
                            if ( n511_3 )
                            {
                              sub_1402A3B50((__int64 *)&n511_11, n511_3);
                              memcpy(v533, v366, n511_3);
                              v364 = v533;
                              n511_6 = n511_11;
                            }
                          }
                          else
                          {
                            v534[0] = 0;
                            v364 = v534;
                            n511_11 = 0;
                            v533 = v534;
                            n511_6 = 0;
                            n0x1FF_16 = 0x1FF;
                          }
                        }
                        if ( n511_6 > n0x1FF_15 )
                        {
                          sub_1402A3C90(&n511_7);
                          sub_1402A3B50((__int64 *)&n511_7, n511_6);
                        }
                        memmove(v545, v364, n511_6);
                        n511_7 = n511_6;
                        *((_BYTE *)v545 + n511_6) = 0;
                        if ( v533 != v534 )
                        {
                          qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_16;
                          sub_147605980(v533);
                        }
                        v367 = *(_QWORD *)(v18 + 0x10) + *(_QWORD *)(v18 + 0x28) * (int)v385;
                        v368 = &v537[v363];
                        CreateStringObjectFromString(&v433, (const char *)v545);
                        v369 = (unsigned __int64 *)sub_143429A20((__int64)(a4 + 1), (__int64 *)&v433);
                        sub_140370D10(&v433);
                        v431 = v367;
                        CreateStringObjectFromString(&v432, v368);
                        v370 = v369[1];
                        if ( v370 == v369[2] )
                        {
                          sub_14747A5F0(v369, (_QWORD *)v370, (__int64)&v431);
                        }
                        else
                        {
                          *(_QWORD *)v370 = v431;
                          sub_14035B160((void **)(v370 + 8), (const void **)&v432);
                          v369[1] += 0x10LL;
                        }
                        sub_140370D10(&v432);
                        allocSize = (unsigned __int64)String1;
                      }
                      if ( v415 )
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v415 + 0x28LL))(v415);
                      ++allocSize_46;
                    }
                    while ( allocSize_46 < allocSize );
                    v267 = v537;
                    if ( v545 != v546 )
                    {
                      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_15;
                      sub_147605980(v545);
                      v267 = v537;
                    }
                    if ( v267 != v538 )
                    {
                      v268 = 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_14;
LABEL_506:
                      qword_149B3AB68 += v268;
                      sub_147605980(v267);
                      v11 = (__int64)a1;
                      goto LABEL_767;
                    }
                    break;
                  default:
LABEL_766:
                    v11 = (__int64)a1;
                    goto LABEL_767;
                }
              }
              v11 = (__int64)a1;
LABEL_767:
              v8 = a4;
LABEL_768:
              if ( v383 )
              {
                (*(void (__fastcall **)(__int64))(*(_QWORD *)v383 + 0x28LL))(v383);
                v7 = v387;
                v10 = v388;
              }
              else
              {
LABEL_100:
                v7 = v387;
                v10 = v388;
              }
            }
            else
            {
              *(double *)&String1 = 0.0;
              if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, char **))(*(_QWORD *)v25 + 0x108LL))(
                      v25,
                      v17,
                      &String1)
                && ((_BYTE)n0x10 != 0x10 || (unsigned __int8)(n3 - 2) <= 1u) )
              {
LABEL_33:
                v11 = (__int64)a1;
LABEL_34:
                v7 = v387;
LABEL_35:
                v10 = v388;
                goto LABEL_36;
              }
              switch ( n0x10 )
              {
                case 1:
                  v32 = *String1 == 0x31 && !String1[1] || !_stricmp(String1, "true");
                  goto LABEL_32;
                case 2:
                case 6:
                  v32 = atoi(String1);
LABEL_32:
                  *(_BYTE *)v18 = v32;
                  goto LABEL_33;
                case 3:
                case 7:
                  *(_WORD *)v18 = atoi(String1);
                  goto LABEL_33;
                case 4:
                  *(_DWORD *)v18 = atoi(String1);
                  goto LABEL_33;
                case 5:
                  *(_QWORD *)v18 = atoi64(String1);
                  goto LABEL_33;
                case 8:
                  *(_DWORD *)v18 = atoll(String1);
                  goto LABEL_33;
                case 9:
                  *(_QWORD *)v18 = strtoull(String1, 0, 0xA);
                  goto LABEL_33;
                case 0xA:
                  sub_140379DF0(v18, String1);
                  goto LABEL_33;
                case 0xB:
                  *(double *)&String1_3 = atof(String1);
                  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
                  *(float *)v18 = *(float *)&_XMM1;
                  goto LABEL_33;
                case 0xC:
                  *(double *)v18 = atof(String1);
                  goto LABEL_33;
                case 0xD:
                  if ( *(double *)&String1 != 0.0 && *String1 == 0x40 )
                    assignCStringToStringStructure((void **)v18, String1);
                  goto LABEL_33;
                case 0xE:
                  v38 = sub_1402BC380(&v506, String1);
                  String1_3 = *(_OWORD *)v38;
                  *(_OWORD *)v18 = *(_OWORD *)v38;
                  goto LABEL_33;
                case 0xF:
                  v34 = v17;
                  v550[0] = 0;
                  v11 = (__int64)a1;
                  v549 = v550;
                  v547 = 0;
                  n0x1FF_17 = 0x1FF;
                  sub_1474A4630((__int64)a1, (__int64)&v547, (__int64)s1, v34);
                  v35 = sub_1474A1490((__int64)a1, v549, String1);
                  v36 = v22 - 1;
                  if ( v36 )
                  {
                    n2 = v36 - 1;
                    if ( n2 )
                    {
                      if ( n2 == 2 )
                        *(_DWORD *)v18 = v35;
                    }
                    else
                    {
                      *(_WORD *)v18 = v35;
                    }
                  }
                  else
                  {
                    *(_BYTE *)v18 = v35;
                  }
                  if ( v549 == v550 )
                    goto LABEL_100;
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_17;
                  sub_147605980(v549);
                  v7 = v387;
                  v10 = v388;
                  break;
                case 0x10:
                  if ( (_BYTE)n3 )
                  {
                    switch ( n3 )
                    {
                      case 1:
                        (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(*(_QWORD *)*v409 + 0x168LL))(
                          *v409,
                          &v408,
                          v17);
                        v7 = v387;
                        v11 = (__int64)a1;
                        if ( v408 )
                        {
                          sub_1474B7EA0((__int64)a1, (_QWORD *)v18, &v408, (__int64)v8, v387);
                          if ( v408 )
                            (*(void (__fastcall **)(__int64))(*(_QWORD *)v408 + 0x28LL))(v408);
                        }
                        goto LABEL_35;
                      case 2:
                        String1_4 = String1;
                        if ( *(double *)&String1 == 0.0 || !*String1 )
                        {
                          v11 = (__int64)a1;
                          v7 = v387;
                          v10 = v388;
                          *(_QWORD *)v18 = 0;
                        }
                        else
                        {
                          Str[0] = 0;
                          v42 = 0;
                          n0x1FF_18 = 0x1FF;
                          p_Str = Str;
                          v539 = 0;
                          p_Str_1 = Str;
                          n511_8 = 0xFFFFFFFFFFFFFFFFuLL;
                          do
                            ++n511_8;
                          while ( String1[n511_8] );
                          if ( n511_8 )
                          {
                            sub_1402A3B50((__int64 *)&v539, n511_8);
                            memcpy(p_Str_1, String1_4, n511_8);
                            p_Str = (const char *)p_Str_1;
                            v42 = v539;
                          }
                          v45 = &p_Str[v42];
                          p_Str_2 = p_Str;
                          if ( p_Str >= &p_Str[v42]
                            || (p_Str
                              ? (v48 = strspn(p_Str, "."), p_Str = (const char *)p_Str_1, v47 = v48, v42 = v539)
                              : (v47 = 0),
                                v49 = v47,
                                v50 = &p_Str_2[v47],
                                v50 >= v45) )
                          {
                            v530[0] = 0;
                            Size_1 = 0;
                            v53 = 0xFFFFFFFF;
                            v529 = v530;
                            n0x1FF_19 = 0x1FF;
                          }
                          else
                          {
                            if ( v50 )
                            {
                              n511_12 = strcspn(&p_Str_2[v47], ".");
                              p_Str = (const char *)p_Str_1;
                              v42 = v539;
                            }
                            else
                            {
                              n511_12 = 0;
                            }
                            n511_9 = n511_12;
                            v53 = n511_12 + v47 + 1;
                            if ( v49 < v42 )
                            {
                              if ( n511_12 == 0xFFFFFFFFFFFFFFFFuLL )
                                n511_9 = v42 - v49;
                              if ( n511_9 + v49 > v42 )
                                n511_9 = v42 - v49;
                              v58 = &p_Str[v49];
                              v530[0] = 0;
                              Size_1 = 0;
                              v529 = v530;
                              n0x1FF_19 = 0x1FF;
                              if ( n511_9 )
                              {
                                sub_1402A3B50((__int64 *)&Size_1, n511_9);
                                memcpy(v529, v58, n511_9);
                                p_Str = (const char *)p_Str_1;
                              }
                            }
                            else
                            {
                              v530[0] = 0;
                              v529 = v530;
                              Size_1 = 0;
                              n0x1FF_19 = 0x1FF;
                            }
                          }
                          v54 = &p_Str[v53];
                          sub_1403E0AA0(&v396);
                          Size = Size_1;
                          if ( Size_1 )
                          {
                            sub_1403DE0C0(&v396, Size_1);
                            sub_1403E1FA0(v396, v529, Size);
                          }
                          v56 = (unsigned __int64 *)sub_143429A20((__int64)(v8 + 1), (__int64 *)&v396);
                          sub_140370D10(&v396);
                          v427 = v18;
                          CreateStringObjectFromString(&v428, v54);
                          v57 = v56[1];
                          if ( v57 == v56[2] )
                          {
                            sub_14747A5F0(v56, (_QWORD *)v57, (__int64)&v427);
                          }
                          else
                          {
                            *(_QWORD *)v57 = v427;
                            sub_14035B160((void **)(v57 + 8), (const void **)&v428);
                            v56[1] += 0x10LL;
                          }
                          ++*v8;
                          sub_140370D10(&v428);
                          if ( v529 != v530 )
                          {
                            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_19;
                            sub_147605980(v529);
                          }
                          if ( p_Str_1 != Str )
                          {
                            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_18;
                            sub_147605980(p_Str_1);
                            v11 = (__int64)a1;
                            goto LABEL_100;
                          }
                          v11 = (__int64)a1;
                          v7 = v387;
                          v10 = v388;
                        }
                        break;
                      case 3:
                        v11 = (__int64)a1;
                        String1_3 = *(_OWORD *)sub_1402BC380(&v507, String1);
                        String1_5 = String1_3;
                        v39 = (__int64 (__fastcall ***)(_QWORD))sub_1403B6150(a1, &String1_5);
                        if ( v39 )
                        {
                          *((_QWORD *)&String1_3 + 1) = *((_QWORD *)&String1_5 + 1);
                          *(_OWORD *)v18 = String1_5;
                          v40 = (**v39)(v39);
                          v7 = v387;
                          *(_QWORD *)(v18 + 0x10) = v40;
                        }
                        else
                        {
                          v7 = v387;
                          *(_QWORD *)v18 = 0;
                          *(_QWORD *)(v18 + 8) = 0;
                          *(_QWORD *)(v18 + 0x10) = 0;
                        }
                        v10 = v388;
                        break;
                      default:
                        goto LABEL_33;
                    }
                  }
                  else
                  {
                    (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(*(_QWORD *)*v409 + 0x168LL))(*v409, &v410, v17);
                    v7 = v387;
                    v11 = (__int64)a1;
                    if ( !v410 )
                      goto LABEL_35;
                    sub_1474B8180((_DWORD)a1, v18, (unsigned int)&v410, (_DWORD)v8, v387);
                    if ( v410 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v410 + 0x28LL))(v410);
                      goto LABEL_35;
                    }
                    v10 = v388;
                  }
                  break;
                default:
                  goto LABEL_33;
              }
            }
LABEL_36:
            v14 = v426 + 1;
            v426 = v14;
            if ( v14 >= v490 )
              break;
            pOutFieldPtrsVec__1 = pOutFieldPtrsVec_;
          }
        }
        v378 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
        v379 = DataCore::LookupDCStructDescByName(v11, v378);
        if ( v379 && *(_BYTE *)(v379 + 0x20) )
          sub_1402A6620(v7, &v491);
        if ( (_QWORD)pOutFieldPtrsVec_ )
        {
          sub_1403A3120(
            (__int64)&pOutFieldPtrsVec_,
            (const void *)pOutFieldPtrsVec_,
            (v419 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
          pOutFieldPtrsVec_ = 0;
          v419 = 0;
        }
      }
    }
  }
  v500 = __rdtsc();
  return qword_149B4B878(&n0x1600);
}

// --- End Function: sub_1474B8180 (0x1474B8180) ---

// --- Function: DataCore::RegisterDataCoreStruct (0x1474C27E0) ---
// Registers a named data structure within the DataCore system.  Initializes the
// structure data based on parameters, creates a managed string object for the
// name, performs a deep copy of the data, calculates an FNV-1a hash of the name,
// and attempts to insert the name and copied data into the central hash map
// located at `pDataCore + 304`. If an entry with the same name already exists,
// logs a fatal error. Cleans up temporary resources before returning.  @param
// pDataCore Pointer to the main DataCore object. @param pszStructName Null-
// terminated string representing the unique name for the structure. @param
// pDataParam1 Parameter passed to `InitializeDataCoreStructData` (maps to offset
// 0x10). @param pDataParam2 Parameter passed to `InitializeDataCoreStructData`
// (maps to offset 0x00). @param pDataParam3 Parameter passed to
// `InitializeDataCoreStructData` (maps to offset 0x08). @param pDataParam4
// Parameter passed to `InitializeDataCoreStructData` (maps to offset 0x18). @param
// pDataParam5 Parameter passed to `InitializeDataCoreStructData` (maps to offset
// 0x20). @param pDataParam6 Parameter passed to `InitializeDataCoreStructData`
// (maps to offset 0x28). @return Result of a cleanup operation
// (`vector_dword_set_size`), likely ignored.
_BYTE *__fastcall DataCore::RegisterDataCoreStruct(
        __int64 a1,
        const char *a2,
        __int64 pDataParam1,
        __int64 pDataParam2,
        __int64 pDataParam3,
        __int64 pDataParam4,
        char pDataParam5,
        __int64 pDataParam6)
{
  __int64 v10; // rbx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r8
  __int64 i; // rdx
  __int64 v14; // rcx
  _BYTE *result; // rax
  __int64 *p_pStructNameStringObj; // [rsp+40h] [rbp-B8h] BYREF
  _BYTE *copiedStructData; // [rsp+48h] [rbp-B0h] BYREF
  _BYTE *pStructNameStringObj; // [rsp+50h] [rbp-A8h] BYREF
  _BYTE v19[56]; // [rsp+58h] [rbp-A0h] BYREF
  unsigned __int64 v20; // [rsp+90h] [rbp-68h] BYREF
  _BYTE mapLookupResult_[24]; // [rsp+98h] [rbp-60h] BYREF
  _BYTE structDataBuffer_[56]; // [rsp+B0h] [rbp-48h] BYREF
  unsigned __int64 v23; // [rsp+E8h] [rbp-10h] BYREF

  v10 = DataCore::InitializeDataCoreStructData(
          (__int64)structDataBuffer_,
          pDataParam2,
          pDataParam3,
          pDataParam1,
          pDataParam4,
          pDataParam5,
          pDataParam6);
  CreateStringObjectFromString((void **)&pStructNameStringObj, a2);
  sub_147481E00(v19, v10);
  p_pStructNameStringObj = (__int64 *)&pStructNameStringObj;
  copiedStructData = v19;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v11;
  while ( pStructNameStringObj[v11] );
  v12 = 0;
  for ( i = 0xCBF29CE484222325uLL; v12 < v11; i = 0x100000001B3LL * (v14 ^ i) )
    v14 = (unsigned __int8)pStructNameStringObj[v12++];
  FindOrInsertHashMapEntry(
    (__int64 *)(a1 + 0x130),
    (__int64)mapLookupResult_,
    &pStructNameStringObj,
    (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 0x40,
    (int)&byte_14819E9C1,
    &p_pStructNameStringObj,
    (__int64 *)&copiedStructData);
  vector_dword_set_size(&v20, 0, 0);
  sub_140370D10(&pStructNameStringObj);
  result = (_BYTE *)vector_dword_set_size(&v23, 0, 0);
  if ( !mapLookupResult_[0x10] )
    return LogFatalError("[DataCore] RegisterStruct: Attempt to register '%s' multiple times", a2);
  return result;
}

// --- End Function: DataCore::RegisterDataCoreStruct (0x1474C27E0) ---

// --- Function: sub_1474C4090 (0x1474C4090) ---
__int64 __fastcall sub_1474C4090(__int64 a1, _QWORD *a2, const char *s1, char a4)
{
  char v7; // r9
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  signed __int64 v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // r14
  __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rsi
  __int64 v16; // rcx
  _BYTE *v17; // rdx
  __int64 v18; // r8
  __int64 v19; // r8
  __int64 n2; // r8
  __int128 pOutFieldPtrsVec_; // [rsp+20h] [rbp-48h] BYREF
  __int64 v23; // [rsp+30h] [rbp-38h]

  if ( a4 )
  {
    v7 = *((_BYTE *)a2 + 8);
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( v7 && *a2 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 8LL))(*a2);
      v7 = *((_BYTE *)a2 + 8);
    }
    if ( strcmp(s1, p_p_p_p_p_p_p_p_p_p_p_p_Source) )
    {
      if ( v7 )
      {
        if ( *a2 )
        {
          (**(void (__fastcall ***)(_QWORD, __int64))*a2)(*a2, 1);
          *a2 = 0;
        }
        *((_BYTE *)a2 + 8) = 0;
      }
      v9 = DataCore::LookupDCStructDescByName(a1, (__int64)s1);
      if ( v9 )
      {
        v10 = (_QWORD *)(***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v9 + 0x10))(*(_QWORD *)(v9 + 0x10), 0);
        *a2 = v10;
        v11 = v10;
        if ( v10 )
        {
          v12 = *v10;
          pOutFieldPtrsVec_ = 0;
          v23 = 0;
          v13 = (*(__int64 (__fastcall **)(_QWORD *))(v12 + 8))(v10);
          sub_1474A5370(a1, v13, (unsigned __int64)&pOutFieldPtrsVec_, 1);
          v14 = 0;
          v15 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
          if ( v15 )
          {
            do
            {
              v16 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v14);
              v17 = (char *)v11 + *(_QWORD *)(v16 + 8);
              v18 = *(_QWORD *)(v16 + 0x10);
              if ( !*(_BYTE *)(v16 + 0x1A) )
              {
                switch ( *(_BYTE *)(v16 + 0x18) )
                {
                  case 1:
                  case 2:
                  case 6:
                    *v17 = 0;
                    break;
                  case 3:
                  case 7:
                    *(_WORD *)v17 = 0;
                    break;
                  case 4:
                  case 8:
                  case 0xB:
                    *(_DWORD *)v17 = 0;
                    break;
                  case 5:
                  case 9:
                  case 0xC:
                    *(_QWORD *)v17 = 0;
                    break;
                  case 0xF:
                    v19 = v18 - 1;
                    if ( v19 )
                    {
                      n2 = v19 - 1;
                      if ( n2 )
                      {
                        if ( n2 == 2 )
                          *(_DWORD *)v17 = 0xFFFFFFFF;
                      }
                      else
                      {
                        *(_WORD *)v17 = 0xFFFF;
                      }
                    }
                    else
                    {
                      *v17 = 0xFF;
                    }
                    break;
                  case 0x10:
                    if ( !*(_BYTE *)(v16 + 0x19) )
                      sub_1474CFE80(a1, v17, v18);
                    break;
                  default:
                    break;
                }
              }
              ++v14;
            }
            while ( v14 < v15 );
          }
          if ( (_QWORD)pOutFieldPtrsVec_ )
            sub_1403A3120(
              (__int64)&pOutFieldPtrsVec_,
              (const void *)pOutFieldPtrsVec_,
              (v23 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
        }
        *((_BYTE *)a2 + 8) = 1;
      }
    }
  }
  if ( *((_BYTE *)a2 + 8) )
    return *a2;
  else
    return 0;
}

// --- End Function: sub_1474C4090 (0x1474C4090) ---

// --- Function: sub_1474C42F0 (0x1474C42F0) ---
__int64 __fastcall sub_1474C42F0(_QWORD *a1)
{
  _QWORD *v2; // r12
  _QWORD *v3; // r15
  _QWORD *v4; // rdi
  __int64 *v5; // rax
  const char *v6; // r13
  int v7; // eax
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // r14
  unsigned __int64 v10; // rbx
  unsigned __int128 v11; // rax
  __int64 v12; // r9
  __int64 v18; // r10
  __int64 v19; // rcx
  __int64 v20; // rcx
  _OWORD *v23; // rbx
  __int64 result; // rax
  _BYTE v25[8]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v26; // [rsp+28h] [rbp-40h]

  v2 = (_QWORD *)a1[0x36];
  v3 = (_QWORD *)a1[0x35];
  if ( v3 != v2 )
  {
    v4 = v3 + 1;
    v5 = a1 + 0xF;
    do
    {
      sub_14747F760(v5, (__int64)v25, v4);
      v6 = *(const char **)(v26 + 0x10);
      v7 = psub_1403360E0(0xFFFFFFFF, (__int64)v4, 0x10);
      v8 = a1[4];
      v9 = 0;
      v10 = v8;
      v11 = (unsigned int)~v7 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
      v12 = v8 & ((*((_QWORD *)&v11 + 1) + (_QWORD)v11) >> 7);
      _XMM2 = (BYTE8(v11) + (_BYTE)v11) & 0x7F;
      __asm { vpshufb xmm2, xmm2, xmm0 }
      while ( 1 )
      {
        _XMM1 = *(_OWORD *)(v12 + a1[1]);
        __asm
        {
          vpcmpeqb xmm0, xmm2, xmm1
          vpmovmskb eax, xmm0
        }
        if ( _EAX )
          break;
LABEL_9:
        __asm
        {
          vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
          vpmovmskb eax, xmm1
        }
        if ( _EAX )
          goto LABEL_14;
        v9 += 0x10LL;
        v12 = v10 & (v9 + v12);
        if ( v9 > v8 )
        {
          __debugbreak();
          v8 = a1[4];
        }
      }
      v18 = a1[2];
      while ( 1 )
      {
        _BitScanForward((unsigned int *)&v19, _EAX);
        v20 = v10 & (v12 + v19);
        if ( *(_QWORD *)(v18 + 0x18 * v20) == *v4 && *(_QWORD *)(v18 + 0x18 * v20 + 8) == v4[1] )
          break;
        _EAX &= _EAX - 1;
        if ( !_EAX )
          goto LABEL_9;
      }
      if ( v20 != a1[4] )
      {
        v23 = (_OWORD *)*v3;
        *(_OWORD *)*v3 = *(_OWORD *)v4;
        *((_QWORD *)v23 + 2) = (***(__int64 (__fastcall ****)(_QWORD))(v18 + 0x18 * v20 + 0x10))(*(_QWORD *)(v18 + 0x18 * v20 + 0x10));
        goto LABEL_15;
      }
LABEL_14:
      sub_1405C0E00(8u, 0, "[DataCore] Attempting to resolve record reference for record [%s] failed.", v6);
LABEL_15:
      v3 += 3;
      v5 = a1 + 0xF;
      v4 += 3;
    }
    while ( v3 != v2 );
  }
  result = a1[0x35];
  if ( result != a1[0x36] )
    a1[0x36] = result;
  return result;
}

// --- End Function: sub_1474C42F0 (0x1474C42F0) ---

// --- Function: sub_1474C44D0 (0x1474C44D0) ---
double __fastcall sub_1474C44D0(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, _QWORD *a5)
{
  return sub_1474B8180(a1, a2, a5, a3, a4);
}

// --- End Function: sub_1474C44D0 (0x1474C44D0) ---

// --- Function: sub_1474C44F0 (0x1474C44F0) ---
void __fastcall sub_1474C44F0(__int64 a1, char *a2, const char *a3, char **a4)
{
  __int64 v7; // rax
  __int64 v8; // r15
  __int64 v9; // rdi
  char v10; // r14
  char *Size; // rax
  char *Size_2; // rbx
  char *v13; // r12
  void **v14; // rax
  char *Size_1; // rbx
  char *v16; // rax
  void **v17; // rax
  char *v18; // rcx
  __int64 v19; // rdx
  char *v20; // rbx
  char v21; // di
  char *v22; // rdx
  char v23; // [rsp+20h] [rbp-58h]
  unsigned __int8 *v24; // [rsp+28h] [rbp-50h] BYREF
  int v25; // [rsp+30h] [rbp-48h]
  char *v26; // [rsp+38h] [rbp-40h] BYREF
  char *String; // [rsp+40h] [rbp-38h] BYREF
  __int128 pOutFieldPtrsVec_; // [rsp+48h] [rbp-30h] BYREF
  __int64 v29; // [rsp+58h] [rbp-20h]
  void *v30; // [rsp+60h] [rbp-18h] BYREF
  unsigned __int64 v31; // [rsp+68h] [rbp-10h]

  if ( a2 )
  {
    v7 = (*(__int64 (__fastcall **)(char *))(*(_QWORD *)a2 + 8LL))(a2);
    v8 = 0;
    v29 = 0;
    pOutFieldPtrsVec_ = 0;
    sub_1474A5370(a1, v7, (unsigned __int64)&pOutFieldPtrsVec_, 1);
    v9 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
    v31 = v9;
    CreateStringObjectFromString((void **)&v26, a3);
    sub_14035B3E0(&v24);
    v10 = 0;
    Size = sub_1403E61D0((__int64 *)&v26, 0x2E, 0);
    v25 = 0xFFFFFFFF;
    Size_2 = Size;
    if ( Size == (char *)0xFFFFFFFFFFFFFFFFLL )
    {
      v10 = 1;
      copyStringStructure((char **)&v24, &v26);
      v13 = a2;
    }
    else
    {
      v14 = sub_1403EAE30((__int64 *)&v26, (void **)&String, 0, (size_t)Size);
      sub_140377F00((char **)&v24, (char **)v14);
      sub_140370D10(&String);
      v13 = &v26[(_QWORD)Size_2 + 1];
    }
    Size_1 = sub_1403E61D0((__int64 *)&v24, 0x5B, 0);
    if ( Size_1 != (char *)0xFFFFFFFFFFFFFFFFLL )
    {
      v16 = sub_1403E61D0((__int64 *)&v24, 0x5D, 0);
      if ( v16 != (char *)0xFFFFFFFFFFFFFFFFLL )
      {
        sub_1403EAE30((__int64 *)&v24, (void **)&String, (size_t)(Size_1 + 1), v16 - Size_1 - 1);
        v25 = atoi(String);
        v17 = sub_1403EAE30((__int64 *)&v24, &v30, 0, (size_t)Size_1);
        sub_140377F00((char **)&v24, (char **)v17);
        sub_140370D10(&v30);
        sub_140370D10(&String);
      }
    }
    if ( v9 )
    {
      v18 = a2;
      while ( 1 )
      {
        v19 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v8);
        v20 = &v18[*(_QWORD *)(v19 + 8)];
        v21 = *(_BYTE *)(v19 + 0x19);
        v23 = *(_BYTE *)(v19 + 0x1A);
        if ( *(_BYTE *)(v19 + 0x18) == 0x10 )
          break;
LABEL_26:
        if ( ++v8 >= v31 )
          goto LABEL_31;
      }
      if ( !(unsigned int)sub_1403E47B0(&v24, *(_QWORD *)v19) )
      {
        if ( v23 )
        {
          if ( v25 < *((_DWORD *)v20 + 6) )
          {
            if ( !v21 )
            {
              if ( v10 )
              {
                v20 = (char *)(*((_QWORD *)v20 + 2) + *((_QWORD *)v20 + 5) * v25);
LABEL_29:
                *a4 = v20;
                goto LABEL_31;
              }
              v22 = (char *)(*((_QWORD *)v20 + 2) + *((_QWORD *)v20 + 5) * v25);
              goto LABEL_24;
            }
            if ( v21 == 1 )
            {
              v22 = *(char **)(*((_QWORD *)v20 + 5) * v25 + *((_QWORD *)v20 + 2));
              if ( v10 )
              {
                *a4 = v22;
                goto LABEL_31;
              }
              goto LABEL_24;
            }
          }
        }
        else
        {
          if ( !v21 )
          {
LABEL_14:
            if ( v10 )
              goto LABEL_29;
            v22 = v20;
LABEL_24:
            sub_1474C44F0(a1, v22, v13, a4);
            goto LABEL_25;
          }
          if ( v21 == 1 )
          {
            v20 = *(char **)v20;
            goto LABEL_14;
          }
        }
      }
LABEL_25:
      v18 = a2;
      goto LABEL_26;
    }
LABEL_31:
    sub_140370D10(&v24);
    sub_140370D10(&v26);
    if ( (_QWORD)pOutFieldPtrsVec_ )
      sub_1403A3120(
        (__int64)&pOutFieldPtrsVec_,
        (const void *)pOutFieldPtrsVec_,
        (v29 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
  }
}

// --- End Function: sub_1474C44F0 (0x1474C44F0) ---

// --- Function: sub_1474C4780 (0x1474C4780) ---
void __fastcall sub_1474C4780(_QWORD *a1)
{
  __int64 v2; // rsi
  __int64 i; // r15
  __int64 *v4; // rdi
  unsigned __int8 **v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rdi

  v2 = a1[0x38];
  for ( i = a1[0x39]; v2 != i; v2 += 0x10 )
  {
    v4 = (__int64 *)a1[0x2D];
    v5 = (unsigned __int8 **)v4[1];
    while ( !*((_BYTE *)v5 + 0x19) )
    {
      if ( (int)sub_1403E4780(v5 + 4, (_QWORD *)(v2 + 8)) >= 0 )
      {
        v4 = (__int64 *)v5;
        v5 = (unsigned __int8 **)*v5;
      }
      else
      {
        v5 = (unsigned __int8 **)v5[2];
      }
    }
    if ( !*((_BYTE *)v4 + 0x19)
      && (int)sub_1403E4780((unsigned __int8 **)(v2 + 8), v4 + 4) >= 0
      && v4 != (__int64 *)a1[0x2D] )
    {
      **(_QWORD **)v2 = v4[5];
    }
  }
  v6 = a1[0x38];
  v7 = a1[0x39];
  if ( v6 != v7 )
  {
    do
    {
      sub_140370D10((_QWORD *)(v6 + 8));
      v6 += 0x10;
    }
    while ( v6 != v7 );
    a1[0x39] = a1[0x38];
  }
}

// --- End Function: sub_1474C4780 (0x1474C4780) ---

// --- Function: sub_1474CD780 (0x1474CD780) ---
void __fastcall sub_1474CD780(__int64 a1)
{
  *(_DWORD *)(a1 + 0x2D0) = 0;
}

// --- End Function: sub_1474CD780 (0x1474CD780) ---

// --- Function: sub_1474CE4C0 (0x1474CE4C0) ---
__int64 __fastcall sub_1474CE4C0(int n0x2714)
{
  __int64 result; // rax

  if ( n0x2714 > 0x2714 )
  {
    switch ( n0x2714 )
    {
      case 0x2719:
        result = 0xFFFFFFFALL;
        break;
      case 0x271D:
        result = 0xFFFFFFFFLL;
        break;
      case 0x271E:
        result = 0xFFFFFFF6LL;
        break;
      case 0x2726:
        result = 0xFFFFFFF2LL;
        break;
      case 0x2728:
        result = 0xFFFFFFF0LL;
        break;
      case 0x2733:
        result = 0xFFFFFFE4LL;
        break;
      case 0x2734:
        result = 0xFFFFFFF4LL;
        break;
      case 0x2735:
        result = 0xFFFFFFFBLL;
        break;
      case 0x2738:
        result = 0xFFFFFFEFLL;
        break;
      case 0x273A:
        result = 0xFFFFFFECLL;
        break;
      case 0x273B:
      case 0x273F:
        result = 0xFFFFFFFCLL;
        break;
      case 0x273D:
        result = 0xFFFFFFE9LL;
        break;
      case 0x2740:
        result = 0xFFFFFFFELL;
        break;
      case 0x2741:
        result = 0xFFFFFFFDLL;
        break;
      case 0x2743:
        result = 0xFFFFFFEELL;
        break;
      case 0x2745:
        result = 0xFFFFFFF9LL;
        break;
      case 0x2746:
        result = 0xFFFFFFF7LL;
        break;
      case 0x2747:
        result = 0xFFFFFFEDLL;
        break;
      case 0x2748:
        result = 0xFFFFFFF1LL;
        break;
      case 0x2749:
        result = 0xFFFFFFEBLL;
        break;
      case 0x274B:
        result = 0xFFFFFFE5LL;
        break;
      case 0x274C:
        result = 0xFFFFFFE6LL;
        break;
      case 0x274D:
        result = 0xFFFFFFF8LL;
        break;
      case 0x2750:
        result = 0xFFFFFFF5LL;
        break;
      case 0x276D:
        result = 0xFFFFFFEALL;
        break;
      default:
        goto LABEL_32;
    }
  }
  else if ( n0x2714 == 0x2714 )
  {
    return 0xFFFFFFF3LL;
  }
  else if ( n0x2714 )
  {
LABEL_32:
    sub_1403A2CE0((__int64)"CrySock could not translate OS error code %x, treating as miscellaneous", n0x2714);
    return 0xFFFFFC18LL;
  }
  else
  {
    return 0;
  }
  return result;
}

// --- End Function: sub_1474CE4C0 (0x1474CE4C0) ---

// --- Function: sub_1474CEDE0 (0x1474CEDE0) ---
__int64 __fastcall sub_1474CEDE0(__int64 a1)
{
  const void *v2; // rcx
  __int64 result; // rax

  *(_BYTE *)(a1 + 0x398) = 1;
  v2 = *(const void **)(a1 + 0x2A8);
  if ( v2 )
  {
    result = sub_1402A3D30(v2);
    *(_QWORD *)(a1 + 0x2A8) = 0;
  }
  return result;
}

// --- End Function: sub_1474CEDE0 (0x1474CEDE0) ---

// --- Function: sub_1474CFE80 (0x1474CFE80) ---
void __fastcall sub_1474CFE80(__int64 a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v5; // rax
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  __int64 v8; // rcx
  _BYTE *v9; // rdx
  __int64 v10; // r8
  __int64 v11; // r8
  __int64 n2; // r8
  __int128 pOutFieldPtrsVec_; // [rsp+20h] [rbp-38h] BYREF
  __int64 v14; // [rsp+30h] [rbp-28h]

  if ( a2 )
  {
    v2 = *a2;
    v14 = 0;
    pOutFieldPtrsVec_ = 0;
    v5 = (*(__int64 (__fastcall **)(__int64 *))(v2 + 8))(a2);
    sub_1474A5370(a1, v5, (unsigned __int64)&pOutFieldPtrsVec_, 1);
    v6 = 0;
    v7 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
    if ( v7 )
    {
      do
      {
        v8 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v6);
        v9 = (char *)a2 + *(_QWORD *)(v8 + 8);
        v10 = *(_QWORD *)(v8 + 0x10);
        if ( !*(_BYTE *)(v8 + 0x1A) )
        {
          switch ( *(_BYTE *)(v8 + 0x18) )
          {
            case 1:
            case 2:
            case 6:
              *v9 = 0;
              break;
            case 3:
            case 7:
              *(_WORD *)v9 = 0;
              break;
            case 4:
            case 8:
            case 0xB:
              *(_DWORD *)v9 = 0;
              break;
            case 5:
            case 9:
            case 0xC:
              *(_QWORD *)v9 = 0;
              break;
            case 0xF:
              v11 = v10 - 1;
              if ( v11 )
              {
                n2 = v11 - 1;
                if ( n2 )
                {
                  if ( n2 == 2 )
                    *(_DWORD *)v9 = 0xFFFFFFFF;
                }
                else
                {
                  *(_WORD *)v9 = 0xFFFF;
                }
              }
              else
              {
                *v9 = 0xFF;
              }
              break;
            case 0x10:
              if ( !*(_BYTE *)(v8 + 0x19) )
                sub_1474CFE80(a1, v9, v10);
              break;
            default:
              break;
          }
        }
        ++v6;
      }
      while ( v6 < v7 );
    }
    if ( (_QWORD)pOutFieldPtrsVec_ )
      sub_1403A3120(
        (__int64)&pOutFieldPtrsVec_,
        (const void *)pOutFieldPtrsVec_,
        (v14 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
  }
}

// --- End Function: sub_1474CFE80 (0x1474CFE80) ---

// --- Function: sub_1474D20C0 (0x1474D20C0) ---
__int64 __fastcall sub_1474D20C0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = xmmword_14819F440;
  v4 = 0;
  v5 = a2 >> 7;
  v6 = 0;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 0x10;
    v9 = v7 & (v6 + v9);
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = v7 & (v9 + v13);
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_1474D0CD0(a1, v9, v8);
LABEL_11:
        v18 = a1[3];
        v19 = 0;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 0x10;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = v18 & (v20 + _RAX);
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1;
    }
    sub_1474D29C0(a1, v17, v8);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_1474D20C0 (0x1474D20C0) ---

// --- Function: sub_1474D2320 (0x1474D2320) ---
__int64 __fastcall sub_1474D2320(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = xmmword_14819F440;
  v4 = 0;
  v5 = a2 >> 7;
  v6 = 0;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 0x10;
    v9 = v7 & (v6 + v9);
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = v7 & (v9 + v13);
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_1474D13F0(a1, v9, v8);
LABEL_11:
        v18 = a1[3];
        v19 = 0;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 0x10;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = v18 & (v20 + _RAX);
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1;
    }
    sub_1474D2DD0(a1, v17, v8);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_1474D2320 (0x1474D2320) ---

// --- Function: sub_1474D2450 (0x1474D2450) ---
void __fastcall sub_1474D2450(__int64 a1, unsigned __int64 a2, __int64 n3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rax
  bool v6; // cf
  unsigned __int64 allocSize; // rax
  _QWORD *v8; // rax
  _QWORD *v9; // rdx
  _QWORD *v10; // rax

  *(_QWORD *)(a1 + 0x18) = a2;
  v3 = a2;
  *(_QWORD *)(a1 + 0x20) = a2;
  if ( a2 )
  {
    v5 = 0x10 * a2;
    if ( !is_mul_ok(a2, 0x10u) )
      v5 = 0xFFFFFFFFFFFFFFFFuLL;
    v6 = __CFADD__(v5, 8);
    allocSize = v5 + 8;
    if ( v6 )
      allocSize = 0xFFFFFFFFFFFFFFFFuLL;
    v8 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    if ( v8 )
    {
      v9 = v8 + 1;
      *v8 = v3;
      v10 = v8 + 1;
      do
      {
        *v10 = 0;
        *((_BYTE *)v10 + 8) = 0;
        v10 += 2;
        --v3;
      }
      while ( v3 );
      *(_QWORD *)(a1 + 0x10) = v9;
      *(_BYTE *)(a1 + 8) = 1;
    }
    else
    {
      *(_QWORD *)(a1 + 0x10) = 0;
      *(_BYTE *)(a1 + 8) = 1;
    }
  }
}

// --- End Function: sub_1474D2450 (0x1474D2450) ---

// --- Function: sub_1474D24F0 (0x1474D24F0) ---
void __fastcall sub_1474D24F0(__int64 a1, unsigned __int64 a2, __int64 n3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rax
  __int64 v6; // rbp
  _QWORD *v7; // rdi

  *(_QWORD *)(a1 + 0x18) = a2;
  v3 = a2;
  *(_QWORD *)(a1 + 0x20) = a2;
  if ( a2 )
  {
    v5 = allocWithProfilerInfo_w(saturated_mul(a2, 0x18u));
    v6 = v5;
    if ( v5 )
    {
      v7 = (_QWORD *)v5;
      do
      {
        sub_140361E00(v7);
        v7 += 3;
        --v3;
      }
      while ( v3 );
    }
    else
    {
      v6 = 0;
    }
    *(_QWORD *)(a1 + 0x10) = v6;
    *(_BYTE *)(a1 + 8) = 1;
  }
}

// --- End Function: sub_1474D24F0 (0x1474D24F0) ---

// --- Function: sub_1474D2580 (0x1474D2580) ---
void __fastcall sub_1474D2580(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rax
  bool v5; // cf
  unsigned __int64 allocSize; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rbp
  __int64 v9; // rdi

  *(_QWORD *)(a1 + 0x18) = a2;
  v2 = a2;
  *(_QWORD *)(a1 + 0x20) = a2;
  if ( a2 )
  {
    v4 = 0x10 * a2;
    if ( !is_mul_ok(a2, 0x10u) )
      v4 = 0xFFFFFFFFFFFFFFFFuLL;
    v5 = __CFADD__(v4, 8);
    allocSize = v4 + 8;
    if ( v5 )
      allocSize = 0xFFFFFFFFFFFFFFFFuLL;
    v7 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    if ( v7 )
    {
      v8 = v7 + 1;
      v9 = (__int64)(v7 + 1);
      *v7 = v2;
      do
      {
        sub_140362C90(v9);
        v9 += 0x10;
        --v2;
      }
      while ( v2 );
    }
    else
    {
      v8 = 0;
    }
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_BYTE *)(a1 + 8) = 1;
  }
}

// --- End Function: sub_1474D2580 (0x1474D2580) ---

// --- Function: sub_1474D2620 (0x1474D2620) ---
void __fastcall sub_1474D2620(__int64 a1, unsigned __int64 a2, __int64 n3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rax
  bool v6; // cf
  unsigned __int64 allocSize; // rax
  _QWORD *v8; // rax
  _QWORD *v9; // rbp
  _QWORD *v10; // rdi

  *(_QWORD *)(a1 + 0x18) = a2;
  v3 = a2;
  *(_QWORD *)(a1 + 0x20) = a2;
  if ( a2 )
  {
    v5 = 8 * a2;
    if ( !is_mul_ok(a2, 8u) )
      v5 = 0xFFFFFFFFFFFFFFFFuLL;
    v6 = __CFADD__(v5, 8);
    allocSize = v5 + 8;
    if ( v6 )
      allocSize = 0xFFFFFFFFFFFFFFFFuLL;
    v8 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    if ( v8 )
    {
      v9 = v8 + 1;
      v10 = v8 + 1;
      *v8 = v3;
      do
      {
        sub_14035B3E0(v10++);
        --v3;
      }
      while ( v3 );
    }
    else
    {
      v9 = 0;
    }
    *(_QWORD *)(a1 + 0x10) = v9;
    *(_BYTE *)(a1 + 8) = 1;
  }
}

// --- End Function: sub_1474D2620 (0x1474D2620) ---

// --- Function: sub_1474D2FE0 (0x1474D2FE0) ---
void __fastcall sub_1474D2FE0(__int64 a1, unsigned __int64 allocSize)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  unsigned __int64 allocSize_1; // rcx
  __int64 v7; // rax
  __int64 v8; // rdi
  _BYTE *v9; // rcx
  _BYTE *v10; // rdx

  if ( allocSize <= *(_QWORD *)(a1 + 0x20) )
  {
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
  else
  {
    v4 = ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
       | ((unsigned int)(allocSize - 1) >> 1)
       | (allocSize - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    allocSize_1 = (v5 | HIWORD(v5)) + 1;
    *(_QWORD *)(a1 + 0x20) = (unsigned int)allocSize_1;
    v7 = allocWithProfilerInfo_w(allocSize_1);
    v8 = v7;
    v9 = *(_BYTE **)(a1 + 0x10);
    if ( *(_QWORD *)(a1 + 0x18) )
    {
      v10 = (_BYTE *)v7;
      do
      {
        *v10 = v9[(_QWORD)v10 - v7];
        ++v10;
      }
      while ( (unsigned __int64)&v10[-v7] < *(_QWORD *)(a1 + 0x18) );
    }
    if ( *(_BYTE *)(a1 + 8) )
      sub_1402A3D30(v9);
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
}

// --- End Function: sub_1474D2FE0 (0x1474D2FE0) ---

// --- Function: sub_1474D30B0 (0x1474D30B0) ---
void __fastcall sub_1474D30B0(__int64 a1, unsigned __int64 allocSize)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  __int64 v6; // rax
  char *v7; // rcx
  unsigned __int64 v8; // r8
  __int64 v9; // rsi
  _WORD *v10; // rdx

  if ( allocSize <= *(_QWORD *)(a1 + 0x20) )
  {
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
  else
  {
    v4 = ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
       | ((unsigned int)(allocSize - 1) >> 1)
       | (allocSize - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    *(_QWORD *)(a1 + 0x20) = (v5 | HIWORD(v5)) + 1;
    v6 = allocWithProfilerInfo_w(saturated_mul((v5 | HIWORD(v5)) + 1, 2u));
    v7 = *(char **)(a1 + 0x10);
    v8 = 0;
    v9 = v6;
    if ( *(_QWORD *)(a1 + 0x18) )
    {
      v10 = (_WORD *)v6;
      do
      {
        ++v8;
        *v10 = *(_WORD *)&v7[(_QWORD)v10 - v6];
        ++v10;
      }
      while ( v8 < *(_QWORD *)(a1 + 0x18) );
    }
    if ( *(_BYTE *)(a1 + 8) )
      sub_1402A3D30(v7);
    *(_QWORD *)(a1 + 0x10) = v9;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
}

// --- End Function: sub_1474D30B0 (0x1474D30B0) ---

// --- Function: sub_1474D3190 (0x1474D3190) ---
void __fastcall sub_1474D3190(__int64 a1, unsigned __int64 allocSize)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  __int64 v6; // rax
  char *v7; // rcx
  unsigned __int64 v8; // r8
  __int64 v9; // rsi
  _DWORD *v10; // rdx

  if ( allocSize <= *(_QWORD *)(a1 + 0x20) )
  {
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
  else
  {
    v4 = ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
       | ((unsigned int)(allocSize - 1) >> 1)
       | (allocSize - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    *(_QWORD *)(a1 + 0x20) = (v5 | HIWORD(v5)) + 1;
    v6 = allocWithProfilerInfo_w(saturated_mul((v5 | HIWORD(v5)) + 1, 4u));
    v7 = *(char **)(a1 + 0x10);
    v8 = 0;
    v9 = v6;
    if ( *(_QWORD *)(a1 + 0x18) )
    {
      v10 = (_DWORD *)v6;
      do
      {
        ++v8;
        *v10 = *(_DWORD *)&v7[(_QWORD)v10 - v6];
        ++v10;
      }
      while ( v8 < *(_QWORD *)(a1 + 0x18) );
    }
    if ( *(_BYTE *)(a1 + 8) )
      sub_1402A3D30(v7);
    *(_QWORD *)(a1 + 0x10) = v9;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
}

// --- End Function: sub_1474D3190 (0x1474D3190) ---

// --- Function: sub_1474D3270 (0x1474D3270) ---
void __fastcall sub_1474D3270(__int64 a1, unsigned __int64 allocSize)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  unsigned __int64 v6; // rdi
  __int64 v7; // rax
  bool v8; // cf
  unsigned __int64 allocSize_1; // rax
  _QWORD *v10; // rax
  unsigned __int64 v11; // rbx
  _QWORD *v12; // rbp
  _QWORD *i; // rax
  __int64 v14; // r15
  __int64 v15; // rdi
  __int64 v16; // rdi
  __int64 j; // rbx

  if ( allocSize <= *(_QWORD *)(a1 + 0x20) )
  {
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
  else
  {
    v4 = ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
       | ((unsigned int)(allocSize - 1) >> 1)
       | (allocSize - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    v6 = (v5 | HIWORD(v5)) + 1;
    v7 = 0x10 * v6;
    *(_QWORD *)(a1 + 0x20) = v6;
    if ( !is_mul_ok(v6, 0x10u) )
      v7 = 0xFFFFFFFFFFFFFFFFuLL;
    v8 = __CFADD__(v7, 8);
    allocSize_1 = v7 + 8;
    if ( v8 )
      allocSize_1 = 0xFFFFFFFFFFFFFFFFuLL;
    v10 = (_QWORD *)allocWithProfilerInfo_w(allocSize_1);
    v11 = 0;
    if ( v10 )
    {
      *v10 = v6;
      v12 = v10 + 1;
      for ( i = v10 + 1; v6; --v6 )
      {
        *i = 0;
        *((_BYTE *)i + 8) = 0;
        i += 2;
      }
    }
    else
    {
      v12 = 0;
    }
    v14 = *(_QWORD *)(a1 + 0x10);
    if ( *(_QWORD *)(a1 + 0x18) )
    {
      v15 = (__int64)v12;
      do
      {
        sub_140379DC0(v15, (ULONG_PTR **)(v14 - (_QWORD)v12 + v15));
        ++v11;
        v15 += 0x10;
      }
      while ( v11 < *(_QWORD *)(a1 + 0x18) );
    }
    if ( *(_BYTE *)(a1 + 8) && v14 )
    {
      v16 = *(_QWORD *)(v14 - 8);
      for ( j = v14 + 0x10 * v16; v16; --v16 )
      {
        j -= 0x10;
        sub_140372C00(j);
      }
      sub_1402A3D30((const void *)(v14 - 8));
    }
    *(_QWORD *)(a1 + 0x10) = v12;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
}

// --- End Function: sub_1474D3270 (0x1474D3270) ---

// --- Function: sub_1474D33E0 (0x1474D33E0) ---
void __fastcall sub_1474D33E0(__int64 a1, unsigned __int64 allocSize)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  bool v6; // cf
  unsigned __int64 allocSize_1; // rax
  _QWORD *v8; // rax
  unsigned __int64 v9; // rbp
  char **v10; // r14
  _QWORD *i; // rdi
  __int64 v12; // r15
  char **v13; // rbx
  __int64 v14; // rbx
  _QWORD *j; // rdi

  if ( allocSize <= *(_QWORD *)(a1 + 0x20) )
  {
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
  else
  {
    v4 = (((((((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
            | ((unsigned int)(allocSize - 1) >> 1)
            | ((_DWORD)allocSize - 1)) >> 4)
          | ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
          | ((unsigned int)(allocSize - 1) >> 1)
          | ((_DWORD)allocSize - 1)) >> 8)
        | ((((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
          | ((unsigned int)(allocSize - 1) >> 1)
          | ((_DWORD)allocSize - 1)) >> 4)
        | ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
        | ((unsigned int)(allocSize - 1) >> 1)
        | ((_DWORD)allocSize - 1)
        | ((((((((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
              | ((unsigned int)(allocSize - 1) >> 1)
              | ((_DWORD)allocSize - 1)) >> 4)
            | ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
            | ((unsigned int)(allocSize - 1) >> 1)
            | ((_DWORD)allocSize - 1)) >> 8)
          | ((((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
            | ((unsigned int)(allocSize - 1) >> 1)
            | ((_DWORD)allocSize - 1)) >> 4)
          | ((((unsigned int)(allocSize - 1) >> 1) | ((_DWORD)allocSize - 1)) >> 2)
          | ((unsigned int)(allocSize - 1) >> 1)
          | ((_DWORD)allocSize - 1)) >> 0x10))
       + 1;
    v5 = 8 * v4;
    *(_QWORD *)(a1 + 0x20) = v4;
    if ( !is_mul_ok(v4, 8u) )
      v5 = 0xFFFFFFFFFFFFFFFFuLL;
    v6 = __CFADD__(v5, 8);
    allocSize_1 = v5 + 8;
    if ( v6 )
      allocSize_1 = 0xFFFFFFFFFFFFFFFFuLL;
    v8 = (_QWORD *)allocWithProfilerInfo_w(allocSize_1);
    v9 = 0;
    if ( v8 )
    {
      *v8 = v4;
      v10 = (char **)(v8 + 1);
      for ( i = v8 + 1; v4; --v4 )
        sub_14035B3E0(i++);
    }
    else
    {
      v10 = 0;
    }
    v12 = *(_QWORD *)(a1 + 0x10);
    if ( *(_QWORD *)(a1 + 0x18) )
    {
      v13 = v10;
      do
      {
        copyStringStructure(v13, (char **)((char *)v13 + v12 - (_QWORD)v10));
        ++v9;
        ++v13;
      }
      while ( v9 < *(_QWORD *)(a1 + 0x18) );
    }
    if ( *(_BYTE *)(a1 + 8) && v12 )
    {
      v14 = *(_QWORD *)(v12 - 8);
      for ( j = (_QWORD *)(v12 + 8 * v14); v14; --v14 )
      {
        j += 0xFFFFFFFF;
        sub_140370D10(j);
      }
      sub_1402A3D30((const void *)(v12 - 8));
    }
    *(_QWORD *)(a1 + 0x10) = v10;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 0x18) = allocSize;
  }
}

// --- End Function: sub_1474D33E0 (0x1474D33E0) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: unknown_libname_248 (0x148032240) ---
// Microsoft VisualC v14 64bit runtime
const __m128i *__fastcall unknown_libname_248(const __m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  signed __int64 v3; // r9
  unsigned __int64 v5; // rdx
  const __m128i *v10; // rdx
  unsigned __int64 v13; // r9
  const __m128i *v14; // rdx
  __m128i v15; // xmm1
  __int64 v16; // rax

  v3 = (char *)a2 - (char *)a1;
  v5 = ((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL;
  if ( v5 && (dword_149B1CF54 & 0x20) != 0 )
  {
    _XMM2 = a3;
    _YMM2 = (__m256i)a3;
    __asm
    {
      vpunpcklqdq xmm2, xmm2, xmm2
      vinsertf128 ymm2, ymm2, xmm2, 1
    }
    v10 = (const __m128i *)((char *)a1 + v5);
    while ( 1 )
    {
      __asm
      {
        vpcmpeqq ymm1, ymm2, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        break;
      a1 += 2;
      if ( a1 == v10 )
      {
        v3 &= 0x1Fu;
        __asm { vzeroupper }
        goto LABEL_7;
      }
    }
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
LABEL_7:
    v13 = v3 & 0xFFFFFFFFFFFFFFF0uLL;
    if ( v13 && (dword_149B1CF54 & 4) != 0 )
    {
      v14 = (const __m128i *)((char *)a1 + v13);
      v15 = _mm_unpacklo_epi64((__m128i)a3, (__m128i)a3);
      while ( 1 )
      {
        LODWORD(v16) = _mm_movemask_epi8(_mm_cmpeq_epi64(_mm_loadu_si128(a1), v15));
        if ( (_DWORD)v16 )
          break;
        if ( ++a1 == v14 )
          goto LABEL_12;
      }
      _BitScanForward((unsigned int *)&v16, v16);
      return (const __m128i *)((char *)a1 + v16);
    }
    else
    {
LABEL_12:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i64[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 8);
      }
      return a1;
    }
  }
}

// --- End Function: unknown_libname_248 (0x148032240) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

