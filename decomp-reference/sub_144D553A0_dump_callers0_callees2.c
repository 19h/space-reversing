// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x144D553A0 (sub_144D553A0)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 40
// ------------------------------------------------------------

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall sub_1402A3D30(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B2210) ---
void __fastcall std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>(
        std::shared_ptr<std::vector<char> > *this)
{
  volatile signed __int32 *v1; // rbx

  v1 = (volatile signed __int32 *)*((_QWORD *)this + 1);
  if ( v1 && _InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
    if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
  }
}

// --- End Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B2210) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 status_bits; // rax

  if ( qword_149B3B1F0 )
    status_bits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    status_bits = 1;
  if ( !qword_149B3B208 )
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)status_bits & 0xFFFFFFF7;
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
// A comprehensive function for logging and dispatching telemetry events. It
// captures system time, generates unique identifiers, formats event data
// (including parameters and tags) into a buffer, and conditionally outputs to
// console or dispatches to various logging handlers based on configuration and
// event type. It also handles dynamic memory allocation and deallocation for event
// data structures.
void __fastcall sub_1403045C0(
        unsigned int event_severity_level,
        __int64 *event_data_ptr,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 v84; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char v89; // cl
  int v90; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v94; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  const void *Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *v110; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v112; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int v116; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v128; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v132; // [rsp+118h] [rbp+78h]
  char *v133; // [rsp+120h] [rbp+80h]
  __int64 *event_data_ptr_1; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v132 = a4;
  v133 = a3;
  event_data_ptr_1 = event_data_ptr;
  n4 = event_severity_level;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  v128 = v12;
  if ( v11 && !sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity) )
    return;
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v20 = v117;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v147[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400_1 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400_1 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            sub_1402A6760(v14, _Whereptr, __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        sub_1402A6760(v14, _Whereptr_1, (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)__Val_0___1 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v142, __Val_0___1);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)__Val_0___1, &v130, &__Val_0___4);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      __Val_0___5 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v48 = *(_QWORD **)__Val_0___7;
        v49 = **(_QWORD ***)__Val_0___7;
        if ( v49 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        __Val_0___7 = __Val_0___6;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          __Val_0___3 = __Val_0___5;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        __Val_0___3 = __Val_0___5;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v57;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              sub_1402A6760(v14, _Whereptr_2, __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          sub_1402A6760(v14, _Whereptr_3, &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    __Val_0___1 = __Val_0___2;
    v29 = v143;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[__Val_0___4];
    v124 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 0x70);
    v69 = v120;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 0xA) = v29;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * n0x400], (__int64)(8 * n0x400) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v76 = *(_QWORD *)&v71[8 * n0x400_3];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_130;
    }
  }
  v84 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v84 = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(v84 & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_130:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(v128, n4, v133, event_data_ptr_1, v132, __Val_0__, _Newcapacity, v146, n0x10_1, &a8);
    v123[0] = v87;
  }
  v89 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&FileTime,
            v128,
            (__int64)String,
            n4,
            event_data_ptr_1,
            v133,
            v132,
            __Val_0__,
            _Newcapacity,
            a7,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &a8);
    v89 = a8;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (v89 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v83);
    v89 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v89 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v83);
    n2_126 = ::n2_126;
  }
  v83[v88] = 0;
  v94 = a8;
  v95 = (a8 & 1) != 0 && n2_125 == 2;
  v96 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = (const void *)Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v117;
LABEL_166:
    v116 = v123[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v128,
      Buffer,
      String,
      n4,
      event_data_ptr_1,
      v133,
      v132,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v71,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      a8,
      v116);
    sub_1402A3D30(Buffer_3);
    v94 = a8;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v94 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v94 = a8;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (v94 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    v110 = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = v110[5];
        v112 = (_QWORD *)*v110;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)v110[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_190;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        v110[4] = 0;
        v110[5] = 0xF;
        *((_BYTE *)v110 + 0x10) = 0;
        sub_1402A3D30(v110);
        v110 = v112;
      }
      while ( v112 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_desc_ptr)
{
  unsigned __int64 entity_desc_val; // r9
  __int64 entity_base_addr_or_id; // r10
  unsigned __int64 entity_type_flags; // r9
  __int64 align_mask; // rax
  __int64 aligned_base_addr_or_id; // r10
  __int64 entity_header_ptr; // rbx
  bool is_privileged_or_bypass; // al

  entity_desc_val = *entity_desc_ptr;
  if ( !*entity_desc_ptr )
    return 0;
  entity_base_addr_or_id = entity_desc_val & 0xFFFFFFFFFFFFLL;
  entity_type_flags = HIWORD(entity_desc_val);
  if ( (entity_type_flags & 0xF000) != 0 )
  {
    align_mask = map_flag_to_mask(0x2000u);
    entity_header_ptr = aligned_base_addr_or_id & ~(align_mask - 1);
  }
  else
  {
    entity_header_ptr = entity_base_addr_or_id - 6;
  }
  if ( *(_WORD *)(entity_header_ptr + 2) != (entity_type_flags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || (is_privileged_or_bypass = is_thread_privileged_or_bypass_mode()) )
    is_privileged_or_bypass = 1;
  return *(_WORD *)(entity_header_ptr + 4) == 2 && is_privileged_or_bypass
      || validate_entity_descriptor_detailed_access(entity_desc_ptr) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int result_mask; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        result_mask = 0;
        if ( input_flag == 0x6000 )
          return 0x4000000;
        return result_mask;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_1403515F0 (0x1403515F0) ---
void __fastcall sub_1403515F0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-18h]
  __int64 n0xB0; // [rsp+90h] [rbp-10h]
  __int64 n0xA8; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  LODWORD(v9) = a6;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 1u, a5, v9, a7, a8);
}

// --- End Function: sub_1403515F0 (0x1403515F0) ---

// --- Function: sub_1403534F0 (0x1403534F0) ---
void __fastcall sub_1403534F0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v15; // rsp
  __int64 v16; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  __int64 v21; // [rsp+A0h] [rbp-E0h] BYREF

  v15 = alloca(0x150);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_140356B50((__int64)&v21, a10, a11);
  LODWORD(v16) = a6;
  sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 3u, a5, v16, a7, a8);
}

// --- End Function: sub_1403534F0 (0x1403534F0) ---

// --- Function: sub_140356B50 (0x140356B50) ---
__int64 __fastcall sub_140356B50(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  const char *p_null_1; // rax
  const char *p_null; // rdx
  unsigned __int64 v5; // rax
  __int64 n2; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Name";
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_1 = (const char *)a2[1];
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( p_null[v5] );
  *(_QWORD *)(a1 + 0x68) = v5;
  *(_QWORD *)(a1 + 0x78) = "EntityId";
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_BYTE *)(a1 + 0xC9) = 1;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4C70;
  n2 = 2;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  *(_QWORD *)(a1 + 0xD8) = 0x17;
  return n2;
}

// --- End Function: sub_140356B50 (0x140356B50) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_140370D10 (0x140370D10) ---
// // Decrements a reference count associated with a managed object and //
// deallocates the object's memory if the reference count is still positive. //
// This pattern is characteristic of shared pointer or reference-counted // memory
// management, where the reference count is stored in a control block // located
// just before the actual data pointed to by *a1. // // Parameters: //
// pManagedObjectPtr: A pointer to a QWORD, where the QWORD itself points //
// to the managed data. The reference count is expected //                      at
// an offset of -8 bytes from this data pointer.
void __fastcall sub_140370D10(_QWORD *pManagedObjectPtr)
{
  int *v1; // rcx

  v1 = (int *)(*pManagedObjectPtr - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_1403847F0 (0x1403847F0) ---
void **__fastcall sub_1403847F0(void **a1, char **a2)
{
  sub_1403DFF30(a1, *a2, *((int *)*a2 + 0xFFFFFFFE));
  return a1;
}

// --- End Function: sub_1403847F0 (0x1403847F0) ---

// --- Function: sub_140384840 (0x140384840) ---
void **__fastcall sub_140384840(void **a1, char *a2)
{
  unsigned __int64 Size; // rax

  if ( a2 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DFF30(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DFF30(a1, 0, 0);
    return a1;
  }
}

// --- End Function: sub_140384840 (0x140384840) ---

// --- Function: validate_entity_descriptor_detailed_access (0x140392020) ---
// Performs detailed access validation for an entity descriptor. It extracts the
// entity's base address or ID from the descriptor. It then determines a pointer to
// entity metadata based on the highest bit of the descriptor (either by masking or
// by applying a -6 offset to the base address/ID). The function then dispatches to
// different validation logic based on the value of a status/type field at
// `entity_metadata_ptr + 4`: - If 0, returns false. - If 1, calls
// `check_thread_list_contains_value` with the entity's base address/ID. - If 2,
// checks for a privileged/bypass state (via `get_thread_context_ptr + 0x12D` or
// `is_thread_privileged_or_bypass_mode`). If privileged, returns true; otherwise,
// calls `validate_access_with_virtual_calls`. - If 3 or 4, checks thread data from
// `get_thread_context_ptr`. If a specific thread status is 1, it returns true if
// the entity's base address/ID is NOT equal to the magic value `0x13374770CLL`. -
// For any other status/type, returns false.
char __fastcall validate_entity_descriptor_detailed_access(_QWORD *entity_descriptor_ptr)
{
  _QWORD *entity_base_addr_or_id; // rbx
  __int64 entity_metadata_ptr; // rax
  __int64 thread_data_ptr; // rax

  entity_base_addr_or_id = (_QWORD *)(*entity_descriptor_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*entity_descriptor_ptr & 0xF000000000000000uLL) != 0 )
    entity_metadata_ptr = *entity_descriptor_ptr & 0xFFFFFF000000LL;
  else
    entity_metadata_ptr = (__int64)entity_base_addr_or_id + 0xFFFFFFFA;
  if ( !*(_WORD *)(entity_metadata_ptr + 4) )
    return 0;
  if ( *(_WORD *)(entity_metadata_ptr + 4) == 1 )
    return check_thread_list_contains_value((__int64)entity_base_addr_or_id);
  if ( *(_WORD *)(entity_metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(entity_metadata_ptr + 4) - 3 <= 1 )
    {
      thread_data_ptr = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
      if ( thread_data_ptr )
      {
        if ( *(_DWORD *)(thread_data_ptr + 8) == 1 )
          return *entity_base_addr_or_id != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)entity_base_addr_or_id);
}

// --- End Function: validate_entity_descriptor_detailed_access (0x140392020) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403DFF30 (0x1403DFF30) ---
void __fastcall sub_1403DFF30(void **a1, char *a2, size_t Size)
{
  _BYTE *v4; // rbp
  size_t Size_1; // r13
  unsigned __int64 n8; // r15
  _DWORD *v9; // rax
  char *v10; // rcx

  if ( Size )
  {
    v4 = *a1;
    Size_1 = *((int *)*a1 + 0xFFFFFFFE);
    if ( Size + Size_1 <= *((int *)*a1 + 0xFFFFFFFF) )
    {
      if ( &v4[Size_1] != a2 )
        memcpy(&v4[Size_1], a2, Size);
      *((_DWORD *)*a1 + 0xFFFFFFFE) += Size;
      *((_BYTE *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= Size + Size_1 )
        n8 = Size + Size_1;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        v9 = (_DWORD *)allocWithProfilerInfo(n8 + 9, 0);
        *a1 = v9 + 2;
        *v9 = n8;
        v9[1] = n8;
        *((_BYTE *)*a1 + n8) = 0;
        if ( *a1 != v4 )
          memcpy(*a1, v4, Size_1);
        v10 = (char *)*a1 + Size_1;
        if ( v10 != a2 )
          memcpy(v10, a2, Size);
        *((_DWORD *)*a1 + 0xFFFFFFFE) = Size + Size_1;
        *((_BYTE *)*a1 + Size_1 + Size) = 0;
      }
      if ( *((int *)v4 + 0xFFFFFFFF) > 0 )
        sub_147605980(v4 + 0xFFFFFFF8);
    }
  }
}

// --- End Function: sub_1403DFF30 (0x1403DFF30) ---

// --- Function: sub_1403E20D0 (0x1403E20D0) ---
__int64 __fastcall sub_1403E20D0(__int64 a1)
{
  __int64 result; // rax

  if ( !a1 )
    return 0;
  result = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++result;
  while ( *(_BYTE *)(a1 + result) );
  return (int)result;
}

// --- End Function: sub_1403E20D0 (0x1403E20D0) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 allocWithProfilerInfo_ww()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
void __fastcall sub_1403E4E60(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403E7A60 (0x1403E7A60) ---
__int64 __fastcall sub_1403E7A60(_QWORD *a1)
{
  return *(int *)(*a1 - 8LL);
}

// --- End Function: sub_1403E7A60 (0x1403E7A60) ---

// --- Function: sub_1403E90A0 (0x1403E90A0) ---
void __fastcall sub_1403E90A0(void **a1, unsigned __int64 a2)
{
  _BYTE *v2; // rdi
  unsigned __int64 v5; // rcx
  _DWORD *v6; // rax

  v2 = *a1;
  v5 = *((int *)*a1 + 0xFFFFFFFF);
  if ( a2 > v5 )
  {
    if ( a2 )
    {
      v6 = (_DWORD *)allocWithProfilerInfo(a2 + 9, 0);
      *a1 = v6 + 2;
      *v6 = a2;
      v6[1] = a2;
      *((_BYTE *)*a1 + a2) = 0;
    }
    else
    {
      *a1 = (char *)&qword_149B3B33C + 4;
    }
    if ( *a1 != v2 )
      memcpy(*a1, v2, *((int *)v2 + 0xFFFFFFFE));
    *((_DWORD *)*a1 + 0xFFFFFFFE) = *((_DWORD *)v2 + 0xFFFFFFFE);
    *((_BYTE *)*a1 + *((int *)v2 + 0xFFFFFFFE)) = 0;
LABEL_12:
    if ( *((int *)v2 + 0xFFFFFFFF) > 0 )
      sub_147605980(v2 + 0xFFFFFFF8);
    return;
  }
  if ( !a2 && *((_DWORD *)v2 + 0xFFFFFFFE) != (_DWORD)v5 )
  {
    sub_1403DE0C0((char **)a1, *((int *)v2 + 0xFFFFFFFE));
    if ( *a1 != v2 )
      memcpy(*a1, v2, *((int *)v2 + 0xFFFFFFFE));
    goto LABEL_12;
  }
}

// --- End Function: sub_1403E90A0 (0x1403E90A0) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n12_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n0xC + a2), n12_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: sub_14040A530 (0x14040A530) ---
bool __fastcall sub_14040A530(_QWORD *a1)
{
  return *a1 && (a1[1] != a1[2] || a1[4] != a1[5]);
}

// --- End Function: sub_14040A530 (0x14040A530) ---

// --- Function: sub_14040AE50 (0x14040AE50) ---
char __fastcall sub_14040AE50(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  _BYTE *v7; // rax
  char v8; // bl

  if ( !*a3 )
    return 0;
  v7 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)*a3 + 0x110LL))(*a3, a4);
  v8 = sub_1403FFA40(a1, a2, v7);
  if ( *a3 )
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a3 + 0x28LL))(*a3);
  return v8;
}

// --- End Function: sub_14040AE50 (0x14040AE50) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_1480BE950);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *thread_base_ctx_ptr; // rax
  unsigned __int64 *thread_base_ctx_ptr_1; // rcx
  unsigned __int64 n0xF; // rax

  thread_base_ctx_ptr = sub_1404B3EA0();
  thread_base_ctx_ptr_1 = thread_base_ctx_ptr;
  if ( !thread_base_ctx_ptr )
    return &dword_149B45F40;
  n0xF = *thread_base_ctx_ptr;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&thread_base_ctx_ptr_1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 thread_data_ptr; // rcx

  thread_data_ptr = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( thread_data_ptr )
    return *(_BYTE *)(thread_data_ptr + 0x42) != 0;
  else
    return *(_BYTE *)(get_thread_context_ptr() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_144BE8650 (0x144BE8650) ---
void __fastcall sub_144BE8650(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12,
        _QWORD *a13,
        _QWORD *a14)
{
  void *v18; // rsp
  __int64 v19; // [rsp+18h] [rbp-2B8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-2A0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-248h]
  __int64 n0xB0; // [rsp+90h] [rbp-240h]
  __int64 n0xA8; // [rsp+98h] [rbp-238h]
  _QWORD *v24; // [rsp+A0h] [rbp-230h]
  const char *p_EntityId; // [rsp+A8h] [rbp-228h]
  __int64 v26; // [rsp+B0h] [rbp-220h]
  __int64 (__fastcall *p_sub_1403EB550)(__int64, __int64, __int64); // [rsp+B8h] [rbp-218h]
  __int64 (__fastcall *p_sub_1403EAFB0)(__int64, _BYTE *, unsigned __int64); // [rsp+C0h] [rbp-210h]
  __int64 v29; // [rsp+C8h] [rbp-208h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+D0h] [rbp-200h]
  __int64 v31; // [rsp+D8h] [rbp-1F8h]
  void (__fastcall *p_sub_1403E4EB0)(const void *); // [rsp+E0h] [rbp-1F0h]
  __int64 (__fastcall *p_sub_1403E4C70)(__int64); // [rsp+E8h] [rbp-1E8h]
  unsigned __int64 v34; // [rsp+F0h] [rbp-1E0h]
  char v35; // [rsp+F8h] [rbp-1D8h]
  char v36; // [rsp+F9h] [rbp-1D7h]
  __int64 n0x18; // [rsp+100h] [rbp-1D0h]
  __int64 n0x17; // [rsp+108h] [rbp-1C8h]
  __int64 v39; // [rsp+110h] [rbp-1C0h] BYREF

  v18 = alloca(0x2A0);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v24 = a10;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  p_EntityId = "EntityId";
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v36 = 1;
  v26 = *a10;
  p_sub_1403EB550 = sub_1403EB550;
  p_sub_1403EAFB0 = sub_1403EAFB0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E4EB0 = sub_1403E4EB0;
  p_sub_1403E4C70 = sub_1403E4C70;
  v29 = 0;
  v31 = 0;
  v35 = 0;
  v34 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x18 = 0x18;
  n0x17 = 0x17;
  sub_144C10190((__int64)&v39, a11, a12, a13, a14);
  LODWORD(v19) = a6;
  sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 6u, a5, v19, a7, a8);
}

// --- End Function: sub_144BE8650 (0x144BE8650) ---

// --- Function: sub_144BEEFA0 (0x144BEEFA0) ---
void __fastcall sub_144BEEFA0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12,
        _QWORD *a13)
{
  void *v17; // rsp
  __int64 v18; // [rsp+18h] [rbp-248h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-230h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-1D8h]
  __int64 n0xB0; // [rsp+90h] [rbp-1D0h]
  __int64 n0xA8; // [rsp+98h] [rbp-1C8h]
  __int64 v23; // [rsp+A0h] [rbp-1C0h] BYREF

  v17 = alloca(0x230);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_144C10190((__int64)&v23, a10, a11, a12, a13);
  LODWORD(v18) = a6;
  sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 5u, a5, v18, a7, a8);
}

// --- End Function: sub_144BEEFA0 (0x144BEEFA0) ---

// --- Function: sub_144D553A0 (0x144D553A0) ---
void __fastcall sub_144D553A0(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v7; // r14d
  __int64 *ThreadLogContextSlot; // rdi
  unsigned __int8 v9; // al
  void (__fastcall *v10)(_QWORD); // rax
  int v11; // r14d
  __int64 v12; // rax
  __int64 *ThreadLogContextSlot_1; // rdi
  unsigned __int8 v14; // al
  const void *v15; // rcx
  void (__fastcall *v16)(_QWORD); // rax
  unsigned __int64 *v17; // rax
  bool v18; // al
  unsigned __int64 v19; // rcx
  int v20; // r14d
  __int64 v21; // rax
  __int64 *ThreadLogContextSlot_2; // rdi
  __int64 v23; // rbx
  __int64 v24; // rax
  volatile signed __int32 *v25; // rbx
  void *v26; // [rsp+60h] [rbp-A0h] BYREF
  void *v27; // [rsp+68h] [rbp-98h] BYREF
  char *v28; // [rsp+70h] [rbp-90h] BYREF
  void **v29; // [rsp+78h] [rbp-88h] BYREF
  void **v30; // [rsp+80h] [rbp-80h]
  unsigned __int64 v31; // [rsp+88h] [rbp-78h] BYREF
  void *v32; // [rsp+90h] [rbp-70h] BYREF
  char *v33; // [rsp+98h] [rbp-68h] BYREF
  __int128 v34; // [rsp+A0h] [rbp-60h] BYREF
  const char *p_Entity_Name; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v36; // [rsp+B8h] [rbp-48h]
  const void *v37; // [rsp+C0h] [rbp-40h]
  __int128 v38; // [rsp+D0h] [rbp-30h] BYREF
  __int128 v39; // [rsp+E0h] [rbp-20h] BYREF
  const void *v40; // [rsp+F0h] [rbp-10h]
  __int64 v41; // [rsp+F8h] [rbp-8h] BYREF
  _BYTE v42[8]; // [rsp+100h] [rbp+0h] BYREF
  _QWORD v43[2]; // [rsp+108h] [rbp+8h] BYREF
  _QWORD v44[2]; // [rsp+118h] [rbp+18h] BYREF
  _QWORD v45[2]; // [rsp+128h] [rbp+28h] BYREF
  char v46; // [rsp+138h] [rbp+38h]
  __int128 v47; // [rsp+140h] [rbp+40h] BYREF
  unsigned __int64 v48; // [rsp+170h] [rbp+70h] BYREF

  v48 = a1;
  if ( !is_entity_descriptor_valid_or_accessible(&v48) )
  {
    HIDWORD(v26) = 0xE;
    LODWORD(v26) = (unsigned __int8)sub_14056A7D0(0x31) + 0xC7;
    v29 = &v26;
    v30 = &v27;
    v7 = invokeGlobalCallbackAndMaskStatusBits(
           3,
           (__int64)&v29,
           (__int64)"LoadingPlatformUtilities::LoadEntityFromXml",
           "Invalid entity passed to FreightElevatorUtilities::LoadEntityFromXml.");
    if ( (v7 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot = getThreadLogContextSlot();
      v34 = 0;
      v9 = sub_14056A7D0(0x31);
      v29 = &v26;
      LODWORD(v26) = v9 + 0xC7;
      v30 = &v27;
      HIDWORD(v26) = 0xE;
      sub_1403515F0(
        3u,
        (__int64 *)&v29,
        "LoadingPlatformUtilities::LoadEntityFromXml",
        "Invalid entity passed to FreightElevatorUtilities::LoadEntityFromXml.",
        1,
        v7,
        &v34,
        0,
        (__int64)ThreadLogContextSlot);
    }
    v10 = *(void (__fastcall **)(_QWORD))a4;
    if ( *(_QWORD *)(a4 + 8) == 1 )
      v10(0);
    else
      ((void (__fastcall *)(__int64, _QWORD))v10)(a4, 0);
    return;
  }
  (*(void (__fastcall **)(unsigned __int64, __int128 *))(*(_QWORD *)(v48 & 0xFFFFFFFFFFFFLL) + 0x388LL))(
    v48 & 0xFFFFFFFFFFFFLL,
    &v38);
  if ( !(_QWORD)v38 )
  {
    HIDWORD(v26) = 0xE;
    LODWORD(v26) = (unsigned __int8)sub_14056A7D0(0x31) + 0xC7;
    v29 = &v26;
    v30 = &v27;
    v11 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)&v29,
            (__int64)"LoadingPlatformUtilities::LoadEntityFromXml",
            "Failed to get SpawnBatch in LoadFromXml. EnityName[$$] EntityId[$$]");
    if ( (v11 & 0xFFFFF) == 0 )
      goto LABEL_11;
    v36 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)(v48 & 0xFFFFFFFFFFFFLL) + 8LL))(
                       v48 & 0xFFFFFFFFFFFFLL,
                       v42);
    p_Entity_Name = "Entity_Id";
    LOBYTE(v37) = 0;
    v12 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v48 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v48 & 0xFFFFFFFFFFFFLL);
    v40 = 0;
    *(_QWORD *)&v39 = "Entity_Name";
    *((_QWORD *)&v39 + 1) = v12;
    ThreadLogContextSlot_1 = getThreadLogContextSlot();
    v34 = 0;
    v14 = sub_14056A7D0(0x31);
    HIDWORD(v27) = 0xE;
    LODWORD(v27) = v14 + 0xC7;
    v43[0] = &v27;
    v43[1] = &v28;
    sub_1403534F0(
      3,
      (__int64)v43,
      "LoadingPlatformUtilities::LoadEntityFromXml",
      (__int64)"Failed to get SpawnBatch in LoadFromXml. EnityName[$$] EntityId[$$]",
      1,
      v11,
      &v34,
      0,
      (__int64)ThreadLogContextSlot_1,
      &v39,
      &p_Entity_Name);
    v15 = v40;
    goto LABEL_10;
  }
  v17 = (unsigned __int64 *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)(v48 & 0xFFFFFFFFFFFFLL)
                                                                                 + 0x10LL))(
                              v48 & 0xFFFFFFFFFFFFLL,
                              v42);
  v18 = is_entity_descriptor_valid_or_accessible(v17);
  v19 = v48;
  if ( v18 )
    v19 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(v48 & 0xFFFFFFFFFFFFLL) + 0x10LL))(
                       v48 & 0xFFFFFFFFFFFFLL,
                       v43);
  v31 = v19;
  if ( is_entity_descriptor_valid_or_accessible(&v31) )
  {
    sub_14035B3E0(&v28);
    sub_14035B3E0(&v33);
    (*(void (__fastcall **)(unsigned __int64, char **, char **))(*(_QWORD *)(v31 & 0xFFFFFFFFFFFFLL) + 0x80LL))(
      v31 & 0xFFFFFFFFFFFFLL,
      &v28,
      &v33);
    (*(void (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)(v31 & 0xFFFFFFFFFFFFLL) + 8LL))(
      v31 & 0xFFFFFFFFFFFFLL,
      &v41);
    sub_14035B3E0(&v26);
    v23 = sub_1403E7A60(&v28);
    v24 = sub_1403E20D0((__int64)"Path: ");
    sub_1403E90A0(&v26, v24 + v23);
    sub_140384840(&v26, "Path: ");
    sub_1403847F0(&v26, &v28);
    sub_14035B160(&v27, (const void **)&v26);
    sub_140384840(&v27, " - Context: ");
    sub_14035B160(&v32, (const void **)&v27);
    sub_1403847F0(&v32, &v33);
    sub_140370D10(&v27);
    sub_140370D10(&v26);
    if ( *((_QWORD *)&v38 + 1) )
      _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v38 + 1) + 8LL));
    v47 = v38;
    sub_144D576E0(v48, v41, &v47, a2, a3, &v32, a4);
    sub_140370D10(&v32);
    sub_140370D10(&v33);
    sub_140370D10(&v28);
    goto LABEL_22;
  }
  HIDWORD(v27) = 0xE;
  LODWORD(v27) = (unsigned __int8)sub_14056A7D0(0x31) + 0xC7;
  v44[0] = &v27;
  v44[1] = &v28;
  v20 = invokeGlobalCallbackAndMaskStatusBits(
          3,
          (__int64)v44,
          (__int64)"LoadingPlatformUtilities::LoadEntityFromXml",
          "Failed to get OC Entity in LoadFromXml. EnityName[$$] EntityId[$$]");
  if ( (v20 & 0xFFFFF) != 0 )
  {
    v45[1] = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, void ***))(*(_QWORD *)(v48 & 0xFFFFFFFFFFFFLL) + 8LL))(
                          v48 & 0xFFFFFFFFFFFFLL,
                          &v29);
    v45[0] = "Entity_Id";
    v46 = 0;
    v21 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v48 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v48 & 0xFFFFFFFFFFFFLL);
    v37 = 0;
    p_Entity_Name = "Entity_Name";
    v36 = v21;
    ThreadLogContextSlot_2 = getThreadLogContextSlot();
    v39 = 0;
    HIDWORD(v26) = 0xE;
    LODWORD(v26) = (unsigned __int8)sub_14056A7D0(0x31) + 0xC7;
    *(_QWORD *)&v34 = &v26;
    *((_QWORD *)&v34 + 1) = &v27;
    sub_1403534F0(
      3,
      (__int64)&v34,
      "LoadingPlatformUtilities::LoadEntityFromXml",
      (__int64)"Failed to get OC Entity in LoadFromXml. EnityName[$$] EntityId[$$]",
      1,
      v20,
      &v39,
      0,
      (__int64)ThreadLogContextSlot_2,
      &p_Entity_Name,
      v45);
    v15 = v37;
LABEL_10:
    sub_1402A3D30(v15);
  }
LABEL_11:
  v16 = *(void (__fastcall **)(_QWORD))a4;
  if ( *(_QWORD *)(a4 + 8) == 1 )
    v16(0);
  else
    ((void (__fastcall *)(__int64, _QWORD))v16)(a4, 0);
LABEL_22:
  v25 = (volatile signed __int32 *)*((_QWORD *)&v38 + 1);
  if ( *((_QWORD *)&v38 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v38 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v25)(v25);
      if ( _InterlockedExchangeAdd(v25 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v25 + 8LL))(v25);
    }
  }
}

// --- End Function: sub_144D553A0 (0x144D553A0) ---

// --- Function: sub_144D576E0 (0x144D576E0) ---
void __fastcall sub_144D576E0(
        __int64 a1,
        __int64 a2,
        std::shared_ptr<std::vector<char> > *a3,
        _QWORD *a4,
        __int64 a5,
        _QWORD *a6,
        __int64 a7)
{
  __int64 v7; // r15
  int v11; // esi
  __int64 v12; // rdi
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 *ThreadLogContextSlot; // rdi
  void (__fastcall *v17)(_QWORD); // rax
  volatile signed __int32 *v18; // rbx
  __int64 v19; // r8
  unsigned __int8 v20; // al
  int v21; // r12d
  __int64 v22; // rdi
  __int64 v23; // rcx
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rcx
  __int64 *ThreadLogContextSlot_1; // rdi
  unsigned __int8 v28; // al
  void (__fastcall *v29)(_QWORD); // rax
  char *v30; // rdi
  char *v31; // rsi
  char *v32; // rax
  _BYTE *v33; // rcx
  char *v34; // rdi
  char *v35; // rsi
  char *v36; // rax
  __int64 v37; // [rsp+70h] [rbp-90h] BYREF
  __int64 *v38; // [rsp+78h] [rbp-88h] BYREF
  __int64 **v39; // [rsp+80h] [rbp-80h]
  _DWORD v40[2]; // [rsp+88h] [rbp-78h] BYREF
  __int64 v41; // [rsp+90h] [rbp-70h] BYREF
  _BYTE *v42; // [rsp+98h] [rbp-68h]
  __int128 v43; // [rsp+A0h] [rbp-60h]
  void *v44[2]; // [rsp+B0h] [rbp-50h]
  __int64 v45; // [rsp+C0h] [rbp-40h]
  __int16 v46; // [rsp+C8h] [rbp-38h]
  char v47; // [rsp+CAh] [rbp-36h]
  const char *p_Entity_Name_1; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v49; // [rsp+D8h] [rbp-28h]
  const void *v50; // [rsp+E0h] [rbp-20h]
  __int64 v51; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v52; // [rsp+F0h] [rbp-10h]
  const void *v53; // [rsp+F8h] [rbp-8h]
  const char *p_Entity_Name; // [rsp+100h] [rbp+0h] BYREF
  __int64 v55; // [rsp+108h] [rbp+8h]
  const void *v56; // [rsp+110h] [rbp+10h]
  const char *p_Entity_Id; // [rsp+118h] [rbp+18h] BYREF
  __int64 v58; // [rsp+120h] [rbp+20h]
  char v59; // [rsp+128h] [rbp+28h]
  const char *p_ocId; // [rsp+130h] [rbp+30h] BYREF
  __int64 *v61; // [rsp+138h] [rbp+38h]
  char v62; // [rsp+140h] [rbp+40h]
  char v63[8]; // [rsp+148h] [rbp+48h] BYREF
  _OWORD v64[3]; // [rsp+150h] [rbp+50h] BYREF
  __int64 v65; // [rsp+1A8h] [rbp+A8h] BYREF

  v7 = a5;
  (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(*(_QWORD *)*a4 + 0x168LL))(*a4, &v65, a5);
  if ( !v65 )
  {
    v40[1] = 0xE;
    v40[0] = (unsigned __int8)sub_14056A7D0(0x31) + 0xC7;
    p_ocId = (const char *)v40;
    v61 = &v41;
    v11 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)&p_ocId,
            (__int64)"LoadingPlatformUtilities::LoadFromXmlNode",
            "Failed to find child node. ChildNodeName[$$] SourceString[$$] EnityName[$$] EntityId[$$]");
    if ( (v11 & 0xFFFFF) != 0 )
    {
      v12 = a1 & 0xFFFFFFFFFFFFLL;
      v13 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v12 + 8LL))(v12, v63);
      p_Entity_Id = "Entity_Id";
      v14 = *(_QWORD *)v12;
      v58 = v13;
      v59 = 0;
      v15 = (*(__int64 (__fastcall **)(__int64))(v14 + 0x70))(v12);
      v56 = 0;
      v55 = v15;
      p_Entity_Name = "Entity_Name";
      v51 = 0;
      v53 = 0;
      v52 = *a6;
      p_Entity_Name_1 = 0;
      v49 = v7;
      v50 = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v64[0] = 0;
      HIDWORD(v37) = 0xE;
      LODWORD(v37) = (unsigned __int8)sub_14056A7D0(0x31) + 0xC7;
      v38 = &v37;
      v39 = &v38;
      sub_144BEEFA0(
        3u,
        (__int64 *)&v38,
        "LoadingPlatformUtilities::LoadFromXmlNode",
        "Failed to find child node. ChildNodeName[$$] SourceString[$$] EnityName[$$] EntityId[$$]",
        1,
        v11,
        v64,
        0,
        (__int64)ThreadLogContextSlot,
        &p_Entity_Name_1,
        &v51,
        &p_Entity_Name,
        &p_Entity_Id);
      sub_1402A3D30(v50);
      sub_1402A3D30(v53);
      sub_1402A3D30(v56);
    }
    v17 = *(void (__fastcall **)(_QWORD))a7;
    if ( *(_QWORD *)(a7 + 8) == 1 )
      v17(0);
    else
      ((void (__fastcall *)(__int64, _QWORD))v17)(a7, 0);
    if ( v65 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v65 + 0x28LL))(v65);
    v18 = (volatile signed __int32 *)*((_QWORD *)a3 + 1);
    if ( v18 && _InterlockedExchangeAdd(v18 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
      if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8LL))(v18);
    }
    return;
  }
  v37 = v65;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  *(_OWORD *)v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v65 + 0x20LL))(v65);
  sub_14040AE50((__int64)&v41, a2, &v37, (__int64)"entitySuperGUID");
  if ( sub_14040A530(&v41) )
  {
    LOBYTE(v19) = 0x3F;
    (*(void (__fastcall **)(_QWORD, __int64 *, __int64, __int64, _QWORD))(**(_QWORD **)a3 + 0x70LL))(
      *(_QWORD *)a3,
      &v41,
      v19,
      a7,
      *a6);
    v34 = (char *)v44[0];
    if ( v44[0] )
    {
      v35 = (char *)v44[1];
      if ( v44[0] != v44[1] )
      {
        do
        {
          sub_140370D10(v34);
          v34 += 8;
        }
        while ( v34 != v35 );
        v34 = (char *)v44[0];
      }
      v36 = v34;
      if ( ((v45 - (_QWORD)v34) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        v34 = (char *)*((_QWORD *)v34 + 0xFFFFFFFF);
        if ( (unsigned __int64)(v36 - v34 - 8) > 0x1F )
          goto LABEL_44;
      }
      sub_1402A3D30(v34);
      *(_OWORD *)v44 = 0;
      v45 = 0;
    }
    v33 = v42;
    if ( !v42 )
      goto LABEL_30;
    if ( ((*((_QWORD *)&v43 + 1) - (_QWORD)v42) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
      goto LABEL_29;
    v33 = (_BYTE *)*((_QWORD *)v42 + 0xFFFFFFFF);
    if ( (unsigned __int64)(v42 - v33 - 8) <= 0x1F )
      goto LABEL_29;
LABEL_44:
    invalid_parameter_noinfo_noreturn();
  }
  v20 = sub_14056A7D0(0x31);
  HIDWORD(v37) = 0xE;
  LODWORD(v37) = v20 + 0xC7;
  v38 = &v37;
  v39 = &v38;
  v21 = invokeGlobalCallbackAndMaskStatusBits(
          3,
          (__int64)&v38,
          (__int64)"LoadingPlatformUtilities::LoadFromXmlNode",
          "Failed to read SuperGUID. ObjectContainerId[$$] ChildNodeName[$$] SourceString[$$] EnityName[$$] EntityId[$$]");
  if ( (v21 & 0xFFFFF) != 0 )
  {
    v22 = a1 & 0xFFFFFFFFFFFFLL;
    v23 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v22 + 8LL))(v22, v63);
    p_Entity_Id = "Entity_Id";
    v24 = *(_QWORD *)v22;
    v58 = v23;
    v59 = 0;
    v25 = (*(__int64 (__fastcall **)(__int64))(v24 + 0x70))(v22);
    v50 = 0;
    v49 = v25;
    p_Entity_Name_1 = "Entity_Name";
    v51 = 0;
    v53 = 0;
    v26 = *a6;
    p_ocId = "ocId";
    v52 = v26;
    p_Entity_Name = 0;
    v55 = v7;
    v56 = 0;
    v61 = (__int64 *)a2;
    v62 = 0;
    ThreadLogContextSlot_1 = getThreadLogContextSlot();
    v64[0] = 0;
    v28 = sub_14056A7D0(0x31);
    HIDWORD(v37) = 0xE;
    LODWORD(v37) = v28 + 0xC7;
    v38 = &v37;
    v39 = &v38;
    sub_144BE8650(
      3u,
      (__int64 *)&v38,
      "LoadingPlatformUtilities::LoadFromXmlNode",
      "Failed to read SuperGUID. ObjectContainerId[$$] ChildNodeName[$$] SourceString[$$] EnityName[$$] EntityId[$$]",
      1,
      v21,
      v64,
      0,
      (__int64)ThreadLogContextSlot_1,
      &p_ocId,
      &p_Entity_Name,
      &v51,
      &p_Entity_Name_1,
      &p_Entity_Id);
    sub_1402A3D30(v56);
    sub_1402A3D30(v53);
    sub_1402A3D30(v50);
  }
  v29 = *(void (__fastcall **)(_QWORD))a7;
  if ( *(_QWORD *)(a7 + 8) == 1 )
    v29(0);
  else
    ((void (__fastcall *)(__int64, _QWORD))v29)(a7, 0);
  v30 = (char *)v44[0];
  if ( v44[0] )
  {
    v31 = (char *)v44[1];
    if ( v44[0] != v44[1] )
    {
      do
      {
        sub_140370D10(v30);
        v30 += 8;
      }
      while ( v30 != v31 );
      v30 = (char *)v44[0];
    }
    v32 = v30;
    if ( ((v45 - (_QWORD)v30) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      v30 = (char *)*((_QWORD *)v30 + 0xFFFFFFFF);
      if ( (unsigned __int64)(v32 - v30 - 8) > 0x1F )
        goto LABEL_44;
    }
    sub_1402A3D30(v30);
    *(_OWORD *)v44 = 0;
    v45 = 0;
  }
  v33 = v42;
  if ( v42 )
  {
    if ( ((*((_QWORD *)&v43 + 1) - (_QWORD)v42) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000
      || (v33 = (_BYTE *)*((_QWORD *)v42 + 0xFFFFFFFF), (unsigned __int64)(v42 - v33 - 8) <= 0x1F) )
    {
LABEL_29:
      sub_1402A3D30(v33);
      v43 = 0;
      v42 = 0;
      goto LABEL_30;
    }
    goto LABEL_44;
  }
LABEL_30:
  if ( v65 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v65 + 0x28LL))(v65);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>(a3);
}

// --- End Function: sub_144D576E0 (0x144D576E0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 rotatedCookie; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  rotatedCookie = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)rotatedCookie )
  {
    StackCookie = __ROR8__(rotatedCookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

