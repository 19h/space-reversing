// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x142277AF0 (sub_142277AF0)
// Caller Depth: 1
// Callee/Ref Depth: 6
// Total Functions Found: 106
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402D2790 (0x1402D2790) ---
unsigned __int64 __fastcall sub_1402D2790(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(result + 24) && (result = *(unsigned int *)(a1 + 20), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 20) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CB820((volatile signed __int64 *)a1, v3);
    }
  }
  return result;
}

// --- End Function: sub_1402D2790 (0x1402D2790) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: validateHandleAccess (0x14030EC00) ---
// Validates a given handle by checking its internal type, flags, and thread-
// specific access permissions. It extracts the raw pointer and flags from the
// handle, then performs checks against metadata associated with the handle. It
// also verifies if the current thread's context or global settings permit access
// to the handle based on its type.
bool __fastcall validateHandleAccess(unsigned __int64 *a1)
{
  unsigned __int64 handleValue; // r9
  __int64 rawPointer; // r10
  unsigned __int64 handleFlags; // r9
  __int64 flagMask; // rax
  __int64 metadataBase; // r10
  __int64 metadataPtr; // rbx
  bool isThreadAccessPermitted; // al

  handleValue = *a1;
  if ( !*a1 )
    return 0;
  rawPointer = handleValue & 0xFFFFFFFFFFFFLL;
  handleFlags = HIWORD(handleValue);
  if ( (handleFlags & 0xF000) != 0 )
  {
    flagMask = map_flag_to_mask(0x2000u);
    metadataPtr = metadataBase & ~(flagMask - 1);
  }
  else
  {
    metadataPtr = rawPointer - 6;
  }
  if ( *(_WORD *)(metadataPtr + 2) != (handleFlags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (isThreadAccessPermitted = sub_140539D80()) )
    isThreadAccessPermitted = 1;
  return *(_WORD *)(metadataPtr + 4) == 2 && isThreadAccessPermitted || sub_140392020(a1) != 0;
}

// --- End Function: validateHandleAccess (0x14030EC00) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 24576 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_1403298D0 (0x1403298D0) ---
__int64 __fastcall sub_1403298D0(_BYTE *a1)
{
  unsigned __int64 v1; // rax
  _BYTE *v2; // rdx
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbx
  int v5; // eax
  unsigned int n3; // ecx

  if ( !a1 || !*a1 )
    return 3;
  v1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v1;
  while ( a1[v1] );
  v2 = &a1[v1 + 0xFFFFFFFF];
  if ( v2 < a1 )
  {
LABEL_11:
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    while ( *v2 != 0x2E )
    {
      if ( *v2 != 0x2F && *v2 != 0x3A && *v2 != 0x5C && --v2 >= a1 )
        continue;
      goto LABEL_11;
    }
    p_p_p_p_p_p_p_p_p_p_p_p_Source = v2 + 1;
  }
  if ( !_stricmp(p_p_p_p_p_p_p_p_p_p_p_p_Source, "chr")
    || !_stricmp(p_p_p_p_p_p_p_p_p_p_p_p_Source, "skel")
    || !_stricmp(p_p_p_p_p_p_p_p_p_p_p_p_Source, "cdf")
    || !_stricmp(p_p_p_p_p_p_p_p_p_p_p_p_Source, "cga") )
  {
    return 0;
  }
  if ( !_stricmp(p_p_p_p_p_p_p_p_p_p_p_p_Source, "skin") )
    return 2;
  v5 = _stricmp(p_p_p_p_p_p_p_p_p_p_p_p_Source, "cgf");
  n3 = 3;
  if ( !v5 )
    return 1;
  return n3;
}

// --- End Function: sub_1403298D0 (0x1403298D0) ---

// --- Function: sub_140336140 (0x140336140) ---
__int64 __fastcall sub_140336140(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *p_sub_1403E1790)(); // rax

  sub_1403E30D0();
  if ( (dword_149B3D560 & 0x100000) != 0 )
  {
    p_sub_1403E1790 = (__int64 (__fastcall *)())sub_1403E1630;
  }
  else
  {
    sub_1403E19B0();
    p_sub_1403E1790 = (__int64 (__fastcall *)())sub_1403E1790;
  }
  off_149924C30[0] = p_sub_1403E1790;
  return ((__int64 (__fastcall *)(_QWORD, __int64, __int64))p_sub_1403E1790)(a1, a2, a3);
}

// --- End Function: sub_140336140 (0x140336140) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: sub_14035B360 (0x14035B360) ---
void **__fastcall sub_14035B360(void **a1, void *a2, size_t Size)
{
  _DWORD *v6; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( Size )
  {
    v6 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v6 + 2;
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B360 (0x14035B360) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140377F00 (0x140377F00) ---
char **__fastcall sub_140377F00(char **a1, char **a2)
{
  char *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E9810(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377F00 (0x140377F00) ---

// --- Function: sub_14037FC70 (0x14037FC70) ---
const ULONG_PTR *__fastcall sub_14037FC70(__int64 a1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)a1 )
    return *(const ULONG_PTR **)a1;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14037FC70 (0x14037FC70) ---

// --- Function: sub_1403847F0 (0x1403847F0) ---
void **__fastcall sub_1403847F0(void **a1, char **a2)
{
  sub_1403DFF30(a1, *a2, *((int *)*a2 + 0xFFFFFFFE));
  return a1;
}

// --- End Function: sub_1403847F0 (0x1403847F0) ---

// --- Function: sub_140384840 (0x140384840) ---
void **__fastcall sub_140384840(void **a1, char *a2)
{
  unsigned __int64 Size; // rax

  if ( a2 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DFF30(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DFF30(a1, 0, 0);
    return a1;
  }
}

// --- End Function: sub_140384840 (0x140384840) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B3D00 (0x1403B3D00) ---
__int64 *__fastcall sub_1403B3D00(__int64 a1)
{
  __int64 (__fastcall ***v2)(_QWORD, __int64); // rax
  __int64 v3; // rax

  v2 = (__int64 (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0
                                                                                     + 0x240LL))(qword_149B4FCA0);
  v3 = (**v2)(v2, a1);
  if ( v3 )
    return (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x10LL))(v3);
  if ( (dword_149B3E068 & 1) == 0 )
  {
    dword_149B3E068 |= 1u;
    qword_149B3E060 = (__int64)&qword_149B3B33C + 4;
    atexit(sub_1480BD370);
  }
  return &qword_149B3E060;
}

// --- End Function: sub_1403B3D00 (0x1403B3D00) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403B4BC0 (0x1403B4BC0) ---
__int64 __fastcall sub_1403B4BC0(__int64 a1)
{
  unsigned int n0x26B2BBF1; // edx
  __int64 result; // rax

  n0x26B2BBF1 = *(_DWORD *)(a1 + 0x90);
  if ( !n0x26B2BBF1 || n0x26B2BBF1 == 0x26B2BBF1 || n0x26B2BBF1 == 0xD634F8FC )
    return 0;
  result = 0;
  if ( n0x26B2BBF1 != 0x46C01EB2 )
    return n0x26B2BBF1;
  return result;
}

// --- End Function: sub_1403B4BC0 (0x1403B4BC0) ---

// --- Function: sub_1403BFA30 (0x1403BFA30) ---
bool __fastcall sub_1403BFA30(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BFA30 (0x1403BFA30) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149B4FCF8;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403CB300 (0x1403CB300) ---
double __fastcall sub_1403CB300(__int64 a1, signed __int64 a2, const char *a3, const char *a4, char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403CB380(a1, a2, a3, a4);
  else
    return sub_1403CB5B0(a1, a2, a3, a4);
}

// --- End Function: sub_1403CB300 (0x1403CB300) ---

// --- Function: sub_1403CB380 (0x1403CB380) ---
double __fastcall sub_1403CB380(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  _BYTE v19[16]; // [rsp+30h] [rbp-29h] BYREF
  int n5632; // [rsp+40h] [rbp-19h] BYREF
  __int64 v21; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v23; // [rsp+50h] [rbp-9h]
  unsigned __int64 v24; // [rsp+58h] [rbp-1h]
  __int64 v25; // [rsp+60h] [rbp+7h]
  __int64 v26; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 284LL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 248LL))(v4, v19, &v27);
  if ( (a2 & 0x200000) == 0 )
    return result;
  v12 = (unsigned __int64)v11 << 32;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 292) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n5632 = 5632;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v21 = 1;
      n2 = 2;
      v23 = __rdtsc();
      qword_149B4B870(
        &n5632,
        &word_149B3E384,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        146);
      v15 = word_149B3E384;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(v10 + 292) = -1;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n5632 = 5632;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  n2 = 2;
  v23 = __rdtsc();
  qword_149B4B870(
    &n5632,
    &word_149B3E388,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    177);
  v15 = word_149B3E388;
LABEL_10:
  HIWORD(n5632) = v15;
  qword_149B4B8B0("Lock: %s", a4);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
  qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
  qword_149B4B8B0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 232LL))(v4, v11);
  v24 = __rdtsc();
  return qword_149B4B878(&n5632);
}

// --- End Function: sub_1403CB380 (0x1403CB380) ---

// --- Function: sub_1403CB5B0 (0x1403CB5B0) ---
double __fastcall sub_1403CB5B0(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int *p_n5632; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  int v15; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v16[3]; // [rsp+34h] [rbp-65h] BYREF
  int n5632_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v18; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+50h] [rbp-49h]
  unsigned __int64 v21; // [rsp+58h] [rbp-41h]
  __int64 v22; // [rsp+60h] [rbp-39h]
  __int64 v23; // [rsp+68h] [rbp-31h]
  int n5632; // [rsp+90h] [rbp-9h] BYREF
  __int64 v25; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v27; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v28; // [rsp+A8h] [rbp+Fh]
  __int64 v29; // [rsp+B0h] [rbp+17h]
  __int64 v30; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 296LL))(qword_149B4FCF8, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n5632 = 5632;
        v25 = 1;
        n2 = 2;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v27 = __rdtsc();
        qword_149B4B870(
          &n5632,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          98);
        HIWORD(n5632) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", a4);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v16[0] = v10;
        qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n5632 = &n5632;
        v28 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return result;
    }
    n5632_1 = 5632;
    v18 = 1;
    n2_1 = 2;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v20 = __rdtsc();
    qword_149B4B870(
      &n5632_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      74);
    HIWORD(n5632_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", a4);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
    qword_149B4B8B0("Caller: %s", a3);
    v15 = v6;
    qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n5632 = &n5632_1;
    v21 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_n5632);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: sub_1403CB5B0 (0x1403CB5B0) ---

// --- Function: sub_1403CB820 (0x1403CB820) ---
unsigned __int64 __fastcall sub_1403CB820(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  unsigned __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v8 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 |= (unsigned __int64)v5 << 48;
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
      break;
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
      return result;
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
    return qword_149B3B488(a1);
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v7 & (v9 - 1)) << 9) + v11 + 284) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FCF8 + 216LL))(
             qword_149B4FCF8,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: sub_1403CB820 (0x1403CB820) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 192LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403D8950 (0x1403D8950) ---
void **__fastcall sub_1403D8950(__int64 *a1, void **a2, const char *Control, int *a4)
{
  __int64 v6; // rcx
  const char *v10; // rdi
  unsigned __int64 v11; // rsi
  int v12; // r12d
  const char *v13; // rcx
  int Size; // eax
  int v15; // edx

  v6 = *a4;
  if ( (int)v6 >= 0 )
  {
    if ( Control )
    {
      v10 = (const char *)(*a1 + v6);
      v11 = *a1 + *(int *)(*a1 - 8);
      if ( (unsigned __int64)v10 >= v11 || (v12 = strspn(v10, Control), v13 = &v10[v12], (unsigned __int64)v13 >= v11) )
      {
        *a4 = 0xFFFFFFFF;
        *a2 = (char *)&qword_149B3B33C + 4;
      }
      else
      {
        Size = strcspn(v13, Control);
        v15 = v12 + *a4;
        *a4 = v15 + Size + 1;
        sub_1403EAE30(a1, a2, v15, Size);
      }
      return a2;
    }
    else
    {
      sub_14035B160(a2, (const void **)a1);
      return a2;
    }
  }
  else
  {
    *a2 = (char *)&qword_149B3B33C + 4;
    return a2;
  }
}

// --- End Function: sub_1403D8950 (0x1403D8950) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 16) & (unsigned int)(v9 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 = (v5 << 16) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 284) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 216LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403DFF30 (0x1403DFF30) ---
void __fastcall sub_1403DFF30(void **a1, char *a2, size_t Size)
{
  _BYTE *v4; // rbp
  size_t Size_1; // r13
  unsigned __int64 n8; // r15
  _DWORD *v9; // rax
  char *v10; // rcx

  if ( Size )
  {
    v4 = *a1;
    Size_1 = *((int *)*a1 + 0xFFFFFFFE);
    if ( Size + Size_1 <= *((int *)*a1 + 0xFFFFFFFF) )
    {
      if ( &v4[Size_1] != a2 )
        memcpy(&v4[Size_1], a2, Size);
      *((_DWORD *)*a1 + 0xFFFFFFFE) += Size;
      *((_BYTE *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= Size + Size_1 )
        n8 = Size + Size_1;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        v9 = (_DWORD *)allocWithProfilerInfo(n8 + 9, 0);
        *a1 = v9 + 2;
        *v9 = n8;
        v9[1] = n8;
        *((_BYTE *)*a1 + n8) = 0;
        if ( *a1 != v4 )
          memcpy(*a1, v4, Size_1);
        v10 = (char *)*a1 + Size_1;
        if ( v10 != a2 )
          memcpy(v10, a2, Size);
        *((_DWORD *)*a1 + 0xFFFFFFFE) = Size + Size_1;
        *((_BYTE *)*a1 + Size_1 + Size) = 0;
      }
      if ( *((int *)v4 + 0xFFFFFFFF) > 0 )
        sub_147605980(v4 + 0xFFFFFFF8);
    }
  }
}

// --- End Function: sub_1403DFF30 (0x1403DFF30) ---

// --- Function: sub_1403E1630 (0x1403E1630) ---
unsigned __int64 __fastcall sub_1403E1630(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r14
  __m128i v11; // xmm3
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // r15
  unsigned __int8 *v15; // rbx
  unsigned __int8 v16; // al
  unsigned __int64 result; // rax
  unsigned __int8 v18[16]; // [rsp+20h] [rbp-48h] BYREF

  _XMM5 = xmmword_1481B6CF0;
  v4 = 0;
  v6 = 0;
  v7 = a1;
  if ( (a3 & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
  {
    do
    {
      _XMM3 = *(__m128i *)(a2 + v6);
      __asm
      {
        vpcmpgtb xmm1, xmm5, xmm3
        vpcmpgtb xmm0, xmm3, xmm4
      }
      v11 = _mm_add_epi8((__m128i)(_XMM1 & _XMM0 & xmmword_1481B6C40), _XMM3);
      v6 += 0x10LL;
      LODWORD(v7) = _mm_crc32_u64(_mm_crc32_u64(v7, v11.m128i_u64[0]), _mm_extract_epi64(v11, 1));
    }
    while ( v6 < (a3 & 0xFFFFFFFFFFFFFFF0uLL) );
  }
  v12 = 0;
  v13 = a3 - v6;
  if ( v13 )
  {
    v14 = a2 - (_QWORD)v18 + v6;
    do
    {
      v15 = &v18[v12];
      v16 = tolower(v18[v12 + v14]);
      ++v12;
      *v15 = v16;
    }
    while ( v12 < v13 );
  }
  result = (unsigned int)v7;
  if ( (v13 & 0xFFFFFFFFFFFFFFF8uLL) != 0 )
  {
    do
    {
      result = _mm_crc32_u64(result, *(_QWORD *)&v18[v4]);
      v4 += 8LL;
    }
    while ( v4 < (v13 & 0xFFFFFFFFFFFFFFF8uLL) );
  }
  if ( (v13 & 4) != 0 )
  {
    result = _mm_crc32_u32(result, *(_DWORD *)&v18[v4]);
    v4 += 4LL;
  }
  if ( (v13 & 2) != 0 )
  {
    result = _mm_crc32_u16(result, *(_WORD *)&v18[v4]);
    v4 += 2LL;
  }
  if ( (v13 & 1) != 0 )
    return _mm_crc32_u8(result, v18[v4]);
  return result;
}

// --- End Function: sub_1403E1630 (0x1403E1630) ---

// --- Function: sub_1403E1790 (0x1403E1790) ---
__int64 __fastcall sub_1403E1790(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 i; // rdi
  int C; // ecx

  for ( i = a3; i; --i )
  {
    C = *a2++;
    a1 = unk_149B3D6A0[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403E1790 (0x1403E1790) ---

// --- Function: sub_1403E19B0 (0x1403E19B0) ---
__int64 sub_1403E19B0()
{
  int n0xFF; // r10d
  _DWORD *v1; // r11
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  __int64 result; // rax
  int v13; // r9d
  signed int n0x1E; // r8d
  unsigned int v15; // eax

  n0xFF = 0;
  v1 = unk_149B3D6A0;
  do
  {
    v2 = ((n0xFF & 1) << 7) | 0x40;
    if ( (n0xFF & 2) == 0 )
      v2 = (n0xFF & 1) << 7;
    v3 = v2 | 0x20;
    if ( (n0xFF & 4) == 0 )
      v3 = v2;
    v4 = v3 | 0x10;
    if ( (n0xFF & 8) == 0 )
      v4 = v3;
    v5 = v4 | 8;
    if ( (n0xFF & 0x10) == 0 )
      v5 = v4;
    v6 = v5 | 4;
    if ( (n0xFF & 0x20) == 0 )
      v6 = v5;
    v7 = v6 | 2;
    if ( (n0xFF & 0x40) == 0 )
      v7 = v6;
    v8 = v7 | 1;
    if ( (((unsigned int)n0xFF >> 6) & 2) == 0 )
      v8 = v7;
    v9 = (((2
          * ((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41) >> 0x1F)
           & 0x1EDC6F41))
         ^ (((2
            * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
             & 0x1EDC6F41) >> 0x1F)
           & 0x1EDC6F41) >> 0x1F)
         & 0x1EDC6F41) >> 0x1F)
       & 0x1EDC6F41;
    v10 = (2
         * ((2
           * ((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41) >> 0x1F)
            & 0x1EDC6F41))
          ^ (((2
             * ((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 0x19) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 0x1F)
              & 0x1EDC6F41) >> 0x1F)
            & 0x1EDC6F41) >> 0x1F)
          & 0x1EDC6F41))
        ^ v9;
    v11 = (2 * ((2 * v10) ^ (v10 >> 0x1F) & 0x1EDC6F41))
        ^ (((2 * v10) ^ (v10 >> 0x1F) & 0x1EDC6F41) >> 0x1F)
        & 0x1EDC6F41;
    LODWORD(result) = (2 * v11) ^ (v11 >> 0x1F) & 0x1EDC6F41;
    v13 = 0;
    n0x1E = 0x1E;
    do
    {
      if ( (result & 1) != 0 )
        v13 |= 1 << (n0x1E + 1);
      v15 = (unsigned int)result >> 1;
      if ( (v15 & 1) != 0 )
        v13 |= 1 << n0x1E;
      result = v15 >> 1;
      n0x1E -= 2;
    }
    while ( n0x1E > (int)0xFFFFFFFE );
    *v1 = v13;
    ++n0xFF;
    ++v1;
  }
  while ( n0xFF <= 0xFF );
  return result;
}

// --- End Function: sub_1403E19B0 (0x1403E19B0) ---

// --- Function: sub_1403E30D0 (0x1403E30D0) ---
void sub_1403E30D0()
{
  __int64 n7; // rax
  __int64 Relationship; // rcx
  unsigned int v25; // r8d
  __int64 Relationship_1; // rcx
  __int64 Relationship_2; // rcx
  __int64 Relationship_3; // rcx
  __int64 v41; // rbx
  unsigned __int64 NodeNumber; // rcx
  unsigned __int64 size; // rcx
  void *v44; // rsp
  void *v45; // rsp
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *p_Buffer; // r15
  unsigned __int64 v47; // r12
  int v48; // r13d
  unsigned __int8 v49; // cl
  unsigned __int8 v50; // r14
  unsigned __int8 v51; // cl
  unsigned __int8 v52; // si
  unsigned __int8 v53; // cl
  unsigned __int8 v54; // di
  unsigned __int8 v55; // cl
  unsigned __int8 v56; // r10
  unsigned __int8 v57; // cl
  unsigned __int8 v58; // r9
  unsigned __int8 v59; // cl
  unsigned __int8 v60; // r8
  unsigned __int8 v61; // cl
  unsigned __int8 v62; // al
  __int64 v63; // rcx
  _BYTE *v64; // rax
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer; // [rsp+20h] [rbp+0h] BYREF

  if ( !byte_149B3B502 )
  {
    _RAX = 1;
    __asm { cpuid }
    dword_149B3D558 = _RAX;
    n7 = 7;
    dword_149B3D560 = _RCX;
    dword_149B3D55C = _RBX;
    dword_149B3D564 = _RDX;
    __asm { cpuid }
    dword_149B3D56C = _RAX;
    _RAX = 0x80000007LL;
    dword_149B3D574 = _RCX;
    dword_149B3D570 = _RBX;
    dword_149B3D578 = _RDX;
    __asm { cpuid }
    dword_149B3D57C = _RAX;
    _RAX = 0x80000001LL;
    dword_149B3D584 = _RCX;
    dword_149B3D580 = _RBX;
    dword_149B3D588 = _RDX;
    __asm { cpuid }
    _RAX = 0x80000000LL;
    dword_149B3D58C = _RCX;
    dword_149B3D590 = _RDX;
    __asm { cpuid }
    LODWORD(Buffer.ProcessorMask) = 0xFFFFFFFF;
    v25 = _RAX;
    HIDWORD(Buffer.ProcessorMask) = _RBX;
    Buffer.Relationship = Relationship;
    *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
    if ( (unsigned int)_RAX > 0x80000002 )
    {
      _RAX = 0x80000002LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_1;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149B3D5A0 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000003 )
    {
      _RAX = 0x80000003LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_2;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149B3D5B0 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000004 )
    {
      _RAX = 0x80000004LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_3;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_149B3D5C0 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    v41 = 0;
    Buffer.NumaNode.NodeNumber = 0;
    if ( GetLogicalProcessorInformation(0, &Buffer.NumaNode.NodeNumber) || GetLastError() != ERROR_INSUFFICIENT_BUFFER )
      __debugbreak();
    NodeNumber = Buffer.NumaNode.NodeNumber + 0xFLL;
    if ( NodeNumber <= Buffer.NumaNode.NodeNumber )
      NodeNumber = 0xFFFFFFFFFFFFFF0LL;
    size = NodeNumber & 0xFFFFFFFFFFFFFFF0uLL;
    v44 = alloca(size);
    v45 = alloca(size);
    p_Buffer = &Buffer;
    if ( !GetLogicalProcessorInformation(&Buffer, &Buffer.NumaNode.NodeNumber) )
      __debugbreak();
    v47 = (unsigned __int64)Buffer.NumaNode.NodeNumber >> 5;
    if ( v47 )
    {
      v48 = dword_149B3D568;
      do
      {
        if ( p_Buffer->Relationship == RelationProcessorCore )
        {
          v49 = (p_Buffer->ProcessorMask & 0x55) + (((unsigned __int8)p_Buffer->ProcessorMask >> 1) & 0x55);
          v50 = (v49 & 0x33) + ((v49 >> 2) & 0x33);
          v51 = (BYTE1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE1(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v52 = (v51 & 0x33) + ((v51 >> 2) & 0x33);
          v53 = (WORD1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE2(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v54 = (v53 & 0x33) + ((v53 >> 2) & 0x33);
          v55 = (BYTE3(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE3(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v56 = (v55 & 0x33) + ((v55 >> 2) & 0x33);
          v57 = (HIDWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE4(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v58 = (v57 & 0x33) + ((v57 >> 2) & 0x33);
          v59 = (((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) & 0x55)
              + (((unsigned __int8)((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) >> 1) & 0x55);
          v60 = (v59 & 0x33) + ((v59 >> 2) & 0x33);
          v61 = (HIWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE6(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v62 = (HIBYTE(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)HIBYTE(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v48 += (unsigned __int8)((v50 >> 4)
                                 + (v50 & 0xF)
                                 + (v52 >> 4)
                                 + (v52 & 0xF)
                                 + (v54 >> 4)
                                 + (v54 & 0xF)
                                 + (v56 >> 4)
                                 + (v56 & 0xF)
                                 + (v58 >> 4)
                                 + (v58 & 0xF)
                                 + (v60 >> 4)
                                 + (v60 & 0xF)
                                 + ((unsigned __int8)((v61 & 0x33) + ((v61 >> 2) & 0x33)) >> 4)
                                 + (((v61 & 0x33) + ((v61 >> 2) & 0x33)) & 0xF)
                                 + ((unsigned __int8)((v62 & 0x33) + ((v62 >> 2) & 0x33)) >> 4)
                                 + (((v62 & 0x33) + ((v62 >> 2) & 0x33)) & 0xF));
        }
        ++p_Buffer;
        --v47;
      }
      while ( v47 );
      dword_149B3D568 = v48;
    }
    v63 = 0;
    if ( (_BYTE)xmmword_149B3D5A0 )
    {
      do
      {
        for ( ; *((_BYTE *)&xmmword_149B3D5A0 + v41) == 0x20; ++v41 )
          ;
        *((_BYTE *)&xmmword_149B3D5A0 + v63) = *((_BYTE *)&xmmword_149B3D5A0 + v41);
        if ( *((_BYTE *)&xmmword_149B3D5A0 + v41) )
        {
          while ( 1 )
          {
            v64 = (char *)&xmmword_149B3D5A0 + v41;
            ++v63;
            ++v41;
            if ( *v64 == 0x20 )
              break;
            *((_BYTE *)&xmmword_149B3D5A0 + v63) = *((_BYTE *)&xmmword_149B3D5A0 + v41);
            if ( !*((_BYTE *)&xmmword_149B3D5A0 + v41) )
              goto LABEL_27;
          }
        }
        else
        {
LABEL_27:
          if ( v63 )
          {
            if ( *((_BYTE *)&xmmword_149B3D5A0 + v63 - 1) == 0x20 )
              *((_BYTE *)&xmmword_149B3D5A0 + v63 - 1) = 0;
          }
        }
      }
      while ( *((_BYTE *)&xmmword_149B3D5A0 + v41) );
    }
    byte_149B3B502 = 1;
  }
}

// --- End Function: sub_1403E30D0 (0x1403E30D0) ---

// --- Function: sub_1403E42A0 (0x1403E42A0) ---
void __fastcall sub_1403E42A0(char **a1)
{
  if ( *((_DWORD *)*a1 + 0xFFFFFFFE) )
    sub_1403E9810(a1, 0, 0x20);
}

// --- End Function: sub_1403E42A0 (0x1403E42A0) ---

// --- Function: sub_1403E5570 (0x1403E5570) ---
bool __fastcall sub_1403E5570(_QWORD *a1)
{
  return !*a1 || !*(_BYTE *)*a1;
}

// --- End Function: sub_1403E5570 (0x1403E5570) ---

// --- Function: sub_1403E5DE0 (0x1403E5DE0) ---
char *__fastcall sub_1403E5DE0(__int64 *a1, const char *SubStr, unsigned __int64 a3)
{
  __int64 v3; // r9
  char *v5; // rax

  v3 = *a1;
  if ( a3 <= *(int *)(*a1 - 8) && v3 + a3 && (v5 = strstr((const char *)(v3 + a3), SubStr)) != 0 )
    return &v5[-*a1];
  else
    return (char *)0xFFFFFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403E5DE0 (0x1403E5DE0) ---

// --- Function: sub_1403E7A60 (0x1403E7A60) ---
__int64 __fastcall sub_1403E7A60(_QWORD *a1)
{
  return *(int *)(*a1 - 8LL);
}

// --- End Function: sub_1403E7A60 (0x1403E7A60) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 - 1) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 - 2)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 - 2));
  memset(&(*a1)[*((int *)v3 - 2)], Val_1, Size);
  if ( *((int *)v3 - 1) > 0 )
    sub_147605980(v3 - 8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1403EAE30 (0x1403EAE30) ---
void **__fastcall sub_1403EAE30(__int64 *a1, void **a2, size_t a3, size_t Size_1)
{
  __int64 v6; // rdx
  size_t v7; // rcx
  size_t Size; // r8

  v6 = *a1;
  v7 = *(int *)(*a1 - 8);
  if ( a3 < v7 )
  {
    Size = v7 - a3;
    if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
      Size_1 = v7 - a3;
    if ( a3 + Size_1 <= v7 )
      Size = Size_1;
    sub_14035B360(a2, (void *)(a3 + v6), Size);
    return a2;
  }
  else
  {
    *a2 = (char *)&qword_149B3B33C + 4;
    return a2;
  }
}

// --- End Function: sub_1403EAE30 (0x1403EAE30) ---

// --- Function: sub_140421D10 (0x140421D10) ---
__int64 __fastcall sub_140421D10(__int64 a1, __int64 a2, _DWORD *a3, int a4)
{
  __int64 v5; // r12
  __int64 v7; // rax
  __int64 v8; // rbp
  size_t i; // r12
  const ULONG_PTR *v10; // rax
  unsigned __int64 v11; // rbx
  char *v12; // rsi
  char *v13; // rbx
  size_t v14; // rdi
  size_t v15; // r14
  __int64 v16; // r12
  char *v17; // rsi
  unsigned __int64 v18; // rbx
  unsigned __int64 v19; // rbx
  size_t v20; // rdi
  __int64 v21; // rbp
  size_t v22; // rbx
  const ULONG_PTR *v23; // rax
  char *v24; // rbx
  char *v25; // rbp
  int v26; // edi
  __int64 v27; // rdx
  int v28; // ecx
  int v30; // [rsp+20h] [rbp-68h] BYREF
  __int64 v31; // [rsp+28h] [rbp-60h]
  size_t v32; // [rsp+30h] [rbp-58h]
  __int64 v33; // [rsp+38h] [rbp-50h]
  size_t v34; // [rsp+40h] [rbp-48h]
  __int64 v35; // [rsp+48h] [rbp-40h]
  __int64 v36; // [rsp+98h] [rbp+10h]
  int v37; // [rsp+A0h] [rbp+18h]

  v36 = a2;
  *a3 = a4;
  v5 = *(_QWORD *)(a2 + 0x140);
  v7 = 0x160LL * *(_QWORD *)(a2 + 0x148);
  v33 = v5;
  v35 = v5 + v7;
  if ( v5 == v5 + v7 )
    return a2;
  v8 = v5 + 8;
  v31 = v5 + 8;
  do
  {
    v37 = 0;
    for ( i = 0; ; i = v32 )
    {
      v10 = sub_14037FC70(v8);
      v11 = 0xFFFFFFFFFFFFFFFFuLL;
      v12 = (char *)v10 + i;
      do
        ++v11;
      while ( *((_BYTE *)v10 + v11) );
      v13 = (char *)v10 + v11;
      if ( v12 >= v13 )
        break;
      v14 = strspn((const char *)v10 + i, " ");
      if ( &v12[v14] >= v13 )
        break;
      v15 = strcspn(&v12[v14], " ");
      v34 = i;
      v32 = v14 + v15 + 1 + i;
      if ( i == 0xFFFFFFFFFFFFFFFFuLL )
        break;
      v16 = 0;
      while ( 1 )
      {
        v17 = (char *)(v16 + a1);
        v18 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++v18;
        while ( *(_BYTE *)(a1 + v18) );
        v19 = a1 + v18;
        if ( (unsigned __int64)v17 >= v19 )
          break;
        v20 = strspn((const char *)(v16 + a1), " ");
        if ( (unsigned __int64)&v17[v20] >= v19 )
          break;
        v21 = v16;
        v22 = strcspn(&v17[v20], " ");
        v16 += v20 + v22 + 1;
        if ( v21 == 0xFFFFFFFFFFFFFFFFuLL )
          break;
        v23 = sub_14037FC70(v31);
        if ( v15 == v22 )
        {
          if ( v15 )
          {
            v24 = v17;
            v25 = (char *)v23 + v34 - a1 - v21;
            while ( 1 )
            {
              v26 = tolower(v25[(_QWORD)v24]);
              if ( v26 != tolower(*v24) )
                break;
              if ( ++v24 - v17 >= v15 )
                goto LABEL_21;
            }
          }
          else
          {
LABEL_21:
            v27 = sub_140421D10(a1, v33, &v30, (unsigned int)(a4 + 1));
            v28 = v37 + v30;
            ++v37;
            v30 = v28;
            if ( v28 > *a3 )
            {
              *a3 = v28;
              v36 = v27;
            }
          }
        }
      }
      v8 = v31;
    }
    v8 += 0x160;
    v31 = v8;
    v33 += 0x160;
  }
  while ( v33 != v35 );
  return v36;
}

// --- End Function: sub_140421D10 (0x140421D10) ---

// --- Function: sub_140421FA0 (0x140421FA0) ---
__int64 __fastcall sub_140421FA0(__int64 a1, __int64 a2, _DWORD *a3, int a4)
{
  __int64 v5; // r12
  __int64 v7; // rax
  __int64 v8; // rbp
  size_t i; // r12
  const ULONG_PTR *v10; // rax
  unsigned __int64 v11; // rbx
  char *v12; // rsi
  char *v13; // rbx
  size_t v14; // rdi
  size_t v15; // r14
  __int64 v16; // r12
  char *v17; // rsi
  unsigned __int64 v18; // rbx
  unsigned __int64 v19; // rbx
  size_t v20; // rdi
  __int64 v21; // rbp
  size_t v22; // rbx
  const ULONG_PTR *v23; // rax
  char *v24; // rbx
  char *v25; // rbp
  int v26; // edi
  __int64 v27; // rdx
  int v28; // ecx
  int v30; // [rsp+20h] [rbp-68h] BYREF
  __int64 v31; // [rsp+28h] [rbp-60h]
  size_t v32; // [rsp+30h] [rbp-58h]
  __int64 v33; // [rsp+38h] [rbp-50h]
  size_t v34; // [rsp+40h] [rbp-48h]
  __int64 v35; // [rsp+48h] [rbp-40h]
  __int64 v36; // [rsp+98h] [rbp+10h]
  int v37; // [rsp+A0h] [rbp+18h]

  v36 = a2;
  *a3 = a4;
  v5 = *(_QWORD *)(a2 + 0x70);
  v7 = *(_QWORD *)(a2 + 0x78);
  v33 = v5;
  v35 = v5 + 0x90 * v7;
  if ( v5 == v35 )
    return a2;
  v8 = v5 + 8;
  v31 = v5 + 8;
  do
  {
    v37 = 0;
    for ( i = 0; ; i = v32 )
    {
      v10 = sub_14037FC70(v8);
      v11 = 0xFFFFFFFFFFFFFFFFuLL;
      v12 = (char *)v10 + i;
      do
        ++v11;
      while ( *((_BYTE *)v10 + v11) );
      v13 = (char *)v10 + v11;
      if ( v12 >= v13 )
        break;
      v14 = strspn((const char *)v10 + i, " ");
      if ( &v12[v14] >= v13 )
        break;
      v15 = strcspn(&v12[v14], " ");
      v34 = i;
      v32 = v14 + v15 + 1 + i;
      if ( i == 0xFFFFFFFFFFFFFFFFuLL )
        break;
      v16 = 0;
      while ( 1 )
      {
        v17 = (char *)(v16 + a1);
        v18 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++v18;
        while ( *(_BYTE *)(a1 + v18) );
        v19 = a1 + v18;
        if ( (unsigned __int64)v17 >= v19 )
          break;
        v20 = strspn((const char *)(v16 + a1), " ");
        if ( (unsigned __int64)&v17[v20] >= v19 )
          break;
        v21 = v16;
        v22 = strcspn(&v17[v20], " ");
        v16 += v20 + v22 + 1;
        if ( v21 == 0xFFFFFFFFFFFFFFFFuLL )
          break;
        v23 = sub_14037FC70(v31);
        if ( v15 == v22 )
        {
          if ( v15 )
          {
            v24 = v17;
            v25 = (char *)v23 + v34 - a1 - v21;
            while ( 1 )
            {
              v26 = tolower(v25[(_QWORD)v24]);
              if ( v26 != tolower(*v24) )
                break;
              if ( ++v24 - v17 >= v15 )
                goto LABEL_21;
            }
          }
          else
          {
LABEL_21:
            v27 = sub_140421FA0(a1, v33, &v30, (unsigned int)(a4 + 1));
            v28 = v37 + v30;
            ++v37;
            v30 = v28;
            if ( v28 > *a3 )
            {
              *a3 = v28;
              v36 = v27;
            }
          }
        }
      }
      v8 = v31;
    }
    v8 += 0x90;
    v31 = v8;
    v33 += 0x90;
  }
  while ( v33 != v35 );
  return v36;
}

// --- End Function: sub_140421FA0 (0x140421FA0) ---

// --- Function: sub_1404232A0 (0x1404232A0) ---
_QWORD *__fastcall sub_1404232A0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( validateHandleAccess(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_11;
    if ( n0xFFFF_11 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v9,
                            "IAttachableComponent");
      n0xFFFF_11 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_1404232A0 (0x1404232A0) ---

// --- Function: sub_140423940 (0x140423940) ---
_QWORD *__fastcall sub_140423940(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_12;
  if ( n0xFFFF_12 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "IEntityGeometryResource");
    n0xFFFF_12 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_140423940 (0x140423940) ---

// --- Function: sub_14048CBB0 (0x14048CBB0) ---
__int64 __fastcall sub_14048CBB0(__int64 a1, void **a2, __int64 *a3)
{
  unsigned __int8 v5; // di
  void **v6; // rax
  const char *SubStr; // [rsp+20h] [rbp-18h] BYREF
  void *v9[2]; // [rsp+28h] [rbp-10h] BYREF
  int v10; // [rsp+58h] [rbp+20h] BYREF

  v10 = 0;
  v5 = 0;
  sub_1403D8950(a3, (void **)&SubStr, " ", &v10);
  while ( !sub_1403BFA30(&SubStr) )
  {
    if ( (unsigned int)sub_1403E5DE0((__int64 *)a2, SubStr, 0) == 0xFFFFFFFF )
    {
      if ( !sub_1403BFA30(a2) )
        sub_140384840(a2, " ");
      sub_1403847F0(a2, (char **)&SubStr);
      v5 |= 1u;
    }
    v6 = sub_1403D8950(a3, v9, " ", &v10);
    sub_140377F00((char **)&SubStr, (char **)v6);
    sub_140370D10(v9);
  }
  sub_140370D10(&SubStr);
  return v5;
}

// --- End Function: sub_14048CBB0 (0x14048CBB0) ---

// --- Function: sub_1404BCCA0 (0x1404BCCA0) ---
__int64 __fastcall sub_1404BCCA0(__int64 a1, __int64 a2)
{
  int v3; // [rsp+40h] [rbp+18h] BYREF

  return sub_140421D10(a2, a1, &v3, 0) + 0x18;
}

// --- End Function: sub_1404BCCA0 (0x1404BCCA0) ---

// --- Function: sub_1404BCCD0 (0x1404BCCD0) ---
__int64 __fastcall sub_1404BCCD0(__int64 a1, __int64 a2)
{
  int v3; // [rsp+40h] [rbp+18h] BYREF

  return sub_140421FA0(a2, a1, &v3, 0);
}

// --- End Function: sub_1404BCCD0 (0x1404BCCD0) ---

// --- Function: sub_1404BD120 (0x1404BD120) ---
__int64 __fastcall sub_1404BD120(__int64 a1)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rbx

  if ( !*(_BYTE *)(a1 + 8) )
    return a1;
  sub_1403E42A0((char **)a1);
  *(_BYTE *)(a1 + 8) = 0;
  v2 = *(_QWORD **)(a1 + 0x18);
  v3 = (_QWORD *)*v2;
  if ( (_QWORD *)*v2 != v2 )
  {
    do
    {
      sub_14048CBB0(a1, (void **)a1, v3 + 3);
      v3 = (_QWORD *)*v3;
    }
    while ( v3 != *(_QWORD **)(a1 + 0x18) );
  }
  return a1;
}

// --- End Function: sub_1404BD120 (0x1404BD120) ---

// --- Function: sub_140505130 (0x140505130) ---
_BYTE *__fastcall sub_140505130(__int64 a1, float a2)
{
  _BYTE *result; // rax
  float v4[6]; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+48h] [rbp+10h] BYREF

  v4[0] = 0.0;
  v4[1] = 0.0;
  v4[2] = 0.0;
  v4[3] = a2 * 3.5449078;
  result = sub_140518140((__int64)v4, &v5);
  *(_DWORD *)(a1 + 0xD) = *(_DWORD *)result;
  return result;
}

// --- End Function: sub_140505130 (0x140505130) ---

// --- Function: sub_1405051A0 (0x1405051A0) ---
void __fastcall sub_1405051A0(__int64 a1, char *a2, float a3)
{
  int n0x7FFFFFFE; // ecx
  char n0x7FFFFFFE_1; // al

  if ( (float)(a3 * 255.0) < 2147483600.0 )
  {
    n0x7FFFFFFE = (int)(float)((float)(a3 * 255.0) + 0.5);
    if ( n0x7FFFFFFE < 0 )
    {
      *a2 = 0;
      return;
    }
  }
  else
  {
    n0x7FFFFFFE = 0x7FFFFFFE;
  }
  n0x7FFFFFFE_1 = 0xFF;
  if ( (unsigned int)n0x7FFFFFFE < 0xFF )
    n0x7FFFFFFE_1 = n0x7FFFFFFE;
  *a2 = n0x7FFFFFFE_1;
}

// --- End Function: sub_1405051A0 (0x1405051A0) ---

// --- Function: sub_140518140 (0x140518140) ---
_BYTE *__fastcall sub_140518140(__int64 a1, _BYTE *a2)
{
  __int128 v2; // xmm1
  __int128 v3; // kr00_16
  __int128 n0x3EFA2A1C_1; // xmm3
  __int128 n0x3EFA2A1C; // kr00_16
  __int128 n0x3EFA2A1C_3; // xmm10
  __int128 n0x3EFA2A1C_2; // kr00_16
  __int128 n0x3EFA2A1C_5; // xmm11
  __int128 n0x3EFA2A1C_4; // kr00_16
  __int128 v11; // kr00_16
  int v14; // ecx
  __int128 v20; // kr00_16
  int v22; // r8d
  __int128 v28; // kr00_16
  int v30; // eax
  __int128 v35; // kr00_16
  _BYTE *result; // rax

  v3 = *(unsigned int *)(a1 + 0xC);
  *(float *)&v3 = *(float *)(a1 + 0xC) * 0.28209481;
  v2 = v3;
  n0x3EFA2A1C = 0x3EFA2A1Cu;
  *(float *)&n0x3EFA2A1C = 0.48860252 * *(float *)a1;
  n0x3EFA2A1C_1 = n0x3EFA2A1C;
  n0x3EFA2A1C_2 = 0x3EFA2A1Cu;
  *(float *)&n0x3EFA2A1C_2 = 0.48860252 * *(float *)(a1 + 4);
  n0x3EFA2A1C_3 = n0x3EFA2A1C_2;
  n0x3EFA2A1C_4 = 0x3EFA2A1Cu;
  *(float *)&n0x3EFA2A1C_4 = 0.48860252 * *(float *)(a1 + 8);
  n0x3EFA2A1C_5 = n0x3EFA2A1C_4;
  v11 = v2;
  *(float *)&v11 = *(float *)&v2 + 0.0019607844;
  _XMM2 = v11;
  LODWORD(_XMM0) = 0;
  if ( (float)(*(float *)&v2 + 0.0019607844) >= 0.0 )
    __asm { vminss  xmm0, xmm2, xmm5 }
  LODWORD(_XMM4) = 0xBF800000;
  v14 = (int)(float)(*(float *)&_XMM0 * 255.0);
  if ( *(float *)&n0x3EFA2A1C_1 >= -1.0 )
    __asm { vminss  xmm0, xmm3, xmm5 }
  else
    LODWORD(_XMM0) = 0xBF800000;
  _XMM2 = 0x80000000;
  __asm
  {
    vandnps xmm3, xmm3, xmm0
    vroundps xmm1, xmm3, 0
  }
  v20 = _XMM3;
  *(float *)&v20 = *(float *)&_XMM3 - *(float *)&_XMM1;
  _XMM3 = v20;
  __asm { vcmpeqss xmm3, xmm3, dword ptr cs:xmmword_14819FFB0 }
  v22 = (int)COERCE_FLOAT(
               COERCE_UNSIGNED_INT(COERCE_FLOAT(_XMM3 & 0x3F800000) + *(float *)&_XMM1)
             | COERCE_UNSIGNED_INT(*(float *)&_XMM0 * 127.0) & 0x80000000);
  if ( *(float *)&n0x3EFA2A1C_3 >= -1.0 )
    __asm { vminss  xmm0, xmm10, xmm5 }
  else
    LODWORD(_XMM0) = 0xBF800000;
  _XMM2 = 0x80000000;
  __asm
  {
    vandnps xmm3, xmm3, xmm0
    vroundps xmm1, xmm3, 0
  }
  v28 = _XMM3;
  *(float *)&v28 = *(float *)&_XMM3 - *(float *)&_XMM1;
  _XMM3 = v28;
  __asm { vcmpeqss xmm3, xmm3, dword ptr cs:xmmword_14819FFB0 }
  v30 = (int)COERCE_FLOAT(
               COERCE_UNSIGNED_INT(COERCE_FLOAT(_XMM3 & 0x3F800000) + *(float *)&_XMM1)
             | COERCE_UNSIGNED_INT(*(float *)&_XMM0 * 127.0) & 0x80000000);
  if ( *(float *)&n0x3EFA2A1C_5 >= -1.0 )
    __asm { vminss  xmm4, xmm11, xmm5 }
  _XMM2 = 0x80000000;
  __asm
  {
    vandnps xmm3, xmm3, xmm0
    vroundps xmm1, xmm3, 0
  }
  v35 = _XMM3;
  *(float *)&v35 = *(float *)&_XMM3 - *(float *)&_XMM1;
  _XMM3 = v35;
  __asm { vcmpeqss xmm3, xmm3, dword ptr cs:xmmword_14819FFB0 }
  a2[1] = v30;
  a2[2] = (int)COERCE_FLOAT(
                 COERCE_UNSIGNED_INT(COERCE_FLOAT(_XMM3 & 0x3F800000) + *(float *)&_XMM1)
               | COERCE_UNSIGNED_INT(*(float *)&_XMM4 * 127.0) & 0x80000000);
  result = a2;
  *a2 = v22;
  a2[3] = v14;
  return result;
}

// --- End Function: sub_140518140 (0x140518140) ---

// --- Function: sub_14051D760 (0x14051D760) ---
void __fastcall sub_14051D760(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 0x11) = a2;
}

// --- End Function: sub_14051D760 (0x14051D760) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_1405A5080 (0x1405A5080) ---
__int64 __fastcall sub_1405A5080(__int64 a1, __int64 a2)
{
  float v2; // xmm1_4
  __int64 result; // rax

  *(_DWORD *)(a2 + 0x2C) = *(_DWORD *)(a1 + 0x58);
  *(_DWORD *)(a2 + 0x10) = *(_DWORD *)(a1 + 0x3C);
  *(_DWORD *)(a2 + 0x14) = *(_DWORD *)(a1 + 0x40);
  *(_DWORD *)(a2 + 0x18) = *(_DWORD *)(a1 + 0x44);
  *(_DWORD *)(a2 + 0x1C) = *(_DWORD *)(a1 + 0x48);
  *(_DWORD *)(a2 + 0x20) = *(_DWORD *)(a1 + 0x4C);
  *(_DWORD *)(a2 + 0x24) = *(_DWORD *)(a1 + 0x50);
  *(_DWORD *)(a2 + 0x28) = *(_DWORD *)(a1 + 0x54);
  *(_DWORD *)(a2 + 0x3C) = *(_DWORD *)(a1 + 0x68);
  *(_DWORD *)(a2 + 0x40) = *(_DWORD *)(a1 + 0x6C);
  *(_DWORD *)(a2 + 0xC) = *(_DWORD *)(a1 + 0x38);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 0x30);
  *(_DWORD *)(a2 + 0x48) = *(_DWORD *)(a1 + 0x74);
  *(_DWORD *)(a2 + 0x98) = *(unsigned __int8 *)(a1 + 0x8F);
  *(_DWORD *)(a2 + 0x9C) = *(unsigned __int8 *)(a1 + 0x90);
  *(_DWORD *)(a2 + 0xA0) = *(unsigned __int8 *)(a1 + 0x91);
  *(_DWORD *)(a2 + 0x84) = *(unsigned __int8 *)(a1 + 0x8B);
  *(_DWORD *)(a2 + 0x88) = *(unsigned __int8 *)(a1 + 0x8C);
  *(_DWORD *)(a2 + 0x8C) = *(unsigned __int8 *)(a1 + 0x8A);
  *(_DWORD *)(a2 + 0x90) = *(unsigned __int8 *)(a1 + 0x8D);
  *(_DWORD *)(a2 + 0x80) = *(unsigned __int8 *)(a1 + 0x89);
  *(_DWORD *)(a2 + 0x7C) = *(unsigned __int8 *)(a1 + 0x88);
  *(_DWORD *)(a2 + 0xB0) = *(unsigned __int8 *)(a1 + 0x92);
  *(_DWORD *)(a2 + 0x94) = *(unsigned __int8 *)(a1 + 0x8E);
  *(_DWORD *)(a2 + 0x54) = *(_DWORD *)(a1 + 0x78);
  *(_DWORD *)(a2 + 0xB8) = *(_DWORD *)(a1 + 0x98);
  *(_DWORD *)(a2 + 0xB4) = *(_DWORD *)(a1 + 0x94);
  *(_DWORD *)(a2 + 0x34) = *(_DWORD *)(a1 + 0x60);
  *(_DWORD *)(a2 + 0x44) = *(_DWORD *)(a1 + 0x70);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 0x34);
  *(_DWORD *)(a2 + 0x38) = *(_DWORD *)(a1 + 0x64);
  *(_DWORD *)(a2 + 0x30) = *(_DWORD *)(a1 + 0x5C);
  *(_DWORD *)(a2 + 0xA8) = *(unsigned __int8 *)(a1 + 0x93);
  *(_DWORD *)(a2 + 0x50) = *(_DWORD *)(a1 + 0x9C);
  *(_DWORD *)(a2 + 0x4C) = *(_DWORD *)(a1 + 0xA0);
  *(_DWORD *)(a2 + 0x5C) = *(_DWORD *)(a1 + 0xA4);
  *(_DWORD *)(a2 + 0x60) = *(_DWORD *)(a1 + 0xA8);
  *(_DWORD *)(a2 + 0x64) = *(_DWORD *)(a1 + 0xAC);
  *(_DWORD *)(a2 + 0xBC) = *(_DWORD *)(a1 + 0xB0);
  *(_DWORD *)(a2 + 0xC0) = *(_DWORD *)(a1 + 0xB4);
  v2 = *(float *)(a1 + 0x7C);
  if ( v2 > 0.0 )
    *(float *)(a2 + 0x58) = v2;
  *(_DWORD *)(a2 + 0x74) = *(_DWORD *)(a1 + 0x80);
  result = *(unsigned int *)(a1 + 0x84);
  *(_DWORD *)(a2 + 0x78) = result;
  return result;
}

// --- End Function: sub_1405A5080 (0x1405A5080) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Logs a fatal error message. If the fatal error system is not properly
// initialized (missing necessary function pointers), it triggers a debug break.
// Otherwise, it formats the provided message into a buffer and dispatches it to an
// external logging function. Execution typically halts after this function.
_BYTE *LogFatalError(const char *formatString, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC pfnInitFatalFunctionsAddr; // rax
  _BYTE *result; // rax
  _QWORD *pStdioCommonVsnprintf; // rax
  int formattedMessageLength; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, formatString);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    pfnInitFatalFunctionsAddr = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))pfnInitFatalFunctionsAddr)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    pStdioCommonVsnprintf = sub_1402A4380();
    formattedMessageLength = _stdio_common_vsprintf(
                               *pStdioCommonVsnprintf | 2LL,
                               formattedMessageBuffer,
                               0x1000u,
                               formatString,
                               0,
                               args);
    if ( formattedMessageLength < 0 )
      formattedMessageLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedMessageLength >= 0x1000 )
      formattedMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: p_sub_140B13360 (0x140B13360) ---
__int64 __fastcall p_sub_140B13360(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x18LL))(a1);
}

// --- End Function: p_sub_140B13360 (0x140B13360) ---

// --- Function: sub_14212A920 (0x14212A920) ---
__int64 __fastcall sub_14212A920(_BYTE **a1, __int64 a2)
{
  _BYTE *v2; // r8
  __int64 result; // rax

  v2 = *a1;
  *(_BYTE *)a2 = **a1;
  *(_BYTE *)(a2 + 1) = v2[1];
  *(_BYTE *)(a2 + 2) = v2[2];
  *(_BYTE *)(a2 + 3) = v2[3];
  *(_BYTE *)(a2 + 4) = v2[4];
  *(_BYTE *)(a2 + 5) = v2[5];
  *(_BYTE *)(a2 + 6) = v2[6];
  *(_BYTE *)(a2 + 7) = v2[7];
  *(_BYTE *)(a2 + 8) = v2[8];
  *(_DWORD *)(a2 + 9) = *(_DWORD *)(v2 + 9);
  *(_DWORD *)(a2 + 0xD) = *(_DWORD *)(v2 + 0xD);
  result = (unsigned __int8)v2[0x11];
  *(_BYTE *)(a2 + 0x11) = result;
  return result;
}

// --- End Function: sub_14212A920 (0x14212A920) ---

// --- Function: sub_1421318D0 (0x1421318D0) ---
const ULONG_PTR *__fastcall sub_1421318D0(
        _QWORD *a1,
        void (__fastcall *p_sub_140B13360)(_QWORD, __int64, __int64, __int64),
        __int64 *a3,
        unsigned int *a4,
        __int64 *a5)
{
  __int64 v5; // rbx
  int v10; // esi
  unsigned __int32 v11; // eax
  __int64 v12; // rcx
  __int64 *v13; // rsi
  __int64 v14; // rdi
  char *v15; // rdi
  char v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // rdx
  _QWORD *v20; // rcx
  __int64 *v21; // rax
  int v22; // eax
  const ULONG_PTR *result; // rax
  __int64 v24; // [rsp+30h] [rbp-51h] BYREF
  __int64 v25; // [rsp+38h] [rbp-49h]
  _QWORD *v26; // [rsp+40h] [rbp-41h]
  __int64 v27; // [rsp+48h] [rbp-39h]
  __int64 v28; // [rsp+50h] [rbp-31h]
  _QWORD *v29; // [rsp+58h] [rbp-29h]
  _BYTE v30[2]; // [rsp+60h] [rbp-21h] BYREF
  __int16 v31; // [rsp+62h] [rbp-1Fh]
  __int64 v32; // [rsp+64h] [rbp-1Dh]
  int v33; // [rsp+6Ch] [rbp-15h]
  unsigned __int64 v34; // [rsp+70h] [rbp-11h]
  unsigned __int64 v35; // [rsp+78h] [rbp-9h]
  __int64 v36; // [rsp+80h] [rbp-1h]
  __int64 v37; // [rsp+88h] [rbp+7h]
  __int16 v38; // [rsp+E0h] [rbp+5Fh] BYREF

  v5 = (__int64)(a1 + 4);
  v29 = a1 + 4;
  v10 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v5 + 0x10) == v10 )
  {
    ++*(_DWORD *)(v5 + 0x14);
  }
  else
  {
    v11 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 1, 0);
    if ( v11 )
      sub_1403C33A0(v5, v11, "SCIGListenerSet<struct IEntityGeometryResourceListener>::Notify", 1);
    else
      *(_QWORD *)(v5 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v5 + 0x10) = v10;
  }
  v12 = a1[1] - *a1;
  v24 = *a1;
  v12 >>= 4;
  v28 = v12;
  v26 = a1;
  v27 = 0;
  v25 = a1[3];
  a1[3] = &v24;
  if ( v12 > 0 )
  {
    v13 = a5;
    v14 = v27;
    do
    {
      v15 = (char *)(v24 + 0x10 * v14);
      v16 = *v15;
      v38 = *((_WORD *)v15 + 1);
      v31 = 0;
      v32 = 0;
      v33 = 0;
      v35 = 0;
      v36 = 0;
      v37 = 0;
      v30[1] = v16;
      v34 = __rdtsc();
      v30[0] = 0;
      qword_149B4B870(v30, &v38, &p_p_p_p_p_p_p_p_p_p_p_Source, &p_p_p_p_p_p_p_p_p_p_p_Source, 0);
      v17 = *v13;
      v18 = *a4;
      v19 = *a3;
      v31 = v38;
      p_sub_140B13360(*((_QWORD *)v15 + 1), v19, v18, v17);
      ++v27;
      v35 = __rdtsc();
      qword_149B4B878(v30);
      v14 = v27;
    }
    while ( v27 < v28 );
    v5 = (__int64)v29;
  }
  v20 = v26 + 3;
  v21 = (__int64 *)v26[3];
  if ( v21 )
  {
    while ( v21 != &v24 )
    {
      v20 = v21 + 1;
      v21 = (__int64 *)v21[1];
      if ( !v21 )
        goto LABEL_16;
    }
    *v20 = v25;
  }
LABEL_16:
  v22 = *(_DWORD *)(v5 + 0x14);
  if ( v22 )
  {
    result = (const ULONG_PTR *)(unsigned int)(v22 - 1);
    *(_DWORD *)(v5 + 0x14) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
    result = (const ULONG_PTR *)(unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v5, 0, 1);
    if ( (_DWORD)result == 1 )
      *(_QWORD *)(v5 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      return sub_1403DB1F0(v5, (unsigned __int32)result);
  }
  return result;
}

// --- End Function: sub_1421318D0 (0x1421318D0) ---

// --- Function: sub_14219F070 (0x14219F070) ---
char __fastcall sub_14219F070(unsigned __int64 *a1)
{
  _WORD *v2; // rax
  __int16 v3; // rbx^6
  __int64 v4; // rsi
  __int16 n2; // cx
  _WORD *v6; // rdi
  _WORD *v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 v11; // [rsp+30h] [rbp+8h] BYREF

  LOBYTE(v2) = (unsigned __int8)sub_1404232A0(&v11, a1[1]);
  v3 = HIWORD(v11);
  if ( v11 )
  {
    v4 = v11 & 0xFFFFFFFFFFFFLL;
    v2 = (_WORD *)sub_1403B4B50(v11 & 0xFFFFFFFFFFFFLL);
    n2 = v2[2];
    if ( n2 != 4 && v2[1] == (v3 & 0xFFF) )
    {
      if ( n2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || (LOBYTE(v2) = sub_14031FE20(&v11), (_BYTE)v2) )
      {
        v2 = (_WORD *)(*(__int64 (__fastcall **)(unsigned __int64 *))(*a1 + 0x600))(a1);
        v6 = v2;
        if ( v2 )
        {
          v2 = (_WORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x608LL))(v4);
          v7 = v2;
          if ( v2 )
          {
            LOBYTE(v2) = (*(__int64 (__fastcall **)(_WORD *))(*(_QWORD *)v2 + 0x190LL))(v2);
            if ( (_BYTE)v2 )
            {
              v8 = (*(__int64 (__fastcall **)(_WORD *))(*(_QWORD *)v7 + 0xD0LL))(v7);
              if ( validateHandleAccess((unsigned __int64 *)(v8 + 8)) )
                v9 = *(_QWORD *)(v8 + 8) & 0xFFFFFFFFFFFFLL;
              else
                v9 = 0;
              v2 = (_WORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v9 + 0x4F8LL))(v9, 0xFFFFFFFFLL);
              if ( v2 )
                LOBYTE(v2) = (*(__int64 (__fastcall **)(_WORD *, _WORD *))(*(_QWORD *)v6 + 0x298LL))(v6, v2);
            }
          }
        }
      }
    }
  }
  return (char)v2;
}

// --- End Function: sub_14219F070 (0x14219F070) ---

// --- Function: sub_142229FA0 (0x142229FA0) ---
bool __fastcall sub_142229FA0(__int64 a1)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 0x1F0);
  return v2 && (!sub_1403E5570((_QWORD *)(v2 + 0x20)) || *(_QWORD *)(*(_QWORD *)(a1 + 0x1F0) + 0x48LL));
}

// --- End Function: sub_142229FA0 (0x142229FA0) ---

// --- Function: sub_14222C450 (0x14222C450) ---
void __fastcall sub_14222C450(__int64 a1)
{
  __int64 v1; // rdi
  Parameter *Parameter; // rbx
  void (__fastcall *v4)(__int64); // rsi
  __int64 v5; // r15
  __int64 v6; // rax
  double v7; // xmm1_8
  void (__fastcall *v8)(ULONG_PTR, _QWORD, __int64 *); // rdi
  unsigned int event_key_from_source_location; // eax
  __int64 v10; // rdi
  void (__fastcall *v11)(__int64); // rsi
  __int64 v12; // rax
  double v13; // xmm1_8
  void (__fastcall *v14)(ULONG_PTR, _QWORD, __int64 *); // rdi
  unsigned int event_key_from_source_location_1; // eax
  __int64 v16; // rax
  __int16 v17; // rbx^6
  __int64 v18; // r12
  __int64 v19; // rax
  __int16 n4; // cx
  unsigned __int8 n7; // r13
  void (__fastcall *v22)(__int64, __int64, __int64, _QWORD, _QWORD *); // rdi
  _QWORD *v23; // rax
  unsigned __int16 v24; // bx
  void **v25; // rax
  __int64 v26; // rax
  char v27; // al
  unsigned __int16 v28; // bx
  bool v29; // zf
  __int64 v30; // rax
  unsigned __int8 n6; // di
  void (__fastcall *v32)(__int64, __int64, __int64, _QWORD, __int64 *); // rsi
  void **v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned __int16 v36; // bx
  void (__fastcall *v37)(__int64, __int64, __int64, _QWORD, __int64 *); // rdi
  void **v38; // rax
  __int64 v39; // rax
  __int64 v40; // rax
  unsigned __int16 v41; // bx
  void (__fastcall *v42)(__int64, __int64, __int64, _QWORD, __int64 *); // rdi
  void **v43; // rax
  __int64 v44; // rax
  __int64 v45; // rax
  unsigned __int16 v46; // bx
  void (__fastcall *v47)(__int64, __int64, __int64, _QWORD, __int64 *); // rdi
  void **v48; // rax
  __int64 v49; // rax
  __int64 v50; // rax
  unsigned __int16 v51; // bx
  void (__fastcall *v52)(__int64, __int64, __int64, _QWORD, __int64 *); // rdi
  void **v53; // rax
  __int64 v54; // rax
  __int64 v55; // rax
  unsigned __int16 v56; // bx
  void (__fastcall *v57)(__int64, __int64, __int64, _QWORD, __int64 *); // rdi
  void **v58; // rax
  __int64 v59; // rax
  void (__fastcall *v60)(__int64, __int64, __int64, _QWORD, _QWORD *); // rdi
  _QWORD *v61; // rax
  unsigned __int16 v62; // bx
  void **v63; // rax
  __int64 v64; // rax
  __int64 v65; // rax
  unsigned __int16 v66; // bx
  void (__fastcall *v67)(__int64, __int64, __int64, _QWORD, __int64 *); // rdi
  void **v68; // rax
  __int64 v69; // rax
  __int64 v70; // rax
  unsigned __int16 v71; // bx
  void (__fastcall *v72)(__int64, __int64, __int64, _QWORD, __int64 *); // rdi
  void **v73; // rax
  __int64 v74; // rax
  __int64 v75; // rdi
  __int64 (__fastcall *v76)(__int64, _BYTE *, __int16 *); // rbx
  __int16 n0xFFFF_1; // ax
  __int64 v78; // rbx
  __int64 v79; // rax
  __int16 n4_1; // dx
  __int64 (__fastcall *v81)(__int64, _BYTE *, __int16 *); // rbx
  __int16 n0xFFFF_3; // ax
  __int64 v83; // rax
  __int64 v84; // rcx
  __int64 v85; // rax
  __int64 v86; // rbx
  __int16 n0xFFFF; // dx
  bool v88; // si
  volatile signed __int32 *v89; // rbx
  __int128 v90; // [rsp+30h] [rbp-D0h] BYREF
  double v91; // [rsp+40h] [rbp-C0h]
  _BYTE v92[2]; // [rsp+48h] [rbp-B8h] BYREF
  _BYTE v93[2]; // [rsp+4Ah] [rbp-B6h] BYREF
  _BYTE v94[4]; // [rsp+4Ch] [rbp-B4h] BYREF
  __int64 v95; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v96; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v97; // [rsp+60h] [rbp-A0h] BYREF
  __int64 (__fastcall *p_sub_14146F690_1)(__int64); // [rsp+68h] [rbp-98h] BYREF
  __int64 (__fastcall *p_sub_141470140_1)(); // [rsp+70h] [rbp-90h]
  __int64 v100; // [rsp+78h] [rbp-88h]
  __int64 v101; // [rsp+80h] [rbp-80h] BYREF
  __int64 (__fastcall *p_sub_14146F690)(__int64); // [rsp+88h] [rbp-78h] BYREF
  __int64 (__fastcall *p_sub_141470140)(); // [rsp+90h] [rbp-70h]
  __int64 v104; // [rsp+98h] [rbp-68h]
  _QWORD v105[3]; // [rsp+A0h] [rbp-60h] BYREF
  _QWORD v106[3]; // [rsp+B8h] [rbp-48h] BYREF
  void *v107; // [rsp+D0h] [rbp-30h] BYREF
  void *v108; // [rsp+D8h] [rbp-28h] BYREF
  void *v109; // [rsp+E0h] [rbp-20h] BYREF
  void *v110; // [rsp+E8h] [rbp-18h] BYREF
  void *v111; // [rsp+F0h] [rbp-10h] BYREF
  void *v112; // [rsp+F8h] [rbp-8h] BYREF
  void *v113; // [rsp+100h] [rbp+0h] BYREF
  void *v114; // [rsp+108h] [rbp+8h] BYREF
  void *v115; // [rsp+110h] [rbp+10h] BYREF
  void *v116; // [rsp+118h] [rbp+18h] BYREF
  _BYTE v117[8]; // [rsp+120h] [rbp+20h] BYREF
  _BYTE v118[8]; // [rsp+128h] [rbp+28h] BYREF
  __int64 v119; // [rsp+130h] [rbp+30h] BYREF
  __int128 v120; // [rsp+138h] [rbp+38h]
  __int64 v121; // [rsp+148h] [rbp+48h] BYREF
  __int128 v122; // [rsp+150h] [rbp+50h]
  __int64 v123; // [rsp+160h] [rbp+60h] BYREF
  __int128 v124; // [rsp+168h] [rbp+68h]
  __int64 v125; // [rsp+178h] [rbp+78h] BYREF
  __int128 v126; // [rsp+180h] [rbp+80h]
  __int64 v127; // [rsp+190h] [rbp+90h] BYREF
  __int128 v128; // [rsp+198h] [rbp+98h]
  __int64 v129; // [rsp+1A8h] [rbp+A8h] BYREF
  __int128 v130; // [rsp+1B0h] [rbp+B0h]
  __int64 v131; // [rsp+1C0h] [rbp+C0h] BYREF
  __int128 v132; // [rsp+1C8h] [rbp+C8h]
  __int64 v133; // [rsp+1D8h] [rbp+D8h] BYREF
  __int128 v134; // [rsp+1E0h] [rbp+E0h]
  _BYTE v135[24]; // [rsp+1F0h] [rbp+F0h] BYREF
  _BYTE v136[24]; // [rsp+208h] [rbp+108h] BYREF
  _BYTE v137[24]; // [rsp+220h] [rbp+120h] BYREF
  _BYTE v138[24]; // [rsp+238h] [rbp+138h] BYREF
  _BYTE v139[24]; // [rsp+250h] [rbp+150h] BYREF
  _BYTE v140[24]; // [rsp+268h] [rbp+168h] BYREF
  _BYTE v141[24]; // [rsp+280h] [rbp+180h] BYREF
  _BYTE v142[24]; // [rsp+298h] [rbp+198h] BYREF
  _BYTE v143[24]; // [rsp+2B0h] [rbp+1B0h] BYREF
  _BYTE v144[88]; // [rsp+2C8h] [rbp+1C8h] BYREF
  __int16 n0xFFFF_2; // [rsp+330h] [rbp+230h] BYREF
  __int16 n0xFFFF_4; // [rsp+338h] [rbp+238h] BYREF
  char v147; // [rsp+340h] [rbp+240h] BYREF
  char v148; // [rsp+348h] [rbp+248h] BYREF

  v1 = qword_149B4FC88;
  Parameter = a1 + 0x410;
  v4 = *(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC88 + 0x20LL);
  if ( n0xFFFF_12 == (__int16)0xFFFF )
    n0xFFFF_12 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                             qword_149B4FC88,
                             &v147,
                             "IEntityGeometryResource");
  v4(v1);
  _StarEngineModule__(Parameter);
  v101 = a1;
  v5 = 0;
  *((_QWORD *)&v90 + 1) = sub_14224F460;
  *(_QWORD *)&v90 = a1;
  LODWORD(v91) = 0;
  HIDWORD(v91) = (unsigned __int64)sub_14224F460 >> 0x20;
  v6 = allocWithProfilerInfo_w(0x18u);
  if ( v6 )
  {
    v7 = v91;
    *(_OWORD *)v6 = v90;
    *(double *)(v6 + 0x10) = v7;
    v104 = v6;
  }
  else
  {
    v104 = 0;
  }
  p_sub_14146F690 = sub_14146F690;
  p_sub_141470140 = sub_141470140;
  v8 = *(void (__fastcall **)(ULONG_PTR, _QWORD, __int64 *))(*(_QWORD *)Parameter + 8LL);
  event_key_from_source_location = event_key_from_source_location_0;
  if ( !event_key_from_source_location_0 )
    event_key_from_source_location = get_event_key_from_source_location(
                                       &event_key_from_source_location_0,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/Base"
                                                "GeometryResource.cpp",
                                       0x7E);
  v8(Parameter, event_key_from_source_location, &v101);
  if ( (unsigned __int64)p_sub_141470140 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))p_sub_141470140)(2, &p_sub_14146F690);
  v10 = qword_149B4FC88;
  v11 = *(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC88 + 0x20LL);
  if ( n0xFFFF_12 == (__int16)0xFFFF )
    n0xFFFF_12 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                             qword_149B4FC88,
                             &v148,
                             "IEntityGeometryResource");
  v11(v10);
  _StarEngineModule__(Parameter);
  v97 = a1;
  *((_QWORD *)&v90 + 1) = sub_142257CC0;
  HIDWORD(v91) = (unsigned __int64)sub_142257CC0 >> 0x20;
  *(_QWORD *)&v90 = a1;
  LODWORD(v91) = 0;
  v12 = allocWithProfilerInfo_w(0x18u);
  if ( v12 )
  {
    v13 = v91;
    *(_OWORD *)v12 = v90;
    *(double *)(v12 + 0x10) = v13;
    v100 = v12;
  }
  else
  {
    v100 = 0;
  }
  p_sub_14146F690_1 = sub_14146F690;
  p_sub_141470140_1 = sub_141470140;
  v14 = *(void (__fastcall **)(ULONG_PTR, _QWORD, __int64 *))(*(_QWORD *)Parameter + 8LL);
  event_key_from_source_location_1 = ::event_key_from_source_location_1;
  if ( !::event_key_from_source_location_1 )
    event_key_from_source_location_1 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_1,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/Ba"
                                                  "seGeometryResource.cpp",
                                         0x83);
  v14(Parameter, event_key_from_source_location_1, &v97);
  if ( (unsigned __int64)p_sub_141470140_1 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))p_sub_141470140_1)(2, &p_sub_14146F690_1);
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6A8LL))(a1);
  sub_140496B70(v16 + 0x30);
  if ( *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6A8LL))(a1) + 0x28) )
    sub_1421A9EF0(a1);
  sub_14033FE90(a1, &v95);
  v17 = HIWORD(v95);
  if ( v95 )
  {
    v18 = v95 & 0xFFFFFFFFFFFFLL;
    v19 = sub_1403B4B50(v95 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v19 + 4);
    if ( n4 != 4
      && *(_WORD *)(v19 + 2) == (v17 & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v95)) )
    {
      n7 = 7;
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6B0LL))(a1) )
        n7 = 0;
      v22 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD *))(*(_QWORD *)v18 + 0x580LL);
      v23 = (_QWORD *)allocWithProfilerInfo_w(8u);
      if ( v23 )
        *v23 = a1;
      else
        v23 = 0;
      v24 = *(_WORD *)(a1 + 0x10);
      v105[2] = v23;
      v105[0] = sub_1421ACB70;
      v105[1] = sub_1421B1BD0;
      v25 = CreateStringObjectFromString(&v107, "GeomResourceModelTag");
      v26 = sub_14036E270(v135, v25, v24, n7);
      v22(v18, a1 + 0x290, v26, 0, v105);
      v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6B0LL))(a1);
      v28 = *(_WORD *)(a1 + 0x10);
      v29 = v27 == 0;
      v30 = *(_QWORD *)v18;
      n6 = 6;
      if ( !v29 )
        n6 = 0;
      v133 = 0;
      v134 = 0;
      v32 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v30 + 0x580);
      v33 = CreateStringObjectFromString(&v108, "GeomResourceHolographic");
      v34 = sub_14036E270(v136, v33, v28, n6);
      v32(v18, a1 + 0x3B0, v34, 0, &v133);
      v35 = *(_QWORD *)v18;
      v36 = *(_WORD *)(a1 + 0x10);
      v131 = 0;
      v37 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v35 + 0x580);
      v132 = 0;
      v38 = CreateStringObjectFromString(&v109, "GeomResourceWear");
      v39 = sub_14036E270(v137, v38, v36, n7);
      v37(v18, a1 + 0x2B0, v39, 0, &v131);
      v40 = *(_QWORD *)v18;
      v41 = *(_WORD *)(a1 + 0x10);
      v119 = 0;
      v42 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v40 + 0x580);
      v120 = 0;
      v43 = CreateStringObjectFromString(&v110, "GeomResourceDirt");
      v44 = sub_14036E270(v138, v43, v41, n7);
      v42(v18, a1 + 0x2D0, v44, 0, &v119);
      v45 = *(_QWORD *)v18;
      v46 = *(_WORD *)(a1 + 0x10);
      v121 = 0;
      v47 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v45 + 0x580);
      v122 = 0;
      v48 = CreateStringObjectFromString(&v111, "GeomResourceInterference");
      v49 = sub_14036E270(v139, v48, v46, n7);
      v47(v18, a1 + 0x2F0, v49, 0, &v121);
      v50 = *(_QWORD *)v18;
      v51 = *(_WORD *)(a1 + 0x10);
      v123 = 0;
      v52 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v50 + 0x580);
      v124 = 0;
      v53 = CreateStringObjectFromString(&v112, "GeomResourceDamage");
      v54 = sub_14036E270(v140, v53, v51, n7);
      v52(v18, a1 + 0x310, v54, 0, &v123);
      v55 = *(_QWORD *)v18;
      v56 = *(_WORD *)(a1 + 0x10);
      v125 = 0;
      v57 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v55 + 0x580);
      v126 = 0;
      v58 = CreateStringObjectFromString(&v113, "GeomResourceSubObjectNameHash");
      v59 = sub_14036E270(v141, v58, v56, n7);
      v57(v18, a1 + 0x330, v59, 0, &v125);
      v60 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD *))(*(_QWORD *)v18 + 0x580LL);
      v61 = (_QWORD *)allocWithProfilerInfo_w(8u);
      if ( v61 )
        *v61 = a1;
      else
        v61 = 0;
      v62 = *(_WORD *)(a1 + 0x10);
      v106[2] = v61;
      v106[0] = sub_1421ADAD0;
      v106[1] = sub_1421B3E90;
      v63 = CreateStringObjectFromString(&v114, "GeomResourceSubObjectVisibilityTags");
      v64 = sub_14036E270(v142, v63, v62, n7);
      v60(v18, a1 + 0x350, v64, 0, v106);
      v65 = *(_QWORD *)v18;
      v66 = *(_WORD *)(a1 + 0x10);
      v127 = 0;
      v67 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v65 + 0x580);
      v128 = 0;
      v68 = CreateStringObjectFromString(&v115, "GeomResourceModelPath");
      v69 = sub_14036E270(v143, v68, v66, n7);
      v67(v18, a1 + 0x370, v69, 0, &v127);
      v70 = *(_QWORD *)v18;
      v71 = *(_WORD *)(a1 + 0x10);
      v129 = 0;
      v72 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *))(v70 + 0x580);
      v130 = 0;
      v73 = CreateStringObjectFromString(&v116, "GeomResourceMaterialPath");
      v74 = sub_14036E270(v144, v73, v71, n7);
      v72(v18, a1 + 0x390, v74, 0, &v129);
    }
  }
  sub_142278660(a1, 0);
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v75 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v75 = 0;
  v76 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v75 + 0x340LL);
  n0xFFFF_1 = n0xFFFF_13;
  if ( n0xFFFF_13 == (__int16)0xFFFF )
  {
    n0xFFFF_1 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            v92,
                            "IEntityRenderProxy");
    n0xFFFF_13 = n0xFFFF_1;
  }
  n0xFFFF_2 = n0xFFFF_1;
  v78 = *(_QWORD *)v76(v75, v117, &n0xFFFF_2);
  v96 = v78;
  if ( !v78
    || (v79 = sub_1403B4B50(v78 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v79 + 4), n4_1 == 4)
    || *(_WORD *)(v79 + 2) != (HIWORD(v78) & 0xFFF)
    || (n4_1 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v96) )
  {
    v81 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v75 + 0x338LL);
    n0xFFFF_3 = n0xFFFF_14;
    if ( n0xFFFF_14 == (__int16)0xFFFF )
    {
      n0xFFFF_3 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                      + 0x10LL))(
                              qword_149B4FC88,
                              v93,
                              "RenderProxy");
      n0xFFFF_14 = n0xFFFF_3;
    }
    n0xFFFF_4 = n0xFFFF_3;
    v78 = *(_QWORD *)v81(v75, v118, &n0xFFFF_4);
  }
  v83 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 0xE0) = v78;
  if ( !*(_BYTE *)((*(__int64 (__fastcall **)(__int64))(v83 + 0x6A8))(a1) + 0x221) )
    goto LABEL_72;
  v84 = validateHandleAccess((unsigned __int64 *)(a1 + 8)) ? *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL : 0LL;
  v85 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v84 + 0x380LL))(v84);
  v86 = v85;
  if ( !v85 || !(unsigned int)sub_1403B4BC0(v85) || *(_DWORD *)(a1 + 0x338) )
    goto LABEL_72;
  n0xFFFF = n0xFFFF_9;
  if ( n0xFFFF_9 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          v94,
                          "Vehicle");
    n0xFFFF_9 = n0xFFFF;
  }
  if ( find_component_by_id(v86, n0xFFFF) )
    goto LABEL_72;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v5 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  (*(void (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v5 + 0x388LL))(v5, &v90);
  v88 = (_QWORD)v90
     && (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)v90 + 0xD0LL))(v90, *(_QWORD *)(v86 + 0x98)) == 0;
  v89 = (volatile signed __int32 *)*((_QWORD *)&v90 + 1);
  if ( *((_QWORD *)&v90 + 1)
    && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v90 + 1) + 8LL), 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v89)(v89);
    if ( _InterlockedExchangeAdd(v89 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v89 + 8LL))(v89);
  }
  if ( v88 )
LABEL_72:
    sub_142277AF0(a1, 0);
}

// --- End Function: sub_14222C450 (0x14222C450) ---

// --- Function: sub_142234A70 (0x142234A70) ---
void __fastcall sub_142234A70(__int64 a1)
{
  sub_142277AF0(a1, *(_BYTE *)(a1 + 0xE8));
  *(_BYTE *)(a1 + 0xE8) = 0;
}

// --- End Function: sub_142234A70 (0x142234A70) ---

// --- Function: sub_14223A500 (0x14223A500) ---
__int64 __fastcall sub_14223A500(__int64 a1, unsigned int n2, _BYTE *a3, __int64 a4)
{
  __int64 v4; // rdi
  int n3_1; // eax
  int v10; // eax
  unsigned __int64 *v11; // r14
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  __int64 v16; // rax
  __int64 *v17; // rax
  __int64 *v18; // r12
  __int64 v19; // rax
  unsigned int n3_2; // ebx
  _QWORD *v21; // rax
  __int64 v22; // r8
  _QWORD *v23; // rbx
  __int64 v24; // rcx
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // rbx
  __int64 v28; // rcx
  int v29; // eax
  unsigned __int64 *v30; // rcx
  __int64 v31; // r9
  __int64 *v32; // rcx
  __int64 v33; // rax
  __int64 v34; // rcx
  int v35; // r13d
  __int64 v36; // rcx
  __int64 v37; // rax
  unsigned int v38; // r14d
  bool v39; // al
  __int16 v40; // rbx^6
  __int64 v41; // r14
  __int64 v42; // rax
  __int16 n4; // cx
  __int64 v44; // rax
  __int64 v45; // rdx
  __int64 v46; // rcx
  __int64 v47; // rbx
  __int64 v48; // rcx
  int v49; // eax
  unsigned __int64 *v50; // rcx
  __int64 v51; // rcx
  __int64 v52; // rcx
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // r13
  __int64 v56; // rbx
  int v57; // eax
  unsigned __int64 v58; // rbx
  __int64 v59; // rax
  __int16 n4_1; // dx
  _BYTE *v61; // rdi
  void (__fastcall *v62)(_BYTE *, _QWORD); // rbx
  unsigned __int8 v63; // al
  const char *v64; // rax
  int v66; // [rsp+20h] [rbp-E0h]
  int v67; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v68; // [rsp+50h] [rbp-B0h] BYREF
  int n3; // [rsp+58h] [rbp-A8h]
  __int64 v70; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v71; // [rsp+68h] [rbp-98h] BYREF
  __int64 v72; // [rsp+70h] [rbp-90h] BYREF
  __int64 v73; // [rsp+78h] [rbp-88h] BYREF
  int n0x2900; // [rsp+80h] [rbp-80h] BYREF
  __int64 v75; // [rsp+84h] [rbp-7Ch]
  int v76; // [rsp+8Ch] [rbp-74h]
  unsigned __int64 v77; // [rsp+90h] [rbp-70h]
  unsigned __int64 v78; // [rsp+98h] [rbp-68h]
  __int64 v79; // [rsp+A0h] [rbp-60h]
  __int64 v80; // [rsp+A8h] [rbp-58h]
  __int64 v81; // [rsp+E0h] [rbp-20h]
  __m256 v82; // [rsp+F0h] [rbp-10h] BYREF
  __m256 v83; // [rsp+110h] [rbp+10h]
  __int128 v84; // [rsp+130h] [rbp+30h]
  unsigned int v85; // [rsp+140h] [rbp+40h]
  unsigned int v86; // [rsp+144h] [rbp+44h]
  unsigned int v87; // [rsp+148h] [rbp+48h]
  unsigned int v88; // [rsp+14Ch] [rbp+4Ch]
  unsigned int v89; // [rsp+150h] [rbp+50h]
  unsigned int v90; // [rsp+154h] [rbp+54h]
  unsigned int v91; // [rsp+158h] [rbp+58h]
  unsigned int v92; // [rsp+15Ch] [rbp+5Ch]
  unsigned int v93; // [rsp+160h] [rbp+60h]
  unsigned int v94; // [rsp+164h] [rbp+64h]
  unsigned int v95; // [rsp+168h] [rbp+68h]
  unsigned int v96; // [rsp+16Ch] [rbp+6Ch]
  unsigned int v97; // [rsp+170h] [rbp+70h]
  unsigned int v98; // [rsp+174h] [rbp+74h]
  unsigned int v99; // [rsp+178h] [rbp+78h]
  unsigned int v100; // [rsp+17Ch] [rbp+7Ch]
  unsigned int v101; // [rsp+184h] [rbp+84h]
  unsigned int v102; // [rsp+188h] [rbp+88h]
  unsigned int v103; // [rsp+18Ch] [rbp+8Ch]
  unsigned int v104; // [rsp+190h] [rbp+90h]
  unsigned int v105; // [rsp+194h] [rbp+94h]
  unsigned int v106; // [rsp+198h] [rbp+98h]
  unsigned int v107; // [rsp+19Ch] [rbp+9Ch]
  unsigned int v108; // [rsp+1A0h] [rbp+A0h]
  unsigned int v109; // [rsp+1A4h] [rbp+A4h]
  unsigned int v110; // [rsp+1A8h] [rbp+A8h]
  unsigned int v111; // [rsp+1ACh] [rbp+ACh]
  unsigned int v112; // [rsp+1B0h] [rbp+B0h]

  v4 = 0;
  LODWORD(v70) = n2;
  v75 = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  n0x2900 = 0x2900;
  v77 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_149DC6C8C,
    "CBaseEntityGeometryResource::LoadGeometry",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/BaseGeometryResource.cpp",
    0x5C6);
  HIWORD(n0x2900) = word_149DC6C8C;
  if ( n2 > 2 )
  {
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v4 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    v64 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x70LL))(v4);
    sub_1405C0E00(0xAu, 0, "Undefined geometry slot for entity '%s'.", v64);
    n3 = 3;
    goto LABEL_116;
  }
  n3_1 = sub_1403298D0(a3);
  n3 = n3_1;
  if ( !n3_1 )
  {
    v35 = *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x648LL))(a1) + 0xD6) != 0 ? 8 : 0;
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v36 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v36 = 0;
    v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x380LL))(v36);
    v38 = v35;
    if ( !*(_DWORD *)(a1 + 0x338) )
    {
LABEL_72:
      v45 = *(_QWORD *)(a1 + 0x250);
      v46 = *(_QWORD *)(a1 + 0x260);
      v47 = *(_QWORD *)(v46
                      + 0x10
                      * ((0x100000001B3LL
                        * (*(unsigned __int8 *)(a1 + 0x1FB)
                         ^ (0x100000001B3LL
                          * (*(unsigned __int8 *)(a1 + 0x1FA)
                           ^ (0x100000001B3LL
                            * (*(unsigned __int8 *)(a1 + 0x1F9)
                             ^ (0x100000001B3LL * (*(unsigned __int8 *)(a1 + 0x1F8) ^ 0xCBF29CE484222325uLL))))))))
                       & *(_QWORD *)(a1 + 0x278))
                      + 8);
      if ( v47 != v45 )
      {
        v48 = *(_QWORD *)(v46
                        + 0x10
                        * ((0x100000001B3LL
                          * (*(unsigned __int8 *)(a1 + 0x1FB)
                           ^ (0x100000001B3LL
                            * (*(unsigned __int8 *)(a1 + 0x1FA)
                             ^ (0x100000001B3LL
                              * (*(unsigned __int8 *)(a1 + 0x1F9)
                               ^ (0x100000001B3LL * (*(unsigned __int8 *)(a1 + 0x1F8) ^ 0xCBF29CE484222325uLL))))))))
                         & *(_QWORD *)(a1 + 0x278)));
        v49 = *(_DWORD *)(a1 + 0x1F8);
        if ( v49 == *(_DWORD *)(v47 + 0x10) )
        {
LABEL_78:
          v50 = (unsigned __int64 *)(a1 + 8);
          if ( !v47 )
            v47 = *(_QWORD *)(a1 + 0x250);
          if ( v47 == v45 )
          {
            if ( validateHandleAccess(v50) )
              v52 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v52 = 0;
            (*(void (__fastcall **)(__int64, _QWORD, _BYTE *, _QWORD, _DWORD))(*(_QWORD *)v52 + 0x548LL))(
              v52,
              (unsigned int)v70,
              a3,
              v38,
              *(_DWORD *)(a1 + 0x338));
          }
          else
          {
            if ( validateHandleAccess(v50) )
              v51 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v51 = 0;
            (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v51 + 0x500LL))(
              v51,
              *(_QWORD *)(v47 + 0x18),
              (unsigned int)v70);
          }
          if ( (v38 & 0x10) != 0 )
            sub_14219F070((unsigned __int64 *)a1);
          v11 = (unsigned __int64 *)(a1 + 8);
          if ( *(_WORD *)(a1 + 0x28C) )
          {
            v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x600LL))(a1);
            v11 = (unsigned __int64 *)(a1 + 8);
            if ( v53 )
            {
              v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x30LL))(v53);
              v11 = (unsigned __int64 *)(a1 + 8);
              v55 = v54;
              if ( v54 )
              {
                v56 = *(_QWORD *)v54;
                v57 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v54 + 0x258LL))(v54);
                (*(void (__fastcall **)(__int64, _QWORD))(v56 + 0x250))(v55, v57 | 0x8000u);
                v11 = (unsigned __int64 *)(a1 + 8);
              }
            }
          }
          goto LABEL_95;
        }
        while ( v47 != v48 )
        {
          v47 = *(_QWORD *)(v47 + 8);
          if ( v49 == *(_DWORD *)(v47 + 0x10) )
            goto LABEL_78;
        }
      }
      v47 = 0;
      goto LABEL_78;
    }
    if ( v37 )
    {
      v39 = (unsigned int)sub_1403B4BC0(v37) != 0;
    }
    else
    {
      sub_1404232A0(&v68, *(_QWORD *)(a1 + 8));
      v40 = HIWORD(v68);
      if ( !v68 )
        goto LABEL_72;
      v41 = v68 & 0xFFFFFFFFFFFFLL;
      v42 = sub_1403B4B50(v68 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v42 + 4);
      if ( n4 == 4 )
      {
        v38 = v35;
        goto LABEL_72;
      }
      if ( *(_WORD *)(v42 + 2) != (v40 & 0xFFF) )
      {
        v38 = v35;
        goto LABEL_72;
      }
      if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v68) )
      {
        v38 = v35;
        goto LABEL_72;
      }
      v44 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v41 + 0x608LL))(v41);
      if ( v44 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v44 + 0x190LL))(v44) )
      {
LABEL_71:
        v38 = v35 | 0x10;
        goto LABEL_72;
      }
      v39 = 0;
    }
    v38 = v35;
    if ( !v39 )
      goto LABEL_72;
    goto LABEL_71;
  }
  v10 = n3_1 - 1;
  if ( !v10 )
  {
    if ( a4 )
    {
      LOBYTE(v66) = 1;
      v21 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, __int64, _QWORD, int, _DWORD, _QWORD, _DWORD, _BYTE))(*(_QWORD *)qword_149B4FBE0 + 0xA8LL))(
                        qword_149B4FBE0,
                        &v73,
                        a4,
                        0,
                        v66,
                        0,
                        0,
                        0,
                        0);
      v22 = *(_QWORD *)(a1 + 0x400);
      v23 = v21;
      *(_QWORD *)(a1 + 0x400) = *v21;
      *v21 = v22;
      if ( v22 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 8LL))(v22);
      *v23 = 0;
      if ( v73 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v73 + 8LL))(v73);
    }
    else
    {
      v24 = *(_QWORD *)(a1 + 0x400);
      if ( v24 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 8LL))(v24);
        *(_QWORD *)(a1 + 0x400) = 0;
      }
    }
    v25 = *(_QWORD *)(a1 + 0x210);
    v26 = *(_QWORD *)(a1 + 0x220);
    v27 = *(_QWORD *)(v26
                    + 0x10
                    * ((0x100000001B3LL
                      * (*(unsigned __int8 *)(a1 + 0x1FB)
                       ^ (0x100000001B3LL
                        * (*(unsigned __int8 *)(a1 + 0x1FA)
                         ^ (0x100000001B3LL
                          * (*(unsigned __int8 *)(a1 + 0x1F9)
                           ^ (0x100000001B3LL * (*(unsigned __int8 *)(a1 + 0x1F8) ^ 0xCBF29CE484222325uLL))))))))
                     & *(_QWORD *)(a1 + 0x238))
                    + 8);
    if ( v27 != v25 )
    {
      v28 = *(_QWORD *)(v26
                      + 0x10
                      * ((0x100000001B3LL
                        * (*(unsigned __int8 *)(a1 + 0x1FB)
                         ^ (0x100000001B3LL
                          * (*(unsigned __int8 *)(a1 + 0x1FA)
                           ^ (0x100000001B3LL
                            * (*(unsigned __int8 *)(a1 + 0x1F9)
                             ^ (0x100000001B3LL * (*(unsigned __int8 *)(a1 + 0x1F8) ^ 0xCBF29CE484222325uLL))))))))
                       & *(_QWORD *)(a1 + 0x238)));
      v29 = *(_DWORD *)(a1 + 0x1F8);
      if ( v29 == *(_DWORD *)(v27 + 0x10) )
      {
LABEL_41:
        v11 = (unsigned __int64 *)(a1 + 8);
        v30 = (unsigned __int64 *)(a1 + 8);
        if ( !v27 )
          v27 = *(_QWORD *)(a1 + 0x210);
        if ( v27 == v25 )
        {
          if ( validateHandleAccess(v30) )
            v34 = *v11 & 0xFFFFFFFFFFFFLL;
          else
            v34 = 0;
          (*(void (__fastcall **)(__int64, _QWORD, _BYTE *, _QWORD, _DWORD))(*(_QWORD *)v34 + 0x540LL))(
            v34,
            n2,
            a3,
            0,
            0);
        }
        else
        {
          if ( validateHandleAccess(v30) )
            v32 = (__int64 *)(*v11 & 0xFFFFFFFFFFFFLL);
          else
            v32 = 0;
          v33 = *v32;
          LOBYTE(v67) = 0;
          LOBYTE(v31) = 1;
          v68 = 0;
          (*(void (__fastcall **)(__int64 *, __int64, _QWORD, __int64, unsigned int, _QWORD, unsigned __int64, unsigned __int64, int, unsigned __int64 *))(v33 + 0x528))(
            v32,
            v27 + 0x18,
            n2,
            v31,
            0xBF800000,
            0,
            0xFFFFFFFFFFFFFFFFuLL,
            0xFFFFFFFFFFFFFFFFuLL,
            v67,
            &v68);
        }
        goto LABEL_95;
      }
      while ( v27 != v28 )
      {
        v27 = *(_QWORD *)(v27 + 8);
        if ( v29 == *(_DWORD *)(v27 + 0x10) )
          goto LABEL_41;
      }
    }
    v27 = 0;
    goto LABEL_41;
  }
  if ( v10 != 1 )
  {
    v11 = (unsigned __int64 *)(a1 + 8);
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v12 = *v11 & 0xFFFFFFFFFFFFLL;
    else
      v12 = 0;
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v12 + 0x488LL))(v12, n2);
    v13 = *(_QWORD *)(a1 + 0x400);
    if ( v13 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 8LL))(v13);
      *(_QWORD *)(a1 + 0x400) = 0;
    }
LABEL_95:
    if ( *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x648LL))(a1) + 0xD7) )
    {
      if ( validateHandleAccess(v11) )
        v4 = *v11 & 0xFFFFFFFFFFFFLL;
      (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v4 + 0x38LL))(v4, 0x80000000LL, 0);
    }
    else
    {
      if ( validateHandleAccess(v11) )
        v4 = *v11 & 0xFFFFFFFFFFFFLL;
      (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v4 + 0x30LL))(v4, 0x80000000LL, 0);
    }
    v58 = *(_QWORD *)(a1 + 0xE0);
    v68 = v58;
    if ( v58 )
    {
      v59 = sub_1403B4B50(v58 & 0xFFFFFFFFFFFFLL);
      n4_1 = *(_WORD *)(v59 + 4);
      if ( n4_1 != 4
        && *(_WORD *)(v59 + 2) == (HIWORD(v58) & 0xFFF)
        && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v68)) )
      {
        v61 = (_BYTE *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v58 & 0xFFFFFFFFFFFFLL) + 0x5D8LL))(v58 & 0xFFFFFFFFFFFFLL);
        if ( v61 )
        {
          v81 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6A8LL))(a1) + 0xE8);
          if ( v81 )
            (*(void (__fastcall **)(_BYTE *, _QWORD))(*(_QWORD *)v61 + 0x198LL))(v61, *(unsigned int *)(v81 + 8));
          if ( v61[0x16] == 0x64 )
          {
            v62 = *(void (__fastcall **)(_BYTE *, _QWORD))(*(_QWORD *)v61 + 0xD8LL);
            v63 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x668LL))(a1);
            v62(v61, v63);
          }
        }
      }
    }
LABEL_116:
    n3_2 = n3;
    goto LABEL_117;
  }
  v14 = 0;
  if ( a4 )
  {
    v15 = *(_QWORD *)a1;
    v82 = ymmword_1485AC800;
    v83 = ymmword_1485AC820;
    v84 = xmmword_1484AE0C0;
    v85 = 0xFFBFFFFF;
    v86 = 0xFFBFFFFF;
    v87 = 0xFFBFFFFF;
    v96 = 0x80000000;
    v97 = 0x80000000;
    v100 = 0x80000000;
    v101 = 0x80000000;
    v98 = 0x80000000;
    v99 = 0x80000000;
    v102 = 0x80000000;
    v103 = 0x80000000;
    v104 = 0x80000000;
    v105 = 0x80000000;
    v107 = 0x80000000;
    v108 = 0x80000000;
    v109 = 0x80000000;
    v110 = 0x80000000;
    v88 = 0xFFBFFFFF;
    v89 = 0xFFBFFFFF;
    v90 = 0xFFBFFFFF;
    v91 = 0xFFBFFFFF;
    v111 = 0x80000000;
    v112 = 0x80000000;
    v92 = 0xFFBFFFFF;
    v93 = 0xFFBFFFFF;
    v94 = 0xFFBFFFFF;
    v95 = 0xFFBFFFFF;
    v106 = 0x80000000;
    __asm { vzeroupper }
    v16 = (*(__int64 (__fastcall **)(__int64))(v15 + 0x648))(a1);
    sub_1405A5080(*(_QWORD *)(v16 + 0x50) + 0x20LL, (__int64)&v82);
    v17 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64 *, __int64, __int64, __m256 *))(*(_QWORD *)qword_149B4FCA8
                                                                                               + 0x18LL))(
                       qword_149B4FCA8,
                       &v70,
                       a4,
                       1,
                       &v82);
    v14 = *v17;
    *v17 = 0;
    if ( v70 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v70 + 8LL))(v70);
  }
  (*(void (__fastcall **)(__int64, __int64 *, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)qword_149B4FCA8 + 0x18LL))(
    qword_149B4FCA8,
    &v71,
    a3,
    v14 != 0 ? 2 : 0,
    0);
  if ( v71 )
  {
    v11 = (unsigned __int64 *)(a1 + 8);
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v18 = (__int64 *)(*v11 & 0xFFFFFFFFFFFFLL);
    else
      v18 = 0;
    v19 = *v18;
    v70 = v14;
    v68 = *(_QWORD *)(v19 + 0x530);
    if ( v14 )
      (**(void (__fastcall ***)(__int64))v14)(v14);
    v72 = v71;
    if ( v71 )
      (**(void (__fastcall ***)(__int64))v71)(v71);
    ((void (__fastcall *)(__int64 *, _QWORD, __int64 *, __int64 *, _DWORD))v68)(v18, n2, &v72, &v70, 0);
    if ( v71 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v71 + 8LL))(v71);
    if ( v14 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 8LL))(v14);
    goto LABEL_95;
  }
  v71 = 0;
  if ( v14 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 8LL))(v14);
  n3_2 = 3;
LABEL_117:
  v78 = __rdtsc();
  qword_149B4B878(&n0x2900);
  return n3_2;
}

// --- End Function: sub_14223A500 (0x14223A500) ---

// --- Function: sub_14223C000 (0x14223C000) ---
void __fastcall sub_14223C000(__int64 a1, _BYTE *a2, _BYTE *a3)
{
  __int64 v3; // r14
  __int64 v7; // rax
  __int64 v8; // r9
  __int64 *v9; // r12
  _QWORD *v10; // rbx
  __int64 v11; // r8
  __int64 v12; // rcx
  int v13; // ecx
  void (__fastcall *v14)(__int64, _QWORD, __int64 *); // rbx
  unsigned int v15; // eax
  __int64 v16; // rax
  __int64 v17; // rbx
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rax
  void (__fastcall *v21)(__int64, __int64 *); // r15
  unsigned __int64 n0x1FF_3; // rcx
  size_t n0x1FF_1; // rbx
  char *Str_1; // rax
  char *Str_2; // rbx
  char *v26; // r15
  int n0x1FF_14; // esi
  int n0x1FF_15; // eax
  char *v29; // r8
  int n0x1FF_13; // eax
  size_t n0x1FF_5; // rbx
  int v32; // r13d
  _BYTE *v33; // rcx
  char *v34; // rsi
  _BYTE *v35; // rax
  __int64 v36; // rax
  __int64 *v37; // r8
  __int64 v38; // rdi
  volatile signed __int32 *v39; // rbx
  __int64 v40; // rdx
  signed __int32 v41; // eax
  signed __int32 v42; // ett
  __int64 v43; // rcx
  char *Str_3; // r9
  unsigned __int64 n0x1FF_7; // rdx
  char *v46; // rbx
  char *v47; // rsi
  int v48; // edi
  int v49; // eax
  const char *v50; // rcx
  int n0x1FF_16; // eax
  int n0x1FF_12; // ecx
  size_t n0x1FF_9; // rdi
  size_t n0x1FF_11; // rbx
  _BYTE *p_Src; // rsi
  char *v56; // r15
  _BYTE *p_Src_2; // rax
  _BYTE *v58; // rax
  __int64 v59; // [rsp+30h] [rbp-D0h]
  __int64 v60; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v61; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v62; // [rsp+48h] [rbp-B8h]
  int n0x2900; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v64; // [rsp+54h] [rbp-ACh]
  int v65; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v66; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v67; // [rsp+68h] [rbp-98h]
  __int64 v68; // [rsp+70h] [rbp-90h]
  __int64 v69; // [rsp+78h] [rbp-88h]
  _BYTE v70[8]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v71; // [rsp+A8h] [rbp-58h]
  size_t n0x1FF_6; // [rsp+B0h] [rbp-50h]
  unsigned __int64 n0x1FF_4; // [rsp+B8h] [rbp-48h]
  void *v74; // [rsp+C0h] [rbp-40h]
  _BYTE v75[520]; // [rsp+C8h] [rbp-38h] BYREF
  size_t n0x1FF_10; // [rsp+2D0h] [rbp+1D0h]
  __int64 n0x1FF_8; // [rsp+2D8h] [rbp+1D8h]
  void *p_Src_1; // [rsp+2E0h] [rbp+1E0h]
  _BYTE Src[520]; // [rsp+2E8h] [rbp+1E8h] BYREF
  size_t n0x1FF_2; // [rsp+4F0h] [rbp+3F0h]
  __int64 n0x1FF; // [rsp+4F8h] [rbp+3F8h]
  char *Str; // [rsp+500h] [rbp+400h]
  _BYTE v83[520]; // [rsp+508h] [rbp+408h] BYREF

  v3 = 0;
  n0x2900 = 0x2900;
  v64 = 0;
  v65 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v66 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_149DC6C84,
    "CBaseEntityGeometryResource::LoadMaterial",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/BaseGeometryResource.cpp",
    0x568);
  HIWORD(n0x2900) = word_149DC6C84;
  if ( a2 && *a2 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FBE0 + 0x418LL))(qword_149B4FBE0);
    LOBYTE(v8) = 1;
    v9 = (__int64 *)(a1 + 0x1D8);
    v10 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _BYTE *, __int64, _DWORD))(*(_QWORD *)v7 + 0x18LL))(
                      v7,
                      &v60,
                      a2,
                      v8,
                      0);
    v11 = *(_QWORD *)(a1 + 0x1D8);
    v59 = a1 + 0x1D8;
    *(_QWORD *)(a1 + 0x1D8) = *v10;
    *v10 = v11;
    if ( v11 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x10LL))(v11);
    *v10 = 0;
    if ( v60 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v60 + 0x10LL))(v60);
  }
  else
  {
    v9 = (__int64 *)(a1 + 0x1D8);
    v12 = *(_QWORD *)(a1 + 0x1D8);
    v59 = a1 + 0x1D8;
    if ( v12 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x10LL))(v12);
      *v9 = 0;
    }
  }
  v13 = *(_DWORD *)(a1 + 0x288);
  if ( v13 )
  {
    if ( (unsigned int)(v13 - 1) > 1 )
      goto LABEL_14;
    goto LABEL_11;
  }
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x600LL))(a1);
  v17 = v16;
  if ( !v16 )
    goto LABEL_11;
  if ( *(_WORD *)(a1 + 0x28C) )
  {
    v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x30LL))(v16);
    if ( v18 )
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v18 + 0x250LL))(v18, 0x8000);
  }
  v19 = *v9;
  v20 = *(_QWORD *)v17;
  v61 = v19;
  v21 = *(void (__fastcall **)(__int64, __int64 *))(v20 + 0x170);
  if ( v19 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 8LL))(v19);
  v21(v17, &v61);
  if ( !a3 )
  {
LABEL_11:
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v3 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    v14 = *(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v3 + 0x4E0LL);
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x660LL))(a1);
    v14(v3, v15, v9);
    goto LABEL_14;
  }
  v62 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x50LL))(v17);
  if ( !v62 )
    goto LABEL_14;
  v83[0] = 0;
  n0x1FF_3 = 0;
  Str = v83;
  n0x1FF_2 = 0;
  n0x1FF_1 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x1FF = 0x1FF;
  do
    ++n0x1FF_1;
  while ( a3[n0x1FF_1] );
  if ( n0x1FF_1 )
  {
    Str_1 = v83;
    if ( n0x1FF_1 + 1 > 0x200 )
    {
      Str_1 = (char *)allocWithProfilerInfo(n0x1FF_1 + 1, 0);
      qword_149B3AB68 += n0x1FF_1 + 1;
      n0x1FF = n0x1FF_1;
    }
    Str = Str_1;
    n0x1FF_2 = n0x1FF_1;
    Str_1[n0x1FF_1] = 0;
    memcpy(Str, a3, n0x1FF_1);
    n0x1FF_3 = n0x1FF_2;
  }
  Str_2 = Str;
  v26 = &Str[n0x1FF_3];
  if ( Str >= &Str[n0x1FF_3] )
    goto LABEL_95;
  if ( Str )
  {
    n0x1FF_15 = strspn(Str, SubStr_);
    n0x1FF_3 = n0x1FF_2;
    n0x1FF_14 = n0x1FF_15;
  }
  else
  {
    n0x1FF_14 = 0;
  }
  v29 = &Str_2[n0x1FF_14];
  if ( v29 >= v26
    || (v29 ? (n0x1FF_13 = strcspn(&Str_2[n0x1FF_14], SubStr_), n0x1FF_3 = n0x1FF_2) : (n0x1FF_13 = 0),
        n0x1FF_5 = n0x1FF_13,
        v32 = n0x1FF_14 + n0x1FF_13 + 1,
        n0x1FF_14 >= n0x1FF_3) )
  {
LABEL_95:
    v33 = v75;
    n0x1FF_4 = 0x1FF;
    v74 = v75;
    n0x1FF_6 = 0;
    v75[0] = 0;
  }
  else
  {
    if ( n0x1FF_13 == 0xFFFFFFFFFFFFFFFFuLL )
      n0x1FF_5 = n0x1FF_3 - n0x1FF_14;
    if ( n0x1FF_5 + n0x1FF_14 > n0x1FF_3 )
      n0x1FF_5 = n0x1FF_3 - n0x1FF_14;
    v33 = v75;
    v34 = &Str[n0x1FF_14];
    v75[0] = 0;
    v74 = v75;
    n0x1FF_6 = 0;
    n0x1FF_4 = 0x1FF;
    if ( n0x1FF_5 )
    {
      v35 = v75;
      if ( n0x1FF_5 + 1 > 0x200 )
      {
        v35 = (_BYTE *)allocWithProfilerInfo(n0x1FF_5 + 1, 0);
        qword_149B3AB68 += n0x1FF_5 + 1;
        n0x1FF_4 = n0x1FF_5;
      }
      v74 = v35;
      n0x1FF_6 = n0x1FF_5;
      v35[n0x1FF_5] = 0;
      memcpy(v74, v34, n0x1FF_5);
      if ( n0x1FF_6 )
      {
        while ( 1 )
        {
          v36 = (*(__int64 (__fastcall **)(__int64, void *))(*(_QWORD *)v62 + 0x58LL))(v62, v74);
          if ( v36 )
          {
            v37 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v36 + 0x158LL))(v36, v70);
            v38 = 0;
            v39 = 0;
            v40 = v37[1];
            if ( v40 )
            {
              v41 = *(_DWORD *)(v40 + 8);
              if ( v41 )
              {
                while ( 1 )
                {
                  v42 = v41;
                  v41 = _InterlockedCompareExchange((volatile signed __int32 *)(v40 + 8), v41 + 1, v41);
                  if ( v42 == v41 )
                    break;
                  if ( !v41 )
                    goto LABEL_53;
                }
                v38 = *v37;
                v39 = (volatile signed __int32 *)v37[1];
              }
            }
LABEL_53:
            v43 = v71;
            if ( v71 && _InterlockedExchangeAdd((volatile signed __int32 *)(v71 + 0xC), 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v43 + 8LL))(v43, v40, v37);
            if ( v38 )
              (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v38 + 0x80LL))(v38, v59, v37);
            if ( v39 )
            {
              if ( _InterlockedExchangeAdd(v39 + 2, 0xFFFFFFFF) == 1 )
              {
                (**(void (__fastcall ***)(volatile signed __int32 *, __int64, __int64 *))v39)(v39, v40, v37);
                if ( _InterlockedExchangeAdd(v39 + 3, 0xFFFFFFFF) == 1 )
                  (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v39 + 8LL))(v39);
              }
            }
          }
          if ( v32 < 0 )
            goto LABEL_82;
          Str_3 = Str;
          n0x1FF_7 = n0x1FF_2;
          v46 = &Str[v32];
          v47 = &Str[n0x1FF_2];
          if ( v46 >= &Str[n0x1FF_2] )
            break;
          if ( v46 )
          {
            v49 = strspn(&Str[v32], SubStr_);
            Str_3 = Str;
            v48 = v49;
            n0x1FF_7 = n0x1FF_2;
          }
          else
          {
            v48 = 0;
          }
          v50 = &v46[v48];
          if ( v50 >= v47 )
            break;
          if ( v50 )
          {
            n0x1FF_16 = strcspn(v50, SubStr_);
            Str_3 = Str;
            n0x1FF_7 = n0x1FF_2;
          }
          else
          {
            n0x1FF_16 = 0;
          }
          n0x1FF_12 = v48 + v32;
          n0x1FF_9 = n0x1FF_16;
          v32 = n0x1FF_12 + n0x1FF_16 + 1;
          if ( n0x1FF_12 < n0x1FF_7 )
          {
            if ( n0x1FF_16 == 0xFFFFFFFFFFFFFFFFuLL )
              n0x1FF_9 = n0x1FF_7 - n0x1FF_12;
            if ( n0x1FF_9 + n0x1FF_12 > n0x1FF_7 )
              n0x1FF_9 = n0x1FF_7 - n0x1FF_12;
            Src[0] = 0;
            p_Src = Src;
            p_Src_1 = Src;
            n0x1FF_11 = 0;
            n0x1FF_10 = 0;
            v56 = &Str_3[n0x1FF_12];
            n0x1FF_8 = 0x1FF;
            if ( n0x1FF_9 )
            {
              p_Src_2 = Src;
              if ( n0x1FF_9 + 1 > 0x200 )
              {
                p_Src_2 = (_BYTE *)allocWithProfilerInfo(n0x1FF_9 + 1, 0);
                qword_149B3AB68 += n0x1FF_9 + 1;
                n0x1FF_8 = n0x1FF_9;
              }
              p_Src_1 = p_Src_2;
              n0x1FF_10 = n0x1FF_9;
              p_Src_2[n0x1FF_9] = 0;
              memcpy(p_Src_1, v56, n0x1FF_9);
              p_Src = p_Src_1;
              n0x1FF_11 = n0x1FF_10;
            }
            goto LABEL_84;
          }
          n0x1FF_11 = 0;
          n0x1FF_10 = 0;
LABEL_83:
          p_Src = Src;
          Src[0] = 0;
          p_Src_1 = Src;
          n0x1FF_8 = 0x1FF;
LABEL_84:
          if ( n0x1FF_11 > n0x1FF_4 )
          {
            if ( v74 != v75 )
            {
              qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_4;
              sub_147605980(v74);
            }
            v75[0] = 0;
            v74 = v75;
            n0x1FF_6 = 0;
            n0x1FF_4 = 0x1FF;
            if ( n0x1FF_11 )
            {
              v58 = v75;
              if ( n0x1FF_11 + 1 > 0x200 )
              {
                v58 = (_BYTE *)allocWithProfilerInfo(n0x1FF_11 + 1, 0);
                qword_149B3AB68 += n0x1FF_11 + 1;
                n0x1FF_4 = n0x1FF_11;
              }
              n0x1FF_6 = n0x1FF_11;
              v74 = v58;
              v58[n0x1FF_11] = 0;
            }
          }
          memmove(v74, p_Src, n0x1FF_11);
          n0x1FF_6 = n0x1FF_11;
          *((_BYTE *)v74 + n0x1FF_11) = 0;
          if ( p_Src_1 != Src )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_8;
            sub_147605980(p_Src_1);
          }
          if ( !n0x1FF_6 )
            goto LABEL_94;
        }
        v32 = 0xFFFFFFFF;
LABEL_82:
        n0x1FF_11 = 0;
        n0x1FF_10 = 0;
        goto LABEL_83;
      }
LABEL_94:
      v33 = v74;
    }
  }
  if ( v33 != v75 )
  {
    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_4;
    sub_147605980(v33);
  }
  if ( Str != v83 )
  {
    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
    sub_147605980(Str);
  }
LABEL_14:
  v67 = __rdtsc();
  qword_149B4B878(&n0x2900);
}

// --- End Function: sub_14223C000 (0x14223C000) ---

// --- Function: sub_14223DA80 (0x14223DA80) ---
void __fastcall sub_14223DA80(__int64 a1, __int64 a2)
{
  void (__fastcall ***v4)(_QWORD, __int64 *, __int64); // rax
  __int64 v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // rdx
  __int64 v8; // rbx
  __int64 v9; // rax
  __int16 n4; // dx
  unsigned int v11; // eax
  int v12; // edx
  __int64 v13; // rcx
  __int64 v14; // rax
  const char *v15; // rbx
  __int64 v16; // rcx
  const char *v17; // rax
  __int64 v18; // [rsp+38h] [rbp-19h] BYREF
  int n0x2900; // [rsp+48h] [rbp-9h] BYREF
  __int64 v20; // [rsp+4Ch] [rbp-5h]
  int v21; // [rsp+54h] [rbp+3h]
  unsigned __int64 v22; // [rsp+58h] [rbp+7h]
  unsigned __int64 v23; // [rsp+60h] [rbp+Fh]
  __int64 v24; // [rsp+68h] [rbp+17h]
  __int64 v25; // [rsp+70h] [rbp+1Fh]
  __int64 v26; // [rsp+B8h] [rbp+67h] BYREF

  v20 = 0;
  v21 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  n0x2900 = 0x2900;
  v22 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_149DC6C88,
    "CBaseEntityGeometryResource::LoadTintPalette",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/BaseGeometryResource.cpp",
    0x5A7);
  HIWORD(n0x2900) = word_149DC6C88;
  v4 = (void (__fastcall ***)(_QWORD, __int64 *, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FBE0
                                                                                             + 0x830LL))(qword_149B4FBE0);
  (**v4)(v4, &v18, a2);
  v5 = v18;
  if ( *(_QWORD *)(a1 + 0x1E0) != v18 )
  {
    v6 = v18;
    if ( v18 )
    {
      (*(void (**)(void))(*(_QWORD *)v18 + 8LL))();
      v5 = v18;
    }
    v7 = *(_QWORD *)(a1 + 0x1E0);
    if ( v7 )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v7 + 0x10LL))(*(_QWORD *)(a1 + 0x1E0));
      v5 = v18;
    }
    *(_QWORD *)(a1 + 0x1E0) = v6;
    v8 = *(_QWORD *)(a1 + 0xE0);
    v26 = v8;
    if ( v8 )
    {
      v9 = sub_1403B4B50(v8 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v9 + 4);
      if ( n4 != 4
        && *(_WORD *)(v9 + 2) == (HIWORD(v8) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v26)) )
      {
        v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x660LL))(a1);
        v12 = *(_DWORD *)(a1 + 0x288);
        if ( v12 && (unsigned int)(v12 - 1) >= 2 )
        {
          if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
            v13 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v13 = 0;
          v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x20LL))(v13);
          v15 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x18LL))(v14);
          if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
            v16 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v16 = 0;
          v17 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x70LL))(v16);
          sub_1405C0E00(0xAu, 2u, "LoadTintPalette - Unhandled geometry type for '%s' %s.", v17, v15);
        }
        else
        {
          (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x5F8LL))(
            v8 & 0xFFFFFFFFFFFFLL,
            v11,
            v18);
        }
      }
      v5 = v18;
    }
  }
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x10LL))(v5);
  v18 = 0;
  v23 = __rdtsc();
  qword_149B4B878(&n0x2900);
}

// --- End Function: sub_14223DA80 (0x14223DA80) ---

// --- Function: sub_142243EE0 (0x142243EE0) ---
void __fastcall sub_142243EE0(__int64 a1)
{
  __int64 v2; // rcx

  if ( validateHandleAccess((unsigned __int64 *)(a1 - 0x68)) )
    v2 = *(_QWORD *)(a1 - 0x68) & 0xFFFFFFFFFFFFLL;
  else
    v2 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x50LL))(v2) && *(_DWORD *)(a1 + 0x218) == 3 )
    sub_142277AF0(a1 - 0x70, 0);
}

// --- End Function: sub_142243EE0 (0x142243EE0) ---

// --- Function: sub_142243F40 (0x142243F40) ---
__int64 __fastcall sub_142243F40(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 0x218) == 3 )
  {
    v1 = a1 - 0x70;
    sub_142277AF0(a1 - 0x70, 0);
    return sub_1421D2C30(v1);
  }
  return result;
}

// --- End Function: sub_142243F40 (0x142243F40) ---

// --- Function: sub_142277960 (0x142277960) ---
void __fastcall sub_142277960(__int64 a1, char a2)
{
  __int64 v2; // rbx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rax
  int n0x2900; // [rsp+30h] [rbp-58h] BYREF
  __int64 v10; // [rsp+34h] [rbp-54h]
  int v11; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v12; // [rsp+40h] [rbp-48h]
  unsigned __int64 v13; // [rsp+48h] [rbp-40h]
  __int64 v14; // [rsp+50h] [rbp-38h]
  __int64 v15; // [rsp+58h] [rbp-30h]

  v2 = 0;
  n0x2900 = 0x2900;
  v10 = 0;
  v11 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v12 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_149DC6C6C,
    "CBaseEntityGeometryResource::RefreshGeometry",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/BaseGeometryResource.cpp",
    0x3C1);
  HIWORD(n0x2900) = word_149DC6C6C;
  if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
    v5 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v5 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x58LL))(v5) )
  {
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v6 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v6 = 0;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x50LL))(v6) )
    {
      v7 = validateHandleAccess((unsigned __int64 *)(a1 + 8)) ? *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL : 0LL;
      v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x380LL))(v7);
      if ( v8 )
      {
        if ( (unsigned int)sub_1403B4BC0(v8) )
          goto LABEL_14;
      }
    }
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v2 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x50LL))(v2) )
    {
LABEL_14:
      *(_BYTE *)(a1 + 0xE8) |= a2;
      sub_1403CF100(a1, 0);
    }
    else
    {
      sub_142277AF0(a1, a2);
    }
  }
  v13 = __rdtsc();
  qword_149B4B878(&n0x2900);
}

// --- End Function: sub_142277960 (0x142277960) ---

// --- Function: sub_142277AF0 (0x142277AF0) ---
void __fastcall sub_142277AF0(__int64 a1, char a2)
{
  const ULONG_PTR *v2; // r14
  char v3; // r12
  signed __int64 v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // r13
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rbx
  __int64 v13; // rdi
  __int64 (__fastcall *v14)(__int64, char *, __int64 *); // r12
  __int16 n0xFFFF; // ax
  __int64 v16; // rdi
  __int64 v17; // rax
  __int16 n4; // dx
  __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // rax
  __int64 v22; // rdi
  __int64 v23; // rdi
  __int64 v24; // rax
  __int16 n4_1; // dx
  bool v26; // al
  ULONG_PTR *v27; // r12
  __int64 v28; // rcx
  __int64 v29; // rcx
  const ULONG_PTR *v30; // rax
  __int64 v31; // rcx
  __int64 v32; // rax
  __int16 n4_2; // cx
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // [rsp+40h] [rbp-59h] BYREF
  unsigned __int64 v37; // [rsp+48h] [rbp-51h] BYREF
  int n0x2900; // [rsp+50h] [rbp-49h] BYREF
  __int64 v39; // [rsp+54h] [rbp-45h]
  int v40; // [rsp+5Ch] [rbp-3Dh]
  unsigned __int64 v41; // [rsp+60h] [rbp-39h]
  unsigned __int64 v42; // [rsp+68h] [rbp-31h]
  __int64 v43; // [rsp+70h] [rbp-29h]
  __int64 v44; // [rsp+78h] [rbp-21h]
  char v45[8]; // [rsp+A0h] [rbp+7h] BYREF
  __int64 v46[9]; // [rsp+A8h] [rbp+Fh] BYREF
  __int64 v47; // [rsp+100h] [rbp+67h] BYREF
  char v48; // [rsp+108h] [rbp+6Fh]
  const ULONG_PTR *v49; // [rsp+110h] [rbp+77h] BYREF
  __int64 v50; // [rsp+118h] [rbp+7Fh]

  v48 = a2;
  v2 = 0;
  n0x2900 = 0x2900;
  v39 = 0;
  v3 = a2;
  v40 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v41 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_149DC6C70,
    "CBaseEntityGeometryResource::RefreshGeometryInt",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/BaseGeometryResource.cpp",
    0x3E4);
  HIWORD(n0x2900) = word_149DC6C70;
  if ( *(_DWORD *)(a1 + 0x180) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x184);
  }
  else
  {
    v5 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x170));
    if ( (v5 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x170, v5, "CBaseEntityGeometryResource::RefreshGeometryInt", "m_tagsRWLock", 1);
  }
  v6 = *(_QWORD *)sub_1404BD120(a1 + 0x188);
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6A8LL))(a1);
  v8 = sub_1404BCCA0(v7 + 0x30, v6);
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6A8LL))(a1);
  v10 = sub_1404BCCD0(v9 + 0x190, v6);
  v11 = *(_QWORD *)a1;
  v12 = 0;
  v50 = v10;
  v36 = 0;
  if ( *(_BYTE *)((*(__int64 (__fastcall **)(__int64))(v11 + 0x6A8))(a1) + 0x220) )
  {
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v13 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v13 = 0;
    v14 = *(__int64 (__fastcall **)(__int64, char *, __int64 *))(*(_QWORD *)v13 + 0x340LL);
    n0xFFFF = n0xFFFF_11;
    if ( n0xFFFF_11 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, const ULONG_PTR **, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                               + 0x10LL))(
                            qword_149B4FC88,
                            &v49,
                            "IAttachableComponent");
      n0xFFFF_11 = n0xFFFF;
    }
    LOWORD(v47) = n0xFFFF;
    v16 = *(_QWORD *)v14(v13, v45, &v47);
    v47 = v16;
    if ( !v16 )
      goto LABEL_25;
    v17 = sub_1403B4B50(v16 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v17 + 4);
    if ( n4 == 4 || *(_WORD *)(v17 + 2) != (HIWORD(v16) & 0xFFF) )
      goto LABEL_25;
    if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_140391F30(&v47) )
      goto LABEL_25;
    v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v16 & 0xFFFFFFFFFFFFLL) + 0x608LL))(v16 & 0xFFFFFFFFFFFFLL);
    v20 = v19;
    if ( !v19 )
      goto LABEL_25;
    (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v19 + 0xD8LL))(v19, &v37);
    if ( validateHandleAccess(&v37)
      && (v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x48LL))(v20)) != 0
      && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v21 + 0x740LL))(v21)
      && (v22 = *sub_140423940(v37 & 0xFFFFFFFFFFFFLL, v46), v47 = v22, is_valid_handle_typeA(&v47))
      && (v12 = v22, v36 = v22, (unsigned __int8)sub_142229FA0(v22 & 0xFFFFFFFFFFFFLL)) )
    {
      v23 = *(_QWORD *)((v22 & 0xFFFFFFFFFFFFLL) + 0x1F0);
    }
    else
    {
LABEL_25:
      v23 = v50;
    }
    v3 = v48;
  }
  else
  {
    v23 = v50;
  }
  v26 = 1;
  if ( *(_QWORD *)(a1 + 0x1F0) == v23 )
  {
    if ( !v12
      || (v24 = sub_1403B4B50(v12 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v24 + 4), n4_1 == 4)
      || *(_WORD *)(v24 + 2) != (HIWORD(v12) & 0xFFF)
      || (n4_1 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v36) )
    {
      v26 = 0;
    }
  }
  if ( *(_QWORD *)(a1 + 0x1E8) != v8 || v26 || v3 )
  {
    *(_QWORD *)(a1 + 0x1E8) = v8;
    *(_QWORD *)(a1 + 0x1F0) = v23;
    LODWORD(v47) = *(_DWORD *)(v8 + 0x20);
    v27 = (ULONG_PTR *)sub_14037FC70(v8 + 0x10);
    v49 = sub_14037FC70(v8 + 0x28);
    if ( byte_149B501D5 )
    {
      v28 = *(_QWORD *)(v8 + 0x50);
      if ( v28 )
        v2 = sub_14037FC70(v28 + 0x10);
    }
    v29 = *(_QWORD *)(a1 + 0x1F0);
    if ( v29 && (!sub_1403E5570((_QWORD *)(v29 + 0x20)) || *(_QWORD *)(*(_QWORD *)(a1 + 0x1F0) + 0x48LL)) )
    {
      v30 = sub_14037FC70(*(_QWORD *)(a1 + 0x1F0) + 0x20LL);
      v31 = *(_QWORD *)(a1 + 0x1F0) + 0x30LL;
    }
    else
    {
      if ( v12
        && (v32 = sub_1403B4B50(v12 & 0xFFFFFFFFFFFFLL), n4_2 = *(_WORD *)(v32 + 4), n4_2 != 4)
        && *(_WORD *)(v32 + 2) == (HIWORD(v12) & 0xFFF)
        && (n4_2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v36))
        && (v34 = *(_QWORD *)((v12 & 0xFFFFFFFFFFFFLL) + 0x1E8)) != 0 )
      {
        v30 = sub_14037FC70(v34 + 0x40);
        v35 = *(_QWORD *)((v12 & 0xFFFFFFFFFFFFLL) + 0x1E8);
      }
      else
      {
        v30 = sub_14037FC70(*(_QWORD *)(a1 + 0x1E8) + 0x40LL);
        v35 = *(_QWORD *)(a1 + 0x1E8);
      }
      v31 = v35 + 0x60;
    }
    if ( !v27 || !*(_BYTE *)v27 )
      v27 = *(ULONG_PTR **)(a1 + 0x378);
    if ( !v30 || !*(_BYTE *)v30 )
      v30 = *(const ULONG_PTR **)(a1 + 0x398);
    sub_1422A41F0(a1, v47, v27, (__int64)v30, (__int64)v49, v31, (__int64)v2);
  }
  sub_1402D2790(a1 + 0x170);
  v42 = __rdtsc();
  qword_149B4B878(&n0x2900);
}

// --- End Function: sub_142277AF0 (0x142277AF0) ---

// --- Function: sub_1422A41F0 (0x1422A41F0) ---
void __fastcall sub_1422A41F0(__int64 a1, unsigned int a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // r14
  unsigned int v11; // ebx
  __int64 v12; // r8
  __int64 v13; // r8
  unsigned int v14; // eax
  __int64 v15; // r8
  const ULONG_PTR *v16; // rsi
  __int64 *v17; // r13
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  __int64 v19; // r8
  unsigned int v20; // eax
  __int64 v21; // r8
  int v22; // r13d
  int v23; // esi
  int v24; // eax
  int v25; // ecx
  __int64 v26; // rax
  __int64 v27; // rcx
  __int64 v28; // rax
  _BYTE *v29; // r8
  unsigned int v30; // r15d
  __int64 v31; // r8
  __int64 v32; // rdx
  __int64 v33; // rdx
  __int64 v34; // rax
  __int64 v35; // rcx
  void (__fastcall *v36)(__int64, _QWORD, __int64); // rsi
  __int64 v37; // rax
  signed __int64 v38; // rdx
  const void **v39; // rbx
  size_t n0x1FF_1; // rsi
  const void *v41; // r13
  _BYTE *v42; // rax
  int v43; // eax
  int v44; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v45; // [rsp+34h] [rbp-CCh]
  int v46; // [rsp+38h] [rbp-C8h]
  int v47; // [rsp+3Ch] [rbp-C4h]
  __int64 v48; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v49; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v50; // [rsp+50h] [rbp-B0h]
  void (__fastcall *v51)(__int64, _QWORD, __int64); // [rsp+58h] [rbp-A8h]
  __int64 v52; // [rsp+60h] [rbp-A0h]
  int n0x2900; // [rsp+70h] [rbp-90h] BYREF
  __int64 v54; // [rsp+74h] [rbp-8Ch]
  int v55; // [rsp+7Ch] [rbp-84h]
  unsigned __int64 v56; // [rsp+80h] [rbp-80h]
  unsigned __int64 v57; // [rsp+88h] [rbp-78h]
  __int64 v58; // [rsp+90h] [rbp-70h]
  __int64 v59; // [rsp+98h] [rbp-68h]
  _BYTE v60[28]; // [rsp+C0h] [rbp-40h] BYREF
  int v61; // [rsp+DCh] [rbp-24h]
  char v62[16]; // [rsp+E0h] [rbp-20h] BYREF
  size_t n0x1FF_2; // [rsp+F0h] [rbp-10h]
  unsigned __int64 n0x1FF; // [rsp+F8h] [rbp-8h]
  void *v65; // [rsp+100h] [rbp+0h]
  _BYTE v66[520]; // [rsp+108h] [rbp+8h] BYREF
  char v67[272]; // [rsp+310h] [rbp+210h] BYREF

  v7 = 0;
  v45 = a2;
  v50 = a6;
  v49 = a4;
  v48 = a5;
  v52 = a7;
  n0x2900 = 0x2900;
  v54 = 0;
  v55 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v56 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_149DC6C80,
    "CBaseEntityGeometryResource::SetGeometry",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\GeometryResource/BaseGeometryResource.cpp",
    0x4F4);
  v11 = 0;
  HIWORD(n0x2900) = word_149DC6C80;
  if ( *a3 )
  {
    a3 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, _BYTE *, char *, _QWORD))(*(_QWORD *)qword_149B4FC18 + 8LL))(
                    qword_149B4FC18,
                    a3,
                    v67,
                    0);
    v12 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v12;
    while ( a3[v12] );
    v11 = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(0xFFFFFFFF, (__int64)a3, v12);
  }
  v13 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v13;
  while ( *(_BYTE *)(v13 + a4) );
  v14 = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(0xFFFFFFFF, a4, v13);
  v15 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v15;
  while ( *(_BYTE *)(a5 + v15) );
  v47 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(v14, a5, v15);
  if ( *(_QWORD *)(v50 + 0x18) )
  {
    v16 = sub_14037FC70(v50 + 0x20);
    v17 = sub_1403B3D00(v50 + 8);
    if ( (unsigned __int64)sub_1403E7A60(v17) <= 0xF )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(*v17 + 0x10);
    v19 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v19;
    while ( *((_BYTE *)p_p_p_p_p_p_p_p_p_p_p_p_Source + v19) );
    v20 = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(
             0xFFFFFFFF,
             (__int64)p_p_p_p_p_p_p_p_p_p_p_p_Source,
             v19);
    v21 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v21;
    while ( *((_BYTE *)v16 + v21) );
    v22 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_149924C30[0])(v20, (__int64)v16, v21);
  }
  else
  {
    v22 = 0;
  }
  v23 = *(_DWORD *)(a1 + 0x1F8);
  v24 = *(_DWORD *)(a1 + 0x1FC);
  v25 = *(_DWORD *)(a1 + 0x200);
  v46 = v24;
  v44 = v25;
  if ( v23 == v11 )
  {
    v30 = v45;
  }
  else
  {
    v26 = *(_QWORD *)a1;
    *(_DWORD *)(a1 + 0x1F8) = v11;
    v51 = *(void (__fastcall **)(__int64, _QWORD, __int64))(v26 + 0x680);
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v27 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v27 = 0;
    v28 = (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v27 + 0x388LL))(v27, v60);
    v51(a1, 0, v28);
    v29 = a3;
    v30 = v45;
    *(_DWORD *)(a1 + 0x288) = sub_14223A500(a1, v45, v29, v52);
    v24 = v46;
  }
  if ( v24 != v47 || v23 != v11 )
  {
    v31 = v48;
    v32 = v49;
    *(_DWORD *)(a1 + 0x1FC) = v47;
    sub_14223C000(a1, v32, v31);
  }
  if ( v44 == v22 && v23 == v11 || (v33 = v50, *(_DWORD *)(a1 + 0x200) = v22, sub_14223DA80(a1, v33), v23 == v11) )
  {
    v66[0] = 0;
    v65 = v66;
    n0x1FF_2 = 0;
    n0x1FF = 0x1FF;
    if ( *(_DWORD *)(a1 + 0x180) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0x184);
    }
    else
    {
      v38 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x170));
      if ( (v38 & 0x200000) != 0 )
        sub_1403CB300(a1 + 0x170, v38, "CBaseEntityGeometryResource::SetGeometry", "m_tagsRWLock", 1);
    }
    v39 = (const void **)sub_1404BD120(a1 + 0x188);
    n0x1FF_1 = sub_1403E7A60(v39);
    v41 = *v39;
    if ( n0x1FF_1 > n0x1FF )
    {
      if ( v65 != v66 )
      {
        qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
        sub_147605980(v65);
      }
      v66[0] = 0;
      v65 = v66;
      n0x1FF_2 = 0;
      n0x1FF = 0x1FF;
      if ( n0x1FF_1 )
      {
        v42 = v66;
        if ( n0x1FF_1 + 1 > 0x200 )
        {
          v42 = (_BYTE *)allocWithProfilerInfo(n0x1FF_1 + 1, 0);
          qword_149B3AB68 += n0x1FF_1 + 1;
          n0x1FF = n0x1FF_1;
        }
        n0x1FF_2 = n0x1FF_1;
        v65 = v42;
        v42[n0x1FF_1] = 0;
      }
    }
    memmove(v65, v41, n0x1FF_1);
    n0x1FF_2 = n0x1FF_1;
    *((_BYTE *)v65 + n0x1FF_1) = 0;
    sub_1402D2790(a1 + 0x170);
    v49 = (__int64)v65;
    v43 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x660LL))(a1);
    v48 = a1;
    v44 = v43;
    sub_1421318D0(a1 + 0xA8, (unsigned int)p_sub_140B13360, (unsigned int)&v48, (unsigned int)&v44, (__int64)&v49);
    if ( v65 != v66 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v65);
    }
  }
  else
  {
    if ( *(float *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6A8LL))(a1) + 0x158) > 0.00000011920929 )
    {
      (*(void (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD, int))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
                                                                    + 0x4C0LL))(
        *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL,
        v60,
        v30,
        0,
        2);
      v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x6A8LL))(a1);
      v35 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      v61 = *(_DWORD *)(v34 + 0x158);
      (*(void (__fastcall **)(__int64, _QWORD, _BYTE *, __int64, _DWORD, _BYTE))(*(_QWORD *)v35 + 0x4C8LL))(
        v35,
        v30,
        v60,
        2,
        0,
        0);
    }
    v36 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)a1 + 0x688LL);
    if ( validateHandleAccess((unsigned __int64 *)(a1 + 8)) )
      v7 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    v37 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v7 + 0x388LL))(v7, v62);
    v36(a1, 0, v37);
  }
  sub_1422CD040(a1);
  v57 = __rdtsc();
  qword_149B4B878(&n0x2900);
}

// --- End Function: sub_1422A41F0 (0x1422A41F0) ---

// --- Function: sub_1422ADF60 (0x1422ADF60) ---
void __fastcall sub_1422ADF60(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 0x288) == 3 )
  {
    sub_142277AF0(a1, *(_BYTE *)(a1 + 0xE8));
    *(_BYTE *)(a1 + 0xE8) = 0;
  }
}

// --- End Function: sub_1422ADF60 (0x1422ADF60) ---

// --- Function: sub_1422CD040 (0x1422CD040) ---
void __fastcall sub_1422CD040(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // dx
  unsigned __int16 v5; // di
  __int64 v6; // rbx
  unsigned int n0x83000; // edi
  __int64 v8; // [rsp+30h] [rbp+8h] BYREF

  v1 = a1[0x1C];
  v8 = v1;
  if ( v1 )
  {
    v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v3 + 4);
    if ( n4 != 4
      && *(_WORD *)(v3 + 2) == (HIWORD(v1) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v8)) )
    {
      v5 = 0xFFFE;
      if ( *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD *))(*a1 + 0x6A8LL))(a1) + 0x148) == 1 )
      {
        v5 = 0xFFFF;
      }
      else if ( *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD *))(*a1 + 0x6A8LL))(a1) + 0x148) == 2 )
      {
        v5 = 0xFFFD;
      }
      v6 = v1 & 0xFFFFFFFFFFFFLL;
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x710LL))(v6, v5);
      n0x83000 = 0;
      switch ( *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD *))(*a1 + 0x6A8LL))(a1) + 0x14C) )
      {
        case 1:
          n0x83000 = 0x83000;
          break;
        case 2:
          n0x83000 = 0x3000;
          break;
        case 3:
          n0x83000 = 0x1000;
          break;
        case 4:
          break;
        case 5:
          n0x83000 = 0x182000;
          break;
        default:
          n0x83000 = 0x183000;
          break;
      }
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x640LL))(v6, n0x83000);
      sub_1422CEC40(a1);
    }
  }
}

// --- End Function: sub_1422CD040 (0x1422CD040) ---

// --- Function: sub_1422CEC40 (0x1422CEC40) ---
char __fastcall sub_1422CEC40(__int64 a1)
{
  _UNKNOWN **v1; // rax
  int v4; // ecx
  _UNKNOWN **v5; // rsi
  __int64 v17; // rbx
  __int16 n2; // dx
  __int64 v19; // rbx
  __int64 v20; // rbp
  __int64 v21; // rdi
  char n0x20; // dl
  __int64 v23; // rax
  __int128 v25; // [rsp+20h] [rbp-78h] BYREF
  int v26; // [rsp+30h] [rbp-68h]
  _UNKNOWN *retaddr; // [rsp+98h] [rbp+0h] BYREF
  __int64 v28; // [rsp+A0h] [rbp+8h] BYREF

  v1 = &retaddr;
  if ( *(_DWORD *)(a1 + 0x288) != 3 )
  {
    v1 = (_UNKNOWN **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x648LL))(a1);
    v4 = *(_DWORD *)(a1 + 0x3FC);
    v5 = v1;
    v25 = *(_OWORD *)(a1 + 0x3EC);
    LODWORD(_XMM9) = v25;
    v26 = v4;
    if ( *(float *)&v25 < 0.0 )
    {
      _XMM0 = *((unsigned int *)v1 + 0x3B);
      __asm
      {
        vmaxss  xmm1, xmm0, dword ptr [rdi+2B8h]
        vmaxss  xmm9, xmm1, dword ptr [rdi+3D8h]
      }
    }
    LODWORD(_XMM8) = DWORD1(v25);
    if ( *((float *)&v25 + 1) < 0.0 )
    {
      _XMM0 = *((unsigned int *)v1 + 0x3C);
      __asm
      {
        vmaxss  xmm1, xmm0, dword ptr [rdi+2D8h]
        vmaxss  xmm8, xmm1, dword ptr [rdi+3DCh]
      }
    }
    LODWORD(_XMM7) = DWORD2(v25);
    if ( *((float *)&v25 + 2) < 0.0 )
    {
      _XMM0 = *((unsigned int *)v1 + 0x3D);
      __asm
      {
        vmaxss  xmm1, xmm0, dword ptr [rdi+2F8h]
        vmaxss  xmm7, xmm1, dword ptr [rdi+3E0h]
      }
    }
    LODWORD(_XMM6) = HIDWORD(v25);
    if ( *((float *)&v25 + 3) < 0.0 )
    {
      _XMM0 = *((unsigned int *)v1 + 0x3E);
      __asm
      {
        vmaxss  xmm1, xmm0, dword ptr [rdi+318h]
        vmaxss  xmm6, xmm1, dword ptr [rdi+3E4h]
      }
    }
    v17 = *(_QWORD *)(a1 + 0xE0);
    v28 = v17;
    if ( v17 )
    {
      v1 = (_UNKNOWN **)sub_1403B4B50(v17 & 0xFFFFFFFFFFFFLL);
      n2 = *((_WORD *)v1 + 2);
      if ( n2 != 4 && *((_WORD *)v1 + 1) == (HIWORD(v17) & 0xFFF) )
      {
        if ( n2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || (LOBYTE(v1) = sub_140391F30(&v28), (_BYTE)v1) )
        {
          v19 = v17 & 0xFFFFFFFFFFFFLL;
          v20 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x660LL))(a1);
          v1 = (_UNKNOWN **)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v19 + 0x6C8LL))(v19, v20);
          v21 = (__int64)v1;
          if ( v1 )
          {
            sub_1405051A0((__int64)v1, (char *)v1, *(float *)&_XMM9);
            sub_140505130(v21, *(float *)&_XMM8);
            sub_1405051A0(v21, (char *)(v21 + 2), *(float *)&_XMM7);
            sub_1405051A0(v21, (char *)(v21 + 1), *(float *)&_XMM6);
            n0x20 = *((_BYTE *)v5 + 0xFC);
            if ( (unsigned __int8)n0x20 < 0x20u )
              sub_14051D760(v21, n0x20);
            v23 = *(_QWORD *)v19;
            *(_QWORD *)&v25 = &v28;
            v28 = v21;
            *((_QWORD *)&v25 + 1) = sub_14212A920;
            LOBYTE(v1) = (*(__int64 (__fastcall **)(__int64, _QWORD, __int128 *))(v23 + 0x6D0))(
                           v19,
                           (unsigned int)v20,
                           &v25);
          }
        }
      }
    }
  }
  return (char)v1;
}

// --- End Function: sub_1422CEC40 (0x1422CEC40) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: _onexit (0x1480335BC) ---
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)(); // rdx

  if ( Table._first == (_PVFV *)0xFFFFFFFFFFFFFFFFLL )
    v2 = crt_atexit((_PVFV)Func);
  else
    v2 = register_onexit_function(&Table, Func);
  v3 = 0;
  if ( !v2 )
    return Func;
  return v3;
}

// --- End Function: _onexit (0x1480335BC) ---

// --- Function: atexit (0x1480335F8) ---
int __cdecl atexit(void (__cdecl *Func)())
{
  return (onexit((_onexit_t)Func) != 0) - 1;
}

// --- End Function: atexit (0x1480335F8) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
// Standard stack security check function. Compares the provided stack cookie with
// the global security cookie. If a mismatch is detected or the cookie is
// corrupted, it triggers a security failure report.
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: strstr (0x148082149) ---
// attributes: thunk
char *__cdecl strstr(const char *Str, const char *SubStr)
{
  return __imp_strstr(Str, SubStr);
}

// --- End Function: strstr (0x148082149) ---

// --- Function: _register_onexit_function (0x148082329) ---
// attributes: thunk
int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function)
{
  return _register_onexit_function(Table, Function);
}

// --- End Function: _register_onexit_function (0x148082329) ---

// --- Function: _crt_atexit (0x14808232F) ---
// attributes: thunk
int __cdecl crt_atexit(_PVFV Function)
{
  return _crt_atexit(Function);
}

// --- End Function: _crt_atexit (0x14808232F) ---

// --- Function: sub_1480BD370 (0x1480BD370) ---
void __fastcall sub_1480BD370()
{
  if ( *(int *)(qword_149B3E060 - 4) > 0 )
    sub_147605980((const void *)(qword_149B3E060 - 8));
}

// --- End Function: sub_1480BD370 (0x1480BD370) ---

