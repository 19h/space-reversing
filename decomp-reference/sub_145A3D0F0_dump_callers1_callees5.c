// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x145A3D0F0 (sub_145A3D0F0)
// Caller Depth: 1
// Callee/Ref Depth: 5
// Total Functions Found: 377
// ------------------------------------------------------------

// --- Function: sub_1402A24F0 (0x1402A24F0) ---
__int64 __fastcall sub_1402A24F0(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1402A24F0 (0x1402A24F0) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A2870) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3190 (0x1402A3190) ---
__int64 sub_1402A3190(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n511;
  while ( Buffer[n511] );
  sub_1402A3BE0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A3190 (0x1402A3190) ---

// --- Function: ?do_is_equal@_Identity_equal_resource@pmr@std@@MEBA_NAEBVmemory_resource@23@@Z (0x1402A3450) ---
bool __fastcall std::pmr::_Identity_equal_resource::do_is_equal(
        std::pmr::_Identity_equal_resource *this,
        const struct std::pmr::memory_resource *this_1)
{
  return this == this_1;
}

// --- End Function: ?do_is_equal@_Identity_equal_resource@pmr@std@@MEBA_NAEBVmemory_resource@23@@Z (0x1402A3450) ---

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402A3B50 (0x1402A3B50) ---
_BYTE *__fastcall sub_1402A3B50(__int64 *a1, __int64 n511_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n511; // rcx

  result = a1 + 3;
  if ( n511_1 )
  {
    allocSize = n511_1 + 1;
    if ( (unsigned __int64)(n511_1 + 1) <= 0x200 )
    {
      n511 = 511;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3AB68 += allocSize;
      n511 = n511_1;
    }
    a1[1] = n511;
    *a1 = n511_1;
    a1[2] = (__int64)result;
    result[n511_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 511;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A3B50 (0x1402A3B50) ---

// --- Function: sub_1402A3BE0 (0x1402A3BE0) ---
__int64 __fastcall sub_1402A3BE0(__int64 a1, const void *a2, size_t n511)
{
  size_t n511_1; // r8
  const void *v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  n511_1 = *(_QWORD *)(a1 + 8);
  if ( n511 > n511_1 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n511_1;
      sub_147605980(v7);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x1FF;
    sub_1402A3B50((__int64 *)a1, n511);
  }
  memmove(*(void **)(a1 + 0x10), a2, n511);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n511;
  *(_BYTE *)(n511 + result) = 0;
  return result;
}

// --- End Function: sub_1402A3BE0 (0x1402A3BE0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
void __fastcall sub_1402A3D30(const void *a1)
{
  sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---
_QWORD *__fastcall std::_Allocate<16,std::_Default_allocate_traits,0>(unsigned __int64 _Bytes)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  _QWORD *result; // rax

  if ( _Bytes < 0x1000 )
  {
    if ( _Bytes )
      return (_QWORD *)allocWithProfilerInfo_w(_Bytes);
    else
      return 0;
  }
  else
  {
    if ( _Bytes + 0x27 < _Bytes )
      sub_1402E1170();
    v1 = allocWithProfilerInfo_w(_Bytes + 0x27);
    v2 = v1;
    if ( !v1 )
      invalid_parameter_noinfo_noreturn();
    result = (_QWORD *)((v1 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    result[0xFFFFFFFF] = v2;
  }
  return result;
}

// --- End Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---

// --- Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A60C0) ---
void __fastcall std::_Deallocate<16,0>(_QWORD *a1, unsigned __int64 n0x1000)
{
  if ( n0x1000 >= 0x1000 )
  {
    if ( (unsigned __int64)a1 - a1[0xFFFFFFFF] - 8 > 0x1F )
      invalid_parameter_noinfo_noreturn();
    a1 = (_QWORD *)a1[0xFFFFFFFF];
  }
  sub_1402A3D30(a1);
}

// --- End Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A60C0) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall sub_1402A6760(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: sub_1402A85A0 (0x1402A85A0) ---
unsigned __int64 __fastcall sub_1402A85A0(unsigned __int64 a1)
{
  if ( a1 > 0xFFFFFFFFFFFFFFFLL )
    sub_1402E1170();
  return 0x10 * a1;
}

// --- End Function: sub_1402A85A0 (0x1402A85A0) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: unknown_libname_2 (0x1402ADBA0) ---
// Microsoft VisualC v14 64bit runtime
_QWORD *__fastcall unknown_libname_2(_QWORD *a1, _QWORD *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

// --- End Function: unknown_libname_2 (0x1402ADBA0) ---

// --- Function: sub_1402B1640 (0x1402B1640) ---
void __fastcall sub_1402B1640(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: sub_1402B1640 (0x1402B1640) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: sub_1402B1820 (0x1402B1820) ---
const ULONG_PTR *__fastcall sub_1402B1820(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v4; // eax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 0x14);
  if ( v2 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v4 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v1, v4);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402B1820 (0x1402B1820) ---

// --- Function: sub_1402B4B90 (0x1402B4B90) ---
bool __fastcall sub_1402B4B90(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

// --- End Function: sub_1402B4B90 (0x1402B4B90) ---

// --- Function: LogTraceConditional (0x1402C1000) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
        qword_149B4FCB0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C1000) ---

// --- Function: sub_1402C4680 (0x1402C4680) ---
__int64 __fastcall sub_1402C4680(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0x24;
  sub_1402C61F0(
    a1,
    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    *(unsigned __int8 *)(a2 + 7),
    *(unsigned __int8 *)(a2 + 6),
    *(unsigned __int8 *)(a2 + 5),
    *(unsigned __int8 *)(a2 + 4),
    HIBYTE(*(_DWORD *)a2),
    (unsigned __int8)BYTE2(*(_DWORD *)a2),
    BYTE1(*(_DWORD *)a2),
    (unsigned __int8)*(_DWORD *)a2,
    *(unsigned __int8 *)(a2 + 0xF),
    *(unsigned __int8 *)(a2 + 0xE),
    *(unsigned __int8 *)(a2 + 0xD),
    *(unsigned __int8 *)(a2 + 0xC),
    HIBYTE(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)BYTE2(*(_DWORD *)(a2 + 8)),
    BYTE1(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)*(_DWORD *)(a2 + 8));
  return a1;
}

// --- End Function: sub_1402C4680 (0x1402C4680) ---

// --- Function: sub_1402C61F0 (0x1402C61F0) ---
__int64 sub_1402C61F0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n36; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n36 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n36;
  while ( Buffer[n36] );
  sub_1402DE5F0(a1, Buffer, n36);
  return a1;
}

// --- End Function: sub_1402C61F0 (0x1402C61F0) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402CD240 (0x1402CD240) ---
__int64 __fastcall sub_1402CD240(__int64 a1, const char *a2, char a3)
{
  __int64 result; // rax
  int v7; // edi
  unsigned __int32 v8; // eax

  result = NtCurrentTeb_w();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v8 )
    {
      result = sub_1403C33A0(a1, v8, a2, a3);
    }
    else
    {
      result = NtCurrentTeb_w();
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v7;
  }
  return result;
}

// --- End Function: sub_1402CD240 (0x1402CD240) ---

// --- Function: ?_Decref@_Ref_count_base@std@@QEAAXXZ (0x1402DEFC0) ---
void __fastcall std::_Ref_count_base::_Decref(std::_Ref_count_base *this)
{
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(std::_Ref_count_base *))this)(this);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(std::_Ref_count_base *))(*(_QWORD *)this + 8LL))(this);
  }
}

// --- End Function: ?_Decref@_Ref_count_base@std@@QEAAXXZ (0x1402DEFC0) ---

// --- Function: sub_1402E07D0 (0x1402E07D0) ---
void __fastcall sub_1402E07D0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 n8; // rbx
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v5; // r15
  unsigned __int64 allocSize; // rcx
  __int64 v7; // rax
  _QWORD *v8; // r14
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx
  __int64 v11; // r12
  size_t Size; // rdi
  const void *v13; // rdx
  char *v14; // rdi
  size_t Size_1; // r8
  char *v16; // rcx
  const void *v17; // rcx

  n8 = 1;
  n8_1 = a1[2];
  if ( n8_1 )
    n8 = n8_1;
  while ( n8 - n8_1 < a2 || n8 < 8 )
  {
    if ( 0xFFFFFFFFFFFFFFFLL - n8 < n8 )
      unknown_libname_8(n8_1, a2, 0xFFFFFFFFFFFFFFFLL);
    n8 *= 2LL;
  }
  v5 = a1[3] >> 1;
  if ( n8 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  allocSize = 8 * n8;
  if ( 8 * n8 < 0x1000 )
  {
    if ( allocSize )
      v8 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v8 = 0;
    goto LABEL_15;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_25:
    sub_1402E1170();
  v7 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v7 )
    goto LABEL_24;
  v8 = (_QWORD *)((v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v8[0xFFFFFFFF] = v7;
LABEL_15:
  v9 = a1[2];
  v10 = n8 - v9;
  v11 = 8 * v5;
  Size = 8 * v9 - 8 * v5;
  memmove(&v8[v5], (const void *)(a1[1] + 8 * v5), Size);
  v13 = (const void *)a1[1];
  v14 = (char *)&v8[v5] + Size;
  if ( v5 > v10 )
  {
    memmove(v14, v13, 8 * v10);
    memmove(v8, (const void *)(8 * v10 + a1[1]), v11 - 8 * v10);
    v16 = (char *)v8 + v11 - 8 * v10;
    Size_1 = 8 * v10;
  }
  else
  {
    memmove(v14, v13, 8 * v5);
    memset(&v14[v11], 0, 8 * (v10 - v5));
    Size_1 = 8 * v5;
    v16 = (char *)v8;
  }
  memset(v16, 0, Size_1);
  v17 = (const void *)a1[1];
  if ( v17 )
  {
    if ( (unsigned __int64)(8LL * a1[2]) < 0x1000 )
    {
LABEL_22:
      sub_1402A3D30(v17);
      goto LABEL_23;
    }
    if ( (unsigned __int64)v17 - *((_QWORD *)v17 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v17 = (const void *)*((_QWORD *)v17 + 0xFFFFFFFF);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  a1[2] += v10;
  a1[1] = v8;
}

// --- End Function: sub_1402E07D0 (0x1402E07D0) ---

// --- Function: _InterlockedIncrement_w_1 (0x1402E0B90) ---
void __fastcall InterlockedIncrement_w_1(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 8));
}

// --- End Function: _InterlockedIncrement_w_1 (0x1402E0B90) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: sub_1402E11D0 (0x1402E11D0) ---
void __fastcall sub_1402E11D0(_QWORD *a1)
{
  __int64 v1; // rax
  _QWORD *v3; // r14
  __int64 v4; // rbx
  const void *v5; // rcx
  _QWORD *v6; // rcx

  v1 = a1[4];
  if ( v1 )
  {
    do
      a1[4] = --v1;
    while ( v1 );
    a1[3] = 0;
  }
  v3 = a1 + 1;
  if ( a1[1] )
  {
    v4 = a1[2];
    if ( v4 )
    {
      do
      {
        --v4;
        v5 = *(const void **)(a1[1] + 8 * v4);
        if ( v5 )
          sub_1402A3D30(v5);
      }
      while ( v4 );
      v3 = a1 + 1;
    }
    v6 = (_QWORD *)a1[1];
    if ( (unsigned __int64)(8LL * a1[2]) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - v6[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)v6[0xFFFFFFFF];
    }
    sub_1402A3D30(v6);
  }
  *v3 = 0;
  a1[2] = 0;
}

// --- End Function: sub_1402E11D0 (0x1402E11D0) ---

// --- Function: unknown_libname_8 (0x1402E1F50) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_8()
{
  std::_Xlength_error("deque<T> too long");
}

// --- End Function: unknown_libname_8 (0x1402E1F50) ---

// --- Function: unknown_libname_9 (0x1402E1F70) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E1F70) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: NtCurrentTeb_ww_0 (0x1402E2480) ---
__int64 NtCurrentTeb_ww_0()
{
  return *(unsigned __int8 *)(NtCurrentTeb_w() + 0x12D);
}

// --- End Function: NtCurrentTeb_ww_0 (0x1402E2480) ---

// --- Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---
// Microsoft VisualC v14 64bit runtime
__int64 __fastcall __crt_strtox::maximum_signed_value(__crt_strtox *this)
{
  return 0x7FFFFFFFFFFFFFFFLL;
}

// --- End Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n22 = 22;
  if ( n22 + 1 >= 0x1000 )
  {
    allocSize = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n22 == -1 )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FD310 (0x1402FD310) ---
__int64 __fastcall sub_1402FD310(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  if ( a4 < a5 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(a3 + 112 * a4 + 24))(
             *(_QWORD *)(a3 + 112 * a4),
             a1,
             a2,
             a4 - a5 + 1);
  else
    return 0;
}

// --- End Function: sub_1402FD310 (0x1402FD310) ---

// --- Function: sub_1402FD350 (0x1402FD350) ---
__int64 __fastcall sub_1402FD350(_BYTE *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  _BYTE v6[24]; // [rsp+40h] [rbp-18h] BYREF

  return sub_1402FF680((__int64)v6, a1, a2, a3, a4, a5);
}

// --- End Function: sub_1402FD350 (0x1402FD350) ---

// --- Function: sub_1402FD7E0 (0x1402FD7E0) ---
__int64 **__fastcall sub_1402FD7E0(__int64 **a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v6; // rcx
  __int64 *v7; // rbx
  __int64 n40; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 *v12; // rbp
  __int64 *v13; // rdx
  __int64 *v14; // r8
  __int64 *v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // r9
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  __int64 *v24; // rdx
  __int64 *v25; // r9
  __int64 v26; // rsi
  __int64 v27; // rdi
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r10
  __int64 v30; // rax
  bool v31; // zf
  __int64 *v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rsi
  unsigned __int64 v35; // rdi
  unsigned __int64 v36; // r11
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 **result; // rax

  v6 = a2;
  v7 = &a2[(__int64)(a3 - (_QWORD)a2) >> 4];
  n40 = (__int64)(a3 - 8 - (_QWORD)a2) >> 3;
  if ( n40 <= 40 )
  {
    v14 = (__int64 *)(a3 - 8);
  }
  else
  {
    v9 = (n40 + 1) >> 3;
    v10 = 16 * v9;
    v11 = 8 * v9;
    v12 = &a2[v9];
    sub_1402FD760(a2, v12, &a2[2 * v9]);
    sub_1402FD760(&v7[v11 / 0xFFFFFFFFFFFFFFF8uLL], v7, &v7[(unsigned __int64)v11 / 8]);
    sub_1402FD760((__int64 *)(a3 - 8 - v10), (__int64 *)(a3 - 8 - v11), (__int64 *)(a3 - 8));
    v14 = v13;
    v6 = v12;
  }
  sub_1402FD760(v6, v7, v14);
  v15 = v7 + 1;
  if ( a2 < v7 )
  {
    v16 = *v7;
    do
    {
      v17 = *(v7 - 1);
      v18 = *(_QWORD *)(v16 + 8);
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 < v18 || v19 == v18 && *(_QWORD *)(v17 + 80) < *(_QWORD *)(v16 + 80) )
        break;
      if ( v18 < v19 || v18 == v19 && *(_QWORD *)(v16 + 80) < *(_QWORD *)(v17 + 80) )
        break;
      --v7;
      v16 = v17;
    }
    while ( a2 < v7 );
  }
  if ( (unsigned __int64)v15 < a3 )
  {
    v20 = *v7;
    v21 = *(_QWORD *)(*v7 + 8);
    do
    {
      v22 = *v15;
      v23 = *(_QWORD *)(*v15 + 8);
      if ( v23 < v21 || v23 == v21 && *(_QWORD *)(v22 + 80) < *(_QWORD *)(v20 + 80) )
        break;
      if ( v21 < v23 || v21 == v23 && *(_QWORD *)(v20 + 80) < *(_QWORD *)(v22 + 80) )
        break;
      ++v15;
    }
    while ( (unsigned __int64)v15 < a3 );
  }
  v24 = v15;
  v25 = v7;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( (unsigned __int64)v24 < a3 )
      {
        v26 = *v24;
        v27 = *v7;
        v28 = *(_QWORD *)(*v24 + 8);
        v29 = *(_QWORD *)(*v7 + 8);
        if ( v29 >= v28 && (v29 != v28 || *(_QWORD *)(v27 + 80) >= *(_QWORD *)(v26 + 80)) )
        {
          if ( v28 < v29 || v28 == v29 && *(_QWORD *)(v26 + 80) < *(_QWORD *)(v27 + 80) )
            break;
          if ( v15 != v24 )
          {
            v30 = *v15;
            *v15 = v26;
            *v24 = v30;
          }
          ++v15;
        }
        ++v24;
      }
      v31 = v25 == a2;
      if ( v25 <= a2 )
        goto LABEL_46;
      v32 = v25 - 1;
      while ( 1 )
      {
        v33 = *v7;
        v34 = *v32;
        v35 = *(_QWORD *)(*v7 + 8);
        v36 = *(_QWORD *)(*v32 + 8);
        if ( v36 >= v35 && (v36 != v35 || *(_QWORD *)(v34 + 80) >= *(_QWORD *)(v33 + 80)) )
          break;
LABEL_44:
        --v25;
        --v32;
        if ( a2 >= v25 )
          goto LABEL_45;
      }
      if ( v35 >= v36 && (v35 != v36 || *(_QWORD *)(v33 + 80) >= *(_QWORD *)(v34 + 80)) )
      {
        if ( --v7 != v32 )
        {
          v37 = *v7;
          *v7 = v34;
          *v32 = v37;
        }
        goto LABEL_44;
      }
LABEL_45:
      v31 = v25 == a2;
LABEL_46:
      if ( !v31 )
      {
        --v25;
        if ( v24 == (__int64 *)a3 )
        {
          if ( v25 != --v7 )
          {
            v40 = *v25;
            *v25 = *v7;
            *v7 = v40;
          }
          v41 = *--v15;
          v42 = *v7;
          *v7 = v41;
          *v15 = v42;
        }
        else
        {
          v43 = *v24;
          *v24++ = *v25;
          *v25 = v43;
        }
        continue;
      }
      break;
    }
    if ( v24 != (__int64 *)a3 )
    {
      if ( v15 != v24 )
      {
        v38 = *v7;
        *v7 = *v15;
        *v15 = v38;
      }
      ++v15;
      v39 = *v7;
      *v7++ = *v24;
      *v24++ = v39;
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v7;
  a1[1] = v15;
  return result;
}

// --- End Function: sub_1402FD7E0 (0x1402FD7E0) ---

// --- Function: sub_1402FDAA0 (0x1402FDAA0) ---
unsigned __int64 __fastcall sub_1402FDAA0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rdi
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r11
  __int64 v11; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 n2; // rax
  unsigned __int64 v15; // r11
  __int64 v16; // rcx
  __int64 v17; // r8
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v10 = 2 * v9;
      v11 = *(_QWORD *)(a1 + 16 * v9 + 16);
      v12 = *(_QWORD *)(a1 + 16 * v9 + 8);
      v13 = *(_QWORD *)(v11 + 8);
      if ( v13 < *(_QWORD *)(v12 + 8) || v13 == *(_QWORD *)(v12 + 8) && *(_QWORD *)(v11 + 80) < *(_QWORD *)(v12 + 80) )
        n2 = 1;
      else
        n2 = 2;
      v9 = v10 + n2;
      *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * (v10 + n2));
      a2 = v10 + n2;
    }
    while ( v10 + n2 < v5 );
  }
  if ( v9 == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v8 >= a2 )
  {
    result = *a4;
    *(_QWORD *)(a1 + 8 * a2) = *a4;
  }
  else
  {
    while ( 1 )
    {
      v15 = *a4;
      v16 = (a2 - 1) >> 1;
      v17 = *(_QWORD *)(a1 + 8 * v16);
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(*a4 + 8) )
      {
        if ( result != *(_QWORD *)(*a4 + 8) )
          break;
        result = *(_QWORD *)(v15 + 80);
        if ( *(_QWORD *)(v17 + 80) >= result )
          break;
      }
      *(_QWORD *)(a1 + 8 * a2) = v17;
      a2 = (a2 - 1) >> 1;
      if ( v8 >= v16 )
      {
        result = *a4;
        *(_QWORD *)(a1 + 8 * v16) = *a4;
        return result;
      }
    }
    *(_QWORD *)(a1 + 8 * a2) = v15;
  }
  return result;
}

// --- End Function: sub_1402FDAA0 (0x1402FDAA0) ---

// --- Function: sub_1402FDB90 (0x1402FDB90) ---
unsigned __int64 __fastcall sub_1402FDB90(__int64 *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  _QWORD *v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v7 = ((__int64)v2 - *a1) / 112;
  if ( a2 < v7 )
  {
    v8 = v4 + 112 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 112 )
    {
      if ( *(_BYTE *)(i + 88) )
      {
        if ( *(_QWORD *)i )
          result = (*(__int64 (**)(void))(i + 64))();
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
    return result;
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v11 = v10 / 112;
  if ( a2 > v10 / 112 )
  {
    if ( a2 > 0x249249249249249LL )
      unknown_libname_10();
    v12 = v11 >> 1;
    if ( v11 <= 0x249249249249249LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x249249249249249LL )
          goto LABEL_29;
      }
      else
      {
        v13 = a2;
      }
      allocSize = 112 * v13;
      if ( 112 * v13 < 0x1000 )
      {
        if ( allocSize )
          v16 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
        else
          v16 = 0;
LABEL_23:
        v17 = &v16[14 * v7];
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 14;
            --v18;
          }
          while ( v18 );
        }
        sub_1402FE290(*a1, a1[1], v16);
        return sub_1402FFAF0(a1, (__int64)v16, a2, v13);
      }
      if ( allocSize + 39 >= allocSize )
      {
        v15 = allocWithProfilerInfo_w(allocSize + 39);
        if ( !v15 )
          invalid_parameter_noinfo_noreturn();
        v16 = (_QWORD *)((v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v16 - 1) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402E1170();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 14;
  }
  a1[1] = (__int64)v2;
  return result;
}

// --- End Function: sub_1402FDB90 (0x1402FDB90) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)v8 + 80LL) )
          {
            n256 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i - 1);
              i -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                  break;
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30-- - v8) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: sub_1402FE6B0 (0x1402FE6B0) ---
__int64 __fastcall sub_1402FE6B0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
      return 0xFFFFFFFFLL;
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAu;
    *(_BYTE *)(v6 + v5) = v9 + 48;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_1402FE6B0 (0x1402FE6B0) ---

// --- Function: sub_1402FE770 (0x1402FE770) ---
__int64 __fastcall sub_1402FE770(
        double *Buffer,
        unsigned __int64 Size,
        __int64 a3,
        const void **a4,
        const void **a5,
        const void **a6,
        _BYTE *p_])
{
  _BYTE *v7; // rdi
  size_t Size_1; // rbx
  char *v12; // rcx
  size_t Size_2; // rsi
  size_t Size_3; // rdi
  __int64 v15; // r14
  _BYTE *v16; // rsi
  char *v17; // rcx
  size_t Size_4; // rbp
  int v19; // eax
  int v20; // ecx
  __int64 result; // rax

  v7 = *a4;
  Size_1 = -1;
  do
    ++Size_1;
  while ( v7[Size_1] );
  if ( Size_1 + a3 >= Size )
    return 0xFFFFFFFFLL;
  v12 = (char *)Buffer + a3;
  Size_2 = Size - a3;
  if ( Size_1 )
  {
    if ( !v12 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v7 && Size_2 >= Size_1 )
    {
      memcpy(v12, *a4, Size_1);
    }
    else
    {
      memset(v12, 0, Size - a3);
      if ( !v7 )
        goto LABEL_6;
      if ( Size_2 < Size_1 )
      {
        *errno() = 34;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size_1 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  Size_3 = -1;
  v15 = a3 + (int)Size_1;
  v16 = *a5;
  do
    ++Size_3;
  while ( v16[Size_3] );
  if ( Size_3 + v15 >= Size )
    return 0xFFFFFFFFLL;
  v17 = (char *)Buffer + v15;
  Size_4 = Size - v15;
  if ( !Size_3 )
    goto LABEL_28;
  if ( !v17 )
    goto LABEL_20;
  if ( v16 && Size_4 >= Size_3 )
  {
    memcpy(v17, *a5, Size_3);
  }
  else
  {
    memset(v17, 0, Size - v15);
    if ( !v16 )
    {
LABEL_20:
      *errno() = 22;
LABEL_27:
      invalid_parameter_noinfo();
      goto LABEL_28;
    }
    if ( Size_4 < Size_3 )
    {
      *errno() = 34;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( (Size_3 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v19 = sub_1402FE920(Buffer, Size, v15 + (int)Size_3, a6, p_]);
  if ( v19 < 0 )
    return 0xFFFFFFFFLL;
  v20 = Size_3 + v19;
  result = (unsigned int)(Size_1 + Size_3 + v19);
  if ( v20 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_1402FE770 (0x1402FE770) ---

// --- Function: sub_1402FE920 (0x1402FE920) ---
__int64 __fastcall sub_1402FE920(double *Buffer, unsigned __int64 n0xF, __int64 a3, const void **a4, _BYTE *_)
{
  _BYTE *v5; // rsi
  size_t Size; // rbx
  char *v10; // rcx
  size_t Size_1; // rbp
  __int64 v12; // rcx
  size_t Size_2; // rdi
  _BYTE *v14; // rcx

  v5 = *a4;
  Size = -1;
  do
    ++Size;
  while ( v5[Size] );
  if ( Size + a3 >= n0xF )
    return 0xFFFFFFFFLL;
  v10 = (char *)Buffer + a3;
  Size_1 = n0xF - a3;
  if ( !Size )
    goto LABEL_14;
  if ( !v10 )
    goto LABEL_6;
  if ( v5 && Size_1 >= Size )
  {
    memcpy(v10, v5, Size);
  }
  else
  {
    memset(v10, 0, n0xF - a3);
    if ( !v5 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( Size_1 < Size )
    {
      *errno() = 34;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v12 = a3 + (int)Size;
  if ( v12 + 1 >= n0xF )
    return 0xFFFFFFFFLL;
  Size_2 = n0xF - v12;
  v14 = (char *)Buffer + v12;
  if ( !v14 )
  {
LABEL_17:
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(Size + 1);
  }
  if ( _ && Size_2 )
  {
    *v14 = *_;
    return (unsigned int)(Size + 1);
  }
  else
  {
    memset(v14, 0, Size_2);
    if ( !_ )
      goto LABEL_17;
    if ( !Size_2 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(Size + 1);
  }
}

// --- End Function: sub_1402FE920 (0x1402FE920) ---

// --- Function: sub_1402FEA70 (0x1402FEA70) ---
__int64 __fastcall sub_1402FEA70(double *Buffer, unsigned __int64 n0xF, __int64 a3, char *p____EVT_COUNT__:, int *a5)
{
  unsigned __int64 n0xD; // rdi
  char *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r10
  int v13; // ecx
  int v14; // r9d
  __int64 v15; // rdi
  __int64 i; // r8
  __int64 v17; // r11
  int v18; // eax
  char *v19; // r8
  char *v20; // rax
  __int64 v21; // r10
  char v22; // cl
  char v23; // dl
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v10 = (char *)Buffer + a3;
  if ( !v10 )
    goto LABEL_3;
  if ( p____EVT_COUNT__: && n0xD >= 0xD )
  {
    *(double *)v10 = *(double *)p____EVT_COUNT__:;
    *((_DWORD *)v10 + 2) = *((_DWORD *)p____EVT_COUNT__: + 2);
    v10[0xC] = p____EVT_COUNT__:[0xC];
    goto LABEL_11;
  }
  memset(v10, 0, n0xF - a3);
  if ( p____EVT_COUNT__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v11 = n0xF - (a3 + 0xD);
  v12 = (__int64)Buffer + a3 + 0xD;
  v13 = *a5;
  if ( *a5 >= 0 )
  {
    v14 = 0;
  }
  else if ( v11 )
  {
    *(_BYTE *)v12 = 0x2D;
    v13 = -v13 & 0x7FFFFFFF;
    v14 = 1;
  }
  else
  {
    v14 = 0xFFFFFFFF;
  }
  v15 = v14;
  for ( i = v14; ; ++i )
  {
    v17 = v14;
    if ( v14 >= (int)v11 || i < 0 )
      break;
    ++v14;
    v18 = v13 % 0xA;
    v13 /= 0xA;
    *(_BYTE *)(i + v12) = v18 + 0x30;
    if ( !v13 )
    {
      if ( v15 < v17 )
      {
        v19 = (char *)(v17 + v12);
        v20 = (char *)(v15 + v12);
        v21 = -v12;
        do
        {
          v22 = *v19--;
          v23 = *v20;
          *v20++ = v22;
          v19[1] = v23;
        }
        while ( (__int64)&v20[v21] < (__int64)&v19[v21] );
      }
      result = (unsigned int)(v14 + 0xD);
      if ( v14 >= 0 )
        return result;
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEA70 (0x1402FEA70) ---

// --- Function: sub_1402FEBF0 (0x1402FEBF0) ---
__int64 __fastcall sub_1402FEBF0(
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a3,
        char *p____@severity__:,
        unsigned int *p_n0xF,
        char *___severity__:_,
        const void **a7,
        char *p______tags__:[)
{
  unsigned __int64 n0xD; // rbx
  char *v13; // rcx
  int v14; // ebx
  __int64 v15; // rsi
  __int64 v16; // rcx
  unsigned int n0xF_1; // r9d
  __int64 v18; // r8
  __int64 v19; // r11
  unsigned int v20; // eax
  char *v21; // rdx
  __int64 v22; // r9
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v13 = (char *)Buffer + a3;
  if ( !v13 )
    goto LABEL_3;
  if ( p____@severity__: && n0xD >= 0xD )
  {
    *(double *)v13 = *(double *)p____@severity__:;
    *((_DWORD *)v13 + 2) = *((_DWORD *)p____@severity__: + 2);
    v13[0xC] = p____@severity__:[0xC];
    goto LABEL_11;
  }
  memset(v13, 0, n0xF - a3);
  if ( p____@severity__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v14 = 0;
  v15 = a3 + 0xD;
  v16 = 0;
  n0xF_1 = *p_n0xF;
  v18 = (__int64)Buffer + v15;
  while ( 1 )
  {
    v19 = v14;
    if ( v14 >= (int)n0xF - (int)v15 || v16 < 0 )
      break;
    ++v14;
    v20 = n0xF_1 % 0xA;
    n0xF_1 /= 0xAu;
    *(_BYTE *)(v16 + v18) = v20 + 0x30;
    ++v16;
    if ( !n0xF_1 )
    {
      if ( (int)v19 > 0 )
      {
        v21 = (char *)(v19 + v18);
        v22 = -v18;
        do
        {
          v23 = *v21--;
          v24 = *(_BYTE *)v18;
          *(_BYTE *)v18++ = v23;
          v21[1] = v24;
        }
        while ( v22 + v18 < (__int64)&v21[v22] );
      }
      if ( v14 >= 0 )
      {
        v25 = sub_1402FED90(Buffer, n0xF, v15 + v14, ___severity__:_, a7, p______tags__:[);
        if ( v25 >= 0 )
        {
          v26 = v14 + v25;
          result = (unsigned int)(v14 + v25 + 0xD);
          if ( v26 < 0 )
            return 0xFFFFFFFFLL;
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEBF0 (0x1402FEBF0) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---
void __fastcall std::vector<vraudio::AudioBuffer const *>::_Change_array(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  _QWORD *v6; // rcx

  v6 = *(_QWORD **)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)*(v6 - 1);
    }
    sub_1402A3D30(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(__int64 a1, _QWORD *a2, __int64 a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(a3 + 36));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(a3 + 32);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(a3 + 8);
  v18 = *(_QWORD *)a3;
  v31 = v16;
  if ( (v17 - *(_QWORD *)a3) / 112 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 88) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 64))();
        v18 += 112;
      }
      while ( v18 != v17 );
      *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
    }
    sub_1402FDB90((__int64 *)a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 48;
    v23 = -48 - __Val_0___1;
    v29 = -48 - __Val_0___1;
    while ( !v16 )
    {
      v20 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 24)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 112LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 48),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)a3));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 112;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = -16 - __Val_0__;
      v26 = __Val_0__ + 16;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 56)
          && *(_QWORD *)(v26 + 32) )
        {
          if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 112LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)a3;
          if ( *(_BYTE *)(v27 + 88) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 64))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 56))(*(_QWORD *)(v26 - 16));
          v25 = -16 - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 16) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 24) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 32) = *(_QWORD *)(v26 + 16);
          *(_QWORD *)(v27 + 48) = *(_QWORD *)(v26 + 32);
          *(_QWORD *)(v27 + 40) = *(_QWORD *)(v26 + 24);
          *(_QWORD *)(v27 + 56) = *(_QWORD *)(v26 + 40);
          *(_QWORD *)(v27 + 64) = *(_QWORD *)(v26 + 48);
          *(_QWORD *)(v27 + 72) = *(_QWORD *)(v26 + 56);
          *(_QWORD *)(v27 + 80) = *(_QWORD *)(v26 + 64);
          *(_QWORD *)(v27 + 96) = *(_QWORD *)(v26 + 80);
          *(_QWORD *)(v27 + 104) = *(_QWORD *)(v26 + 88);
          *(_BYTE *)(v27 + 88) = 1;
          *(_BYTE *)(v27 + 89) = *(_BYTE *)(v26 + 73);
        }
        ++_Newcapacity_2;
        v26 += 112;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(a3 + 24) = a1;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 19), SizeInBytes - 19, ".%03dZ", v3 - 1000 * v7) + 19);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149B3B1F0 )
    result = qword_149B3B1F0(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149B3B208 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140300AB0 (0x140300AB0) ---
__int64 __fastcall sub_140300AB0(int a1)
{
  __int64 n1000; // rax

  switch ( a1 )
  {
    case 2:
      n1000 = 1000;
      break;
    case 3:
      n1000 = 5000;
      break;
    case 4:
      n1000 = 15000;
      break;
    case 5:
      n1000 = 30000;
      break;
    case 6:
      n1000 = 60000;
      break;
    case 7:
      n1000 = 300000;
      break;
    case 8:
      n1000 = 900000;
      break;
    case 9:
      n1000 = 1800000;
      break;
    default:
      n1000 = 0;
      break;
  }
  return n1000;
}

// --- End Function: sub_140300AB0 (0x140300AB0) ---

// --- Function: sub_140300BC0 (0x140300BC0) ---
__int64 __fastcall sub_140300BC0(_WORD *a1, int a2, char n37)
{
  unsigned int n2_1; // r10d
  __int64 n2; // rax

  n2_1 = 0;
  switch ( n37 )
  {
    case 8:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 25180;
      n2 = 2;
      break;
    case 9:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29788;
      n2 = 2;
      break;
    case 10:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 28252;
      n2 = 2;
      break;
    case 12:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 26204;
      n2 = 2;
      break;
    case 13:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29276;
      n2 = 2;
      break;
    case 34:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 8796;
      n2 = 2;
      break;
    case 92:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 23644;
      n2 = 2;
      break;
    default:
      if ( a2 > 0 )
      {
        *(_BYTE *)a1 = n37;
        n2_1 = 1;
      }
LABEL_18:
      n2 = n2_1;
      break;
  }
  return n2;
}

// --- End Function: sub_140300BC0 (0x140300BC0) ---

// --- Function: sub_140300D10 (0x140300D10) ---
__int64 __fastcall sub_140300D10(_BYTE *a1, int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // r10
  int v8; // edx
  int v9; // ebp
  unsigned __int64 i; // rbx
  int v11; // r11d
  int v12; // r9d
  _WORD *v13; // r8
  __int64 v14; // rax
  unsigned int v15; // edx

  v4 = -1;
  do
    ++v4;
  while ( *(_BYTE *)(a3 + v4) );
  v8 = 0;
  v9 = 0;
  if ( a4 )
  {
    if ( a2 <= 0 )
    {
      v9 = 1;
    }
    else
    {
      *a1 = 34;
      v8 = 1;
    }
  }
  for ( i = 0; i < v4; ++i )
  {
    if ( v8 >= a2 )
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = a2 - v8;
      v13 = &a1[v8];
      switch ( *(_BYTE *)(i + a3) )
      {
        case 8:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 25180;
          v8 += 2;
          break;
        case 9:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 29788;
          v8 += 2;
          break;
        case 0xA:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 28252;
          v8 += 2;
          break;
        case 0xC:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 26204;
          v8 += 2;
          break;
        case 0xD:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 29276;
          v8 += 2;
          break;
        case 0x22:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 8796;
          v8 += 2;
          break;
        case 0x5C:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 23644;
          v8 += 2;
          break;
        default:
          if ( v12 > 0 )
          {
            *(_BYTE *)v13 = *(_BYTE *)(i + a3);
            v11 = 1;
          }
LABEL_26:
          v8 += v11;
          break;
      }
    }
  }
  if ( a4 )
  {
    if ( v8 < a2 )
    {
      v14 = v8;
      v15 = v8 + 1;
      if ( v9 )
        v15 = -1;
      a1[v14] = 34;
      return v15;
    }
    v9 = 1;
  }
  if ( v9 )
    return (unsigned int)-1;
  return (unsigned int)v8;
}

// --- End Function: sub_140300D10 (0x140300D10) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        char *a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = -1;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = -1;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 22;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 22;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 34;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 91;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = -1;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 31;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = -1;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 22;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 34;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 22;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 34;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 15392;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 22;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 34;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = -1;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 22;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 34;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = -1;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 22;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 34;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 8254;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 34;
  }
  else
  {
    *errno() = 22;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = -1;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 34;
  }
  else
  {
LABEL_108:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 32;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = -1;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 91;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 34;
            }
            else
            {
              *errno() = 22;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 22;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 34;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = -1;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 22;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 34;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 14;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 11822;
      Buffer_3[Size - 2] = 46;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        char *a7,
        char *a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 128;
  n0xF_5[0] = n4;
  v159 = a6;
  n0xF_17 = n0xF + 128;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 1886216564;
    *((_WORD *)Buffer + 6) = 14882;
    *((_BYTE *)Buffer + 14) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = -1;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 15 >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_25 = -1;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 15;
  Size_1 = n0xF_1 - 15;
  if ( Size )
  {
    if ( Buffer == (double *)-15LL )
    {
LABEL_11:
      *errno() = 22;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 15);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 34;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 15LL;
  if ( (int)Size + 24LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 22;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 34;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 34;
LABEL_28:
  v34 = (int)Size + 24LL;
  Size_3 = -1;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 22;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 34;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 13 >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 22;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 34;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 578315369;
  *((_BYTE *)v39 + 12) = 58;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 13, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 13;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_25 = v45 + 15;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 31;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              v162,
              v161,
              n4_1,
              v166,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (a18 & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 128;
      n0xF_26 = n0xF + 128;
      n0xF_18 = n0xF + 128;
      goto LABEL_95;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 128;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 128;
      n0xF_18 = n0xF + 128;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 128;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 128;
  n0xF_18 = n0xF + 128;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 22;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 34;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 34;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = -1;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_129:
      n0xF_3 = n0xF + 128;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      v58 = v159;
      goto LABEL_131;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 34;
      }
      else
      {
LABEL_111:
        *errno() = 22;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 128;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_130;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 11298;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 22;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 34;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 34;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_145:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 11LL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 22;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 34;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 14882;
      *((_BYTE *)v88 + 10) = 34;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 11;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 128;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 13LL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 22;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 34;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 975332711;
      *((_BYTE *)v94 + 12) = 34;
    }
    n0xF_2 += 13;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 128;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 34;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 11LL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 22;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 34;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 11;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 11;
    *((_WORD *)v97 + 4) = 14882;
    *((_BYTE *)v97 + 10) = 34;
  }
LABEL_209:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            v164,
            __Val_0___1,
            _Newcapacity,
            a11,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 22;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 34;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 34;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 80);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != -1;
              n0xF_16 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 22;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 34;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 11357;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 80);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != -1;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_248:
              v115 = n0xF + 128;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 22;
                goto LABEL_255;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 34;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 128;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 34;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = -1;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 22;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 34;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 128;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 22;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 34;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 14882;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != -1 )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 22;
                  goto LABEL_292;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 34;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 91;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 80);
          v102 = v114 != -1;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 80);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != -1;
          n0xF_16 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 22;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 34;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 44;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 44;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 34;
      }
      else
      {
        *errno() = 22;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 32))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 128;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 128;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 22;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 34;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 1819635234;
          v136[2] = 8812;
        }
      }
LABEL_315:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 22;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 34;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 93;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 13LL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 22;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 34;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 975329103;
        *((_BYTE *)v139 + 12) = 49;
      }
      n0xF_2 += 13;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 22;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 34;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 2685;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    v147 = v161;
    qword_149B3B210(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 39 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 39);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(_Newvec - 1) = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
char __fastcall sub_1403045C0(
        unsigned int n4_1,
        __int64 *a2,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  char result; // al
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned __int64 n0x10; // rax
  __int64 *v17; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v19; // r13
  char *v20; // r15
  __int64 v21; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v23; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  __int64 *v25; // rax
  __int64 *v26; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v28; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  __int64 v32; // r13
  __int64 (__fastcall *v33)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v34; // rax
  unsigned __int64 v35; // rcx
  __int64 *v36; // rdi
  _QWORD *v37; // r13
  bool v38; // zf
  _QWORD *v39; // rbx
  _QWORD *v40; // rax
  _BYTE *v41; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v44; // r9
  __int64 v45; // rcx
  __m256 *p_Src; // r14
  char *v47; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __int64 p_Src_2; // r15
  _QWORD *v51; // r14
  _QWORD *v52; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v57; // rax
  __int64 *v58; // rcx
  __int64 v59; // rcx
  _QWORD *v60; // rbx
  __int64 v61; // rcx
  __int64 *v62; // r14
  __int64 p_Src_3; // rax
  __int64 *v64; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v66; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v70; // rax
  char *v71; // r11
  unsigned __int64 _Newcapacity_1; // r10
  char *v73; // rdi
  int v74; // r13d
  __int64 v75; // rcx
  __int64 v76; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v78; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v83; // rax
  __int64 v84; // r15
  char *v85; // r14
  __int64 v86; // rax
  void *v87; // rsp
  __int64 (__fastcall *v88)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v89; // edx
  int v90; // r12d
  char v91; // cl
  int v92; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v96; // al
  bool v97; // dl
  bool v98; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v100; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v105; // rax
  void *v106; // rsp
  char v107; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v110; // rsi
  _QWORD **v111; // rcx
  _QWORD *v112; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v114; // rdi
  __int64 v115; // rcx
  __int64 *v116; // rbx
  __int64 v117; // rcx
  int v118; // [rsp+90h] [rbp-10h]
  unsigned __int8 v119; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  __int64 *v121; // [rsp+B0h] [rbp+10h]
  __int64 v122; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v124; // [rsp+C8h] [rbp+28h] BYREF
  int v125[2]; // [rsp+D0h] [rbp+30h]
  char *v126; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v130; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v132; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v134; // [rsp+118h] [rbp+78h]
  char *v135; // [rsp+120h] [rbp+80h]
  __int64 *v136; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v138; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v143; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v144; // [rsp+168h] [rbp+C8h] BYREF
  __int64 v145; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v148[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v149[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v134 = a4;
  v135 = a3;
  v136 = a2;
  n4 = n4_1;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v130 = v12;
  if ( v11 )
  {
    result = sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v144 = (__int64 *)&v143;
  n0x10 = 0;
  v143 = 0;
  v17 = 0;
  v121 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v19 = 0;
  v122 = 0;
  v20 = 0;
  n0x10_1 = 0;
  v21 = 0;
  v126 = 0;
  v124 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v73 = (char *)v149;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v23 = v119;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 89) && n0x10 < 0x10 )
    {
      v148[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v149[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v17 )
      {
        __asm { vzeroupper }
        v25 = (__int64 *)allocWithProfilerInfo_w(0x18u);
        v17 = v25;
        v121 = v25;
        if ( v25 )
        {
          v26 = v25;
          *v25 = 0;
          n0x400_1 = 0;
          v25[1] = 0;
          v28 = (__int64)v25;
          v25[2] = 0;
        }
        else
        {
          v17 = 0;
          v26 = 0;
          n0x400_1 = 0;
          v121 = 0;
          v28 = 0;
        }
        sub_1403044D0(v28, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v149;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v26[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v26[2] )
          {
            sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)v17, _Whereptr, __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v26[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v21 = v124;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v17[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v17[2] )
      {
        __asm { vzeroupper }
        sub_1402A6760(
          (std::vector<vraudio::AudioBuffer const *> *)v17,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        v17[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v122 = *((_QWORD *)__Val_0___1 + 13) + v19;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v144, __Val_0___1, v14, v15);
    v32 = v21;
    v33 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v145 = v21++;
    v124 = v21;
    if ( !v33 )
    {
      v71 = v126;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v132 = 0;
    v34 = v33(*(_QWORD *)__Val_0___1, &v132, &__Val_0___4);
    v35 = 0;
    *(_QWORD *)v125 = 0;
    if ( !v132 )
      goto LABEL_94;
    v36 = v144;
    v37 = (_QWORD *)(v34 + 16);
    v138 = (_QWORD *)(v34 + 16);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v37 - 2);
      __Val_0___5 = (vraudio::AudioBuffer *)(v37 - 2);
      v38 = *v37 == 0;
      v124 = v21 + 1;
      v37[8] = v21;
      if ( v38 )
      {
        v60 = (_QWORD *)*(v37 - 1);
        v62 = 0;
      }
      else
      {
        if ( !*v36 )
        {
          __asm { vzeroupper }
          v39 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v39 )
          {
            *v39 = 0;
            v39[1] = 0;
            v40 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v40 = v40;
            v40[1] = v40;
            *v39 = v40;
          }
          else
          {
            v39 = 0;
          }
          *v36 = (__int64)v39;
        }
        v41 = (_BYTE *)*(v37 - 1);
        Size = -1;
        memset(&Src, 0, sizeof(Src));
        Size_1 = -1;
        do
          ++Size_1;
        while ( v41[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v41, Size_1, v15);
        v44 = (_BYTE *)*v37;
        do
          ++Size;
        while ( v44[Size] );
        v45 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v23, v44, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v47 = (char *)p_Src + v45;
          memmove(v47, v44, Size);
          v47[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v36;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(_QWORD *)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v51 = *(_QWORD **)__Val_0___7;
        v52 = **(_QWORD ***)__Val_0___7;
        if ( v52 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v52[4];
          Buf1 = v52 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = (__m256 *)p_Src_2;
          if ( v52[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v52 = (_QWORD *)*v52;
        }
        while ( v52 != v51 );
        __Val_0___7 = __Val_0___6;
        if ( v52 == v51 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v57 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v57 + 32) = 0;
          *(_QWORD *)(v57 + 40) = 0;
          *(__m256 *)(v57 + 16) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v58 = (__int64 *)v51[1];
          *(_QWORD *)v57 = v51;
          *(_QWORD *)(v57 + 8) = v58;
          v51[1] = v57;
          *v58 = v57;
          v59 = *(_QWORD *)*v36;
          v60 = (_QWORD *)(*(_QWORD *)(v59 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v59 + 8) + 40LL) > 0xFu )
            v60 = (_QWORD *)*v60;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v61 = *(_QWORD *)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v61 = *(_QWORD *)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - v61 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v61);
          }
LABEL_66:
          v17 = v121;
          v62 = 0;
          v37 = v138;
          __Val_0___3 = __Val_0___5;
          v35 = *(_QWORD *)v125;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          goto LABEL_74;
        }
        v60 = v52 + 2;
        if ( v60[3] > 0xFu )
          v60 = (_QWORD *)*v60;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
          if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v17 = v121;
        v62 = 0;
        v37 = v138;
        __Val_0___3 = __Val_0___5;
        v35 = *(_QWORD *)v125;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 15;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v60;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v17 )
        {
          __asm { vzeroupper }
          v64 = (__int64 *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v121 = v64;
          v17 = v64;
          if ( v64 )
          {
            *v64 = 0;
            v66 = (__int64)v64;
            v64[1] = 0;
            v64[2] = 0;
            v62 = v64;
          }
          else
          {
            v17 = 0;
            v121 = 0;
            v66 = 0;
          }
          sub_1403044D0(v66, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v149;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v62[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v62[2] )
            {
              sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)v17, _Whereptr_2, __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v62[1] += 8;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v17[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v17[2] )
        {
          __asm { vzeroupper }
          sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)v17, _Whereptr_3, &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          v17[1] += 8;
        }
        v35 = *(_QWORD *)v125;
      }
      else
      {
        v149[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v35;
      v70 = v37[11] + v122;
      v37 += 14;
      v21 = v124;
      v122 = v70;
      *(_QWORD *)v125 = v35;
      v138 = v37;
    }
    while ( v35 < v132 );
    __Val_0___1 = __Val_0___2;
    v32 = v145;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v32 = -1;
    v71 = &v126[__Val_0___4];
    v126 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 112);
    v14 = v122;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 10) = v32;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v19 = v14;
      continue;
    }
    break;
  }
  v20 = v71;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  v126 = v71;
  if ( !v17 )
    goto LABEL_105;
  if ( !((v17[1] - *v17) >> 3) )
    __debugbreak();
  v73 = (char *)*v17;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v126 = v71;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v73, (unsigned __int64)&v73[8 * n0x400], (__int64)(8 * n0x400) >> 3, v119);
  v74 = 0;
  v75 = 0;
  v76 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v78 = *(_QWORD *)&v73[8 * n0x400_3];
    if ( v76 == *(_QWORD *)(v78 + 8) )
    {
      if ( ++v75 == 1 )
        *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3 - 8] + 80LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 80LL) = v75;
    }
    else
    {
      v75 = 0;
      *(_QWORD *)(v78 + 80) = -(__int64)(*(_QWORD *)(v78 + 80) != -1);
      v76 = *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v20 + 1) << 10;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v84 = 0;
  }
  else
  {
    v83 = allocWithProfilerInfo_w(n0x8000_2);
    v84 = v83;
    if ( v83 )
    {
      v85 = (char *)v83;
      goto LABEL_130;
    }
  }
  v86 = n0x8000_2 + 15;
  if ( n0x8000_2 + 15 < n0x8000_2 )
    v86 = 0xFFFFFFFFFFFFFF0LL;
  v87 = alloca(v86 & 0xFFFFFFFFFFFFFFF0uLL);
  v85 = (char *)&v119;
LABEL_130:
  v88 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v89 = 1;
  *v85 = 0;
  v90 = 0;
  LODWORD(v124) = 0;
  v125[0] = 1;
  if ( v88 && qword_149B3B200 && byte_149924748 )
  {
    v89 = v88(v130, n4, v135, v136, v134, __Val_0__, _Newcapacity, v148, n0x10_1, &a8);
    v125[0] = v89;
  }
  v91 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v92 = sub_140302340(
            *(_QWORD *)&FileTime,
            v130,
            (__int64)String,
            n4,
            v136,
            v135,
            v134,
            __Val_0__,
            _Newcapacity,
            a7,
            v85,
            n0x8000_2,
            (int *)&v124,
            v89,
            &a8);
    v91 = a8;
    v90 = v92;
    v74 = v124;
  }
  if ( n2_125 == 1 && (v91 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v85);
    v91 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v91 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v85);
    n2_126 = ::n2_126;
  }
  v85[v90] = 0;
  v96 = a8;
  v97 = (a8 & 1) != 0 && n2_125 == 2;
  v98 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v97 || v98 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v100 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v100 = v122 + v90 + ((_QWORD)(v126 + 4) << 9);
    n0x8000_3 = v100 + 128;
    if ( *p_n0x8000_1 < v100 + 128 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v105 = n0x8000_3 + 15;
    if ( n0x8000_3 + 15 < n0x8000_3 )
      v105 = 0xFFFFFFFFFFFFFF0LL;
    v106 = alloca(v105 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v119;
LABEL_166:
    v118 = v125[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v130,
      Buffer,
      String,
      n4,
      v136,
      v135,
      v134,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v73,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 128,
      (__int64)&v85[v74],
      v90 - v74,
      a8,
      v118);
    sub_1402A3D30(Buffer_3);
    v96 = a8;
  }
  v107 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v96 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v96 = a8;
      v107 = byte_149B3AEA8;
    }
    if ( v107 )
    {
      if ( (v96 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A3D30(v84);
  v110 = v143;
  if ( v143 )
  {
    v111 = (_QWORD **)*v143;
    **(_QWORD **)(*v143 + 8) = 0;
    v112 = *v111;
    if ( *v111 )
    {
      do
      {
        n0xF_1 = v112[5];
        v114 = (_QWORD *)*v112;
        if ( n0xF_1 > 0xF )
        {
          v115 = v112[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v115 - *(_QWORD *)(v115 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v115 = *(_QWORD *)(v115 - 8);
          }
          sub_1402A3D30(v115);
        }
        v112[4] = 0;
        v112[5] = 15;
        *((_BYTE *)v112 + 16) = 0;
        sub_1402A3D30((__int64)v112);
        v112 = v114;
      }
      while ( v114 );
    }
    sub_1402A3D30(*v110);
    result = sub_1402A3D30((__int64)v110);
  }
  v116 = v121;
  if ( v121 )
  {
    v117 = *v121;
    if ( *v121 )
    {
      if ( ((v121[2] - v117) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v117 - *(_QWORD *)(v117 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v117 = *(_QWORD *)(v117 - 8);
      }
      sub_1402A3D30(v117);
      *v116 = 0;
      v116[1] = 0;
      v116[2] = 0;
    }
    return sub_1402A3D30((__int64)v116);
  }
  return result;
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: sub_140305400 (0x140305400) ---
__int64 __fastcall sub_140305400(
        __int64 a1,
        __int64 a2,
        int a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        __int64 (__fastcall *a9)(__int64, __int64, __int64, __int64, __int64, _BYTE *))
{
  __int64 v9; // rbp
  int v11; // ecx
  int v12; // esi
  char n37; // r8
  __int64 v14; // r15
  char *v15; // rbx
  __int64 v17; // rcx
  char n36; // cl
  __int64 v19; // rdi
  _BYTE *v20; // r11
  unsigned __int64 n0x39; // rcx
  char *v22; // r10
  int n31_2; // r8d
  __int64 n31; // rdx
  __int64 v25; // r9
  int n31_1; // eax
  __int64 n31_3; // rcx
  int v28; // eax
  int v29; // edi
  _BYTE *v30; // rbp
  int n31_5; // r9d
  __int64 n31_6; // r8
  char *v33; // r11
  __int64 v34; // r10
  unsigned __int64 n0x39_1; // rdx
  int n31_4; // eax
  int v37; // eax
  int v38; // eax
  __int64 v39; // rax
  _BYTE *v41; // [rsp+28h] [rbp-90h]
  char String[4]; // [rsp+30h] [rbp-88h] BYREF
  int v43; // [rsp+34h] [rbp-84h]
  __int64 (__fastcall *v44)(__int64, __int64, __int64, __int64, __int64, _BYTE *); // [rsp+38h] [rbp-80h]
  __int64 v45; // [rsp+40h] [rbp-78h]
  _BYTE v46[32]; // [rsp+48h] [rbp-70h] BYREF

  v9 = a5;
  v11 = a3;
  v12 = a3;
  v45 = a5;
  n37 = *a4;
  v14 = 0;
  v44 = a9;
  v15 = a4;
  v43 = v11;
  if ( n37 )
  {
    do
    {
      v17 = 0x3FF6C0900000000LL;
      if ( n37 == 36 )
      {
        n36 = *++v15;
        v19 = 0;
        if ( n36 == 36 )
        {
LABEL_6:
          v19 = v14++;
        }
        else
        {
          while ( (unsigned __int8)(n36 - 48) <= 9u )
          {
            String[0] = n36;
            ++v15;
            v19 = atoi(String) + 10 * v19;
            n36 = *v15;
            if ( *v15 == 36 )
              goto LABEL_6;
          }
          --v15;
        }
        v20 = 0;
        if ( v15[1] == 123 )
        {
          n0x39 = (unsigned __int8)v15[2];
          v22 = v15;
          v15 += 2;
          n31_2 = 0;
          n31 = 0;
          if ( (_BYTE)n0x39 != 125 )
          {
            do
            {
              if ( n31 >= 31 || (unsigned __int8)n0x39 > 0x39u || (v25 = 0x3FF6C0900000000LL, !_bittest64(&v25, n0x39)) )
              {
                v15 = v22;
                goto LABEL_20;
              }
              ++v15;
              v46[n31] = n0x39;
              ++n31_2;
              ++n31;
              n0x39 = (unsigned __int8)*v15;
            }
            while ( (_BYTE)n0x39 != 125 );
            if ( n31_2 > 0 )
            {
              n31_1 = 31;
              if ( n31_2 < 31 )
                n31_1 = n31_2;
              n31_3 = n31_1;
              if ( (unsigned __int64)n31_1 >= 0x20 )
LABEL_55:
                _report_rangecheckfailure(n31_3);
              v46[n31_1] = 0;
              v20 = v46;
            }
          }
        }
LABEL_20:
        if ( v12 < (int)a2 )
        {
          v28 = v44(v12 + a1, a2 - v12, v9, v19 + a7, a6, v20);
          if ( v28 >= 0 )
            v12 += v28;
        }
        v29 = a2;
      }
      else if ( n37 == 37 )
      {
        v30 = 0;
        n31_5 = 0;
        n31_6 = 0;
        v33 = v15;
        v34 = 0;
        while ( 2 )
        {
          n0x39_1 = *++v15;
          switch ( (int)n0x39_1 )
          {
            case 0:
              v15 = v33 + 1;
              goto LABEL_39;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64:
            case 66:
            case 68:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 84:
            case 85:
            case 86:
            case 87:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            case 96:
            case 98:
            case 104:
            case 106:
            case 107:
            case 108:
            case 109:
            case 113:
            case 114:
            case 116:
            case 118:
            case 119:
              v17 = 0x3FF6C0900000000LL;
              goto LABEL_28;
            case 37:
            case 65:
            case 67:
            case 69:
            case 70:
            case 71:
            case 83:
            case 88:
            case 90:
            case 97:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 105:
            case 110:
            case 111:
            case 112:
            case 115:
            case 117:
            case 120:
              if ( n31_5 <= 0 )
                goto LABEL_37;
              n31_4 = 31;
              if ( n31_5 < 31 )
                n31_4 = n31_5;
              n31_3 = n31_4;
              if ( (unsigned __int64)n31_4 >= 0x20 )
                goto LABEL_55;
              v46[n31_4] = 0;
              v30 = v46;
LABEL_37:
              v34 = v14++;
LABEL_39:
              v29 = a2;
              if ( v12 >= (int)a2 )
              {
                v9 = v45;
              }
              else
              {
                v41 = v30;
                v9 = v45;
                v37 = v44(v12 + a1, a2 - v12, v45, v34 + a7, a6, v41);
                if ( v37 >= 0 )
                  v12 += v37;
              }
              break;
            default:
LABEL_28:
              if ( n31_6 < 31 && (unsigned __int8)n0x39_1 <= 0x39u && _bittest64(&v17, n0x39_1) )
              {
                ++n31_5;
                v46[n31_6++] = n0x39_1;
              }
              continue;
          }
          break;
        }
      }
      else
      {
        v29 = a2;
        if ( a8 )
        {
          if ( v12 < (int)a2 )
          {
            v38 = sub_140300BC0((_WORD *)(v12 + a1), (int)a2 - v12, n37);
            if ( v38 >= 0 )
              v12 += v38;
          }
        }
        else if ( v12 < (int)a2 )
        {
          v39 = v12++;
          *(_BYTE *)(v39 + a1) = n37;
        }
      }
      n37 = *++v15;
    }
    while ( n37 );
    v11 = v43;
  }
  else
  {
    v29 = a2;
  }
  if ( v12 < v29 )
    *(_BYTE *)(v12 + a1) = 0;
  return (unsigned int)(v12 - v11);
}

// --- End Function: sub_140305400 (0x140305400) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 24576 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: j_cosf (0x140332E10) ---
// attributes: thunk
float __cdecl j_cosf(float X)
{
  return cosf(X);
}

// --- End Function: j_cosf (0x140332E10) ---

// --- Function: j_sinf (0x140333560) ---
// attributes: thunk
float __cdecl j_sinf(float X)
{
  return sinf(X);
}

// --- End Function: j_sinf (0x140333560) ---

// --- Function: sub_1403335B0 (0x1403335B0) ---
__int64 __fastcall sub_1403335B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_1403335B0 (0x1403335B0) ---

// --- Function: sub_140344450 (0x140344450) ---
char *__fastcall sub_140344450(__int64 a1, _QWORD *a2)
{
  _BYTE *v3; // rdx
  char *result; // rax

  v3 = *(_BYTE **)(a1 + 8);
  if ( v3 == *(_BYTE **)(a1 + 0x10) )
    return sub_1402A6B30(a1, v3, a2);
  *(_QWORD *)v3 = *a2;
  result = *(char **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = result + 8;
  return result;
}

// --- End Function: sub_140344450 (0x140344450) ---

// --- Function: sub_14035AA80 (0x14035AA80) ---
__int64 __fastcall sub_14035AA80(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 45;
    v6 = 1;
    a4 = -a4 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = -1;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
      return 0xFFFFFFFFLL;
    ++v6;
    v10 = a4 % 10;
    a4 /= 10;
    *(_BYTE *)(v8 + v4) = v10 + 48;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_14035AA80 (0x14035AA80) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_14035C4A0 (0x14035C4A0) ---
_DWORD *__fastcall sub_14035C4A0(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

// --- End Function: sub_14035C4A0 (0x14035C4A0) ---

// --- Function: sub_1403706F0 (0x1403706F0) ---
_DWORD *__fastcall sub_1403706F0(_DWORD *a1)
{
  _DWORD *result; // rax

  *a1 = 0xF;
  result = a1;
  a1[1] = 0x80000000;
  a1[2] = 0x80000000;
  a1[3] = 0x80000000;
  return result;
}

// --- End Function: sub_1403706F0 (0x1403706F0) ---

// --- Function: sub_140370740 (0x140370740) ---
__int64 __fastcall sub_140370740(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 0xE0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)a1 = 6;
  *(_QWORD *)(a1 + 0x38) = 0x8000000000000000uLL;
  result = a1;
  *(_DWORD *)(a1 + 0x10) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x28) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x34) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 4) = 0x80000000;
  *(_DWORD *)(a1 + 8) = 0x80000000;
  *(_DWORD *)(a1 + 0x60) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x64) = 0xFFBFFFFF;
  *(_QWORD *)(a1 + 0x70) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x78) = 0x80000000;
  *(_QWORD *)(a1 + 0x80) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x90) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x68) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x6C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x88) = 0x80000000;
  *(_DWORD *)(a1 + 0x9C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xA4) = 0x80000000;
  *(_QWORD *)(a1 + 0xA8) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0xB0) = 0x80000000;
  *(_DWORD *)(a1 + 0xB4) = 0x80000000;
  *(_DWORD *)(a1 + 0xB8) = 0x80000000;
  *(_DWORD *)(a1 + 0xBC) = 0x80000000;
  *(_DWORD *)(a1 + 0xD0) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xD4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xD8) = 0xFFBFFFFF;
  *(_QWORD *)(a1 + 0xF0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x2C) = 0x80000000;
  *(_DWORD *)(a1 + 0xF8) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xE8) = 0x80000000;
  *(_OWORD *)(a1 + 0xC0) = xmmword_1481AD6E0;
  *(_DWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0xC) = 1;
  *(_DWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x58) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x48) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_DWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = 0;
  return result;
}

// --- End Function: sub_140370740 (0x140370740) ---

// --- Function: sub_1403708B0 (0x1403708B0) ---
_DWORD *__fastcall sub_1403708B0(_DWORD *a1)
{
  _DWORD *result; // rax

  *a1 = 0xA;
  result = a1;
  a1[2] = 0xFFBFFFFF;
  a1[6] = 0xFFBFFFFF;
  a1[3] = 0xFFBFFFFF;
  a1[4] = 0xFFBFFFFF;
  a1[5] = 0xFFBFFFFF;
  a1[1] = 0x80000000;
  a1[9] = 0xFFBFFFFF;
  a1[0xA] = 0xFFBFFFFF;
  a1[0xB] = 0xFFBFFFFF;
  a1[0xF] = 0xFFBFFFFF;
  a1[0x10] = 0xFFBFFFFF;
  a1[0x11] = 0x80000000;
  a1[0x12] = 0x80000000;
  a1[0x13] = 0x80000000;
  a1[0xE] = 0xFFBFFFFF;
  a1[0x14] = 0x80000000;
  a1[0x15] = 0xFFBFFFFF;
  a1[0x16] = 0x80000000;
  a1[0x17] = 0x80000000;
  a1[0x18] = 0x80000000;
  a1[0x19] = 0x80000000;
  a1[0x1A] = 0x80000000;
  a1[0x1B] = 0x80000000;
  return result;
}

// --- End Function: sub_1403708B0 (0x1403708B0) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140377F00 (0x140377F00) ---
char **__fastcall sub_140377F00(char **a1, char **a2)
{
  char *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E9810(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377F00 (0x140377F00) ---

// --- Function: copyStringStructure (0x140377F40) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
char **__fastcall copyStringStructure(char **a1, char **a2)
{
  unsigned __int64 Size; // rdi

  Size = *((int *)*a2 + 0xFFFFFFFE);
  sub_1403E9810(a1, Size, 0x20);
  if ( Size && *a1 != *a2 )
    memcpy(*a1, *a2, Size);
  return a1;
}

// --- End Function: copyStringStructure (0x140377F40) ---

// --- Function: assignCStringToStringStructure (0x140377FA0) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **a1, _BYTE *a2)
{
  __int64 Size; // rax

  if ( a2 )
  {
    Size = -1;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DE230(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DE230(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x140377FA0) ---

// --- Function: sub_14037F610 (0x14037F610) ---
bool __fastcall sub_14037F610(__int64 a1, __int64 a2)
{
  return a1 != a2;
}

// --- End Function: sub_14037F610 (0x14037F610) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1 & 0xFFFFFFFFFFFFLL, 0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: sub_14037FC70 (0x14037FC70) ---
const ULONG_PTR *__fastcall sub_14037FC70(__int64 a1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)a1 )
    return *(const ULONG_PTR **)a1;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14037FC70 (0x14037FC70) ---

// --- Function: HIWORD_w (0x14037FC90) ---
bool __fastcall HIWORD_w(_QWORD *a1)
{
  return *a1 && *(_QWORD *)((*a1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*a1);
}

// --- End Function: HIWORD_w (0x14037FC90) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403A9130 (0x1403A9130) ---
char **sub_1403A9130(char **a1, const char *Format_1, ...)
{
  _QWORD *v4; // rdi
  int BufferCount_2; // eax
  int BufferCount_1; // ecx
  size_t BufferCount; // rbx
  va_list va; // [rsp+70h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = sub_1402A4380();
  BufferCount_2 = _stdio_common_vsprintf(*v4 | 2LL, 0, 0, Format_1, 0, va);
  if ( BufferCount_2 < 0 )
    BufferCount_2 = -1;
  BufferCount_1 = 0;
  if ( BufferCount_2 >= 0 )
    BufferCount_1 = BufferCount_2;
  BufferCount = BufferCount_1;
  sub_1403E9810(a1, BufferCount_1, 32);
  _stdio_common_vsprintf(*v4 | 1LL, *a1, BufferCount, Format_1, 0, va);
  return a1;
}

// --- End Function: sub_1403A9130 (0x1403A9130) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B0A70 (0x1403B0A70) ---
_QWORD *__fastcall sub_1403B0A70(unsigned __int64 *a1, _QWORD *a2)
{
  if ( sub_14030EC00(a1) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B0A70 (0x1403B0A70) ---

// --- Function: sub_1403B27D0 (0x1403B27D0) ---
_QWORD *__fastcall sub_1403B27D0(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x88);
  return a2;
}

// --- End Function: sub_1403B27D0 (0x1403B27D0) ---

// --- Function: sub_1403B3E50 (0x1403B3E50) ---
const char *sub_1403B3E50()
{
  return "Text";
}

// --- End Function: sub_1403B3E50 (0x1403B3E50) ---

// --- Function: sub_1403B3E60 (0x1403B3E60) ---
const char *sub_1403B3E60()
{
  return "TraceContext";
}

// --- End Function: sub_1403B3E60 (0x1403B3E60) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: get_event_key_from_source_location (0x1403BB9D0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149B3D530;
  if ( !qword_149B3D530 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149B3D530 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BB9D0) ---

// --- Function: sub_1403BFA30 (0x1403BFA30) ---
bool __fastcall sub_1403BFA30(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BFA30 (0x1403BFA30) ---

// --- Function: sub_1403BFC90 (0x1403BFC90) ---
bool __fastcall sub_1403BFC90(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  return v1 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x20LL))(v1);
}

// --- End Function: sub_1403BFC90 (0x1403BFC90) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149B4FCF8;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403C3BF0 (0x1403C3BF0) ---
void __fastcall sub_1403C3BF0(__int64 a1)
{
  unsigned __int8 (__fastcall ***v2)(_QWORD, _QWORD); // rcx

  if ( (*(_BYTE *)(a1 + 0x1A) & 1) == 0 )
  {
    v2 = (unsigned __int8 (__fastcall ***)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 0x10) & 0xFFFFFFFFFFFFLL);
    if ( !v2 || (**v2)(v2, *(_WORD *)(a1 + 0x18) & 0x3FFF) )
    {
      *(_BYTE *)(a1 + 0x1A) &= ~1u;
      *(_BYTE *)(a1 + 0x1A) |= 1u;
    }
    else
    {
      *(_BYTE *)(a1 + 0x1A) &= ~1u;
      *(_BYTE *)(a1 + 0x1A) = *(_BYTE *)(a1 + 0x1A);
    }
  }
}

// --- End Function: sub_1403C3BF0 (0x1403C3BF0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 192LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403D8950 (0x1403D8950) ---
void **__fastcall sub_1403D8950(__int64 *a1, void **a2, const char *Control, int *a4)
{
  __int64 v6; // rcx
  const char *v10; // rdi
  unsigned __int64 v11; // rsi
  int v12; // r12d
  const char *v13; // rcx
  int Size; // eax
  int v15; // edx

  v6 = *a4;
  if ( (int)v6 >= 0 )
  {
    if ( Control )
    {
      v10 = (const char *)(*a1 + v6);
      v11 = *a1 + *(int *)(*a1 - 8);
      if ( (unsigned __int64)v10 >= v11 || (v12 = strspn(v10, Control), v13 = &v10[v12], (unsigned __int64)v13 >= v11) )
      {
        *a4 = 0xFFFFFFFF;
        *a2 = (char *)&qword_149B3B33C + 4;
      }
      else
      {
        Size = strcspn(v13, Control);
        v15 = v12 + *a4;
        *a4 = v15 + Size + 1;
        sub_1403EAE30(a1, a2, v15, Size);
      }
      return a2;
    }
    else
    {
      sub_14035B160(a2, (const void **)a1);
      return a2;
    }
  }
  else
  {
    *a2 = (char *)&qword_149B3B33C + 4;
    return a2;
  }
}

// --- End Function: sub_1403D8950 (0x1403D8950) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 16) & (unsigned int)(v9 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 = (v5 << 16) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 284) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 216LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
    return sub_1403DCDF0(a1, a2, a3, a4, a5);
  else
    return sub_1403DD0B0(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: sub_1403DCDF0 (0x1403DCDF0) ---
__int64 __fastcall sub_1403DCDF0(__int64 a1, unsigned __int64 a2, __int64 a3, const char *a4, const char *a5)
{
  __int64 v5; // r15
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r14d
  const char *v12; // r13
  bool v13; // zf
  signed __int64 v14; // rax
  __int64 result; // rax
  unsigned __int64 v16; // rdx
  signed __int64 v17; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int64 v19; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-91h] BYREF
  __int64 v22; // [rsp+34h] [rbp-8Dh]
  int n2; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 v24; // [rsp+40h] [rbp-81h]
  unsigned __int64 v25; // [rsp+48h] [rbp-79h]
  __int64 v26; // [rsp+50h] [rbp-71h]
  __int64 v27; // [rsp+58h] [rbp-69h]
  int n0x1600_1; // [rsp+80h] [rbp-41h] BYREF
  __int64 v29; // [rsp+84h] [rbp-3Dh]
  int n2_1; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 v31; // [rsp+90h] [rbp-31h]
  unsigned __int64 v32; // [rsp+98h] [rbp-29h]
  __int64 v33; // [rsp+A0h] [rbp-21h]
  __int64 v34; // [rsp+A8h] [rbp-19h]
  _BYTE v35[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char v36; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 v37; // [rsp+130h] [rbp+6Fh]

  v37 = a3;
  v5 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v5 + 0xF8LL))(v5, v35, &v36);
  v12 = a5;
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v16 = (unsigned __int64)v11 << 0x30;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v10 + 0x124) = HIWORD(a2);
        v17 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v16 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v13 = a2 == v17;
        a2 = v17;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v22 = 1;
          n2 = 2;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v24 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E394,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(n0x1600) = word_149B3E394;
          qword_149B4B8B0("Lock: %s", v12);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v25 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
        v19 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v16, a2);
        v13 = a2 == v19;
        a2 = v19;
        if ( v13 )
        {
          n0x1600_1 = 0x1600;
          v29 = 1;
          n2_1 = 2;
          v32 = 0;
          v33 = 0;
          v34 = 0;
          v31 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E398,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600_1) = word_149B3E398;
          qword_149B4B8B0("Lock: %s", v12);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v32 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | 0x200000, a2);
    v13 = a2 == v14;
    a2 = v14;
  }
  while ( !v13 );
  result = v37;
  *(_QWORD *)(a1 + 8) = v37;
  return result;
}

// --- End Function: sub_1403DCDF0 (0x1403DCDF0) ---

// --- Function: sub_1403DD0B0 (0x1403DD0B0) ---
signed __int64 __fastcall sub_1403DD0B0(__int64 a1, signed __int64 a2, __int64 a3, const char *a4, const char *a5)
{
  char v5; // r14
  signed __int64 v9; // rcx
  bool v10; // zf
  signed __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int v13; // esi
  signed __int64 v14; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int v16; // [rsp+38h] [rbp-81h] BYREF
  _DWORD v17[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int n0x1600; // [rsp+48h] [rbp-71h] BYREF
  __int64 v19; // [rsp+4Ch] [rbp-6Dh]
  int n2; // [rsp+54h] [rbp-65h]
  unsigned __int64 v21; // [rsp+58h] [rbp-61h]
  unsigned __int64 v22; // [rsp+60h] [rbp-59h]
  __int64 v23; // [rsp+68h] [rbp-51h]
  __int64 v24; // [rsp+70h] [rbp-49h]
  int n0x1600_1; // [rsp+98h] [rbp-21h] BYREF
  __int64 v26; // [rsp+9Ch] [rbp-1Dh]
  int n2_1; // [rsp+A4h] [rbp-15h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-11h]
  unsigned __int64 v29; // [rsp+B0h] [rbp-9h]
  __int64 v30; // [rsp+B8h] [rbp-1h]
  __int64 v31; // [rsp+C0h] [rbp+7h]

  v5 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 0x128LL))(qword_149B4FCF8, a1);
      if ( (a2 & 0x2003FF) == 0 )
        break;
      if ( v5 )
      {
        n0x1600 = 0x1600;
        v19 = 1;
        n2 = 2;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v21 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E38C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(n0x1600) = word_149B3E38C;
        qword_149B4B8B0("Lock: %s", a5);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a4);
        v16 = a2;
        qword_149B3B480(a1, &v16, 4, 0xFFFFFFFFLL);
        a2 = *(_QWORD *)a1;
        v22 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v13 = a2 + 0x400000;
        v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 + 0x400000, a2);
        v10 = a2 == v14;
        a2 = v14;
        if ( v10 )
        {
          v5 = 1;
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E390,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600_1) = word_149B3E390;
          qword_149B4B8B0("Lock: %s", a5);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a4);
          v17[0] = v13;
          qword_149B3B480(a1, v17, 4, 0xFFFFFFFFLL);
          a2 = *(_QWORD *)a1;
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v9 = (a2 | 0x200000) - 0x400000;
    if ( !v5 )
      v9 = a2 | 0x200000;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v9, a2);
    v10 = a2 == result;
    a2 = result;
  }
  while ( !v10 );
  *(_QWORD *)(a1 + 8) = a3;
  return result;
}

// --- End Function: sub_1403DD0B0 (0x1403DD0B0) ---

// --- Function: sub_1403DD380 (0x1403DD380) ---
const ULONG_PTR *__fastcall sub_1403DD380(__int64 a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // r8
  int v9; // ecx
  __int64 v10; // r8
  unsigned __int64 v11; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v14 - 1)) << 9) + v16 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    v6 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
      qword_149B3B490(a1);
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v7 = qword_149B4FCF8;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v15,
        &v13);
      v8 = v15 + ((WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1)) << 9);
      LODWORD(a2) = *(_DWORD *)(v8 + 0x124);
      *(_DWORD *)(v8 + 0x11C) = (unsigned __int16)(WORD2(a2) + v13);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0xD8LL))(v7);
      while ( (_DWORD)a2 != 0xFFFFFFFF )
      {
        v9 = (unsigned __int16)(a2 + v13);
        v10 = v15 + ((unsigned __int64)((unsigned int)a2 & (v13 - 1)) << 9);
        LODWORD(a2) = *(_DWORD *)(v10 + 0x124);
        *(_DWORD *)(v10 + 0x11C) = v9;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0xD8LL))(v7);
      }
    }
  }
  else if ( (a2 & 0xFFC00000) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
      qword_149B4FCF8,
      &v15,
      &v13);
    v11 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v11 & (v13 - 1)) << 9) + v15 + 0x11C) = (unsigned __int16)(v11 + v13);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FCF8 + 0xD8LL))(qword_149B4FCF8, (unsigned int)v11);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DD380 (0x1403DD380) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403DE230 (0x1403DE230) ---
void *__fastcall sub_1403DE230(void **a1, void *a2, size_t Size)
{
  _BYTE *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = *a1;
  if ( Size > *((int *)v5 - 1) )
  {
    v7 = (int *)(v5 - 8);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = (char *)&qword_149B3B33C + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, Size);
  *((_DWORD *)*a1 - 2) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403DE230 (0x1403DE230) ---

// --- Function: sub_1403E2C90 (0x1403E2C90) ---
__int64 __fastcall sub_1403E2C90(unsigned __int8 *a1)
{
  __int64 v1; // r8

  v1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v1;
  while ( a1[v1] );
  return (unsigned int)~psub_1403361A0(0xFFFFFFFF, a1, v1);
}

// --- End Function: sub_1403E2C90 (0x1403E2C90) ---

// --- Function: sub_1403E42C0 (0x1403E42C0) ---
__int64 __fastcall sub_1403E42C0(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( *a1 != a1[1] )
    a1[1] = result;
  return result;
}

// --- End Function: sub_1403E42C0 (0x1403E42C0) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 sub_1403E4B50()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4B60 (0x1403E4B60) ---
_OWORD *__fastcall sub_1403E4B60(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)allocWithProfilerInfo_w(0x10u);
  if ( result )
    *result = *a1;
  return result;
}

// --- End Function: sub_1403E4B60 (0x1403E4B60) ---

// --- Function: sub_1403E4B90 (0x1403E4B90) ---
_QWORD *__fastcall sub_1403E4B90(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A3D30(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)allocWithProfilerInfo_w(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E4B90 (0x1403E4B90) ---

// --- Function: sub_1403E4C70 (0x1403E4C70) ---
__int64 __fastcall sub_1403E4C70(__int64 a1)
{
  __int64 result; // rax

  result = allocWithProfilerInfo_w(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 16) = *(double *)(a1 + 16);
  }
  return result;
}

// --- End Function: sub_1403E4C70 (0x1403E4C70) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
__int64 __fastcall sub_1403E4E60(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4E70 (0x1403E4E70) ---
void __fastcall sub_1403E4E70(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E70 (0x1403E4E70) ---

// --- Function: sub_1403E4E80 (0x1403E4E80) ---
__int64 __fastcall sub_1403E4E80(const void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_1402A3D30(a1[2]);
    return sub_1402A3D30(a1);
  }
  return result;
}

// --- End Function: sub_1403E4E80 (0x1403E4E80) ---

// --- Function: sub_1403E4EB0 (0x1403E4EB0) ---
__int64 __fastcall sub_1403E4EB0(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4EB0 (0x1403E4EB0) ---

// --- Function: sub_1403E5570 (0x1403E5570) ---
bool __fastcall sub_1403E5570(_QWORD *a1)
{
  return !*a1 || !*(_BYTE *)*a1;
}

// --- End Function: sub_1403E5570 (0x1403E5570) ---

// --- Function: sub_1403E6750 (0x1403E6750) ---
unsigned __int64 __fastcall sub_1403E6750(unsigned __int64 *a1)
{
  if ( sub_14030EC00(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6750 (0x1403E6750) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---

// --- Function: sub_1403E7650 (0x1403E7650) ---
bool __fastcall sub_1403E7650(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E7650 (0x1403E7650) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 - 1) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 - 2)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 - 2));
  memset(&(*a1)[*((int *)v3 - 2)], Val_1, Size);
  if ( *((int *)v3 - 1) > 0 )
    sub_147605980(v3 - 8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1403EABD0 (0x1403EABD0) ---
__int64 __fastcall sub_1403EABD0(_QWORD *a1)
{
  return (__int64)(a1[1] - *a1) >> 2;
}

// --- End Function: sub_1403EABD0 (0x1403EABD0) ---

// --- Function: sub_1403EAD10 (0x1403EAD10) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_1403EAD10(double a1)
{
  __int128 v2; // kr00_16

  v2 = *(_OWORD *)&a1;
  *(float *)&v2 = fsqrt(*(float *)&a1);
  return (__m128)v2;
}

// --- End Function: sub_1403EAD10 (0x1403EAD10) ---

// --- Function: sub_1403EAE30 (0x1403EAE30) ---
void **__fastcall sub_1403EAE30(__int64 *a1, void **a2, size_t a3, size_t Size_1)
{
  __int64 v6; // rdx
  size_t v7; // rcx
  size_t Size; // r8

  v6 = *a1;
  v7 = *(int *)(*a1 - 8);
  if ( a3 < v7 )
  {
    Size = v7 - a3;
    if ( Size_1 == 0xFFFFFFFFFFFFFFFFuLL )
      Size_1 = v7 - a3;
    if ( a3 + Size_1 <= v7 )
      Size = Size_1;
    sub_14035B360(a2, (void *)(a3 + v6), Size);
    return a2;
  }
  else
  {
    *a2 = (char *)&qword_149B3B33C + 4;
    return a2;
  }
}

// --- End Function: sub_1403EAE30 (0x1403EAE30) ---

// --- Function: sub_1403EAFB0 (0x1403EAFB0) ---
__int64 __fastcall sub_1403EAFB0(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 16) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 34;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      v6 = sub_14035AA80((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    *a2 = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FE6B0((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
    return 0xFFFFFFFFLL;
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
    return 0xFFFFFFFFLL;
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 34;
    }
    else
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403EAFB0 (0x1403EAFB0) ---

// --- Function: sub_1403EB0E0 (0x1403EB0E0) ---
__int64 __fastcall sub_1403EB0E0(__int64 a1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EB0E0 (0x1403EB0E0) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n12; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12 = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 = 12;
      if ( (int)n12_1 <= 12 )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n12 + a2), n12_1 - (unsigned int)n12);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v8;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 19;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v10;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 18;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12 += v14;
    if ( n12 < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n12 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return (unsigned int)-1;
  return (unsigned int)n12;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB550 (0x1403EB550) ---
__int64 __fastcall sub_1403EB550(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 16) )
    return sub_14035AA80(a2, a3, 0, v3);
  else
    return sub_1402FE6B0(a2, a3, 0, v3);
}

// --- End Function: sub_1403EB550 (0x1403EB550) ---

// --- Function: sub_1403EB580 (0x1403EB580) ---
__int64 __fastcall sub_1403EB580(__int64 a1, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB580 (0x1403EB580) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: _snprintf_s (0x1403ECF60) ---
int snprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = (unsigned __int64 *)sub_1402A4380();
  result = _stdio_common_vsnprintf_s(*v8, DstBuf, SizeInBytes, MaxCount, Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: _snprintf_s (0x1403ECF60) ---

// --- Function: sub_14041E9D0 (0x14041E9D0) ---
void __fastcall sub_14041E9D0(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
}

// --- End Function: sub_14041E9D0 (0x14041E9D0) ---

// --- Function: sub_1404501E0 (0x1404501E0) ---
__int64 __fastcall sub_1404501E0(__int64 a1, size_t a2, __int64 a3, const void **a4, const void **a5)
{
  _BYTE *v5; // rdi
  size_t Size; // rbx
  void *v10; // rcx
  size_t Size_1; // rsi
  size_t Size_2; // rdi
  __int64 v13; // rcx
  _BYTE *v14; // rsi
  size_t Size_3; // rbp
  void *v16; // rcx
  __int64 result; // rax

  v5 = *a4;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( v5[Size] );
  if ( Size + a3 >= a2 )
    return 0xFFFFFFFFLL;
  v10 = (void *)(a3 + a1);
  Size_1 = a2 - a3;
  if ( Size )
  {
    if ( !v10 )
    {
LABEL_6:
      *errno() = 0x16;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v5 && Size_1 >= Size )
    {
      memcpy(v10, *a4, Size);
    }
    else
    {
      memset(v10, 0, a2 - a3);
      if ( !v5 )
        goto LABEL_6;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) == 0LL )
  {
    Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
    v13 = a3 + (int)Size;
    v14 = *a5;
    do
      ++Size_2;
    while ( v14[Size_2] );
    if ( Size_2 + v13 < a2 )
    {
      Size_3 = a2 - v13;
      v16 = (void *)(a1 + v13);
      if ( !Size_2 )
        goto LABEL_28;
      if ( !v16 )
        goto LABEL_20;
      if ( v14 && Size_3 >= Size_2 )
      {
        memcpy(v16, *a5, Size_2);
        goto LABEL_28;
      }
      memset(v16, 0, Size_3);
      if ( v14 )
      {
        if ( Size_3 >= Size_2 )
          goto LABEL_28;
        *errno() = 0x22;
      }
      else
      {
LABEL_20:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
LABEL_28:
      result = (unsigned int)(Size + Size_2);
      if ( (Size_2 & 0x80000000) == 0LL )
        return result;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1404501E0 (0x1404501E0) ---

// --- Function: sub_1404A9260 (0x1404A9260) ---
__int64 __fastcall sub_1404A9260(_QWORD *a1, int a2, char a3, _BYTE *a4)
{
  __int64 v4; // rbx
  __int64 v9; // r8
  unsigned __int64 v10; // rdx
  __int64 *v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rdi
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 *v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rax
  __int64 v21; // rcx
  int n0x4400; // [rsp+30h] [rbp-68h] BYREF
  __int64 v24; // [rsp+34h] [rbp-64h]
  int v25; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v26; // [rsp+40h] [rbp-58h]
  unsigned __int64 v27; // [rsp+48h] [rbp-50h]
  __int64 v28; // [rsp+50h] [rbp-48h]
  __int64 v29; // [rsp+58h] [rbp-40h]

  v4 = 0;
  v24 = 0;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  n0x4400 = 0x4400;
  v26 = __rdtsc();
  qword_149B4B870(
    &n0x4400,
    &word_149B46BC0,
    "CTagDefinition::Find",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\ICryAction/ICryMannequinTagDefs.cpp",
    0x407);
  HIWORD(n0x4400) = word_149B46BC0;
  if ( a4 )
    *a4 = 0;
  v9 = a1[0x14];
  v10 = 0x100000001B3LL
      * (HIBYTE(a2)
       ^ (0x100000001B3LL
        * (BYTE2(a2)
         ^ (0x100000001B3LL * (BYTE1(a2) ^ (0x100000001B3LL * ((unsigned __int8)a2 ^ 0xCBF29CE484222325uLL)))))));
  v11 = (__int64 *)(a1[0x16] + 0x10 * (v10 & a1[0x19]));
  v12 = v11[1];
  if ( v12 == v9 )
  {
LABEL_8:
    v12 = 0;
    goto LABEL_9;
  }
  v13 = *v11;
  if ( a2 != *(_DWORD *)(v12 + 0x10) )
  {
    while ( v12 != v13 )
    {
      v12 = *(_QWORD *)(v12 + 8);
      if ( a2 == *(_DWORD *)(v12 + 0x10) )
        goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_9:
  if ( !v12 )
    v12 = a1[0x14];
  if ( v12 != v9 )
  {
    LODWORD(v14) = *(_DWORD *)(v12 + 0x14);
    goto LABEL_29;
  }
  v15 = v10 & a1[0x11];
  v16 = a1[0xC];
  v17 = (__int64 *)(a1[0xE] + 0x10 * v15);
  v18 = v17[1];
  if ( v18 != v16 )
  {
    v19 = *v17;
    if ( a2 == *(_DWORD *)(v18 + 0x10) )
    {
LABEL_17:
      v4 = v18;
    }
    else
    {
      while ( v18 != v19 )
      {
        v18 = *(_QWORD *)(v18 + 8);
        if ( a2 == *(_DWORD *)(v18 + 0x10) )
          goto LABEL_17;
      }
    }
  }
  if ( !v4 )
    v4 = a1[0xC];
  if ( v4 == v16 )
    goto LABEL_28;
  v14 = *(int *)(v4 + 0x14);
  v20 = a1[2];
  v21 = 0x38 * v14;
  if ( !*(_BYTE *)(0x38 * v14 + v20 + 0x36)
    || *(_WORD *)(v21 + v20 + 0x32) == 0xFFFF && *(_WORD *)(v21 + v20 + 0x30) == 0xFFFF )
  {
    goto LABEL_29;
  }
  if ( !a3 )
  {
LABEL_28:
    LODWORD(v14) = 0xFFFFFFFF;
    goto LABEL_29;
  }
  if ( a4 )
    *a4 = 1;
  LODWORD(v14) = *(_DWORD *)(v4 + 0x14);
LABEL_29:
  v27 = __rdtsc();
  qword_149B4B878(&n0x4400);
  return (unsigned int)v14;
}

// --- End Function: sub_1404A9260 (0x1404A9260) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1480BE950, v3);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: sub_1404BAD90 (0x1404BAD90) ---
__int64 sub_1404BAD90()
{
  unsigned int n0x3E8; // ecx
  __int64 result; // rax

  n0x3E8 = sub_14056CEF0();
  if ( n0x3E8 < 0x3E8 )
    return 0x3E8;
  result = 0xFFFFFFFDLL;
  if ( n0x3E8 < 0xFFFFFFFD )
    return n0x3E8;
  return result;
}

// --- End Function: sub_1404BAD90 (0x1404BAD90) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n15; // rax

  v0 = sub_1404B3EA0();
  v1 = v0;
  if ( !v0 )
    return &dword_149B45F40;
  n15 = *v0;
  if ( n15 > 0xF )
    n15 = 15;
  return (__int64 *)&v1[22 * n15 + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_1404F3FB0 (0x1404F3FB0) ---
__int64 __fastcall sub_1404F3FB0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[40] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[40] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[41] >> 4];
  a2[3] = _0123456789abcdef_[a1[41] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[42] >> 4];
  a2[5] = _0123456789abcdef_[a1[42] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[43] >> 4];
  a2[7] = _0123456789abcdef_[a1[43] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[44] >> 4];
  a2[9] = _0123456789abcdef_[a1[44] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[45] >> 4];
  a2[11] = _0123456789abcdef_[a1[45] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[46] >> 4];
  a2[13] = _0123456789abcdef_[a1[46] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[47] >> 4];
  a2[15] = _0123456789abcdef_[a1[47] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F3FB0 (0x1404F3FB0) ---

// --- Function: sub_1404F4100 (0x1404F4100) ---
__int64 __fastcall sub_1404F4100(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[16] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[16] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[17] >> 4];
  a2[3] = _0123456789abcdef_[a1[17] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[18] >> 4];
  a2[5] = _0123456789abcdef_[a1[18] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[19] >> 4];
  a2[7] = _0123456789abcdef_[a1[19] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[20] >> 4];
  a2[9] = _0123456789abcdef_[a1[20] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[21] >> 4];
  a2[11] = _0123456789abcdef_[a1[21] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[22] >> 4];
  a2[13] = _0123456789abcdef_[a1[22] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[23] >> 4];
  a2[15] = _0123456789abcdef_[a1[23] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[24] >> 4];
  a2[17] = _0123456789abcdef_[a1[24] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[25] >> 4];
  a2[19] = _0123456789abcdef_[a1[25] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[26] >> 4];
  a2[21] = _0123456789abcdef_[a1[26] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[27] >> 4];
  a2[23] = _0123456789abcdef_[a1[27] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[28] >> 4];
  a2[25] = _0123456789abcdef_[a1[28] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[29] >> 4];
  a2[27] = _0123456789abcdef_[a1[29] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[30] >> 4];
  a2[29] = _0123456789abcdef_[a1[30] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[31] >> 4];
  a2[31] = _0123456789abcdef_[a1[31] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4100 (0x1404F4100) ---

// --- Function: sub_1404F4350 (0x1404F4350) ---
__int64 __fastcall sub_1404F4350(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[32] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[32] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[33] >> 4];
  a2[3] = _0123456789abcdef_[a1[33] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[34] >> 4];
  a2[5] = _0123456789abcdef_[a1[34] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[35] >> 4];
  a2[7] = _0123456789abcdef_[a1[35] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[36] >> 4];
  a2[9] = _0123456789abcdef_[a1[36] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[37] >> 4];
  a2[11] = _0123456789abcdef_[a1[37] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[38] >> 4];
  a2[13] = _0123456789abcdef_[a1[38] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[39] >> 4];
  a2[15] = _0123456789abcdef_[a1[39] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F4350 (0x1404F4350) ---

// --- Function: sub_1404F4760 (0x1404F4760) ---
__int64 __fastcall sub_1404F4760(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[11] = _0123456789abcdef_[a1[5] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[13] = _0123456789abcdef_[a1[6] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[15] = _0123456789abcdef_[a1[7] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[17] = _0123456789abcdef_[a1[8] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[19] = _0123456789abcdef_[a1[9] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[10] >> 4];
  a2[21] = _0123456789abcdef_[a1[10] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[11] >> 4];
  a2[23] = _0123456789abcdef_[a1[11] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[12] >> 4];
  a2[25] = _0123456789abcdef_[a1[12] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[13] >> 4];
  a2[27] = _0123456789abcdef_[a1[13] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[14] >> 4];
  a2[29] = _0123456789abcdef_[a1[14] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[15] >> 4];
  a2[31] = _0123456789abcdef_[a1[15] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4760 (0x1404F4760) ---

// --- Function: sub_140501E10 (0x140501E10) ---
bool __fastcall sub_140501E10(__int64 a1, __int64 a2)
{
  return *(double *)(a2 + 8) == *(double *)(a1 + 8);
}

// --- End Function: sub_140501E10 (0x140501E10) ---

// --- Function: _snprintf_s_w (0x140504870) ---
int __fastcall sub_140504870(
        __int64 a1,
        char *DstBuf,
        size_t SizeInBytes,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  return snprintf_s(
           DstBuf,
           SizeInBytes,
           0xFFFFFFFFFFFFFFFFuLL,
           (const char *)&Format__0,
           *(_QWORD *)(a1 + 8),
           a6,
           a7,
           a8,
           a9);
}

// --- End Function: _snprintf_s_w (0x140504870) ---

// --- Function: sub_140504DA0 (0x140504DA0) ---
int __fastcall sub_140504DA0(__int64 a1, char *DstBuf, size_t SizeInBytes, __int64 a4, __int64 a5, const void *a6)
{
  __int128 v6; // xmm6
  __int64 v9; // xmm6_8
  int v10; // eax
  __int64 v11; // rcx
  unsigned __int64 n0x20; // rax
  const void *v14; // [rsp+38h] [rbp-60h] BYREF
  const char *p_f; // [rsp+40h] [rbp-58h] BYREF
  char Format_[32]; // [rsp+50h] [rbp-48h] BYREF
  __int128 v17; // [rsp+80h] [rbp-18h]

  v17 = v6;
  v9 = *(_QWORD *)(a1 + 8);
  v14 = a6;
  p_f = "f";
  if ( !a6 )
    return snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, (const char *)&Format__0, v9);
  Format_[0] = 0x25;
  v10 = sub_1404501E0((__int64)Format_, 0x1Fu, 1, &v14, (const void **)&p_f);
  if ( v10 < 0 )
    return snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, (const char *)&Format__0, v9);
  n0x20 = v10 + 1LL;
  if ( n0x20 >= 0x20 )
    _report_rangecheckfailure(v11);
  Format_[n0x20] = 0;
  return snprintf_s(DstBuf, SizeInBytes, 0xFFFFFFFFFFFFFFFFuLL, Format_, v9);
}

// --- End Function: sub_140504DA0 (0x140504DA0) ---

// --- Function: sub_140508E90 (0x140508E90) ---
float *__fastcall sub_140508E90(float *a1, float *a2, float *a3)
{
  float v3; // xmm0_4

  v3 = *a1;
  if ( *a1 < *a2 )
    a1 = a2;
  if ( v3 > *a3 )
    return a3;
  return a1;
}

// --- End Function: sub_140508E90 (0x140508E90) ---

// --- Function: sub_140522CF0 (0x140522CF0) ---
__int64 __fastcall sub_140522CF0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC00 + 0x228LL))(qword_149B4FC00, a1);
}

// --- End Function: sub_140522CF0 (0x140522CF0) ---

// --- Function: sub_140539D30 (0x140539D30) ---
__int64 (__fastcall *__fastcall sub_140539D30(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_14039B170(0, "__InitializeThreadInfoBlock__", 0);
  if ( result )
    return (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}

// --- End Function: sub_140539D30 (0x140539D30) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056CEF0 (0x14056CEF0) ---
__int64 sub_14056CEF0()
{
  return sub_14056D140((__int64)&unk_1499305A0);
}

// --- End Function: sub_14056CEF0 (0x14056CEF0) ---

// --- Function: sub_1405975C0 (0x1405975C0) ---
_QWORD *__fastcall sub_1405975C0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_1405975C0 (0x1405975C0) ---

// --- Function: sub_140597650 (0x140597650) ---
bool __fastcall sub_140597650(_QWORD *a1, _QWORD *a2)
{
  return *a1 > *a2;
}

// --- End Function: sub_140597650 (0x140597650) ---

// --- Function: sub_140597760 (0x140597760) ---
__m128 sub_140597760()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_140597760 (0x140597760) ---

// --- Function: sub_1405A5A20 (0x1405A5A20) ---
bool __fastcall sub_1405A5A20(_DWORD *a1)
{
  return (*a1 & 0xFFA00000) == 0xFFA00000;
}

// --- End Function: sub_1405A5A20 (0x1405A5A20) ---

// --- Function: sub_1405A8C00 (0x1405A8C00) ---
__int64 __fastcall sub_1405A8C00(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(double *)a1 = *(double *)a2;
  result = *(unsigned int *)(a2 + 8);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_1405A8C00 (0x1405A8C00) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_140814780 (0x140814780) ---
__int64 __fastcall sub_140814780(__int64 a1)
{
  return a1 + 0x100;
}

// --- End Function: sub_140814780 (0x140814780) ---

// --- Function: sub_1408822B0 (0x1408822B0) ---
__int64 __fastcall sub_1408822B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x110);
}

// --- End Function: sub_1408822B0 (0x1408822B0) ---

// --- Function: sub_1412A8470 (0x1412A8470) ---
__int64 __fastcall sub_1412A8470(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 0x19;
  *(_QWORD *)(a1 + 8) = 0;
  result = a1;
  *(_QWORD *)(a1 + 0x10) = 0xFFFFFFFFFFFFFFFFuLL;
  return result;
}

// --- End Function: sub_1412A8470 (0x1412A8470) ---

// --- Function: sub_1413017D0 (0x1413017D0) ---
__int64 __fastcall sub_1413017D0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 0x128);
}

// --- End Function: sub_1413017D0 (0x1413017D0) ---

// --- Function: sub_14161ADF0 (0x14161ADF0) ---
_QWORD *__fastcall sub_14161ADF0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( sub_14030EC00(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_24;
    if ( n0xFFFF_24 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v8,
                            "IEntityPhysicalProxy");
      n0xFFFF_24 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_14161ADF0 (0x14161ADF0) ---

// --- Function: sub_1416615D0 (0x1416615D0) ---
__int64 __fastcall sub_1416615D0(__int64 a1, unsigned __int64 n3, __int64 a3, __int128 *a4, char *__z:, double *a6)
{
  __int128 v6; // xmm6
  bool v7; // zf
  __int128 v9; // xmm6
  double v10; // xmm0_8
  int v13; // eax
  __int64 v14; // rcx
  unsigned __int64 n0x20; // rax
  char *Format; // r9
  int v17; // eax
  int v18; // r12d
  __int64 v19; // r14
  _BYTE *v20; // rcx
  unsigned __int64 n5; // rdi
  __int128 v22; // xmm6
  double v23; // xmm0_8
  __int64 v24; // r14
  int v25; // eax
  __int64 v26; // rcx
  unsigned __int64 n0x20_1; // rax
  int v28; // eax
  int v29; // ecx
  __int64 result; // rax
  __int128 v31; // [rsp+30h] [rbp-A8h] BYREF
  const void *v32[2]; // [rsp+40h] [rbp-98h] BYREF
  char Format_[32]; // [rsp+50h] [rbp-88h] BYREF
  __int128 v34; // [rsp+80h] [rbp-58h]

  v34 = v6;
  v7 = *((_QWORD *)a4 + 1) == 0;
  v9 = *a4;
  v10 = *((double *)a4 + 2);
  v31 = *a4;
  *(double *)v32 = v10;
  if ( v7 || (Format_[0] = 0x25, v13 = sub_1404501E0((__int64)Format_, 0x1Fu, 1, (const void **)&v31 + 1, v32), v13 < 0) )
  {
    Format = (char *)&Format__0;
  }
  else
  {
    n0x20 = v13 + 1LL;
    if ( n0x20 >= 0x20 )
      _report_rangecheckfailure(v14);
    Format_[n0x20] = 0;
    Format = Format_;
  }
  v17 = snprintf_s((char *)(a3 + a1), n3 - a3, 0xFFFFFFFFFFFFFFFFuLL, Format, (_QWORD)v9);
  v18 = v17;
  if ( v17 < 0 )
    return 0xFFFFFFFFLL;
  v19 = a3 + v17;
  if ( v19 + 5 >= n3 )
    return 0xFFFFFFFFLL;
  v20 = (_BYTE *)(v19 + a1);
  n5 = n3 - v19;
  if ( !(v19 + a1) )
    goto LABEL_9;
  if ( __z: && n5 >= 5 )
  {
    *(_DWORD *)v20 = *(_DWORD *)__z:;
    v20[4] = __z:[4];
  }
  else
  {
    memset(v20, 0, n3 - v19);
    if ( !__z: )
    {
LABEL_9:
      *errno() = 0x16;
LABEL_16:
      invalid_parameter_noinfo();
      goto LABEL_17;
    }
    if ( n5 < 5 )
    {
      *errno() = 0x22;
      goto LABEL_16;
    }
  }
LABEL_17:
  v22 = *(_OWORD *)a6;
  v23 = a6[2];
  v24 = v19 + 5;
  v7 = *((_QWORD *)a6 + 1) == 0;
  v31 = *(_OWORD *)a6;
  *(double *)v32 = v23;
  if ( v7 || (Format_[0] = 0x25, v25 = sub_1404501E0((__int64)Format_, 0x1Fu, 1, (const void **)&v31 + 1, v32), v25 < 0) )
  {
    v28 = snprintf_s((char *)(v24 + a1), n3 - v24, 0xFFFFFFFFFFFFFFFFuLL, (const char *)&Format__0, (_QWORD)v22);
  }
  else
  {
    n0x20_1 = v25 + 1LL;
    if ( n0x20_1 >= 0x20 )
      _report_rangecheckfailure(v26);
    Format_[n0x20_1] = 0;
    v28 = snprintf_s((char *)(v24 + a1), n3 - v24, 0xFFFFFFFFFFFFFFFFuLL, Format_, (_QWORD)v22);
  }
  if ( v28 < 0 )
    return 0xFFFFFFFFLL;
  v29 = v28 + 5;
  result = (unsigned int)(v18 + v28 + 5);
  if ( v29 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_1416615D0 (0x1416615D0) ---

// --- Function: sub_141661810 (0x141661810) ---
__int64 __fastcall sub_141661810(
        __int64 a1,
        unsigned __int64 n3,
        __int64 a3,
        __int128 *a4,
        char *__y:,
        __int128 *a6,
        char *__z:,
        double *a8)
{
  __int128 v8; // xmm6
  bool v9; // zf
  __int128 v12; // xmm6
  double v13; // xmm0_8
  int v15; // eax
  __int64 v16; // rcx
  unsigned __int64 n0x20; // rax
  const char *Format; // r9
  int v19; // eax
  int v20; // r14d
  __int64 v21; // rdi
  _BYTE *v22; // rcx
  unsigned __int64 n5; // rbx
  int v24; // eax
  int v25; // ecx
  __int64 result; // rax
  __int128 v27; // [rsp+40h] [rbp-A8h] BYREF
  double v28; // [rsp+50h] [rbp-98h] BYREF
  _BYTE v29[32]; // [rsp+60h] [rbp-88h] BYREF
  __int128 v30; // [rsp+90h] [rbp-58h]

  v30 = v8;
  v9 = *((_QWORD *)a4 + 1) == 0;
  v12 = *a4;
  v13 = *((double *)a4 + 2);
  v27 = *a4;
  v28 = v13;
  if ( v9
    || (v29[0] = 0x25, v15 = sub_1404501E0((__int64)v29, 0x1Fu, 1, (const void **)&v27 + 1, (const void **)&v28),
                       v15 < 0) )
  {
    Format = (const char *)&Format__0;
  }
  else
  {
    n0x20 = v15 + 1LL;
    if ( n0x20 >= 0x20 )
      _report_rangecheckfailure(v16);
    v29[n0x20] = 0;
    Format = v29;
  }
  v19 = snprintf_s((char *)(a3 + a1), n3 - a3, 0xFFFFFFFFFFFFFFFFuLL, Format, (_QWORD)v12);
  v20 = v19;
  if ( v19 < 0 )
    return 0xFFFFFFFFLL;
  v21 = a3 + v19;
  if ( v21 + 5 >= n3 )
    return 0xFFFFFFFFLL;
  v22 = (_BYTE *)(v21 + a1);
  n5 = n3 - v21;
  if ( !(v21 + a1) )
    goto LABEL_9;
  if ( __y: && n5 >= 5 )
  {
    *(_DWORD *)v22 = *(_DWORD *)__y:;
    v22[4] = __y:[4];
    goto LABEL_17;
  }
  memset(v22, 0, n3 - v21);
  if ( __y: )
  {
    if ( n5 >= 5 )
      goto LABEL_17;
    *errno() = 0x22;
  }
  else
  {
LABEL_9:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_17:
  v24 = sub_1416615D0(a1, n3, v21 + 5, a6, __z:, a8);
  if ( v24 < 0 )
    return 0xFFFFFFFFLL;
  v25 = v24 + 5;
  result = (unsigned int)(v20 + v24 + 5);
  if ( v25 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_141661810 (0x141661810) ---

// --- Function: sub_1417CDAD0 (0x1417CDAD0) ---
__m256i *__fastcall sub_1417CDAD0(__m256i *a1)
{
  __m256i *result; // rax

  result = (__m256i *)allocWithProfilerInfo_w(0x20u);
  if ( result )
  {
    *result = *a1;
    __asm { vzeroupper }
  }
  else
  {
    __asm { vzeroupper }
  }
  return result;
}

// --- End Function: sub_1417CDAD0 (0x1417CDAD0) ---

// --- Function: sub_1417CDB50 (0x1417CDB50) ---
void __fastcall sub_1417CDB50(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1417CDB50 (0x1417CDB50) ---

// --- Function: sub_1417CEB40 (0x1417CEB40) ---
bool __fastcall sub_1417CEB40(double *a1, double *a2)
{
  return fabs(a1[1] - a2[1]) <= 0.5 && fabs(a1[2] - a2[2]) <= 0.5 && fabs(a1[3] - a2[3]) <= 0.5;
}

// --- End Function: sub_1417CEB40 (0x1417CEB40) ---

// --- Function: swprintf_w (0x1417D1930) ---
int __fastcall sub_1417D1930(double *a1, wchar_t *a2, size_t Count)
{
  return swprintf(a2, Count, "{\"x\":%f,\"y\":%f,\"z\":%f}", a1[1], a1[2], a1[3]);
}

// --- End Function: swprintf_w (0x1417D1930) ---

// --- Function: sub_1417D1A70 (0x1417D1A70) ---
__int64 __fastcall sub_1417D1A70(__int64 a1, void *a2, unsigned __int64 n3, __int64 a4, int a5, double a6)
{
  int v8; // eax
  double v10[3]; // [rsp+40h] [rbp-58h] BYREF
  __int128 v11; // [rsp+58h] [rbp-40h] BYREF
  const char *p_f; // [rsp+68h] [rbp-30h]
  __int128 v13; // [rsp+70h] [rbp-28h] BYREF
  const char *p_f_1; // [rsp+80h] [rbp-18h]

  v10[0] = *(double *)(a1 + 0x18);
  v10[1] = a6;
  *(_QWORD *)&v10[2] = "f";
  *(_QWORD *)&v11 = *(_QWORD *)(a1 + 0x10);
  *((double *)&v11 + 1) = a6;
  p_f = "f";
  *(_QWORD *)&v13 = *(_QWORD *)(a1 + 8);
  *((double *)&v13 + 1) = a6;
  p_f_1 = "f";
  if ( n3 <= 3 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    qmemcpy(a2, "x: ", 3);
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  v8 = sub_141661810((__int64)a2, n3, 3, &v13, ", y: ", &v11, ", z: ", v10);
  if ( v8 >= 0 )
    return (unsigned int)(v8 + 3);
  else
    return 0xFFFFFFFFLL;
}

// --- End Function: sub_1417D1A70 (0x1417D1A70) ---

// --- Function: sub_141848E00 (0x141848E00) ---
_QWORD *__fastcall sub_141848E00(_QWORD *p_pExceptionObject)
{
  p_pExceptionObject[1] = "bad allocation";
  *p_pExceptionObject = off_1481A05A8;
  return p_pExceptionObject;
}

// --- End Function: sub_141848E00 (0x141848E00) ---

// --- Function: sub_141873D00 (0x141873D00) ---
_QWORD *__fastcall sub_141873D00(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( sub_14030EC00(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_43;
    if ( n0xFFFF_43 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v8,
                            "IEntityRenderProxy");
      n0xFFFF_43 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_141873D00 (0x141873D00) ---

// --- Function: sub_141976650 (0x141976650) ---
void __fastcall sub_141976650(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx

  v2 = (_QWORD *)a1[0xB];
  if ( v2 )
  {
    if ( ((a1[0xD] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        goto LABEL_11;
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[0xB] = 0;
    a1[0xC] = 0;
    a1[0xD] = 0;
  }
  v3 = (_QWORD *)a1[7];
  if ( !v3 )
    return;
  if ( ((a1[9] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
  {
    if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v3 = (_QWORD *)v3[0xFFFFFFFF];
      goto LABEL_10;
    }
LABEL_11:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_1402A3D30(v3);
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
}

// --- End Function: sub_141976650 (0x141976650) ---

// --- Function: sub_141A63B10 (0x141A63B10) ---
__int64 __fastcall sub_141A63B10(__int64 a1, __int64 a2)
{
  unsigned __int64 *v4; // rcx

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 0x18) = *(_OWORD *)(a2 + 0x18);
  *(_DWORD *)(a1 + 0x28) = *(_DWORD *)(a2 + 0x28);
  *(_BYTE *)(a1 + 0x2C) = *(_BYTE *)(a2 + 0x2C);
  *(_BYTE *)(a1 + 0x2D) = *(_BYTE *)(a2 + 0x2D);
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x34) = *(_DWORD *)(a2 + 0x34);
  v4 = (unsigned __int64 *)(a1 + 0x38);
  if ( v4 != (unsigned __int64 *)(a2 + 0x38) )
    sub_141A27640(v4, *(_DWORD **)(a2 + 0x38), (__int64)(*(_QWORD *)(a2 + 0x40) - *(_QWORD *)(a2 + 0x38)) >> 6);
  *(_DWORD *)(a1 + 0x50) = *(_DWORD *)(a2 + 0x50);
  if ( a1 + 0x58 != a2 + 0x58 )
    sub_140342360(a1 + 0x58, *(char **)(a2 + 0x58), (__int64)(*(_QWORD *)(a2 + 0x60) - *(_QWORD *)(a2 + 0x58)) >> 3);
  *(_BYTE *)(a1 + 0x70) = *(_BYTE *)(a2 + 0x70);
  *(_DWORD *)(a1 + 0x74) = *(_DWORD *)(a2 + 0x74);
  return a1;
}

// --- End Function: sub_141A63B10 (0x141A63B10) ---

// --- Function: sub_141BDC970 (0x141BDC970) ---
__int64 __fastcall sub_141BDC970(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  const void *v6; // rdx
  char *v7; // rdi
  signed __int64 Size; // rbx

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 0x18) = *(_OWORD *)(a2 + 0x18);
  *(_DWORD *)(a1 + 0x28) = *(_DWORD *)(a2 + 0x28);
  *(_BYTE *)(a1 + 0x2C) = *(_BYTE *)(a2 + 0x2C);
  *(_BYTE *)(a1 + 0x2D) = *(_BYTE *)(a2 + 0x2D);
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x34) = *(_DWORD *)(a2 + 0x34);
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  v4 = (__int64)(*(_QWORD *)(a2 + 0x40) - *(_QWORD *)(a2 + 0x38)) >> 6;
  if ( v4 )
  {
    if ( v4 > 0x3FFFFFFFFFFFFFFLL )
      unknown_libname_10();
    sub_140332540((unsigned __int64 *)(a1 + 0x38), v4);
    *(_QWORD *)(a1 + 0x40) = sub_141A33C60(*(_QWORD *)(a2 + 0x38), *(_QWORD *)(a2 + 0x40), *(_DWORD **)(a1 + 0x38));
  }
  *(_DWORD *)(a1 + 0x50) = *(_DWORD *)(a2 + 0x50);
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  v5 = (__int64)(*(_QWORD *)(a2 + 0x60) - *(_QWORD *)(a2 + 0x58)) >> 3;
  if ( v5 )
  {
    if ( v5 > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    sub_1402FAD40((unsigned __int64 *)(a1 + 0x58), v5);
    v6 = *(const void **)(a2 + 0x58);
    v7 = *(char **)(a1 + 0x58);
    Size = *(_QWORD *)(a2 + 0x60) - (_QWORD)v6;
    memmove(v7, v6, Size);
    *(_QWORD *)(a1 + 0x60) = &v7[8 * (Size >> 3)];
  }
  *(_BYTE *)(a1 + 0x70) = *(_BYTE *)(a2 + 0x70);
  *(_DWORD *)(a1 + 0x74) = *(_DWORD *)(a2 + 0x74);
  return a1;
}

// --- End Function: sub_141BDC970 (0x141BDC970) ---

// --- Function: sub_141D17630 (0x141D17630) ---
// attributes: thunk
__int64 __fastcall sub_141D17630(__int64 a1)
{
  return sub_1403335B0(a1);
}

// --- End Function: sub_141D17630 (0x141D17630) ---

// --- Function: sub_141D73D00 (0x141D73D00) ---
__int64 __fastcall sub_141D73D00(__int64 a1, __int64 a2)
{
  __int128 v2; // kr00_16
  float v8; // xmm0_4

  v2 = *(unsigned int *)(a2 + 4);
  *(float *)&v2 = *(float *)(a2 + 4) * *(float *)(a2 + 8);
  LODWORD(_XMM0) = 0xBF800000;
  *(float *)&v2 = (float)(*(float *)&v2 + *(float *)&v2)
                + (float)((float)(*(float *)(a2 + 0xC) * *(float *)a2) + (float)(*(float *)(a2 + 0xC) * *(float *)a2));
  _XMM3 = v2;
  if ( *(float *)&v2 >= -1.0 )
  {
    __asm { vminss  xmm1, xmm3, xmm7 }
    if ( *(float *)&_XMM1 < -1.0 )
      goto LABEL_5;
  }
  else
  {
    _XMM1 = 0xBF800000;
  }
  __asm { vminss  xmm0, xmm1, xmm7; X }
LABEL_5:
  v8 = asinf(*(float *)&_XMM0);
  *(float *)(a1 + 4) = v8;
  if ( COERCE_FLOAT(LODWORD(v8) & 0x7FFFFFFF) > 1.5607964 )
  {
    *(float *)a1 = atan2f(
                     (float)((float)(*(float *)(a2 + 8) * *(float *)a2) + (float)(*(float *)(a2 + 8) * *(float *)a2))
                   + (float)((float)(*(float *)(a2 + 0xC) * *(float *)(a2 + 4))
                           + (float)(*(float *)(a2 + 0xC) * *(float *)(a2 + 4))),
                     (float)((float)(*(float *)(a2 + 8) * *(float *)(a2 + 4))
                           - (float)(*(float *)(a2 + 0xC) * *(float *)a2))
                   * -2.0);
    *(_DWORD *)(a1 + 8) = 0;
  }
  else
  {
    *(float *)a1 = atan2f(
                     (float)((float)(*(float *)(a2 + 4) * *(float *)a2)
                           - (float)(*(float *)(a2 + 0xC) * *(float *)(a2 + 8)))
                   * -2.0,
                     (float)((float)((float)(*(float *)(a2 + 4) + *(float *)(a2 + 4)) * *(float *)(a2 + 4))
                           + (float)((float)(*(float *)(a2 + 0xC) + *(float *)(a2 + 0xC)) * *(float *)(a2 + 0xC)))
                   - 1.0);
    *(float *)(a1 + 8) = atan2f(
                           (float)((float)(*(float *)(a2 + 8) * *(float *)a2)
                                 - (float)(*(float *)(a2 + 0xC) * *(float *)(a2 + 4)))
                         * -2.0,
                           (float)((float)((float)(*(float *)(a2 + 0xC) + *(float *)(a2 + 0xC)) * *(float *)(a2 + 0xC))
                                 + (float)((float)(*(float *)(a2 + 8) + *(float *)(a2 + 8)) * *(float *)(a2 + 8)))
                         - 1.0);
  }
  return a1;
}

// --- End Function: sub_141D73D00 (0x141D73D00) ---

// --- Function: sub_141EF04A0 (0x141EF04A0) ---
__int64 __fastcall sub_141EF04A0(__int64 a1)
{
  __int64 result; // rax

  *(_WORD *)(a1 + 4) = 0x100;
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 0x30) = 0x1000007FFLL;
  result = a1;
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0x81;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_BYTE *)(a1 + 0x78) = 0;
  *(_DWORD *)(a1 + 0x7C) = 0;
  *(_WORD *)(a1 + 0x80) = 1;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_DWORD *)(a1 + 0xB0) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_DWORD *)(a1 + 0xD8) = 0;
  *(_DWORD *)(a1 + 0x14) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x10) = 0xFFBFFFFF;
  return result;
}

// --- End Function: sub_141EF04A0 (0x141EF04A0) ---

// --- Function: sub_1425D62E0 (0x1425D62E0) ---
_QWORD *__fastcall sub_1425D62E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_31;
  if ( n0xFFFF_31 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "Actor");
    n0xFFFF_31 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D62E0 (0x1425D62E0) ---

// --- Function: sub_1425D69E0 (0x1425D69E0) ---
_QWORD *__fastcall sub_1425D69E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n257; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n257_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n257 = n257_0;
  if ( n257_0 == (__int16)0xFFFF )
  {
    n257 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                       qword_149B4FC88,
                       &v9,
                       "SCItemWeaponComponent");
    n257_0 = n257;
  }
  n257_1 = n257;
  v6 = *(_QWORD *)v4(a1, &v10, &n257_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D69E0 (0x1425D69E0) ---

// --- Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---
__int64 __fastcall std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z (0x1426D6F80) ---

// --- Function: sub_142704BB0 (0x142704BB0) ---
_QWORD *__fastcall sub_142704BB0(_QWORD *a1, _QWORD *a2)
{
  __int64 v3; // [rsp+50h] [rbp-28h]
  __int64 v4; // [rsp+60h] [rbp-18h]
  std::_Ref_count_base *v5; // [rsp+60h] [rbp-18h]

  if ( a2[1] )
    InterlockedIncrement_w_1(a2[1]);
  v4 = a2[1];
  *a1 = *a2;
  v3 = v4;
  v5 = (std::_Ref_count_base *)a1[1];
  a1[1] = v3;
  if ( v5 )
    std::_Ref_count_base::_Decref(v5);
  return a1;
}

// --- End Function: sub_142704BB0 (0x142704BB0) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142705160 (0x142705160) ---
__int64 __fastcall sub_142705160(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_142705160 (0x142705160) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || sub_140539D80() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: sub_142744750 (0x142744750) ---
__int64 __fastcall sub_142744750(unsigned __int8 a1)
{
  return (unsigned int)a1 + 0xC7;
}

// --- End Function: sub_142744750 (0x142744750) ---

// --- Function: sub_14277B400 (0x14277B400) ---
unsigned __int64 __fastcall sub_14277B400(__int64 a1, unsigned __int64 a2)
{
  __crt_strtox *v3; // rcx
  unsigned __int64 v5; // [rsp+20h] [rbp-38h]
  __int64 v6; // [rsp+30h] [rbp-28h]
  __int64 v7; // [rsp+40h] [rbp-18h] BYREF
  __int64 v8; // [rsp+48h] [rbp-10h] BYREF

  v3 = *(__crt_strtox **)a1;
  v5 = (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v3) >> 4;
  v7 = 0xFFFFFFFFFFFFFFFLL;
  v8 = __crt_strtox::maximum_signed_value(v3);
  v6 = *unknown_libname_2(&v8, &v7);
  if ( v5 > v6 - v5 / 2 )
    return v6;
  if ( v5 / 2 + v5 >= a2 )
    return v5 / 2 + v5;
  return a2;
}

// --- End Function: sub_14277B400 (0x14277B400) ---

// --- Function: unknown_libname_67 (0x14277CFC0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_67()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_67 (0x14277CFC0) ---

// --- Function: sub_1427C1BD0 (0x1427C1BD0) ---
_QWORD *__fastcall sub_1427C1BD0(Parameter *Parameter, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rax
  __crt_strtox *v4; // rcx
  unsigned __int64 _Bytes; // rax
  _QWORD *v7; // [rsp+20h] [rbp-98h]
  __int64 v8; // [rsp+30h] [rbp-88h]
  _QWORD **v10; // [rsp+40h] [rbp-78h]
  unsigned __int64 v12; // [rsp+58h] [rbp-60h]
  __int64 v13; // [rsp+68h] [rbp-50h]
  __int64 v14; // [rsp+80h] [rbp-38h] BYREF
  __int64 v15; // [rsp+88h] [rbp-30h] BYREF
  __int64 v16; // [rsp+90h] [rbp-28h]
  unsigned __int64 v17; // [rsp+98h] [rbp-20h]

  v10 = (_QWORD **)((char *)Parameter + 8);
  v8 = ((__int64)a2 - *(_QWORD *)Parameter) >> 4;
  v3 = (_QWORD *)((char *)Parameter + 8);
  v4 = *(__crt_strtox **)Parameter;
  v13 = (__int64)(*v3 - (_QWORD)v4) >> 4;
  v14 = 0xFFFFFFFFFFFFFFFLL;
  v15 = __crt_strtox::maximum_signed_value(v4);
  v16 = *unknown_libname_2(&v15, &v14);
  if ( v13 == v16 )
    unknown_libname_67();
  v12 = sub_14277B400((__int64)Parameter, v13 + 1);
  v17 = v12;
  _Bytes = sub_1402A85A0(v12);
  v7 = std::_Allocate<16,std::_Default_allocate_traits,0>(_Bytes);
  sub_1427C26A0((__int64)&v7[2 * v8], a3);
  if ( a2 == *v10 )
  {
    sub_1427C2480(*(_QWORD **)Parameter, *v10, (__int64)v7, (__int64)Parameter);
  }
  else
  {
    sub_1427C2480(*(_QWORD **)Parameter, a2, (__int64)v7, (__int64)Parameter);
    sub_1427C2480(a2, *v10, (__int64)&v7[2 * v8 + 2], (__int64)Parameter);
  }
  sub_142816FF0(Parameter, (__int64)v7, v13 + 1, v12);
  return &v7[2 * v8];
}

// --- End Function: sub_1427C1BD0 (0x1427C1BD0) ---

// --- Function: sub_1427C2480 (0x1427C2480) ---
__int64 __fastcall sub_1427C2480(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v7; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+50h] [rbp-28h] BYREF
  __int64 v9; // [rsp+58h] [rbp-20h]
  __int64 v10; // [rsp+60h] [rbp-18h]

  v8 = a3;
  v9 = a3;
  v10 = a4;
  while ( a1 != a2 )
  {
    sub_1427C2730(v9, a1);
    v9 += 0x10;
    a1 += 2;
  }
  v8 = v9;
  v7 = v9;
  sub_1427CACC0(&v8);
  return v7;
}

// --- End Function: sub_1427C2480 (0x1427C2480) ---

// --- Function: sub_1427C26A0 (0x1427C26A0) ---
_QWORD *__fastcall sub_1427C26A0(__int64 a1, _QWORD *a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-18h]

  v3 = (_QWORD *)sub_1402A2B80(0x10, a1);
  *v3 = 0;
  v3[1] = 0;
  if ( a2[1] )
    InterlockedIncrement_w_1(a2[1]);
  *v3 = *a2;
  v3[1] = a2[1];
  return v3;
}

// --- End Function: sub_1427C26A0 (0x1427C26A0) ---

// --- Function: sub_142816FF0 (0x142816FF0) ---
__int64 __fastcall sub_142816FF0(Parameter *Parameter, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 i; // [rsp+20h] [rbp-58h]
  __int64 *v7; // [rsp+38h] [rbp-40h]
  _QWORD *v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]

  v7 = (__int64 *)((char *)Parameter + 8);
  v8 = (_QWORD *)((char *)Parameter + 0x10);
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( *(_QWORD *)Parameter )
  {
    v9 = *v7;
    for ( i = *(_QWORD *)Parameter; i != v9; i += 0x10 )
    {
      if ( *(_QWORD *)(i + 8) )
        std::_Ref_count_base::_Decref(*(std::_Ref_count_base **)(i + 8));
    }
    std::_Deallocate<16,0>(*(_QWORD **)Parameter, 0x10 * ((__int64)(*v8 - *(_QWORD *)Parameter) >> 4));
  }
  *(_QWORD *)Parameter = a2;
  *v7 = 0x10 * a3 + a2;
  result = 0x10 * a4 + a2;
  *v8 = result;
  return result;
}

// --- End Function: sub_142816FF0 (0x142816FF0) ---

// --- Function: sub_142C0A570 (0x142C0A570) ---
Parameter *__fastcall sub_142C0A570(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  Parameter *Parameter_2; // [rsp+28h] [rbp-30h]

  Parameter_2 = (Parameter *)((char *)Parameter + 8);
  Parameter_1 = Parameter;
  if ( *(_QWORD *)Parameter != *((_QWORD *)Parameter + 1) )
  {
    _StarEngineModule__((ULONG_PTR)Parameter);
    Parameter_1 = Parameter_2;
    *(_QWORD *)Parameter_2 = *(_QWORD *)Parameter;
  }
  return Parameter_1;
}

// --- End Function: sub_142C0A570 (0x142C0A570) ---

// --- Function: sub_142E9B490 (0x142E9B490) ---
char *__fastcall sub_142E9B490(BB_ComparisonOperatorType *Parameter, const void *src)
{
  if ( *((_QWORD *)Parameter + 1) == *((_QWORD *)Parameter + 2) )
    return sub_142E9F960(Parameter, *((AK::WriteBytesCount **)Parameter + 1), src);
  else
    return (char *)sub_142E9A440((__int64 *)Parameter, src);
}

// --- End Function: sub_142E9B490 (0x142E9B490) ---

// --- Function: sub_142EC37E0 (0x142EC37E0) ---
__int64 __fastcall sub_142EC37E0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 4;
  result = a1;
  *(_DWORD *)(a1 + 4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 8) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xC) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x14) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x18) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x20) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x2C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x24) = 0x80000000;
  *(_DWORD *)(a1 + 0x28) = 0x80000000;
  *(_DWORD *)(a1 + 0x30) = 0x80000000;
  *(_DWORD *)(a1 + 0x5C) = 0x80000000;
  *(_DWORD *)(a1 + 0x48) = 0x80000000;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x34) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x38) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x3C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x40) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x10) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x58) = 0x80000000;
  *(_DWORD *)(a1 + 0x44) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x60) = 0x80000000;
  *(_DWORD *)(a1 + 0x80) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x68) = 0x80000000;
  *(_DWORD *)(a1 + 0x6C) = 0x80000000;
  *(_DWORD *)(a1 + 0x70) = 0x80000000;
  *(_DWORD *)(a1 + 0x64) = 0x80000000;
  return result;
}

// --- End Function: sub_142EC37E0 (0x142EC37E0) ---

// --- Function: sub_142ED3D20 (0x142ED3D20) ---
__int64 __fastcall sub_142ED3D20(__int64 a1, __int64 a2, unsigned int a3, int a4, int a5)
{
  int v5; // r11d
  __int64 n0x17; // r10
  _DWORD *v8; // rcx
  unsigned int v9; // edx
  _DWORD v11[10]; // [rsp+20h] [rbp-28h] BYREF

  v5 = 0;
  n0x17 = 0;
  v8 = (_DWORD *)(a1 + 0xC0);
  v9 = a3;
  do
  {
    if ( !v9 )
      break;
    if ( (v9 & 1) != 0 )
      v5 |= *v8;
    ++n0x17;
    v9 >>= 1;
    ++v8;
  }
  while ( n0x17 < 0x17 );
  v11[5] = a5;
  v11[2] = a3;
  v11[0] = 0x19;
  v11[4] = 0xFFFFFFFF;
  v11[3] = a4 | v5;
  return (*(__int64 (__fastcall **)(__int64, _DWORD *, _QWORD))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL) + 0x18LL))(
           a2 & 0xFFFFFFFFFFFFLL,
           v11,
           0);
}

// --- End Function: sub_142ED3D20 (0x142ED3D20) ---

// --- Function: sub_142EEAFD0 (0x142EEAFD0) ---
__int64 __fastcall sub_142EEAFD0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
             qword_149B4FCA0,
             0xA,
             0);
  return result;
}

// --- End Function: sub_142EEAFD0 (0x142EEAFD0) ---

// --- Function: sub_142F6ECE0 (0x142F6ECE0) ---
__int64 __fastcall sub_142F6ECE0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(double *)(a1 + 56) = *(double *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(double *)(a1 + 88) = *(double *)(a2 + 88);
  *(_DWORD *)(a1 + 108) = *(_DWORD *)(a2 + 108);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a2 + 100);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 104);
  *(double *)(a1 + 112) = *(double *)(a2 + 112);
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a2 + 120);
  *(_BYTE *)(a1 + 124) = *(_BYTE *)(a2 + 124);
  *(_BYTE *)(a1 + 125) = *(_BYTE *)(a2 + 125);
  *(_BYTE *)(a1 + 126) = *(_BYTE *)(a2 + 126);
  *(_BYTE *)(a1 + 127) = *(_BYTE *)(a2 + 127);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  return a1;
}

// --- End Function: sub_142F6ECE0 (0x142F6ECE0) ---

// --- Function: sub_14318F1B0 (0x14318F1B0) ---
__int64 __fastcall sub_14318F1B0(__int64 a1)
{
  bool v2; // [rsp+20h] [rbp-88h]
  __int64 v3; // [rsp+28h] [rbp-80h]
  __int64 v4; // [rsp+30h] [rbp-78h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  _DWORD *v6; // [rsp+48h] [rbp-60h]
  _DWORD *v7; // [rsp+50h] [rbp-58h]
  const char *v8; // [rsp+58h] [rbp-50h]
  __int64 v9; // [rsp+60h] [rbp-48h]
  unsigned __int8 (__fastcall *v10)(__int64, __int64, const char *); // [rsp+68h] [rbp-40h]
  _BYTE v11[24]; // [rsp+70h] [rbp-38h] BYREF
  _BYTE v12[32]; // [rsp+88h] [rbp-20h] BYREF

  if ( !a1 )
    return 0;
  v7 = (_DWORD *)sub_1432685F0((__int64)v12);
  v6 = (_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 0x18LL))(a1, v11);
  v2 = unknown_libname_19(v7, v6);
  sub_1403090C0((__int64)v11);
  sub_1403090C0((__int64)v12);
  if ( v2 )
    return a1;
  if ( sub_1402C7230()
    && (v3 = sub_1402C7230(), (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x240LL))(v3))
    && (v4 = sub_1402C7230(),
        v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x240LL))(v4),
        v10 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v5 + 0x100LL),
        v8 = sub_1432683D0(),
        v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1),
        v10(v5, v9, v8)) )
  {
    return a1;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_14318F1B0 (0x14318F1B0) ---

// --- Function: sub_143192820 (0x143192820) ---
__int64 __fastcall sub_143192820(__int64 a1)
{
  return sub_14318F1B0(a1);
}

// --- End Function: sub_143192820 (0x143192820) ---

// --- Function: sub_14325AD60 (0x14325AD60) ---
void __fastcall sub_14325AD60(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 0xD0) )
  {
    ++*(_DWORD *)(a1 + 0xD0);
  }
  else
  {
    sub_14161ADF0(a1, &v5);
    if ( AssetMeta::HasActorSubresource(&v5) )
    {
      v2 = sub_14030ECF0(&v5);
      v3 = a1 + 0x70;
      if ( !a1 )
        v3 = 0;
      (*(void (__fastcall **)(__int64, __int64, __int64, const char *))(*(_QWORD *)v2 + 0x680LL))(
        v2,
        v3,
        1,
        "CBasePhysicsController");
      v4 = sub_14030ECF0(&v5);
      (*(void (__fastcall **)(__int64, __int64, __int64, const char *))(*(_QWORD *)v4 + 0x680LL))(
        v4,
        v3,
        0x40,
        "CBasePhysicsController");
      ++*(_DWORD *)(a1 + 0xD0);
    }
    else
    {
      ++*(_DWORD *)(a1 + 0xD0);
    }
  }
}

// --- End Function: sub_14325AD60 (0x14325AD60) ---

// --- Function: sub_14326CF90 (0x14326CF90) ---
void __fastcall sub_14326CF90(__int64 a1)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF

  if ( (*(_DWORD *)(a1 + 0xD0))-- == 1 )
  {
    sub_14161ADF0(a1, &v5);
    if ( AssetMeta::HasActorSubresource(&v5) )
    {
      v3 = sub_14030ECF0(&v5);
      v4 = a1 + 0x70;
      if ( !a1 )
        v4 = 0;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 0x688LL))(v3, v4);
    }
  }
  if ( *(int *)(a1 + 0xD0) < 0 )
    *(_DWORD *)(a1 + 0xD0) = 0;
}

// --- End Function: sub_14326CF90 (0x14326CF90) ---

// --- Function: sub_1432B1780 (0x1432B1780) ---
__int64 __fastcall sub_1432B1780(__int64 a1, _QWORD *a2, char a3)
{
  char v4; // [rsp+20h] [rbp-F8h]
  _QWORD *Parameter_; // [rsp+28h] [rbp-F0h] BYREF
  BOOL v6; // [rsp+30h] [rbp-E8h]
  __int64 v7; // [rsp+38h] [rbp-E0h]
  __int64 v8; // [rsp+40h] [rbp-D8h]
  __int64 v9; // [rsp+48h] [rbp-D0h]
  __int64 (__fastcall ***v10)(_QWORD); // [rsp+50h] [rbp-C8h]
  __int64 v11; // [rsp+58h] [rbp-C0h]
  __int64 v12; // [rsp+60h] [rbp-B8h]
  __int64 v13; // [rsp+68h] [rbp-B0h]
  __int64 v14; // [rsp+70h] [rbp-A8h]
  __int64 v15; // [rsp+78h] [rbp-A0h]
  __int64 v16; // [rsp+80h] [rbp-98h]
  _QWORD Parameter__1[2]; // [rsp+88h] [rbp-90h] BYREF
  __int64 (__fastcall ***v18)(_QWORD); // [rsp+98h] [rbp-80h]
  unsigned __int8 (__fastcall **v19)(_QWORD *); // [rsp+A0h] [rbp-78h]
  _QWORD *Parameter__2; // [rsp+A8h] [rbp-70h]
  __int64 v21; // [rsp+B0h] [rbp-68h]
  _QWORD *Parameter__3; // [rsp+B8h] [rbp-60h]
  __int64 v23; // [rsp+C0h] [rbp-58h]
  _QWORD *Parameter__4; // [rsp+C8h] [rbp-50h]
  _QWORD *Parameter__5; // [rsp+D0h] [rbp-48h]
  _QWORD *Parameter__6; // [rsp+D8h] [rbp-40h]
  __int64 v27; // [rsp+E0h] [rbp-38h]
  __int64 v28[4]; // [rsp+E8h] [rbp-30h] BYREF
  BB_ComparisonOperatorType Parameter__7[4]; // [rsp+108h] [rbp-10h] BYREF

  v7 = a1 + 0x3520;
  sub_1431B0E90((__int64)v28, a1 + 0x3520, a1 + 0x3538);
  v11 = v28[0];
  v8 = v28[0];
  v12 = v28[0];
  v13 = *(_QWORD *)v28[0];
  std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
    (Parameter *)&Parameter_,
    v13);
  while ( 1 )
  {
    v14 = v28[0];
    v9 = v28[0];
    v15 = v28[0];
    v16 = *(_QWORD *)(v28[0] + 8);
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
      (Parameter *)Parameter__1,
      v16);
    v6 = Parameter_ == (_QWORD *)Parameter__1[0];
    if ( Parameter_ == (_QWORD *)Parameter__1[0] )
    {
      sub_1432F01F0(v28);
      return 0;
    }
    Parameter__1[1] = Parameter_;
    v18 = (__int64 (__fastcall ***)(_QWORD))*Parameter_;
    v10 = v18;
    v4 = (**v18)(v18);
    v19 = (unsigned __int8 (__fastcall **)(_QWORD *))*a2;
    if ( v4 == (*v19)(a2) )
      break;
    Parameter_ += 2;
  }
  Parameter__2 = Parameter_;
  v21 = *Parameter_;
  sub_1432F3FF0((__int64)a2, v21);
  if ( a3 )
  {
    Parameter__3 = Parameter_;
    v23 = *Parameter_;
    sub_145846310(a1, v23);
    Parameter__4 = Parameter_;
    v27 = v28[0];
    Parameter__5 = Parameter_;
    Parameter__6 = Parameter_;
    sub_1432A1590(v28[0], Parameter__7, Parameter_);
  }
  sub_1432F01F0(v28);
  return 1;
}

// --- End Function: sub_1432B1780 (0x1432B1780) ---

// --- Function: sub_143825070 (0x143825070) ---
_QWORD *__fastcall sub_143825070(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v9 = *(_QWORD *)(a1 + 8);
  if ( sub_14030EC00(&v9) )
  {
    v3 = v9 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v9 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_70;
    if ( n0xFFFF_70 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v8,
                            "SCActorRotationComponent");
      n0xFFFF_70 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a2 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_143825070 (0x143825070) ---

// --- Function: sub_1443C8760 (0x1443C8760) ---
__int64 __fastcall sub_1443C8760(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  *(_QWORD *)a1 = &off_148926598;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 0x10) = 0;
  sub_14035B3E0((_QWORD *)(a1 + 0x18));
  *(_DWORD *)(a1 + 0x20) = 0;
  v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(qword_149B4FC40, 0);
  *(_QWORD *)a1 = &off_1489265B0;
  result = a1;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 0x28) = 0;
  *(_DWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x34) = 0xFFFFFFFF;
  *(_OWORD *)(a1 + 0x38) = 0;
  *(_OWORD *)(a1 + 0x48) = 0;
  *(_DWORD *)(a1 + 0x58) = 0;
  *(_WORD *)(a1 + 0x5C) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_DWORD *)(a1 + 0x80) = 0xBF800000;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_BYTE *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0xA4) = 0x3F800000;
  *(_DWORD *)(a1 + 0x20) = 0x3F800000;
  return result;
}

// --- End Function: sub_1443C8760 (0x1443C8760) ---

// --- Function: sub_1443C8870 (0x1443C8870) ---
__int64 __fastcall sub_1443C8870(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  *(_QWORD *)a1 = &off_148926598;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 0x10) = 0;
  sub_14035B3E0((_QWORD *)(a1 + 0x18));
  *(_DWORD *)(a1 + 0x20) = 0;
  v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(qword_149B4FC40, 0);
  *(_QWORD *)a1 = off_1489266D0;
  result = a1;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 0x28) = 0;
  *(_DWORD *)(a1 + 0x2C) = 0xFFFFFFFF;
  *(_OWORD *)(a1 + 0x30) = 0;
  *(_OWORD *)(a1 + 0x40) = 0;
  *(_DWORD *)(a1 + 0x50) = 0;
  *(_WORD *)(a1 + 0x54) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_DWORD *)(a1 + 0x78) = 0xBF800000;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_BYTE *)(a1 + 0x98) = 0;
  *(_DWORD *)(a1 + 0x9C) = 0x3F800000;
  *(_BYTE *)(a1 + 0xA0) = 0;
  *(_DWORD *)(a1 + 0x20) = 0x3F800000;
  return result;
}

// --- End Function: sub_1443C8870 (0x1443C8870) ---

// --- Function: sub_1443C9B20 (0x1443C9B20) ---
__int64 __fastcall sub_1443C9B20(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  *(_QWORD *)a1 = &off_148926598;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 0x10) = 0;
  sub_14035B3E0((_QWORD *)(a1 + 0x18));
  *(_DWORD *)(a1 + 0x20) = 0;
  v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(qword_149B4FC40, 0);
  *(_QWORD *)a1 = off_148926630;
  result = a1;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x2C) = 0;
  *(_QWORD *)(a1 + 0x34) = 1;
  *(_BYTE *)(a1 + 0x3C) = 0xFF;
  *(_DWORD *)(a1 + 0x40) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x44) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_DWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x8C) = 0;
  *(_DWORD *)(a1 + 0x94) = 0;
  *(_DWORD *)(a1 + 0x6C) = 0xFFFFFFFE;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_BYTE *)(a1 + 0x78) = 0xFF;
  *(_DWORD *)(a1 + 0x7C) = 0;
  *(_WORD *)(a1 + 0x80) = 0xFFFF;
  *(_QWORD *)(a1 + 0x84) = 0;
  *(_BYTE *)(a1 + 0x98) = 0;
  *(_DWORD *)(a1 + 0x9C) = 0;
  *(_WORD *)(a1 + 0xA0) = 0xFF00;
  *(_DWORD *)(a1 + 0x20) = 0x3F000000;
  return result;
}

// --- End Function: sub_1443C9B20 (0x1443C9B20) ---

// --- Function: sub_1443CA220 (0x1443CA220) ---
__int64 __fastcall sub_1443CA220(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  *(_QWORD *)a1 = &off_148926598;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 0x10) = 0;
  sub_14035B3E0((_QWORD *)(a1 + 0x18));
  *(_DWORD *)(a1 + 0x20) = 0;
  v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(qword_149B4FC40, 0);
  *(_QWORD *)a1 = off_148926650;
  result = a1;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 0x28) = 0;
  *(_DWORD *)(a1 + 0x2C) = 0xFFFFFFFF;
  *(_OWORD *)(a1 + 0x30) = 0;
  *(_OWORD *)(a1 + 0x40) = 0;
  *(_DWORD *)(a1 + 0x50) = 0;
  *(_WORD *)(a1 + 0x54) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_DWORD *)(a1 + 0x78) = 0xBF800000;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_BYTE *)(a1 + 0x98) = 0;
  *(_DWORD *)(a1 + 0x9C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x20) = 0x3F000000;
  return result;
}

// --- End Function: sub_1443CA220 (0x1443CA220) ---

// --- Function: sub_1443CA900 (0x1443CA900) ---
__int64 __fastcall sub_1443CA900(__int64 a1, char a2)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 0x39;
  result = a1;
  *(_BYTE *)(a1 + 4) = a2;
  return result;
}

// --- End Function: sub_1443CA900 (0x1443CA900) ---

// --- Function: sub_1443CB320 (0x1443CB320) ---
__int64 __fastcall sub_1443CB320(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  *(_BYTE *)(a1 + 0x10) = 0;
  *(_QWORD *)a1 = &off_148926598;
  *(_QWORD *)(a1 + 8) = 0;
  sub_14035B3E0((_QWORD *)(a1 + 0x18));
  *(_DWORD *)(a1 + 0x20) = 0;
  v2 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(qword_149B4FC40, 0);
  *(_QWORD *)a1 = off_1489266B0;
  result = a1;
  *(_QWORD *)(a1 + 8) = v2;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_DWORD *)(a1 + 0x20) = 0x3F800000;
  return result;
}

// --- End Function: sub_1443CB320 (0x1443CB320) ---

// --- Function: sub_1443CD4A0 (0x1443CD4A0) ---
void __fastcall sub_1443CD4A0(const void **a1, int *a2)
{
  int *v3; // rdi
  unsigned __int64 v4; // rbp
  unsigned __int64 n8; // rsi
  __int64 v6; // rcx
  unsigned __int64 v7; // r14
  __int64 v8; // r13
  int *v9; // rdi
  __int64 v10; // rbx

  v3 = a2;
  v4 = dword_148924110[*a2];
  n8 = (unsigned __int64)a1[1];
  v6 = (__int64)a1[2];
  if ( n8 - v6 < v4 )
  {
    if ( !n8 )
      n8 = 8;
    for ( ; n8 - v6 < v4; n8 *= 2LL )
      ;
    v7 = 0;
    v8 = allocWithProfilerInfo_w(n8);
    if ( a1[2] )
    {
      do
      {
        v9 = (int *)((char *)*a1 + v7);
        v10 = dword_148924110[*v9];
        sub_1443D82F0(v7 + v8, v9);
        sub_1443D3250((__int64)v9);
        v7 += v10;
      }
      while ( v7 < (unsigned __int64)a1[2] );
      v3 = a2;
    }
    sub_1402A3D30(*a1);
    *a1 = (const void *)v8;
    a1[1] = (const void *)n8;
  }
  sub_1443D0AE0((__int64)a1[2] + (_QWORD)*a1, (__int64)v3);
  a1[2] = (char *)a1[2] + v4;
}

// --- End Function: sub_1443CD4A0 (0x1443CD4A0) ---

// --- Function: sub_1443CF880 (0x1443CF880) ---
void __fastcall sub_1443CF880(_QWORD *a1)
{
  unsigned __int64 v2; // r8
  int *v3; // rcx

  a1[3] = 0;
  if ( a1[2] )
  {
    v2 = 0;
    do
    {
      v3 = (int *)(v2 + *a1);
      a1[3] = v2 + dword_148924110[*v3];
      sub_1443D3250((__int64)v3);
      v2 = a1[3];
    }
    while ( v2 < a1[2] );
    a1[3] = 0;
    a1[2] = 0;
  }
  else
  {
    a1[3] = 0;
    a1[2] = 0;
  }
}

// --- End Function: sub_1443CF880 (0x1443CF880) ---

// --- Function: sub_1443D4F50 (0x1443D4F50) ---
int *__fastcall sub_1443D4F50(_QWORD *a1)
{
  int *result; // rax

  result = (int *)(a1[3] + *a1);
  a1[3] += dword_148924110[*result];
  return result;
}

// --- End Function: sub_1443D4F50 (0x1443D4F50) ---

// --- Function: sub_1443D7790 (0x1443D7790) ---
bool __fastcall sub_1443D7790(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x18) < *(_QWORD *)(a1 + 0x10);
}

// --- End Function: sub_1443D7790 (0x1443D7790) ---

// --- Function: sub_1446EB270 (0x1446EB270) ---
_QWORD *__fastcall sub_1446EB270(__int64 a1, _QWORD *a2)
{
  sub_141873D00(a1, a2);
  return a2;
}

// --- End Function: sub_1446EB270 (0x1446EB270) ---

// --- Function: sub_1448FBB10 (0x1448FBB10) ---
__int64 __fastcall sub_1448FBB10(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(double *)(a1 + 0x20) = *(double *)(a2 + 0x20);
  *(double *)(a1 + 8) = *(double *)(a2 + 8);
  *(double *)(a1 + 0x10) = *(double *)(a2 + 0x10);
  *(double *)(a1 + 0x18) = *(double *)(a2 + 0x18);
  return a1;
}

// --- End Function: sub_1448FBB10 (0x1448FBB10) ---

// --- Function: sub_144969C30 (0x144969C30) ---
void __fastcall sub_144969C30(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_144969C30 (0x144969C30) ---

// --- Function: sub_144E2E4E0 (0x144E2E4E0) ---
char __fastcall sub_144E2E4E0(__int64 a1, char a2, float a3, char a4, unsigned __int8 a5)
{
  __int64 n0x460; // rax

  n0x460 = 0x460;
  if ( !a4 )
    n0x460 = 0x400;
  return sub_144E2E500(n0x460 + a1, a2, a3, a5);
}

// --- End Function: sub_144E2E4E0 (0x144E2E4E0) ---

// --- Function: sub_144E2E500 (0x144E2E500) ---
char __fastcall sub_144E2E500(__int64 a1, char a2, float a3, unsigned __int8 a4)
{
  unsigned int v6; // r14d
  int v7; // esi
  unsigned __int32 v8; // eax
  __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  __int64 v12; // rsi
  __int128 n0x3E99999A; // xmm1
  unsigned __int8 v17; // bp
  __int128 n0x3F800000; // xmm1
  int v22; // eax
  unsigned __int32 v23; // eax
  __int64 v25; // [rsp+20h] [rbp-38h]

  v6 = a4;
  if ( byte_149B501D5 || (_BYTE)qword_149B501D6 )
  {
    v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x30) == v7 )
    {
      ++*(_DWORD *)(a1 + 0x34);
    }
    else
    {
      v8 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x20), 1, 0);
      if ( v8 )
        sub_1403C33A0(a1 + 0x20, v8, "CGlobalGameUI::SFadeVariables::FadeScreen", 1);
      else
        *(_QWORD *)(a1 + 0x28) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x30) = v7;
    }
    if ( *(_BYTE *)(a1 + 0x10) && a3 > 0.0 )
    {
      v9 = *(_QWORD *)(a1 + 0x58);
      LOBYTE(v25) = a2;
      *((float *)&v25 + 1) = a3;
      if ( ((*(_BYTE *)(a1 + 0x50) + (_BYTE)v9) & 1) == 0 && *(_QWORD *)(a1 + 0x48) <= (unsigned __int64)(v9 + 2) >> 1 )
        sub_1402E07D0((_QWORD *)(a1 + 0x38), 1u);
      v10 = *(_QWORD *)(a1 + 0x48);
      *(_QWORD *)(a1 + 0x50) &= 2 * v10 - 1;
      v11 = *(_QWORD *)(a1 + 0x58) + *(_QWORD *)(a1 + 0x50);
      v12 = (v11 >> 1) & (v10 - 1);
      if ( !*(_QWORD *)(*(_QWORD *)(a1 + 0x40) + 8 * v12) )
        *(_QWORD *)(*(_QWORD *)(a1 + 0x40) + 8 * v12) = allocWithProfilerInfo_w(0x10u);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x40) + 8 * v12) + 8 * (v11 & 1)) = v25;
      ++*(_QWORD *)(a1 + 0x58);
    }
    else
    {
      _XMM0 = v6;
      __asm { vpcmpeqd xmm2, xmm0, xmm1 }
      n0x3E99999A = 0x3E99999Au;
      __asm { vblendvps xmm0, xmm1, xmm3, xmm2 }
      *(float *)(a1 + 0x14) = *(float *)&_XMM0;
      v17 = a2 ^ 1;
      *(_DWORD *)(a1 + 0x18) = 0;
      _XMM0 = v17;
      __asm { vpcmpeqd xmm2, xmm0, xmm1 }
      n0x3F800000 = 0x3F800000u;
      __asm { vblendvps xmm0, xmm1, xmm3, xmm2 }
      *(_BYTE *)(a1 + 0x1C) = v17;
      *(float *)(a1 + 0xC) = *(float *)&_XMM0;
      *(_BYTE *)(a1 + 0x10) = 1;
      *(_QWORD *)a1 = 0;
      *(_DWORD *)(a1 + 8) = 0;
      sub_1402E11D0((_QWORD *)(a1 + 0x38));
    }
    v22 = *(_DWORD *)(a1 + 0x34);
    if ( v22 )
    {
      *(_DWORD *)(a1 + 0x34) = v22 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x30) = 0xFFFFFFFF;
      v23 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x20), 0, 1);
      if ( v23 == 1 )
        *(_QWORD *)(a1 + 0x28) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DB1F0(a1 + 0x20, v23);
    }
  }
  return 1;
}

// --- End Function: sub_144E2E500 (0x144E2E500) ---

// --- Function: sub_144E30AE0 (0x144E30AE0) ---
__int64 sub_144E30AE0()
{
  return qword_149E4A1A0;
}

// --- End Function: sub_144E30AE0 (0x144E30AE0) ---

// --- Function: sub_144E31650 (0x144E31650) ---
__int64 __fastcall sub_144E31650(__int64 a1, char a2)
{
  if ( a2 )
    return *(unsigned __int8 *)(a1 + 0x470);
  else
    return *(unsigned __int8 *)(a1 + 0x410);
}

// --- End Function: sub_144E31650 (0x144E31650) ---

// --- Function: sub_144E3FE20 (0x144E3FE20) ---
__int64 __fastcall sub_144E3FE20(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_144E41350(a1 + 0x70, a3, a4, a5, a6) + 1;
}

// --- End Function: sub_144E3FE20 (0x144E3FE20) ---

// --- Function: sub_144E40650 (0x144E40650) ---
__int64 __fastcall sub_144E40650(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  unsigned __int64 v5; // [rsp+20h] [rbp-48h]
  const char *p_null; // [rsp+30h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( p_null[v5] );
  *(_QWORD *)(a1 + 0x68) = v5;
  return sub_140C00860(a1 + 0x70, a3, a4) + 1;
}

// --- End Function: sub_144E40650 (0x144E40650) ---

// --- Function: sub_144E41350 (0x144E41350) ---
__int64 __fastcall sub_144E41350(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  unsigned __int64 v6; // [rsp+20h] [rbp-48h]
  const char *p_null; // [rsp+30h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E50();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v6;
  while ( p_null[v6] );
  *(_QWORD *)(a1 + 0x68) = v6;
  return sub_144E40650(a1 + 0x70, a3, a4, a5) + 1;
}

// --- End Function: sub_144E41350 (0x144E41350) ---

// --- Function: sub_144E45D10 (0x144E45D10) ---
char sub_144E45D10()
{
  __int64 v1; // [rsp+20h] [rbp-18h]

  v1 = sub_1464E7930(qword_149E7E438);
  if ( v1 )
    return sub_14647F400(v1);
  else
    return 0;
}

// --- End Function: sub_144E45D10 (0x144E45D10) ---

// --- Function: sub_144E57960 (0x144E57960) ---
__int64 __fastcall sub_144E57960(unsigned __int64 *a1, __int64 a2)
{
  __int64 result; // rax
  char v3; // al
  char v4; // al
  void *v5; // rsp
  __int64 v6; // [rsp+18h] [rbp-248h]
  _BYTE v7[480]; // [rsp+30h] [rbp-230h] BYREF
  int v9; // [rsp+264h] [rbp+4h]
  _DWORD v10[2]; // [rsp+268h] [rbp+8h] BYREF
  char v11; // [rsp+270h] [rbp+10h] BYREF
  _DWORD v12[2]; // [rsp+278h] [rbp+18h] BYREF
  char v13; // [rsp+280h] [rbp+20h] BYREF
  const char *p_pure_game; // [rsp+288h] [rbp+28h]
  const char *p_local_client; // [rsp+290h] [rbp+30h]
  unsigned __int64 v16; // [rsp+298h] [rbp+38h]
  const char *p_non_authoritative_dedicated_server; // [rsp+2A0h] [rbp+40h]
  const char *p_remote_client; // [rsp+2A8h] [rbp+48h]
  const char *p_local_client_1; // [rsp+2B0h] [rbp+50h]
  unsigned __int64 v20; // [rsp+2B8h] [rbp+58h]
  _BYTE *v21; // [rsp+2C0h] [rbp+60h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+2C8h] [rbp+68h]
  __int64 v23; // [rsp+2D0h] [rbp+70h]
  _QWORD *v24; // [rsp+2D8h] [rbp+78h]
  _QWORD *v25; // [rsp+2E0h] [rbp+80h]
  _QWORD *v26; // [rsp+2E8h] [rbp+88h]
  _QWORD *v27; // [rsp+2F0h] [rbp+90h]
  __int64 *ThreadLogContextSlot; // [rsp+2F8h] [rbp+98h]
  const void *v29; // [rsp+300h] [rbp+A0h]
  const void *v30; // [rsp+308h] [rbp+A8h]
  const void *v31; // [rsp+310h] [rbp+B0h]
  const void *v32; // [rsp+318h] [rbp+B8h]
  __int64 v33; // [rsp+320h] [rbp+C0h]
  const char *p_local_client_2; // [rsp+328h] [rbp+C8h]
  _QWORD v35[2]; // [rsp+330h] [rbp+D0h] BYREF
  const void *v36; // [rsp+340h] [rbp+E0h]
  _QWORD v37[2]; // [rsp+348h] [rbp+E8h] BYREF
  const void *v38; // [rsp+358h] [rbp+F8h]
  _QWORD v39[2]; // [rsp+360h] [rbp+100h] BYREF
  const void *v40; // [rsp+370h] [rbp+110h]
  _QWORD v41[2]; // [rsp+378h] [rbp+118h] BYREF
  const void *v42; // [rsp+388h] [rbp+128h]
  _QWORD src_[2]; // [rsp+390h] [rbp+130h] BYREF
  _QWORD src__1[2]; // [rsp+3A0h] [rbp+140h] BYREF
  _QWORD v45[3]; // [rsp+3B0h] [rbp+150h] BYREF
  _BYTE dst_[16]; // [rsp+3C8h] [rbp+168h] BYREF
  __int64 dst__1[2]; // [rsp+3D8h] [rbp+178h] BYREF

  result = (unsigned __int8)sub_144E5DE60(a1, off_149A44430);
  if ( (_BYTE)result )
  {
    if ( sub_1465D1DE0((__int64)a1) )
    {
      if ( *(_BYTE *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x2A0) )
      {
        v33 = sub_1402A24F0((__int64)&qword_149B4FBE0);
        if ( *(_BYTE *)(v33 + 0x5F6) )
          p_pure_game = "editor";
        else
          p_pure_game = "pure game";
        p_local_client = p_pure_game;
      }
      else
      {
        p_local_client = "local client";
      }
      p_local_client_1 = p_local_client;
    }
    else
    {
      if ( *(_BYTE *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x2A0) )
      {
        v16 = sub_1403E6750(a1 + 1);
        if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v16 + 0x720LL))(v16) )
          p_non_authoritative_dedicated_server = "authoritative dedicated server";
        else
          p_non_authoritative_dedicated_server = "non-authoritative dedicated server";
        p_remote_client = p_non_authoritative_dedicated_server;
      }
      else
      {
        p_remote_client = "remote client";
      }
      p_local_client_1 = p_remote_client;
    }
    p_local_client_2 = p_local_client_1;
    v3 = sub_14056A7D0(0x42);
    v10[0] = sub_142744750(v3);
    v10[1] = 0;
    src_[0] = v10;
    src_[1] = &v11;
    qmemcpy(dst_, src_, sizeof(dst_));
    v9 = invokeGlobalCallbackAndMaskStatusBits(
           5,
           (__int64)dst_,
           (__int64)"[ActorState] Ragdoll",
           "[ACTOR STATE][$$] '$$' <$$>: $$");
    if ( (v9 & 0xFFFFF) != 0 )
    {
      v41[0] = 0;
      v41[1] = a2;
      v42 = 0;
      v24 = v41;
      v39[0] = 0;
      v39[1] = p_local_client_2;
      v40 = 0;
      v25 = v39;
      v20 = sub_1403E6750(a1 + 1);
      v23 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v20 + 0x70LL))(v20);
      v37[0] = 0;
      v37[1] = v23;
      v38 = 0;
      v26 = v37;
      v35[0] = 0;
      v35[1] = "SSCActorStateCVars::LogRagdoll";
      v36 = 0;
      v27 = v35;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v45[0] = 0;
      v45[1] = 0;
      v4 = sub_14056A7D0(0x42);
      v12[0] = sub_142744750(v4);
      v12[1] = 0;
      src__1[0] = v12;
      src__1[1] = &v13;
      qmemcpy(dst__1, src__1, sizeof(dst__1));
      v45[2] = 5;
      v5 = alloca(0x230);
      v21 = v7;
      __Val_0__ = (vraudio::AudioBuffer *)v7;
      sub_144E3FE20((__int64)v7, (__int64)ThreadLogContextSlot, v27, v26, v25, v24);
      LODWORD(v6) = v9;
      sub_1403045C0(5u, dst__1, "[ActorState] Ragdoll", "[ACTOR STATE][$$] '$$' <$$>: $$", __Val_0__, 5u, 1, v6, v45, 0);
      v29 = v36;
      sub_1402A3D30(v36);
      v30 = v38;
      sub_1402A3D30(v38);
      v31 = v40;
      sub_1402A3D30(v40);
      v32 = v42;
      sub_1402A3D30(v42);
    }
    return 0;
  }
  return result;
}

// --- End Function: sub_144E57960 (0x144E57960) ---

// --- Function: sub_144E5DE60 (0x144E5DE60) ---
char __fastcall sub_144E5DE60(unsigned __int64 *a1, char *a2)
{
  char *v2; // rax
  __int64 v3; // rcx
  unsigned __int8 v4; // dl
  unsigned int v5; // eax
  const struct __crt_stdio_stream *v6; // rax
  char *v8; // rax
  __int64 v9; // rcx
  unsigned __int8 v10; // dl
  unsigned int v11; // eax
  char *v12; // rax
  __int64 v13; // rcx
  unsigned __int8 v14; // dl
  unsigned int v15; // eax
  char *v16; // rax
  __int64 v17; // rcx
  unsigned __int8 v18; // dl
  unsigned int v19; // eax
  unsigned __int8 *v20; // rax
  __int64 v21; // rcx
  unsigned __int8 v22; // dl
  unsigned int v23; // eax
  char **v24; // rax
  __int64 *v25; // rax
  char **v26; // rax
  unsigned __int8 *v27; // rax
  __int64 v28; // rcx
  unsigned __int8 v29; // dl
  unsigned int v30; // eax
  void **v31; // rax
  bool v32; // [rsp+21h] [rbp-B7h]
  void *v33; // [rsp+28h] [rbp-B0h] BYREF
  BOOL v34; // [rsp+30h] [rbp-A8h]
  int v35; // [rsp+34h] [rbp-A4h] BYREF
  unsigned __int64 v36; // [rsp+38h] [rbp-A0h]
  unsigned __int64 v37; // [rsp+40h] [rbp-98h]
  unsigned __int64 *v38; // [rsp+48h] [rbp-90h]
  std::pmr::_Identity_equal_resource *v39; // [rsp+50h] [rbp-88h] BYREF
  struct std::pmr::memory_resource *v40; // [rsp+58h] [rbp-80h]
  std::pmr::_Identity_equal_resource *v41; // [rsp+60h] [rbp-78h]
  __int64 *v42; // [rsp+68h] [rbp-70h]
  void *v43; // [rsp+70h] [rbp-68h] BYREF
  __int64 v44; // [rsp+78h] [rbp-60h]
  __int64 (__fastcall *v45)(unsigned __int64, char *); // [rsp+80h] [rbp-58h]
  __int64 v46; // [rsp+88h] [rbp-50h]
  char **v47; // [rsp+90h] [rbp-48h]
  __int64 v48; // [rsp+98h] [rbp-40h]
  __int64 v49; // [rsp+A0h] [rbp-38h] BYREF
  __int64 *v50; // [rsp+A8h] [rbp-30h]
  void *v51; // [rsp+B0h] [rbp-28h] BYREF
  void *v52; // [rsp+B8h] [rbp-20h] BYREF
  char v53[8]; // [rsp+C0h] [rbp-18h] BYREF
  char v54[16]; // [rsp+C8h] [rbp-10h] BYREF

  if ( *a2 )
  {
    v2 = a2;
    v3 = (char *)&word_1481A69AC - a2;
    while ( 1 )
    {
      v4 = *v2;
      if ( *v2 != v2[v3] )
        break;
      ++v2;
      if ( !v4 )
      {
        v5 = 0;
        goto LABEL_7;
      }
    }
    v5 = v4 < (unsigned __int8)v2[v3] ? 0xFFFFFFFF : 1;
LABEL_7:
    if ( v5 )
    {
      v6 = (const struct __crt_stdio_stream *)strtoull(a2, 0, 0);
      v40 = *(struct std::pmr::memory_resource **)_lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
                                                    (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v53,
                                                    v6);
      v38 = a1 + 1;
      sub_1403B0A70(a1 + 1, &v39);
      v41 = v39;
      if ( std::pmr::_Identity_equal_resource::do_is_equal(v39, v40) )
        return 1;
      v8 = a2;
      v9 = "2" - a2;
      while ( 1 )
      {
        v10 = *v8;
        if ( *v8 != v8[v9] )
          break;
        ++v8;
        if ( !v10 )
        {
          v11 = 0;
          goto LABEL_15;
        }
      }
      v11 = v10 < (unsigned __int8)v8[v9] ? 0xFFFFFFFF : 1;
LABEL_15:
      if ( !v11 )
        return 1;
      if ( sub_1465D1DE0((__int64)a1) )
      {
        v12 = a2;
        v13 = "1" - a2;
        while ( 1 )
        {
          v14 = *v12;
          if ( *v12 != v12[v13] )
            break;
          ++v12;
          if ( !v14 )
          {
            v15 = 0;
            goto LABEL_23;
          }
        }
        v15 = v14 < (unsigned __int8)v12[v13] ? 0xFFFFFFFF : 1;
LABEL_23:
        if ( !v15 )
          return 1;
      }
      if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64 *))(*a1 + 0x650))(a1) )
      {
        v16 = a2;
        v17 = "3" - a2;
        while ( 1 )
        {
          v18 = *v16;
          if ( *v16 != v16[v17] )
            break;
          ++v16;
          if ( !v18 )
          {
            v19 = 0;
            goto LABEL_31;
          }
        }
        v19 = v18 < (unsigned __int8)v16[v17] ? 0xFFFFFFFF : 1;
LABEL_31:
        if ( !v19 )
          return 1;
      }
      v35 = 0;
      v42 = (__int64 *)CreateStringObjectFromString(&v43, a2);
      sub_1403D8950(v42, &v33, SubStr_, &v35);
      sub_140370D10(&v43);
      while ( !sub_1403BFA30(&v33) )
      {
        v36 = sub_1403E6750(a1 + 1);
        v44 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v36 + 0x70LL))(v36);
        v20 = (unsigned __int8 *)sub_1402A2660((__int64)&v33);
        v21 = v44 - (_QWORD)v20;
        while ( 1 )
        {
          v22 = *v20;
          if ( *v20 != v20[v21] )
            break;
          ++v20;
          if ( !v22 )
          {
            v23 = 0;
            goto LABEL_40;
          }
        }
        v23 = v22 < v20[v21] ? 0xFFFFFFFF : 1;
LABEL_40:
        if ( !v23 )
          goto LABEL_41;
        sub_14035B3E0(&v49);
        v47 = v24;
        v37 = sub_1403E6750(a1 + 1);
        v45 = *(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)v37 + 8LL);
        v25 = (__int64 *)v45(v37, v54);
        v46 = sub_1402A24F0(*v25);
        v26 = sub_1403A9130(v47, "%llu", v46);
        v48 = sub_1402A2660((__int64)v26);
        v27 = (unsigned __int8 *)sub_1402A2660((__int64)&v33);
        v28 = v48 - (_QWORD)v27;
        while ( 1 )
        {
          v29 = *v27;
          if ( *v27 != v27[v28] )
            break;
          ++v27;
          if ( !v29 )
          {
            v30 = 0;
            goto LABEL_47;
          }
        }
        v30 = v29 < v27[v28] ? 0xFFFFFFFF : 1;
LABEL_47:
        v34 = v30 == 0;
        v32 = v30 == 0;
        sub_140370D10(&v49);
        if ( v32 )
        {
LABEL_41:
          sub_140370D10(&v33);
          return 1;
        }
        v50 = (__int64 *)CreateStringObjectFromString(&v52, a2);
        v31 = sub_1403D8950(v50, &v51, SubStr_, &v35);
        sub_140377F00((char **)&v33, (char **)v31);
        sub_140370D10(&v51);
        sub_140370D10(&v52);
      }
      sub_140370D10(&v33);
    }
  }
  return 0;
}

// --- End Function: sub_144E5DE60 (0x144E5DE60) ---

// --- Function: fabs_w_13 (0x144EDF3D0) ---
bool __fastcall fabs_w_13(__int64 a1)
{
  return fabs(*(float *)(a1 + 0x14) - *(float *)(a1 + 0x10)) >= 6.2831855;
}

// --- End Function: fabs_w_13 (0x144EDF3D0) ---

// --- Function: fabs_w_14 (0x144EDF3F0) ---
bool __fastcall fabs_w_14(__int64 a1)
{
  return fabs(*(float *)(a1 + 0xC) - *(float *)(a1 + 8)) >= 6.2831855;
}

// --- End Function: fabs_w_14 (0x144EDF3F0) ---

// --- Function: sub_145627EF0 (0x145627EF0) ---
char __fastcall sub_145627EF0(__int64 a1, __int64 a2, int n2)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  int v7; // eax
  __int64 v9; // [rsp+48h] [rbp+20h] BYREF

  if ( n2 != 2 )
    return 0;
  sub_1403B27D0(a1, &v9);
  if ( !Handle::IsValid(&v9) )
    return 0;
  v4 = sub_142705160(&v9);
  v5 = sub_1457CC9F0(v4);
  if ( !v5 )
    return 0;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0xD8LL))(v5);
  v7 = sub_1404A9260(*(_QWORD **)(*(_QWORD *)v6 + 0x18LL), dword_149E5D070, 0, 0);
  if ( v7 == 0xFFFFFFFF )
    return 0;
  *(_OWORD *)(a2 + 0x30) = 0;
  *(_DWORD *)(a2 + 0x28) = 4;
  *(_DWORD *)(a2 + 0x2C) = v7;
  *(_DWORD *)(a2 + 0x50) = sub_1404BAD90();
  return 1;
}

// --- End Function: sub_145627EF0 (0x145627EF0) ---

// --- Function: sub_1457CC9F0 (0x1457CC9F0) ---
__int64 __fastcall sub_1457CC9F0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xB0);
}

// --- End Function: sub_1457CC9F0 (0x1457CC9F0) ---

// --- Function: sub_1457E2510 (0x1457E2510) ---
void __fastcall sub_1457E2510(__crt_win32_buffer_debug_info *a1, __int64 a2, int a3, float *a4, int a5, int a6)
{
  const char *v10; // rbx
  unsigned __int64 *v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  int v15; // [rsp+40h] [rbp-E8h] BYREF
  __int64 v16; // [rsp+48h] [rbp-E0h] BYREF
  _QWORD v17[3]; // [rsp+50h] [rbp-D8h] BYREF
  __int64 v18; // [rsp+68h] [rbp-C0h] BYREF
  _QWORD v19[5]; // [rsp+78h] [rbp-B0h] BYREF
  int v20; // [rsp+A0h] [rbp-88h]
  float v21; // [rsp+C8h] [rbp-60h]
  char v22; // [rsp+E8h] [rbp-40h]
  float v23; // [rsp+ECh] [rbp-3Ch]

  v10 = __crt_win32_buffer_debug_info::file_name(a1);
  if ( (*(unsigned __int8 (__fastcall **)(const char *))(*(_QWORD *)v10 + 0x650LL))(v10) )
  {
    if ( !sub_145843670((__int64)a1) )
    {
      sub_1457B7BF0((__int64)v10, &v16);
      if ( is_valid_handle_typeA(&v16) )
      {
        sub_1443C9C40((__int64)v17);
        v15 = 0xFFFFFFFF;
        v11 = (unsigned __int64 *)sub_14030ECF0(&v16);
        if ( sub_145086FF0(v11, dword_149E63C00, a3, a4, a5, a6, (__int64)v19, &v15) )
        {
          v12 = *(_QWORD *)v10;
          LODWORD(v19[0]) = 6;
          if ( (*(unsigned __int8 (__fastcall **)(const char *))(v12 + 0x660))(v10)
            && *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2 + 0x28) + 0x48) )
          {
            v13 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2 + 0x28);
            sub_141B8AAC0((__int64)v19, dword_149E63C04, v13 + 0x10);
          }
          v14 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2 + 0x40);
          if ( HIDWORD(v19[0]) == *(_DWORD *)(v14 + 4)
            && v19[1] == *(_QWORD *)(v14 + 8)
            && v19[2] == *(_QWORD *)(v14 + 0x10)
            && v19[3] == *(_QWORD *)(v14 + 0x18)
            && v19[4] == *(_QWORD *)(v14 + 0x20)
            && v20 == *(_DWORD *)(v14 + 0x28)
            && v23 == *(float *)(v14 + 0x74)
            && v21 == *(float *)(v14 + 0x50) )
          {
            v22 = *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a2 + 0x40) + 0x70)
                + 1;
          }
          sub_1457B48D0((__int64)a1, v17, "CSCActorControlStateKnockback::RemoteClientPlayReaction");
        }
        sub_141976650(v19);
        sub_140370D10(&v18);
      }
    }
  }
}

// --- End Function: sub_1457E2510 (0x1457E2510) ---

// --- Function: sub_1457F2560 (0x1457F2560) ---
__int64 __fastcall sub_1457F2560(__int64 a1)
{
  __int64 v2; // [rsp+20h] [rbp-18h]

  v2 = allocWithProfilerInfo_w(0x28u);
  if ( !v2 )
    return 0;
  sub_1448FBB10(v2, a1);
  return v2;
}

// --- End Function: sub_1457F2560 (0x1457F2560) ---

// --- Function: sub_1457F26B0 (0x1457F26B0) ---
_BOOL8 __fastcall sub_1457F26B0(double *a1, double *a2)
{
  double v2; // xmm0_8
  double X; // [rsp+28h] [rbp-70h]

  X = fabs(*a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2] + a1[3] * a2[3]);
  if ( X >= 1.0 )
    v2 = acos(1.0);
  else
    v2 = acos(X);
  return v2 <= 0.5;
}

// --- End Function: sub_1457F26B0 (0x1457F26B0) ---

// --- Function: ?_Swap@?$_Ptr_base@V__ExceptionPtr@@@std@@QEAAXAEAV12@@Z_1 (0x1457F2840) ---
_BOOL8 __fastcall std::_Ptr_base<__ExceptionPtr>::_Swap(__int64 a1, __int64 a2)
{
  return sub_1457F26B0((double *)(a1 + 8), (double *)(a2 + 8));
}

// --- End Function: ?_Swap@?$_Ptr_base@V__ExceptionPtr@@@std@@QEAAXAEAV12@@Z_1 (0x1457F2840) ---

// --- Function: sub_1457F2870 (0x1457F2870) ---
int __fastcall sub_1457F2870(double *a1, wchar_t *a2, size_t Count)
{
  return swprintf(a2, Count, "{\"v\":{\"x\":%f,\"y\":%f,\"z\":%f},\"w\":%f}", a1[1], a1[2], a1[3], a1[4]);
}

// --- End Function: sub_1457F2870 (0x1457F2870) ---

// --- Function: sub_1457F28F0 (0x1457F28F0) ---
__int64 __fastcall sub_1457F28F0(__int64 a1, __int64 a2, size_t a3, __int64 a4, int a5, double a6)
{
  int v7; // [rsp+50h] [rbp-78h]
  int v9; // [rsp+58h] [rbp-70h]
  double v10[3]; // [rsp+60h] [rbp-68h] BYREF
  __int128 v11; // [rsp+78h] [rbp-50h] BYREF
  const char *p_f; // [rsp+88h] [rbp-40h]
  __int128 v13; // [rsp+90h] [rbp-38h] BYREF
  const char *p_f_1; // [rsp+A0h] [rbp-28h]
  __int128 v15; // [rsp+A8h] [rbp-20h] BYREF
  const char *p_f_2; // [rsp+B8h] [rbp-10h]

  v10[0] = *(double *)(a1 + 0x18);
  v10[1] = a6;
  *(_QWORD *)&v10[2] = "f";
  *(_QWORD *)&v11 = *(_QWORD *)(a1 + 0x10);
  *((double *)&v11 + 1) = a6;
  p_f = "f";
  *(_QWORD *)&v13 = *(_QWORD *)(a1 + 8);
  *((double *)&v13 + 1) = a6;
  p_f_1 = "f";
  *(_QWORD *)&v15 = *(_QWORD *)a1;
  *((double *)&v15 + 1) = a6;
  p_f_2 = "f";
  v7 = sub_140305D50(a2, a3, 0, "v.x: ", 5u);
  if ( v7 >= 0 )
  {
    v9 = sub_142F62DB0(a2, a3, v7, &v15, ", v.y: ", &v13, ", v.z: ", &v11, ", w: ", v10);
    if ( v9 >= 0 )
      return (unsigned int)(v9 + v7);
    else
      return 0xFFFFFFFF;
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

// --- End Function: sub_1457F28F0 (0x1457F28F0) ---

// --- Function: sub_1457F2AB0 (0x1457F2AB0) ---
__int64 __fastcall sub_1457F2AB0(__int64 a1, __int64 a2, size_t a3, __int64 a4, char a5, double a6)
{
  int v7; // [rsp+20h] [rbp-18h]

  LOBYTE(v7) = a5;
  return sub_1457F28F0(a1 + 8, a2, a3, a4, v7, a6);
}

// --- End Function: sub_1457F2AB0 (0x1457F2AB0) ---

// --- Function: sub_145822E10 (0x145822E10) ---
const ULONG_PTR *__fastcall sub_145822E10(__int64 a1, _QWORD *a2, _BYTE *a3)
{
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 *v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rbx
  __int64 (__fastcall *v11)(_QWORD *, __int64, _QWORD, __int64); // rsi
  __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  volatile signed __int64 *v14; // rbx
  char v15; // r12
  int v16; // edi
  __int64 v17; // r8
  unsigned __int64 v18; // rax
  __int64 *v19; // rbx
  unsigned __int8 (__fastcall ***v20)(_QWORD); // rsi
  char v21; // di
  char n9; // al
  __int64 v23; // rax
  volatile signed __int32 *v24; // rdi
  __int128 *v25; // rdx
  __int128 *v26; // rdx
  Parameter *Parameter_1; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 n0x10; // rax
  volatile signed __int32 *v31; // rsi
  __int64 v32; // rsi
  unsigned int v33; // r13d
  unsigned int i; // edi
  void (__fastcall *v35)(_QWORD *, __int64); // rbx
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rbx
  __int64 v39; // r8
  Parameter *Parameter_2; // rcx
  __int64 v41; // rdi
  __int64 *v42; // rdx
  __int64 v43; // rbx
  __int64 v44; // rdi
  __int64 v45; // rbx
  __int64 v46; // rcx
  __int64 v47; // rax
  __int64 v48; // rcx
  __int64 v49; // rax
  __int64 v51; // rcx
  int v52; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v54; // [rsp+30h] [rbp-50h] BYREF
  __int64 v55; // [rsp+38h] [rbp-48h]
  __int128 v56; // [rsp+40h] [rbp-40h] BYREF
  __int128 v57; // [rsp+50h] [rbp-30h] BYREF
  Parameter *Parameter; // [rsp+60h] [rbp-20h]
  __int64 v59; // [rsp+68h] [rbp-18h]
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // [rsp+70h] [rbp-10h]
  int v61; // [rsp+78h] [rbp-8h] BYREF
  __int64 v62; // [rsp+C0h] [rbp+40h] BYREF
  _BYTE *v63; // [rsp+D0h] [rbp+50h]

  v63 = a3;
  v62 = a1;
  if ( sub_1465D1DE0(*(_QWORD *)(a1 + 8)) )
    goto LABEL_7;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = sub_14030EC00((unsigned __int64 *)(v6 + 8)) ? *(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFLL : 0LL;
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x720LL))(v7)
    || (v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                          qword_149B4FC40,
                          0),
        v9 = *(_QWORD *)(a1 + 0x3500),
        v10 = *v8,
        v11 = *(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD, __int64))(*a2 + 8LL),
        v12 = sub_14601F8F0(a1 + 0x3510),
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)v11(a2, v10, **(_QWORD **)(v12 + 0x150), v9),
        !(_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source) )
  {
LABEL_7:
    v14 = (volatile signed __int64 *)(a1 + 0x3538);
    Parameter = (__int64 **)(a1 + 0x3520);
    v59 = a1 + 0x3538;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const ULONG_PTR *)&v61;
    v15 = 1;
    v61 = 1;
    v16 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x3548) == v16 )
    {
      ++*(_DWORD *)(a1 + 0x354C);
    }
    else
    {
      v17 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v18 = _InterlockedCompareExchange64(v14, 0x200000, 0);
      if ( v18 )
        sub_1403DCD60(
          (__int64)v14,
          v18,
          v17,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          1);
      else
        *(_QWORD *)(a1 + 0x3540) = v17;
      *(_DWORD *)(a1 + 0x3548) = v16;
    }
    v19 = *Parameter;
    if ( *Parameter != Parameter[1] )
    {
      while ( 1 )
      {
        v20 = (unsigned __int8 (__fastcall ***)(_QWORD))*v19;
        v21 = (*(__int64 (__fastcall **)(_QWORD *))*a2)(a2);
        if ( (**v20)(v20) != v21 )
        {
          Parameter_1 = (Parameter *)Parameter;
          goto LABEL_40;
        }
        n9 = (*(__int64 (__fastcall **)(_QWORD *))*a2)(a2);
        if ( !n9 )
          break;
        if ( n9 == 7 )
        {
          v28 = allocWithProfilerInfo_w(0xC0u);
          v24 = (volatile signed __int32 *)v28;
          if ( v28 )
          {
            *(_DWORD *)(v28 + 8) = 1;
            *(_DWORD *)(v28 + 0xC) = 1;
            *(_QWORD *)v28 = off_148AEB420;
            sub_145829FB0(v28 + 0x10, (__int64)a2);
            *((_QWORD *)&v57 + 1) = v24;
            *(_QWORD *)&v57 = v24 + 4;
            v25 = &v57;
LABEL_20:
            sub_142704BB0(v19, v25);
LABEL_21:
            if ( _InterlockedExchangeAdd(v24 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v24)(v24);
              if ( _InterlockedExchangeAdd(v24 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v24 + 8LL))(v24);
            }
            goto LABEL_26;
          }
          v57 = xmmword_1482B5800;
          v26 = &v57;
        }
        else
        {
          if ( n9 != 9 )
            goto LABEL_64;
          v23 = allocWithProfilerInfo_w(0xC0u);
          v24 = (volatile signed __int32 *)v23;
          if ( v23 )
          {
            *(_DWORD *)(v23 + 8) = 1;
            *(_DWORD *)(v23 + 0xC) = 1;
            *(_QWORD *)v23 = off_148AEB420;
            sub_145829FB0(v23 + 0x10, (__int64)a2);
            *((_QWORD *)&v56 + 1) = v24;
            *(_QWORD *)&v56 = v24 + 4;
            v25 = &v56;
            goto LABEL_20;
          }
          v56 = xmmword_1482B5800;
          v26 = &v56;
        }
        sub_142704BB0(v19, v26);
LABEL_26:
        assignCStringToStringStructure((void **)(*v19 + 0x18), a3);
        Parameter_1 = (Parameter *)Parameter;
        v15 = 0;
        v19 = Parameter[1] + 0xFFFFFFFE;
LABEL_40:
        v19 += 2;
        if ( v19 == *((__int64 **)Parameter_1 + 1) )
          goto LABEL_41;
      }
      v29 = allocWithProfilerInfo_w(0xC0u);
      v24 = (volatile signed __int32 *)v29;
      if ( v29 )
      {
        *(_DWORD *)(v29 + 8) = 1;
        *(_DWORD *)(v29 + 0xC) = 1;
        *(_QWORD *)v29 = off_148AEB420;
        sub_145829FB0(v29 + 0x10, (__int64)a2);
        n0x10 = (__int64)(v24 + 4);
        _InterlockedIncrement(v24 + 2);
      }
      else
      {
        v24 = 0;
        n0x10 = 0x10;
      }
      v31 = (volatile signed __int32 *)v19[1];
      *v19 = n0x10;
      v19[1] = (__int64)v24;
      if ( v31 )
      {
        if ( _InterlockedExchangeAdd(v31 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v31)(v31);
          if ( _InterlockedExchangeAdd(v31 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v31 + 8LL))(v31);
        }
      }
      if ( !v24 )
        goto LABEL_26;
      goto LABEL_21;
    }
LABEL_41:
    v32 = v62;
    v33 = sub_146054F00(v62 + 0x3510);
    for ( i = 0; i < v33; ++i )
    {
      v35 = *(void (__fastcall **)(_QWORD *, __int64))(*a2 + 0x10LL);
      v36 = sub_145F95DB0(v32 + 0x3510, i);
      v35(a2, v36);
    }
    if ( v15 )
    {
      v37 = allocWithProfilerInfo_w(0xC0u);
      v38 = v37;
      if ( v37 )
      {
        *(_DWORD *)(v37 + 8) = 1;
        *(_DWORD *)(v37 + 0xC) = 1;
        *(_QWORD *)v37 = off_148AEB420;
        sub_145829FB0(v37 + 0x10, (__int64)a2);
        v39 = 0;
      }
      else
      {
        v39 = 0;
        v38 = 0;
      }
      Parameter_2 = (Parameter *)Parameter;
      v54 = v38 + 0x10;
      v41 = v38;
      v55 = v38;
      v42 = Parameter[1];
      if ( v42 == Parameter[2] )
      {
        sub_1427C1BD0((Parameter *)Parameter, v42, &v54);
      }
      else
      {
        *v42 = 0;
        v42[1] = 0;
        if ( v38 )
        {
          _InterlockedIncrement((volatile signed __int32 *)(v38 + 8));
          v41 = v55;
        }
        *v42 = v38 + 0x10;
        v42[1] = v38;
        *((_QWORD *)Parameter_2 + 1) += 0x10LL;
      }
      if ( v41 )
      {
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v41 + 8), 0xFFFFFFFF) == 1 )
        {
          v43 = v55;
          (**(void (__fastcall ***)(__int64, __int64 *, __int64))v55)(v55, v42, v39);
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v43 + 0xC), 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v55 + 8LL))(v55);
        }
      }
      assignCStringToStringStructure((void **)(Parameter[1][0xFFFFFFFE] + 0x18), v63);
    }
    v44 = v62;
    v45 = *(_QWORD *)(v62 + 8);
    if ( sub_14030EC00((unsigned __int64 *)(v45 + 8)) )
      v46 = *(_QWORD *)(v45 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v46 = 0;
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v46 + 0x720LL))(v46) )
    {
      v47 = *(_QWORD *)(v44 + 0x3508);
      if ( v47 )
      {
        v62 = **(_QWORD **)(v47 + 0x150);
        if ( sub_140597650(a2 + 1, &v62) )
        {
          v48 = *(_QWORD *)(v44 + 0x3508);
          v49 = a2[1];
          *(_QWORD *)(v48 + 0x10) |= 0x4000000000uLL;
          **(_QWORD **)(v48 + 0x150) = v49;
        }
      }
    }
LABEL_64:
    p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    if ( (*(_DWORD *)p_p_p_p_p_p_p_p_p_p_p_p_Source_1)-- == 1 )
    {
      v51 = v59;
      v52 = *(_DWORD *)(v59 + 0x14);
      if ( v52 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v52 - 1);
        *(_DWORD *)(v59 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        *(_DWORD *)(v59 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v51, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v51 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          return sub_1403DD380(v51, n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_145822E10 (0x145822E10) ---

// --- Function: sub_14583AFE0 (0x14583AFE0) ---
__int64 __fastcall sub_14583AFE0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 8);
  if ( sub_14030EC00((unsigned __int64 *)(v1 + 8)) )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  else
    return (*(__int64 (**)(void))(MEMORY[0] + 0x720LL))();
}

// --- End Function: sub_14583AFE0 (0x14583AFE0) ---

// --- Function: sub_14583B030 (0x14583B030) ---
char __fastcall sub_14583B030(__int64 a1)
{
  return sub_1465D1DE0(*(_QWORD *)(a1 + 8));
}

// --- End Function: sub_14583B030 (0x14583B030) ---

// --- Function: sub_14583F430 (0x14583F430) ---
__int64 __fastcall sub_14583F430(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 0x3508);
  if ( !result )
    return sub_14601FAD0(a1 + 0x3510);
  return result;
}

// --- End Function: sub_14583F430 (0x14583F430) ---

// --- Function: sub_14583F5E0 (0x14583F5E0) ---
__int64 __fastcall sub_14583F5E0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x3368);
}

// --- End Function: sub_14583F5E0 (0x14583F5E0) ---

// --- Function: sub_1458402C0 (0x1458402C0) ---
_QWORD *__fastcall sub_1458402C0(__int64 a1, _QWORD *a2)
{
  *a2 = **(_QWORD **)(*(_QWORD *)(a1 + 0x3508) + 0x150LL);
  return a2;
}

// --- End Function: sub_1458402C0 (0x1458402C0) ---

// --- Function: sub_1458409B0 (0x1458409B0) ---
char __fastcall sub_1458409B0(__int64 a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  float v11; // xmm0_4
  unsigned __int64 v13; // [rsp+38h] [rbp+10h] BYREF

  v4 = *(_QWORD *)(a2 + 8);
  if ( sub_14030EC00((unsigned __int64 *)(v4 + 8)) )
    v7 = *(_QWORD *)(v4 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v7 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v7 + 0x3B8LL))(v7, &v13);
  if ( v13 && *(_QWORD *)((v13 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v13) )
    (*(void (__fastcall **)(unsigned __int64, __int64))(*(_QWORD *)(v13 & 0xFFFFFFFFFFFFLL) + 0x20LL))(
      v13 & 0xFFFFFFFFFFFFLL,
      a4);
  v8 = *a3;
  if ( *a3 )
  {
    *(_DWORD *)(a4 + 0x1C) = *(_DWORD *)(v8 + 0x60);
    v9 = *a3;
    *(double *)(a4 + 0x10) = *(double *)(*a3 + 0x98);
    *(_DWORD *)(a4 + 0x18) = *(_DWORD *)(v9 + 0xA0);
    v10 = *a3;
    *(double *)(a4 + 4) = *(double *)(*a3 + 0x80);
    *(_DWORD *)(a4 + 0xC) = *(_DWORD *)(v10 + 0x88);
    *(_DWORD *)(a4 + 0x34) = *(_DWORD *)(*a3 + 0x64);
    v11 = *(float *)(*a3 + 0x74);
    *(_DWORD *)(a4 + 0x38) = *(_DWORD *)(*a3 + 0x70);
    *(float *)(a4 + 0x3C) = v11;
    *(_DWORD *)(a4 + 0x40) = 0;
    *(_DWORD *)(a4 + 0x30) = 1;
    v8 = *a3;
    *(double *)(a4 + 0x48) = *(double *)(*a3 + 0xB0);
    *(_DWORD *)(a4 + 0x50) = *(_DWORD *)(v8 + 0xB8);
    LOBYTE(v8) = 1;
    *(_DWORD *)(a4 + 0x54) = *(_DWORD *)(*a3 + 0x108);
  }
  return v8;
}

// --- End Function: sub_1458409B0 (0x1458409B0) ---

// --- Function: sub_145840AD0 (0x145840AD0) ---
char __fastcall sub_145840AD0(__int64 a1, __int64 a2)
{
  return sub_1458409B0(a1 + 0x32F0, a1, *(__int64 **)(a1 + 0x3368), a2);
}

// --- End Function: sub_145840AD0 (0x145840AD0) ---

// --- Function: sub_145840E80 (0x145840E80) ---
_QWORD *__fastcall sub_145840E80(__int64 a1, _QWORD *a2)
{
  *a2 = **(_QWORD **)(sub_14601F8F0(a1 + 0x3510) + 0x150);
  return a2;
}

// --- End Function: sub_145840E80 (0x145840E80) ---

// --- Function: sub_145843B60 (0x145843B60) ---
bool __fastcall sub_145843B60(__int64 a1)
{
  char v1; // dl

  v1 = *(_BYTE *)(a1 + 0x70);
  return (unsigned __int8)(v1 - 2) <= 1u || (unsigned __int8)(v1 - 0x26) <= 2u;
}

// --- End Function: sub_145843B60 (0x145843B60) ---

// --- Function: sub_145843D90 (0x145843D90) ---
bool __fastcall sub_145843D90(__int64 a1)
{
  return *(_BYTE *)(a1 + 0x70) == 1;
}

// --- End Function: sub_145843D90 (0x145843D90) ---

// --- Function: sub_145843E20 (0x145843E20) ---
bool __fastcall sub_145843E20(__int64 a1)
{
  return *(_BYTE *)(a1 + 0x70) == 0xD;
}

// --- End Function: sub_145843E20 (0x145843E20) ---

// --- Function: sub_145847EE0 (0x145847EE0) ---
__int64 __fastcall sub_145847EE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 0x3508);
  if ( v2 )
  {
    *(_QWORD *)(v2 + 0x10) |= 0x1000000000uLL;
    v3 = *(_QWORD *)(v2 + 0x140);
    *(_QWORD *)v3 = *(_QWORD *)a2;
    *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 0x28);
    *(double *)(v3 + 0x18) = *(double *)(a2 + 0x38);
    _XMM3 = *(unsigned __int64 *)(a2 + 0x20);
    _XMM0 = *(unsigned __int64 *)(a2 + 8);
    _XMM1 = *(unsigned __int64 *)(a2 + 0x10);
    _XMM2 = *(unsigned __int64 *)(a2 + 0x18);
    __asm { vcvtpd2ps xmm3, xmm3 }
    *(float *)(v3 + 0x2C) = *(float *)&_XMM3;
    __asm { vcvtpd2ps xmm0, xmm0 }
    *(float *)(v3 + 0x20) = *(float *)&_XMM0;
    __asm { vcvtpd2ps xmm1, xmm1 }
    *(float *)(v3 + 0x24) = *(float *)&_XMM1;
    __asm { vcvtpd2ps xmm2, xmm2 }
    *(float *)(v3 + 0x28) = *(float *)&_XMM2;
    *(_DWORD *)(v3 + 0x3C) = *(_DWORD *)(a2 + 0x60);
    *(_DWORD *)(v3 + 0x40) = *(_DWORD *)(a2 + 0x64);
    *(_DWORD *)(v3 + 0x44) = *(_DWORD *)(a2 + 0x68);
    result = *(unsigned int *)(a2 + 0x6C);
    *(_DWORD *)(v3 + 0x48) = result;
  }
  return result;
}

// --- End Function: sub_145847EE0 (0x145847EE0) ---

// --- Function: sub_145847F70 (0x145847F70) ---
void __fastcall sub_145847F70(__int64 a1, char a2, float a3)
{
  *(float *)(a1 + 0x35BC) = a3;
  *(_BYTE *)(a1 + 0x35B8) = a2;
}

// --- End Function: sub_145847F70 (0x145847F70) ---

// --- Function: sub_14584B890 (0x14584B890) ---
_QWORD *__fastcall sub_14584B890(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *result; // rax

  v2 = *(_QWORD *)(a1 + 0x3508);
  *(_QWORD *)(v2 + 0x10) |= 0x4000000000uLL;
  result = *(_QWORD **)(v2 + 0x150);
  *result = a2;
  return result;
}

// --- End Function: sub_14584B890 (0x14584B890) ---

// --- Function: sub_145873400 (0x145873400) ---
void __fastcall sub_145873400(__crt_win32_buffer_debug_info *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4[112]; // [rsp+40h] [rbp-398h] BYREF

  if ( *(_BYTE *)(a4 + 0x19) )
  {
    sub_1443C8F60((__int64)v4);
    if ( sub_145874F00(a1, a2, a3, (__int64)v4, a4) )
    {
      sub_14584F8C0(a2, (__int64)v4, "CSCActorControlStateForceReactions::HandleForceReactionEventRemote");
      sub_14585FF80((__int64)a1, (__int64)v4);
    }
    sub_1443CBE20(v4);
  }
}

// --- End Function: sub_145873400 (0x145873400) ---

// --- Function: sub_145880800 (0x145880800) ---
void __fastcall sub_145880800(__crt_win32_buffer_debug_info *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  const char *v4; // [rsp+28h] [rbp-150h]
  _QWORD v5[3]; // [rsp+30h] [rbp-148h] BYREF
  __int64 v6; // [rsp+48h] [rbp-130h] BYREF
  char v7; // [rsp+58h] [rbp-120h]
  _QWORD v8[15]; // [rsp+E0h] [rbp-98h] BYREF
  char v9; // [rsp+158h] [rbp-20h]

  v4 = __crt_win32_buffer_debug_info::file_name(a1);
  v3 = std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(a3 + 0xA8);
  if ( (unsigned __int8)sub_14587B370((__int64)v4, v3 + 8) )
  {
    sub_1443C8D70((__int64)v5);
    if ( (unsigned __int8)sub_145851870(a2, v5, 1) )
    {
      v7 = 1;
      v9 = 0;
      sub_14584EEE0(a2, v5, "CSCActorControlStateForceReactionStagger::ProcessEventCheckBounceRemote");
    }
    sub_141976650(v8);
    sub_140370D10(&v6);
  }
}

// --- End Function: sub_145880800 (0x145880800) ---

// --- Function: sub_1458817A0 (0x1458817A0) ---
void __fastcall sub_1458817A0(__crt_win32_buffer_debug_info *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // [rsp+28h] [rbp-230h]
  __int64 v5; // [rsp+30h] [rbp-228h]
  const char *v6; // [rsp+38h] [rbp-220h]
  __int64 v7; // [rsp+48h] [rbp-210h]
  _BYTE v8[8]; // [rsp+78h] [rbp-1E0h] BYREF
  double v9[4]; // [rsp+80h] [rbp-1D8h] BYREF
  _BYTE dst_[24]; // [rsp+A0h] [rbp-1B8h] BYREF
  _BYTE v11[72]; // [rsp+B8h] [rbp-1A0h] BYREF
  _QWORD v12[3]; // [rsp+100h] [rbp-158h] BYREF
  __int64 v13; // [rsp+118h] [rbp-140h] BYREF
  char v14; // [rsp+128h] [rbp-130h]
  _BYTE v15[56]; // [rsp+170h] [rbp-E8h] BYREF
  __int64 v16; // [rsp+1A8h] [rbp-B0h]
  _QWORD v17[15]; // [rsp+1B0h] [rbp-A8h] BYREF
  char v18; // [rsp+228h] [rbp-30h]
  char v19; // [rsp+229h] [rbp-2Fh]

  v6 = __crt_win32_buffer_debug_info::file_name(a1);
  sub_1443C8D70((__int64)v12);
  v4 = sub_1403E6750((unsigned __int64 *)v6 + 1);
  v7 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)v4 + 0x660LL))(v4, v8);
  v9[0] = 0.0;
  v9[1] = 0.0;
  v9[2] = 0.0;
  v9[3] = 1.0;
  qmemcpy(dst_, (const void *)(a4 + 8), sizeof(dst_));
  v5 = sub_14036F270((__int64)v11, (__int64)v9, v7);
  sub_14030DE50((__int64)v15, v5);
  v16 = *(_QWORD *)(v5 + 0x38);
  v19 = 1;
  v14 = 0;
  v18 = 1;
  sub_14584EEE0(a2, v12, "CSCActorControlStateForceReactionStagger::ProcessEventStaggerRelativeDelayedRemote");
  sub_141976650(v17);
  sub_140370D10(&v13);
}

// --- End Function: sub_1458817A0 (0x1458817A0) ---

// --- Function: sub_145881990 (0x145881990) ---
void __fastcall sub_145881990(__crt_win32_buffer_debug_info *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 *v4; // rax
  double *v5; // [rsp+30h] [rbp-2D8h]
  const char *v6; // [rsp+38h] [rbp-2D0h]
  unsigned __int64 v7; // [rsp+40h] [rbp-2C8h]
  __int64 v8; // [rsp+48h] [rbp-2C0h]
  unsigned __int64 v9; // [rsp+50h] [rbp-2B8h]
  unsigned __int64 v10; // [rsp+58h] [rbp-2B0h]
  __int64 v11; // [rsp+68h] [rbp-2A0h]
  __int64 v12; // [rsp+90h] [rbp-278h]
  _BYTE v13[8]; // [rsp+A0h] [rbp-268h] BYREF
  _BYTE v14[8]; // [rsp+A8h] [rbp-260h] BYREF
  double v15[4]; // [rsp+B0h] [rbp-258h] BYREF
  _BYTE dst_[24]; // [rsp+D0h] [rbp-238h] BYREF
  _BYTE v17[64]; // [rsp+E8h] [rbp-220h] BYREF
  _BYTE v18[64]; // [rsp+128h] [rbp-1E0h] BYREF
  _BYTE v19[72]; // [rsp+168h] [rbp-1A0h] BYREF
  _QWORD v20[3]; // [rsp+1B0h] [rbp-158h] BYREF
  __int64 v21; // [rsp+1C8h] [rbp-140h] BYREF
  char v22; // [rsp+1D8h] [rbp-130h]
  _BYTE v23[56]; // [rsp+1E0h] [rbp-128h] BYREF
  __int64 v24; // [rsp+218h] [rbp-F0h]
  _BYTE v25[56]; // [rsp+220h] [rbp-E8h] BYREF
  __int64 v26; // [rsp+258h] [rbp-B0h]
  _QWORD v27[15]; // [rsp+260h] [rbp-A8h] BYREF
  char v28; // [rsp+2D8h] [rbp-30h]
  char v29; // [rsp+2D9h] [rbp-2Fh]

  v6 = __crt_win32_buffer_debug_info::file_name(a1);
  sub_1443C8D70((__int64)v20);
  v7 = sub_1403E6750((unsigned __int64 *)v6 + 1);
  v4 = (__int64 *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)v7 + 0x660LL))(v7, v13);
  v8 = sub_14036F270((__int64)v17, a4 + 8, *v4);
  sub_14030DE50((__int64)v25, v8);
  v26 = *(_QWORD *)(v8 + 0x38);
  v9 = sub_1403E6750((unsigned __int64 *)v6 + 1);
  v12 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)v9 + 0x660LL))(v9, v14);
  v10 = sub_1403E6750((unsigned __int64 *)v6 + 1);
  v5 = (double *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *, _QWORD))(*(_QWORD *)v10 + 0x268LL))(v10, v18, 0);
  v15[3] = v5[3];
  v15[0] = *v5;
  v15[1] = v5[1];
  v15[2] = v5[2];
  qmemcpy(dst_, v5 + 4, sizeof(dst_));
  v11 = sub_14036F270((__int64)v19, (__int64)v15, v12);
  sub_14030DE50((__int64)v23, v11);
  v24 = *(_QWORD *)(v11 + 0x38);
  sub_141A63B10((__int64)v27, a4 + 0x40);
  v29 = 0;
  if ( (unsigned __int8)sub_14587B370((__int64)v6, (__int64)v25) )
  {
    v22 = 1;
    v28 = 0;
  }
  else
  {
    v22 = 0;
    v28 = 1;
  }
  sub_14584EEE0(a2, v20, "CSCActorControlStateForceReactionStagger::ProcessEventStaggerRemote");
  sub_141976650(v27);
  sub_140370D10(&v21);
}

// --- End Function: sub_145881990 (0x145881990) ---

// --- Function: sub_145A23190 (0x145A23190) ---
char __fastcall sub_145A23190(
        unsigned int n4,
        __int64 *a2,
        char *p_Actor_Teleport,
        char *$$:_Teleporting_actor__$$__[$$]_($$)_from_Z$$_W$$_[Zone_$$]_to,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 *ThreadLogContextSlot,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12,
        _QWORD *a13,
        _QWORD *a14,
        _QWORD *a15,
        _QWORD *a16,
        _QWORD *a17,
        _QWORD *a18,
        _QWORD *a19,
        _QWORD *a20,
        _QWORD *a21,
        _QWORD *a22,
        _QWORD *a23,
        _QWORD *a24)
{
  void *v28; // rsp
  const char *p_null; // rdx
  const char *p_null_1; // rcx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rax
  __int64 v34; // [rsp+18h] [rbp-738h]
  _QWORD __Val_0___[11]; // [rsp+50h] [rbp-700h] BYREF
  __int16 n0x100; // [rsp+A8h] [rbp-6A8h]
  __int64 n0xB0; // [rsp+B0h] [rbp-6A0h]
  __int64 n0xA8; // [rsp+B8h] [rbp-698h]
  _QWORD *v39; // [rsp+C0h] [rbp-690h]
  const char *p_Function; // [rsp+C8h] [rbp-688h]
  __int64 v41; // [rsp+D0h] [rbp-680h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+D8h] [rbp-678h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+E0h] [rbp-670h]
  __int64 v44; // [rsp+E8h] [rbp-668h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+F0h] [rbp-660h]
  __int64 v46; // [rsp+F8h] [rbp-658h]
  __int64 (__fastcall *p_sub_1403E4E80)(const void **); // [rsp+100h] [rbp-650h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+108h] [rbp-648h]
  unsigned __int64 v49; // [rsp+110h] [rbp-640h]
  char v50; // [rsp+118h] [rbp-638h]
  char v51; // [rsp+119h] [rbp-637h]
  __int64 n0x18; // [rsp+120h] [rbp-630h]
  unsigned __int64 v53; // [rsp+128h] [rbp-628h]
  _QWORD *v54; // [rsp+130h] [rbp-620h]
  const char *p_Name; // [rsp+138h] [rbp-618h]
  __int64 v56; // [rsp+140h] [rbp-610h]
  __int64 (__fastcall *p_sub_1403EB580_1)(__int64, _BYTE *, size_t, __int64, char); // [rsp+148h] [rbp-608h]
  __int64 (__fastcall *p_sub_1403EB0E0_1)(__int64, _BYTE *, int); // [rsp+150h] [rbp-600h]
  __int64 v59; // [rsp+158h] [rbp-5F8h]
  bool (__fastcall *p_sub_1403E7650_1)(__int64, __int64); // [rsp+160h] [rbp-5F0h]
  __int64 v61; // [rsp+168h] [rbp-5E8h]
  __int64 (__fastcall *p_sub_1403E4E80_1)(const void **); // [rsp+170h] [rbp-5E0h]
  _QWORD *(__fastcall *p_sub_1403E4B90_1)(_QWORD *); // [rsp+178h] [rbp-5D8h]
  unsigned __int64 v64; // [rsp+180h] [rbp-5D0h]
  char v65; // [rsp+188h] [rbp-5C8h]
  char v66; // [rsp+189h] [rbp-5C7h]
  __int64 n0x18_1; // [rsp+190h] [rbp-5C0h]
  unsigned __int64 v68; // [rsp+198h] [rbp-5B8h]
  _QWORD *v69; // [rsp+1A0h] [rbp-5B0h]
  const char *p_EntityId; // [rsp+1A8h] [rbp-5A8h]
  __int64 v71; // [rsp+1B0h] [rbp-5A0h]
  __int64 (__fastcall *p_sub_1403EB550)(__int64, __int64, __int64); // [rsp+1B8h] [rbp-598h]
  __int64 (__fastcall *p_sub_1403EAFB0)(__int64, _BYTE *, unsigned __int64); // [rsp+1C0h] [rbp-590h]
  __int64 v74; // [rsp+1C8h] [rbp-588h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+1D0h] [rbp-580h]
  __int64 v76; // [rsp+1D8h] [rbp-578h]
  __int64 (__fastcall *p_sub_1403E4EB0)(const void *); // [rsp+1E0h] [rbp-570h]
  __int64 (__fastcall *p_sub_1403E4C70)(__int64); // [rsp+1E8h] [rbp-568h]
  unsigned __int64 v79; // [rsp+1F0h] [rbp-560h]
  char v80; // [rsp+1F8h] [rbp-558h]
  char v81; // [rsp+1F9h] [rbp-557h]
  __int64 n0x18_2; // [rsp+200h] [rbp-550h]
  __int64 n0x17; // [rsp+208h] [rbp-548h]
  __int64 v84; // [rsp+210h] [rbp-540h] BYREF

  v28 = alloca(0x700);
  p_null = "null";
  __Val_0___[0] = ThreadLogContextSlot;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  p_Function = "Function";
  v39 = a10;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v51 = 1;
  v41 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v44 = 0;
  v46 = 0;
  v49 = 0xFFFFFFFFFFFFFFFFuLL;
  v50 = 0;
  n0x18 = 0x18;
  p_null_1 = "null";
  if ( a10[1] )
    p_null_1 = (const char *)a10[1];
  v31 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v31;
  while ( p_null_1[v31] );
  v53 = v31;
  p_Name = "Name";
  v54 = a11;
  v66 = 0;
  v56 = *a11;
  p_sub_1403EB580_1 = sub_1403EB580;
  p_sub_1403EB0E0_1 = sub_1403EB0E0;
  p_sub_1403E7650_1 = sub_1403E7650;
  p_sub_1403E4E80_1 = sub_1403E4E80;
  p_sub_1403E4B90_1 = sub_1403E4B90;
  v59 = 0;
  v61 = 0;
  v64 = 0xFFFFFFFFFFFFFFFFuLL;
  v65 = 0;
  n0x18_1 = 0x18;
  if ( a11[1] )
    p_null = (const char *)a11[1];
  v32 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v32;
  while ( p_null[v32] );
  v68 = v32;
  v69 = a12;
  p_EntityId = "EntityId";
  v81 = 1;
  v71 = *a12;
  p_sub_1403EB550 = sub_1403EB550;
  p_sub_1403EAFB0 = sub_1403EAFB0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E4EB0 = sub_1403E4EB0;
  p_sub_1403E4C70 = sub_1403E4C70;
  v74 = 0;
  v76 = 0;
  v80 = 0;
  v79 = 0xFFFFFFFFFFFFFFFFuLL;
  n0x18_2 = 0x18;
  n0x17 = 0x17;
  sub_145A23960((__int64)&v84, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24);
  LODWORD(v34) = a6;
  return sub_1403045C0(
           n4,
           a2,
           p_Actor_Teleport,
           $$:_Teleporting_actor__$$__[$$]_($$)_from_Z$$_W$$_[Zone_$$]_to,
           (vraudio::AudioBuffer *)__Val_0___,
           0x10u,
           a5,
           v34,
           a7,
           a8);
}

// --- End Function: sub_145A23190 (0x145A23190) ---

// --- Function: sub_145A23570 (0x145A23570) ---
__int64 __fastcall sub_145A23570(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  unsigned __int64 v8; // r8
  const char *p_null; // r9
  const char *p_null_2; // rax
  const char *p_null_1; // rdx
  unsigned __int64 v13; // rax
  const char *p_null_3; // rdx
  unsigned __int64 v15; // rax
  __int64 n6; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Name";
  *(_BYTE *)(a1 + 0x59) = 0;
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  p_null = "null";
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_2 = (const char *)a2[1];
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v13 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v13;
  while ( p_null_1[v13] );
  *(_QWORD *)(a1 + 0x68) = v13;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Float";
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_QWORD *)(a1 + 0x88) = sub_140504DA0;
  *(_QWORD *)(a1 + 0x90) = snprintf_s_w;
  *(_QWORD *)(a1 + 0xA0) = sub_140501E10;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E70;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B60;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x10;
  *(_QWORD *)(a1 + 0xD8) = 0x1C;
  *(_QWORD *)(a1 + 0xE8) = "Quat";
  *(_BYTE *)(a1 + 0x139) = 0;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_QWORD *)(a1 + 0x128) = sub_1457F2560;
  *(_QWORD *)(a1 + 0xF8) = sub_1457F2AB0;
  *(_QWORD *)(a1 + 0x100) = sub_1457F2870;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = std::_Ptr_base<__ExceptionPtr>::_Swap;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_144969C30;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x28;
  *(_QWORD *)(a1 + 0x148) = 0x84;
  *(_QWORD *)(a1 + 0x158) = "Quat";
  *(_BYTE *)(a1 + 0x1A9) = 0;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x1C8) = "Reason";
  *(_QWORD *)(a1 + 0x198) = sub_1457F2560;
  *(_QWORD *)(a1 + 0x168) = sub_1457F2AB0;
  *(_QWORD *)(a1 + 0x170) = sub_1457F2870;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = std::_Ptr_base<__ExceptionPtr>::_Swap;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x190) = sub_144969C30;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0x28;
  *(_QWORD *)(a1 + 0x1B8) = 0x84;
  *(_QWORD *)(a1 + 0x1C0) = a6;
  *(_BYTE *)(a1 + 0x219) = 0;
  *(_QWORD *)(a1 + 0x1D0) = *a6;
  *(_QWORD *)(a1 + 0x1D8) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x1E0) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x1F0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x200) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x208) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0x18;
  p_null_3 = "null";
  if ( a6[1] )
    p_null_3 = (const char *)a6[1];
  v15 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v15;
  while ( p_null_3[v15] );
  *(_QWORD *)(a1 + 0x228) = v15;
  *(_QWORD *)(a1 + 0x238) = "Text";
  *(_QWORD *)(a1 + 0x230) = a7;
  *(_BYTE *)(a1 + 0x289) = 0;
  *(_QWORD *)(a1 + 0x240) = *a7;
  *(_QWORD *)(a1 + 0x248) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x250) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x260) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x270) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x278) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x258) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x290) = 0x18;
  if ( a7[1] )
    p_null = (const char *)a7[1];
  do
    ++v8;
  while ( p_null[v8] );
  n6 = 6;
  *(_QWORD *)(a1 + 0x298) = v8;
  return n6;
}

// --- End Function: sub_145A23570 (0x145A23570) ---

// --- Function: sub_145A23960 (0x145A23960) ---
__int64 __fastcall sub_145A23960(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        _QWORD *a7,
        _QWORD *a8,
        _QWORD *a9,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12,
        _QWORD *a13)
{
  const char *p_null; // r8
  const char *p_null_2; // rax
  const char *p_null_1; // rdx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Text";
  *(_BYTE *)(a1 + 0x59) = 0;
  p_null = "null";
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_2 = (const char *)a2[1];
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v17 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v17;
  while ( p_null_1[v17] );
  *(_QWORD *)(a1 + 0x68) = v17;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Position";
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1417D1A70;
  *(_QWORD *)(a1 + 0x90) = swprintf_w;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1417CEB40;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1417CDB50;
  *(_QWORD *)(a1 + 0xB8) = sub_1417CDAD0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x20;
  *(_QWORD *)(a1 + 0xD8) = 0x5E;
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_QWORD *)(a1 + 0xE8) = "Position";
  *(_BYTE *)(a1 + 0x139) = 0;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0x158) = "Name";
  *(_QWORD *)(a1 + 0xF8) = sub_1417D1A70;
  *(_QWORD *)(a1 + 0x100) = swprintf_w;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = sub_1417CEB40;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_1417CDB50;
  *(_QWORD *)(a1 + 0x128) = sub_1417CDAD0;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x20;
  *(_QWORD *)(a1 + 0x148) = 0x5E;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_BYTE *)(a1 + 0x1A9) = 0;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x168) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x170) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x180) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x190) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x198) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0x18;
  if ( a5[1] )
    p_null = (const char *)a5[1];
  v18 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v18;
  while ( p_null[v18] );
  *(_QWORD *)(a1 + 0x1B8) = v18;
  *(_QWORD *)(a1 + 0x1C0) = a6;
  *(_QWORD *)(a1 + 0x1C8) = "Position";
  *(_BYTE *)(a1 + 0x219) = 0;
  *(_QWORD *)(a1 + 0x1D0) = *a6;
  *(_QWORD *)(a1 + 0x230) = a7;
  *(_QWORD *)(a1 + 0x1D8) = sub_1417D1A70;
  *(_QWORD *)(a1 + 0x1E0) = swprintf_w;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F0) = sub_1417CEB40;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x200) = sub_1417CDB50;
  *(_QWORD *)(a1 + 0x208) = sub_1417CDAD0;
  *(_QWORD *)(a1 + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0x20;
  *(_QWORD *)(a1 + 0x228) = 0x5E;
  *(_QWORD *)(a1 + 0x238) = "Position";
  *(_BYTE *)(a1 + 0x289) = 0;
  *(_QWORD *)(a1 + 0x240) = *a7;
  *(_QWORD *)(a1 + 0x248) = sub_1417D1A70;
  *(_QWORD *)(a1 + 0x250) = swprintf_w;
  *(_QWORD *)(a1 + 0x258) = 0;
  *(_QWORD *)(a1 + 0x260) = sub_1417CEB40;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = sub_1417CDB50;
  *(_QWORD *)(a1 + 0x278) = sub_1417CDAD0;
  *(_QWORD *)(a1 + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x290) = 0x20;
  *(_QWORD *)(a1 + 0x298) = 0x5E;
  return sub_145A23570(a1 + 0x2A0, a8, a9, a10, a11, a12, a13) + 6;
}

// --- End Function: sub_145A23960 (0x145A23960) ---

// --- Function: sub_145A281D0 (0x145A281D0) ---
__int64 __fastcall sub_145A281D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 result; // rax
  double v8; // xmm1_8

  v2 = *(_QWORD *)(a2 + 0x10);
  v4 = 0;
  v5 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)gEnv + 0x118LL))(gEnv, *(_QWORD *)v2);
  if ( !v5 || (v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x668LL))(v5)) == 0 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)gEnv + 0x118LL))(gEnv, *(_QWORD *)(v2 + 0x80));
    if ( v6 )
      v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x648LL))(v6);
  }
  *(_QWORD *)a1 = 0x3FD157E6AAFF2FC4LL;
  *(_QWORD *)(a1 + 0x18) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x10) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 8) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x30) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x28) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x20) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x108) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x100) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0xF8) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 0x110) = 0x5F138D352E5096AFLL;
  *(_QWORD *)(a1 + 0x118) = 0x5F138D352E5096AFLL;
  *(_QWORD *)(a1 + 0x120) = 0x5F138D352E5096AFLL;
  *(_QWORD *)(a1 + 0x128) = 0xDF138D352E5096AFuLL;
  *(_QWORD *)(a1 + 0x130) = 0xDF138D352E5096AFuLL;
  *(_QWORD *)(a1 + 0x138) = 0xDF138D352E5096AFuLL;
  result = a1;
  *(_QWORD *)(a1 + 0x140) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = 0;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_QWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_DWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x180) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_BYTE *)(a1 + 0x194) = 0;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(v2 + 0x28);
  v8 = *(double *)(v2 + 0x38);
  *(_QWORD *)(a1 + 0x160) = v4;
  *(_BYTE *)(a1 + 0x191) = 1;
  *(double *)(a1 + 0x18) = v8;
  if ( v4 )
    *(_BYTE *)(a1 + 0x190) = 1;
  return result;
}

// --- End Function: sub_145A281D0 (0x145A281D0) ---

// --- Function: sub_145A284B0 (0x145A284B0) ---
void __fastcall sub_145A284B0(
        int a1,
        __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  __int64 (__fastcall *v5)(__int64, __int64); // rdi
  __int64 v6; // rax
  __int64 (__fastcall *v7)(__int64, __int64); // rdx

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A3D30(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (__int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v6 = allocWithProfilerInfo_w(0x88u);
        v7 = (__int64 (__fastcall *)(__int64, __int64))v6;
        if ( v6 )
        {
          *(_QWORD *)v6 = *(_QWORD *)v5;
          *(_QWORD *)(v6 + 0x20) = *((_QWORD *)v5 + 4);
          *(_QWORD *)(v6 + 8) = *((_QWORD *)v5 + 1);
          *(_QWORD *)(v6 + 0x10) = *((_QWORD *)v5 + 2);
          *(_QWORD *)(v6 + 0x18) = *((_QWORD *)v5 + 3);
          *(_OWORD *)(v6 + 0x28) = *(_OWORD *)((char *)v5 + 0x28);
          *(double *)(v6 + 0x38) = *((double *)v5 + 7);
          *(_QWORD *)(v6 + 0x40) = *((_QWORD *)v5 + 8);
          *(_OWORD *)(v6 + 0x48) = *(_OWORD *)((char *)v5 + 0x48);
          *(double *)(v6 + 0x58) = *((double *)v5 + 0xB);
          *(_DWORD *)(v6 + 0x6C) = *((_DWORD *)v5 + 0x1B);
          *(_DWORD *)(v6 + 0x60) = *((_DWORD *)v5 + 0x18);
          *(_DWORD *)(v6 + 0x64) = *((_DWORD *)v5 + 0x19);
          *(_DWORD *)(v6 + 0x68) = *((_DWORD *)v5 + 0x1A);
          *(double *)(v6 + 0x70) = *((double *)v5 + 0xE);
          *(_DWORD *)(v6 + 0x78) = *((_DWORD *)v5 + 0x1E);
          *(_BYTE *)(v6 + 0x7C) = *((_BYTE *)v5 + 0x7C);
          *(_BYTE *)(v6 + 0x7D) = *((_BYTE *)v5 + 0x7D);
          *(_BYTE *)(v6 + 0x7E) = *((_BYTE *)v5 + 0x7E);
          *(_BYTE *)(v6 + 0x7F) = *((_BYTE *)v5 + 0x7F);
          *(_QWORD *)(v6 + 0x80) = *((_QWORD *)v5 + 0x10);
        }
        else
        {
          v7 = 0;
        }
        a2[2] = v7;
        *a2 = sub_145A281D0;
        a2[1] = (__int64 (__fastcall *)(__int64, __int64))sub_145A284B0;
      }
    }
  }
}

// --- End Function: sub_145A284B0 (0x145A284B0) ---

// --- Function: sub_145A31670 (0x145A31670) ---
__int64 __fastcall sub_145A31670(__int64 a1, _DWORD *dst)
{
  __int64 v3; // rax
  _DWORD *v4; // rax
  __int64 result; // rax

  v3 = sub_1403335B0(a1);
  v4 = (_DWORD *)sub_143192820(*(_QWORD *)(v3 + 0x18));
  *dst = v4[0xF];
  dst[1] = v4[0x10];
  result = (unsigned int)v4[0x15];
  dst[2] = result;
  return result;
}

// --- End Function: sub_145A31670 (0x145A31670) ---

// --- Function: sub_145A316A0 (0x145A316A0) ---
char __fastcall sub_145A316A0(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rbx
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rax
  const char *v14; // r12
  __int64 v15; // rcx
  const char **v16; // rax
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  __int64 v21; // rax
  const char **v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rcx
  __int64 v26; // rdi
  __int64 (__fastcall *v27)(__int64, const ULONG_PTR *, _QWORD); // rbx
  const ULONG_PTR *v28; // rax
  __int64 v30; // [rsp+20h] [rbp-B8h] BYREF
  _BYTE v31[24]; // [rsp+28h] [rbp-B0h] BYREF
  _BYTE v32[8]; // [rsp+40h] [rbp-98h] BYREF
  __int64 v33; // [rsp+48h] [rbp-90h]
  char *v34; // [rsp+50h] [rbp-88h]
  char v35; // [rsp+58h] [rbp-80h] BYREF

  v8 = sub_1403335B0(a1);
  v9 = 0;
  v10 = sub_143192820(*(_QWORD *)(v8 + 0x18));
  if ( !v10 )
  {
    v11 = sub_14030EC00((unsigned __int64 *)(a1 + 8)) ? *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL : 0LL;
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x20LL))(v11);
    v13 = (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v12 + 0x10LL))(v12, v31);
    v14 = *(const char **)(sub_1402C4680((__int64)v32, v13) + 0x10);
    v15 = sub_14030EC00((unsigned __int64 *)(a1 + 8)) ? *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL : 0LL;
    v16 = (const char **)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v15 + 0x78LL))(v15, &v30);
    LogFatalError(
      "CSCActorPhysicsController::LoadPhysicsParams invalid params for actor [%s] with class GUID [%s].",
      *v16,
      v14);
    sub_140370D10(&v30);
    if ( v34 != &v35 )
    {
      qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - v33;
      sub_147605980(v34);
    }
  }
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)a2 = 0xB;
  *(_DWORD *)(a2 + 0x14) = *(_DWORD *)(v10 + 8);
  *(_DWORD *)(a2 + 0x94) = *(_DWORD *)(v10 + 0x30);
  v17 = *(_DWORD *)(a1 + 0x314);
  if ( !v17 )
  {
    v17 = *(_DWORD *)(a1 + 0x31C);
    *(_DWORD *)(a1 + 0x314) = v17;
  }
  *(_DWORD *)(a1 + 0x318) = v17;
  v18 = v17 - 1;
  if ( v18 )
  {
    v19 = v18 - 1;
    if ( !v19 )
    {
      *(_WORD *)(a2 + 0x80) = 2;
      goto LABEL_20;
    }
    v20 = v19 - 1;
    if ( !v20 )
    {
      *(_WORD *)(a2 + 0x80) = 3;
      goto LABEL_20;
    }
    if ( v20 == 1 )
    {
      *(_WORD *)(a2 + 0x80) = 4;
      goto LABEL_20;
    }
  }
  *(_WORD *)(a2 + 0x80) = 1;
LABEL_20:
  v21 = sub_1465EEE60(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
  if ( !sub_145840AD0(v21, a3) )
  {
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v9 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    v22 = (const char **)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v9 + 0x78LL))(v9, &v30);
    LogFatalError(
      "CSCActorPhysicsController::LoadPhysicsParams for '%s' failed GetPlayerDimensionsForPhysicsController call.",
      *v22);
    sub_140370D10(&v30);
  }
  a4[1] = *(_DWORD *)(v10 + 0x3C);
  a4[3] = *(_DWORD *)(v10 + 0x38);
  a4[2] = *(_DWORD *)(v10 + 0x40);
  a4[4] = *(_DWORD *)(v10 + 0x34);
  a4[0xB] = *(_DWORD *)(v10 + 8);
  a4[0xD] = *(_DWORD *)(v10 + 0x48);
  a4[0xE] = *(_DWORD *)(v10 + 0x4C);
  a4[0x10] = *(_DWORD *)(v10 + 0x50);
  a4[0x11] = *(_DWORD *)(v10 + 0x54);
  LOBYTE(v23) = sub_1403E5570((_QWORD *)(v10 + 0x58));
  if ( !(_BYTE)v23 )
  {
    v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FBE0 + 0x418LL))(qword_149B4FBE0);
    v25 = v10 + 0x58;
    v26 = v24;
    v27 = *(__int64 (__fastcall **)(__int64, const ULONG_PTR *, _QWORD))(*(_QWORD *)v24 + 0x78LL);
    v28 = sub_14037FC70(v25);
    v23 = v27(v26, v28, 0);
    if ( v23 )
    {
      LOWORD(v23) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x10LL))(v23);
      a4[0xC] = (unsigned __int16)v23;
    }
  }
  return v23;
}

// --- End Function: sub_145A316A0 (0x145A316A0) ---

// --- Function: sub_145A34030 (0x145A34030) ---
__int64 __fastcall sub_145A34030(__int64 a1)
{
  __int64 v2; // rbx
  __int64 v3; // r14
  __int64 v4; // rdi
  __int64 v5; // r8
  char v6; // r12
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rcx
  _DWORD v13[4]; // [rsp+20h] [rbp-E0h] BYREF
  __int128 v14; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v15; // [rsp+40h] [rbp-C0h]
  unsigned int v16; // [rsp+44h] [rbp-BCh]
  unsigned int v17; // [rsp+48h] [rbp-B8h]
  unsigned int v18; // [rsp+50h] [rbp-B0h]
  unsigned int v19; // [rsp+54h] [rbp-ACh]
  unsigned int v20; // [rsp+58h] [rbp-A8h]
  unsigned int v21; // [rsp+5Ch] [rbp-A4h]
  unsigned int v22; // [rsp+60h] [rbp-A0h]
  unsigned int v23; // [rsp+64h] [rbp-9Ch]
  unsigned int v24; // [rsp+68h] [rbp-98h]
  unsigned int v25; // [rsp+6Ch] [rbp-94h]
  unsigned int v26; // [rsp+70h] [rbp-90h]
  unsigned int v27; // [rsp+74h] [rbp-8Ch]
  unsigned int v28; // [rsp+78h] [rbp-88h]
  unsigned __int64 v29; // [rsp+80h] [rbp-80h]
  unsigned int v30; // [rsp+88h] [rbp-78h]
  unsigned int v31; // [rsp+8Ch] [rbp-74h]
  unsigned int v32; // [rsp+90h] [rbp-70h]
  unsigned int v33; // [rsp+94h] [rbp-6Ch]
  unsigned int v34; // [rsp+98h] [rbp-68h]
  unsigned int v35; // [rsp+9Ch] [rbp-64h]
  unsigned int v36; // [rsp+A0h] [rbp-60h]
  unsigned int v37; // [rsp+B0h] [rbp-50h]
  __m256i v38; // [rsp+C0h] [rbp-40h] BYREF
  __m256i v39; // [rsp+E0h] [rbp-20h]
  __m256i v40; // [rsp+100h] [rbp+0h] BYREF
  __int128 v41; // [rsp+120h] [rbp+20h]
  __int128 v42; // [rsp+130h] [rbp+30h]
  __m256i v43; // [rsp+140h] [rbp+40h]
  __m256i v44; // [rsp+160h] [rbp+60h]
  __m256i v45; // [rsp+180h] [rbp+80h] BYREF
  _DWORD v46[8]; // [rsp+1A0h] [rbp+A0h] BYREF
  __int128 v47; // [rsp+1C0h] [rbp+C0h]
  int v48; // [rsp+1D0h] [rbp+D0h]
  unsigned int v49; // [rsp+1D4h] [rbp+D4h]
  unsigned int v50; // [rsp+1D8h] [rbp+D8h]
  unsigned int v51; // [rsp+1E4h] [rbp+E4h]
  unsigned int v52; // [rsp+1E8h] [rbp+E8h]
  unsigned int v53; // [rsp+1F4h] [rbp+F4h]
  _BYTE v54[72]; // [rsp+200h] [rbp+100h] BYREF
  unsigned __int64 v55; // [rsp+248h] [rbp+148h]
  unsigned __int64 v56; // [rsp+350h] [rbp+250h] BYREF

  v2 = 0;
  if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
    v3 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
  else
    v3 = 0;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v4 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v4 = 0;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x318LL))(v4);
  if ( v6 )
  {
    LOBYTE(v5) = 1;
    (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)v4 + 0x310LL))(v4, 0, v5, 0);
  }
  *((float *)&v42 + 3) = 0.0;
  *(float *)&v43.m256i_i32[5] = 0.0;
  memset(&v40, 0, 0x19);
  v41 = 0;
  memset(&v45, 0, 0x1C);
  v38.m256i_i32[0] = 0;
  v47 = xmmword_148218FC0;
  v39.m256i_i64[2] = 0x1000007FFLL;
  v38.m256i_i16[2] = 0x100;
  v38.m256i_i32[2] = 0xFFFFFFFF;
  v38.m256i_i8[0xC] = 0;
  v38.m256i_i8[0x18] = 0;
  v14 = xmmword_148745680;
  *(_OWORD *)v39.m256i_i8 = 0xFFFFFFFFFFFFFFFFuLL;
  v39.m256i_i64[3] = 0x81;
  *(_QWORD *)&v42 = 0;
  BYTE8(v42) = 0;
  v43.m256i_i16[0] = 1;
  v43.m256i_i64[1] = 0;
  v43.m256i_i32[4] = 0;
  v43.m256i_i64[3] = 0;
  *(_OWORD *)v44.m256i_i8 = 0u;
  v44.m256i_i32[4] = 0xFFFFFFFF;
  v44.m256i_i64[3] = 0;
  v38.m256i_i64[2] = 0xFFBFFFFFFFBFFFFFuLL;
  v48 = 0;
  v46[0] = 1;
  v46[4] = 0xFFBFFFFF;
  v46[1] = 0xFFBFFFFF;
  v46[7] = 0xFFBFFFFF;
  v49 = 0xFFBFFFFF;
  v51 = 0xFFBFFFFF;
  v52 = 0xFFBFFFFF;
  v53 = 0x80000000;
  v50 = 0xFFBFFFFF;
  v16 = 0xFFBFFFFF;
  v17 = 0xFFBFFFFF;
  v18 = 0xFFBFFFFF;
  v21 = 0xFFBFFFFF;
  v19 = 0x80000000;
  v20 = 0x80000000;
  v22 = 0x80000000;
  v31 = 0x80000000;
  v28 = 0x80000000;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v23 = 0xFFBFFFFF;
  v24 = 0xFFBFFFFF;
  v25 = 0xFFBFFFFF;
  v26 = 0xFFBFFFFF;
  v15 = 0xFFBFFFFF;
  v30 = 0x80000000;
  v27 = 0xFFBFFFFF;
  v32 = 0x80000000;
  v37 = 0xFFBFFFFF;
  v34 = 0x80000000;
  v35 = 0x80000000;
  v36 = 0x80000000;
  v33 = 0x80000000;
  sub_145A316A0(a1, (__int64)&v38, (__int64)v46, &v14);
  v39.m256i_i64[1] |= 0x8000000uLL;
  *((_QWORD *)&v41 + 1) = v46;
  *(_QWORD *)&v42 = &v14;
  (*(void (__fastcall **)(__int64, __m256i *))(*(_QWORD *)v4 + 0x390LL))(v4, &v38);
  *(__m256i *)(a1 + 0x320) = v38;
  *(__m256i *)(a1 + 0x340) = v39;
  *(__m256i *)(a1 + 0x360) = v40;
  *(_OWORD *)(a1 + 0x380) = v41;
  *(_OWORD *)(a1 + 0x390) = v42;
  *(__m256i *)(a1 + 0x3A0) = v43;
  *(__m256i *)(a1 + 0x3C0) = v44;
  *(__m256i *)(a1 + 0x3E0) = v45;
  __asm { vzeroupper }
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v7 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v7 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v7 + 0x3B8LL))(v7, &v56);
  if ( v56 && *(_QWORD *)((v56 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v56) )
  {
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v8 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v8 = 0;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x440LL))(v8);
    sub_140370740((__int64)v54);
    v55 = 0xFFFFFFFFFFFFFFDFuLL;
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v9 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v9 = 0;
    (*(void (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v9 + 0x3F8LL))(v9, v54, 0, 0);
    if ( v6 )
    {
      LOBYTE(v10) = 1;
      (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)v4 + 0x310LL))(v4, 1, v10, 0);
    }
    sub_1465FAFF0(v3);
    v13[1] = *(unsigned __int8 *)(a1 + 0x4B8);
    v13[0] = 6;
    v13[2] = 0xFFBFFFFF;
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v11 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    else
      v11 = 0;
    (*(void (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(*(_QWORD *)v11 + 0x408LL))(v11, v13, 0, 0);
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v2 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x448LL))(v2);
  }
  else
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x70LL))(v4);
    return sub_142EEAFD0((__int64)"%s: Failed to physicalize Player Entity %s");
  }
}

// --- End Function: sub_145A34030 (0x145A34030) ---

// --- Function: sub_145A344E0 (0x145A344E0) ---
void __fastcall sub_145A344E0(__int64 a1, int n6)
{
  __int128 v2; // xmm11
  __int128 v3; // xmm15
  __int64 *v4; // r12
  float v7; // xmm11_4
  __int64 v8; // rdi
  __int64 v9; // rcx
  const char *v10; // rax
  const char *p_PassiveRagdoll; // r13
  unsigned __int64 *v12; // rsi
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rbx
  float *AttachmentOffsetVec3; // rax
  double v17; // xmm0_8
  float v19; // xmm10_4
  float v20; // xmm8_4
  float v21; // xmm11_4
  double v22; // xmm9_8
  double v23; // xmm10_8
  double v24; // xmm8_8
  double v25; // xmm11_8
  double v26; // xmm4_8
  double v27; // xmm13_8
  double v28; // xmm7_8
  double v29; // xmm14_8
  double v30; // xmm15_8
  double v31; // xmm8_8
  double v32; // xmm9_8
  __int64 v33; // rcx
  __int64 v34; // rax
  const char *v35; // rax
  __int64 v36; // rbx
  unsigned __int64 *v37; // rcx
  __int64 v38; // rcx
  __int64 v39; // rax
  __int64 v40; // rax
  char v41; // dl
  int *v42; // rax
  __int64 v43; // rcx
  double v44; // xmm12_8
  double v45; // xmm8_8
  double v46; // xmm13_8
  double v47; // xmm14_8
  double v48; // xmm6_8
  double v49; // xmm9_8
  double v50; // kr00_8
  __int64 v51; // rcx
  __int64 v52; // rax
  const char *v53; // rax
  __int64 v54; // rbx
  unsigned __int64 *v55; // rcx
  unsigned __int64 v56; // rax
  __int64 v57; // rcx
  __int128 n0x42A00000; // xmm0
  __int64 v62; // rcx
  __int64 v63; // rcx
  unsigned __int64 v64; // rcx
  __int64 v65; // rcx
  int v66; // eax
  __int64 v67; // rcx
  __int64 v68; // rcx
  __int64 v69; // rax
  int *v70; // rax
  _QWORD *v71; // rax
  __int64 v72; // rcx
  double v73; // [rsp+28h] [rbp-D8h]
  unsigned __int64 v74; // [rsp+78h] [rbp-88h] BYREF
  __int64 v75; // [rsp+80h] [rbp-80h]
  float v76[6]; // [rsp+88h] [rbp-78h] BYREF
  _DWORD v77[6]; // [rsp+A0h] [rbp-60h] BYREF
  double v78; // [rsp+B8h] [rbp-48h]
  int v79; // [rsp+C0h] [rbp-40h]
  float v80; // [rsp+C4h] [rbp-3Ch]
  unsigned int v81; // [rsp+C8h] [rbp-38h]
  _BYTE v82[12]; // [rsp+CCh] [rbp-34h]
  unsigned int v83; // [rsp+D8h] [rbp-28h]
  unsigned int v84; // [rsp+DCh] [rbp-24h]
  __m256 v85; // [rsp+E0h] [rbp-20h]
  __int128 v86; // [rsp+100h] [rbp+0h]
  __int128 v87; // [rsp+110h] [rbp+10h] BYREF
  unsigned int v88; // [rsp+120h] [rbp+20h]
  unsigned int v89; // [rsp+124h] [rbp+24h]
  unsigned int v90; // [rsp+128h] [rbp+28h]
  unsigned int v91; // [rsp+130h] [rbp+30h]
  unsigned int v92; // [rsp+134h] [rbp+34h]
  unsigned int v93; // [rsp+138h] [rbp+38h]
  unsigned int v94; // [rsp+13Ch] [rbp+3Ch]
  unsigned int v95; // [rsp+140h] [rbp+40h]
  unsigned int v96; // [rsp+144h] [rbp+44h]
  unsigned int v97; // [rsp+148h] [rbp+48h]
  unsigned int v98; // [rsp+14Ch] [rbp+4Ch]
  unsigned int v99; // [rsp+150h] [rbp+50h]
  unsigned int v100; // [rsp+154h] [rbp+54h]
  unsigned int v101; // [rsp+158h] [rbp+58h]
  unsigned __int64 v102; // [rsp+160h] [rbp+60h]
  unsigned int v103; // [rsp+168h] [rbp+68h]
  unsigned int v104; // [rsp+16Ch] [rbp+6Ch]
  unsigned int v105; // [rsp+170h] [rbp+70h]
  unsigned int v106; // [rsp+174h] [rbp+74h]
  unsigned int v107; // [rsp+178h] [rbp+78h]
  unsigned int v108; // [rsp+17Ch] [rbp+7Ch]
  unsigned int v109; // [rsp+180h] [rbp+80h]
  unsigned int v110; // [rsp+190h] [rbp+90h]
  __m256i v111; // [rsp+1A0h] [rbp+A0h] BYREF
  __m256i v112; // [rsp+1C0h] [rbp+C0h]
  __m256i v113; // [rsp+1E0h] [rbp+E0h] BYREF
  __int128 v114; // [rsp+200h] [rbp+100h]
  __int128 v115; // [rsp+210h] [rbp+110h]
  __m256i v116; // [rsp+220h] [rbp+120h]
  __m256i v117; // [rsp+240h] [rbp+140h]
  __m256i v118; // [rsp+260h] [rbp+160h] BYREF
  _DWORD v119[8]; // [rsp+280h] [rbp+180h] BYREF
  __int128 v120; // [rsp+2A0h] [rbp+1A0h]
  int v121; // [rsp+2B0h] [rbp+1B0h]
  unsigned int v122; // [rsp+2B4h] [rbp+1B4h]
  unsigned int v123; // [rsp+2B8h] [rbp+1B8h]
  unsigned int v124; // [rsp+2C4h] [rbp+1C4h]
  unsigned int v125; // [rsp+2C8h] [rbp+1C8h]
  unsigned int v126; // [rsp+2D4h] [rbp+1D4h]
  double v127; // [rsp+2E0h] [rbp+1E0h] BYREF
  double v128; // [rsp+2E8h] [rbp+1E8h]
  double v129; // [rsp+2F0h] [rbp+1F0h]
  double v130; // [rsp+2F8h] [rbp+1F8h]
  double v131; // [rsp+300h] [rbp+200h]
  double v132; // [rsp+308h] [rbp+208h]
  double v133; // [rsp+310h] [rbp+210h]
  _BYTE v134[72]; // [rsp+320h] [rbp+220h] BYREF
  __int64 v135; // [rsp+368h] [rbp+268h]
  unsigned __int64 v136; // [rsp+378h] [rbp+278h]
  __int64 v137; // [rsp+440h] [rbp+340h] BYREF
  __int64 n0x1FF_1; // [rsp+448h] [rbp+348h]
  _BYTE *v139; // [rsp+450h] [rbp+350h]
  _BYTE v140[520]; // [rsp+458h] [rbp+358h] BYREF
  __int64 v141; // [rsp+660h] [rbp+560h] BYREF
  __int64 n0x1FF; // [rsp+668h] [rbp+568h]
  _BYTE *v143; // [rsp+670h] [rbp+570h]
  _BYTE v144[520]; // [rsp+678h] [rbp+578h] BYREF
  __int128 v145; // [rsp+890h] [rbp+790h]
  __int128 v146; // [rsp+8D0h] [rbp+7D0h]

  v146 = v2;
  v4 = (__int64 *)(a1 + 0x118);
  v7 = 1.0;
  v75 = sub_1465EECD0(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
  v8 = 0;
  switch ( n6 )
  {
    case 1:
    case 3:
      p_PassiveRagdoll = "FloppyRagdoll";
      break;
    case 4:
      v7 = -1.0;
      p_PassiveRagdoll = "DrivenRagdoll";
      break;
    case 5:
      v7 = -0.5;
      p_PassiveRagdoll = "NewRagdoll";
      break;
    case 6:
      v7 = -1.0;
      p_PassiveRagdoll = "PassiveRagdoll";
      break;
    default:
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v9 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v9 = 0;
      v10 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x70LL))(v9);
      LogTraceConditional("Trying to physicalize a ragdoll on %s using an unsupported mode %d", v10, n6);
      __debugbreak();
  }
  v12 = (unsigned __int64 *)(a1 + 8);
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v13 = *v12 & 0xFFFFFFFFFFFFLL;
  else
    v13 = 0;
  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v13 + 0x3B8LL))(v13, &v74);
  if ( !v74
    || *(_QWORD *)((v74 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v74)
    || (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v74 & 0xFFFFFFFFFFFFLL) + 8LL))(v74 & 0xFFFFFFFFFFFFLL) != 6 )
  {
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v43 = *v12 & 0xFFFFFFFFFFFFLL;
    else
      v43 = 0;
    (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v43 + 0x268LL))(v43, &v127, 0);
    v44 = v128 * v127 - v129 * v130 + v128 * v127 - v129 * v130;
    v45 = v130 * v130 + v130 * v130;
    v46 = v128 * v128 + v128 * v128 + v45 - 1.0;
    v47 = v127 * v130 + v127 * v130 + v128 * v129 + v128 * v129;
    v48 = v128 * v130 + v128 * v130 + v127 * v129 + v127 * v129;
    v49 = v128 * v129 - v127 * v130 + v128 * v129 - v127 * v130;
    v50 = v129 * v129 + v129 * v129 + v45 - 1.0;
    v144[0] = 0;
    v143 = v144;
    v141 = 0;
    n0x1FF = 0x1FF;
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v51 = *v12 & 0xFFFFFFFFFFFFLL;
    else
      v51 = 0;
    v52 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v51 + 0x648LL))(v51);
    v53 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 0x1F0LL))(v52);
    v54 = *(_QWORD *)(sub_1402A3190(
                        (__int64)&v141,
                        "%s: mode=%s pos(%.2f, %.2f, %.2f) dir(%.2f, %.2f, %.2f) up(%.2f, %.2f, %.2f) zone='%s'",
                        "CSCActorPhysicsController::PhysicalizeRagdoll",
                        p_PassiveRagdoll,
                        v131,
                        v132,
                        v133,
                        v44,
                        v46,
                        v47,
                        v48,
                        v49,
                        v50,
                        v53)
                    + 0x10);
    if ( is_valid_handle_typeA(v4) )
      v55 = (unsigned __int64 *)(*v4 & 0xFFFFFFFFFFFFLL);
    else
      v55 = 0;
    sub_144E57960(v55, v54);
    if ( v143 != v144 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v143);
    }
    if ( n6 == 6 )
      goto LABEL_70;
    v56 = v74;
    if ( v74 )
    {
      if ( *(_QWORD *)((v74 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v74) )
      {
        if ( (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v74 & 0xFFFFFFFFFFFFLL) + 8LL))(v74 & 0xFFFFFFFFFFFFLL) == 0xB )
          goto LABEL_70;
        v56 = v74;
      }
      if ( v56 && *(_QWORD *)((v56 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v56) )
        (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v56 & 0xFFFFFFFFFFFFLL) + 8LL))(v56 & 0xFFFFFFFFFFFFLL);
    }
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v57 = *v12 & 0xFFFFFFFFFFFFLL;
    else
      v57 = 0;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v57 + 0x70LL))(v57);
    sub_142EEAFD0((__int64)"%s: '%s' is not a actor entity (type=%i), this will cause the articulated entity to be unhosted!");
    sub_145A34030(a1);
LABEL_70:
    v87 = xmmword_148745680;
    v120 = xmmword_148218FC0;
    _XMM6 = 0;
    memset(&v113, 0, 0x19);
    memset(&v118, 0, 0x1C);
    n0x42A00000 = 0x42A00000u;
    v89 = 0xFFBFFFFF;
    v119[0] = 1;
    v112.m256i_i64[2] = 0x1000007FFLL;
    __asm { vcmpltss xmm1, xmm6, xmm2 }
    *(_QWORD *)&v115 = &v87;
    __asm { vblendvps xmm0, xmm0, xmm2, xmm1 }
    v116.m256i_i16[0] = 1;
    v111.m256i_i32[5] = _XMM0;
    *((float *)&v115 + 3) = 0.0;
    *(float *)&v116.m256i_i32[5] = v7;
    v90 = 0xFFBFFFFF;
    v91 = 0xFFBFFFFF;
    v94 = 0xFFBFFFFF;
    v92 = 0x80000000;
    v93 = 0x80000000;
    v95 = 0x80000000;
    v104 = 0x80000000;
    v101 = 0x80000000;
    v102 = 0xFFFFFFFFFFFFFFFFuLL;
    v96 = 0xFFBFFFFF;
    v97 = 0xFFBFFFFF;
    v98 = 0xFFBFFFFF;
    v99 = 0xFFBFFFFF;
    v88 = 0xFFBFFFFF;
    v103 = 0x80000000;
    v100 = 0xFFBFFFFF;
    v105 = 0x80000000;
    v110 = 0xFFBFFFFF;
    v107 = 0x80000000;
    v108 = 0x80000000;
    v109 = 0x80000000;
    v106 = 0x80000000;
    v121 = 0;
    v119[4] = 0xFFBFFFFF;
    v119[1] = 0xFFBFFFFF;
    v119[7] = 0xFFBFFFFF;
    v122 = 0xFFBFFFFF;
    v124 = 0xFFBFFFFF;
    v125 = 0xFFBFFFFF;
    v126 = 0x80000000;
    v123 = 0xFFBFFFFF;
    v111.m256i_i16[2] = 0x100;
    v111.m256i_i8[0xC] = 0;
    v111.m256i_i8[0x18] = 0;
    v112.m256i_i64[0] = 0xFFFFFFFFFFFFFFFFuLL;
    v112.m256i_i64[3] = 0x81;
    *(_QWORD *)&v114 = 0;
    BYTE8(v115) = 0;
    v116.m256i_i64[1] = 0;
    v116.m256i_i32[4] = 0;
    v116.m256i_i64[3] = 0;
    *(_OWORD *)v117.m256i_i8 = 0u;
    v117.m256i_i32[4] = 0xFFFFFFFF;
    v117.m256i_i64[3] = 0;
    v111.m256i_i32[4] = 0xFFBFFFFF;
    v111.m256i_i32[0] = 6;
    v111.m256i_i32[2] = 0;
    *((_QWORD *)&v114 + 1) = v119;
    v112.m256i_i64[1] = 0x8000000;
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v62 = *v12 & 0xFFFFFFFFFFFFLL;
    else
      v62 = 0;
    (*(void (__fastcall **)(__int64, __m256i *))(*(_QWORD *)v62 + 0x390LL))(v62, &v111);
    *(__m256i *)(a1 + 0x320) = v111;
    *(__m256i *)(a1 + 0x340) = v112;
    *(__m256i *)(a1 + 0x360) = v113;
    *(_OWORD *)(a1 + 0x380) = v114;
    *(_OWORD *)(a1 + 0x390) = v115;
    *(__m256i *)(a1 + 0x3A0) = v116;
    *(__m256i *)(a1 + 0x3C0) = v117;
    *(__m256i *)(a1 + 0x3E0) = v118;
    __asm { vzeroupper }
    if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
      v63 = *v12 & 0xFFFFFFFFFFFFLL;
    else
      v63 = 0;
    v64 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, float *))(*(_QWORD *)v63 + 0x3B8LL))(v63, v76);
    v74 = v64;
    if ( v64 && *(_QWORD *)((v64 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v64) )
    {
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v65 = *v12 & 0xFFFFFFFFFFFFLL;
      else
        v65 = 0;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v65 + 0x440LL))(v65);
      v66 = *(_DWORD *)(a1 + 0x194);
      v85 = ymmword_148574CE0;
      v86 = xmmword_14819FFD0;
      *(_QWORD *)v82 = *(_QWORD *)(a1 + 0x18C);
      v78 = *(double *)v82;
      v80 = 0.0;
      v77[0] = 0xA;
      v77[2] = 0xFFBFFFFF;
      v77[3] = 0xFFBFFFFF;
      v77[4] = 0xFFBFFFFF;
      v77[5] = 0xFFBFFFFF;
      v77[1] = 0x80000000;
      v81 = 0xFFBFFFFF;
      v84 = 0xFFBFFFFF;
      v83 = 0xFFBFFFFF;
      *(_DWORD *)&v82[8] = v66;
      v79 = v66;
      __asm { vzeroupper }
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v67 = *v12 & 0xFFFFFFFFFFFFLL;
      else
        v67 = 0;
      (*(void (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(*(_QWORD *)v67 + 0x3F8LL))(v67, v77, 0, 0);
      sub_140370740((__int64)v134);
      v135 |= 0xFFFFFFFFFFFFFFDFuLL;
      v136 = 0xFFFFFFFFFFFFFFDFuLL;
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v68 = *v12 & 0xFFFFFFFFFFFFLL;
      else
        v68 = 0;
      (*(void (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v68 + 0x3F8LL))(v68, v134, 0, 0);
      v69 = sub_1408822B0(qword_149E7E438);
      sub_142ED3D20(v69, v74, 0x10000u, 0, 0xFFFFFFFF);
      v70 = (int *)sub_1443CA900((__int64)v76, n6 == 4);
      sub_145ED3E50(v75, v70);
      v71 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                        qword_149B4FC40,
                        0);
      if ( sub_140597650((_QWORD *)(a1 + 0x250), v71) )
      {
        if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
          v72 = *v12 & 0xFFFFFFFFFFFFLL;
        else
          v72 = 0;
        (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v72 + 0x408LL))(v72, a1 + 0x200, 0, 0);
        *(_QWORD *)(a1 + 0x250) = 0;
      }
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v8 = *v12 & 0xFFFFFFFFFFFFLL;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x448LL))(v8);
    }
    return;
  }
  v145 = v3;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v14 = *v12 & 0xFFFFFFFFFFFFLL;
  else
    v14 = 0;
  v15 = (*(__int64 (__fastcall **)(__int64, _DWORD *, _QWORD))(*(_QWORD *)v14 + 0x268LL))(v14, v77, 0);
  AttachmentOffsetVec3 = CEntityTemplate::GetAttachmentOffsetVec3(
                           (_QWORD *)(*(_QWORD *)(a1 + 0x128) & 0xFFFFFFFFFFFFLL),
                           v76);
  v17 = *(double *)(v15 + 0x30);
  _XMM12 = *(_OWORD *)(v15 + 0x20);
  v140[0] = 0;
  v19 = AttachmentOffsetVec3[3];
  v20 = *AttachmentOffsetVec3;
  v21 = AttachmentOffsetVec3[2];
  v22 = AttachmentOffsetVec3[1];
  *(double *)&v82[4] = v17;
  v23 = v19;
  v24 = v20;
  v25 = v21;
  v26 = v24 * v23;
  v27 = v22 * v24 - v25 * v23 + v22 * v24 - v25 * v23;
  v28 = v23 * v23 + v23 * v23;
  v29 = v22 * v22 + v22 * v22 + v28 - 1.0;
  v30 = v25 * v22 + v25 * v22 + v26 + v26;
  v31 = v25 * v24 + v25 * v24 + v22 * v23 + v22 * v23;
  v32 = v25 * v22 - v26 + v25 * v22 - v26;
  v137 = 0;
  v139 = v140;
  n0x1FF_1 = 0x1FF;
  if ( sub_14030EC00(v12) )
    v33 = *v12 & 0xFFFFFFFFFFFFLL;
  else
    v33 = 0;
  v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v33 + 0x648LL))(v33);
  v35 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x1F0LL))(v34);
  __asm { vmovhpd qword ptr [rsp+960h+var_938], xmm12 }
  v36 = *(_QWORD *)(sub_1402A3190(
                      (__int64)&v137,
                      "%s: mode=%s pos(%.2f, %.2f, %.2f) dir(%.2f, %.2f, %.2f) up(%.2f, %.2f, %.2f) zone='%s'",
                      "CSCActorPhysicsController::PhysicalizeRagdoll",
                      p_PassiveRagdoll,
                      *(double *)&_XMM12,
                      v73,
                      *(double *)&v82[4],
                      v27,
                      v29,
                      v30,
                      v31,
                      v32,
                      v25 * v25 + v25 * v25 + v28 - 1.0,
                      v35)
                  + 0x10);
  if ( is_valid_handle_typeA(v4) )
    v37 = (unsigned __int64 *)(*v4 & 0xFFFFFFFFFFFFLL);
  else
    v37 = 0;
  sub_144E57960(v37, v36);
  if ( v139 != v140 )
  {
    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
    sub_147605980(v139);
  }
  if ( is_valid_handle_typeA(v4) )
    v38 = *v4 & 0xFFFFFFFFFFFFLL;
  else
    v38 = 0;
  v39 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 0x768LL))(v38);
  v40 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x30LL))(v39);
  switch ( n6 )
  {
    case 1:
    case 3:
      if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v40 + 0x98LL))(v40, 1, 1) )
        return;
      v41 = 0;
      break;
    case 4:
      if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v40 + 0x98LL))(v40, 2, 0) )
        return;
      v41 = 1;
      break;
    case 5:
      if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v40 + 0x98LL))(v40, 3, 0) )
        return;
      v41 = 1;
      break;
    default:
      if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v40 + 0x98LL))(v40, 4, 0) )
        return;
      v41 = 1;
      break;
  }
  v42 = (int *)sub_1443CA900((__int64)v76, v41);
  sub_145ED3E50(v75, v42);
}

// --- End Function: sub_145A344E0 (0x145A344E0) ---

// --- Function: sub_145A35300 (0x145A35300) ---
double __fastcall sub_145A35300(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rax
  bool v4; // bp
  __int64 v5; // rdi
  int v6; // esi
  unsigned __int32 v7; // eax
  char v8; // si
  __int64 v9; // rcx
  int n2; // edx
  int v11; // eax
  unsigned __int32 v12; // eax
  int n0x4300; // [rsp+30h] [rbp-78h] BYREF
  __int64 v15; // [rsp+34h] [rbp-74h]
  int v16; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v17; // [rsp+40h] [rbp-68h]
  unsigned __int64 v18; // [rsp+48h] [rbp-60h]
  __int64 v19; // [rsp+50h] [rbp-58h]
  __int64 v20; // [rsp+58h] [rbp-50h]

  n0x4300 = 0x4300;
  v15 = 0;
  v16 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v17 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E6815C,
    "CSCActorPhysicsController::PrePhysicsUpdate",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorPhysicsController.cpp",
    0x15E);
  v2 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
  HIWORD(n0x4300) = word_149E6815C;
  v3 = sub_1465EEE60(v2);
  v4 = sub_145843770(v3);
  v5 = sub_1440A35D0(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
  if ( v4 )
  {
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v5 + 0x10) == v6 )
    {
      ++*(_DWORD *)(v5 + 0x14);
    }
    else
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 1, 0);
      if ( v7 )
        sub_1403C33A0(v5, v7, "CSCActorPhysicsController::PrePhysicsUpdate", 1);
      else
        *(_QWORD *)(v5 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(v5 + 0x10) = v6;
    }
  }
  sub_145A2E710(a1);
  v8 = 0;
  if ( *(_BYTE *)(a1 + 0x2D8) )
  {
    v8 = 1;
    *(_BYTE *)(a1 + 0x2D8) = sub_145A3D0F0(a1, a1 + 0x258) ^ 1;
    if ( *(_BYTE *)(a1 + 0x2D9) )
    {
      *(_BYTE *)(a1 + 0x2D9) = 0;
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v9 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v9 = 0;
      (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v9 + 0x6E8LL))(v9, 0, a1);
    }
  }
  n2 = *(_DWORD *)(a1 + 0x30C);
  if ( n2 != *(_DWORD *)(a1 + 0x310) )
  {
    v8 = 1;
    if ( *(_BYTE *)(a1 + 0x4B8) || !n2 )
      sub_145A3C120(a1, n2, *(float *)(a1 + 0x400));
  }
  if ( *(_DWORD *)(a1 + 0x314) == *(_DWORD *)(a1 + 0x318) )
  {
    if ( !v8 )
      sub_1403A3CF0(a1, 0);
  }
  else
  {
    sub_145A3BBA0(a1);
  }
  if ( v4 )
  {
    v11 = *(_DWORD *)(v5 + 0x14);
    if ( v11 )
    {
      *(_DWORD *)(v5 + 0x14) = v11 - 1;
    }
    else
    {
      *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
      v12 = _InterlockedCompareExchange((volatile signed __int32 *)v5, 0, 1);
      if ( v12 == 1 )
        *(_QWORD *)(v5 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DB1F0(v5, v12);
    }
  }
  v18 = __rdtsc();
  return qword_149B4B878(&n0x4300);
}

// --- End Function: sub_145A35300 (0x145A35300) ---

// --- Function: sub_145A3A490 (0x145A3A490) ---
__int64 __fastcall sub_145A3A490(__int64 a1, int n2, char a3, float *a4)
{
  __int64 n2_1; // rax
  __int64 v5; // rbx
  float v6; // xmm2_4

  n2_1 = *(unsigned int *)(a1 + 0x310);
  v5 = a1;
  if ( (_DWORD)n2_1 != n2 )
  {
    *(_DWORD *)(a1 + 0x30C) = n2;
    if ( a4 )
    {
      v6 = *a4;
    }
    else if ( (unsigned int)(n2_1 - 3) > 3 || (unsigned int)(n2 - 3) <= 3 )
    {
      v6 = 0.0;
    }
    else
    {
      v6 = 0.30000001;
    }
    *(float *)(a1 + 0x400) = v6;
    if ( !a3 )
      return sub_1403A58C0(a1, 0);
    if ( *(_BYTE *)(a1 + 0x4B8) || !n2 )
      sub_145A3C120(a1, n2, v6);
    n2_1 = *(unsigned int *)(v5 + 0x310);
    if ( *(_DWORD *)(v5 + 0x30C) != (_DWORD)n2_1 )
    {
      a1 = v5;
      return sub_1403A58C0(a1, 0);
    }
  }
  return n2_1;
}

// --- End Function: sub_145A3A490 (0x145A3A490) ---

// --- Function: sub_145A3A5E0 (0x145A3A5E0) ---
double __fastcall sub_145A3A5E0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rsi
  char v7; // al
  __int64 v8; // rcx
  __int64 v9; // rdx
  int n0x4200; // [rsp+30h] [rbp-58h] BYREF
  __int64 v12; // [rsp+34h] [rbp-54h]
  int v13; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v14; // [rsp+40h] [rbp-48h]
  unsigned __int64 v15; // [rsp+48h] [rbp-40h]
  __int64 v16; // [rsp+50h] [rbp-38h]
  __int64 v17; // [rsp+58h] [rbp-30h]

  v3 = 0;
  n0x4200 = 0x4200;
  v12 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = __rdtsc();
  qword_149B4B870(
    &n0x4200,
    &word_149E6816C,
    "CSCActorPhysicsController::RequestTeleport",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorPhysicsController.cpp",
    0x59C);
  HIWORD(n0x4200) = word_149E6816C;
  *(_QWORD *)(a1 + 0x258) = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 0x260) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x268) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x270) = *(_QWORD *)(a2 + 0x18);
  *(_QWORD *)(a1 + 0x278) = *(_QWORD *)(a2 + 0x20);
  *(_OWORD *)(a1 + 0x280) = *(_OWORD *)(a2 + 0x28);
  *(double *)(a1 + 0x290) = *(double *)(a2 + 0x38);
  *(_QWORD *)(a1 + 0x298) = *(_QWORD *)(a2 + 0x40);
  *(_OWORD *)(a1 + 0x2A0) = *(_OWORD *)(a2 + 0x48);
  *(double *)(a1 + 0x2B0) = *(double *)(a2 + 0x58);
  *(_DWORD *)(a1 + 0x2B8) = *(_DWORD *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x2BC) = *(_DWORD *)(a2 + 0x64);
  *(_DWORD *)(a1 + 0x2C0) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x2C4) = *(_DWORD *)(a2 + 0x6C);
  *(double *)(a1 + 0x2C8) = *(double *)(a2 + 0x70);
  *(_DWORD *)(a1 + 0x2D0) = *(_DWORD *)(a2 + 0x78);
  *(_BYTE *)(a1 + 0x2D4) = *(_BYTE *)(a2 + 0x7C);
  *(_BYTE *)(a1 + 0x2D5) = *(_BYTE *)(a2 + 0x7D);
  *(_BYTE *)(a1 + 0x2D6) = *(_BYTE *)(a2 + 0x7E);
  *(_BYTE *)(a1 + 0x2D7) = *(_BYTE *)(a2 + 0x7F);
  *(_BYTE *)(a1 + 0x2D9) = 0;
  if ( a3 )
  {
    v7 = sub_145A3D0F0(a1, a2) ^ 1;
    *(_BYTE *)(a1 + 0x2D8) = v7;
    if ( !v7 )
      goto LABEL_15;
  }
  else
  {
    *(_BYTE *)(a1 + 0x2D8) = 1;
  }
  sub_1403A58C0(a1, 0);
  if ( !*(_BYTE *)(a1 + 0x4B8) )
  {
    if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
      v8 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
    else
      v8 = 0;
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x660LL))(v8) )
      sub_1403CF100(a1, 0);
    if ( *(_BYTE *)(a1 + 0x308) )
    {
      *(_BYTE *)(a1 + 0x2D9) = 1;
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v3 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      LOBYTE(v9) = 1;
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v3 + 0x6E8LL))(v3, v9, a1);
    }
  }
LABEL_15:
  v15 = __rdtsc();
  return qword_149B4B878(&n0x4200);
}

// --- End Function: sub_145A3A5E0 (0x145A3A5E0) ---

// --- Function: sub_145A3B9F0 (0x145A3B9F0) ---
char __fastcall sub_145A3B9F0(__int64 a1, double *a2)
{
  __m128 v2; // kr00_16
  __m128 v3; // xmm4
  float v4; // xmm4_4
  float v5; // kr00_4
  float v6; // eax
  double v7; // xmm0_8
  __int64 gEnv; // rbx
  char result; // al
  int event_key_from_source_location; // eax
  double v11; // [rsp+20h] [rbp-58h] BYREF
  float v12; // [rsp+28h] [rbp-50h]
  double *v13; // [rsp+30h] [rbp-48h] BYREF
  int event_key_from_source_location_1; // [rsp+38h] [rbp-40h]
  __int64 n0xC; // [rsp+40h] [rbp-38h]
  const char *p_struct_SPI_Player_GravityChanged; // [rsp+48h] [rbp-30h]
  char v17; // [rsp+50h] [rbp-28h]
  void (__fastcall *__StarEngineModule_)(ULONG_PTR); // [rsp+58h] [rbp-20h]
  __int64 (__fastcall *p_sub_1405A8C00)(__int64, __int64); // [rsp+60h] [rbp-18h]
  unsigned __int64 v20; // [rsp+80h] [rbp+8h] BYREF

  *(double *)(a1 + 0x18C) = *a2;
  *(_DWORD *)(a1 + 0x194) = *((_DWORD *)a2 + 2);
  v2 = (__m128)*(unsigned int *)a2;
  v2.m128_f32[0] = (float)((float)(*(float *)a2 * *(float *)a2) + (float)(*((float *)a2 + 1) * *((float *)a2 + 1)))
                 + (float)(*((float *)a2 + 2) * *((float *)a2 + 2));
  v3 = _mm_sqrt_ps(_mm_shuffle_ps(v2, v2, 0));
  v4 = _mm_shuffle_ps(v3, v3, 0xFF).m128_f32[0];
  *(float *)(a1 + 0x1BC) = v4;
  if ( v4 == 0.0 )
  {
    *(_QWORD *)&v11 = src__4 ^ 0x8000000080000000uLL;
    LODWORD(v12) = dword_149932E98 ^ 0x80000000;
  }
  else
  {
    v5 = (float)(1.0 / v4) * *((float *)a2 + 1);
    *(float *)&v11 = (float)(1.0 / v4) * *(float *)a2;
    v12 = (float)(1.0 / v4) * *((float *)a2 + 2);
    *((float *)&v11 + 1) = v5;
  }
  v6 = v12;
  *(double *)(a1 + 0x198) = v11;
  *(float *)(a1 + 0x1A0) = v6;
  v7 = *a2;
  gEnv = ::gEnv;
  v12 = *((float *)a2 + 2);
  v20 = *(_QWORD *)(a1 + 8);
  v11 = v7;
  result = sub_14030EC00(&v20);
  if ( result )
  {
    v13 = &v11;
    event_key_from_source_location = event_key_from_source_location_26;
    if ( !event_key_from_source_location_26 )
      event_key_from_source_location = get_event_key_from_source_location(
                                         &event_key_from_source_location_26,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/Player/Notifications.h",
                                         0xCE);
    event_key_from_source_location_1 = event_key_from_source_location;
    n0xC = 0xC;
    p_struct_SPI_Player_GravityChanged = "struct SPI_Player_GravityChanged";
    v17 = byte_149E68068;
    __StarEngineModule_ = _StarEngineModule__;
    p_sub_1405A8C00 = sub_1405A8C00;
    return (*(__int64 (__fastcall **)(__int64, unsigned __int64, double **))(*(_QWORD *)gEnv + 0x360LL))(
             gEnv,
             v20,
             &v13);
  }
  return result;
}

// --- End Function: sub_145A3B9F0 (0x145A3B9F0) ---

// --- Function: sub_145A3C120 (0x145A3C120) ---
double __fastcall sub_145A3C120(__int64 a1, int n2, float a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int128 v5; // xmm8
  __int128 v6; // xmm9
  __int128 v7; // xmm10
  __int128 v8; // xmm11
  __int128 v9; // xmm12
  __int128 v10; // xmm13
  __int128 v11; // xmm14
  __int64 v12; // rbx
  __int64 v15; // rax
  int n0xF; // eax
  __int64 v17; // rax
  __int64 v18; // r14
  __int64 v19; // rax
  unsigned int v20; // eax
  char v21; // cl
  unsigned int v22; // r12d
  unsigned int v23; // edi
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rcx
  __int64 v28; // rcx
  unsigned __int64 *v29; // r12
  __int64 v30; // rcx
  __int64 v31; // r9
  __int64 v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rax
  __int64 v36; // rdi
  __int64 v37; // rcx
  _BYTE *v38; // rdx
  __int64 v39; // rcx
  double v40; // xmm11_8
  double v41; // xmm8_8
  double v42; // xmm12_8
  double v43; // xmm13_8
  double v44; // xmm6_8
  double v45; // xmm9_8
  double v46; // kr00_8
  __int64 v47; // rcx
  __int64 v48; // rax
  const char *p_blend; // r9
  __int64 v50; // rax
  __int64 v51; // rcx
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // rdx
  __int64 v55; // rdi
  __int64 v56; // rax
  _QWORD *v57; // rax
  __int64 v58; // rax
  __int64 v59; // rcx
  __int64 v60; // rcx
  __int64 v61; // rdi
  const char *v63; // [rsp+68h] [rbp-98h]
  int v64; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int64 v65; // [rsp+78h] [rbp-88h] BYREF
  _DWORD v66[4]; // [rsp+80h] [rbp-80h] BYREF
  double v67; // [rsp+90h] [rbp-70h] BYREF
  __int64 v68; // [rsp+98h] [rbp-68h]
  double v69; // [rsp+A0h] [rbp-60h]
  double v70; // [rsp+A8h] [rbp-58h]
  double v71; // [rsp+B0h] [rbp-50h]
  double v72; // [rsp+B8h] [rbp-48h]
  double v73; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v74; // [rsp+D0h] [rbp-30h] BYREF
  int n0x4300; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v76; // [rsp+E4h] [rbp-1Ch]
  int v77; // [rsp+ECh] [rbp-14h]
  unsigned __int64 v78; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v79; // [rsp+F8h] [rbp-8h]
  __int64 v80; // [rsp+100h] [rbp+0h]
  __int64 v81; // [rsp+108h] [rbp+8h]
  _DWORD v82[20]; // [rsp+130h] [rbp+30h] BYREF
  unsigned __int64 v83; // [rsp+180h] [rbp+80h]
  unsigned int v84; // [rsp+188h] [rbp+88h]
  unsigned int v85; // [rsp+18Ch] [rbp+8Ch]
  unsigned int v86; // [rsp+190h] [rbp+90h]
  unsigned int v87; // [rsp+194h] [rbp+94h]
  unsigned int v88; // [rsp+198h] [rbp+98h]
  unsigned int v89; // [rsp+19Ch] [rbp+9Ch]
  unsigned int v90; // [rsp+1A0h] [rbp+A0h]
  unsigned int v91; // [rsp+1B0h] [rbp+B0h]
  _DWORD v92[8]; // [rsp+1C0h] [rbp+C0h] BYREF
  __int128 v93; // [rsp+1E0h] [rbp+E0h]
  int v94; // [rsp+1F0h] [rbp+F0h]
  unsigned int v95; // [rsp+1F4h] [rbp+F4h]
  unsigned int v96; // [rsp+1F8h] [rbp+F8h]
  unsigned int v97; // [rsp+204h] [rbp+104h]
  unsigned int v98; // [rsp+208h] [rbp+108h]
  unsigned int v99; // [rsp+214h] [rbp+114h]
  _BYTE v100[16]; // [rsp+220h] [rbp+120h] BYREF
  _BYTE v101[96]; // [rsp+230h] [rbp+130h] BYREF
  __int128 v102; // [rsp+290h] [rbp+190h]
  __int128 v103; // [rsp+2A0h] [rbp+1A0h]
  _BYTE v104[96]; // [rsp+2B0h] [rbp+1B0h]
  _BYTE v105[12]; // [rsp+310h] [rbp+210h] BYREF
  int v106; // [rsp+31Ch] [rbp+21Ch]
  int v107; // [rsp+320h] [rbp+220h]
  _DWORD v108[36]; // [rsp+3A0h] [rbp+2A0h] BYREF
  __int64 v109; // [rsp+430h] [rbp+330h] BYREF
  __int64 n0x1FF; // [rsp+438h] [rbp+338h]
  _BYTE *v111; // [rsp+440h] [rbp+340h]
  _BYTE v112[520]; // [rsp+448h] [rbp+348h] BYREF
  __int128 v113; // [rsp+660h] [rbp+560h]
  __int128 v114; // [rsp+670h] [rbp+570h]
  __int128 v115; // [rsp+680h] [rbp+580h]
  __int128 v116; // [rsp+690h] [rbp+590h]
  __int128 v117; // [rsp+6A0h] [rbp+5A0h]
  __int128 v118; // [rsp+6B0h] [rbp+5B0h]
  __int128 v119; // [rsp+6C0h] [rbp+5C0h]
  __int128 v120; // [rsp+6D0h] [rbp+5D0h]
  __int128 v121; // [rsp+6E0h] [rbp+5E0h]

  v113 = v11;
  v12 = 0;
  v76 = 0;
  v77 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  n0x4300 = 0x4300;
  v78 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E68168,
    "CSCActorPhysicsController::SetProfile",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorPhysicsController.cpp",
    0x357);
  HIWORD(n0x4300) = word_149E68168;
  if ( n2 != *(_DWORD *)(a1 + 0x310) )
  {
    v15 = sub_1465EEE60(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
    if ( *(_QWORD *)sub_14583F5E0(v15) )
    {
      n0xF = *(_DWORD *)(a1 + 0xAC);
      if ( n0xF == 0xF )
      {
        sub_145A34030(a1);
      }
      else if ( !n0xF )
      {
        v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL) + 0x768LL))(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
        v18 = v17;
        if ( !v17 )
          goto LABEL_99;
        if ( (unsigned int)(n2 - 3) > 3 )
        {
          v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x20LL))(v17);
          v20 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v19 + 0xA0LL))(v19, 0);
          v21 = 0;
          v22 = v20;
          v23 = 0;
          if ( !v20 )
            goto LABEL_99;
          do
          {
            if ( v21 )
              goto LABEL_13;
            v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x20LL))(v18);
            v25 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v24 + 0xB8LL))(v24, 0, v23++);
            v21 = *(_BYTE *)(v25 + 0x54) & 1;
          }
          while ( v23 < v22 );
          if ( !v21 )
          {
            v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x20LL))(v18);
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x40LL))(v26);
            goto LABEL_99;
          }
        }
LABEL_13:
        if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
          v27 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v27 = 0;
        (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v27 + 0x5B0LL))(v27, 1, 0x13);
      }
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v28 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v28 = 0;
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v28 + 0x3B8LL))(v28, &v65);
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v29 = (unsigned __int64 *)(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
      else
        v29 = 0;
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v30 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v30 = 0;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x440LL))(v30);
      switch ( n2 )
      {
        case 0:
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v32 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v32 = 0;
          LOBYTE(v31) = 1;
          (*(void (__fastcall **)(__int64, _QWORD, __int64, __int64))(*(_QWORD *)v32 + 0x5B0LL))(v32, 0, 0x13, v31);
          v66[0] = 3;
          v66[1] = 1;
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v33 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v33 = 0;
          (*(void (__fastcall **)(__int64, _DWORD *, _QWORD, _QWORD))(*(_QWORD *)v33 + 0x408LL))(v33, v66, 0, 0);
          *(_QWORD *)(a1 + 0x13C) = 0;
          *(_DWORD *)(a1 + 0x138) = 0;
          *(_QWORD *)(a1 + 0x148) = 0;
          *(_DWORD *)(a1 + 0x144) = 0;
          *(_QWORD *)(a1 + 0x154) = 0;
          *(_DWORD *)(a1 + 0x150) = 0;
          *(_QWORD *)(a1 + 0x160) = 0;
          *(_DWORD *)(a1 + 0x15C) = 0;
          *(_QWORD *)(a1 + 0x16C) = 0;
          *(_DWORD *)(a1 + 0x168) = 0;
          *(_QWORD *)(a1 + 0x178) = 0;
          *(_DWORD *)(a1 + 0x174) = 0;
          *(_DWORD *)(a1 + 0x1B0) = 0;
          *(_QWORD *)(a1 + 0x47C) = 0;
          *(_DWORD *)(a1 + 0x478) = 0;
          goto LABEL_89;
        case 1:
        case 2:
          if ( !v65 || *(_QWORD *)((v65 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v65) )
            goto LABEL_59;
          if ( *(_DWORD *)(a1 + 0x310) == 8 )
          {
            *(_QWORD *)&v67 = 0x8000000000000008uLL;
            v68 = 0x80000000LL;
            v69 = 0.0;
            LODWORD(v70) = 0xFFBFFFFF;
            HIDWORD(v71) = 0;
            if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
              v34 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v34 = 0;
            (*(void (__fastcall **)(__int64, double *, _QWORD, _QWORD))(*(_QWORD *)v34 + 0x408LL))(v34, &v67, 0, 0);
            v35 = sub_1403335B0(a1);
            v36 = sub_143192820(*(_QWORD *)(v35 + 0x18));
            sub_142EC37E0((__int64)v105);
            v106 = *(_DWORD *)(v36 + 0x38);
            v107 = *(_DWORD *)(v36 + 0x34);
            if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            {
              v38 = v105;
              v37 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              v37 = 0;
              v38 = v105;
            }
LABEL_88:
            (*(void (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v37 + 0x3F8LL))(v37, v38, 0, 0);
          }
          else if ( (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 8LL))(v65 & 0xFFFFFFFFFFFFLL) == 6
                 && *(_DWORD *)(a1 + 0x310) )
          {
            v121 = v3;
            v120 = v4;
            v119 = v5;
            v118 = v6;
            v117 = v7;
            v116 = v8;
            v115 = v9;
            v114 = v10;
            if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
              v39 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v39 = 0;
            (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v39 + 0x268LL))(v39, &v67, 0);
            v40 = *(double *)&v68 * v67 - v69 * v70 + *(double *)&v68 * v67 - v69 * v70;
            v41 = v70 * v70 + v70 * v70;
            v42 = *(double *)&v68 * *(double *)&v68 + *(double *)&v68 * *(double *)&v68 + v41 - 1.0;
            v43 = v67 * v70 + v67 * v70 + *(double *)&v68 * v69 + *(double *)&v68 * v69;
            v44 = *(double *)&v68 * v70 + *(double *)&v68 * v70 + v67 * v69 + v67 * v69;
            v45 = *(double *)&v68 * v69 - v67 * v70 + *(double *)&v68 * v69 - v67 * v70;
            v46 = v69 * v69 + v69 * v69 + v41 - 1.0;
            v112[0] = 0;
            v111 = v112;
            v109 = 0;
            n0x1FF = 0x1FF;
            if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
              v47 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v47 = 0;
            v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v47 + 0x648LL))(v47);
            v63 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x1F0LL))(v48);
            p_blend = "snap";
            if ( n2 == 2 )
              p_blend = "blend";
            v50 = sub_1402A3190(
                    (__int64)&v109,
                    "%s: mode=%s pos(%.2f, %.2f, %.2f) dir(%.2f, %.2f, %.2f) up(%.2f, %.2f, %.2f) zone='%s'",
                    "CSCActorPhysicsController::SetProfile",
                    p_blend,
                    v71,
                    v72,
                    v73,
                    v40,
                    v42,
                    v43,
                    v44,
                    v45,
                    v46,
                    v63);
            sub_144E57960(v29, *(_QWORD *)(v50 + 0x10));
            if ( v111 != v112 )
            {
              qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
              sub_147605980(v111);
            }
            sub_141EF04A0((__int64)v101);
            v94 = 0;
            v93 = xmmword_148218FC0;
            v92[0] = 1;
            v92[4] = 0xFFBFFFFF;
            v92[1] = 0xFFBFFFFF;
            v92[7] = 0xFFBFFFFF;
            v95 = 0xFFBFFFFF;
            v97 = 0xFFBFFFFF;
            v98 = 0xFFBFFFFF;
            v99 = 0x80000000;
            v96 = 0xFFBFFFFF;
            sub_142EC37E0((__int64)v108);
            sub_145A316A0(a1, (__int64)v101, (__int64)v92, v108);
            *((_QWORD *)&v102 + 1) = v92;
            BYTE8(v103) = n2 == 2;
            *(_QWORD *)&v103 = v108;
            *((float *)&v103 + 3) = a3;
            if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
              v51 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v51 = 0;
            (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v51 + 0x390LL))(v51, v101);
            *(__m256i *)(a1 + 0x320) = *(__m256i *)v101;
            *(__m256i *)(a1 + 0x340) = *(__m256i *)&v101[0x20];
            *(__m256i *)(a1 + 0x360) = *(__m256i *)&v101[0x40];
            *(_OWORD *)(a1 + 0x380) = v102;
            *(_OWORD *)(a1 + 0x390) = v103;
            *(__m256i *)(a1 + 0x3A0) = *(__m256i *)v104;
            *(__m256i *)(a1 + 0x3C0) = *(__m256i *)&v104[0x20];
            *(__m256i *)(a1 + 0x3E0) = *(__m256i *)&v104[0x40];
            __asm { vzeroupper }
            sub_1465FAFF0((__int64)v29);
          }
          else
          {
LABEL_59:
            v52 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v29 + 0x768))(v29);
            if ( v52 && ((*(_DWORD *)(a1 + 0x310) - 3) & 0xFFFFFFFD) == 0 )
            {
              v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 0x30LL))(v52);
              LOBYTE(v54) = 1;
              (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v53 + 0x268LL))(v53, v54);
            }
            v55 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v29 + 0x768))(v29);
            if ( v65
              && *(_QWORD *)((v65 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v65)
              && (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 8LL))(v65 & 0xFFFFFFFFFFFFLL) == 0xB )
            {
              if ( !v55 )
                goto LABEL_89;
              v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x30LL))(v55);
              v57 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v56 + 0x28LL))(v56, v100);
              if ( *v57 )
              {
                if ( *(_QWORD *)((*v57 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*v57) )
                  goto LABEL_69;
              }
            }
            sub_145A34030(a1);
            if ( v55 )
            {
LABEL_69:
              v58 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x30LL))(v55);
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x90LL))(v58);
            }
          }
          goto LABEL_89;
        case 3:
        case 4:
        case 5:
          if ( v65 && *(_QWORD *)((v65 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v65) )
          {
            sub_145A344E0(a1, n2);
LABEL_89:
            if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
              v60 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
            else
              v60 = 0;
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v60 + 0x448LL))(v60);
            if ( (unsigned int)(*(_DWORD *)(a1 + 0x310) - 3) <= 3 )
            {
              if ( (unsigned int)(n2 - 3) <= 3 )
                goto LABEL_97;
              v64 = 0;
              v61 = sub_1465EECD0((__int64)v29);
              sub_14035C4A0(&v64, 0xFA);
              sub_145ED3E50(v61, &v64);
            }
            if ( n2 == 1 )
            {
              sub_14325AD60(a1);
LABEL_98:
              *(_DWORD *)(a1 + 0x310) = n2;
              *(_DWORD *)(a1 + 0xAC) = n2 != 0 ? 0xB : 0;
              break;
            }
LABEL_97:
            sub_14326CF90(a1);
            goto LABEL_98;
          }
          sub_145A3C120(a1, 1, 0.0);
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v12 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x448LL))(v12);
          break;
        case 6:
          sub_145A344E0(a1, 6);
          goto LABEL_89;
        case 7:
          goto LABEL_59;
        case 8:
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v59 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v59 = 0;
          (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v59 + 0x3B8LL))(v59, &v74);
          if ( !v74
            || *(_QWORD *)((v74 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v74)
            || (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(v74 & 0xFFFFFFFFFFFFLL) + 8LL))(v74 & 0xFFFFFFFFFFFFLL) != 0xB )
          {
            sub_145A34030(a1);
          }
          v82[0] = 4;
          v83 = 0xFFFFFFFFFFFFFFFFuLL;
          *(float *)&v82[3] = 1.0;
          *(float *)&v82[4] = 0.0;
          v82[1] = 0xFFBFFFFF;
          v82[2] = 0xFFBFFFFF;
          v82[5] = 0xFFBFFFFF;
          v82[6] = 0xFFBFFFFF;
          v82[8] = 0xFFBFFFFF;
          v82[0xB] = 0xFFBFFFFF;
          v82[9] = 0x80000000;
          v82[0xA] = 0x80000000;
          v82[0xC] = 0x80000000;
          v85 = 0x80000000;
          v82[0x12] = 0x80000000;
          v82[0xD] = 0xFFBFFFFF;
          v82[0xE] = 0xFFBFFFFF;
          v82[0xF] = 0xFFBFFFFF;
          v82[0x10] = 0xFFBFFFFF;
          v84 = 0x80000000;
          v82[0x11] = 0xFFBFFFFF;
          v86 = 0x80000000;
          v91 = 0xFFBFFFFF;
          v88 = 0x80000000;
          v89 = 0x80000000;
          v90 = 0x80000000;
          v87 = 0x80000000;
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v37 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v37 = 0;
          v38 = v82;
          goto LABEL_88;
        default:
          goto LABEL_89;
      }
    }
  }
LABEL_99:
  v79 = __rdtsc();
  return qword_149B4B878(&n0x4300);
}

// --- End Function: sub_145A3C120 (0x145A3C120) ---

// --- Function: sub_145A3D0F0 (0x145A3D0F0) ---
__int64 __fastcall sub_145A3D0F0(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm8
  __int128 v3; // xmm9
  __int128 v4; // xmm10
  __int128 v5; // xmm11
  __int128 v6; // xmm12
  __int128 v7; // xmm13
  __int128 v8; // xmm14
  __int128 v9; // xmm15
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r13
  __int64 v16; // rax
  __int64 v17; // r10
  __int64 v18; // rax
  _QWORD *v19; // rcx
  double v20; // xmm9_8
  __int128 *v22; // rdx
  __int64 v23; // r12
  __int128 v24; // xmm0
  __int64 v25; // rbx
  __int64 v26; // rbx
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rbx
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rbx
  __int64 (__fastcall *v35)(__int64, unsigned __int64 *, __int64, const char *, __int128 *); // r12
  __int64 v36; // rax
  __m256 v37; // ymm1
  __int128 v38; // xmm0
  __int128 *v39; // rcx
  __int64 *v40; // rdx
  __m256 v41; // ymm1
  __int128 v42; // xmm1
  __int64 v43; // rax
  __int64 v44; // rsi
  __int64 v45; // rax
  _QWORD *v46; // rax
  __int64 v47; // rcx
  _QWORD *v48; // rbx
  _QWORD *v49; // rax
  double v52; // xmm1_8
  __int64 v53; // rax
  __int64 v54; // rcx
  unsigned __int64 *v55; // rax
  __int64 v56; // rcx
  unsigned __int8 v57; // bl
  __int64 v58; // rsi
  bool v59; // al
  __int64 v60; // rcx
  __int64 v61; // rsi
  void (__fastcall *v62)(__int64, __int128 *, __int64 *, unsigned __int64 *, int, unsigned int, __int128 *, _QWORD, __int64 *, int, _QWORD, _BYTE); // rbx
  bool v63; // cl
  void (__fastcall *v64)(__int64, __m256 *, __int64, __int64, int, _QWORD); // r10
  double v65; // kr00_8
  double v66; // xmm11_8
  double v67; // xmm12_8
  __int64 v74; // rax
  __int128 v76; // kr00_16
  __int64 v78; // rcx
  __int64 v79; // rcx
  unsigned __int64 *v80; // rax
  __int64 v81; // rcx
  __int64 v82; // rax
  void (__fastcall *v83)(__int64, __int64, __int64, _QWORD, _QWORD); // rbx
  __int64 v84; // rax
  __int64 v85; // rax
  double v86; // xmm10_8
  double v87; // xmm6_8
  double v88; // xmm12_8
  __int128 v89; // xmm11
  __int128 v90; // kr00_16
  double v91; // xmm15_8
  double v92; // xmm14_8
  __int64 v93; // rax
  __int64 v102; // rcx
  void (__fastcall *v103)(__int64, __int64, __int64, _QWORD, _QWORD); // rbx
  __int64 v104; // rax
  float v105; // xmm6_4
  __m128 v106; // xmm7
  float v107; // xmm4_4
  float v108; // xmm5_4
  __m128 v109; // kr00_16
  __int64 v110; // rbx
  __int64 v113; // rax
  __int64 v114; // rcx
  __int64 v115; // rax
  __int64 v116; // rcx
  __int64 v117; // rax
  __int64 v118; // rbx
  __int64 v119; // rcx
  __int64 v120; // rax
  __int64 v121; // rcx
  __int64 v122; // rax
  __int64 *v123; // rsi
  __int64 v124; // rbx
  __int64 v125; // rax
  __int16 n4; // cx
  __int64 v127; // rbx
  __int64 v128; // rcx
  __int64 v129; // rax
  bool v130; // al
  __int64 gEnv; // rsi
  float v132; // eax
  __int64 v133; // rcx
  char **v134; // rax
  char **v135; // r13
  __int64 v136; // rcx
  _QWORD *v137; // rax
  const char *v138; // rax
  char **v139; // rax
  __int64 v140; // rax
  __int64 v141; // rbx
  char *v142; // r15
  unsigned __int64 *v143; // rcx
  double *v144; // rax
  double v146; // xmm7_8
  int v147; // eax
  char n0xCC_2; // r15
  int v149; // r13d
  __int128 v152; // kr00_16
  const char *p_Success; // rax
  const char *p_unknown; // rbx
  const char *p_unknown_1; // rax
  __int64 v159; // rcx
  Server **p_Server; // rax
  __int64 v161; // rcx
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v163; // rcx
  __int64 v164; // rcx
  __int64 v165; // rcx
  int v167; // [rsp+20h] [rbp-120h]
  int v168; // [rsp+20h] [rbp-120h]
  int v169; // [rsp+20h] [rbp-120h]
  int v170; // [rsp+20h] [rbp-120h]
  __int64 *ThreadLogContextSlot; // [rsp+40h] [rbp-100h]
  double v172; // [rsp+C0h] [rbp-80h] BYREF
  __int128 v173; // [rsp+C8h] [rbp-78h] BYREF
  __int64 v174; // [rsp+D8h] [rbp-68h]
  float v175; // [rsp+E0h] [rbp-60h] BYREF
  float v176; // [rsp+E4h] [rbp-5Ch]
  float v177; // [rsp+E8h] [rbp-58h]
  float v178; // [rsp+ECh] [rbp-54h]
  __int128 v179; // [rsp+F0h] [rbp-50h] BYREF
  __m256 v180; // [rsp+100h] [rbp-40h] BYREF
  __int128 v181; // [rsp+120h] [rbp-20h] BYREF
  __int128 v182; // [rsp+130h] [rbp-10h]
  unsigned __int64 v183; // [rsp+140h] [rbp+0h] BYREF
  __int64 v184; // [rsp+148h] [rbp+8h] BYREF
  const char *p_CSCActorPhysicsController::Teleport; // [rsp+150h] [rbp+10h]
  const void *v186; // [rsp+158h] [rbp+18h]
  __int128 *v187; // [rsp+160h] [rbp+20h] BYREF
  __m256 v188; // [rsp+168h] [rbp+28h]
  __int128 v189; // [rsp+188h] [rbp+48h]
  __m256 v190; // [rsp+198h] [rbp+58h]
  double v191; // [rsp+1B8h] [rbp+78h]
  __int128 v192; // [rsp+1C0h] [rbp+80h]
  double v193; // [rsp+1D0h] [rbp+90h]
  int v194; // [rsp+1D8h] [rbp+98h]
  char v195; // [rsp+1DCh] [rbp+9Ch]
  char v196; // [rsp+1DDh] [rbp+9Dh]
  char v197; // [rsp+1DEh] [rbp+9Eh]
  char v198; // [rsp+1DFh] [rbp+9Fh]
  __int64 v199; // [rsp+1E0h] [rbp+A0h]
  unsigned __int64 v200; // [rsp+1F0h] [rbp+B0h] BYREF
  __int128 v201; // [rsp+1F8h] [rbp+B8h] BYREF
  double v202; // [rsp+208h] [rbp+C8h]
  unsigned __int64 v203; // [rsp+210h] [rbp+D0h] BYREF
  __m256 v204; // [rsp+218h] [rbp+D8h]
  float v205; // [rsp+238h] [rbp+F8h]
  float v206; // [rsp+23Ch] [rbp+FCh]
  unsigned int v207; // [rsp+240h] [rbp+100h]
  unsigned int v208; // [rsp+244h] [rbp+104h]
  int n0x80; // [rsp+248h] [rbp+108h]
  unsigned int v210; // [rsp+24Ch] [rbp+10Ch]
  __int64 v211; // [rsp+250h] [rbp+110h]
  unsigned int v212; // [rsp+260h] [rbp+120h]
  __int64 v213; // [rsp+268h] [rbp+128h]
  int v214; // [rsp+270h] [rbp+130h]
  float v215; // [rsp+274h] [rbp+134h]
  float v216; // [rsp+278h] [rbp+138h]
  float v217; // [rsp+27Ch] [rbp+13Ch]
  unsigned int v218; // [rsp+280h] [rbp+140h]
  int v219; // [rsp+284h] [rbp+144h]
  float v220; // [rsp+288h] [rbp+148h]
  float v221; // [rsp+28Ch] [rbp+14Ch]
  float v222; // [rsp+290h] [rbp+150h]
  __int64 v223; // [rsp+298h] [rbp+158h]
  int v224; // [rsp+2A0h] [rbp+160h]
  _QWORD v225[2]; // [rsp+2B0h] [rbp+170h] BYREF
  double v226; // [rsp+2C0h] [rbp+180h]
  _QWORD v227[2]; // [rsp+2C8h] [rbp+188h] BYREF
  const void *v228; // [rsp+2D8h] [rbp+198h]
  int n0x4300; // [rsp+2E0h] [rbp+1A0h] BYREF
  __int64 v230; // [rsp+2E4h] [rbp+1A4h]
  int v231; // [rsp+2ECh] [rbp+1ACh]
  unsigned __int64 v232; // [rsp+2F0h] [rbp+1B0h]
  unsigned __int64 v233; // [rsp+2F8h] [rbp+1B8h]
  __int64 v234; // [rsp+300h] [rbp+1C0h]
  __int64 v235; // [rsp+308h] [rbp+1C8h]
  _QWORD v236[2]; // [rsp+330h] [rbp+1F0h] BYREF
  const void *v237; // [rsp+340h] [rbp+200h]
  _QWORD v238[2]; // [rsp+348h] [rbp+208h] BYREF
  const void *v239; // [rsp+358h] [rbp+218h]
  _QWORD v240[2]; // [rsp+360h] [rbp+220h] BYREF
  const void *v241; // [rsp+370h] [rbp+230h]
  _QWORD v242[2]; // [rsp+378h] [rbp+238h] BYREF
  const void *v243; // [rsp+388h] [rbp+248h]
  _QWORD v244[2]; // [rsp+390h] [rbp+250h] BYREF
  __int64 v245[2]; // [rsp+3A0h] [rbp+260h] BYREF
  __int64 v246; // [rsp+3B0h] [rbp+270h] BYREF
  char v247[8]; // [rsp+3B8h] [rbp+278h] BYREF
  __int64 v248; // [rsp+3C0h] [rbp+280h] BYREF
  __int128 v249; // [rsp+3C8h] [rbp+288h]
  double v250; // [rsp+3D8h] [rbp+298h]
  __int64 v251; // [rsp+3E0h] [rbp+2A0h] BYREF
  __int128 v252; // [rsp+3E8h] [rbp+2A8h]
  double v253; // [rsp+3F8h] [rbp+2B8h]
  __int64 v254; // [rsp+400h] [rbp+2C0h] BYREF
  __int128 v255; // [rsp+408h] [rbp+2C8h]
  double v256; // [rsp+418h] [rbp+2D8h]
  __int64 v257; // [rsp+420h] [rbp+2E0h] BYREF
  __int128 v258; // [rsp+428h] [rbp+2E8h]
  __int64 v259; // [rsp+438h] [rbp+2F8h]
  char v260[32]; // [rsp+440h] [rbp+300h] BYREF
  __int128 v261; // [rsp+460h] [rbp+320h]
  __int64 v262; // [rsp+470h] [rbp+330h]
  __int128 v263; // [rsp+480h] [rbp+340h]
  __int128 v264; // [rsp+490h] [rbp+350h]
  __int128 v265; // [rsp+4A0h] [rbp+360h]
  __int128 v266; // [rsp+4B0h] [rbp+370h]
  __int128 v267; // [rsp+4C0h] [rbp+380h]
  __int128 v268; // [rsp+4D0h] [rbp+390h]
  __int128 v269; // [rsp+4E0h] [rbp+3A0h]
  __int128 v270; // [rsp+4F0h] [rbp+3B0h]
  unsigned __int64 n0xCC_1; // [rsp+570h] [rbp+430h] BYREF
  __int64 n0xCC; // [rsp+578h] [rbp+438h] BYREF
  __int64 v273; // [rsp+580h] [rbp+440h] BYREF
  const char *p_Success_1; // [rsp+588h] [rbp+448h] BYREF

  v270 = v2;
  v230 = 0;
  v231 = 0;
  v233 = 0;
  v234 = 0;
  v235 = 0;
  v269 = v3;
  n0x4300 = 0x4300;
  v232 = __rdtsc();
  qword_149B4B870(
    &n0x4300,
    &word_149E68170,
    "CSCActorPhysicsController::Teleport",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorPhysicsController.cpp",
    0x5D6);
  HIWORD(n0x4300) = word_149E68170;
  if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
    v12 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
  else
    v12 = 0;
  v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x768LL))(v12);
  if ( v13 )
  {
    v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x30LL))(v13);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x90LL))(v14);
  }
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v15 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v15 = 0;
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x648LL))(v15);
  v17 = *(_QWORD *)v15;
  v273 = v16;
  (*(void (__fastcall **)(__int64, char *, __int64))(v17 + 0x1E8))(v15, v260, 2);
  LOBYTE(v167) = 0;
  v18 = (*(__int64 (__fastcall **)(__int64, __int128 **, _QWORD, _QWORD, int))(*(_QWORD *)v15 + 0x1E8LL))(
          v15,
          &v187,
          0,
          0,
          v167);
  v19 = (_QWORD *)(*(_QWORD *)(a1 + 0x128) & 0xFFFFFFFFFFFFLL);
  v20 = *(double *)(v18 + 0x30);
  _XMM8 = *(_OWORD *)(v18 + 0x20);
  v179 = _XMM8;
  *(double *)&n0xCC = v20;
  v226 = v20;
  CEntityTemplate::GetAttachmentOffsetVec3(v19, &v175);
  v22 = *(__int128 **)a2;
  v23 = 0;
  v24 = *(_OWORD *)(a2 + 0x28);
  v180 = *(__m256 *)(a2 + 8);
  v182 = *(_OWORD *)(a2 + 0x38);
  v181 = v24;
  if ( v22 )
  {
    __asm { vzeroupper }
    v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)::gEnv + 0x118LL))(::gEnv);
    v31 = v30;
    if ( v30 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x50LL))(v30) )
      {
        v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x668LL))(v31);
        goto LABEL_34;
      }
    }
    else
    {
      v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
      v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x1D0LL))(v32);
      (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)v33 + 0x100LL))(
        v33,
        &v183,
        *(_QWORD *)(a1 + 8));
      if ( sub_14030EC00(&v183) )
      {
        if ( !*(_QWORD *)(a1 + 0x2E0)
          || fabs(*(double *)(a2 + 0x48) - *(double *)(a1 + 0x2E8)) > 0.05000000074505806
          || fabs(*(double *)(a2 + 0x50) - *(double *)(a1 + 0x2F0)) > 0.05000000074505806
          || fabs(*(double *)(a2 + 0x58) - *(double *)(a1 + 0x2F8)) > 0.05000000074505806 )
        {
          *(_OWORD *)(a1 + 0x2E8) = *(_OWORD *)(a2 + 0x48);
          *(double *)(a1 + 0x2F8) = *(double *)(a2 + 0x58);
          *(_QWORD *)(a1 + 0x300) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40
                                                                                          + 0x38LL))(
                                                 qword_149B4FC40,
                                                 0);
          v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)::gEnv + 0x2D0LL))(::gEnv);
          v35 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *, __int64, const char *, __int128 *))(*(_QWORD *)v34 + 0x30LL);
          v36 = (*(__int64 (__fastcall **)(unsigned __int64, double *))(*(_QWORD *)(v183 & 0xFFFFFFFFFFFFLL) + 8LL))(
                  v183 & 0xFFFFFFFFFFFFLL,
                  &v172);
          v37 = *(__m256 *)(a2 + 8);
          v38 = *(_OWORD *)(a2 + 0x28);
          v39 = *(__int128 **)a2;
          v40 = (__int64 *)v36;
          v194 = *(_DWORD *)(a2 + 0x78);
          v195 = *(_BYTE *)(a2 + 0x7C);
          LOBYTE(v36) = *(_BYTE *)(a2 + 0x7D);
          v188 = v37;
          v41 = *(__m256 *)(a2 + 0x38);
          v196 = v36;
          LOBYTE(v36) = *(_BYTE *)(a2 + 0x7E);
          v190 = v41;
          v42 = *(_OWORD *)(a2 + 0x60);
          v197 = v36;
          LOBYTE(v36) = *(_BYTE *)(a2 + 0x7F);
          v189 = v38;
          *(_QWORD *)&v38 = *(_QWORD *)(a2 + 0x58);
          v192 = v42;
          *(_QWORD *)&v42 = *(_QWORD *)(a2 + 0x70);
          v198 = v36;
          v43 = *v40;
          v187 = v39;
          v199 = v43;
          v191 = *(double *)&v38;
          v193 = *(double *)&v42;
          __asm { vzeroupper }
          v44 = sub_142F6ECE0((__int64)&v203, (__int64)&v187);
          v45 = allocWithProfilerInfo_w(0x88u);
          if ( v45 )
            v174 = sub_142F6ECE0(v45, v44);
          else
            v174 = 0;
          *(_QWORD *)&v173 = sub_145A281D0;
          *((_QWORD *)&v173 + 1) = sub_145A284B0;
          v46 = (_QWORD *)v35(v34, &n0xCC_1, 1, "Teleport", &v173);
          v47 = *(_QWORD *)(a1 + 0x2E0);
          v48 = v46;
          *(_QWORD *)(a1 + 0x2E0) = *v46;
          *v46 = v47;
          if ( v47 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v47 + 0x10LL))(v47);
          *v48 = 0;
          if ( n0xCC_1 )
            (*(void (__fastcall **)(unsigned __int64))(*(_QWORD *)n0xCC_1 + 0x10LL))(n0xCC_1);
          n0xCC_1 = 0;
          if ( *((_QWORD *)&v173 + 1) >= 2u )
            (*((void (__fastcall **)(__int64, __int128 *))&v173 + 1))(2, &v173);
        }
        v49 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                          qword_149B4FC40,
                          0);
        sub_1405975C0(v49, &v246, (_QWORD *)(a1 + 0x300));
        _XMM0 = sub_140597760();
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        if ( *(float *)&_XMM1 > 10.0 )
        {
          v29 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v183 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v183 & 0xFFFFFFFFFFFFLL);
          v52 = *(double *)(a2 + 0x58);
          v181 = *(_OWORD *)(a2 + 0x48);
          *(double *)&v182 = v52;
          goto LABEL_34;
        }
      }
    }
    v57 = 0;
    goto LABEL_178;
  }
  __asm { vzeroupper }
  if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
    v25 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
  else
    v25 = 0;
  v26 = *(_QWORD *)(v25 + 8);
  v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
  v28 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x1D0LL))(v27);
  (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v28 + 0x100LL))(v28, &v200, v26);
  if ( !sub_14030EC00(&v200) )
    goto LABEL_38;
  v29 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v200 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v200 & 0xFFFFFFFFFFFFLL);
LABEL_34:
  v23 = v29;
  if ( v29 )
  {
    v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x20LL))(v29);
    if ( v53 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x58LL))(v53) )
        v23 = 0;
    }
  }
LABEL_38:
  LOBYTE(n0xCC_1) = 0;
  CreateStringObjectFromString((void **)&p_Success_1, (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source);
  if ( *(_DWORD *)(a1 + 0x310) != 7
    || (sub_14030EC00((unsigned __int64 *)(a1 + 8)) ? (v54 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) : (v54 = 0),
        (v55 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v54 + 0x150LL))(v54, v247),
         !sub_14030EC00(v55))
     || (sub_14030EC00((unsigned __int64 *)(a1 + 8)) ? (v56 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) : (v56 = 0),
         (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v56 + 0x178LL))(v56) == 9)) )
  {
    if ( !v23 )
    {
      assignCStringToStringStructure(
        (void **)&p_Success_1,
        "Trying to teleport an actor to a position in an unknown zone, failing");
      v58 = v273;
LABEL_124:
      if ( *(_BYTE *)(a2 + 0x7C) )
      {
        v133 = is_valid_handle_typeA((__int64 *)(a1 + 0x118)) ? *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL : 0LL;
        if ( sub_1465D1DE0(v133) )
        {
          v140 = sub_144E30AE0();
          v141 = v140;
          if ( v140 )
          {
            if ( !(unsigned __int8)sub_144E31650(v140, 1) )
              sub_144E2E4E0(v141, 1, 0.0, 1, 1u);
          }
        }
      }
      v142 = off_149A44400;
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v143 = (unsigned __int64 *)(*(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL);
      else
        v143 = 0;
      if ( sub_144E5DE60(v143, v142) )
      {
        if ( v23 )
        {
          v144 = (double *)(*(__int64 (__fastcall **)(__int64, _QWORD *, __int128 *))(*(_QWORD *)v23 + 0x170LL))(
                             v23,
                             v227,
                             &v181);
        }
        else
        {
          v201 = v181;
          v202 = *(double *)&v182;
          v144 = (double *)&v201;
        }
        _XMM6 = *(_OWORD *)v144;
        v146 = v144[2];
        n0xCC = 0xCC;
        v244[0] = &n0xCC;
        v244[1] = &v273;
        v202 = v146;
        v147 = invokeGlobalCallbackAndMaskStatusBits(
                 5,
                 (__int64)v244,
                 (__int64)"Actor Teleport",
                 "$$: Teleporting actor '$$' [$$] ($$) from Z$$ W$$ [Zone $$] to Z$$ W$$ [Zone $$], distance = $$, base r"
                 "otation from $$ to $$ requested by '$$', result '$$'");
        n0xCC_2 = n0xCC_1;
        v149 = v147;
        if ( (v147 & 0xFFFFF) != 0 )
        {
          v204 = v180;
          *(double *)v188.m256_f32 = v175;
          *(double *)&v188.m256_f32[6] = v178;
          *(double *)&v188.m256_f32[4] = v177;
          *(double *)&v188.m256_f32[2] = v176;
          __asm
          {
            vunpckhpd xmm1, xmm8, xmm8
            vunpckhpd xmm0, xmm6, xmm6
          }
          *((_QWORD *)&v152 + 1) = *((_QWORD *)&_XMM1 + 1);
          v227[0] = 0;
          p_Success = "Success";
          v228 = 0;
          if ( !(_BYTE)n0xCC_1 )
            p_Success = p_Success_1;
          p_unknown = "unknown";
          v227[1] = p_Success;
          v242[0] = 0;
          v242[1] = &p_p_p_p_p_p_p_p_p_p_p_Source;
          v243 = 0;
          v203 = 0;
          v187 = 0;
          *(_QWORD *)&v179 = 0;
          *(double *)&v152 = (*(double *)&_XMM1 - *(double *)&_XMM0) * (*(double *)&_XMM1 - *(double *)&_XMM0)
                           + (*(double *)&_XMM8 - *(double *)&_XMM6) * (*(double *)&_XMM8 - *(double *)&_XMM6)
                           + (v226 - v202) * (v226 - v202);
          _XMM2 = v152;
          __asm
          {
            vmovddup xmm1, xmm2
            vsqrtpd xmm4, xmm1
            vmovhpd [rbp+420h+var_470+8], xmm4
          }
          if ( v23 )
          {
            __asm { vzeroupper }
            p_unknown_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v23 + 0x1F0LL))(v23);
          }
          else
          {
            p_unknown_1 = "unknown";
          }
          v225[0] = 0;
          v225[1] = p_unknown_1;
          v226 = 0.0;
          v248 = 0;
          v251 = 0;
          v252 = v181;
          v253 = *(double *)&v182;
          v249 = _XMM6;
          v250 = v146;
          if ( v58 )
          {
            __asm { vzeroupper }
            p_unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x1F0LL))(v58);
          }
          v258 = v261;
          v259 = v262;
          v240[0] = 0;
          v240[1] = p_unknown;
          v241 = 0;
          v254 = 0;
          v255 = _XMM8;
          v256 = v20;
          v257 = 0;
          __asm { vzeroupper }
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v159 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v159 = 0;
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v159 + 0x720LL))(v159) )
          {
            p_Server = "Authority";
          }
          else
          {
            p_Server = "Client";
            if ( byte_149B4FE80 )
              p_Server = "Server";
          }
          v238[0] = 0;
          v238[1] = p_Server;
          v239 = 0;
          sub_1403B0A70((unsigned __int64 *)(a1 + 8), &n0xCC);
          *((_QWORD *)&v201 + 1) = n0xCC;
          *(_QWORD *)&v201 = 0;
          LOBYTE(v202) = 0;
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v161 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v161 = 0;
          v236[1] = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v161 + 0x70LL))(v161);
          p_CSCActorPhysicsController::Teleport = "CSCActorPhysicsController::Teleport";
          v236[0] = 0;
          v237 = 0;
          v184 = 0;
          v186 = 0;
          ThreadLogContextSlot_1 = getThreadLogContextSlot();
          n0xCC_1 = 0xCC;
          v245[0] = (__int64)&n0xCC_1;
          v245[1] = (__int64)&n0xCC;
          v173 = 0;
          sub_145A23190(
            5,
            (__int64)v245,
            "Actor Teleport",
            "$$: Teleporting actor '$$' [$$] ($$) from Z$$ W$$ [Zone $$] to Z$$ W$$ [Zone $$], distance = $$, base rotati"
            "on from $$ to $$ requested by '$$', result '$$'",
            1,
            v149,
            &v173,
            0,
            ThreadLogContextSlot_1,
            &v184,
            v236,
            &v201,
            v238,
            &v257,
            &v254,
            v240,
            &v251,
            &v248,
            v225,
            &v179,
            &v187,
            &v203,
            v242,
            v227);
          sub_1402A3D30(v186);
          sub_1402A3D30(v237);
          sub_1402A3D30(v239);
          sub_1402A3D30(v241);
          sub_1402A3D30(*(const void **)&v226);
          sub_1402A3D30(v243);
          sub_1402A3D30(v228);
        }
        if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
          v163 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v163 = 0;
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v163 + 0x720LL))(v163) && n0xCC_2 && v23 )
        {
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v164 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v164 = 0;
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v164 + 0x648LL))(v164);
        }
      }
      v165 = *(_QWORD *)(a1 + 0x2E0);
      if ( v165 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v165 + 0x10LL))(v165);
        *(_QWORD *)(a1 + 0x2E0) = 0;
      }
      v57 = 1;
      goto LABEL_176;
    }
    v58 = v273;
    v268 = v4;
    v267 = v5;
    v266 = v6;
    v265 = v7;
    v264 = v8;
    v59 = sub_14030EC00((unsigned __int64 *)(a1 + 8));
    if ( v23 == v58 )
    {
      if ( v59 )
        v60 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v60 = 0;
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v60 + 0x3B8LL))(v60, &n0xCC_1);
      if ( n0xCC_1
        && *(_QWORD *)((n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(n0xCC_1)
        && (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8LL))(n0xCC_1 & 0xFFFFFFFFFFFFLL) == 6 )
      {
        v61 = qword_149B4FC00;
        v215 = 0.0;
        v216 = 0.0;
        v217 = 0.0;
        v220 = 0.0;
        v221 = 0.0;
        v222 = 0.0;
        LODWORD(v184) = 0xFFBFFFFF;
        v203 = 0xFFBFFFFF0000000CuLL;
        v219 = 0;
        *(_QWORD *)v204.m256_f32 = 0xFFBFFFFFFFBFFFFFuLL;
        v205 = NAN;
        v210 = 0xFFF7FFFF;
        v212 = 0xFFBFFFFF;
        v218 = 0xFFBFFFFF;
        *(_QWORD *)&v204.m256_f32[2] = 0xFFBFFFFFFFBFFFFFuLL;
        v204.m256_f32[4] = NAN;
        v204.m256_f32[7] = NAN;
        v213 = 0;
        v214 = 0;
        v223 = 0;
        v224 = 0;
        v62 = *(void (__fastcall **)(__int64, __int128 *, __int64 *, unsigned __int64 *, int, unsigned int, __int128 *, _QWORD, __int64 *, int, _QWORD, _BYTE))(*(_QWORD *)qword_149B4FC00 + 0x390LL);
        ThreadLogContextSlot = *(__int64 **)(*(__int64 (__fastcall **)(__int64, double *))(*(_QWORD *)v23 + 0x18LL))(
                                              v23,
                                              &v172);
        *(float *)&v173 = 0.0;
        *((float *)&v173 + 1) = 0.0;
        *((float *)&v173 + 2) = 0.0;
        v62(v61, &v181, &v184, &v203, 1, 0xFFFFFFFF, &v173, 0, ThreadLogContextSlot, 0x1E, 0, 0);
        if ( v172 != 0.0 )
          sub_140522CF0(*(__int64 *)&v172);
        v63 = *(float *)&v184 == 0.0
           && *((float *)&v184 + 1) == 0.0
           && *(float *)&p_CSCActorPhysicsController::Teleport == 0.0;
        LOBYTE(v169) = 0;
        v64 = *(void (__fastcall **)(__int64, __m256 *, __int64, __int64, int, _QWORD))(*(_QWORD *)v15 + 0x1D8LL);
        if ( v63 )
        {
          v64(v15, &v180, 2, 0x2001002, v169, 0);
          *(double *)&v188.m256_f32[4] = *(double *)&v182;
          *(_OWORD *)v188.m256_f32 = v181;
          *((_QWORD *)&v76 + 1) = (LODWORD(v176) ^ (unsigned __int128)0x80000000) >> 0x40;
          v65 = COERCE_FLOAT(LODWORD(v176) ^ 0x80000000);
          v66 = COERCE_FLOAT(LODWORD(v177) ^ 0x80000000);
          v67 = COERCE_FLOAT(LODWORD(v175) ^ 0x80000000);
          _XMM2 = COERCE_UNSIGNED_INT64(
                    *(double *)&v180.m256_f32[6] * v178
                  - (*(double *)v180.m256_f32 * v67
                   + v65 * *(double *)&v180.m256_f32[2]
                   + *(double *)&v180.m256_f32[4] * v66));
          __asm { vcvtsd2ss xmm9, xmm2, xmm2 }
          _XMM2 = COERCE_UNSIGNED_INT64(
                    *(double *)&v180.m256_f32[2] * v66
                  - v65 * *(double *)&v180.m256_f32[4]
                  + *(double *)&v180.m256_f32[6] * v67
                  + *(double *)v180.m256_f32 * v178);
          __asm { vcvtsd2ss xmm5, xmm2, xmm2 }
          _XMM2 = COERCE_UNSIGNED_INT64(
                    *(double *)&v180.m256_f32[4] * v67
                  - *(double *)v180.m256_f32 * v66
                  + v65 * *(double *)&v180.m256_f32[6]
                  + *(double *)&v180.m256_f32[2] * v178);
          __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
          LODWORD(v187) = 0;
          *((_QWORD *)&v189 + 1) = 0x80000000FFBFFFFFuLL;
          LOBYTE(v190.m256_f32[1]) = LOBYTE(v190.m256_f32[1]) & 0xF0 | 8;
          v74 = *(_QWORD *)v23;
          *(double *)&v76 = v65 * *(double *)v180.m256_f32
                          - *(double *)&v180.m256_f32[2] * v67
                          + *(double *)&v180.m256_f32[6] * v66
                          + *(double *)&v180.m256_f32[4] * v178;
          _XMM2 = v76;
          __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
          *(float *)&v189 = *(float *)&_XMM1;
          v188.m256_f32[6] = *(float *)&_XMM5;
          v188.m256_f32[7] = *(float *)&_XMM4;
          *((float *)&v189 + 1) = *(float *)&_XMM9;
          LODWORD(v190.m256_f32[0]) = 0x80;
          *(_QWORD *)&v190.m256_f32[2] = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, double *))(v74 + 0x18))(
                                                      v23,
                                                      &v172);
          if ( v172 != 0.0 )
            sub_140522CF0(*(__int64 *)&v172);
          if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
            v78 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
          else
            v78 = 0;
          (*(void (__fastcall **)(__int64, __int128 **, _QWORD, _QWORD))(*(_QWORD *)v78 + 0x3F8LL))(v78, &v187, 0, 0);
          _XMM8 = v179;
          v20 = *(double *)&n0xCC;
          v58 = v273;
        }
        else
        {
          v64(v15, &v180, 2, 0x2001006, v169, 0);
          v58 = v273;
        }
        goto LABEL_91;
      }
    }
    else
    {
      if ( v59 )
        v79 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v79 = 0;
      v80 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, double *))(*(_QWORD *)v79 + 0x150LL))(v79, &v172);
      if ( sub_14030EC00(v80) )
      {
        sub_14035B3E0(&n0xCC);
        v135 = v134;
        if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
          v136 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v136 = 0;
        v137 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v136 + 0x150LL))(v136, &v273);
        v138 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*v137 & 0xFFFFFFFFFFFFLL) + 0x70LL))(*v137 & 0xFFFFFFFFFFFFLL);
        v139 = sub_1403A9130(v135, "Trying to teleport an actor to a new zone while attached to [%s], failing", v138);
        copyStringStructure((char **)&p_Success_1, v139);
        sub_140370D10(&n0xCC);
        goto LABEL_124;
      }
      if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
        v81 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v81 = 0;
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v81 + 0x3B8LL))(v81, &n0xCC_1);
      if ( n0xCC_1
        && *(_QWORD *)((n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(n0xCC_1)
        && (*(unsigned int (__fastcall **)(unsigned __int64))(*(_QWORD *)(n0xCC_1 & 0xFFFFFFFFFFFFLL) + 8LL))(n0xCC_1 & 0xFFFFFFFFFFFFLL) == 6 )
      {
        v82 = *(_QWORD *)v15;
        v263 = v9;
        v83 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD))(v82 + 0x680);
        v84 = (*(__int64 (__fastcall **)(__int64, __int128 **, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL))(
                qword_149B4FBE8,
                &v187,
                v58,
                v23);
        v83(v15, v23, v84, 0, 0);
        LOBYTE(v170) = 0;
        (*(void (__fastcall **)(__int64, __m256 *, __int64, __int64, int, _QWORD))(*(_QWORD *)v15 + 0x1D8LL))(
          v15,
          &v180,
          2,
          0x2001002,
          v170,
          0);
        LODWORD(v203) = 0;
        LOBYTE(v210) = v210 & 0xF0 | 8;
        v207 = 0xFFBFFFFF;
        v208 = 0x80000000;
        *(_OWORD *)v204.m256_f32 = v181;
        *(double *)&v204.m256_f32[4] = *(double *)&v182;
        v85 = (*(__int64 (__fastcall **)(__int64, __int128 **, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL))(
                qword_149B4FBE8,
                &v187,
                v58,
                v23);
        v86 = *(double *)(v85 + 8);
        v87 = *(double *)v85;
        v88 = *(double *)(v85 + 0x18);
        v89 = *(unsigned __int64 *)(v85 + 0x10);
        v172 = v88 * v178 - (*(double *)v85 * v175 + v86 * v176 + *(double *)&v89 * v177);
        *((_QWORD *)&v90 + 1) = *((_QWORD *)&v89 + 1);
        v91 = -(v177 * v86 - *(double *)&v89 * v176 + v175 * v88 + v87 * v178);
        v92 = -(*(double *)&v89 * v175 - v177 * v87 + v176 * v88 + v86 * v178);
        v93 = *(_QWORD *)v23;
        *(double *)&v89 = -(v87 * v176 - v175 * v86 + v177 * v88 + *(double *)&v89 * v178);
        _XMM2 = COERCE_UNSIGNED_INT64(
                  *(double *)&v180.m256_f32[6] * v172
                - (*(double *)v180.m256_f32 * v91
                 + v92 * *(double *)&v180.m256_f32[2]
                 + *(double *)&v180.m256_f32[4] * *(double *)&v89));
        __asm { vcvtsd2ss xmm9, xmm2, xmm2 }
        _XMM2 = COERCE_UNSIGNED_INT64(
                  *(double *)&v180.m256_f32[2] * *(double *)&v89
                - v92 * *(double *)&v180.m256_f32[4]
                + *(double *)&v180.m256_f32[6] * v91
                + *(double *)v180.m256_f32 * v172);
        __asm { vcvtsd2ss xmm5, xmm2, xmm2 }
        _XMM2 = COERCE_UNSIGNED_INT64(
                  *(double *)&v180.m256_f32[4] * v91
                - *(double *)v180.m256_f32 * *(double *)&v89
                + v92 * *(double *)&v180.m256_f32[6]
                + *(double *)&v180.m256_f32[2] * v172);
        __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
        *(double *)&v90 = v92 * *(double *)v180.m256_f32
                        - *(double *)&v180.m256_f32[2] * v91
                        + *(double *)&v180.m256_f32[6] * *(double *)&v89
                        + *(double *)&v180.m256_f32[4] * v172;
        _XMM2 = v90;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        n0x80 = 0x80;
        v205 = *(float *)&_XMM1;
        v204.m256_f32[6] = *(float *)&_XMM5;
        v204.m256_f32[7] = *(float *)&_XMM4;
        v206 = *(float *)&_XMM9;
        v211 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, double *))(v93 + 0x18))(v23, &v172);
        if ( v172 != 0.0 )
          sub_140522CF0(*(__int64 *)&v172);
        if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
          v102 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
        else
          v102 = 0;
        (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD, _QWORD))(*(_QWORD *)v102 + 0x3F8LL))(
          v102,
          &v203,
          0,
          0);
        _XMM8 = v179;
        v20 = *(double *)&n0xCC;
        goto LABEL_91;
      }
      v103 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v15 + 0x680LL);
      v104 = (*(__int64 (__fastcall **)(__int64, __int128 **, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL))(
               qword_149B4FBE8,
               &v187,
               v58,
               v23);
      v103(v15, v23, v104, 0, 0);
    }
    LOBYTE(v168) = 0;
    (*(void (__fastcall **)(__int64, __m256 *, __int64, __int64, int, _QWORD))(*(_QWORD *)v15 + 0x1D8LL))(
      v15,
      &v180,
      2,
      0x2001006,
      v168,
      0);
LABEL_91:
    LOBYTE(n0xCC_1) = 1;
    sub_143825070(a1, &n0xCC);
    v105 = *(float *)(a2 + 0x64);
    v106 = (__m128)*(unsigned int *)(a2 + 0x68);
    v107 = *(float *)(a2 + 0x6C);
    v108 = *(float *)(a2 + 0x60);
    v109 = v106;
    v109.m128_f32[0] = (float)((float)(v106.m128_f32[0] * v106.m128_f32[0]) + (float)(v105 * v105))
                     + (float)((float)(v108 * v108) + (float)(v107 * v107));
    v110 = n0xCC & 0xFFFFFFFFFFFFLL;
    if ( v109.m128_f32[0] <= 0.0000000099999999 )
    {
      *((float *)&v173 + 3) = 1.0;
      *(float *)&v173 = 0.0;
      *((float *)&v173 + 1) = 0.0;
      *((float *)&v173 + 2) = 0.0;
    }
    else
    {
      _XMM0 = _mm_shuffle_ps(v109, v109, 0);
      __asm { vrsqrtps xmm3, xmm0 }
      _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
      _XMM3.m128_f32[0] = (float)(1.5
                                - (float)((float)((float)(v109.m128_f32[0] * _XMM3.m128_f32[0]) * _XMM3.m128_f32[0])
                                        * 0.5))
                        * _XMM3.m128_f32[0];
      *((float *)&v173 + 3) = _XMM3.m128_f32[0] * v107;
      *(float *)&v173 = _XMM3.m128_f32[0] * v108;
      *((float *)&v173 + 1) = _XMM3.m128_f32[0] * v105;
      *((float *)&v173 + 2) = _XMM3.m128_f32[0] * v106.m128_f32[0];
    }
    sub_1461F6D30(n0xCC & 0xFFFFFFFFFFFFLL, (float *)&v173);
    sub_1461E66C0(v110, (const void *)(a2 + 0x70));
    if ( v23 != v58 )
    {
      v113 = *(_QWORD *)v15;
      n0xCC = 0x100000003LL;
      (*(void (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(v113 + 0x408))(v15, &n0xCC, 0, 0);
    }
    if ( *(_BYTE *)(a2 + 0x7D) )
    {
      sub_145A3C120(a1, 0, 0.0);
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v114 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
      else
        v114 = 0;
      v115 = sub_1465EF570(v114);
      *(_BYTE *)(v115 + 0xC) = 0;
      *(_DWORD *)(v115 + 0x10) = 0;
      if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
        v116 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
      else
        v116 = 0;
      v117 = sub_1465EECD0(v116);
      LODWORD(n0xCC) = 0;
      v118 = v117;
      sub_14035C4A0(&n0xCC, 0xDE);
      sub_145ED3E20(v118, (int *)&n0xCC);
    }
    if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
      v119 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
    else
      v119 = 0;
    v120 = sub_1465EEE60(v119);
    sub_145847EE0(v120, a2);
    if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
      v121 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
    else
      v121 = 0;
    v122 = sub_1465EEEC0(v121);
    v123 = sub_145F4F9E0(v122, &n0xCC);
    v124 = *v123;
    if ( *v123 )
    {
      v125 = sub_1403B4B50(v124 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v125 + 4);
      if ( n4 != 4
        && *(_WORD *)(v125 + 2) == (HIWORD(v124) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(v123)) )
      {
        v127 = *v123 & 0xFFFFFFFFFFFFLL;
        if ( v127 )
        {
          *(_QWORD *)&v179 = 0;
          if ( is_valid_handle_typeA((__int64 *)(a1 + 0x118)) )
            v128 = *(_QWORD *)(a1 + 0x118) & 0xFFFFFFFFFFFFLL;
          else
            v128 = 0;
          v129 = sub_1465EEE60(v128);
          v130 = sub_145843B60(v129);
          gEnv = ::gEnv;
          DWORD2(v179) = !v130 + 1;
          v187 = &v179;
          v132 = *(float *)&dword_149E65118;
          if ( !dword_149E65118 )
            LODWORD(v132) = get_event_key_from_source_location(
                              &dword_149E65118,
                              (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/Player/Items.h",
                              0x1B);
          v188.m256_f32[0] = v132;
          *(_QWORD *)&v188.m256_f32[2] = 0x10;
          *(_QWORD *)&v188.m256_f32[4] = "struct SPI_ThrusterPack_RequestAction";
          LOBYTE(v188.m256_f32[6]) = byte_149E68124;
          *(_QWORD *)&v189 = _StarEngineModule__;
          *((_QWORD *)&v189 + 1) = sub_14041E9D0;
          (*(void (__fastcall **)(__int64, __int64, __int128 **))(*(_QWORD *)gEnv + 0x358LL))(gEnv, v127, &v187);
        }
      }
    }
    v58 = v273;
    goto LABEL_124;
  }
  if ( !*(_BYTE *)(a2 + 0x7F) )
  {
    assignCStringToStringStructure((void **)&p_Success_1, "Trying to teleport an actor that is linked, failing");
    v58 = v273;
    goto LABEL_124;
  }
  v57 = 0;
LABEL_176:
  sub_140370D10(&p_Success_1);
LABEL_178:
  v233 = __rdtsc();
  qword_149B4B878(&n0x4300);
  return v57;
}

// --- End Function: sub_145A3D0F0 (0x145A3D0F0) ---

// --- Function: sub_145A53600 (0x145A53600) ---
double __fastcall sub_145A53600(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v7; // rbp
  int v8; // eax
  int v9; // esi
  int v10; // ebx
  __int128 v11; // xmm6
  __int64 v12; // rax
  __int128 v13; // kr00_16
  double result; // xmm0_8

  v2 = sub_145A53E00(a1);
  v3 = v2;
  if ( !v2 )
    return 0.0;
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x30LL))(v2);
  if ( v4 )
  {
    v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x358LL))(v4);
    if ( v5 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x90LL))(v5);
      return result;
    }
  }
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x20LL))(v3);
  if ( !v6 )
    return 0.0;
  v7 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0xC8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(a1 + 0xC8) & 0xFFFFFFFFFFFFLL);
  v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0xA0LL))(v6, v7);
  v9 = v8;
  if ( !v8 )
    return 0.0;
  v10 = 0;
  v11 = 0;
  if ( v8 > 0 )
  {
    do
    {
      v12 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v6 + 0xB8LL))(
              v6,
              (unsigned int)v7,
              (unsigned int)v10++);
      v13 = v11;
      *(float *)&v13 = *(float *)&v11 + (float)(*(float *)(v12 + 0x2C) * *(float *)(v12 + 0x24));
      v11 = v13;
    }
    while ( v10 < v9 );
  }
  return *(double *)&v11;
}

// --- End Function: sub_145A53600 (0x145A53600) ---

// --- Function: sub_145A53E00 (0x145A53E00) ---
__int64 __fastcall sub_145A53E00(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int16 n4; // dx
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_QWORD *)(a1 + 0xC0);
  v5 = v1;
  if ( v1
    && (v2 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v2 + 4), n4 != 4)
    && *(_WORD *)(v2 + 2) == (HIWORD(v1) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v5)) )
  {
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v1 & 0xFFFFFFFFFFFFLL) + 0x5A8LL))(v1 & 0xFFFFFFFFFFFFLL);
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_145A53E00 (0x145A53E00) ---

// --- Function: sub_145ACCD50 (0x145ACCD50) ---
char __fastcall sub_145ACCD50(__int64 a1)
{
  unsigned __int64 v2; // rax
  int n8; // [rsp+24h] [rbp-34h]
  __int64 v4; // [rsp+28h] [rbp-30h]
  __int64 v5; // [rsp+40h] [rbp-18h]

  n8 = *(_DWORD *)(a1 + 0x4F8);
  if ( (n8 & 8) != 0 && n8 == 8 )
    return 1;
  if ( sub_142C0F3C0(a1 + 0x4F0, 0) )
    return 2;
  v2 = sub_1403E6750((unsigned __int64 *)(*(_QWORD *)(a1 + 0x158) + 8LL));
  if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v2 + 0x720LL))(v2)
    && ((v5 = sub_1465EEE60(*(_QWORD *)(a1 + 0x158)),
         v4 = sub_14583F430(v5),
         Concurrency::details::_ContextCallback::_HasCapturedContext((Concurrency::details::_ContextCallback *)(v4 + 0x178)))
     && *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v4 + 0x178) + 4)
     || *(_BYTE *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v4 + 0x20) == 0xB) )
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_145ACCD50 (0x145ACCD50) ---

// --- Function: sub_145AD55F0 (0x145AD55F0) ---
__int64 __fastcall sub_145AD55F0(__int64 a1)
{
  __int64 v1; // rax
  unsigned __int8 v3; // [rsp+20h] [rbp-28h]
  unsigned __int64 v4; // [rsp+28h] [rbp-20h]

  v3 = 0;
  if ( sub_145ACCD50(a1) == 2 )
  {
    v4 = sub_1403E6750((unsigned __int64 *)(*(_QWORD *)(a1 + 0x158) + 8LL));
    if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v4 + 0x720LL))(v4) )
    {
      v1 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x158) + 0x758LL))(*(_QWORD *)(a1 + 0x158));
      if ( !sub_1403BFC90(v1) )
        return 1;
    }
  }
  return v3;
}

// --- End Function: sub_145AD55F0 (0x145AD55F0) ---

// --- Function: sub_145AD72E0 (0x145AD72E0) ---
char __fastcall sub_145AD72E0(__int64 a1)
{
  char result; // al
  __int64 v2; // [rsp+28h] [rbp-30h]
  __int64 v3; // [rsp+30h] [rbp-28h]
  __int64 v4; // [rsp+48h] [rbp-10h]

  if ( !(unsigned __int8)sub_145AD55F0(a1) )
    return 0;
  v3 = sub_1465EEE60(*(_QWORD *)(a1 + 0x158));
  v2 = sub_14583F430(v3);
  switch ( *(_BYTE *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0x20) )
  {
    case 1:
    case 5:
    case 0xB:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x2C:
      result = 0;
      break;
    case 2:
      if ( sub_144E45D10() )
        goto LABEL_15;
      result = 0;
      break;
    case 4:
      if ( *(_BYTE *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0xF0) != 1
        || (*(_DWORD *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0xF8) + 0x1C) & 4) == 0 )
      {
        goto LABEL_15;
      }
      result = 0;
      break;
    case 8:
      if ( *(_BYTE *)(std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0x1E8) + 0x10) != 1 )
        goto LABEL_15;
      v4 = *(_QWORD *)std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>(v2 + 0x210);
      if ( !sub_14037F610(v4, 0) )
        goto LABEL_15;
      result = 0;
      break;
    case 0x24:
      if ( !*(_BYTE *)(sub_1402A2660(v2 + 0x200) + 0x58) )
        goto LABEL_15;
      result = 0;
      break;
    default:
LABEL_15:
      result = 1;
      break;
  }
  return result;
}

// --- End Function: sub_145AD72E0 (0x145AD72E0) ---

// --- Function: sub_145B34360 (0x145B34360) ---
void __fastcall sub_145B34360(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5[3]; // [rsp+20h] [rbp-B8h] BYREF
  __int64 v6; // [rsp+38h] [rbp-A0h] BYREF
  char n2; // [rsp+48h] [rbp-90h]
  int v8; // [rsp+50h] [rbp-88h]
  int v9; // [rsp+90h] [rbp-48h]
  int v10; // [rsp+94h] [rbp-44h]
  char v11; // [rsp+98h] [rbp-40h]

  v4 = sub_1465EEE60(a1);
  sub_1443C9B20((__int64)v5);
  v8 = 1;
  sub_1432B1780(v4, v5, 1);
  v9 = *(_DWORD *)(a3 + 0xC);
  v10 = *(_DWORD *)(a3 + 8);
  v11 = *(_BYTE *)(a3 + 4);
  n2 = 2;
  sub_145AFB8F0(v4, v5, "CSCActorControlStateFall::HandleRemoteFallSelection");
  sub_140370D10(&v6);
}

// --- End Function: sub_145B34360 (0x145B34360) ---

// --- Function: sub_145B343F0 (0x145B343F0) ---
void __fastcall sub_145B343F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  volatile signed __int32 *v7; // rbx
  __int64 v8; // [rsp+30h] [rbp-C8h] BYREF
  volatile signed __int32 *v9; // [rsp+38h] [rbp-C0h]
  __int64 v10[3]; // [rsp+40h] [rbp-B8h] BYREF
  __int64 v11; // [rsp+58h] [rbp-A0h] BYREF
  int v12; // [rsp+6Ch] [rbp-8Ch]

  sub_1465CA060(a1, &v8);
  if ( v8 && *(_BYTE *)(v8 + 0x82) )
  {
    sub_1443C9B20((__int64)v10);
    sub_145B2EF70((__int64)v10, a2, a1, a3, v8);
    if ( v12 )
    {
      v6 = sub_1465EEE60(a1);
      sub_145AFB8F0(v6, v10, "CSCActorControlStateJump::HandleRemoteKnockdownEvent");
    }
    sub_140370D10(&v11);
  }
  v7 = v9;
  if ( v9 && _InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
    if ( _InterlockedExchangeAdd(v7 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8LL))(v7);
  }
}

// --- End Function: sub_145B343F0 (0x145B343F0) ---

// --- Function: sub_145B344D0 (0x145B344D0) ---
void __fastcall sub_145B344D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdi
  __int64 v5[3]; // [rsp+20h] [rbp-B8h] BYREF
  __int64 v6; // [rsp+38h] [rbp-A0h] BYREF
  char n3; // [rsp+48h] [rbp-90h]
  int v8; // [rsp+50h] [rbp-88h]
  int v9; // [rsp+9Ch] [rbp-3Ch]
  char v10; // [rsp+A0h] [rbp-38h]
  char v11; // [rsp+A1h] [rbp-37h]
  __int64 v12; // [rsp+A4h] [rbp-34h]
  float v13; // [rsp+ACh] [rbp-2Ch]
  float v14; // [rsp+B0h] [rbp-28h]
  float v15; // [rsp+B4h] [rbp-24h]

  v4 = sub_1465EEE60(a1);
  sub_1443C9B20((__int64)v5);
  v8 = 1;
  sub_1432B1780(v4, v5, 1);
  v9 = *(_DWORD *)(a3 + 8);
  v10 = *(_BYTE *)(a3 + 4);
  v11 = *(_BYTE *)(a3 + 0xC);
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  n3 = 3;
  v12 = 0;
  sub_145AFB8F0(v4, v5, "CSCActorControlStateLand::HandleRemoteLandSelection");
  sub_140370D10(&v6);
}

// --- End Function: sub_145B344D0 (0x145B344D0) ---

// --- Function: sub_145CE13C0 (0x145CE13C0) ---
_QWORD *__fastcall sub_145CE13C0(__int64 a1, _QWORD *a2, unsigned int n2)
{
  __int64 v5; // rax
  __int64 v6; // rax

  v5 = sub_1465EECD0(*(_QWORD *)(a1 + 0x80));
  v6 = sub_140814780(v5);
  sub_145F4E9C0(v6, a2, n2);
  return a2;
}

// --- End Function: sub_145CE13C0 (0x145CE13C0) ---

// --- Function: sub_145D28790 (0x145D28790) ---
bool __fastcall sub_145D28790(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  __int64 (__fastcall *v2)(unsigned __int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v4; // rbx
  __int64 v5; // rax
  __int16 n4; // cx
  unsigned __int64 v7; // rbx
  __int64 (__fastcall *v8)(unsigned __int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF_2; // ax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int16 n4_1; // cx
  unsigned __int64 v13; // rbx
  __int64 (__fastcall *v14)(unsigned __int64, _BYTE *, __int16 *); // rdi
  __int16 n0xFFFF_3; // ax
  __int64 v16; // rbx
  __int64 v17; // rax
  __int16 n4_2; // cx
  __int64 *v19; // rax
  _BYTE v21[8]; // [rsp+20h] [rbp-18h] BYREF
  __int64 v22; // [rsp+28h] [rbp-10h] BYREF
  unsigned __int64 v23; // [rsp+70h] [rbp+38h] BYREF
  __int16 n0xFFFF_1; // [rsp+78h] [rbp+40h] BYREF
  char v25; // [rsp+80h] [rbp+48h] BYREF
  __int64 v26; // [rsp+88h] [rbp+50h] BYREF

  v23 = a1;
  if ( !sub_14030EC00(&v23) )
    return 0;
  v1 = v23 & 0xFFFFFFFFFFFFLL;
  v2 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF = n0xFFFF_71;
  if ( n0xFFFF_71 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v25,
                          "SCMeleeWeapon");
    n0xFFFF_71 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v4 = *(_QWORD *)v2(v1, v21, &n0xFFFF_1);
  v26 = v4;
  if ( v4 )
  {
    v5 = sub_1403B4B50(v4 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v5 + 4);
    if ( n4 != 4
      && *(_WORD *)(v5 + 2) == (HIWORD(v4) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_142714E30(&v26)) )
    {
      return 1;
    }
  }
  v7 = v23 & 0xFFFFFFFFFFFFLL;
  v8 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF_2 = n0xFFFF_72;
  if ( n0xFFFF_72 == (__int16)0xFFFF )
  {
    n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v25,
                            "SCItemExplosive");
    n0xFFFF_72 = n0xFFFF_2;
  }
  n0xFFFF_1 = n0xFFFF_2;
  v10 = *(_QWORD *)v8(v7, v21, &n0xFFFF_1);
  v26 = v10;
  if ( v10 )
  {
    v11 = sub_1403B4B50(v10 & 0xFFFFFFFFFFFFLL);
    n4_1 = *(_WORD *)(v11 + 4);
    if ( n4_1 != 4
      && *(_WORD *)(v11 + 2) == (HIWORD(v10) & 0xFFF)
      && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_142714E30(&v26)) )
    {
      return 1;
    }
  }
  v13 = v23 & 0xFFFFFFFFFFFFLL;
  v14 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int16 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF_3 = n0xFFFF_73;
  if ( n0xFFFF_73 == (__int16)0xFFFF )
  {
    n0xFFFF_3 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v25,
                            "EntityComponentTriggerableDevices");
    n0xFFFF_73 = n0xFFFF_3;
  }
  n0xFFFF_1 = n0xFFFF_3;
  v16 = *(_QWORD *)v14(v13, v21, &n0xFFFF_1);
  v26 = v16;
  if ( v16 )
  {
    v17 = sub_1403B4B50(v16 & 0xFFFFFFFFFFFFLL);
    n4_2 = *(_WORD *)(v17 + 4);
    if ( n4_2 != 4
      && *(_WORD *)(v17 + 2) == (HIWORD(v16) & 0xFFF)
      && (n4_2 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v26)) )
    {
      return 1;
    }
  }
  v19 = sub_1425D69E0(v23 & 0xFFFFFFFFFFFFLL, &v22);
  return is_valid_handle_typeA(v19);
}

// --- End Function: sub_145D28790 (0x145D28790) ---

// --- Function: sub_145EC6580 (0x145EC6580) ---
const ULONG_PTR *__fastcall sub_145EC6580(
        __int64 a1,
        __int64 *a2,
        _BYTE *p_CSCActorControlStateDownedEnter::RemoteClientPlayHitReaction:_r)
{
  __int64 *v5; // rax
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 (__fastcall *v8)(__int64 *, __int64, _QWORD, __int64); // rsi
  _QWORD *v9; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  char v11; // r15
  int v12; // edi
  __int64 v13; // r8
  unsigned __int64 v14; // rax
  __int64 *v15; // rbx
  unsigned __int8 (__fastcall ***v16)(_QWORD); // rsi
  char v17; // di
  char n9; // al
  __int64 v19; // rax
  volatile signed __int32 *v20; // rdi
  __int128 *v21; // rdx
  __int128 *v22; // rdx
  Parameter *Parameter_1; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 n0x10; // rax
  volatile signed __int32 *v27; // rsi
  __int64 v28; // rsi
  unsigned int v29; // r13d
  unsigned int i; // edi
  void (__fastcall *v31)(__int64 *, __int64); // rbx
  __int64 v32; // rax
  __int64 v33; // rax
  volatile signed __int32 *v34; // rbx
  __int64 v35; // r8
  Parameter *Parameter_2; // rcx
  __int64 *v37; // rdx
  _QWORD *v38; // rax
  __int64 v40; // rcx
  int v41; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v43; // [rsp+30h] [rbp-39h] BYREF
  __int128 v44; // [rsp+38h] [rbp-31h] BYREF
  __int128 v45; // [rsp+48h] [rbp-21h] BYREF
  _QWORD v46[2]; // [rsp+58h] [rbp-11h] BYREF
  Parameter *Parameter; // [rsp+68h] [rbp-1h]
  __int64 v48; // [rsp+70h] [rbp+7h]
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // [rsp+78h] [rbp+Fh]
  int v50; // [rsp+80h] [rbp+17h] BYREF
  __int64 v53; // [rsp+E8h] [rbp+7Fh] BYREF

  if ( sub_14583B030(a1)
    || (unsigned __int8)sub_14583AFE0(a1)
    || (v5 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                          qword_149B4FC40,
                          0),
        v6 = *(_QWORD *)(a1 + 0x3500),
        v7 = *v5,
        v8 = *(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, __int64))(*a2 + 8),
        v9 = sub_145840E80(a1, &v53),
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)v8(a2, v7, *v9, v6),
        !(_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source) )
  {
    Parameter = (__int64 **)(a1 + 0x3520);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const ULONG_PTR *)&v50;
    v11 = 1;
    v48 = a1 + 0x3538;
    v50 = 1;
    v12 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x3548) == v12 )
    {
      ++*(_DWORD *)(a1 + 0x354C);
    }
    else
    {
      v13 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v14 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0x3538), 0x200000, 0);
      if ( v14 )
        sub_1403DCD60(
          a1 + 0x3538,
          v14,
          v13,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          1);
      else
        *(_QWORD *)(a1 + 0x3540) = v13;
      *(_DWORD *)(a1 + 0x3548) = v12;
    }
    v15 = *Parameter;
    if ( *Parameter != Parameter[1] )
    {
      while ( 1 )
      {
        v16 = (unsigned __int8 (__fastcall ***)(_QWORD))*v15;
        v17 = (*(__int64 (__fastcall **)(__int64 *))*a2)(a2);
        if ( (**v16)(v16) != v17 )
        {
          Parameter_1 = (Parameter *)Parameter;
          goto LABEL_37;
        }
        n9 = (*(__int64 (__fastcall **)(__int64 *))*a2)(a2);
        if ( !n9 )
          break;
        if ( n9 == 7 )
        {
          v24 = allocWithProfilerInfo_w(0xB8u);
          v20 = (volatile signed __int32 *)v24;
          if ( v24 )
          {
            *(_DWORD *)(v24 + 8) = 1;
            *(_DWORD *)(v24 + 0xC) = 1;
            *(_QWORD *)v24 = off_148B16100;
            sub_145ECAE20(v24 + 0x10, (__int64)a2);
            *((_QWORD *)&v45 + 1) = v20;
            *(_QWORD *)&v45 = v20 + 4;
            v21 = &v45;
LABEL_17:
            sub_142704BB0(v15, v21);
LABEL_18:
            if ( _InterlockedExchangeAdd(v20 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v20)(v20);
              if ( _InterlockedExchangeAdd(v20 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v20 + 8LL))(v20);
            }
            goto LABEL_23;
          }
          v45 = xmmword_1482B5800;
          v22 = &v45;
        }
        else
        {
          if ( n9 != 9 )
            goto LABEL_58;
          v19 = allocWithProfilerInfo_w(0xB8u);
          v20 = (volatile signed __int32 *)v19;
          if ( v19 )
          {
            *(_DWORD *)(v19 + 8) = 1;
            *(_DWORD *)(v19 + 0xC) = 1;
            *(_QWORD *)v19 = off_148B16100;
            sub_145ECAE20(v19 + 0x10, (__int64)a2);
            *((_QWORD *)&v44 + 1) = v20;
            *(_QWORD *)&v44 = v20 + 4;
            v21 = &v44;
            goto LABEL_17;
          }
          v44 = xmmword_1482B5800;
          v22 = &v44;
        }
        sub_142704BB0(v15, v22);
LABEL_23:
        assignCStringToStringStructure(
          (void **)(*v15 + 0x18),
          p_CSCActorControlStateDownedEnter::RemoteClientPlayHitReaction:_r);
        Parameter_1 = (Parameter *)Parameter;
        v11 = 0;
        v15 = Parameter[1] + 0xFFFFFFFE;
LABEL_37:
        v15 += 2;
        if ( v15 == *((__int64 **)Parameter_1 + 1) )
          goto LABEL_38;
      }
      v25 = allocWithProfilerInfo_w(0xB8u);
      v20 = (volatile signed __int32 *)v25;
      if ( v25 )
      {
        *(_DWORD *)(v25 + 8) = 1;
        *(_DWORD *)(v25 + 0xC) = 1;
        *(_QWORD *)v25 = off_148B16100;
        sub_145ECAE20(v25 + 0x10, (__int64)a2);
        n0x10 = (__int64)(v20 + 4);
        _InterlockedIncrement(v20 + 2);
      }
      else
      {
        v20 = 0;
        n0x10 = 0x10;
      }
      v27 = (volatile signed __int32 *)v15[1];
      *v15 = n0x10;
      v15[1] = (__int64)v20;
      if ( v27 )
      {
        if ( _InterlockedExchangeAdd(v27 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v27)(v27);
          if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v27 + 8LL))(v27);
        }
      }
      if ( !v20 )
        goto LABEL_23;
      goto LABEL_18;
    }
LABEL_38:
    v28 = a1 + 0x3510;
    v29 = sub_146054F00(a1 + 0x3510);
    for ( i = 0; i < v29; ++i )
    {
      v31 = *(void (__fastcall **)(__int64 *, __int64))(*a2 + 0x10);
      v32 = sub_145F95DB0(v28, i);
      v31(a2, v32);
    }
    if ( v11 )
    {
      v33 = allocWithProfilerInfo_w(0xB8u);
      v34 = (volatile signed __int32 *)v33;
      if ( v33 )
      {
        *(_DWORD *)(v33 + 8) = 1;
        *(_DWORD *)(v33 + 0xC) = 1;
        *(_QWORD *)v33 = off_148B16100;
        sub_145ECAE20(v33 + 0x10, (__int64)a2);
        v35 = 0;
      }
      else
      {
        v35 = 0;
        v34 = 0;
      }
      Parameter_2 = (Parameter *)Parameter;
      v46[0] = v34 + 4;
      v46[1] = v34;
      v37 = Parameter[1];
      if ( v37 == Parameter[2] )
      {
        sub_1427C1BD0((Parameter *)Parameter, v37, v46);
      }
      else
      {
        *v37 = 0;
        v37[1] = 0;
        if ( v34 )
          _InterlockedIncrement(v34 + 2);
        *v37 = (__int64)(v34 + 4);
        v37[1] = (__int64)v34;
        *((_QWORD *)Parameter_2 + 1) += 0x10LL;
      }
      if ( v34 )
      {
        if ( _InterlockedExchangeAdd(v34 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *, __int64 *, __int64))v34)(v34, v37, v35);
          if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v34 + 8LL))(v34);
        }
      }
      assignCStringToStringStructure(
        (void **)(Parameter[1][0xFFFFFFFE] + 0x18),
        p_CSCActorControlStateDownedEnter::RemoteClientPlayHitReaction:_r);
    }
    if ( (unsigned __int8)sub_14583AFE0(a1) )
    {
      if ( *(_QWORD *)(a1 + 0x3508) )
      {
        v38 = sub_1458402C0(a1, &v43);
        if ( sub_140597650(a2 + 1, v38) )
          sub_14584B890(a1, a2[1]);
      }
    }
LABEL_58:
    p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    if ( (*(_DWORD *)p_p_p_p_p_p_p_p_p_p_p_p_Source_1)-- == 1 )
    {
      v40 = v48;
      v41 = *(_DWORD *)(v48 + 0x14);
      if ( v41 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v41 - 1);
        *(_DWORD *)(v48 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        *(_DWORD *)(v48 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v40, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v40 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          return sub_1403DD380(v40, n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_145EC6580 (0x145EC6580) ---

// --- Function: sub_145EC6A80 (0x145EC6A80) ---
const ULONG_PTR *__fastcall sub_145EC6A80(
        __int64 a1,
        __int64 *a2,
        _BYTE *p_CSCActorControlStateHost::HandleRemoteClientEventUpperBody)
{
  __int64 *v5; // rax
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 (__fastcall *v8)(__int64 *, __int64, _QWORD, __int64); // rsi
  _QWORD *v9; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  char v11; // r15
  int v12; // edi
  __int64 v13; // r8
  unsigned __int64 v14; // rax
  __int64 *v15; // rbx
  unsigned __int8 (__fastcall ***v16)(_QWORD); // rsi
  char v17; // di
  char n9; // al
  __int64 v19; // rax
  volatile signed __int32 *v20; // rdi
  __int128 *v21; // rdx
  __int128 *v22; // rdx
  Parameter *Parameter_1; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 n0x10; // rax
  volatile signed __int32 *v27; // rsi
  __int64 v28; // rsi
  unsigned int v29; // r13d
  unsigned int i; // edi
  void (__fastcall *v31)(__int64 *, __int64); // rbx
  __int64 v32; // rax
  __int64 v33; // rax
  volatile signed __int32 *v34; // rbx
  __int64 v35; // r8
  Parameter *Parameter_2; // rcx
  __int64 *v37; // rdx
  _QWORD *v38; // rax
  __int64 v40; // rcx
  int v41; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v43; // [rsp+30h] [rbp-39h] BYREF
  __int128 v44; // [rsp+38h] [rbp-31h] BYREF
  __int128 v45; // [rsp+48h] [rbp-21h] BYREF
  _QWORD v46[2]; // [rsp+58h] [rbp-11h] BYREF
  Parameter *Parameter; // [rsp+68h] [rbp-1h]
  __int64 v48; // [rsp+70h] [rbp+7h]
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // [rsp+78h] [rbp+Fh]
  int v50; // [rsp+80h] [rbp+17h] BYREF
  __int64 v53; // [rsp+E8h] [rbp+7Fh] BYREF

  if ( sub_14583B030(a1)
    || (unsigned __int8)sub_14583AFE0(a1)
    || (v5 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                          qword_149B4FC40,
                          0),
        v6 = *(_QWORD *)(a1 + 0x3500),
        v7 = *v5,
        v8 = *(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, __int64))(*a2 + 8),
        v9 = sub_145840E80(a1, &v53),
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)v8(a2, v7, *v9, v6),
        !(_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source) )
  {
    Parameter = (__int64 **)(a1 + 0x3520);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const ULONG_PTR *)&v50;
    v11 = 1;
    v48 = a1 + 0x3538;
    v50 = 1;
    v12 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x3548) == v12 )
    {
      ++*(_DWORD *)(a1 + 0x354C);
    }
    else
    {
      v13 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v14 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0x3538), 0x200000, 0);
      if ( v14 )
        sub_1403DCD60(
          a1 + 0x3538,
          v14,
          v13,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          1);
      else
        *(_QWORD *)(a1 + 0x3540) = v13;
      *(_DWORD *)(a1 + 0x3548) = v12;
    }
    v15 = *Parameter;
    if ( *Parameter != Parameter[1] )
    {
      while ( 1 )
      {
        v16 = (unsigned __int8 (__fastcall ***)(_QWORD))*v15;
        v17 = (*(__int64 (__fastcall **)(__int64 *))*a2)(a2);
        if ( (**v16)(v16) != v17 )
        {
          Parameter_1 = (Parameter *)Parameter;
          goto LABEL_37;
        }
        n9 = (*(__int64 (__fastcall **)(__int64 *))*a2)(a2);
        if ( !n9 )
          break;
        if ( n9 == 7 )
        {
          v24 = allocWithProfilerInfo_w(0xB0u);
          v20 = (volatile signed __int32 *)v24;
          if ( v24 )
          {
            *(_DWORD *)(v24 + 8) = 1;
            *(_DWORD *)(v24 + 0xC) = 1;
            *(_QWORD *)v24 = off_148B4F220;
            sub_145ECAE90(v24 + 0x10, (__int64)a2);
            *((_QWORD *)&v45 + 1) = v20;
            *(_QWORD *)&v45 = v20 + 4;
            v21 = &v45;
LABEL_17:
            sub_142704BB0(v15, v21);
LABEL_18:
            if ( _InterlockedExchangeAdd(v20 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v20)(v20);
              if ( _InterlockedExchangeAdd(v20 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v20 + 8LL))(v20);
            }
            goto LABEL_23;
          }
          v45 = xmmword_1482B5800;
          v22 = &v45;
        }
        else
        {
          if ( n9 != 9 )
            goto LABEL_58;
          v19 = allocWithProfilerInfo_w(0xB0u);
          v20 = (volatile signed __int32 *)v19;
          if ( v19 )
          {
            *(_DWORD *)(v19 + 8) = 1;
            *(_DWORD *)(v19 + 0xC) = 1;
            *(_QWORD *)v19 = off_148B4F220;
            sub_145ECAE90(v19 + 0x10, (__int64)a2);
            *((_QWORD *)&v44 + 1) = v20;
            *(_QWORD *)&v44 = v20 + 4;
            v21 = &v44;
            goto LABEL_17;
          }
          v44 = xmmword_1482B5800;
          v22 = &v44;
        }
        sub_142704BB0(v15, v22);
LABEL_23:
        assignCStringToStringStructure(
          (void **)(*v15 + 0x18),
          p_CSCActorControlStateHost::HandleRemoteClientEventUpperBody);
        Parameter_1 = (Parameter *)Parameter;
        v11 = 0;
        v15 = Parameter[1] + 0xFFFFFFFE;
LABEL_37:
        v15 += 2;
        if ( v15 == *((__int64 **)Parameter_1 + 1) )
          goto LABEL_38;
      }
      v25 = allocWithProfilerInfo_w(0xB0u);
      v20 = (volatile signed __int32 *)v25;
      if ( v25 )
      {
        *(_DWORD *)(v25 + 8) = 1;
        *(_DWORD *)(v25 + 0xC) = 1;
        *(_QWORD *)v25 = off_148B4F220;
        sub_145ECAE90(v25 + 0x10, (__int64)a2);
        n0x10 = (__int64)(v20 + 4);
        _InterlockedIncrement(v20 + 2);
      }
      else
      {
        v20 = 0;
        n0x10 = 0x10;
      }
      v27 = (volatile signed __int32 *)v15[1];
      *v15 = n0x10;
      v15[1] = (__int64)v20;
      if ( v27 )
      {
        if ( _InterlockedExchangeAdd(v27 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v27)(v27);
          if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v27 + 8LL))(v27);
        }
      }
      if ( !v20 )
        goto LABEL_23;
      goto LABEL_18;
    }
LABEL_38:
    v28 = a1 + 0x3510;
    v29 = sub_146054F00(a1 + 0x3510);
    for ( i = 0; i < v29; ++i )
    {
      v31 = *(void (__fastcall **)(__int64 *, __int64))(*a2 + 0x10);
      v32 = sub_145F95DB0(v28, i);
      v31(a2, v32);
    }
    if ( v11 )
    {
      v33 = allocWithProfilerInfo_w(0xB0u);
      v34 = (volatile signed __int32 *)v33;
      if ( v33 )
      {
        *(_DWORD *)(v33 + 8) = 1;
        *(_DWORD *)(v33 + 0xC) = 1;
        *(_QWORD *)v33 = off_148B4F220;
        sub_145ECAE90(v33 + 0x10, (__int64)a2);
        v35 = 0;
      }
      else
      {
        v35 = 0;
        v34 = 0;
      }
      Parameter_2 = (Parameter *)Parameter;
      v46[0] = v34 + 4;
      v46[1] = v34;
      v37 = Parameter[1];
      if ( v37 == Parameter[2] )
      {
        sub_1427C1BD0((Parameter *)Parameter, v37, v46);
      }
      else
      {
        *v37 = 0;
        v37[1] = 0;
        if ( v34 )
          _InterlockedIncrement(v34 + 2);
        *v37 = (__int64)(v34 + 4);
        v37[1] = (__int64)v34;
        *((_QWORD *)Parameter_2 + 1) += 0x10LL;
      }
      if ( v34 )
      {
        if ( _InterlockedExchangeAdd(v34 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *, __int64 *, __int64))v34)(v34, v37, v35);
          if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v34 + 8LL))(v34);
        }
      }
      assignCStringToStringStructure(
        (void **)(Parameter[1][0xFFFFFFFE] + 0x18),
        p_CSCActorControlStateHost::HandleRemoteClientEventUpperBody);
    }
    if ( (unsigned __int8)sub_14583AFE0(a1) )
    {
      if ( *(_QWORD *)(a1 + 0x3508) )
      {
        v38 = sub_1458402C0(a1, &v43);
        if ( sub_140597650(a2 + 1, v38) )
          sub_14584B890(a1, a2[1]);
      }
    }
LABEL_58:
    p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    if ( (*(_DWORD *)p_p_p_p_p_p_p_p_p_p_p_p_Source_1)-- == 1 )
    {
      v40 = v48;
      v41 = *(_DWORD *)(v48 + 0x14);
      if ( v41 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v41 - 1);
        *(_DWORD *)(v48 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        *(_DWORD *)(v48 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v40, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v40 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          return sub_1403DD380(v40, n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_145EC6A80 (0x145EC6A80) ---

// --- Function: sub_145EC6F80 (0x145EC6F80) ---
const ULONG_PTR *__fastcall sub_145EC6F80(
        __int64 a1,
        __int64 a2,
        _BYTE *p_CSCActorControlStateHost::HandleRemoteClientEventMovement:_STra)
{
  __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rbx
  __int64 (__fastcall *v9)(__int64, __int64, _QWORD, __int64); // rsi
  _QWORD *v10; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  volatile signed __int64 *v12; // rbx
  char v13; // r12
  int v14; // edi
  __int64 v15; // r8
  unsigned __int64 v16; // rax
  __int64 *v17; // rbx
  unsigned __int8 (__fastcall ***v18)(_QWORD); // rsi
  char v19; // di
  char n9; // al
  __int64 v21; // rax
  __int64 v22; // rdi
  __int128 *v23; // rdx
  __int128 *v24; // rdx
  Parameter *Parameter_1; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 n0x10; // rax
  volatile signed __int32 *v29; // rsi
  unsigned int v30; // r13d
  unsigned int i; // edi
  void (__fastcall *v32)(__int64, __int64); // rbx
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rbx
  __int64 v36; // r8
  Parameter *Parameter_2; // rcx
  __int64 *v38; // rdx
  _QWORD *v39; // rax
  __int64 v41; // rcx
  int v42; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v44; // [rsp+30h] [rbp-39h] BYREF
  __int128 v45; // [rsp+38h] [rbp-31h] BYREF
  __int128 v46; // [rsp+48h] [rbp-21h] BYREF
  _QWORD v47[2]; // [rsp+58h] [rbp-11h] BYREF
  Parameter *Parameter; // [rsp+68h] [rbp-1h]
  __int64 v49; // [rsp+70h] [rbp+7h]
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // [rsp+78h] [rbp+Fh]
  int v51; // [rsp+80h] [rbp+17h] BYREF
  __int64 v54; // [rsp+E8h] [rbp+7Fh] BYREF

  if ( sub_14583B030(a1)
    || (unsigned __int8)sub_14583AFE0(a1)
    || (v6 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL))(
                          qword_149B4FC40,
                          0),
        v7 = *(_QWORD *)(a1 + 0x3500),
        v8 = *v6,
        v9 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64))(*(_QWORD *)a2 + 8LL),
        v10 = sub_145840E80(a1, &v54),
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)v9(a2, v8, *v10, v7),
        !(_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source) )
  {
    v12 = (volatile signed __int64 *)(a1 + 0x3538);
    Parameter = (__int64 **)(a1 + 0x3520);
    v49 = a1 + 0x3538;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const ULONG_PTR *)&v51;
    v13 = 1;
    v51 = 1;
    v14 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x3548) == v14 )
    {
      ++*(_DWORD *)(a1 + 0x354C);
    }
    else
    {
      v15 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v16 = _InterlockedCompareExchange64(v12, 0x200000, 0);
      if ( v16 )
        sub_1403DCD60(
          (__int64)v12,
          v16,
          v15,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
          1);
      else
        *(_QWORD *)(a1 + 0x3540) = v15;
      *(_DWORD *)(a1 + 0x3548) = v14;
    }
    v17 = *Parameter;
    if ( *Parameter != Parameter[1] )
    {
      while ( 1 )
      {
        v18 = (unsigned __int8 (__fastcall ***)(_QWORD))*v17;
        v19 = (**(__int64 (__fastcall ***)(__int64))a2)(a2);
        if ( (**v18)(v18) != v19 )
        {
          Parameter_1 = (Parameter *)Parameter;
          goto LABEL_37;
        }
        n9 = (**(__int64 (__fastcall ***)(__int64))a2)(a2);
        if ( !n9 )
          break;
        if ( n9 == 7 )
        {
          v26 = allocWithProfilerInfo_w(0x40u);
          v22 = v26;
          if ( v26 )
          {
            *(_DWORD *)(v26 + 8) = 1;
            *(_DWORD *)(v26 + 0xC) = 1;
            *(_QWORD *)v26 = off_148B4F200;
            *(_QWORD *)(v26 + 0x10) = &off_148926598;
            *(_QWORD *)(v26 + 0x18) = *(_QWORD *)(a2 + 8);
            *(_BYTE *)(v26 + 0x20) = *(_BYTE *)(a2 + 0x10);
            sub_14035B160((void **)(v26 + 0x28), (const void **)(a2 + 0x18));
            v23 = &v46;
            *(_DWORD *)(v22 + 0x30) = *(_DWORD *)(a2 + 0x20);
            *(_QWORD *)(v22 + 0x10) = off_1489266B0;
            *(_QWORD *)(v22 + 0x38) = *(_QWORD *)(a2 + 0x28);
            *(_QWORD *)&v46 = v22 + 0x10;
            *((_QWORD *)&v46 + 1) = v22;
LABEL_17:
            sub_142704BB0(v17, v23);
LABEL_18:
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v22 + 8), 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(__int64))v22)(v22);
              if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v22 + 0xC), 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 8LL))(v22);
            }
            goto LABEL_23;
          }
          v46 = xmmword_1482B5800;
          v24 = &v46;
        }
        else
        {
          if ( n9 != 9 )
            goto LABEL_58;
          v21 = allocWithProfilerInfo_w(0x40u);
          v22 = v21;
          if ( v21 )
          {
            *(_DWORD *)(v21 + 8) = 1;
            *(_DWORD *)(v21 + 0xC) = 1;
            *(_QWORD *)v21 = off_148B4F200;
            *(_QWORD *)(v21 + 0x10) = &off_148926598;
            *(_QWORD *)(v21 + 0x18) = *(_QWORD *)(a2 + 8);
            *(_BYTE *)(v21 + 0x20) = *(_BYTE *)(a2 + 0x10);
            sub_14035B160((void **)(v21 + 0x28), (const void **)(a2 + 0x18));
            v23 = &v45;
            *(_DWORD *)(v22 + 0x30) = *(_DWORD *)(a2 + 0x20);
            *(_QWORD *)(v22 + 0x10) = off_1489266B0;
            *(_QWORD *)(v22 + 0x38) = *(_QWORD *)(a2 + 0x28);
            *(_QWORD *)&v45 = v22 + 0x10;
            *((_QWORD *)&v45 + 1) = v22;
            goto LABEL_17;
          }
          v45 = xmmword_1482B5800;
          v24 = &v45;
        }
        sub_142704BB0(v17, v24);
LABEL_23:
        assignCStringToStringStructure(
          (void **)(*v17 + 0x18),
          p_CSCActorControlStateHost::HandleRemoteClientEventMovement:_STra);
        Parameter_1 = (Parameter *)Parameter;
        v13 = 0;
        v17 = Parameter[1] + 0xFFFFFFFE;
LABEL_37:
        v17 += 2;
        if ( v17 == *((__int64 **)Parameter_1 + 1) )
          goto LABEL_38;
      }
      v27 = allocWithProfilerInfo_w(0x40u);
      v22 = v27;
      if ( v27 )
      {
        *(_DWORD *)(v27 + 8) = 1;
        *(_DWORD *)(v27 + 0xC) = 1;
        *(_QWORD *)v27 = off_148B4F200;
        *(_QWORD *)(v27 + 0x10) = &off_148926598;
        *(_QWORD *)(v27 + 0x18) = *(_QWORD *)(a2 + 8);
        *(_BYTE *)(v27 + 0x20) = *(_BYTE *)(a2 + 0x10);
        sub_14035B160((void **)(v27 + 0x28), (const void **)(a2 + 0x18));
        *(_DWORD *)(v22 + 0x30) = *(_DWORD *)(a2 + 0x20);
        *(_QWORD *)(v22 + 0x10) = off_1489266B0;
        *(_QWORD *)(v22 + 0x38) = *(_QWORD *)(a2 + 0x28);
        n0x10 = v22 + 0x10;
        _InterlockedIncrement((volatile signed __int32 *)(v22 + 8));
      }
      else
      {
        v22 = 0;
        n0x10 = 0x10;
      }
      v29 = (volatile signed __int32 *)v17[1];
      *v17 = n0x10;
      v17[1] = v22;
      if ( v29 )
      {
        if ( _InterlockedExchangeAdd(v29 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v29)(v29);
          if ( _InterlockedExchangeAdd(v29 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v29 + 8LL))(v29);
        }
      }
      if ( !v22 )
        goto LABEL_23;
      goto LABEL_18;
    }
LABEL_38:
    v30 = sub_146054F00(a1 + 0x3510);
    for ( i = 0; i < v30; ++i )
    {
      v32 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a2 + 0x10LL);
      v33 = sub_145F95DB0(a1 + 0x3510, i);
      v32(a2, v33);
    }
    if ( v13 )
    {
      v34 = allocWithProfilerInfo_w(0x40u);
      v35 = v34;
      if ( v34 )
      {
        *(_DWORD *)(v34 + 8) = 1;
        *(_DWORD *)(v34 + 0xC) = 1;
        *(_QWORD *)v34 = off_148B4F200;
        *(_QWORD *)(v34 + 0x10) = &off_148926598;
        *(_QWORD *)(v34 + 0x18) = *(_QWORD *)(a2 + 8);
        *(_BYTE *)(v34 + 0x20) = *(_BYTE *)(a2 + 0x10);
        sub_14035B160((void **)(v34 + 0x28), (const void **)(a2 + 0x18));
        v36 = 0;
        *(_DWORD *)(v35 + 0x30) = *(_DWORD *)(a2 + 0x20);
        *(_QWORD *)(v35 + 0x10) = off_1489266B0;
        *(_QWORD *)(v35 + 0x38) = *(_QWORD *)(a2 + 0x28);
      }
      else
      {
        v36 = 0;
        v35 = 0;
      }
      Parameter_2 = (Parameter *)Parameter;
      v47[0] = v35 + 0x10;
      v47[1] = v35;
      v38 = Parameter[1];
      if ( v38 == Parameter[2] )
      {
        sub_1427C1BD0((Parameter *)Parameter, v38, v47);
      }
      else
      {
        *v38 = 0;
        v38[1] = 0;
        if ( v35 )
          _InterlockedIncrement((volatile signed __int32 *)(v35 + 8));
        *v38 = v35 + 0x10;
        v38[1] = v35;
        *((_QWORD *)Parameter_2 + 1) += 0x10LL;
      }
      if ( v35 )
      {
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v35 + 8), 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(__int64, __int64 *, __int64))v35)(v35, v38, v36);
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v35 + 0xC), 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 8LL))(v35);
        }
      }
      assignCStringToStringStructure(
        (void **)(Parameter[1][0xFFFFFFFE] + 0x18),
        p_CSCActorControlStateHost::HandleRemoteClientEventMovement:_STra);
    }
    if ( (unsigned __int8)sub_14583AFE0(a1) )
    {
      if ( *(_QWORD *)(a1 + 0x3508) )
      {
        v39 = sub_1458402C0(a1, &v44);
        if ( sub_140597650((_QWORD *)(a2 + 8), v39) )
          sub_14584B890(a1, *(_QWORD *)(a2 + 8));
      }
    }
LABEL_58:
    p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    if ( (*(_DWORD *)p_p_p_p_p_p_p_p_p_p_p_p_Source_1)-- == 1 )
    {
      v41 = v49;
      v42 = *(_DWORD *)(v49 + 0x14);
      if ( v42 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v42 - 1);
        *(_DWORD *)(v49 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        *(_DWORD *)(v49 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v41, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v41 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          return sub_1403DD380(v41, n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_145EC6F80 (0x145EC6F80) ---

// --- Function: sub_145EC7530 (0x145EC7530) ---
__int64 __fastcall sub_145EC7530(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  int v7; // edi
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  __int64 *v10; // rbx
  unsigned __int8 (__fastcall ***v11)(_QWORD); // rsi
  char v12; // di
  unsigned __int8 v13; // bl
  __int64 v15; // r8
  int v16; // ecx
  __int64 result; // rax
  __int64 v18; // rdi
  char **v19; // rdx
  unsigned __int64 n0x200000; // rax
  __int64 **v21; // [rsp+30h] [rbp-48h] BYREF
  __int64 v22; // [rsp+38h] [rbp-40h]
  int *v23; // [rsp+40h] [rbp-38h]
  int v24; // [rsp+48h] [rbp-30h] BYREF
  int Parameter_; // [rsp+80h] [rbp+8h] BYREF

  v21 = (__int64 **)(a1 + 0x3520);
  v3 = a1 + 0x3538;
  v23 = &v24;
  v22 = a1 + 0x3538;
  v24 = 1;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v9 = _InterlockedCompareExchange64((volatile signed __int64 *)v3, 0x200000, 0);
    if ( v9 )
      sub_1403DCD60(
        v3,
        v9,
        v8,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        1);
    else
      *(_QWORD *)(v3 + 8) = v8;
    *(_DWORD *)(v3 + 0x10) = v7;
  }
  v10 = *v21;
  if ( *v21 == v21[1] )
  {
LABEL_10:
    v13 = 0;
  }
  else
  {
    while ( 1 )
    {
      v11 = (unsigned __int8 (__fastcall ***)(_QWORD))*v10;
      v12 = (**(__int64 (__fastcall ***)(__int64))a2)(a2);
      if ( (**v11)(v11) == v12 )
        break;
      v10 += 2;
      if ( v10 == v21[1] )
        goto LABEL_10;
    }
    v18 = *v10;
    v19 = (char **)(*v10 + 0x18);
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(*v10 + 8);
    *(_BYTE *)(a2 + 0x10) = *(_BYTE *)(v18 + 0x10);
    copyStringStructure((char **)(a2 + 0x18), v19);
    *(_DWORD *)(a2 + 0x20) = *(_DWORD *)(v18 + 0x20);
    *(_BYTE *)(a2 + 0x28) = *(_BYTE *)(v18 + 0x28);
    sub_141A63B10(a2 + 0x30, v18 + 0x30);
    *(_DWORD *)(a2 + 0xA8) = *(_DWORD *)(v18 + 0xA8);
    if ( a3 )
    {
      sub_145846310(a1, *v10);
      sub_1433E9DD0((__int64 *)&v21, (BB_ComparisonOperatorType *)&Parameter_, v10);
    }
    v13 = 1;
  }
  if ( (*v23)-- == 1 )
  {
    v15 = v22;
    v16 = *(_DWORD *)(v22 + 0x14);
    if ( v16 )
    {
      result = v13;
      *(_DWORD *)(v22 + 0x14) = v16 - 1;
      return result;
    }
    *(_DWORD *)(v22 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v15, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      *(_QWORD *)(v15 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      return v13;
    }
    sub_1403DD380(v15, n0x200000);
  }
  return v13;
}

// --- End Function: sub_145EC7530 (0x145EC7530) ---

// --- Function: sub_145EC7720 (0x145EC7720) ---
__int64 __fastcall sub_145EC7720(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  int v7; // edi
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  __int64 *v10; // rbx
  unsigned __int8 (__fastcall ***v11)(_QWORD); // rsi
  char v12; // di
  unsigned __int8 v13; // bl
  __int64 v15; // r8
  int v16; // ecx
  __int64 result; // rax
  __int64 v18; // rdi
  char **v19; // rdx
  unsigned __int64 n0x200000; // rax
  __int64 **v21; // [rsp+30h] [rbp-48h] BYREF
  __int64 v22; // [rsp+38h] [rbp-40h]
  int *v23; // [rsp+40h] [rbp-38h]
  int v24; // [rsp+48h] [rbp-30h] BYREF
  int Parameter_; // [rsp+80h] [rbp+8h] BYREF

  v21 = (__int64 **)(a1 + 0x3520);
  v3 = a1 + 0x3538;
  v23 = &v24;
  v22 = a1 + 0x3538;
  v24 = 1;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v9 = _InterlockedCompareExchange64((volatile signed __int64 *)v3, 0x200000, 0);
    if ( v9 )
      sub_1403DCD60(
        v3,
        v9,
        v8,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        1);
    else
      *(_QWORD *)(v3 + 8) = v8;
    *(_DWORD *)(v3 + 0x10) = v7;
  }
  v10 = *v21;
  if ( *v21 == v21[1] )
  {
LABEL_10:
    v13 = 0;
  }
  else
  {
    while ( 1 )
    {
      v11 = (unsigned __int8 (__fastcall ***)(_QWORD))*v10;
      v12 = (**(__int64 (__fastcall ***)(__int64))a2)(a2);
      if ( (**v11)(v11) == v12 )
        break;
      v10 += 2;
      if ( v10 == v21[1] )
        goto LABEL_10;
    }
    v18 = *v10;
    v19 = (char **)(*v10 + 0x18);
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(*v10 + 8);
    *(_BYTE *)(a2 + 0x10) = *(_BYTE *)(v18 + 0x10);
    copyStringStructure((char **)(a2 + 0x18), v19);
    *(_DWORD *)(a2 + 0x20) = *(_DWORD *)(v18 + 0x20);
    sub_141A63B10(a2 + 0x28, v18 + 0x28);
    *(_BYTE *)(a2 + 0xA0) = *(_BYTE *)(v18 + 0xA0);
    if ( a3 )
    {
      sub_145846310(a1, *v10);
      sub_1433E9DD0((__int64 *)&v21, (BB_ComparisonOperatorType *)&Parameter_, v10);
    }
    v13 = 1;
  }
  if ( (*v23)-- == 1 )
  {
    v15 = v22;
    v16 = *(_DWORD *)(v22 + 0x14);
    if ( v16 )
    {
      result = v13;
      *(_DWORD *)(v22 + 0x14) = v16 - 1;
      return result;
    }
    *(_DWORD *)(v22 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v15, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      *(_QWORD *)(v15 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      return v13;
    }
    sub_1403DD380(v15, n0x200000);
  }
  return v13;
}

// --- End Function: sub_145EC7720 (0x145EC7720) ---

// --- Function: sub_145EC7900 (0x145EC7900) ---
__int64 __fastcall sub_145EC7900(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  int v7; // edi
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  __int64 *v10; // rbx
  unsigned __int8 (__fastcall ***v11)(_QWORD); // rsi
  char v12; // di
  unsigned __int8 v13; // bl
  __int64 v15; // r8
  int v16; // ecx
  __int64 result; // rax
  __int64 v18; // rdi
  char **v19; // rdx
  unsigned __int64 n0x200000; // rax
  __int64 **v21; // [rsp+30h] [rbp-48h] BYREF
  __int64 v22; // [rsp+38h] [rbp-40h]
  int *v23; // [rsp+40h] [rbp-38h]
  int v24; // [rsp+48h] [rbp-30h] BYREF
  int Parameter_; // [rsp+80h] [rbp+8h] BYREF

  v21 = (__int64 **)(a1 + 0x3520);
  v3 = a1 + 0x3538;
  v23 = &v24;
  v22 = a1 + 0x3538;
  v24 = 1;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v9 = _InterlockedCompareExchange64((volatile signed __int64 *)v3, 0x200000, 0);
    if ( v9 )
      sub_1403DCD60(
        v3,
        v9,
        v8,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        1);
    else
      *(_QWORD *)(v3 + 8) = v8;
    *(_DWORD *)(v3 + 0x10) = v7;
  }
  v10 = *v21;
  if ( *v21 == v21[1] )
  {
LABEL_10:
    v13 = 0;
  }
  else
  {
    while ( 1 )
    {
      v11 = (unsigned __int8 (__fastcall ***)(_QWORD))*v10;
      v12 = (**(__int64 (__fastcall ***)(__int64))a2)(a2);
      if ( (**v11)(v11) == v12 )
        break;
      v10 += 2;
      if ( v10 == v21[1] )
        goto LABEL_10;
    }
    v18 = *v10;
    v19 = (char **)(*v10 + 0x18);
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(*v10 + 8);
    *(_BYTE *)(a2 + 0x10) = *(_BYTE *)(v18 + 0x10);
    copyStringStructure((char **)(a2 + 0x18), v19);
    *(_DWORD *)(a2 + 0x20) = *(_DWORD *)(v18 + 0x20);
    *(_QWORD *)(a2 + 0x28) = *(_QWORD *)(v18 + 0x28);
    if ( a3 )
    {
      sub_145846310(a1, *v10);
      sub_1433E9DD0((__int64 *)&v21, (BB_ComparisonOperatorType *)&Parameter_, v10);
    }
    v13 = 1;
  }
  if ( (*v23)-- == 1 )
  {
    v15 = v22;
    v16 = *(_DWORD *)(v22 + 0x14);
    if ( v16 )
    {
      result = v13;
      *(_DWORD *)(v22 + 0x14) = v16 - 1;
      return result;
    }
    *(_DWORD *)(v22 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v15, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      *(_QWORD *)(v15 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      return v13;
    }
    sub_1403DD380(v15, n0x200000);
  }
  return v13;
}

// --- End Function: sub_145EC7900 (0x145EC7900) ---

// --- Function: sub_145ECAE90 (0x145ECAE90) ---
__int64 __fastcall sub_145ECAE90(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &off_148926598;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 0x10) = *(_BYTE *)(a2 + 0x10);
  sub_14035B160((void **)(a1 + 0x18), (const void **)(a2 + 0x18));
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x20);
  *(_QWORD *)a1 = off_148926650;
  sub_141BDC970(a1 + 0x28, a2 + 0x28);
  return a1;
}

// --- End Function: sub_145ECAE90 (0x145ECAE90) ---

// --- Function: sub_145ED3C80 (0x145ED3C80) ---
char __fastcall sub_145ED3C80(__int64 a1, int *a2)
{
  __int64 v4; // rax
  __int64 v5; // rcx
  int *v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rbx
  int *v9; // rbp
  int v10; // eax
  __int64 v11; // r9
  __int64 v12; // rax
  unsigned int v13; // ecx
  unsigned int v14; // edx
  unsigned int v15; // r8d

  if ( *(_BYTE *)(a1 + 0x30) )
  {
    sub_1443CD4A0(*(const void ***)(a1 + 0x88), a2);
    return 0;
  }
  else
  {
    *(_BYTE *)(a1 + 0x30) = 1;
    sub_145ED41F0((char *)a1, *(_QWORD *)(a1 + 8), 0, (__int64)a2);
    while ( sub_1443D7790(*(_QWORD *)(a1 + 0x88)) )
    {
      v4 = *(_QWORD *)(a1 + 0x80);
      v5 = *(_QWORD *)(a1 + 0x88);
      *(_QWORD *)(a1 + 0x80) = v5;
      *(_QWORD *)(a1 + 0x88) = v4;
      while ( sub_1443D7790(*(_QWORD *)(a1 + 0x80)) )
      {
        v6 = sub_1443D4F50(*(_QWORD **)(a1 + 0x80));
        v7 = *(_QWORD *)(a1 + 8);
        v8 = 0;
        v9 = v6;
        if ( v7 )
        {
          do
          {
            v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, int *))v7)(
                    a1 + *(int *)(v7 + 8),
                    *(_QWORD *)(a1 + 0x28),
                    v9);
            if ( v10 == 0xFFFFFFFE )
            {
              v7 = *(_QWORD *)(v7 + 0x20);
            }
            else
            {
              if ( v10 == 0xFFFFFFFF || v10 == *(_DWORD *)(*(_QWORD *)(a1 + 8) + 0x18LL) )
                break;
              sub_145EE0B00(a1, *(_QWORD *)(a1 + 0x18) + 0x48LL * v10);
              v11 = *(_QWORD *)(a1 + 8);
              v8 = v7;
              v12 = v11;
              if ( v11 )
              {
                v13 = *(_DWORD *)(v7 + 0x38);
                v14 = v13;
                v15 = *(_DWORD *)(v11 + 0x38);
                if ( v15 < v13 )
                  v14 = *(_DWORD *)(v11 + 0x38);
                if ( v13 > v14 )
                {
                  do
                    v8 = *(_QWORD *)(v8 + 0x20);
                  while ( *(_DWORD *)(v8 + 0x38) > v14 );
                }
                if ( v15 > v14 )
                {
                  do
                    v12 = *(_QWORD *)(v12 + 0x20);
                  while ( *(_DWORD *)(v12 + 0x38) > v14 );
                }
                for ( ; v8 != v12; v12 = *(_QWORD *)(v12 + 0x20) )
                  v8 = *(_QWORD *)(v8 + 0x20);
              }
              else
              {
                v8 = 0;
              }
              v7 = *(_QWORD *)(a1 + 8);
            }
          }
          while ( v7 != v8 );
        }
      }
      sub_1443CF880(*(_QWORD **)(a1 + 0x80));
    }
    *(_BYTE *)(a1 + 0x30) = 0;
    return 1;
  }
}

// --- End Function: sub_145ED3C80 (0x145ED3C80) ---

// --- Function: sub_145ED3E20 (0x145ED3E20) ---
double __fastcall sub_145ED3E20(__int64 a1, int *a2)
{
  sub_145ED3E50(a1, a2);
  return sub_145ED3FD0(a1, a2);
}

// --- End Function: sub_145ED3E20 (0x145ED3E20) ---

// --- Function: sub_145ED3E50 (0x145ED3E50) ---
double __fastcall sub_145ED3E50(__int64 a1, int *a2)
{
  volatile signed __int32 *v4; // rbx
  int v5; // edi
  _DWORD *v6; // rdi
  unsigned __int32 v7; // eax
  unsigned __int32 v8; // eax
  int n0x4200; // [rsp+30h] [rbp-68h] BYREF
  __int64 v11; // [rsp+34h] [rbp-64h]
  int v12; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v13; // [rsp+40h] [rbp-58h]
  unsigned __int64 v14; // [rsp+48h] [rbp-50h]
  __int64 v15; // [rsp+50h] [rbp-48h]
  __int64 v16; // [rsp+58h] [rbp-40h]

  n0x4200 = 0x4200;
  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v13 = __rdtsc();
  qword_149B4B870(
    &n0x4200,
    &word_149E745C4,
    "CSCActorControlStateHost::HandleEventMovement",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorControlStateHostComponent.cpp",
    0x261);
  v4 = (volatile signed __int32 *)(a1 + 0x278);
  HIWORD(n0x4200) = word_149E745C4;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x288) == v5 )
  {
    ++*(_DWORD *)(a1 + 0x28C);
    v6 = (_DWORD *)(a1 + 0x28C);
  }
  else
  {
    v7 = _InterlockedCompareExchange(v4, 1, 0);
    if ( v7 )
      sub_1403C33A0(a1 + 0x278, v7, "CSCActorControlStateHost::HandleEventMovement", 1);
    else
      *(_QWORD *)(a1 + 0x280) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x288) = v5;
    v6 = (_DWORD *)(a1 + 0x28C);
  }
  if ( *(_BYTE *)(a1 + 0x10) )
  {
    if ( *(_BYTE *)(a1 + 0x11)
      || *(unsigned __int64 (__fastcall ****)(AK::MemoryMgr *__hidden))(a1 + 0x28) == off_149A7BBB8 )
    {
      v6 = (_DWORD *)(a1 + 0x28C);
    }
    else
    {
      sub_145ED3C80(*(_QWORD *)(a1 + 0x18), a2);
    }
  }
  else
  {
    sub_145ED4470(a1, (__int64)a2);
  }
  if ( *v6 )
  {
    --*v6;
  }
  else
  {
    *(_DWORD *)(a1 + 0x288) = 0xFFFFFFFF;
    v8 = _InterlockedCompareExchange(v4, 0, 1);
    if ( v8 == 1 )
      *(_QWORD *)(a1 + 0x280) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(a1 + 0x278, v8);
  }
  v14 = __rdtsc();
  return qword_149B4B878(&n0x4200);
}

// --- End Function: sub_145ED3E50 (0x145ED3E50) ---

// --- Function: sub_145ED3FD0 (0x145ED3FD0) ---
double __fastcall sub_145ED3FD0(__int64 a1, int *a2)
{
  volatile signed __int32 *v4; // rbx
  int v5; // ebp
  unsigned __int32 v6; // eax
  __int64 v7; // rcx
  __int64 v8; // rbp
  int v9; // eax
  unsigned __int32 v10; // eax
  int n0x4200; // [rsp+30h] [rbp-128h] BYREF
  __int64 v13; // [rsp+34h] [rbp-124h]
  int v14; // [rsp+3Ch] [rbp-11Ch]
  unsigned __int64 v15; // [rsp+40h] [rbp-118h]
  unsigned __int64 v16; // [rsp+48h] [rbp-110h]
  __int64 v17; // [rsp+50h] [rbp-108h]
  __int64 v18; // [rsp+58h] [rbp-100h]
  __int64 v19[3]; // [rsp+80h] [rbp-D8h] BYREF
  __int64 v20; // [rsp+98h] [rbp-C0h] BYREF
  _QWORD v21[15]; // [rsp+A8h] [rbp-B0h] BYREF

  n0x4200 = 0x4200;
  v13 = 0;
  v14 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v15 = __rdtsc();
  qword_149B4B870(
    &n0x4200,
    &word_149E745C8,
    "CSCActorControlStateHost::HandleEventUpperBody",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\SCActorControlStateHostComponent.cpp",
    0x283);
  v4 = (volatile signed __int32 *)(a1 + 0x278);
  HIWORD(n0x4200) = word_149E745C8;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x288) == v5 )
  {
    ++*(_DWORD *)(a1 + 0x28C);
  }
  else
  {
    v6 = _InterlockedCompareExchange(v4, 1, 0);
    if ( v6 )
      sub_1403C33A0(a1 + 0x278, v6, "CSCActorControlStateHost::HandleEventUpperBody", 1);
    else
      *(_QWORD *)(a1 + 0x280) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x288) = v5;
  }
  if ( *(_BYTE *)(a1 + 0x10) )
  {
    if ( !*(_BYTE *)(a1 + 0x11)
      && *(unsigned __int64 (__fastcall ****)(AK::MemoryMgr *__hidden))(a1 + 0x30) != off_149A7BBB8 )
    {
      v7 = *(_QWORD *)(a1 + 0x20);
      if ( v7 )
        sub_145ED3C80(v7, a2);
    }
  }
  else if ( !*(_BYTE *)(a1 + 0x11) )
  {
    v8 = sub_1465EEE60(*(_QWORD *)(a1 + 8));
    if ( *a2 == 0x92 )
    {
      sub_1443CA220((__int64)v19);
      if ( sub_145627EF0(a1, (__int64)v19, a2[1]) )
        sub_145EC6A80(v8, v19, "CSCActorControlStateHost::HandleRemoteClientEventUpperBody");
      sub_141976650(v21);
      sub_140370D10(&v20);
    }
  }
  v9 = *(_DWORD *)(a1 + 0x28C);
  if ( v9 )
  {
    *(_DWORD *)(a1 + 0x28C) = v9 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0x288) = 0xFFFFFFFF;
    v10 = _InterlockedCompareExchange(v4, 0, 1);
    if ( v10 == 1 )
      *(_QWORD *)(a1 + 0x280) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(a1 + 0x278, v10);
  }
  v16 = __rdtsc();
  return qword_149B4B878(&n0x4200);
}

// --- End Function: sub_145ED3FD0 (0x145ED3FD0) ---

// --- Function: sub_145ED41F0 (0x145ED41F0) ---
void __fastcall sub_145ED41F0(char *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  int v8; // eax
  __int64 v9; // r9
  __int64 v10; // rcx
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned int v13; // r8d

  if ( a2 != a3 )
  {
    v5 = a3;
    v6 = a2;
    do
    {
      v8 = (*(__int64 (__fastcall **)(char *, _QWORD, __int64))v6)(&a1[*(int *)(v6 + 8)], *((_QWORD *)a1 + 5), a4);
      if ( v8 == 0xFFFFFFFE )
      {
        v6 = *(_QWORD *)(v6 + 0x20);
      }
      else
      {
        if ( v8 == 0xFFFFFFFF || v8 == *(_DWORD *)(*((_QWORD *)a1 + 1) + 0x18LL) )
          return;
        sub_145EE0B00((__int64)a1, *((_QWORD *)a1 + 3) + 0x48LL * v8);
        v9 = *((_QWORD *)a1 + 1);
        v5 = v6;
        v10 = v9;
        if ( v9 )
        {
          v11 = *(_DWORD *)(v6 + 0x38);
          v12 = v11;
          v13 = *(_DWORD *)(v9 + 0x38);
          if ( v13 < v11 )
            v12 = *(_DWORD *)(v9 + 0x38);
          if ( v11 > v12 )
          {
            do
              v5 = *(_QWORD *)(v5 + 0x20);
            while ( *(_DWORD *)(v5 + 0x38) > v12 );
          }
          if ( v13 > v12 )
          {
            do
              v10 = *(_QWORD *)(v10 + 0x20);
            while ( *(_DWORD *)(v10 + 0x38) > v12 );
          }
          for ( ; v5 != v10; v10 = *(_QWORD *)(v10 + 0x20) )
            v5 = *(_QWORD *)(v5 + 0x20);
        }
        else
        {
          v5 = 0;
        }
        v6 = *((_QWORD *)a1 + 1);
      }
    }
    while ( v6 != v5 );
  }
}

// --- End Function: sub_145ED41F0 (0x145ED41F0) ---

// --- Function: sub_145ED4470 (0x145ED4470) ---
void __fastcall sub_145ED4470(__int64 a1, __int64 a2)
{
  __crt_win32_buffer_debug_info *v4; // rbx
  int n0x11C; // eax
  __int64 v6; // r14
  char n0x2A; // al
  _BYTE *v8; // rdx
  __int64 *v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rax
  char n0x17; // dl
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int64 *v16; // rsi
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  char n0x18; // cl
  __int64 v23; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v24; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v25[3]; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v26[3]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v27; // [rsp+70h] [rbp-90h] BYREF
  __int64 v28; // [rsp+78h] [rbp-88h]
  _QWORD v29[2]; // [rsp+88h] [rbp-78h] BYREF
  __int64 v30; // [rsp+98h] [rbp-68h] BYREF
  _QWORD v31[14]; // [rsp+A0h] [rbp-60h] BYREF
  char v32; // [rsp+110h] [rbp+10h]

  if ( !*(_BYTE *)(a1 + 0x11) )
  {
    v4 = (__crt_win32_buffer_debug_info *)sub_1465EEE60(*(_QWORD *)(a1 + 8));
    n0x11C = *(_DWORD *)a2;
    if ( *(int *)a2 > 0x108 )
    {
      if ( n0x11C == 0x11C )
      {
        v21 = sub_14583F430((__int64)v4);
        if ( v21 )
        {
          n0x18 = **(_BYTE **)(v21 + 0x20);
          if ( n0x18 != 1 && n0x18 != 0x18 && n0x18 != 0xD )
          {
            sub_1443C8870((__int64)&v27);
            if ( !(unsigned __int8)sub_145EC7720((__int64)v4, (__int64)&v27, 0) )
              sub_145EC6580(
                (__int64)v4,
                &v27,
                "CSCActorControlStateHost::HandleRemoteClientEventMovement: SPassOut event");
            sub_141976650(&v30);
            sub_140370D10(v29);
          }
        }
      }
    }
    else if ( n0x11C == 0x108 )
    {
      v20 = sub_14583F430((__int64)v4);
      if ( v20 && **(_BYTE **)(v20 + 0x20) != 1 )
        sub_145880800((__crt_win32_buffer_debug_info *)a1, (__int64)v4, v20);
    }
    else
    {
      switch ( n0x11C )
      {
        case 3:
          if ( *(_BYTE *)(a2 + 0x11) )
          {
            v23 = *(_QWORD *)(a2 + 8);
            if ( sub_14030EC00((unsigned __int64 *)&v23) )
            {
              sub_1425D62E0(v23 & 0xFFFFFFFFFFFFLL, &v24);
              if ( is_valid_handle_typeA(&v24) )
              {
                if ( sub_1465D1DE0(v24 & 0xFFFFFFFFFFFFLL) )
                {
                  sub_1443C8760((__int64)&v27);
                  if ( !(unsigned __int8)sub_145EC7530((__int64)v4, (__int64)&v27, 0) )
                  {
                    sub_145822E10(
                      (__int64)v4,
                      &v27,
                      "CSCActorControlStateHost::HandleRemoteClientEventMovement: SDead event");
                    sub_145847F70((__int64)v4, 1, 0.0);
                  }
                  sub_141976650(v31);
                  sub_140370D10(v29);
                }
              }
            }
          }
          return;
        case 0x2F:
          v15 = sub_14583F430((__int64)v4);
          if ( v15 && **(_BYTE **)(v15 + 0x20) != 1 )
            sub_145B343F0(*(_QWORD *)(a1 + 8), v15, a2);
          return;
        case 0x34:
          v18 = sub_14583F430((__int64)v4);
          sub_145B34360(*(_QWORD *)(a1 + 8), v18, a2);
          return;
        case 0x35:
          v19 = sub_14583F430((__int64)v4);
          sub_145B344D0(*(_QWORD *)(a1 + 8), v19, a2);
          return;
        case 0x5E:
          v11 = sub_14583F430((__int64)v4);
          if ( v11 )
          {
            n0x17 = **(_BYTE **)(v11 + 0x20);
            if ( n0x17 != 1 && (n0x17 != 0x17 || !*(_BYTE *)(*(_QWORD *)(v11 + 0x1A8) + 0xDLL)) )
              sub_145873400((__crt_win32_buffer_debug_info *)a1, (__int64)v4, v11, a2);
          }
          return;
        case 0x64:
          v13 = sub_14583F430((__int64)v4);
          if ( v13 && **(_BYTE **)(v13 + 0x20) != 1 )
            sub_145881990((__crt_win32_buffer_debug_info *)a1, (__int64)v4, v13, a2);
          return;
        case 0x66:
          v14 = sub_14583F430((__int64)v4);
          if ( v14 && **(_BYTE **)(v14 + 0x20) != 1 )
            sub_1458817A0((__crt_win32_buffer_debug_info *)a1, (__int64)v4, v14, a2);
          return;
        case 0x6A:
          if ( !*(_BYTE *)(a2 + 0x18) )
            return;
          v6 = sub_14583F430((__int64)v4);
          n0x2A = **(_BYTE **)(v6 + 0x20);
          if ( n0x2A == 1 )
          {
            sub_1443C8760((__int64)&v27);
            if ( !(unsigned __int8)sub_145EC7530((__int64)v4, (__int64)&v27, 0) )
            {
              v8 = *(_BYTE **)(v6 + 0x60);
              v28 = *(_QWORD *)(*(_QWORD *)(v6 + 0x20) + 8LL);
              LOBYTE(v30) = *v8;
              sub_141A63B10((__int64)v31, (__int64)(v8 + 0x10));
            }
            sub_145F26EB0(
              v4,
              *(_DWORD *)(a2 + 4),
              (float *)(a2 + 8),
              *(_DWORD *)(a2 + 0x14),
              *(_DWORD *)(a2 + 0x1C),
              (__int64)&v27);
            v9 = v31;
LABEL_17:
            sub_141976650(v9);
            sub_140370D10(v29);
            return;
          }
          if ( n0x2A == 0x2A )
          {
            sub_1443C8870((__int64)&v27);
            if ( !(unsigned __int8)sub_145EC7720((__int64)v4, (__int64)&v27, 0) )
            {
              v10 = *(_QWORD *)(v6 + 0x68);
              v28 = *(_QWORD *)(*(_QWORD *)(v6 + 0x20) + 8LL);
              sub_141A63B10((__int64)&v30, v10);
              v32 = *(_BYTE *)(*(_QWORD *)(v6 + 0x68) + 0xF0LL);
            }
            sub_145F272E0(
              v4,
              *(_DWORD *)(a2 + 4),
              (float *)(a2 + 8),
              *(_DWORD *)(a2 + 0x14),
              *(_DWORD *)(a2 + 0x1C),
              (__int64)&v27);
            v9 = &v30;
            goto LABEL_17;
          }
          if ( !(*(unsigned __int8 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 0x650LL))(*(_QWORD *)(a1 + 8)) )
            sub_1457E2510(
              v4,
              v6,
              *(_DWORD *)(a2 + 4),
              (float *)(a2 + 8),
              *(_DWORD *)(a2 + 0x14),
              *(_DWORD *)(a2 + 0x1C));
          break;
        case 0xAD:
          v16 = (unsigned __int64 *)(a2 + 8);
          v24 = *(_QWORD *)(a2 + 8);
          if ( sub_14030EC00((unsigned __int64 *)&v24) )
          {
            sub_1425D62E0(v24 & 0xFFFFFFFFFFFFLL, &v23);
            if ( is_valid_handle_typeA(&v23) )
            {
              v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x758LL))(v23 & 0xFFFFFFFFFFFFLL);
              if ( sub_1403BFC90(v17) && (sub_145843D90((__int64)v4) || sub_145843E20((__int64)v4)) )
              {
                sub_1443CB320((__int64)v25);
                if ( sub_14030EC00(v16) )
                {
                  v26[2] = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)(*v16 & 0xFFFFFFFFFFFFLL)
                                                                                             + 8LL))(
                                        *v16 & 0xFFFFFFFFFFFFLL,
                                        &v23);
                  sub_145EC6F80(
                    (__int64)v4,
                    (__int64)v25,
                    "CSCActorControlStateHost::HandleRemoteClientEventMovement: STractored event");
                }
                else
                {
                  sub_145EC7900((__int64)v4, (__int64)v25, 1);
                }
                sub_140370D10(v26);
              }
            }
          }
          return;
        case 0xF7:
          sub_1443C9B20((__int64)&v27);
          if ( (unsigned __int8)sub_1432B1780((__int64)v4, &v27, 0) && !LODWORD(v31[0]) )
            sub_145A3A490(*(_QWORD *)(a1 + 0x98) & 0xFFFFFFFFFFFFLL, 3, 0, 0);
          sub_140370D10(v29);
          return;
        default:
          return;
      }
    }
  }
}

// --- End Function: sub_145ED4470 (0x145ED4470) ---

// --- Function: sub_145EE0B00 (0x145EE0B00) ---
_DWORD *__fastcall sub_145EE0B00(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  unsigned int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // r8d
  __int64 i; // rbp
  __int64 j; // rbp
  _DWORD *result; // rax
  int v11; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  if ( v2 && a2 )
  {
    v5 = *(_DWORD *)(v2 + 0x38);
    v6 = v5;
    v7 = *(_DWORD *)(a2 + 0x38);
    if ( v7 < v5 )
      v6 = *(_DWORD *)(a2 + 0x38);
    if ( v5 > v6 )
    {
      do
        v2 = *(_QWORD *)(v2 + 0x20);
      while ( *(_DWORD *)(v2 + 0x38) > v6 );
    }
    if ( v7 > v6 )
    {
      do
        a2 = *(_QWORD *)(a2 + 0x20);
      while ( *(_DWORD *)(a2 + 0x38) > v6 );
    }
    for ( ; v2 != a2; a2 = *(_QWORD *)(a2 + 0x20) )
      v2 = *(_QWORD *)(v2 + 0x20);
  }
  else
  {
    v2 = 0;
  }
  v11 = 0;
  sub_14035C4A0(&v11, 0xD4);
  for ( i = *(_QWORD *)(a1 + 8); i != v2; i = *(_QWORD *)(i + 0x20) )
    (*(void (__fastcall **)(__int64, _QWORD, int *))i)(a1 + *(int *)(i + 8), *(_QWORD *)(a1 + 0x28), &v11);
  v11 = 0;
  sub_14035C4A0(&v11, 0xD2);
  for ( j = *(_QWORD *)(a1 + 8); j != v2; j = *(_QWORD *)(j + 0x20) )
    (*(void (__fastcall **)(__int64, _QWORD, int *))j)(a1 + *(int *)(j + 8), *(_QWORD *)(a1 + 0x28), &v11);
  *(_QWORD *)(a1 + 8) = v3;
  sub_14035C4A0(&v11, 0xD1);
  if ( v3 == v2 )
  {
    v11 = 0;
    return sub_14035C4A0(&v11, 0xD3);
  }
  else
  {
    sub_145ED42E0(a1, *(_QWORD *)(v3 + 0x20), v2, (__int64)&v11);
    (*(void (__fastcall **)(__int64, _QWORD, int *))v3)(a1 + *(int *)(v3 + 8), *(_QWORD *)(a1 + 0x28), &v11);
    v11 = 0;
    sub_14035C4A0(&v11, 0xD3);
    do
    {
      result = (_DWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD, int *))v3)(
                           a1 + *(int *)(v3 + 8),
                           *(_QWORD *)(a1 + 0x28),
                           &v11);
      v3 = *(_QWORD *)(v3 + 0x20);
    }
    while ( v3 != v2 );
  }
  return result;
}

// --- End Function: sub_145EE0B00 (0x145EE0B00) ---

// --- Function: sub_145F26EB0 (0x145F26EB0) ---
void __fastcall sub_145F26EB0(__crt_win32_buffer_debug_info *a1, int a2, float *a3, int a4, int a5, __int64 a6)
{
  bool v8; // [rsp+41h] [rbp-127h]
  unsigned __int64 *v9; // [rsp+48h] [rbp-120h]
  int v10; // [rsp+54h] [rbp-114h] BYREF
  float v11; // [rsp+58h] [rbp-110h]
  unsigned __int64 v12; // [rsp+60h] [rbp-108h]
  __int64 v13; // [rsp+68h] [rbp-100h] BYREF
  __int64 v14; // [rsp+70h] [rbp-F8h]
  __int64 v15; // [rsp+78h] [rbp-F0h]
  __int64 v16; // [rsp+80h] [rbp-E8h] BYREF
  __int64 v17; // [rsp+88h] [rbp-E0h]
  __int64 v18; // [rsp+90h] [rbp-D8h]
  void (__fastcall *v19)(unsigned __int64, __int64 *); // [rsp+98h] [rbp-D0h]
  __int64 (__fastcall *v20)(__int64, _QWORD); // [rsp+A0h] [rbp-C8h]
  _QWORD *v21; // [rsp+A8h] [rbp-C0h]
  _QWORD *v22; // [rsp+B0h] [rbp-B8h]
  __int64 v23; // [rsp+B8h] [rbp-B0h]
  __int64 (__fastcall *v24)(__int64, _QWORD); // [rsp+C0h] [rbp-A8h]
  __int64 v25; // [rsp+C8h] [rbp-A0h] BYREF
  _QWORD v26[16]; // [rsp+D0h] [rbp-98h] BYREF

  v9 = (unsigned __int64 *)__crt_win32_buffer_debug_info::file_name(a1);
  (*(void (__fastcall **)(unsigned __int64 *))(*v9 + 0x650))(v9);
  if ( !*(_BYTE *)(a6 + 0x28) )
  {
    if ( *(_DWORD *)(a6 + 0x34) == 0xFFFFFFFF )
    {
      sub_1419732D0((__int64)v26);
      v10 = 0xFFFFFFFF;
      if ( sub_145F072E0((__int64)v9, a2, a3, a4, a5, (__int64)v26, &v10) )
        sub_141A63B10(a6 + 0x30, (__int64)v26);
      if ( *(_DWORD *)(a6 + 0x34) == 0xFFFFFFFF )
        *(_BYTE *)(a6 + 0x28) = 1;
      if ( (unsigned int)sub_145F0D1E0((__int64)v9) )
      {
        if ( (unsigned int)sub_145F0D1E0((__int64)v9) == 1 )
          *(_DWORD *)(a6 + 0xA8) = sub_145F23210((__int64)v9, a6 + 0x30);
      }
      else
      {
        v12 = sub_1403E6750(v9 + 1);
        v19 = *(void (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v12 + 0x3B8LL);
        v19(v12, &v13);
        v8 = 0;
        if ( HIWORD_w(&v13) )
        {
          v14 = sub_14030ECF0(&v13);
          if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v14 + 8LL))(v14) == 6 )
            v8 = 1;
        }
        if ( sub_145843D20((__int64)a1) || sub_145843D30((__int64)a1) || v8 )
          *(_BYTE *)(a6 + 0x28) = 1;
      }
      sub_145822E10(
        (__int64)a1,
        (_QWORD *)a6,
        "CSCActorControlStateDead::RemoteClientPlayHitReaction: ragdoll due to no death animation");
      sub_141976650(v26);
    }
    else if ( !(unsigned int)sub_145F0D1E0((__int64)v9) )
    {
      v15 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
      v20 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v15 + 0x38LL);
      v21 = (_QWORD *)v20(v15, 0);
      v22 = sub_1405975C0(v21, &v25, (_QWORD *)(a6 + 8));
      _XMM0 = sub_140597760();
      __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
      v11 = *(float *)&_XMM0;
      sub_1457B7B60((__int64)v9, &v16);
      if ( is_valid_handle_typeA(&v16) )
      {
        v23 = v16 & 0xFFFFFFFFFFFFLL;
        v17 = *(_QWORD *)((v16 & 0xFFFFFFFFFFFFLL) + 0x5A0);
        if ( v17 )
        {
          if ( v11 > *(float *)(v17 + 0x18) )
          {
            v18 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
            v24 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v18 + 0x38LL);
            *(_QWORD *)(a6 + 8) = *(_QWORD *)v24(v18, 0);
            *(_BYTE *)(a6 + 0x28) = 1;
            sub_145822E10(
              (__int64)a1,
              (_QWORD *)a6,
              "CSCActorControlStateDead::RemoteClientPlayHitReaction: ragdoll as shot during death animation");
          }
        }
      }
    }
  }
}

// --- End Function: sub_145F26EB0 (0x145F26EB0) ---

// --- Function: sub_145F272E0 (0x145F272E0) ---
void __fastcall sub_145F272E0(__crt_win32_buffer_debug_info *a1, int a2, float *a3, int a4, int a5, __int64 *a6)
{
  __int64 v6; // rax
  bool v9; // [rsp+41h] [rbp-1A7h]
  unsigned __int64 *v10; // [rsp+48h] [rbp-1A0h]
  int v11; // [rsp+50h] [rbp-198h] BYREF
  float v12; // [rsp+54h] [rbp-194h]
  unsigned __int64 v13; // [rsp+58h] [rbp-190h]
  __int64 v14; // [rsp+60h] [rbp-188h] BYREF
  __int64 v15; // [rsp+68h] [rbp-180h]
  __int64 v16; // [rsp+70h] [rbp-178h]
  __int64 v17; // [rsp+78h] [rbp-170h] BYREF
  __int64 v18; // [rsp+80h] [rbp-168h]
  __int64 v19; // [rsp+88h] [rbp-160h]
  void (__fastcall *v20)(unsigned __int64, __int64 *); // [rsp+90h] [rbp-158h]
  __int64 (__fastcall *v21)(__int64, _QWORD); // [rsp+98h] [rbp-150h]
  _QWORD *v22; // [rsp+A0h] [rbp-148h]
  _QWORD *v23; // [rsp+A8h] [rbp-140h]
  __int64 v24; // [rsp+B0h] [rbp-138h]
  __int64 (__fastcall *v25)(__int64, _QWORD); // [rsp+B8h] [rbp-130h]
  __int64 v26; // [rsp+C0h] [rbp-128h] BYREF
  _QWORD v27[16]; // [rsp+D0h] [rbp-118h] BYREF
  _QWORD v28[16]; // [rsp+150h] [rbp-98h] BYREF

  v10 = (unsigned __int64 *)__crt_win32_buffer_debug_info::file_name(a1);
  (*(void (__fastcall **)(unsigned __int64 *))(*v10 + 0x650))(v10);
  if ( !*((_BYTE *)a6 + 0xA0) )
  {
    if ( *((_DWORD *)a6 + 0xB) == 0xFFFFFFFF )
    {
      sub_1419732D0((__int64)v27);
      v11 = 0xFFFFFFFF;
      if ( sub_145F072E0((__int64)v10, a2, a3, a4, a5, (__int64)v27, &v11) )
        sub_141A63B10((__int64)(a6 + 5), (__int64)v27);
      if ( *((_DWORD *)a6 + 0xB) == 0xFFFFFFFF )
        *((_BYTE *)a6 + 0xA0) = 1;
      v13 = sub_1403E6750(v10 + 1);
      v20 = *(void (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v13 + 0x3B8LL);
      v20(v13, &v14);
      v9 = 0;
      if ( HIWORD_w(&v14) )
      {
        v15 = sub_14030ECF0(&v14);
        if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v15 + 8LL))(v15) == 6 )
          v9 = 1;
      }
      if ( sub_145843D20((__int64)a1) || sub_145843D30((__int64)a1) || v9 )
      {
        *((_BYTE *)a6 + 0xA0) = 1;
        v6 = sub_1419732D0((__int64)v28);
        sub_141977320((__int64)(a6 + 5), v6);
        sub_141976650(v28);
      }
      sub_145EC6580(
        (__int64)a1,
        a6,
        "CSCActorControlStateDownedEnter::RemoteClientPlayHitReaction: ragdoll due to no death animation");
      sub_141976650(v27);
    }
    else
    {
      v16 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
      v21 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 0x38LL);
      v22 = (_QWORD *)v21(v16, 0);
      v23 = sub_1405975C0(v22, &v26, a6 + 1);
      _XMM0 = sub_140597760();
      __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
      v12 = *(float *)&_XMM0;
      sub_1457B7B60((__int64)v10, &v17);
      if ( is_valid_handle_typeA(&v17) )
      {
        v24 = v17 & 0xFFFFFFFFFFFFLL;
        v18 = *(_QWORD *)((v17 & 0xFFFFFFFFFFFFLL) + 0x5A0);
        if ( v18 )
        {
          if ( v12 > *(float *)(v18 + 0x18) )
          {
            v19 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
            v25 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v19 + 0x38LL);
            a6[1] = *(_QWORD *)v25(v19, 0);
            *((_BYTE *)a6 + 0xA0) = 1;
            sub_145EC6580(
              (__int64)a1,
              a6,
              "CSCActorControlStateDownedEnter::RemoteClientPlayHitReaction: ragdoll as shot during death animation");
          }
        }
      }
    }
  }
}

// --- End Function: sub_145F272E0 (0x145F272E0) ---

// --- Function: sub_145F44D30 (0x145F44D30) ---
_QWORD *__fastcall sub_145F44D30(__int64 a1, _QWORD *a2)
{
  int v4; // edi
  unsigned __int32 v5; // eax
  int v6; // eax
  __int64 v7; // rbp
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rcx
  __int64 v11; // rdi
  __int64 v12; // rdi
  bool v13; // al
  __int64 v14; // rdi
  __int64 (__fastcall *v15)(__int64, _BYTE *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v17; // rdi
  __int64 v18; // rax
  __int16 n4; // dx
  int v20; // eax
  unsigned __int32 v21; // eax
  __int64 v23; // [rsp+20h] [rbp-48h] BYREF
  _BYTE v24[64]; // [rsp+28h] [rbp-40h] BYREF
  __int16 n0xFFFF_1; // [rsp+70h] [rbp+8h] BYREF
  char v26; // [rsp+80h] [rbp+18h] BYREF
  unsigned __int64 v27; // [rsp+88h] [rbp+20h] BYREF

  v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x60) == v4 )
  {
    ++*(_DWORD *)(a1 + 0x64);
  }
  else
  {
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x50), 1, 0);
    if ( v5 )
      sub_1403C33A0(a1 + 0x50, v5, "CSCActorInventory::GetLastAddedItem", 1);
    else
      *(_QWORD *)(a1 + 0x58) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(a1 + 0x60) = v4;
  }
  v6 = ((__int64)(*(_QWORD *)(a1 + 0x40) - *(_QWORD *)(a1 + 0x38)) >> 3) - 1;
  v7 = v6;
  if ( v6 < 0 )
  {
LABEL_28:
    v20 = *(_DWORD *)(a1 + 0x64);
    *a2 = 0;
    if ( v20 )
    {
LABEL_31:
      *(_DWORD *)(a1 + 0x64) = v20 - 1;
      return a2;
    }
  }
  else
  {
    while ( 1 )
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 0x38) + 8 * v7);
      v27 = v8;
      if ( v8 )
      {
        v9 = v8;
        v10 = HIWORD(v8);
        v11 = v9 & 0xFFFFFFFFFFFFLL;
        v12 = (v10 & 0xF000) != 0 ? v11 & 0xFFFFFF000000LL : v11 - 6;
        if ( *(_WORD *)(v12 + 2) == (v10 & 0xFFF) )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v13 = sub_140539D80()) )
            v13 = 1;
          if ( *(_WORD *)(v12 + 4) == 2 && v13 || sub_140392020(&v27) )
          {
            v14 = v27 & 0xFFFFFFFFFFFFLL;
            v15 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)(v27 & 0xFFFFFFFFFFFFLL) + 0x340LL);
            n0xFFFF = n0xFFFF_74;
            if ( n0xFFFF_74 == (__int16)0xFFFF )
            {
              n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                           + 0x10LL))(
                                    qword_149B4FC88,
                                    &v26,
                                    "SCItemSuitThrusterPack");
              n0xFFFF_74 = n0xFFFF;
            }
            n0xFFFF_1 = n0xFFFF;
            v17 = *(_QWORD *)v15(v14, v24, &n0xFFFF_1);
            v23 = v17;
            if ( v17 )
            {
              v18 = sub_1403B4B50(v17 & 0xFFFFFFFFFFFFLL);
              n4 = *(_WORD *)(v18 + 4);
              if ( n4 != 4
                && *(_WORD *)(v18 + 2) == (HIWORD(v17) & 0xFFF)
                && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v23)) )
              {
                break;
              }
            }
          }
        }
      }
      if ( --v7 < 0 )
        goto LABEL_28;
    }
    v20 = *(_DWORD *)(a1 + 0x64);
    *a2 = v17;
    if ( v20 )
      goto LABEL_31;
  }
  *(_DWORD *)(a1 + 0x60) = 0xFFFFFFFF;
  v21 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x50), 0, 1);
  if ( v21 == 1 )
    *(_QWORD *)(a1 + 0x58) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    sub_1403DB1F0(a1 + 0x50, v21);
  return a2;
}

// --- End Function: sub_145F44D30 (0x145F44D30) ---

// --- Function: sub_145F4DD20 (0x145F4DD20) ---
_QWORD *__fastcall sub_145F4DD20(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 0x38);
  if ( v2 )
  {
    sub_145CE13C0(v2, a2, 2u);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_145F4DD20 (0x145F4DD20) ---

// --- Function: sub_145F4E9C0 (0x145F4E9C0) ---
_QWORD *__fastcall sub_145F4E9C0(__int64 a1, _QWORD *a2, unsigned int n2)
{
  bool v5; // al
  __int64 n0x108; // r8

  if ( n2 == 2 )
  {
    v5 = sub_14030EC00((unsigned __int64 *)(a1 + 0x108));
    n0x108 = 0x108;
    if ( !v5 )
      n0x108 = 0xD8;
    *a2 = *(_QWORD *)(n0x108 + a1);
    return a2;
  }
  else
  {
    *a2 = *(_QWORD *)(a1 + 0x30LL * n2 + 0xD8);
    return a2;
  }
}

// --- End Function: sub_145F4E9C0 (0x145F4E9C0) ---

// --- Function: sub_145F4F9E0 (0x145F4F9E0) ---
_QWORD *__fastcall sub_145F4F9E0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 0x38);
  if ( v2 )
  {
    sub_145F44D30(v2, a2);
    return a2;
  }
  else
  {
    *a2 = 0;
    return a2;
  }
}

// --- End Function: sub_145F4F9E0 (0x145F4F9E0) ---

// --- Function: sub_145F95D90 (0x145F95D90) ---
__int64 __fastcall sub_145F95D90(__int64 a1, __int64 a2)
{
  return 0x270 * a2 + a1;
}

// --- End Function: sub_145F95D90 (0x145F95D90) ---

// --- Function: sub_145F95DB0 (0x145F95DB0) ---
__int64 __fastcall sub_145F95DB0(__int64 a1, int a2)
{
  return sub_145F95D90(*(_QWORD *)a1, (a2 + *(_DWORD *)(a1 + 8)) % 0xAu);
}

// --- End Function: sub_145F95DB0 (0x145F95DB0) ---

// --- Function: sub_14601F8F0 (0x14601F8F0) ---
__int64 __fastcall sub_14601F8F0(__int64 a1)
{
  return sub_145F95D90(*(_QWORD *)a1, *(unsigned int *)(a1 + 0xC));
}

// --- End Function: sub_14601F8F0 (0x14601F8F0) ---

// --- Function: sub_14601FAD0 (0x14601FAD0) ---
__int64 __fastcall sub_14601FAD0(__int64 a1)
{
  return sub_145F95D90(*(_QWORD *)a1, *(unsigned int *)(a1 + 8));
}

// --- End Function: sub_14601FAD0 (0x14601FAD0) ---

// --- Function: sub_146054F00 (0x146054F00) ---
__int64 __fastcall sub_146054F00(__int64 a1)
{
  unsigned int v1; // r8d
  unsigned int v2; // edx
  __int64 result; // rax

  v1 = *(_DWORD *)(a1 + 0xC);
  v2 = *(_DWORD *)(a1 + 8);
  result = v1 - v2 + 0xB;
  if ( v1 >= v2 )
    return v1 - v2 + 1;
  return result;
}

// --- End Function: sub_146054F00 (0x146054F00) ---

// --- Function: sub_1461A3C20 (0x1461A3C20) ---
void __fastcall sub_1461A3C20(__int64 a1)
{
  double v1; // xmm0_8
  __int64 v2; // rax
  float v4; // [rsp+20h] [rbp-378h]
  float X; // [rsp+24h] [rbp-374h]
  float *AttachmentOffsetVec3; // [rsp+28h] [rbp-370h]
  float *v7; // [rsp+30h] [rbp-368h]
  float dst_[4]; // [rsp+58h] [rbp-340h] BYREF
  float v9; // [rsp+68h] [rbp-330h]
  float v10; // [rsp+6Ch] [rbp-32Ch]
  float v11; // [rsp+70h] [rbp-328h]
  float v12; // [rsp+74h] [rbp-324h]
  float Y; // [rsp+78h] [rbp-320h]
  float v14; // [rsp+80h] [rbp-318h]
  float v15; // [rsp+84h] [rbp-314h]
  float v16; // [rsp+88h] [rbp-310h]
  float v17; // [rsp+8Ch] [rbp-30Ch]
  float v18; // [rsp+90h] [rbp-308h] BYREF
  float v19; // [rsp+94h] [rbp-304h]
  float v20; // [rsp+98h] [rbp-300h]
  float v21; // [rsp+9Ch] [rbp-2FCh]
  float v22; // [rsp+A0h] [rbp-2F8h]
  float v23; // [rsp+A4h] [rbp-2F4h]
  float v24; // [rsp+A8h] [rbp-2F0h]
  float v25; // [rsp+B0h] [rbp-2E8h]
  float v26; // [rsp+B4h] [rbp-2E4h]
  float v27; // [rsp+B8h] [rbp-2E0h]
  float v28; // [rsp+BCh] [rbp-2DCh]
  float v29; // [rsp+C0h] [rbp-2D8h]
  float v30; // [rsp+C4h] [rbp-2D4h]
  float v31; // [rsp+C8h] [rbp-2D0h]
  float v32; // [rsp+CCh] [rbp-2CCh]
  float v33; // [rsp+D0h] [rbp-2C8h] BYREF
  float v34; // [rsp+D4h] [rbp-2C4h]
  float v35; // [rsp+D8h] [rbp-2C0h]
  float v36; // [rsp+DCh] [rbp-2BCh]
  char v37; // [rsp+E0h] [rbp-2B8h]
  char v38; // [rsp+E1h] [rbp-2B7h]
  float v39; // [rsp+E4h] [rbp-2B4h]
  float v40; // [rsp+E8h] [rbp-2B0h]
  float v41; // [rsp+ECh] [rbp-2ACh]
  float v42; // [rsp+F0h] [rbp-2A8h]
  float v43; // [rsp+F4h] [rbp-2A4h]
  float v44; // [rsp+F8h] [rbp-2A0h]
  float X_1; // [rsp+100h] [rbp-298h]
  __int64 v46; // [rsp+108h] [rbp-290h]
  float *v47; // [rsp+110h] [rbp-288h]
  float *v48; // [rsp+118h] [rbp-280h]
  float *v49; // [rsp+120h] [rbp-278h]
  unsigned int v50; // [rsp+128h] [rbp-270h]
  unsigned int v51; // [rsp+130h] [rbp-268h]
  unsigned int v52; // [rsp+138h] [rbp-260h]
  unsigned int v53; // [rsp+140h] [rbp-258h]
  unsigned int v54; // [rsp+148h] [rbp-250h]
  unsigned int v55; // [rsp+150h] [rbp-248h]
  float v56; // [rsp+154h] [rbp-244h]
  float v57; // [rsp+158h] [rbp-240h]
  float v58; // [rsp+160h] [rbp-238h]
  float v59; // [rsp+168h] [rbp-230h]
  float v60; // [rsp+170h] [rbp-228h]
  float v61; // [rsp+178h] [rbp-220h]
  float v62; // [rsp+180h] [rbp-218h]
  float v63; // [rsp+188h] [rbp-210h]
  float v64; // [rsp+190h] [rbp-208h]
  unsigned int v65; // [rsp+198h] [rbp-200h]
  float v66; // [rsp+1A0h] [rbp-1F8h]
  float v67; // [rsp+1A8h] [rbp-1F0h]
  float v68; // [rsp+1B0h] [rbp-1E8h]
  float v69; // [rsp+1B8h] [rbp-1E0h]
  float v70; // [rsp+1C0h] [rbp-1D8h]
  float v71; // [rsp+1C8h] [rbp-1D0h]
  float v72; // [rsp+1D0h] [rbp-1C8h]
  float v73; // [rsp+1D8h] [rbp-1C0h]
  float v74; // [rsp+1E0h] [rbp-1B8h]
  __int64 v75; // [rsp+1E8h] [rbp-1B0h]
  float *v76; // [rsp+1F0h] [rbp-1A8h]
  float *v77; // [rsp+1F8h] [rbp-1A0h]
  float v78; // [rsp+200h] [rbp-198h]
  float v79; // [rsp+204h] [rbp-194h]
  float v80; // [rsp+208h] [rbp-190h]
  float v81; // [rsp+20Ch] [rbp-18Ch]
  float v82; // [rsp+210h] [rbp-188h]
  float v83; // [rsp+218h] [rbp-180h]
  float v84; // [rsp+220h] [rbp-178h]
  float v85; // [rsp+228h] [rbp-170h]
  float v86; // [rsp+230h] [rbp-168h]
  float v87; // [rsp+238h] [rbp-160h]
  float v88; // [rsp+240h] [rbp-158h]
  unsigned int v89; // [rsp+248h] [rbp-150h]
  float v90; // [rsp+250h] [rbp-148h]
  float v91; // [rsp+254h] [rbp-144h]
  float v92; // [rsp+258h] [rbp-140h]
  float v93; // [rsp+25Ch] [rbp-13Ch]
  float v94; // [rsp+264h] [rbp-134h]
  float v95; // [rsp+268h] [rbp-130h]
  float v96; // [rsp+26Ch] [rbp-12Ch]
  _QWORD *v97; // [rsp+270h] [rbp-128h]
  __int64 v98; // [rsp+278h] [rbp-120h]
  __int64 v99; // [rsp+280h] [rbp-118h]
  __int64 v100; // [rsp+288h] [rbp-110h]
  float dst__1[4]; // [rsp+290h] [rbp-108h] BYREF
  float dst__2[4]; // [rsp+2A0h] [rbp-F8h] BYREF
  _DWORD src__2[3]; // [rsp+2B0h] [rbp-E8h] BYREF
  float src_[3]; // [rsp+2BCh] [rbp-DCh] BYREF
  _DWORD src__1[4]; // [rsp+2C8h] [rbp-D0h] BYREF
  __int64 v106; // [rsp+2D8h] [rbp-C0h]
  __int64 v107; // [rsp+2E0h] [rbp-B8h]
  float *src; // [rsp+2E8h] [rbp-B0h]
  _DWORD *src_1; // [rsp+2F0h] [rbp-A8h]
  _DWORD *src_2; // [rsp+2F8h] [rbp-A0h]
  __m128 v111; // [rsp+300h] [rbp-98h]
  __m128 v112; // [rsp+310h] [rbp-88h]
  __int128 v113; // [rsp+320h] [rbp-78h]
  __int128 v114; // [rsp+330h] [rbp-68h]
  float v115[4]; // [rsp+340h] [rbp-58h] BYREF
  float v116[4]; // [rsp+350h] [rbp-48h] BYREF
  __int128 v117; // [rsp+360h] [rbp-38h]

  v106 = *(_QWORD *)(a1 + 0x550) & 0xFFFFFFFFFFFFLL;
  v1 = sub_145A53600(v106);
  v4 = *(float *)&v1;
  if ( *(float *)&v1 < 0.99900001 )
  {
    v100 = *(_QWORD *)(a1 + 0x548) & 0xFFFFFFFFFFFFLL;
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v100 + 0x650LL))(v100) )
    {
      v107 = *(_QWORD *)(a1 + 0x548) & 0xFFFFFFFFFFFFLL;
      v2 = sub_1465EEBE0(v107);
      if ( !sub_145AD72E0(v2) )
      {
        v97 = (_QWORD *)(a1 + 0x548);
        if ( is_valid_handle_typeA((__int64 *)(a1 + 0x548)) )
          v98 = *v97 & 0xFFFFFFFFFFFFLL;
        else
          v98 = 0;
        v7 = sub_1461C16E0(a1, v115, v98);
        AttachmentOffsetVec3 = CEntityTemplate::GetAttachmentOffsetVec3((_QWORD *)a1, v116);
        v69 = (float)((float)((float)(*AttachmentOffsetVec3 * v7[1]) - (float)(AttachmentOffsetVec3[1] * *v7))
                    + (float)(AttachmentOffsetVec3[3] * v7[2]))
            + (float)(AttachmentOffsetVec3[2] * v7[3]);
        v68 = (float)((float)((float)(AttachmentOffsetVec3[2] * *v7) - (float)(*AttachmentOffsetVec3 * v7[2]))
                    + (float)(AttachmentOffsetVec3[3] * v7[1]))
            + (float)(AttachmentOffsetVec3[1] * v7[3]);
        v67 = (float)((float)((float)(AttachmentOffsetVec3[1] * v7[2]) - (float)(AttachmentOffsetVec3[2] * v7[1]))
                    + (float)(AttachmentOffsetVec3[3] * *v7))
            + (float)(*AttachmentOffsetVec3 * v7[3]);
        v66 = (float)(AttachmentOffsetVec3[3] * v7[3])
            - (float)((float)((float)(*AttachmentOffsetVec3 * *v7) + (float)(AttachmentOffsetVec3[1] * v7[1]))
                    + (float)(AttachmentOffsetVec3[2] * v7[2]));
        v81 = v66;
        v78 = v67;
        v79 = v68;
        v80 = v69;
        v37 = 0;
        v99 = a1 + 0xA8;
        v75 = a1 + 0xA8;
        LODWORD(v72) = *(_DWORD *)(a1 + 0xB0) ^ 0x80000000;
        LODWORD(v71) = *(_DWORD *)(a1 + 0xAC) ^ 0x80000000;
        LODWORD(v70) = *(_DWORD *)(a1 + 0xA8) ^ 0x80000000;
        src_[0] = v70;
        src_[1] = v71;
        src_[2] = v72;
        src = src_;
        v73 = *(float *)(a1 + 0xB4);
        qmemcpy(dst_, src_, 0xCu);
        dst_[3] = v73;
        v84 = (float)((float)((float)(dst_[0] * *(float *)(a1 + 0xBC)) - (float)(dst_[1] * *(float *)(a1 + 0xB8)))
                    + (float)(v73 * *(float *)(a1 + 0xC0)))
            + (float)(dst_[2] * *(float *)(a1 + 0xC4));
        v83 = (float)((float)((float)(dst_[2] * *(float *)(a1 + 0xB8)) - (float)(dst_[0] * *(float *)(a1 + 0xC0)))
                    + (float)(v73 * *(float *)(a1 + 0xBC)))
            + (float)(dst_[1] * *(float *)(a1 + 0xC4));
        v82 = (float)((float)((float)(dst_[1] * *(float *)(a1 + 0xC0)) - (float)(dst_[2] * *(float *)(a1 + 0xBC)))
                    + (float)(v73 * *(float *)(a1 + 0xB8)))
            + (float)(dst_[0] * *(float *)(a1 + 0xC4));
        v74 = (float)(v73 * *(float *)(a1 + 0xC4))
            - (float)((float)((float)(dst_[0] * *(float *)(a1 + 0xB8)) + (float)(dst_[1] * *(float *)(a1 + 0xBC)))
                    + (float)(dst_[2] * *(float *)(a1 + 0xC0)));
        v28 = v74;
        v25 = v82;
        v26 = v83;
        v27 = v84;
        v88 = (float)((float)((float)(dst_[0] * *(float *)(a1 + 0x3A8)) - (float)(dst_[1] * *(float *)(a1 + 0x3A4)))
                    + (float)(v73 * *(float *)(a1 + 0x3AC)))
            + (float)(dst_[2] * *(float *)(a1 + 0x3B0));
        v87 = (float)((float)((float)(dst_[2] * *(float *)(a1 + 0x3A4)) - (float)(dst_[0] * *(float *)(a1 + 0x3AC)))
                    + (float)(v73 * *(float *)(a1 + 0x3A8)))
            + (float)(dst_[1] * *(float *)(a1 + 0x3B0));
        v86 = (float)((float)((float)(dst_[1] * *(float *)(a1 + 0x3AC)) - (float)(dst_[2] * *(float *)(a1 + 0x3A8)))
                    + (float)(v73 * *(float *)(a1 + 0x3A4)))
            + (float)(dst_[0] * *(float *)(a1 + 0x3B0));
        v85 = (float)(v73 * *(float *)(a1 + 0x3B0))
            - (float)((float)((float)(dst_[0] * *(float *)(a1 + 0x3A4)) + (float)(dst_[1] * *(float *)(a1 + 0x3A8)))
                    + (float)(dst_[2] * *(float *)(a1 + 0x3AC)));
        v32 = v85;
        v29 = v86;
        v30 = v87;
        v31 = v88;
        v46 = a1 + 0xA8;
        v38 = 0;
        v17 = v66;
        v14 = v67;
        v15 = v68;
        v16 = v69;
        v21 = *(float *)(a1 + 0xB4);
        v18 = *(float *)(a1 + 0xA8);
        v19 = *(float *)(a1 + 0xAC);
        v20 = *(float *)(a1 + 0xB0);
        X = (float)((float)((float)(v67 * v18) + (float)(v68 * v19)) + (float)(v69 * v20)) + (float)(v66 * v21);
        if ( X < 0.0 )
        {
          X = -(float)((float)((float)((float)(v67 * v18) + (float)(v68 * v19)) + (float)(v69 * v20))
                     + (float)(v66 * v21));
          v76 = &v18;
          v51 = LODWORD(v20) ^ 0x80000000;
          v50 = LODWORD(v19) ^ 0x80000000;
          v89 = LODWORD(v18) ^ 0x80000000;
          src__1[0] = LODWORD(v18) ^ 0x80000000;
          src__1[1] = LODWORD(v19) ^ 0x80000000;
          src__1[2] = LODWORD(v20) ^ 0x80000000;
          src_1 = src__1;
          v52 = LODWORD(v21) ^ 0x80000000;
          qmemcpy(dst__1, src__1, 0xCu);
          LODWORD(dst__1[3]) = LODWORD(v21) ^ 0x80000000;
          v18 = dst__1[0];
          v19 = dst__1[1];
          v20 = dst__1[2];
          LODWORD(v21) ^= 0x80000000;
        }
        if ( X <= 0.99989998 )
        {
          v43 = v21 - (float)(v17 * X);
          v40 = v18 - (float)(v14 * X);
          v41 = v19 - (float)(v15 * X);
          v42 = v20 - (float)(v16 * X);
          v56 = (float)((float)((float)(v40 * v40) + (float)(v41 * v41)) + (float)(v42 * v42)) + (float)(v43 * v43);
          LODWORD(Y) = sub_1403EAD10(COERCE_DOUBLE((unsigned __int64)LODWORD(v56))).m128_u32[0];
          X_1 = atan2f(Y, X) * v4;
          v24 = j_sinf(X_1);
          v23 = j_cosf(X_1);
          v12 = (float)(v17 * v23) + (float)((float)(v43 * v24) / Y);
          v9 = (float)(v14 * v23) + (float)((float)(v40 * v24) / Y);
          v10 = (float)(v15 * v23) + (float)((float)(v41 * v24) / Y);
          v11 = (float)(v16 * v23) + (float)((float)(v42 * v24) / Y);
        }
        else
        {
          v36 = v21;
          v33 = v18;
          v34 = v19;
          v35 = v20;
          if ( (float)((float)((float)((float)(v14 * v18) + (float)(v15 * v19)) + (float)(v16 * v20))
                     + (float)(v17 * v21)) < 0.0 )
          {
            v77 = &v33;
            v65 = LODWORD(v35) ^ 0x80000000;
            v54 = LODWORD(v34) ^ 0x80000000;
            v53 = LODWORD(v33) ^ 0x80000000;
            src__2[0] = LODWORD(v33) ^ 0x80000000;
            src__2[1] = LODWORD(v34) ^ 0x80000000;
            src__2[2] = LODWORD(v35) ^ 0x80000000;
            src_2 = src__2;
            v55 = LODWORD(v36) ^ 0x80000000;
            qmemcpy(dst__2, src__2, 0xCu);
            LODWORD(dst__2[3]) = LODWORD(v36) ^ 0x80000000;
            v33 = dst__2[0];
            v34 = dst__2[1];
            v35 = dst__2[2];
            LODWORD(v36) ^= 0x80000000;
          }
          v9 = (float)(v14 * (float)(1.0 - *(float *)&v1)) + (float)(v33 * *(float *)&v1);
          v10 = (float)(v15 * (float)(1.0 - *(float *)&v1)) + (float)(v34 * *(float *)&v1);
          v11 = (float)(v16 * (float)(1.0 - *(float *)&v1)) + (float)(v35 * *(float *)&v1);
          v12 = (float)(v17 * (float)(1.0 - *(float *)&v1)) + (float)(v36 * *(float *)&v1);
          v44 = (float)((float)((float)(v12 * v12) + (float)(v9 * v9)) + (float)(v10 * v10)) + (float)(v11 * v11);
          v111 = _mm_shuffle_ps((__m128)LODWORD(v44), (__m128)LODWORD(v44), 0);
          v112 = v111;
          __asm { vrsqrtps xmm0, [rsp+398h+var_88] }
          v113 = _XMM0;
          v114 = _XMM0;
          v117 = _XMM0;
          v39 = *((float *)&_XMM0 + 3);
          v22 = *((float *)&_XMM0 + 3)
              * (float)(1.5 - (float)((float)((float)(v44 * *((float *)&_XMM0 + 3)) * *((float *)&_XMM0 + 3)) * 0.5));
          v12 = (float)((float)(v17 * (float)(1.0 - v4)) + (float)(v36 * v4)) * v22;
          v9 = (float)((float)(v14 * (float)(1.0 - v4)) + (float)(v33 * v4)) * v22;
          v10 = (float)((float)(v15 * (float)(1.0 - v4)) + (float)(v34 * v4)) * v22;
          v11 = v11 * v22;
        }
        v47 = (float *)(a1 + 0xA8);
        *(float *)(a1 + 0xA8) = v9;
        v47[1] = v10;
        v47[2] = v11;
        v47[3] = v12;
        v60 = (float)((float)((float)(*(float *)(a1 + 0xA8) * v26) - (float)(*(float *)(a1 + 0xAC) * v25))
                    + (float)(*(float *)(a1 + 0xB4) * v27))
            + (float)(*(float *)(a1 + 0xB0) * v28);
        v59 = (float)((float)((float)(*(float *)(a1 + 0xB0) * v25) - (float)(*(float *)(a1 + 0xA8) * v27))
                    + (float)(*(float *)(a1 + 0xB4) * v26))
            + (float)(*(float *)(a1 + 0xAC) * v28);
        v58 = (float)((float)((float)(*(float *)(a1 + 0xAC) * v27) - (float)(*(float *)(a1 + 0xB0) * v26))
                    + (float)(*(float *)(a1 + 0xB4) * v25))
            + (float)(*(float *)(a1 + 0xA8) * v28);
        v57 = (float)(*(float *)(a1 + 0xB4) * v28)
            - (float)((float)((float)(*(float *)(a1 + 0xA8) * v25) + (float)(*(float *)(a1 + 0xAC) * v26))
                    + (float)(*(float *)(a1 + 0xB0) * v27));
        v93 = v57;
        v90 = v58;
        v91 = v59;
        v92 = v60;
        v48 = (float *)(a1 + 0xB8);
        *(float *)(a1 + 0xB8) = v58;
        v48[1] = v91;
        v48[2] = v92;
        v48[3] = v93;
        v64 = (float)((float)((float)(*(float *)(a1 + 0xA8) * v30) - (float)(*(float *)(a1 + 0xAC) * v29))
                    + (float)(*(float *)(a1 + 0xB4) * v31))
            + (float)(*(float *)(a1 + 0xB0) * v32);
        v63 = (float)((float)((float)(*(float *)(a1 + 0xB0) * v29) - (float)(*(float *)(a1 + 0xA8) * v31))
                    + (float)(*(float *)(a1 + 0xB4) * v30))
            + (float)(*(float *)(a1 + 0xAC) * v32);
        v62 = (float)((float)((float)(*(float *)(a1 + 0xAC) * v31) - (float)(*(float *)(a1 + 0xB0) * v30))
                    + (float)(*(float *)(a1 + 0xB4) * v29))
            + (float)(*(float *)(a1 + 0xA8) * v32);
        v61 = (float)(*(float *)(a1 + 0xB4) * v32)
            - (float)((float)((float)(*(float *)(a1 + 0xA8) * v29) + (float)(*(float *)(a1 + 0xAC) * v30))
                    + (float)(*(float *)(a1 + 0xB0) * v31));
        v96 = v61;
        v94 = v63;
        v95 = v64;
        v49 = (float *)(a1 + 0x3A4);
        *(float *)(a1 + 0x3A4) = v62;
        v49[1] = v94;
        v49[2] = v95;
        v49[3] = v96;
      }
    }
  }
}

// --- End Function: sub_1461A3C20 (0x1461A3C20) ---

// --- Function: sub_1461B5580 (0x1461B5580) ---
float *__fastcall sub_1461B5580(float *dst, float *a2, __int64 a3)
{
  float Y; // xmm0_4
  float *src; // rax
  bool v5; // [rsp+23h] [rbp-105h]
  bool v6; // [rsp+24h] [rbp-104h]
  float v7; // [rsp+28h] [rbp-100h]
  float v8; // [rsp+40h] [rbp-E8h]
  float v9; // [rsp+48h] [rbp-E0h]
  unsigned int v10; // [rsp+50h] [rbp-D8h]
  float v11; // [rsp+68h] [rbp-C0h]
  float v12; // [rsp+70h] [rbp-B8h]
  float src_[3]; // [rsp+78h] [rbp-B0h] BYREF
  float src__1[3]; // [rsp+84h] [rbp-A4h] BYREF
  float *v15; // [rsp+90h] [rbp-98h]
  float *dst_1; // [rsp+98h] [rbp-90h]
  float *v17; // [rsp+A0h] [rbp-88h]
  __m128 v18; // [rsp+B0h] [rbp-78h]
  __m128 v19; // [rsp+C0h] [rbp-68h]
  __m128 v20; // [rsp+D0h] [rbp-58h]
  __m128 v21; // [rsp+E0h] [rbp-48h]
  __m128 v22; // [rsp+F0h] [rbp-38h]

  v9 = dst[2] - a2[2];
  v8 = dst[1] - a2[1];
  src_[0] = *dst - *a2;
  src_[1] = v8;
  src_[2] = v9;
  qmemcpy(dst, src_, 0xCu);
  v5 = !fabs_w_14(a3);
  v6 = !fabs_w_13(a3);
  if ( !fabs_w_16(a3) )
  {
    v15 = dst + 2;
    dst[2] = *sub_140508E90(dst + 2, (float *)(a3 + 0x18), (float *)(a3 + 0x1C));
  }
  if ( *(_BYTE *)(a3 + 0x20) && v5 && v6 )
  {
    Y = dst[1];
    sub_1461B6F10(Y, *dst, (float *)a3);
    *(float *)&v10 = (float)(*dst * *dst) + (float)(dst[1] * dst[1]);
    v18 = _mm_shuffle_ps((__m128)v10, (__m128)v10, 0);
    v19 = v18;
    v20 = _mm_sqrt_ps(v18);
    v21 = v20;
    v22 = v20;
    v7 = v20.m128_f32[3];
    if ( v20.m128_f32[3] > Y && v20.m128_f32[3] > 0.0 )
    {
      dst[1] = dst[1] * (float)(Y / v20.m128_f32[3]);
      *dst = *dst * (float)(Y / v7);
    }
  }
  else
  {
    if ( v5 )
    {
      dst_1 = dst;
      *dst = *sub_140508E90(dst, (float *)(a3 + 8), (float *)(a3 + 0xC));
    }
    if ( v6 )
    {
      v17 = dst + 1;
      dst[1] = *sub_140508E90(dst + 1, (float *)(a3 + 0x10), (float *)(a3 + 0x14));
    }
  }
  v12 = dst[2] + a2[2];
  v11 = dst[1] + a2[1];
  src__1[0] = *dst + *a2;
  src__1[1] = v11;
  src__1[2] = v12;
  src = src__1;
  qmemcpy(dst, src__1, 0xCu);
  return src;
}

// --- End Function: sub_1461B5580 (0x1461B5580) ---

// --- Function: sub_1461B6F10 (0x1461B6F10) ---
void __fastcall sub_1461B6F10(float Y, float X, float *a3)
{
  double v3; // kr00_8
  float v4; // [rsp+28h] [rbp-30h]
  float v5; // [rsp+2Ch] [rbp-2Ch]
  float v6; // [rsp+30h] [rbp-28h]
  float X_1; // [rsp+38h] [rbp-20h]

  if ( Y < 0.0 )
    v4 = a3[4];
  else
    v4 = a3[5];
  if ( X < 0.0 )
    v5 = a3[2];
  else
    v5 = a3[3];
  X_1 = atan2f(Y, X);
  v6 = j_cosf(X_1);
  *(_QWORD *)&v3 = COERCE_UNSIGNED_INT(v5 * v5);
  *(float *)&v3 = (float)((float)(v5 * v5) * (float)(v6 * v6))
                + (float)((float)(v4 * v4) * (float)(1.0 - (float)(v6 * v6)));
  sub_1403EAD10(v3);
}

// --- End Function: sub_1461B6F10 (0x1461B6F10) ---

// --- Function: sub_1461C16E0 (0x1461C16E0) ---
float *__fastcall sub_1461C16E0(__int64 a1, float *a2, __int64 a3)
{
  float v4; // xmm0_4
  float v5; // [rsp+24h] [rbp-E4h]
  float v6; // [rsp+28h] [rbp-E0h]
  float v7; // [rsp+2Ch] [rbp-DCh]
  float v8; // [rsp+30h] [rbp-D8h]
  float v9; // [rsp+34h] [rbp-D4h]
  float X; // [rsp+40h] [rbp-C8h]
  float X_1; // [rsp+48h] [rbp-C0h]
  float X_2; // [rsp+50h] [rbp-B8h]
  float *v14; // [rsp+58h] [rbp-B0h]
  float v15; // [rsp+60h] [rbp-A8h] BYREF
  float v16; // [rsp+64h] [rbp-A4h]
  float v17; // [rsp+68h] [rbp-A0h]
  float v18; // [rsp+70h] [rbp-98h] BYREF
  float v19; // [rsp+74h] [rbp-94h]
  float v20; // [rsp+78h] [rbp-90h]
  float v21; // [rsp+7Ch] [rbp-8Ch]
  float v22; // [rsp+80h] [rbp-88h]
  float v23; // [rsp+88h] [rbp-80h]
  float v24; // [rsp+90h] [rbp-78h]
  __int64 v25; // [rsp+98h] [rbp-70h]
  float v26; // [rsp+A0h] [rbp-68h]
  float v27; // [rsp+A4h] [rbp-64h]
  float v28; // [rsp+A8h] [rbp-60h]
  __int64 v29; // [rsp+B0h] [rbp-58h]
  float v30; // [rsp+B8h] [rbp-50h] BYREF
  float v31; // [rsp+BCh] [rbp-4Ch]
  float v32; // [rsp+C0h] [rbp-48h]
  __int64 (__fastcall *v33)(__int64, _BYTE *, _QWORD); // [rsp+C8h] [rbp-40h]
  void (__fastcall *v34)(__int64, float *); // [rsp+D0h] [rbp-38h]
  _BYTE v35[48]; // [rsp+D8h] [rbp-30h] BYREF

  v29 = *(_QWORD *)(a1 + 0x548) & 0xFFFFFFFFFFFFLL;
  v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x768LL))(v29);
  if ( v25 )
  {
    v33 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)a3 + 0x5D8LL);
    v14 = (float *)v33(a3, v35, 0);
    v21 = v14[3];
    v18 = *v14;
    v19 = v14[1];
    v20 = v14[2];
    v34 = *(void (__fastcall **)(__int64, float *))(*(_QWORD *)v25 + 0x1D8LL);
    v34(v25, &v15);
    if ( v15 == 0.0 && v16 == 0.0 && v17 == 0.0 )
    {
      a2[3] = v21;
      *a2 = v18;
      a2[1] = v19;
      a2[2] = v20;
    }
    else
    {
      sub_141D73D00((__int64)&v30, (__int64)&v18);
      v24 = v32 - v17;
      v23 = v31 - v16;
      v22 = v30 - v15;
      v26 = v30 - v15;
      v27 = v31 - v16;
      v28 = v32 - v17;
      X = (float)(v31 - v16) * 0.5;
      v5 = j_sinf(X);
      v8 = j_cosf(X);
      X_1 = v28 * 0.5;
      v6 = j_sinf(v28 * 0.5);
      v9 = j_cosf(X_1);
      X_2 = v26 * 0.5;
      v7 = j_sinf(v26 * 0.5);
      v4 = j_cosf(X_2);
      a2[3] = (float)((float)(v4 * v8) * v9) - (float)((float)(v7 * v5) * v6);
      *a2 = (float)((float)(v4 * v5) * v9) - (float)((float)(v7 * v8) * v6);
      a2[1] = (float)((float)(v4 * v8) * v6) + (float)((float)(v7 * v5) * v9);
      a2[2] = (float)((float)(v4 * v5) * v6) + (float)((float)(v7 * v8) * v9);
    }
    return a2;
  }
  else
  {
    a2[3] = 0x3F800000;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return a2;
  }
}

// --- End Function: sub_1461C16E0 (0x1461C16E0) ---

// --- Function: sub_1461C4930 (0x1461C4930) ---
float *__fastcall sub_1461C4930(_QWORD *a1, float *a2, char a3)
{
  _QWORD *v3; // rax
  __int64 v4; // r8
  float *v11; // [rsp+20h] [rbp-168h]
  double *v12; // [rsp+28h] [rbp-160h]
  float *v13; // [rsp+30h] [rbp-158h]
  float v14; // [rsp+38h] [rbp-150h]
  float v15; // [rsp+3Ch] [rbp-14Ch]
  float v16; // [rsp+44h] [rbp-144h]
  __int64 v17; // [rsp+48h] [rbp-140h]
  unsigned int v18; // [rsp+50h] [rbp-138h]
  __int64 v19; // [rsp+58h] [rbp-130h]
  __int64 v20; // [rsp+60h] [rbp-128h]
  float *v21; // [rsp+68h] [rbp-120h]
  float v22; // [rsp+80h] [rbp-108h]
  float v23; // [rsp+88h] [rbp-100h]
  float v24; // [rsp+90h] [rbp-F8h]
  _QWORD *v25; // [rsp+98h] [rbp-F0h]
  __int64 v26; // [rsp+A0h] [rbp-E8h] BYREF
  __int64 v27; // [rsp+A8h] [rbp-E0h]
  __int64 v28; // [rsp+B0h] [rbp-D8h]
  __int64 v29; // [rsp+B8h] [rbp-D0h]
  unsigned __int64 v30; // [rsp+C0h] [rbp-C8h]
  float *v31; // [rsp+C8h] [rbp-C0h]
  _QWORD *v32; // [rsp+D0h] [rbp-B8h]
  __int64 (__fastcall *v33)(__int64, _BYTE *); // [rsp+D8h] [rbp-B0h]
  _QWORD *v34; // [rsp+E0h] [rbp-A8h]
  __int64 (__fastcall *v35)(__int64, _QWORD); // [rsp+E8h] [rbp-A0h]
  __int64 (__fastcall *v36)(__int64, _QWORD); // [rsp+F0h] [rbp-98h]
  __int64 (__fastcall *v37)(unsigned __int64, _BYTE *, __int64); // [rsp+F8h] [rbp-90h]
  double v38; // [rsp+100h] [rbp-88h]
  double v39; // [rsp+108h] [rbp-80h]
  double v40; // [rsp+110h] [rbp-78h]
  double v41; // [rsp+118h] [rbp-70h]
  __int64 (__fastcall *v42)(__int64, _QWORD); // [rsp+120h] [rbp-68h]
  unsigned __int8 (__fastcall *v43)(__int64, __int64); // [rsp+128h] [rbp-60h]
  double v44; // [rsp+130h] [rbp-58h]
  double v45; // [rsp+138h] [rbp-50h]
  double v46; // [rsp+140h] [rbp-48h]
  double v47; // [rsp+148h] [rbp-40h]
  _BYTE v48[8]; // [rsp+150h] [rbp-38h] BYREF
  __int64 v49; // [rsp+158h] [rbp-30h] BYREF
  _BYTE v50[40]; // [rsp+160h] [rbp-28h] BYREF

  v32 = a1 + 0xAD;
  if ( AssetMeta::HasActorSubresource(a1 + 0xAD) )
    v17 = *v32 & 0xFFFFFFFFFFFFLL;
  else
    v17 = 0;
  if ( !v17 )
    goto LABEL_15;
  v43 = *(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)v17 + 0x5D0LL);
  if ( v43(v17, 2) )
  {
    v33 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v17 + 0x588LL);
    v25 = (_QWORD *)v33(v17, v48);
  }
  else
  {
    sub_1402B1640(&v49);
    v25 = v3;
  }
  v34 = v25;
  v26 = *v25;
  if ( HIWORD_w(&v26)
    && (v27 = sub_14030ECF0(&v26), (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v27 + 8LL))(v27) == 6)
    && (v28 = a1[0xA9] & 0xFFFFFFFFFFFFLL,
        (v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x768LL))(v28)) != 0) )
  {
    v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x68LL))(v19);
    v35 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v29 + 0x30LL);
    v18 = v35(v29, (unsigned int)dword_149E78770);
    v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x28LL))(v19);
    v36 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v20 + 0x158LL);
    v11 = (float *)v36(v20, 0);
    v30 = sub_1403E6750(a1 + 1);
    v37 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int64))(*(_QWORD *)v30 + 0x288LL);
    LOBYTE(v4) = 1;
    v12 = (double *)v37(v30, v50, v4);
    v41 = *v12 * v11[1] - v12[1] * *v11 + v12[3] * v11[2] + v12[2] * v11[3];
    v40 = v12[2] * *v11 - *v12 * v11[2] + v12[3] * v11[1] + v12[1] * v11[3];
    v39 = v12[1] * v11[2] - v12[2] * v11[1] + v12[3] * *v11 + *v12 * v11[3];
    v38 = v12[3] * v11[3] - (*v12 * *v11 + v12[1] * v11[1] + v12[2] * v11[2]);
    v47 = v38;
    v44 = v39;
    v45 = v40;
    _XMM0 = *(unsigned __int64 *)&v41;
    v46 = v41;
    __asm { vcvtsd2ss xmm0, xmm0, [rsp+188h+var_40] }
    v16 = *(float *)&_XMM0;
    __asm { vcvtsd2ss xmm0, xmm0, [rsp+188h+var_58] }
    v14 = *(float *)&_XMM0;
    __asm { vcvtsd2ss xmm0, xmm0, [rsp+188h+var_50] }
    v15 = *(float *)&_XMM0;
    __asm { vcvtsd2ss xmm0, xmm0, [rsp+188h+var_48] }
    if ( v18 == 0xFFFFFFFF )
    {
      a2[3] = v16;
      *a2 = v14;
      a2[1] = v15;
      a2[2] = *(float *)&_XMM0;
    }
    else
    {
      v42 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v20 + 0x150LL);
      v13 = (float *)v42(v20, v18);
      v24 = (float)((float)((float)(v14 * v13[1]) - (float)(v15 * *v13)) + (float)(v16 * v13[2]))
          + (float)(*(float *)&_XMM0 * v13[3]);
      v23 = (float)((float)((float)(*(float *)&_XMM0 * *v13) - (float)(v14 * v13[2])) + (float)(v16 * v13[1]))
          + (float)(v15 * v13[3]);
      v22 = (float)((float)((float)(v15 * v13[2]) - (float)(*(float *)&_XMM0 * v13[1])) + (float)(v16 * *v13))
          + (float)(v14 * v13[3]);
      a2[3] = (float)(v16 * v13[3])
            - (float)((float)((float)(v14 * *v13) + (float)(v15 * v13[1])) + (float)(*(float *)&_XMM0 * v13[2]));
      *a2 = v22;
      a2[1] = v23;
      a2[2] = v24;
    }
    return a2;
  }
  else
  {
LABEL_15:
    if ( a3 )
      v31 = (float *)a1 + 0x23;
    else
      v31 = (float *)a1 + 0x1F;
    v21 = v31;
    a2[3] = v31[3];
    *a2 = *v21;
    a2[1] = v21[1];
    a2[2] = v21[2];
    return a2;
  }
}

// --- End Function: sub_1461C4930 (0x1461C4930) ---

// --- Function: CEntityTemplate::GetAttachmentOffsetVec3 (0x1461C5100) ---
float *__fastcall CEntityTemplate::GetAttachmentOffsetVec3(_QWORD *a1, float *a2)
{
  sub_1461C4930(a1, a2, 1);
  return a2;
}

// --- End Function: CEntityTemplate::GetAttachmentOffsetVec3 (0x1461C5100) ---

// --- Function: fabs_w_16 (0x1461DD150) ---
bool __fastcall fabs_w_16(__int64 a1)
{
  return fabs(*(float *)(a1 + 0x1C) - *(float *)(a1 + 0x18)) >= 6.2831855;
}

// --- End Function: fabs_w_16 (0x1461DD150) ---

// --- Function: sub_1461E66C0 (0x1461E66C0) ---
float *__fastcall sub_1461E66C0(__int64 a1, const void *src)
{
  qmemcpy((void *)(a1 + 0x3B4), src, 0xCu);
  return sub_146200EA0(a1);
}

// --- End Function: sub_1461E66C0 (0x1461E66C0) ---

// --- Function: sub_1461F6D30 (0x1461F6D30) ---
void __fastcall sub_1461F6D30(__int64 a1, float *a2)
{
  sub_1461F88D0(a1, 0);
  *(_BYTE *)(a1 + 0x3F9) = 0;
  sub_1461F6D90((_QWORD *)a1, a2);
  sub_146200EA0(a1);
  sub_1461A3C20(a1);
}

// --- End Function: sub_1461F6D30 (0x1461F6D30) ---

// --- Function: sub_1461F6D90 (0x1461F6D90) ---
float *__fastcall sub_1461F6D90(_QWORD *a1, float *a2)
{
  float dst_[4]; // [rsp+20h] [rbp-D8h] BYREF
  float v4; // [rsp+30h] [rbp-C8h]
  float v5; // [rsp+38h] [rbp-C0h]
  float v6; // [rsp+40h] [rbp-B8h]
  float v7; // [rsp+48h] [rbp-B0h]
  float v8; // [rsp+50h] [rbp-A8h]
  float v9; // [rsp+58h] [rbp-A0h]
  float v10; // [rsp+60h] [rbp-98h]
  float v11; // [rsp+68h] [rbp-90h]
  float *v12; // [rsp+70h] [rbp-88h]
  float *AttachmentOffsetVec3; // [rsp+78h] [rbp-80h]
  float src_[3]; // [rsp+80h] [rbp-78h] BYREF
  float v15[5]; // [rsp+8Ch] [rbp-6Ch] BYREF
  float *src; // [rsp+A0h] [rbp-58h]
  float dst__1[4]; // [rsp+B0h] [rbp-48h] BYREF
  _BYTE v18[12]; // [rsp+C0h] [rbp-38h] BYREF
  float v19[11]; // [rsp+CCh] [rbp-2Ch] BYREF

  AttachmentOffsetVec3 = CEntityTemplate::GetAttachmentOffsetVec3(a1, v19);
  v12 = AttachmentOffsetVec3;
  LODWORD(v6) = *((_DWORD *)AttachmentOffsetVec3 + 2) ^ 0x80000000;
  LODWORD(v5) = *((_DWORD *)AttachmentOffsetVec3 + 1) ^ 0x80000000;
  LODWORD(v4) = *(_DWORD *)AttachmentOffsetVec3 ^ 0x80000000;
  src_[0] = v4;
  src_[1] = v5;
  src_[2] = v6;
  src = src_;
  v7 = AttachmentOffsetVec3[3];
  qmemcpy(dst_, src_, 0xCu);
  dst_[3] = v7;
  v11 = (float)((float)((float)(dst_[0] * a2[1]) - (float)(dst_[1] * *a2)) + (float)(v7 * a2[2]))
      + (float)(dst_[2] * a2[3]);
  v10 = (float)((float)((float)(dst_[2] * *a2) - (float)(dst_[0] * a2[2])) + (float)(v7 * a2[1]))
      + (float)(dst_[1] * a2[3]);
  v9 = (float)((float)((float)(dst_[1] * a2[2]) - (float)(dst_[2] * a2[1])) + (float)(v7 * *a2))
     + (float)(dst_[0] * a2[3]);
  v8 = (float)(v7 * a2[3])
     - (float)((float)((float)(dst_[0] * *a2) + (float)(dst_[1] * a2[1])) + (float)(dst_[2] * a2[2]));
  v15[3] = v8;
  v15[0] = v9;
  v15[1] = v10;
  v15[2] = v11;
  qmemcpy(dst__1, (const void *)sub_141D73D00((__int64)v18, (__int64)v15), 0xCu);
  return sub_1461F7080((__int64)a1, dst__1);
}

// --- End Function: sub_1461F6D90 (0x1461F6D90) ---

// --- Function: sub_1461F7080 (0x1461F7080) ---
float *__fastcall sub_1461F7080(__int64 a1, float *dst)
{
  float *result; // rax
  unsigned __int8 n3; // [rsp+20h] [rbp-1E8h]
  float v4; // [rsp+28h] [rbp-1E0h] BYREF
  float v5; // [rsp+2Ch] [rbp-1DCh]
  float v6; // [rsp+30h] [rbp-1D8h]
  float v7; // [rsp+34h] [rbp-1D4h]
  float dst_[3]; // [rsp+38h] [rbp-1D0h] BYREF
  float v9; // [rsp+48h] [rbp-1C0h]
  float v10; // [rsp+4Ch] [rbp-1BCh]
  float v11; // [rsp+50h] [rbp-1B8h]
  float v12; // [rsp+54h] [rbp-1B4h]
  float v13; // [rsp+58h] [rbp-1B0h]
  float v14; // [rsp+5Ch] [rbp-1ACh]
  float v15; // [rsp+60h] [rbp-1A8h]
  float v16; // [rsp+64h] [rbp-1A4h]
  float v17; // [rsp+68h] [rbp-1A0h]
  float v18; // [rsp+6Ch] [rbp-19Ch]
  float v19; // [rsp+70h] [rbp-198h]
  float v20; // [rsp+74h] [rbp-194h]
  float v21; // [rsp+78h] [rbp-190h]
  float v22; // [rsp+7Ch] [rbp-18Ch]
  float v23; // [rsp+80h] [rbp-188h]
  float v24; // [rsp+84h] [rbp-184h]
  float v25; // [rsp+88h] [rbp-180h]
  float v26; // [rsp+8Ch] [rbp-17Ch]
  float v27; // [rsp+90h] [rbp-178h]
  float v28; // [rsp+94h] [rbp-174h]
  float v29; // [rsp+98h] [rbp-170h]
  float v30; // [rsp+9Ch] [rbp-16Ch]
  float v31; // [rsp+A0h] [rbp-168h]
  float v32; // [rsp+A4h] [rbp-164h]
  float v33; // [rsp+A8h] [rbp-160h]
  float v34; // [rsp+ACh] [rbp-15Ch]
  float X_4; // [rsp+B0h] [rbp-158h]
  float X_5; // [rsp+B8h] [rbp-150h]
  float X_6; // [rsp+C8h] [rbp-140h]
  float X_7; // [rsp+D0h] [rbp-138h]
  float X_8; // [rsp+D8h] [rbp-130h]
  float X; // [rsp+E0h] [rbp-128h]
  float X_1; // [rsp+E8h] [rbp-120h]
  float X_2; // [rsp+F0h] [rbp-118h]
  float X_3; // [rsp+F8h] [rbp-110h]
  float *v45; // [rsp+100h] [rbp-108h]
  float *v46; // [rsp+108h] [rbp-100h]
  float *v47; // [rsp+110h] [rbp-F8h]
  float v48; // [rsp+118h] [rbp-F0h]
  float v49; // [rsp+120h] [rbp-E8h]
  float v50; // [rsp+128h] [rbp-E0h]
  float v51; // [rsp+150h] [rbp-B8h]
  float v52; // [rsp+158h] [rbp-B0h]
  float v53; // [rsp+160h] [rbp-A8h]
  float *v54; // [rsp+168h] [rbp-A0h]
  float v55; // [rsp+170h] [rbp-98h]
  float v56; // [rsp+17Ch] [rbp-8Ch]
  float v57; // [rsp+180h] [rbp-88h]
  float v58; // [rsp+184h] [rbp-84h]
  float v59; // [rsp+188h] [rbp-80h]
  float v60; // [rsp+190h] [rbp-78h]
  float v61; // [rsp+198h] [rbp-70h]
  float v62; // [rsp+1A0h] [rbp-68h]
  float v63; // [rsp+1A4h] [rbp-64h]
  float v64; // [rsp+1A8h] [rbp-60h]
  float v65; // [rsp+1ACh] [rbp-5Ch]
  float v66; // [rsp+1B0h] [rbp-58h]
  float v67; // [rsp+1B4h] [rbp-54h]
  float v68; // [rsp+1B8h] [rbp-50h]
  float v69; // [rsp+1BCh] [rbp-4Ch]
  float v70[3]; // [rsp+1C0h] [rbp-48h] BYREF
  float src_[3]; // [rsp+1CCh] [rbp-3Ch] BYREF
  float v72[3]; // [rsp+1D8h] [rbp-30h] BYREF
  float src__1[3]; // [rsp+1E4h] [rbp-24h] BYREF

  CEntityTemplate::GetAttachmentOffsetVec3((_QWORD *)a1, &v4);
  v72[2] = 0.0;
  v72[1] = 0.0;
  v72[0] = 0.0;
  sub_1461B5580(dst, v72, a1 + 0x400);
  X = dst[1] * 0.5;
  v26 = j_sinf(X);
  v11 = j_cosf(X);
  X_1 = dst[2] * 0.5;
  v9 = j_sinf(X_1);
  v12 = j_cosf(X_1);
  X_2 = *dst * 0.5;
  v10 = j_sinf(X_2);
  v25 = j_cosf(X_2);
  v30 = (float)((float)(v25 * v11) * v12) - (float)((float)(v10 * v26) * v9);
  v27 = (float)((float)(v25 * v26) * v12) - (float)((float)(v10 * v11) * v9);
  v28 = (float)((float)(v25 * v11) * v9) + (float)((float)(v10 * v26) * v12);
  v29 = (float)((float)(v25 * v26) * v9) + (float)((float)(v10 * v11) * v12);
  v55 = (float)((float)((float)(v4 * v28) - (float)(v5 * v27)) + (float)(v7 * v29)) + (float)(v6 * v30);
  v53 = (float)((float)((float)(v6 * v27) - (float)(v4 * v29)) + (float)(v7 * v28)) + (float)(v5 * v30);
  v52 = (float)((float)((float)(v5 * v29) - (float)(v6 * v28)) + (float)(v7 * v27)) + (float)(v4 * v30);
  v51 = (float)(v7 * v30) - (float)((float)((float)(v4 * v27) + (float)(v5 * v28)) + (float)(v6 * v29));
  v65 = v51;
  v62 = v52;
  v63 = v53;
  v64 = v55;
  v45 = (float *)(a1 + 0xA8);
  *(float *)(a1 + 0xA8) = v52;
  v45[1] = v63;
  v45[2] = v64;
  v45[3] = v65;
  dst_[2] = 0.0;
  dst_[1] = 0.0;
  dst_[0] = 0.0;
  for ( n3 = 0; n3 < 3u; ++n3 )
  {
    v54 = (float *)(a1 + 0xCLL * n3 + 0xC8);
    v61 = dst_[2] + *(float *)(a1 + 0xCLL * n3 + 0xD0);
    v60 = dst_[1] + *(float *)(a1 + 0xCLL * n3 + 0xCC);
    v59 = dst_[0] + *v54;
    src_[0] = v59;
    src_[1] = v60;
    src_[2] = v61;
    qmemcpy(dst_, src_, sizeof(dst_));
  }
  X_3 = dst_[1] * 0.5;
  v14 = j_sinf(dst_[1] * 0.5);
  v17 = j_cosf(X_3);
  X_4 = dst_[2] * 0.5;
  v15 = j_sinf(dst_[2] * 0.5);
  v18 = j_cosf(X_4);
  X_5 = dst_[0] * 0.5;
  v16 = j_sinf(dst_[0] * 0.5);
  v13 = j_cosf(X_5);
  v69 = (float)((float)(v13 * v17) * v18) - (float)((float)(v16 * v14) * v15);
  v66 = (float)((float)(v13 * v14) * v18) - (float)((float)(v16 * v17) * v15);
  v67 = (float)((float)(v13 * v17) * v15) + (float)((float)(v16 * v14) * v18);
  v68 = (float)((float)(v13 * v14) * v15) + (float)((float)(v16 * v17) * v18);
  v46 = (float *)(a1 + 0x370);
  *(float *)(a1 + 0x370) = v66;
  v46[1] = v67;
  v46[2] = v68;
  v46[3] = v69;
  if ( dst_[0] != 0.0 || dst_[1] != 0.0 || dst_[2] != 0.0 )
  {
    v50 = dst[2] + dst_[2];
    v49 = dst[1] + dst_[1];
    v48 = *dst + dst_[0];
    src__1[0] = v48;
    src__1[1] = v49;
    src__1[2] = v50;
    qmemcpy(dst, src__1, 0xCu);
    v70[2] = 0.0;
    v70[1] = 0.0;
    v70[0] = 0.0;
    sub_1461B5580(dst, v70, a1 + 0x400);
  }
  X_6 = dst[1] * 0.5;
  v20 = j_sinf(X_6);
  v23 = j_cosf(X_6);
  X_7 = dst[2] * 0.5;
  v21 = j_sinf(X_7);
  v24 = j_cosf(X_7);
  X_8 = *dst * 0.5;
  v22 = j_sinf(X_8);
  v19 = j_cosf(X_8);
  v34 = (float)((float)(v19 * v23) * v24) - (float)((float)(v22 * v20) * v21);
  v31 = (float)((float)(v19 * v20) * v24) - (float)((float)(v22 * v23) * v21);
  v32 = (float)((float)(v19 * v23) * v21) + (float)((float)(v22 * v20) * v24);
  v33 = (float)((float)(v19 * v20) * v21) + (float)((float)(v22 * v23) * v24);
  v58 = (float)(v7 * v34) - (float)((float)((float)(v4 * v31) + (float)(v5 * v32)) + (float)(v6 * v33));
  v56 = (float)((float)((float)(v6 * v31) - (float)(v4 * v33)) + (float)(v7 * v32)) + (float)(v5 * v34);
  v57 = (float)((float)((float)(v4 * v32) - (float)(v5 * v31)) + (float)(v7 * v33)) + (float)(v6 * v34);
  v47 = (float *)(a1 + 0xB8);
  *(float *)(a1 + 0xB8) = (float)((float)((float)(v5 * v33) - (float)(v6 * v32)) + (float)(v7 * v31))
                        + (float)(v4 * v34);
  v47[1] = v56;
  v47[2] = v57;
  result = v47;
  v47[3] = v58;
  return result;
}

// --- End Function: sub_1461F7080 (0x1461F7080) ---

// --- Function: sub_1461F88D0 (0x1461F88D0) ---
__int64 __fastcall sub_1461F88D0(__int64 a1, char a2)
{
  __int64 result; // rax

  result = a1;
  *(_BYTE *)(a1 + 0x3F8) = a2;
  return result;
}

// --- End Function: sub_1461F88D0 (0x1461F88D0) ---

// --- Function: sub_146200EA0 (0x146200EA0) ---
float *__fastcall sub_146200EA0(__int64 a1)
{
  float *result; // rax
  bool v2; // [rsp+20h] [rbp-208h]
  float v3; // [rsp+30h] [rbp-1F8h]
  float v4; // [rsp+34h] [rbp-1F4h]
  float v5; // [rsp+38h] [rbp-1F0h]
  float v6; // [rsp+3Ch] [rbp-1ECh]
  float v7; // [rsp+40h] [rbp-1E8h]
  float v8; // [rsp+44h] [rbp-1E4h]
  float v9; // [rsp+48h] [rbp-1E0h]
  float v10; // [rsp+4Ch] [rbp-1DCh]
  float v11; // [rsp+50h] [rbp-1D8h]
  float v12; // [rsp+54h] [rbp-1D4h]
  float v13; // [rsp+58h] [rbp-1D0h] BYREF
  float v14; // [rsp+5Ch] [rbp-1CCh]
  float v15; // [rsp+60h] [rbp-1C8h]
  float v16; // [rsp+64h] [rbp-1C4h]
  float dst_[4]; // [rsp+68h] [rbp-1C0h] BYREF
  float X; // [rsp+78h] [rbp-1B0h]
  float X_1; // [rsp+80h] [rbp-1A8h]
  float X_2; // [rsp+88h] [rbp-1A0h]
  float dst__1[4]; // [rsp+90h] [rbp-198h] BYREF
  float v22; // [rsp+A0h] [rbp-188h] BYREF
  float v23; // [rsp+A4h] [rbp-184h]
  float v24; // [rsp+A8h] [rbp-180h]
  float *v25; // [rsp+B0h] [rbp-178h]
  float v26; // [rsp+B8h] [rbp-170h]
  float v27; // [rsp+C0h] [rbp-168h]
  float v28; // [rsp+C8h] [rbp-160h]
  unsigned int v29; // [rsp+D0h] [rbp-158h]
  unsigned int v30; // [rsp+D8h] [rbp-150h]
  unsigned int v31; // [rsp+E0h] [rbp-148h]
  unsigned int v32; // [rsp+E8h] [rbp-140h]
  unsigned int v33; // [rsp+F0h] [rbp-138h]
  float v34; // [rsp+F8h] [rbp-130h]
  float v35; // [rsp+100h] [rbp-128h]
  unsigned int v36; // [rsp+108h] [rbp-120h]
  unsigned int v37; // [rsp+130h] [rbp-F8h]
  float v38; // [rsp+138h] [rbp-F0h]
  float *v39; // [rsp+140h] [rbp-E8h]
  __int64 v40; // [rsp+148h] [rbp-E0h]
  unsigned int v41; // [rsp+150h] [rbp-D8h]
  unsigned int v42; // [rsp+158h] [rbp-D0h]
  float v43; // [rsp+160h] [rbp-C8h]
  float v44; // [rsp+164h] [rbp-C4h]
  float v45; // [rsp+168h] [rbp-C0h]
  float v46; // [rsp+16Ch] [rbp-BCh]
  float v47; // [rsp+170h] [rbp-B8h]
  float v48; // [rsp+178h] [rbp-B0h]
  float v49; // [rsp+184h] [rbp-A4h]
  float v50; // [rsp+188h] [rbp-A0h]
  float v51; // [rsp+18Ch] [rbp-9Ch]
  unsigned __int64 v52; // [rsp+190h] [rbp-98h] BYREF
  _DWORD src_[3]; // [rsp+198h] [rbp-90h] BYREF
  float src__1[3]; // [rsp+1A4h] [rbp-84h] BYREF
  float src__2[3]; // [rsp+1B0h] [rbp-78h] BYREF
  float v56[3]; // [rsp+1BCh] [rbp-6Ch] BYREF
  _DWORD src__3[3]; // [rsp+1C8h] [rbp-60h] BYREF
  float v58[3]; // [rsp+1D4h] [rbp-54h] BYREF
  float v59[4]; // [rsp+1E0h] [rbp-48h] BYREF
  __int64 v60; // [rsp+1F0h] [rbp-38h]
  _DWORD *src; // [rsp+1F8h] [rbp-30h]
  __int64 v62; // [rsp+200h] [rbp-28h]

  CEntityTemplate::GetAttachmentOffsetVec3((_QWORD *)a1, &v13);
  v39 = &v13;
  v42 = LODWORD(v15) ^ 0x80000000;
  v41 = LODWORD(v14) ^ 0x80000000;
  v37 = LODWORD(v13) ^ 0x80000000;
  src_[0] = LODWORD(v13) ^ 0x80000000;
  src_[1] = LODWORD(v14) ^ 0x80000000;
  src_[2] = LODWORD(v15) ^ 0x80000000;
  src = src_;
  v46 = v16;
  qmemcpy(dst_, src_, 0xCu);
  dst_[3] = v16;
  v27 = (float)((float)((float)(dst_[0] * *(float *)(a1 + 0xBC)) - (float)(dst_[1] * *(float *)(a1 + 0xB8)))
              + (float)(v16 * *(float *)(a1 + 0xC0)))
      + (float)(dst_[2] * *(float *)(a1 + 0xC4));
  v26 = (float)((float)((float)(dst_[2] * *(float *)(a1 + 0xB8)) - (float)(dst_[0] * *(float *)(a1 + 0xC0)))
              + (float)(v16 * *(float *)(a1 + 0xBC)))
      + (float)(dst_[1] * *(float *)(a1 + 0xC4));
  v48 = (float)((float)((float)(dst_[1] * *(float *)(a1 + 0xC0)) - (float)(dst_[2] * *(float *)(a1 + 0xBC)))
              + (float)(v16 * *(float *)(a1 + 0xB8)))
      + (float)(dst_[0] * *(float *)(a1 + 0xC4));
  v47 = (float)(v16 * *(float *)(a1 + 0xC4))
      - (float)((float)((float)(dst_[0] * *(float *)(a1 + 0xB8)) + (float)(dst_[1] * *(float *)(a1 + 0xBC)))
              + (float)(dst_[2] * *(float *)(a1 + 0xC0)));
  v59[3] = v47;
  v59[0] = v48;
  v59[1] = v26;
  v59[2] = v27;
  sub_141D73D00((__int64)&v22, (__int64)v59);
  v2 = 0;
  v62 = *(_QWORD *)(a1 + 0x548) & 0xFFFFFFFFFFFFLL;
  v60 = sub_1465EEEC0(v62);
  sub_145F4DD20(v60, &v52);
  if ( sub_14030EC00(&v52) )
    v2 = sub_145D28790(v52);
  if ( v2 )
  {
    src__1[2] = 0.0;
    src__1[1] = 0.0;
    src__1[0] = 0.0;
    qmemcpy(dst__1, src__1, 0xCu);
  }
  else
  {
    v28 = v22;
    src__2[0] = v22;
    src__2[1] = 0.0;
    src__2[2] = 0.0;
    qmemcpy(dst__1, src__2, 0xCu);
    v56[2] = 0.0;
    v56[1] = 0.0;
    v56[0] = 0.0;
    sub_1461B5580(dst__1, v56, a1 + 0x428);
    v36 = LODWORD(dst__1[2]) ^ 0x80000000;
    v30 = LODWORD(dst__1[1]) ^ 0x80000000;
    v29 = LODWORD(dst__1[0]) ^ 0x80000000;
    src__3[0] = LODWORD(dst__1[0]) ^ 0x80000000;
    src__3[1] = LODWORD(dst__1[1]) ^ 0x80000000;
    src__3[2] = LODWORD(dst__1[2]) ^ 0x80000000;
    qmemcpy(dst__1, src__3, 0xCu);
  }
  sub_1461B5580((float *)(a1 + 0x3B4), dst__1, a1 + 0x428);
  v33 = LODWORD(v24) ^ 0x80000000;
  v32 = LODWORD(v23) ^ 0x80000000;
  v31 = LODWORD(v22) ^ 0x80000000;
  LODWORD(v58[0]) = LODWORD(v22) ^ 0x80000000;
  LODWORD(v58[1]) = LODWORD(v23) ^ 0x80000000;
  LODWORD(v58[2]) = LODWORD(v24) ^ 0x80000000;
  sub_1461B5580((float *)(a1 + 0x3B4), v58, a1 + 0x400);
  v40 = a1 + 0x3B4;
  v38 = v24 + *(float *)(a1 + 0x3BC);
  v35 = v23 + *(float *)(a1 + 0x3B8);
  v34 = v22 + *(float *)(a1 + 0x3B4);
  v43 = v34;
  v44 = v35;
  v45 = v38;
  X = v35 * 0.5;
  v4 = j_sinf(v35 * 0.5);
  v7 = j_cosf(X);
  X_1 = v45 * 0.5;
  v5 = j_sinf(v45 * 0.5);
  v8 = j_cosf(X_1);
  X_2 = v43 * 0.5;
  v6 = j_sinf(v43 * 0.5);
  v3 = j_cosf(X_2);
  v12 = (float)((float)(v3 * v7) * v8) - (float)((float)(v6 * v4) * v5);
  v9 = (float)((float)(v3 * v4) * v8) - (float)((float)(v6 * v7) * v5);
  v10 = (float)((float)(v3 * v7) * v5) + (float)((float)(v6 * v4) * v8);
  v11 = (float)((float)(v3 * v4) * v5) + (float)((float)(v6 * v7) * v8);
  v51 = (float)(v16 * v12) - (float)((float)((float)(v13 * v9) + (float)(v14 * v10)) + (float)(v15 * v11));
  v49 = (float)((float)((float)(v15 * v9) - (float)(v13 * v11)) + (float)(v16 * v10)) + (float)(v14 * v12);
  v50 = (float)((float)((float)(v13 * v10) - (float)(v14 * v9)) + (float)(v16 * v11)) + (float)(v15 * v12);
  v25 = (float *)(a1 + 0x3A4);
  *(float *)(a1 + 0x3A4) = (float)((float)((float)(v14 * v11) - (float)(v15 * v10)) + (float)(v16 * v9))
                         + (float)(v13 * v12);
  v25[1] = v49;
  v25[2] = v50;
  result = v25;
  v25[3] = v51;
  return result;
}

// --- End Function: sub_146200EA0 (0x146200EA0) ---

// --- Function: sub_1462475E0 (0x1462475E0) ---
char *__fastcall sub_1462475E0(char *src_1, char *src_2, __int64 a3, unsigned __int8 a4)
{
  __int64 i; // [rsp+30h] [rbp-68h]
  char *p_src; // [rsp+38h] [rbp-60h] BYREF
  char *src_3; // [rsp+40h] [rbp-58h]
  __int64 v8; // [rsp+48h] [rbp-50h]
  signed __int64 v9; // [rsp+50h] [rbp-48h]
  _QWORD src_[3]; // [rsp+58h] [rbp-40h] BYREF

  while ( 1 )
  {
    if ( (src_2 - src_1) / 0x18 <= 0x20 )
      return sub_146241AF0(src_1, src_2);
    if ( a3 <= 0 )
      break;
    sub_146243930(&p_src, src_1, src_2);
    a3 = (a3 >> 2) + (a3 >> 1);
    v9 = (p_src - src_1) / 0x18;
    if ( v9 >= (src_2 - src_3) / 0x18 )
    {
      sub_1462475E0(src_3, src_2, a3, a4);
      src_2 = p_src;
    }
    else
    {
      sub_1462475E0(src_1, p_src, a3, a4);
      src_1 = src_3;
    }
  }
  v8 = (src_2 - src_1) / 0x18;
  for ( i = v8 >> 1; i > 0; sub_146244B00(src_1, i, v8, src_) )
  {
    --i;
    qmemcpy(src_, &src_1[0x18 * i], sizeof(src_));
  }
  return (char *)sub_1462470D0(src_1, src_2);
}

// --- End Function: sub_1462475E0 (0x1462475E0) ---

// --- Function: sub_14631D700 (0x14631D700) ---
__int64 __fastcall sub_14631D700(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // rax
  int m; // [rsp+44h] [rbp-264h]
  int i; // [rsp+48h] [rbp-260h]
  int v5; // [rsp+4Ch] [rbp-25Ch]
  unsigned __int8 v6; // [rsp+61h] [rbp-247h]
  unsigned __int64 j; // [rsp+68h] [rbp-240h]
  Parameter *Parameter_1; // [rsp+70h] [rbp-238h]
  __int64 v9; // [rsp+78h] [rbp-230h]
  int v10; // [rsp+80h] [rbp-228h]
  unsigned int v11; // [rsp+84h] [rbp-224h]
  __int64 v12; // [rsp+90h] [rbp-218h]
  __int64 v13; // [rsp+98h] [rbp-210h]
  unsigned __int64 k; // [rsp+A0h] [rbp-208h]
  __int64 v15; // [rsp+A8h] [rbp-200h]
  unsigned int v16; // [rsp+B0h] [rbp-1F8h]
  unsigned int v17; // [rsp+B4h] [rbp-1F4h]
  _QWORD *v18; // [rsp+C0h] [rbp-1E8h]
  _QWORD *v19; // [rsp+C8h] [rbp-1E0h]
  __int64 v20; // [rsp+D8h] [rbp-1D0h]
  __int64 v21; // [rsp+E0h] [rbp-1C8h]
  _QWORD *v22; // [rsp+F0h] [rbp-1B8h]
  __int64 v23; // [rsp+108h] [rbp-1A0h]
  __int64 v24; // [rsp+118h] [rbp-190h]
  ULONG_PTR Parameter[2]; // [rsp+130h] [rbp-178h] BYREF
  ULONG_PTR Parameter_[3]; // [rsp+140h] [rbp-168h] BYREF
  __int64 v27; // [rsp+158h] [rbp-150h] BYREF
  unsigned __int8 *v28; // [rsp+160h] [rbp-148h]
  __int64 (__fastcall *v29)(__int64, _QWORD); // [rsp+168h] [rbp-140h]
  __int64 (__fastcall *v30)(__int64, _QWORD); // [rsp+170h] [rbp-138h]
  __int64 v31; // [rsp+178h] [rbp-130h]
  __int64 v32; // [rsp+180h] [rbp-128h]
  __int64 v33; // [rsp+188h] [rbp-120h]
  _QWORD *v34; // [rsp+190h] [rbp-118h]
  _QWORD *v35; // [rsp+198h] [rbp-110h]
  unsigned __int64 v36; // [rsp+1A0h] [rbp-108h]
  __int64 v37; // [rsp+1A8h] [rbp-100h]
  const ULONG_PTR *v38; // [rsp+1B0h] [rbp-F8h]
  __int64 (__fastcall *v39)(__int64, const ULONG_PTR *); // [rsp+1B8h] [rbp-F0h]
  __int64 (__fastcall *v40)(__int64, _QWORD, _QWORD); // [rsp+1C0h] [rbp-E8h]
  _QWORD *v41; // [rsp+1C8h] [rbp-E0h]
  __int64 v42; // [rsp+1D0h] [rbp-D8h]
  _QWORD *v43; // [rsp+1D8h] [rbp-D0h]
  _QWORD *v44; // [rsp+1E0h] [rbp-C8h]
  _QWORD *v45; // [rsp+1E8h] [rbp-C0h]
  _QWORD *v46; // [rsp+1F0h] [rbp-B8h]
  __int64 v47; // [rsp+1F8h] [rbp-B0h] BYREF
  __int64 v48; // [rsp+200h] [rbp-A8h]
  __int64 v49; // [rsp+208h] [rbp-A0h]
  const ULONG_PTR *v50; // [rsp+210h] [rbp-98h]
  const char *v51; // [rsp+218h] [rbp-90h]
  ULONG_PTR v52; // [rsp+220h] [rbp-88h]
  Parameter *Parameter_2; // [rsp+228h] [rbp-80h]
  ULONG_PTR v54; // [rsp+230h] [rbp-78h]
  ULONG_PTR v55; // [rsp+238h] [rbp-70h]
  Parameter *Parameter_3; // [rsp+240h] [rbp-68h]
  ULONG_PTR v57; // [rsp+248h] [rbp-60h]
  char *src; // [rsp+250h] [rbp-58h]
  ULONG_PTR v59; // [rsp+258h] [rbp-50h]
  ULONG_PTR v60; // [rsp+260h] [rbp-48h]
  char *src_1; // [rsp+268h] [rbp-40h]
  _QWORD src_[3]; // [rsp+278h] [rbp-30h] BYREF

  result = a1;
  if ( *(_QWORD *)(a1 + 0x258) )
  {
    *(_DWORD *)(a1 + 0x250) = 0xFFFFFFFF;
    if ( !sub_1403E5570((_QWORD *)(*(_QWORD *)(a1 + 0x258) + 8LL)) )
    {
      v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x268) & 0xFFFFFFFFFFFFLL) + 0x768LL))(*(_QWORD *)(a1 + 0x268) & 0xFFFFFFFFFFFFLL);
      v20 = v9 ? (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x30LL))(v9) : 0LL;
      if ( v9 && v20 )
      {
        v28 = (unsigned __int8 *)sub_14037FC70(*(_QWORD *)(a1 + 0x258) + 8LL);
        v16 = sub_1403E2C90(v28);
        v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x70LL))(v9);
        v29 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v21 + 0x30LL);
        v10 = v29(v21, v16);
        if ( v10 >= 0 )
        {
          v30 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v20 + 0xF0LL);
          v11 = v30(v20, (unsigned int)v10);
        }
        else
        {
          v11 = 0xFFFFFFFF;
        }
        *(_DWORD *)(a1 + 0x250) = v11;
      }
    }
    Parameter_1 = *(_QWORD *)(a1 + 0x258) + 0x78LL;
    if ( !((*(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x80LL) - *(_QWORD *)Parameter_1) / 0x18LL) || (result = a2) != 0 )
    {
      v31 = *(_QWORD *)(a1 + 0x258) + 0x48LL;
      v27 = v31;
      v32 = v31;
      sub_1402CD240(v31, "CSCBodyHealthComponent::PostPhysicalize", 1);
      if ( a2 )
      {
        sub_142C0A570((Parameter *)Parameter_1);
        for ( i = 0; ; ++i )
        {
          v22 = (_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x60LL);
          v33 = i;
          if ( i >= (unsigned __int64)((v22[1] - *v22) / 0x38LL) )
            break;
          v34 = (_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x60LL);
          v35 = v34;
          sub_1403E42C0((__int64 *)(*v34 + 0x38LL * i + 0x18));
        }
      }
      if ( !((*(_QWORD *)(Parameter_1 + 8) - *(_QWORD *)Parameter_1) / 0x18LL) )
      {
        v12 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x268) & 0xFFFFFFFFFFFFLL)
                                                          + 0x768LL))(
                *(_QWORD *)(a1 + 0x268) & 0xFFFFFFFFFFFFLL,
                (*(_QWORD *)(Parameter_1 + 8) - *(_QWORD *)Parameter_1) % 0x18LL);
        if ( v12 )
        {
          v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x70LL))(v12);
          v23 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x30LL))(v12);
          v13 = *(_QWORD *)(a1 + 0x258) + 0x18LL;
          v19 = (_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x60LL);
          for ( j = 0; ; ++j )
          {
            v36 = *(_QWORD *)(v13 + 0x18);
            if ( j >= v36 )
              break;
            v39 = *(__int64 (__fastcall **)(__int64, const ULONG_PTR *))(*(_QWORD *)v15 + 0x48LL);
            v37 = *(_QWORD *)(v13 + 0x10) + 0x38 * j;
            v38 = sub_14037FC70(v37 + 8);
            v17 = v39(v15, v38);
            v40 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v23 + 0xE0LL);
            v18 = (_QWORD *)v40(v23, v17, 0);
            if ( v18 )
            {
              for ( k = 0; k < sub_1403EABD0(v18); ++k )
              {
                v41 = v18;
                v5 = *(_DWORD *)(*v18 + 4 * k);
                if ( v5 < 0 )
                {
                  v24 = *(_QWORD *)(v13 + 0x18);
                  v49 = *(_QWORD *)(v13 + 0x10) + 0x38 * j;
                  v50 = sub_14037FC70(v49 + 8);
                  v51 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0xE0LL))(v15);
                  sub_1405C0E00(
                    0xAu,
                    0,
                    "%s Body mapping - Skeleton [%s] has issue mapping joint [%s] with id [%d] outside size [%zu]",
                    "CSCBodyHealthComponent::PostPhysicalize",
                    v51,
                    (const char *)v50,
                    v5,
                    v24);
                }
                else
                {
                  src_[1] = j;
                  src_[0] = v5;
                  for ( m = 0; ; ++m )
                  {
                    v42 = m;
                    if ( m >= (unsigned __int64)((v19[1] - *v19) / 0x38LL) )
                      break;
                    v43 = v19;
                    v45 = (_QWORD *)(0x38LL * m + *v19);
                    v44 = (_QWORD *)(*(_QWORD *)(v13 + 0x10) + 0x38 * j + 0x20);
                    if ( sub_1402B4B90(v45, v44) )
                    {
                      src_[2] = m;
                      v46 = v19;
                      v48 = *v19 + 0x38LL * m + 0x18;
                      v47 = v5;
                      sub_140344450(v48, &v47);
                      break;
                    }
                  }
                  sub_142E9B490((BB_ComparisonOperatorType *)Parameter_1, src_);
                }
              }
            }
          }
          if ( *(_QWORD *)Parameter_1 != *(_QWORD *)(Parameter_1 + 8) )
          {
            Parameter_2 = Parameter_1;
            v52 = *(_QWORD *)(Parameter_1 + 8);
            Parameter[0] = v52;
            _StarEngineModule__((ULONG_PTR)Parameter);
            v54 = Parameter[0];
            src = (char *)Parameter[0];
            Parameter[1] = Parameter_1;
            Parameter_3 = Parameter_1;
            v55 = *(_QWORD *)Parameter_1;
            Parameter_[0] = v55;
            _StarEngineModule__((ULONG_PTR)Parameter_);
            v57 = Parameter_[0];
            v59 = Parameter_[0];
            src_1 = src;
            v60 = Parameter_[0];
            Parameter_[2] = Parameter_[0];
            Parameter_[1] = (ULONG_PTR)src;
            sub_1462475E0((char *)Parameter_[0], src, (__int64)&src[-Parameter_[0]] / 0x18, v6);
          }
        }
      }
      return (__int64)sub_1402B1820(&v27);
    }
  }
  return result;
}

// --- End Function: sub_14631D700 (0x14631D700) ---

// --- Function: sub_14644BB60 (0x14644BB60) ---
__int64 __fastcall sub_14644BB60(__int64 a1)
{
  return a1 + 0xED8;
}

// --- End Function: sub_14644BB60 (0x14644BB60) ---

// --- Function: sub_14647F400 (0x14647F400) ---
char __fastcall sub_14647F400(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rax

  v2 = *(_QWORD *)(a1 + 0x200);
  if ( !v2 || !sub_1442DE8E0(v2) )
    return 1;
  v3 = *(_QWORD *)(a1 + 0x200);
  if ( !v3 )
    return (*(__int64 (**)(void))(MEMORY[0] + 0x700LL))();
  v4 = sub_1442DE8E0(v3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x700LL))(v4);
}

// --- End Function: sub_14647F400 (0x14647F400) ---

// --- Function: sub_1464E7930 (0x1464E7930) ---
__int64 __fastcall sub_1464E7930(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x180LL))(*(_QWORD *)(a1 + 0xE8));
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x28LL))(v1);
}

// --- End Function: sub_1464E7930 (0x1464E7930) ---

// --- Function: sub_1465D1DE0 (0x1465D1DE0) ---
char __fastcall sub_1465D1DE0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v3[4]; // [rsp+28h] [rbp-20h] BYREF

  v3[0] = *(_QWORD *)(a1 + 0x6C8);
  if ( !is_valid_handle_typeA(v3) )
    return 0;
  v3[1] = v3[0] & 0xFFFFFFFFFFFFLL;
  v1 = sub_14644BB60(v3[0] & 0xFFFFFFFFFFFFLL);
  return sub_1413017D0(v1);
}

// --- End Function: sub_1465D1DE0 (0x1465D1DE0) ---

// --- Function: sub_1465EEBE0 (0x1465EEBE0) ---
__int64 __fastcall sub_1465EEBE0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270);
}

// --- End Function: sub_1465EEBE0 (0x1465EEBE0) ---

// --- Function: sub_1465EECD0 (0x1465EECD0) ---
__int64 __fastcall sub_1465EECD0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x2900LL;
}

// --- End Function: sub_1465EECD0 (0x1465EECD0) ---

// --- Function: sub_1465EEE60 (0x1465EEE60) ---
__int64 __fastcall sub_1465EEE60(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x2B98LL;
}

// --- End Function: sub_1465EEE60 (0x1465EEE60) ---

// --- Function: sub_1465EEEC0 (0x1465EEEC0) ---
__int64 __fastcall sub_1465EEEC0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x6B60LL;
}

// --- End Function: sub_1465EEEC0 (0x1465EEEC0) ---

// --- Function: sub_1465EF570 (0x1465EF570) ---
__int64 __fastcall sub_1465EF570(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270) + 0x9A50LL;
}

// --- End Function: sub_1465EF570 (0x1465EF570) ---

// --- Function: sub_1465FAFF0 (0x1465FAFF0) ---
__int64 __fastcall sub_1465FAFF0(__int64 a1)
{
  __int64 result; // rax
  __int64 *v2; // rax
  __int64 v3; // [rsp+38h] [rbp-2E0h]
  __int64 v4; // [rsp+40h] [rbp-2D8h] BYREF
  __int64 v5; // [rsp+48h] [rbp-2D0h]
  __int64 v6; // [rsp+50h] [rbp-2C8h] BYREF
  __int64 v7; // [rsp+58h] [rbp-2C0h]
  __int64 v8[2]; // [rsp+60h] [rbp-2B8h] BYREF
  __int64 v9[6]; // [rsp+70h] [rbp-2A8h] BYREF
  __int64 v10; // [rsp+A0h] [rbp-278h]
  unsigned __int64 v11; // [rsp+A8h] [rbp-270h]
  unsigned __int64 v12; // [rsp+B0h] [rbp-268h]
  unsigned __int64 v13; // [rsp+B8h] [rbp-260h]
  __int64 v14; // [rsp+C0h] [rbp-258h]
  __int64 v15; // [rsp+C8h] [rbp-250h]
  unsigned __int64 v16; // [rsp+D0h] [rbp-248h]
  __int64 v17; // [rsp+D8h] [rbp-240h]
  __int64 v18; // [rsp+E0h] [rbp-238h]
  void (__fastcall *v19)(__int64, _QWORD); // [rsp+E8h] [rbp-230h]
  void (__fastcall *v20)(__int64, _QWORD); // [rsp+F0h] [rbp-228h]
  void (__fastcall *v21)(__int64, _QWORD); // [rsp+F8h] [rbp-220h]
  __int64 v22; // [rsp+100h] [rbp-218h]
  void (__fastcall *v23)(__int64, _DWORD *); // [rsp+108h] [rbp-210h]
  __int64 v24; // [rsp+110h] [rbp-208h]
  void (__fastcall *v25)(__int64, __int64 *); // [rsp+118h] [rbp-200h]
  __int64 v26; // [rsp+120h] [rbp-1F8h]
  void (__fastcall *v27)(unsigned __int64, _DWORD *, __int64, _QWORD); // [rsp+128h] [rbp-1F0h]
  __int64 v28; // [rsp+130h] [rbp-1E8h]
  void (__fastcall *v29)(unsigned __int64, _DWORD *, __int64, _QWORD); // [rsp+138h] [rbp-1E0h]
  __int64 v30; // [rsp+140h] [rbp-1D8h]
  __int64 v31; // [rsp+148h] [rbp-1D0h]
  void (__fastcall *v32)(unsigned __int64, __int64 *); // [rsp+150h] [rbp-1C8h]
  __int64 v33; // [rsp+158h] [rbp-1C0h]
  __int64 v34; // [rsp+160h] [rbp-1B8h]
  _QWORD v35[2]; // [rsp+168h] [rbp-1B0h] BYREF
  __int64 v36; // [rsp+178h] [rbp-1A0h]
  void (__fastcall *v37)(unsigned __int64, _BYTE *, __int64, _QWORD); // [rsp+180h] [rbp-198h]
  __int64 v38; // [rsp+188h] [rbp-190h]
  __int64 v39; // [rsp+190h] [rbp-188h]
  unsigned int (__fastcall *v40)(__int64, _BYTE *); // [rsp+198h] [rbp-180h]
  __int64 v41; // [rsp+1A0h] [rbp-178h]
  __int64 v42; // [rsp+1A8h] [rbp-170h]
  __int64 v43; // [rsp+1B0h] [rbp-168h]
  _DWORD dst[4]; // [rsp+1B8h] [rbp-160h] BYREF
  _DWORD v45[4]; // [rsp+1C8h] [rbp-150h] BYREF
  __int64 v46; // [rsp+1D8h] [rbp-140h] BYREF
  _BYTE v47[12]; // [rsp+1E0h] [rbp-138h] BYREF
  int n0x2000; // [rsp+1ECh] [rbp-12Ch]
  _BYTE v49[24]; // [rsp+200h] [rbp-118h] BYREF
  double v50[15]; // [rsp+218h] [rbp-100h] BYREF
  _DWORD v51[34]; // [rsp+290h] [rbp-88h] BYREF

  sub_14161ADF0(a1, v8);
  if ( AssetMeta::HasActorSubresource(v8) )
  {
    v8[1] = v8[0] & 0xFFFFFFFFFFFFLL;
    v19 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(v8[0] & 0xFFFFFFFFFFFFLL) + 0x630LL);
    v19(v8[0] & 0xFFFFFFFFFFFFLL, 0);
  }
  sub_1446EB270(a1, v9);
  if ( AssetMeta::HasActorSubresource(v9) )
  {
    v9[1] = v9[0] & 0xFFFFFFFFFFFFLL;
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v9[0] & 0xFFFFFFFFFFFFLL) + 0x5D8LL))(v9[0] & 0xFFFFFFFFFFFFLL);
    if ( v3 )
    {
      v20 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0x198LL);
      v20(v3, *(unsigned int *)(qword_149E7E430 + 0x13B4));
      v21 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xD8LL);
      v21(v3, *(unsigned int *)(qword_149E7E430 + 0x13B8));
    }
  }
  v5 = *(_QWORD *)(a1 + 0x5D0);
  v18 = *(_QWORD *)(a1 + 0x608);
  v9[2] = v5 & 0xFFFFFFFFFFFFLL;
  qmemcpy(
    dst,
    (const void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x5E8LL))(v5 & 0xFFFFFFFFFFFFLL),
    0xCu);
  v22 = v18 & 0xFFFFFFFFFFFFLL;
  sub_145A31670(v18 & 0xFFFFFFFFFFFFLL, dst);
  v9[3] = v5 & 0xFFFFFFFFFFFFLL;
  v23 = *(void (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x5F0LL);
  v23(v5 & 0xFFFFFFFFFFFFLL, dst);
  v9[4] = v5 & 0xFFFFFFFFFFFFLL;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x578LL))(v5 & 0xFFFFFFFFFFFFLL);
  v9[5] = v5 & 0xFFFFFFFFFFFFLL;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 0x620LL))(v5 & 0xFFFFFFFFFFFFLL);
  v24 = *(_QWORD *)(a1 + 0x578) & 0xFFFFFFFFFFFFLL;
  sub_14631D700(v24, 0);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x768LL))(a1);
  v7 = result;
  if ( result )
  {
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x30LL))(v7);
    v25 = *(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v10 + 0x28LL);
    v25(v10, &v6);
    if ( HIWORD_w(&v6) )
    {
      sub_1403708B0(v51);
      v51[0x13] = 5;
      v11 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
      v27 = *(void (__fastcall **)(unsigned __int64, _DWORD *, __int64, _QWORD))(*(_QWORD *)v11 + 0x3F8LL);
      v26 = v6;
      v27(v11, v51, v6, 0);
      sub_1403706F0(v45);
      v45[2] = 0x2000000;
      v12 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
      v29 = *(void (__fastcall **)(unsigned __int64, _DWORD *, __int64, _QWORD))(*(_QWORD *)v12 + 0x3F8LL);
      v28 = v6;
      v29(v12, v45, v6, 0);
      v31 = sub_1408822B0(qword_149E7E438);
      v30 = v6;
      sub_142ED3D20(v31, v6, 0x800u, 0, 0xFFFFFFFF);
    }
    v13 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
    v32 = *(void (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v13 + 0x3B8LL);
    v32(v13, &v4);
    result = HIWORD_w(&v4);
    if ( (_BYTE)result )
    {
      if ( *(_BYTE *)(sub_141D17630(a1) + 0x30) )
      {
        v34 = sub_1408822B0(qword_149E7E438);
        v33 = v4;
        sub_142ED3D20(v34, v4, 0x2000u, 0, 0xFFFFFFFF);
        *(_BYTE *)(a1 + 0x93B) = 0;
        *(_BYTE *)(a1 + 0x93C) = 0;
        if ( !*(_BYTE *)(a1 + 0x93C) )
        {
          v35[0] = *(_QWORD *)(a1 + 8);
          v14 = sub_14030ECF0(v35);
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x720LL))(v14) )
          {
            v15 = a1 + 0x918;
            *(_BYTE *)(a1 + 0x920) = 0;
            sub_1403C3BF0(v15);
            *(_BYTE *)(a1 + 0x93A) = 0;
          }
          else
          {
            *(_BYTE *)(a1 + 0x938) = 1;
          }
          sub_1412A8470((__int64)v47);
          n0x2000 = 0x2000;
          v16 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
          v37 = *(void (__fastcall **)(unsigned __int64, _BYTE *, __int64, _QWORD))(*(_QWORD *)v16 + 0x3F8LL);
          v35[1] = &v46;
          sub_1402B1640(&v46);
          v36 = *v2;
          v37(v16, v47, v36, 0);
        }
      }
      else
      {
        v39 = sub_1408822B0(qword_149E7E438);
        v38 = v4;
        sub_142ED3D20(v39, v4, 0x1000u, 0, 0xFFFFFFFF);
      }
      sub_142EC37E0((__int64)v49);
      v17 = sub_14030ECF0(&v4);
      v40 = *(unsigned int (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v17 + 0x20LL);
      if ( v40(v17, v49) )
      {
        if ( !sub_1405A5A20(v50) )
        {
          v41 = v18 & 0xFFFFFFFFFFFFLL;
          sub_145A3B9F0(v18 & 0xFFFFFFFFFFFFLL, v50);
        }
      }
      v43 = sub_1408822B0(qword_149E7E438);
      v42 = v4;
      return sub_142ED3D20(v43, v4, 0x400u, 0, 0xFFFFFFFF);
    }
  }
  return result;
}

// --- End Function: sub_1465FAFF0 (0x1465FAFF0) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_1475B3F30 (0x1475B3F30) ---
int __fastcall sub_1475B3F30(char *Buffer, size_t BufferCount, unsigned __int64 n0x40000000)
{
  const char *p_%u.%u_MB; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-A8h]
  int v11; // [rsp+28h] [rbp-A0h]
  __m256 DstBuf_; // [rsp+40h] [rbp-88h] BYREF
  __m256 DstBuf__1; // [rsp+60h] [rbp-68h] BYREF
  __m256 v14; // [rsp+80h] [rbp-48h]

  DstBuf_ = (__m256)0LL;
  if ( n0x40000000 >= 0x10000000000LL )
  {
    p_%u.%u_MB = "%u.%u TB";
    v7 = (0xA * (n0x40000000 & 0xFFFFFFFFFFLL)) >> 0x28;
    v8 = n0x40000000 >> 0x28;
LABEL_7:
    v11 = v7;
    v10 = v8;
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, p_%u.%u_MB, v10, v11);
    goto LABEL_11;
  }
  if ( n0x40000000 >= 0x40000000 )
  {
    p_%u.%u_MB = "%u.%u GB";
    v7 = (0xA * (n0x40000000 & 0x3FFFFFFF)) >> 0x1E;
    v8 = n0x40000000 >> 0x1E;
    goto LABEL_7;
  }
  if ( n0x40000000 >= 0x100000 )
  {
    p_%u.%u_MB = "%u.%u MB";
    v7 = (0xA * (n0x40000000 & 0xFFFFF)) >> 0x14;
    v8 = n0x40000000 >> 0x14;
    goto LABEL_7;
  }
  if ( n0x40000000 < 0x400 )
  {
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, "%u byte(s)", n0x40000000);
  }
  else
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf_,
      0x20u,
      0xFFFFFFFFFFFFFFFFuLL,
      "%u.%u KB",
      n0x40000000 >> 0xA,
      (0xA * (n0x40000000 & 0x3FF)) >> 0xA);
  }
LABEL_11:
  DstBuf__1 = (__m256)0LL;
  v14 = (__m256)0LL;
  if ( byte_1516B60CF )
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf__1,
      0x40u,
      0xFFFFFFFFFFFFFFFFuLL,
      " (Started with < %u GB of available system memory.)",
      8);
  }
  __asm { vzeroupper }
  return snprintf_s(
           Buffer,
           BufferCount,
           0xFFFFFFFFFFFFFFFFuLL,
           "Out of system memory. Failed to allocate %s (%zu).%s",
           (const char *)&DstBuf_,
           n0x40000000,
           (const char *)&DstBuf__1);
}

// --- End Function: sub_1475B3F30 (0x1475B3F30) ---

// --- Function: sub_1475DF210 (0x1475DF210) ---
void __fastcall sub_1475DF210(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1475B3F30(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1475DF210 (0x1475DF210) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476030E0 (0x1476030E0) ---
unsigned __int64 __fastcall sub_1476030E0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n32; // eax
  unsigned int n32_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147603270((__int64)&qword_151700CC0, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n32 = 32;
    n32_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n32 = n32_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(32 - n32) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148D699B0[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 16 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3840;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 12);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147604610(&unk_151700CD0[4 * v12]);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1476034A0((__int64)&qword_151700CC0, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_151701F50;
  if ( qword_151701F50 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_151701E50;
    if ( qword_151701E50 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1476030E0 (0x1476030E0) ---

// --- Function: sub_147603270 (0x147603270) ---
__int64 __fastcall sub_147603270(__int64 a1, unsigned __int64 n0xE000)
{
  unsigned __int64 n0xE000_2; // r13
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // rbx
  unsigned __int64 v5; // r12
  __int64 v6; // r15
  __int64 v7; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rsi
  unsigned __int64 v10; // r14
  __int64 v11; // r8
  __int64 v12; // rsi
  __int64 v13; // rax
  __int128 v15; // [rsp+30h] [rbp-40h] BYREF
  double v16; // [rsp+40h] [rbp-30h]
  __int64 v17; // [rsp+48h] [rbp-28h] BYREF
  __int128 v18; // [rsp+50h] [rbp-20h]
  double v19; // [rsp+60h] [rbp-10h]
  double v20; // [rsp+B0h] [rbp+40h] BYREF
  unsigned __int64 n0xE000_1; // [rsp+B8h] [rbp+48h]
  __int64 v22; // [rsp+C0h] [rbp+50h]

  n0xE000_1 = n0xE000;
  n0xE000_2 = n0xE000;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
  v5 = sub_147603A00(n0xE000, 1);
  v6 = ~(*(unsigned int *)(a1 + 0x1284) - 1LL) & (*(unsigned int *)(a1 + 0x1284) + n0xE000_2 - 1);
  v22 = v6;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x12C0));
  v20 = 0.0;
  v7 = sub_147602DF0(a1, v5, &v20);
  v8 = *(_QWORD **)(v7 + 8);
  if ( v8 )
  {
    *(_QWORD *)(v7 + 8) = *v8;
    v9 = v8[1];
    v8[1] = 0;
    *v8 = *(_QWORD *)(a1 + 0x12B8);
    *(_QWORD *)(a1 + 0x12B8) = v8;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 0x1290);
    if ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 )
    {
      do
      {
        v11 = *(unsigned int *)(a1 + 0x12AC);
        v12 = (v11 + 0x17) & ~(v11 - 1);
        *(__m256i *)(a1 + 0x1298) = *(__m256i *)sub_14056DBC0((__int64)&v17, 0x8000000000LL, v11, &off_148D699A8, 1, 0);// "StarAlloc-Large"
        v10 = (*(_QWORD *)(a1 + 0x1298) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
        __asm { vzeroupper }
        sub_14056DA40(a1 + 0x1298, v10, v12);
        *(_WORD *)(v10 + 0x15) = 0;
        *(_BYTE *)(v10 + 0x17) = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)(v10 + 0x10) = 0x1337;
        *(_BYTE *)(v10 + 0x14) = 0;
        *(_QWORD *)(v10 + 8) = v12;
        *(_QWORD *)v10 = *(_QWORD *)(a1 + 0x1290);
        *(_QWORD *)(a1 + 0x1290) = v10;
      }
      while ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 );
      v6 = v22;
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
      n0xE000_2 = n0xE000_1;
    }
    v13 = *(_QWORD *)(v10 + 8);
    v9 = v13 + v10;
    *(_QWORD *)(v10 + 8) = v5 + v13;
  }
  sub_14056DA40(a1 + 0x1270, v9, v6);
  v16 = v20;
  *(_QWORD *)&v15 = n0xE000_2;
  *((_QWORD *)&v15 + 1) = v6;
  v19 = v20;
  v17 = v9;
  v18 = v15;
  sub_1476044E0((__int64 *)(a1 + 0x1228), (__int64)&v15, &v17);
  LeaveCriticalSection(lpCriticalSection);
  return v9;
}

// --- End Function: sub_147603270 (0x147603270) ---

// --- Function: sub_1476034A0 (0x1476034A0) ---
__int64 __fastcall sub_1476034A0(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 n0x10)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 i; // rax
  __int64 v9; // r11
  signed __int32 v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rbp
  unsigned __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r12
  unsigned __int64 v16; // r15
  unsigned __int64 v17; // rax
  _QWORD *v18; // r8
  unsigned __int64 v19; // rax
  int v20; // r9d
  signed __int64 v21; // rdx
  int n2_1; // [rsp+20h] [rbp-48h] BYREF
  __int64 v24; // [rsp+28h] [rbp-40h]
  int n2; // [rsp+78h] [rbp+10h] BYREF
  __int64 v27; // [rsp+80h] [rbp+18h]

  v27 = a3;
  v4 = *(unsigned int *)(a1 + 0x11AC);
  v24 = v4;
  v5 = 0x20 * a3 + a1 + 0x10;
  v6 = a3;
  for ( i = sub_147604610((volatile signed __int64 *)v5); !i; i = sub_147604610((volatile signed __int64 *)v5) )
  {
    v10 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 1, 0) - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        n2 = 2;
        qword_149B3B480(v5 + 0x18, &n2, 4, 0xFFFFFFFFLL);
      }
      else
      {
        v11 = *(_QWORD *)(v5 + 0x10);
        if ( !v11 || 0x2000000LL - *(_QWORD *)(v11 + 0x20) - v4 < a2 )
        {
          sub_147602270(v9, a2, v6);
          v9 = a1;
        }
        v12 = *(_QWORD *)(v5 + 0x10);
        v13 = v12 - v4 + 0x2000000;
        v14 = *(_QWORD *)(v12 + 0x20);
        v15 = v14 + v12;
        if ( v12 + v14 + 0x20 * a2 < v13 )
          v13 = v12 + v14 + 0x20 * a2;
        v16 = ~(v24 - 1) & (v13 - v12 + v4 - 1);
        v17 = *(_QWORD *)(v12 + 0x18);
        if ( v16 > v17 )
        {
          sub_14056DA40(v9 + 0x1198, v17 + v12, v16 - v17);
          *(_QWORD *)(v12 + 0x18) = v16;
        }
        *(_QWORD *)(v12 + 0x20) = v13 - v12;
        v18 = (_QWORD *)(v15 + a2 - 8);
        v19 = v15 + 2 * a2;
        v20 = 1;
        v21 = (signed __int64)v18;
        for ( *v18 = 0; v19 <= v13; v19 += a2 )
        {
          *(_QWORD *)(v19 - 8) = v21;
          ++v20;
          v21 = v19 - 8;
        }
        sub_1476047E0((volatile signed __int64 *)v5, v21, v18, v20);
        if ( _InterlockedExchange((volatile __int32 *)(v5 + 0x18), 0) == 2 )
          qword_149B3B490(v5 + 0x18);
        v6 = v27;
        v4 = v24;
      }
    }
    else if ( (unsigned int)(_InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 2, 1) - 1) <= 1 )
    {
      n2_1 = 2;
      qword_149B3B480(v5 + 0x18, &n2_1, 4, 0xFFFFFFFFLL);
    }
  }
  return i - a2 + 8;
}

// --- End Function: sub_1476034A0 (0x1476034A0) ---

// --- Function: sub_147604610 (0x147604610) ---
__int64 __fastcall sub_147604610(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __int32 v5; // edx
  __m128i v6; // rt0
  signed __int64 v8; // [rsp+18h] [rbp-40h]
  __m128i v9; // [rsp+30h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    LODWORD(v8) = epi64 + 1;
    HIDWORD(v8) = HIDWORD(epi64) - 1;
    v6.m128i_i64[0] = v2.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v8, *(_QWORD *)v2.m128i_i64[0], v6.m128i_i64);
    v4 = v6.m128i_i64[0];
    v5 = v6.m128i_i32[2];
    v9 = v6;
    if ( v6.m128i_i64[0] == v2.m128i_i64[0] && v5 == (_DWORD)epi64 )
      break;
    v2 = v9;
    if ( !v4 )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_147604610 (0x147604610) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6320);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6336);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6320) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 6320);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: __report_rangecheckfailure (0x1480339D0) ---
void __noreturn _report_rangecheckfailure()
{
  _report_securityfailure(8);
}

// --- End Function: __report_rangecheckfailure (0x1480339D0) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

// --- Function: asinf (0x148082227) ---
// attributes: thunk
float __cdecl asinf(float X)
{
  return __imp_asinf(X);
}

// --- End Function: asinf (0x148082227) ---

// --- Function: atan2f (0x14808222D) ---
// attributes: thunk
float __cdecl atan2f(float Y, float X)
{
  return __imp_atan2f(Y, X);
}

// --- End Function: atan2f (0x14808222D) ---

// --- Function: cosf (0x148082233) ---
// attributes: thunk
float __cdecl cosf(float X)
{
  return __imp_cosf(X);
}

// --- End Function: cosf (0x148082233) ---

// --- Function: sinf (0x148082245) ---
// attributes: thunk
float __cdecl sinf(float X)
{
  return __imp_sinf(X);
}

// --- End Function: sinf (0x148082245) ---

// --- Function: sub_1480BE950 (0x1480BE950) ---
__int64 sub_1480BE950()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = NtCurrentTeb_w();
  sub_1402A3D30(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = NtCurrentTeb_w();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0;
  return result;
}

// --- End Function: sub_1480BE950 (0x1480BE950) ---

