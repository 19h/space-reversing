// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1468E0330 (sub_1468E0330)
// Caller Depth: 0
// Callee/Ref Depth: 4
// Total Functions Found: 13
// ------------------------------------------------------------

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1402D0950 (0x1402D0950) ---
unsigned __int64 __fastcall sub_1402D0950(__int64 a1)
{
  unsigned __int64 tls_data_offset_784; // rax
  unsigned __int64 v3; // rdx

  tls_data_offset_784 = get_tls_data_offset_784();
  if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(tls_data_offset_784 + 0x18)
    && (tls_data_offset_784 = *(unsigned int *)(a1 + 0xC), (_DWORD)tls_data_offset_784) )
  {
    tls_data_offset_784 = (unsigned int)(tls_data_offset_784 - 1);
    *(_DWORD *)(a1 + 0xC) = tls_data_offset_784;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      tls_data_offset_784 = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
      {
        return sub_1403C6F70((volatile signed __int64 *)a1, v3);
      }
    }
  }
  return tls_data_offset_784;
}

// --- End Function: sub_1402D0950 (0x1402D0950) ---

// --- Function: is_valid_handle_typeB (0x14030C8B0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *packed_handle_ptr)
{
  unsigned __int64 packed_handle_value; // r9
  __int64 handle_ptr; // r10
  unsigned __int64 handle_flags; // r9
  __int64 mask_from_flag; // rax
  __int64 handle_ptr_copy; // r10
  __int64 metadata_ptr; // rbx
  bool is_thread_state_ok; // al

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_ptr = packed_handle_value & 0xFFFFFFFFFFFFLL;
  handle_flags = HIWORD(packed_handle_value);
  if ( (handle_flags & 0xF000) != 0 )
  {
    mask_from_flag = map_flag_to_mask(0x2000u);
    metadata_ptr = handle_ptr_copy & ~(mask_from_flag - 1);
  }
  else
  {
    metadata_ptr = handle_ptr - 6;
  }
  if ( *(_WORD *)(metadata_ptr + 2) != (handle_flags & 0xFFF) )
  {
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (is_thread_state_ok = is_thread_flag_57_or_38_set()) )
  {
    is_thread_state_ok = 1;
  }
  return *(_WORD *)(metadata_ptr + 4) == 2 && is_thread_state_ok
      || check_handle_access_by_state_extended(packed_handle_ptr) != 0;
}

// --- End Function: is_valid_handle_typeB (0x14030C8B0) ---

// --- Function: map_flag_to_mask (0x140322940) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
      {
        return 0;
      }
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( input_flag == 0x6000 )
        {
          return 0x4000000;
        }
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140322940) ---

// --- Function: check_thread_list_contains_value (0x14038E3B0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 thread_data; // rbx
  unsigned __int64 *v3; // rax
  char *list_begin_1; // r10
  char *list_begin; // rcx
  unsigned __int64 search_value; // rdx
  unsigned __int64 search_range_count; // r8
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) )
  {
    return 0;
  }
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &vf_output_temp);
  list_begin_1 = *(char **)(thread_data + 0x18);
  list_begin = *(char **)(thread_data + 0x10);
  search_value = *v3;
  search_range_count = (list_begin_1 - list_begin) >> 4;
  while ( search_range_count )
  {
    if ( *(_QWORD *)&list_begin[0x10 * (search_range_count >> 1)] >= search_value )
    {
      search_range_count >>= 1;
    }
    else
    {
      list_begin += 0x10 * (search_range_count >> 1) + 0x10;
      search_range_count += 0xFFFFFFFFFFFFFFFFuLL - (search_range_count >> 1);
    }
  }
  if ( list_begin == list_begin_1 )
  {
    return 0;
  }
  if ( search_value < *(_QWORD *)list_begin )
  {
    list_begin = *(char **)(thread_data + 0x18);
  }
  return list_begin != list_begin_1;
}

// --- End Function: check_thread_list_contains_value (0x14038E3B0) ---

// --- Function: validate_access_with_virtual_calls (0x14038E4B0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 thread_data; // rax
  __int64 global_validator_object; // rdi
  __int64 (__fastcall *global_validator_vtable)(__int64, _QWORD); // rbx
  _QWORD *value_from_object_ptr; // rax
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_tls_data_offset_784() )
  {
    return 1;
  }
  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) || !is_illegal_entity_access_check_enabled() )
  {
    return 1;
  }
  global_validator_object = ::global_validator_object;
  global_validator_vtable = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::global_validator_object + 0x3D8LL);
  value_from_object_ptr = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                                      payload_ptr_state2,
                                      &vf_output_temp);
  return global_validator_vtable(global_validator_object, *value_from_object_ptr);
}

// --- End Function: validate_access_with_virtual_calls (0x14038E4B0) ---

// --- Function: check_handle_access_by_state_extended (0x14038E620) ---
// Checks access permissions for the provided packed handle using extended logic.
// Calculates the metadata pointer based on high bits in the packed handle.
// Validates access based on the state field (metadata + 4): - State 0: Returns
// false (invalid). - State 1: Checks if the handle's payload exists in a thread-
// local list using `check_thread_list_contains_value`. - State 2: Returns true if
// specific thread flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3 or 4: Returns
// true if thread data exists, its status field at +8 is 1, and the payload value
// is not equal to the constant 0x13374770CLL. - Other states: Return false.
char __fastcall check_handle_access_by_state_extended(_QWORD *packed_handle_ptr)
{
  _QWORD *handle_payload_ptr; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  handle_payload_ptr = (_QWORD *)(*packed_handle_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*packed_handle_ptr & 0xF000000000000000uLL) != 0 )
  {
    metadata_ptr = *packed_handle_ptr & 0xFFFFFF000000LL;
  }
  else
  {
    metadata_ptr = (__int64)handle_payload_ptr + 0xFFFFFFFA;
  }
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value((__int64)handle_payload_ptr);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(metadata_ptr + 4) - 3 <= 1 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *handle_payload_ptr != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls((__int64)handle_payload_ptr);
  }
}

// --- End Function: check_handle_access_by_state_extended (0x14038E620) ---

// --- Function: sub_1403C6C70 (0x1403C6C70) ---
void __fastcall sub_1403C6C70(volatile signed __int64 *a1, signed __int64 a2, __int64 a3, __int64 a4, char a5)
{
  int *p_n0x1600; // rcx
  int v8; // esi
  bool v9; // zf
  signed __int64 v10; // rax
  int v11; // [rsp+30h] [rbp-61h] BYREF
  _DWORD v12[3]; // [rsp+34h] [rbp-5Dh] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-51h] BYREF
  __int64 v14; // [rsp+44h] [rbp-4Dh]
  int v15; // [rsp+4Ch] [rbp-45h]
  __int64 v16; // [rsp+50h] [rbp-41h]
  unsigned __int64 v17; // [rsp+58h] [rbp-39h]
  __int64 v18; // [rsp+60h] [rbp-31h]
  __int64 v19; // [rsp+68h] [rbp-29h]
  int n0x1600; // [rsp+90h] [rbp-1h] BYREF
  __int64 v21; // [rsp+94h] [rbp+3h]
  int v22; // [rsp+9Ch] [rbp+Bh]
  __int64 v23; // [rsp+A0h] [rbp+Fh]
  unsigned __int64 v24; // [rsp+A8h] [rbp+17h]
  __int64 v25; // [rsp+B0h] [rbp+1Fh]
  __int64 v26; // [rsp+B8h] [rbp+27h]

  if ( a5 && *(_BYTE *)(get_tls_data_offset_784() + 0x1C) && qword_14981D3D8 )
  {
    sub_1403C6E30(a1, a2);
    return;
  }
  if ( (a2 & 0x200000) != 0 )
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
      {
        (*(void (__fastcall **)(__int64, volatile signed __int64 *))(*(_QWORD *)qword_14981D318 + 0x128LL))(
          qword_14981D318,
          a1);
      }
      if ( (a2 & 0x100000) != 0 )
      {
        break;
      }
      v8 = a2 | 0x100000;
      v10 = _InterlockedCompareExchange64(a1, a2 | 0x100000, a2);
      v9 = a2 == v10;
      a2 = v10;
      if ( v9 )
      {
        n0x1600 = 0x1600;
        v21 = 0;
        v22 = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v23 = 1;
        psub_7FF6AAB938D0(
          &n0x1600,
          0,
          &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          0);
        v12[0] = v8;
        off_149808B88(a1, v12, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        p_n0x1600 = &n0x1600;
        v24 = __rdtsc();
        goto LABEL_12;
      }
LABEL_13:
      if ( (a2 & 0x200000) == 0 )
      {
        return;
      }
    }
    n0x1600_1 = 0x1600;
    v14 = 0;
    v15 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v16 = 1;
    psub_7FF6AAB938D0(
      &n0x1600_1,
      0,
      &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      0);
    v11 = a2;
    off_149808B88(a1, &v11, 4, 0xFFFFFFFFLL);
    a2 = *a1;
    p_n0x1600 = &n0x1600_1;
    v17 = __rdtsc();
LABEL_12:
    psub_7FF6AAB93930(p_n0x1600);
    goto LABEL_13;
  }
}

// --- End Function: sub_1403C6C70 (0x1403C6C70) ---

// --- Function: sub_1403C6E30 (0x1403C6E30) ---
double __fastcall sub_1403C6E30(volatile signed __int64 *a1, signed __int64 a2)
{
  __int64 v2; // r14
  __int64 tls_data_offset_784; // rax
  __int64 v6; // rsi
  unsigned int v7; // r15d
  unsigned __int64 v8; // rdx
  signed __int64 v9; // rax
  unsigned __int64 v10; // rcx
  signed __int64 v11; // rax
  signed __int64 v12; // rtt
  double result; // xmm0_8
  _BYTE v14[16]; // [rsp+30h] [rbp-19h] BYREF
  int n0x1600; // [rsp+40h] [rbp-9h] BYREF
  __int64 v16; // [rsp+44h] [rbp-5h]
  int v17; // [rsp+4Ch] [rbp+3h]
  __int64 v18; // [rsp+50h] [rbp+7h]
  unsigned __int64 v19; // [rsp+58h] [rbp+Fh]
  __int64 v20; // [rsp+60h] [rbp+17h]
  __int64 v21; // [rsp+68h] [rbp+1Fh]
  char v22; // [rsp+B8h] [rbp+6Fh] BYREF

  v2 = qword_14981D318;
  tls_data_offset_784 = get_tls_data_offset_784();
  v6 = *(_QWORD *)tls_data_offset_784;
  v7 = *(_DWORD *)(*(_QWORD *)tls_data_offset_784 + 0x1CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v2 + 0xF8LL))(v2, v14, &v22);
  if ( (a2 & 0x200000) != 0 )
  {
    v8 = (unsigned __int64)v7 << 0x20;
    while ( 1 )
    {
      v9 = a2;
      if ( (a2 & 0xFFFF00000000LL) != 0 )
      {
        *(_DWORD *)(v6 + 0x24) = WORD2(a2);
        v10 = v8 | a2 & 0xFFFF0000FFFFFFFFuLL;
        v9 = a2;
      }
      else
      {
        *(_DWORD *)(v6 + 0x24) = 0xFFFFFFFF;
        v10 = a2 | v8;
      }
      v12 = v9;
      v11 = _InterlockedCompareExchange64(a1, v10, v9);
      a2 = v11;
      if ( v12 == v11 )
      {
        break;
      }
      if ( (v11 & 0x200000) == 0 )
      {
        return result;
      }
    }
    n0x1600 = 0x1600;
    v16 = 0;
    v17 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v18 = 1;
    psub_7FF6AAB938D0(
      &n0x1600,
      0,
      &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
      0);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0xE8LL))(v2, v7);
    v19 = __rdtsc();
    return psub_7FF6AAB93930(&n0x1600);
  }
  return result;
}

// --- End Function: sub_1403C6E30 (0x1403C6E30) ---

// --- Function: sub_1403C6F70 (0x1403C6F70) ---
__int64 __fastcall sub_1403C6F70(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned int)(v8 - 1)) + v10 + 0x24);
      if ( v5 != 0xFFFFFFFF )
      {
        v4 |= (unsigned __int64)v5 << 0x30;
      }
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
    {
      break;
    }
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
    {
      return result;
    }
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
  {
    return off_149808B90(a1);
  }
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
      qword_14981D318,
      &v11,
      &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(0xC0LL * ((unsigned int)v7 & (v9 - 1)) + v11 + 0x1C) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D318 + 0xD8LL))(
             qword_14981D318,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: sub_1403C6F70 (0x1403C6F70) ---

// --- Function: is_thread_flag_57_or_38_set (0x140535D40) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 thread_data_ptr_offset_16; // rcx

  thread_data_ptr_offset_16 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  if ( thread_data_ptr_offset_16 )
  {
    return *(_BYTE *)(thread_data_ptr_offset_16 + 0x39) != 0;
  }
  else
  {
    return *(_BYTE *)(get_tls_data_offset_784() + 0x26) != 0;
  }
}

// --- End Function: is_thread_flag_57_or_38_set (0x140535D40) ---

// --- Function: sub_1468DBB60 (0x1468DBB60) ---
__int64 __fastcall sub_1468DBB60(__int64 a1, __int64 a2, unsigned int n2_1, unsigned __int8 n2_2)
{
  int n2; // ebx
  unsigned __int64 *v6; // rcx
  __int64 v9; // rax
  char v11; // di
  char v12; // bp
  __int64 v13; // rbx
  signed __int64 v14; // rdx
  signed __int64 v15; // r12
  bool v16; // zf
  __int64 n0xF0; // rax

  n2 = n2_2;
  v6 = *(unsigned __int64 **)(a1 + 0x128);
  if ( v6 )
  {
    if ( is_valid_handle_typeB(v6) )
    {
      v9 = *(_QWORD *)(a1 + 0x128);
      if ( *(_DWORD *)(v9 + 0x10) == 5 )
      {
        sub_1468DBB60(*(_QWORD *)v9 & 0xFFFFFFFFFFFFLL, a2, n2_1, n2);
        return a2;
      }
    }
  }
  if ( !(_BYTE)n2 || n2 == 2 )
  {
    v11 = 0;
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)pCZoneSystem + 0xE8LL))(pCZoneSystem);
  }
  else
  {
    v11 = 1;
    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD))(*(_QWORD *)pCZoneSystem + 0xE8LL))(pCZoneSystem) )
    {
      v12 = 1;
      v13 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)pCZoneSystem + 0x98LL))(pCZoneSystem);
      if ( *(_DWORD *)(v13 + 8) == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
      {
        ++*(_DWORD *)(v13 + 0xC);
      }
      else
      {
        v14 = _InterlockedIncrement64((volatile signed __int64 *)v13);
        if ( (v14 & 0x200000) != 0 )
        {
          sub_1403C6C70(
            (volatile signed __int64 *)v13,
            v14,
            (__int64)"CEntity::GetPos",
            (__int64)"gEnv->pZoneSystem->GetGlobalStateLock()",
            1);
        }
      }
      goto LABEL_14;
    }
  }
  v12 = 0;
  v13 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)pCZoneSystem + 0x98LL))(pCZoneSystem);
LABEL_14:
  if ( v11 )
  {
    if ( *(_DWORD *)(a1 + 0xC8) == *(_DWORD *)(get_tls_data_offset_784() + 0x18) )
    {
      ++*(_DWORD *)(a1 + 0xCC);
    }
    else
    {
      v15 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0xC0));
      if ( (v15 & 0x200000) != 0 )
      {
        sub_1403C6C70(
          (volatile signed __int64 *)(a1 + 0xC0),
          v15,
          (__int64)"CEntity::GetPos",
          (__int64)"m_cross_ecus_state.updateLock",
          1);
      }
    }
  }
  if ( n2_1 == 2 )
  {
    v16 = v11 == 0;
    n0xF0 = 0xF0;
    if ( !v11 )
    {
      n0xF0 = 0x48;
    }
    *(_OWORD *)a2 = *(_OWORD *)(n0xF0 + a1);
    *(double *)(a2 + 0x10) = *(double *)(n0xF0 + a1 + 0x10);
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(*(_QWORD *)pCZoneSystem + 0x2D8LL))(
      pCZoneSystem,
      a2,
      a1 + 0x2A0,
      n2_1);
    v16 = v11 == 0;
  }
  if ( !v16 )
  {
    sub_1402D0950(a1 + 0xC0);
  }
  if ( v12 )
  {
    sub_1402D0950(v13);
  }
  return a2;
}

// --- End Function: sub_1468DBB60 (0x1468DBB60) ---

// --- Function: sub_1468E0330 (0x1468E0330) ---
__int64 __fastcall sub_1468E0330(__int64 a1, __int64 a2, unsigned __int8 n2)
{
  sub_1468DBB60(a1, a2, 0, n2);
  return a2;
}

// --- End Function: sub_1468E0330 (0x1468E0330) ---

