// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1454048C0 (HandleFetchShipDataResult)
// Caller Depth: 1
// Callee/Ref Depth: 8
// Total Functions Found: 373
// ------------------------------------------------------------

// --- Function: identity_int64 (0x1402A24F0) ---
// This function is a simple identity function that returns its single __int64
// argument unchanged. It effectively acts as a pass-through.
__int64 __fastcall identity_int64(__int64 a1)
{
  return a1;
}

// --- End Function: identity_int64 (0x1402A24F0) ---

// --- Function: _Current_set (0x1402A2500) ---
bool __fastcall Current_set(unsigned __int8 **a1, _QWORD *a2)
{
  return (unsigned int)sub_1403E4780(a1, a2) == 0;
}

// --- End Function: _Current_set (0x1402A2500) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: sub_1402A2AD0 (0x1402A2AD0) ---
__int64 __fastcall sub_1402A2AD0(_QWORD *a1)
{
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 result; // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *))a1[1];
  if ( (unsigned __int64)n2 < 2 )
  {
    result = 0;
    *a1 = 0;
  }
  else
  {
    n2(2, a1);
    result = 0;
    a1[1] = 0;
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_1402A2AD0 (0x1402A2AD0) ---

// --- Function: sub_1402A2B80 (0x1402A2B80) ---
__int64 __fastcall sub_1402A2B80(__int64 a1, __int64 a2)
{
  return a2;
}

// --- End Function: sub_1402A2B80 (0x1402A2B80) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---
bool __fastcall AK::WriteBytesCount::Reserve(AK::WriteBytesCount *this)
{
  return 0;
}

// --- End Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---
_QWORD *__fastcall std::_Allocate<16,std::_Default_allocate_traits,0>(unsigned __int64 _Bytes)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  _QWORD *result; // rax

  if ( _Bytes < 0x1000 )
  {
    if ( _Bytes )
      return (_QWORD *)allocWithProfilerInfo_w(_Bytes);
    else
      return 0;
  }
  else
  {
    if ( _Bytes + 0x27 < _Bytes )
      sub_1402E1170();
    v1 = allocWithProfilerInfo_w(_Bytes + 0x27);
    v2 = v1;
    if ( !v1 )
      invalid_parameter_noinfo_noreturn();
    result = (_QWORD *)((v1 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    result[0xFFFFFFFF] = v2;
  }
  return result;
}

// --- End Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---

// --- Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A60C0) ---
void __fastcall std::_Deallocate<16,0>(_QWORD *a1, unsigned __int64 n0x1000)
{
  if ( n0x1000 >= 0x1000 )
  {
    if ( (unsigned __int64)a1 - a1[0xFFFFFFFF] - 8 > 0x1F )
      invalid_parameter_noinfo_noreturn();
    a1 = (_QWORD *)a1[0xFFFFFFFF];
  }
  sub_1402A3D30(a1);
}

// --- End Function: ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z (0x1402A60C0) ---

// --- Function: sub_1402A6620 (0x1402A6620) ---
char *__fastcall sub_1402A6620(__int64 a1, _QWORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _QWORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  char *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 0x10);
  if ( v2 == v4 )
  {
    v7 = 0x1FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*(_QWORD *)a1] >> 3;
    if ( v8 == 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = (__int64)&v4[-*(_QWORD *)a1] >> 3;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_QWORD *)sub_140391AB0(a1, 8 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = *(char **)(a1 + 8);
    v16 = *(char **)a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 8;
      Size = *(_QWORD *)(a1 + 8) - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *(_QWORD *)a1 )
      sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_QWORD *)a1 = v13;
    result = v17;
    *(_QWORD *)(a1 + 8) = &v13[v11];
    *(_QWORD *)(a1 + 0x10) = &v13[v12];
  }
  else
  {
    *(_QWORD *)v2 = *a2;
    result = *(char **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result + 8;
  }
  return result;
}

// --- End Function: sub_1402A6620 (0x1402A6620) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 39 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 39);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 - 1) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: sub_1402ABD50 (0x1402ABD50) ---
// attributes: thunk
void __fastcall sub_1402ABD50(_QWORD *a1)
{
  sub_140370D10(a1);
}

// --- End Function: sub_1402ABD50 (0x1402ABD50) ---

// --- Function: unknown_libname_2 (0x1402ADBA0) ---
// Microsoft VisualC v14 64bit runtime
_QWORD *__fastcall unknown_libname_2(_QWORD *a1, _QWORD *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

// --- End Function: unknown_libname_2 (0x1402ADBA0) ---

// --- Function: unknown_libname_472 (0x1402AE2A0) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_472(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_472 (0x1402AE2A0) ---

// --- Function: sub_1402AE3D0 (0x1402AE3D0) ---
__int64 *__fastcall sub_1402AE3D0(__int64 *a1, const char *a2, __int64 a3, char a4)
{
  *a1 = a3;
  sub_1402CD240(a3, a2, a4);
  return a1;
}

// --- End Function: sub_1402AE3D0 (0x1402AE3D0) ---

// --- Function: sub_1402B1640 (0x1402B1640) ---
void __fastcall sub_1402B1640(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: sub_1402B1640 (0x1402B1640) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: sub_1402B1820 (0x1402B1820) ---
const ULONG_PTR *__fastcall sub_1402B1820(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v4; // eax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 0x14);
  if ( v2 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v4 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v1, v4);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402B1820 (0x1402B1820) ---

// --- Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B2210) ---
void __fastcall std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>(
        std::shared_ptr<std::vector<char> > *this)
{
  volatile signed __int32 *v1; // rbx

  v1 = (volatile signed __int32 *)*((_QWORD *)this + 1);
  if ( v1 && _InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
    if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
  }
}

// --- End Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B2210) ---

// --- Function: sub_1402B2810 (0x1402B2810) ---
__int64 __fastcall sub_1402B2810(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)a1 )
  {
    sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_1402B2810 (0x1402B2810) ---

// --- Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B4910) ---
std::shared_ptr<vraudio::MixerNode> *__fastcall std::shared_ptr<vraudio::MixerNode>::operator=(
        std::shared_ptr<vraudio::MixerNode> *this,
        std::shared_ptr<vraudio::MixerNode> *_Right)
{
  __int64 v2; // rax
  __int64 v4; // r8
  volatile signed __int32 *v5; // rbx

  v2 = *(_QWORD *)_Right;
  v4 = *((_QWORD *)_Right + 1);
  *(_QWORD *)_Right = 0;
  *((_QWORD *)_Right + 1) = 0;
  v5 = (volatile signed __int32 *)*((_QWORD *)this + 1);
  *(_QWORD *)this = v2;
  *((_QWORD *)this + 1) = v4;
  if ( !v5 )
    return this;
  if ( _InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
    if ( _InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
  }
  return this;
}

// --- End Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B4910) ---

// --- Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B4B80) ---
bool __fastcall std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B4B80) ---

// --- Function: unknown_libname_6 (0x1402BC360) ---
// Microsoft VisualC v14 64bit runtime
_QWORD *__fastcall unknown_libname_6(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a1 = *a2;
  a1[1] = *a3;
  return a1;
}

// --- End Function: unknown_libname_6 (0x1402BC360) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402CD240 (0x1402CD240) ---
__int64 __fastcall sub_1402CD240(__int64 a1, const char *a2, char a3)
{
  __int64 result; // rax
  int v7; // edi
  unsigned __int32 v8; // eax

  result = NtCurrentTeb_w();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v8 )
    {
      result = sub_1403C33A0(a1, v8, a2, a3);
    }
    else
    {
      result = NtCurrentTeb_w();
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v7;
  }
  return result;
}

// --- End Function: sub_1402CD240 (0x1402CD240) ---

// --- Function: sub_1402D2790 (0x1402D2790) ---
unsigned __int64 __fastcall sub_1402D2790(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(result + 24) && (result = *(unsigned int *)(a1 + 20), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 20) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CB820((volatile signed __int64 *)a1, v3);
    }
  }
  return result;
}

// --- End Function: sub_1402D2790 (0x1402D2790) ---

// --- Function: sub_1402DB100 (0x1402DB100) ---
const ULONG_PTR *__fastcall sub_1402DB100(__int64 a1)
{
  unsigned __int32 v1; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  v1 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
  if ( v1 != 1 )
    return sub_1403DB1F0(a1, v1);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402DB100 (0x1402DB100) ---

// --- Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
        __int64 **a1,
        __int64 a2,
        __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 0x18) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 0x18LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 0x18) )
      {
        v13 = *(_QWORD **)(v9 + 0x10);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 0x10) = *v13;
          if ( !*(_BYTE *)(*v13 + 0x19LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 0x10LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 0x19) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v12 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 0x18) )
      {
        v19 = *(_QWORD *)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = *(_QWORD *)(v19 + 0x10);
          v20 = *(_QWORD *)(v19 + 0x10);
          if ( !*(_BYTE *)(v20 + 0x19) )
            *(_QWORD *)(v20 + 8) = v9;
          *(_QWORD *)(v19 + 8) = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(__int64 **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          *(_QWORD *)(v19 + 0x10) = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 0x19LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v11 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 0x18) = 1;
  return a3;
}

// --- End Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_7 (0x1402E11B0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402E11B0) ---

// --- Function: unknown_libname_9 (0x1402E1F70) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E1F70) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E23C0) ---
_QWORD *__fastcall std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
        _QWORD *a1,
        _QWORD *a2)
{
  *a2 = *a1;
  return a2;
}

// --- End Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E23C0) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: NtCurrentTeb_ww_0 (0x1402E2480) ---
__int64 NtCurrentTeb_ww_0()
{
  return *(unsigned __int8 *)(NtCurrentTeb_w() + 0x12D);
}

// --- End Function: NtCurrentTeb_ww_0 (0x1402E2480) ---

// --- Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---
// Microsoft VisualC v14 64bit runtime
__int64 __fastcall __crt_strtox::maximum_signed_value(__crt_strtox *this)
{
  return 0x7FFFFFFFFFFFFFFFLL;
}

// --- End Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FAA80 (0x1402FAA80) ---
_QWORD *__fastcall sub_1402FAA80(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v3; // r9
  __int64 v4; // r8
  _QWORD *result; // rax

  v2 = *a2;
  v3 = a2[2];
  v4 = a2[1];
  a2[2] = 0;
  a2[1] = 0;
  *a2 = 0;
  *a1 = v2;
  result = a1;
  a1[1] = v4;
  a1[2] = v3;
  return result;
}

// --- End Function: sub_1402FAA80 (0x1402FAA80) ---

// --- Function: sub_1402FB060 (0x1402FB060) ---
__int64 *__fastcall sub_1402FB060(__int64 *a1, ARLabelMovementType *a2)
{
  unsigned __int64 n0xF; // rdx
  _QWORD *v5; // rcx
  __int64 *result; // rax

  if ( a1 != (__int64 *)a2 )
  {
    n0xF = a1[3];
    if ( n0xF > 0xF )
    {
      v5 = (_QWORD *)*a1;
      if ( n0xF + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v5 - v5[0xFFFFFFFF] - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v5 = (_QWORD *)v5[0xFFFFFFFF];
      }
      sub_1402A3D30(v5);
    }
    a1[3] = 0xF;
    a1[2] = 0;
    *(_BYTE *)a1 = 0;
    *(__m256i *)a1 = *(__m256i *)a2;
    *((_QWORD *)a2 + 2) = 0;
    *((_QWORD *)a2 + 3) = 0xF;
    *(_BYTE *)a2 = 0;
  }
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FB060 (0x1402FB060) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n22 = 22;
  if ( n22 + 1 >= 0x1000 )
  {
    allocSize = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n22 == -1 )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FBA60 (0x1402FBA60) ---
__int64 __fastcall sub_1402FBA60(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  _OWORD *v3; // r14
  unsigned __int64 n0xF; // rsi
  __int64 n22; // rdi
  unsigned __int64 allocSize; // rax
  __int64 v8; // rax
  __int64 v9; // rcx

  v2 = 0;
  v3 = (_OWORD *)a2;
  *(_OWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  n0xF = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)(a2 + 24) > 0xFu )
    v3 = *(_OWORD **)a2;
  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( n0xF > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  *(_QWORD *)(a1 + 24) = 15;
  if ( n0xF > 0xF )
  {
    if ( (n0xF | 0xF) <= 0x7FFFFFFFFFFFFFFFLL )
    {
      n22 = n0xF | 0xF;
      if ( (n0xF | 0xF) < 0x16 )
        n22 = 22;
      if ( (unsigned __int64)(n22 + 1) < 0x1000 )
      {
        if ( n22 != -1 )
          v2 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
        goto LABEL_18;
      }
      allocSize = n22 + 40;
      if ( n22 + 40 < (unsigned __int64)(n22 + 1) )
        sub_1402E1170();
    }
    else
    {
      allocSize = 0x8000000000000027uLL;
    }
    v8 = allocWithProfilerInfo_w(allocSize);
    v9 = v8;
    if ( !v8 )
      invalid_parameter_noinfo_noreturn();
    v2 = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v2 - 1) = v9;
LABEL_18:
    *(_QWORD *)a1 = v2;
    *(_QWORD *)(a1 + 16) = n0xF;
    *(_QWORD *)(a1 + 24) = n22;
    memcpy(v2, v3, n0xF + 1);
    return a1;
  }
  *(_QWORD *)(a1 + 16) = n0xF;
  *(_OWORD *)a1 = *v3;
  return a1;
}

// --- End Function: sub_1402FBA60 (0x1402FBA60) ---

// --- Function: sub_1402FD310 (0x1402FD310) ---
__int64 __fastcall sub_1402FD310(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  if ( a4 < a5 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(a3 + 112 * a4 + 24))(
             *(_QWORD *)(a3 + 112 * a4),
             a1,
             a2,
             a4 - a5 + 1);
  else
    return 0;
}

// --- End Function: sub_1402FD310 (0x1402FD310) ---

// --- Function: sub_1402FD350 (0x1402FD350) ---
__int64 __fastcall sub_1402FD350(_BYTE *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  _BYTE v6[24]; // [rsp+40h] [rbp-18h] BYREF

  return sub_1402FF680((__int64)v6, a1, a2, a3, a4, a5);
}

// --- End Function: sub_1402FD350 (0x1402FD350) ---

// --- Function: sub_1402FD760 (0x1402FD760) ---
unsigned __int64 __fastcall sub_1402FD760(__int64 *a1, __int64 *a2, __int64 *a3)
{
  __int64 v3; // r10
  __int64 v5; // rcx
  unsigned __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  unsigned __int64 result; // rax
  __int64 v11; // r8

  v3 = *a2;
  v5 = *a1;
  v7 = *(_QWORD *)(*a2 + 8);
  if ( v7 < *(_QWORD *)(v5 + 8) || v7 == *(_QWORD *)(v5 + 8) && *(_QWORD *)(v3 + 0x50) < *(_QWORD *)(v5 + 0x50) )
  {
    *a2 = v5;
    *a1 = v3;
  }
  v8 = *a3;
  v9 = *a2;
  result = *(_QWORD *)(*a3 + 8);
  if ( result < *(_QWORD *)(*a2 + 8)
    || result == *(_QWORD *)(*a2 + 8) && (result = *(_QWORD *)(v9 + 0x50), *(_QWORD *)(v8 + 0x50) < result) )
  {
    *a3 = v9;
    *a2 = v8;
    v11 = *a1;
    result = *(_QWORD *)(v8 + 8);
    if ( result < *(_QWORD *)(*a1 + 8)
      || result == *(_QWORD *)(*a1 + 8) && (result = *(_QWORD *)(v11 + 0x50), *(_QWORD *)(v8 + 0x50) < result) )
    {
      *a2 = v11;
      *a1 = v8;
    }
  }
  return result;
}

// --- End Function: sub_1402FD760 (0x1402FD760) ---

// --- Function: sub_1402FD7E0 (0x1402FD7E0) ---
__int64 **__fastcall sub_1402FD7E0(__int64 **a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v6; // rcx
  __int64 *v7; // rbx
  __int64 n40; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 *v12; // rbp
  __int64 *v13; // rdx
  __int64 *v14; // r8
  __int64 *v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // r9
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  __int64 *v24; // rdx
  __int64 *v25; // r9
  __int64 v26; // rsi
  __int64 v27; // rdi
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r10
  __int64 v30; // rax
  bool v31; // zf
  __int64 *v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rsi
  unsigned __int64 v35; // rdi
  unsigned __int64 v36; // r11
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 **result; // rax

  v6 = a2;
  v7 = &a2[(__int64)(a3 - (_QWORD)a2) >> 4];
  n40 = (__int64)(a3 - 8 - (_QWORD)a2) >> 3;
  if ( n40 <= 40 )
  {
    v14 = (__int64 *)(a3 - 8);
  }
  else
  {
    v9 = (n40 + 1) >> 3;
    v10 = 16 * v9;
    v11 = 8 * v9;
    v12 = &a2[v9];
    sub_1402FD760(a2, v12, &a2[2 * v9]);
    sub_1402FD760(&v7[v11 / 0xFFFFFFFFFFFFFFF8uLL], v7, &v7[(unsigned __int64)v11 / 8]);
    sub_1402FD760((__int64 *)(a3 - 8 - v10), (__int64 *)(a3 - 8 - v11), (__int64 *)(a3 - 8));
    v14 = v13;
    v6 = v12;
  }
  sub_1402FD760(v6, v7, v14);
  v15 = v7 + 1;
  if ( a2 < v7 )
  {
    v16 = *v7;
    do
    {
      v17 = *(v7 - 1);
      v18 = *(_QWORD *)(v16 + 8);
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 < v18 || v19 == v18 && *(_QWORD *)(v17 + 80) < *(_QWORD *)(v16 + 80) )
        break;
      if ( v18 < v19 || v18 == v19 && *(_QWORD *)(v16 + 80) < *(_QWORD *)(v17 + 80) )
        break;
      --v7;
      v16 = v17;
    }
    while ( a2 < v7 );
  }
  if ( (unsigned __int64)v15 < a3 )
  {
    v20 = *v7;
    v21 = *(_QWORD *)(*v7 + 8);
    do
    {
      v22 = *v15;
      v23 = *(_QWORD *)(*v15 + 8);
      if ( v23 < v21 || v23 == v21 && *(_QWORD *)(v22 + 80) < *(_QWORD *)(v20 + 80) )
        break;
      if ( v21 < v23 || v21 == v23 && *(_QWORD *)(v20 + 80) < *(_QWORD *)(v22 + 80) )
        break;
      ++v15;
    }
    while ( (unsigned __int64)v15 < a3 );
  }
  v24 = v15;
  v25 = v7;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( (unsigned __int64)v24 < a3 )
      {
        v26 = *v24;
        v27 = *v7;
        v28 = *(_QWORD *)(*v24 + 8);
        v29 = *(_QWORD *)(*v7 + 8);
        if ( v29 >= v28 && (v29 != v28 || *(_QWORD *)(v27 + 80) >= *(_QWORD *)(v26 + 80)) )
        {
          if ( v28 < v29 || v28 == v29 && *(_QWORD *)(v26 + 80) < *(_QWORD *)(v27 + 80) )
            break;
          if ( v15 != v24 )
          {
            v30 = *v15;
            *v15 = v26;
            *v24 = v30;
          }
          ++v15;
        }
        ++v24;
      }
      v31 = v25 == a2;
      if ( v25 <= a2 )
        goto LABEL_46;
      v32 = v25 - 1;
      while ( 1 )
      {
        v33 = *v7;
        v34 = *v32;
        v35 = *(_QWORD *)(*v7 + 8);
        v36 = *(_QWORD *)(*v32 + 8);
        if ( v36 >= v35 && (v36 != v35 || *(_QWORD *)(v34 + 80) >= *(_QWORD *)(v33 + 80)) )
          break;
LABEL_44:
        --v25;
        --v32;
        if ( a2 >= v25 )
          goto LABEL_45;
      }
      if ( v35 >= v36 && (v35 != v36 || *(_QWORD *)(v33 + 80) >= *(_QWORD *)(v34 + 80)) )
      {
        if ( --v7 != v32 )
        {
          v37 = *v7;
          *v7 = v34;
          *v32 = v37;
        }
        goto LABEL_44;
      }
LABEL_45:
      v31 = v25 == a2;
LABEL_46:
      if ( !v31 )
      {
        --v25;
        if ( v24 == (__int64 *)a3 )
        {
          if ( v25 != --v7 )
          {
            v40 = *v25;
            *v25 = *v7;
            *v7 = v40;
          }
          v41 = *--v15;
          v42 = *v7;
          *v7 = v41;
          *v15 = v42;
        }
        else
        {
          v43 = *v24;
          *v24++ = *v25;
          *v25 = v43;
        }
        continue;
      }
      break;
    }
    if ( v24 != (__int64 *)a3 )
    {
      if ( v15 != v24 )
      {
        v38 = *v7;
        *v7 = *v15;
        *v15 = v38;
      }
      ++v15;
      v39 = *v7;
      *v7++ = *v24;
      *v24++ = v39;
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v7;
  a1[1] = v15;
  return result;
}

// --- End Function: sub_1402FD7E0 (0x1402FD7E0) ---

// --- Function: sub_1402FDAA0 (0x1402FDAA0) ---
unsigned __int64 __fastcall sub_1402FDAA0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rdi
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r11
  __int64 v11; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 n2; // rax
  unsigned __int64 v15; // r11
  __int64 v16; // rcx
  __int64 v17; // r8
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v10 = 2 * v9;
      v11 = *(_QWORD *)(a1 + 16 * v9 + 16);
      v12 = *(_QWORD *)(a1 + 16 * v9 + 8);
      v13 = *(_QWORD *)(v11 + 8);
      if ( v13 < *(_QWORD *)(v12 + 8) || v13 == *(_QWORD *)(v12 + 8) && *(_QWORD *)(v11 + 80) < *(_QWORD *)(v12 + 80) )
        n2 = 1;
      else
        n2 = 2;
      v9 = v10 + n2;
      *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * (v10 + n2));
      a2 = v10 + n2;
    }
    while ( v10 + n2 < v5 );
  }
  if ( v9 == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v8 >= a2 )
  {
    result = *a4;
    *(_QWORD *)(a1 + 8 * a2) = *a4;
  }
  else
  {
    while ( 1 )
    {
      v15 = *a4;
      v16 = (a2 - 1) >> 1;
      v17 = *(_QWORD *)(a1 + 8 * v16);
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(*a4 + 8) )
      {
        if ( result != *(_QWORD *)(*a4 + 8) )
          break;
        result = *(_QWORD *)(v15 + 80);
        if ( *(_QWORD *)(v17 + 80) >= result )
          break;
      }
      *(_QWORD *)(a1 + 8 * a2) = v17;
      a2 = (a2 - 1) >> 1;
      if ( v8 >= v16 )
      {
        result = *a4;
        *(_QWORD *)(a1 + 8 * v16) = *a4;
        return result;
      }
    }
    *(_QWORD *)(a1 + 8 * a2) = v15;
  }
  return result;
}

// --- End Function: sub_1402FDAA0 (0x1402FDAA0) ---

// --- Function: sub_1402FDB90 (0x1402FDB90) ---
unsigned __int64 __fastcall sub_1402FDB90(__int64 *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  _QWORD *v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v7 = ((__int64)v2 - *a1) / 112;
  if ( a2 < v7 )
  {
    v8 = v4 + 112 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 112 )
    {
      if ( *(_BYTE *)(i + 88) )
      {
        if ( *(_QWORD *)i )
          result = (*(__int64 (**)(void))(i + 64))();
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
    return result;
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v11 = v10 / 112;
  if ( a2 > v10 / 112 )
  {
    if ( a2 > 0x249249249249249LL )
      unknown_libname_10();
    v12 = v11 >> 1;
    if ( v11 <= 0x249249249249249LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x249249249249249LL )
          goto LABEL_29;
      }
      else
      {
        v13 = a2;
      }
      allocSize = 112 * v13;
      if ( 112 * v13 < 0x1000 )
      {
        if ( allocSize )
          v16 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
        else
          v16 = 0;
LABEL_23:
        v17 = &v16[14 * v7];
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 14;
            --v18;
          }
          while ( v18 );
        }
        sub_1402FE290(*a1, a1[1], v16);
        return sub_1402FFAF0(a1, (__int64)v16, a2, v13);
      }
      if ( allocSize + 39 >= allocSize )
      {
        v15 = allocWithProfilerInfo_w(allocSize + 39);
        if ( !v15 )
          invalid_parameter_noinfo_noreturn();
        v16 = (_QWORD *)((v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v16 - 1) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402E1170();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 14;
  }
  a1[1] = (__int64)v2;
  return result;
}

// --- End Function: sub_1402FDB90 (0x1402FDB90) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)v8 + 80LL) )
          {
            n256 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i - 1);
              i -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                  break;
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30-- - v8) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: sub_1402FE290 (0x1402FE290) ---
_QWORD *__fastcall sub_1402FE290(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v4; // r8
  char *v5; // r9
  __int64 v6; // rax
  __int64 v7; // rax

  if ( a1 != a2 )
  {
    v4 = a1 + 0x10;
    v5 = (char *)a3 - a1;
    do
    {
      *a3 = 0;
      v6 = *(_QWORD *)(v4 - 0x10);
      v4 += 0x70;
      *a3 = v6;
      a3 += 0xE;
      v7 = *(_QWORD *)(v4 - 0x78);
      *(_QWORD *)(v4 - 0x80) = 0;
      *(_QWORD *)&v5[v4 - 0x78] = v7;
      *(_QWORD *)&v5[v4 - 0x70] = *(_QWORD *)(v4 - 0x70);
      *(_QWORD *)&v5[v4 - 0x68] = *(_QWORD *)(v4 - 0x68);
      *(_QWORD *)&v5[v4 - 0x60] = *(_QWORD *)(v4 - 0x60);
      *(_QWORD *)&v5[v4 - 0x50] = *(_QWORD *)(v4 - 0x50);
      *(_QWORD *)&v5[v4 - 0x58] = *(_QWORD *)(v4 - 0x58);
      *(_QWORD *)&v5[v4 - 0x48] = *(_QWORD *)(v4 - 0x48);
      *(_QWORD *)&v5[v4 - 0x40] = *(_QWORD *)(v4 - 0x40);
      *(_QWORD *)&v5[v4 - 0x38] = *(_QWORD *)(v4 - 0x38);
      *(_QWORD *)&v5[v4 - 0x30] = *(_QWORD *)(v4 - 0x30);
      v5[v4 - 0x28] = *(_BYTE *)(v4 - 0x28);
      v5[v4 - 0x27] = *(_BYTE *)(v4 - 0x27);
      *(_QWORD *)&v5[v4 - 0x20] = *(_QWORD *)(v4 - 0x20);
      *(_QWORD *)&v5[v4 - 0x18] = *(_QWORD *)(v4 - 0x18);
    }
    while ( v4 - 0x10 != a2 );
  }
  return a3;
}

// --- End Function: sub_1402FE290 (0x1402FE290) ---

// --- Function: sub_1402FE6B0 (0x1402FE6B0) ---
__int64 __fastcall sub_1402FE6B0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
      return 0xFFFFFFFFLL;
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAu;
    *(_BYTE *)(v6 + v5) = v9 + 48;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_1402FE6B0 (0x1402FE6B0) ---

// --- Function: sub_1402FE770 (0x1402FE770) ---
__int64 __fastcall sub_1402FE770(
        double *Buffer,
        unsigned __int64 Size,
        __int64 a3,
        const void **a4,
        const void **a5,
        const void **a6,
        _BYTE *p_])
{
  _BYTE *v7; // rdi
  size_t Size_1; // rbx
  char *v12; // rcx
  size_t Size_2; // rsi
  size_t Size_3; // rdi
  __int64 v15; // r14
  _BYTE *v16; // rsi
  char *v17; // rcx
  size_t Size_4; // rbp
  int v19; // eax
  int v20; // ecx
  __int64 result; // rax

  v7 = *a4;
  Size_1 = -1;
  do
    ++Size_1;
  while ( v7[Size_1] );
  if ( Size_1 + a3 >= Size )
    return 0xFFFFFFFFLL;
  v12 = (char *)Buffer + a3;
  Size_2 = Size - a3;
  if ( Size_1 )
  {
    if ( !v12 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v7 && Size_2 >= Size_1 )
    {
      memcpy(v12, *a4, Size_1);
    }
    else
    {
      memset(v12, 0, Size - a3);
      if ( !v7 )
        goto LABEL_6;
      if ( Size_2 < Size_1 )
      {
        *errno() = 34;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size_1 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  Size_3 = -1;
  v15 = a3 + (int)Size_1;
  v16 = *a5;
  do
    ++Size_3;
  while ( v16[Size_3] );
  if ( Size_3 + v15 >= Size )
    return 0xFFFFFFFFLL;
  v17 = (char *)Buffer + v15;
  Size_4 = Size - v15;
  if ( !Size_3 )
    goto LABEL_28;
  if ( !v17 )
    goto LABEL_20;
  if ( v16 && Size_4 >= Size_3 )
  {
    memcpy(v17, *a5, Size_3);
  }
  else
  {
    memset(v17, 0, Size - v15);
    if ( !v16 )
    {
LABEL_20:
      *errno() = 22;
LABEL_27:
      invalid_parameter_noinfo();
      goto LABEL_28;
    }
    if ( Size_4 < Size_3 )
    {
      *errno() = 34;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( (Size_3 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v19 = sub_1402FE920(Buffer, Size, v15 + (int)Size_3, a6, p_]);
  if ( v19 < 0 )
    return 0xFFFFFFFFLL;
  v20 = Size_3 + v19;
  result = (unsigned int)(Size_1 + Size_3 + v19);
  if ( v20 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_1402FE770 (0x1402FE770) ---

// --- Function: sub_1402FE920 (0x1402FE920) ---
__int64 __fastcall sub_1402FE920(double *Buffer, unsigned __int64 n0xF, __int64 a3, const void **a4, _BYTE *_)
{
  _BYTE *v5; // rsi
  size_t Size; // rbx
  char *v10; // rcx
  size_t Size_1; // rbp
  __int64 v12; // rcx
  size_t Size_2; // rdi
  _BYTE *v14; // rcx

  v5 = *a4;
  Size = -1;
  do
    ++Size;
  while ( v5[Size] );
  if ( Size + a3 >= n0xF )
    return 0xFFFFFFFFLL;
  v10 = (char *)Buffer + a3;
  Size_1 = n0xF - a3;
  if ( !Size )
    goto LABEL_14;
  if ( !v10 )
    goto LABEL_6;
  if ( v5 && Size_1 >= Size )
  {
    memcpy(v10, v5, Size);
  }
  else
  {
    memset(v10, 0, n0xF - a3);
    if ( !v5 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( Size_1 < Size )
    {
      *errno() = 34;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v12 = a3 + (int)Size;
  if ( v12 + 1 >= n0xF )
    return 0xFFFFFFFFLL;
  Size_2 = n0xF - v12;
  v14 = (char *)Buffer + v12;
  if ( !v14 )
  {
LABEL_17:
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(Size + 1);
  }
  if ( _ && Size_2 )
  {
    *v14 = *_;
    return (unsigned int)(Size + 1);
  }
  else
  {
    memset(v14, 0, Size_2);
    if ( !_ )
      goto LABEL_17;
    if ( !Size_2 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(Size + 1);
  }
}

// --- End Function: sub_1402FE920 (0x1402FE920) ---

// --- Function: sub_1402FEA70 (0x1402FEA70) ---
__int64 __fastcall sub_1402FEA70(double *Buffer, unsigned __int64 n0xF, __int64 a3, char *p____EVT_COUNT__:, int *a5)
{
  unsigned __int64 n0xD; // rdi
  char *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r10
  int v13; // ecx
  int v14; // r9d
  __int64 v15; // rdi
  __int64 i; // r8
  __int64 v17; // r11
  int v18; // eax
  char *v19; // r8
  char *v20; // rax
  __int64 v21; // r10
  char v22; // cl
  char v23; // dl
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v10 = (char *)Buffer + a3;
  if ( !v10 )
    goto LABEL_3;
  if ( p____EVT_COUNT__: && n0xD >= 0xD )
  {
    *(double *)v10 = *(double *)p____EVT_COUNT__:;
    *((_DWORD *)v10 + 2) = *((_DWORD *)p____EVT_COUNT__: + 2);
    v10[0xC] = p____EVT_COUNT__:[0xC];
    goto LABEL_11;
  }
  memset(v10, 0, n0xF - a3);
  if ( p____EVT_COUNT__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v11 = n0xF - (a3 + 0xD);
  v12 = (__int64)Buffer + a3 + 0xD;
  v13 = *a5;
  if ( *a5 >= 0 )
  {
    v14 = 0;
  }
  else if ( v11 )
  {
    *(_BYTE *)v12 = 0x2D;
    v13 = -v13 & 0x7FFFFFFF;
    v14 = 1;
  }
  else
  {
    v14 = 0xFFFFFFFF;
  }
  v15 = v14;
  for ( i = v14; ; ++i )
  {
    v17 = v14;
    if ( v14 >= (int)v11 || i < 0 )
      break;
    ++v14;
    v18 = v13 % 0xA;
    v13 /= 0xA;
    *(_BYTE *)(i + v12) = v18 + 0x30;
    if ( !v13 )
    {
      if ( v15 < v17 )
      {
        v19 = (char *)(v17 + v12);
        v20 = (char *)(v15 + v12);
        v21 = -v12;
        do
        {
          v22 = *v19--;
          v23 = *v20;
          *v20++ = v22;
          v19[1] = v23;
        }
        while ( (__int64)&v20[v21] < (__int64)&v19[v21] );
      }
      result = (unsigned int)(v14 + 0xD);
      if ( v14 >= 0 )
        return result;
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEA70 (0x1402FEA70) ---

// --- Function: sub_1402FEBF0 (0x1402FEBF0) ---
__int64 __fastcall sub_1402FEBF0(
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a3,
        char *p____@severity__:,
        unsigned int *p_n0xF,
        char *___severity__:_,
        const void **a7,
        char *p______tags__:[)
{
  unsigned __int64 n0xD; // rbx
  char *v13; // rcx
  int v14; // ebx
  __int64 v15; // rsi
  __int64 v16; // rcx
  unsigned int n0xF_1; // r9d
  __int64 v18; // r8
  __int64 v19; // r11
  unsigned int v20; // eax
  char *v21; // rdx
  __int64 v22; // r9
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v13 = (char *)Buffer + a3;
  if ( !v13 )
    goto LABEL_3;
  if ( p____@severity__: && n0xD >= 0xD )
  {
    *(double *)v13 = *(double *)p____@severity__:;
    *((_DWORD *)v13 + 2) = *((_DWORD *)p____@severity__: + 2);
    v13[0xC] = p____@severity__:[0xC];
    goto LABEL_11;
  }
  memset(v13, 0, n0xF - a3);
  if ( p____@severity__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v14 = 0;
  v15 = a3 + 0xD;
  v16 = 0;
  n0xF_1 = *p_n0xF;
  v18 = (__int64)Buffer + v15;
  while ( 1 )
  {
    v19 = v14;
    if ( v14 >= (int)n0xF - (int)v15 || v16 < 0 )
      break;
    ++v14;
    v20 = n0xF_1 % 0xA;
    n0xF_1 /= 0xAu;
    *(_BYTE *)(v16 + v18) = v20 + 0x30;
    ++v16;
    if ( !n0xF_1 )
    {
      if ( (int)v19 > 0 )
      {
        v21 = (char *)(v19 + v18);
        v22 = -v18;
        do
        {
          v23 = *v21--;
          v24 = *(_BYTE *)v18;
          *(_BYTE *)v18++ = v23;
          v21[1] = v24;
        }
        while ( v22 + v18 < (__int64)&v21[v22] );
      }
      if ( v14 >= 0 )
      {
        v25 = sub_1402FED90(Buffer, n0xF, v15 + v14, ___severity__:_, a7, p______tags__:[);
        if ( v25 >= 0 )
        {
          v26 = v14 + v25;
          result = (unsigned int)(v14 + v25 + 0xD);
          if ( v26 < 0 )
            return 0xFFFFFFFFLL;
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEBF0 (0x1402FEBF0) ---

// --- Function: sub_1402FED90 (0x1402FED90) ---
__int64 __fastcall sub_1402FED90(
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a3,
        char *___severity__:_,
        const void **a5,
        char *p______tags__:[)
{
  unsigned __int64 n0xD; // rbx
  char *v11; // rcx
  __int64 v12; // r14
  size_t Size; // rbx
  _BYTE *v14; // rsi
  char *v15; // rcx
  size_t Size_1; // rbp
  __int64 v17; // rcx
  size_t Size_2; // rdi
  double *v19; // rcx
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v11 = (char *)Buffer + a3;
  if ( !v11 )
    goto LABEL_3;
  if ( ___severity__:_ && n0xD >= 0xD )
  {
    *(double *)v11 = *(double *)___severity__:_;
    *((_DWORD *)v11 + 2) = *((_DWORD *)___severity__:_ + 2);
    v11[0xC] = ___severity__:_[0xC];
  }
  else
  {
    memset(v11, 0, n0xF - a3);
    if ( !___severity__:_ )
    {
LABEL_3:
      *errno() = 0x16;
LABEL_10:
      invalid_parameter_noinfo();
      goto LABEL_11;
    }
    if ( n0xD < 0xD )
    {
      *errno() = 0x22;
      goto LABEL_10;
    }
  }
LABEL_11:
  v12 = a3 + 0xD;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  v14 = *a5;
  do
    ++Size;
  while ( v14[Size] );
  if ( Size + v12 >= n0xF )
    return 0xFFFFFFFFLL;
  v15 = (char *)Buffer + v12;
  Size_1 = n0xF - v12;
  if ( !Size )
    goto LABEL_24;
  if ( !v15 )
    goto LABEL_16;
  if ( v14 && Size_1 >= Size )
  {
    memcpy(v15, *a5, Size);
  }
  else
  {
    memset(v15, 0, n0xF - v12);
    if ( !v14 )
    {
LABEL_16:
      *errno() = 0x16;
LABEL_23:
      invalid_parameter_noinfo();
      goto LABEL_24;
    }
    if ( Size_1 < Size )
    {
      *errno() = 0x22;
      goto LABEL_23;
    }
  }
LABEL_24:
  if ( (Size & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v17 = v12 + (int)Size;
  if ( v17 + 0xA >= n0xF )
    return 0xFFFFFFFFLL;
  Size_2 = n0xF - v17;
  v19 = (double *)((char *)Buffer + v17);
  if ( !v19 )
    goto LABEL_27;
  if ( !p______tags__:[ || Size_2 < 0xA )
  {
    memset(v19, 0, Size_2);
    if ( p______tags__:[ )
    {
      if ( Size_2 >= 0xA )
        goto LABEL_36;
      *errno() = 0x22;
LABEL_35:
      invalid_parameter_noinfo();
LABEL_36:
      result = (unsigned int)(Size + 0x17);
      if ( (int)Size + 0xA < 0 )
        return 0xFFFFFFFFLL;
      return result;
    }
LABEL_27:
    *errno() = 0x16;
    goto LABEL_35;
  }
  *v19 = *(double *)p______tags__:[;
  *((_WORD *)v19 + 4) = *((_WORD *)p______tags__:[ + 4);
  result = (unsigned int)(Size + 0x17);
  if ( (int)Size + 0xA < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_1402FED90 (0x1402FED90) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: sub_1402FF680 (0x1402FF680) ---
__int64 __fastcall sub_1402FF680(
        __int64 a1,
        _BYTE *a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        unsigned __int64 a6)
{
  unsigned int v10; // edi
  unsigned __int64 *v11; // rsi
  unsigned __int64 v12; // rax
  size_t Size; // rsi
  _BYTE *v14; // r14
  _BYTE *v15; // rcx
  size_t Size_1; // rbp
  __int64 v17; // r14
  int v18; // eax
  int v19; // esi
  __int64 v20; // rdx
  size_t n2; // rbx
  _WORD *v22; // rcx
  unsigned __int64 v23; // rbx
  _BYTE *v24; // rcx

  if ( a5 >= a6 )
    return 0;
  v10 = 0;
  if ( (int)a3 <= 0 )
    goto LABEL_27;
  if ( a3 <= 1 )
  {
    v11 = (unsigned __int64 *)(a4 + 0x70 * a5 + 0x50);
    v12 = *v11;
    goto LABEL_28;
  }
  if ( a2 )
  {
    *a2 = 0x3C;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  v14 = *(_BYTE **)(0x70 * a5 + a4 + 8);
  do
    ++Size;
  while ( v14[Size] );
  if ( Size + 1 >= a3 )
  {
    v11 = (unsigned __int64 *)(a4 + 0x70 * a5 + 0x50);
    v12 = *v11;
    goto LABEL_28;
  }
  v15 = a2 + 1;
  Size_1 = a3 - 1;
  if ( Size )
  {
    if ( a2 == (_BYTE *)0xFFFFFFFFFFFFFFFFLL )
    {
LABEL_15:
      *errno() = 0x16;
LABEL_22:
      invalid_parameter_noinfo();
      goto LABEL_23;
    }
    if ( v14 && Size_1 >= Size )
    {
      memcpy(v15, v14, Size);
    }
    else
    {
      memset(v15, 0, a3 - 1);
      if ( !v14 )
        goto LABEL_15;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_22;
      }
    }
  }
LABEL_23:
  if ( (Size & 0x80000000) != 0LL )
  {
    v11 = (unsigned __int64 *)(a4 + 0x70 * a5 + 0x50);
    v12 = *v11;
    goto LABEL_28;
  }
  if ( (int)Size + 1 >= 0 )
    v10 = Size + 1;
LABEL_27:
  v11 = (unsigned __int64 *)(a4 + 0x70 * a5 + 0x50);
  v12 = *v11;
  if ( (int)v10 >= (int)a3 )
    return v10;
LABEL_28:
  if ( v12 == 0xFFFFFFFFFFFFFFFFuLL )
  {
    if ( (int)v10 + 1LL >= a3 )
      return v10;
    v23 = a3 - (int)v10;
    v24 = &a2[v10];
    if ( v24 )
    {
      if ( v23 )
      {
        *v24 = 0x3E;
        return ++v10;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    return ++v10;
  }
  if ( (int)v10 + 1LL < a3 )
  {
    if ( &a2[v10] )
    {
      if ( a3 != v10 )
      {
        a2[v10] = 0x5B;
LABEL_36:
        v17 = (int)v10 + 1LL;
        v18 = sub_1402FE6B0((__int64)a2, a3, v17, *v11);
        v19 = v18;
        if ( v18 < 0 )
          return v10;
        v20 = v17 + v18;
        if ( v20 + 2 >= a3 )
          return v10;
        n2 = a3 - v20;
        v22 = &a2[v20];
        if ( &a2[v20] )
        {
          if ( n2 >= 2 )
          {
            *v22 = 0x3E5D;
            goto LABEL_44;
          }
          memset(v22, 0, n2);
          *errno() = 0x22;
        }
        else
        {
          *errno() = 0x16;
        }
        invalid_parameter_noinfo();
LABEL_44:
        if ( v19 + 3 >= 0 )
          v10 += v19 + 3;
        return v10;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_36;
  }
  return v10;
}

// --- End Function: sub_1402FF680 (0x1402FF680) ---

// --- Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---
void __fastcall std::vector<vraudio::AudioBuffer const *>::_Change_array(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  _QWORD *v6; // rcx

  v6 = *(_QWORD **)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)*(v6 - 1);
    }
    sub_1402A3D30(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---

// --- Function: sub_1402FFAF0 (0x1402FFAF0) ---
__int64 __fastcall sub_1402FFAF0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  __int64 i; // rdi
  _QWORD *v10; // r8
  __int64 result; // rax

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v4 != (_QWORD *)i; v4 += 0xE )
    {
      if ( *((_BYTE *)v4 + 0x58) && *v4 )
        ((void (*)(void))v4[8])();
    }
    v10 = (_QWORD *)*a1;
    if ( (unsigned __int64)(0x70 * ((a1[2] - *a1) / 0x70)) >= 0x1000 )
    {
      if ( (unsigned __int64)v10 - v10[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = (_QWORD *)v10[0xFFFFFFFF];
    }
    sub_1402A3D30(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 0x70 * a3;
  result = a2 + 0x70 * a4;
  a1[2] = result;
  return result;
}

// --- End Function: sub_1402FFAF0 (0x1402FFAF0) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(
        __int64 timestampMs,
        _QWORD *unknownContext2,
        __int64 callbackContext,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  unsigned __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  unsigned __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(callbackContext + 0x24));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(callbackContext + 0x20);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(callbackContext + 8);
  v18 = *(_QWORD *)callbackContext;
  v31 = v16;
  if ( (v17 - *(_QWORD *)callbackContext) / 0x70 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 0x58) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 0x40))();
        v18 += 0x70;
      }
      while ( v18 != v17 );
      *(_QWORD *)(callbackContext + 8) = *(_QWORD *)callbackContext;
    }
    sub_1402FDB90((__int64 *)callbackContext, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = unknownContext2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 0x30;
    v23 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v29 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v16 )
    {
      v20 = unknownContext2 + 1;
      if ( _Newcapacity_1 < (__int64)(unknownContext2[1] - *unknownContext2) >> 2
        && !*(_DWORD *)(*unknownContext2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 0x18)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(callbackContext + 8) - *(_QWORD *)callbackContext) / 0x70LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 0x30),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)callbackContext));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v26 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *unknownContext2) >> 2
          && !*(_DWORD *)(*unknownContext2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 0x38)
          && *(_QWORD *)(v26 + 0x20) )
        {
          if ( (*(_QWORD *)(callbackContext + 8) - *(_QWORD *)callbackContext) / 0x70LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)callbackContext;
          if ( *(_BYTE *)(v27 + 0x58) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 0x40))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 0x38))(*(_QWORD *)(v26 - 0x10));
          v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 0x10) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 0x18) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 0x20) = *(_QWORD *)(v26 + 0x10);
          *(_QWORD *)(v27 + 0x30) = *(_QWORD *)(v26 + 0x20);
          *(_QWORD *)(v27 + 0x28) = *(_QWORD *)(v26 + 0x18);
          *(_QWORD *)(v27 + 0x38) = *(_QWORD *)(v26 + 0x28);
          *(_QWORD *)(v27 + 0x40) = *(_QWORD *)(v26 + 0x30);
          *(_QWORD *)(v27 + 0x48) = *(_QWORD *)(v26 + 0x38);
          *(_QWORD *)(v27 + 0x50) = *(_QWORD *)(v26 + 0x40);
          *(_QWORD *)(v27 + 0x60) = *(_QWORD *)(v26 + 0x50);
          *(_QWORD *)(v27 + 0x68) = *(_QWORD *)(v26 + 0x58);
          *(_BYTE *)(v27 + 0x58) = 1;
          *(_BYTE *)(v27 + 0x59) = *(_BYTE *)(v26 + 0x49);
        }
        ++_Newcapacity_2;
        v26 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(callbackContext + 0x18) = timestampMs;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 timestampMs)
{
  int timestampMs_1; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  timestampMs_1 = timestampMs;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = timestampMs / 0x3E8;
  Time = timestampMs / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", timestampMs_1 - 0x3E8 * v7)
                      + 0x13);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes a global callback function if it is registered, passing the provided
// arguments. If no callback is registered, it defaults to returning a status of 1.
// The resulting status bits are then masked: bit 2 is cleared if qword_149B3B208
// is zero, and bit 3 is cleared if qword_149B3B210 is zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 statusBits; // rax

  if ( qword_149B3B1F0 )
    statusBits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    statusBits = 1;
  if ( !qword_149B3B208 )
    statusBits = (unsigned int)statusBits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)statusBits & 0xFFFFFFF7;
  return statusBits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140300AB0 (0x140300AB0) ---
__int64 __fastcall sub_140300AB0(int a1)
{
  __int64 n1000; // rax

  switch ( a1 )
  {
    case 2:
      n1000 = 1000;
      break;
    case 3:
      n1000 = 5000;
      break;
    case 4:
      n1000 = 15000;
      break;
    case 5:
      n1000 = 30000;
      break;
    case 6:
      n1000 = 60000;
      break;
    case 7:
      n1000 = 300000;
      break;
    case 8:
      n1000 = 900000;
      break;
    case 9:
      n1000 = 1800000;
      break;
    default:
      n1000 = 0;
      break;
  }
  return n1000;
}

// --- End Function: sub_140300AB0 (0x140300AB0) ---

// --- Function: sub_140300BC0 (0x140300BC0) ---
__int64 __fastcall sub_140300BC0(_WORD *a1, int a2, char n37)
{
  unsigned int n2_1; // r10d
  __int64 n2; // rax

  n2_1 = 0;
  switch ( n37 )
  {
    case 8:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 25180;
      n2 = 2;
      break;
    case 9:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29788;
      n2 = 2;
      break;
    case 10:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 28252;
      n2 = 2;
      break;
    case 12:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 26204;
      n2 = 2;
      break;
    case 13:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29276;
      n2 = 2;
      break;
    case 34:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 8796;
      n2 = 2;
      break;
    case 92:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 23644;
      n2 = 2;
      break;
    default:
      if ( a2 > 0 )
      {
        *(_BYTE *)a1 = n37;
        n2_1 = 1;
      }
LABEL_18:
      n2 = n2_1;
      break;
  }
  return n2;
}

// --- End Function: sub_140300BC0 (0x140300BC0) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 timestampMs,
        wchar_t *p_uuidString,
        unsigned int n4,
        __int64 *playerId,
        _BYTE *Src,
        char *sourceLocation,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 unknownContext1,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *p_outputFlags)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          sourceLocation,
          (__int64)__Val_0__,
          _Newcapacity,
          unknownContext1,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *playerId;
  if ( !((playerId[1] - *playerId) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *playerId;
  }
  while ( v62 < (playerId[1] - *playerId) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*p_outputFlags & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*p_outputFlags & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(timestampMs, p_uuidString, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 timestampMs,
        _BYTE *p_Buffer,
        _BYTE *p_uuidString,
        unsigned int n4,
        _QWORD *playerId,
        char *messageString,
        char *sourceLocation,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 unknownContext1,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int outputFlags,
        int eventKeyVectorPtr)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *playerId_1; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *playerId_3; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *messageString_2; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 timestampMs_2; // r14
  _BYTE *p_uuidString_2; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *playerId_2; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *p_uuidString_1; // [rsp+C0h] [rbp-A8h]
  __int64 timestampMs_1; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *sourceLocation_1; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *messageString_1; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  playerId_1 = playerId;
  messageString_1 = messageString;
  sourceLocation_1 = sourceLocation;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  p_uuidString_1 = p_uuidString;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  timestampMs_1 = timestampMs;
  n0xF_3 = n0xF + 0x80;
  n0xF_5[0] = n4;
  playerId_2 = playerId;
  n0xF_17 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    playerId_1 = playerId_2;
LABEL_57:
    n0xF_25 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( p_uuidString[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( p_uuidString && Size_4 >= Size_3 )
    {
      memcpy(v36, p_uuidString, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !p_uuidString )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  playerId_1 = playerId_2;
  n0xF_25 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (outputFlags & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              timestampMs_1,
              p_uuidString_1,
              n4_1,
              messageString_1,
              playerId_1,
              v165,
              a17,
              sourceLocation_1,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &outputFlags);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (outputFlags & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (outputFlags & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (outputFlags & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_26 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_95;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_18 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  playerId_3 = playerId_2;
  v59 = playerId_2[1];
  v60 = *playerId_2;
  v61 = (v59 - *playerId_2) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_129:
      n0xF_3 = n0xF + 0x80;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      playerId_3 = playerId_2;
      goto LABEL_131;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 0x22;
      }
      else
      {
LABEL_111:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_130;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    playerId_3 = playerId_2;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = playerId_3[1];
    ++v62;
    v60 = *playerId_3;
    v75 = v59 - *playerId_3;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_145:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 0xB;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *messageString_1 )
  {
    messageString_2 = messageString_1;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *messageString_2);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++messageString_2;
    }
    while ( *messageString_2 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_209:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            sourceLocation_1,
            __Val_0___1,
            _Newcapacity,
            unknownContext1,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_16 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_248:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_255;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 0x16;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_292;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_16 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_315:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( eventKeyVectorPtr <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &eventKeyVectorPtr);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (outputFlags & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 outputFlags,
                 timestampMs_1,
                 p_uuidString_1,
                 n4,
                 messageString_1,
                 playerId_2,
                 v165,
                 v48,
                 sourceLocation_1,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  timestampMs_2 = timestampMs_1;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    p_uuidString_2 = p_uuidString_1;
    qword_149B3B210(timestampMs_1, p_uuidString_1, n4, Buffer_1, p_n0xFa, eventKeyVectorPtr);
  }
  else
  {
    p_uuidString_2 = p_uuidString_1;
  }
  if ( v167 )
    v167(
      outputFlags,
      timestampMs_2,
      p_uuidString_2,
      n4,
      messageString_1,
      playerId_2,
      v165,
      a17,
      sourceLocation_1,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 39 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 39);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(_Newvec - 1) = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: ReportTelemetryEvent (0x1403045C0) ---
// This function serves as a comprehensive structured logging or telemetry event
// reporting mechanism. It captures various contextual data points such as
// timestamps, unique IDs (UUID-like), player information, source location, and
// custom event-specific data. The collected data is formatted into a human-
// readable string and/or a JSON-like structure. Depending on global configuration
// flags, the formatted output can be directed to standard output, standard error,
// or custom logging callbacks. It also handles dynamic memory allocation and
// deallocation for internal buffers and data structures.
void __fastcall ReportTelemetryEvent(
        unsigned int logLevel,
        __int64 *playerId,
        char *messageString,
        char *sourceLocation,
        vraudio::AudioBuffer *audioBufferContext,
        unsigned __int64 audioBufferCount,
        __int64 unknownContext1,
        __int64 outputFlags,
        _QWORD *unknownContext2,
        __int64 callbackContext)
{
  _QWORD *unknownContext2_1; // rdi
  __int64 callbackContext_1; // rbx
  __int64 timestampMs_1; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 eventKeyCount; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *audioBufferContext_2; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *audioBufferContext_4; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *audioBufferContext_8; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_1; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 audioBufferCount_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 eventKeyCount_1; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 logMessageBuffer; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char outputFlags_1; // cl
  int v90; // eax
  FILE *File; // rax
  int g_logToStderrEnabled; // r8d
  FILE *File_1; // rax
  char outputFlags_2; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_1; // rax
  const void *Buffer_2; // rsi
  double *Buffer; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *eventKeyListPtr; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *eventKeyListPtr_1; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int eventKeyVectorPtr; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME uuid; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *audioBufferContext_1; // [rsp+F0h] [rbp+50h]
  __int64 timestampMs; // [rsp+F8h] [rbp+58h]
  unsigned __int64 audioBufferContext_5; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *audioBufferContext_3; // [rsp+110h] [rbp+70h]
  char *sourceLocation_1; // [rsp+118h] [rbp+78h]
  char *messageStringa; // [rsp+120h] [rbp+80h]
  __int64 *playerIda; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *audioBufferContext_6; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *audioBufferContext_7; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 audioBufferCount_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char timestampBuffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t uuidString[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  unknownContext2_1 = unknownContext2;
  callbackContext_1 = callbackContext;
  sourceLocation_1 = sourceLocation;
  messageStringa = messageString;
  playerIda = playerId;
  n4 = logLevel;
  audioBufferContext_1 = audioBufferContext;
  if ( qword_149B3B188 )
  {
    timestampMs_1 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &uuid);
    timestampMs_1 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&uuid - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  timestampMs = timestampMs_1;
  if ( callbackContext_1
    && !sub_1402FFCB0(
          timestampMs_1,
          unknownContext2_1,
          callbackContext_1,
          (__int64)audioBufferContext,
          audioBufferCount) )
  {
    return;
  }
  if ( qword_149B3B1E0 )
  {
    uuid = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(uuidString, 0x25);
  }
  else
  {
    uuid = (struct _FILETIME)qword_149B3B250++;
    swprintf(uuidString, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(timestampBuffer, 0x20u, timestampMs_1);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  eventKeyCount = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  audioBufferCount_2 = 0;
  if ( !audioBufferCount )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  audioBufferContext_2 = audioBufferContext_1;
  v20 = v117;
  audioBufferContext_3 = audioBufferContext_1;
  while ( 2 )
  {
    audioBufferContext_4 = audioBufferContext_2;
    if ( *((_BYTE *)audioBufferContext_2 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = audioBufferContext_2;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    audioBufferContext_5 = (unsigned __int64)audioBufferContext_2;
    if ( eventKeyCount < 0x400 )
    {
      v147[eventKeyCount] = audioBufferContext_2;
LABEL_30:
      n0xF_29 = ++eventKeyCount;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, audioBufferCount);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              v14,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400;
          ++__Val_0_;
        }
        while ( n0x400 < 0x400 );
        eventKeyCount = n0xF_29;
        audioBufferContext_2 = audioBufferContext_3;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          v14,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&audioBufferContext_5);
      }
      else
      {
        *_Whereptr_1 = audioBufferContext_2;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)audioBufferContext_2 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)audioBufferContext_2 + 1) = sub_1402FF3C0(&v142, audioBufferContext_2);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)audioBufferContext_2 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    audioBufferContext_5 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)audioBufferContext_2, &v130, &audioBufferContext_5);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      audioBufferContext_4 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      audioBufferContext_6 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        audioBufferContext_8 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        audioBufferContext_7 = audioBufferContext_8;
        v48 = *(_QWORD **)audioBufferContext_8;
        v49 = **(_QWORD ***)audioBufferContext_8;
        if ( v49 == *(_QWORD **)audioBufferContext_8 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        audioBufferContext_8 = audioBufferContext_7;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)audioBufferContext_8 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)audioBufferContext_8 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          audioBufferContext_4 = audioBufferContext_6;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        audioBufferContext_4 = audioBufferContext_6;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)audioBufferContext_4 + 1) = v57;
      eventKeyCount = n0xF_29;
      audioBufferContext_7 = audioBufferContext_4;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_1 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, audioBufferCount);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                v14,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_1;
            ++__Val_0__1;
          }
          while ( n0x400_1 < 0x400 );
          eventKeyCount = n0xF_29;
          audioBufferContext_4 = audioBufferContext_6;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            v14,
            _Whereptr_3,
            &audioBufferContext_7);
        }
        else
        {
          *_Whereptr_3 = audioBufferContext_4;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = audioBufferContext_4;
      }
      n0xF_29 = ++eventKeyCount;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    audioBufferContext_2 = audioBufferContext_3;
    v29 = v143;
LABEL_94:
    if ( audioBufferContext_5 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[audioBufferContext_5];
    v124 += audioBufferContext_5;
LABEL_98:
    audioBufferContext_2 = (vraudio::AudioBuffer *)((char *)audioBufferContext_2 + 0x70);
    v69 = v120;
    audioBufferCount_1 = audioBufferCount_2 + 1;
    *((_QWORD *)audioBufferContext_4 + 0xA) = v29;
    audioBufferCount_2 = audioBufferCount_1;
    audioBufferContext_3 = audioBufferContext_2;
    if ( audioBufferCount_1 < audioBufferCount )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = eventKeyCount;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = eventKeyCount;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * eventKeyCount], (__int64)(8 * eventKeyCount) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( eventKeyCount_1 = 0; eventKeyCount_1 < eventKeyCount; ++eventKeyCount_1 )
  {
    v76 = *(_QWORD *)&v71[8 * eventKeyCount_1];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_131;
    }
  }
  logMessageBuffer = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    logMessageBuffer = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(logMessageBuffer & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_131:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(
            timestampMs,
            n4,
            messageStringa,
            playerIda,
            sourceLocation_1,
            audioBufferContext_1,
            audioBufferCount,
            v146,
            n0x10_1,
            &outputFlags);
    v123[0] = v87;
  }
  outputFlags_1 = outputFlags;
  if ( (outputFlags & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&uuid,
            timestampMs,
            uuidString,
            n4,
            playerIda,
            messageStringa,
            sourceLocation_1,
            audioBufferContext_1,
            audioBufferCount,
            unknownContext1,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &outputFlags);
    outputFlags_1 = outputFlags;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (outputFlags_1 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", timestampBuffer, v83);
    outputFlags_1 = outputFlags;
  }
  g_logToStderrEnabled = n2_126;
  if ( n2_126 == 1 && (outputFlags_1 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(n2_126 + 1);
    fprintf(File_1, "%s %s\n", timestampBuffer, v83);
    g_logToStderrEnabled = n2_126;
  }
  v83[v88] = 0;
  outputFlags_2 = outputFlags;
  v95 = (outputFlags & 1) != 0 && n2_125 == 2;
  v96 = (outputFlags & 2) != 0 && g_logToStderrEnabled == 2;
  if ( (outputFlags & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_2 = 0;
    }
    else
    {
      Buffer_1 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_2 = (const void *)Buffer_1;
      if ( Buffer_1 )
      {
        Buffer = (double *)Buffer_1;
        goto LABEL_167;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer = (double *)&v117;
LABEL_167:
    eventKeyVectorPtr = v123[0];
    *(_BYTE *)Buffer = 0;
    sub_140302E40(
      *(_QWORD *)&uuid,
      timestampMs,
      timestampBuffer,
      uuidString,
      n4,
      playerIda,
      messageStringa,
      sourceLocation_1,
      (__int64)audioBufferContext_1,
      audioBufferCount,
      unknownContext1,
      (__int64)v71,
      n0xF_29,
      Buffer,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      outputFlags,
      eventKeyVectorPtr);
    sub_1402A3D30(Buffer_2);
    outputFlags_2 = outputFlags;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (outputFlags_2 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      outputFlags_2 = outputFlags;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (outputFlags_2 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    eventKeyListPtr = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = eventKeyListPtr[5];
        eventKeyListPtr_1 = (_QWORD *)*eventKeyListPtr;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)eventKeyListPtr[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_191;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        eventKeyListPtr[4] = 0;
        eventKeyListPtr[5] = 0xF;
        *((_BYTE *)eventKeyListPtr + 0x10) = 0;
        sub_1402A3D30(eventKeyListPtr);
        eventKeyListPtr = eventKeyListPtr_1;
      }
      while ( eventKeyListPtr_1 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_191:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: ReportTelemetryEvent (0x1403045C0) ---

// --- Function: sub_140305400 (0x140305400) ---
__int64 __fastcall sub_140305400(
        __int64 a1,
        __int64 a2,
        int a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        __int64 (__fastcall *a9)(__int64, __int64, __int64, __int64, __int64, _BYTE *))
{
  __int64 v9; // rbp
  int v11; // ecx
  int v12; // esi
  char n37; // r8
  __int64 v14; // r15
  char *v15; // rbx
  __int64 v17; // rcx
  char n36; // cl
  __int64 v19; // rdi
  _BYTE *v20; // r11
  unsigned __int64 n0x39; // rcx
  char *v22; // r10
  int n31_2; // r8d
  __int64 n31; // rdx
  __int64 v25; // r9
  int n31_1; // eax
  __int64 n31_3; // rcx
  int v28; // eax
  int v29; // edi
  _BYTE *v30; // rbp
  int n31_5; // r9d
  __int64 n31_6; // r8
  char *v33; // r11
  __int64 v34; // r10
  unsigned __int64 n0x39_1; // rdx
  int n31_4; // eax
  int v37; // eax
  int v38; // eax
  __int64 v39; // rax
  _BYTE *v41; // [rsp+28h] [rbp-90h]
  char String[4]; // [rsp+30h] [rbp-88h] BYREF
  int v43; // [rsp+34h] [rbp-84h]
  __int64 (__fastcall *v44)(__int64, __int64, __int64, __int64, __int64, _BYTE *); // [rsp+38h] [rbp-80h]
  __int64 v45; // [rsp+40h] [rbp-78h]
  _BYTE v46[32]; // [rsp+48h] [rbp-70h] BYREF

  v9 = a5;
  v11 = a3;
  v12 = a3;
  v45 = a5;
  n37 = *a4;
  v14 = 0;
  v44 = a9;
  v15 = a4;
  v43 = v11;
  if ( n37 )
  {
    do
    {
      v17 = 0x3FF6C0900000000LL;
      if ( n37 == 36 )
      {
        n36 = *++v15;
        v19 = 0;
        if ( n36 == 36 )
        {
LABEL_6:
          v19 = v14++;
        }
        else
        {
          while ( (unsigned __int8)(n36 - 48) <= 9u )
          {
            String[0] = n36;
            ++v15;
            v19 = atoi(String) + 10 * v19;
            n36 = *v15;
            if ( *v15 == 36 )
              goto LABEL_6;
          }
          --v15;
        }
        v20 = 0;
        if ( v15[1] == 123 )
        {
          n0x39 = (unsigned __int8)v15[2];
          v22 = v15;
          v15 += 2;
          n31_2 = 0;
          n31 = 0;
          if ( (_BYTE)n0x39 != 125 )
          {
            do
            {
              if ( n31 >= 31 || (unsigned __int8)n0x39 > 0x39u || (v25 = 0x3FF6C0900000000LL, !_bittest64(&v25, n0x39)) )
              {
                v15 = v22;
                goto LABEL_20;
              }
              ++v15;
              v46[n31] = n0x39;
              ++n31_2;
              ++n31;
              n0x39 = (unsigned __int8)*v15;
            }
            while ( (_BYTE)n0x39 != 125 );
            if ( n31_2 > 0 )
            {
              n31_1 = 31;
              if ( n31_2 < 31 )
                n31_1 = n31_2;
              n31_3 = n31_1;
              if ( (unsigned __int64)n31_1 >= 0x20 )
LABEL_55:
                _report_rangecheckfailure(n31_3);
              v46[n31_1] = 0;
              v20 = v46;
            }
          }
        }
LABEL_20:
        if ( v12 < (int)a2 )
        {
          v28 = v44(v12 + a1, a2 - v12, v9, v19 + a7, a6, v20);
          if ( v28 >= 0 )
            v12 += v28;
        }
        v29 = a2;
      }
      else if ( n37 == 37 )
      {
        v30 = 0;
        n31_5 = 0;
        n31_6 = 0;
        v33 = v15;
        v34 = 0;
        while ( 2 )
        {
          n0x39_1 = *++v15;
          switch ( (int)n0x39_1 )
          {
            case 0:
              v15 = v33 + 1;
              goto LABEL_39;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64:
            case 66:
            case 68:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 84:
            case 85:
            case 86:
            case 87:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            case 96:
            case 98:
            case 104:
            case 106:
            case 107:
            case 108:
            case 109:
            case 113:
            case 114:
            case 116:
            case 118:
            case 119:
              v17 = 0x3FF6C0900000000LL;
              goto LABEL_28;
            case 37:
            case 65:
            case 67:
            case 69:
            case 70:
            case 71:
            case 83:
            case 88:
            case 90:
            case 97:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 105:
            case 110:
            case 111:
            case 112:
            case 115:
            case 117:
            case 120:
              if ( n31_5 <= 0 )
                goto LABEL_37;
              n31_4 = 31;
              if ( n31_5 < 31 )
                n31_4 = n31_5;
              n31_3 = n31_4;
              if ( (unsigned __int64)n31_4 >= 0x20 )
                goto LABEL_55;
              v46[n31_4] = 0;
              v30 = v46;
LABEL_37:
              v34 = v14++;
LABEL_39:
              v29 = a2;
              if ( v12 >= (int)a2 )
              {
                v9 = v45;
              }
              else
              {
                v41 = v30;
                v9 = v45;
                v37 = v44(v12 + a1, a2 - v12, v45, v34 + a7, a6, v41);
                if ( v37 >= 0 )
                  v12 += v37;
              }
              break;
            default:
LABEL_28:
              if ( n31_6 < 31 && (unsigned __int8)n0x39_1 <= 0x39u && _bittest64(&v17, n0x39_1) )
              {
                ++n31_5;
                v46[n31_6++] = n0x39_1;
              }
              continue;
          }
          break;
        }
      }
      else
      {
        v29 = a2;
        if ( a8 )
        {
          if ( v12 < (int)a2 )
          {
            v38 = sub_140300BC0((_WORD *)(v12 + a1), (int)a2 - v12, n37);
            if ( v38 >= 0 )
              v12 += v38;
          }
        }
        else if ( v12 < (int)a2 )
        {
          v39 = v12++;
          *(_BYTE *)(v39 + a1) = n37;
        }
      }
      n37 = *++v15;
    }
    while ( n37 );
    v11 = v43;
  }
  else
  {
    v29 = a2;
  }
  if ( v12 < v29 )
    *(_BYTE *)(v12 + a1) = 0;
  return (unsigned int)(v12 - v11);
}

// --- End Function: sub_140305400 (0x140305400) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: sub_140307D70 (0x140307D70) ---
_OWORD *__fastcall sub_140307D70(__int64 *a1, _BYTE *a2, _OWORD *a3)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rdi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  void *v15; // rcx
  _OWORD *v16; // r14
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  _BYTE *v20; // rcx
  _OWORD *result; // rax

  v4 = (unsigned __int64)&a2[-*a1];
  v5 = (a1[1] - *a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_24;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 0x10 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = v14;
  v16 = (_OWORD *)((char *)v14 + (v4 & 0xFFFFFFFFFFFFFFF0uLL));
  *v16 = *a3;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v15 = v16 + 1;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v15, v18, Size);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v20[-*((_QWORD *)v20 + 0xFFFFFFFF) - 8] <= 0x1F )
    {
      v20 = (_BYTE *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v14;
  result = v16;
  a1[1] = (__int64)&v14[2 * v8];
  a1[2] = (__int64)&v14[allocSize / 8];
  return result;
}

// --- End Function: sub_140307D70 (0x140307D70) ---

// --- Function: ??$_Emplace_reallocate@W4Api@RtAudio@@@?$vector@W4Api@RtAudio@@V?$allocator@W4Api@RtAudio@@@std@@@std@@QEAAPEAW4Api@RtAudio@@QEAW423@$$QEAW423@@Z (0x1403081E0) ---
RtAudio::Api *__fastcall std::vector<enum RtAudio::Api>::_Emplace_reallocate<enum RtAudio::Api>(
        std::vector<enum RtAudio::Api> *this,
        RtAudio::Api *const _Whereptr,
        RtAudio::Api *<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _DWORD *v15; // r14
  void *v16; // rcx
  RtAudio::Api *_Whereptr_2; // r8
  RtAudio::Api *_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  RtAudio::Api *result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 2;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 2;
  if ( v5 == 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 2;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x3FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 4 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = (_DWORD *)v14 + v3;
  *v15 = *(_DWORD *)<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (RtAudio::Api *)*((_QWORD *)this + 1);
  _Whereptr_1 = *(RtAudio::Api **)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = _Whereptr_2 - _Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, _Whereptr - _Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFFCuLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (RtAudio::Api *)((char *)v14 + 4 * v3);
  *((_QWORD *)this + 1) = (char *)v14 + 4 * v9;
  *((_QWORD *)this + 2) = (char *)v14 + allocSize;
  return result;
}

// --- End Function: ??$_Emplace_reallocate@W4Api@RtAudio@@@?$vector@W4Api@RtAudio@@V?$allocator@W4Api@RtAudio@@@std@@@std@@QEAAPEAW4Api@RtAudio@@QEAW423@$$QEAW423@@Z (0x1403081E0) ---

// --- Function: ??1?$vector@Ugame_graph_edge@GameGraph@AI@GSC@@V?$allocator@Ugame_graph_edge@GameGraph@AI@GSC@@@std@@@std@@QEAA@XZ (0x14030BA40) ---
void __fastcall std::vector<GSC::AI::GameGraph::game_graph_edge>::~vector<GSC::AI::GameGraph::game_graph_edge>(
        std::vector<GSC::AI::GameGraph::game_graph_edge> *this)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)this;
  if ( v2 )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
  }
}

// --- End Function: ??1?$vector@Ugame_graph_edge@GameGraph@AI@GSC@@V?$allocator@Ugame_graph_edge@GameGraph@AI@GSC@@@std@@@std@@QEAA@XZ (0x14030BA40) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: validateHandleAccess (0x14030EC00) ---
// Validates a given handle by checking its internal type, flags, and thread-
// specific access permissions. It extracts the raw pointer and flags from the
// handle, then performs checks against metadata associated with the handle. It
// also verifies if the current thread's context or global settings permit access
// to the handle based on its type.
bool __fastcall validateHandleAccess(unsigned __int64 *a1)
{
  unsigned __int64 handleValue; // r9
  __int64 rawPointer; // r10
  unsigned __int64 handleFlags; // r9
  __int64 flagMask; // rax
  __int64 metadataBase; // r10
  __int64 metadataPtr; // rbx
  bool isThreadAccessPermitted; // al

  handleValue = *a1;
  if ( !*a1 )
    return 0;
  rawPointer = handleValue & 0xFFFFFFFFFFFFLL;
  handleFlags = HIWORD(handleValue);
  if ( (handleFlags & 0xF000) != 0 )
  {
    flagMask = map_flag_to_mask(0x2000u);
    metadataPtr = metadataBase & ~(flagMask - 1);
  }
  else
  {
    metadataPtr = rawPointer - 6;
  }
  if ( *(_WORD *)(metadataPtr + 2) != (handleFlags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (isThreadAccessPermitted = sub_140539D80()) )
    isThreadAccessPermitted = 1;
  return *(_WORD *)(metadataPtr + 4) == 2 && isThreadAccessPermitted || sub_140392020(a1) != 0;
}

// --- End Function: validateHandleAccess (0x14030EC00) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 24576 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_140354560 (0x140354560) ---
__int64 __fastcall sub_140354560(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  result = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return result;
}

// --- End Function: sub_140354560 (0x140354560) ---

// --- Function: sub_14035AA80 (0x14035AA80) ---
__int64 __fastcall sub_14035AA80(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 45;
    v6 = 1;
    a4 = -a4 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = -1;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
      return 0xFFFFFFFFLL;
    ++v6;
    v10 = a4 % 10;
    a4 /= 10;
    *(_BYTE *)(v8 + v4) = v10 + 48;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_14035AA80 (0x14035AA80) ---

// --- Function: sub_14035AE20 (0x14035AE20) ---
_QWORD *__fastcall sub_14035AE20(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  void (__fastcall *v4)(__int64, _QWORD *, _QWORD *); // rax
  void (__fastcall *n2)(__int64, _QWORD *); // rax

  v2 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = (void (__fastcall *)(__int64, _QWORD *, _QWORD *))a2[1];
  if ( v4 == (void (__fastcall *)(__int64, _QWORD *, _QWORD *))1 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
    n2 = (void (__fastcall *)(__int64, _QWORD *))a2[1];
    if ( (unsigned __int64)n2 >= 2 )
      goto LABEL_7;
    goto LABEL_8;
  }
  if ( v4 )
  {
    v4(1, a1, a2);
    n2 = (void (__fastcall *)(__int64, _QWORD *))v2[1];
    if ( (unsigned __int64)n2 >= 2 )
    {
      a2 = v2;
LABEL_7:
      n2(2, a2);
      v2[1] = 0;
    }
LABEL_8:
    *v2 = 0;
  }
  return a1;
}

// --- End Function: sub_14035AE20 (0x14035AE20) ---

// --- Function: sub_14035B140 (0x14035B140) ---
_QWORD *__fastcall sub_14035B140(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149B3B33C + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035B140 (0x14035B140) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_14035B3F0 (0x14035B3F0) ---
_QWORD *__fastcall sub_14035B3F0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = &unk_149B3E478;
  v2 = *a2;
  *a2 = (__int64)&unk_149B3E478;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035B3F0 (0x14035B3F0) ---

// --- Function: sub_14035B410 (0x14035B410) ---
void **__fastcall sub_14035B410(void **a1, const void **a2)
{
  __int64 v4; // rdi

  *a1 = &unk_149B3E478;
  v4 = *((int *)*a2 + 0xFFFFFFFE);
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
  {
    sub_1403DE120(a1, *((int *)*a2 + 0xFFFFFFFE));
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, 2 * v4);
  }
  return a1;
}

// --- End Function: sub_14035B410 (0x14035B410) ---

// --- Function: sub_14035F010 (0x14035F010) ---
_QWORD *__fastcall sub_14035F010(_QWORD *a1, unsigned __int8 **a2)
{
  void **v4; // rax
  _QWORD *v5; // rax
  __int64 v6; // rdx
  unsigned __int8 *v7; // r8
  __int64 v8; // r9
  int v9; // eax
  int v10; // ecx
  __int64 v11; // rax

  *a1 = &unk_149B3E478;
  v4 = (void **)sub_1403AE5D0();
  v5 = (_QWORD *)sub_140351340(&unk_149B3E230, v4);
  v7 = *a2;
  v8 = *v5 - (_QWORD)*a2;
  do
  {
    v9 = v7[v8];
    v10 = *v7 - v9;
    if ( v10 )
      break;
    ++v7;
  }
  while ( v9 );
  if ( v10 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)qword_149B4FCA0 + 0x4E0LL))(
            qword_149B4FCA0,
            v6,
            v7);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD *, _QWORD))(*(_QWORD *)v11 + 0xA8LL))(v11, *a2, a1, 0);
  }
  return a1;
}

// --- End Function: sub_14035F010 (0x14035F010) ---

// --- Function: sub_14036C440 (0x14036C440) ---
__int64 __fastcall sub_14036C440(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v2 = allocWithProfilerInfo_w(0x40u);
  *(_QWORD *)v2 = v2;
  *(_QWORD *)(v2 + 8) = v2;
  *(_QWORD *)(v2 + 0x10) = v2;
  *(_WORD *)(v2 + 0x18) = 0x101;
  *(_QWORD *)a1 = v2;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  v3 = allocWithProfilerInfo_w(0x40u);
  *(_QWORD *)v3 = v3;
  *(_QWORD *)(v3 + 8) = v3;
  *(_QWORD *)(v3 + 0x10) = v3;
  *(_WORD *)(v3 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x10) = v3;
  *(_QWORD *)(a1 + 0x50) = (char *)&qword_149B3B33C + 4;
  *(_QWORD *)(a1 + 0x58) = (char *)&qword_149B3B33C + 4;
  result = a1;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_WORD *)(a1 + 0x48) = 0;
  *(_BYTE *)(a1 + 0x60) = 0;
  *(_DWORD *)(a1 + 0x68) = 0;
  return result;
}

// --- End Function: sub_14036C440 (0x14036C440) ---

// --- Function: sub_14036CFD0 (0x14036CFD0) ---
__int64 __fastcall sub_14036CFD0(__int64 a1)
{
  *(_DWORD *)(a1 + 8) = 8;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_14036CFD0 (0x14036CFD0) ---

// --- Function: sub_14036DC00 (0x14036DC00) ---
__int64 __fastcall sub_14036DC00(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 8) = (char *)&qword_149B3B33C + 4;
  *(_QWORD *)(a1 + 0x18) = (char *)&qword_149B3B33C + 4;
  result = a1;
  *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
  return result;
}

// --- End Function: sub_14036DC00 (0x14036DC00) ---

// --- Function: sub_140370B50 (0x140370B50) ---
__int64 __fastcall sub_140370B50(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx

  v1 = *(volatile signed __int32 **)(a1 + 24);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v4 = *(volatile signed __int32 **)(a1 + 8);
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
  }
  return result;
}

// --- End Function: sub_140370B50 (0x140370B50) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140375670 (0x140375670) ---
void __fastcall sub_140375670(__int64 *a1)
{
  int *v2; // rcx
  _QWORD *v3; // rcx

  v2 = (int *)(a1[0xB] - 8);
  if ( v2[1] > 0 )
    sub_147605980(v2);
  if ( *(int *)(a1[0xA] - 4) > 0 )
    sub_147605980((const void *)(a1[0xA] - 8));
  v3 = (_QWORD *)a1[4];
  if ( v3 )
  {
    if ( ((a1[6] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    a1[4] = 0;
    a1[5] = 0;
    a1[6] = 0;
  }
  sub_140308410((__int64)(a1 + 2), (__int64)(a1 + 2), *(__int64 **)(a1[2] + 8));
  sub_1402A3D30((const void *)a1[2]);
  sub_140308410((__int64)a1, (__int64)a1, *(__int64 **)(*a1 + 8));
  sub_1402A3D30((const void *)*a1);
}

// --- End Function: sub_140375670 (0x140375670) ---

// --- Function: sub_140375750 (0x140375750) ---
// attributes: thunk
void __fastcall sub_140375750(__int64 *a1)
{
  sub_140375670(a1);
}

// --- End Function: sub_140375750 (0x140375750) ---

// --- Function: sub_140375760 (0x140375760) ---
__int64 __fastcall sub_140375760(_QWORD *a1)
{
  volatile signed __int32 *v1; // rbx
  _QWORD *v3; // rcx
  const void *v4; // rcx

  v1 = (volatile signed __int32 *)a1[0x29];
  if ( v1 )
  {
    if ( _InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v3 = (_QWORD *)a1[0x25];
  if ( v3 )
  {
    if ( ((a1[0x27] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        goto LABEL_16;
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    a1[0x25] = 0;
    a1[0x26] = 0;
    a1[0x27] = 0;
  }
  v4 = (const void *)a1[0x22];
  if ( v4 )
  {
    if ( ((a1[0x24] - (_QWORD)v4) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_14:
      sub_1402A3D30(v4);
      a1[0x22] = 0;
      a1[0x23] = 0;
      a1[0x24] = 0;
      return sub_140376310((__int64)a1);
    }
    if ( (unsigned __int64)v4 - *((_QWORD *)v4 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v4 = (const void *)*((_QWORD *)v4 + 0xFFFFFFFF);
      goto LABEL_14;
    }
LABEL_16:
    invalid_parameter_noinfo_noreturn();
  }
  return sub_140376310((__int64)a1);
}

// --- End Function: sub_140375760 (0x140375760) ---

// --- Function: sub_140375DF0 (0x140375DF0) ---
__int64 __fastcall sub_140375DF0(__int64 *a1)
{
  int *v2; // rcx

  v2 = (int *)(a1[0xE] - 8);
  if ( v2[1] > 0 )
    sub_147605980(v2);
  if ( *(int *)(a1[0xD] - 4) > 0 )
    sub_147605980((const void *)(a1[0xD] - 8));
  if ( *(int *)(a1[0xC] - 4) > 0 )
    sub_147605980((const void *)(a1[0xC] - 8));
  if ( *(int *)(a1[9] - 4) > 0 )
    sub_147605980((const void *)(a1[9] - 8));
  if ( *(int *)(a1[8] - 4) > 0 )
    sub_147605980((const void *)(a1[8] - 8));
  sub_1403E0EE0(a1 + 4);
  return sub_1403E0FB0((__int64)a1);
}

// --- End Function: sub_140375DF0 (0x140375DF0) ---

// --- Function: sub_1403762C0 (0x1403762C0) ---
void __fastcall sub_1403762C0(__int64 a1)
{
  int *v2; // rcx

  v2 = (int *)(*(_QWORD *)(a1 + 0x18) - 8LL);
  if ( v2[1] > 0 )
    sub_147605980(v2);
  if ( *(int *)(*(_QWORD *)(a1 + 8) - 4LL) > 0 )
    sub_147605980((const void *)(*(_QWORD *)(a1 + 8) - 8LL));
}

// --- End Function: sub_1403762C0 (0x1403762C0) ---

// --- Function: sub_1403778D0 (0x1403778D0) ---
__int64 __fastcall sub_1403778D0(_QWORD *a1)
{
  unsigned __int64 n0xF; // rdx
  _QWORD *v3; // rcx
  __int64 result; // rax
  unsigned __int64 n0xF_1; // rdx
  const void *v6; // rcx

  n0xF = a1[8];
  if ( n0xF > 0xF )
  {
    v3 = (_QWORD *)a1[5];
    if ( n0xF + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - *(v3 - 1) - 8 > 0x1F )
        goto LABEL_12;
      v3 = (_QWORD *)*(v3 - 1);
    }
    result = sub_1402A3D30(v3);
  }
  a1[7] = 0;
  a1[8] = 15;
  *((_BYTE *)a1 + 40) = 0;
  n0xF_1 = a1[4];
  if ( n0xF_1 > 0xF )
  {
    v6 = (const void *)a1[1];
    if ( n0xF_1 + 1 < 0x1000 )
    {
LABEL_10:
      result = sub_1402A3D30(v6);
      goto LABEL_11;
    }
    if ( (unsigned __int64)v6 - *((_QWORD *)v6 - 1) - 8 <= 0x1F )
    {
      v6 = (const void *)*((_QWORD *)v6 - 1);
      goto LABEL_10;
    }
LABEL_12:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  a1[3] = 0;
  a1[4] = 15;
  *((_BYTE *)a1 + 8) = 0;
  return result;
}

// --- End Function: sub_1403778D0 (0x1403778D0) ---

// --- Function: sub_140377F00 (0x140377F00) ---
char **__fastcall sub_140377F00(char **a1, char **a2)
{
  char *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E9810(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377F00 (0x140377F00) ---

// --- Function: copyStringStructure (0x140377F40) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
char **__fastcall copyStringStructure(char **a1, char **a2)
{
  unsigned __int64 Size; // rdi

  Size = *((int *)*a2 + 0xFFFFFFFE);
  sub_1403E9810(a1, Size, 0x20);
  if ( Size && *a1 != *a2 )
    memcpy(*a1, *a2, Size);
  return a1;
}

// --- End Function: copyStringStructure (0x140377F40) ---

// --- Function: assignCStringToStringStructure (0x140377FA0) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **a1, _BYTE *a2)
{
  __int64 Size; // rax

  if ( a2 )
  {
    Size = -1;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DE230(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DE230(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x140377FA0) ---

// --- Function: sub_140377FE0 (0x140377FE0) ---
void **__fastcall sub_140377FE0(void **a1, void **a2)
{
  void *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E98E0(a2, 0, 0x20u);
  return a1;
}

// --- End Function: sub_140377FE0 (0x140377FE0) ---

// --- Function: sub_1403798D0 (0x1403798D0) ---
std::shared_ptr<vraudio::MixerNode> *__fastcall sub_1403798D0(
        std::shared_ptr<vraudio::MixerNode> *a1,
        std::shared_ptr<vraudio::MixerNode> *_Right)
{
  std::shared_ptr<vraudio::MixerNode>::operator=(a1, _Right);
  return a1;
}

// --- End Function: sub_1403798D0 (0x1403798D0) ---

// --- Function: sub_14037F610 (0x14037F610) ---
bool __fastcall sub_14037F610(__int64 a1, __int64 a2)
{
  return a1 != a2;
}

// --- End Function: sub_14037F610 (0x14037F610) ---

// --- Function: sub_14037F680 (0x14037F680) ---
bool __fastcall sub_14037F680(unsigned __int16 **a1, _QWORD *a2)
{
  unsigned __int16 *v2; // rax
  __int64 v3; // r8
  int v4; // ecx
  int v5; // edx

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  do
  {
    v4 = *(unsigned __int16 *)((char *)v2 + v3);
    v5 = *v2 - v4;
    if ( v5 )
      break;
    ++v2;
  }
  while ( v4 );
  return v5 != 0;
}

// --- End Function: sub_14037F680 (0x14037F680) ---

// --- Function: psub_1403360E0_w (0x140383540) ---
__int64 __fastcall sub_140383540(__int64 a1, __int64 a2)
{
  return (unsigned int)~psub_1403360E0(0xFFFFFFFF, a2, 0x10);
}

// --- End Function: psub_1403360E0_w (0x140383540) ---

// --- Function: p_p_p_sub_140384A94 (0x140384A94) ---
void __fastcall p_p_p_sub_140384A94(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
}

// --- End Function: p_p_p_sub_140384A94 (0x140384A94) ---

// --- Function: sub_140391AB0 (0x140391AB0) ---
__int64 __fastcall sub_140391AB0(__int64 a1, unsigned __int64 allocSize)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  unsigned __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403B38D0();
  n0x40 = (allocSize >> 8) + ((_BYTE)allocSize != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
      goto LABEL_7;
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 0x40LL;
      if ( n0x4000 >= 0x4000 )
        goto LABEL_2;
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
        n0x40_1 = 0xFFFFFFFFFFFFFFFFuLL;
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
          goto LABEL_2;
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ;
          n0x4000_2 + 0x40 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL);
          v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = 0xFFFFFFFFFFFFFFFFuLL )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 0x40LL;
    }
    if ( n0x4000_2 < n0x4000 )
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 0x40)) - 1;
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056DB80((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056DBC0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_14056DA40((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(allocSize, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140391AB0 (0x140391AB0) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_14039A4B0 (0x14039A4B0) ---
unsigned __int64 __fastcall sub_14039A4B0(__int64 *a1)
{
  __int64 v1; // rbx
  int v3; // r14d
  signed __int32 v4; // edi
  __int64 v5; // rax
  void (**v6)(void); // rdi
  void (*v7)(void); // rax
  void (*n2_3)(void); // rax
  void (*n2_2)(void); // rax
  int v10; // eax
  volatile signed __int32 *v11; // rbx
  unsigned __int64 n2_4; // rax
  void (*v13)(void); // [rsp+20h] [rbp-40h] BYREF
  unsigned __int64 n2; // [rsp+28h] [rbp-38h]
  __int64 v15; // [rsp+30h] [rbp-30h]
  void (*v16)(void); // [rsp+38h] [rbp-28h] BYREF
  void (*n2_1)(void); // [rsp+40h] [rbp-20h]
  __int64 v18; // [rsp+48h] [rbp-18h]

  v1 = *a1;
  v13 = 0;
  n2 = 0;
  v15 = 0;
  if ( !v1 )
    goto LABEL_37;
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v1 + 0x10) == v3 )
  {
    ++*(_DWORD *)(v1 + 0x14);
  }
  else
  {
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 1, 0);
    if ( v4 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
        sub_1403C3410(v1, v4, "CFutureHandle::Cancel");
      else
        sub_1403C3680(v1, v4, "CFutureHandle::Cancel");
    }
    else
    {
      *(_QWORD *)(v1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    }
    *(_DWORD *)(v1 + 0x10) = v3;
  }
  v5 = *a1;
  if ( !*(_BYTE *)(*a1 + 0x39) && !*(_BYTE *)(v5 + 0x38) )
  {
    *(_BYTE *)(v5 + 0x39) = 1;
    v6 = (void (**)(void))(*a1 + 0x20);
    v16 = 0;
    n2_1 = 0;
    v18 = 0;
    v7 = v6[1];
    if ( v7 == (void (*)(void))1 )
    {
      v16 = *v6;
      n2_1 = v6[1];
    }
    else
    {
      if ( !v7 )
      {
LABEL_20:
        *v6 = 0;
        if ( n2 >= 2 )
        {
          ((void (__fastcall *)(__int64, void (**)(void)))n2)(2, &v13);
          n2 = 0;
        }
        n2_2 = n2_1;
        v13 = 0;
        if ( n2_1 == (void (*)(void))1 )
        {
          v13 = v16;
          n2 = 1;
        }
        else
        {
          if ( n2_1 )
          {
            ((void (__fastcall *)(__int64, void (**)(void), void (**)(void)))n2_1)(1, &v13, &v16);
            n2_2 = n2_1;
            if ( (unsigned __int64)n2_1 >= 2 )
            {
              ((void (__fastcall *)(__int64, void (**)(void)))n2_1)(2, &v16);
              n2_2 = 0;
              n2_1 = 0;
            }
            v16 = 0;
          }
          if ( (unsigned __int64)n2_2 >= 2 )
            ((void (__fastcall *)(__int64, void (**)(void)))n2_2)(2, &v16);
        }
        goto LABEL_30;
      }
      ((void (__fastcall *)(__int64, void (**)(void), void (**)(void)))v7)(1, &v16, v6);
    }
    n2_3 = v6[1];
    if ( (unsigned __int64)n2_3 >= 2 )
    {
      ((void (__fastcall *)(__int64, void (**)(void)))n2_3)(2, v6);
      v6[1] = 0;
    }
    *v6 = 0;
    goto LABEL_20;
  }
LABEL_30:
  v10 = *(_DWORD *)(v1 + 0x14);
  if ( v10 )
  {
    *(_DWORD *)(v1 + 0x14) = v10 - 1;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    sub_1402DB100(v1);
  }
  if ( v13 )
  {
    if ( n2 == 1 )
      v13();
    else
      ((void (__fastcall *)(void (**)(void)))v13)(&v13);
  }
LABEL_37:
  v11 = (volatile signed __int32 *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if ( v11 )
  {
    if ( _InterlockedExchangeAdd(v11 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
    }
  }
  n2_4 = n2;
  if ( n2 >= 2 )
    return ((__int64 (__fastcall *)(__int64, void (**)(void)))n2)(2, &v13);
  return n2_4;
}

// --- End Function: sub_14039A4B0 (0x14039A4B0) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_14039F0F0 (0x14039F0F0) ---
void **sub_14039F0F0(void **a1, const wchar_t **a2, ...)
{
  _QWORD *v4; // rax
  unsigned __int64 v5; // rcx
  wchar_t Buffer[4096]; // [rsp+30h] [rbp-2028h] BYREF
  va_list va; // [rsp+2070h] [rbp+18h] BYREF

  va_start(va, a2);
  *a1 = &unk_149B3E478;
  v4 = sub_1402A4380();
  _stdio_common_vswprintf(*v4 | 1LL, Buffer, 0x1000u, *a2, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1403DE2D0(a1, Buffer, (int)v5);
  return a1;
}

// --- End Function: sub_14039F0F0 (0x14039F0F0) ---

// --- Function: sub_1403A3120 (0x1403A3120) ---
void __fastcall sub_1403A3120(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403B38D0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 0x20) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ; v7 + 0x40 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 0x28) = 0 )
    {
      v11 = v7;
      v7 += 0x40LL;
    }
    if ( v7 < v8 )
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~((1LL << ((__int64)v8 % 0x40)) - 1);
  }
  else
  {
    sub_147605980(a2);
  }
}

// --- End Function: sub_1403A3120 (0x1403A3120) ---

// --- Function: sub_1403A3C70 (0x1403A3C70) ---
__int64 __fastcall sub_1403A3C70(_QWORD *a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = (volatile signed __int32 *)a1[1];
  result = 0;
  *a1 = 0;
  a1[1] = 0;
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  return result;
}

// --- End Function: sub_1403A3C70 (0x1403A3C70) ---

// --- Function: sub_1403ABCB0 (0x1403ABCB0) ---
_OWORD *__fastcall sub_1403ABCB0(_OWORD *a1, unsigned int a2)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int128 v6; // xmm0
  _OWORD *result; // rax
  _BYTE v8[16]; // [rsp+20h] [rbp-28h] BYREF

  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0xC0LL))(gEnv);
  if ( v4 && (v5 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 0x10LL))(v4, a2)) != 0 )
    v6 = *(_OWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v5 + 0x10LL))(v5, v8);
  else
    v6 = 0;
  result = a1;
  *a1 = v6;
  return result;
}

// --- End Function: sub_1403ABCB0 (0x1403ABCB0) ---

// --- Function: sub_1403AE630 (0x1403AE630) ---
__int64 sub_1403AE630()
{
  __int64 result; // rax
  void **v1; // rbx
  signed __int64 v2; // rdi

  result = qword_149B3E278;
  if ( !qword_149B3E278 )
  {
    v1 = (void **)allocWithProfilerInfo_w(8u);
    if ( v1 )
    {
      *v1 = &unk_149B3E478;
      sub_1403DE2D0(v1, (void *)&p__n, 0);
    }
    else
    {
      v1 = 0;
    }
    v2 = _InterlockedCompareExchange64(&qword_149B3E278, (signed __int64)v1, 0);
    if ( v2 )
    {
      if ( v1 )
      {
        if ( *((int *)*v1 + 0xFFFFFFFF) > 0 )
          sub_147605980((char *)*v1 + 0xFFFFFFF8);
        sub_1402A3D30(v1);
      }
      return v2;
    }
    else
    {
      return qword_149B3E278;
    }
  }
  return result;
}

// --- End Function: sub_1403AE630 (0x1403AE630) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B1280 (0x1403B1280) ---
__int64 sub_1403B1280()
{
  __int64 result; // rax
  void **v1; // rbx
  signed __int64 v2; // rdi

  result = qword_149B3E280;
  if ( !qword_149B3E280 )
  {
    v1 = (void **)allocWithProfilerInfo_w(8u);
    if ( v1 )
    {
      *v1 = &unk_149B3E478;
      sub_1403DE2D0(v1, L"@LOC_INVALID", 0xCu);
    }
    else
    {
      v1 = 0;
    }
    v2 = _InterlockedCompareExchange64(&qword_149B3E280, (signed __int64)v1, 0);
    if ( v2 )
    {
      if ( v1 )
      {
        if ( *((int *)*v1 + 0xFFFFFFFF) > 0 )
          sub_147605980((char *)*v1 + 0xFFFFFFF8);
        sub_1402A3D30(v1);
      }
      return v2;
    }
    else
    {
      return qword_149B3E280;
    }
  }
  return result;
}

// --- End Function: sub_1403B1280 (0x1403B1280) ---

// --- Function: sub_1403B1810 (0x1403B1810) ---
__int64 __fastcall sub_1403B1810(__int64 a1)
{
  return a1 + 0x98;
}

// --- End Function: sub_1403B1810 (0x1403B1810) ---

// --- Function: sub_1403B27D0 (0x1403B27D0) ---
_QWORD *__fastcall sub_1403B27D0(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x88);
  return a2;
}

// --- End Function: sub_1403B27D0 (0x1403B27D0) ---

// --- Function: sub_1403B38D0 (0x1403B38D0) ---
__int64 sub_1403B38D0()
{
  __int64 *v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(__int64 **)(NtCurrentTeb_w() + 0x10);
  result = *v0;
  if ( !*v0 )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0x828u);
    if ( v2 )
    {
      v2[3] = &p_p_p_p_p_p_p_p_p_p_p_Source;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *v0 = (__int64)v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 0xC0);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 0xC0) = v6 | 1;
      _tlregdtor((__int64)sub_1480BD400);
    }
    return *v0;
  }
  return result;
}

// --- End Function: sub_1403B38D0 (0x1403B38D0) ---

// --- Function: sub_1403B3E60 (0x1403B3E60) ---
const char *sub_1403B3E60()
{
  return "TraceContext";
}

// --- End Function: sub_1403B3E60 (0x1403B3E60) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403B8470 (0x1403B8470) ---
signed __int64 sub_1403B8470()
{
  void **v0; // rbx
  _QWORD *v1; // rcx

  v0 = (void **)qword_149B3E258;
  if ( !qword_149B3E258 )
  {
    v1 = (_QWORD *)allocWithProfilerInfo_w(8u);
    if ( v1 )
      *v1 = "@LOC_UNINITIALIZED";
    else
      v1 = 0;
    v0 = (void **)_InterlockedCompareExchange64(&qword_149B3E258, (signed __int64)v1, 0);
    if ( v0 )
      sub_1402A3D30(v1);
    else
      v0 = (void **)qword_149B3E258;
  }
  return sub_140351340(&qword_149B3E240, v0);
}

// --- End Function: sub_1403B8470 (0x1403B8470) ---

// --- Function: get_event_key_from_source_location (0x1403BB9D0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149B3D530;
  if ( !qword_149B3D530 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149B3D530 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BB9D0) ---

// --- Function: sub_1403BE7B0 (0x1403BE7B0) ---
unsigned __int64 __fastcall sub_1403BE7B0(__int64 a1, int a2, __int64 a3)
{
  __int64 v4; // rbp
  _QWORD *v6; // rsi
  signed __int64 v7; // rdi
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // r8
  __int64 v13; // rdx
  __int64 v14; // rcx
  void (__fastcall *v15)(__int64); // rax
  __int64 *v16; // rax
  _QWORD *v17; // rcx
  __int64 v19; // [rsp+20h] [rbp-38h] BYREF
  __int64 v20; // [rsp+28h] [rbp-30h]
  __int64 v21; // [rsp+30h] [rbp-28h]
  __int64 v22; // [rsp+38h] [rbp-20h]
  int v23; // [rsp+40h] [rbp-18h]
  _QWORD *v24; // [rsp+48h] [rbp-10h]

  v4 = a1 + 8;
  v6 = (_QWORD *)a1;
  if ( *(_DWORD *)(a1 + 0x18) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v7 = _InterlockedIncrement64((volatile signed __int64 *)v4);
    if ( (v7 & 0x200000) != 0 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
        sub_1403CB380(v4, v7, "SCigEventSystem::InvokeCallbacks", "m_callbackLock");
      else
        sub_1403CB5B0(v4, v7, "SCigEventSystem::InvokeCallbacks", "m_callbackLock");
    }
  }
  v8 = v6[4];
  v9 = v6[5];
  if ( v8 != v9 )
  {
    while ( *(_DWORD *)v8 != a2 )
    {
      v8 += 0x20;
      if ( v8 == v9 )
        return sub_1402D2790(v4);
    }
    v10 = 0;
    v19 = 0;
    v20 = (__int64)(*(_QWORD *)(v8 + 0x10) - *(_QWORD *)(v8 + 8)) >> 5;
    v11 = v20;
    v12 = *(_QWORD *)(v8 + 8);
    v13 = v6[0xE];
    v22 = v13;
    v21 = v12;
    v23 = a2;
    v24 = v6;
    v6[0xE] = &v19;
    if ( v11 > 0 )
    {
      while ( 1 )
      {
        v14 = v12 + 0x20 * v10 + 8;
        v15 = *(void (__fastcall **)(__int64))v14;
        if ( *(_QWORD *)(v14 + 8) == 1 )
          v15(a3);
        else
          ((void (__fastcall *)(__int64, __int64))v15)(v14, a3);
        v10 = v19 + 1;
        v19 = v10;
        if ( v10 >= v20 )
          break;
        v12 = v21;
      }
      v6 = v24;
      v13 = v22;
    }
    v16 = (__int64 *)v6[0xE];
    v17 = v6 + 0xE;
    if ( v16 )
    {
      while ( v16 != &v19 )
      {
        v17 = v16 + 3;
        v16 = (__int64 *)v16[3];
        if ( !v16 )
          return sub_1402D2790(v4);
      }
      *v17 = v13;
    }
  }
  return sub_1402D2790(v4);
}

// --- End Function: sub_1403BE7B0 (0x1403BE7B0) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149B4FCF8;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403C4110 (0x1403C4110) ---
__int64 __fastcall sub_1403C4110(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  __int64 v4; // rcx
  __int64 result; // rax

  *(_BYTE *)a1 = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 == 1 )
  {
    v3 = *(_QWORD *)(a2 + 0x18);
    v4 = *(_QWORD *)(a2 + 0x10);
    result = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 0x18) = 0;
    *(_QWORD *)(a2 + 0x10) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a1 + 8) = result;
    *(_QWORD *)(a1 + 0x10) = v4;
    *(_QWORD *)(a1 + 0x18) = v3;
    __asm { vzeroupper }
  }
  else
  {
    result = *(unsigned int *)(a2 + 8);
    *(_DWORD *)(a1 + 8) = result;
    *(_OWORD *)(a1 + 0x10) = 0;
    *(_QWORD *)(a1 + 0x20) = 0;
    *(_QWORD *)(a1 + 0x28) = 0;
    *(__m256i *)(a1 + 0x10) = *(__m256i *)(a2 + 0x10);
    *(_QWORD *)(a2 + 0x20) = 0;
    *(_QWORD *)(a2 + 0x28) = 0xF;
    *(_BYTE *)(a2 + 0x10) = 0;
    *(_OWORD *)(a1 + 0x30) = 0;
    *(_QWORD *)(a1 + 0x40) = 0;
    *(_QWORD *)(a1 + 0x48) = 0;
    *(__m256i *)(a1 + 0x30) = *(__m256i *)(a2 + 0x30);
    *(_QWORD *)(a2 + 0x40) = 0;
    *(_QWORD *)(a2 + 0x48) = 0xF;
    *(_BYTE *)(a2 + 0x30) = 0;
    __asm { vzeroupper }
  }
  return result;
}

// --- End Function: sub_1403C4110 (0x1403C4110) ---

// --- Function: sub_1403CB380 (0x1403CB380) ---
double __fastcall sub_1403CB380(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  _BYTE v19[16]; // [rsp+30h] [rbp-29h] BYREF
  int n5632; // [rsp+40h] [rbp-19h] BYREF
  __int64 v21; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v23; // [rsp+50h] [rbp-9h]
  unsigned __int64 v24; // [rsp+58h] [rbp-1h]
  __int64 v25; // [rsp+60h] [rbp+7h]
  __int64 v26; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 284LL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 248LL))(v4, v19, &v27);
  if ( (a2 & 0x200000) == 0 )
    return result;
  v12 = (unsigned __int64)v11 << 32;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 292) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n5632 = 5632;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v21 = 1;
      n2 = 2;
      v23 = __rdtsc();
      qword_149B4B870(
        &n5632,
        &word_149B3E384,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        146);
      v15 = word_149B3E384;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(v10 + 292) = -1;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n5632 = 5632;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  n2 = 2;
  v23 = __rdtsc();
  qword_149B4B870(
    &n5632,
    &word_149B3E388,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    177);
  v15 = word_149B3E388;
LABEL_10:
  HIWORD(n5632) = v15;
  qword_149B4B8B0("Lock: %s", a4);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
  qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
  qword_149B4B8B0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 232LL))(v4, v11);
  v24 = __rdtsc();
  return qword_149B4B878(&n5632);
}

// --- End Function: sub_1403CB380 (0x1403CB380) ---

// --- Function: sub_1403CB5B0 (0x1403CB5B0) ---
double __fastcall sub_1403CB5B0(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int *p_n5632; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  int v15; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v16[3]; // [rsp+34h] [rbp-65h] BYREF
  int n5632_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v18; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+50h] [rbp-49h]
  unsigned __int64 v21; // [rsp+58h] [rbp-41h]
  __int64 v22; // [rsp+60h] [rbp-39h]
  __int64 v23; // [rsp+68h] [rbp-31h]
  int n5632; // [rsp+90h] [rbp-9h] BYREF
  __int64 v25; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v27; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v28; // [rsp+A8h] [rbp+Fh]
  __int64 v29; // [rsp+B0h] [rbp+17h]
  __int64 v30; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 296LL))(qword_149B4FCF8, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n5632 = 5632;
        v25 = 1;
        n2 = 2;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v27 = __rdtsc();
        qword_149B4B870(
          &n5632,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          98);
        HIWORD(n5632) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", a4);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v16[0] = v10;
        qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n5632 = &n5632;
        v28 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return result;
    }
    n5632_1 = 5632;
    v18 = 1;
    n2_1 = 2;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v20 = __rdtsc();
    qword_149B4B870(
      &n5632_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      74);
    HIWORD(n5632_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", a4);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
    qword_149B4B8B0("Caller: %s", a3);
    v15 = v6;
    qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n5632 = &n5632_1;
    v21 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_n5632);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: sub_1403CB5B0 (0x1403CB5B0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 192LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 16) & (unsigned int)(v9 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 = (v5 << 16) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 284) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 216LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403DE120 (0x1403DE120) ---
_WORD *__fastcall sub_1403DE120(void **a1, __int64 a2)
{
  _WORD *result; // rax
  _DWORD *v5; // rax

  if ( a2 )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(2 * a2 + 0xA, 0);
    *a1 = v5 + 2;
    *v5 = a2;
    v5[1] = a2;
    result = *a1;
    *((_WORD *)*a1 + a2) = 0;
  }
  else
  {
    result = &unk_149B3E478;
    *a1 = &unk_149B3E478;
  }
  return result;
}

// --- End Function: sub_1403DE120 (0x1403DE120) ---

// --- Function: sub_1403DE2D0 (0x1403DE2D0) ---
void *__fastcall sub_1403DE2D0(void **a1, void *a2, unsigned __int64 a3)
{
  _WORD *v4; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v4 = *a1;
  if ( a3 > *((int *)v4 + 0xFFFFFFFF) )
  {
    v7 = (int *)(v4 + 0xFFFFFFFC);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = &unk_149B3E478;
    if ( a3 )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(2 * a3 + 0xA, 0);
      *a1 = v8 + 2;
      *v8 = a3;
      v8[1] = a3;
      *((_WORD *)*a1 + a3) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, 2 * a3);
  *((_DWORD *)*a1 + 0xFFFFFFFE) = a3;
  result = *a1;
  *((_WORD *)*a1 + a3) = 0;
  return result;
}

// --- End Function: sub_1403DE2D0 (0x1403DE2D0) ---

// --- Function: sub_1403E0E50 (0x1403E0E50) ---
__int64 __fastcall sub_1403E0E50(__int64 a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    sub_140343BB0(v2, *(_QWORD **)(a1 + 8));
    v3 = *(_QWORD **)a1;
    if ( (unsigned __int64)(0x150 * ((*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) / 0x150LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_1403E0E50 (0x1403E0E50) ---

// --- Function: sub_1403E0EE0 (0x1403E0EE0) ---
__int64 __fastcall sub_1403E0EE0(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rdi
  _QWORD *v4; // r8
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; v1 += 3 )
    {
      if ( *(int *)(*v1 - 4LL) > 0 )
        sub_147605980((const void *)(*v1 - 8LL));
    }
    v4 = (_QWORD *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1403E0EE0 (0x1403E0EE0) ---

// --- Function: sub_1403E0FB0 (0x1403E0FB0) ---
__int64 __fastcall sub_1403E0FB0(__int64 a1)
{
  __int64 *v1; // rbx
  __int64 *i; // rsi
  __int64 *v4; // r8
  __int64 result; // rax

  v1 = *(__int64 **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(__int64 **)(a1 + 8); v1 != i; v1 += 0x11 )
      sub_140375DF0(v1);
    v4 = *(__int64 **)a1;
    if ( (unsigned __int64)(0x88 * ((*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) / 0x88LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (__int64 *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_1403E0FB0 (0x1403E0FB0) ---

// --- Function: sub_1403E2E40 (0x1403E2E40) ---
__int64 __fastcall sub_1403E2E40(__int64 a1, __int64 a2)
{
  HMODULE hModule; // rax
  FARPROC ProcAddress; // rbx
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  ProcAddress = GetProcAddress(hModule, "___cigFetchNonWrapFunction___");
  if ( !ProcAddress )
  {
    hModule_1 = LoadLibraryA(0);
    if ( hModule_1 )
      ProcAddress = GetProcAddress(hModule_1, "___cigFetchNonWrapFunction___");
  }
  return ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a1, a2);
}

// --- End Function: sub_1403E2E40 (0x1403E2E40) ---

// --- Function: EnterCriticalSection (0x1403E3690) ---
// attributes: thunk
void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_EnterCriticalSection(lpCriticalSection);
}

// --- End Function: EnterCriticalSection (0x1403E3690) ---

// --- Function: LeaveCriticalSection (0x1403E3CD0) ---
// attributes: thunk
void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_LeaveCriticalSection(lpCriticalSection);
}

// --- End Function: LeaveCriticalSection (0x1403E3CD0) ---

// --- Function: sub_1403E4780 (0x1403E4780) ---
__int64 __fastcall sub_1403E4780(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E4780 (0x1403E4780) ---

// --- Function: sub_1403E47B0 (0x1403E47B0) ---
__int64 __fastcall sub_1403E47B0(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // rdx
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E47B0 (0x1403E47B0) ---

// --- Function: sub_1403E48C0 (0x1403E48C0) ---
__int64 __fastcall sub_1403E48C0(unsigned __int16 **a1, _QWORD *a2)
{
  unsigned __int16 *v2; // rax
  __int64 v3; // r8
  unsigned __int16 v4; // cx

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != *(unsigned __int16 *)((char *)v2 + v3) )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < *(unsigned __int16 *)((char *)v2 + v3) ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E48C0 (0x1403E48C0) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 sub_1403E4B50()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4C70 (0x1403E4C70) ---
__int64 __fastcall sub_1403E4C70(__int64 a1)
{
  __int64 result; // rax

  result = allocWithProfilerInfo_w(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 16) = *(double *)(a1 + 16);
  }
  return result;
}

// --- End Function: sub_1403E4C70 (0x1403E4C70) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
__int64 __fastcall sub_1403E4E60(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4EB0 (0x1403E4EB0) ---
__int64 __fastcall sub_1403E4EB0(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4EB0 (0x1403E4EB0) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---

// --- Function: sub_1403E7690 (0x1403E7690) ---
__int64 __fastcall sub_1403E7690(_DWORD *a1, _DWORD *a2)
{
  char n3; // bl
  unsigned __int64 n0xF_3; // r14
  void **p_Buf2; // rdx
  char *v6; // rdi
  void **p_Buf1; // rcx
  unsigned __int64 n0xF_2; // rbp
  char *v9; // rsi
  unsigned __int8 v10; // r15
  char *v11; // rax
  char *v12; // rax
  void *Buf2[3]; // [rsp+28h] [rbp-70h] BYREF
  unsigned __int64 n0xF; // [rsp+40h] [rbp-58h]
  void *Buf1[2]; // [rsp+48h] [rbp-50h] BYREF
  size_t Size; // [rsp+58h] [rbp-40h]
  unsigned __int64 n0xF_1; // [rsp+60h] [rbp-38h]

  n3 = 0;
  if ( *a1 != *a2 )
  {
    n0xF_3 = n0xF;
    v6 = (char *)Buf2[0];
    n0xF_2 = n0xF_1;
    v9 = (char *)Buf1[0];
    goto LABEL_11;
  }
  sub_1402FBA60((__int64)Buf2, (__int64)(a2 + 2));
  sub_1402FBA60((__int64)Buf1, (__int64)(a1 + 2));
  n0xF_3 = n0xF;
  p_Buf2 = Buf2;
  v6 = (char *)Buf2[0];
  p_Buf1 = Buf1;
  n0xF_2 = n0xF_1;
  v9 = (char *)Buf1[0];
  if ( n0xF > 0xF )
    p_Buf2 = (void **)Buf2[0];
  if ( n0xF_1 > 0xF )
    p_Buf1 = (void **)Buf1[0];
  if ( (void *)Size != Buf2[2] || memcmp(p_Buf1, p_Buf2, Size) )
  {
    n3 = 3;
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  v10 = 1;
  n3 = 3;
LABEL_12:
  if ( (n3 & 2) != 0 )
  {
    n3 &= ~2u;
    if ( n0xF_2 > 0xF )
    {
      v11 = v9;
      if ( n0xF_2 + 1 >= 0x1000 )
      {
        v9 = (char *)*((_QWORD *)v9 + 0xFFFFFFFF);
        if ( (unsigned __int64)(v11 - v9 - 8) > 0x1F )
LABEL_21:
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v9);
    }
  }
  if ( (n3 & 1) != 0 && n0xF_3 > 0xF )
  {
    v12 = v6;
    if ( n0xF_3 + 1 >= 0x1000 )
    {
      v6 = (char *)*((_QWORD *)v6 + 0xFFFFFFFF);
      if ( (unsigned __int64)(v12 - v6 - 8) > 0x1F )
        goto LABEL_21;
    }
    sub_1402A3D30(v6);
  }
  return v10;
}

// --- End Function: sub_1403E7690 (0x1403E7690) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 - 1) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 - 2)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 - 2));
  memset(&(*a1)[*((int *)v3 - 2)], Val_1, Size);
  if ( *((int *)v3 - 1) > 0 )
    sub_147605980(v3 - 8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1403E98E0 (0x1403E98E0) ---
void __fastcall sub_1403E98E0(void **a1, unsigned __int64 a2, __int16 a3)
{
  _WORD *v3; // rdi
  unsigned __int64 v5; // r9
  int *v6; // rsi
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  _WORD *v10; // rdi
  _WORD *v11; // rdi
  unsigned __int64 i; // rcx

  v3 = *a1;
  v5 = *((int *)*a1 + 0xFFFFFFFE);
  v6 = (int *)((char *)*a1 + 0xFFFFFFF8);
  if ( a2 <= v5 )
  {
    if ( a2 >= v5 )
      return;
    *v6 = a2;
    goto LABEL_17;
  }
  v8 = a2 - v5;
  if ( a2 == v5 )
    return;
  if ( a2 <= *((int *)v3 + 0xFFFFFFFF) )
  {
    v11 = &v3[v5];
    for ( i = a2 - v5; i; --i )
      *v11++ = a3;
    *((_DWORD *)*a1 + 0xFFFFFFFE) = a2;
LABEL_17:
    *((_WORD *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    return;
  }
  sub_1403DE120(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, 2LL * *v6);
  v9 = v8;
  v10 = (char *)*a1 + 2 * *v6;
  while ( v9 )
  {
    *v10++ = a3;
    --v9;
  }
  if ( v6[1] > 0 )
    sub_147605980(v6);
}

// --- End Function: sub_1403E98E0 (0x1403E98E0) ---

// --- Function: sub_1403EAFB0 (0x1403EAFB0) ---
__int64 __fastcall sub_1403EAFB0(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 16) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 34;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      v6 = sub_14035AA80((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    *a2 = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FE6B0((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
    return 0xFFFFFFFFLL;
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
    return 0xFFFFFFFFLL;
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 34;
    }
    else
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403EAFB0 (0x1403EAFB0) ---

// --- Function: sub_1403EB130 (0x1403EB130) ---
__int64 __fastcall sub_1403EB130(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  __int64 v8; // rax
  __int64 v10; // rbx
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64, char); // rbp
  __int64 v12; // rax
  unsigned int v13; // ebx
  __int64 v14; // [rsp+40h] [rbp+8h] BYREF

  if ( !qword_149B4FDB8 || !qword_149B4FD68 )
    return 0;
  if ( *a1 )
  {
    sub_1405C2F40(&v14, (__int64)a1);
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FD68 + 0x98LL))(qword_149B4FD68);
    v11 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, char))(*(_QWORD *)v10 + 0x10LL);
    if ( v14 )
      v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x10LL))(v14);
    else
      v12 = 0;
    v13 = v11(v10, v12, a2, a3, a5);
    if ( v14 )
      (**(void (__fastcall ***)(__int64, __int64))v14)(v14, 1);
    return v13;
  }
  else
  {
    v8 = (*(__int64 (**)(void))(*(_QWORD *)qword_149B4FD68 + 0x98LL))();
    return (*(__int64 (__fastcall **)(__int64, _DWORD *, __int64, __int64, char))(*(_QWORD *)v8 + 0x18LL))(
             v8,
             a1,
             a2,
             a3,
             a5);
  }
}

// --- End Function: sub_1403EB130 (0x1403EB130) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n12; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12 = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 = 12;
      if ( (int)n12_1 <= 12 )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n12 + a2), n12_1 - (unsigned int)n12);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v8;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 19;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v10;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 18;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12 += v14;
    if ( n12 < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n12 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return (unsigned int)-1;
  return (unsigned int)n12;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB550 (0x1403EB550) ---
__int64 __fastcall sub_1403EB550(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 16) )
    return sub_14035AA80(a2, a3, 0, v3);
  else
    return sub_1402FE6B0(a2, a3, 0, v3);
}

// --- End Function: sub_1403EB550 (0x1403EB550) ---

// --- Function: sub_1403EB620 (0x1403EB620) ---
__int64 __fastcall sub_1403EB620(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax

  if ( !qword_149B4FDB8 || !qword_149B4FD68 )
    return 0;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FD68 + 0x98LL))(qword_149B4FD68);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v6 + 8LL))(v6, a1, a2, a3);
}

// --- End Function: sub_1403EB620 (0x1403EB620) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: _snprintf_s (0x1403ECF60) ---
int snprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = (unsigned __int64 *)sub_1402A4380();
  result = _stdio_common_vsnprintf_s(*v8, DstBuf, SizeInBytes, MaxCount, Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: _snprintf_s (0x1403ECF60) ---

// --- Function: sub_1403EF290 (0x1403EF290) ---
_OWORD *__fastcall sub_1403EF290(__int64 *a1, _OWORD *a2)
{
  _BYTE *v3; // rdx
  _OWORD *result; // rax

  v3 = (_BYTE *)a1[1];
  if ( v3 == (_BYTE *)a1[2] )
    return sub_140307D70(a1, v3, a2);
  *(_OWORD *)v3 = *a2;
  result = (_OWORD *)a1[1];
  a1[1] = (__int64)(result + 1);
  return result;
}

// --- End Function: sub_1403EF290 (0x1403EF290) ---

// --- Function: sub_14042D760 (0x14042D760) ---
void __fastcall sub_14042D760(__int64 a1, __int64 a2)
{
  char v4; // cl
  _QWORD *v5; // rdi
  __int64 v6; // rbx
  _QWORD *v7; // rbx
  _QWORD *i; // rbp
  _QWORD *v9; // r8

  if ( !*(_BYTE *)(a1 + 0x50) )
  {
    sub_1403C4110(a1, a2);
    *(_BYTE *)(a1 + 0x50) = 1;
    return;
  }
  if ( a2 != a1 )
  {
    v4 = *(_BYTE *)a1;
    v5 = (_QWORD *)(a1 + 8);
    if ( v4 == *(_BYTE *)a2 )
    {
      v6 = a2 + 8;
      if ( *(_BYTE *)a2 == 1 )
      {
        if ( v5 != (_QWORD *)v6 )
        {
          sub_1403E0E50(a1 + 8);
          *v5 = *(_QWORD *)v6;
          *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(v6 + 8);
          *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(v6 + 0x10);
          *(_QWORD *)v6 = 0;
          *(_QWORD *)(v6 + 8) = 0;
          *(_QWORD *)(v6 + 0x10) = 0;
        }
      }
      else
      {
        *(_DWORD *)v5 = *(_DWORD *)v6;
        sub_1402FB060((__int64 *)(a1 + 0x10), (ARLabelMovementType *)(a2 + 0x10));
        sub_1402FB060((__int64 *)(a1 + 0x30), (ARLabelMovementType *)(v6 + 0x28));
      }
      return;
    }
    if ( v4 == 1 )
    {
      v7 = (_QWORD *)*v5;
      if ( *v5 )
      {
        for ( i = *(_QWORD **)(a1 + 0x10); v7 != i; v7 += 0x2A )
          sub_140375760(v7);
        v9 = (_QWORD *)*v5;
        if ( (unsigned __int64)(0x150 * ((*(_QWORD *)(a1 + 0x18) - *(_QWORD *)(a1 + 8)) / 0x150LL)) >= 0x1000 )
        {
          if ( (unsigned __int64)v9 - v9[0xFFFFFFFF] - 8 > 0x1F )
            invalid_parameter_noinfo_noreturn();
          v9 = (_QWORD *)v9[0xFFFFFFFF];
        }
        sub_1402A3D30(v9);
        *v5 = 0;
        *(_QWORD *)(a1 + 0x10) = 0;
        *(_QWORD *)(a1 + 0x18) = 0;
        sub_1403C4110(a1, a2);
        return;
      }
    }
    else
    {
      sub_1403778D0((_QWORD *)(a1 + 8));
    }
    sub_1403C4110(a1, a2);
  }
}

// --- End Function: sub_14042D760 (0x14042D760) ---

// --- Function: sub_14042FD60 (0x14042FD60) ---
void **__fastcall sub_14042FD60(__int64 a1, const void **a2)
{
  __int64 *v2; // rbx
  __int64 *v4; // r8
  void **result; // rax
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rsi
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r15
  __int64 v13; // r12
  _QWORD *v14; // r14
  void **v15; // r13
  __int64 *v16; // rdx
  _QWORD *v17; // r8
  __int64 *v18; // rcx
  __int64 *v19; // rbx
  __int64 *i; // rsi

  v2 = *(__int64 **)(a1 + 8);
  v4 = *(__int64 **)(a1 + 0x10);
  if ( v2 == v4 )
  {
    v7 = *(__int64 **)a1;
    v8 = 0x1FFFFFFFFFFFFFFFLL;
    v9 = v2 - v7;
    if ( v9 == 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v10 = v4 - v7;
    v11 = v10 >> 1;
    v12 = v9 + 1;
    if ( v10 <= 0x1FFFFFFFFFFFFFFFLL - (v10 >> 1) )
    {
      v8 = v11 + v10;
      if ( v11 + v10 < v12 )
        v8 = v9 + 1;
    }
    v13 = v8;
    v14 = (_QWORD *)sub_140391AB0(a1, 8 * v8);
    v15 = (void **)&v14[v9];
    sub_14035B160(v15, a2);
    v16 = *(__int64 **)(a1 + 8);
    v17 = v14;
    v18 = *(__int64 **)a1;
    if ( v2 != v16 )
    {
      sub_14043EFE0(v18, v2, v14);
      v16 = *(__int64 **)(a1 + 8);
      v17 = v15 + 1;
      v18 = v2;
    }
    sub_14043EFE0(v18, v16, v17);
    v19 = *(__int64 **)a1;
    if ( *(_QWORD *)a1 )
    {
      for ( i = *(__int64 **)(a1 + 8); v19 != i; ++v19 )
        sub_140370D10(v19);
      sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    }
    result = v15;
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = &v14[v12];
    *(_QWORD *)(a1 + 0x10) = &v14[v13];
  }
  else
  {
    sub_14035B160(*(void ***)(a1 + 8), a2);
    result = *(void ***)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result + 1;
  }
  return result;
}

// --- End Function: sub_14042FD60 (0x14042FD60) ---

// --- Function: sub_14043EFE0 (0x14043EFE0) ---
_QWORD *__fastcall sub_14043EFE0(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  __int64 *i; // rbx

  for ( i = a1; i != a2; ++i )
    sub_14035B140(a3++, i);
  return a3;
}

// --- End Function: sub_14043EFE0 (0x14043EFE0) ---

// --- Function: sub_140463400 (0x140463400) ---
void __fastcall sub_140463400(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rdi
  char v4; // al
  _QWORD *v5; // rcx

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; v1 += 4 )
    {
      v4 = *((_BYTE *)v1 + 0x18);
      if ( v4 )
      {
        if ( v4 == 1 )
          sub_140370D10(v1 + 1);
        sub_140370D10(v1);
      }
      else
      {
        sub_1404FE420(v1);
      }
    }
    v5 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v5 - v5[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v5 = (_QWORD *)v5[0xFFFFFFFF];
    }
    sub_1402A3D30(v5);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

// --- End Function: sub_140463400 (0x140463400) ---

// --- Function: sub_1404634D0 (0x1404634D0) ---
__int64 __fastcall sub_1404634D0(__int64 a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rdi
  __int64 result; // rax

  v1 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(_QWORD **)(a1 + 8); v1 != i; ++v1 )
      sub_140370D10(v1);
    sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_1404634D0 (0x1404634D0) ---

// --- Function: sub_1404A7660 (0x1404A7660) ---
__int64 __fastcall sub_1404A7660(__int64 a1)
{
  if ( *(_BYTE *)a1 == 1 )
    return sub_1403E0E50(a1 + 8);
  else
    return sub_1403778D0((_QWORD *)(a1 + 8));
}

// --- End Function: sub_1404A7660 (0x1404A7660) ---

// --- Function: sub_1404B22E0 (0x1404B22E0) ---
__int64 __fastcall sub_1404B22E0(__int64 a1)
{
  __int64 v2; // rax

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0xC0LL))(gEnv);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0x10LL))(v2, *(unsigned int *)(a1 + 8));
}

// --- End Function: sub_1404B22E0 (0x1404B22E0) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1480BE950, v3);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: sub_1404B4090 (0x1404B4090) ---
__int64 __fastcall sub_1404B4090(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x18);
}

// --- End Function: sub_1404B4090 (0x1404B4090) ---

// --- Function: sub_1404B8DD0 (0x1404B8DD0) ---
const char *sub_1404B8DD0()
{
  return "Int";
}

// --- End Function: sub_1404B8DD0 (0x1404B8DD0) ---

// --- Function: sub_1404B8E00 (0x1404B8E00) ---
const char *sub_1404B8E00()
{
  return "UInt";
}

// --- End Function: sub_1404B8E00 (0x1404B8E00) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to a thread-specific log context slot. This function first
// obtains a thread-local data block. If the block is valid, it uses an internal
// index (clamped to 15) from the block to calculate and return the address of a
// specific log context slot within that block. If the thread-local data block is
// not available, it returns a pointer to a global fallback context.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *threadDataBlock; // rax
  unsigned __int64 *threadDataBlock_1; // rcx
  unsigned __int64 n0xF; // rax

  threadDataBlock = sub_1404B3EA0();
  threadDataBlock_1 = threadDataBlock;
  if ( !threadDataBlock )
    return &dword_149B45F40;
  n0xF = *threadDataBlock;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&threadDataBlock_1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_1404CC7C0 (0x1404CC7C0) ---
__int64 *__fastcall sub_1404CC7C0(__int64 *a1, __int64 *a2, void (__fastcall **a3)(char *))
{
  __int64 v3; // rbx
  int v7; // edi
  unsigned __int32 v8; // eax
  _OWORD *v9; // rdi
  _BYTE *v10; // rdi
  _QWORD *v11; // rcx
  char *v12; // rdi
  char *v13; // rax
  char *v14; // rdi
  char *v15; // rax
  __int64 *ThreadLogContextSlot; // rax
  void (__fastcall **v17)(char *); // rdi
  void (__fastcall *n2)(char *); // rax
  void (__fastcall *v19)(char *); // rax
  void (__fastcall *n2_1)(char *); // rax
  int v21; // eax
  unsigned __int32 v22; // eax
  void (__fastcall *v23)(char *); // rax
  volatile signed __int32 *v24; // rbx
  volatile signed __int32 *v25; // rbx
  __int64 v26; // rcx
  __int64 v27; // rax
  __int64 *result; // rax
  char v29[8]; // [rsp+20h] [rbp-E0h] BYREF
  _BYTE v30[40]; // [rsp+28h] [rbp-D8h] BYREF
  __m256 v31; // [rsp+50h] [rbp-B0h] BYREF
  char v32; // [rsp+70h] [rbp-90h]
  char v33[8]; // [rsp+80h] [rbp-80h] BYREF
  _BYTE v34[40]; // [rsp+88h] [rbp-78h] BYREF
  __m256 v35; // [rsp+B0h] [rbp-50h] BYREF
  char v36; // [rsp+D0h] [rbp-30h]
  char v37[8]; // [rsp+D8h] [rbp-28h] BYREF
  _QWORD v38[9]; // [rsp+E0h] [rbp-20h] BYREF
  char v39; // [rsp+128h] [rbp+28h]

  v3 = *a1;
  v32 = 0;
  v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v8 )
      sub_1403C33A0(
        v3,
        v8,
        "CFuture<class CigResult<struct EntityGraph::SEntityGraphQueryResult,struct CigError> >::OnResolved",
        1);
    else
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v3 + 0x10) = v7;
  }
  if ( *(_BYTE *)(*a1 + 0x39) )
    goto LABEL_66;
  v9 = (_OWORD *)a1[2];
  if ( *(_BYTE *)(*a1 + 0x38) )
  {
    v10 = (char *)v9 + 0xC8;
    v39 = 0;
    v36 = 0;
    if ( v10[0x50] )
    {
      sub_1403C4110((__int64)v33, (__int64)v10);
      v36 = 1;
      if ( v39 )
      {
        sub_14042D760((__int64)v10, (__int64)v37);
      }
      else if ( v10[0x50] )
      {
        v11 = v10 + 8;
        if ( *v10 == 1 )
          sub_1403E0E50((__int64)v11);
        else
          sub_1403778D0(v11);
        v10[0x50] = 0;
      }
    }
    if ( v36 )
    {
      if ( !v32 )
      {
        v29[0] = v33[0];
        if ( v33[0] == 1 )
        {
          *(_OWORD *)v30 = *(_OWORD *)v34;
          *(_QWORD *)&v30[0x10] = *(_QWORD *)&v34[0x10];
          memset(v34, 0, 0x18);
        }
        else
        {
          *(__m256i *)&v30[8] = *(__m256i *)&v34[8];
          *(_OWORD *)&v34[0x18] = xmmword_1481AA760;
          v31 = v35;
          *(_OWORD *)&v35.m256_f32[4] = xmmword_1481AA760;
          *(_DWORD *)v30 = *(_DWORD *)v34;
          v34[8] = 0;
          LOBYTE(v35.m256_f32[0]) = 0;
        }
        v32 = 1;
LABEL_49:
        if ( v36 )
        {
          __asm { vzeroupper }
          if ( v33[0] == 1 )
            sub_1403E0E50((__int64)v34);
          else
            sub_1403778D0(v34);
        }
        goto LABEL_53;
      }
      if ( v29[0] == v33[0] )
      {
        if ( v33[0] == 1 )
        {
          sub_1403E0E50((__int64)v30);
          *(_OWORD *)v30 = *(_OWORD *)v34;
          memset(v34, 0, 0x18);
          *(_QWORD *)&v30[0x10] = *(_QWORD *)&v34[0x10];
        }
        else
        {
          *(_DWORD *)v30 = *(_DWORD *)v34;
          sub_1402FB060((__int64 *)&v30[8], (ARLabelMovementType *)&v34[8]);
          sub_1402FB060((__int64 *)&v31, (ARLabelMovementType *)&v35);
        }
        goto LABEL_49;
      }
      if ( v29[0] == 1 )
      {
        v12 = *(char **)v30;
        if ( *(_QWORD *)v30 )
        {
          if ( *(_QWORD *)v30 != *(_QWORD *)&v30[8] )
          {
            do
            {
              sub_140375760(v12);
              v12 += 0x150;
            }
            while ( v12 != *(char **)&v30[8] );
            v12 = *(char **)v30;
          }
          v13 = v12;
          if ( (unsigned __int64)(0x150 * ((*(_QWORD *)&v30[0x10] - (_QWORD)v12) / 0x150LL)) < 0x1000
            || (v12 = (char *)*((_QWORD *)v12 + 0xFFFFFFFF), (unsigned __int64)(v13 - v12 - 8) <= 0x1F) )
          {
            sub_1402A3D30(v12);
            memset(v30, 0, 0x18);
            sub_1403C4110((__int64)v29, (__int64)v33);
            goto LABEL_49;
          }
LABEL_45:
          invalid_parameter_noinfo_noreturn();
        }
      }
      else
      {
        sub_1403778D0(v30);
      }
      sub_1403C4110((__int64)v29, (__int64)v33);
      goto LABEL_49;
    }
    if ( !v32 )
    {
LABEL_53:
      if ( v39 )
      {
        __asm { vzeroupper }
        if ( v37[0] == 1 )
          sub_1403E0E50((__int64)v38);
        else
          sub_1403778D0(v38);
      }
      goto LABEL_66;
    }
    if ( v29[0] == 1 )
    {
      v14 = *(char **)v30;
      if ( *(_QWORD *)v30 )
      {
        if ( *(_QWORD *)v30 != *(_QWORD *)&v30[8] )
        {
          do
          {
            sub_140375760(v14);
            v14 += 0x150;
          }
          while ( v14 != *(char **)&v30[8] );
          v14 = *(char **)v30;
        }
        v15 = v14;
        if ( (unsigned __int64)(0x150 * ((*(_QWORD *)&v30[0x10] - (_QWORD)v14) / 0x150LL)) >= 0x1000 )
        {
          v14 = (char *)*((_QWORD *)v14 + 0xFFFFFFFF);
          if ( (unsigned __int64)(v15 - v14 - 8) > 0x1F )
            goto LABEL_45;
        }
        sub_1402A3D30(v14);
        memset(v30, 0, 0x18);
      }
    }
    else
    {
      sub_1403778D0(v30);
    }
    v32 = 0;
    goto LABEL_49;
  }
  ThreadLogContextSlot = getThreadLogContextSlot();
  *v9 = *(_OWORD *)ThreadLogContextSlot;
  v9[1] = *((_OWORD *)ThreadLogContextSlot + 1);
  v9[2] = *((_OWORD *)ThreadLogContextSlot + 2);
  v9[3] = *((_OWORD *)ThreadLogContextSlot + 3);
  v9[4] = *((_OWORD *)ThreadLogContextSlot + 4);
  v9[5] = *((_OWORD *)ThreadLogContextSlot + 5);
  v9[6] = *((_OWORD *)ThreadLogContextSlot + 6);
  v9[7] = *((_OWORD *)ThreadLogContextSlot + 7);
  v9[8] = *((_OWORD *)ThreadLogContextSlot + 8);
  v9[9] = *((_OWORD *)ThreadLogContextSlot + 9);
  v9[0xA] = *((_OWORD *)ThreadLogContextSlot + 0xA);
  v17 = (void (__fastcall **)(char *))(v9 + 0xB);
  n2 = v17[1];
  if ( (unsigned __int64)n2 >= 2 )
  {
    ((void (__fastcall *)(__int64, void (__fastcall **)(char *)))n2)(2, v17);
    v17[1] = 0;
  }
  *v17 = 0;
  v19 = a3[1];
  if ( v19 == (void (__fastcall *)(char *))1 )
  {
    *v17 = *a3;
    v17[1] = a3[1];
  }
  else
  {
    if ( !v19 )
      goto LABEL_66;
    ((void (__fastcall *)(__int64, void (__fastcall **)(char *), void (__fastcall **)(char *)))v19)(1, v17, a3);
  }
  n2_1 = a3[1];
  if ( (unsigned __int64)n2_1 >= 2 )
  {
    ((void (__fastcall *)(__int64, void (__fastcall **)(char *)))n2_1)(2, a3);
    a3[1] = 0;
  }
  *a3 = 0;
LABEL_66:
  v21 = *(_DWORD *)(v3 + 0x14);
  if ( v21 )
  {
    *(_DWORD *)(v3 + 0x14) = v21 - 1;
  }
  else
  {
    *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
    v22 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 0, 1);
    if ( v22 == 1 )
    {
      *(_QWORD *)(v3 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      __asm { vzeroupper }
      sub_1403DB1F0(v3, v22);
    }
  }
  if ( v32 )
  {
    v23 = *a3;
    if ( a3[1] == (void (__fastcall *)(char *))1 )
    {
      __asm { vzeroupper }
      v23(v29);
    }
    else
    {
      __asm { vzeroupper }
      ((void (__fastcall *)(void (__fastcall **)(char *), char *))v23)(a3, v29);
    }
    v24 = (volatile signed __int32 *)a1[1];
    *a1 = 0;
    a1[1] = 0;
    if ( v24 )
    {
      if ( _InterlockedExchangeAdd(v24 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v24)(v24);
        if ( _InterlockedExchangeAdd(v24 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v24 + 8LL))(v24);
      }
    }
  }
  v25 = (volatile signed __int32 *)a1[3];
  a1[2] = 0;
  a1[3] = 0;
  if ( v25 )
  {
    if ( _InterlockedExchangeAdd(v25 + 2, 0xFFFFFFFF) == 1 )
    {
      __asm { vzeroupper }
      (**(void (__fastcall ***)(volatile signed __int32 *))v25)(v25);
      if ( _InterlockedExchangeAdd(v25 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v25 + 8LL))(v25);
    }
  }
  v26 = *a1;
  v27 = a1[1];
  *a1 = 0;
  a1[1] = 0;
  *a2 = v26;
  a2[1] = v27;
  if ( v32 )
  {
    __asm { vzeroupper }
    if ( v29[0] == 1 )
      sub_1403E0E50((__int64)v30);
    else
      sub_1403778D0(v30);
  }
  result = a2;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404CC7C0 (0x1404CC7C0) ---

// --- Function: sub_1404F3FB0 (0x1404F3FB0) ---
__int64 __fastcall sub_1404F3FB0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[40] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[40] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[41] >> 4];
  a2[3] = _0123456789abcdef_[a1[41] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[42] >> 4];
  a2[5] = _0123456789abcdef_[a1[42] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[43] >> 4];
  a2[7] = _0123456789abcdef_[a1[43] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[44] >> 4];
  a2[9] = _0123456789abcdef_[a1[44] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[45] >> 4];
  a2[11] = _0123456789abcdef_[a1[45] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[46] >> 4];
  a2[13] = _0123456789abcdef_[a1[46] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[47] >> 4];
  a2[15] = _0123456789abcdef_[a1[47] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F3FB0 (0x1404F3FB0) ---

// --- Function: sub_1404F4100 (0x1404F4100) ---
__int64 __fastcall sub_1404F4100(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[16] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[16] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[17] >> 4];
  a2[3] = _0123456789abcdef_[a1[17] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[18] >> 4];
  a2[5] = _0123456789abcdef_[a1[18] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[19] >> 4];
  a2[7] = _0123456789abcdef_[a1[19] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[20] >> 4];
  a2[9] = _0123456789abcdef_[a1[20] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[21] >> 4];
  a2[11] = _0123456789abcdef_[a1[21] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[22] >> 4];
  a2[13] = _0123456789abcdef_[a1[22] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[23] >> 4];
  a2[15] = _0123456789abcdef_[a1[23] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[24] >> 4];
  a2[17] = _0123456789abcdef_[a1[24] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[25] >> 4];
  a2[19] = _0123456789abcdef_[a1[25] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[26] >> 4];
  a2[21] = _0123456789abcdef_[a1[26] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[27] >> 4];
  a2[23] = _0123456789abcdef_[a1[27] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[28] >> 4];
  a2[25] = _0123456789abcdef_[a1[28] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[29] >> 4];
  a2[27] = _0123456789abcdef_[a1[29] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[30] >> 4];
  a2[29] = _0123456789abcdef_[a1[30] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[31] >> 4];
  a2[31] = _0123456789abcdef_[a1[31] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4100 (0x1404F4100) ---

// --- Function: sub_1404F4350 (0x1404F4350) ---
__int64 __fastcall sub_1404F4350(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[32] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[32] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[33] >> 4];
  a2[3] = _0123456789abcdef_[a1[33] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[34] >> 4];
  a2[5] = _0123456789abcdef_[a1[34] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[35] >> 4];
  a2[7] = _0123456789abcdef_[a1[35] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[36] >> 4];
  a2[9] = _0123456789abcdef_[a1[36] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[37] >> 4];
  a2[11] = _0123456789abcdef_[a1[37] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[38] >> 4];
  a2[13] = _0123456789abcdef_[a1[38] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[39] >> 4];
  a2[15] = _0123456789abcdef_[a1[39] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F4350 (0x1404F4350) ---

// --- Function: sub_1404F4760 (0x1404F4760) ---
__int64 __fastcall sub_1404F4760(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[11] = _0123456789abcdef_[a1[5] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[13] = _0123456789abcdef_[a1[6] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[15] = _0123456789abcdef_[a1[7] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[17] = _0123456789abcdef_[a1[8] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[19] = _0123456789abcdef_[a1[9] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[10] >> 4];
  a2[21] = _0123456789abcdef_[a1[10] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[11] >> 4];
  a2[23] = _0123456789abcdef_[a1[11] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[12] >> 4];
  a2[25] = _0123456789abcdef_[a1[12] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[13] >> 4];
  a2[27] = _0123456789abcdef_[a1[13] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[14] >> 4];
  a2[29] = _0123456789abcdef_[a1[14] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[15] >> 4];
  a2[31] = _0123456789abcdef_[a1[15] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4760 (0x1404F4760) ---

// --- Function: sub_1404FBC30 (0x1404FBC30) ---
__int64 __fastcall sub_1404FBC30(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rsi
  __int64 result; // rax

  v4 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(_QWORD **)(a1 + 8); v4 != i; ++v4 )
      sub_140370D10(v4);
    sub_1403A3120(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 8 * a3;
  result = a2 + 8 * a4;
  *(_QWORD *)(a1 + 0x10) = result;
  return result;
}

// --- End Function: sub_1404FBC30 (0x1404FBC30) ---

// --- Function: sub_1404FE420 (0x1404FE420) ---
__int64 __fastcall sub_1404FE420(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rsi
  _QWORD *v4; // rcx
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; v1 += 4 )
    {
      sub_1404FE420(v1 + 1);
      sub_140370D10(v1);
    }
    v4 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1404FE420 (0x1404FE420) ---

// --- Function: sub_140504AA0 (0x140504AA0) ---
__int64 __fastcall sub_140504AA0(unsigned __int64 *a1, _BYTE *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  int v6; // eax
  int v7; // esi
  __int64 v8; // rdx
  unsigned __int64 v9; // rbx

  v3 = *a1;
  if ( a3 <= 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    *a2 = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FE6B0((__int64)a2, a3, 1, v3);
  v7 = v6;
  if ( v6 < 0 )
    return 0xFFFFFFFFLL;
  v8 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
    return 0xFFFFFFFFLL;
  v9 = a3 - v8;
  if ( !&a2[v8] )
  {
    *errno() = 0x16;
LABEL_12:
    invalid_parameter_noinfo();
    return (unsigned int)(v7 + 2);
  }
  if ( !v9 )
  {
    *errno() = 0x22;
    goto LABEL_12;
  }
  a2[v8] = 0x22;
  return (unsigned int)(v7 + 2);
}

// --- End Function: sub_140504AA0 (0x140504AA0) ---

// --- Function: sub_140504F50 (0x140504F50) ---
__int64 __fastcall sub_140504F50(unsigned __int64 *a1, __int64 a2, int a3)
{
  return sub_1402FE6B0(a2, a3, 0, *a1);
}

// --- End Function: sub_140504F50 (0x140504F50) ---

// --- Function: sub_140509680 (0x140509680) ---
_QWORD *__fastcall sub_140509680(_QWORD *a1, _QWORD *a2)
{
  __int64 v3; // r8
  __int64 v4; // rax
  __int64 v5; // rcx
  _QWORD *result; // rax

  a1[1] = 0;
  *a1 = 0;
  a1[2] = 0;
  *a1 = *a2;
  *a2 = 0;
  v3 = a1[1];
  a1[1] = a2[1];
  v4 = a2[2];
  a2[1] = v3;
  v5 = a1[2];
  a1[2] = v4;
  result = a1;
  a2[2] = v5;
  return result;
}

// --- End Function: sub_140509680 (0x140509680) ---

// --- Function: sub_140539D30 (0x140539D30) ---
__int64 (__fastcall *__fastcall sub_140539D30(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_14039B170(0, "__InitializeThreadInfoBlock__", 0);
  if ( result )
    return (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}

// --- End Function: sub_140539D30 (0x140539D30) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10(a3);
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DB80 (0x14056DB80) ---
__int64 __fastcall sub_14056DB80(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 0x1000 )
        return 0x1000;
      if ( ++v1 == v2 )
        return 0x1000;
    }
  }
  return 0x1000;
}

// --- End Function: sub_14056DB80 (0x14056DB80) ---

// --- Function: sub_14056DBC0 (0x14056DBC0) ---
__int64 __fastcall sub_14056DBC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E2E40(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056DBC0 (0x14056DBC0) ---

// --- Function: sub_14056DD10 (0x14056DD10) ---
// attributes: thunk
__int64 sub_14056DD10()
{
  return qword_149B4F990();
}

// --- End Function: sub_14056DD10 (0x14056DD10) ---

// --- Function: sub_1405B0470 (0x1405B0470) ---
bool __fastcall sub_1405B0470(__int64 a1)
{
  return *(_QWORD *)a1 && *(_DWORD *)(a1 + 8) != 9;
}

// --- End Function: sub_1405B0470 (0x1405B0470) ---

// --- Function: sub_1405B40F0 (0x1405B40F0) ---
__int64 __fastcall sub_1405B40F0(__int64 a1, __int16 a2)
{
  __int64 *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v7; // rsi
  int *v8; // rbx
  int *v9; // rax
  int v10; // ebx
  int v11; // edi
  __int64 v12; // rdi
  unsigned __int8 (__fastcall *v13)(__int64, __int64, const char *); // rbx
  __int64 v14; // rax
  _BYTE v15[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v16; // [rsp+28h] [rbp-30h]
  _BYTE v17[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v18; // [rsp+40h] [rbp-18h]

  v3 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x60LL))(a1);
  v4 = *v3;
  v5 = v3[1];
  if ( *v3 == v5 )
    return 0;
  while ( *(_WORD *)v4 != a2 )
  {
    v4 += 0x20;
    if ( v4 == v5 )
      return 0;
  }
  v7 = *(_QWORD *)(v4 + 8);
  if ( !v7 )
    return 0;
  v8 = (int *)sub_1405BB430((__int64)v17);
  v9 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 0x18LL))(v7, v15);
  v10 = *v8;
  v11 = *v9;
  if ( v16 )
    sub_147605980(v16);
  if ( v18 )
    sub_147605980(v18);
  if ( v10 != v11 )
  {
    if ( !qword_149B4FCA0 )
      return 0;
    if ( !(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0) )
      return 0;
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0);
    v13 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v12 + 0x100LL);
    v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
    if ( !v13(v12, v14, "VehicleComponentParams") )
      return 0;
  }
  return v7;
}

// --- End Function: sub_1405B40F0 (0x1405B40F0) ---

// --- Function: sub_1405BA390 (0x1405BA390) ---
__int64 __fastcall sub_1405BA390(__int64 a1)
{
  return a1 + 0x90;
}

// --- End Function: sub_1405BA390 (0x1405BA390) ---

// --- Function: sub_1405BA3A0 (0x1405BA3A0) ---
__int64 __fastcall sub_1405BA3A0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 0x20);
}

// --- End Function: sub_1405BA3A0 (0x1405BA3A0) ---

// --- Function: sub_1405C0C30 (0x1405C0C30) ---
_QWORD *__fastcall sub_1405C0C30(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x78);
  return a2;
}

// --- End Function: sub_1405C0C30 (0x1405C0C30) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Logs a fatal error message. If the fatal error system is not properly
// initialized (missing necessary function pointers), it triggers a debug break.
// Otherwise, it formats the provided message into a buffer and dispatches it to an
// external logging function. Execution typically halts after this function.
_BYTE *LogFatalError(const char *formatString, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC pfnInitFatalFunctionsAddr; // rax
  _BYTE *result; // rax
  _QWORD *pStdioCommonVsnprintf; // rax
  int formattedMessageLength; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, formatString);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    pfnInitFatalFunctionsAddr = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))pfnInitFatalFunctionsAddr)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    pStdioCommonVsnprintf = sub_1402A4380();
    formattedMessageLength = _stdio_common_vsprintf(
                               *pStdioCommonVsnprintf | 2LL,
                               formattedMessageBuffer,
                               0x1000u,
                               formatString,
                               0,
                               args);
    if ( formattedMessageLength < 0 )
      formattedMessageLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedMessageLength >= 0x1000 )
      formattedMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_1405C2F40 (0x1405C2F40) ---
_QWORD *__fastcall sub_1405C2F40(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 *v5; // rax
  __int64 v6; // rdx
  void (__fastcall ***v7)(_QWORD, __int64); // rcx
  void (__fastcall ***v9)(_QWORD, __int64); // [rsp+30h] [rbp+8h] BYREF

  *a1 = 0;
  if ( qword_149B4FDB8 && qword_149B4FD68 )
  {
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FD68 + 0x98LL))(qword_149B4FD68);
    v5 = (__int64 *)(*(__int64 (__fastcall **)(__int64, void (__fastcall ****)(_QWORD, __int64), __int64))(*(_QWORD *)v4 + 0x30LL))(
                      v4,
                      &v9,
                      a2);
    v6 = *v5;
    *v5 = 0;
    v7 = (void (__fastcall ***)(_QWORD, __int64))*a1;
    *a1 = v6;
    if ( v7 )
      (**v7)(v7, 1);
    if ( v9 )
      (**v9)(v9, 1);
  }
  return a1;
}

// --- End Function: sub_1405C2F40 (0x1405C2F40) ---

// --- Function: InitTraceContextPlayerIdIntDescriptor (0x140A60210) ---
// Initializes a structure to describe a "PlayerId" field within a "TraceContext"
// for logging or telemetry. It sets up various function pointers for
// serialization, deserialization, comparison, and memory management specific to an
// integer type. The PlayerId value itself is copied from the provided source.
__int64 __fastcall InitTraceContextPlayerIdIntDescriptor(
        __int64 fieldDescriptor,
        __int64 threadLogContextSlot,
        _QWORD *playerIdValuePtr)
{
  __int64 fieldCount; // rax

  *(_QWORD *)fieldDescriptor = threadLogContextSlot;
  *(_QWORD *)(fieldDescriptor + 8) = "TraceContext";
  *(_WORD *)(fieldDescriptor + 0x58) = 0x100;
  *(_QWORD *)(fieldDescriptor + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(fieldDescriptor + 0x20) = sub_1403EB240;
  *(_QWORD *)(fieldDescriptor + 0x30) = sub_1403E77F0;
  *(_QWORD *)(fieldDescriptor + 0x40) = sub_1403E4E60;
  *(_QWORD *)(fieldDescriptor + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(fieldDescriptor + 0x78) = "PlayerId";
  *(_QWORD *)(fieldDescriptor + 0x10) = 0;
  *(_QWORD *)(fieldDescriptor + 0x28) = 0;
  *(_QWORD *)(fieldDescriptor + 0x38) = 0;
  *(_QWORD *)(fieldDescriptor + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(fieldDescriptor + 0x60) = 0xB0;
  *(_QWORD *)(fieldDescriptor + 0x68) = 0xA8;
  *(_QWORD *)(fieldDescriptor + 0x70) = playerIdValuePtr;
  *(_BYTE *)(fieldDescriptor + 0xC9) = 1;
  *(_QWORD *)(fieldDescriptor + 0x80) = *playerIdValuePtr;
  *(_QWORD *)(fieldDescriptor + 0x88) = sub_1403EB550;
  *(_QWORD *)(fieldDescriptor + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(fieldDescriptor + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(fieldDescriptor + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(fieldDescriptor + 0xB8) = sub_1403E4C70;
  fieldCount = 2;
  *(_QWORD *)(fieldDescriptor + 0x98) = 0;
  *(_QWORD *)(fieldDescriptor + 0xA8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(fieldDescriptor + 0xC8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xD0) = 0x18;
  *(_QWORD *)(fieldDescriptor + 0xD8) = 0x17;
  return fieldCount;
}

// --- End Function: InitTraceContextPlayerIdIntDescriptor (0x140A60210) ---

// --- Function: InitTraceContextPlayerIdErrorDetailsDescriptor (0x140A60320) ---
// Initializes a complex structure to describe a "TraceContext" event, including
// "PlayerId" and "ErrorDetails" fields. It configures function pointers for
// serialization, deserialization, comparison, and memory management for both the
// PlayerId (integer type) and ErrorDetails (custom type) sections. This function
// is used to set up the descriptor for structured logging of events with
// associated error information.
__int64 __fastcall InitTraceContextPlayerIdErrorDetailsDescriptor(
        __int64 fieldDescriptor,
        __int64 *threadLogContextSlot,
        _QWORD *playerIdValuePtr,
        __int64 errorDetailsPtr)
{
  __int64 fieldCount; // rax

  *(_QWORD *)fieldDescriptor = threadLogContextSlot;
  *(_QWORD *)(fieldDescriptor + 8) = "TraceContext";
  *(_WORD *)(fieldDescriptor + 0x58) = 0x100;
  *(_QWORD *)(fieldDescriptor + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(fieldDescriptor + 0x20) = sub_1403EB240;
  *(_QWORD *)(fieldDescriptor + 0x30) = sub_1403E77F0;
  *(_QWORD *)(fieldDescriptor + 0x40) = sub_1403E4E60;
  *(_QWORD *)(fieldDescriptor + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(fieldDescriptor + 0x78) = "PlayerId";
  *(_QWORD *)(fieldDescriptor + 0x10) = 0;
  *(_QWORD *)(fieldDescriptor + 0x28) = 0;
  *(_QWORD *)(fieldDescriptor + 0x38) = 0;
  *(_QWORD *)(fieldDescriptor + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(fieldDescriptor + 0x60) = 0xB0;
  *(_QWORD *)(fieldDescriptor + 0x68) = 0xA8;
  *(_QWORD *)(fieldDescriptor + 0x70) = playerIdValuePtr;
  *(_BYTE *)(fieldDescriptor + 0xC9) = 1;
  *(_QWORD *)(fieldDescriptor + 0x80) = *playerIdValuePtr;
  *(_QWORD *)(fieldDescriptor + 0x88) = sub_1403EB550;
  *(_QWORD *)(fieldDescriptor + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(fieldDescriptor + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(fieldDescriptor + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(fieldDescriptor + 0xB8) = sub_1403E4C70;
  *(_QWORD *)(fieldDescriptor + 0xE8) = "ErrorDetails";
  *(_QWORD *)(fieldDescriptor + 0xF8) = sub_1403EB620;
  *(_QWORD *)(fieldDescriptor + 0x100) = sub_1403EB130;
  *(_QWORD *)(fieldDescriptor + 0x110) = sub_1403E7690;
  *(_QWORD *)(fieldDescriptor + 0x120) = sub_1403E4E60;
  *(_QWORD *)(fieldDescriptor + 0x128) = allocWithProfilerInfo_ww;
  fieldCount = 3;
  *(_QWORD *)(fieldDescriptor + 0x98) = 0;
  *(_QWORD *)(fieldDescriptor + 0xA8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(fieldDescriptor + 0xC8) = 0;
  *(_QWORD *)(fieldDescriptor + 0xD0) = 0x18;
  *(_QWORD *)(fieldDescriptor + 0xD8) = 0x17;
  *(_QWORD *)(fieldDescriptor + 0xE0) = errorDetailsPtr;
  *(_WORD *)(fieldDescriptor + 0x138) = 0;
  *(_QWORD *)(fieldDescriptor + 0xF0) = 0;
  *(_QWORD *)(fieldDescriptor + 0x108) = 0;
  *(_QWORD *)(fieldDescriptor + 0x118) = 0;
  *(_QWORD *)(fieldDescriptor + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(fieldDescriptor + 0x140) = 0x48;
  *(_QWORD *)(fieldDescriptor + 0x148) = 0x800;
  return fieldCount;
}

// --- End Function: InitTraceContextPlayerIdErrorDetailsDescriptor (0x140A60320) ---

// --- Function: sub_140A60850 (0x140A60850) ---
__int64 __fastcall sub_140A60850(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "PlayerId";
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x20) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0x30) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4C70;
  result = 1;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  *(_QWORD *)(a1 + 0x68) = 0x17;
  return result;
}

// --- End Function: sub_140A60850 (0x140A60850) ---

// --- Function: sub_140AB53A0 (0x140AB53A0) ---
unsigned __int64 __fastcall sub_140AB53A0(__int64 **a1, unsigned __int64 a2)
{
  __int64 *v4; // rcx
  unsigned __int64 result; // rax
  __int64 v6; // r15
  __int64 v7; // rax
  __int64 *v8; // r14
  __int64 v9; // r12
  __int64 *v10; // rbx
  _QWORD *i; // rdi

  v4 = *a1;
  result = a1[2] - v4;
  if ( a2 > result )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v6 = a1[1] - v4;
    v7 = sub_140391AB0((__int64)a1, 8 * a2);
    v8 = a1[1];
    v9 = v7;
    v10 = *a1;
    for ( i = (_QWORD *)v7; v10 != v8; ++v10 )
      sub_14035B140(i++, v10);
    return sub_1404FBC30((__int64)a1, v9, v6, a2);
  }
  return result;
}

// --- End Function: sub_140AB53A0 (0x140AB53A0) ---

// --- Function: sub_140AB91C0 (0x140AB91C0) ---
unsigned __int64 __fastcall sub_140AB91C0(__int64 a1, _QWORD *a2)
{
  return 0x100000001B3LL
       * (HIBYTE(*a2)
        ^ (0x100000001B3LL
         * ((unsigned __int8)BYTE6(*a2)
          ^ (0x100000001B3LL
           * ((0x100000001B3LL
             * ((unsigned __int8)BYTE4(*a2)
              ^ (0x100000001B3LL
               * (BYTE3(*a2)
                ^ (0x100000001B3LL
                 * ((unsigned __int8)BYTE2(*a2)
                  ^ (0x100000001B3LL
                   * ((unsigned __int8)BYTE1(*a2) ^ (0x100000001B3LL * ((unsigned __int8)*a2 ^ 0xCBF29CE484222325uLL))))))))))
            ^ (unsigned __int8)((unsigned __int16)WORD2(*a2) >> 8))))));
}

// --- End Function: sub_140AB91C0 (0x140AB91C0) ---

// --- Function: sub_140AFA420 (0x140AFA420) ---
_QWORD *__fastcall sub_140AFA420(__int64 *a1, __int64 *a2)
{
  __int64 *v3; // rbx
  _QWORD *result; // rax

  if ( a1 != a2 )
  {
    v3 = a1 + 0x11;
    do
    {
      sub_140463400(v3 + 1);
      sub_140370D10(v3);
      sub_140370D10(v3 + 0xFFFFFFFF);
      sub_1403E0EE0(v3 + 0xFFFFFFFA);
      sub_1403E0FB0((__int64)(v3 + 0xFFFFFFF7));
      sub_140370D10(v3 + 0xFFFFFFF0);
      v3 += 0x16;
      result = v3 + 0xFFFFFFEF;
    }
    while ( v3 + 0xFFFFFFEF != a2 );
  }
  return result;
}

// --- End Function: sub_140AFA420 (0x140AFA420) ---

// --- Function: sub_140B01DB0 (0x140B01DB0) ---
void __fastcall sub_140B01DB0(__int64 **a1)
{
  sub_140AFA420(*a1, a1[1]);
  if ( *a1 )
    sub_1402A3D30(*a1);
}

// --- End Function: sub_140B01DB0 (0x140B01DB0) ---

// --- Function: sub_140B9AF10 (0x140B9AF10) ---
__int64 __fastcall sub_140B9AF10(__int64 a1, __int64 *ThreadLogContextSlot, __int64 a3, __int64 a4)
{
  __int64 n3; // rax

  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x78) = "EntityId";
  *(_QWORD *)(a1 + 0x88) = sub_140504F50;
  *(_QWORD *)(a1 + 0x90) = sub_140504AA0;
  *(_QWORD *)(a1 + 0xA0) = std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0xB8) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0xE8) = "ErrorDetails";
  *(_QWORD *)(a1 + 0xF8) = sub_1403EB620;
  *(_QWORD *)(a1 + 0x100) = sub_1403EB130;
  *(_QWORD *)(a1 + 0x110) = sub_1403E7690;
  *(_QWORD *)(a1 + 0x120) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x128) = allocWithProfilerInfo_ww;
  n3 = 3;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_WORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 8;
  *(_QWORD *)(a1 + 0xD8) = 0x17;
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_WORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x140) = 0x48;
  *(_QWORD *)(a1 + 0x148) = 0x800;
  return n3;
}

// --- End Function: sub_140B9AF10 (0x140B9AF10) ---

// --- Function: sub_1412251A0 (0x1412251A0) ---
__int64 __fastcall sub_1412251A0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 n2; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "PlayerId";
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x20) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0x30) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4C70;
  *(_QWORD *)(a1 + 0x78) = "EntityId";
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  *(_QWORD *)(a1 + 0x68) = 0x17;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_BYTE *)(a1 + 0xC9) = 1;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4C70;
  n2 = 2;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  *(_QWORD *)(a1 + 0xD8) = 0x17;
  return n2;
}

// --- End Function: sub_1412251A0 (0x1412251A0) ---

// --- Function: sub_14122A290 (0x14122A290) ---
__int64 __fastcall sub_14122A290(__int64 a1, int a2, _OWORD *a3)
{
  *(_OWORD *)(a1 + 8) = *a3;
  *(_DWORD *)a1 = a2;
  return a1;
}

// --- End Function: sub_14122A290 (0x14122A290) ---

// --- Function: sub_141259930 (0x141259930) ---
RtAudio::Api *__fastcall sub_141259930(__int64 a1, int a2, int n149)
{
  __int64 *v3; // rsi
  __int64 inserted; // rcx
  __int64 v8; // rax
  __int64 v9; // rax
  __int128 v10; // xmm0
  RtAudio::Api *_Whereptr_1; // rax
  __int64 v12; // rcx
  RtAudio::Api *_Whereptr; // rdx
  __int128 v14; // [rsp+20h] [rbp-38h] BYREF
  int n149_1; // [rsp+70h] [rbp+18h] BYREF

  n149_1 = n149;
  v3 = *(__int64 **)a1;
  DWORD2(v14) = 0;
  inserted = (__int64)v3;
  v8 = v3[1];
  *(_QWORD *)&v14 = v8;
  while ( !*(_BYTE *)(v8 + 0x19) )
  {
    *(_QWORD *)&v14 = v8;
    if ( *(_DWORD *)(v8 + 0x20) >= a2 )
    {
      inserted = v8;
      DWORD2(v14) = 1;
      v8 = *(_QWORD *)v8;
    }
    else
    {
      v8 = *(_QWORD *)(v8 + 0x10);
      DWORD2(v14) = 0;
    }
  }
  if ( *(_BYTE *)(inserted + 0x19) || a2 < *(_DWORD *)(inserted + 0x20) )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFLL )
      unknown_libname_7();
    v9 = allocWithProfilerInfo_w(0x40u);
    v10 = v14;
    *(_DWORD *)(v9 + 0x20) = a2;
    *(_QWORD *)(v9 + 0x28) = 0;
    *(_QWORD *)(v9 + 0x30) = 0;
    *(_QWORD *)(v9 + 0x38) = 0;
    *(_QWORD *)v9 = v3;
    *(_QWORD *)(v9 + 8) = v3;
    *(_QWORD *)(v9 + 0x10) = v3;
    *(_WORD *)(v9 + 0x18) = 0;
    v14 = v10;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 (__int64 **)a1,
                 (__int64)&v14,
                 v9);
  }
  _Whereptr_1 = *(RtAudio::Api **)(inserted + 0x28);
  v12 = inserted + 0x28;
  if ( n149 == 0x95 )
  {
    if ( _Whereptr_1 != *(RtAudio::Api **)(v12 + 8) )
      *(_QWORD *)(v12 + 8) = _Whereptr_1;
  }
  else
  {
    _Whereptr = *(RtAudio::Api **)(v12 + 8);
    if ( _Whereptr_1 == _Whereptr )
    {
LABEL_14:
      if ( _Whereptr == *(RtAudio::Api **)(v12 + 0x10) )
      {
        return std::vector<enum RtAudio::Api>::_Emplace_reallocate<enum RtAudio::Api>(
                 (std::vector<enum RtAudio::Api> *)v12,
                 _Whereptr,
                 (RtAudio::Api *)&n149_1);
      }
      else
      {
        *(_DWORD *)_Whereptr = n149;
        *(_QWORD *)(v12 + 8) += 4LL;
      }
    }
    else
    {
      while ( *(_DWORD *)_Whereptr_1 != n149 )
      {
        _Whereptr_1 = (RtAudio::Api *)((char *)_Whereptr_1 + 4);
        if ( _Whereptr_1 == _Whereptr )
          goto LABEL_14;
      }
    }
  }
  return _Whereptr_1;
}

// --- End Function: sub_141259930 (0x141259930) ---

// --- Function: sub_1415A29D0 (0x1415A29D0) ---
void __fastcall sub_1415A29D0(__int64 *p_memoryManager, __int64 n2)
{
  p_memoryManager[7] |= n2;
}

// --- End Function: sub_1415A29D0 (0x1415A29D0) ---

// --- Function: sub_141848E00 (0x141848E00) ---
_QWORD *__fastcall sub_141848E00(_QWORD *p_pExceptionObject)
{
  p_pExceptionObject[1] = "bad allocation";
  *p_pExceptionObject = off_1481A05A8;
  return p_pExceptionObject;
}

// --- End Function: sub_141848E00 (0x141848E00) ---

// --- Function: ?deallocate@__crt_win32_buffer_no_resizing@@SAXQEAXAEBV__crt_win32_buffer_empty_debug_info@@@Z (0x1426D7AA0) ---
// Microsoft VisualC v14 64bit runtime
void __fastcall __crt_win32_buffer_no_resizing::deallocate(
        void *const a1,
        const struct __crt_win32_buffer_empty_debug_info *a2)
{
  ;
}

// --- End Function: ?deallocate@__crt_win32_buffer_no_resizing@@SAXQEAXAEBV__crt_win32_buffer_empty_debug_info@@@Z (0x1426D7AA0) ---

// --- Function: ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@1@@Z (0x1426FC3B0) ---
_QWORD *__fastcall std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
        Parameter *Parameter_1,
        __int64 a2)
{
  *Parameter_1 = a2;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@1@@Z (0x1426FC3B0) ---

// --- Function: ZeroInitializeAndNotifyEngine (0x1426FC500) ---
// Initializes the first three QWORDs of the provided structure to zero. Following
// initialization, it invokes the _StarEngineModule__ callback, likely to register
// or notify the engine about the state of this parameter.
Parameter *__fastcall ZeroInitializeAndNotifyEngine(Parameter *Parameter)
{
  *(_QWORD *)Parameter = 0;
  *((_QWORD *)Parameter + 1) = 0;
  *((_QWORD *)Parameter + 2) = 0;
  _StarEngineModule__((ULONG_PTR)Parameter);
  return Parameter;
}

// --- End Function: ZeroInitializeAndNotifyEngine (0x1426FC500) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || sub_140539D80() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: add_0xC7 (0x142744750) ---
// This function takes an unsigned 8-bit integer, casts it to an unsigned integer,
// and adds the constant value 0xC7 (199) to it, returning the result as a 64-bit
// integer.
__int64 __fastcall add_0xC7(unsigned __int8 a1)
{
  return (unsigned int)a1 + 0xC7;
}

// --- End Function: add_0xC7 (0x142744750) ---

// --- Function: sub_14277C8E0 (0x14277C8E0) ---
Parameter *__fastcall sub_14277C8E0(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  Parameter *Parameter_2; // [rsp+30h] [rbp-38h]
  _QWORD *v4; // [rsp+48h] [rbp-20h]

  v4 = (_QWORD *)((char *)Parameter + 8);
  Parameter_2 = (Parameter *)((char *)Parameter + 0x10);
  _StarEngineModule__((ULONG_PTR)Parameter);
  Parameter_1 = Parameter;
  if ( *(_QWORD *)Parameter )
  {
    std::_Deallocate<16,0>(
      *(_QWORD **)Parameter,
      0x10 * ((__int64)(*(_QWORD *)Parameter_2 - *(_QWORD *)Parameter) >> 4));
    *(_QWORD *)Parameter = 0;
    *v4 = 0;
    Parameter_1 = Parameter_2;
    *(_QWORD *)Parameter_2 = 0;
  }
  return Parameter_1;
}

// --- End Function: sub_14277C8E0 (0x14277C8E0) ---

// --- Function: unknown_libname_67 (0x14277CFC0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_67()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_67 (0x14277CFC0) ---

// --- Function: Handle_GetRawPointerIfValid (0x14277D6A0) ---
// Checks if a given handle is valid using `Handle::IsValid`. If valid, it extracts
// and returns the raw pointer or value stored within the handle; otherwise, it
// returns 0.
__int64 __fastcall Handle_GetRawPointerIfValid(_QWORD *handle_ptr)
{
  if ( Handle::IsValid(handle_ptr) )
    return *handle_ptr & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: Handle_GetRawPointerIfValid (0x14277D6A0) ---

// --- Function: sub_14277DDD0 (0x14277DDD0) ---
_QWORD *__fastcall sub_14277DDD0(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v5)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v8; // [rsp+50h] [rbp+18h] BYREF
  char v9; // [rsp+58h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
  v3 = v2;
  if ( v2 )
  {
    n0xFFFF = n0xFFFF_8;
    v5 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v2 + 0x340LL);
    if ( n0xFFFF_8 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v8,
                            "SCAirTrafficControllerDataManager");
      n0xFFFF_8 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v5(v3, &v9, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_14277DDD0 (0x14277DDD0) ---

// --- Function: sub_14282BD80 (0x14282BD80) ---
Parameter *__fastcall sub_14282BD80(Parameter *Parameter, __int64 *a2)
{
  __int64 v3; // [rsp+50h] [rbp-88h]
  __int64 v4; // [rsp+60h] [rbp-78h]
  __int64 v5; // [rsp+70h] [rbp-68h]

  v3 = a2[2];
  a2[2] = 0;
  v4 = a2[1];
  a2[1] = 0;
  v5 = *a2;
  *a2 = 0;
  *(_QWORD *)Parameter = v5;
  *((_QWORD *)Parameter + 1) = v4;
  *((_QWORD *)Parameter + 2) = v3;
  _StarEngineModule__((ULONG_PTR)Parameter);
  _StarEngineModule__((ULONG_PTR)Parameter);
  return Parameter;
}

// --- End Function: sub_14282BD80 (0x14282BD80) ---

// --- Function: sub_142C14530 (0x142C14530) ---
__int64 __fastcall sub_142C14530(__int64 a1)
{
  const char *v2; // [rsp+20h] [rbp-28h]
  __int64 (__fastcall *v3)(__int64, const char *); // [rsp+28h] [rbp-20h]

  v3 = *(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 0x80LL);
  v2 = sub_14258AFE0();
  return v3(a1, v2);
}

// --- End Function: sub_142C14530 (0x142C14530) ---

// --- Function: sub_142C7E820 (0x142C7E820) ---
void **__fastcall sub_142C7E820(void **a1, __int64 a2, unsigned int a3)
{
  const void **v6; // rax
  __int16 n0xFFFF; // dx
  __int64 v8; // rax
  char **v9; // rdx
  __int64 v10; // rax
  const char *v11; // rax
  const void **v12; // rax
  char *v14; // rdi
  _QWORD *v15; // rax
  __int64 v16; // rax
  const wchar_t *v17; // [rsp+30h] [rbp-18h] BYREF
  _QWORD v18[2]; // [rsp+38h] [rbp-10h] BYREF
  void *v19; // [rsp+58h] [rbp+10h] BYREF
  void *v20; // [rsp+68h] [rbp+20h] BYREF

  if ( !a2 )
    goto LABEL_11;
  v6 = (const void **)sub_1403B8470();
  sub_14035B160(&v20, v6);
  n0xFFFF = n0xFFFF_9;
  if ( n0xFFFF_9 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, void **, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v19,
                          "Vehicle");
    n0xFFFF_9 = n0xFFFF;
  }
  v8 = sub_1405B40F0(a2, n0xFFFF);
  if ( v8 )
  {
    v9 = (char **)(v8 + 0x128);
  }
  else
  {
    v10 = sub_142C14530(a2);
    if ( !v10 )
      goto LABEL_9;
    v9 = (char **)(v10 + 0x40);
  }
  copyStringStructure((char **)&v20, v9);
LABEL_9:
  if ( !(unsigned int)sub_1403E47B0((unsigned __int8 **)&v20, (__int64)"@LOC_UNINITIALIZED") )
  {
    v11 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 0x18LL))(a2);
    sub_1405C0E00(
      0xAu,
      2u,
      "%s : Class %s has uninitialized localized name",
      "CGameLocalizationHelper::GetUniqueNameLocString",
      v11);
    sub_140370D10(&v20);
LABEL_11:
    v12 = (const void **)sub_1403AE630();
    sub_14035B410(a1, v12);
    return a1;
  }
  if ( a3 <= 1 )
  {
    sub_14035F010(a1, (unsigned __int8 **)&v20);
    sub_140370D10(&v20);
    return a1;
  }
  else
  {
    v14 = off_1499CA508;                        // "@vehicle_UniqueNameFormatNumber"
    sub_14035B3E0(&v19);
    if ( v14 )
    {
      if ( *v14 == 0x40 )
        assignCStringToStringStructure(&v19, v14);
    }
    sub_14035F010(&v17, (unsigned __int8 **)&v19);
    v15 = sub_14035F010(v18, (unsigned __int8 **)&v20);
    v16 = sub_1402A2660((__int64)v15);
    sub_14039F0F0(a1, &v17, v16, a3);
    sub_140370D10(v18);
    sub_140370D10(&v17);
    sub_140370D10(&v19);
    sub_140370D10(&v20);
    return a1;
  }
}

// --- End Function: sub_142C7E820 (0x142C7E820) ---

// --- Function: sub_142CAF900 (0x142CAF900) ---
_BOOL8 __fastcall sub_142CAF900(__int64 a1)
{
  __int64 v1; // rax
  float v2; // xmm0_4
  float v3; // kr00_4
  float v4; // xmm1_4
  float v5; // kr00_4
  __int64 v7; // [rsp+18h] [rbp-10h]

  v7 = *(_QWORD *)(a1 + 0x38);
  v1 = *(_QWORD *)(a1 + 0x10) + 1LL;
  if ( v1 < 0 )
  {
    v3 = (float)(v1 & 1 | ((unsigned __int64)v1 >> 1));
    v2 = v3 + v3;
  }
  else
  {
    v2 = (float)v1;
  }
  if ( v7 < 0 )
  {
    v5 = (float)(*(_QWORD *)(a1 + 0x38) & 1uLL | (*(_QWORD *)(a1 + 0x38) >> 1));
    v4 = v5 + v5;
  }
  else
  {
    v4 = (float)v7;
  }
  return *(float *)a1 < (float)(v2 / v4);
}

// --- End Function: sub_142CAF900 (0x142CAF900) ---

// --- Function: sub_142CB0B40 (0x142CB0B40) ---
AK::WriteBytesCount *sub_142CB0B40(_QWORD *a1, __int64 a2, ...)
{
  _QWORD *v3; // [rsp+20h] [rbp-38h]
  _QWORD *v4; // [rsp+28h] [rbp-30h] BYREF
  _QWORD *v5; // [rsp+30h] [rbp-28h]
  __int64 v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  __int64 v8; // [rsp+48h] [rbp-10h]
  __int64 v11; // [rsp+70h] [rbp+18h] BYREF
  va_list va; // [rsp+70h] [rbp+18h]
  AK::WriteBytesCount *v13; // [rsp+78h] [rbp+20h]
  va_list va1; // [rsp+80h] [rbp+28h] BYREF

  va_start(va1, a2);
  va_start(va, a2);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, AK::WriteBytesCount *);
  v4 = *(_QWORD **)(v11 + 8);
  ++a1[2];
  sub_14281EE90(v13, (__int64 *)va);
  sub_14281EE90((AK::WriteBytesCount *)((char *)v13 + 8), &v4);
  *v4 = v13;
  *(_QWORD *)(v11 + 8) = v13;
  v8 = a1[1];
  v7 = a1[3];
  v6 = a1[6] & a2;
  v3 = (_QWORD *)(v7 + 0x10 * v6);
  v5 = v3 + 1;
  if ( *v3 == v8 )
  {
    *v3 = v13;
    *v5 = v13;
  }
  else if ( *v3 == v11 )
  {
    *v3 = v13;
  }
  else if ( (_QWORD *)*v5 == v4 )
  {
    *v5 = v13;
  }
  return v13;
}

// --- End Function: sub_142CB0B40 (0x142CB0B40) ---

// --- Function: sub_142D418C0 (0x142D418C0) ---
_OWORD *__fastcall sub_142D418C0(__int64 *a1, _BYTE *a2, _OWORD *a3)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rdi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  void *v15; // rcx
  _OWORD *v16; // r14
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  _BYTE *v20; // rcx
  _OWORD *result; // rax

  v4 = (unsigned __int64)&a2[-*a1];
  v5 = (a1[1] - *a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
    unknown_libname_67();
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_24;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 0x10 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = v14;
  v16 = (_OWORD *)((char *)v14 + (v4 & 0xFFFFFFFFFFFFFFF0uLL));
  *v16 = *a3;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v15 = v16 + 1;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v15, v18, Size);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v20[-*((_QWORD *)v20 + 0xFFFFFFFF) - 8] <= 0x1F )
    {
      v20 = (_BYTE *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v14;
  result = v16;
  a1[1] = (__int64)&v14[2 * v8];
  a1[2] = (__int64)&v14[allocSize / 8];
  return result;
}

// --- End Function: sub_142D418C0 (0x142D418C0) ---

// --- Function: sub_1432A7770 (0x1432A7770) ---
__int64 __fastcall sub_1432A7770(__int64 a1, __int64 a2)
{
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  sub_1432A9E00((unsigned __int64 (__fastcall **)(__int64, __int64))a1, &v4);
  return a1;
}

// --- End Function: sub_1432A7770 (0x1432A7770) ---

// --- Function: sub_1432A9E00 (0x1432A9E00) ---
unsigned __int64 (__fastcall **__fastcall sub_1432A9E00(
        unsigned __int64 (__fastcall **a1)(__int64 a1, __int64 a2),
        _QWORD *a2))(__int64 a1, __int64 a2)
{
  unsigned __int64 (__fastcall **result)(__int64, __int64); // rax
  unsigned __int64 (__fastcall *v3)(__int64, __int64); // [rsp+20h] [rbp-18h]
  unsigned __int64 (__fastcall *v4)(__int64, __int64); // [rsp+28h] [rbp-10h]

  sub_1402A2AD0(a1);
  v3 = (unsigned __int64 (__fastcall *)(__int64, __int64))allocWithProfilerInfo_w(8u);
  if ( v3 )
  {
    *(_QWORD *)v3 = *a2;
    v4 = v3;
  }
  else
  {
    v4 = 0;
  }
  a1[2] = v4;
  *a1 = sub_143310F40;
  result = a1;
  a1[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))sub_143312300;
  return result;
}

// --- End Function: sub_1432A9E00 (0x1432A9E00) ---

// --- Function: sub_1432C6CE0 (0x1432C6CE0) ---
_QWORD *__fastcall sub_1432C6CE0(_QWORD *a1, _QWORD *a2, std::pmr::_Identity_equal_resource **a3, __int64 a4)
{
  __int64 v5; // [rsp+28h] [rbp-40h]
  __int64 v6; // [rsp+30h] [rbp-38h]
  __int64 v7; // [rsp+38h] [rbp-30h]
  __int64 v8; // [rsp+48h] [rbp-20h]

  v7 = a1[6] & a4;
  v5 = *(_QWORD *)(a1[3] + 0x10 * v7 + 8);
  v6 = a1[1];
  if ( v5 == v6 )
  {
    *a2 = v6;
    a2[1] = 0;
    return a2;
  }
  else
  {
    v8 = *(_QWORD *)(a1[3] + 0x10 * v7);
    while ( 1 )
    {
      if ( std::pmr::_Identity_equal_resource::do_is_equal(*a3, *(const struct std::pmr::memory_resource **)(v5 + 0x10)) )
      {
        *a2 = *(_QWORD *)v5;
        a2[1] = v5;
        return a2;
      }
      if ( v5 == v8 )
        break;
      v5 = *(_QWORD *)(v5 + 8);
    }
    *a2 = v5;
    a2[1] = 0;
    return a2;
  }
}

// --- End Function: sub_1432C6CE0 (0x1432C6CE0) ---

// --- Function: sub_1432C6E40 (0x1432C6E40) ---
_QWORD *__fastcall sub_1432C6E40(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  _QWORD *v5; // [rsp+8h] [rbp-40h]
  _QWORD *v6; // [rsp+10h] [rbp-38h]
  __int64 v7; // [rsp+18h] [rbp-30h]

  v7 = a1[6] & a4;
  v5 = *(_QWORD **)(a1[3] + 0x10 * v7 + 8);
  v6 = (_QWORD *)a1[1];
  if ( v5 == v6 )
  {
    *a2 = v6;
    a2[1] = 0;
    return a2;
  }
  else
  {
    while ( 1 )
    {
      if ( *a3 == v5[2] )
      {
        *a2 = *v5;
        a2[1] = v5;
        return a2;
      }
      if ( v5 == *(_QWORD **)(a1[3] + 0x10 * v7) )
        break;
      v5 = (_QWORD *)v5[1];
    }
    *a2 = v5;
    a2[1] = 0;
    return a2;
  }
}

// --- End Function: sub_1432C6E40 (0x1432C6E40) ---

// --- Function: sub_1432D8300 (0x1432D8300) ---
_QWORD *__fastcall sub_1432D8300(_QWORD *a1, Parameter *Parameter_1, std::pmr::_Identity_equal_resource **a3)
{
  __int64 v4; // [rsp+20h] [rbp-48h]
  __int64 v5; // [rsp+28h] [rbp-40h]
  unsigned __int64 v6; // [rsp+40h] [rbp-28h]
  _QWORD v7[3]; // [rsp+50h] [rbp-18h] BYREF

  v6 = sub_140AB91C0((__int64)a1, a3);
  v4 = sub_1432C6CE0(a1, v7, a3, v6)[1];
  if ( v4 )
    v5 = v4;
  else
    v5 = a1[1];
  *Parameter_1 = v5;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_1432D8300 (0x1432D8300) ---

// --- Function: sub_143310F40 (0x143310F40) ---
unsigned __int64 __fastcall sub_143310F40(__int64 a1, __int64 a2)
{
  return sub_1403BE7B0(a2, *(_DWORD *)(*(_QWORD *)(a1 + 0x10) + 4LL), *(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_143310F40 (0x143310F40) ---

// --- Function: sub_143312300 (0x143312300) ---
unsigned __int64 (__fastcall **__fastcall sub_143312300(
        int n2,
        unsigned __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        unsigned __int64 (__fastcall **a3)(__int64 a1, __int64 a2)))(__int64 a1, __int64 a2)
{
  unsigned __int64 (__fastcall **result)(__int64, __int64); // rax
  unsigned __int64 (__fastcall *v4)(__int64, __int64); // [rsp+50h] [rbp-38h]
  unsigned __int64 (__fastcall *v5)(__int64, __int64); // [rsp+58h] [rbp-30h]
  unsigned __int64 (__fastcall *v6)(__int64, __int64); // [rsp+60h] [rbp-28h]

  if ( n2 )
  {
    if ( n2 == 1 )
    {
      result = a3;
      if ( *a3 )
      {
        if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
        {
          a2[2] = 0;
          *a2 = *a3;
          a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
        }
        else
        {
          a2[2] = a3[2];
          *a2 = *a3;
          a2[1] = a3[1];
        }
        a3[2] = 0;
        *a3 = 0;
        result = a3;
        a3[1] = 0;
      }
    }
    else if ( n2 == 2 )
    {
      sub_1402A3D30(a2[2]);
      a2[2] = 0;
      *a2 = 0;
      result = a2;
      a2[1] = 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v6 = a3[2];
    result = a3;
    if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        result = a2;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v4 = (unsigned __int64 (__fastcall *)(__int64, __int64))allocWithProfilerInfo_w(8u);
        if ( v4 )
        {
          *(_QWORD *)v4 = *(_QWORD *)v6;
          v5 = v4;
        }
        else
        {
          v5 = 0;
        }
        a2[2] = v5;
        *a2 = sub_143310F40;
        result = a2;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))sub_143312300;
      }
    }
  }
  return result;
}

// --- End Function: sub_143312300 (0x143312300) ---

// --- Function: sub_143502490 (0x143502490) ---
_QWORD *__fastcall sub_143502490(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_10;
  if ( n0xFFFF_10 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "Wallet");
    n0xFFFF_10 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_143502490 (0x143502490) ---

// --- Function: sub_1436C6BA0 (0x1436C6BA0) ---
_QWORD *__fastcall sub_1436C6BA0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // [rsp+28h] [rbp-70h]
  _QWORD *v5; // [rsp+30h] [rbp-68h]
  _QWORD v6[2]; // [rsp+40h] [rbp-58h] BYREF
  _QWORD src_[2]; // [rsp+50h] [rbp-48h] BYREF
  __int64 v8; // [rsp+60h] [rbp-38h] BYREF
  _BYTE dst_[40]; // [rsp+70h] [rbp-28h] BYREF

  src_[0] = p_p_p_sub_140384A94;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, 0x10u);
  __crt_win32_buffer_no_resizing::deallocate(0, (const struct __crt_win32_buffer_empty_debug_info *)dst_);
  v2 = identity_int64((__int64)&qword_149B4FBE0);
  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(v2 + 0xA0) + 0x118LL))(*(_QWORD *)(v2 + 0xA0), a2);
  if ( v4 )
  {
    v5 = sub_143502490(v4, &v8);
  }
  else
  {
    v6[0] = 0;
    v5 = v6;
  }
  v6[1] = v5;
  *a1 = *v5;
  return a1;
}

// --- End Function: sub_1436C6BA0 (0x1436C6BA0) ---

// --- Function: sub_143DBC250 (0x143DBC250) ---
unsigned __int64 __fastcall sub_143DBC250(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [rsp+20h] [rbp-38h]
  __int64 v4; // [rsp+30h] [rbp-28h]
  __int64 v5; // [rsp+40h] [rbp-18h] BYREF
  __int64 v6; // [rsp+48h] [rbp-10h] BYREF

  v3 = (a1[2] - *a1) / 0x88LL;
  v5 = 0x1E1E1E1E1E1E1E1LL;
  v6 = __crt_strtox::maximum_signed_value((__crt_strtox *)0x88);
  v4 = *unknown_libname_2(&v6, &v5);
  if ( v3 > v4 - v3 / 2 )
    return v4;
  if ( v3 / 2 + v3 >= a2 )
    return v3 / 2 + v3;
  return a2;
}

// --- End Function: sub_143DBC250 (0x143DBC250) ---

// --- Function: sub_143DC0750 (0x143DC0750) ---
__int64 __fastcall sub_143DC0750(__crt_strtox *a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+20h] [rbp-28h] BYREF
  __int64 v3; // [rsp+28h] [rbp-20h] BYREF
  __int64 v4; // [rsp+30h] [rbp-18h]
  __int64 v5; // [rsp+38h] [rbp-10h]

  v5 = *((_QWORD *)a1 + 2);
  v2 = 0x3FFFFFFFFFFFFFFLL;
  v3 = __crt_strtox::maximum_signed_value(a1);
  v4 = *unknown_libname_2(&v3, &v2);
  result = v4;
  if ( v5 == v4 )
    std::_Xlength_error("unordered_map/set too long");
  return result;
}

// --- End Function: sub_143DC0750 (0x143DC0750) ---

// --- Function: sub_143F5BCA0 (0x143F5BCA0) ---
_QWORD *__fastcall sub_143F5BCA0(_QWORD *a1, __int64 a2, const void *src, _QWORD *a4)
{
  unsigned __int64 _Bytes; // rax
  _QWORD *dst; // [rsp+20h] [rbp-48h]

  *a1 = a2;
  a1[1] = 0;
  a1[1] = 0;
  _Bytes = sub_1402A8690(1u);
  a1[1] = std::_Allocate<16,std::_Default_allocate_traits,0>(_Bytes);
  dst = (_QWORD *)sub_1402A2B80(0x30, a1[1] + 0x10LL);
  qmemcpy(dst, src, 0x10u);
  dst[2] = *a4;
  sub_14035AE20(dst + 3, a4 + 1);
  return a1;
}

// --- End Function: sub_143F5BCA0 (0x143F5BCA0) ---

// --- Function: sub_143F6F7A0 (0x143F6F7A0) ---
_QWORD *__fastcall sub_143F6F7A0(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  _QWORD *v5; // [rsp+28h] [rbp-40h]
  _QWORD *v6; // [rsp+30h] [rbp-38h]
  __int64 v7; // [rsp+38h] [rbp-30h]
  _QWORD *v8; // [rsp+48h] [rbp-20h]

  v7 = a1[6] & a4;
  v5 = *(_QWORD **)(a1[3] + 0x10 * v7 + 8);
  v6 = (_QWORD *)a1[1];
  if ( v5 == v6 )
  {
    *a2 = v6;
    a2[1] = 0;
    return a2;
  }
  else
  {
    v8 = *(_QWORD **)(a1[3] + 0x10 * v7);
    while ( 1 )
    {
      if ( sub_1402B4B90(a3, v5 + 2) )
      {
        *a2 = *v5;
        a2[1] = v5;
        return a2;
      }
      if ( v5 == v8 )
        break;
      v5 = (_QWORD *)v5[1];
    }
    *a2 = v5;
    a2[1] = 0;
    return a2;
  }
}

// --- End Function: sub_143F6F7A0 (0x143F6F7A0) ---

// --- Function: sub_143F70740 (0x143F70740) ---
__int64 __fastcall sub_143F70740(__int64 a1)
{
  return sub_143F6F900(0xCBF29CE484222325uLL, a1);
}

// --- End Function: sub_143F70740 (0x143F70740) ---

// --- Function: sub_143F7C510 (0x143F7C510) ---
__int64 __fastcall sub_143F7C510(__crt_strtox *a1, __int64 a2, _BYTE *dst, _QWORD *a4)
{
  __int64 v5; // [rsp+28h] [rbp-D0h]
  ULONG_PTR Parameter; // [rsp+38h] [rbp-C0h] BYREF
  ULONG_PTR Parameter_; // [rsp+48h] [rbp-B0h] BYREF
  _QWORD dst_[9]; // [rsp+50h] [rbp-A8h] BYREF
  __int64 v10; // [rsp+98h] [rbp-60h]
  AK::WriteBytesCount *Parameter__1; // [rsp+A0h] [rbp-58h]
  _QWORD *v12; // [rsp+A8h] [rbp-50h]
  Parameter *Parameter_1; // [rsp+B0h] [rbp-48h]
  __int64 v14; // [rsp+B8h] [rbp-40h] BYREF
  __int64 v15; // [rsp+C0h] [rbp-38h]
  _QWORD v16[6]; // [rsp+C8h] [rbp-30h] BYREF

  dst_[2] = a1;
  dst_[3] = a1;
  v5 = psub_1403360E0_w((__int64)a1, (__int64)dst);
  sub_143F6F7A0(a1, dst_, dst, v5);
  if ( dst_[1] )
  {
    dst_[5] = (char *)a1 + 8;
    dst_[4] = dst_[1];
    Parameter = dst_[1];
    _StarEngineModule__((ULONG_PTR)&Parameter);
    dst_[6] = &Parameter;
    *(_QWORD *)a2 = Parameter;
    *(_BYTE *)(a2 + 8) = 0;
    return a2;
  }
  else
  {
    sub_143DC0750(a1);
    sub_143F5BCA0(&v14, (__int64)a1 + 8, dst, a4);
    if ( sub_142CAF900((__int64)a1) )
    {
      sub_143FE6320(a1);
      dst_[7] = v15 + 0x10;
      qmemcpy(dst_, sub_143F6F7A0(a1, v16, (_QWORD *)(v15 + 0x10), v5), 0x10u);
    }
    v12 = (_QWORD *)((char *)a1 + 8);
    dst_[8] = 0;
    v10 = v15;
    v15 = 0;
    Parameter__1 = sub_142CB0B40(a1, v5, dst_[0], v10);
    Parameter_ = (ULONG_PTR)Parameter__1;
    _StarEngineModule__((ULONG_PTR)&Parameter_);
    Parameter_1 = &Parameter_;
    *(_QWORD *)a2 = Parameter_;
    *(_BYTE *)(a2 + 8) = 1;
    sub_143F851C0(&v14);
    return a2;
  }
}

// --- End Function: sub_143F7C510 (0x143F7C510) ---

// --- Function: sub_143F7D3E0 (0x143F7D3E0) ---
_QWORD *__fastcall sub_143F7D3E0(_QWORD *a1, Parameter *Parameter_1, _QWORD *va1)
{
  __int64 v4; // [rsp+20h] [rbp-48h]
  __int64 v5; // [rsp+28h] [rbp-40h]
  __int64 v6; // [rsp+38h] [rbp-30h]
  _QWORD v7[3]; // [rsp+50h] [rbp-18h] BYREF

  v6 = sub_143F70740((__int64)va1);
  v4 = sub_1432C6E40(a1, v7, va1, v6)[1];
  if ( v4 )
    v5 = v4;
  else
    v5 = a1[1];
  *Parameter_1 = v5;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_143F7D3E0 (0x143F7D3E0) ---

// --- Function: sub_143F851C0 (0x143F851C0) ---
void __fastcall sub_143F851C0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 8) )
    sub_1402A2AD0((_QWORD *)(*(_QWORD *)(a1 + 8) + 0x28LL));
  if ( *(_QWORD *)(a1 + 8) )
    std::_Deallocate<16,0>(*(_QWORD **)(a1 + 8), 0x40u);
}

// --- End Function: sub_143F851C0 (0x143F851C0) ---

// --- Function: ?do_put@?$time_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBUtm@@DD@Z_0 (0x143F9A220) ---
__int64 std::time_put<char,std::ostreambuf_iterator<char>>::do_put(__int64 a1, const void *src, ...)
{
  char v3; // [rsp+30h] [rbp-B8h] BYREF
  unsigned int v4; // [rsp+34h] [rbp-B4h]
  unsigned int v5; // [rsp+38h] [rbp-B0h]
  _QWORD *v6; // [rsp+40h] [rbp-A8h]
  _QWORD *v7; // [rsp+48h] [rbp-A0h]
  __int64 v8; // [rsp+50h] [rbp-98h]
  __int64 v9; // [rsp+58h] [rbp-90h]
  __int128 dst_; // [rsp+60h] [rbp-88h] BYREF
  _BYTE dst__1[16]; // [rsp+70h] [rbp-78h] BYREF
  _BYTE dst__2[16]; // [rsp+80h] [rbp-68h] BYREF
  _QWORD v13[3]; // [rsp+90h] [rbp-58h] BYREF
  _BYTE v14[24]; // [rsp+A8h] [rbp-40h] BYREF
  __int64 v17; // [rsp+100h] [rbp+18h] BYREF
  va_list va; // [rsp+100h] [rbp+18h]
  __int64 *v19; // [rsp+108h] [rbp+20h]
  va_list va1; // [rsp+110h] [rbp+28h] BYREF

  va_start(va1, src);
  va_start(va, src);
  v17 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, __int64 *);
  qmemcpy(&dst_, &src__1, sizeof(dst_));
  sub_14122A290((__int64)v14, 0, &dst_);
  v3 = 0;
  v4 = sub_143FAC680(a1, (unsigned int)&v3, (unsigned int)v14, (_DWORD)src, (__int64)va, (__int64)v19);
  if ( v3 )
  {
    v9 = a1 + 8;
    v6 = v13;
    v7 = sub_1402FAA80(v13, v19);
    v8 = v17;
    qmemcpy(dst__1, src, sizeof(dst__1));
    qmemcpy(dst__2, dst__1, sizeof(dst__2));
    sub_143F9A540(v9, (unsigned int)v14, (unsigned int)dst__2, v17, (__int64)v7);
  }
  v5 = v4;
  std::vector<GSC::AI::GameGraph::game_graph_edge>::~vector<GSC::AI::GameGraph::game_graph_edge>((std::vector<GSC::AI::GameGraph::game_graph_edge> *)v19);
  return v5;
}

// --- End Function: ?do_put@?$time_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBUtm@@DD@Z_0 (0x143F9A220) ---

// --- Function: sub_143F9A540 (0x143F9A540) ---
void __fastcall sub_143F9A540(__int64 a1, __int64 a2, const void *dst, __int64 a4, __int64 *a5)
{
  _QWORD *v5; // [rsp+40h] [rbp-B8h]
  void (__fastcall *v6)(__int64, _BYTE *, __int64, _QWORD *); // [rsp+48h] [rbp-B0h]
  _QWORD *v7; // [rsp+58h] [rbp-A0h]
  void (__fastcall *v8)(__int64, _BYTE *, __int64, _QWORD *); // [rsp+60h] [rbp-98h]
  _BYTE dst_[16]; // [rsp+68h] [rbp-90h] BYREF
  _BYTE dst__1[16]; // [rsp+80h] [rbp-78h] BYREF
  _BYTE dst__2[16]; // [rsp+90h] [rbp-68h] BYREF
  _BYTE dst__3[16]; // [rsp+A0h] [rbp-58h] BYREF
  _QWORD v13[3]; // [rsp+B0h] [rbp-48h] BYREF
  _QWORD v14[6]; // [rsp+C8h] [rbp-30h] BYREF

  if ( *(_QWORD *)(a1 + 8) == 1 )
  {
    v6 = *(void (__fastcall **)(__int64, _BYTE *, __int64, _QWORD *))a1;
    v5 = sub_1402FAA80(v13, a5);
    qmemcpy(dst_, dst, sizeof(dst_));
    qmemcpy(dst__1, dst_, sizeof(dst__1));
    v6(a2, dst__1, a4, v5);
    std::vector<GSC::AI::GameGraph::game_graph_edge>::~vector<GSC::AI::GameGraph::game_graph_edge>((std::vector<GSC::AI::GameGraph::game_graph_edge> *)a5);
  }
  else
  {
    v8 = *(void (__fastcall **)(__int64, _BYTE *, __int64, _QWORD *))a1;
    v7 = sub_1402FAA80(v14, a5);
    qmemcpy(dst__2, dst, sizeof(dst__2));
    qmemcpy(dst__3, dst__2, sizeof(dst__3));
    ((void (__fastcall *)(__int64, __int64, _BYTE *, __int64, _QWORD *))v8)(a1, a2, dst__3, a4, v7);
    std::vector<GSC::AI::GameGraph::game_graph_edge>::~vector<GSC::AI::GameGraph::game_graph_edge>((std::vector<GSC::AI::GameGraph::game_graph_edge> *)a5);
  }
}

// --- End Function: sub_143F9A540 (0x143F9A540) ---

// --- Function: sub_143F9FED0 (0x143F9FED0) ---
__int64 __fastcall sub_143F9FED0(__int64 a1, __int64 a2, __int64 *a3, _QWORD *a4)
{
  __int64 v5; // [rsp+20h] [rbp-108h]
  __int64 v6; // [rsp+28h] [rbp-100h] BYREF
  __int64 v7; // [rsp+30h] [rbp-F8h] BYREF
  void (__fastcall *v8)(__int64, _BYTE *); // [rsp+38h] [rbp-F0h]
  _QWORD *v9; // [rsp+40h] [rbp-E8h]
  __crt_strtox *v10; // [rsp+48h] [rbp-E0h]
  _QWORD *v11; // [rsp+50h] [rbp-D8h]
  _QWORD *v12; // [rsp+58h] [rbp-D0h]
  __int64 v13; // [rsp+60h] [rbp-C8h]
  __int64 v14; // [rsp+68h] [rbp-C0h]
  __int64 v15; // [rsp+70h] [rbp-B8h] BYREF
  _BYTE dst_[16]; // [rsp+78h] [rbp-B0h] BYREF
  _BYTE dst__1[16]; // [rsp+90h] [rbp-98h] BYREF
  __int64 v18; // [rsp+A0h] [rbp-88h] BYREF
  _QWORD v19[3]; // [rsp+A8h] [rbp-80h] BYREF
  __int64 v20; // [rsp+C0h] [rbp-68h] BYREF
  _QWORD v21[2]; // [rsp+D0h] [rbp-58h] BYREF
  _QWORD v22[3]; // [rsp+E0h] [rbp-48h] BYREF
  _BYTE dst[16]; // [rsp+F8h] [rbp-30h] BYREF

  v6 = 0;
  v7 = 0;
  qmemcpy(dst, unknown_libname_6(&v20, &v7, &v6), sizeof(dst));
  v5 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0xC0);
  v8 = *(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v5 + 0x700LL);
  v8(v5, dst);
  sub_1402AE3D0(&v15, "CWallet::Authority_Request_FilterAvailableShips", a1 + 0x3F8, 1);
  v10 = (__crt_strtox *)(a1 + 0x3B8);
  v18 = a2;
  v9 = v19;
  sub_14035AE20(v19, a4);
  sub_143F7C510(v10, (__int64)v21, dst, &v18);
  sub_1402A2AD0(v19);
  v14 = a1 + 0x358;
  v11 = v22;
  v12 = sub_1402FAA80(v22, a3);
  v13 = a2;
  qmemcpy(dst_, dst, sizeof(dst_));
  qmemcpy(dst__1, dst_, sizeof(dst__1));
  std::time_put<char,std::ostreambuf_iterator<char>>::do_put(v14, dst__1, a2, v12);
  sub_1402B1820(&v15);
  return sub_1402A2AD0(a4);
}

// --- End Function: sub_143F9FED0 (0x143F9FED0) ---

// --- Function: sub_143FA4AF0 (0x143FA4AF0) ---
_BYTE *sub_143FA4AF0(__int64 a1, _BYTE *a2, ...)
{
  _QWORD v3[2]; // [rsp+30h] [rbp-98h] BYREF
  ULONG_PTR Parameter[2]; // [rsp+40h] [rbp-88h] BYREF
  ULONG_PTR Parameter_; // [rsp+50h] [rbp-78h] BYREF
  _QWORD v6[3]; // [rsp+58h] [rbp-70h] BYREF
  ULONG_PTR v7; // [rsp+70h] [rbp-58h]
  __int64 v8; // [rsp+78h] [rbp-50h]
  __int64 v9; // [rsp+80h] [rbp-48h]
  __int64 v10; // [rsp+88h] [rbp-40h]
  __int64 v11; // [rsp+90h] [rbp-38h]
  __int64 v12; // [rsp+98h] [rbp-30h]
  ULONG_PTR Parameter__1; // [rsp+A0h] [rbp-28h]
  __int64 v14; // [rsp+A8h] [rbp-20h]
  __int64 v15; // [rsp+B0h] [rbp-18h]
  __int64 v18; // [rsp+E0h] [rbp+18h] BYREF
  va_list va; // [rsp+E0h] [rbp+18h]
  va_list va1; // [rsp+E8h] [rbp+20h] BYREF

  va_start(va1, a2);
  va_start(va, a2);
  v18 = va_arg(va1, _QWORD);
  v6[1] = a1 + 0x410;
  sub_1432D8300(a1 + 0x410, v3, (__int64 *)va);
  v6[2] = a1 + 0x410;
  v3[1] = a1 + 0x418;
  v8 = a1 + 0x418;
  v7 = *(_QWORD *)(a1 + 0x418);
  Parameter[0] = v7;
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( v3[0] == Parameter[0] )
  {
    identity_int64((__int64)a2);
    a2[1] = 0;
    return a2;
  }
  else
  {
    v9 = v3[0] + 0x10LL;
    v10 = v3[0] + 0x18LL;
    sub_143F7D3E0(v3[0] + 0x18LL, v6, (__int64 *)va1);
    v11 = v3[0] + 0x10LL;
    v12 = v3[0] + 0x18LL;
    Parameter[1] = v3[0] + 0x20LL;
    v14 = v3[0] + 0x20LL;
    Parameter__1 = *(_QWORD *)(v3[0] + 0x20LL);
    Parameter_ = Parameter__1;
    _StarEngineModule__((ULONG_PTR)&Parameter_);
    if ( v6[0] == Parameter_ )
    {
      identity_int64((__int64)a2);
      a2[1] = 0;
    }
    else
    {
      v15 = v6[0] + 0x10LL;
      *a2 = *(_BYTE *)(v6[0] + 0x18LL);
      a2[1] = 1;
    }
    return a2;
  }
}

// --- End Function: sub_143FA4AF0 (0x143FA4AF0) ---

// --- Function: sub_143FAC680 (0x143FAC680) ---
__int64 __fastcall sub_143FAC680(__int64 a1, __int64 a2, __int64 a3, const void *src, va_list va, __int64 a6)
{
  unsigned int v7; // [rsp+40h] [rbp-108h]
  __int64 v8; // [rsp+48h] [rbp-100h]
  ULONG_PTR Parameter; // [rsp+50h] [rbp-F8h] BYREF
  __int64 v10; // [rsp+58h] [rbp-F0h]
  __int64 v11; // [rsp+60h] [rbp-E8h] BYREF
  va_list va_1; // [rsp+68h] [rbp-E0h] BYREF
  _QWORD v13[5]; // [rsp+70h] [rbp-D8h] BYREF
  __int64 (__fastcall *p_sub_143FE2450)(); // [rsp+98h] [rbp-B0h]
  __int64 *v15; // [rsp+A0h] [rbp-A8h]
  __int64 *v16; // [rsp+A8h] [rbp-A0h]
  va_list *p_va; // [rsp+B0h] [rbp-98h]
  va_list *p_va_1; // [rsp+B8h] [rbp-90h]
  __int64 *v19; // [rsp+C0h] [rbp-88h]
  __int64 *v20; // [rsp+C8h] [rbp-80h]
  _QWORD *v21; // [rsp+D0h] [rbp-78h]
  __int64 (__fastcall **p_p_sub_143FE2450)(); // [rsp+D8h] [rbp-70h]
  __int64 v23; // [rsp+E0h] [rbp-68h]
  __int64 (__fastcall *v24)(__int64, _QWORD, __int64, __int64, _QWORD *, __int64); // [rsp+E8h] [rbp-60h]
  __int64 v25[2]; // [rsp+F0h] [rbp-58h] BYREF
  _QWORD v26[2]; // [rsp+100h] [rbp-48h] BYREF
  __int64 (__fastcall *p_sub_143FE2450_1)(); // [rsp+110h] [rbp-38h] BYREF
  __int64 v28; // [rsp+118h] [rbp-30h] BYREF
  va_list va_2; // [rsp+120h] [rbp-28h] BYREF
  __int64 v30; // [rsp+128h] [rbp-20h] BYREF
  __int64 v31; // [rsp+130h] [rbp-18h] BYREF

  v8 = ((__int64)(*(_QWORD *)(a1 + 0x20) << 0x10) >> 0x10) & 0xFFFFFFFFFFFFLL;
  if ( !v8 )
    return 1;
  sub_14035AE10(&Parameter);
  Parameter = (ULONG_PTR)&off_1481AF030;
  v10 = 0;
  sub_140338040((__int64)&Parameter);
  sub_140525200((__int64)&Parameter);
  sub_143F618A0(&Parameter, a6);
  v23 = v10;
  p_sub_143FE2450 = sub_143FE2450;
  v24 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _QWORD *, __int64))(*(_QWORD *)v8 + 8LL);
  v21 = (_QWORD *)identity_int64((__int64)v25);
  v13[2] = a6;
  v11 = a6;
  v15 = &v11;
  v13[3] = va;
  va_1 = va;
  p_va = &va_1;
  v13[4] = src;
  v13[0] = src;
  v19 = v13;
  v13[1] = &p_sub_143FE2450_1;
  p_sub_143FE2450_1 = p_sub_143FE2450;
  identity_int64((__int64)&v28);
  v16 = &v28;
  v28 = *v15;
  p_va_1 = &va_2;
  va_2 = *p_va;
  v20 = &v30;
  v30 = *v19;
  v25[1] = (__int64)&v31;
  p_p_sub_143FE2450 = &p_sub_143FE2450_1;
  sub_1436BB760(v26, (__int64)&p_sub_143FE2450_1, v21);
  v7 = v24(v8, *(_WORD *)(a1 + 0x28) & 0x3FFF, a3, v23, v26, a2);
  sub_1402A2B70(v25);
  _StarEngineModule__((ULONG_PTR)&Parameter);
  return v7;
}

// --- End Function: sub_143FAC680 (0x143FAC680) ---

// --- Function: sub_143FE6320 (0x143FE6320) ---
__int64 __fastcall sub_143FE6320(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_143FE3F50(a1);
  return sub_143FE5410(a1, v1);
}

// --- End Function: sub_143FE6320 (0x143FE6320) ---

// --- Function: Handle_GetRawPointerIfValid_w (0x1442DE8E0) ---
__int64 __fastcall sub_1442DE8E0(__int64 a1)
{
  return Handle_GetRawPointerIfValid((_QWORD *)(a1 + 0x70));
}

// --- End Function: Handle_GetRawPointerIfValid_w (0x1442DE8E0) ---

// --- Function: sub_14458F090 (0x14458F090) ---
void **__fastcall sub_14458F090(void **a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int64 *); // rsi
  __int64 v6; // rbx
  __int64 v7; // rax
  __int16 n4; // cx
  const void **v10; // rax
  _BYTE v11[24]; // [rsp+20h] [rbp-18h] BYREF
  __int64 v12; // [rsp+50h] [rbp+18h] BYREF
  char v13; // [rsp+58h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
  v3 = v2;
  if ( !v2 )
    goto LABEL_11;
  n0xFFFF = n0xFFFF_7;
  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v2 + 0x340LL);
  if ( n0xFFFF_7 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v13,
                          "IATCTokenComponent");
    n0xFFFF_7 = n0xFFFF;
  }
  if ( (LOWORD(v12) = n0xFFFF, v6 = *(_QWORD *)v5(v3, v11, &v12), (v12 = v6) != 0)
    && (v7 = sub_1403B4B50(v6 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v7 + 4), n4 != 4)
    && *(_WORD *)(v7 + 2) == (HIWORD(v6) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v12)) )
  {
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)(v6 & 0xFFFFFFFFFFFFLL) + 0x600LL))(v6 & 0xFFFFFFFFFFFFLL, a1);
    return a1;
  }
  else
  {
LABEL_11:
    v10 = (const void **)sub_1403B1280();
    sub_14035B410(a1, v10);
    return a1;
  }
}

// --- End Function: sub_14458F090 (0x14458F090) ---

// --- Function: sub_14469AA20 (0x14469AA20) ---
__int64 __fastcall sub_14469AA20(__int64 a1)
{
  sub_1402ABD50((_QWORD *)(a1 + 0x58));
  sub_140370D10((_QWORD *)(a1 + 0x40));
  return 0;
}

// --- End Function: sub_14469AA20 (0x14469AA20) ---

// --- Function: sub_1446BDBD0 (0x1446BDBD0) ---
__int64 sub_1446BDBD0()
{
  __int64 result; // rax

  result = (unsigned int)dword_149E4202C;
  if ( !dword_149E4202C )
    return get_event_key_from_source_location(
             &dword_149E4202C,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/UI/Events.h",
             0x161);
  return result;
}

// --- End Function: sub_1446BDBD0 (0x1446BDBD0) ---

// --- Function: sub_1446BDC00 (0x1446BDC00) ---
__int64 sub_1446BDC00()
{
  __int64 result; // rax

  result = (unsigned int)dword_149E42028;
  if ( !dword_149E42028 )
    return get_event_key_from_source_location(
             &dword_149E42028,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/UI/Events.h",
             0x15B);
  return result;
}

// --- End Function: sub_1446BDC00 (0x1446BDC00) ---

// --- Function: sub_144BC1E00 (0x144BC1E00) ---
_OWORD *__fastcall sub_144BC1E00(__int64 *Parameter, _OWORD *a2)
{
  _BYTE *v3; // rdx
  _OWORD *result; // rax

  v3 = (_BYTE *)Parameter[1];
  if ( v3 == (_BYTE *)Parameter[2] )
    return sub_142D418C0(Parameter, v3, a2);
  *(_OWORD *)v3 = *a2;
  result = (_OWORD *)Parameter[1];
  Parameter[1] = (__int64)(result + 1);
  return result;
}

// --- End Function: sub_144BC1E00 (0x144BC1E00) ---

// --- Function: sub_144D049F0 (0x144D049F0) ---
void __fastcall sub_144D049F0(__int64 *p_memoryManager, __int64 n0x2000)
{
  p_memoryManager[8] |= n0x2000;
}

// --- End Function: sub_144D049F0 (0x144D049F0) ---

// --- Function: sub_144D177A0 (0x144D177A0) ---
__int64 __fastcall sub_144D177A0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax

  if ( !sub_1403335B0(a1) || !*(_BYTE *)(sub_1403335B0(a1) + 0x18) )
    return *(unsigned int *)(a1 + 0x998);
  v2 = sub_140970360(qword_149E7E438);
  v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x1D0LL))(v2);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0x18LL))(v3, *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_144D177A0 (0x144D177A0) ---

// --- Function: sub_1453D2020 (0x1453D2020) ---
_QWORD *__fastcall sub_1453D2020(_QWORD *p_futureResultPtr2, __int64 a2)
{
  *p_futureResultPtr2 = 0;
  p_futureResultPtr2[1] = 0;
  p_futureResultPtr2[2] = 0;
  sub_1453D3320(p_futureResultPtr2, a2);
  sub_140B01DB0((__int64 **)(a2 + 0x20));
  return p_futureResultPtr2;
}

// --- End Function: sub_1453D2020 (0x1453D2020) ---

// --- Function: sub_1453D2850 (0x1453D2850) ---
_QWORD *__fastcall sub_1453D2850(_QWORD *a1, __int64 a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1453D3A30(a1, a2);
  sub_14545FA30((Parameter *)(a2 + 0x20));
  sub_14277C8E0((Parameter *)(a2 + 8));
  return a1;
}

// --- End Function: sub_1453D2850 (0x1453D2850) ---

// --- Function: sub_1453D28C0 (0x1453D28C0) ---
_QWORD *__fastcall sub_1453D28C0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  _BYTE v4[96]; // [rsp+28h] [rbp-60h] BYREF

  v2 = sub_1453ED940(v4, a2);
  sub_1453D2850(a1, v2);
  sub_14545FA30((Parameter *)(a2 + 0x20));
  sub_14277C8E0((Parameter *)(a2 + 8));
  return a1;
}

// --- End Function: sub_1453D28C0 (0x1453D28C0) ---

// --- Function: sub_1453D2B80 (0x1453D2B80) ---
__int64 __fastcall sub_1453D2B80(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _BYTE v4[176]; // [rsp+28h] [rbp-B0h] BYREF

  v2 = sub_1453EDA60(v4, a2);
  sub_1453D2C10(a1, v2);
  sub_14277C8E0((Parameter *)(a2 + 0x88));
  sub_14545FA30(a2 + 0x70);
  sub_1404A7660(a2 + 0x20);
  return a1;
}

// --- End Function: sub_1453D2B80 (0x1453D2B80) ---

// --- Function: sub_1453D2C10 (0x1453D2C10) ---
_QWORD *__fastcall sub_1453D2C10(_QWORD *a1, __int64 a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1453D3DA0(a1, a2);
  sub_14277C8E0((Parameter *)(a2 + 0x88));
  sub_14545FA30((Parameter *)(a2 + 0x70));
  sub_1404A7660(a2 + 0x20);
  return a1;
}

// --- End Function: sub_1453D2C10 (0x1453D2C10) ---

// --- Function: sub_1453D3320 (0x1453D3320) ---
_QWORD *__fastcall sub_1453D3320(_QWORD *p_futureResultPtr2, _QWORD *p_futureResultPtr3_1)
{
  _QWORD *p_futureResultPtr2_1; // rax
  _BYTE *p_engineService; // [rsp+20h] [rbp-18h]
  __int64 v4; // [rsp+28h] [rbp-10h]

  sub_1402A2AD0(p_futureResultPtr2);
  p_engineService = (_BYTE *)allocWithProfilerInfo_w(0x38u);
  if ( p_engineService )
    v4 = sub_1453ED820(p_engineService, p_futureResultPtr3_1);
  else
    v4 = 0;
  p_futureResultPtr2[2] = v4;
  *p_futureResultPtr2 = sub_14540B8A0;
  p_futureResultPtr2_1 = p_futureResultPtr2;
  p_futureResultPtr2[1] = sub_14540CAF0;
  return p_futureResultPtr2_1;
}

// --- End Function: sub_1453D3320 (0x1453D3320) ---

// --- Function: sub_1453D3DA0 (0x1453D3DA0) ---
_QWORD *__fastcall sub_1453D3DA0(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]
  __int64 v4; // [rsp+28h] [rbp-10h]

  sub_1402A2AD0(a1);
  v3 = allocWithProfilerInfo_w(0xA0u);
  if ( v3 )
    v4 = sub_1453EDA60(v3, a2);
  else
    v4 = 0;
  a1[2] = v4;
  *a1 = sub_14540BDF0;
  result = a1;
  a1[1] = sub_14540F160;
  return result;
}

// --- End Function: sub_1453D3DA0 (0x1453D3DA0) ---

// --- Function: sub_1453D5960 (0x1453D5960) ---
__int64 __fastcall sub_1453D5960(__int64 a1, _BYTE *buf)
{
  return sub_1453D5990(a1 + 8);
}

// --- End Function: sub_1453D5960 (0x1453D5960) ---

// --- Function: sub_1453D5990 (0x1453D5990) ---
__int64 __fastcall sub_1453D5990(__int64 a1)
{
  unsigned int v2; // [rsp+20h] [rbp-48h]
  __int64 v3; // [rsp+24h] [rbp-44h]
  void (__fastcall *v4)(__int64, _QWORD, _QWORD *); // [rsp+38h] [rbp-30h]
  _QWORD v5[5]; // [rsp+40h] [rbp-28h] BYREF

  v2 = sub_1446BDBD0();
  v4 = *(void (__fastcall **)(__int64, _QWORD, _QWORD *))(*(_QWORD *)a1 + 0x20LL);
  HIDWORD(v3) = v2;
  sub_1432A7770((__int64)v5, v3);
  v4(a1, v2, v5);
  return sub_1402A2AD0(v5);
}

// --- End Function: sub_1453D5990 (0x1453D5990) ---

// --- Function: sub_1453D5A00 (0x1453D5A00) ---
__int64 __fastcall sub_1453D5A00(__int64 a1, char *buf)
{
  return sub_1453D5A30(a1 + 8);
}

// --- End Function: sub_1453D5A00 (0x1453D5A00) ---

// --- Function: sub_1453D5A30 (0x1453D5A30) ---
__int64 __fastcall sub_1453D5A30(__int64 a1)
{
  unsigned int v2; // [rsp+20h] [rbp-48h]
  __int64 v3; // [rsp+24h] [rbp-44h]
  void (__fastcall *v4)(__int64, _QWORD, _QWORD *); // [rsp+38h] [rbp-30h]
  _QWORD v5[5]; // [rsp+40h] [rbp-28h] BYREF

  v2 = sub_1446BDC00();
  v4 = *(void (__fastcall **)(__int64, _QWORD, _QWORD *))(*(_QWORD *)a1 + 0x20LL);
  HIDWORD(v3) = v2;
  sub_1432A7770((__int64)v5, v3);
  v4(a1, v2, v5);
  return sub_1402A2AD0(v5);
}

// --- End Function: sub_1453D5A30 (0x1453D5A30) ---

// --- Function: sub_1453DA700 (0x1453DA700) ---
__int64 __fastcall sub_1453DA700(AK::WriteBytesCount *a1, __int64 a2)
{
  __int64 v3; // [rsp+20h] [rbp-18h]
  __int64 v4; // [rsp+28h] [rbp-10h]

  if ( AK::WriteBytesCount::Reserve(a1) )
  {
    v3 = sub_1402A2B80(0x88, (__int64)a1);
    return sub_1453F6560(v3, a2);
  }
  else
  {
    v4 = sub_1402A2B80(0x88, (__int64)a1);
    return sub_1453F6560(v4, a2);
  }
}

// --- End Function: sub_1453DA700 (0x1453DA700) ---

// --- Function: sub_1453DB580 (0x1453DB580) ---
__int64 __fastcall sub_1453DB580(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+28h] [rbp-20h]

  v3 = sub_1402A2B80(0x88, *(_QWORD *)(a1 + 8));
  sub_1453F6560(v3, a2);
  result = *(_QWORD *)(a1 + 8) + 0x88LL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_1453DB580 (0x1453DB580) ---

// --- Function: sub_1453DC930 (0x1453DC930) ---
__int64 __fastcall sub_1453DC930(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+40h] [rbp-18h]

  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 0x10) )
    return sub_1453DF900(a1, *(_QWORD *)(a1 + 8), a2);
  sub_1453DA700(*(AK::WriteBytesCount **)(a1 + 8), a2);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3 + 0x88;
  return v3;
}

// --- End Function: sub_1453DC930 (0x1453DC930) ---

// --- Function: sub_1453DF900 (0x1453DF900) ---
_QWORD *__fastcall sub_1453DF900(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // [rsp+20h] [rbp-B8h]
  __int64 v5; // [rsp+30h] [rbp-A8h]
  _QWORD *v7; // [rsp+40h] [rbp-98h]
  unsigned __int64 v9; // [rsp+60h] [rbp-78h]
  __int64 v10; // [rsp+70h] [rbp-68h]
  __int64 v11; // [rsp+90h] [rbp-48h] BYREF
  __int64 v12; // [rsp+98h] [rbp-40h] BYREF
  __int64 v13; // [rsp+A0h] [rbp-38h]
  __int64 v14; // [rsp+A8h] [rbp-30h]
  _QWORD *v15; // [rsp+B0h] [rbp-28h]
  __int64 v16; // [rsp+B8h] [rbp-20h]
  __int64 v17; // [rsp+C8h] [rbp-10h]

  v7 = a1 + 1;
  v5 = (a2 - *a1) / 0x88;
  v10 = (a1[1] - *a1) / 0x88LL;
  v11 = 0x1E1E1E1E1E1E1E1LL;
  v12 = __crt_strtox::maximum_signed_value((__crt_strtox *)0x88);
  v13 = *unknown_libname_2(&v12, &v11);
  if ( v10 == v13 )
    unknown_libname_67();
  v9 = sub_143DBC250(a1, v10 + 1);
  v17 = 0x1E1E1E1E1E1E1E1LL;
  if ( v9 > 0x1E1E1E1E1E1E1E1LL )
    sub_1402E1170();
  v14 = 0x88 * v9;
  v15 = std::_Allocate<16,std::_Default_allocate_traits,0>(0x88 * v9);
  v4 = v15;
  v16 = sub_1402A2B80(0x88, (__int64)&v15[0x11 * v5]);
  sub_1453F6560(v16, a3);
  if ( a2 == *v7 )
  {
    sub_1453E7CB0(*a1, *v7, v4, a1);
  }
  else
  {
    sub_1453E7CB0(*a1, a2, v4, a1);
    sub_1453E7CB0(a2, *v7, &v4[0x11 * v5 + 0x11], a1);
  }
  sub_14545E6F0(a1, v4, v10 + 1, v9);
  return &v4[0x11 * v5];
}

// --- End Function: sub_1453DF900 (0x1453DF900) ---

// --- Function: sub_1453E0870 (0x1453E0870) ---
__int64 __fastcall sub_1453E0870(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // [rsp+20h] [rbp-28h]
  __int64 n0x28; // [rsp+28h] [rbp-20h]

  n0x28 = (a3 - a1) / 0x88;
  if ( n0x28 <= 0x28 )
    return sub_1453E15E0(a1, a2, a3, a4);
  v5 = (n0x28 + 1) >> 3;
  sub_1453E15E0(a1, 0x88 * v5 + a1, 0x110 * v5 + a1, a4);
  sub_1453E15E0(a2 - 0x88 * v5, a2, 0x88 * v5 + a2, a4);
  sub_1453E15E0(a3 - 0x110 * v5, a3 - 0x88 * v5, a3, a4);
  return sub_1453E15E0(0x88 * v5 + a1, a2, a3 - 0x88 * v5, a4);
}

// --- End Function: sub_1453E0870 (0x1453E0870) ---

// --- Function: sub_1453E0DB0 (0x1453E0DB0) ---
__int64 __fastcall sub_1453E0DB0(__int64 a1, __int64 a2, char a3)
{
  __int64 v4; // [rsp+20h] [rbp-D8h]
  __int64 v5; // [rsp+28h] [rbp-D0h]
  __int64 j; // [rsp+30h] [rbp-C8h]
  __int64 i; // [rsp+38h] [rbp-C0h]
  __int64 v8; // [rsp+40h] [rbp-B8h]
  _BYTE v9[64]; // [rsp+50h] [rbp-A8h] BYREF
  _QWORD v10[3]; // [rsp+90h] [rbp-68h] BYREF
  _QWORD v11[7]; // [rsp+A8h] [rbp-50h] BYREF
  char v14; // [rsp+110h] [rbp+18h] BYREF

  v14 = a3;
  if ( a1 != a2 )
  {
    v5 = a1;
    while ( 1 )
    {
      v5 += 0x88;
      if ( v5 == a2 )
        break;
      v4 = v5;
      sub_1453F6560(v9, v5);
      if ( (unsigned __int8)sub_145402390(&v14, v9, a1) )
      {
        v8 = v5 + 0x88;
        for ( i = v5; a1 != i; sub_1453FBB90(v8, i) )
        {
          i -= 0x88;
          v8 -= 0x88;
        }
        sub_1453FBB90(a1, v9);
      }
      else
      {
        for ( j = v5; ; v4 = j )
        {
          j -= 0x88;
          if ( !(unsigned __int8)sub_145402390(&v14, v9, j) )
            break;
          sub_1453FBB90(v4, j);
        }
        sub_1453FBB90(v4, v9);
      }
      sub_1402ABD50(v11);
      sub_140370D10(v10);
    }
  }
  return a2;
}

// --- End Function: sub_1453E0DB0 (0x1453E0DB0) ---

// --- Function: sub_1453E1100 (0x1453E1100) ---
void __fastcall sub_1453E1100(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // [rsp+30h] [rbp-B8h]
  __int64 v4; // [rsp+38h] [rbp-B0h]
  _BYTE v5[64]; // [rsp+40h] [rbp-A8h] BYREF
  _QWORD v6[3]; // [rsp+80h] [rbp-68h] BYREF
  _QWORD v7[7]; // [rsp+98h] [rbp-50h] BYREF

  v4 = (a2 - a1) / 0x88;
  v3 = v4 >> 1;
  while ( v3 > 0 )
  {
    --v3;
    sub_1453F6560(v5, 0x88 * v3 + a1);
    sub_1453E2F70(a1, v3, v4, (unsigned int)v5, a3);
    sub_1402ABD50(v7);
    sub_140370D10(v6);
  }
}

// --- End Function: sub_1453E1100 (0x1453E1100) ---

// --- Function: sub_1453E15E0 (0x1453E15E0) ---
__int64 __fastcall sub_1453E15E0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 result; // rax
  char v8; // [rsp+48h] [rbp+20h] BYREF

  v8 = a4;
  if ( (unsigned __int8)sub_145402390(&v8, a2, a1) )
    sub_1453ED650(a2, a1);
  result = (unsigned __int8)sub_145402390(&v8, a3, a2);
  if ( (_BYTE)result )
  {
    sub_1453ED650(a3, a2);
    result = (unsigned __int8)sub_145402390(&v8, a2, a1);
    if ( (_BYTE)result )
      return sub_1453ED650(a2, a1);
  }
  return result;
}

// --- End Function: sub_1453E15E0 (0x1453E15E0) ---

// --- Function: sub_1453E28E0 (0x1453E28E0) ---
unsigned __int64 *__fastcall sub_1453E28E0(
        unsigned __int64 *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int8 a4)
{
  __int128 v4; // rtt
  unsigned __int64 v6; // [rsp+20h] [rbp-98h]
  unsigned __int64 v7; // [rsp+28h] [rbp-90h]
  unsigned __int64 v8; // [rsp+30h] [rbp-88h]
  unsigned __int64 v9; // [rsp+40h] [rbp-78h]
  unsigned __int64 v10; // [rsp+48h] [rbp-70h]
  unsigned __int8 v14; // [rsp+D8h] [rbp+20h] BYREF

  v14 = a4;
  v4 = (__int64)(a3 - a2);
  sub_1453E0870(a2, 0x88 * (((__int64)(a3 - a2) / 0x88) >> 1) + a2, a3 - 0x88, a4);
  v6 = 0x88 * ((__int64)(v4 / 0x88) >> 1) + a2;
  v7 = v6 + 0x88;
  while ( a2 < v6
       && !(unsigned __int8)sub_145402390(&v14, v6 - 0x88, v6)
       && !(unsigned __int8)sub_145402390(&v14, v6, v6 - 0x88) )
    v6 -= 0x88LL;
  while ( v7 < a3 && !(unsigned __int8)sub_145402390(&v14, v7, v6) && !(unsigned __int8)sub_145402390(&v14, v6, v7) )
    v7 += 0x88LL;
  v8 = v7;
  v9 = v6;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v8 >= a3 )
        goto LABEL_19;
      if ( !(unsigned __int8)sub_145402390(&v14, v6, v8) )
        break;
LABEL_11:
      v8 += 0x88LL;
    }
    if ( !(unsigned __int8)sub_145402390(&v14, v8, v6) )
    {
      if ( v7 != v8 )
        sub_1453ED650(v7, v8);
      v7 += 0x88LL;
      goto LABEL_11;
    }
LABEL_19:
    while ( a2 < v9 )
    {
      v10 = v9 - 0x88;
      if ( !(unsigned __int8)sub_145402390(&v14, v9 - 0x88, v6) )
      {
        if ( (unsigned __int8)sub_145402390(&v14, v6, v10) )
          break;
        v6 -= 0x88LL;
        if ( v6 != v10 )
          sub_1453ED650(v6, v10);
      }
      v9 -= 0x88LL;
    }
    if ( v9 == a2 && v8 == a3 )
      break;
    if ( v9 == a2 )
    {
      if ( v7 != v8 )
        sub_1453ED650(v6, v7);
      v7 += 0x88LL;
      sub_1453ED650(v6, v8);
      v6 += 0x88LL;
      v8 += 0x88LL;
    }
    else if ( v8 == a3 )
    {
      v9 -= 0x88LL;
      v6 -= 0x88LL;
      if ( v9 != v6 )
        sub_1453ED650(v9, v6);
      v7 -= 0x88LL;
      sub_1453ED650(v6, v7);
    }
    else
    {
      v9 -= 0x88LL;
      sub_1453ED650(v8, v9);
      v8 += 0x88LL;
    }
  }
  *a1 = v6;
  a1[1] = v7;
  return a1;
}

// --- End Function: sub_1453E28E0 (0x1453E28E0) ---

// --- Function: sub_1453E2F70 (0x1453E2F70) ---
__int64 __fastcall sub_1453E2F70(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  __int64 v6; // [rsp+30h] [rbp-28h]
  __int64 v7; // [rsp+38h] [rbp-20h]
  int v8; // [rsp+40h] [rbp-18h]
  __int64 v10; // [rsp+68h] [rbp+10h]

  v10 = a2;
  v8 = a2;
  v6 = a2;
  v7 = (a3 - 1) >> 1;
  while ( v6 < v7 )
  {
    v6 = 2 * v6 + 2;
    if ( (unsigned __int8)sub_145402390(&a5, 0x88 * v6 + a1, 0x88 * (v6 - 1) + a1) )
      --v6;
    sub_1453FBB90(0x88 * v10 + a1, 0x88 * v6 + a1);
    v10 = v6;
  }
  if ( v6 == v7 && !(a3 % 2) )
  {
    sub_1453FBB90(0x88 * v10 + a1, 0x88 * (a3 - 1) + a1);
    LODWORD(v10) = a3 - 1;
  }
  return sub_1453E34C0(a1, v10, v8, a4, a5);
}

// --- End Function: sub_1453E2F70 (0x1453E2F70) ---

// --- Function: sub_1453E32B0 (0x1453E32B0) ---
void __fastcall sub_1453E32B0(__int64 a1, __int64 a2, char a3)
{
  _BYTE v3[64]; // [rsp+30h] [rbp-A8h] BYREF
  _QWORD v4[3]; // [rsp+70h] [rbp-68h] BYREF
  _QWORD v5[7]; // [rsp+88h] [rbp-50h] BYREF
  __int64 v7; // [rsp+E8h] [rbp+10h]

  if ( (a2 - a1) / 0x88 >= 2 )
  {
    v7 = a2 - 0x88;
    sub_1453F6560(v3, a2 - 0x88);
    sub_1453FBB90(v7, a1);
    sub_1453E2F70(a1, 0, (v7 - a1) / 0x88, (int)v3, a3);
    sub_1402ABD50(v5);
    sub_140370D10(v4);
  }
}

// --- End Function: sub_1453E32B0 (0x1453E32B0) ---

// --- Function: sub_1453E34C0 (0x1453E34C0) ---
__int64 sub_1453E34C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  __int64 i; // [rsp+20h] [rbp-18h]
  __int64 v7; // [rsp+48h] [rbp+10h]
  va_list va; // [rsp+60h] [rbp+28h] BYREF

  va_start(va, a4);
  v7 = a2;
  for ( i = (a2 - 1) >> 1; a3 < v7 && (unsigned __int8)sub_145402390(va, 0x88 * i + a1, a4); i = (i - 1) >> 1 )
  {
    sub_1453FBB90(0x88 * v7 + a1, 0x88 * i + a1);
    v7 = i;
  }
  return sub_1453FBB90(0x88 * v7 + a1, a4);
}

// --- End Function: sub_1453E34C0 (0x1453E34C0) ---

// --- Function: sub_1453E6300 (0x1453E6300) ---
__int64 __fastcall sub_1453E6300(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n2; // rax
  __int64 i; // [rsp+20h] [rbp-28h]
  unsigned __int64 v6; // [rsp+30h] [rbp-18h] BYREF
  unsigned __int64 v7; // [rsp+38h] [rbp-10h]

  while ( 1 )
  {
    if ( (__int64)(a2 - a1) / 0x88 <= 0x20 )
      return sub_1453E0DB0(a1, a2, a4);
    if ( a3 <= 0 )
      break;
    sub_1453E28E0(&v6, a1, a2, a4);
    a3 = (a3 >> 2) + (a3 >> 1);
    if ( (__int64)(v6 - a1) / 0x88 >= (__int64)(a2 - v7) / 0x88 )
    {
      sub_1453E6300(v7, a2, a3, a4);
      a2 = v6;
    }
    else
    {
      sub_1453E6300(a1, v6, a3, a4);
      a1 = v7;
    }
  }
  sub_1453E1100(a1, a2, a4);
  for ( i = a2; ; i -= 0x88 )
  {
    n2 = (__int64)(i - a1) / 0x88;
    if ( n2 < 2 )
      break;
    sub_1453E32B0(a1, i, a4);
  }
  return n2;
}

// --- End Function: sub_1453E6300 (0x1453E6300) ---

// --- Function: sub_1453E7CB0 (0x1453E7CB0) ---
__int64 __fastcall sub_1453E7CB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 i; // [rsp+28h] [rbp-50h]
  __int64 v8; // [rsp+38h] [rbp-40h]
  __int64 v9; // [rsp+40h] [rbp-38h]
  __int64 v10; // [rsp+50h] [rbp-28h] BYREF
  __int64 v11; // [rsp+58h] [rbp-20h]
  __int64 v12; // [rsp+60h] [rbp-18h]

  v10 = a3;
  v11 = a3;
  v12 = a4;
  while ( a1 != a2 )
  {
    sub_1453DB580((__int64)&v10, a1);
    a1 += 0x88;
  }
  v10 = v11;
  v9 = v11;
  v8 = v11;
  for ( i = v11; i != v8; i += 0x88 )
    sub_14469AA20(i);
  return v9;
}

// --- End Function: sub_1453E7CB0 (0x1453E7CB0) ---

// --- Function: InitTraceContextWithPlayerIdDescriptor (0x1453E85E0) ---
// Initializes a comprehensive event descriptor structure for a "TraceContext"
// event. This includes setting up the base context, assigning function pointers
// for various operations (serialization, comparison, memory management), and
// recursively initializing a nested "PlayerId" field descriptor. The PlayerId is
// expected to be an integer type.
__int64 __fastcall InitTraceContextWithPlayerIdDescriptor(
        __int64 eventDescriptor,
        __int64 *threadLogContextSlot,
        _QWORD *playerIdValuePtr,
        _QWORD *nestedFieldContext)
{
  *(_QWORD *)eventDescriptor = threadLogContextSlot;
  *(_QWORD *)(eventDescriptor + 8) = sub_1403B3E60();
  *(_BYTE *)(eventDescriptor + 0x59) = 1;
  *(_QWORD *)(eventDescriptor + 0x10) = 0;
  *(_QWORD *)(eventDescriptor + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(eventDescriptor + 0x20) = sub_1403EB240;
  *(_QWORD *)(eventDescriptor + 0x28) = 0;
  *(_QWORD *)(eventDescriptor + 0x30) = sub_1403E77F0;
  *(_QWORD *)(eventDescriptor + 0x38) = 0;
  *(_QWORD *)(eventDescriptor + 0x40) = sub_1403E4E60;
  *(_QWORD *)(eventDescriptor + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(eventDescriptor + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(eventDescriptor + 0x58) = 0;
  *(_QWORD *)(eventDescriptor + 0x60) = 0xB0;
  *(_QWORD *)(eventDescriptor + 0x68) = 0xA8;
  return sub_1453E97D0(eventDescriptor + 0x70, playerIdValuePtr, nestedFieldContext) + 1;
}

// --- End Function: InitTraceContextWithPlayerIdDescriptor (0x1453E85E0) ---

// --- Function: sub_1453E86F0 (0x1453E86F0) ---
__int64 __fastcall sub_1453E86F0(
        __int64 a1,
        __int64 *ThreadLogContextSlot,
        _QWORD *playerIdPtr,
        _QWORD *eventDescriptorPtr4,
        _QWORD *eventDescriptorPtr3)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_1453E9940(a1 + 0x70, playerIdPtr, eventDescriptorPtr4, eventDescriptorPtr3) + 1;
}

// --- End Function: sub_1453E86F0 (0x1453E86F0) ---

// --- Function: sub_1453E8800 (0x1453E8800) ---
__int64 __fastcall sub_1453E8800(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_1453E9AC0((int)a1 + 0x70, a3, a4, a5, a6) + 1;
}

// --- End Function: sub_1453E8800 (0x1453E8800) ---

// --- Function: sub_1453E8920 (0x1453E8920) ---
__int64 __fastcall sub_1453E8920(__int64 a1, __int64 *ThreadLogContextSlot, _QWORD *a3, _QWORD *a4)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_1453E9DC0(a1 + 0x70, a3, a4) + 1;
}

// --- End Function: sub_1453E8920 (0x1453E8920) ---

// --- Function: sub_1453E8B40 (0x1453E8B40) ---
__int64 __fastcall sub_1453E8B40(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_1453EA6A0(a1 + 0x70, a3, a4) + 1;
}

// --- End Function: sub_1453E8B40 (0x1453E8B40) ---

// --- Function: sub_1453E97D0 (0x1453E97D0) ---
__int64 __fastcall sub_1453E97D0(__int64 a1, _QWORD *playerIdValuePtr, _QWORD *nestedFieldContext)
{
  *(_QWORD *)a1 = playerIdValuePtr;
  *(_QWORD *)(a1 + 8) = sub_1404B8DD0();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *playerIdValuePtr;
  *(_QWORD *)(a1 + 0x18) = sub_1405048A0;
  *(_QWORD *)(a1 + 0x20) = sub_1405048A0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = FH4::HandlerMap4::iterator::operator==;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E70;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B60;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x10;
  *(_QWORD *)(a1 + 0x68) = 0x15;
  return sub_140A60850(a1 + 0x70, nestedFieldContext) + 1;
}

// --- End Function: sub_1453E97D0 (0x1453E97D0) ---

// --- Function: sub_1453E9940 (0x1453E9940) ---
__int64 __fastcall sub_1453E9940(
        __int64 a1,
        _QWORD *playerIdPtr,
        _QWORD *eventDescriptorPtr4,
        _QWORD *eventDescriptorPtr3)
{
  *(_QWORD *)a1 = playerIdPtr;
  *(_QWORD *)(a1 + 8) = sub_1404B8DD0();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *playerIdPtr;
  *(_QWORD *)(a1 + 0x18) = sub_1405048A0;
  *(_QWORD *)(a1 + 0x20) = sub_1405048A0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = FH4::HandlerMap4::iterator::operator==;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E70;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B60;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x10;
  *(_QWORD *)(a1 + 0x68) = 0x15;
  return sub_1412251A0(a1 + 0x70, eventDescriptorPtr4, eventDescriptorPtr3) + 1;
}

// --- End Function: sub_1453E9940 (0x1453E9940) ---

// --- Function: sub_1453E9DC0 (0x1453E9DC0) ---
__int64 __fastcall sub_1453E9DC0(__int64 a1, _QWORD *a2, _QWORD *nestedFieldContext)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1404B8E00();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB110;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB110;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E70;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B60;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x10;
  *(_QWORD *)(a1 + 0x68) = 0x15;
  return sub_140A60850(a1 + 0x70, nestedFieldContext) + 1;
}

// --- End Function: sub_1453E9DC0 (0x1453E9DC0) ---

// --- Function: sub_1453ED220 (0x1453ED220) ---
__int64 *__fastcall sub_1453ED220(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // [rsp+20h] [rbp-78h]
  __int64 v7; // [rsp+38h] [rbp-60h]

  while ( a2 != a3 && !(unsigned __int8)sub_145403F20(a4, a2) )
    a2 += 0x88;
  v5 = a2;
  v7 = a2;
  if ( a2 != a3 )
  {
    while ( 1 )
    {
      v5 += 0x88;
      if ( v5 == a3 )
        break;
      if ( !(unsigned __int8)sub_145403F20(a4, v5) )
      {
        sub_1453FBB90(v7, v5);
        v7 += 0x88;
      }
    }
  }
  *a1 = v7;
  return a1;
}

// --- End Function: sub_1453ED220 (0x1453ED220) ---

// --- Function: sub_1453ED650 (0x1453ED650) ---
void __fastcall sub_1453ED650(__int64 a1, __int64 a2)
{
  _BYTE v2[64]; // [rsp+20h] [rbp-A8h] BYREF
  _QWORD v3[3]; // [rsp+60h] [rbp-68h] BYREF
  _QWORD v4[7]; // [rsp+78h] [rbp-50h] BYREF

  sub_1453F6560(v2, a1);
  sub_1453FBB90(a1, a2);
  sub_1453FBB90(a2, v2);
  sub_1402ABD50(v4);
  sub_140370D10(v3);
}

// --- End Function: sub_1453ED650 (0x1453ED650) ---

// --- Function: sub_1453ED820 (0x1453ED820) ---
_BYTE *__fastcall sub_1453ED820(_BYTE *p_engineService, _QWORD *p_futureResultPtr3)
{
  *(_QWORD *)p_engineService = *p_futureResultPtr3;
  *((_QWORD *)p_engineService + 1) = p_futureResultPtr3[1];
  *((_QWORD *)p_engineService + 2) = p_futureResultPtr3[2];
  p_engineService[0x18] = *((_BYTE *)p_futureResultPtr3 + 0x18);
  sub_140509680((_QWORD *)p_engineService + 4, p_futureResultPtr3 + 4);
  return p_engineService;
}

// --- End Function: sub_1453ED820 (0x1453ED820) ---

// --- Function: sub_1453ED940 (0x1453ED940) ---
__int64 __fastcall sub_1453ED940(__int64 a1, _QWORD *a2)
{
  *(_QWORD *)a1 = *a2;
  sub_14282BD80((Parameter *)(a1 + 8), a2 + 1);
  sub_14282BD80((Parameter *)(a1 + 0x20), a2 + 4);
  qmemcpy((void *)(a1 + 0x38), a2 + 7, 0x20u);
  return a1;
}

// --- End Function: sub_1453ED940 (0x1453ED940) ---

// --- Function: sub_1453EDA60 (0x1453EDA60) ---
__int64 __fastcall sub_1453EDA60(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 0x10) = *(_BYTE *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  sub_1403C4110(a1 + 0x20, a2 + 0x20);
  sub_14282BD80((Parameter *)(a1 + 0x70), (__int64 *)(a2 + 0x70));
  sub_14282BD80((Parameter *)(a1 + 0x88), (__int64 *)(a2 + 0x88));
  return a1;
}

// --- End Function: sub_1453EDA60 (0x1453EDA60) ---

// --- Function: sub_1453F6560 (0x1453F6560) ---
__int64 __fastcall sub_1453F6560(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  qmemcpy((void *)(a1 + 8), (const void *)(a2 + 8), 0x18u);
  qmemcpy((void *)(a1 + 0x20), (const void *)(a2 + 0x20), 0x19u);
  sub_14035B140((_QWORD *)(a1 + 0x40), (__int64 *)(a2 + 0x40));
  *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(a2 + 0x48);
  *(_QWORD *)(a1 + 0x50) = *(_QWORD *)(a2 + 0x50);
  sub_14035B3F0((_QWORD *)(a1 + 0x58), (__int64 *)(a2 + 0x58));
  *(_QWORD *)(a1 + 0x60) = *(_QWORD *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_QWORD *)(a1 + 0x70) = *(_QWORD *)(a2 + 0x70);
  *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(a2 + 0x78);
  *(_BYTE *)(a1 + 0x80) = *(_BYTE *)(a2 + 0x80);
  *(_BYTE *)(a1 + 0x81) = *(_BYTE *)(a2 + 0x81);
  *(_BYTE *)(a1 + 0x82) = *(_BYTE *)(a2 + 0x82);
  *(_BYTE *)(a1 + 0x83) = *(_BYTE *)(a2 + 0x83);
  return a1;
}

// --- End Function: sub_1453F6560 (0x1453F6560) ---

// --- Function: sub_1453F6AE0 (0x1453F6AE0) ---
__int64 __fastcall sub_1453F6AE0(__int64 a1, __int64 a2)
{
  const void **v2; // rax
  _BYTE *dst; // [rsp+20h] [rbp-A8h]
  __int64 v5; // [rsp+28h] [rbp-A0h] BYREF
  __int64 v6; // [rsp+30h] [rbp-98h] BYREF
  void **v7; // [rsp+38h] [rbp-90h]
  __int64 v8; // [rsp+40h] [rbp-88h]
  __int64 (__fastcall *v9)(__int64, _BYTE *); // [rsp+48h] [rbp-80h]
  __int64 v10; // [rsp+50h] [rbp-78h] BYREF
  _QWORD v11[2]; // [rsp+58h] [rbp-70h] BYREF
  __int64 v12; // [rsp+68h] [rbp-60h] BYREF
  __int64 v13; // [rsp+78h] [rbp-50h] BYREF
  _BYTE dst_[16]; // [rsp+88h] [rbp-40h] BYREF
  _BYTE v15[16]; // [rsp+98h] [rbp-30h] BYREF

  *(_QWORD *)a1 = 0;
  v5 = 0;
  v6 = 0;
  qmemcpy((void *)(a1 + 8), unknown_libname_6(&v12, &v6, &v5), 0x10u);
  *(_QWORD *)(a1 + 0x18) = 0;
  sub_14036CFD0(a1 + 0x20);
  *(_BYTE *)(a1 + 0x38) = 7;
  sub_14035B3E0((_QWORD *)(a1 + 0x40));
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  v7 = (void **)(a1 + 0x58);
  v2 = (const void **)sub_1403B1280();
  sub_14035B410(v7, v2);
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_DWORD *)(a1 + 0x68) = 0;
  sub_1402B1640((_QWORD *)(a1 + 0x70));
  sub_1402B1640((_QWORD *)(a1 + 0x78));
  *(_BYTE *)(a1 + 0x80) = 0;
  *(_BYTE *)(a1 + 0x81) = 0;
  *(_BYTE *)(a1 + 0x82) = 0;
  *(_BYTE *)(a1 + 0x83) = 0;
  if ( *(_QWORD *)(a2 + 0x10) )
  {
    v8 = *(_QWORD *)(a2 + 0x10);
    v9 = *(__int64 (__fastcall **)(__int64, _BYTE *))(**(_QWORD **)(a2 + 0x10) + 0x10LL);
    dst = (_BYTE *)v9(v8, v15);
  }
  else
  {
    v10 = 0;
    v11[0] = 0;
    qmemcpy(dst_, unknown_libname_6(&v13, v11, &v10), sizeof(dst_));
    dst = dst_;
  }
  v11[1] = dst;
  qmemcpy((void *)(a1 + 8), dst, 0x10u);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 0x38) = *(_BYTE *)(a2 + 0x78);
  copyStringStructure((char **)(a1 + 0x40), (char **)(a2 + 8));
  return a1;
}

// --- End Function: sub_1453F6AE0 (0x1453F6AE0) ---

// --- Function: sub_1453F6D90 (0x1453F6D90) ---
_BYTE *__fastcall sub_1453F6D90(_BYTE *p_tempShipDataBuffer, __int64 a2)
{
  const void **v2; // rax
  __int64 v4; // [rsp+30h] [rbp-68h] BYREF
  __int64 v5; // [rsp+38h] [rbp-60h] BYREF
  void **v6; // [rsp+40h] [rbp-58h]
  __int64 v7; // [rsp+48h] [rbp-50h] BYREF
  __int128 v8; // [rsp+58h] [rbp-40h] BYREF
  _BYTE dst_[16]; // [rsp+68h] [rbp-30h] BYREF

  *(_QWORD *)p_tempShipDataBuffer = 0;
  v4 = 0;
  v5 = 0;
  qmemcpy(p_tempShipDataBuffer + 8, unknown_libname_6(&v7, &v5, &v4), 0x10u);
  *((_QWORD *)p_tempShipDataBuffer + 3) = 0;
  sub_14036CFD0((__int64)(p_tempShipDataBuffer + 0x20));
  p_tempShipDataBuffer[0x38] = 7;
  sub_14035B3E0((_QWORD *)p_tempShipDataBuffer + 8);
  *((_QWORD *)p_tempShipDataBuffer + 9) = 0;
  *((_QWORD *)p_tempShipDataBuffer + 0xA) = 0;
  v6 = (void **)(p_tempShipDataBuffer + 0x58);
  v2 = (const void **)sub_1403B1280();
  sub_14035B410(v6, v2);
  *((_QWORD *)p_tempShipDataBuffer + 0xC) = 0;
  *((_DWORD *)p_tempShipDataBuffer + 0x1A) = 0;
  sub_1402B1640((_QWORD *)p_tempShipDataBuffer + 0xE);
  sub_1402B1640((_QWORD *)p_tempShipDataBuffer + 0xF);
  p_tempShipDataBuffer[0x80] = 0;
  p_tempShipDataBuffer[0x81] = 0;
  p_tempShipDataBuffer[0x82] = 0;
  p_tempShipDataBuffer[0x83] = 0;
  *(_QWORD *)p_tempShipDataBuffer = *(_QWORD *)a2;
  *((_QWORD *)p_tempShipDataBuffer + 3) = *(_QWORD *)(a2 + 8);
  *((_QWORD *)p_tempShipDataBuffer + 0xA) = *(_QWORD *)(a2 + 0x10);
  *((_QWORD *)p_tempShipDataBuffer + 0xC) = *(_QWORD *)(a2 + 0x18);
  qmemcpy(p_tempShipDataBuffer + 0x20, (const void *)(a2 + 0x30), 0x18u);
  qmemcpy(dst_, sub_1403ABCB0(&v8, *(_DWORD *)(a2 + 0x54)), sizeof(dst_));
  qmemcpy(p_tempShipDataBuffer + 8, dst_, 0x10u);
  p_tempShipDataBuffer[0x38] = *(_BYTE *)(a2 + 0x58);
  copyStringStructure((char **)p_tempShipDataBuffer + 8, (char **)(a2 + 0x48));
  *((_QWORD *)p_tempShipDataBuffer + 0xE) = *(_QWORD *)(a2 + 0x20);
  *((_QWORD *)p_tempShipDataBuffer + 0xF) = *(_QWORD *)(a2 + 0x28);
  *((_QWORD *)p_tempShipDataBuffer + 9) = *(_QWORD *)(a2 + 0x60);
  *((_DWORD *)p_tempShipDataBuffer + 0x1A) = *(_DWORD *)(a2 + 0x50);
  p_tempShipDataBuffer[0x80] = (*(_BYTE *)(a2 + 0x68) & 1) != 0;
  p_tempShipDataBuffer[0x81] = (*(_BYTE *)(a2 + 0x68) & 2) != 0;
  p_tempShipDataBuffer[0x82] = (*(_BYTE *)(a2 + 0x68) & 4) != 0;
  p_tempShipDataBuffer[0x83] = (*(_BYTE *)(a2 + 0x68) & 8) != 0;
  return p_tempShipDataBuffer;
}

// --- End Function: sub_1453F6D90 (0x1453F6D90) ---

// --- Function: sub_1453F7170 (0x1453F7170) ---
__int64 __fastcall sub_1453F7170(__int64 a1, _QWORD *a2)
{
  const void **v2; // rax
  char **v3; // rax
  __int64 v5; // [rsp+20h] [rbp-B8h]
  _BYTE *dst; // [rsp+28h] [rbp-B0h]
  __int64 v7; // [rsp+30h] [rbp-A8h] BYREF
  __int64 v8; // [rsp+38h] [rbp-A0h] BYREF
  void **v9; // [rsp+40h] [rbp-98h]
  __int64 (__fastcall *v10)(__int64, _BYTE *); // [rsp+48h] [rbp-90h]
  __int64 v11; // [rsp+50h] [rbp-88h] BYREF
  _QWORD v12[2]; // [rsp+58h] [rbp-80h] BYREF
  __int64 v13; // [rsp+68h] [rbp-70h] BYREF
  __int64 v14; // [rsp+70h] [rbp-68h] BYREF
  __int64 v15; // [rsp+78h] [rbp-60h] BYREF
  __int64 v16; // [rsp+88h] [rbp-50h] BYREF
  _BYTE dst_[16]; // [rsp+98h] [rbp-40h] BYREF
  _BYTE v18[16]; // [rsp+A8h] [rbp-30h] BYREF

  *(_QWORD *)a1 = 0;
  v7 = 0;
  v8 = 0;
  qmemcpy((void *)(a1 + 8), unknown_libname_6(&v15, &v8, &v7), 0x10u);
  *(_QWORD *)(a1 + 0x18) = 0;
  sub_14036CFD0(a1 + 0x20);
  *(_BYTE *)(a1 + 0x38) = 7;
  sub_14035B3E0((_QWORD *)(a1 + 0x40));
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  v9 = (void **)(a1 + 0x58);
  v2 = (const void **)sub_1403B1280();
  sub_14035B410(v9, v2);
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_DWORD *)(a1 + 0x68) = 0;
  sub_1402B1640((_QWORD *)(a1 + 0x70));
  sub_1402B1640((_QWORD *)(a1 + 0x78));
  *(_BYTE *)(a1 + 0x80) = 0;
  *(_BYTE *)(a1 + 0x81) = 0;
  *(_BYTE *)(a1 + 0x82) = 0;
  *(_BYTE *)(a1 + 0x83) = 0;
  *(_QWORD *)a1 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
                     a2,
                     &v13);
  if ( sub_1404B22E0((__int64)a2) )
  {
    v5 = sub_1404B22E0((__int64)a2);
    v10 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v5 + 0x10LL);
    dst = (_BYTE *)v10(v5, v18);
  }
  else
  {
    v11 = 0;
    v12[0] = 0;
    qmemcpy(dst_, unknown_libname_6(&v16, v12, &v11), sizeof(dst_));
    dst = dst_;
  }
  v12[1] = dst;
  qmemcpy((void *)(a1 + 8), dst, 0x10u);
  qmemcpy((void *)(a1 + 0x20), (const void *)sub_1403B1810((__int64)a2), 0x18u);
  *(_QWORD *)(a1 + 0x18) = *sub_1403B27D0((__int64)a2, &v14);
  *(_BYTE *)(a1 + 0x38) = sub_1405BA3A0((__int64)a2);
  v3 = (char **)sub_1405BA390((__int64)a2);
  copyStringStructure((char **)(a1 + 0x40), v3);
  *(_QWORD *)(a1 + 0x48) = sub_1404B4090((__int64)a2);
  return a1;
}

// --- End Function: sub_1453F7170 (0x1453F7170) ---

// --- Function: sub_1453FBB90 (0x1453FBB90) ---
__int64 __fastcall sub_1453FBB90(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  qmemcpy((void *)(a1 + 8), (const void *)(a2 + 8), 0x18u);
  qmemcpy((void *)(a1 + 0x20), (const void *)(a2 + 0x20), 0x19u);
  sub_140377F00((char **)(a1 + 0x40), (char **)(a2 + 0x40));
  *(_QWORD *)(a1 + 0x48) = *(_QWORD *)(a2 + 0x48);
  *(_QWORD *)(a1 + 0x50) = *(_QWORD *)(a2 + 0x50);
  sub_140377FE0((void **)(a1 + 0x58), (void **)(a2 + 0x58));
  *(_QWORD *)(a1 + 0x60) = *(_QWORD *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_QWORD *)(a1 + 0x70) = *(_QWORD *)(a2 + 0x70);
  *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(a2 + 0x78);
  *(_BYTE *)(a1 + 0x80) = *(_BYTE *)(a2 + 0x80);
  *(_BYTE *)(a1 + 0x81) = *(_BYTE *)(a2 + 0x81);
  *(_BYTE *)(a1 + 0x82) = *(_BYTE *)(a2 + 0x82);
  *(_BYTE *)(a1 + 0x83) = *(_BYTE *)(a2 + 0x83);
  return a1;
}

// --- End Function: sub_1453FBB90 (0x1453FBB90) ---

// --- Function: sub_1453FEA20 (0x1453FEA20) ---
__int64 __fastcall sub_1453FEA20(_QWORD *src, __int64 *a2)
{
  __int64 result; // rax
  void *v3; // rsp
  void *v4; // rsp
  __int64 v5; // [rsp+18h] [rbp-398h]
  _BYTE v6[256]; // [rsp+30h] [rbp-380h] BYREF
  __int64 v7; // [rsp+168h] [rbp-248h]
  _BYTE v8[480]; // [rsp+180h] [rbp-230h] BYREF
  BOOL v9; // [rsp+3B0h] [rbp+0h]
  int v10; // [rsp+3B4h] [rbp+4h]
  int v11; // [rsp+3B8h] [rbp+8h]
  unsigned int v12; // [rsp+3C0h] [rbp+10h]
  __int64 v13; // [rsp+3C8h] [rbp+18h] BYREF
  __int64 v14; // [rsp+3D0h] [rbp+20h] BYREF
  _DWORD v15[2]; // [rsp+3D8h] [rbp+28h] BYREF
  char v16; // [rsp+3E0h] [rbp+30h] BYREF
  _DWORD v17[2]; // [rsp+3E8h] [rbp+38h] BYREF
  char v18; // [rsp+3F0h] [rbp+40h] BYREF
  _DWORD v19[2]; // [rsp+3F8h] [rbp+48h] BYREF
  char v20; // [rsp+400h] [rbp+50h] BYREF
  _DWORD v21[2]; // [rsp+408h] [rbp+58h] BYREF
  char v22; // [rsp+410h] [rbp+60h] BYREF
  __int64 *v23; // [rsp+418h] [rbp+68h]
  __int64 *v24; // [rsp+420h] [rbp+70h]
  __int64 *v25; // [rsp+428h] [rbp+78h]
  __int64 *v26; // [rsp+430h] [rbp+80h]
  __int64 *v27; // [rsp+438h] [rbp+88h]
  _BYTE *v28; // [rsp+440h] [rbp+90h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+448h] [rbp+98h]
  __int64 *v30; // [rsp+450h] [rbp+A0h]
  ULONG_PTR Parameter[3]; // [rsp+458h] [rbp+A8h] BYREF
  vraudio::AudioBuffer *__Val_0___1; // [rsp+470h] [rbp+C0h]
  __int64 *v33; // [rsp+478h] [rbp+C8h]
  __int64 v34; // [rsp+480h] [rbp+D0h]
  _QWORD Parameter_[3]; // [rsp+488h] [rbp+D8h] BYREF
  __int64 v36; // [rsp+4A0h] [rbp+F0h]
  __int64 Parameter__1[2]; // [rsp+4A8h] [rbp+F8h] BYREF
  __int64 v38; // [rsp+4B8h] [rbp+108h]
  __int64 v39; // [rsp+4C0h] [rbp+110h]
  __int64 *v40; // [rsp+4C8h] [rbp+118h]
  __int64 v41; // [rsp+4D0h] [rbp+120h]
  _QWORD Parameter__2[2]; // [rsp+4D8h] [rbp+128h] BYREF
  __int64 v43; // [rsp+4E8h] [rbp+138h]
  _QWORD Parameter__3[5]; // [rsp+4F0h] [rbp+140h] BYREF
  __int64 *PlayerIdFromContext; // [rsp+518h] [rbp+168h]
  __int64 v46; // [rsp+520h] [rbp+170h]
  __int64 v47; // [rsp+528h] [rbp+178h]
  __int64 v48; // [rsp+530h] [rbp+180h]
  __int64 v49; // [rsp+538h] [rbp+188h]
  _QWORD *v50; // [rsp+540h] [rbp+190h]
  _QWORD *v51; // [rsp+548h] [rbp+198h]
  _QWORD *v52; // [rsp+550h] [rbp+1A0h]
  _QWORD *v53; // [rsp+558h] [rbp+1A8h]
  __int64 *ThreadLogContextSlot; // [rsp+560h] [rbp+1B0h]
  ULONG_PTR v55; // [rsp+568h] [rbp+1B8h]
  __int64 *v56; // [rsp+570h] [rbp+1C0h]
  ULONG_PTR v57; // [rsp+578h] [rbp+1C8h]
  __int64 v58; // [rsp+580h] [rbp+1D0h]
  ULONG_PTR v59; // [rsp+588h] [rbp+1D8h]
  __int64 v60; // [rsp+590h] [rbp+1E0h]
  __int64 v61; // [rsp+598h] [rbp+1E8h]
  __int64 v62; // [rsp+5A0h] [rbp+1F0h]
  __int64 *v63; // [rsp+5A8h] [rbp+1F8h]
  __int64 v64; // [rsp+5B0h] [rbp+200h]
  _QWORD *v65; // [rsp+5B8h] [rbp+208h]
  _QWORD *v66; // [rsp+5C0h] [rbp+210h]
  __int64 *ThreadLogContextSlot_1; // [rsp+5C8h] [rbp+218h]
  __int64 v68; // [rsp+5D0h] [rbp+220h]
  __int64 v69; // [rsp+5D8h] [rbp+228h]
  __int64 v70; // [rsp+5E0h] [rbp+230h]
  __int64 *v71; // [rsp+5E8h] [rbp+238h]
  __int64 v72; // [rsp+5F0h] [rbp+240h]
  __int64 v73; // [rsp+5F8h] [rbp+248h]
  _QWORD src_[2]; // [rsp+600h] [rbp+250h] BYREF
  _QWORD src__1[2]; // [rsp+610h] [rbp+260h] BYREF
  _QWORD v76[2]; // [rsp+620h] [rbp+270h] BYREF
  _QWORD v77[2]; // [rsp+630h] [rbp+280h] BYREF
  _QWORD v78[2]; // [rsp+640h] [rbp+290h] BYREF
  _QWORD src__2[2]; // [rsp+650h] [rbp+2A0h] BYREF
  _QWORD v80[2]; // [rsp+660h] [rbp+2B0h] BYREF
  _QWORD src__3[2]; // [rsp+670h] [rbp+2C0h] BYREF
  _QWORD v82[2]; // [rsp+680h] [rbp+2D0h] BYREF
  _QWORD src__4[2]; // [rsp+690h] [rbp+2E0h] BYREF
  _QWORD v84[2]; // [rsp+6A0h] [rbp+2F0h] BYREF
  _QWORD v85[2]; // [rsp+6B0h] [rbp+300h] BYREF
  char v86; // [rsp+6C0h] [rbp+310h]
  _QWORD v87[2]; // [rsp+6C8h] [rbp+318h] BYREF
  char v88; // [rsp+6D8h] [rbp+328h]
  __int64 Parameter__4[3]; // [rsp+6E0h] [rbp+330h] BYREF
  _QWORD v90[2]; // [rsp+6F8h] [rbp+348h] BYREF
  __int64 v91; // [rsp+708h] [rbp+358h] BYREF
  _QWORD v92[2]; // [rsp+710h] [rbp+360h] BYREF
  _BYTE v93[8]; // [rsp+720h] [rbp+370h] BYREF
  _BYTE dst_[16]; // [rsp+728h] [rbp+378h] BYREF
  _BYTE dst__1[16]; // [rsp+738h] [rbp+388h] BYREF
  _BYTE dst__2[16]; // [rsp+750h] [rbp+3A0h] BYREF
  _BYTE dst__3[16]; // [rsp+760h] [rbp+3B0h] BYREF
  __int64 dst__4[2]; // [rsp+770h] [rbp+3C0h] BYREF
  _BYTE dst__5[16]; // [rsp+780h] [rbp+3D0h] BYREF
  __int64 dst__6[2]; // [rsp+790h] [rbp+3E0h] BYREF

  result = validateHandleAccess(src + 1);
  if ( (_BYTE)result )
  {
    v70 = src[3];
    v71 = sub_14277DDD0(&v91);
    v72 = *v71;
    v73 = v72;
    v13 = v72;
    if ( Handle::IsValid(&v13) )
    {
      src_[0] = v13;
      src_[1] = src[3];
      qmemcpy(dst_, src_, sizeof(dst_));
      qmemcpy(dst__1, dst_, sizeof(dst__1));
      v23 = a2;
      v33 = a2;
      v34 = a2[1];
      std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
        (Parameter *)Parameter_,
        v34);
      Parameter_[1] = Parameter_[0];
      v38 = Parameter_[0];
      v24 = a2;
      Parameter_[2] = a2;
      v36 = *a2;
      std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
        (Parameter *)Parameter__1,
        v36);
      Parameter__1[1] = Parameter__1[0];
      v39 = Parameter__1[0];
      qmemcpy(dst__2, dst__1, sizeof(dst__2));
      sub_1453ED220(&v14, Parameter__1[0], v38, (__int64)dst__2);
      v25 = a2;
      v40 = a2;
      v41 = a2[1];
      std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
        (Parameter *)Parameter__2,
        v41);
      v9 = v14 == Parameter__2[0];
      if ( v14 != Parameter__2[0] )
      {
        v26 = a2;
        Parameter__2[1] = a2;
        v43 = a2[1];
        std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
          (Parameter *)Parameter__3,
          v43);
        Parameter__3[1] = Parameter__3[0];
        Parameter__3[2] = v14;
        Parameter__3[4] = Parameter__3[0];
        Parameter__3[3] = v14;
        v49 = (Parameter__3[0] - v14) / 0x88;
        v15[0] = add_0xC7(0x16u);
        v15[1] = 8;
        src__1[0] = v15;
        src__1[1] = &v16;
        qmemcpy(dst__3, src__1, sizeof(dst__3));
        v10 = invokeGlobalCallbackAndMaskStatusBits(
                5,
                (__int64)dst__3,
                (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::()::<lambda_2>::()::<lambda_1>::operator ()",
                "$$ vehicles out of $$ are not supported at this ATC location ($$) for player $$");
        if ( (v10 & 0xFFFFF) != 0 )
        {
          PlayerIdFromContext = GetPlayerIdFromContext(qword_149E7E438, v92);
          v46 = identity_int64(*PlayerIdFromContext);
          v85[0] = 0;
          v85[1] = v46;
          v86 = 0;
          v50 = v85;
          v47 = v13 & 0xFFFFFFFFFFFFLL;
          v12 = sub_144D177A0(v13 & 0xFFFFFFFFFFFFLL);
          v76[0] = 0;
          v76[1] = v12;
          v51 = v76;
          v27 = a2;
          v48 = (a2[1] - *a2) / 0x88;
          v77[0] = 0;
          v77[1] = v48;
          v52 = v77;
          v78[0] = 0;
          v78[1] = v49;
          v53 = v78;
          ThreadLogContextSlot = getThreadLogContextSlot();
          v80[0] = 0;
          v80[1] = 0;
          v17[0] = add_0xC7(0x16u);
          v17[1] = 8;
          src__2[0] = v17;
          src__2[1] = &v18;
          qmemcpy(dst__4, src__2, sizeof(dst__4));
          v92[1] = 5;
          v3 = alloca(0x230);
          v28 = v8;
          __Val_0__ = (vraudio::AudioBuffer *)v8;
          sub_1453E8800((__int64)v8, (__int64)ThreadLogContextSlot, (int)v53, (int)v52, (__int64)v51, (__int64)v50);
          LODWORD(v7) = v10;
          ReportTelemetryEvent(
            5u,
            dst__4,
            "CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::()::<lambda_2>::()::<lambda_1>::operator ()",
            "$$ vehicles out of $$ are not supported at this ATC location ($$) for player $$",
            __Val_0__,
            5u,
            1,
            v7,
            v80,
            0);
        }
        v30 = a2;
        v56 = a2;
        v55 = a2[1];
        Parameter[0] = v55;
        _StarEngineModule__((ULONG_PTR)Parameter);
        v57 = Parameter[0];
        v59 = Parameter[0];
        v58 = v14;
        v60 = v14;
        sub_1454626D0(a2, v93, v14, Parameter[0]);
      }
    }
    if ( *((_BYTE *)src + 0x10) )
    {
      v61 = *src;
      return sub_145414A40(v61, src[3], a2);
    }
    else
    {
      v19[0] = add_0xC7(0x16u);
      v19[1] = 8;
      src__3[0] = v19;
      src__3[1] = &v20;
      qmemcpy(dst__5, src__3, sizeof(dst__5));
      v11 = invokeGlobalCallbackAndMaskStatusBits(
              5,
              (__int64)dst__5,
              (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::()::<lambda_2>::()::<lambda_1>::operator ()",
              "Fetching vehicle list for player $$ completed. Retrieved $$ vehicles.");
      if ( (v11 & 0xFFFFF) != 0 )
      {
        Parameter[1] = (ULONG_PTR)a2;
        v62 = (a2[1] - *a2) / 0x88;
        v82[0] = 0;
        v82[1] = v62;
        v65 = v82;
        v63 = GetPlayerIdFromContext(qword_149E7E438, v90);
        v64 = identity_int64(*v63);
        v87[0] = 0;
        v87[1] = v64;
        v88 = 0;
        v66 = v87;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v84[0] = 0;
        v84[1] = 0;
        v21[0] = add_0xC7(0x16u);
        v21[1] = 8;
        src__4[0] = v21;
        src__4[1] = &v22;
        qmemcpy(dst__6, src__4, sizeof(dst__6));
        v90[1] = 3;
        v4 = alloca(0x150);
        Parameter[2] = (ULONG_PTR)v6;
        __Val_0___1 = (vraudio::AudioBuffer *)v6;
        sub_1453E8B40((__int64)v6, (__int64)ThreadLogContextSlot_1, (__int64)v66, (__int64)v65);
        LODWORD(v5) = v11;
        ReportTelemetryEvent(
          5u,
          dst__6,
          "CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::()::<lambda_2>::()::<lambda_1>::operator ()",
          "Fetching vehicle list for player $$ completed. Retrieved $$ vehicles.",
          __Val_0___1,
          3u,
          1,
          v5,
          v84,
          0);
      }
      ZeroInitializeAndNotifyEngine((Parameter *)Parameter__4);
      v68 = *src;
      sub_145418950(v68, a2, Parameter__4);
      v69 = *src;
      ProcessFetchedShipData(v69, Parameter__4);
      return (__int64)DeallocateShipDataList((Parameter *)Parameter__4);
    }
  }
  return result;
}

// --- End Function: sub_1453FEA20 (0x1453FEA20) ---

// --- Function: sub_145400150 (0x145400150) ---
__int64 __fastcall sub_145400150(__int64 *a1, _BYTE *a2)
{
  void *v2; // rsp
  void *v4; // rsp
  void *v5; // rsp
  __int64 v6; // rax
  __int64 v7; // rax
  void *v8; // rsp
  __int64 v9; // [rsp+18h] [rbp-1D8h]
  _BYTE v10[32]; // [rsp+30h] [rbp-1C0h] BYREF
  __int64 v11; // [rsp+88h] [rbp-168h]
  _BYTE v12[64]; // [rsp+A0h] [rbp-150h] BYREF
  __int64 v13; // [rsp+F8h] [rbp-F8h]
  _BYTE v14[228]; // [rsp+110h] [rbp-E0h] BYREF
  char v15; // [rsp+1F4h] [rbp+4h] BYREF
  char v16; // [rsp+1F5h] [rbp+5h]
  _QWORD *v17; // [rsp+1F8h] [rbp+8h]
  int v18; // [rsp+200h] [rbp+10h]
  int v20; // [rsp+208h] [rbp+18h]
  int v21; // [rsp+20Ch] [rbp+1Ch]
  BOOL v22; // [rsp+210h] [rbp+20h]
  BOOL v23; // [rsp+214h] [rbp+24h]
  int v24; // [rsp+218h] [rbp+28h]
  ULONG_PTR Parameter__13; // [rsp+220h] [rbp+30h]
  __int64 v26; // [rsp+228h] [rbp+38h]
  _QWORD *v27; // [rsp+230h] [rbp+40h]
  ULONG_PTR Parameter__7; // [rsp+238h] [rbp+48h]
  __int64 v29; // [rsp+240h] [rbp+50h]
  ULONG_PTR Parameter__19; // [rsp+248h] [rbp+58h]
  _DWORD v31[2]; // [rsp+250h] [rbp+60h] BYREF
  char v32; // [rsp+258h] [rbp+68h] BYREF
  _DWORD v33[2]; // [rsp+260h] [rbp+70h] BYREF
  char v34; // [rsp+268h] [rbp+78h] BYREF
  _DWORD v35[2]; // [rsp+270h] [rbp+80h] BYREF
  char v36; // [rsp+278h] [rbp+88h] BYREF
  _DWORD v37[2]; // [rsp+280h] [rbp+90h] BYREF
  char v38; // [rsp+288h] [rbp+98h] BYREF
  _DWORD v39[2]; // [rsp+290h] [rbp+A0h] BYREF
  char v40; // [rsp+298h] [rbp+A8h] BYREF
  _DWORD v41[2]; // [rsp+2A0h] [rbp+B0h] BYREF
  char v42; // [rsp+2A8h] [rbp+B8h] BYREF
  _DWORD v43[2]; // [rsp+2B0h] [rbp+C0h] BYREF
  char v44; // [rsp+2B8h] [rbp+C8h] BYREF
  _DWORD v45[2]; // [rsp+2C0h] [rbp+D0h] BYREF
  char v46; // [rsp+2C8h] [rbp+D8h] BYREF
  _QWORD *v47; // [rsp+2D0h] [rbp+E0h]
  _QWORD *v48; // [rsp+2D8h] [rbp+E8h]
  Parameter *Parameter_1; // [rsp+2E0h] [rbp+F0h]
  ULONG_PTR Parameter[2]; // [rsp+2E8h] [rbp+F8h] BYREF
  ULONG_PTR Parameter__3[2]; // [rsp+2F8h] [rbp+108h] BYREF
  ULONG_PTR Parameter__4; // [rsp+308h] [rbp+118h] BYREF
  ULONG_PTR Parameter__5; // [rsp+310h] [rbp+120h]
  __int64 v54; // [rsp+318h] [rbp+128h]
  __int64 v55[2]; // [rsp+320h] [rbp+130h] BYREF
  __int64 v56; // [rsp+330h] [rbp+140h]
  __int64 v57; // [rsp+338h] [rbp+148h]
  _BYTE *v58; // [rsp+340h] [rbp+150h]
  __int64 *v59; // [rsp+348h] [rbp+158h]
  _BYTE *v60; // [rsp+350h] [rbp+160h]
  vraudio::AudioBuffer *__Val_0___1; // [rsp+358h] [rbp+168h]
  vraudio::AudioBuffer *__Val_0___3; // [rsp+360h] [rbp+170h]
  _BYTE *v63; // [rsp+368h] [rbp+178h]
  ULONG_PTR Parameter__8; // [rsp+370h] [rbp+180h]
  vraudio::AudioBuffer *__Val_0___2; // [rsp+378h] [rbp+188h]
  _QWORD *v66; // [rsp+380h] [rbp+190h]
  _BYTE *v67; // [rsp+388h] [rbp+198h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+390h] [rbp+1A0h]
  __int64 *v69; // [rsp+398h] [rbp+1A8h]
  ULONG_PTR Parameter_; // [rsp+3A0h] [rbp+1B0h] BYREF
  ULONG_PTR Parameter__14; // [rsp+3A8h] [rbp+1B8h]
  __int64 v72; // [rsp+3B8h] [rbp+1C8h]
  __int64 v73; // [rsp+3C0h] [rbp+1D0h]
  _QWORD *v74; // [rsp+3C8h] [rbp+1D8h]
  _QWORD *v75; // [rsp+3D0h] [rbp+1E0h]
  __int64 *ThreadLogContextSlot; // [rsp+3D8h] [rbp+1E8h]
  __int64 v77; // [rsp+3E0h] [rbp+1F0h]
  __int64 v78; // [rsp+3E8h] [rbp+1F8h]
  _QWORD *v79; // [rsp+3F0h] [rbp+200h]
  _QWORD *v80; // [rsp+3F8h] [rbp+208h]
  __int64 v81; // [rsp+400h] [rbp+210h]
  __int64 v82; // [rsp+408h] [rbp+218h]
  __int64 v83; // [rsp+410h] [rbp+220h]
  ULONG_PTR Parameter__15; // [rsp+418h] [rbp+228h]
  Parameter *Parameter_2; // [rsp+420h] [rbp+230h]
  ULONG_PTR v86; // [rsp+428h] [rbp+238h]
  ULONG_PTR Parameter__2; // [rsp+430h] [rbp+240h]
  Parameter *Parameter_3; // [rsp+438h] [rbp+248h]
  ULONG_PTR v89; // [rsp+440h] [rbp+250h]
  _QWORD *v90; // [rsp+448h] [rbp+258h]
  ULONG_PTR Parameter__21; // [rsp+450h] [rbp+260h]
  ULONG_PTR v92; // [rsp+458h] [rbp+268h]
  ULONG_PTR Parameter__22; // [rsp+460h] [rbp+270h]
  ULONG_PTR Parameter__17; // [rsp+468h] [rbp+278h]
  ULONG_PTR Parameter__16; // [rsp+470h] [rbp+280h]
  _QWORD *v96; // [rsp+478h] [rbp+288h]
  ULONG_PTR Parameter__18; // [rsp+480h] [rbp+290h]
  __int64 v98; // [rsp+488h] [rbp+298h]
  __int64 v99; // [rsp+490h] [rbp+2A0h]
  __int64 v100; // [rsp+498h] [rbp+2A8h]
  __int64 v101; // [rsp+4A0h] [rbp+2B0h]
  _QWORD *v102; // [rsp+4A8h] [rbp+2B8h]
  _QWORD *v103; // [rsp+4B0h] [rbp+2C0h]
  ULONG_PTR Parameter__20; // [rsp+4B8h] [rbp+2C8h]
  Parameter *Parameter_4; // [rsp+4C0h] [rbp+2D0h]
  __int64 Parameter__6; // [rsp+4C8h] [rbp+2D8h]
  __int64 (__fastcall *v107)(__int64, _BYTE *); // [rsp+4D0h] [rbp+2E0h]
  __int64 v108; // [rsp+4D8h] [rbp+2E8h]
  __int64 *v109; // [rsp+4E0h] [rbp+2F0h]
  __int64 v110; // [rsp+4E8h] [rbp+2F8h]
  ULONG_PTR Parameter__9; // [rsp+4F0h] [rbp+300h]
  __int64 (__fastcall *v112)(__int64, _BYTE *); // [rsp+4F8h] [rbp+308h]
  __int64 v113; // [rsp+500h] [rbp+310h]
  __int64 v114; // [rsp+508h] [rbp+318h]
  _BYTE *v115; // [rsp+510h] [rbp+320h]
  Parameter *Parameter_5; // [rsp+518h] [rbp+328h]
  Parameter *Parameter_6; // [rsp+520h] [rbp+330h]
  _BYTE *v118; // [rsp+528h] [rbp+338h]
  char *v119; // [rsp+530h] [rbp+340h]
  _QWORD *v120; // [rsp+538h] [rbp+348h]
  __int64 v121; // [rsp+540h] [rbp+350h]
  __int64 *ThreadLogContextSlot_1; // [rsp+548h] [rbp+358h]
  __int64 *v123; // [rsp+550h] [rbp+360h]
  __int64 v124; // [rsp+558h] [rbp+368h]
  _QWORD *v125; // [rsp+560h] [rbp+370h]
  __int64 *ThreadLogContextSlot_3; // [rsp+568h] [rbp+378h]
  _BYTE *v127; // [rsp+570h] [rbp+380h]
  _QWORD *v128; // [rsp+578h] [rbp+388h]
  __int64 *ThreadLogContextSlot_2; // [rsp+580h] [rbp+390h]
  __int64 v130; // [rsp+588h] [rbp+398h]
  __int64 *v131; // [rsp+590h] [rbp+3A0h]
  __int64 v132; // [rsp+598h] [rbp+3A8h] BYREF
  __int64 v133; // [rsp+5A0h] [rbp+3B0h]
  _QWORD src_[2]; // [rsp+5B0h] [rbp+3C0h] BYREF
  _QWORD v135[2]; // [rsp+5C0h] [rbp+3D0h] BYREF
  _QWORD src__1[2]; // [rsp+5D0h] [rbp+3E0h] BYREF
  _QWORD v137[2]; // [rsp+5E0h] [rbp+3F0h] BYREF
  _QWORD src__6[2]; // [rsp+5F0h] [rbp+400h] BYREF
  _QWORD src__7[2]; // [rsp+600h] [rbp+410h] BYREF
  __int128 v140; // [rsp+610h] [rbp+420h] BYREF
  _QWORD v141[2]; // [rsp+620h] [rbp+430h] BYREF
  _QWORD src__4[2]; // [rsp+630h] [rbp+440h] BYREF
  _QWORD src__5[2]; // [rsp+640h] [rbp+450h] BYREF
  _QWORD v144[2]; // [rsp+650h] [rbp+460h] BYREF
  _QWORD src__2[2]; // [rsp+660h] [rbp+470h] BYREF
  _QWORD src__3[2]; // [rsp+670h] [rbp+480h] BYREF
  _QWORD v147[2]; // [rsp+680h] [rbp+490h] BYREF
  __int64 Parameter__1[3]; // [rsp+690h] [rbp+4A0h] BYREF
  _QWORD v149[2]; // [rsp+6A8h] [rbp+4B8h] BYREF
  char v150; // [rsp+6B8h] [rbp+4C8h]
  _QWORD v151[2]; // [rsp+6C0h] [rbp+4D0h] BYREF
  char v152; // [rsp+6D0h] [rbp+4E0h]
  __int64 n2; // [rsp+6D8h] [rbp+4E8h]
  _QWORD v154[2]; // [rsp+6E0h] [rbp+4F0h] BYREF
  _QWORD v155[3]; // [rsp+6F0h] [rbp+500h] BYREF
  _QWORD v156[2]; // [rsp+708h] [rbp+518h] BYREF
  __int64 v157; // [rsp+718h] [rbp+528h] BYREF
  _QWORD v158[2]; // [rsp+720h] [rbp+530h] BYREF
  _BYTE dst__8[16]; // [rsp+730h] [rbp+540h] BYREF
  __int64 dst__9[2]; // [rsp+740h] [rbp+550h] BYREF
  _BYTE dst__6[16]; // [rsp+750h] [rbp+560h] BYREF
  __int64 dst__7[2]; // [rsp+760h] [rbp+570h] BYREF
  _BYTE dst_[16]; // [rsp+770h] [rbp+580h] BYREF
  __int64 dst__1[2]; // [rsp+780h] [rbp+590h] BYREF
  _BYTE dst__2[16]; // [rsp+790h] [rbp+5A0h] BYREF
  _BYTE dst__3[16]; // [rsp+7A0h] [rbp+5B0h] BYREF
  _BYTE v167[8]; // [rsp+7B0h] [rbp+5C0h] BYREF
  __int64 dst__5[2]; // [rsp+7B8h] [rbp+5C8h] BYREF
  __int64 v169; // [rsp+7C8h] [rbp+5D8h] BYREF
  _QWORD v170[2]; // [rsp+7D0h] [rbp+5E0h] BYREF
  __int64 v171; // [rsp+7E0h] [rbp+5F0h] BYREF
  _BYTE dst__4[16]; // [rsp+7E8h] [rbp+5F8h] BYREF
  _BYTE Parameter__12[24]; // [rsp+7F8h] [rbp+608h] BYREF
  _QWORD v174[2]; // [rsp+810h] [rbp+620h] BYREF
  char v175; // [rsp+820h] [rbp+630h]
  __int64 v176; // [rsp+828h] [rbp+638h]
  _BYTE v177[80]; // [rsp+830h] [rbp+640h] BYREF
  _BYTE Parameter__10[24]; // [rsp+880h] [rbp+690h] BYREF
  _BYTE Parameter__11[24]; // [rsp+898h] [rbp+6A8h] BYREF
  char v180; // [rsp+8B0h] [rbp+6C0h] BYREF
  _BYTE v181[168]; // [rsp+8C8h] [rbp+6D8h] BYREF
  _BYTE v182[64]; // [rsp+970h] [rbp+780h] BYREF
  _QWORD v183[3]; // [rsp+9B0h] [rbp+7C0h] BYREF
  _QWORD v184[7]; // [rsp+9C8h] [rbp+7D8h] BYREF
  _BYTE v185[64]; // [rsp+A00h] [rbp+810h] BYREF
  _QWORD v186[3]; // [rsp+A40h] [rbp+850h] BYREF
  _QWORD v187[7]; // [rsp+A58h] [rbp+868h] BYREF

  if ( validateHandleAccess((unsigned __int64 *)a1 + 2) )
  {
    if ( *a2 == 1 )
    {
      if ( *a2 != 1 )
        LogFatalError(
          "GetSuccess should only be called on a result holding a T_Success object. Did you forget to do a cast-to-bool check first?");
      v47 = a2 + 8;
      v39[0] = add_0xC7(0x16u);
      v39[1] = 8;
      src_[0] = v39;
      src_[1] = &v40;
      qmemcpy(dst_, src_, sizeof(dst_));
      v21 = invokeGlobalCallbackAndMaskStatusBits(
              5,
              (__int64)dst_,
              (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
              "AsyncQueryEntitiesByEntitlement query returned $$ results for player $$");
      if ( (v21 & 0xFFFFF) != 0 )
      {
        v131 = GetPlayerIdFromContext(qword_149E7E438, v155);
        v72 = identity_int64(*v131);
        v151[0] = 0;
        v151[1] = v72;
        v152 = 0;
        v74 = v151;
        v66 = v47;
        v73 = (v47[1] - *v47) / 0x150LL;
        v135[0] = 0;
        v135[1] = v73;
        v75 = v135;
        ThreadLogContextSlot = getThreadLogContextSlot();
        v137[0] = 0;
        v137[1] = 0;
        v41[0] = add_0xC7(0x16u);
        v41[1] = 8;
        src__1[0] = v41;
        src__1[1] = &v42;
        qmemcpy(dst__1, src__1, sizeof(dst__1));
        v155[1] = 3;
        v5 = alloca(0x150);
        v67 = v12;
        __Val_0__ = (vraudio::AudioBuffer *)v12;
        sub_1453E8920((__int64)v12, (__int64)ThreadLogContextSlot, v75, v74);
        LODWORD(v11) = v21;
        ReportTelemetryEvent(
          5u,
          dst__1,
          "CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
          "AsyncQueryEntitiesByEntitlement query returned $$ results for player $$",
          __Val_0__,
          3u,
          1,
          v11,
          v137,
          0);
      }
      ZeroInitializeAndNotifyEngine((Parameter *)&Parameter_);
      v69 = a1 + 4;
      v26 = a1[4];
      v77 = a1[5];
      while ( v26 != v77 )
      {
        v78 = v26;
        sub_1453F6AE0((__int64)v185, v26);
        v155[2] = sub_1453DC930((__int64)&Parameter_, (__int64)v185);
        sub_1402ABD50(v187);
        sub_140370D10(v186);
        v26 += 0xB0;
      }
      ZeroInitializeAndNotifyEngine((Parameter *)Parameter__1);
      v48 = v47;
      v27 = (_QWORD *)*v47;
      v79 = (_QWORD *)v47[1];
      while ( v27 != v79 )
      {
        v80 = v27;
        v17 = v27;
        v81 = sub_1405BA390((__int64)v27);
        v82 = v81;
        v83 = v81;
        v90 = (_QWORD *)v81;
        Parameter_1 = &Parameter_;
        Parameter_2 = &Parameter_;
        Parameter__15 = Parameter__14;
        Parameter[0] = Parameter__14;
        _StarEngineModule__((ULONG_PTR)Parameter);
        v86 = Parameter[0];
        Parameter__21 = Parameter[0];
        Parameter[1] = (ULONG_PTR)&Parameter_;
        Parameter_3 = &Parameter_;
        Parameter__2 = Parameter_;
        Parameter__3[0] = Parameter_;
        _StarEngineModule__((ULONG_PTR)Parameter__3);
        v89 = Parameter__3[0];
        v92 = Parameter__3[0];
        v96 = v90;
        Parameter__22 = Parameter__21;
        Parameter__19 = Parameter__3[0];
        Parameter__13 = Parameter__3[0];
        Parameter__17 = Parameter__21;
        while ( Parameter__13 != Parameter__17 )
        {
          Parameter__16 = Parameter__13;
          if ( Current_set((unsigned __int8 **)(Parameter__13 + 0x40), v96) )
            break;
          Parameter__13 += 0x88LL;
        }
        Parameter__18 = Parameter__13;
        Parameter__19 = Parameter__13;
        Parameter__5 = Parameter__13;
        v98 = 0;
        v99 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
                 v17,
                 v156);
        if ( sub_14037F610(v99, v98) )
        {
          v6 = sub_1403B1810((__int64)v17);
          if ( !sub_1405B0470(v6) )
          {
            v100 = 0;
            v101 = *sub_1405C0C30((__int64)v17, &v169);
            if ( sub_14037F610(v101, v100) )
            {
              v102 = std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
                       v17,
                       &v157);
              v103 = sub_1405C0C30((__int64)v17, v158);
              v140 = *(_OWORD *)v102;
              sub_144BC1E00(Parameter__1, &v140);
            }
          }
        }
        sub_1453F7170((__int64)v182, v17);
        Parameter__3[1] = (ULONG_PTR)&Parameter_;
        Parameter_4 = &Parameter_;
        Parameter__20 = Parameter__14;
        Parameter__4 = Parameter__14;
        _StarEngineModule__((ULONG_PTR)&Parameter__4);
        v22 = Parameter__5 == Parameter__4;
        if ( Parameter__5 == Parameter__4 )
        {
          v158[1] = sub_1453DC930((__int64)&Parameter_, (__int64)v182);
        }
        else
        {
          Parameter__6 = Parameter__5;
          sub_1453FBB90(Parameter__5, (__int64)v182);
        }
        sub_1402ABD50(v184);
        sub_140370D10(v183);
        v27 += 0x2A;
      }
      v54 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0x98);
      v107 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v54 + 0x58LL);
      v108 = *(_QWORD *)v107(v54, v167);
      v109 = sub_1436C6BA0(v170, v108);
      v110 = *v109;
      v55[0] = v110;
      if ( is_valid_handle_typeA(v55) )
        v29 = v55[0] & 0xFFFFFFFFFFFFLL;
      else
        v29 = 0;
      if ( v29 )
      {
        unknown_libname_472(&v132);
        v55[1] = (__int64)&Parameter_;
        Parameter__7 = Parameter_;
        Parameter__9 = Parameter__14;
        while ( Parameter__7 != Parameter__9 )
        {
          Parameter__8 = Parameter__7;
          v56 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0xA0);
          v57 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v56 + 0xC0LL))(v56);
          v112 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v57 + 0x18LL);
          qmemcpy(dst__2, (const void *)(Parameter__8 + 8), sizeof(dst__2));
          qmemcpy(dst__3, dst__2, sizeof(dst__3));
          v113 = v112(v57, dst__3);
          sub_143FA4AF0(v29, &v15, a1[1], v113);
          v14[0xE0] = v16;
          if ( !v16 )
            v170[1] = sub_1403EF290(&v132, (_OWORD *)(Parameter__8 + 8));
          Parameter__7 += 0x88LL;
        }
        v114 = *a1;
        v174[0] = v114;
        v174[1] = a1[2];
        v175 = *((_BYTE *)a1 + 0x18);
        v176 = a1[1];
        v115 = v177;
        sub_1403C4110((__int64)v177, (__int64)a2);
        Parameter_5 = Parameter__10;
        sub_14282BD80((Parameter *)Parameter__10, (__int64 *)&Parameter_);
        Parameter_6 = Parameter__11;
        sub_14282BD80((Parameter *)Parameter__11, Parameter__1);
        v59 = &v132;
        v23 = v132 == v133;
        if ( v132 == v133 )
        {
          sub_1454092C0(v174);
        }
        else
        {
          v119 = &v180;
          v118 = v181;
          v7 = sub_1453EDA60((__int64)v181, (__int64)v174);
          v120 = (_QWORD *)sub_1453D2B80((__int64)v119, v7);
          v121 = a1[1];
          sub_143F9FED0(v29, v121, &v132, v120);
        }
        sub_14277C8E0((Parameter *)Parameter__11);
        sub_14545FA30(Parameter__10);
        sub_1404A7660((__int64)v177);
        std::vector<GSC::AI::GameGraph::game_graph_edge>::~vector<GSC::AI::GameGraph::game_graph_edge>((std::vector<GSC::AI::GameGraph::game_graph_edge> *)&v132);
      }
      else
      {
        v43[0] = add_0xC7(0x16u);
        v43[1] = 8;
        src__2[0] = v43;
        src__2[1] = &v44;
        qmemcpy(dst__4, src__2, sizeof(dst__4));
        v24 = invokeGlobalCallbackAndMaskStatusBits(
                3,
                (__int64)dst__4,
                (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
                "Expecting a valid wallet on the player");
        if ( (v24 & 0xFFFFF) != 0 )
        {
          ThreadLogContextSlot_1 = getThreadLogContextSlot();
          v147[0] = 0;
          v147[1] = 0;
          v45[0] = add_0xC7(0x16u);
          v45[1] = 8;
          src__3[0] = v45;
          src__3[1] = &v46;
          qmemcpy(dst__5, src__3, sizeof(dst__5));
          v156[1] = 1;
          v8 = alloca(0x70);
          v60 = v10;
          __Val_0___1 = (vraudio::AudioBuffer *)v10;
          sub_140354560((__int64)v10, (__int64)ThreadLogContextSlot_1);
          LODWORD(v9) = v24;
          ReportTelemetryEvent(
            3u,
            dst__5,
            "CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
            "Expecting a valid wallet on the player",
            __Val_0___1,
            1u,
            1,
            v9,
            v147,
            0);
        }
      }
      sub_14277C8E0((Parameter *)Parameter__1);
      return sub_14545FA30(&Parameter_);
    }
    else
    {
      v31[0] = add_0xC7(0x16u);
      v31[1] = 8;
      src__4[0] = v31;
      src__4[1] = &v32;
      qmemcpy(dst__6, src__4, sizeof(dst__6));
      v20 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)dst__6,
              (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
              "AsyncQueryEntitiesByEntitlement failed for the player [$$] with Error: $$");
      if ( (v20 & 0xFFFFF) != 0 )
      {
        if ( *a2 )
          LogFatalError(
            "GetError should only be called on a result holding a T_Error object. Did you forget to do a cast-to-bool check first?");
        v127 = a2 + 8;
        v128 = GetPlayerIdFromContext(qword_149E7E438, v154);
        ThreadLogContextSlot_2 = getThreadLogContextSlot();
        v144[0] = 0;
        v144[1] = 0;
        v37[0] = add_0xC7(0x16u);
        v37[1] = 8;
        src__5[0] = v37;
        src__5[1] = &v38;
        qmemcpy(dst__7, src__5, sizeof(dst__7));
        v154[1] = 3;
        v4 = alloca(0x150);
        v63 = v12;
        __Val_0___2 = (vraudio::AudioBuffer *)v12;
        sub_140B9AF10((__int64)v12, (__int64)ThreadLogContextSlot_2, (__int64)v128, (__int64)v127);
        LODWORD(v11) = v20;
        ReportTelemetryEvent(
          3u,
          dst__7,
          "CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
          "AsyncQueryEntitiesByEntitlement failed for the player [$$] with Error: $$",
          __Val_0___2,
          3u,
          1,
          v11,
          v144,
          0);
      }
      v130 = *a1;
      ZeroInitializeAndNotifyEngine((Parameter *)Parameter__12);
      ProcessFetchedShipData(v130, Parameter__12);
      return DeallocateShipDataList(Parameter__12);
    }
  }
  else
  {
    v33[0] = add_0xC7(0x16u);
    v33[1] = 8;
    src__6[0] = v33;
    src__6[1] = &v34;
    qmemcpy(dst__8, src__6, sizeof(dst__8));
    v18 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)dst__8,
            (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
            "ASOP entity was null in the AsyncQueryEntitiesByEntitlement callback for player $$");
    if ( (v18 & 0xFFFFF) != 0 )
    {
      v123 = GetPlayerIdFromContext(qword_149E7E438, &v171);
      v124 = identity_int64(*v123);
      v149[0] = 0;
      v149[1] = v124;
      v150 = 0;
      v125 = v149;
      ThreadLogContextSlot_3 = getThreadLogContextSlot();
      v141[0] = 0;
      v141[1] = 0;
      v35[0] = add_0xC7(0x16u);
      v35[1] = 8;
      src__7[0] = v35;
      src__7[1] = &v36;
      qmemcpy(dst__9, src__7, sizeof(dst__9));
      n2 = 2;
      v2 = alloca(0xE0);
      v58 = v14;
      __Val_0___3 = (vraudio::AudioBuffer *)v14;
      InitTraceContextPlayerIdIntDescriptor((__int64)v14, (__int64)ThreadLogContextSlot_3, v125);
      LODWORD(v13) = v18;
      ReportTelemetryEvent(
        5u,
        dst__9,
        "CEntityComponentShipListProvider::FetchOwnedShipsData::<lambda_1>::operator ()",
        "ASOP entity was null in the AsyncQueryEntitiesByEntitlement callback for player $$",
        __Val_0___3,
        2u,
        1,
        v13,
        v141,
        0);
    }
    return 0;
  }
}

// --- End Function: sub_145400150 (0x145400150) ---

// --- Function: sub_145402390 (0x145402390) ---
__int64 __fastcall sub_145402390(__int64 a1, __int64 a2, __int64 a3)
{
  bool v4; // [rsp+20h] [rbp-78h]
  __int64 v5; // [rsp+28h] [rbp-70h] BYREF
  __int64 v6; // [rsp+30h] [rbp-68h] BYREF
  __int64 v7; // [rsp+38h] [rbp-60h]
  __int64 v8; // [rsp+40h] [rbp-58h]
  _QWORD *v9; // [rsp+48h] [rbp-50h]
  unsigned __int16 **v10; // [rsp+50h] [rbp-48h]
  _BYTE dst_[16]; // [rsp+60h] [rbp-38h] BYREF
  _BYTE dst__1[40]; // [rsp+70h] [rbp-28h] BYREF

  qmemcpy(dst_, (const void *)(a2 + 8), sizeof(dst_));
  sub_1454185F0(&v6, dst_, 1);
  v8 = (__int64)&v6;
  qmemcpy(dst__1, (const void *)(a3 + 8), 0x10u);
  sub_1454185F0(&v5, dst__1, 1);
  v7 = (__int64)&v5;
  if ( sub_14037F680((unsigned __int16 **)v8, &v5) )
  {
    v9 = (_QWORD *)identity_int64(v7);
    v10 = (unsigned __int16 **)identity_int64(v8);
    v4 = (int)sub_1403E48C0(v10, v9) < 0;
    sub_1402ABD50(&v5);
    sub_1402ABD50(&v6);
    return v4;
  }
  else
  {
    sub_1402ABD50(&v5);
    sub_1402ABD50(&v6);
    return 1;
  }
}

// --- End Function: sub_145402390 (0x145402390) ---

// --- Function: HandleFetchShipDataResult (0x1454048C0) ---
// Processes the result of an asynchronous operation to fetch ship data. It first
// validates the input handle. Based on the operation's success or failure, it logs
// appropriate messages (success, error, or invalid entity) using a structured
// logging system. For successful operations, it proceeds to process the fetched
// ship data. For failed operations, it handles error details and performs
// necessary cleanup.
void __fastcall HandleFetchShipDataResult(unsigned __int64 *operationHandle, _BYTE *operationResult)
{
  void *v2; // rsp
  void *v3; // rsp
  void *v4; // rsp
  __int64 v5; // [rsp+18h] [rbp-168h]
  _QWORD v6[8]; // [rsp+30h] [rbp-150h] BYREF
  __int64 v7; // [rsp+88h] [rbp-F8h]
  _BYTE v8[144]; // [rsp+A0h] [rbp-E0h] BYREF
  int v9; // [rsp+180h] [rbp+0h]
  int v11; // [rsp+188h] [rbp+8h]
  int eventDescriptorBuffer; // [rsp+18Ch] [rbp+Ch]
  _QWORD *v13; // [rsp+190h] [rbp+10h]
  _DWORD v14[2]; // [rsp+198h] [rbp+18h] BYREF
  char callbackStatus; // [rsp+1A0h] [rbp+20h] BYREF
  _DWORD v16[2]; // [rsp+1A8h] [rbp+28h] BYREF
  char v17; // [rsp+1B0h] [rbp+30h] BYREF
  _DWORD v18[2]; // [rsp+1B8h] [rbp+38h] BYREF
  char logMessageDescriptor; // [rsp+1C0h] [rbp+40h] BYREF
  _DWORD v20[2]; // [rsp+1C8h] [rbp+48h] BYREF
  char v21; // [rsp+1D0h] [rbp+50h] BYREF
  _DWORD v22[2]; // [rsp+1D8h] [rbp+58h] BYREF
  char v23; // [rsp+1E0h] [rbp+60h] BYREF
  _DWORD v24[2]; // [rsp+1E8h] [rbp+68h] BYREF
  char v25; // [rsp+1F0h] [rbp+70h] BYREF
  _BYTE *v26; // [rsp+1F8h] [rbp+78h]
  vraudio::AudioBuffer *__Val_0___2; // [rsp+200h] [rbp+80h]
  _QWORD *v28; // [rsp+208h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___1; // [rsp+210h] [rbp+90h]
  _QWORD *v30; // [rsp+218h] [rbp+98h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+220h] [rbp+A0h]
  __int64 *ThreadLogContextSlot_2; // [rsp+228h] [rbp+A8h]
  __int64 *v33; // [rsp+230h] [rbp+B0h]
  __int64 eventDescriptorPtr; // [rsp+238h] [rbp+B8h]
  _BYTE *v35; // [rsp+240h] [rbp+C0h]
  _QWORD *eventDescriptorPtr2; // [rsp+248h] [rbp+C8h]
  __int64 *ThreadLogContextSlot; // [rsp+250h] [rbp+D0h]
  __int64 v38; // [rsp+258h] [rbp+D8h]
  __int64 *errorDetailsPtr; // [rsp+260h] [rbp+E0h]
  __int64 errorDetailsValue; // [rsp+268h] [rbp+E8h]
  _QWORD *v41; // [rsp+270h] [rbp+F0h]
  __int64 *v42; // [rsp+278h] [rbp+F8h]
  __int64 *ThreadLogContextSlot_1; // [rsp+280h] [rbp+100h]
  __int64 v44; // [rsp+288h] [rbp+108h]
  __int64 playerIdPtr; // [rsp+290h] [rbp+110h]
  __int64 *playerIdValue; // [rsp+298h] [rbp+118h]
  __int64 v47; // [rsp+2A0h] [rbp+120h]
  _QWORD *v48; // [rsp+2A8h] [rbp+128h]
  _QWORD src__4[2]; // [rsp+2B0h] [rbp+130h] BYREF
  _QWORD src__5[2]; // [rsp+2C0h] [rbp+140h] BYREF
  _QWORD v51[2]; // [rsp+2D0h] [rbp+150h] BYREF
  _QWORD src__2[2]; // [rsp+2E0h] [rbp+160h] BYREF
  _QWORD src__3[2]; // [rsp+2F0h] [rbp+170h] BYREF
  _QWORD v54[2]; // [rsp+300h] [rbp+180h] BYREF
  _QWORD src_[2]; // [rsp+310h] [rbp+190h] BYREF
  __int64 v56; // [rsp+320h] [rbp+1A0h] BYREF
  int playerIdPtr_1; // [rsp+328h] [rbp+1A8h]
  _QWORD src__1[2]; // [rsp+330h] [rbp+1B0h] BYREF
  _QWORD v59[2]; // [rsp+340h] [rbp+1C0h] BYREF
  _QWORD v60[2]; // [rsp+350h] [rbp+1D0h] BYREF
  char v61; // [rsp+360h] [rbp+1E0h]
  _QWORD v62[2]; // [rsp+368h] [rbp+1E8h] BYREF
  char v63; // [rsp+378h] [rbp+1F8h]
  _QWORD v64[2]; // [rsp+380h] [rbp+200h] BYREF
  char v65; // [rsp+390h] [rbp+210h]
  __int64 n2; // [rsp+398h] [rbp+218h]
  _QWORD v67[2]; // [rsp+3A0h] [rbp+220h] BYREF
  __int64 v68; // [rsp+3B0h] [rbp+230h] BYREF
  _QWORD v69[2]; // [rsp+3B8h] [rbp+238h] BYREF
  _BYTE dst__4[16]; // [rsp+3C8h] [rbp+248h] BYREF
  __int64 dst__5[2]; // [rsp+3D8h] [rbp+258h] BYREF
  _BYTE dst__2[16]; // [rsp+3E8h] [rbp+268h] BYREF
  __int64 dst__3[2]; // [rsp+3F8h] [rbp+278h] BYREF
  _BYTE dst_[16]; // [rsp+408h] [rbp+288h] BYREF
  __int64 dst__1[2]; // [rsp+418h] [rbp+298h] BYREF
  __int64 Parameter_[3]; // [rsp+428h] [rbp+2A8h] BYREF

  if ( validateHandleAccess(operationHandle + 1) )
  {
    if ( *operationResult == 1 )
    {
      if ( *operationResult != 1 )
        LogFatalError(
          "GetSuccess should only be called on a result holding a T_Success object. Did you forget to do a cast-to-bool check first?");
      v13 = operationResult + 8;
      v22[0] = add_0xC7(0x16u);
      v22[1] = 8;
      src_[0] = v22;
      src_[1] = &v23;
      qmemcpy(dst_, src_, sizeof(dst_));
      eventDescriptorBuffer = invokeGlobalCallbackAndMaskStatusBits(
                                5,
                                (__int64)dst_,
                                (__int64)"CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
                                "Received $$ player insured entitlements results for player $$");
      if ( (eventDescriptorBuffer & 0xFFFFF) != 0 )
      {
        errorDetailsPtr = GetPlayerIdFromContext(qword_149E7E438, v69);
        errorDetailsValue = identity_int64(*errorDetailsPtr);
        v64[0] = 0;
        v64[1] = errorDetailsValue;
        v65 = 0;
        v41 = v64;
        playerIdPtr = (v13[1] - *v13) / 0xB0LL;
        v56 = 0;
        playerIdPtr_1 = playerIdPtr;
        v42 = &v56;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v59[0] = 0;
        v59[1] = 0;
        v24[0] = add_0xC7(0x16u);
        v24[1] = 8;
        src__1[0] = v24;
        src__1[1] = &v25;
        qmemcpy(dst__1, src__1, sizeof(dst__1));
        v69[1] = 3;
        v4 = alloca(0x150);
        v30 = v6;
        __Val_0__ = (vraudio::AudioBuffer *)v6;
        InitTraceContextWithPlayerIdDescriptor((__int64)v6, ThreadLogContextSlot_1, v42, v41);
        LODWORD(v5) = eventDescriptorBuffer;
        ReportTelemetryEvent(
          5u,
          dst__1,
          "CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
          "Received $$ player insured entitlements results for player $$",
          __Val_0__,
          3u,
          1,
          v5,
          v59,
          0);
      }
      v44 = *operationHandle;
      ProcessFetchedShipEntitlements(v44, operationHandle[2], v13, *((_BYTE *)operationHandle + 0x18));
    }
    else
    {
      v20[0] = add_0xC7(0x16u);
      v20[1] = 8;
      src__2[0] = v20;
      src__2[1] = &v21;
      qmemcpy(dst__2, src__2, sizeof(dst__2));
      v11 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)dst__2,
              (__int64)"CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
              "FetchOwnedShipsData Failed - PlayerId: $$, Error: $$");
      if ( (v11 & 0xFFFFF) != 0 )
      {
        if ( *operationResult )
          LogFatalError(
            "GetError should only be called on a result holding a T_Error object. Did you forget to do a cast-to-bool check first?");
        v35 = operationResult + 8;
        v33 = GetPlayerIdFromContext(qword_149E7E438, &v68);
        eventDescriptorPtr = identity_int64(*v33);
        v62[0] = 0;
        v62[1] = eventDescriptorPtr;
        v63 = 0;
        eventDescriptorPtr2 = v62;
        ThreadLogContextSlot = getThreadLogContextSlot();
        v54[0] = 0;
        v54[1] = 0;
        v14[0] = add_0xC7(0x16u);
        v14[1] = 8;
        src__3[0] = v14;
        src__3[1] = &callbackStatus;
        qmemcpy(dst__3, src__3, sizeof(dst__3));
        v67[1] = 3;
        v3 = alloca(0x150);
        v28 = v6;
        __Val_0___1 = (vraudio::AudioBuffer *)v6;
        InitTraceContextPlayerIdErrorDetailsDescriptor(
          (__int64)v6,
          ThreadLogContextSlot,
          eventDescriptorPtr2,
          (__int64)v35);
        LODWORD(v5) = v11;
        ReportTelemetryEvent(
          3u,
          dst__3,
          "CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
          "FetchOwnedShipsData Failed - PlayerId: $$, Error: $$",
          __Val_0___1,
          3u,
          1,
          v5,
          v54,
          0);
      }
      v38 = *operationHandle;
      ZeroInitializeAndNotifyEngine((Parameter *)Parameter_);
      ProcessFetchedShipData(v38, Parameter_);
      DeallocateShipDataList((Parameter *)Parameter_);
    }
  }
  else
  {
    v18[0] = add_0xC7(0x16u);
    v18[1] = 8;
    src__4[0] = v18;
    src__4[1] = &logMessageDescriptor;
    qmemcpy(dst__4, src__4, sizeof(dst__4));
    v9 = invokeGlobalCallbackAndMaskStatusBits(
           5,
           (__int64)dst__4,
           (__int64)"CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
           "ASOP entity was null in the GetPlayerInsuredEntitledShips callback for player $$");
    if ( (v9 & 0xFFFFF) != 0 )
    {
      playerIdValue = GetPlayerIdFromContext(qword_149E7E438, v67);
      v47 = identity_int64(*playerIdValue);
      v60[0] = 0;
      v60[1] = v47;
      v61 = 0;
      v48 = v60;
      ThreadLogContextSlot_2 = getThreadLogContextSlot();
      v51[0] = 0;
      v51[1] = 0;
      v16[0] = add_0xC7(0x16u);
      v16[1] = 8;
      src__5[0] = v16;
      src__5[1] = &v17;
      qmemcpy(dst__5, src__5, sizeof(dst__5));
      n2 = 2;
      v2 = alloca(0xE0);
      v26 = v8;
      __Val_0___2 = (vraudio::AudioBuffer *)v8;
      InitTraceContextPlayerIdIntDescriptor((__int64)v8, (__int64)ThreadLogContextSlot_2, v48);
      LODWORD(v7) = v9;
      ReportTelemetryEvent(
        5u,
        dst__5,
        "CEntityComponentShipListProvider::FetchShipData::<lambda_1>::operator ()",
        "ASOP entity was null in the GetPlayerInsuredEntitledShips callback for player $$",
        __Val_0___2,
        2u,
        1,
        v7,
        v51,
        0);
    }
  }
}

// --- End Function: HandleFetchShipDataResult (0x1454048C0) ---

// --- Function: sub_1454092C0 (0x1454092C0) ---
__int64 __fastcall sub_1454092C0(__int64 a1)
{
  __int64 result; // rax
  __int64 *v2; // rax
  __int64 v3; // [rsp+40h] [rbp-1D8h]
  __int64 (__fastcall ***v4)(_QWORD); // [rsp+58h] [rbp-1C0h]
  __int64 v5; // [rsp+60h] [rbp-1B8h]
  __int64 v6; // [rsp+68h] [rbp-1B0h]
  __int64 v7; // [rsp+78h] [rbp-1A0h]
  __int64 *v8; // [rsp+A0h] [rbp-178h]
  _QWORD v9[3]; // [rsp+A8h] [rbp-170h] BYREF
  _QWORD src_[4]; // [rsp+C0h] [rbp-158h] BYREF
  __int64 v11[2]; // [rsp+E0h] [rbp-138h] BYREF
  void (__fastcall *v12[3])(char *); // [rsp+F0h] [rbp-128h] BYREF
  _BYTE v13[40]; // [rsp+108h] [rbp-110h] BYREF
  __int64 v14[14]; // [rsp+130h] [rbp-E8h] BYREF
  __int64 v15; // [rsp+1A0h] [rbp-78h] BYREF
  __int64 Parameter_; // [rsp+1A8h] [rbp-70h] BYREF
  __int64 Parameter__1; // [rsp+1C0h] [rbp-58h] BYREF
  _BYTE dst_[32]; // [rsp+1D8h] [rbp-40h] BYREF

  result = validateHandleAccess((unsigned __int64 *)(a1 + 8));
  if ( (_BYTE)result )
  {
    src_[0] = *(_QWORD *)a1;
    src_[1] = *(_QWORD *)(a1 + 8);
    LOBYTE(src_[2]) = *(_BYTE *)(a1 + 0x10);
    src_[3] = *(_QWORD *)(a1 + 0x18);
    unknown_libname_472(v9);
    v3 = *(_QWORD *)(a1 + 0x88);
    v7 = *(_QWORD *)(a1 + 0x90);
    while ( v3 != v7 )
    {
      sub_1402A6620((__int64)v9, (_QWORD *)(v3 + 8));
      v3 += 0x10;
    }
    if ( v9[0] == v9[1] )
    {
      sub_1453FEA20(src_, a1 + 0x70);
    }
    else
    {
      sub_14036C440((__int64)v14);
      v4 = *(__int64 (__fastcall ****)(_QWORD))(identity_int64((__int64)&qword_149B4FBE0) + 0x188);
      v5 = (**v4)(v4);
      v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x60LL))(v5);
      v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD *, __int64 *, char))(*(_QWORD *)v6 + 0x20LL))(
                        v6,
                        v13,
                        v9,
                        v14,
                        0x29);
      v15 = *(_QWORD *)(a1 + 8);
      sub_14282BD80((Parameter *)&Parameter_, (__int64 *)(a1 + 0x88));
      sub_14282BD80((Parameter *)&Parameter__1, (__int64 *)(a1 + 0x70));
      qmemcpy(dst_, src_, sizeof(dst_));
      sub_1453D28C0(v12, &v15);
      v2 = sub_1404CC7C0(v8, v11, v12);
      sub_1403A3C70(v2);
      std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v11);
      sub_1402A2AD0(v12);
      sub_140370B50((__int64)v13);
      sub_140375750(v14);
    }
    return sub_1402B2810((__int64)v9);
  }
  return result;
}

// --- End Function: sub_1454092C0 (0x1454092C0) ---

// --- Function: sub_14540B8A0 (0x14540B8A0) ---
__int64 __fastcall sub_14540B8A0(__int64 a1, _BYTE *a2)
{
  return sub_145400150(*(__int64 **)(a1 + 0x10), a2);
}

// --- End Function: sub_14540B8A0 (0x14540B8A0) ---

// --- Function: HandleFetchShipDataResult_w (0x14540BA50) ---
void __fastcall sub_14540BA50(__int64 a1, _BYTE *a2)
{
  HandleFetchShipDataResult(*(unsigned __int64 **)(a1 + 0x10), a2);
}

// --- End Function: HandleFetchShipDataResult_w (0x14540BA50) ---

// --- Function: sub_14540CAF0 (0x14540CAF0) ---
_QWORD *__fastcall sub_14540CAF0(int n2, _QWORD *a2, _QWORD *a3)
{
  _QWORD *result; // rax
  __int64 **v4; // [rsp+38h] [rbp-30h]

  if ( n2 )
  {
    if ( n2 != 1 )
    {
      if ( n2 != 2 )
        return 0;
      v4 = (__int64 **)a2[2];
      if ( v4 )
      {
        sub_140B01DB0(v4 + 4);
        sub_1402A3D30(v4);
      }
      a2[2] = 0;
      *a2 = 0;
      result = a2;
      a2[1] = 0;
      return result;
    }
  }
  else
  {
    LogFatalError("Can not request a copy for a CigMoveOnlyFunction, something's broken in the implementation");
  }
  result = a3;
  if ( *a3 )
  {
    if ( a3[1] == 1 )
    {
      a2[2] = 0;
      *a2 = *a3;
      a2[1] = 1;
    }
    else
    {
      a2[2] = a3[2];
      *a2 = *a3;
      a2[1] = a3[1];
    }
    a3[2] = 0;
    *a3 = 0;
    result = a3;
    a3[1] = 0;
  }
  return result;
}

// --- End Function: sub_14540CAF0 (0x14540CAF0) ---

// --- Function: ProcessFetchedShipEntitlements (0x145413B20) ---
// Processes a list of fetched ship entitlements. This function logs the data
// fetching process, initializes internal data structures, and iterates through the
// provided entitlements list, adding each item to a local collection. It interacts
// with asynchronous operations (futures/promises) to manage data flow, potentially
// canceling or resolving them. The function also integrates with engine services
// for data management and performs extensive logging of the process.
void __fastcall ProcessFetchedShipEntitlements(
        __int64 shipDataProviderContext,
        __int64 unknownContext,
        _QWORD *entitlementsList,
        char processFlags)
{
  void *v4; // rsp
  void *v5; // rsp
  __int64 v6; // rax
  __int64 *futureResult; // rax
  int v8; // [rsp+8h] [rbp-2C8h]
  __int64 v9; // [rsp+18h] [rbp-2B8h]
  _BYTE eventDescriptorBuffer[144]; // [rsp+30h] [rbp-2A0h] BYREF
  __int64 v11; // [rsp+F8h] [rbp-1D8h]
  _BYTE v12[368]; // [rsp+110h] [rbp-1C0h] BYREF
  int n3; // [rsp+2D0h] [rbp+0h]
  int callbackStatus; // [rsp+2D4h] [rbp+4h]
  int v15; // [rsp+2D8h] [rbp+8h]
  __int64 playerIdValue_1; // [rsp+2E0h] [rbp+10h]
  _DWORD v17[2]; // [rsp+2E8h] [rbp+18h] BYREF
  char v18; // [rsp+2F0h] [rbp+20h] BYREF
  _DWORD v19[2]; // [rsp+2F8h] [rbp+28h] BYREF
  char v20; // [rsp+300h] [rbp+30h] BYREF
  _DWORD v21[2]; // [rsp+308h] [rbp+38h] BYREF
  char v22; // [rsp+310h] [rbp+40h] BYREF
  _DWORD v23[2]; // [rsp+318h] [rbp+48h] BYREF
  char v24; // [rsp+320h] [rbp+50h] BYREF
  _BYTE *eventDescriptorPtr; // [rsp+328h] [rbp+58h]
  __int64 __Val_0__; // [rsp+330h] [rbp+60h]
  __int64 v27; // [rsp+338h] [rbp+68h]
  _QWORD *entitlementsList_1; // [rsp+340h] [rbp+70h]
  _BYTE *p_eventDescriptorBuffer; // [rsp+348h] [rbp+78h]
  vraudio::AudioBuffer *p_eventDescriptorBuffer_1; // [rsp+350h] [rbp+80h]
  __int64 (__fastcall ***v31)(_QWORD); // [rsp+358h] [rbp+88h]
  __int64 v32; // [rsp+360h] [rbp+90h]
  __int64 v33; // [rsp+368h] [rbp+98h]
  __int64 **p_futureResultPtr3; // [rsp+370h] [rbp+A0h]
  __int64 v35; // [rsp+378h] [rbp+A8h]
  __int64 eventDescriptorPtr3; // [rsp+380h] [rbp+B0h]
  __int64 eventDescriptorPtr4; // [rsp+388h] [rbp+B8h]
  __int64 playerIdPtr; // [rsp+390h] [rbp+C0h]
  __int64 *ThreadLogContextSlot; // [rsp+398h] [rbp+C8h]
  __int64 playerIdValue; // [rsp+3A0h] [rbp+D0h]
  __int64 playerIdValue_2; // [rsp+3A8h] [rbp+D8h]
  __int64 v42; // [rsp+3B0h] [rbp+E0h]
  __int64 *errorDetailsPtr; // [rsp+3B8h] [rbp+E8h]
  __int64 errorDetailsValue; // [rsp+3C0h] [rbp+F0h]
  _QWORD *v45; // [rsp+3C8h] [rbp+F8h]
  __int64 *ThreadLogContextSlot_1; // [rsp+3D0h] [rbp+100h]
  __int64 v47; // [rsp+3D8h] [rbp+108h]
  __int64 (__fastcall *v48)(__int64, _BYTE *, __int64, __int64 **, __int64 *, int); // [rsp+3E0h] [rbp+110h]
  _BYTE *p_engineService; // [rsp+3E8h] [rbp+118h]
  __int64 **v50; // [rsp+3F0h] [rbp+120h]
  __int64 *v51; // [rsp+3F8h] [rbp+128h]
  __int64 v52; // [rsp+400h] [rbp+130h]
  _BYTE *p_engineService_1; // [rsp+408h] [rbp+138h]
  __int64 *v54; // [rsp+410h] [rbp+140h]
  __int64 v55; // [rsp+418h] [rbp+148h]
  __int64 *processedEntitlements[3]; // [rsp+420h] [rbp+150h] BYREF
  _QWORD src_[2]; // [rsp+438h] [rbp+168h] BYREF
  __int64 v58; // [rsp+448h] [rbp+178h] BYREF
  int v59; // [rsp+450h] [rbp+180h]
  _QWORD src__1[2]; // [rsp+458h] [rbp+188h] BYREF
  _QWORD v61[2]; // [rsp+468h] [rbp+198h] BYREF
  _QWORD src__2[2]; // [rsp+478h] [rbp+1A8h] BYREF
  _QWORD src__3[2]; // [rsp+488h] [rbp+1B8h] BYREF
  _QWORD v64[2]; // [rsp+498h] [rbp+1C8h] BYREF
  _QWORD v65[2]; // [rsp+4A8h] [rbp+1D8h] BYREF
  char v66; // [rsp+4B8h] [rbp+1E8h]
  _QWORD v67[2]; // [rsp+4C0h] [rbp+1F0h] BYREF
  char v68; // [rsp+4D0h] [rbp+200h]
  _QWORD v69[2]; // [rsp+4D8h] [rbp+208h] BYREF
  char v70; // [rsp+4E8h] [rbp+218h]
  __int64 v71; // [rsp+4F0h] [rbp+220h] BYREF
  _QWORD v72[2]; // [rsp+4F8h] [rbp+228h] BYREF
  _QWORD v73[2]; // [rsp+508h] [rbp+238h] BYREF
  _BYTE dst_[16]; // [rsp+518h] [rbp+248h] BYREF
  __int64 dst__1[2]; // [rsp+528h] [rbp+258h] BYREF
  _BYTE dst__2[16]; // [rsp+538h] [rbp+268h] BYREF
  __int64 dst__3[2]; // [rsp+548h] [rbp+278h] BYREF
  __int64 futureResultPtr[2]; // [rsp+558h] [rbp+288h] BYREF
  void (__fastcall *futureResultPtr2[3])(char *); // [rsp+568h] [rbp+298h] BYREF
  _QWORD futureResultPtr3[3]; // [rsp+580h] [rbp+2B0h] BYREF
  char processFlags_1; // [rsp+598h] [rbp+2C8h]
  __int64 *v82[3]; // [rsp+5A0h] [rbp+2D0h] BYREF
  _BYTE v83[32]; // [rsp+5B8h] [rbp+2E8h] BYREF
  _BYTE traceContext[40]; // [rsp+5D8h] [rbp+308h] BYREF
  __int64 memoryManager[14]; // [rsp+600h] [rbp+330h] BYREF
  _BYTE engineService[56]; // [rsp+670h] [rbp+3A0h] BYREF
  _BYTE engineService_1[56]; // [rsp+6A8h] [rbp+3D8h] BYREF

  v19[0] = add_0xC7(0x16u);
  v19[1] = 8;
  src_[0] = v19;
  src_[1] = &v20;
  qmemcpy(dst_, src_, sizeof(dst_));
  callbackStatus = invokeGlobalCallbackAndMaskStatusBits(
                     5,
                     (__int64)dst_,
                     (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData",
                     "Fetching Owned Ship Data of $$ entitlements for player $$. ATCId: $$");
  if ( (callbackStatus & 0xFFFFF) != 0 )
  {
    v52 = identity_int64(unknownContext);
    v65[0] = 0;
    v65[1] = v52;
    v66 = 0;
    eventDescriptorPtr3 = (__int64)v65;
    v54 = GetPlayerIdFromContext(qword_149E7E438, v72);
    v55 = identity_int64(*v54);
    v67[0] = 0;
    v67[1] = v55;
    v68 = 0;
    eventDescriptorPtr4 = (__int64)v67;
    v35 = (entitlementsList[1] - *entitlementsList) / 0xB0LL;
    v58 = 0;
    v59 = v35;
    playerIdPtr = (__int64)&v58;
    ThreadLogContextSlot = getThreadLogContextSlot();
    v61[0] = 0;
    v61[1] = 0;
    v17[0] = add_0xC7(0x16u);
    v17[1] = 8;
    src__1[0] = v17;
    src__1[1] = &v18;
    qmemcpy(dst__1, src__1, sizeof(dst__1));
    v72[1] = 4;
    v4 = alloca(0x1C0);
    eventDescriptorPtr = v12;
    __Val_0__ = (__int64)v12;
    sub_1453E86F0((__int64)v12, ThreadLogContextSlot, playerIdPtr, eventDescriptorPtr4, eventDescriptorPtr3);
    LODWORD(v11) = callbackStatus;
    ReportTelemetryEvent(
      5u,
      dst__1,
      "CEntityComponentShipListProvider::FetchOwnedShipsData",
      "Fetching Owned Ship Data of $$ entitlements for player $$. ATCId: $$",
      (vraudio::AudioBuffer *)__Val_0__,
      4u,
      1,
      v11,
      v61,
      0);
  }
  sub_14036DC00((__int64)traceContext);
  sub_14036C440((__int64)memoryManager);
  sub_141259930((__int64)memoryManager, 0x81, 0x95);
  sub_144D049F0(memoryManager, 0x2000);
  v27 = sub_1464E7930(qword_149E7E438);
  if ( v27 )
  {
    n3 = sub_146481E10(v27);
    if ( n3 )
    {
      if ( n3 == 1 || n3 == 3 )
        sub_1415A29D0(memoryManager, 2);
    }
    else
    {
      sub_1415A29D0(memoryManager, 1);
    }
  }
  unknown_libname_472(processedEntitlements);
  sub_140AB53A0(processedEntitlements, (entitlementsList[1] - *entitlementsList) / 0xB0LL);
  entitlementsList_1 = entitlementsList;
  playerIdValue_1 = *entitlementsList;
  playerIdValue = entitlementsList[1];
  while ( playerIdValue_1 != playerIdValue )
  {
    playerIdValue_2 = playerIdValue_1;
    sub_14042FD60((__int64)processedEntitlements, (const void **)(playerIdValue_1 + 8));
    playerIdValue_1 += 0xB0;
  }
  v42 = *(_QWORD *)(shipDataProviderContext + 8);
  futureResultPtr3[0] = shipDataProviderContext;
  futureResultPtr3[1] = unknownContext;
  futureResultPtr3[2] = v42;
  processFlags_1 = processFlags;
  v50 = v82;
  sub_140509680(v82, entitlementsList);
  sub_14039A4B0((__int64 *)(shipDataProviderContext + 0xE8));
  v21[0] = add_0xC7(0x16u);
  v21[1] = 8;
  src__2[0] = v21;
  src__2[1] = &v22;
  qmemcpy(dst__2, src__2, sizeof(dst__2));
  v15 = invokeGlobalCallbackAndMaskStatusBits(
          5,
          (__int64)dst__2,
          (__int64)"CEntityComponentShipListProvider::FetchOwnedShipsData",
          "AsyncQueryEntitiesByEntitlement for player $$");
  if ( (v15 & 0xFFFFF) != 0 )
  {
    errorDetailsPtr = GetPlayerIdFromContext(qword_149E7E438, v73);
    errorDetailsValue = identity_int64(*errorDetailsPtr);
    v69[0] = 0;
    v69[1] = errorDetailsValue;
    v70 = 0;
    v45 = v69;
    ThreadLogContextSlot_1 = getThreadLogContextSlot();
    v64[0] = 0;
    v64[1] = 0;
    v23[0] = add_0xC7(0x16u);
    v23[1] = 8;
    src__3[0] = v23;
    src__3[1] = &v24;
    qmemcpy(dst__3, src__3, sizeof(dst__3));
    v73[1] = 2;
    v5 = alloca(0xE0);
    p_eventDescriptorBuffer = eventDescriptorBuffer;
    p_eventDescriptorBuffer_1 = (vraudio::AudioBuffer *)eventDescriptorBuffer;
    InitTraceContextPlayerIdIntDescriptor((__int64)eventDescriptorBuffer, (__int64)ThreadLogContextSlot_1, v45);
    LODWORD(v9) = v15;
    ReportTelemetryEvent(
      5u,
      dst__3,
      "CEntityComponentShipListProvider::FetchOwnedShipsData",
      "AsyncQueryEntitiesByEntitlement for player $$",
      p_eventDescriptorBuffer_1,
      2u,
      1,
      v9,
      v64,
      0);
  }
  v31 = *(__int64 (__fastcall ****)(_QWORD))(identity_int64((__int64)&qword_149B4FBE0) + 0x188);
  v32 = (**v31)(v31);
  v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x60LL))(v32);
  v48 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64, __int64 **, __int64 *, int))(*(_QWORD *)v33 + 0x28LL);
  v47 = *GetPlayerIdFromContext(qword_149E7E438, &v71);
  LOBYTE(v8) = 0x29;
  v51 = (__int64 *)v48(v33, v83, v47, processedEntitlements, memoryManager, v8);
  p_engineService = engineService;
  p_futureResultPtr3 = (__int64 **)sub_1453ED820((__int64)engineService, futureResultPtr3);
  p_engineService_1 = engineService_1;
  v6 = sub_1453ED820((__int64)engineService_1, p_futureResultPtr3);
  sub_1453D2020(futureResultPtr2, v6);
  sub_140B01DB0(p_futureResultPtr3 + 4);
  futureResult = sub_1404CC7C0(v51, futureResultPtr, futureResultPtr2);
  sub_1403798D0(
    (std::shared_ptr<vraudio::MixerNode> *)(shipDataProviderContext + 0xE8),
    (std::shared_ptr<vraudio::MixerNode> *)futureResult);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)futureResultPtr);
  sub_1402A2AD0(futureResultPtr2);
  sub_140370B50((__int64)v83);
  sub_140B01DB0(v82);
  sub_1404634D0((__int64)processedEntitlements);
  sub_140375750(memoryManager);
  sub_1403762C0((__int64)traceContext);
}

// --- End Function: ProcessFetchedShipEntitlements (0x145413B20) ---

// --- Function: sub_145414A40 (0x145414A40) ---
void __fastcall sub_145414A40(__int64 a1, __int64 a2, __int64 *a3)
{
  void *v3; // rsp
  void *v4; // rsp
  bool v7; // al
  char v8; // al
  void *v9; // rsp
  __int64 v10; // [rsp+18h] [rbp-248h]
  _BYTE v11[144]; // [rsp+30h] [rbp-230h] BYREF
  __int64 v12; // [rsp+F8h] [rbp-168h]
  _BYTE v13[64]; // [rsp+110h] [rbp-150h] BYREF
  __int64 v14; // [rsp+168h] [rbp-F8h]
  _BYTE v15[144]; // [rsp+180h] [rbp-E0h] BYREF
  bool v16; // [rsp+260h] [rbp+0h]
  bool v17; // [rsp+261h] [rbp+1h]
  char v18; // [rsp+262h] [rbp+2h]
  char v19; // [rsp+263h] [rbp+3h]
  char v20; // [rsp+264h] [rbp+4h]
  __int64 v21; // [rsp+268h] [rbp+8h]
  std::pmr::_Identity_equal_resource *v22; // [rsp+270h] [rbp+10h]
  int v24; // [rsp+27Ch] [rbp+1Ch]
  int v25; // [rsp+280h] [rbp+20h]
  int v26; // [rsp+284h] [rbp+24h]
  __int64 v27; // [rsp+288h] [rbp+28h] BYREF
  __int64 *v28; // [rsp+290h] [rbp+30h]
  __int64 v29; // [rsp+298h] [rbp+38h]
  __int64 v30; // [rsp+2A0h] [rbp+40h] BYREF
  _DWORD v31[2]; // [rsp+2A8h] [rbp+48h] BYREF
  char v32; // [rsp+2B0h] [rbp+50h] BYREF
  _DWORD v33[2]; // [rsp+2B8h] [rbp+58h] BYREF
  char v34; // [rsp+2C0h] [rbp+60h] BYREF
  _DWORD v35[2]; // [rsp+2C8h] [rbp+68h] BYREF
  char v36; // [rsp+2D0h] [rbp+70h] BYREF
  _DWORD v37[2]; // [rsp+2D8h] [rbp+78h] BYREF
  char v38; // [rsp+2E0h] [rbp+80h] BYREF
  _DWORD v39[2]; // [rsp+2E8h] [rbp+88h] BYREF
  char v40; // [rsp+2F0h] [rbp+90h] BYREF
  _DWORD v41[2]; // [rsp+2F8h] [rbp+98h] BYREF
  char v42; // [rsp+300h] [rbp+A0h] BYREF
  __int64 *v43; // [rsp+308h] [rbp+A8h]
  _BYTE *v44; // [rsp+310h] [rbp+B0h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+318h] [rbp+B8h]
  __int64 *v46; // [rsp+320h] [rbp+C0h]
  _BYTE *v47; // [rsp+328h] [rbp+C8h]
  __int64 v48; // [rsp+330h] [rbp+D0h]
  __int64 v49; // [rsp+338h] [rbp+D8h]
  __int64 v50; // [rsp+340h] [rbp+E0h]
  __int64 v51; // [rsp+348h] [rbp+E8h] BYREF
  _QWORD *v52; // [rsp+350h] [rbp+F0h]
  _BYTE *v53; // [rsp+358h] [rbp+F8h]
  vraudio::AudioBuffer *__Val_0___2; // [rsp+360h] [rbp+100h]
  __int64 v55; // [rsp+368h] [rbp+108h]
  __int64 v56; // [rsp+370h] [rbp+110h]
  __int64 v57; // [rsp+378h] [rbp+118h]
  __int64 v58; // [rsp+380h] [rbp+120h]
  __int64 *v59; // [rsp+388h] [rbp+128h]
  __int64 v60; // [rsp+390h] [rbp+130h]
  __int64 __Val_0___1; // [rsp+398h] [rbp+138h]
  __int64 *v62; // [rsp+3A0h] [rbp+140h]
  __int64 v63; // [rsp+3A8h] [rbp+148h]
  __int64 v64; // [rsp+3B0h] [rbp+150h]
  _QWORD *v65; // [rsp+3B8h] [rbp+158h]
  _QWORD *v66; // [rsp+3C0h] [rbp+160h]
  __int64 *ThreadLogContextSlot; // [rsp+3C8h] [rbp+168h]
  __int64 v68; // [rsp+3D0h] [rbp+170h]
  __int64 (__fastcall *v69)(__int64, _BYTE *); // [rsp+3D8h] [rbp+178h]
  void (__fastcall *v70)(__int64, char *, __int64); // [rsp+3E0h] [rbp+180h]
  __int64 *v71; // [rsp+3E8h] [rbp+188h]
  __int64 v72; // [rsp+3F0h] [rbp+190h]
  __int64 v73; // [rsp+3F8h] [rbp+198h]
  __int64 v74; // [rsp+400h] [rbp+1A0h]
  __int64 v75; // [rsp+408h] [rbp+1A8h]
  __int64 v76; // [rsp+410h] [rbp+1B0h]
  __int64 *v77; // [rsp+418h] [rbp+1B8h]
  __int64 v78; // [rsp+420h] [rbp+1C0h]
  __int64 v79; // [rsp+428h] [rbp+1C8h]
  __int64 v80; // [rsp+430h] [rbp+1D0h]
  _QWORD v81[2]; // [rsp+438h] [rbp+1D8h] BYREF
  __int64 *v82; // [rsp+448h] [rbp+1E8h]
  __int64 v83; // [rsp+450h] [rbp+1F0h]
  _QWORD *v84; // [rsp+458h] [rbp+1F8h]
  __int64 *ThreadLogContextSlot_2; // [rsp+460h] [rbp+200h]
  __int64 v86; // [rsp+468h] [rbp+208h]
  Parameter *Parameter; // [rsp+470h] [rbp+210h]
  __int64 v88; // [rsp+478h] [rbp+218h]
  double (__fastcall *v89)(_QWORD); // [rsp+480h] [rbp+220h]
  double (__fastcall *v90)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+488h] [rbp+228h]
  __int64 *PlayerIdFromContext; // [rsp+490h] [rbp+230h]
  __int64 v92; // [rsp+498h] [rbp+238h]
  _QWORD *v93; // [rsp+4A0h] [rbp+240h]
  __int64 *ThreadLogContextSlot_1; // [rsp+4A8h] [rbp+248h]
  double (__fastcall *v95)(_QWORD); // [rsp+4B0h] [rbp+250h]
  _QWORD v96[2]; // [rsp+4B8h] [rbp+258h] BYREF
  _QWORD src__5[2]; // [rsp+4C8h] [rbp+268h] BYREF
  _QWORD src_[2]; // [rsp+4D8h] [rbp+278h] BYREF
  _QWORD src__1[2]; // [rsp+4E8h] [rbp+288h] BYREF
  _QWORD v100[2]; // [rsp+4F8h] [rbp+298h] BYREF
  _QWORD src__2[2]; // [rsp+508h] [rbp+2A8h] BYREF
  _QWORD v102[2]; // [rsp+518h] [rbp+2B8h] BYREF
  _QWORD src__3[2]; // [rsp+528h] [rbp+2C8h] BYREF
  _QWORD v104[2]; // [rsp+538h] [rbp+2D8h] BYREF
  _QWORD src__4[2]; // [rsp+548h] [rbp+2E8h] BYREF
  _QWORD v106[2]; // [rsp+558h] [rbp+2F8h] BYREF
  char v107; // [rsp+568h] [rbp+308h]
  _QWORD v108[2]; // [rsp+570h] [rbp+310h] BYREF
  char v109; // [rsp+580h] [rbp+320h]
  _QWORD v110[2]; // [rsp+588h] [rbp+328h] BYREF
  char v111; // [rsp+598h] [rbp+338h]
  _QWORD v112[4]; // [rsp+5A0h] [rbp+340h] BYREF
  __int64 v113; // [rsp+5C0h] [rbp+360h] BYREF
  char v114; // [rsp+5CCh] [rbp+36Ch]
  unsigned __int64 v115; // [rsp+5D0h] [rbp+370h]
  unsigned __int64 v116; // [rsp+5D8h] [rbp+378h]
  __int64 n2; // [rsp+610h] [rbp+3B0h]
  _QWORD v118[2]; // [rsp+618h] [rbp+3B8h] BYREF
  __int64 v119; // [rsp+628h] [rbp+3C8h] BYREF
  char v120[8]; // [rsp+630h] [rbp+3D0h] BYREF
  char v121[8]; // [rsp+638h] [rbp+3D8h] BYREF
  _BYTE dst__1[16]; // [rsp+640h] [rbp+3E0h] BYREF
  __int64 dst__2[2]; // [rsp+650h] [rbp+3F0h] BYREF
  _BYTE dst__3[16]; // [rsp+660h] [rbp+400h] BYREF
  __int64 dst__4[2]; // [rsp+670h] [rbp+410h] BYREF
  __int64 v126; // [rsp+680h] [rbp+420h] BYREF
  _BYTE dst__6[16]; // [rsp+690h] [rbp+430h] BYREF
  _BYTE dst__7[16]; // [rsp+6A0h] [rbp+440h] BYREF
  __int64 dst__8[2]; // [rsp+6B0h] [rbp+450h] BYREF
  __int64 v130; // [rsp+6C0h] [rbp+460h] BYREF
  _QWORD v131[2]; // [rsp+6C8h] [rbp+468h] BYREF
  __int64 v132; // [rsp+6D8h] [rbp+478h] BYREF
  __int64 Parameter_[3]; // [rsp+6E0h] [rbp+480h] BYREF
  _QWORD v134[3]; // [rsp+6F8h] [rbp+498h] BYREF
  _BYTE dst__5[16]; // [rsp+710h] [rbp+4B0h] BYREF
  _QWORD buf_[6]; // [rsp+720h] [rbp+4C0h] BYREF
  char v137[32]; // [rsp+750h] [rbp+4F0h] BYREF
  _BYTE dst_[48]; // [rsp+770h] [rbp+510h] BYREF
  __int64 v139; // [rsp+7A0h] [rbp+540h] BYREF
  bool v140; // [rsp+7A8h] [rbp+548h]
  __int64 v141; // [rsp+7B0h] [rbp+550h]
  _BYTE Parameter__1[24]; // [rsp+7B8h] [rbp+558h] BYREF

  memset(buf_, 0, sizeof(buf_));
  qmemcpy(dst_, sub_1402B15B0(buf_), sizeof(dst_));
  sub_1402B15B0(&v113);
  v115 = __rdtsc();
  HIDWORD(v113) = 0;
  v114 = 0;
  LOWORD(v113) = 0x2900;
  v90 = qword_149B4B870;
  qword_149B4B870(
    &v113,
    &word_149E5AD3C,
    "CEntityComponentShipListProvider::FetchShipExtraData",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\EntityComponentShipListProvider.cpp",
    0x6F);
  WORD1(v113) = word_149E5AD3C;
  v43 = a3;
  if ( *a3 == a3[1] )
  {
    v31[0] = add_0xC7(0x16u);
    v31[1] = 8;
    src_[0] = v31;
    src_[1] = &v32;
    qmemcpy(dst__1, src_, sizeof(dst__1));
    v24 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)dst__1,
            (__int64)"CEntityComponentShipListProvider::FetchShipExtraData",
            "ShipData list was empty for player $$");
    if ( (v24 & 0xFFFFF) != 0 )
    {
      PlayerIdFromContext = GetPlayerIdFromContext(qword_149E7E438, &v132);
      v92 = identity_int64(*PlayerIdFromContext);
      v106[0] = 0;
      v106[1] = v92;
      v107 = 0;
      v93 = v106;
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      v100[0] = 0;
      v100[1] = 0;
      v33[0] = add_0xC7(0x16u);
      v33[1] = 8;
      src__1[0] = v33;
      src__1[1] = &v34;
      qmemcpy(dst__2, src__1, sizeof(dst__2));
      n2 = 2;
      v3 = alloca(0xE0);
      v44 = v15;
      __Val_0__ = (vraudio::AudioBuffer *)v15;
      InitTraceContextPlayerIdIntDescriptor((__int64)v15, (__int64)ThreadLogContextSlot_1, v93);
      LODWORD(v14) = v24;
      ReportTelemetryEvent(
        5u,
        dst__2,
        "CEntityComponentShipListProvider::FetchShipExtraData",
        "ShipData list was empty for player $$",
        __Val_0__,
        2u,
        1,
        v14,
        v100,
        0);
    }
    ZeroInitializeAndNotifyEngine((Parameter *)Parameter_);
    ProcessFetchedShipData(a1, Parameter_);
    DeallocateShipDataList((Parameter *)Parameter_);
    v18 = 0;
    v116 = __rdtsc();
    v95 = qword_149B4B878;
    qword_149B4B878(&v113);
  }
  else
  {
    v35[0] = add_0xC7(0x16u);
    v35[1] = 8;
    src__2[0] = v35;
    src__2[1] = &v36;
    qmemcpy(dst__3, src__2, sizeof(dst__3));
    v25 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)dst__3,
            (__int64)"CEntityComponentShipListProvider::FetchShipExtraData",
            "Fetchin Ship Extra Data of $$ vehicles for player $$");
    if ( (v25 & 0xFFFFF) != 0 )
    {
      v62 = GetPlayerIdFromContext(qword_149E7E438, v118);
      v63 = identity_int64(*v62);
      v108[0] = 0;
      v108[1] = v63;
      v109 = 0;
      v65 = v108;
      v46 = a3;
      v64 = (a3[1] - *a3) / 0x88;
      v102[0] = 0;
      v102[1] = v64;
      v66 = v102;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v104[0] = 0;
      v104[1] = 0;
      v37[0] = add_0xC7(0x16u);
      v37[1] = 8;
      src__3[0] = v37;
      src__3[1] = &v38;
      qmemcpy(dst__4, src__3, sizeof(dst__4));
      v118[1] = 3;
      v4 = alloca(0x150);
      v47 = v13;
      __Val_0___1 = (__int64)v13;
      sub_1453E8920((__int64)v13, ThreadLogContextSlot, v66, v65);
      LODWORD(v12) = v25;
      ReportTelemetryEvent(
        5u,
        dst__4,
        "CEntityComponentShipListProvider::FetchShipExtraData",
        "Fetchin Ship Extra Data of $$ vehicles for player $$",
        (vraudio::AudioBuffer *)__Val_0___1,
        3u,
        1,
        v12,
        v104,
        0);
    }
    unknown_libname_472(v112);
    v56 = sub_1464E7930(qword_149E7E438);
    v16 = v56 && (unsigned __int8)sub_1464853D0(v56);
    v17 = v16;
    v57 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0x98);
    v58 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v57 + 0xA0LL))(v57);
    v55 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x140LL))(v58);
    v19 = 0;
    v59 = a3;
    v29 = *a3;
    v68 = a3[1];
    while ( v29 != v68 )
    {
      v21 = v29;
      v60 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0xA0);
      v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v60 + 0xC0LL))(v60);
      v69 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v48 + 0x18LL);
      qmemcpy(dst__5, (const void *)(v21 + 8), sizeof(dst__5));
      qmemcpy(dst__6, dst__5, sizeof(dst__6));
      v49 = v69(v48, dst__6);
      if ( v49 )
      {
        v50 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0x1E0);
        v70 = *(void (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v50 + 0x68LL);
        v70(v50, v137, v49);
        _XMM0 = sub_1403B6AB0();
        __asm { vcvttsd2si rax, xmm0 }
        *(_DWORD *)(v21 + 0x68) = _RAX;
      }
      v27 = *(_QWORD *)v21;
      if ( sub_14037F610(v27, 0) )
      {
        sub_140344450((__int64)v112, &v27);
        v22 = 0;
        v71 = sub_14277DDD0(&v119);
        v72 = *v71;
        v30 = v72;
        if ( is_valid_handle_typeA(&v30) )
        {
          v74 = v30 & 0xFFFFFFFFFFFFLL;
          v73 = v27;
          v22 = *(std::pmr::_Identity_equal_resource **)sub_144D27970(v30 & 0xFFFFFFFFFFFFLL, v120, v27);
          v7 = sub_14037F610((__int64)v22, 0);
          *(_BYTE *)(v21 + 0x81) = v7;
          v76 = v30 & 0xFFFFFFFFFFFFLL;
          v75 = v27;
          v8 = sub_144D52300(v30 & 0xFFFFFFFFFFFFLL, v27);
          *(_BYTE *)(v21 + 0x83) = v8;
        }
        if ( std::pmr::_Identity_equal_resource::do_is_equal(v22, 0) )
          v22 = *(std::pmr::_Identity_equal_resource **)sub_14458F1C0(v121, v27);
        *(_QWORD *)(v21 + 0x50) = v22;
        v77 = sub_14033A1A0(&v126);
        v78 = *v77;
        v79 = v78;
        v51 = v78;
        if ( is_valid_handle_typeA(&v51) )
        {
          v80 = v51 & 0xFFFFFFFFFFFFLL;
          v52 = sub_1403B4B00(v51 & 0xFFFFFFFFFFFFLL, &v130);
        }
        else
        {
          v81[0] = 0;
          v52 = v81;
        }
        v81[1] = v52;
        *(_QWORD *)(v21 + 0x60) = *v52;
      }
      v29 += 0x88;
    }
    v39[0] = add_0xC7(0x16u);
    v39[1] = 8;
    src__4[0] = v39;
    src__4[1] = &v40;
    qmemcpy(dst__7, src__4, sizeof(dst__7));
    v26 = invokeGlobalCallbackAndMaskStatusBits(
            5,
            (__int64)dst__7,
            (__int64)"CEntityComponentShipListProvider::FetchShipExtraData",
            "Querying the variable service for destroyed state of the vehicles of player $$");
    if ( (v26 & 0xFFFFF) != 0 )
    {
      v82 = GetPlayerIdFromContext(qword_149E7E438, v131);
      v83 = identity_int64(*v82);
      v110[0] = 0;
      v110[1] = v83;
      v111 = 0;
      v84 = v110;
      ThreadLogContextSlot_2 = getThreadLogContextSlot();
      v96[0] = 0;
      v96[1] = 0;
      v41[0] = add_0xC7(0x16u);
      v41[1] = 8;
      src__5[0] = v41;
      src__5[1] = &v42;
      qmemcpy(dst__8, src__5, sizeof(dst__8));
      v131[1] = 2;
      v9 = alloca(0xE0);
      v53 = v11;
      __Val_0___2 = (vraudio::AudioBuffer *)v11;
      InitTraceContextPlayerIdIntDescriptor((__int64)v11, (__int64)ThreadLogContextSlot_2, v84);
      LODWORD(v10) = v26;
      ReportTelemetryEvent(
        5u,
        dst__8,
        "CEntityComponentShipListProvider::FetchShipExtraData",
        "Querying the variable service for destroyed state of the vehicles of player $$",
        __Val_0___2,
        2u,
        1,
        v10,
        v96,
        0);
    }
    v88 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x60LL))(v55);
    v28 = &v139;
    v86 = *(_QWORD *)(a1 + 8);
    v139 = a1;
    v140 = v17;
    v141 = v86;
    Parameter = Parameter__1;
    sub_14282BD80((Parameter *)Parameter__1, a3);
    sub_1453D20E0(v134, v28);
    sub_141262DE0(v88, v112, v134);
    sub_1402A2AD0(v134);
    std::vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____::_vector__anonymous_namespace_::sample_vertex___std::allocator__anonymous_namespace_::sample_vertex_____((__int64)v112);
    v20 = 0;
    v116 = __rdtsc();
    v89 = qword_149B4B878;
    qword_149B4B878(&v113);
  }
}

// --- End Function: sub_145414A40 (0x145414A40) ---

// --- Function: sub_1454185F0 (0x1454185F0) ---
void **__fastcall sub_1454185F0(void **a1, const void *src, unsigned int a3)
{
  const void **v4; // rax
  __int64 v5; // [rsp+20h] [rbp-58h]
  __int64 v6; // [rsp+28h] [rbp-50h]
  __int64 v7; // [rsp+30h] [rbp-48h]
  __int64 (__fastcall *v8)(__int64, _BYTE *); // [rsp+38h] [rbp-40h]
  _BYTE dst_[16]; // [rsp+40h] [rbp-38h] BYREF
  _BYTE dst__1[40]; // [rsp+50h] [rbp-28h] BYREF

  v5 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0xA0);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0xC0LL))(v5);
  v8 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v6 + 0x18LL);
  qmemcpy(dst_, src, sizeof(dst_));
  qmemcpy(dst__1, dst_, 0x10u);
  v7 = v8(v6, dst__1);
  if ( v7 )
  {
    sub_142C7E820(a1, v7, a3);
  }
  else
  {
    v4 = (const void **)sub_1403B1280();
    sub_14035B410(a1, v4);
  }
  return a1;
}

// --- End Function: sub_1454185F0 (0x1454185F0) ---

// --- Function: sub_145418950 (0x145418950) ---
__int64 __fastcall sub_145418950(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-A8h]
  __int64 v5; // [rsp+30h] [rbp-98h]
  _BYTE v6[72]; // [rsp+50h] [rbp-78h] BYREF
  _QWORD v7[6]; // [rsp+98h] [rbp-30h] BYREF

  v4 = *a2;
  v5 = a2[1];
  while ( 1 )
  {
    result = v5;
    if ( v4 == v5 )
      break;
    sub_1453F5CB0(v6, v4);
    sub_1453DC880(a3, v6);
    sub_140370D10(v7);
    v4 += 0x88;
  }
  return result;
}

// --- End Function: sub_145418950 (0x145418950) ---

// --- Function: ProcessFetchedShipData (0x14542ABD0) ---
// Processes a list of fetched ship data. This function logs its entry, then
// iterates through the provided data, copying and adding each item to an internal
// collection. It then sorts or further processes this collection. For each
// processed item, it retrieves a handle, performs data swaps, and updates
// associated fields. Finally, it manages the lifecycle of a future/promise object
// and updates internal state or logging contexts.
__int64 __fastcall ProcessFetchedShipData(__int64 shipDataProviderContext, __int64 *fetchedShipDataList)
{
  void **v2; // rax
  char buf; // [rsp+20h] [rbp-148h] BYREF
  _BYTE tempBuf1[7]; // [rsp+21h] [rbp-147h] BYREF
  __int64 v6; // [rsp+28h] [rbp-140h]
  __int64 v7; // [rsp+30h] [rbp-138h]
  __int64 v8; // [rsp+38h] [rbp-130h]
  __int64 *fetchedShipDataList_1; // [rsp+40h] [rbp-128h]
  __int64 v10; // [rsp+48h] [rbp-120h]
  __int64 v11; // [rsp+50h] [rbp-118h]
  __int64 v12; // [rsp+58h] [rbp-110h]
  __int64 v13; // [rsp+60h] [rbp-108h]
  __int64 v14; // [rsp+68h] [rbp-100h]
  __int64 v15; // [rsp+70h] [rbp-F8h]
  __int64 v16; // [rsp+78h] [rbp-F0h]
  __int64 v17; // [rsp+80h] [rbp-E8h]
  void *handleObject; // [rsp+88h] [rbp-E0h] BYREF
  __int64 (__fastcall *updateFunction)(__int64, __int64); // [rsp+90h] [rbp-D8h]
  __int64 futureObject[5]; // [rsp+98h] [rbp-D0h] BYREF
  _BYTE p_tempShipDataBuffer[64]; // [rsp+C0h] [rbp-A8h] BYREF
  _QWORD v22[3]; // [rsp+100h] [rbp-68h] BYREF
  _QWORD v23[7]; // [rsp+118h] [rbp-50h] BYREF

  sub_1402AE3D0(futureObject, "CEntityComponentShipListProvider::OnFetchedShipData", shipDataProviderContext + 0x70, 1);
  sub_145462260((Parameter *)(shipDataProviderContext + 0x88));
  fetchedShipDataList_1 = fetchedShipDataList;
  v6 = *fetchedShipDataList;
  v14 = fetchedShipDataList[1];
  while ( v6 != v14 )
  {
    v15 = v6;
    sub_1453F6D90(p_tempShipDataBuffer, v6);
    v16 = shipDataProviderContext + 0x88;
    futureObject[3] = sub_1453DC930(shipDataProviderContext + 0x88, (__int64)p_tempShipDataBuffer);
    sub_1402ABD50(v23);
    sub_140370D10(v22);
    v6 += 0x70;
  }
  sub_145445B60(shipDataProviderContext, (ULONG_PTR *)(shipDataProviderContext + 0x88));
  v10 = shipDataProviderContext + 0x88;
  v7 = *(_QWORD *)(shipDataProviderContext + 0x88);
  v17 = *(_QWORD *)(shipDataProviderContext + 0x90);
  while ( v7 != v17 )
  {
    v8 = v7;
    v2 = sub_14458F090(&handleObject);
    sub_140377FE0((void **)(v7 + 0x58), v2);
    sub_1402ABD50(&handleObject);
    v11 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0x98);
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0xA0LL))(v11);
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x140LL))(v12);
    updateFunction = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 0x140LL);
    *(_DWORD *)(v7 + 0x68) = updateFunction(v13, v7 + 8);
    v7 += 0x88;
  }
  sub_1402B1820(futureObject);
  futureObject[1] = shipDataProviderContext + 0xF8;
  memset(&buf, 0, sizeof(buf));
  sub_1453D5A00(shipDataProviderContext + 0xF8, &buf);
  memset(tempBuf1, 0, 1u);
  return sub_1453D5960(shipDataProviderContext + 0xF8, tempBuf1);
}

// --- End Function: ProcessFetchedShipData (0x14542ABD0) ---

// --- Function: sub_145445B60 (0x145445B60) ---
__int64 __fastcall sub_145445B60(__int64 shipDataProviderContext, ULONG_PTR *a2)
{
  __int64 result; // rax
  unsigned __int8 v3; // [rsp+31h] [rbp-97h]
  ULONG_PTR Parameter[2]; // [rsp+48h] [rbp-80h] BYREF
  ULONG_PTR Parameter_[3]; // [rsp+58h] [rbp-70h] BYREF
  ULONG_PTR v6; // [rsp+70h] [rbp-58h]
  ULONG_PTR *v7; // [rsp+78h] [rbp-50h]
  ULONG_PTR v8; // [rsp+80h] [rbp-48h]
  ULONG_PTR v9; // [rsp+88h] [rbp-40h]
  ULONG_PTR *v10; // [rsp+90h] [rbp-38h]
  ULONG_PTR v11; // [rsp+98h] [rbp-30h]
  unsigned __int64 v12; // [rsp+A0h] [rbp-28h]
  ULONG_PTR v13; // [rsp+A8h] [rbp-20h]
  ULONG_PTR v14; // [rsp+B0h] [rbp-18h]
  unsigned __int64 v15; // [rsp+B8h] [rbp-10h]

  result = *a2 == a2[1];
  if ( *a2 != a2[1] )
  {
    v7 = a2;
    v6 = a2[1];
    Parameter[0] = v6;
    _StarEngineModule__((ULONG_PTR)Parameter);
    v8 = Parameter[0];
    v12 = Parameter[0];
    Parameter[1] = (ULONG_PTR)a2;
    v10 = a2;
    v9 = *a2;
    Parameter_[0] = v9;
    _StarEngineModule__((ULONG_PTR)Parameter_);
    v11 = Parameter_[0];
    v13 = Parameter_[0];
    v15 = v12;
    v14 = Parameter_[0];
    Parameter_[2] = Parameter_[0];
    Parameter_[1] = v12;
    return sub_1453E6300(Parameter_[0], v12, (__int64)(v12 - Parameter_[0]) / 0x88, v3);
  }
  return result;
}

// --- End Function: sub_145445B60 (0x145445B60) ---

// --- Function: sub_14545E6F0 (0x14545E6F0) ---
_QWORD *__fastcall sub_14545E6F0(Parameter *Parameter, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD *result; // rax
  __int64 i; // [rsp+30h] [rbp-48h]
  __int64 *v7; // [rsp+38h] [rbp-40h]
  _QWORD *v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]

  v7 = Parameter + 1;
  v8 = Parameter + 2;
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( *Parameter )
  {
    v9 = *v7;
    for ( i = *Parameter; i != v9; i += 0x88 )
      sub_14469AA20(i);
    std::_Deallocate<16,0>((_QWORD *)*Parameter, 0x88 * ((*v8 - *Parameter) / 0x88));
  }
  *Parameter = (__int64)a2;
  *v7 = (__int64)&a2[0x11 * a3];
  result = &a2[0x11 * a4];
  *v8 = result;
  return result;
}

// --- End Function: sub_14545E6F0 (0x14545E6F0) ---

// --- Function: DeallocateShipDataList (0x14545F7E0) ---
// Deallocates memory associated with a list or vector of ship data objects. It
// iterates through each element in the collection, invoking a specific
// deallocation routine for a nested pointer within each element (at offset +0x48).
// After cleaning up individual elements, it frees the main buffer backing the
// collection and nullifies the collection's pointers.
Parameter *__fastcall DeallocateShipDataList(Parameter *shipDataVector)
{
  Parameter *shipDataVector_1; // rax
  __int64 currentElementPtr; // [rsp+20h] [rbp-58h]
  __int64 *endPtr; // [rsp+38h] [rbp-40h]
  Parameter *shipDataVector_2; // [rsp+40h] [rbp-38h]
  __int64 currentElementPtr_1; // [rsp+48h] [rbp-30h]

  endPtr = (__int64 *)((char *)shipDataVector + 8);
  shipDataVector_2 = (Parameter *)((char *)shipDataVector + 0x10);
  _StarEngineModule__((ULONG_PTR)shipDataVector);
  shipDataVector_1 = shipDataVector;
  if ( *(_QWORD *)shipDataVector )
  {
    currentElementPtr_1 = *endPtr;
    for ( currentElementPtr = *(_QWORD *)shipDataVector; currentElementPtr != currentElementPtr_1; currentElementPtr += 0x70 )
      sub_140370D10((_QWORD *)(currentElementPtr + 0x48));
    std::_Deallocate<16,0>(
      *(_QWORD **)shipDataVector,
      0x70 * ((*(_QWORD *)shipDataVector_2 - *(_QWORD *)shipDataVector) / 0x70LL));
    *(_QWORD *)shipDataVector = 0;
    *endPtr = 0;
    shipDataVector_1 = shipDataVector_2;
    *(_QWORD *)shipDataVector_2 = 0;
  }
  return shipDataVector_1;
}

// --- End Function: DeallocateShipDataList (0x14545F7E0) ---

// --- Function: sub_14545FA30 (0x14545FA30) ---
Parameter *__fastcall sub_14545FA30(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  __int64 i; // [rsp+30h] [rbp-48h]
  __int64 *v4; // [rsp+38h] [rbp-40h]
  Parameter *Parameter_2; // [rsp+40h] [rbp-38h]
  __int64 v6; // [rsp+48h] [rbp-30h]

  v4 = Parameter + 1;
  Parameter_2 = Parameter + 2;
  _StarEngineModule__((ULONG_PTR)Parameter);
  Parameter_1 = Parameter;
  if ( *Parameter )
  {
    v6 = *v4;
    for ( i = *Parameter; i != v6; i += 0x88 )
      sub_14469AA20(i);
    std::_Deallocate<16,0>((_QWORD *)*Parameter, 0x88 * ((*Parameter_2 - *Parameter) / 0x88));
    *Parameter = 0;
    *v4 = 0;
    Parameter_1 = Parameter_2;
    *Parameter_2 = 0;
  }
  return Parameter_1;
}

// --- End Function: sub_14545FA30 (0x14545FA30) ---

// --- Function: sub_145462260 (0x145462260) ---
Parameter *__fastcall sub_145462260(Parameter *Parameter)
{
  Parameter *Parameter_1; // rax
  __int64 i; // [rsp+20h] [rbp-48h]
  Parameter *Parameter_2; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+48h] [rbp-20h]

  Parameter_2 = Parameter + 1;
  Parameter_1 = Parameter;
  if ( *Parameter != Parameter[1] )
  {
    _StarEngineModule__((ULONG_PTR)Parameter);
    v5 = *Parameter_2;
    for ( i = *Parameter; i != v5; i += 0x88 )
      sub_14469AA20(i);
    Parameter_1 = Parameter_2;
    *Parameter_2 = *Parameter;
  }
  return Parameter_1;
}

// --- End Function: sub_145462260 (0x145462260) ---

// --- Function: sub_1454626D0 (0x1454626D0) ---
__int64 *__fastcall sub_1454626D0(__int64 a1, Parameter *Parameter_1, __int64 a3, __int64 a4)
{
  __int64 i; // [rsp+20h] [rbp-68h]
  __int64 v6; // [rsp+28h] [rbp-60h]
  __int64 j; // [rsp+30h] [rbp-58h]
  __int64 *v8; // [rsp+38h] [rbp-50h]
  __int64 v10; // [rsp+60h] [rbp-28h]
  __int64 v11; // [rsp+68h] [rbp-20h]

  v8 = (__int64 *)(a1 + 8);
  if ( a3 != a4 )
  {
    v6 = a3;
    v10 = *v8;
    for ( i = a4; i != v10; i += 0x88 )
    {
      sub_1453FBB90(v6, i);
      v6 += 0x88;
    }
    v11 = *v8;
    for ( j = v6; j != v11; j += 0x88 )
      sub_14469AA20(j);
    *v8 = v6;
  }
  *Parameter_1 = a3;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: sub_1454626D0 (0x1454626D0) ---

// --- Function: sub_146481E10 (0x146481E10) ---
__int64 __fastcall sub_146481E10(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 RawPointerIfValid_w; // rax

  v2 = *(_QWORD *)(a1 + 0x200);
  if ( !v2 || !Handle_GetRawPointerIfValid_w(v2) )
    return 4;
  v3 = *(_QWORD *)(a1 + 0x200);
  if ( !v3 )
    return (*(__int64 (**)(void))(MEMORY[0] + 0x7D8LL))();
  RawPointerIfValid_w = Handle_GetRawPointerIfValid_w(v3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)RawPointerIfValid_w + 0x7D8LL))(RawPointerIfValid_w);
}

// --- End Function: sub_146481E10 (0x146481E10) ---

// --- Function: GetPlayerIdFromContext (0x1464E7490) ---
// Retrieves a QWORD value from a fixed offset (0xC10) within the provided base
// structure. The retrieved value is stored at the location pointed to by 'a2'.
// This function likely extracts a specific identifier or pointer from a larger
// context object.
_QWORD *__fastcall GetPlayerIdFromContext(__int64 contextBase, _QWORD *outputPtr)
{
  *outputPtr = *(_QWORD *)(contextBase + 0xC10);
  return outputPtr;
}

// --- End Function: GetPlayerIdFromContext (0x1464E7490) ---

// --- Function: sub_1464E7930 (0x1464E7930) ---
__int64 __fastcall sub_1464E7930(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x180LL))(*(_QWORD *)(a1 + 0xE8));
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x28LL))(v1);
}

// --- End Function: sub_1464E7930 (0x1464E7930) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_1475B3F30 (0x1475B3F30) ---
int __fastcall sub_1475B3F30(char *Buffer, size_t BufferCount, unsigned __int64 n0x40000000)
{
  const char *p_%u.%u_MB; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-A8h]
  int v11; // [rsp+28h] [rbp-A0h]
  __m256 DstBuf_; // [rsp+40h] [rbp-88h] BYREF
  __m256 DstBuf__1; // [rsp+60h] [rbp-68h] BYREF
  __m256 v14; // [rsp+80h] [rbp-48h]

  DstBuf_ = (__m256)0LL;
  if ( n0x40000000 >= 0x10000000000LL )
  {
    p_%u.%u_MB = "%u.%u TB";
    v7 = (0xA * (n0x40000000 & 0xFFFFFFFFFFLL)) >> 0x28;
    v8 = n0x40000000 >> 0x28;
LABEL_7:
    v11 = v7;
    v10 = v8;
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, p_%u.%u_MB, v10, v11);
    goto LABEL_11;
  }
  if ( n0x40000000 >= 0x40000000 )
  {
    p_%u.%u_MB = "%u.%u GB";
    v7 = (0xA * (n0x40000000 & 0x3FFFFFFF)) >> 0x1E;
    v8 = n0x40000000 >> 0x1E;
    goto LABEL_7;
  }
  if ( n0x40000000 >= 0x100000 )
  {
    p_%u.%u_MB = "%u.%u MB";
    v7 = (0xA * (n0x40000000 & 0xFFFFF)) >> 0x14;
    v8 = n0x40000000 >> 0x14;
    goto LABEL_7;
  }
  if ( n0x40000000 < 0x400 )
  {
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, "%u byte(s)", n0x40000000);
  }
  else
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf_,
      0x20u,
      0xFFFFFFFFFFFFFFFFuLL,
      "%u.%u KB",
      n0x40000000 >> 0xA,
      (0xA * (n0x40000000 & 0x3FF)) >> 0xA);
  }
LABEL_11:
  DstBuf__1 = (__m256)0LL;
  v14 = (__m256)0LL;
  if ( byte_1516B60CF )
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf__1,
      0x40u,
      0xFFFFFFFFFFFFFFFFuLL,
      " (Started with < %u GB of available system memory.)",
      8);
  }
  __asm { vzeroupper }
  return snprintf_s(
           Buffer,
           BufferCount,
           0xFFFFFFFFFFFFFFFFuLL,
           "Out of system memory. Failed to allocate %s (%zu).%s",
           (const char *)&DstBuf_,
           n0x40000000,
           (const char *)&DstBuf__1);
}

// --- End Function: sub_1475B3F30 (0x1475B3F30) ---

// --- Function: sub_1475DF210 (0x1475DF210) ---
void __fastcall sub_1475DF210(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1475B3F30(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1475DF210 (0x1475DF210) ---

// --- Function: sub_147602270 (0x147602270) ---
void __fastcall sub_147602270(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rcx
  _QWORD *v9; // rdi
  __int64 v10; // rcx
  unsigned __int64 v11; // r14
  __int64 v12; // rsi
  __int64 v13; // rcx
  _BYTE v14[32]; // [rsp+30h] [rbp-48h] BYREF

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x11C0));
  v6 = *(_QWORD *)(a1 + 0x1190);
  if ( (unsigned __int64)(0x4000000000LL - *(_QWORD *)(v6 + 8)) < 0x2000000 )
  {
    v7 = *(unsigned int *)(a1 + 0x11AC);
    *(__m256i *)(a1 + 0x1198) = *(__m256i *)sub_14056DBC0(
                                              (__int64)v14,
                                              0x8000000000LL,
                                              *(_DWORD *)(a1 + 0x11AC),
                                              off_148D699A0,
                                              1,
                                              0);// "StarAlloc-Small"
    v6 = (*(_QWORD *)(a1 + 0x1198) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
    __asm { vzeroupper }
    sub_14056DA40(a1 + 0x1198, v6, (v7 + 0x17) & ~(v7 - 1));
    *(_WORD *)(v6 + 0x15) = 0;
    *(_BYTE *)(v6 + 0x17) = 0;
    *(_QWORD *)v6 = 0;
    *(_BYTE *)(v6 + 0x14) = 0;
    *(_QWORD *)(v6 + 8) = ((v6 + 0x2000017) & 0xFFFFFFFFFE000000uLL) - v6;
    *(_DWORD *)(v6 + 0x10) = 0x1337;
    *(_QWORD *)v6 = *(_QWORD *)(a1 + 0x1190);
    *(_BYTE *)(v6 + 0x14) = 1;
    *(_QWORD *)(a1 + 0x1190) = v6;
  }
  v8 = *(_QWORD *)(v6 + 8);
  v9 = (_QWORD *)(v6 + v8 + *(unsigned int *)(a1 + 0x11AC));
  *(_QWORD *)(v6 + 8) = v8 + 0x2000000;
  v10 = *(unsigned int *)(a1 + 0x11AC);
  v11 = a2 + v10 + 0x2F - ((unsigned __int64)v9 + v10 + a2 + 0x2F) % a2;
  if ( *(_BYTE *)(a1 + 0x14F8) )
    v12 = 0x2000000 - v10;
  else
    v12 = ~(v10 - 1) & (v11 + v10 - 1);
  sub_14056DA40(a1 + 0x1198, (__int64)v9, v12);
  v9[5] = 0x1337;
  *v9 = 0;
  v13 = 0x20 * (a3 + 1);
  v9[1] = a3;
  v9[2] = a2;
  v9[4] = v11;
  v9[3] = v12;
  *v9 = *(_QWORD *)(v13 + a1);
  *(_QWORD *)(v13 + a1) = v9;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 0x11C0));
}

// --- End Function: sub_147602270 (0x147602270) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_147602A80 (0x147602A80) ---
void __fastcall sub_147602A80(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned __int32 v4; // eax
  __int64 v5; // r13
  int v6; // ebx
  unsigned int v7; // ebp
  unsigned __int32 v8; // r15d
  unsigned int v9; // ebx
  unsigned __int32 v10; // [rsp+20h] [rbp-88h]
  unsigned __int32 v11; // [rsp+20h] [rbp-88h]
  int n0x1600; // [rsp+30h] [rbp-78h] BYREF
  __int64 v13; // [rsp+34h] [rbp-74h]
  int n2; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v15; // [rsp+40h] [rbp-68h]
  unsigned __int64 v16; // [rsp+48h] [rbp-60h]
  __int64 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-50h]

  v3 = a1 + 0x12F0;
  v4 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0x12F0), 1u);
  v5 = a1 + 0x12F0 + 0x10 * (v4 & 0x1F);
  v6 = (v4 >> 5) & 0x7FFF;
  v7 = ((v4 - 0x20) >> 5) & 0x7FFF;
  v8 = *(_DWORD *)(v5 + 8);
  if ( (v8 & 0x7FFF) != v7 )
  {
    if ( qword_149B4FDB8 )
    {
      n0x1600 = 0x1600;
      v13 = 1;
      n2 = 2;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v15 = __rdtsc();
      qword_149B4B870(
        &n0x1600,
        &word_1517021C0,
        "Wait on Full Queue",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Containers/CigProducerConsumerQueue.h",
        0xB2);
      HIWORD(n0x1600) = word_1517021C0;
      LOBYTE(v11) = 0;
      sub_1407E63A0(v3, (volatile signed __int32 *)(v5 + 8), v8, v7, v11);
      v16 = __rdtsc();
      qword_149B4B878(&n0x1600);
    }
    else
    {
      LOBYTE(v10) = 0;
      sub_1407E63A0(a1 + 0x12F0, (volatile signed __int32 *)(v5 + 8), v8, v7, v10);
    }
  }
  *(_QWORD *)(v5 + 0x10) = a2;
  v9 = _InterlockedExchange((volatile __int32 *)(v5 + 0xC), v6);
  if ( (v9 & 0xFFFF8000) != 0 )
    sub_1407E6520(v3, v5 + 0xC, v9);
}

// --- End Function: sub_147602A80 (0x147602A80) ---

// --- Function: sub_147602DF0 (0x147602DF0) ---
__int64 __fastcall sub_147602DF0(__int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  __int64 v3; // r12
  __int64 *v4; // rdi
  unsigned __int64 v5; // r11
  unsigned __int128 v9; // rax
  unsigned __int64 v10; // rbx
  __int64 v11; // r9
  __int64 v14; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  _QWORD *v20; // r8
  __int64 v23; // rdx
  __int64 v24; // r9
  __int64 v26; // rbp
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // [rsp+40h] [rbp-68h] BYREF
  __int64 v29; // [rsp+48h] [rbp-60h] BYREF
  __int64 *v30; // [rsp+50h] [rbp-58h] BYREF
  __int64 *v31; // [rsp+58h] [rbp-50h] BYREF
  _BYTE v32[32]; // [rsp+60h] [rbp-48h] BYREF
  _QWORD *v33; // [rsp+B0h] [rbp+8h]

  v3 = *(_QWORD *)(a1 + 0x1270);
  v4 = (__int64 *)(a1 + 0x11F0);
  v5 = *(_QWORD *)(a1 + 0x1208);
  v9 = a2 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = 0;
  v11 = v5 & ((*((_QWORD *)&v9 + 1) + (_QWORD)v9) >> 7);
  _XMM2 = (BYTE8(v9) + (_BYTE)v9) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v14 = *v4;
    _XMM1 = *(_OWORD *)(*v4 + v11);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_6:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      v20 = v33;
      v24 = v14 + v5;
      v23 = v14;
      goto LABEL_11;
    }
    v10 += 0x10LL;
    v11 = v5 & (v10 + v11);
    if ( v10 > v5 )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v18, _EAX);
    LODWORD(v33) = 0;
    v19 = v5 & (v11 + v18);
    v20 = (_QWORD *)(v4[1] + 0x10 * v19);
    if ( *v20 == a2 )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v14 = *v4;
      goto LABEL_6;
    }
  }
  v23 = *v4;
  v24 = *v4 + v19;
LABEL_11:
  if ( v24 == v23 + *(_QWORD *)(a1 + 0x1208) )
  {
    v26 = *(_QWORD *)(a1 + 0x1260);
    v27 = *(_QWORD *)(a1 + 0x1268);
    *(_QWORD *)(a1 + 0x1260) = v26 + 1;
    if ( 0x10 * v26 >= v27 )
    {
      sub_14056DA40(a1 + 0x1270, v3 + v27, *(unsigned int *)(a1 + 0x1284));
      *(_QWORD *)(a1 + 0x1268) += *(unsigned int *)(a1 + 0x1284);
    }
    v28 = a2;
    v30 = (__int64 *)&v28;
    v29 = v26;
    v31 = &v29;
    *(_QWORD *)(v3 + 0x10 * v26) = a2;
    *a3 = v26;
    sub_147601B90(
      v4,
      (__int64)v32,
      &v28,
      (__PAIR128__(a2, a2) * 0xDE5FB9D2630458E9uLL) >> 0x40,
      (int)&byte_14819E9C1,
      &v30,
      &v31);
    return v3 + 0x10 * v26;
  }
  else
  {
    *a3 = v20[1];
    return v3 + 0x10LL * v20[1];
  }
}

// --- End Function: sub_147602DF0 (0x147602DF0) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476030E0 (0x1476030E0) ---
unsigned __int64 __fastcall sub_1476030E0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n32; // eax
  unsigned int n32_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147603270((__int64)&qword_151700CC0, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n32 = 32;
    n32_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n32 = n32_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(32 - n32) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148D699B0[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 16 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3840;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 12);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147604610(&unk_151700CD0[4 * v12]);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1476034A0((__int64)&qword_151700CC0, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_151701F50;
  if ( qword_151701F50 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_151701E50;
    if ( qword_151701E50 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1476030E0 (0x1476030E0) ---

// --- Function: sub_147603270 (0x147603270) ---
__int64 __fastcall sub_147603270(__int64 a1, unsigned __int64 n0xE000)
{
  unsigned __int64 n0xE000_2; // r13
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // rbx
  unsigned __int64 v5; // r12
  __int64 v6; // r15
  __int64 v7; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rsi
  unsigned __int64 v10; // r14
  __int64 v11; // r8
  __int64 v12; // rsi
  __int64 v13; // rax
  __int128 v15; // [rsp+30h] [rbp-40h] BYREF
  double v16; // [rsp+40h] [rbp-30h]
  __int64 v17; // [rsp+48h] [rbp-28h] BYREF
  __int128 v18; // [rsp+50h] [rbp-20h]
  double v19; // [rsp+60h] [rbp-10h]
  double v20; // [rsp+B0h] [rbp+40h] BYREF
  unsigned __int64 n0xE000_1; // [rsp+B8h] [rbp+48h]
  __int64 v22; // [rsp+C0h] [rbp+50h]

  n0xE000_1 = n0xE000;
  n0xE000_2 = n0xE000;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
  v5 = sub_147603A00(n0xE000, 1);
  v6 = ~(*(unsigned int *)(a1 + 0x1284) - 1LL) & (*(unsigned int *)(a1 + 0x1284) + n0xE000_2 - 1);
  v22 = v6;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x12C0));
  v20 = 0.0;
  v7 = sub_147602DF0(a1, v5, &v20);
  v8 = *(_QWORD **)(v7 + 8);
  if ( v8 )
  {
    *(_QWORD *)(v7 + 8) = *v8;
    v9 = v8[1];
    v8[1] = 0;
    *v8 = *(_QWORD *)(a1 + 0x12B8);
    *(_QWORD *)(a1 + 0x12B8) = v8;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 0x1290);
    if ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 )
    {
      do
      {
        v11 = *(unsigned int *)(a1 + 0x12AC);
        v12 = (v11 + 0x17) & ~(v11 - 1);
        *(__m256i *)(a1 + 0x1298) = *(__m256i *)sub_14056DBC0((__int64)&v17, 0x8000000000LL, v11, &off_148D699A8, 1, 0);// "StarAlloc-Large"
        v10 = (*(_QWORD *)(a1 + 0x1298) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
        __asm { vzeroupper }
        sub_14056DA40(a1 + 0x1298, v10, v12);
        *(_WORD *)(v10 + 0x15) = 0;
        *(_BYTE *)(v10 + 0x17) = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)(v10 + 0x10) = 0x1337;
        *(_BYTE *)(v10 + 0x14) = 0;
        *(_QWORD *)(v10 + 8) = v12;
        *(_QWORD *)v10 = *(_QWORD *)(a1 + 0x1290);
        *(_QWORD *)(a1 + 0x1290) = v10;
      }
      while ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 );
      v6 = v22;
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
      n0xE000_2 = n0xE000_1;
    }
    v13 = *(_QWORD *)(v10 + 8);
    v9 = v13 + v10;
    *(_QWORD *)(v10 + 8) = v5 + v13;
  }
  sub_14056DA40(a1 + 0x1270, v9, v6);
  v16 = v20;
  *(_QWORD *)&v15 = n0xE000_2;
  *((_QWORD *)&v15 + 1) = v6;
  v19 = v20;
  v17 = v9;
  v18 = v15;
  sub_1476044E0((__int64 *)(a1 + 0x1228), (__int64)&v15, &v17);
  LeaveCriticalSection(lpCriticalSection);
  return v9;
}

// --- End Function: sub_147603270 (0x147603270) ---

// --- Function: sub_1476034A0 (0x1476034A0) ---
__int64 __fastcall sub_1476034A0(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 n0x10)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 i; // rax
  __int64 v9; // r11
  signed __int32 v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rbp
  unsigned __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r12
  unsigned __int64 v16; // r15
  unsigned __int64 v17; // rax
  _QWORD *v18; // r8
  unsigned __int64 v19; // rax
  int v20; // r9d
  signed __int64 v21; // rdx
  int n2_1; // [rsp+20h] [rbp-48h] BYREF
  __int64 v24; // [rsp+28h] [rbp-40h]
  int n2; // [rsp+78h] [rbp+10h] BYREF
  __int64 v27; // [rsp+80h] [rbp+18h]

  v27 = a3;
  v4 = *(unsigned int *)(a1 + 0x11AC);
  v24 = v4;
  v5 = 0x20 * a3 + a1 + 0x10;
  v6 = a3;
  for ( i = sub_147604610((volatile signed __int64 *)v5); !i; i = sub_147604610((volatile signed __int64 *)v5) )
  {
    v10 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 1, 0) - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        n2 = 2;
        qword_149B3B480(v5 + 0x18, &n2, 4, 0xFFFFFFFFLL);
      }
      else
      {
        v11 = *(_QWORD *)(v5 + 0x10);
        if ( !v11 || 0x2000000LL - *(_QWORD *)(v11 + 0x20) - v4 < a2 )
        {
          sub_147602270(v9, a2, v6);
          v9 = a1;
        }
        v12 = *(_QWORD *)(v5 + 0x10);
        v13 = v12 - v4 + 0x2000000;
        v14 = *(_QWORD *)(v12 + 0x20);
        v15 = v14 + v12;
        if ( v12 + v14 + 0x20 * a2 < v13 )
          v13 = v12 + v14 + 0x20 * a2;
        v16 = ~(v24 - 1) & (v13 - v12 + v4 - 1);
        v17 = *(_QWORD *)(v12 + 0x18);
        if ( v16 > v17 )
        {
          sub_14056DA40(v9 + 0x1198, v17 + v12, v16 - v17);
          *(_QWORD *)(v12 + 0x18) = v16;
        }
        *(_QWORD *)(v12 + 0x20) = v13 - v12;
        v18 = (_QWORD *)(v15 + a2 - 8);
        v19 = v15 + 2 * a2;
        v20 = 1;
        v21 = (signed __int64)v18;
        for ( *v18 = 0; v19 <= v13; v19 += a2 )
        {
          *(_QWORD *)(v19 - 8) = v21;
          ++v20;
          v21 = v19 - 8;
        }
        sub_1476047E0((volatile signed __int64 *)v5, v21, v18, v20);
        if ( _InterlockedExchange((volatile __int32 *)(v5 + 0x18), 0) == 2 )
          qword_149B3B490(v5 + 0x18);
        v6 = v27;
        v4 = v24;
      }
    }
    else if ( (unsigned int)(_InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 2, 1) - 1) <= 1 )
    {
      n2_1 = 2;
      qword_149B3B480(v5 + 0x18, &n2_1, 4, 0xFFFFFFFFLL);
    }
  }
  return i - a2 + 8;
}

// --- End Function: sub_1476034A0 (0x1476034A0) ---

// --- Function: sub_147603A00 (0x147603A00) ---
__int64 __fastcall sub_147603A00(unsigned __int64 n0x10000, char a2)
{
  __int64 result; // rax

  if ( !a2 )
    goto LABEL_18;
  if ( n0x10000 <= 0x10000 )
    return 0x10000;
  if ( n0x10000 <= 0x20000 )
    return 0x20000;
  if ( n0x10000 <= 0x30000 )
    return 0x30000;
  if ( n0x10000 <= 0x40000 )
    return 0x40000;
  if ( n0x10000 <= 0x50000 )
    return 0x50000;
  if ( n0x10000 <= 0x60000 )
    return 0x60000;
  if ( n0x10000 <= 0x70000 )
    return 0x70000;
  if ( n0x10000 <= 0x80000 )
    return 0x80000;
LABEL_18:
  if ( n0x10000 <= 0xA0000 )
    return 0xA0000;
  if ( n0x10000 <= 0xC0000 )
    return 0xC0000;
  if ( n0x10000 <= 0xE0000 )
    return 0xE0000;
  if ( n0x10000 <= 0x100000 )
    return 0x100000;
  if ( n0x10000 <= 0x140000 )
    return 0x140000;
  if ( n0x10000 <= 0x180000 )
    return 0x180000;
  if ( n0x10000 <= 0x1C0000 )
    return 0x1C0000;
  if ( n0x10000 <= 0x200000 )
    return 0x200000;
  if ( n0x10000 <= 0x400000 )
    return 0x400000;
  if ( n0x10000 <= 0x600000 )
    return 0x600000;
  if ( n0x10000 <= 0x800000 )
    return 0x800000;
  if ( n0x10000 <= 0xA00000 )
    return 0xA00000;
  if ( n0x10000 <= 0xC00000 )
    return 0xC00000;
  if ( n0x10000 <= 0xE00000 )
    return 0xE00000;
  if ( n0x10000 <= 0x1000000 )
    return 0x1000000;
  if ( n0x10000 <= 0x1400000 )
    return 0x1400000;
  if ( n0x10000 <= 0x1800000 )
    return 0x1800000;
  if ( n0x10000 <= 0x1C00000 )
    return 0x1C00000;
  if ( n0x10000 <= 0x2000000 )
    return 0x2000000;
  if ( n0x10000 <= 0x2800000 )
    return 0x2800000;
  if ( n0x10000 <= 0x3000000 )
    return 0x3000000;
  if ( n0x10000 <= 0x3800000 )
    return 0x3800000;
  if ( n0x10000 <= 0x4000000 )
    return 0x4000000;
  if ( n0x10000 <= 0x5000000 )
    return 0x5000000;
  if ( n0x10000 <= 0x6000000 )
    return 0x6000000;
  if ( n0x10000 <= 0x7000000 )
    return 0x7000000;
  if ( n0x10000 <= 0x8000000 )
    return 0x8000000;
  if ( n0x10000 <= 0xA000000 )
    return 0xA000000;
  if ( n0x10000 <= 0xC000000 )
    return 0xC000000;
  if ( n0x10000 <= 0xE000000 )
    return 0xE000000;
  if ( n0x10000 <= 0x10000000 )
    return 0x10000000;
  if ( n0x10000 <= 0x14000000 )
    return 0x14000000;
  if ( n0x10000 <= 0x18000000 )
    return 0x18000000;
  if ( n0x10000 <= 0x1C000000 )
    return 0x1C000000;
  if ( n0x10000 <= 0x20000000 )
    return 0x20000000;
  if ( n0x10000 <= 0x28000000 )
    return 0x28000000;
  if ( n0x10000 <= 0x30000000 )
    return 0x30000000;
  if ( n0x10000 <= 0x38000000 )
    return 0x38000000;
  if ( n0x10000 <= 0x40000000 )
    return 0x40000000;
  if ( n0x10000 <= 0x50000000 )
    return 0x50000000;
  if ( n0x10000 <= 0x60000000 )
    return 0x60000000;
  if ( n0x10000 <= 0x70000000 )
    return 0x70000000;
  result = 0x80000000LL;
  if ( n0x10000 > 0x80000000 )
  {
    result = 0xA0000000LL;
    if ( n0x10000 > 0xA0000000 )
    {
      result = 0xC0000000LL;
      if ( n0x10000 > 0xC0000000 )
      {
        result = 0xE0000000LL;
        if ( n0x10000 > 0xE0000000 )
        {
          result = 0x100000000LL;
          if ( n0x10000 > 0x100000000LL )
          {
            result = 0x180000000LL;
            if ( n0x10000 > 0x180000000LL )
            {
              result = 0x200000000LL;
              if ( n0x10000 > 0x200000000LL )
              {
                result = 0x280000000LL;
                if ( n0x10000 > 0x280000000LL )
                {
                  result = 0x300000000LL;
                  if ( n0x10000 > 0x300000000LL )
                  {
                    result = 0x380000000LL;
                    if ( n0x10000 > 0x380000000LL )
                    {
                      result = 0x400000000LL;
                      if ( n0x10000 > 0x400000000LL )
                      {
                        result = 0x500000000LL;
                        if ( n0x10000 > 0x500000000LL )
                        {
                          result = 0x600000000LL;
                          if ( n0x10000 > 0x600000000LL )
                          {
                            result = 0x700000000LL;
                            if ( n0x10000 > 0x700000000LL )
                            {
                              result = 0x800000000LL;
                              if ( n0x10000 > 0x800000000LL )
                              {
                                result = 0xA00000000LL;
                                if ( n0x10000 > 0xA00000000LL )
                                {
                                  result = 0xC00000000LL;
                                  if ( n0x10000 > 0xC00000000LL )
                                  {
                                    result = 0xE00000000LL;
                                    if ( n0x10000 > 0xE00000000LL )
                                    {
                                      result = 0x1000000000LL;
                                      if ( n0x10000 > 0x1000000000LL )
                                      {
                                        result = 0x1400000000LL;
                                        if ( n0x10000 > 0x1400000000LL )
                                        {
                                          result = 0x1800000000LL;
                                          if ( n0x10000 > 0x1800000000LL )
                                          {
                                            result = 0x1C00000000LL;
                                            if ( n0x10000 > 0x1C00000000LL )
                                            {
                                              result = 0x2000000000LL;
                                              if ( n0x10000 > 0x2000000000LL )
                                              {
                                                result = 0x2800000000LL;
                                                if ( n0x10000 > 0x2800000000LL )
                                                {
                                                  result = 0x3000000000LL;
                                                  if ( n0x10000 > 0x3000000000LL )
                                                  {
                                                    result = 0x3800000000LL;
                                                    if ( n0x10000 > 0x3800000000LL )
                                                    {
                                                      result = 0x4000000000LL;
                                                      if ( n0x10000 > 0x4000000000LL )
                                                      {
                                                        _XMM0 = 0;
                                                        if ( (n0x10000 & 0x8000000000000000uLL) != 0LL )
                                                        {
                                                          __asm { vcvtsi2sd xmm0, xmm0, rax }
                                                          *(double *)&_XMM0 = *(double *)&_XMM0 + *(double *)&_XMM0;
                                                        }
                                                        else
                                                        {
                                                          __asm { vcvtsi2sd xmm0, xmm0, rcx }
                                                        }
                                                        LogFatalError(
                                                          "StarAlloc: Requested Allocation Size %.2f MB is larger than su"
                                                          "pported by StarAlloc",
                                                          *(double *)&_XMM0 * 0.00000095367431640625);
                                                        return 0;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_147603A00 (0x147603A00) ---

// --- Function: sub_1476044E0 (0x1476044E0) ---
__int64 __fastcall sub_1476044E0(__int64 *a1, __int64 a2, __int64 *a3)
{
  double v3; // r9
  __int128 v4; // xmm0
  double v5; // xmm1_8
  unsigned __int128 v7; // rax
  __int128 v8; // xmm0
  __int64 result; // rax
  double *v10; // [rsp+40h] [rbp-58h] BYREF
  __int128 *v11; // [rsp+48h] [rbp-50h] BYREF
  __int128 v12; // [rsp+50h] [rbp-48h] BYREF
  char v13; // [rsp+60h] [rbp-38h]
  double v14; // [rsp+68h] [rbp-30h] BYREF
  __int128 v15; // [rsp+70h] [rbp-28h] BYREF
  double v16; // [rsp+80h] [rbp-18h]

  v3 = *(double *)a3;
  v4 = *(_OWORD *)(a3 + 1);
  v5 = *((double *)a3 + 3);
  v10 = &v14;
  v14 = v3;
  v11 = &v15;
  v15 = v4;
  v7 = 0x100000001B3LL
     * (HIBYTE(*(_QWORD *)&v3)
      ^ (0x100000001B3LL
       * (BYTE6(v3)
        ^ (0x100000001B3LL
         * (BYTE5(v3)
          ^ (0x100000001B3LL
           * (BYTE4(v3)
            ^ (0x100000001B3LL
             * (BYTE3(v3)
              ^ (0x100000001B3LL
               * (BYTE2(v3) ^ (0x100000001B3LL * ((0x100000001B3LL * (LOBYTE(v3) ^ 0xCBF29CE484222325uLL)) ^ BYTE1(v3))))))))))))))
     * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v16 = v5;
  sub_147601A00(
    a1,
    (__int64)&v12,
    &v14,
    v7 + *((_QWORD *)&v7 + 1),
    (int)&byte_14819E9C1,
    (_QWORD **)&v10,
    (__int64 *)&v11);
  v8 = v12;
  *(_BYTE *)(a2 + 0x10) = v13;
  result = a2;
  *(_OWORD *)a2 = v8;
  return result;
}

// --- End Function: sub_1476044E0 (0x1476044E0) ---

// --- Function: sub_147604610 (0x147604610) ---
__int64 __fastcall sub_147604610(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __int32 v5; // edx
  __m128i v6; // rt0
  signed __int64 v8; // [rsp+18h] [rbp-40h]
  __m128i v9; // [rsp+30h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    LODWORD(v8) = epi64 + 1;
    HIDWORD(v8) = HIDWORD(epi64) - 1;
    v6.m128i_i64[0] = v2.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v8, *(_QWORD *)v2.m128i_i64[0], v6.m128i_i64);
    v4 = v6.m128i_i64[0];
    v5 = v6.m128i_i32[2];
    v9 = v6;
    if ( v6.m128i_i64[0] == v2.m128i_i64[0] && v5 == (_DWORD)epi64 )
      break;
    v2 = v9;
    if ( !v4 )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_147604610 (0x147604610) ---

// --- Function: sub_1476046F0 (0x1476046F0) ---
char __fastcall sub_1476046F0(volatile signed __int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __m128i v4; // rt0
  __m128i v5; // xmm0
  signed __int64 epi64; // r9
  __int64 v7; // rdx
  __m128i v8; // rt0
  signed __int64 v10; // [rsp+18h] [rbp-40h]
  __m128i v11; // [rsp+30h] [rbp-28h]

  v4 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v4.m128i_i64);
  v5 = v4;
  if ( (unsigned int)(v4.m128i_i32[3] + 1) >= a3 )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v5, 1);
    *a2 = v5.m128i_i64[0];
    LODWORD(v10) = epi64 + 1;
    HIDWORD(v10) = HIDWORD(epi64) + 1;
    v8.m128i_i64[0] = v5.m128i_i64[0];
    v8.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v10, (signed __int64)a2, v8.m128i_i64);
    v7 = v8.m128i_i64[1];
    v11 = v8;
    if ( v8.m128i_i64[0] == v5.m128i_i64[0] && (_DWORD)v7 == (_DWORD)epi64 )
      break;
    v5 = v11;
    if ( (unsigned int)(HIDWORD(v7) + 1) >= a3 )
      return 0;
  }
  return 1;
}

// --- End Function: sub_1476046F0 (0x1476046F0) ---

// --- Function: sub_1476047E0 (0x1476047E0) ---
__int64 __fastcall sub_1476047E0(volatile signed __int64 *a1, signed __int64 a2, _QWORD *a3, int a4)
{
  __m128i v6; // rt0
  __m128i i; // xmm0
  signed __int64 epi64; // r9
  __int64 result; // rax
  __int32 v10; // edx
  __m128i v11; // rt0
  signed __int64 v12; // [rsp+18h] [rbp-50h]
  __m128i v13; // [rsp+30h] [rbp-38h]

  v6 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v6.m128i_i64);
  for ( i = v6; ; i = v13 )
  {
    epi64 = _mm_extract_epi64(i, 1);
    *a3 = i.m128i_i64[0];
    LODWORD(v12) = epi64 + 1;
    HIDWORD(v12) = a4 + HIDWORD(epi64);
    v11.m128i_i64[0] = i.m128i_i64[0];
    v11.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v12, a2, v11.m128i_i64);
    result = v11.m128i_i64[0];
    v10 = v11.m128i_i32[2];
    v13 = v11;
    if ( v11.m128i_i64[0] == i.m128i_i64[0] && v10 == (_DWORD)epi64 )
      break;
  }
  return result;
}

// --- End Function: sub_1476047E0 (0x1476047E0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
// Standard stack security check function. Compares the provided stack cookie with
// the global security cookie. If a mismatch is detected or the cookie is
// corrupted, it triggers a security failure report.
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6320);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6336);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6320) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 6320);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: __report_rangecheckfailure (0x1480339D0) ---
void __noreturn _report_rangecheckfailure()
{
  _report_securityfailure(8);
}

// --- End Function: __report_rangecheckfailure (0x1480339D0) ---

// --- Function: __report_securityfailure (0x1480339E4) ---
void __fastcall __noreturn _report_securityfailure(unsigned int a1)
{
  DWORD64 retaddr; // [rsp+28h] [rbp+0h]
  unsigned int v2; // [rsp+30h] [rbp+8h] BYREF

  v2 = a1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(v2);
  capture_current_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v2;
  qword_151736400 = retaddr;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = v2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_securityfailure (0x1480339E4) ---

// --- Function: capture_current_context (0x148033A80) ---
struct _RUNTIME_FUNCTION *__fastcall capture_current_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rdi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+50h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+58h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+60h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
  if ( FunctionEntry )
    return (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                         0,
                                         ImageBase,
                                         ControlPc,
                                         FunctionEntry,
                                         ContextRecord,
                                         &HandlerData,
                                         &EstablisherFrame,
                                         0);
  return FunctionEntry;
}

// --- End Function: capture_current_context (0x148033A80) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

// --- Function: free_0 (0x1480821F7) ---
// attributes: thunk
void __cdecl free_0(void *Block)
{
  free(Block);
}

// --- End Function: free_0 (0x1480821F7) ---

// --- Function: malloc_0 (0x1480821FD) ---
// attributes: thunk
void *__cdecl malloc_0(size_t Size)
{
  return malloc(Size);
}

// --- End Function: malloc_0 (0x1480821FD) ---

// --- Function: sub_1480BD400 (0x1480BD400) ---
__int64 sub_1480BD400()
{
  __int64 v0; // rax

  v0 = NtCurrentTeb_w();
  return sub_1402A3D30(**(const void ***)(v0 + 0x10));
}

// --- End Function: sub_1480BD400 (0x1480BD400) ---

// --- Function: sub_1480BE950 (0x1480BE950) ---
__int64 sub_1480BE950()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = NtCurrentTeb_w();
  sub_1402A3D30(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = NtCurrentTeb_w();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0;
  return result;
}

// --- End Function: sub_1480BE950 (0x1480BE950) ---

// --- Function: sub_148177D00 (0x148177D00) ---
__int64 sub_148177D00()
{
  volatile signed __int64 *v0; // rdi
  __int64 ThreadLocalStoragePointer; // rax
  __int64 n0x8C; // rsi
  __int64 v3; // rbp
  __int64 v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *v6; // rax
  int v7; // r9d
  _QWORD *v8; // r8

  v0 = unk_151700CD0;
  ThreadLocalStoragePointer = (__int64)NtCurrentTeb()->ThreadLocalStoragePointer;
  n0x8C = 0x8C;
  v3 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF00LL;
  v4 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF10LL;
  do
  {
    v5 = *(_QWORD **)v4;
    if ( *(_QWORD *)v4 )
    {
      v6 = (_QWORD *)*v5;
      v7 = 1;
      v8 = *(_QWORD **)v4;
      if ( *v5 )
      {
        do
        {
          ++v7;
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while ( v6 );
      }
      ThreadLocalStoragePointer = sub_1476047E0(v0, (signed __int64)v5, v8, v7);
      *(_QWORD *)v4 = 0;
      *(_DWORD *)(v4 + 0xC) = 0;
    }
    v4 += 0x10;
    v0 += 4;
    --n0x8C;
  }
  while ( n0x8C );
  *(_BYTE *)(v3 + 1) = 1;
  return ThreadLocalStoragePointer;
}

// --- End Function: sub_148177D00 (0x148177D00) ---

