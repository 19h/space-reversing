// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x140327A60 (sub_140327A60)
//   - 0x1403B2070 (sub_1403B2070)
//   - 0x1468DBFC0 (sub_1468DBFC0)
//   - 0x147222EB0 (sub_147222EB0)
//   - 0x14722A370 (sub_14722A370)
//   - 0x14722A720 (sub_14722A720)
//   - 0x14723A830 (sub_14723A830)
//   - 0x14723ABD0 (sub_14723ABD0)
//   - 0x14723CB40 (sub_14723CB40)
//   - 0x14723CBE0 (sub_14723CBE0)
//   - 0x14723CE60 (sub_14723CE60)
//   - 0x14723D000 (sub_14723D000)
//   - 0x14723D160 (sub_14723D160)
//   - 0x14723D290 (sub_14723D290)
//   - 0x14723D330 (sub_14723D330)
//   - 0x14723D6E0 (sub_14723D6E0)
//   - 0x14723D9D0 (sub_14723D9D0)
//   - 0x14723DCD0 (sub_14723DCD0)
//   - 0x14723DF00 (sub_14723DF00)
//   - 0x14723E0B0 (sub_14723E0B0)
//   - 0x14723E2B0 (sub_14723E2B0)
//   - 0x14723E3A0 (sub_14723E3A0)
//   - 0x14723E630 (sub_14723E630)
//   - 0x14723E6E0 (sub_14723E6E0)
//   - 0x14723E760 (sub_14723E760)
//   - 0x14723E780 (sub_14723E780)
//   - 0x14723E870 (sub_14723E870)
//   - 0x14723EB40 (DataCore::GetStructFieldPointers)
//   - 0x14723EDF0 (DataCore::LookupDCStructDescByName)
//   - 0x14723EEF0 (sub_14723EEF0)
//   - 0x14723F2F0 (sub_14723F2F0)
//   - 0x14723FCB0 (sub_14723FCB0)
//   - 0x147240310 (sub_147240310)
//   - 0x147242730 (sub_147242730)
//   - 0x14724E7E0 (sub_14724E7E0)
//   - 0x147250D70 (sub_147250D70)
//   - 0x14725C050 (RegisterDataCoreStruct)
//   - 0x14725DCF0 (sub_14725DCF0)
//   - 0x14725DD10 (sub_14725DD10)
//   - 0x147266E90 (sub_147266E90)
//   - 0x1472688E0 (sub_1472688E0)
// Caller Depth: 0
// Callee/Ref Depth: 4
// Total Functions Found: 329
// ------------------------------------------------------------

// --- Function: _ (0x1402A08E0) ---
__int64 __fastcall sub_1402A08E0(__int64 a1)
{
  return a1;
}

// --- End Function: _ (0x1402A08E0) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A0C60) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A0C60) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A1370) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0LL;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A1370) ---

// --- Function: sub_1402A1C40 (0x1402A1C40) ---
_BYTE *__fastcall sub_1402A1C40(__int64 *a1, __int64 n511)
{
  _BYTE *result; // rax
  unsigned __int64 n0x6400000; // rsi
  __int64 n511_1; // rcx

  result = a1 + 3;
  if ( n511 )
  {
    n0x6400000 = n511 + 1;
    if ( (unsigned __int64)(n511 + 1) <= 0x200 )
    {
      n511_1 = 511;
    }
    else
    {
      result = (_BYTE *)sub_14739AFC0(n0x6400000, 0);
      qword_149808368 += n0x6400000;
      n511_1 = n511;
    }
    a1[1] = n511_1;
    *a1 = n511;
    a1[2] = (__int64)result;
    result[n511] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 511;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A1C40 (0x1402A1C40) ---

// --- Function: sub_1402A1D80 (0x1402A1D80) ---
__int64 __fastcall sub_1402A1D80(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _BYTE *v3; // rsi
  __int64 result; // rax

  v2 = (_QWORD *)a1[2];
  v3 = a1 + 3;
  if ( v2 != a1 + 3 )
  {
    qword_149808368 += -1LL - a1[1];
    result = sub_14739AF10(v2);
  }
  a1[2] = v3;
  *v3 = 0;
  *a1 = 0LL;
  a1[1] = 511LL;
  return result;
}

// --- End Function: sub_1402A1D80 (0x1402A1D80) ---

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: sub_1402A1E30 (0x1402A1E30) ---
__int64 __fastcall sub_1402A1E30(unsigned __int64 n0x6400000)
{
  return sub_14739AFC0(n0x6400000, 0LL);
}

// --- End Function: sub_1402A1E30 (0x1402A1E30) ---

// --- Function: sub_1402A2470 (0x1402A2470) ---
void *sub_1402A2470()
{
  return &unk_149808280;
}

// --- End Function: sub_1402A2470 (0x1402A2470) ---

// --- Function: sub_1402A4690 (0x1402A4690) ---
char *__fastcall sub_1402A4690(char **a1, _QWORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _QWORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  _BYTE *v16; // rdx
  char *v17; // rbp
  char *Size; // r8

  v2 = a1[1];
  v4 = a1[2];
  if ( v2 == v4 )
  {
    v7 = 0x1FFFFFFFFFFFFFFFLL;
    v8 = (v2 - *a1) >> 3;
    if ( v8 == 0x1FFFFFFFFFFFFFFFLL )
    {
      unknown_libname_10();
    }
    v9 = (v4 - *a1) >> 3;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
      {
        v7 = v8 + 1;
      }
    }
    v12 = v7;
    v13 = (_QWORD *)sub_14038E0B0((__int64)a1, 8 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = a1[1];
    v16 = *a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = (char *)(v15 - v16);
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 8;
      Size = (char *)(a1[1] - v2);
      v16 = v2;
    }
    memmove(v14, v16, (size_t)Size);
    if ( *a1 )
    {
      sub_14039EFB0((__int64)a1, *a1, (a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL);
    }
    *a1 = (char *)v13;
    result = v17;
    a1[1] = (char *)&v13[v11];
    a1[2] = (char *)&v13[v12];
  }
  else
  {
    *(_QWORD *)v2 = *a2;
    result = a1[1];
    a1[1] = result + 8;
  }
  return result;
}

// --- End Function: sub_1402A4690 (0x1402A4690) ---

// --- Function: sub_1402A47D0 (0x1402A47D0) ---
char *__fastcall sub_1402A47D0(__int64 *a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 n0x6400000; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  _BYTE *v20; // rcx
  char *result; // rax

  v3 = (__int64)&a2[-*a1] >> 3;
  v5 = (a1[1] - *a1) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = (a1[2] - *a1) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
  {
    goto LABEL_24;
  }
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
  {
    v11 = v10 + v8;
  }
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_24;
  }
  n0x6400000 = 8 * v11;
  if ( n0x6400000 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      v14 = (_QWORD *)sub_1402A1E30(n0x6400000);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_13;
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_24:
    sub_1402DEE40();
  }
  v13 = sub_1402A1E30(n0x6400000 + 39);
  if ( !v13 )
  {
    goto LABEL_22;
  }
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *a3;
  v16 = v14;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v16 = v15 + 1;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v16, v18, Size);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      free_memory_wrapper(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v20[-*((_QWORD *)v20 - 1) - 8] <= 0x1F )
    {
      v20 = (_BYTE *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v14;
  result = (char *)&v14[v3];
  a1[1] = (__int64)&v14[v9];
  a1[2] = (__int64)&v14[n0x6400000 / 8];
  return result;
}

// --- End Function: sub_1402A47D0 (0x1402A47D0) ---

// --- Function: sub_1402A4BA0 (0x1402A4BA0) ---
char *__fastcall sub_1402A4BA0(__int64 *a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  _QWORD *v12; // rsi
  void *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  char *v16; // rbp
  size_t Size; // r8
  _BYTE *ptr_to_free; // rcx
  char *result; // rax

  v4 = (__int64)&a2[-*a1] >> 3;
  v5 = 0x1FFFFFFFFFFFFFFFLL;
  v6 = (a1[1] - *a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v9 = (a1[2] - *a1) >> 3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    v5 = v11 + v9;
    if ( v11 + v9 < v10 )
    {
      v5 = v6 + 1;
    }
  }
  v12 = (_QWORD *)sub_1402DFE40((__int64)a1, v5);
  v12[v4] = *a3;
  v13 = v12;
  v14 = (_BYTE *)a1[1];
  v15 = (_BYTE *)*a1;
  v16 = (char *)&v12[v4];
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = v16 + 8;
    Size = a1[1] - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  ptr_to_free = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)ptr_to_free) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)&ptr_to_free[-*((_QWORD *)ptr_to_free - 1) - 8] > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      ptr_to_free = (_BYTE *)*((_QWORD *)ptr_to_free - 1);
    }
    free_memory_wrapper(ptr_to_free);
  }
  *a1 = (__int64)v12;
  result = v16;
  a1[1] = (__int64)&v12[v10];
  a1[2] = (__int64)&v12[v5];
  return result;
}

// --- End Function: sub_1402A4BA0 (0x1402A4BA0) ---

// --- Function: sub_1402A56E0 (0x1402A56E0) ---
char *__fastcall sub_1402A56E0(__int64 *a1, _BYTE *a2, __int64 a3)
{
  __int64 v6; // r12
  __int64 v7; // rdx
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  _QWORD *v13; // rbx
  void *v14; // rcx
  double *v15; // rbp
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  size_t Size; // r8
  _BYTE *ptr_to_free; // r8
  char *result; // rax

  v6 = (__int64)&a2[-*a1] / 24;
  v7 = (a1[1] - *a1) / 24;
  if ( v7 == 0xAAAAAAAAAAAAAAALL )
  {
    unknown_libname_10();
  }
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 24;
  if ( v9 > 0xAAAAAAAAAAAAAAALL - (v9 >> 1) )
  {
    goto LABEL_24;
  }
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
  {
    v10 = (v9 >> 1) + v9;
  }
  if ( v10 > 0xAAAAAAAAAAAAAAALL )
  {
    goto LABEL_24;
  }
  v11 = 24 * v10;
  if ( 24 * v10 < 0x1000 )
  {
    if ( v11 )
    {
      v13 = (_QWORD *)sub_1402A1E30(24 * v10);
    }
    else
    {
      v13 = 0;
    }
    goto LABEL_13;
  }
  if ( v11 + 39 < v11 )
  {
LABEL_24:
    sub_1402DEE40();
  }
  v12 = sub_1402A1E30(v11 + 39);
  if ( !v12 )
  {
    goto LABEL_22;
  }
  v13 = (_QWORD *)((v12 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v13 - 1) = v12;
LABEL_13:
  v14 = v13;
  *(_OWORD *)&v13[3 * v6] = *(_OWORD *)a3;
  v15 = (double *)&v13[3 * v6];
  v15[2] = *(double *)(a3 + 16);
  v16 = (_BYTE *)a1[1];
  v17 = (_BYTE *)*a1;
  if ( a2 == v16 )
  {
    Size = v16 - v17;
  }
  else
  {
    memmove(v13, v17, a2 - v17);
    v14 = v15 + 3;
    Size = a1[1] - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v14, v17, Size);
  ptr_to_free = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(24 * ((a1[2] - (__int64)ptr_to_free) / 24)) < 0x1000 )
    {
LABEL_20:
      free_memory_wrapper(ptr_to_free);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&ptr_to_free[-*((_QWORD *)ptr_to_free - 1) - 8] <= 0x1F )
    {
      ptr_to_free = (_BYTE *)*((_QWORD *)ptr_to_free - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v13;
  a1[1] = (__int64)&v13[3 * v8];
  result = (char *)&v13[3 * v6];
  a1[2] = (__int64)&v13[v11 / 8];
  return result;
}

// --- End Function: sub_1402A56E0 (0x1402A56E0) ---

// --- Function: sub_1402A5FE0 (0x1402A5FE0) ---
__int64 __fastcall sub_1402A5FE0(__int64 a1, __int64 a2, __int64 i)
{
  __int64 i_1; // rbx
  const void *i_2; // rcx
  __int64 result; // rax

  i_1 = i;
  while ( !*(_BYTE *)(i_1 + 25) )
  {
    sub_1402A5FE0(a1, a2, *(_QWORD *)(i_1 + 16));
    i_2 = (const void *)i_1;
    i_1 = *(_QWORD *)i_1;
    free_memory_wrapper(i_2);
  }
  return result;
}

// --- End Function: sub_1402A5FE0 (0x1402A5FE0) ---

// --- Function: sub_1402A78B0 (0x1402A78B0) ---
const void **__fastcall sub_1402A78B0(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 n0x6400000; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
  {
    unknown_libname_9();
  }
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    n0x6400000 = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
    {
      v6 = v12 + n0xF;
    }
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
      {
        v15 = 0;
      }
      else
      {
        v15 = (_QWORD *)sub_1402A1E30(v6 + 1);
      }
      goto LABEL_15;
    }
    n0x6400000 = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
    {
      sub_1402DEE40();
    }
  }
  v14 = sub_1402A1E30(n0x6400000);
  if ( !v14 )
  {
    goto LABEL_20;
  }
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  free_memory_wrapper(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A78B0 (0x1402A78B0) ---

// --- Function: sub_1402A8A70 (0x1402A8A70) ---
__int64 __fastcall sub_1402A8A70(unsigned __int64 **a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 *v5; // r15
  unsigned __int64 *v6; // rax
  unsigned __int64 v7; // rcx
  unsigned __int64 *v8; // rbx
  unsigned __int64 *v9; // rbp
  unsigned __int64 *v10; // rcx
  unsigned __int64 **v12; // r13
  unsigned __int64 **v13; // r12
  __int64 v14; // rdi
  __int64 v15; // rcx
  float v16; // xmm1_4
  float v17; // kr00_4
  unsigned __int64 n8_2; // rdx
  float v19; // xmm0_4
  float v20; // kr00_4
  unsigned __int64 v23; // rcx
  unsigned __int64 n8_1; // rax
  unsigned __int64 n8; // rcx
  unsigned __int64 v26; // r8
  unsigned __int64 *v27; // rdx
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rdx
  int v30; // ecx
  __int64 *v31; // rdx
  unsigned __int64 *v32; // rcx
  __int64 v33; // rax
  unsigned __int64 *v34; // r8
  unsigned __int64 v35; // [rsp+70h] [rbp+8h]

  v5 = a1[1];
  v6 = a1[3];
  v35 = 0x100000001B3LL
      * (a3[3]
       ^ (0x100000001B3LL * (a3[2] ^ (0x100000001B3LL * (a3[1] ^ (0x100000001B3LL * (*a3 ^ 0xCBF29CE484222325uLL)))))));
  v7 = 2 * (v35 & (unsigned __int64)a1[6]);
  v8 = (unsigned __int64 *)v6[v7 + 1];
  if ( v8 == v5 )
  {
    v8 = v5;
    v9 = v5;
  }
  else
  {
    v10 = (unsigned __int64 *)v6[v7];
    if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
    {
LABEL_6:
      *(_QWORD *)a2 = v8;
      *(_BYTE *)(a2 + 8) = 0;
      return a2;
    }
    while ( v8 != v10 )
    {
      v8 = (unsigned __int64 *)v8[1];
      if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
      {
        goto LABEL_6;
      }
    }
    v5 = v8;
    v9 = v8;
  }
  v12 = a1 + 1;
  v13 = a1 + 6;
  if ( a1[2] == (unsigned __int64 *)0x7FFFFFFFFFFFFFFLL )
  {
    std::_Xlength_error("unordered_map/set too long");
  }
  v14 = sub_1402A1E30(0x20u);
  *(_DWORD *)(v14 + 16) = *(_DWORD *)a3;
  *(_QWORD *)(v14 + 24) = 0;
  v15 = (__int64)a1[2] + 1;
  if ( v15 < 0 )
  {
    v17 = (float)(v15 & 1 | ((unsigned __int64)v15 >> 1));
    v16 = v17 + v17;
  }
  else
  {
    v16 = (float)v15;
  }
  n8_2 = (unsigned __int64)a1[7];
  if ( (n8_2 & 0x8000000000000000uLL) != 0LL )
  {
    v20 = (float)((unsigned __int64)a1[7] & 1 | (n8_2 >> 1));
    v19 = v20 + v20;
  }
  else
  {
    v19 = (float)(__int64)n8_2;
  }
  if ( *(float *)a1 >= (float)(v16 / v19) )
  {
    v26 = v35;
  }
  else
  {
    _XMM1 = 0;
    __asm { vroundss xmm1, xmm1, xmm0, 2 }
    v23 = 0;
    if ( *(float *)&_XMM1 >= 9.223372e18 )
    {
      *(float *)&_XMM1 = *(float *)&_XMM1 - 9.223372e18;
      if ( *(float *)&_XMM1 < 9.223372e18 )
      {
        v23 = 0x8000000000000000uLL;
      }
    }
    n8_1 = v23 + (unsigned int)(int)*(float *)&_XMM1;
    n8 = 8;
    if ( n8_1 > 8 )
    {
      n8 = n8_1;
    }
    if ( n8_2 < n8 )
    {
      if ( n8_2 >= 0x200 || (n8_2 *= 8LL, n8_2 < n8) )
      {
        n8_2 = n8;
      }
    }
    sub_1402DE090(a1, n8_2);
    v26 = v35;
    v27 = a1[3];
    v8 = a1[1];
    v28 = v27[2 * (v35 & (unsigned __int64)a1[6]) + 1];
    if ( (unsigned __int64 *)v28 != v8 )
    {
      v29 = v27[2 * (v35 & (unsigned __int64)a1[6])];
      v30 = *(_DWORD *)(v14 + 16);
      if ( v30 != *(_DWORD *)(v28 + 16) )
      {
        while ( 1 )
        {
          v8 = (unsigned __int64 *)v28;
          if ( v28 == v29 )
          {
            break;
          }
          v28 = *(_QWORD *)(v28 + 8);
          if ( v30 == *(_DWORD *)(v28 + 16) )
          {
            goto LABEL_30;
          }
        }
        v13 = a1 + 6;
        v12 = a1 + 1;
        v9 = (unsigned __int64 *)v28;
        v5 = (unsigned __int64 *)v28;
        goto LABEL_34;
      }
LABEL_30:
      v8 = *(unsigned __int64 **)v28;
    }
    v13 = a1 + 6;
    v9 = v8;
    v12 = a1 + 1;
    v5 = v8;
  }
LABEL_34:
  v31 = (__int64 *)v8[1];
  a1[2] = (unsigned __int64 *)((char *)a1[2] + 1);
  *(_QWORD *)v14 = v5;
  *(_QWORD *)(v14 + 8) = v31;
  *v31 = v14;
  v8[1] = v14;
  v32 = a1[3];
  v33 = 2 * (v26 & (unsigned __int64)*v13);
  v34 = (unsigned __int64 *)v32[2 * (v26 & (unsigned __int64)*v13)];
  if ( v34 == *v12 )
  {
    v32[v33] = v14;
    goto LABEL_39;
  }
  if ( v34 != v9 )
  {
    if ( (__int64 *)v32[v33 + 1] != v31 )
    {
LABEL_40:
      *(_QWORD *)a2 = v14;
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
LABEL_39:
    v32[v33 + 1] = v14;
    goto LABEL_40;
  }
  v32[v33] = v14;
  *(_QWORD *)a2 = v14;
  *(_BYTE *)(a2 + 8) = 1;
  return a2;
}

// --- End Function: sub_1402A8A70 (0x1402A8A70) ---

// --- Function: sub_1402AF650 (0x1402AF650) ---
_QWORD *__fastcall sub_1402AF650(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_147F343E8;
  return a1;
}

// --- End Function: sub_1402AF650 (0x1402AF650) ---

// --- Function: sub_1402AF900 (0x1402AF900) ---
__int64 __fastcall sub_1402AF900(__int64 *a1)
{
  _QWORD *v2; // rcx
  __int64 v3; // rcx
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx

  v2 = (_QWORD *)a1[3];
  if ( v2 )
  {
    if ( ((a1[5] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v2 = (_QWORD *)*(v2 - 1);
    }
    free_memory_wrapper(v2);
    a1[3] = 0LL;
    a1[4] = 0LL;
    a1[5] = 0LL;
  }
  v3 = a1[1];
  **(_QWORD **)(v3 + 8) = 0LL;
  v4 = *(_QWORD **)v3;
  if ( v4 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      free_memory_wrapper(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  return free_memory_wrapper((const void *)a1[1]);
}

// --- End Function: sub_1402AF900 (0x1402AF900) ---

// --- Function: sub_1402B02C0 (0x1402B02C0) ---
__int64 __fastcall sub_1402B02C0(const void **a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    if ( (((_BYTE *)a1[2] - (_BYTE *)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v2 = (_QWORD *)*(v2 - 1);
    }
    free_memory_wrapper(v2);
    result = 0LL;
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
  return result;
}

// --- End Function: sub_1402B02C0 (0x1402B02C0) ---

// --- Function: sub_1402B0320 (0x1402B0320) ---
__int64 __fastcall sub_1402B0320(const void **a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    if ( (unsigned __int64)(24 * (((_BYTE *)a1[2] - (_BYTE *)v2) / 24)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v2 = (_QWORD *)*(v2 - 1);
    }
    free_memory_wrapper(v2);
    result = 0LL;
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
  return result;
}

// --- End Function: sub_1402B0320 (0x1402B0320) ---

// --- Function: ??0_lambda_17b8e77e04f0039ff1429d79b8271fa1_@@QEAA@AEBQEB_W@Z (0x1402B2AF0) ---
// Microsoft VisualC v14 64bit runtime
_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *__fastcall _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
        _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *this,
        const wchar_t **a2)
{
  *(_QWORD *)this = *a2;
  return this;
}

// --- End Function: ??0_lambda_17b8e77e04f0039ff1429d79b8271fa1_@@QEAA@AEBQEB_W@Z (0x1402B2AF0) ---

// --- Function: sub_1402B5F60 (0x1402B5F60) ---
__int64 __fastcall sub_1402B5F60(__int64 a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64))
{
  __int64 v5; // rbx
  __int64 result; // rax

  if ( a3 )
  {
    v5 = a3;
    do
    {
      result = a4(a1);
      a1 += a2;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

// --- End Function: sub_1402B5F60 (0x1402B5F60) ---

// --- Function: sub_1402BA020 (0x1402BA020) ---
__int64 *__fastcall sub_1402BA020(__int64 *a1, char *a2)
{
  __int64 n123; // r8
  __int64 n90; // r8
  __int64 v6; // r8
  __int64 n90_1; // rcx
  __int64 v8; // r8
  __int64 v9; // rcx
  __int64 n90_2; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r8
  __int64 n90_3; // rcx
  __int64 v15; // rdx
  __int64 n90_4; // rcx
  __int64 v17; // rdx
  __int64 v18; // rax
  __int64 n90_5; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  __int64 n90_6; // rcx
  __int64 v23; // rdx
  __int64 v24; // rax
  __int64 n90_7; // rcx
  __int64 v26; // rdx
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 n122; // rcx
  __int64 v30; // rax
  __int64 n90_8; // rcx
  __int64 v32; // rdx
  __int64 v33; // rax
  __int64 n90_9; // rcx
  __int64 v35; // rdx
  __int64 v36; // rax
  __int64 n90_10; // rcx
  __int64 v38; // rdx
  __int64 v39; // rax
  __int64 v40; // rdx
  __int64 n122_1; // rcx
  __int64 v42; // rax
  __int64 n90_11; // rcx
  __int64 v44; // rdx
  __int64 v45; // rax
  __int64 n90_12; // rcx
  __int64 v47; // rdx
  __int64 v48; // rax
  __int64 n90_13; // rcx
  __int64 v50; // rdx
  __int64 v51; // rax
  __int64 v52; // rdx
  __int64 n122_2; // rcx
  __int64 v54; // rcx
  __int64 n90_14; // r8
  __int64 v56; // rcx
  __int64 v57; // rax
  __int64 n90_15; // r8
  __int64 v59; // rcx
  __int64 v60; // r8
  __int64 v61; // r8
  __int64 n90_16; // rcx
  __int64 v63; // rcx
  __int64 v64; // rcx
  __int64 n122_3; // r8
  __int64 v66; // r8
  __int64 v67; // r8
  __int64 n90_17; // rcx
  __int64 v69; // rcx
  __int64 v70; // rcx
  __int64 n90_18; // r8
  __int64 v72; // r8
  __int64 v73; // r8
  __int64 n90_19; // rcx
  __int64 v75; // rcx
  __int64 v76; // rcx
  __int64 n90_20; // r8
  __int64 v78; // r8
  __int64 v79; // r8
  __int64 n90_21; // rcx
  __int64 v81; // rcx
  __int64 v82; // rcx
  __int64 n90_22; // r8
  __int64 v84; // r8
  __int64 v85; // r8
  __int64 n90_23; // rcx
  __int64 v87; // rcx
  __int64 v88; // rcx
  __int64 n90_24; // r8
  __int64 v90; // rax
  __int64 n90_25; // r8
  __int64 v92; // rcx
  __int64 v93; // rax
  __int64 n90_26; // r8
  __int64 v95; // rcx
  __int64 v96; // rax
  __int64 n97; // r8
  __int64 v98; // rcx
  __int64 v99; // rax
  __int64 v100; // rcx
  __int64 *result; // rax
  __int64 v102; // rdx
  __int64 n122_4; // rcx
  __int64 v104; // rdx
  __int64 v105; // rax
  __int64 n122_5; // rcx
  __int64 v107; // rdx
  __int64 v108; // rax
  __int64 n122_6; // rcx
  __int64 v110; // rdx
  __int64 v111; // rax
  __int64 n122_7; // rcx
  __int64 v113; // rdx
  __int64 v114; // rax
  __int64 n122_8; // rcx
  __int64 v116; // rdx
  __int64 v117; // rax
  __int64 n122_9; // rcx
  __int64 v119; // rdx
  __int64 v120; // rax
  __int64 n122_10; // rcx
  __int64 v122; // rdx
  __int64 v123; // rax
  __int64 v124; // rdx
  __int64 n122_11; // rcx
  __int64 v126; // rax
  __int64 n122_12; // rcx
  __int64 v128; // rdx
  __int64 v129; // rax
  __int64 n122_13; // rcx
  __int64 v131; // rdx
  __int64 v132; // rax
  __int64 n122_14; // rcx
  __int64 v134; // rdx
  __int64 v135; // rax
  __int64 v136; // rdx
  __int64 n122_15; // rcx
  __int64 v138; // rax
  __int64 n122_16; // rcx
  __int64 v140; // rdx
  __int64 v141; // rax
  __int64 n122_17; // rcx
  __int64 v143; // rdx
  __int64 v144; // rax
  __int64 n122_18; // rcx
  __int64 v146; // rdx
  __int64 v147; // rax
  __int64 n122_19; // rcx
  __int64 v149; // r8
  __int64 n122_20; // rcx
  __int64 v151; // r8
  __int64 v152; // rax
  __int64 n122_21; // rcx
  __int64 v154; // r8
  __int64 v155; // rax
  __int64 n122_22; // rcx
  __int64 v157; // r8
  __int64 v158; // rax
  __int64 v159; // r8
  __int64 n122_23; // rcx
  __int64 v161; // rax
  __int64 n122_24; // rcx
  __int64 v163; // r8
  __int64 v164; // rax
  __int64 n122_25; // rcx
  __int64 v166; // r8
  __int64 v167; // rax
  __int64 n122_26; // rcx
  __int64 v169; // r8
  __int64 v170; // rax
  __int64 n122_27; // rcx
  __int64 v172; // r8
  __int64 v173; // rax
  __int64 n122_28; // rcx
  __int64 v175; // r8
  __int64 v176; // rax
  __int64 n122_29; // rcx
  __int64 v178; // r8
  __int64 v179; // rax
  __int64 n122_30; // rcx
  __int64 v181; // r8
  __int64 v182; // rax
  __int64 n122_31; // rcx
  __int64 v184; // r8
  __int64 v185; // rax
  __int64 n122_32; // rcx
  __int64 v187; // r8
  __int64 v188; // rax
  __int64 n122_33; // rcx
  __int64 v190; // r8
  __int64 v191; // rax
  __int64 n122_34; // rcx
  __int64 v193; // r8

  n123 = *a2;
  if ( (_BYTE)n123 == 123 )
  {
    n90 = a2[1];
    if ( (char)n90 <= 122 )
    {
      if ( (char)n90 < 97 )
      {
        if ( (char)n90 > 90 )
        {
          goto LABEL_263;
        }
        if ( (char)n90 < 65 )
        {
          if ( (unsigned __int8)(n90 - 48) > 9u )
          {
            goto LABEL_263;
          }
          v6 = n90 - 48;
        }
        else
        {
          v6 = n90 - 55;
        }
      }
      else
      {
        v6 = n90 - 87;
      }
      n90_1 = a2[2];
      v8 = v6 << 28;
      if ( (char)n90_1 <= 122 )
      {
        if ( (char)n90_1 < 97 )
        {
          if ( (char)n90_1 > 90 )
          {
            goto LABEL_263;
          }
          if ( (char)n90_1 < 65 )
          {
            if ( (unsigned __int8)(n90_1 - 48) > 9u )
            {
              goto LABEL_263;
            }
            v9 = n90_1 - 48;
          }
          else
          {
            v9 = n90_1 - 55;
          }
        }
        else
        {
          v9 = n90_1 - 87;
        }
        n90_2 = a2[3];
        v11 = v8 | (v9 << 24);
        if ( (char)n90_2 <= 122 )
        {
          if ( (char)n90_2 < 97 )
          {
            if ( (char)n90_2 > 90 )
            {
              goto LABEL_263;
            }
            if ( (char)n90_2 < 65 )
            {
              if ( (unsigned __int8)(n90_2 - 48) > 9u )
              {
                goto LABEL_263;
              }
              v12 = n90_2 - 48;
            }
            else
            {
              v12 = n90_2 - 55;
            }
          }
          else
          {
            v12 = n90_2 - 87;
          }
          v13 = v11 | (v12 << 20);
          n90_3 = a2[4];
          if ( (char)n90_3 <= 122 )
          {
            if ( (char)n90_3 < 97 )
            {
              if ( (char)n90_3 > 90 )
              {
                goto LABEL_263;
              }
              if ( (char)n90_3 < 65 )
              {
                if ( (unsigned __int8)(n90_3 - 48) > 9u )
                {
                  goto LABEL_263;
                }
                v15 = n90_3 - 48;
              }
              else
              {
                v15 = n90_3 - 55;
              }
            }
            else
            {
              v15 = n90_3 - 87;
            }
            n90_4 = a2[5];
            v17 = v13 | (v15 << 16);
            if ( (char)n90_4 <= 122 )
            {
              if ( (char)n90_4 < 97 )
              {
                if ( (char)n90_4 > 90 )
                {
                  goto LABEL_263;
                }
                if ( (char)n90_4 < 65 )
                {
                  if ( (unsigned __int8)(n90_4 - 48) > 9u )
                  {
                    goto LABEL_263;
                  }
                  v18 = n90_4 - 48;
                }
                else
                {
                  v18 = n90_4 - 55;
                }
              }
              else
              {
                v18 = n90_4 - 87;
              }
              n90_5 = a2[6];
              v20 = (v18 << 12) | v17;
              if ( (char)n90_5 <= 122 )
              {
                if ( (char)n90_5 < 97 )
                {
                  if ( (char)n90_5 > 90 )
                  {
                    goto LABEL_263;
                  }
                  if ( (char)n90_5 < 65 )
                  {
                    if ( (unsigned __int8)(n90_5 - 48) > 9u )
                    {
                      goto LABEL_263;
                    }
                    v21 = n90_5 - 48;
                  }
                  else
                  {
                    v21 = n90_5 - 55;
                  }
                }
                else
                {
                  v21 = n90_5 - 87;
                }
                n90_6 = a2[7];
                v23 = (v21 << 8) | v20;
                if ( (char)n90_6 <= 122 )
                {
                  if ( (char)n90_6 < 97 )
                  {
                    if ( (char)n90_6 > 90 )
                    {
                      goto LABEL_263;
                    }
                    if ( (char)n90_6 < 65 )
                    {
                      if ( (unsigned __int8)(n90_6 - 48) > 9u )
                      {
                        goto LABEL_263;
                      }
                      v24 = n90_6 - 48;
                    }
                    else
                    {
                      v24 = n90_6 - 55;
                    }
                  }
                  else
                  {
                    v24 = n90_6 - 87;
                  }
                  n90_7 = a2[8];
                  v26 = (16 * v24) | v23;
                  if ( (char)n90_7 <= 122 )
                  {
                    if ( (char)n90_7 < 97 )
                    {
                      if ( (char)n90_7 > 90 )
                      {
                        goto LABEL_263;
                      }
                      if ( (char)n90_7 < 65 )
                      {
                        if ( (unsigned __int8)(n90_7 - 48) > 9u )
                        {
                          goto LABEL_263;
                        }
                        v27 = n90_7 - 48;
                      }
                      else
                      {
                        v27 = n90_7 - 55;
                      }
                    }
                    else
                    {
                      v27 = n90_7 - 87;
                    }
                    v28 = v27 | v26;
                    if ( a2[9] != 45 )
                    {
                      goto LABEL_263;
                    }
                    n122 = a2[10];
                    if ( (char)n122 > 122 )
                    {
                      goto LABEL_263;
                    }
                    if ( (char)n122 < 97 )
                    {
                      if ( (char)n122 > 90 )
                      {
                        goto LABEL_263;
                      }
                      if ( (char)n122 < 65 )
                      {
                        if ( (unsigned __int8)(n122 - 48) > 9u )
                        {
                          goto LABEL_263;
                        }
                        v30 = n122 - 48;
                      }
                      else
                      {
                        v30 = n122 - 55;
                      }
                    }
                    else
                    {
                      v30 = n122 - 87;
                    }
                    n90_8 = a2[11];
                    v32 = (v30 << 44) | v28;
                    if ( (char)n90_8 <= 122 )
                    {
                      if ( (char)n90_8 < 97 )
                      {
                        if ( (char)n90_8 > 90 )
                        {
                          goto LABEL_263;
                        }
                        if ( (char)n90_8 < 65 )
                        {
                          if ( (unsigned __int8)(n90_8 - 48) > 9u )
                          {
                            goto LABEL_263;
                          }
                          v33 = n90_8 - 48;
                        }
                        else
                        {
                          v33 = n90_8 - 55;
                        }
                      }
                      else
                      {
                        v33 = n90_8 - 87;
                      }
                      n90_9 = a2[12];
                      v35 = (v33 << 40) | v32;
                      if ( (char)n90_9 <= 122 )
                      {
                        if ( (char)n90_9 < 97 )
                        {
                          if ( (char)n90_9 > 90 )
                          {
                            goto LABEL_263;
                          }
                          if ( (char)n90_9 < 65 )
                          {
                            if ( (unsigned __int8)(n90_9 - 48) > 9u )
                            {
                              goto LABEL_263;
                            }
                            v36 = n90_9 - 48;
                          }
                          else
                          {
                            v36 = n90_9 - 55;
                          }
                        }
                        else
                        {
                          v36 = n90_9 - 87;
                        }
                        n90_10 = a2[13];
                        v38 = (v36 << 36) | v35;
                        if ( (char)n90_10 <= 122 )
                        {
                          if ( (char)n90_10 < 97 )
                          {
                            if ( (char)n90_10 > 90 )
                            {
                              goto LABEL_263;
                            }
                            if ( (char)n90_10 < 65 )
                            {
                              if ( (unsigned __int8)(n90_10 - 48) > 9u )
                              {
                                goto LABEL_263;
                              }
                              v39 = n90_10 - 48;
                            }
                            else
                            {
                              v39 = n90_10 - 55;
                            }
                          }
                          else
                          {
                            v39 = n90_10 - 87;
                          }
                          v40 = (v39 << 32) | v38;
                          if ( a2[14] != 45 )
                          {
                            goto LABEL_263;
                          }
                          n122_1 = a2[15];
                          if ( (char)n122_1 > 122 )
                          {
                            goto LABEL_263;
                          }
                          if ( (char)n122_1 < 97 )
                          {
                            if ( (char)n122_1 > 90 )
                            {
                              goto LABEL_263;
                            }
                            if ( (char)n122_1 < 65 )
                            {
                              if ( (unsigned __int8)(n122_1 - 48) > 9u )
                              {
                                goto LABEL_263;
                              }
                              v42 = a2[15];
                            }
                            else
                            {
                              v42 = n122_1 - 7;
                            }
                          }
                          else
                          {
                            v42 = n122_1 - 7;
                          }
                          n90_11 = a2[16];
                          v44 = (v42 << 60) | v40;
                          if ( (char)n90_11 <= 122 )
                          {
                            if ( (char)n90_11 < 97 )
                            {
                              if ( (char)n90_11 > 90 )
                              {
                                goto LABEL_263;
                              }
                              if ( (char)n90_11 < 65 )
                              {
                                if ( (unsigned __int8)(n90_11 - 48) > 9u )
                                {
                                  goto LABEL_263;
                                }
                                v45 = n90_11 - 48;
                              }
                              else
                              {
                                v45 = n90_11 - 55;
                              }
                            }
                            else
                            {
                              v45 = n90_11 - 87;
                            }
                            n90_12 = a2[17];
                            v47 = (v45 << 56) | v44;
                            if ( (char)n90_12 <= 122 )
                            {
                              if ( (char)n90_12 < 97 )
                              {
                                if ( (char)n90_12 > 90 )
                                {
                                  goto LABEL_263;
                                }
                                if ( (char)n90_12 < 65 )
                                {
                                  if ( (unsigned __int8)(n90_12 - 48) > 9u )
                                  {
                                    goto LABEL_263;
                                  }
                                  v48 = n90_12 - 48;
                                }
                                else
                                {
                                  v48 = n90_12 - 55;
                                }
                              }
                              else
                              {
                                v48 = n90_12 - 87;
                              }
                              n90_13 = a2[18];
                              v50 = (v48 << 52) | v47;
                              if ( (char)n90_13 <= 122 )
                              {
                                if ( (char)n90_13 < 97 )
                                {
                                  if ( (char)n90_13 > 90 )
                                  {
                                    goto LABEL_263;
                                  }
                                  if ( (char)n90_13 < 65 )
                                  {
                                    if ( (unsigned __int8)(n90_13 - 48) > 9u )
                                    {
                                      goto LABEL_263;
                                    }
                                    v51 = n90_13 - 48;
                                  }
                                  else
                                  {
                                    v51 = n90_13 - 55;
                                  }
                                }
                                else
                                {
                                  v51 = n90_13 - 87;
                                }
                                v52 = (v51 << 48) | v50;
                                if ( a2[19] != 45 )
                                {
                                  goto LABEL_263;
                                }
                                n122_2 = a2[20];
                                if ( (char)n122_2 > 122 )
                                {
                                  goto LABEL_263;
                                }
                                if ( (char)n122_2 < 97 )
                                {
                                  if ( (char)n122_2 > 90 )
                                  {
                                    goto LABEL_263;
                                  }
                                  if ( (char)n122_2 < 65 )
                                  {
                                    if ( (unsigned __int8)(n122_2 - 48) > 9u )
                                    {
                                      goto LABEL_263;
                                    }
                                    v54 = n122_2 - 48;
                                  }
                                  else
                                  {
                                    v54 = n122_2 - 55;
                                  }
                                }
                                else
                                {
                                  v54 = n122_2 - 87;
                                }
                                n90_14 = a2[21];
                                v56 = 16 * v54;
                                if ( (char)n90_14 <= 122 )
                                {
                                  if ( (char)n90_14 < 97 )
                                  {
                                    if ( (char)n90_14 > 90 )
                                    {
                                      goto LABEL_263;
                                    }
                                    if ( (char)n90_14 < 65 )
                                    {
                                      if ( (unsigned __int8)(n90_14 - 48) > 9u )
                                      {
                                        goto LABEL_263;
                                      }
                                      v57 = n90_14 - 48;
                                    }
                                    else
                                    {
                                      v57 = n90_14 - 55;
                                    }
                                  }
                                  else
                                  {
                                    v57 = n90_14 - 87;
                                  }
                                  n90_15 = a2[22];
                                  v59 = v57 | v56;
                                  if ( (char)n90_15 <= 122 )
                                  {
                                    if ( (char)n90_15 < 97 )
                                    {
                                      if ( (char)n90_15 > 90 )
                                      {
                                        goto LABEL_263;
                                      }
                                      if ( (char)n90_15 < 65 )
                                      {
                                        if ( (unsigned __int8)(n90_15 - 48) > 9u )
                                        {
                                          goto LABEL_263;
                                        }
                                        v60 = n90_15 - 48;
                                      }
                                      else
                                      {
                                        v60 = n90_15 - 55;
                                      }
                                    }
                                    else
                                    {
                                      v60 = n90_15 - 87;
                                    }
                                    v61 = v59 | (v60 << 12);
                                    n90_16 = a2[23];
                                    if ( (char)n90_16 <= 122 )
                                    {
                                      if ( (char)n90_16 < 97 )
                                      {
                                        if ( (char)n90_16 > 90 )
                                        {
                                          goto LABEL_263;
                                        }
                                        if ( (char)n90_16 < 65 )
                                        {
                                          if ( (unsigned __int8)(n90_16 - 48) > 9u )
                                          {
                                            goto LABEL_263;
                                          }
                                          v63 = n90_16 - 48;
                                        }
                                        else
                                        {
                                          v63 = n90_16 - 55;
                                        }
                                      }
                                      else
                                      {
                                        v63 = n90_16 - 87;
                                      }
                                      v64 = v61 | (v63 << 8);
                                      if ( a2[24] != 45 )
                                      {
                                        goto LABEL_263;
                                      }
                                      n122_3 = a2[25];
                                      if ( (char)n122_3 > 122 )
                                      {
                                        goto LABEL_263;
                                      }
                                      if ( (char)n122_3 < 97 )
                                      {
                                        if ( (char)n122_3 > 90 )
                                        {
                                          goto LABEL_263;
                                        }
                                        if ( (char)n122_3 < 65 )
                                        {
                                          if ( (unsigned __int8)(n122_3 - 48) > 9u )
                                          {
                                            goto LABEL_263;
                                          }
                                          v66 = n122_3 - 48;
                                        }
                                        else
                                        {
                                          v66 = n122_3 - 55;
                                        }
                                      }
                                      else
                                      {
                                        v66 = n122_3 - 87;
                                      }
                                      v67 = v64 | (v66 << 20);
                                      n90_17 = a2[26];
                                      if ( (char)n90_17 <= 122 )
                                      {
                                        if ( (char)n90_17 < 97 )
                                        {
                                          if ( (char)n90_17 > 90 )
                                          {
                                            goto LABEL_263;
                                          }
                                          if ( (char)n90_17 < 65 )
                                          {
                                            if ( (unsigned __int8)(n90_17 - 48) > 9u )
                                            {
                                              goto LABEL_263;
                                            }
                                            v69 = n90_17 - 48;
                                          }
                                          else
                                          {
                                            v69 = n90_17 - 55;
                                          }
                                        }
                                        else
                                        {
                                          v69 = n90_17 - 87;
                                        }
                                        v70 = v67 | (v69 << 16);
                                        n90_18 = a2[27];
                                        if ( (char)n90_18 <= 122 )
                                        {
                                          if ( (char)n90_18 < 97 )
                                          {
                                            if ( (char)n90_18 > 90 )
                                            {
                                              goto LABEL_263;
                                            }
                                            if ( (char)n90_18 < 65 )
                                            {
                                              if ( (unsigned __int8)(n90_18 - 48) > 9u )
                                              {
                                                goto LABEL_263;
                                              }
                                              v72 = n90_18 - 48;
                                            }
                                            else
                                            {
                                              v72 = n90_18 - 55;
                                            }
                                          }
                                          else
                                          {
                                            v72 = n90_18 - 87;
                                          }
                                          v73 = v70 | (v72 << 28);
                                          n90_19 = a2[28];
                                          if ( (char)n90_19 <= 122 )
                                          {
                                            if ( (char)n90_19 < 97 )
                                            {
                                              if ( (char)n90_19 > 90 )
                                              {
                                                goto LABEL_263;
                                              }
                                              if ( (char)n90_19 < 65 )
                                              {
                                                if ( (unsigned __int8)(n90_19 - 48) > 9u )
                                                {
                                                  goto LABEL_263;
                                                }
                                                v75 = n90_19 - 48;
                                              }
                                              else
                                              {
                                                v75 = n90_19 - 55;
                                              }
                                            }
                                            else
                                            {
                                              v75 = n90_19 - 87;
                                            }
                                            v76 = v73 | (v75 << 24);
                                            n90_20 = a2[29];
                                            if ( (char)n90_20 <= 122 )
                                            {
                                              if ( (char)n90_20 < 97 )
                                              {
                                                if ( (char)n90_20 > 90 )
                                                {
                                                  goto LABEL_263;
                                                }
                                                if ( (char)n90_20 < 65 )
                                                {
                                                  if ( (unsigned __int8)(n90_20 - 48) > 9u )
                                                  {
                                                    goto LABEL_263;
                                                  }
                                                  v78 = n90_20 - 48;
                                                }
                                                else
                                                {
                                                  v78 = n90_20 - 55;
                                                }
                                              }
                                              else
                                              {
                                                v78 = n90_20 - 87;
                                              }
                                              v79 = v76 | (v78 << 36);
                                              n90_21 = a2[30];
                                              if ( (char)n90_21 <= 122 )
                                              {
                                                if ( (char)n90_21 < 97 )
                                                {
                                                  if ( (char)n90_21 > 90 )
                                                  {
                                                    goto LABEL_263;
                                                  }
                                                  if ( (char)n90_21 < 65 )
                                                  {
                                                    if ( (unsigned __int8)(n90_21 - 48) > 9u )
                                                    {
                                                      goto LABEL_263;
                                                    }
                                                    v81 = n90_21 - 48;
                                                  }
                                                  else
                                                  {
                                                    v81 = n90_21 - 55;
                                                  }
                                                }
                                                else
                                                {
                                                  v81 = n90_21 - 87;
                                                }
                                                v82 = v79 | (v81 << 32);
                                                n90_22 = a2[31];
                                                if ( (char)n90_22 <= 122 )
                                                {
                                                  if ( (char)n90_22 < 97 )
                                                  {
                                                    if ( (char)n90_22 > 90 )
                                                    {
                                                      goto LABEL_263;
                                                    }
                                                    if ( (char)n90_22 < 65 )
                                                    {
                                                      if ( (unsigned __int8)(n90_22 - 48) > 9u )
                                                      {
                                                        goto LABEL_263;
                                                      }
                                                      v84 = n90_22 - 48;
                                                    }
                                                    else
                                                    {
                                                      v84 = n90_22 - 55;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v84 = n90_22 - 87;
                                                  }
                                                  v85 = v82 | (v84 << 44);
                                                  n90_23 = a2[32];
                                                  if ( (char)n90_23 <= 122 )
                                                  {
                                                    if ( (char)n90_23 < 97 )
                                                    {
                                                      if ( (char)n90_23 > 90 )
                                                      {
                                                        goto LABEL_263;
                                                      }
                                                      if ( (char)n90_23 < 65 )
                                                      {
                                                        if ( (unsigned __int8)(n90_23 - 48) > 9u )
                                                        {
                                                          goto LABEL_263;
                                                        }
                                                        v87 = n90_23 - 48;
                                                      }
                                                      else
                                                      {
                                                        v87 = n90_23 - 55;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v87 = n90_23 - 87;
                                                    }
                                                    v88 = v85 | (v87 << 40);
                                                    n90_24 = a2[33];
                                                    if ( (char)n90_24 <= 122 )
                                                    {
                                                      if ( (char)n90_24 < 97 )
                                                      {
                                                        if ( (char)n90_24 > 90 )
                                                        {
                                                          goto LABEL_263;
                                                        }
                                                        if ( (char)n90_24 < 65 )
                                                        {
                                                          if ( (unsigned __int8)(n90_24 - 48) > 9u )
                                                          {
                                                            goto LABEL_263;
                                                          }
                                                          v90 = n90_24 - 48;
                                                        }
                                                        else
                                                        {
                                                          v90 = n90_24 - 55;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v90 = n90_24 - 87;
                                                      }
                                                      n90_25 = a2[34];
                                                      v92 = (v90 << 52) | v88;
                                                      if ( (char)n90_25 <= 122 )
                                                      {
                                                        if ( (char)n90_25 < 97 )
                                                        {
                                                          if ( (char)n90_25 > 90 )
                                                          {
                                                            goto LABEL_263;
                                                          }
                                                          if ( (char)n90_25 < 65 )
                                                          {
                                                            if ( (unsigned __int8)(n90_25 - 48) > 9u )
                                                            {
                                                              goto LABEL_263;
                                                            }
                                                            v93 = n90_25 - 48;
                                                          }
                                                          else
                                                          {
                                                            v93 = n90_25 - 55;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          v93 = n90_25 - 87;
                                                        }
                                                        n90_26 = a2[35];
                                                        v95 = (v93 << 48) | v92;
                                                        if ( (char)n90_26 <= 122 )
                                                        {
                                                          if ( (char)n90_26 < 97 )
                                                          {
                                                            if ( (char)n90_26 > 90 )
                                                            {
                                                              goto LABEL_263;
                                                            }
                                                            if ( (char)n90_26 < 65 )
                                                            {
                                                              if ( (unsigned __int8)(n90_26 - 48) > 9u )
                                                              {
                                                                goto LABEL_263;
                                                              }
                                                              v96 = a2[35];
                                                            }
                                                            else
                                                            {
                                                              v96 = n90_26 - 7;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            v96 = n90_26 - 7;
                                                          }
                                                          n97 = a2[36];
                                                          v98 = (v96 << 60) | v95;
                                                          if ( (char)n97 <= 122 )
                                                          {
                                                            if ( (char)n97 >= 97 )
                                                            {
                                                              v99 = n97 - 87;
                                                              goto LABEL_262;
                                                            }
                                                            if ( (char)n97 <= 90 )
                                                            {
                                                              if ( (char)n97 >= 65 )
                                                              {
                                                                v99 = n97 - 55;
                                                                goto LABEL_262;
                                                              }
                                                              if ( (unsigned __int8)(n97 - 48) <= 9u )
                                                              {
                                                                v99 = n97 - 48;
LABEL_262:
                                                                v100 = (v99 << 56) | v98;
                                                                if ( a2[37] != 125 )
                                                                {
                                                                  goto LABEL_263;
                                                                }
                                                                goto LABEL_524;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_263:
    *a1 = 0;
    a1[1] = 0;
    return a1;
  }
  if ( (char)n123 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n123 < 97 )
  {
    if ( (char)n123 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n123 < 65 )
    {
      if ( (unsigned __int8)(n123 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v102 = *a2;
    }
    else
    {
      v102 = n123 - 7;
    }
  }
  else
  {
    v102 = n123 - 7;
  }
  n122_4 = a2[1];
  v104 = v102 << 60;
  if ( (char)n122_4 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_4 < 97 )
  {
    if ( (char)n122_4 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_4 < 65 )
    {
      if ( (unsigned __int8)(n122_4 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v105 = n122_4 - 48;
    }
    else
    {
      v105 = n122_4 - 55;
    }
  }
  else
  {
    v105 = n122_4 - 87;
  }
  n122_5 = a2[2];
  v107 = (v105 << 56) | v104;
  if ( (char)n122_5 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_5 < 97 )
  {
    if ( (char)n122_5 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_5 < 65 )
    {
      if ( (unsigned __int8)(n122_5 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v108 = n122_5 - 48;
    }
    else
    {
      v108 = n122_5 - 55;
    }
  }
  else
  {
    v108 = n122_5 - 87;
  }
  n122_6 = a2[3];
  v110 = (v108 << 52) | v107;
  if ( (char)n122_6 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_6 < 97 )
  {
    if ( (char)n122_6 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_6 < 65 )
    {
      if ( (unsigned __int8)(n122_6 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v111 = n122_6 - 48;
    }
    else
    {
      v111 = n122_6 - 55;
    }
  }
  else
  {
    v111 = n122_6 - 87;
  }
  n122_7 = a2[4];
  v113 = (v111 << 48) | v110;
  if ( (char)n122_7 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_7 < 97 )
  {
    if ( (char)n122_7 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_7 < 65 )
    {
      if ( (unsigned __int8)(n122_7 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v114 = n122_7 - 48;
    }
    else
    {
      v114 = n122_7 - 55;
    }
  }
  else
  {
    v114 = n122_7 - 87;
  }
  n122_8 = a2[5];
  v116 = (v114 << 44) | v113;
  if ( (char)n122_8 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_8 < 97 )
  {
    if ( (char)n122_8 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_8 < 65 )
    {
      if ( (unsigned __int8)(n122_8 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v117 = n122_8 - 48;
    }
    else
    {
      v117 = n122_8 - 55;
    }
  }
  else
  {
    v117 = n122_8 - 87;
  }
  n122_9 = a2[6];
  v119 = (v117 << 40) | v116;
  if ( (char)n122_9 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_9 < 97 )
  {
    if ( (char)n122_9 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_9 < 65 )
    {
      if ( (unsigned __int8)(n122_9 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v120 = n122_9 - 48;
    }
    else
    {
      v120 = n122_9 - 55;
    }
  }
  else
  {
    v120 = n122_9 - 87;
  }
  n122_10 = a2[7];
  v122 = (v120 << 36) | v119;
  if ( (char)n122_10 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_10 < 97 )
  {
    if ( (char)n122_10 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_10 < 65 )
    {
      if ( (unsigned __int8)(n122_10 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v123 = n122_10 - 48;
    }
    else
    {
      v123 = n122_10 - 55;
    }
  }
  else
  {
    v123 = n122_10 - 87;
  }
  v124 = (v123 << 32) | v122;
  if ( a2[8] != 45 )
  {
    goto LABEL_263;
  }
  n122_11 = a2[9];
  if ( (char)n122_11 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_11 < 97 )
  {
    if ( (char)n122_11 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_11 < 65 )
    {
      if ( (unsigned __int8)(n122_11 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v126 = n122_11 - 48;
    }
    else
    {
      v126 = n122_11 - 55;
    }
  }
  else
  {
    v126 = n122_11 - 87;
  }
  n122_12 = a2[10];
  v128 = (v126 << 28) | v124;
  if ( (char)n122_12 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_12 < 97 )
  {
    if ( (char)n122_12 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_12 < 65 )
    {
      if ( (unsigned __int8)(n122_12 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v129 = n122_12 - 48;
    }
    else
    {
      v129 = n122_12 - 55;
    }
  }
  else
  {
    v129 = n122_12 - 87;
  }
  n122_13 = a2[11];
  v131 = (v129 << 24) | v128;
  if ( (char)n122_13 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_13 < 97 )
  {
    if ( (char)n122_13 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_13 < 65 )
    {
      if ( (unsigned __int8)(n122_13 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v132 = n122_13 - 48;
    }
    else
    {
      v132 = n122_13 - 55;
    }
  }
  else
  {
    v132 = n122_13 - 87;
  }
  n122_14 = a2[12];
  v134 = (v132 << 20) | v131;
  if ( (char)n122_14 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_14 < 97 )
  {
    if ( (char)n122_14 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_14 < 65 )
    {
      if ( (unsigned __int8)(n122_14 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v135 = n122_14 - 48;
    }
    else
    {
      v135 = n122_14 - 55;
    }
  }
  else
  {
    v135 = n122_14 - 87;
  }
  v136 = (v135 << 16) | v134;
  if ( a2[13] != 45 )
  {
    goto LABEL_263;
  }
  n122_15 = a2[14];
  if ( (char)n122_15 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_15 < 97 )
  {
    if ( (char)n122_15 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_15 < 65 )
    {
      if ( (unsigned __int8)(n122_15 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v138 = n122_15 - 48;
    }
    else
    {
      v138 = n122_15 - 55;
    }
  }
  else
  {
    v138 = n122_15 - 87;
  }
  n122_16 = a2[15];
  v140 = (v138 << 12) | v136;
  if ( (char)n122_16 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_16 < 97 )
  {
    if ( (char)n122_16 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_16 < 65 )
    {
      if ( (unsigned __int8)(n122_16 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v141 = n122_16 - 48;
    }
    else
    {
      v141 = n122_16 - 55;
    }
  }
  else
  {
    v141 = n122_16 - 87;
  }
  n122_17 = a2[16];
  v143 = (v141 << 8) | v140;
  if ( (char)n122_17 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_17 < 97 )
  {
    if ( (char)n122_17 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_17 < 65 )
    {
      if ( (unsigned __int8)(n122_17 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v144 = n122_17 - 48;
    }
    else
    {
      v144 = n122_17 - 55;
    }
  }
  else
  {
    v144 = n122_17 - 87;
  }
  n122_18 = a2[17];
  v146 = (16 * v144) | v143;
  if ( (char)n122_18 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_18 < 97 )
  {
    if ( (char)n122_18 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_18 < 65 )
    {
      if ( (unsigned __int8)(n122_18 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v147 = n122_18 - 48;
    }
    else
    {
      v147 = n122_18 - 55;
    }
  }
  else
  {
    v147 = n122_18 - 87;
  }
  v52 = v147 | v146;
  if ( a2[18] != 45 )
  {
    goto LABEL_263;
  }
  n122_19 = a2[19];
  if ( (char)n122_19 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_19 < 97 )
  {
    if ( (char)n122_19 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_19 < 65 )
    {
      if ( (unsigned __int8)(n122_19 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v149 = a2[19];
    }
    else
    {
      v149 = n122_19 - 7;
    }
  }
  else
  {
    v149 = n122_19 - 7;
  }
  n122_20 = a2[20];
  v151 = v149 << 60;
  if ( (char)n122_20 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_20 < 97 )
  {
    if ( (char)n122_20 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_20 < 65 )
    {
      if ( (unsigned __int8)(n122_20 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v152 = n122_20 - 48;
    }
    else
    {
      v152 = n122_20 - 55;
    }
  }
  else
  {
    v152 = n122_20 - 87;
  }
  n122_21 = a2[21];
  v154 = (v152 << 56) | v151;
  if ( (char)n122_21 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_21 < 97 )
  {
    if ( (char)n122_21 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_21 < 65 )
    {
      if ( (unsigned __int8)(n122_21 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v155 = n122_21 - 48;
    }
    else
    {
      v155 = n122_21 - 55;
    }
  }
  else
  {
    v155 = n122_21 - 87;
  }
  n122_22 = a2[22];
  v157 = (v155 << 52) | v154;
  if ( (char)n122_22 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_22 < 97 )
  {
    if ( (char)n122_22 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_22 < 65 )
    {
      if ( (unsigned __int8)(n122_22 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v158 = n122_22 - 48;
    }
    else
    {
      v158 = n122_22 - 55;
    }
  }
  else
  {
    v158 = n122_22 - 87;
  }
  v159 = (v158 << 48) | v157;
  if ( a2[23] != 45 )
  {
    goto LABEL_263;
  }
  n122_23 = a2[24];
  if ( (char)n122_23 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_23 < 97 )
  {
    if ( (char)n122_23 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_23 < 65 )
    {
      if ( (unsigned __int8)(n122_23 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v161 = n122_23 - 48;
    }
    else
    {
      v161 = n122_23 - 55;
    }
  }
  else
  {
    v161 = n122_23 - 87;
  }
  n122_24 = a2[25];
  v163 = (v161 << 44) | v159;
  if ( (char)n122_24 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_24 < 97 )
  {
    if ( (char)n122_24 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_24 < 65 )
    {
      if ( (unsigned __int8)(n122_24 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v164 = n122_24 - 48;
    }
    else
    {
      v164 = n122_24 - 55;
    }
  }
  else
  {
    v164 = n122_24 - 87;
  }
  n122_25 = a2[26];
  v166 = (v164 << 40) | v163;
  if ( (char)n122_25 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_25 < 97 )
  {
    if ( (char)n122_25 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_25 < 65 )
    {
      if ( (unsigned __int8)(n122_25 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v167 = n122_25 - 48;
    }
    else
    {
      v167 = n122_25 - 55;
    }
  }
  else
  {
    v167 = n122_25 - 87;
  }
  n122_26 = a2[27];
  v169 = (v167 << 36) | v166;
  if ( (char)n122_26 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_26 < 97 )
  {
    if ( (char)n122_26 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_26 < 65 )
    {
      if ( (unsigned __int8)(n122_26 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v170 = n122_26 - 48;
    }
    else
    {
      v170 = n122_26 - 55;
    }
  }
  else
  {
    v170 = n122_26 - 87;
  }
  n122_27 = a2[28];
  v172 = (v170 << 32) | v169;
  if ( (char)n122_27 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_27 < 97 )
  {
    if ( (char)n122_27 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_27 < 65 )
    {
      if ( (unsigned __int8)(n122_27 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v173 = n122_27 - 48;
    }
    else
    {
      v173 = n122_27 - 55;
    }
  }
  else
  {
    v173 = n122_27 - 87;
  }
  n122_28 = a2[29];
  v175 = (v173 << 28) | v172;
  if ( (char)n122_28 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_28 < 97 )
  {
    if ( (char)n122_28 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_28 < 65 )
    {
      if ( (unsigned __int8)(n122_28 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v176 = n122_28 - 48;
    }
    else
    {
      v176 = n122_28 - 55;
    }
  }
  else
  {
    v176 = n122_28 - 87;
  }
  n122_29 = a2[30];
  v178 = (v176 << 24) | v175;
  if ( (char)n122_29 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_29 < 97 )
  {
    if ( (char)n122_29 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_29 < 65 )
    {
      if ( (unsigned __int8)(n122_29 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v179 = n122_29 - 48;
    }
    else
    {
      v179 = n122_29 - 55;
    }
  }
  else
  {
    v179 = n122_29 - 87;
  }
  n122_30 = a2[31];
  v181 = (v179 << 20) | v178;
  if ( (char)n122_30 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_30 < 97 )
  {
    if ( (char)n122_30 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_30 < 65 )
    {
      if ( (unsigned __int8)(n122_30 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v182 = n122_30 - 48;
    }
    else
    {
      v182 = n122_30 - 55;
    }
  }
  else
  {
    v182 = n122_30 - 87;
  }
  n122_31 = a2[32];
  v184 = (v182 << 16) | v181;
  if ( (char)n122_31 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_31 < 97 )
  {
    if ( (char)n122_31 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_31 < 65 )
    {
      if ( (unsigned __int8)(n122_31 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v185 = n122_31 - 48;
    }
    else
    {
      v185 = n122_31 - 55;
    }
  }
  else
  {
    v185 = n122_31 - 87;
  }
  n122_32 = a2[33];
  v187 = (v185 << 12) | v184;
  if ( (char)n122_32 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_32 < 97 )
  {
    if ( (char)n122_32 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_32 < 65 )
    {
      if ( (unsigned __int8)(n122_32 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v188 = n122_32 - 48;
    }
    else
    {
      v188 = n122_32 - 55;
    }
  }
  else
  {
    v188 = n122_32 - 87;
  }
  n122_33 = a2[34];
  v190 = (v188 << 8) | v187;
  if ( (char)n122_33 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_33 < 97 )
  {
    if ( (char)n122_33 > 90 )
    {
      goto LABEL_263;
    }
    if ( (char)n122_33 < 65 )
    {
      if ( (unsigned __int8)(n122_33 - 48) > 9u )
      {
        goto LABEL_263;
      }
      v191 = n122_33 - 48;
    }
    else
    {
      v191 = n122_33 - 55;
    }
  }
  else
  {
    v191 = n122_33 - 87;
  }
  n122_34 = a2[35];
  v193 = (16 * v191) | v190;
  if ( (char)n122_34 > 122 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_34 >= 97 )
  {
    *a1 = v52;
    result = a1;
    a1[1] = v193 | (n122_34 - 87);
    return result;
  }
  if ( (char)n122_34 > 90 )
  {
    goto LABEL_263;
  }
  if ( (char)n122_34 >= 65 )
  {
    *a1 = v52;
    result = a1;
    a1[1] = v193 | (n122_34 - 55);
    return result;
  }
  if ( (unsigned __int8)(n122_34 - 48) > 9u )
  {
    goto LABEL_263;
  }
  v100 = v193 | (n122_34 - 48);
LABEL_524:
  *a1 = v52;
  result = a1;
  a1[1] = v100;
  return result;
}

// --- End Function: sub_1402BA020 (0x1402BA020) ---

// --- Function: LogTraceConditional (0x1402BED30) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
__int64 LogTraceConditional(const char *format_string, ...)
{
  __int64 result; // rax
  va_list varargs; // [rsp+38h] [rbp+10h] BYREF

  va_start(varargs, format_string);
  if ( qword_14981D3D8 && Parameter_3 )
  {
    if ( qword_14981D2D0 )
    {
      return (*(__int64 (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_14981D2D0 + 8LL))(
               qword_14981D2D0,
               3,
               format_string,
               (__int64 *)varargs);
    }
  }
  return result;
}

// --- End Function: LogTraceConditional (0x1402BED30) ---

// --- Function: sub_1402C23C0 (0x1402C23C0) ---
__int64 __fastcall sub_1402C23C0(__int64 rcx0, __int64 a2)
{
  *(_BYTE *)(rcx0 + 24) = 0;
  *(_QWORD *)(rcx0 + 16) = rcx0 + 24;
  *(_QWORD *)rcx0 = 0LL;
  *(_QWORD *)(rcx0 + 8) = 36LL;
  sub_1402C3E00(
    rcx0,
    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    *(unsigned __int8 *)(a2 + 7),
    *(unsigned __int8 *)(a2 + 6),
    *(unsigned __int8 *)(a2 + 5),
    *(unsigned __int8 *)(a2 + 4),
    HIBYTE(*(_DWORD *)a2),
    (unsigned __int8)BYTE2(*(_DWORD *)a2),
    BYTE1(*(_DWORD *)a2),
    (unsigned __int8)*(_DWORD *)a2,
    *(unsigned __int8 *)(a2 + 15),
    *(unsigned __int8 *)(a2 + 14),
    *(unsigned __int8 *)(a2 + 13),
    *(unsigned __int8 *)(a2 + 12),
    HIBYTE(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)BYTE2(*(_DWORD *)(a2 + 8)),
    BYTE1(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)*(_DWORD *)(a2 + 8));
  return rcx0;
}

// --- End Function: sub_1402C23C0 (0x1402C23C0) ---

// --- Function: sub_1402C3E00 (0x1402C3E00) ---
__int64 sub_1402C3E00(__int64 a1, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  size_t n36; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A2470();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format, 0, va);
  Buffer[4095] = 0;
  n36 = -1;
  do
  {
    ++n36;
  }
  while ( Buffer[n36] );
  sub_1402DC280(a1, Buffer, n36);
  return a1;
}

// --- End Function: sub_1402C3E00 (0x1402C3E00) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 NtCurrentTeb_wrp()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1402C7FC0 (0x1402C7FC0) ---
__int64 __fastcall sub_1402C7FC0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
    {
      break;
    }
    v4 = 0;
    if ( (int)result < 0 )
    {
      v4 = a1;
    }
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402C7FC0 (0x1402C7FC0) ---

// --- Function: sub_1402D09F0 (0x1402D09F0) ---
__int64 __fastcall sub_1402D09F0(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
    {
      break;
    }
    ++a4;
    if ( (a1 & 1) != 0 )
    {
      a3 |= 1 << (a2 - v4);
    }
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D09F0 (0x1402D09F0) ---

// --- Function: sub_1402DC280 (0x1402DC280) ---
__int64 __fastcall sub_1402DC280(__int64 a1, const void *a2, size_t n36)
{
  size_t n36_2; // r8
  const void *v7; // rcx
  _BYTE *v8; // rsi
  size_t n36_1; // rax
  __int64 v10; // rax
  __int64 result; // rax

  n36_2 = *(_QWORD *)(a1 + 8);
  if ( n36 > n36_2 )
  {
    v7 = *(const void **)(a1 + 16);
    v8 = (_BYTE *)(a1 + 24);
    if ( v7 != (const void *)(a1 + 24) )
    {
      qword_149808530 += -1LL - n36_2;
      sub_14739AF10(v7);
    }
    *v8 = 0;
    n36_1 = 36;
    *(_QWORD *)(a1 + 8) = 36;
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)a1 = 0;
    if ( n36 )
    {
      if ( n36 + 1 > 0x25 )
      {
        v10 = sub_14739AFC0(n36 + 1, 0);
        qword_149808530 += n36 + 1;
        v8 = (_BYTE *)v10;
        n36_1 = n36;
      }
      *(_QWORD *)(a1 + 8) = n36_1;
      *(_QWORD *)a1 = n36;
      *(_QWORD *)(a1 + 16) = v8;
      v8[n36] = 0;
    }
  }
  memmove(*(void **)(a1 + 16), a2, n36);
  result = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a1 = n36;
  *(_BYTE *)(n36 + result) = 0;
  return result;
}

// --- End Function: sub_1402DC280 (0x1402DC280) ---

// --- Function: sub_1402DC370 (0x1402DC370) ---
unsigned __int64 __fastcall sub_1402DC370(unsigned __int64 **a1, unsigned __int64 a2, unsigned __int64 buf)
{
  unsigned __int64 *buf_2; // rcx
  unsigned __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int64 *v8; // rdi
  unsigned __int64 *ptr_to_free; // rcx
  signed __int64 v10; // rax
  unsigned __int64 result; // rax
  unsigned __int64 buf_1; // [rsp+40h] [rbp+18h] BYREF

  buf_1 = buf;
  buf_2 = a1[1];
  if ( buf_2 - *a1 >= a2 )
  {
    return sub_1402AB390(*a1, buf_2, &buf_1);
  }
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_20;
  }
  v6 = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( v6 )
    {
      v8 = (unsigned __int64 *)sub_1402A1E30(8 * a2);
    }
    else
    {
      v8 = 0;
    }
    goto LABEL_10;
  }
  if ( v6 + 39 < v6 )
  {
LABEL_20:
    sub_1402DEE40();
  }
  v7 = sub_1402A1E30(v6 + 39);
  if ( !v7 )
  {
    goto LABEL_18;
  }
  v8 = (unsigned __int64 *)((v7 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v8 - 1) = v7;
LABEL_10:
  ptr_to_free = *a1;
  v10 = a1[2] - *a1;
  if ( !v10 )
  {
    goto LABEL_15;
  }
  if ( (unsigned __int64)(8 * v10) >= 0x1000 )
  {
    if ( (unsigned __int64)ptr_to_free - *(ptr_to_free - 1) - 8 <= 0x1F )
    {
      ptr_to_free = (unsigned __int64 *)*(ptr_to_free - 1);
      goto LABEL_14;
    }
LABEL_18:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_14:
  free_memory_wrapper(ptr_to_free);
LABEL_15:
  result = (unsigned __int64)&v8[v6 / 8];
  *a1 = v8;
  a1[1] = &v8[v6 / 8];
  a1[2] = &v8[v6 / 8];
  if ( v8 != &v8[v6 / 8] )
  {
    do
    {
      *v8++ = buf;
    }
    while ( v8 != (unsigned __int64 *)result );
  }
  return result;
}

// --- End Function: sub_1402DC370 (0x1402DC370) ---

// --- Function: sub_1402DC930 (0x1402DC930) ---
__int64 __fastcall sub_1402DC930(unsigned __int64 *a1, const void *a2, size_t Size)
{
  unsigned __int64 *v5; // rsi
  size_t Size_1; // r14
  unsigned __int64 v8; // rbp
  unsigned __int64 n8; // rdx
  unsigned __int64 v10; // rax
  __int64 result; // rax

  if ( Size )
  {
    v5 = (unsigned __int64 *)a1[2];
    Size_1 = *a1;
    v8 = *a1 + Size;
    if ( v8 <= a1[1] )
    {
      memcpy((char *)v5 + Size_1, a2, Size);
      *a1 += Size;
      result = a1[2];
      *(_BYTE *)(*a1 + result) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= v8 )
      {
        n8 = *a1 + Size;
      }
      if ( n8 )
      {
        if ( n8 < 8 )
        {
          n8 = 8;
        }
        sub_1402A1C40((__int64 *)a1, n8);
        memcpy((void *)a1[2], v5, Size_1);
        memcpy((void *)(Size_1 + a1[2]), a2, Size);
        v10 = a1[2];
        *a1 = v8;
        *(_BYTE *)(Size_1 + Size + v10) = 0;
      }
      result = (__int64)(a1 + 3);
      if ( v5 != a1 + 3 )
      {
        qword_149808368 += -1LL - a1[1];
        sub_14739AF10(v5);
      }
    }
  }
  return result;
}

// --- End Function: sub_1402DC930 (0x1402DC930) ---

// --- Function: sub_1402DE090 (0x1402DE090) ---
unsigned __int64 __fastcall sub_1402DE090(unsigned __int64 **a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 *buf; // rbx
  unsigned __int64 v5; // rcx
  unsigned __int64 *v6; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 *buf_2; // rcx
  unsigned __int64 *buf_1; // rdx
  unsigned __int64 *v10; // r11
  unsigned __int64 v11; // r9
  int v12; // r8d
  unsigned __int64 *v13; // r8
  unsigned __int64 **v14; // r10
  unsigned __int64 **v15; // r9
  unsigned __int64 **v16; // r10
  _QWORD *v17; // r9
  unsigned __int64 **v18; // r8
  unsigned __int64 *v19; // r10
  unsigned __int64 **v20; // r9
  unsigned __int64 **v21; // r8

  _BitScanReverse64(&v3, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v3 )
  {
    std::_Xlength_error("invalid hash bucket count");
  }
  buf = a1[1];
  _BitScanReverse64(&v5, (a2 - 1) | 1);
  v6 = (unsigned __int64 *)(1LL << ((unsigned __int8)v5 + 1));
  sub_1402DC370(a1 + 3, 2LL * (_QWORD)v6, (unsigned __int64)buf);
  a1[7] = v6;
  result = (unsigned __int64)v6 - 1;
  a1[6] = (unsigned __int64 *)((char *)v6 - 1);
  buf_2 = (unsigned __int64 *)*a1[1];
  for ( buf_1 = buf_2; buf_1 != buf; buf_2 = buf_1 )
  {
    buf_1 = (unsigned __int64 *)*buf_1;
    result = *((unsigned __int8 *)buf_2 + 19);
    v10 = &a1[3][2
               * ((unsigned __int64)a1[6]
                & (0x100000001B3LL
                 * (result
                  ^ (0x100000001B3LL
                   * (*((unsigned __int8 *)buf_2 + 18)
                    ^ (0x100000001B3LL
                     * (*((unsigned __int8 *)buf_2 + 17)
                      ^ (0x100000001B3LL * (*((unsigned __int8 *)buf_2 + 16) ^ 0xCBF29CE484222325uLL)))))))))];
    v11 = *v10;
    if ( (unsigned __int64 *)*v10 == buf )
    {
      *v10 = (unsigned __int64)buf_2;
      v10[1] = (unsigned __int64)buf_2;
    }
    else
    {
      result = v10[1];
      v12 = *((_DWORD *)buf_2 + 4);
      if ( v12 == *(_DWORD *)(result + 16) )
      {
        v13 = *(unsigned __int64 **)result;
        if ( *(unsigned __int64 **)result != buf_2 )
        {
          v14 = (unsigned __int64 **)buf_2[1];
          *v14 = buf_1;
          v15 = (unsigned __int64 **)buf_1[1];
          *v15 = v13;
          result = v13[1];
          *(_QWORD *)result = buf_2;
          v13[1] = (unsigned __int64)v15;
          buf_1[1] = (unsigned __int64)v14;
          buf_2[1] = result;
        }
        v10[1] = (unsigned __int64)buf_2;
      }
      else if ( v11 == result )
      {
LABEL_12:
        v16 = (unsigned __int64 **)buf_2[1];
        *v16 = buf_1;
        v17 = (_QWORD *)buf_1[1];
        *v17 = result;
        v18 = *(unsigned __int64 ***)(result + 8);
        *v18 = buf_2;
        *(_QWORD *)(result + 8) = v17;
        buf_1[1] = (unsigned __int64)v16;
        buf_2[1] = (unsigned __int64)v18;
        *v10 = (unsigned __int64)buf_2;
      }
      else
      {
        while ( 1 )
        {
          result = *(_QWORD *)(result + 8);
          if ( v12 == *(_DWORD *)(result + 16) )
          {
            break;
          }
          if ( v11 == result )
          {
            goto LABEL_12;
          }
        }
        v19 = *(unsigned __int64 **)result;
        v20 = (unsigned __int64 **)buf_2[1];
        *v20 = buf_1;
        v21 = (unsigned __int64 **)buf_1[1];
        *v21 = v19;
        result = v19[1];
        *(_QWORD *)result = buf_2;
        v19[1] = (unsigned __int64)v21;
        buf_1[1] = (unsigned __int64)v20;
        buf_2[1] = result;
      }
    }
  }
  return result;
}

// --- End Function: sub_1402DE090 (0x1402DE090) ---

// --- Function: sub_1402DE890 (0x1402DE890) ---
__int64 __fastcall sub_1402DE890(__int64 **a1, __int64 a2, __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  _QWORD *v19; // r8
  __int64 v20; // rcx
  _QWORD *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 24) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
    {
      *v4 = a3;
    }
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
    {
      v4[2] = a3;
    }
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 24LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 24) )
      {
        v13 = *(_QWORD **)(v9 + 16);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 16) = *v13;
          if ( !*(_BYTE *)(*v13 + 25LL) )
          {
            *(_QWORD *)(*v13 + 8LL) = v9;
          }
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
            {
              *v14 = v13;
            }
            else
            {
              v14[2] = v13;
            }
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 16LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 25) )
        {
          *(_QWORD *)(v17 + 8) = v15;
        }
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
          {
            v18[2] = v16;
          }
          else
          {
            *v18 = v16;
          }
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 24) )
      {
        v19 = *(_QWORD **)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = v19[2];
          v20 = v19[2];
          if ( !*(_BYTE *)(v20 + 25) )
          {
            *(_QWORD *)(v20 + 8) = v9;
          }
          v19[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v19;
          }
          else
          {
            v21 = *(_QWORD **)(v9 + 8);
            if ( v9 == v21[2] )
            {
              v21[2] = v19;
            }
            else
            {
              *v21 = v19;
            }
          }
          v19[2] = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 25LL) )
        {
          *(_QWORD *)(*v16 + 8LL) = v15;
        }
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
          {
            *v22 = v16;
          }
          else
          {
            v22[2] = v16;
          }
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v11 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 24) = 1;
  return a3;
}

// --- End Function: sub_1402DE890 (0x1402DE890) ---

// --- Function: sub_1402DEC20 (0x1402DEC20) ---
void __fastcall __noreturn sub_1402DEC20(const struct stdext::exception *a1)
{
  if ( std::_Raise_handler )
  {
    std::_Raise_handler(a1);
  }
  (*(void (__fastcall **)(const struct stdext::exception *))(*(_QWORD *)a1 + 16LL))(a1);
  invoke_watson(0LL, 0LL, 0LL, 0, 0LL);
}

// --- End Function: sub_1402DEC20 (0x1402DEC20) ---

// --- Function: sub_1402DEE40 (0x1402DEE40) ---
void __noreturn sub_1402DEE40()
{
  const struct stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (const struct stdext::exception *)sub_1402AF650(v1);
  sub_1402DEC20(v0);
}

// --- End Function: sub_1402DEE40 (0x1402DEE40) ---

// --- Function: unknown_libname_7 (0x1402DEE80) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402DEE80) ---

// --- Function: unknown_libname_10 (0x1402DFC60) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402DFC60) ---

// --- Function: sub_1402DFCB0 (0x1402DFCB0) ---
__int64 __fastcall sub_1402DFCB0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
    {
      break;
    }
    v5 = v4 + 32;
    if ( (unsigned __int8)(v4 - 65) > 0x19u )
    {
      v5 = v4;
    }
    v6 = sub_1402D09F0(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402C7FC0(79764919, 1, (v6 << 25) ^ (unsigned int)((unsigned __int64)(v6 << 24) >> 31) & 0x4C11DB7);
    v8 = sub_1402D09F0(v7 >> 1, 32, v7 << 31, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402DFCB0 (0x1402DFCB0) ---

// --- Function: sub_1402DFE40 (0x1402DFE40) ---
unsigned __int64 __fastcall sub_1402DFE40(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 n0x6400000; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  unsigned __int64 result; // rax

  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_10;
  }
  n0x6400000 = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      return sub_1402A1E30(n0x6400000);
    }
    else
    {
      return 0;
    }
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_10:
    sub_1402DEE40();
  }
  v3 = sub_1402A1E30(n0x6400000 + 39);
  v4 = v3;
  if ( !v3 )
  {
    invalid_parameter_noinfo_noreturn();
  }
  result = (v3 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(result - 8) = v4;
  return result;
}

// --- End Function: sub_1402DFE40 (0x1402DFE40) ---

// --- Function: sub_1402F5120 (0x1402F5120) ---
int sub_1402F5120(FILE *Stream, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A2470();
  return _stdio_common_vfprintf(*v4, Stream, Format, 0LL, va);
}

// --- End Function: sub_1402F5120 (0x1402F5120) ---

// --- Function: sub_1402F8E30 (0x1402F8E30) ---
void *__fastcall sub_1402F8E30(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 n0x6400000; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_9();
  }
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    n0x6400000 = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_1402A1E30(n0x6400000);
    if ( !v9 )
    {
      invalid_parameter_noinfo_noreturn();
    }
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
  {
    n22 = 22;
  }
  if ( n22 + 1 >= 0x1000 )
  {
    n0x6400000 = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
    {
      sub_1402DEE40();
    }
    goto LABEL_6;
  }
  if ( n22 == -1 )
  {
    v10 = 0;
  }
  else
  {
    v10 = (_QWORD *)sub_1402A1E30(n22 + 1);
  }
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402F8E30 (0x1402F8E30) ---

// --- Function: sub_1402FBC20 (0x1402FBC20) ---
__int64 __fastcall sub_1402FBC20(char *i, char *i_8, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  char *i_1; // r15
  __int64 i_2; // rdi
  char *i_8a_1; // r14
  char *ia_1; // rbp
  char *i_3; // rsi
  size_t n8; // r14
  char *i_4; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i_5; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  char *i_8a; // [rsp+30h] [rbp-38h] BYREF
  char *ia; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (i_8 - i) & 0xFFFFFFFFFFFFFFF8uLL;
  i_1 = i_8;
  i_2 = (__int64)i;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( (char *)i_2 != i_1 )
    {
      i_3 = (char *)(i_2 + 8);
      if ( (char *)(i_2 + 8) != i_1 )
      {
        n8 = 8;
        do
        {
          i_4 = i_3;
          v14 = *(_QWORD *)i_3;
          v15 = *(_QWORD *)(*(_QWORD *)i_2 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)i_3 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)i_3 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)i_2 + 80LL) )
          {
            n256 = (__int64)memmove((void *)(i_2 + 8), (const void *)i_2, n8);
            *(_QWORD *)i_2 = v14;
          }
          else
          {
            for ( i_5 = i_3; ; i_4 = i_5 )
            {
              v17 = *((_QWORD *)i_5 - 1);
              i_5 -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                {
                  break;
                }
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                {
                  break;
                }
              }
              *(_QWORD *)i_4 = v17;
            }
            *(_QWORD *)i_4 = v14;
          }
          i_3 += 8;
          n8 += 8LL;
        }
        while ( i_3 != i_1 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FB540((__int64 **)&i_8a, (__int64 *)i_2, (unsigned __int64)i_1);
      i_8a_1 = i_8a;
      ia_1 = ia;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((unsigned __int64)&i_8a[-i_2] & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((i_1 - ia)
                                                                                       & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FBC20(ia, i_1, a3, a4);
        i_1 = i_8a_1;
      }
      else
      {
        sub_1402FBC20((char *)i_2, i_8a, a3, a4);
        i_2 = (__int64)ia_1;
      }
      n256 = (unsigned __int64)&i_1[-i_2] & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
      {
        goto LABEL_7;
      }
    }
    v18 = (__int64)&i_1[-i_2] >> 3;
    v19 = (__int64)&i_1[-i_2] >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)(i_2 + 8 * v19-- - 8);
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)(i_2 + 8 * j);
          v25 = *(_QWORD *)(i_2 + 8 * j - 8);
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)(i_2 + 8 * v22) = *(_QWORD *)(i_2 + 8 * j);
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)(i_2 + 8 * v22) = *(_QWORD *)(i_2 + 8 * v18 - 8);
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)(i_2 + 8 * v27);
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)(i_2 + 8 * v22) = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)(i_2 + 8 * v22) = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (unsigned __int64)&i_1[-i_2] & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(i_1 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)i_2;
        sub_1402FB800(i_2, 0, ((__int64)v30-- - i_2) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8 - i_2) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FBC20 (0x1402FBC20) ---

// --- Function: sub_1402FD110 (0x1402FD110) ---
_QWORD *__fastcall sub_1402FD110(__int64 **a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *(_QWORD *)(a2 + 16) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)sub_1402A1E30(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)sub_1402A1E30(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = *(_BYTE **)(a2 + 8);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( v7[Size_1] );
    sub_1402F8E30(&Src, v7, Size_1);
    v10 = *(_BYTE **)(a2 + 16);
    do
    {
      ++Size;
    }
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A78B0((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
      {
        p_Src = *(__m256 **)Src.m256_f32;
      }
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
    {
      goto LABEL_26;
    }
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
      {
        p_Src_1 = p_Src_2;
      }
      if ( v18[5] > 0xFu )
      {
        Buf1 = (_QWORD *)*Buf1;
      }
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
      {
        break;
      }
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
      {
        std::_Xlength_error("list too long");
      }
      v23 = sub_1402A1E30(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
      {
        v26 = (_QWORD *)*v26;
      }
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
      {
        v26 = (_QWORD *)*v26;
      }
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      free_memory_wrapper(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FD110 (0x1402FD110) ---

// --- Function: sub_1402FD6B0 (0x1402FD6B0) ---
const void *__fastcall sub_1402FD6B0(const void **a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // rcx
  const void *result; // rax

  v6 = *a1;
  if ( v6 )
  {
    if ( (((_BYTE *)a1[2] - (_BYTE *)v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v6 = (_QWORD *)*(v6 - 1);
    }
    free_memory_wrapper(v6);
  }
  *a1 = (const void *)a2;
  a1[1] = (const void *)(a2 + 8 * a3);
  result = (const void *)(a2 + 8 * a4);
  a1[2] = result;
  return result;
}

// --- End Function: sub_1402FD6B0 (0x1402FD6B0) ---

// --- Function: sub_1402FDA00 (0x1402FDA00) ---
bool __fastcall sub_1402FDA00(__int64 a1, _QWORD *a2, __int64 *a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  __int64 v11; // r10
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // bp
  __int64 v18; // rdi
  __int64 v19; // rbx
  unsigned __int64 v20; // rsi
  _QWORD *v21; // r15
  unsigned __int64 v22; // rbx
  __int64 v23; // rdi
  __int64 v24; // r9
  char v25; // al
  __int64 v26; // r8
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rax
  __int64 v30; // [rsp+20h] [rbp-48h]
  bool v32; // [rsp+80h] [rbp+18h]

  v7 = sub_1402FE800(*((unsigned int *)a3 + 9), a2, a3[3], a1);
  if ( v9 + v7 > v10 )
  {
    return 0;
  }
  v13 = *((unsigned int *)a3 + 8);
  v17 = 0;
  if ( (_DWORD)v13 != 1 )
  {
    v14 = sub_1402FE800(v13, v8, v9, v10);
    if ( v15 + v14 < v16 )
    {
      v17 = 1;
    }
  }
  v18 = a3[1];
  v19 = *a3;
  v32 = v17;
  if ( (v18 - *a3) / 104 != a5 )
  {
    if ( v19 != v18 )
    {
      do
      {
        if ( *(_BYTE *)(v19 + 88) && *(_QWORD *)v19 )
        {
          (*(void (**)(void))(v19 + 64))();
        }
        v19 += 104LL;
      }
      while ( v19 != v18 );
      a3[1] = *a3;
    }
    sub_1402FB8F0(a3, a5);
    v11 = a4;
    v17 = 1;
    v32 = 1;
  }
  v20 = 0LL;
  v21 = a2 + 1;
  v22 = 0LL;
  if ( a5 )
  {
    v23 = v11 + 48;
    v24 = -48 - v11;
    v30 = -48 - v11;
    while ( !v17 )
    {
      v21 = a2 + 1;
      if ( v22 < (__int64)(a2[1] - *a2) >> 2 && !*(_DWORD *)(*a2 + 4 * v22) && *(_QWORD *)(v23 + 24) && *(_QWORD *)v23 )
      {
        if ( (a3[1] - *a3) / 104 <= v22 )
        {
          __debugbreak();
        }
        v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v23)(*(_QWORD *)(v23 - 48), *(_QWORD *)(v24 + v23 + *a3));
        v24 = v30;
        v17 = v25 == 0;
        v32 = v25 == 0;
      }
      ++v22;
      v23 += 104LL;
      if ( v22 >= a5 )
      {
        goto LABEL_26;
      }
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v17 )
  {
LABEL_27:
    if ( a5 )
    {
      v26 = -16 - a4;
      v27 = a4 + 16;
      do
      {
        if ( v20 < (__int64)(*v21 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * v20)
          && *(_QWORD *)(v27 + 56)
          && *(_QWORD *)(v27 + 32) )
        {
          if ( (a3[1] - *a3) / 104 <= v20 )
          {
            __debugbreak();
          }
          v28 = v27 + v26 + *a3;
          if ( *(_BYTE *)(v28 + 88) )
          {
            if ( *(_QWORD *)v28 )
            {
              (*(void (**)(void))(v28 + 64))();
            }
          }
          v29 = (*(__int64 (__fastcall **)(_QWORD))(v27 + 56))(*(_QWORD *)(v27 - 16));
          v26 = -16 - a4;
          *(_QWORD *)v28 = v29;
          *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 - 8);
          *(_QWORD *)(v28 + 16) = *(_QWORD *)v27;
          *(_QWORD *)(v28 + 24) = *(_QWORD *)(v27 + 8);
          *(_QWORD *)(v28 + 32) = *(_QWORD *)(v27 + 16);
          *(_QWORD *)(v28 + 48) = *(_QWORD *)(v27 + 32);
          *(_QWORD *)(v28 + 40) = *(_QWORD *)(v27 + 24);
          *(_QWORD *)(v28 + 56) = *(_QWORD *)(v27 + 40);
          *(_QWORD *)(v28 + 64) = *(_QWORD *)(v27 + 48);
          *(_QWORD *)(v28 + 72) = *(_QWORD *)(v27 + 56);
          *(_QWORD *)(v28 + 80) = *(_QWORD *)(v27 + 64);
          *(_QWORD *)(v28 + 96) = *(_QWORD *)(v27 + 80);
          *(_BYTE *)(v28 + 88) = 1;
          *(_BYTE *)(v28 + 89) = *(_BYTE *)(v27 + 73);
        }
        ++v20;
        v27 += 104LL;
      }
      while ( v20 < a5 );
      v17 = v32;
    }
    a3[3] = a1;
  }
  return v17;
}

// --- End Function: sub_1402FDA00 (0x1402FDA00) ---

// --- Function: sub_1402FE700 (0x1402FE700) ---
__int64 __fastcall sub_1402FE700(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
  {
    return 0xFFFFFFFFLL;
  }
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 19), SizeInBytes - 19, ".%03dZ", v3 - 1000 * v7) + 19);
}

// --- End Function: sub_1402FE700 (0x1402FE700) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !qword_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !qword_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_1402FEA60 (0x1402FEA60) ---
__int64 __fastcall sub_1402FEA60(_BYTE *a1, int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // r10
  int v8; // edx
  int v9; // ebp
  unsigned __int64 i; // rbx
  int v11; // r11d
  int v12; // r9d
  _WORD *v13; // r8
  __int64 v14; // rax
  unsigned int v15; // edx

  v4 = -1;
  do
  {
    ++v4;
  }
  while ( *(_BYTE *)(a3 + v4) );
  v8 = 0;
  v9 = 0;
  if ( a4 )
  {
    if ( a2 <= 0 )
    {
      v9 = 1;
    }
    else
    {
      *a1 = 34;
      v8 = 1;
    }
  }
  for ( i = 0; i < v4; ++i )
  {
    if ( v8 >= a2 )
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = a2 - v8;
      v13 = &a1[v8];
      switch ( *(_BYTE *)(i + a3) )
      {
        case 8:
          if ( v12 <= 1 )
          {
            goto LABEL_26;
          }
          *v13 = 25180;
          v8 += 2;
          break;
        case 9:
          if ( v12 <= 1 )
          {
            goto LABEL_26;
          }
          *v13 = 29788;
          v8 += 2;
          break;
        case 0xA:
          if ( v12 <= 1 )
          {
            goto LABEL_26;
          }
          *v13 = 28252;
          v8 += 2;
          break;
        case 0xC:
          if ( v12 <= 1 )
          {
            goto LABEL_26;
          }
          *v13 = 26204;
          v8 += 2;
          break;
        case 0xD:
          if ( v12 <= 1 )
          {
            goto LABEL_26;
          }
          *v13 = 29276;
          v8 += 2;
          break;
        case 0x22:
          if ( v12 <= 1 )
          {
            goto LABEL_26;
          }
          *v13 = 8796;
          v8 += 2;
          break;
        case 0x5C:
          if ( v12 <= 1 )
          {
            goto LABEL_26;
          }
          *v13 = 23644;
          v8 += 2;
          break;
        default:
          if ( v12 > 0 )
          {
            *(_BYTE *)v13 = *(_BYTE *)(i + a3);
            v11 = 1;
          }
LABEL_26:
          v8 += v11;
          break;
      }
    }
  }
  if ( a4 )
  {
    if ( v8 < a2 )
    {
      v14 = v8;
      v15 = v8 + 1;
      if ( v9 )
      {
        v15 = -1;
      }
      a1[v14] = 34;
      return v15;
    }
    v9 = 1;
  }
  if ( v9 )
  {
    return (unsigned int)-1;
  }
  return (unsigned int)v8;
}

// --- End Function: sub_1402FEA60 (0x1402FEA60) ---

// --- Function: sub_140300090 (0x140300090) ---
__int64 __fastcall sub_140300090(
        int dwLowDateTime,
        __int64 a2,
        __int64 Buffer,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        __int64 a7,
        _QWORD *a8,
        unsigned __int64 a9,
        __int64 a10,
        char *Buffer_1,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_2; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 a13a_1; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_3; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_4; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 v79; // rdi
  _QWORD *v80; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *a4; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *a13a; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_1495F6708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
    {
      v17 = off_1495F6720[0];
    }
  }
  else
  {
    v17 = off_1495F6728[0];
  }
  Size_5 = -1;
  a4 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = -1;
  v21 = (const void **)&off_1495F6738[0][n4];
  do
  {
    ++Size_1;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_1) );
  if ( Size_1 >= Size )
  {
    goto LABEL_25;
  }
  if ( Size_1 )
  {
    if ( Buffer_1 )
    {
      if ( off_1495F6710 )
      {
        memcpy(Buffer_1, off_1495F6710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer_1, 0, Size);
    }
    *errno() = 22;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
  {
    goto LABEL_25;
  }
  if ( !&Buffer_1[(int)Size_1] )
  {
    *errno() = 22;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 34;
    goto LABEL_22;
  }
  Buffer_1[(int)Size_1] = 91;
LABEL_23:
  v22 = sub_1402FC4C0(
          (__int64)Buffer_1,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&a4,
          v21,
          (__int64)&off_1495F6710,
          (__int64)"]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
  {
LABEL_25:
    Sizea_4 = -1;
  }
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
  {
    Sizea_1 = 0;
  }
  v85 = (unsigned int)Sizea_4 >> 31;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_141;
  }
  v24 = off_1495F6710;
  Size_2 = -1;
  do
  {
    ++Size_2;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
  {
    goto LABEL_125;
  }
  Buffer_2 = Buffer_1;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer_1[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 22;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_1495F6710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_1495F6710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
      {
        goto LABEL_34;
      }
      if ( Size_3 < Size_2 )
      {
        *errno() = 34;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
  {
    goto LABEL_125;
  }
  v30 = &Buffer_2[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_2[v29] )
  {
    *errno() = 22;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_2 = Buffer_1;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 34;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 15392;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_1495F6730;
  do
  {
    ++Size_5;
  }
  while ( *((_BYTE *)off_1495F6730 + Size_5) );
  if ( Size_5 + v32 >= Size )
  {
    goto LABEL_125;
  }
  v34 = &Buffer_2[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 22;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_1495F6730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_1495F6730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
      {
        goto LABEL_56;
      }
      if ( Size_6 < Size_5 )
      {
        *errno() = 34;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  Size_7 = -1;
  v37 = v32 + (int)Size_5;
  do
  {
    ++Size_7;
  }
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
  {
    goto LABEL_125;
  }
  v38 = &Buffer_2[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 22;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
      {
        goto LABEL_71;
      }
      if ( Size_8 < Size_7 )
      {
        *errno() = 34;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v40 = off_1495F6710;
  Size_9 = -1;
  v42 = v37 + (int)Size_7;
  a4 = (void *)v42;
  do
  {
    ++Size_9;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_9) );
  if ( Size_9 + v42 >= Size )
  {
    goto LABEL_125;
  }
  v43 = &Buffer_2[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 22;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_1495F6710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_1495F6710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
      {
        goto LABEL_86;
      }
      if ( Size_10 < Size_9 )
      {
        *errno() = 34;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)a4;
    Buffer_2 = Buffer_1;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
  {
    goto LABEL_125;
  }
  v46 = &Buffer_2[v45];
  n2 = Size - v45;
  if ( &Buffer_2[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 8254;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 34;
  }
  else
  {
    *errno() = 22;
  }
  invalid_parameter_noinfo();
  Buffer_2 = Buffer_1;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = -1;
  do
  {
    ++Size_11;
  }
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
  {
    goto LABEL_124;
  }
  v50 = &Buffer_2[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
  {
    goto LABEL_116;
  }
  if ( !v50 )
  {
    goto LABEL_108;
  }
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
    {
      goto LABEL_116;
    }
    *errno() = 34;
  }
  else
  {
LABEL_108:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
  {
    goto LABEL_125;
  }
  v53 = Size_9 + v52;
  if ( v53 < 0 )
  {
    goto LABEL_125;
  }
  v54 = Size_7 + v53;
  if ( v54 < 0 )
  {
    goto LABEL_125;
  }
  v55 = Size_5 + v54;
  if ( v55 < 0 )
  {
    goto LABEL_125;
  }
  v56 = v55 + 2;
  if ( v56 < 0 )
  {
    goto LABEL_125;
  }
  v57 = Size_2 + v56;
  if ( v57 < 0 )
  {
    goto LABEL_125;
  }
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_142;
  }
  v60 = sub_140303140(
          (__int64)Buffer_1,
          Size,
          Sizea_1,
          (char *)a7,
          (__int64)a8,
          a9,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FB040);
  if ( v60 < 0 )
  {
    v58 = 1;
  }
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
  {
    Sizea_1 = Sizea_3;
  }
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_142;
  }
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer_1[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 32;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  a13a_1 = 0;
  a13a = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
  {
    goto LABEL_175;
  }
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = -1;
      v65 = off_1495F6710;
      a4 = (void *)qword_149808630;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * a13a_1);
      do
      {
        ++Size_14;
      }
      while ( *((_BYTE *)off_1495F6710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
      {
        goto LABEL_171;
      }
      Buffer_3 = Buffer_1;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer_1[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_3[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_3[Size_13] = 91;
LABEL_167:
                v70 = sub_1402FC4C0(
                        (__int64)Buffer_1,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_1495F6718,
                        (const void **)((char *)a4 + Sizec),
                        (__int64)&off_1495F6710,
                        (__int64)"]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      a13a_1 = (unsigned __int64)a13a;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 34;
            }
            else
            {
              *errno() = 22;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        a13a_1 = (unsigned __int64)a13a;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
      {
        goto LABEL_150;
      }
      if ( off_1495F6710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_1495F6710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 22;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 34;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_3 = Buffer_1;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    a13a = (int *)++a13a_1;
    v63 = *a5;
  }
  while ( a13a_1 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_194;
  }
  v73 = v88;
  Size_16 = -1;
  do
  {
    ++Size_16;
  }
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_4 = Buffer_1;
  if ( Size_16 + Sizea_1 >= Size )
  {
    goto LABEL_191;
  }
  Size_17 = Size - Sizea_1;
  v77 = &Buffer_1[Sizea_1];
  if ( !Size_16 )
  {
    goto LABEL_189;
  }
  if ( !v77 )
  {
    goto LABEL_181;
  }
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 22;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 34;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
  {
LABEL_191:
    v58 = 1;
  }
  else
  {
    Sizea_1 += Size_16;
  }
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_4 = Buffer_1;
    v58 = 1;
  }
  else
  {
    Buffer_1[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( a9 )
  {
    v79 = 0;
    if ( (*a15 & 4) != 0 )
    {
      v80 = a8;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))v80[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*v80, &Buffer_4[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++v79;
        v80 += 13;
      }
      while ( v79 < a9 );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_4[Size - 4] = 11822;
      Buffer_4[Size - 2] = 46;
    }
  }
  else
  {
    Buffer_4[Sizea_1] = 0;
    if ( v58 )
    {
      goto LABEL_209;
    }
  }
  Buffer_4[Size - 1] = 0;
  if ( v78 )
  {
    qword_149808998(a2, Buffer, n4, Buffer_4, Sizea_1, a14);
  }
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140300090 (0x140300090) ---

// --- Function: sub_140300B90 (0x140300B90) ---
__int64 __fastcall sub_140300B90(
        __int64 a1,
        __int64 a2,
        _BYTE *Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        _BYTE *Src,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 i,
        unsigned __int64 n0xF,
        double *Buffer_1,
        unsigned __int64 n0xFa,
        __int64 a16,
        int i_1,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r11d
  double *Buffer_2; // r15
  _QWORD *v24; // r14
  int n0xFa_2; // ebx
  unsigned __int64 n0xFa_1; // r9
  unsigned __int64 n0xFa_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xFa_19; // r13d
  int v47; // r13d
  int i_3; // edi
  __int64 v49; // rsi
  _BYTE *v50; // rbp
  int v51; // eax
  unsigned int n4_2; // r14d
  int v53; // eax
  bool v54; // dl
  bool v55; // cl
  bool v56; // al
  int v57; // eax
  int n0xFa_4; // ebp
  int n0xFa_5; // esi
  int n0xF_2; // edi
  int v61; // eax
  __int64 *v62; // r9
  __int64 v63; // rdx
  __int64 v64; // rcx
  __int64 v65; // rax
  unsigned __int64 v66; // r8
  __int64 v67; // r15
  __int64 v68; // r14
  _BYTE *v69; // rsi
  __int64 v70; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v73; // rcx
  __int64 v74; // rcx
  size_t n2; // r8
  _WORD *v76; // rcx
  bool v77; // sf
  int v78; // ecx
  __int64 v79; // rax
  __int64 v80; // r15
  __int64 v81; // r14
  int v82; // eax
  int v83; // eax
  int n0xF_4; // ebp
  int n0xFa_7; // r14d
  int n0xFa_8; // r15d
  int n0xFa_9; // edx
  char *Src_2; // r14
  int v89; // eax
  int n0xFa_10; // ecx
  size_t Size_8; // r8
  double *v92; // rcx
  __int64 v93; // rdi
  __int64 i_4; // rbp
  int v95; // eax
  int n0xFa_11; // ecx
  size_t Size_9; // r8
  double *v98; // rcx
  _BYTE *v99; // rcx
  size_t Size_10; // r8
  double *v101; // rcx
  int n0xFa_12; // ebp
  int v103; // eax
  _BYTE *v104; // rcx
  unsigned __int64 n0xF_5; // rdx
  bool v106; // bp
  __int64 v107; // r14
  unsigned __int64 n0xF_8; // r15
  unsigned __int64 v109; // rsi
  __int64 v110; // r14
  int n0xFa_13; // edx
  int n0xF_7; // ecx
  bool v113; // r15
  int n0xFa_14; // r12d
  size_t Size_11; // r8
  _WORD *v116; // rcx
  _BYTE *v117; // rcx
  __int64 v118; // rax
  unsigned __int64 v119; // r9
  double *Buffer_3; // rdx
  _BYTE *v121; // rdi
  __int64 v122; // rbp
  size_t Size_12; // rbx
  char *v124; // rcx
  size_t Size_13; // rsi
  __int64 v126; // rcx
  size_t Size_14; // r8
  _WORD *v128; // rcx
  int v129; // ecx
  _BYTE *v130; // rcx
  unsigned __int64 n0xFa_16; // r8
  double *Buffer_4; // r12
  unsigned __int64 v133; // r8
  _BYTE *v134; // rcx
  int n0xFa_17; // esi
  int v136; // eax
  double *Buffer_5; // rsi
  _BYTE *v138; // rcx
  size_t Size_15; // r8
  _WORD *v140; // rcx
  int v141; // esi
  int v142; // eax
  size_t Size_16; // r8
  double *v144; // rcx
  size_t Size_17; // r8
  _WORD *v146; // rcx
  size_t n0xFa_18; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  unsigned int n4_3; // ebp
  __int64 v151; // r14
  _BYTE *v152; // rsi
  int v154; // [rsp+20h] [rbp-138h]
  _QWORD *v155; // [rsp+28h] [rbp-130h]
  int v156; // [rsp+28h] [rbp-130h]
  int n0xF_3; // [rsp+80h] [rbp-D8h]
  int n0xFa_6; // [rsp+80h] [rbp-D8h]
  int n0xF_6; // [rsp+80h] [rbp-D8h]
  bool v160; // [rsp+90h] [rbp-C8h]
  bool v161; // [rsp+91h] [rbp-C7h]
  bool v162; // [rsp+92h] [rbp-C6h]
  unsigned __int64 n0xFa_15; // [rsp+98h] [rbp-C0h]
  unsigned __int64 n0xF_1; // [rsp+A0h] [rbp-B8h] BYREF
  unsigned __int64 v165; // [rsp+A8h] [rbp-B0h]
  _BYTE *v166; // [rsp+B0h] [rbp-A8h]
  _QWORD *v167; // [rsp+B8h] [rbp-A0h]
  __int64 v168; // [rsp+C0h] [rbp-98h]
  __int64 v169; // [rsp+C8h] [rbp-90h]
  __int64 v170; // [rsp+D0h] [rbp-88h]
  char *Src_1; // [rsp+D8h] [rbp-80h]
  char *v172; // [rsp+E0h] [rbp-78h]
  void (__fastcall *v173)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, __int64, char *, unsigned __int64, __int128 *); // [rsp+E8h] [rbp-70h] BYREF
  __int64 i_2; // [rsp+F0h] [rbp-68h]
  __int128 v175; // [rsp+F8h] [rbp-60h] BYREF

  n4_1 = n4;
  Buffer_2 = Buffer_1;
  v24 = a6;
  Src_1 = Src;
  v172 = (char *)a8;
  v169 = a9;
  i_2 = i;
  v170 = a16;
  v166 = a4;
  n0xFa_2 = 0;
  n0xFa_1 = n0xFa;
  v173 = 0;
  v168 = a2;
  n0xFa_3 = n0xFa + 128;
  LODWORD(n0xF_1) = n4;
  v167 = a6;
  n0xFa_15 = n0xFa + 128;
  v175 = 0;
  if ( (int)n0xFa <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xFa <= 0xF )
  {
    goto LABEL_57;
  }
  if ( Buffer_1 )
  {
    *Buffer_1 = 0x73656D697440227BLL;
    *((_DWORD *)Buffer_1 + 2) = 1886216564;
    *((_WORD *)Buffer_1 + 6) = 14882;
    *((_BYTE *)Buffer_1 + 14) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    n0xFa_1 = n0xFa;
  }
  Size = -1;
  do
  {
    ++Size;
  }
  while ( Buffer[Size] );
  if ( Size + 15 >= n0xFa_1 )
  {
LABEL_56:
    n0xFa_1 = n0xFa;
    n4_1 = n4;
LABEL_57:
    n0xFa_19 = -1;
    goto LABEL_58;
  }
  v29 = (char *)Buffer_1 + 15;
  Size_1 = n0xFa_1 - 15;
  if ( Size )
  {
    if ( Buffer_1 == (double *)-15LL )
    {
LABEL_11:
      *errno() = 22;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( Buffer && Size_1 >= Size )
    {
      memcpy(v29, Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xFa_1 - 15);
      if ( !Buffer )
      {
        goto LABEL_11;
      }
      if ( Size_1 < Size )
      {
        *errno() = 34;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xFa_1 = n0xFa;
  }
  if ( (Size & 0x80000000) != 0LL )
  {
    goto LABEL_56;
  }
  v31 = (int)Size + 15LL;
  if ( (int)Size + 24LL >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v32 = (double *)((char *)Buffer_1 + v31);
  Size_2 = n0xFa_1 - v31;
  if ( !(double *)((char *)Buffer_1 + v31) )
  {
    *errno() = 22;
LABEL_27:
    invalid_parameter_noinfo();
    n0xFa_1 = n0xFa;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 34;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 34;
LABEL_28:
  v34 = (int)Size + 24LL;
  Size_3 = -1;
  do
  {
    ++Size_3;
  }
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v36 = (char *)Buffer_1 + v34;
  Size_4 = n0xFa_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 22;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xFa_1 - v34);
      if ( !a4 )
      {
        goto LABEL_33;
      }
      if ( Size_4 < Size_3 )
      {
        *errno() = 34;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xFa_1 = n0xFa;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
  {
    goto LABEL_56;
  }
  v38 = v34 + (int)Size_3;
  if ( v38 + 13 >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v39 = (double *)((char *)Buffer_1 + v38);
  Size_5 = n0xFa_1 - v38;
  if ( !(double *)((char *)Buffer_1 + v38) )
  {
    *errno() = 22;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 34;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 578315369;
  *((_BYTE *)v39 + 12) = 58;
LABEL_50:
  v41 = sub_1402FC400((__int64)Buffer_1, n0xFa, v38 + 13, a1);
  if ( v41 < 0 )
  {
    goto LABEL_56;
  }
  v42 = v41 + 13;
  if ( v42 < 0 )
  {
    goto LABEL_56;
  }
  v43 = Size_3 + v42;
  if ( v43 < 0 )
  {
    goto LABEL_56;
  }
  v44 = v43 + 9;
  if ( v44 < 0 )
  {
    goto LABEL_56;
  }
  v45 = Size + v44;
  if ( v45 < 0 )
  {
    goto LABEL_56;
  }
  n0xFa_1 = n0xFa;
  n4_1 = n4;
  n0xFa_19 = v45 + 15;
LABEL_58:
  v24 = v167;
  n0xFa_2 = n0xFa_19;
  if ( n0xFa_19 < 0 )
  {
    n0xFa_2 = 0;
  }
  v47 = (unsigned int)n0xFa_19 >> 31;
LABEL_62:
  i_3 = i_1;
  if ( (a18 & 0x10) != 0 && qword_1498089A8 )
  {
    v49 = a10;
    v50 = v166;
    if ( n0xFa_2 >= (int)n0xFa_1 )
    {
      v47 = 1;
    }
    else
    {
      v51 = qword_1498089A8(
              v168,
              v166,
              n4_1,
              Src_1,
              v24,
              v170,
              i_1,
              v169,
              a10,
              (char *)Buffer_1 + n0xFa_2,
              n0xFa_1 - n0xFa_2,
              &a18);
      if ( v51 < 0 )
      {
        v47 = 1;
      }
      else
      {
        n0xFa_2 += v51;
      }
    }
  }
  else
  {
    v50 = v166;
    v49 = a10;
  }
  if ( (a18 & 0xFFF00) == 0 || !qword_1498089B0 )
  {
    goto LABEL_77;
  }
  if ( n0xFa_2 >= (int)n0xFa )
  {
    v47 = 1;
LABEL_77:
    n4_2 = n4;
    goto LABEL_78;
  }
  v155 = v24;
  n4_2 = n4;
  v53 = qword_1498089B0(
          a18,
          v168,
          v50,
          n4,
          Src_1,
          v155,
          v170,
          i_1,
          v172,
          v169,
          v49,
          (char *)Buffer_1 + n0xFa_2,
          n0xFa - n0xFa_2,
          &v175,
          &v173);
  if ( v53 < 0 )
  {
    v47 = 1;
  }
  else
  {
    n0xFa_2 += v53;
  }
LABEL_78:
  v54 = (a18 & 8) != 0 && qword_1498089A0;
  v162 = v54;
  v55 = (a18 & 1) != 0 && n2_1 == 2;
  v160 = v55;
  v56 = (a18 & 2) != 0 && n2_2 == 2;
  v161 = v56;
  if ( !v54 && !v55 && !v56 )
  {
    n4_3 = n4;
    v151 = v168;
    goto LABEL_383;
  }
  if ( qword_149808978 )
  {
    if ( n0xFa_2 >= (int)n0xFa_3 )
    {
      n0xFa_5 = n0xFa + 128;
      n0xF_3 = n0xFa + 128;
      n0xF_2 = n0xFa + 128;
      goto LABEL_104;
    }
    v57 = qword_149808978((char *)Buffer_1 + n0xFa_2, n0xFa_3 - n0xFa_2);
    if ( v57 < 0 )
    {
      v47 = 1;
      n0xF_3 = n0xFa + 128;
      n0xFa_4 = n0xFa_2;
      n0xFa_5 = n0xFa + 128;
      n0xF_2 = n0xFa + 128;
      goto LABEL_98;
    }
    n0xFa_2 += v57;
  }
  n0xF_3 = n0xFa + 128;
  n0xFa_4 = n0xFa_2;
  n0xFa_5 = n0xFa + 128;
  n0xF_2 = n0xFa + 128;
  if ( n0xFa_2 < (int)n0xFa_3 )
  {
LABEL_98:
    v61 = sub_1402FC940(
            (__int64)Buffer_1,
            n0xFa_3,
            n0xFa_2,
            (__int64)",\"@severity\":",
            (unsigned int *)&n0xF_1,
            (__int64)",\"severity\":\"",
            (__int64)&off_1495F6738[0][n4_2],
            (__int64)"\",\"tags\":[");
    if ( v61 < 0 )
    {
      v47 = 1;
    }
    n0xFa_2 += v61;
    if ( v61 < 0 )
    {
      n0xFa_2 = n0xFa_4;
    }
    goto LABEL_105;
  }
LABEL_104:
  v47 = 1;
LABEL_105:
  v62 = v167;
  v63 = v167[1];
  v64 = *v167;
  v65 = (v63 - *v167) >> 2;
  if ( !v65 )
  {
    goto LABEL_154;
  }
  v66 = 0;
  v165 = 0;
  if ( v65 == 1 )
  {
    goto LABEL_143;
  }
  do
  {
    LODWORD(n0xF_1) = n0xF_2;
    n0xFa_6 = n0xFa_5;
    if ( n0xFa_2 >= n0xFa_5 )
    {
      goto LABEL_140;
    }
    v67 = qword_149808630;
    v68 = *(unsigned int *)(v64 + 4 * v66);
    if ( n0xFa_2 + 1LL >= n0xFa_3 )
    {
      goto LABEL_140;
    }
    if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
    {
      *errno() = 22;
LABEL_114:
      invalid_parameter_noinfo();
      goto LABEL_115;
    }
    if ( n0xFa_3 == n0xFa_2 )
    {
      *errno() = 34;
      goto LABEL_114;
    }
    *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
LABEL_115:
    v69 = *(_BYTE **)(v67 + 8 * v68);
    v70 = n0xFa_2 + 1LL;
    Size_6 = -1;
    do
    {
      ++Size_6;
    }
    while ( v69[Size_6] );
    if ( Size_6 + v70 >= n0xFa_15 )
    {
LABEL_138:
      n0xFa_3 = n0xFa + 128;
LABEL_139:
      n0xFa_5 = n0xFa_6;
      n0xF_2 = n0xF_1;
      v66 = v165;
      v62 = v167;
      goto LABEL_140;
    }
    Size_7 = n0xFa_15 - v70;
    v73 = (char *)Buffer_1 + v70;
    if ( Size_6 )
    {
      if ( !v73 )
      {
        goto LABEL_120;
      }
      if ( v69 && Size_7 >= Size_6 )
      {
        memcpy(v73, v69, Size_6);
        goto LABEL_128;
      }
      memset(v73, 0, n0xFa_15 - v70);
      if ( v69 )
      {
        if ( Size_7 >= Size_6 )
        {
          goto LABEL_128;
        }
        *errno() = 34;
      }
      else
      {
LABEL_120:
        *errno() = 22;
      }
      invalid_parameter_noinfo();
    }
LABEL_128:
    if ( (Size_6 & 0x80000000) != 0LL )
    {
      goto LABEL_138;
    }
    v74 = v70 + (int)Size_6;
    n0xFa_3 = n0xFa + 128;
    if ( v74 + 2 >= n0xFa_15 )
    {
      goto LABEL_139;
    }
    n2 = n0xFa_15 - v74;
    v76 = (_WORD *)((char *)Buffer_1 + v74);
    if ( v76 )
    {
      if ( n2 >= 2 )
      {
        *v76 = 11298;
        goto LABEL_136;
      }
      memset(v76, 0, n2);
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
LABEL_136:
    v77 = (int)Size_6 + 3 < 0;
    v78 = Size_6 + 3;
    v66 = v165;
    v62 = v167;
    n0xFa_5 = n0xFa_6;
    n0xF_2 = n0xF_1;
    if ( !v77 )
    {
      n0xFa_2 += v78;
      goto LABEL_141;
    }
LABEL_140:
    v47 = 1;
LABEL_141:
    v63 = v62[1];
    ++v66;
    v64 = *v62;
    v79 = v63 - *v62;
    v165 = v66;
  }
  while ( v66 < (v79 >> 2) - 1 );
  n0xF_3 = n0xF_2;
LABEL_143:
  if ( n0xFa_2 >= n0xFa_5 )
  {
    goto LABEL_157;
  }
  v80 = qword_149808630;
  v81 = *(unsigned int *)(v64 + 4 * ((v63 - v64) >> 2) - 4);
  if ( n0xFa_2 + 1LL >= n0xFa_3 )
  {
    goto LABEL_166;
  }
  if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
  {
    *errno() = 22;
    goto LABEL_150;
  }
  if ( n0xFa_3 == n0xFa_2 )
  {
    *errno() = 34;
LABEL_150:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
  }
  v82 = sub_1402FC670((__int64)Buffer_1, n0xFa_3, n0xFa_2 + 1LL, (const void **)(v80 + 8 * v81), "\"");
  if ( v82 < 0 || (v83 = v82 + 1, v83 < 0) )
  {
LABEL_166:
    n0xF_4 = n0xF_2;
    n0xFa_7 = n0xFa_5;
    v47 = 1;
    n0xFa_8 = n0xFa_2;
    n0xFa_9 = n0xFa_2;
    goto LABEL_155;
  }
  n0xFa_2 += v83;
  n0xF_3 = n0xF_2;
LABEL_154:
  n0xF_4 = n0xF_2;
  n0xFa_7 = n0xFa_5;
  n0xFa_8 = n0xFa_2;
  n0xFa_9 = n0xFa_2;
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_157:
    v47 = 1;
  }
  else
  {
LABEL_155:
    if ( n0xFa_2 + 11LL >= n0xFa_3 )
    {
      n0xFa_2 = n0xFa_9;
      n0xF_3 = n0xF_2;
      goto LABEL_157;
    }
    Size_8 = n0xFa_3 - n0xFa_2;
    v92 = (double *)((char *)Buffer_1 + n0xFa_2);
    if ( !v92 )
    {
      *errno() = 22;
      goto LABEL_172;
    }
    if ( Size_8 < 0xB )
    {
      memset(v92, 0, Size_8);
      *errno() = 34;
LABEL_172:
      invalid_parameter_noinfo();
    }
    else
    {
      *v92 = 0x746E657665222C5DLL;
      *((_WORD *)v92 + 4) = 14882;
      *((_BYTE *)v92 + 10) = 34;
    }
    n0xF_3 = n0xF_4;
    n0xFa_2 = n0xFa_8 + 11;
    n0xFa_5 = n0xFa_7;
    n0xF_2 = n0xF_4;
  }
  if ( *Src_1 )
  {
    Src_2 = Src_1;
    do
    {
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        v89 = sub_1402FE910((double *)((char *)Buffer_1 + n0xFa_2), (int)n0xFa - n0xFa_2, *Src_2);
        if ( v89 < 0 )
        {
          v47 = 1;
        }
        n0xFa_10 = v89 + n0xFa_2;
        if ( v89 < 0 )
        {
          n0xFa_10 = n0xFa_2;
        }
        n0xFa_2 = n0xFa_10;
      }
      ++Src_2;
    }
    while ( *Src_2 );
    n0xF_2 = n0xF_3;
    n0xFa_3 = n0xFa + 128;
  }
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_180:
    v47 = 1;
  }
  else
  {
    if ( n0xFa_2 + 13LL >= n0xFa_3 )
    {
      n0xF_3 = n0xF_2;
      goto LABEL_180;
    }
    Size_9 = n0xFa_3 - n0xFa_2;
    v98 = (double *)((char *)Buffer_1 + n0xFa_2);
    if ( !v98 )
    {
      *errno() = 22;
      goto LABEL_194;
    }
    if ( Size_9 < 0xD )
    {
      memset(v98, 0, Size_9);
      *errno() = 34;
LABEL_194:
      invalid_parameter_noinfo();
    }
    else
    {
      *v98 = 0x617373656D222C22LL;
      *((_DWORD *)v98 + 2) = 975332711;
      *((_BYTE *)v98 + 12) = 34;
    }
    n0xFa_2 += 13;
    n0xF_3 = n0xF_2;
  }
  if ( i_1 > 0 )
  {
    v93 = v170;
    for ( i_4 = 0; i_4 < i_1; ++i_4 )
    {
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        v95 = sub_1402FE910((double *)((char *)Buffer_1 + n0xFa_2), (int)n0xFa - n0xFa_2, *(_BYTE *)(v93 + i_4));
        if ( v95 < 0 )
        {
          v47 = 1;
        }
        n0xFa_11 = v95 + n0xFa_2;
        if ( v95 < 0 )
        {
          n0xFa_11 = n0xFa_2;
        }
        n0xFa_2 = n0xFa_11;
      }
    }
    n0xF_2 = n0xF_3;
    n0xFa_3 = n0xFa + 128;
  }
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_217:
    v47 = 1;
    goto LABEL_218;
  }
  if ( n0xFa_2 + 1LL < n0xFa_3 )
  {
    v99 = (char *)Buffer_1 + n0xFa_2;
    if ( v99 )
    {
      if ( n0xFa_3 != n0xFa_2 )
      {
        *v99 = 34;
LABEL_208:
        ++n0xFa_2;
        goto LABEL_209;
      }
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
    goto LABEL_208;
  }
  v47 = 1;
LABEL_209:
  if ( n0xFa_2 >= n0xFa_5 || n0xFa_2 + 11LL >= n0xFa_3 )
  {
    goto LABEL_217;
  }
  Size_10 = n0xFa_3 - n0xFa_2;
  v101 = (double *)((char *)Buffer_1 + n0xFa_2);
  if ( !v101 )
  {
    *errno() = 22;
    goto LABEL_216;
  }
  if ( Size_10 < 0xB )
  {
    memset(v101, 0, Size_10);
    *errno() = 34;
LABEL_216:
    invalid_parameter_noinfo();
    n0xFa_2 += 11;
  }
  else
  {
    *v101 = 0x6F746F727040222CLL;
    n0xFa_2 += 11;
    *((_WORD *)v101 + 4) = 14882;
    *((_BYTE *)v101 + 10) = 34;
  }
LABEL_218:
  n0xFa_12 = n0xFa_2;
  if ( n0xFa_2 >= (int)n0xFa )
  {
    v47 = 1;
  }
  else
  {
    v103 = sub_140303140(
             (__int64)Buffer_1,
             n0xFa,
             n0xFa_2,
             v172,
             v169,
             a10,
             a11,
             1,
             (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FB080);
    if ( v103 < 0 )
    {
      v47 = 1;
    }
    n0xFa_2 += v103;
    if ( v103 < 0 )
    {
      n0xFa_2 = n0xFa_12;
    }
  }
  if ( n0xFa_2 >= n0xFa_5 || n0xFa_2 + 1LL >= n0xFa_3 )
  {
    v47 = 1;
  }
  else
  {
    v104 = (char *)Buffer_1 + n0xFa_2;
    if ( !v104 )
    {
      *errno() = 22;
      goto LABEL_231;
    }
    if ( n0xFa_3 == n0xFa_2 )
    {
      *errno() = 34;
LABEL_231:
      invalid_parameter_noinfo();
      ++n0xFa_2;
    }
    else
    {
      *v104 = 34;
      ++n0xFa_2;
    }
  }
  n0xF_5 = n0xF;
  v106 = 0;
  n0xF_1 = 0;
  v107 = 0;
  n0xF_8 = 0;
  if ( n0xF )
  {
    while ( !v47 )
    {
      v109 = *(_QWORD *)(i_2 + 8 * n0xF_8);
      v165 = v109;
      if ( v107 != *(_QWORD *)(v109 + 8) )
      {
        if ( v106 )
        {
          if ( n0xFa_2 < n0xF_2 )
          {
            if ( n0xFa_2 + 2LL >= n0xFa_3 )
            {
              v110 = *(_QWORD *)(v109 + 80);
              v47 = 1;
              n0xF_6 = n0xF_2;
              n0xFa_13 = n0xFa_2;
              n0xF_7 = n0xF_2;
              v113 = v110 != -1;
              n0xFa_14 = n0xFa_2;
              goto LABEL_257;
            }
            Size_11 = n0xFa_3 - n0xFa_2;
            v116 = (_WORD *)((char *)Buffer_1 + n0xFa_2);
            if ( !v116 )
            {
              *errno() = 22;
              goto LABEL_245;
            }
            if ( Size_11 < 2 )
            {
              memset(v116, 0, Size_11);
              *errno() = 34;
LABEL_245:
              invalid_parameter_noinfo();
              n0xFa_2 += 2;
            }
            else
            {
              *v116 = 11357;
              n0xFa_2 += 2;
            }
LABEL_256:
            v118 = *(_QWORD *)(v109 + 80);
            n0xFa_13 = n0xFa_2;
            n0xF_6 = n0xF_2;
            n0xF_7 = n0xF_2;
            n0xFa_14 = n0xFa_2;
            v106 = v118 != -1;
            v110 = v118;
            v113 = v106;
            if ( n0xFa_2 < n0xF_2 )
            {
LABEL_257:
              v119 = n0xFa + 128;
              if ( n0xFa_2 + 1LL >= n0xFa_15 )
              {
                v109 = v165;
                n0xF_2 = n0xF_7;
                n0xFa_2 = n0xFa_13;
                v106 = v113;
                v118 = v110;
                goto LABEL_292;
              }
              Buffer_3 = Buffer_1;
              if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
              {
                *errno() = 22;
                goto LABEL_264;
              }
              if ( n0xFa_15 == n0xFa_2 )
              {
                *errno() = 34;
LABEL_264:
                invalid_parameter_noinfo();
                Buffer_3 = Buffer_1;
                v119 = n0xFa + 128;
              }
              else
              {
                *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
              }
              v121 = *(_BYTE **)(v109 + 8);
              v122 = n0xFa_2 + 1LL;
              Size_12 = -1;
              do
              {
                ++Size_12;
              }
              while ( v121[Size_12] );
              if ( Size_12 + v122 >= v119 )
              {
                goto LABEL_289;
              }
              v124 = (char *)Buffer_3 + v122;
              Size_13 = v119 - v122;
              if ( Size_12 )
              {
                if ( !v124 )
                {
                  goto LABEL_270;
                }
                if ( v121 && Size_13 >= Size_12 )
                {
                  memcpy(v124, v121, Size_12);
                  goto LABEL_278;
                }
                memset(v124, 0, v119 - v122);
                if ( !v121 )
                {
LABEL_270:
                  *errno() = 22;
                  goto LABEL_277;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 34;
LABEL_277:
                  invalid_parameter_noinfo();
                }
LABEL_278:
                v119 = n0xFa + 128;
                Buffer_3 = Buffer_1;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v126 = v122 + (int)Size_12, v126 + 2 >= v119) )
              {
LABEL_289:
                n0xF_2 = n0xF_6;
                n0xFa_2 = n0xFa_14;
                v106 = v113;
                v118 = v110;
              }
              else
              {
                Size_14 = v119 - v126;
                v128 = (_WORD *)((char *)Buffer_3 + v126);
                if ( !v128 )
                {
                  *errno() = 22;
                  goto LABEL_286;
                }
                if ( Size_14 < 2 )
                {
                  memset(v128, 0, Size_14);
                  *errno() = 34;
LABEL_286:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v128 = 14882;
                }
                n0xF_2 = n0xF_6;
                v77 = (int)Size_12 + 3 < 0;
                v129 = Size_12 + 3;
                n0xFa_2 = n0xFa_14;
                v118 = v110;
                v106 = v113;
                if ( !v77 )
                {
                  v109 = v165;
                  n0xFa_2 = v129 + n0xFa_14;
                  goto LABEL_293;
                }
              }
              v109 = v165;
            }
LABEL_292:
            v47 = 1;
LABEL_293:
            if ( v118 != -1 )
            {
              if ( n0xFa_2 < n0xF_2 && n0xFa_2 + 1LL < n0xFa_15 )
              {
                v130 = (char *)Buffer_1 + n0xFa_2;
                if ( !v130 )
                {
                  *errno() = 22;
                  goto LABEL_301;
                }
                if ( n0xFa_15 == n0xFa_2 )
                {
                  *errno() = 34;
LABEL_301:
                  invalid_parameter_noinfo();
                  v107 = *(_QWORD *)(v109 + 8);
                  n0xF_8 = n0xF_1;
                  ++n0xFa_2;
                }
                else
                {
                  n0xF_8 = n0xF_1;
                  ++n0xFa_2;
                  *v130 = 91;
                  v107 = *(_QWORD *)(v109 + 8);
                }
LABEL_315:
                Buffer_4 = Buffer_1;
                goto LABEL_316;
              }
              v47 = 1;
            }
            v107 = *(_QWORD *)(v109 + 8);
            n0xF_8 = n0xF_1;
            goto LABEL_315;
          }
LABEL_291:
          v118 = *(_QWORD *)(v109 + 80);
          v106 = v118 != -1;
          goto LABEL_292;
        }
        if ( n0xFa_2 >= n0xF_2 )
        {
          goto LABEL_291;
        }
        if ( n0xFa_2 + 1LL >= n0xFa_3 )
        {
          v110 = *(_QWORD *)(v109 + 80);
          n0xF_7 = n0xF_2;
          n0xF_6 = n0xF_2;
          v47 = 1;
          n0xFa_13 = n0xFa_2;
          v113 = v110 != -1;
          n0xFa_14 = n0xFa_2;
          goto LABEL_257;
        }
        v117 = (char *)Buffer_1 + n0xFa_2;
        if ( !v117 )
        {
          *errno() = 22;
          goto LABEL_254;
        }
        if ( n0xFa_3 == n0xFa_2 )
        {
          *errno() = 34;
LABEL_254:
          invalid_parameter_noinfo();
        }
        else
        {
          *v117 = 44;
        }
        ++n0xFa_2;
        goto LABEL_256;
      }
      if ( !v107 || n0xF_8 >= n0xF_5 )
      {
        goto LABEL_315;
      }
      if ( n0xFa_2 >= n0xF_2 || n0xFa_2 + 1LL >= n0xFa_3 )
      {
        v47 = 1;
        goto LABEL_315;
      }
      n0xFa_16 = n0xFa_3;
      Buffer_4 = Buffer_1;
      v133 = n0xFa_16 - n0xFa_2;
      v134 = (char *)Buffer_1 + n0xFa_2;
      if ( v134 )
      {
        if ( v133 )
        {
          *v134 = 44;
          ++n0xFa_2;
          goto LABEL_316;
        }
        *errno() = 34;
      }
      else
      {
        *errno() = 22;
      }
      invalid_parameter_noinfo();
      ++n0xFa_2;
LABEL_316:
      n0xFa_17 = n0xFa_2;
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(v154) = 1;
        v136 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v165 + 32))(
                 *(_QWORD *)v165,
                 (char *)Buffer_4 + n0xFa_2,
                 n0xFa - n0xFa_2,
                 0,
                 v154,
                 0);
        if ( v136 < 0 )
        {
          v47 = 1;
        }
        n0xFa_2 += v136;
        if ( v136 < 0 )
        {
          n0xFa_2 = n0xFa_17;
        }
        if ( !v47 )
        {
          n0xFa_3 = n0xFa + 128;
          goto LABEL_323;
        }
      }
      n0xFa_3 = n0xFa + 128;
      if ( n0xFa_2 >= n0xF_2 )
      {
        v47 = 1;
LABEL_323:
        Buffer_5 = Buffer_1;
      }
      else
      {
        Buffer_5 = Buffer_1;
        if ( n0xFa_2 + 6LL >= n0xFa_15 )
        {
          v47 = 1;
          goto LABEL_324;
        }
        Size_15 = n0xFa_15 - n0xFa_2;
        v140 = (_WORD *)((char *)Buffer_1 + n0xFa_2);
        if ( !v140 )
        {
          *errno() = 22;
          goto LABEL_340;
        }
        if ( Size_15 < 6 )
        {
          memset(v140, 0, Size_15);
          *errno() = 34;
LABEL_340:
          invalid_parameter_noinfo();
          n0xFa_2 += 6;
        }
        else
        {
          n0xFa_2 += 6;
          *(_DWORD *)v140 = 1819635234;
          v140[2] = 8812;
        }
      }
LABEL_324:
      n0xF_5 = n0xF;
      if ( (n0xF_8 == n0xF - 1 || v47) && v106 )
      {
        if ( n0xFa_2 >= n0xF_2 || n0xFa_2 + 1LL >= n0xFa_3 )
        {
          v47 = 1;
        }
        else
        {
          v138 = (char *)Buffer_5 + n0xFa_2;
          if ( !v138 )
          {
            *errno() = 22;
            goto LABEL_345;
          }
          if ( n0xFa_3 == n0xFa_2 )
          {
            *errno() = 34;
LABEL_345:
            invalid_parameter_noinfo();
            n0xF_5 = n0xF;
            ++n0xFa_2;
          }
          else
          {
            *v138 = 93;
            ++n0xFa_2;
          }
        }
      }
      n0xF_1 = ++n0xF_8;
      if ( n0xF_8 >= n0xF_5 )
      {
        break;
      }
      continue;
    }
  }
  v141 = a19;
  if ( a19 <= 1 )
  {
    Buffer_2 = Buffer_1;
LABEL_353:
    if ( !v47 )
    {
      goto LABEL_363;
    }
    if ( n0xFa_2 < n0xF_2 )
    {
      goto LABEL_355;
    }
    goto LABEL_374;
  }
  if ( n0xFa_2 >= n0xF_2 )
  {
    goto LABEL_374;
  }
  Buffer_2 = Buffer_1;
  v142 = sub_1402FC7C0((__int64)Buffer_1, n0xFa_3, n0xFa_2, (__int64)",\"EVT_COUNT\":", &a19);
  if ( v142 >= 0 )
  {
    n0xFa_2 += v142;
    goto LABEL_353;
  }
LABEL_355:
  if ( n0xFa_2 + 13LL < n0xFa_3 )
  {
    Size_16 = n0xFa_3 - n0xFa_2;
    v144 = (double *)((char *)Buffer_2 + n0xFa_2);
    if ( !v144 )
    {
      *errno() = 22;
      goto LABEL_361;
    }
    if ( Size_16 < 0xD )
    {
      memset(v144, 0, Size_16);
      *errno() = 34;
LABEL_361:
      invalid_parameter_noinfo();
    }
    else
    {
      *v144 = 0x4C465245564F222CLL;
      *((_DWORD *)v144 + 2) = 975329103;
      *((_BYTE *)v144 + 12) = 49;
    }
    n0xFa_2 += 13;
LABEL_363:
    if ( n0xFa_2 >= n0xF_2 )
    {
      goto LABEL_374;
    }
  }
  if ( n0xFa_2 + 2LL >= n0xFa_3 )
  {
    n0xFa_18 = n0xFa_2;
    *((_BYTE *)Buffer_2 + n0xFa_2) = 0;
  }
  else
  {
    Size_17 = n0xFa_3 - n0xFa_2;
    v146 = (_WORD *)((char *)Buffer_2 + n0xFa_2);
    if ( !v146 )
    {
      *errno() = 22;
      goto LABEL_370;
    }
    if ( Size_17 < 2 )
    {
      memset(v146, 0, Size_17);
      *errno() = 34;
LABEL_370:
      invalid_parameter_noinfo();
    }
    else
    {
      *v146 = 2685;
    }
    n0xFa_2 += 2;
    if ( n0xFa_2 < n0xF_2 )
    {
      n0xFa_18 = n0xFa_2;
      *((_BYTE *)Buffer_2 + n0xFa_2) = 0;
      goto LABEL_375;
    }
LABEL_374:
    Buffer_2 = Buffer_1;
    n0xFa_18 = n0xFa_2;
  }
LABEL_375:
  *((_BYTE *)Buffer_2 + n0xFa_3 - 1) = 0;
  if ( v160 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_2, n0xFa_18, 1u, Stream);
  }
  if ( v161 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_2, n0xFa_18, 1u, Stream_1);
  }
  n4_3 = n4;
  v151 = v168;
  if ( v162 )
  {
    v156 = v141;
    v152 = v166;
    qword_1498089A0(v168, v166, n4, Buffer_2, n0xFa_18, v156);
    i_3 = i_1;
    goto LABEL_384;
  }
  i_3 = i_1;
LABEL_383:
  v152 = v166;
LABEL_384:
  if ( v173 )
  {
    v173(
      a18,
      v151,
      v152,
      n4_3,
      Src_1,
      v167,
      v170,
      i_3,
      v172,
      v169,
      a10,
      (char *)Buffer_2 + n0xFa_2,
      n0xFa - n0xFa_2,
      &v175);
  }
  return (unsigned int)n0xFa_2;
}

// --- End Function: sub_140300B90 (0x140300B90) ---

// --- Function: sub_140302260 (0x140302260) ---
unsigned __int64 __fastcall sub_140302260(__int64 a1, unsigned __int64 a2)
{
  const void *v4; // rcx
  unsigned __int64 result; // rax
  __int64 v6; // rdi
  unsigned __int64 n0x6400000; // rcx
  __int64 v8; // rdi
  __int64 v9; // rax
  _QWORD *v10; // rbx

  v4 = *(const void **)a1;
  result = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3;
  if ( a2 > result )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    {
      unknown_libname_10();
    }
    v6 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    n0x6400000 = 8 * a2;
    v8 = v6 >> 3;
    if ( 8 * a2 < 0x1000 )
    {
      if ( n0x6400000 )
      {
        v10 = (_QWORD *)sub_1402A1E30(n0x6400000);
      }
      else
      {
        v10 = 0;
      }
    }
    else
    {
      if ( n0x6400000 + 39 < n0x6400000 )
      {
        sub_1402DEE40();
      }
      v9 = sub_1402A1E30(n0x6400000 + 39);
      if ( !v9 )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v9;
    }
    memmove(v10, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    return (unsigned __int64)sub_1402FD6B0((const void **)a1, (__int64)v10, v8, a2);
  }
  return result;
}

// --- End Function: sub_140302260 (0x140302260) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 v13; // r13
  char result; // al
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  __int64 v18; // r15
  _QWORD *v19; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  __int64 *v22; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v24; // rcx
  _QWORD *v25; // rbx
  _BYTE *v26; // rdx
  _BYTE *v27; // rdx
  __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *v31; // r14
  __int64 *v32; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  __int64 v42; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *Buf2_1; // r15
  _QWORD **v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *v56; // rcx
  __m256 *Buf2_2; // rax
  __int64 *v58; // rax
  __int64 *v59; // r14
  __int64 v60; // rcx
  _QWORD *v61; // rbx
  _BYTE *v62; // rdx
  _BYTE *v63; // rdx
  __int64 v64; // r10
  __int64 v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 Buffer_3; // rax
  const void *Buffer_5; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  Stream *Stream; // rax
  int n2; // r8d
  Stream *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 Buffer_4; // rax
  const void *Buffer_6; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  Stream *Stream_2; // rax
  Stream *Stream_3; // rax
  const void **v103; // rsi
  _QWORD **v104; // rcx
  _QWORD *v105; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *v107; // rdi
  _QWORD *v108; // rcx
  __int64 *v109; // rbx
  _QWORD *v110; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  __int64 *v114; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  __int64 v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *v121; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 v123; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *v125; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  _QWORD *v129; // [rsp+128h] [rbp+88h] BYREF
  __int64 *v130; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *v131; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **v135; // [rsp+158h] [rbp+B8h] BYREF
  __int64 v136; // [rsp+160h] [rbp+C0h]
  __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  v121 = (_QWORD *)a5;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v13 = a6;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, a5, a6);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  v135 = 0;
  v15 = 0;
  v130 = (__int64 *)&v135;
  n0x400 = 0;
  v114 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !a6 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  v19 = v121;
  v20 = v112;
  v125 = v121;
  while ( 2 )
  {
    v21 = *((_BYTE *)v19 + 89) == 0;
    v131 = v19;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = v19;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    v123 = (unsigned __int64)v19;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = v19;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v114 = (__int64 *)sub_1402A1E30(0x18u);
        v15 = v114;
        if ( v114 )
        {
          v22 = v114;
          *v114 = 0;
          n0x400_1 = 0;
          v15[1] = 0;
          v24 = (__int64)v15;
          v15[2] = 0;
        }
        else
        {
          v15 = 0;
          v22 = 0;
          n0x400_1 = 0;
          v114 = 0;
          v24 = 0;
        }
        sub_140302260(v24, v13);
        v25 = v141;
        do
        {
          v26 = (_BYTE *)v22[1];
          if ( v26 == (_BYTE *)v22[2] )
          {
            sub_1402A47D0(v15, v26, v25);
          }
          else
          {
            *(_QWORD *)v26 = *v25;
            v22[1] += 8;
          }
          ++n0x400_1;
          ++v25;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        v19 = v125;
      }
      v27 = (_BYTE *)v15[1];
      if ( v27 == (_BYTE *)v15[2] )
      {
        __asm { vzeroupper }
        sub_1402A47D0(v15, v27, &v123);
      }
      else
      {
        *(_QWORD *)v27 = v19;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    v19[1] = sub_1402FD110(&v130, (__int64)v19);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64))v19[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    v123 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*v19, &v124, &v123, v28);
    v31 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    v32 = v130;
    do
    {
      v131 = v31;
      v31[10] = v18;
      v21 = v31[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)v31[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*v32 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)sub_1402A1E30(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)sub_1402A1E30(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *v32 = (__int64)v33;
        }
        v35 = (_BYTE *)v31[1];
        Size_2 = -1;
        memset(&v138, 0, sizeof(v138));
        Size_1 = -1;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)v31[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        v42 = *v32;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        Buf2_1 = *(__m256 **)v138.m256_f32;
        v129 = (_QWORD *)v42;
        v45 = *(_QWORD ***)v42;
        v46 = **(_QWORD ***)v42;
        if ( v46 == *(_QWORD **)v42 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = Buf2_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        v42 = (__int64)v129;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *(_QWORD *)(v42 + 8) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = sub_1402A1E30(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 32) = 0;
          *(_QWORD *)(v51 + 40) = 0;
          *(__m256 *)(v51 + 16) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*(_QWORD *)(v42 + 8);
          v53 = v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = (_QWORD *)v51;
          *v53 = v51;
          v54 = *(_QWORD *)*v32;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 40LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v56 = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v56 = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)v56 - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(v56);
          }
          v15 = v114;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            Buf2_2 = Buf2_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              Buf2_1 = *(__m256 **)&Buf2_1[-1].m256_f32[6];
              if ( (unsigned __int64)((char *)Buf2_2 - (char *)Buf2_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(Buf2_1);
          }
          v15 = v114;
          n0x400_2 = 0;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
        }
      }
      v31[1] = v55;
      n0x400 = n0xF;
      v129 = v31;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !v15 )
        {
          __asm { vzeroupper }
          v58 = (__int64 *)sub_1402A1E30(0x18u);
          v15 = v58;
          v114 = v58;
          if ( v58 )
          {
            *v58 = 0;
            v59 = v58;
            v58[1] = 0;
            v60 = (__int64)v58;
            v58[2] = 0;
          }
          else
          {
            v15 = 0;
            v114 = 0;
            v59 = 0;
            v60 = 0;
          }
          sub_140302260(v60, a6);
          v61 = v141;
          do
          {
            v62 = (_BYTE *)v59[1];
            if ( v62 == (_BYTE *)v59[2] )
            {
              sub_1402A47D0(v15, v62, v61);
            }
            else
            {
              *(_QWORD *)v62 = *v61;
              v59[1] += 8;
            }
            ++n0x400_2;
            ++v61;
          }
          while ( n0x400_2 < 0x400 );
          v31 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        v63 = (_BYTE *)v15[1];
        if ( v63 == (_BYTE *)v15[2] )
        {
          __asm { vzeroupper }
          sub_1402A47D0(v15, v63, &v129);
        }
        else
        {
          *(_QWORD *)v63 = v31;
          v15[1] += 8;
        }
      }
      else
      {
        v141[n0xF] = v31;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      v31 += 13;
      a13 = v30;
      *(_QWORD *)v116 = v31;
    }
    while ( v30 < v124 );
    v19 = v125;
LABEL_94:
    v28 = v137;
    v13 = a6;
    if ( v123 > 1 )
    {
      v28 = -1;
    }
    v64 = v123 + v117;
    v117 += v123;
LABEL_98:
    v19 += 13;
    v125 = v19;
    v131[10] = v28;
    if ( ++v132 < v13 )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v114 = v15;
  n0xF = n0x400;
  v117 = v64;
  if ( !v15 )
  {
    goto LABEL_106;
  }
  if ( !((v15[1] - *v15) >> 3) )
  {
    __debugbreak();
  }
  i = (char *)*v15;
  v114 = v15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 80LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 80LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 80) = -(__int64)(*(_QWORD *)(v71 + 80) != -1);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (v65 + 1) << 10;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    Buffer_5 = 0;
  }
  else
  {
    Buffer_3 = sub_1402A1E30(Size);
    Buffer_5 = (const void *)Buffer_3;
    if ( Buffer_3 )
    {
      Buffer_1 = (char *)Buffer_3;
      goto LABEL_131;
    }
  }
  v79 = Size + 15;
  if ( Size + 15 < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && qword_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, v121, a6, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            v121,
            a6,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    sub_1402F5120(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    sub_1402F5120(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((n0xF + 2 * v117 + v117 + 32) << 7);
    }
    n0x8000_2 = v93 + 128;
    if ( *p_n0x8000_1 < v93 + 128 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      Buffer_6 = 0;
    }
    else
    {
      Buffer_4 = sub_1402A1E30(n0x8000_2);
      Buffer_6 = (const void *)Buffer_4;
      if ( Buffer_4 )
      {
        Buffer_2 = (double *)Buffer_4;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 15;
    if ( n0x8000_2 + 15 < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      (__int64)v121,
      a6,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 128,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(Buffer_6);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  result = free_memory_wrapper(Buffer_5);
  v103 = v135;
  if ( v135 )
  {
    v104 = (_QWORD **)*v135;
    **((_QWORD **)*v135 + 1) = 0;
    v105 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = v105[5];
        v107 = (_QWORD *)*v105;
        if ( n0xF_2 > 0xF )
        {
          v108 = (_QWORD *)v105[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v108 - *(v108 - 1) - 8 > 0x1F )
            {
              goto LABEL_190;
            }
            v108 = (_QWORD *)*(v108 - 1);
          }
          free_memory_wrapper(v108);
        }
        v105[4] = 0;
        v105[5] = 15;
        *((_BYTE *)v105 + 16) = 0;
        free_memory_wrapper(v105);
        v105 = v107;
      }
      while ( v107 );
    }
    free_memory_wrapper(*v103);
    result = free_memory_wrapper(v103);
  }
  v109 = v114;
  if ( v114 )
  {
    v110 = (_QWORD *)*v114;
    if ( *v114 )
    {
      if ( ((v114[2] - (_QWORD)v110) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v110 - *(v110 - 1) - 8 > 0x1F )
        {
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        }
        v110 = (_QWORD *)*(v110 - 1);
      }
      free_memory_wrapper(v110);
      *v109 = 0;
      v109[1] = 0;
      v109[2] = 0;
    }
    return free_memory_wrapper(v109);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: swprintf (0x140303B50) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A2470();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0LL, va);
  if ( result < 0 )
  {
    return -1;
  }
  return result;
}

// --- End Function: swprintf (0x140303B50) ---

// --- Function: sub_140306C90 (0x140306C90) ---
_QWORD *__fastcall sub_140306C90(_QWORD *a1, _QWORD *a2, const char **a3, unsigned __int64 a4)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // r12
  unsigned __int64 v6; // rdi
  __int64 v14; // rsi
  __int64 v15; // rsi
  const char **v19; // [rsp+90h] [rbp+18h]

  v19 = a3;
  v4 = a1[3];
  v5 = 0LL;
  v6 = v4 & (a4 >> 7);
  _XMM7 = a4 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v6 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
    {
      break;
    }
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = *a1 + a1[3];
      return a2;
    }
    v5 += 16LL;
    v6 = v4 & (v6 + v5);
    if ( v5 > a1[3] )
    {
      __debugbreak();
    }
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v14, _EBX);
    v15 = v4 & (v6 + v14);
    if ( !_stricmp(*(const char **)(32 * v15 + a1[1]), *a3) )
    {
      break;
    }
    a3 = v19;
    _EBX &= _EBX - 1;
    if ( !_EBX )
    {
      goto LABEL_5;
    }
  }
  *a2 = v15 + *a1;
  a2[1] = 32 * v15 + a1[1];
  return a2;
}

// --- End Function: sub_140306C90 (0x140306C90) ---

// --- Function: sub_140306F70 (0x140306F70) ---
unsigned __int64 __fastcall sub_140306F70(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        int *a4,
        unsigned __int64 n4,
        char a6)
{
  __int64 v6; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rax
  _DWORD *v12; // rdx
  _DWORD *v13; // rdx
  unsigned __int64 n4_1; // rdx
  __int64 n8; // r8
  unsigned __int64 v16; // rdi
  unsigned __int64 n8_1; // rcx
  unsigned __int64 a3a; // [rsp+48h] [rbp+10h] BYREF

  v6 = *a4;
  if ( (_DWORD)v6 )
  {
    a3a = 4 * v6;
    v10 = sub_1403301D0(a1, 0, &a3a, n4, a6);
    v11 = a3a >> 2;
    *a4 = a3a >> 2;
  }
  else
  {
    v10 = 0;
    LODWORD(v11) = 0;
  }
  if ( a2 )
  {
    if ( v10 )
    {
      if ( a3 < (int)v11 )
      {
        LODWORD(v11) = a3;
      }
      if ( a2 != v10 )
      {
        v11 = (int)v11;
        if ( a2 > v10 || a2 + 4LL * (int)v11 <= v10 )
        {
          if ( (_DWORD)v11 )
          {
            v13 = (_DWORD *)v10;
            do
            {
              *v13 = *(_DWORD *)((char *)v13 + a2 - v10);
              ++v13;
              --v11;
            }
            while ( v11 );
          }
        }
        else if ( (_DWORD)v11 )
        {
          v12 = (_DWORD *)(v10 + 4 * ((int)v11 - 1LL));
          do
          {
            *v12 = *(_DWORD *)((char *)v12 + a2 - v10);
            --v12;
            --v11;
          }
          while ( v11 );
        }
      }
    }
    n4_1 = 4;
    a3a = 0;
    n8 = 8;
    if ( n4 > 4 )
    {
      n4_1 = n4;
    }
    v16 = a2 - ((n4_1 + 3) & ~(n4_1 - 1));
    n8_1 = 8;
    if ( n4_1 > 8 )
    {
      n8_1 = n4_1;
    }
    if ( v16 )
    {
      if ( n8_1 > 8 )
      {
        n8 = n8_1;
      }
      (*(void (__fastcall **)(unsigned __int64, unsigned __int64 *, __int64, _QWORD))(v16 - 8))(
        v16 - ((n8 + 7) & ~(n8 - 1)),
        &a3a,
        n8,
        0);
    }
  }
  return v10;
}

// --- End Function: sub_140306F70 (0x140306F70) ---

// --- Function: sub_140327A60 (0x140327A60) ---
const char *sub_140327A60()
{
  return "<unknown>";
}

// --- End Function: sub_140327A60 (0x140327A60) ---

// --- Function: sub_1403301D0 (0x1403301D0) ---
__int64 __fastcall sub_1403301D0(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 n4, unsigned __int8 a5)
{
  unsigned __int64 n4_1; // r8
  __int64 v7; // rsi
  __int64 v8; // r10
  unsigned __int64 v9; // rdx
  __int64 n8; // r11
  unsigned __int64 n8_1; // rcx
  __int64 (__fastcall *v12)(__int64, unsigned __int64 *, __int64, _QWORD); // rax
  __int64 v13; // rdi
  __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rdi
  unsigned __int64 n0x6400000; // rcx
  unsigned __int64 n32_1; // rax
  unsigned __int64 n32; // rcx
  __int64 n0x10000; // rdx
  unsigned __int64 n0x10000_1; // rcx
  __int64 v22; // rax
  __int64 result; // rax

  n4_1 = 4;
  if ( n4 > 4 )
  {
    n4_1 = n4;
  }
  v7 = (n4_1 + 3) & ~(n4_1 - 1);
  v8 = a2 - v7;
  if ( !a2 )
  {
    v8 = 0;
  }
  v9 = *a3;
  if ( *a3 )
  {
    v9 = v7 + ((v9 + 3) & 0xFFFFFFFFFFFFFFFCuLL);
    *a3 = v9;
  }
  n8 = 8;
  n8_1 = 8;
  if ( n4_1 > 8 )
  {
    n8_1 = n4_1;
  }
  if ( v8 )
  {
    v12 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *, __int64, _QWORD))(v8 - 8);
    if ( n8_1 > 8 )
    {
      n8 = n8_1;
    }
    v13 = (n8 + 7) & ~(n8 - 1);
    v14 = v8 - v13;
    if ( v9 )
    {
      *a3 = v9 + v13;
    }
    v15 = v12(v14, a3, n8, a5);
    v9 = *a3;
    if ( *a3 )
    {
      v9 -= v13;
      *a3 = v9;
    }
    v8 = v15 + v13;
    if ( !v15 )
    {
      v8 = 0;
    }
  }
  else if ( v9 )
  {
    if ( n8_1 > 8 )
    {
      n8 = n8_1;
    }
    v16 = (n8 + 7) & ~(n8 - 1);
    n0x6400000 = v9 + v16;
    *a3 = v9 + v16;
    if ( v9 + v16 )
    {
      if ( a5 )
      {
        n32_1 = n0x6400000 + 16;
        n32 = 32;
        if ( n32_1 > 0x20 )
        {
          do
          {
            n32 *= 2LL;
          }
          while ( n32 < n32_1 );
          n0x10000 = 0x10000;
          if ( n32 > 0x10000 )
          {
            n0x10000_1 = n32 >> 3;
            if ( n0x10000_1 > 0x10000 )
            {
              n0x10000 = n0x10000_1;
            }
            n32 = ~(n0x10000 - 1) & (n0x10000 + n32_1 - 1);
          }
        }
        n0x6400000 = n32 - 16;
        *a3 = n0x6400000;
      }
      v22 = sub_14739AFC0(n0x6400000, (struct _exception *)n8);
    }
    else
    {
      v22 = 0;
    }
    v9 = *a3;
    if ( *a3 )
    {
      v9 -= v16;
      *a3 = v9;
    }
    v8 = v16 + v22;
    if ( !v22 )
    {
      v8 = 0;
    }
    if ( v8 )
    {
      *(_QWORD *)(v8 - 8) = sub_140330370;
      v9 = *a3;
    }
  }
  if ( v9 )
  {
    *a3 = v9 - v7;
  }
  result = v7 + v8;
  if ( !v8 )
  {
    return 0;
  }
  return result;
}

// --- End Function: sub_1403301D0 (0x1403301D0) ---

// --- Function: sub_140330370 (0x140330370) ---
__int64 __fastcall sub_140330370(const void *a1, unsigned __int64 *a2, struct _exception *n8, char a4)
{
  unsigned __int64 n0x6400000; // rcx
  unsigned __int64 n32_1; // rcx
  unsigned __int64 n32; // rax
  __int64 n0x10000; // rdx
  unsigned __int64 n0x10000_1; // rax

  n0x6400000 = *a2;
  if ( a1 )
  {
    if ( n0x6400000 )
    {
      if ( (unsigned __int64)n8 > 8 )
      {
        *a2 = (unsigned __int64)&n8[-1].retval + n0x6400000;
      }
      return 0;
    }
    sub_14739AF10(a1);
    return 0;
  }
  else
  {
    if ( !n0x6400000 )
    {
      return 0;
    }
    if ( a4 )
    {
      n32_1 = n0x6400000 + 16;
      n32 = 32;
      if ( n32_1 > 0x20 )
      {
        do
        {
          n32 *= 2LL;
        }
        while ( n32 < n32_1 );
        n0x10000 = 0x10000;
        if ( n32 > 0x10000 )
        {
          n0x10000_1 = n32 >> 3;
          if ( n0x10000_1 > 0x10000 )
          {
            n0x10000 = n0x10000_1;
          }
          n32 = ~(n0x10000 - 1) & (n0x10000 + n32_1 - 1);
        }
      }
      n0x6400000 = n32 - 16;
      *a2 = n32 - 16;
    }
    return sub_14739AFC0(n0x6400000, n8);
  }
}

// --- End Function: sub_140330370 (0x140330370) ---

// --- Function: vector_dword_set_size (0x1403308D0) ---
// Sets the size of a dynamic array (vector) of DWORDs, reallocating the underlying
// buffer if necessary.  This function manages a vector-like structure where
// metadata is stored 4 bytes before the data pointer. The metadata DWORD contains
// the current size in the lower 31 bits and a flag in the high bit. If the high
// bit flag is set, the buffer's capacity (in elements) is stored in a DWORD
// immediately following the last used element.  @param ppVectorData Pointer to the
// variable holding the data pointer for the dynamic array. @param
// newSizeInElements The desired new size of the array in elements. @param
// resizeIfGrowing Flag controlling resize behavior:                        - If 1
// (true): Resizes only if the new size `newSizeInElements` is greater than the
// current capacity.                        - If 0 (false): Resizes if the new size
// `newSizeInElements` is different from the current capacity. @return Returns the
// minimum required size in bytes for the new data and its metadata (4 *
// newSizeInElements + 4). Returns a default pointer (`&unk_149808B07`) via
// `ppVectorData` on allocation failure.
unsigned __int64 __fastcall vector_dword_set_size(
        unsigned __int64 *ppVectorData,
        int newSizeInElements,
        char resizeIfGrowingOnly)
{
  unsigned __int64 pCurrentData; // r10
  int sizeAndFlagMetadata; // ecx
  int v7; // eax
  unsigned __int64 currentCapacityInElements; // r9
  unsigned __int64 pDataForRealloc; // rdx
  int needsResize; // eax
  unsigned __int64 pCurrentData_1; // rax
  unsigned __int64 requiredBytes; // rax
  __int64 newDataSizeInBytes; // rdx
  int newSizeInElements_1; // [rsp+50h] [rbp+18h] BYREF

  pCurrentData = *ppVectorData;
  sizeAndFlagMetadata = *(_DWORD *)(*ppVectorData - 4);
  v7 = 4 * sizeAndFlagMetadata;
  if ( sizeAndFlagMetadata >= 0 )
  {
    currentCapacityInElements = (unsigned __int64)v7 >> 2;
  }
  else
  {
    LODWORD(currentCapacityInElements) = *(_DWORD *)(v7 + pCurrentData);
  }
  pDataForRealloc = 0;
  needsResize = 0;
  if ( resizeIfGrowingOnly )
  {
    LOBYTE(needsResize) = newSizeInElements > (int)currentCapacityInElements;
  }
  else
  {
    LOBYTE(needsResize) = newSizeInElements != (_DWORD)currentCapacityInElements;
  }
  if ( needsResize )
  {
    newSizeInElements_1 = newSizeInElements;
    if ( sizeAndFlagMetadata )
    {
      pDataForRealloc = pCurrentData;
    }
    pCurrentData_1 = sub_140306F70(
                       (__int64)ppVectorData,
                       pDataForRealloc,
                       sizeAndFlagMetadata & 0x7FFFFFFF,
                       &newSizeInElements_1,
                       4u,
                       resizeIfGrowingOnly);
    *ppVectorData = pCurrentData_1;
    pCurrentData = pCurrentData_1;
    if ( !pCurrentData_1 )
    {
      requiredBytes = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
      *ppVectorData = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
      return requiredBytes;
    }
    LODWORD(currentCapacityInElements) = newSizeInElements_1;
  }
  newDataSizeInBytes = 4 * newSizeInElements;
  *(_DWORD *)(pCurrentData - 4) = newSizeInElements;
  requiredBytes = newDataSizeInBytes + 4;
  if ( 4LL * (int)currentCapacityInElements >= (unsigned __int64)(newDataSizeInBytes + 4) )
  {
    *(_DWORD *)(pCurrentData - 4) = newSizeInElements | 0x80000000;
    *(_DWORD *)(newDataSizeInBytes + pCurrentData) = currentCapacityInElements;
  }
  return requiredBytes;
}

// --- End Function: vector_dword_set_size (0x1403308D0) ---

// --- Function: sub_1403339F0 (0x1403339F0) ---
__int64 __fastcall sub_1403339F0(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 (__fastcall *p_sub_1403DCD10)(unsigned int, __int64, __int64); // rax

  sub_1403DE500();
  if ( (RCX_0 & 0x100000) != 0 )
  {
    p_sub_1403DCD10 = (__int64 (__fastcall *)(unsigned int, __int64, __int64))sub_1403DCA70;
  }
  else
  {
    sub_1403DCE50();
    p_sub_1403DCD10 = (__int64 (__fastcall *)(unsigned int, __int64, __int64))sub_1403DCD10;
  }
  psub_1403339F0 = p_sub_1403DCD10;
  return p_sub_1403DCD10(a1, (__int64)a2, a3);
}

// --- End Function: sub_1403339F0 (0x1403339F0) ---

// --- Function: sub_140333A50 (0x140333A50) ---
__int64 __fastcall sub_140333A50(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *p_sub_1403DCC30)(); // rax

  sub_1403DE500();
  if ( (RCX_0 & 0x100000) != 0 )
  {
    p_sub_1403DCC30 = (__int64 (__fastcall *)())sub_1403DCAD0;
  }
  else
  {
    sub_1403DCE50();
    p_sub_1403DCC30 = (__int64 (__fastcall *)())sub_1403DCC30;
  }
  off_1495F6C20[0] = p_sub_1403DCC30;
  return ((__int64 (__fastcall *)(_QWORD, __int64, __int64))p_sub_1403DCC30)(a1, a2, a3);
}

// --- End Function: sub_140333A50 (0x140333A50) ---

// --- Function: sub_140333B20 (0x140333B20) ---
__int64 __fastcall sub_140333B20(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  int C; // ecx

  sub_1403DCFB0();
  for ( off_1495F6C30[0] = (__int64 (__fastcall *)())sub_1403DCCA0; a3; --a3 )
  {
    C = *a2++;
    a1 = dword_14980B220[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_140333B20 (0x140333B20) ---

// --- Function: sub_140341580 (0x140341580) ---
char *__fastcall sub_140341580(char **a1, _DWORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _DWORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  _BYTE *v16; // rdx
  char *v17; // rbp
  char *Size; // r8

  v2 = a1[1];
  v4 = a1[2];
  if ( v2 == v4 )
  {
    v7 = 0x3FFFFFFFFFFFFFFFLL;
    v8 = (v2 - *a1) >> 2;
    if ( v8 == 0x3FFFFFFFFFFFFFFFLL )
    {
      unknown_libname_10();
    }
    v9 = (v4 - *a1) >> 2;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x3FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
      {
        v7 = v8 + 1;
      }
    }
    v12 = v7;
    v13 = (_DWORD *)sub_14038E0B0((__int64)a1, 4 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = a1[1];
    v16 = *a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = (char *)(v15 - v16);
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 4;
      Size = (char *)(a1[1] - v2);
      v16 = v2;
    }
    memmove(v14, v16, (size_t)Size);
    if ( *a1 )
    {
      sub_14039EFB0((__int64)a1, *a1, (a1[2] - *a1) & 0xFFFFFFFFFFFFFFFCuLL);
    }
    *a1 = (char *)v13;
    result = v17;
    a1[1] = (char *)&v13[v11];
    a1[2] = (char *)&v13[v12];
  }
  else
  {
    *(_DWORD *)v2 = *a2;
    result = a1[1];
    a1[1] = result + 4;
  }
  return result;
}

// --- End Function: sub_140341580 (0x140341580) ---

// --- Function: sub_140342370 (0x140342370) ---
char *__fastcall sub_140342370(__int64 a1, _BYTE *Src, _DWORD *a3)
{
  _BYTE *v3; // r9
  __int64 v4; // rsi
  __int64 v6; // rax
  __int64 v7; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // r8
  __int64 v13; // r15
  _DWORD *v14; // rdi
  void *v15; // rcx
  _BYTE *Src_2; // r8
  _BYTE *Src_1; // rdx
  char *v18; // rsi
  size_t Size; // r8
  char *result; // rax

  v3 = *(_BYTE **)a1;
  v4 = (__int64)&Src[-*(_QWORD *)a1] >> 2;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  v7 = 0x3FFFFFFFFFFFFFFFLL;
  if ( v6 == 0x3FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v10 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v3) >> 2;
  v11 = v6 + 1;
  v12 = v10 >> 1;
  if ( v10 <= 0x3FFFFFFFFFFFFFFFLL - (v10 >> 1) )
  {
    v7 = v12 + v10;
    if ( v12 + v10 < v11 )
    {
      v7 = v6 + 1;
    }
  }
  v13 = v7;
  v14 = (_DWORD *)sub_14038E0B0(a1, 4 * v7);
  v14[v4] = *a3;
  v15 = v14;
  Src_2 = *(_BYTE **)(a1 + 8);
  Src_1 = *(_BYTE **)a1;
  v18 = (char *)&v14[v4];
  if ( Src == Src_2 )
  {
    Size = Src_2 - Src_1;
  }
  else
  {
    memmove(v14, Src_1, Src - Src_1);
    v15 = v18 + 4;
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)Src;
    Src_1 = Src;
  }
  memmove(v15, Src_1, Size);
  if ( *(_QWORD *)a1 )
  {
    sub_14039EFB0(a1, *(const void **)a1, (*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFFCuLL);
  }
  *(_QWORD *)a1 = v14;
  result = v18;
  *(_QWORD *)(a1 + 8) = &v14[v11];
  *(_QWORD *)(a1 + 16) = &v14[v13];
  return result;
}

// --- End Function: sub_140342370 (0x140342370) ---

// --- Function: sub_140345820 (0x140345820) ---
unsigned __int64 __fastcall sub_140345820(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  const void *v6; // rdx
  unsigned __int64 result; // rax

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    do
    {
      sub_140345820(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      result = sub_14039EFB0(a2, v6, 0x30uLL);
    }
    while ( !*((_BYTE *)v3 + 25) );
  }
  return result;
}

// --- End Function: sub_140345820 (0x140345820) ---

// --- Function: sub_14034CC90 (0x14034CC90) ---
_QWORD *__fastcall sub_14034CC90(_QWORD *a1, __int64 a2, _QWORD *p__RSI)
{
  _QWORD *v3; // rbx
  __int64 v4; // rdi

  v3 = a1;
  if ( *p__RSI )
  {
    for ( ; a2; --a2 )
    {
      *v3++ = *p__RSI;
    }
    return v3;
  }
  else
  {
    v4 = a2;
    memset(a1, 0, 8 * a2);
    return &v3[v4];
  }
}

// --- End Function: sub_14034CC90 (0x14034CC90) ---

// --- Function: submitTraceContext (0x14034E9F0) ---
// Prepares a trace context structure with specific handler functions and metadata,
// then submits this context along with other logging parameters (level, category,
// message, tags, etc.) to the core logging function `sub_140302350`.
char __fastcall submitTraceContext(
        int log_level,
        __int64 category_ptr,
        void *message_format,
        __int64 arg_ptr_1,
        __int64 trace_context_handlers,
        int status_flags,
        _QWORD *tags_ptr,
        __int64 *list_ptr,
        __int64 thread_log_context_slot)
{
  __int64 status_flags_storage; // [rsp+18h] [rbp-88h]
  __int64 trace_context_handlers_data[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n256; // [rsp+88h] [rbp-18h]
  __int64 n176; // [rsp+90h] [rbp-10h]

  trace_context_handlers_data[0] = thread_log_context_slot;
  trace_context_handlers_data[1] = (__int64)"TraceContext";
  trace_context_handlers_data[3] = (__int64)sub_1403E6C00;
  trace_context_handlers_data[4] = (__int64)sub_1403E6700;
  trace_context_handlers_data[6] = (__int64)sub_1403E2C50;
  trace_context_handlers_data[8] = (__int64)sub_1403E02C0;
  trace_context_handlers_data[9] = (__int64)sub_1403DFFB0;
  LODWORD(status_flags_storage) = status_flags;
  n256 = 256;
  trace_context_handlers_data[2] = 0;
  trace_context_handlers_data[5] = 0;
  trace_context_handlers_data[7] = 0;
  trace_context_handlers_data[10] = -1;
  n176 = 176;
  return sub_140302350(
           log_level,
           category_ptr,
           message_format,
           arg_ptr_1,
           (__int64)trace_context_handlers_data,
           1,
           trace_context_handlers,
           status_flags_storage,
           tags_ptr,
           list_ptr);
}

// --- End Function: submitTraceContext (0x14034E9F0) ---

// --- Function: sub_140357780 (0x140357780) ---
_QWORD *__fastcall sub_140357780(_QWORD *a1, _QWORD *a2)
{
  *a1 = (char *)&qword_149808ABC + 4;
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_140357780 (0x140357780) ---

// --- Function: sub_1403577A0 (0x1403577A0) ---
_QWORD *__fastcall sub_1403577A0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149808ABC + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149808ABC + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_1403577A0 (0x1403577A0) ---

// --- Function: sub_1403577C0 (0x1403577C0) ---
void **__fastcall sub_1403577C0(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149808ABC + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)sub_14739AFC0(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
    {
      memcpy(*a1, *a2, Size);
    }
  }
  return a1;
}

// --- End Function: sub_1403577C0 (0x1403577C0) ---

// --- Function: CreateStringObjectFromString (0x140357920) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **__fastcall CreateStringObjectFromString(void **ppStringObjectData, _BYTE *pszInputString)
{
  __int64 inputStringLength; // rbx
  _DWORD *pAllocatedBuffer; // rax

  *ppStringObjectData = (char *)&qword_149808ABC + 4;
  if ( !pszInputString )
  {
    return ppStringObjectData;
  }
  inputStringLength = -1;
  do
  {
    ++inputStringLength;
  }
  while ( pszInputString[inputStringLength] );
  if ( (_DWORD)inputStringLength )
  {
    pAllocatedBuffer = (_DWORD *)sub_14739AFC0((int)inputStringLength + 9LL, 0);
    *ppStringObjectData = pAllocatedBuffer + 2;
    *pAllocatedBuffer = inputStringLength;
    pAllocatedBuffer[1] = inputStringLength;
    *((_BYTE *)*ppStringObjectData + (int)inputStringLength) = 0;
    if ( *ppStringObjectData != pszInputString )
    {
      memcpy(*ppStringObjectData, pszInputString, (int)inputStringLength);
    }
  }
  return ppStringObjectData;
}

// --- End Function: CreateStringObjectFromString (0x140357920) ---

// --- Function: sub_1403579C0 (0x1403579C0) ---
void **__fastcall sub_1403579C0(void **a1, void *a2, size_t Size)
{
  _DWORD *v6; // rax

  *a1 = (char *)&qword_149808ABC + 4;
  if ( Size )
  {
    v6 = (_DWORD *)sub_14739AFC0(Size + 9, 0LL);
    *a1 = v6 + 2;
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != a2 )
    {
      memcpy(*a1, a2, Size);
    }
  }
  return a1;
}

// --- End Function: sub_1403579C0 (0x1403579C0) ---

// --- Function: initializeEmptyStringStructure (0x140357A40) ---
// Initializes the string structure pointed to by `a1` to represent an empty string
// by setting its internal pointer to the global empty string sentinel
// `qword_149808ABC + 4`.
void __fastcall initializeEmptyStringStructure(_QWORD *string_struct_ptr)
{
  *string_struct_ptr = (char *)&qword_149808ABC + 4;
}

// --- End Function: initializeEmptyStringStructure (0x140357A40) ---

// --- Function: sub_14035E310 (0x14035E310) ---
__int64 __fastcall sub_14035E310(__int64 a1, _BYTE *a2)
{
  size_t Size; // rbx
  void *v5; // rax

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  if ( !a2 )
  {
    return a1;
  }
  Size = -1;
  do
  {
    ++Size;
  }
  while ( a2[Size] );
  if ( Size )
  {
    v5 = (void *)sub_1402A1E30(Size + 1);
    *(_QWORD *)a1 = v5;
    memcpy(v5, a2, Size);
    *(_BYTE *)(Size + *(_QWORD *)a1) = 0;
  }
  return a1;
}

// --- End Function: sub_14035E310 (0x14035E310) ---

// --- Function: initialize_vector_empty (0x14035E3B0) ---
// Initializes a container structure (likely a vector or similar) pointed to by
// `container_ptr` to an empty state by setting its start, end, and capacity
// pointers/markers to null/zero.
_QWORD *__fastcall initialize_vector_empty(_QWORD *container_ptr)
{
  container_ptr[2] = 0;
  *container_ptr = 0;
  container_ptr[1] = 0;
  return container_ptr;
}

// --- End Function: initialize_vector_empty (0x14035E3B0) ---

// --- Function: sub_14035F230 (0x14035F230) ---
__int64 __fastcall sub_14035F230(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *a2;
  result = a1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

// --- End Function: sub_14035F230 (0x14035F230) ---

// --- Function: sub_14035F240 (0x14035F240) ---
__int64 __fastcall sub_14035F240(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0LL;
  result = a1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

// --- End Function: sub_14035F240 (0x14035F240) ---

// --- Function: InitializeDataCoreStructData (0x1403684F0) ---
// Initializes a 64-byte structure buffer with the provided data.  Structure
// Layout: - Offset 0x00 (QWORD): `field_0` - Offset 0x08 (QWORD): `field_8` -
// Offset 0x10 (QWORD): `field_16` - Offset 0x18 (QWORD): `field_24` - Offset 0x20
// (BYTE):  `field_32` - Offset 0x28 (QWORD): `field_40` - Offset 0x30 (QWORD): 0 -
// Offset 0x38 (QWORD): Masked address related to `unk_149808B07` (potentially type
// info or default array pointer).  @param pStructData Pointer to the 64-byte
// structure buffer to initialize. @param field_0 Value for offset 0x00. @param
// field_8 Value for offset 0x08. @param field_16 Value for offset 0x10. @param
// field_24 Value for offset 0x18. @param field_32 Value for offset 0x20. @param
// field_40 Value for offset 0x28. @return Returns the pointer to the initialized
// structure (`pStructData`).
__int64 __fastcall InitializeDataCoreStructData(
        __int64 pStructData,
        __int64 field_0,
        __int64 field_8,
        __int64 field_16,
        __int64 field_24,
        char field_32,
        __int64 field_40)
{
  __int64 pInitializedStructData; // rax

  *(_QWORD *)(pStructData + 24) = field_24;
  *(_BYTE *)(pStructData + 32) = field_32;
  *(_QWORD *)(pStructData + 40) = field_40;
  *(_QWORD *)pStructData = field_0;
  *(_QWORD *)(pStructData + 56) = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
  pInitializedStructData = pStructData;
  *(_QWORD *)(pStructData + 8) = field_8;
  *(_QWORD *)(pStructData + 16) = field_16;
  *(_QWORD *)(pStructData + 48) = 0;
  return pInitializedStructData;
}

// --- End Function: InitializeDataCoreStructData (0x1403684F0) ---

// --- Function: DestroyStringObject (0x14036D270) ---
// Deallocates the memory buffer associated with a string object created by
// `CreateStringObjectFromString`.  It accesses metadata stored 8 bytes before the
// provided data pointer to get the allocation base pointer required by the
// deallocation function `sub_14739AF10`.  @param ppStringObjectData Pointer to the
// variable holding the pointer to the string object's data.
void __fastcall DestroyStringObject(_QWORD *ppStringObjectData)
{
  int *pStringMetadata; // rcx

  pStringMetadata = (int *)(*ppStringObjectData - 8LL);
  if ( pStringMetadata[1] > 0 )
  {
    sub_14739AF10(pStringMetadata);
  }
}

// --- End Function: DestroyStringObject (0x14036D270) ---

// --- Function: sub_14036D3C0 (0x14036D3C0) ---
__int64 __fastcall sub_14036D3C0(__int64 a1)
{
  __int64 (__fastcall ***v1)(_QWORD, __int64); // rcx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = *(__int64 (__fastcall ****)(_QWORD, __int64))a1;
    if ( v1 )
    {
      return (**v1)(v1, 1LL);
    }
  }
  return result;
}

// --- End Function: sub_14036D3C0 (0x14036D3C0) ---

// --- Function: sub_14036F160 (0x14036F160) ---
__int64 __fastcall sub_14036F160(__int64 a1)
{
  const void *v2; // rcx
  __int64 result; // rax

  v2 = *(const void **)a1;
  if ( v2 )
  {
    if ( !*(_BYTE *)(a1 + 8) )
    {
      result = free_memory_wrapper(v2);
    }
    *(_QWORD *)a1 = 0LL;
  }
  return result;
}

// --- End Function: sub_14036F160 (0x14036F160) ---

// --- Function: sub_140374480 (0x140374480) ---
void **__fastcall sub_140374480(void **a1, void **a2)
{
  void *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 - 2) )
  {
    sub_1403E4C30(a2, 0LL, 32);
  }
  return a1;
}

// --- End Function: sub_140374480 (0x140374480) ---

// --- Function: copyStringStructure (0x1403744C0) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
void **__fastcall copyStringStructure(void **dest_string_struct_ptr, const void **src_string_struct_ptr)
{
  unsigned __int64 src_size; // rdi

  src_size = *((int *)*src_string_struct_ptr - 2);
  sub_1403E4C30(dest_string_struct_ptr, src_size, 32);
  if ( src_size && *dest_string_struct_ptr != *src_string_struct_ptr )
  {
    memcpy(*dest_string_struct_ptr, *src_string_struct_ptr, src_size);
  }
  return dest_string_struct_ptr;
}

// --- End Function: copyStringStructure (0x1403744C0) ---

// --- Function: assignCStringToStringStructure (0x140374520) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **string_struct_ptr, _BYTE *c_string)
{
  __int64 c_string_length; // rax

  if ( c_string )
  {
    c_string_length = -1;
    do
    {
      ++c_string_length;
    }
    while ( c_string[c_string_length] );
    sub_1403D9750(string_struct_ptr, c_string, (int)c_string_length);
    return string_struct_ptr;
  }
  else
  {
    sub_1403D9750(string_struct_ptr, 0, 0);
    return string_struct_ptr;
  }
}

// --- End Function: assignCStringToStringStructure (0x140374520) ---

// --- Function: sub_1403762E0 (0x1403762E0) ---
__int64 *__fastcall sub_1403762E0(__int64 *a1, __int64 *a2)
{
  __int64 v2; // r8
  char v3; // al
  __int64 *result; // rax

  v2 = *a1;
  *a1 = *a2;
  v3 = *((_BYTE *)a2 + 8);
  *a2 = v2;
  LOBYTE(v2) = *((_BYTE *)a1 + 8);
  *((_BYTE *)a1 + 8) = v3;
  result = a1;
  *((_BYTE *)a2 + 8) = v2;
  return result;
}

// --- End Function: sub_1403762E0 (0x1403762E0) ---

// --- Function: sub_140376300 (0x140376300) ---
__int64 __fastcall sub_140376300(__int64 a1, ULONG_PTR **a2)
{
  ULONG_PTR *v2; // rax
  bool v4; // zf
  ULONG_PTR *v5; // rdx

  v2 = *a2;
  v4 = *a2 == 0LL;
  v5 = (ULONG_PTR *)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  if ( !v4 )
  {
    v5 = v2;
  }
  sub_14038FC80(a1, v5);
  return a1;
}

// --- End Function: sub_140376300 (0x140376300) ---

// --- Function: sub_140376330 (0x140376330) ---
__int64 __fastcall sub_140376330(__int64 a1, _BYTE *a2)
{
  sub_14038FC80(a1, a2);
  return a1;
}

// --- End Function: sub_140376330 (0x140376330) ---

// --- Function: sub_14037CCB0 (0x14037CCB0) ---
bool __fastcall sub_14037CCB0(_QWORD *a1, _QWORD *a2)
{
  return *a1 < *a2;
}

// --- End Function: sub_14037CCB0 (0x14037CCB0) ---

// --- Function: sub_140380E40 (0x140380E40) ---
void **__fastcall sub_140380E40(void **a1, char **a2)
{
  sub_1403DB450(a1, *a2, *((int *)*a2 - 2));
  return a1;
}

// --- End Function: sub_140380E40 (0x140380E40) ---

// --- Function: sub_140380E90 (0x140380E90) ---
void **__fastcall sub_140380E90(void **a1, char *a2)
{
  __int64 Size; // rax

  if ( a2 )
  {
    Size = -1;
    do
    {
      ++Size;
    }
    while ( a2[Size] );
    sub_1403DB450(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DB450(a1, 0, 0);
    return a1;
  }
}

// --- End Function: sub_140380E90 (0x140380E90) ---

// --- Function: sub_14038E0B0 (0x14038E0B0) ---
__int64 __fastcall sub_14038E0B0(__int64 a1, unsigned __int64 n0x6400000)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403AF4C0();
  n0x40 = (n0x6400000 >> 8) + ((_BYTE)n0x6400000 != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
    {
      goto LABEL_7;
    }
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 64LL;
      if ( n0x4000 >= 0x4000 )
      {
        goto LABEL_2;
      }
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
      {
        n0x40_1 = -1;
      }
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
        {
          goto LABEL_2;
        }
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; n0x4000_2 + 64 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL); v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = -1 )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 64LL;
    }
    if ( n0x4000_2 < n0x4000 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 64)) - 1;
    }
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056A090((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056A0D0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_140569F50((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = sub_14739AFC0(n0x6400000, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_14038E0B0 (0x14038E0B0) ---

// --- Function: sub_14038FC80 (0x14038FC80) ---
void __fastcall sub_14038FC80(__int64 a1, _BYTE *a2)
{
  unsigned __int64 Size_1; // r8
  size_t Size; // rbx
  _BYTE *v6; // rax
  const void *ptr_to_free; // rcx

  if ( !*(_BYTE *)(a1 + 8) )
  {
    if ( a2 )
    {
      Size_1 = -1;
      Size = -1;
      do
      {
        ++Size;
      }
      while ( a2[Size] );
      v6 = *(_BYTE **)a1;
      if ( Size )
      {
        if ( v6 )
        {
          do
          {
            ++Size_1;
          }
          while ( v6[Size_1] );
          if ( Size <= Size_1 )
          {
            goto LABEL_11;
          }
          free_memory_wrapper(*(const void **)a1);
          *(_QWORD *)a1 = 0;
        }
        v6 = (_BYTE *)sub_1402A1E30(Size + 1);
        *(_QWORD *)a1 = v6;
LABEL_11:
        memcpy(v6, a2, Size);
        *(_BYTE *)(Size + *(_QWORD *)a1) = 0;
        return;
      }
      if ( v6 )
      {
        free_memory_wrapper(*(const void **)a1);
        *(_QWORD *)a1 = 0;
      }
    }
    else
    {
      ptr_to_free = *(const void **)a1;
      if ( ptr_to_free )
      {
        free_memory_wrapper(ptr_to_free);
        *(_QWORD *)a1 = 0;
      }
    }
  }
}

// --- End Function: sub_14038FC80 (0x14038FC80) ---

// --- Function: sub_140390550 (0x140390550) ---
void __fastcall sub_140390550(void **Src, void *a2)
{
  const void *ptr_to_free; // rcx

  ptr_to_free = *Src;
  if ( ptr_to_free && !*((_BYTE *)Src + 8) )
  {
    free_memory_wrapper(ptr_to_free);
  }
  *Src = a2;
  *((_BYTE *)Src + 8) = 1;
}

// --- End Function: sub_140390550 (0x140390550) ---

// --- Function: sub_140397520 (0x140397520) ---
FARPROC __fastcall sub_140397520(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
    {
      return result;
    }
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
  {
    return GetProcAddress(hModule_1, lpProcName);
  }
  else
  {
    return v7;
  }
}

// --- End Function: sub_140397520 (0x140397520) ---

// --- Function: sub_14039EBB0 (0x14039EBB0) ---
__int64 sub_14039EBB0(const char *a1, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, a1);
  if ( qword_14981D3D8 && Parameter_3 )
  {
    if ( qword_14981D2D0 )
    {
      return (*(__int64 (__fastcall **)(__int64, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_14981D2D0 + 8LL))(
               qword_14981D2D0,
               0LL,
               a1,
               (__int64 *)va);
    }
  }
  return result;
}

// --- End Function: sub_14039EBB0 (0x14039EBB0) ---

// --- Function: sub_14039EFB0 (0x14039EFB0) ---
void __fastcall sub_14039EFB0(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403AF4C0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 32) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; v7 + 64 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 40) = 0 )
    {
      v11 = v7;
      v7 += 64LL;
    }
    if ( v7 < v8 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~((1LL << ((__int64)v8 % 64)) - 1);
    }
  }
  else
  {
    sub_14739AF10(a2);
  }
}

// --- End Function: sub_14039EFB0 (0x14039EFB0) ---

// --- Function: sub_1403A5050 (0x1403A5050) ---
void **sub_1403A5050(void **a1, const char *Format, ...)
{
  _QWORD *v4; // rdi
  int BufferCount_2; // eax
  int BufferCount_1; // ecx
  size_t BufferCount; // rbx
  va_list va; // [rsp+70h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_1402A2470();
  BufferCount_2 = _stdio_common_vsprintf(*v4 | 2LL, 0, 0, Format, 0, va);
  if ( BufferCount_2 < 0 )
  {
    BufferCount_2 = -1;
  }
  BufferCount_1 = 0;
  if ( BufferCount_2 >= 0 )
  {
    BufferCount_1 = BufferCount_2;
  }
  BufferCount = BufferCount_1;
  sub_1403E4C30(a1, BufferCount_1, 32);
  _stdio_common_vsprintf(*v4 | 1LL, (char *)*a1, BufferCount, Format, 0, va);
  return a1;
}

// --- End Function: sub_1403A5050 (0x1403A5050) ---

// --- Function: sub_1403AA930 (0x1403AA930) ---
_QWORD *__fastcall sub_1403AA930(_QWORD *a1, _QWORD *a2)
{
  _DWORD *v2; // rax
  size_t Size; // rdi
  _DWORD *v6; // rax
  _DWORD *v7; // rdx
  _BYTE *Src_1; // rbx
  size_t Size_2; // rbp
  int *v10; // r14
  size_t Size_1; // rdi
  unsigned __int8 *Src_2; // rcx
  __int64 v13; // rdx
  unsigned __int64 n0x2D; // rax
  _DWORD *v15; // rax
  _BYTE *Src_3; // rcx
  unsigned __int64 Size_3; // rcx
  _DWORD *v19; // rax
  void *Src; // [rsp+40h] [rbp+8h] BYREF

  v2 = (_DWORD *)*a2;
  Src = (char *)&qword_149808ABC + 4;
  Size = (int)*(v2 - 2);
  if ( (_DWORD)Size )
  {
    v6 = (_DWORD *)sub_14739AFC0(Size + 9, 0);
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)v6 + Size + 8) = 0;
    v7 = (_DWORD *)*a2;
    Src = v6 + 2;
    if ( v6 + 2 != v7 )
    {
      memcpy(v6 + 2, v7, Size);
    }
  }
  sub_1403C9BC0(&Src);
  Src_1 = Src;
  Size_2 = *((int *)Src - 2);
  v10 = (int *)((char *)Src - 8);
  Size_1 = Size_2;
  Src_2 = (unsigned __int8 *)Src + Size_2 - 1;
  if ( Src_2 < Src )
  {
LABEL_9:
    *a1 = (char *)&qword_149808ABC + 4;
    if ( !(_DWORD)Size_2 )
    {
      goto LABEL_13;
    }
    v15 = (_DWORD *)sub_14739AFC0(Size_2 + 9, 0);
    Src_3 = v15 + 2;
    *v15 = Size_2;
    v15[1] = Size_2;
    *((_BYTE *)v15 + Size_2 + 8) = 0;
    goto LABEL_11;
  }
  v13 = 0x200000000801LL;
  while ( 1 )
  {
    n0x2D = *Src_2;
    LOBYTE(n0x2D) = n0x2D - 47;
    if ( (unsigned __int8)n0x2D <= 0x2Du )
    {
      if ( _bittest64(&v13, n0x2D) )
      {
        break;
      }
    }
    if ( --Src_2 < Src )
    {
      goto LABEL_9;
    }
  }
  *a1 = (char *)&qword_149808ABC + 4;
  Size_3 = Src_2 - Src_1 + 1;
  if ( Size_3 < Size_2 )
  {
    Src_1 += Size_3;
    Size_1 = Size_2 - Size_3;
    if ( Size_2 != Size_3 )
    {
      v19 = (_DWORD *)sub_14739AFC0(Size_1 + 9, 0);
      Src_3 = v19 + 2;
      *v19 = Size_1;
      v19[1] = Size_1;
      *((_BYTE *)v19 + Size_1 + 8) = 0;
LABEL_11:
      *a1 = Src_3;
      if ( Src_3 != Src_1 )
      {
        memcpy(Src_3, Src_1, Size_1);
      }
    }
  }
LABEL_13:
  if ( v10[1] > 0 )
  {
    sub_14739AF10(v10);
  }
  return a1;
}

// --- End Function: sub_1403AA930 (0x1403AA930) ---

// --- Function: sub_1403AF4C0 (0x1403AF4C0) ---
__int64 sub_1403AF4C0()
{
  __int64 v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  result = *(_QWORD *)v0;
  if ( !*(_QWORD *)v0 )
  {
    v2 = (_QWORD *)sub_1402A1E30(0x828u);
    if ( v2 )
    {
      v2[3] = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)v0 = v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 192);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 192) = v6 | 1;
      _tlregdtor((__int64)sub_147E51590);
    }
    return *(_QWORD *)v0;
  }
  return result;
}

// --- End Function: sub_1403AF4C0 (0x1403AF4C0) ---

// --- Function: sub_1403B2070 (0x1403B2070) ---
__int64 __fastcall sub_1403B2070(_QWORD *pDataCore, _QWORD *p__XMM0)
{
  _QWORD *v2; // rbx
  int v5; // eax
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // r14
  unsigned __int128 v8; // rax
  __int64 v9; // r10
  __int64 v12; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  _QWORD *v18; // r8
  __int64 v21; // rdx
  __int64 v22; // r9
  _QWORD *v24; // [rsp+28h] [rbp-30h]

  v2 = p__XMM0 + 1;
  if ( *(_OWORD *)p__XMM0 == 0 )
  {
    return 0;
  }
  v5 = psub_1403339F0(0xFFFFFFFF, (__int64)p__XMM0, 16);
  v6 = pDataCore[4];
  v7 = 0;
  v8 = (unsigned int)~v5 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v9 = v6 & ((*((_QWORD *)&v8 + 1) + (_QWORD)v8) >> 7);
  _XMM2 = (BYTE8(v8) + (_BYTE)v8) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v12 = pDataCore[1];
    _XMM1 = *(_OWORD *)(v12 + v9);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
    {
      break;
    }
LABEL_8:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      v18 = v24;
      v22 = v12 + v6;
      v21 = v12;
      goto LABEL_13;
    }
    v7 += 16LL;
    v9 = v6 & (v7 + v9);
    if ( v7 > v6 )
    {
      __debugbreak();
    }
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v16, _EAX);
    v17 = v6 & (v9 + v16);
    v18 = (_QWORD *)(pDataCore[2] + 24 * v17);
    if ( *v18 == *p__XMM0 && v18[1] == *v2 )
    {
      break;
    }
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v12 = pDataCore[1];
      goto LABEL_8;
    }
  }
  v21 = pDataCore[1];
  v22 = v21 + v17;
LABEL_13:
  if ( v22 == v21 + v6 )
  {
    return 0;
  }
  else
  {
    return v18[2];
  }
}

// --- End Function: sub_1403B2070 (0x1403B2070) ---

// --- Function: sub_1403BB9F0 (0x1403BB9F0) ---
bool __fastcall sub_1403BB9F0(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BB9F0 (0x1403BB9F0) ---

// --- Function: sub_1403BF6A0 (0x1403BF6A0) ---
char **__fastcall sub_1403BF6A0(char **a1)
{
  char *v1; // r9
  char v3; // al
  char v4; // cl

  v1 = *a1;
  v3 = **a1;
  if ( v3 )
  {
    do
    {
      ++v1;
      v4 = v3 + 32;
      if ( (unsigned __int8)(v3 - 65) > 0x19u )
      {
        v4 = v3;
      }
      *(v1 - 1) = v4;
      v3 = *v1;
    }
    while ( *v1 );
  }
  return a1;
}

// --- End Function: sub_1403BF6A0 (0x1403BF6A0) ---

// --- Function: sub_1403D95E0 (0x1403D95E0) ---
char *__fastcall sub_1403D95E0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = sub_14739AFC0(a2 + 9, 0LL);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149808ABC + 4;
    *a1 = (char *)&qword_149808ABC + 4;
  }
  return result;
}

// --- End Function: sub_1403D95E0 (0x1403D95E0) ---

// --- Function: sub_1403D9750 (0x1403D9750) ---
void *__fastcall sub_1403D9750(void **a1, void *a2, size_t Size)
{
  char *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = (char *)*a1;
  if ( Size > *((int *)v5 - 1) )
  {
    v7 = (int *)(v5 - 8);
    if ( v7[1] > 0 )
    {
      sub_14739AF10(v7);
    }
    *a1 = (char *)&qword_149808ABC + 4;
    if ( Size )
    {
      v8 = (_DWORD *)sub_14739AFC0(Size + 9, 0LL);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
  {
    memcpy(*a1, a2, Size);
  }
  *((_DWORD *)*a1 - 2) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403D9750 (0x1403D9750) ---

// --- Function: sub_1403DB450 (0x1403DB450) ---
void __fastcall sub_1403DB450(void **a1, char *a2, size_t Size)
{
  char *v4; // rbp
  __int64 Size_1; // r13
  unsigned __int64 n8; // r15
  _DWORD *v9; // rax
  char *v10; // rcx

  if ( Size )
  {
    v4 = (char *)*a1;
    Size_1 = *((int *)*a1 - 2);
    if ( Size + Size_1 <= *((int *)*a1 - 1) )
    {
      if ( &v4[Size_1] != a2 )
      {
        memcpy(&v4[Size_1], a2, Size);
      }
      *((_DWORD *)*a1 - 2) += Size;
      *((_BYTE *)*a1 + *((int *)*a1 - 2)) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= Size + Size_1 )
      {
        n8 = Size + Size_1;
      }
      if ( n8 )
      {
        if ( n8 < 8 )
        {
          n8 = 8;
        }
        v9 = (_DWORD *)sub_14739AFC0(n8 + 9, 0);
        *a1 = v9 + 2;
        *v9 = n8;
        v9[1] = n8;
        *((_BYTE *)*a1 + n8) = 0;
        if ( *a1 != v4 )
        {
          memcpy(*a1, v4, Size_1);
        }
        v10 = (char *)*a1 + Size_1;
        if ( v10 != a2 )
        {
          memcpy(v10, a2, Size);
        }
        *((_DWORD *)*a1 - 2) = Size + Size_1;
        *((_BYTE *)*a1 + Size_1 + Size) = 0;
      }
      if ( *((int *)v4 - 1) > 0 )
      {
        sub_14739AF10(v4 - 8);
      }
    }
  }
}

// --- End Function: sub_1403DB450 (0x1403DB450) ---

// --- Function: sub_1403DBFB0 (0x1403DBFB0) ---
char *__fastcall sub_1403DBFB0(_QWORD *a1)
{
  char *result; // rax

  result = (char *)&qword_149808ABC + 4;
  *a1 = (char *)&qword_149808ABC + 4;
  return result;
}

// --- End Function: sub_1403DBFB0 (0x1403DBFB0) ---

// --- Function: sub_1403DCA70 (0x1403DCA70) ---
unsigned __int64 __fastcall sub_1403DCA70(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r9

  result = a1;
  v4 = 0LL;
  if ( (a3 & 0xFFFFFFFFFFFFFFF8uLL) != 0 )
  {
    do
    {
      result = _mm_crc32_u64(result, *(_QWORD *)(v4 + a2));
      v4 += 8LL;
    }
    while ( v4 < (a3 & 0xFFFFFFFFFFFFFFF8uLL) );
  }
  if ( (a3 & 4) != 0 )
  {
    result = _mm_crc32_u32(result, *(_DWORD *)(v4 + a2));
    v4 += 4LL;
  }
  if ( (a3 & 2) != 0 )
  {
    result = _mm_crc32_u16(result, *(_WORD *)(v4 + a2));
    v4 += 2LL;
  }
  if ( (a3 & 1) != 0 )
  {
    return _mm_crc32_u8(result, *(_BYTE *)(v4 + a2));
  }
  return result;
}

// --- End Function: sub_1403DCA70 (0x1403DCA70) ---

// --- Function: sub_1403DCAD0 (0x1403DCAD0) ---
unsigned __int64 __fastcall sub_1403DCAD0(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r14
  __m128i v11; // xmm3
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // r15
  unsigned __int8 *v15; // rbx
  unsigned __int8 v16; // al
  unsigned __int64 result; // rax
  unsigned __int8 v18[16]; // [rsp+20h] [rbp-48h] BYREF

  _XMM5 = XMM5;
  v4 = 0LL;
  v6 = 0LL;
  v7 = a1;
  if ( (a3 & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
  {
    do
    {
      _XMM3 = *(__m128i *)(a2 + v6);
      __asm
      {
        vpcmpgtb xmm1, xmm5, xmm3
        vpcmpgtb xmm0, xmm3, xmm4
      }
      v11 = _mm_add_epi8((__m128i)(_XMM1 & _XMM0 & xmmword_147F49EA0), _XMM3);
      v6 += 16LL;
      LODWORD(v7) = _mm_crc32_u64(_mm_crc32_u64(v7, v11.m128i_u64[0]), _mm_extract_epi64(v11, 1));
    }
    while ( v6 < (a3 & 0xFFFFFFFFFFFFFFF0uLL) );
  }
  v12 = 0LL;
  v13 = a3 - v6;
  if ( v13 )
  {
    v14 = a2 - (_QWORD)v18 + v6;
    do
    {
      v15 = &v18[v12];
      v16 = tolower(v18[v12 + v14]);
      ++v12;
      *v15 = v16;
    }
    while ( v12 < v13 );
  }
  result = (unsigned int)v7;
  if ( (v13 & 0xFFFFFFFFFFFFFFF8uLL) != 0 )
  {
    do
    {
      result = _mm_crc32_u64(result, *(_QWORD *)&v18[v4]);
      v4 += 8LL;
    }
    while ( v4 < (v13 & 0xFFFFFFFFFFFFFFF8uLL) );
  }
  if ( (v13 & 4) != 0 )
  {
    result = _mm_crc32_u32(result, *(_DWORD *)&v18[v4]);
    v4 += 4LL;
  }
  if ( (v13 & 2) != 0 )
  {
    result = _mm_crc32_u16(result, *(_WORD *)&v18[v4]);
    v4 += 2LL;
  }
  if ( (v13 & 1) != 0 )
  {
    return _mm_crc32_u8(result, v18[v4]);
  }
  return result;
}

// --- End Function: sub_1403DCAD0 (0x1403DCAD0) ---

// --- Function: sub_1403DCC30 (0x1403DCC30) ---
__int64 __fastcall sub_1403DCC30(unsigned int a1, unsigned __int8 *a2, __int64 i)
{
  __int64 i_1; // rdi
  int C; // ecx

  for ( i_1 = i; i_1; --i_1 )
  {
    C = *a2++;
    a1 = dword_14980AE20[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403DCC30 (0x1403DCC30) ---

// --- Function: sub_1403DCCA0 (0x1403DCCA0) ---
__int64 __fastcall sub_1403DCCA0(unsigned int a1, unsigned __int8 *a2, __int64 i)
{
  __int64 i_1; // rdi
  int C; // ecx

  for ( i_1 = i; i_1; --i_1 )
  {
    C = *a2++;
    a1 = dword_14980B220[(unsigned __int8)a1 ^ (unsigned __int64)(unsigned int)tolower(C)] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403DCCA0 (0x1403DCCA0) ---

// --- Function: sub_1403DCD10 (0x1403DCD10) ---
__int64 __fastcall sub_1403DCD10(unsigned int a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int64 v3; // rax

  for ( ; a3; --a3 )
  {
    v3 = *a2++;
    a1 = dword_14980AE20[(unsigned __int8)a1 ^ v3] ^ (a1 >> 8);
  }
  return a1;
}

// --- End Function: sub_1403DCD10 (0x1403DCD10) ---

// --- Function: sub_1403DCE50 (0x1403DCE50) ---
__int64 sub_1403DCE50()
{
  int n255; // r10d
  _DWORD *v1; // r11
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  __int64 result; // rax
  int v13; // r9d
  int n30; // r8d
  unsigned int v15; // eax

  n255 = 0;
  v1 = dword_14980AE20;
  do
  {
    v2 = ((n255 & 1) << 7) | 0x40;
    if ( (n255 & 2) == 0 )
    {
      v2 = (n255 & 1) << 7;
    }
    v3 = v2 | 0x20;
    if ( (n255 & 4) == 0 )
    {
      v3 = v2;
    }
    v4 = v3 | 0x10;
    if ( (n255 & 8) == 0 )
    {
      v4 = v3;
    }
    v5 = v4 | 8;
    if ( (n255 & 0x10) == 0 )
    {
      v5 = v4;
    }
    v6 = v5 | 4;
    if ( (n255 & 0x20) == 0 )
    {
      v6 = v5;
    }
    v7 = v6 | 2;
    if ( (n255 & 0x40) == 0 )
    {
      v7 = v6;
    }
    v8 = v7 | 1;
    if ( (((unsigned int)n255 >> 6) & 2) == 0 )
    {
      v8 = v7;
    }
    v9 = (((2
          * ((2
            * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
             & 0x1EDC6F41) >> 31)
           & 0x1EDC6F41))
         ^ (((2
            * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
             & 0x1EDC6F41))
           ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
             & 0x1EDC6F41) >> 31)
           & 0x1EDC6F41) >> 31)
         & 0x1EDC6F41) >> 31)
       & 0x1EDC6F41;
    v10 = (2
         * ((2
           * ((2
             * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
              & 0x1EDC6F41) >> 31)
            & 0x1EDC6F41))
          ^ (((2
             * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
              & 0x1EDC6F41))
            ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x1EDC6F41) >> 31)
              & 0x1EDC6F41) >> 31)
            & 0x1EDC6F41) >> 31)
          & 0x1EDC6F41))
        ^ v9;
    v11 = (2 * ((2 * v10) ^ (v10 >> 31) & 0x1EDC6F41)) ^ (((2 * v10) ^ (v10 >> 31) & 0x1EDC6F41) >> 31) & 0x1EDC6F41;
    LODWORD(result) = (2 * v11) ^ (v11 >> 31) & 0x1EDC6F41;
    v13 = 0;
    for ( n30 = 30; n30 > -2; n30 -= 2 )
    {
      if ( (result & 1) != 0 )
      {
        v13 |= 1 << (n30 + 1);
      }
      v15 = (unsigned int)result >> 1;
      if ( (v15 & 1) != 0 )
      {
        v13 |= 1 << n30;
      }
      result = v15 >> 1;
    }
    *v1 = v13;
    ++n255;
    ++v1;
  }
  while ( n255 <= 255 );
  return result;
}

// --- End Function: sub_1403DCE50 (0x1403DCE50) ---

// --- Function: sub_1403DCFB0 (0x1403DCFB0) ---
__int64 sub_1403DCFB0()
{
  int n255; // r10d
  _DWORD *v1; // r11
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  __int64 result; // rax
  int v13; // r9d
  int n30; // r8d
  unsigned int v15; // eax

  n255 = 0;
  v1 = dword_14980B220;
  do
  {
    v2 = ((n255 & 1) << 7) | 0x40;
    if ( (n255 & 2) == 0 )
    {
      v2 = (n255 & 1) << 7;
    }
    v3 = v2 | 0x20;
    if ( (n255 & 4) == 0 )
    {
      v3 = v2;
    }
    v4 = v3 | 0x10;
    if ( (n255 & 8) == 0 )
    {
      v4 = v3;
    }
    v5 = v4 | 8;
    if ( (n255 & 0x10) == 0 )
    {
      v5 = v4;
    }
    v6 = v5 | 4;
    if ( (n255 & 0x20) == 0 )
    {
      v6 = v5;
    }
    v7 = v6 | 2;
    if ( (n255 & 0x40) == 0 )
    {
      v7 = v6;
    }
    v8 = v7 | 1;
    if ( (((unsigned int)n255 >> 6) & 2) == 0 )
    {
      v8 = v7;
    }
    v9 = (((2
          * ((2
            * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
             & 0x4C11DB7))
           ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
             & 0x4C11DB7) >> 31)
           & 0x4C11DB7))
         ^ (((2
            * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
             & 0x4C11DB7))
           ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
             ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
             & 0x4C11DB7) >> 31)
           & 0x4C11DB7) >> 31)
         & 0x4C11DB7) >> 31)
       & 0x4C11DB7;
    v10 = (2
         * ((2
           * ((2
             * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
              & 0x4C11DB7))
            ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
              & 0x4C11DB7) >> 31)
            & 0x4C11DB7))
          ^ (((2
             * ((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
              & 0x4C11DB7))
            ^ (((2 * ((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7))
              ^ (((v8 << 25) ^ ((char)v8 >> 7) & 0x4C11DB7) >> 31)
              & 0x4C11DB7) >> 31)
            & 0x4C11DB7) >> 31)
          & 0x4C11DB7))
        ^ v9;
    v11 = (2 * ((2 * v10) ^ (v10 >> 31) & 0x4C11DB7)) ^ (((2 * v10) ^ (v10 >> 31) & 0x4C11DB7) >> 31) & 0x4C11DB7;
    LODWORD(result) = (2 * v11) ^ (v11 >> 31) & 0x4C11DB7;
    v13 = 0;
    for ( n30 = 30; n30 > -2; n30 -= 2 )
    {
      if ( (result & 1) != 0 )
      {
        v13 |= 1 << (n30 + 1);
      }
      v15 = (unsigned int)result >> 1;
      if ( (v15 & 1) != 0 )
      {
        v13 |= 1 << n30;
      }
      result = v15 >> 1;
    }
    *v1 = v13;
    ++n255;
    ++v1;
  }
  while ( n255 <= 255 );
  return result;
}

// --- End Function: sub_1403DCFB0 (0x1403DCFB0) ---

// --- Function: sub_1403DD400 (0x1403DD400) ---
void *__fastcall sub_1403DD400(void *a1, const void *a2, size_t Size)
{
  void *result; // rax

  if ( a1 != a2 )
  {
    return memcpy(a1, a2, Size);
  }
  return result;
}

// --- End Function: sub_1403DD400 (0x1403DD400) ---

// --- Function: sub_1403DD500 (0x1403DD500) ---
__int64 __fastcall sub_1403DD500(__int64 a1)
{
  __int64 result; // rax

  if ( !a1 )
  {
    return 0LL;
  }
  result = -1LL;
  do
  {
    ++result;
  }
  while ( *(_BYTE *)(a1 + result) );
  return (int)result;
}

// --- End Function: sub_1403DD500 (0x1403DD500) ---

// --- Function: sub_1403DE500 (0x1403DE500) ---
void sub_1403DE500()
{
  __int64 _RAX; // rax
  __int64 _RDX; // rdx
  __int64 _RCX; // rcx
  __int64 _RBX; // rbx
  __int64 n7; // rax
  __int64 _RAX_1; // rax
  __int64 _RDX_1; // rdx
  __int64 _RCX_1; // rcx
  __int64 _RBX_1; // rbx
  __int64 _RAX_2; // rax
  __int64 _RDX_2; // rdx
  __int64 _RCX_2; // rcx
  __int64 _RBX_2; // rbx
  __int64 _RDX_3; // rdx
  __int64 _RCX_3; // rcx
  __int64 Relationship; // rcx
  unsigned int v25; // r8d
  __int64 Relationship_1; // rcx
  __int64 Relationship_2; // rcx
  __int64 Relationship_3; // rcx
  __int64 v41; // rbx
  unsigned __int64 NodeNumber; // rcx
  unsigned __int64 size; // rcx
  void *v44; // rsp
  void *v45; // rsp
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *p_Buffer; // r15
  unsigned __int64 v47; // r12
  int v48; // r13d
  unsigned __int8 v49; // cl
  unsigned __int8 v50; // r14
  unsigned __int8 v51; // cl
  unsigned __int8 v52; // si
  unsigned __int8 v53; // cl
  unsigned __int8 v54; // di
  unsigned __int8 v55; // cl
  unsigned __int8 v56; // r10
  unsigned __int8 v57; // cl
  unsigned __int8 v58; // r9
  unsigned __int8 v59; // cl
  unsigned __int8 v60; // r8
  unsigned __int8 v61; // cl
  unsigned __int8 v62; // al
  __int64 v63; // rcx
  _BYTE *v64; // rax
  _SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer; // [rsp+20h] [rbp+0h] BYREF

  if ( !byte_149808C26 )
  {
    _RAX = 1;
    __asm { cpuid }
    RAX_0 = _RAX;
    n7 = 7;
    RCX_0 = _RCX;
    RBX_1 = _RBX;
    RDX = _RDX;
    __asm { cpuid }
    RAX_1 = _RAX_1;
    _RAX = 2147483655LL;
    RCX_1 = _RCX_1;
    RBX_2 = _RBX_1;
    RDX_0 = _RDX_1;
    __asm { cpuid }
    RAX_2 = _RAX_2;
    _RAX = 2147483649LL;
    RCX_2 = _RCX_2;
    RBX_3 = _RBX_2;
    RDX_1 = _RDX_2;
    __asm { cpuid }
    _RAX = 0x80000000LL;
    RCX_3 = _RCX_3;
    RDX_2 = _RDX_3;
    __asm { cpuid }
    LODWORD(Buffer.ProcessorMask) = -1;
    v25 = _RAX;
    HIDWORD(Buffer.ProcessorMask) = _RBX;
    Buffer.Relationship = Relationship;
    *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
    if ( (unsigned int)_RAX > 0x80000002 )
    {
      _RAX = 2147483650LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_1;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_14980AD20 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000003 )
    {
      _RAX = 2147483651LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_2;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_14980AD30 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    if ( v25 > 0x80000004 )
    {
      _RAX = 2147483652LL;
      __asm { cpuid }
      Buffer.ProcessorMask = __PAIR64__(_RBX, _RAX);
      Buffer.Relationship = Relationship_3;
      *((_DWORD *)&Buffer.Relationship + 1) = _RDX;
      xmmword_14980AD40 = *(_OWORD *)&Buffer.ProcessorMask;
    }
    v41 = 0;
    Buffer.NumaNode.NodeNumber = 0;
    if ( GetLogicalProcessorInformation(0, &Buffer.NumaNode.NodeNumber) || GetLastError() != 122 )
    {
      __debugbreak();
    }
    NodeNumber = Buffer.NumaNode.NodeNumber + 15LL;
    if ( NodeNumber <= Buffer.NumaNode.NodeNumber )
    {
      NodeNumber = 0xFFFFFFFFFFFFFF0LL;
    }
    size = NodeNumber & 0xFFFFFFFFFFFFFFF0uLL;
    v44 = alloca(size);
    v45 = alloca(size);
    p_Buffer = &Buffer;
    if ( !GetLogicalProcessorInformation(&Buffer, &Buffer.NumaNode.NodeNumber) )
    {
      __debugbreak();
    }
    v47 = (unsigned __int64)Buffer.NumaNode.NodeNumber >> 5;
    if ( v47 )
    {
      v48 = dword_14980ACE8;
      do
      {
        if ( p_Buffer->Relationship == RelationProcessorCore )
        {
          v49 = (p_Buffer->ProcessorMask & 0x55) + (((unsigned __int8)p_Buffer->ProcessorMask >> 1) & 0x55);
          v50 = (v49 & 0x33) + ((v49 >> 2) & 0x33);
          v51 = (BYTE1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE1(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v52 = (v51 & 0x33) + ((v51 >> 2) & 0x33);
          v53 = (WORD1(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE2(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v54 = (v53 & 0x33) + ((v53 >> 2) & 0x33);
          v55 = (BYTE3(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE3(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v56 = (v55 & 0x33) + ((v55 >> 2) & 0x33);
          v57 = (HIDWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE4(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v58 = (v57 & 0x33) + ((v57 >> 2) & 0x33);
          v59 = (((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) & 0x55)
              + (((unsigned __int8)((unsigned __int16)WORD2(p_Buffer->ProcessorMask) >> 8) >> 1) & 0x55);
          v60 = (v59 & 0x33) + ((v59 >> 2) & 0x33);
          v61 = (HIWORD(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)BYTE6(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v62 = (HIBYTE(p_Buffer->ProcessorMask) & 0x55)
              + (((unsigned __int8)HIBYTE(p_Buffer->ProcessorMask) >> 1) & 0x55);
          v48 += (unsigned __int8)((v50 >> 4)
                                 + (v50 & 0xF)
                                 + (v52 >> 4)
                                 + (v52 & 0xF)
                                 + (v54 >> 4)
                                 + (v54 & 0xF)
                                 + (v56 >> 4)
                                 + (v56 & 0xF)
                                 + (v58 >> 4)
                                 + (v58 & 0xF)
                                 + (v60 >> 4)
                                 + (v60 & 0xF)
                                 + ((unsigned __int8)((v61 & 0x33) + ((v61 >> 2) & 0x33)) >> 4)
                                 + (((v61 & 0x33) + ((v61 >> 2) & 0x33)) & 0xF)
                                 + ((unsigned __int8)((v62 & 0x33) + ((v62 >> 2) & 0x33)) >> 4)
                                 + (((v62 & 0x33) + ((v62 >> 2) & 0x33)) & 0xF));
        }
        ++p_Buffer;
        --v47;
      }
      while ( v47 );
      dword_14980ACE8 = v48;
    }
    v63 = 0;
    if ( (_BYTE)xmmword_14980AD20 )
    {
      do
      {
        for ( ; *((_BYTE *)&xmmword_14980AD20 + v41) == 32; ++v41 )
        {
          ;
        }
        *((_BYTE *)&xmmword_14980AD20 + v63) = *((_BYTE *)&xmmword_14980AD20 + v41);
        if ( *((_BYTE *)&xmmword_14980AD20 + v41) )
        {
          while ( 1 )
          {
            v64 = (char *)&xmmword_14980AD20 + v41;
            ++v63;
            ++v41;
            if ( *v64 == 32 )
            {
              break;
            }
            *((_BYTE *)&xmmword_14980AD20 + v63) = *((_BYTE *)&xmmword_14980AD20 + v41);
            if ( !*((_BYTE *)&xmmword_14980AD20 + v41) )
            {
              goto LABEL_27;
            }
          }
        }
        else
        {
LABEL_27:
          if ( v63 )
          {
            if ( *((_BYTE *)&xmmword_14980AD20 + v63 - 1) == 32 )
            {
              *((_BYTE *)&xmmword_14980AD20 + v63 - 1) = 0;
            }
          }
        }
      }
      while ( *((_BYTE *)&xmmword_14980AD20 + v41) );
    }
    byte_149808C26 = 1;
  }
}

// --- End Function: sub_1403DE500 (0x1403DE500) ---

// --- Function: sub_1403DFBE0 (0x1403DFBE0) ---
__int64 __fastcall sub_1403DFBE0(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
    {
      break;
    }
    ++v2;
    if ( !v4 )
    {
      return 0LL;
    }
  }
  return v4 < v2[v3] ? -1 : 1;
}

// --- End Function: sub_1403DFBE0 (0x1403DFBE0) ---

// --- Function: sub_1403DFC10 (0x1403DFC10) ---
__int64 __fastcall sub_1403DFC10(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // rdx
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
    {
      break;
    }
    ++v2;
    if ( !v4 )
    {
      return 0LL;
    }
  }
  return v4 < v2[v3] ? -1 : 1;
}

// --- End Function: sub_1403DFC10 (0x1403DFC10) ---

// --- Function: sub_1403DFFB0 (0x1403DFFB0) ---
__int64 sub_1403DFFB0()
{
  return sub_1402A1E30(1uLL);
}

// --- End Function: sub_1403DFFB0 (0x1403DFFB0) ---

// --- Function: sub_1403DFFC0 (0x1403DFFC0) ---
_OWORD *__fastcall sub_1403DFFC0(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)sub_1402A1E30(0x10uLL);
  if ( result )
  {
    *result = *a1;
  }
  return result;
}

// --- End Function: sub_1403DFFC0 (0x1403DFFC0) ---

// --- Function: sub_1403DFFF0 (0x1403DFFF0) ---
_QWORD *__fastcall sub_1403DFFF0(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)sub_1402A1E30(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    free_memory_wrapper(0);
    v5 = -1;
    while ( v4[++v5] != 0 )
    {
      ;
    }
    Size = v5 + 1;
    v8 = (void *)sub_1402A1E30(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403DFFF0 (0x1403DFFF0) ---

// --- Function: sub_1403E02C0 (0x1403E02C0) ---
__int64 __fastcall sub_1403E02C0(const void *a1)
{
  return free_memory_wrapper(a1);
}

// --- End Function: sub_1403E02C0 (0x1403E02C0) ---

// --- Function: sub_1403E02D0 (0x1403E02D0) ---
__int64 __fastcall sub_1403E02D0(const void *a1)
{
  return free_memory_wrapper(a1);
}

// --- End Function: sub_1403E02D0 (0x1403E02D0) ---

// --- Function: sub_1403E02E0 (0x1403E02E0) ---
__int64 __fastcall sub_1403E02E0(const void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    free_memory_wrapper(a1[2]);
    return free_memory_wrapper(a1);
  }
  return result;
}

// --- End Function: sub_1403E02E0 (0x1403E02E0) ---

// --- Function: sub_1403E1240 (0x1403E1240) ---
__int64 __fastcall sub_1403E1240(__int64 *a1, const char *SubStr, unsigned __int64 a3)
{
  __int64 v3; // r9
  char *v5; // rax

  v3 = *a1;
  if ( a3 <= *(int *)(*a1 - 8) && v3 + a3 && (v5 = strstr((const char *)(v3 + a3), SubStr)) != 0LL )
  {
    return (__int64)&v5[-*a1];
  }
  else
  {
    return -1LL;
  }
}

// --- End Function: sub_1403E1240 (0x1403E1240) ---

// --- Function: sub_1403E1630 (0x1403E1630) ---
char *__fastcall sub_1403E1630(__int64 *a1, char Control_1, unsigned __int64 a3)
{
  __int64 v4; // rcx
  char *v5; // rax
  char Control; // [rsp+30h] [rbp+8h] BYREF
  char v8; // [rsp+31h] [rbp+9h]

  v4 = *a1;
  if ( a3 <= *(int *)(v4 - 8) && (Control = Control_1, v8 = 0, (v5 = strpbrk((const char *)(a3 + v4), &Control)) != 0) )
  {
    return &v5[-*a1];
  }
  else
  {
    return (char *)-1LL;
  }
}

// --- End Function: sub_1403E1630 (0x1403E1630) ---

// --- Function: sub_1403E2A50 (0x1403E2A50) ---
bool __fastcall sub_1403E2A50(unsigned __int8 *a1, unsigned __int8 *a2)
{
  signed __int64 v2; // r8
  int v3; // eax
  int v4; // edx

  if ( a1 == a2 )
  {
    return 1;
  }
  if ( !a1 || !a2 )
  {
    return 0;
  }
  v2 = a2 - a1;
  do
  {
    v3 = a1[v2];
    v4 = *a1 - v3;
    if ( v4 )
    {
      break;
    }
    ++a1;
  }
  while ( v3 );
  return !v4;
}

// --- End Function: sub_1403E2A50 (0x1403E2A50) ---

// --- Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403E2A90) ---
bool __fastcall FH4::HandlerMap4::iterator::operator==(__int64 a1, __int64 a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

// --- End Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403E2A90) ---

// --- Function: sub_1403E2AB0 (0x1403E2AB0) ---
bool __fastcall sub_1403E2AB0(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
  {
    return 1;
  }
  if ( !v2 || !v3 )
  {
    return 0;
  }
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
    {
      break;
    }
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E2AB0 (0x1403E2AB0) ---

// --- Function: sub_1403E2C50 (0x1403E2C50) ---
char __fastcall sub_1403E2C50(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1403E2C50 (0x1403E2C50) ---

// --- Function: sub_1403E2EC0 (0x1403E2EC0) ---
__int64 __fastcall sub_1403E2EC0(_QWORD *a1)
{
  return *(int *)(*a1 - 8LL);
}

// --- End Function: sub_1403E2EC0 (0x1403E2EC0) ---

// --- Function: sub_1403E3F10 (0x1403E3F10) ---
void **__fastcall sub_1403E3F10(void **a1, const char *SubStr, char *a3)
{
  __int64 v6; // rax
  __int64 v7; // r14
  size_t Size_1; // r15
  __int64 Size_2; // rax
  const char *v10; // rbx
  __int64 v11; // rdi
  char *v12; // rsi
  char *v13; // rax
  __int64 v14; // rax
  __int64 v15; // rcx
  int *v16; // rsi
  __int64 v17; // rbp
  unsigned __int64 v18; // rcx
  void **v19; // rsi
  const char *v20; // rbx
  char *v21; // rax
  char *v22; // rdi
  size_t Size; // rsi
  __int64 v24; // rax
  __int64 v25; // rcx
  char *v28; // [rsp+68h] [rbp+10h]
  int v29; // [rsp+78h] [rbp+20h]

  if ( !SubStr )
  {
    return a1;
  }
  v6 = -1;
  do
  {
    ++v6;
  }
  while ( SubStr[v6] );
  v7 = (int)v6;
  if ( !(_DWORD)v6 )
  {
    return a1;
  }
  if ( a3 )
  {
    Size_2 = -1;
    do
    {
      ++Size_2;
    }
    while ( a3[Size_2] );
    Size_1 = (int)Size_2;
  }
  else
  {
    Size_1 = 0;
  }
  v10 = (const char *)*a1;
  v11 = 0;
  v12 = (char *)*a1 + *((int *)*a1 - 2);
  if ( *a1 >= v12 )
  {
    return a1;
  }
  do
  {
    while ( 1 )
    {
      if ( !v10 )
      {
        v15 = 0;
        goto LABEL_18;
      }
      v13 = strstr(v10, SubStr);
      if ( !v13 )
      {
        break;
      }
      ++v11;
      v10 = &v13[v7];
    }
    v14 = -1;
    do
    {
      ++v14;
    }
    while ( v10[v14] );
    v15 = (int)v14;
LABEL_18:
    v10 += v15 + 1;
  }
  while ( v10 < v12 );
  if ( !v11 )
  {
    return a1;
  }
  v16 = (int *)*a1;
  v17 = *((int *)*a1 - 2);
  v18 = v17 + v11 * (Size_1 - v7);
  v29 = v17 + v11 * (Size_1 - v7);
  if ( *(v16 - 1) < v18 )
  {
    sub_1403D95E0((char **)a1, v18);
    if ( *a1 != v16 )
    {
      memcpy(*a1, v16, *(v16 - 2));
    }
    if ( *(v16 - 1) > 0 )
    {
      sub_14739AF10(v16 - 2);
    }
  }
  v19 = a1;
  v20 = (const char *)*a1;
  v28 = (char *)*a1 + *((int *)*a1 - 2);
  if ( *a1 < v28 )
  {
    do
    {
      while ( 2 )
      {
        if ( v20 )
        {
          v21 = strstr(v20, SubStr);
          v22 = v21;
          if ( v21 )
          {
            v20 = &v21[Size_1];
            Size = v17 + (_BYTE *)*v19 - v21 - v7;
            memmove(&v21[Size_1], &v21[v7], Size);
            if ( v22 != a3 )
            {
              memcpy(v22, a3, Size_1);
            }
            v20[Size] = 0;
            v19 = a1;
            v17 += Size_1 - v7;
            continue;
          }
          v24 = -1;
          do
          {
            ++v24;
          }
          while ( v20[v24] );
          v25 = (int)v24;
        }
        else
        {
          v25 = 0;
        }
        break;
      }
      v20 += v25 + 1;
    }
    while ( v20 < v28 );
  }
  *((_DWORD *)*v19 - 2) = v29;
  return v19;
}

// --- End Function: sub_1403E3F10 (0x1403E3F10) ---

// --- Function: sub_1403E4500 (0x1403E4500) ---
void __fastcall sub_1403E4500(void **a1, unsigned __int64 a2)
{
  _BYTE *v2; // rdi
  unsigned __int64 v5; // rcx
  _DWORD *v6; // rax

  v2 = *a1;
  v5 = *((int *)*a1 - 1);
  if ( a2 > v5 )
  {
    if ( a2 )
    {
      v6 = (_DWORD *)sub_14739AFC0(a2 + 9, 0LL);
      *a1 = v6 + 2;
      *v6 = a2;
      v6[1] = a2;
      *((_BYTE *)*a1 + a2) = 0;
    }
    else
    {
      *a1 = (char *)&qword_149808ABC + 4;
    }
    if ( *a1 != v2 )
    {
      memcpy(*a1, v2, *((int *)v2 - 2));
    }
    *((_DWORD *)*a1 - 2) = *((_DWORD *)v2 - 2);
    *((_BYTE *)*a1 + *((int *)v2 - 2)) = 0;
LABEL_12:
    if ( *((int *)v2 - 1) > 0 )
    {
      sub_14739AF10(v2 - 8);
    }
    return;
  }
  if ( !a2 && *((_DWORD *)v2 - 2) != (_DWORD)v5 )
  {
    sub_1403D95E0((char **)a1, *((int *)v2 - 2));
    if ( *a1 != v2 )
    {
      memcpy(*a1, v2, *((int *)v2 - 2));
    }
    goto LABEL_12;
  }
}

// --- End Function: sub_1403E4500 (0x1403E4500) ---

// --- Function: sub_1403E4C30 (0x1403E4C30) ---
__int64 __fastcall sub_1403E4C30(void **a1, unsigned __int64 a2, char Val)
{
  _DWORD *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx
  __int64 result; // rax

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
    {
      return result;
    }
    *(v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
  {
    return result;
  }
  if ( a2 <= (int)*(v3 - 1) )
  {
    memset((char *)v3 + v6, Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    result = *((int *)*a1 - 2);
    *((_BYTE *)*a1 + result) = 0;
    return result;
  }
  sub_1403D95E0((char **)a1, a2);
  if ( *a1 != v3 )
  {
    memcpy(*a1, v3, (int)*(v3 - 2));
  }
  result = (__int64)memset((char *)*a1 + (int)*(v3 - 2), Val_1, Size);
  if ( (int)*(v3 - 1) > 0 )
  {
    sub_14739AF10(v3 - 2);
  }
  return result;
}

// --- End Function: sub_1403E4C30 (0x1403E4C30) ---

// --- Function: sub_1403E6250 (0x1403E6250) ---
void **__fastcall sub_1403E6250(__int64 *a1, void **a2, size_t a3, size_t Size)
{
  __int64 v6; // rdx
  size_t v7; // rcx
  size_t Size_1; // r8

  v6 = *a1;
  v7 = *(int *)(*a1 - 8);
  if ( a3 < v7 )
  {
    Size_1 = v7 - a3;
    if ( Size == -1 )
    {
      Size = v7 - a3;
    }
    if ( a3 + Size <= v7 )
    {
      Size_1 = Size;
    }
    sub_1403579C0(a2, (void *)(a3 + v6), Size_1);
    return a2;
  }
  else
  {
    *a2 = (char *)&qword_149808ABC + 4;
    return a2;
  }
}

// --- End Function: sub_1403E6250 (0x1403E6250) ---

// --- Function: sub_1403E6380 (0x1403E6380) ---
__int64 __fastcall sub_1403E6380(__int64 a1, double *a2, unsigned __int64 n9)
{
  if ( a1 )
  {
    return sub_1402FEA60(a2, n9, a1, 1);
  }
  if ( n9 <= 9 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 0x7274706C6C756E22LL;
    *((_BYTE *)a2 + 8) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  return 9LL;
}

// --- End Function: sub_1403E6380 (0x1403E6380) ---

// --- Function: sub_1403E6550 (0x1403E6550) ---
__int64 __fastcall sub_1403E6550(__int64 a1, double *a2, unsigned __int64 n9)
{
  __int64 v4; // r8

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    return sub_1402FEA60(a2, n9, v4, 1);
  }
  if ( n9 <= 9 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 0x7274706C6C756E22LL;
    *((_BYTE *)a2 + 8) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  return 9LL;
}

// --- End Function: sub_1403E6550 (0x1403E6550) ---

// --- Function: sub_1403E6700 (0x1403E6700) ---
__int64 __fastcall sub_1403E6700(__int64 a1, __int64 a2, unsigned __int64 n12)
{
  int v3; // edi
  int n12_1; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12_1 = 0;
  if ( (int)n12 > 0 )
  {
    if ( n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 = 12;
      if ( (int)n12 <= 12 )
      {
        goto LABEL_52;
      }
    }
    v8 = sub_1404EEAB0((unsigned __int8 *)a1, (_BYTE *)((unsigned int)n12_1 + a2), n12 - (unsigned int)n12_1);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v8;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12_1);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 19;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v10 = sub_1404EE450((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v10;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12_1;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v12 = sub_1404EE6A0((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12_1);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 18;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v14 = sub_1404EE300((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12_1 += v14;
    if ( n12_1 < (int)n12 )
    {
LABEL_46:
      if ( n12 - n12_1 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12_1);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12_1 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
  {
    return (unsigned int)-1;
  }
  return (unsigned int)n12_1;
}

// --- End Function: sub_1403E6700 (0x1403E6700) ---

// --- Function: sub_1403E6970 (0x1403E6970) ---
__int64 __fastcall sub_1403E6970(_BYTE *Src, _DWORD *a2, unsigned __int64 Size, __int64 a4, char a5)
{
  __int64 result; // rax
  size_t Size_1; // rbx

  if ( Src )
  {
    if ( a5 )
    {
      return sub_1402FEA60(a2, Size, (__int64)Src, 0);
    }
    result = -1;
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( Src[Size_1] );
    if ( Size_1 < Size )
    {
      if ( Size_1 )
      {
        if ( !a2 )
        {
          *errno() = 22;
          invalid_parameter_noinfo();
          return (unsigned int)Size_1;
        }
        memcpy(a2, Src, Size_1);
      }
      return (unsigned int)Size_1;
    }
  }
  else if ( Size > 7 )
  {
    if ( a2 )
    {
      *a2 = 1819047278;
      *((_WORD *)a2 + 2) = 29808;
      *((_BYTE *)a2 + 6) = 114;
    }
    else
    {
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return 7;
  }
  else
  {
    return -1;
  }
  return result;
}

// --- End Function: sub_1403E6970 (0x1403E6970) ---

// --- Function: sub_1403E6A90 (0x1403E6A90) ---
__int64 __fastcall sub_1403E6A90(__int64 a1, __int64 a2, unsigned __int64 Size, __int64 a4, char a5)
{
  _BYTE *v6; // rdx
  __int64 result; // rax
  size_t Size_1; // rbx

  v6 = *(_BYTE **)(a1 + 8);
  if ( v6 )
  {
    if ( a5 )
    {
      return sub_1402FEA60((_BYTE *)a2, Size, *(_QWORD *)(a1 + 8), 0);
    }
    result = -1;
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( v6[Size_1] );
    if ( Size_1 < Size )
    {
      if ( Size_1 )
      {
        if ( !a2 )
        {
          *errno() = 22;
          invalid_parameter_noinfo();
          return (unsigned int)Size_1;
        }
        memcpy((void *)a2, v6, Size_1);
      }
      return (unsigned int)Size_1;
    }
  }
  else if ( Size > 7 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 1819047278;
      *(_WORD *)(a2 + 4) = 29808;
      *(_BYTE *)(a2 + 6) = 114;
    }
    else
    {
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return 7;
  }
  else
  {
    return -1;
  }
  return result;
}

// --- End Function: sub_1403E6A90 (0x1403E6A90) ---

// --- Function: sub_1403E6C00 (0x1403E6C00) ---
// attributes: thunk
__int64 __fastcall sub_1403E6C00(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404EEAB0(a1, a2, n0x21);
}

// --- End Function: sub_1403E6C00 (0x1403E6C00) ---

// --- Function: sub_140432100 (0x140432100) ---
__int64 __fastcall sub_140432100(__int64 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // rax
  unsigned __int8 **v6; // rbx
  int v7; // eax

  v3 = *a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = v3;
  v6 = *(unsigned __int8 ***)(v3 + 8);
  for ( *(_QWORD *)a2 = v6; !*((_BYTE *)v6 + 25); *(_DWORD *)(a2 + 8) = v7 )
  {
    *(_QWORD *)a2 = v6;
    if ( (int)sub_1403DFBE0(v6 + 4, a3) >= 0 )
    {
      *(_QWORD *)(a2 + 16) = v6;
      v7 = 1;
      v6 = (unsigned __int8 **)*v6;
    }
    else
    {
      v6 = (unsigned __int8 **)v6[2];
      v7 = 0;
    }
  }
  return a2;
}

// --- End Function: sub_140432100 (0x140432100) ---

// --- Function: sub_14043A360 (0x14043A360) ---
_QWORD *__fastcall sub_14043A360(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  __int64 *i; // rbx

  for ( i = a1; i != a2; ++i )
  {
    sub_1403577A0(a3++, i);
  }
  return a3;
}

// --- End Function: sub_14043A360 (0x14043A360) ---

// --- Function: sub_14043A610 (0x14043A610) ---
char __fastcall sub_14043A610(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        __int64 *arg48,
        __int64 *a11)
{
  void *v11; // rsp
  __int64 a8; // [rsp+18h] [rbp-158h]
  __int64 a5[11]; // [rsp+30h] [rbp-140h] BYREF
  __int16 n256; // [rsp+88h] [rbp-E8h]
  __int64 n176; // [rsp+90h] [rbp-E0h]
  __int64 v17; // [rsp+98h] [rbp-D8h]
  const char *p_Unnamed_Text; // [rsp+A0h] [rbp-D0h]
  __int64 v19; // [rsp+A8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403E6970)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+B0h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1403E6380)(__int64, double *, unsigned __int64); // [rsp+B8h] [rbp-B8h]
  __int64 v22; // [rsp+C0h] [rbp-B0h]
  bool (__fastcall *p_sub_1403E2A50)(unsigned __int8 *, unsigned __int8 *); // [rsp+C8h] [rbp-A8h]
  __int64 v24; // [rsp+D0h] [rbp-A0h]
  __int64 (__fastcall *p_sub_1403E02C0)(const void *); // [rsp+D8h] [rbp-98h]
  __int64 (__fastcall *p_sub_1403DFFB0)(); // [rsp+E0h] [rbp-90h]
  __int64 v27; // [rsp+E8h] [rbp-88h]
  __int16 v28; // [rsp+F0h] [rbp-80h]
  __int64 n8; // [rsp+F8h] [rbp-78h]
  __int64 v30; // [rsp+100h] [rbp-70h]
  const char *p_Unnamed_Text_1; // [rsp+108h] [rbp-68h]
  __int64 v32; // [rsp+110h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403E6970_1)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+118h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6380_1)(__int64, double *, unsigned __int64); // [rsp+120h] [rbp-50h]
  __int64 v35; // [rsp+128h] [rbp-48h]
  bool (__fastcall *p_sub_1403E2A50_1)(unsigned __int8 *, unsigned __int8 *); // [rsp+130h] [rbp-40h]
  __int64 v37; // [rsp+138h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E02C0_1)(const void *); // [rsp+140h] [rbp-30h]
  __int64 (__fastcall *p_sub_1403DFFB0_1)(); // [rsp+148h] [rbp-28h]
  __int64 v40; // [rsp+150h] [rbp-20h]
  __int16 v41; // [rsp+158h] [rbp-18h]
  __int64 n8_1; // [rsp+160h] [rbp-10h]

  v11 = alloca(320);
  a5[0] = arg40;
  n256 = 256;
  a5[2] = 0;
  a5[1] = (__int64)"TraceContext";
  a5[5] = 0;
  a5[3] = (__int64)sub_1403E6C00;
  a5[7] = 0;
  a5[4] = (__int64)sub_1403E6700;
  a5[10] = -1;
  a5[6] = (__int64)sub_1403E2C50;
  n176 = 176;
  a5[8] = (__int64)sub_1403E02C0;
  a5[9] = (__int64)sub_1403DFFB0;
  v17 = *arg48;
  p_Unnamed_Text = "Unnamed_Text";
  v28 = 0;
  v19 = 0;
  p_sub_1403E6970 = sub_1403E6970;
  p_sub_1403E6380 = sub_1403E6380;
  v22 = 0;
  p_sub_1403E2A50 = sub_1403E2A50;
  v24 = 0;
  p_sub_1403E02C0 = sub_1403E02C0;
  p_sub_1403DFFB0 = sub_1403DFFB0;
  v27 = -1;
  n8 = 8;
  LODWORD(a8) = a6;
  v30 = *a11;
  p_Unnamed_Text_1 = "Unnamed_Text";
  v41 = 0;
  v32 = 0;
  p_sub_1403E6970_1 = sub_1403E6970;
  p_sub_1403E6380_1 = sub_1403E6380;
  v35 = 0;
  p_sub_1403E2A50_1 = sub_1403E2A50;
  v37 = 0;
  p_sub_1403E02C0_1 = sub_1403E02C0;
  p_sub_1403DFFB0_1 = sub_1403DFFB0;
  v40 = -1;
  n8_1 = 8;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 3, a7, a8, a9, a10);
}

// --- End Function: sub_14043A610 (0x14043A610) ---

// --- Function: sub_14043FDE0 (0x14043FDE0) ---
char __fastcall sub_14043FDE0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10)
{
  __int64 v11; // [rsp+18h] [rbp-E8h]
  __int64 v12[11]; // [rsp+30h] [rbp-D0h] BYREF
  __int16 n256; // [rsp+88h] [rbp-78h]
  __int64 n176; // [rsp+90h] [rbp-70h]
  _QWORD *v15; // [rsp+98h] [rbp-68h]
  const char *p_Text; // [rsp+A0h] [rbp-60h]
  __int64 v17; // [rsp+A8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6A90)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+B0h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E6550)(__int64, double *, unsigned __int64); // [rsp+B8h] [rbp-48h]
  __int64 v20; // [rsp+C0h] [rbp-40h]
  bool (__fastcall *p_sub_1403E2AB0)(__int64, __int64); // [rsp+C8h] [rbp-38h]
  __int64 v22; // [rsp+D0h] [rbp-30h]
  __int64 (__fastcall *p_sub_1403E02E0)(const void **); // [rsp+D8h] [rbp-28h]
  _QWORD *(__fastcall *p_sub_1403DFFF0)(_QWORD *); // [rsp+E0h] [rbp-20h]
  __int64 v25; // [rsp+E8h] [rbp-18h]
  char v26; // [rsp+F0h] [rbp-10h]
  char v27; // [rsp+F1h] [rbp-Fh]
  __int64 n24; // [rsp+F8h] [rbp-8h]

  v12[0] = a9;
  n256 = 256;
  v12[1] = (__int64)"TraceContext";
  v12[3] = (__int64)sub_1403E6C00;
  v12[4] = (__int64)sub_1403E6700;
  v12[6] = (__int64)sub_1403E2C50;
  v12[8] = (__int64)sub_1403E02C0;
  v12[9] = (__int64)sub_1403DFFB0;
  v15 = a10;
  v12[2] = 0;
  v12[5] = 0;
  v12[7] = 0;
  v12[10] = -1;
  n176 = 176;
  p_Text = "Text";
  v27 = 0;
  v17 = *a10;
  p_sub_1403E6A90 = sub_1403E6A90;
  p_sub_1403E6550 = sub_1403E6550;
  p_sub_1403E2AB0 = sub_1403E2AB0;
  p_sub_1403E02E0 = sub_1403E02E0;
  p_sub_1403DFFF0 = sub_1403DFFF0;
  LODWORD(v11) = a6;
  v20 = 0;
  v22 = 0;
  v25 = -1;
  v26 = 0;
  n24 = 24;
  return sub_140302350(n4, a2, a3, a4, (__int64)v12, 2, a5, v11, a7, a8);
}

// --- End Function: sub_14043FDE0 (0x14043FDE0) ---

// --- Function: sub_140448AD0 (0x140448AD0) ---
unsigned __int64 __fastcall sub_140448AD0(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        int *a4,
        unsigned __int64 n4,
        unsigned __int8 a6)
{
  __int64 v6; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rax
  __int64 v12; // rcx
  _OWORD *v13; // rax
  _OWORD *v14; // rax
  unsigned __int64 n4_1; // rdx
  __int64 n8; // r8
  unsigned __int64 v17; // rdi
  unsigned __int64 n8_1; // rcx
  unsigned __int64 a3a; // [rsp+48h] [rbp+10h] BYREF

  v6 = *a4;
  if ( (_DWORD)v6 )
  {
    a3a = 16 * v6;
    v10 = sub_1403301D0(a1, 0, &a3a, n4, a6);
    v11 = a3a >> 4;
    *a4 = a3a >> 4;
  }
  else
  {
    v10 = 0;
    LODWORD(v11) = 0;
  }
  if ( a2 )
  {
    if ( v10 )
    {
      if ( a3 < (int)v11 )
      {
        LODWORD(v11) = a3;
      }
      if ( a2 != v10 )
      {
        v12 = (int)v11;
        if ( a2 > v10 || 16LL * (int)v11 + a2 <= v10 )
        {
          if ( (_DWORD)v11 )
          {
            v14 = (_OWORD *)v10;
            do
            {
              *v14 = *(_OWORD *)((char *)v14 + a2 - v10);
              ++v14;
              --v12;
            }
            while ( v12 );
          }
        }
        else if ( (_DWORD)v11 )
        {
          v13 = (_OWORD *)(v10 + 16LL * (int)v11 - 16);
          do
          {
            *v13 = *(_OWORD *)((char *)v13 + a2 - v10);
            --v13;
            --v12;
          }
          while ( v12 );
        }
      }
    }
    n4_1 = 4;
    a3a = 0;
    n8 = 8;
    if ( n4 > 4 )
    {
      n4_1 = n4;
    }
    v17 = a2 - ((n4_1 + 3) & ~(n4_1 - 1));
    n8_1 = 8;
    if ( n4_1 > 8 )
    {
      n8_1 = n4_1;
    }
    if ( v17 )
    {
      if ( n8_1 > 8 )
      {
        n8 = n8_1;
      }
      (*(void (__fastcall **)(unsigned __int64, unsigned __int64 *, __int64, _QWORD))(v17 - 8))(
        v17 - ((n8 + 7) & ~(n8 - 1)),
        &a3a,
        n8,
        0);
    }
  }
  return v10;
}

// --- End Function: sub_140448AD0 (0x140448AD0) ---

// --- Function: sub_14044A020 (0x14044A020) ---
__int64 __fastcall sub_14044A020(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  int v10; // eax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 45;
    a4 = -a4 & 0x7FFFFFFF;
    v6 = 1;
  }
  else
  {
    v6 = -1;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
    {
      return 0xFFFFFFFFLL;
    }
    ++v6;
    v10 = a4 % 10;
    a4 /= 10;
    *(_BYTE *)(v8 + v4) = v10 + 48;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_14044A020 (0x14044A020) ---

// --- Function: sub_1404AE300 (0x1404AE300) ---
_QWORD *sub_1404AE300()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  if ( !v0 )
  {
    sub_140535CF0((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A1E30(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_147E52AF0);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404AE300 (0x1404AE300) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 15;
  }
  return (__int64 *)&tls_log_structure_1[22 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: sub_1404EE300 (0x1404EE300) ---
__int64 __fastcall sub_1404EE300(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)a1[40] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[40] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[41] >> 4];
  a2[3] = _0123456789abcdef_[a1[41] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[42] >> 4];
  a2[5] = _0123456789abcdef_[a1[42] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[43] >> 4];
  a2[7] = _0123456789abcdef_[a1[43] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[44] >> 4];
  a2[9] = _0123456789abcdef_[a1[44] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[45] >> 4];
  a2[11] = _0123456789abcdef_[a1[45] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[46] >> 4];
  a2[13] = _0123456789abcdef_[a1[46] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[47] >> 4];
  a2[15] = _0123456789abcdef_[a1[47] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404EE300 (0x1404EE300) ---

// --- Function: sub_1404EE450 (0x1404EE450) ---
__int64 __fastcall sub_1404EE450(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)a1[16] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[16] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[17] >> 4];
  a2[3] = _0123456789abcdef_[a1[17] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[18] >> 4];
  a2[5] = _0123456789abcdef_[a1[18] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[19] >> 4];
  a2[7] = _0123456789abcdef_[a1[19] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[20] >> 4];
  a2[9] = _0123456789abcdef_[a1[20] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[21] >> 4];
  a2[11] = _0123456789abcdef_[a1[21] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[22] >> 4];
  a2[13] = _0123456789abcdef_[a1[22] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[23] >> 4];
  a2[15] = _0123456789abcdef_[a1[23] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[24] >> 4];
  a2[17] = _0123456789abcdef_[a1[24] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[25] >> 4];
  a2[19] = _0123456789abcdef_[a1[25] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[26] >> 4];
  a2[21] = _0123456789abcdef_[a1[26] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[27] >> 4];
  a2[23] = _0123456789abcdef_[a1[27] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[28] >> 4];
  a2[25] = _0123456789abcdef_[a1[28] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[29] >> 4];
  a2[27] = _0123456789abcdef_[a1[29] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[30] >> 4];
  a2[29] = _0123456789abcdef_[a1[30] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[31] >> 4];
  a2[31] = _0123456789abcdef_[a1[31] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404EE450 (0x1404EE450) ---

// --- Function: sub_1404EE6A0 (0x1404EE6A0) ---
__int64 __fastcall sub_1404EE6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)a1[32] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[32] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[33] >> 4];
  a2[3] = _0123456789abcdef_[a1[33] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[34] >> 4];
  a2[5] = _0123456789abcdef_[a1[34] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[35] >> 4];
  a2[7] = _0123456789abcdef_[a1[35] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[36] >> 4];
  a2[9] = _0123456789abcdef_[a1[36] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[37] >> 4];
  a2[11] = _0123456789abcdef_[a1[37] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[38] >> 4];
  a2[13] = _0123456789abcdef_[a1[38] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[39] >> 4];
  a2[15] = _0123456789abcdef_[a1[39] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404EE6A0 (0x1404EE6A0) ---

// --- Function: sub_1404EEAB0 (0x1404EEAB0) ---
__int64 __fastcall sub_1404EEAB0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[11] = _0123456789abcdef_[a1[5] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[13] = _0123456789abcdef_[a1[6] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[15] = _0123456789abcdef_[a1[7] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[17] = _0123456789abcdef_[a1[8] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[19] = _0123456789abcdef_[a1[9] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[10] >> 4];
  a2[21] = _0123456789abcdef_[a1[10] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[11] >> 4];
  a2[23] = _0123456789abcdef_[a1[11] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[12] >> 4];
  a2[25] = _0123456789abcdef_[a1[12] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[13] >> 4];
  a2[27] = _0123456789abcdef_[a1[13] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[14] >> 4];
  a2[29] = _0123456789abcdef_[a1[14] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[15] >> 4];
  a2[31] = _0123456789abcdef_[a1[15] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404EEAB0 (0x1404EEAB0) ---

// --- Function: sub_1404F5D80 (0x1404F5D80) ---
__int64 __fastcall sub_1404F5D80(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rsi
  __int64 result; // rax

  v4 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(_QWORD **)(a1 + 8); v4 != i; ++v4 )
    {
      DestroyStringObject(v4);
    }
    sub_14039EFB0(a1, *(const void **)a1, (*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 8 * a3;
  result = a2 + 8 * a4;
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

// --- End Function: sub_1404F5D80 (0x1404F5D80) ---

// --- Function: sub_1404FAD80 (0x1404FAD80) ---
unsigned __int8 ***__fastcall sub_1404FAD80(unsigned __int8 ***a1, unsigned __int8 ***a2, unsigned __int8 **a3)
{
  unsigned __int8 **v3; // rdi
  unsigned __int8 *v7; // rbx

  v3 = *a1;
  v7 = (*a1)[1];
  while ( !v7[25] )
  {
    if ( (int)sub_1403DFBE0((unsigned __int8 **)v7 + 4, a3) >= 0 )
    {
      v3 = (unsigned __int8 **)v7;
      v7 = *(unsigned __int8 **)v7;
    }
    else
    {
      v7 = (unsigned __int8 *)*((_QWORD *)v7 + 2);
    }
  }
  if ( *((_BYTE *)v3 + 25) || (int)sub_1403DFBE0(a3, v3 + 4) < 0 )
  {
    *a2 = *a1;
  }
  else
  {
    *a2 = v3;
  }
  return a2;
}

// --- End Function: sub_1404FAD80 (0x1404FAD80) ---

// --- Function: sub_1404FE820 (0x1404FE820) ---
__int64 __fastcall sub_1404FE820(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_14044A020(a2, a3, 0LL, *(_DWORD *)(a1 + 8));
}

// --- End Function: sub_1404FE820 (0x1404FE820) ---

// --- Function: sub_140535CF0 (0x140535CF0) ---
__int64 (__fastcall *__fastcall sub_140535CF0(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_140397520(0LL, "__InitializeThreadInfoBlock__", 0);
  if ( result )
  {
    return (__int64 (__fastcall *)(__int64))result(a1);
  }
  return result;
}

// --- End Function: sub_140535CF0 (0x140535CF0) ---

// --- Function: sub_140566BA0 (0x140566BA0) ---
char __fastcall sub_140566BA0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 12;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
      n2 = 26;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
    case 50:
    case 76:
      n2 = 11;
      break;
    case 54:
      n2 = 22;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 29;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 13;
      break;
    case 63:
    case 75:
      n2 = 28;
      break;
    case 64:
    case 78:
      n2 = 24;
      break;
    case 66:
    case 67:
      n2 = 27;
      break;
    case 70:
      n2 = 30;
      break;
    case 82:
    case 83:
      n2 = 15;
      break;
    case 88:
    case 89:
      n2 = 25;
      break;
    case 90:
    case 91:
      n2 = 16;
      break;
    case 92:
      n2 = 17;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 18;
      break;
    case 98:
    case 99:
      n2 = 19;
      break;
    case 100:
      n2 = 20;
      break;
    case 101:
    case 102:
      n2 = 21;
      break;
    case 103:
      n2 = 23;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_140566BA0 (0x140566BA0) ---

// --- Function: sub_140569F50 (0x140569F50) ---
char __fastcall sub_140569F50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149818690;
  if ( !qword_149818690 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403DE270(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149818690 = (__int64)v3;
  }
  if ( v3(a2, a3, 4096LL, 4LL) )
  {
    return 1;
  }
  if ( GetLastError() == 1455 )
  {
    sub_14056A220();
  }
  return 0;
}

// --- End Function: sub_140569F50 (0x140569F50) ---

// --- Function: sub_14056A090 (0x14056A090) ---
__int64 __fastcall sub_14056A090(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 4096LL )
      {
        return 4096LL;
      }
      if ( ++v1 == v2 )
      {
        return 4096LL;
      }
    }
  }
  return 4096LL;
}

// --- End Function: sub_14056A090 (0x14056A090) ---

// --- Function: sub_14056A0D0 (0x14056A0D0) ---
__int64 __fastcall sub_14056A0D0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149818690;
  if ( !qword_149818690 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403DE270(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149818690 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0LL, a2, 0x2000LL, 4LL);
  *(_DWORD *)(a1 + 16) = a6;
  *(_QWORD *)(a1 + 24) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 20) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056A0D0 (0x14056A0D0) ---

// --- Function: sub_140593A60 (0x140593A60) ---
_QWORD *__fastcall sub_140593A60(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_140593A60 (0x140593A60) ---

// --- Function: sub_140593C00 (0x140593C00) ---
__m128 __fastcall sub_140593C00(double _XMM0_8)
{
  __int128 v4; // kr00_16

  _XMM0 = 0LL;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v4 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v4 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v4;
}

// --- End Function: sub_140593C00 (0x140593C00) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !Parameter_3 )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = -1;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[4095] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)Parameter_3 + 280LL))(
                      Parameter_3,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: sub_1405BD4A0 (0x1405BD4A0) ---
__int64 sub_1405BD4A0(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_14981D3D8 && Parameter_3 )
  {
    if ( a3 )
    {
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)Parameter_3 + 344LL))(
               Parameter_3,
               a1,
               a2,
               0LL,
               0LL,
               a3,
               (__int64 *)va);
    }
  }
  return result;
}

// --- End Function: sub_1405BD4A0 (0x1405BD4A0) ---

// --- Function: sub_1405D5BC0 (0x1405D5BC0) ---
_QWORD *__fastcall sub_1405D5BC0(_QWORD *a1)
{
  *a1 = 0LL;
  return a1;
}

// --- End Function: sub_1405D5BC0 (0x1405D5BC0) ---

// --- Function: sub_140892F20 (0x140892F20) ---
char *__fastcall sub_140892F20(__int64 a1, _DWORD *a2)
{
  _BYTE *v3; // rdx
  char *result; // rax

  v3 = *(_BYTE **)(a1 + 8);
  if ( v3 == *(_BYTE **)(a1 + 16) )
  {
    return sub_140342370(a1, v3, a2);
  }
  *(_DWORD *)v3 = *a2;
  result = *(char **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = result + 4;
  return result;
}

// --- End Function: sub_140892F20 (0x140892F20) ---

// --- Function: ensureCapacityAndZeroFill (0x1408E1C10) ---
char *__fastcall ensureCapacityAndZeroFill(char **pOutFieldPtrsVec, unsigned __int64 totalFieldCount)
{
  char *v2; // rbp
  char *result; // rax
  unsigned __int64 totalFieldCount_3; // rsi
  unsigned __int64 totalFieldCount_2; // rcx
  unsigned __int64 totalFieldCount_1; // rdx
  unsigned __int64 v9; // r8
  __int64 v10; // r15
  char *v11; // r14
  size_t Size; // rbx

  v2 = pOutFieldPtrsVec[1];
  result = *pOutFieldPtrsVec;
  totalFieldCount_3 = (v2 - *pOutFieldPtrsVec) >> 3;
  if ( totalFieldCount >= totalFieldCount_3 )
  {
    if ( totalFieldCount > totalFieldCount_3 )
    {
      totalFieldCount_2 = (pOutFieldPtrsVec[2] - result) >> 3;
      if ( totalFieldCount <= totalFieldCount_2 )
      {
        Size = 8 * (totalFieldCount - totalFieldCount_3);
        memset(v2, 0, Size);
        result = &v2[Size];
        pOutFieldPtrsVec[1] = &v2[Size];
      }
      else
      {
        totalFieldCount_1 = 0x1FFFFFFFFFFFFFFFLL;
        if ( totalFieldCount > 0x1FFFFFFFFFFFFFFFLL )
        {
          unknown_libname_10();
        }
        v9 = totalFieldCount_2 >> 1;
        if ( totalFieldCount_2 <= 0x1FFFFFFFFFFFFFFFLL - (totalFieldCount_2 >> 1) )
        {
          totalFieldCount_1 = v9 + totalFieldCount_2;
          if ( v9 + totalFieldCount_2 < totalFieldCount )
          {
            totalFieldCount_1 = totalFieldCount;
          }
        }
        v10 = 8 * totalFieldCount_1;
        v11 = (char *)sub_14038E0B0((__int64)pOutFieldPtrsVec, 8 * totalFieldCount_1);
        memset(&v11[8 * totalFieldCount_3], 0, 8 * (totalFieldCount - totalFieldCount_3));
        memmove(v11, *pOutFieldPtrsVec, pOutFieldPtrsVec[1] - *pOutFieldPtrsVec);
        if ( *pOutFieldPtrsVec )
        {
          sub_14039EFB0(
            (__int64)pOutFieldPtrsVec,
            *pOutFieldPtrsVec,
            (pOutFieldPtrsVec[2] - *pOutFieldPtrsVec) & 0xFFFFFFFFFFFFFFF8uLL);
        }
        *pOutFieldPtrsVec = v11;
        pOutFieldPtrsVec[1] = &v11[8 * totalFieldCount];
        result = &v11[v10];
        pOutFieldPtrsVec[2] = &v11[v10];
      }
    }
  }
  else
  {
    result += 8 * totalFieldCount;
    pOutFieldPtrsVec[1] = result;
  }
  return result;
}

// --- End Function: ensureCapacityAndZeroFill (0x1408E1C10) ---

// --- Function: sub_1409310A0 (0x1409310A0) ---
unsigned __int64 __fastcall sub_1409310A0(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // r9
  int v7; // r11d
  int v8; // eax
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rdx
  int v11; // eax
  unsigned __int64 v12; // rax
  unsigned __int64 result; // rax
  __int64 v14; // rdx
  int a4; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v7 = *(_DWORD *)(*a1 - 4);
  v8 = 16 * v7;
  if ( v7 >= 0 )
  {
    v9 = (unsigned __int64)v8 >> 4;
  }
  else
  {
    LODWORD(v9) = *(_DWORD *)(v8 + v3);
  }
  v10 = 0LL;
  v11 = 0;
  if ( a3 )
  {
    LOBYTE(v11) = a2 > (int)v9;
  }
  else
  {
    LOBYTE(v11) = a2 != (_DWORD)v9;
  }
  if ( v11 )
  {
    a4 = a2;
    if ( v7 )
    {
      v10 = v3;
    }
    v12 = sub_140448AD0((__int64)a1, v10, v7 & 0x7FFFFFFF, &a4, 8uLL, a3);
    *a1 = v12;
    v3 = v12;
    if ( !v12 )
    {
      result = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
      *a1 = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
      return result;
    }
    LODWORD(v9) = a4;
  }
  v14 = 16 * a2;
  *(_DWORD *)(v3 - 4) = a2;
  result = v14 + 4;
  if ( 16LL * (int)v9 >= (unsigned __int64)(v14 + 4) )
  {
    *(_DWORD *)(v3 - 4) = a2 | 0x80000000;
    *(_DWORD *)(v14 + v3) = v9;
  }
  return result;
}

// --- End Function: sub_1409310A0 (0x1409310A0) ---

// --- Function: sub_140996BE0 (0x140996BE0) ---
__int64 __fastcall sub_140996BE0(__int64 a1, __int64 a2, __int64 i)
{
  __int64 i_1; // rbx
  _QWORD *i_2; // rdi
  __int64 result; // rax

  i_1 = i;
  while ( !*(_BYTE *)(i_1 + 25) )
  {
    sub_140996BE0(a1, a2, *(_QWORD *)(i_1 + 16));
    i_2 = (_QWORD *)i_1;
    i_1 = *(_QWORD *)i_1;
    DestroyStringObject(i_2 + 4);
    free_memory_wrapper(i_2);
  }
  return result;
}

// --- End Function: sub_140996BE0 (0x140996BE0) ---

// --- Function: sub_1409A18C0 (0x1409A18C0) ---
__int64 *__fastcall sub_1409A18C0(__int64 **a1, __int64 *a2)
{
  __int64 *v2; // rdi
  __int64 v5; // rbx
  __int64 *v6; // rdi
  __int64 v7; // rsi
  __int128 v8; // xmm0
  __int128 v10; // [rsp+20h] [rbp-38h] BYREF

  v2 = *a1;
  DWORD2(v10) = 0;
  v5 = v2[1];
  *(_QWORD *)&v10 = v5;
  while ( !*(_BYTE *)(v5 + 25) )
  {
    *(_QWORD *)&v10 = v5;
    if ( (int)sub_1403DFBE0((unsigned __int8 **)(v5 + 32), a2) >= 0 )
    {
      v2 = (__int64 *)v5;
      DWORD2(v10) = 1;
      v5 = *(_QWORD *)v5;
    }
    else
    {
      v5 = *(_QWORD *)(v5 + 16);
      DWORD2(v10) = 0;
    }
  }
  if ( *((_BYTE *)v2 + 25) || (int)sub_1403DFBE0((unsigned __int8 **)a2, v2 + 4) < 0 )
  {
    if ( a1[1] == (__int64 *)0x555555555555555LL )
    {
      unknown_libname_7();
    }
    v6 = *a1;
    v7 = sub_1402A1E30(0x30uLL);
    sub_1403577A0((_QWORD *)(v7 + 32), a2);
    v8 = v10;
    *(_DWORD *)(v7 + 40) = 0;
    *(_QWORD *)v7 = v6;
    *(_QWORD *)(v7 + 8) = v6;
    *(_QWORD *)(v7 + 16) = v6;
    *(_WORD *)(v7 + 24) = 0;
    v10 = v8;
    v2 = (__int64 *)sub_1402DE890(a1, (__int64)&v10, v7);
  }
  return v2 + 5;
}

// --- End Function: sub_1409A18C0 (0x1409A18C0) ---

// --- Function: sub_140B7AA40 (0x140B7AA40) ---
char *__fastcall sub_140B7AA40(char *a1, char *a2, char *a3)
{
  char *v3; // rdi
  char *v5; // rbx
  signed __int64 v6; // rsi
  signed __int64 v7; // r14

  v3 = a3;
  v5 = a1;
  if ( a1 != a2 )
  {
    v6 = a1 - a3;
    v7 = a3 - a1 + 8;
    do
    {
      *(_QWORD *)v3 = *(_QWORD *)v5;
      sub_1403577A0(&v5[v7], (__int64 *)&v5[v7 + v6]);
      v3 += 16;
      v5 += 16;
    }
    while ( v5 != a2 );
  }
  return v3;
}

// --- End Function: sub_140B7AA40 (0x140B7AA40) ---

// --- Function: sub_140B8CA90 (0x140B8CA90) ---
__int64 __fastcall sub_140B8CA90(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rdi
  _QWORD *ptr_to_free; // rcx
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; v1 += 2 )
    {
      DestroyStringObject(v1 + 1);
    }
    ptr_to_free = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)ptr_to_free - *(ptr_to_free - 1) - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      ptr_to_free = (_QWORD *)*(ptr_to_free - 1);
    }
    free_memory_wrapper(ptr_to_free);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140B8CA90 (0x140B8CA90) ---

// --- Function: sub_140C9F2E0 (0x140C9F2E0) ---
unsigned __int8 **__fastcall sub_140C9F2E0(unsigned __int8 ***a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2; // rdi
  unsigned __int8 *v5; // rbx
  bool v6; // sf
  unsigned __int8 **result; // rax

  v2 = (unsigned __int8 *)*a1;
  v5 = (*a1)[1];
  while ( !v5[25] )
  {
    if ( (int)sub_1403DFBE0((unsigned __int8 **)v5 + 4, a2) >= 0 )
    {
      v2 = v5;
      v5 = *(unsigned __int8 **)v5;
    }
    else
    {
      v5 = (unsigned __int8 *)*((_QWORD *)v5 + 2);
    }
  }
  if ( v2[25] )
  {
    return *a1;
  }
  v6 = (int)sub_1403DFBE0(a2, (_QWORD *)v2 + 4) < 0;
  result = (unsigned __int8 **)v2;
  if ( v6 )
  {
    return *a1;
  }
  return result;
}

// --- End Function: sub_140C9F2E0 (0x140C9F2E0) ---

// --- Function: sub_1411D1770 (0x1411D1770) ---
bool __fastcall sub_1411D1770(__int64 a1, __int64 a2, unsigned __int8 **a3)
{
  return !*(_BYTE *)(a2 + 25) && (int)sub_1403DFBE0(a3, (_QWORD *)(a2 + 32)) >= 0;
}

// --- End Function: sub_1411D1770 (0x1411D1770) ---

// --- Function: sub_1417C3450 (0x1417C3450) ---
_QWORD *__fastcall sub_1417C3450(_QWORD *pExceptionObject)
{
  pExceptionObject[1] = "bad allocation";
  *pExceptionObject = off_147F343E8;
  return pExceptionObject;
}

// --- End Function: sub_1417C3450 (0x1417C3450) ---

// --- Function: sub_14188D0D0 (0x14188D0D0) ---
__int64 __fastcall sub_14188D0D0(__int64 **a1, unsigned __int64 *a2)
{
  __int64 *v2; // rbx
  __int64 v5; // r8
  __int64 v6; // rax
  unsigned __int64 v7; // r9
  __int64 v8; // rax
  __int64 v10; // [rsp+20h] [rbp-28h] BYREF
  int v11; // [rsp+28h] [rbp-20h]

  v2 = *a1;
  v11 = 0;
  v5 = (__int64)v2;
  v6 = v2[1];
  v10 = v6;
  if ( !*(_BYTE *)(v6 + 25) )
  {
    v7 = *a2;
    do
    {
      v10 = v6;
      if ( *(_QWORD *)(v6 + 32) >= v7 )
      {
        v5 = v6;
        v11 = 1;
        v6 = *(_QWORD *)v6;
      }
      else
      {
        v6 = *(_QWORD *)(v6 + 16);
        v11 = 0;
      }
    }
    while ( !*(_BYTE *)(v6 + 25) );
  }
  if ( *(_BYTE *)(v5 + 25) || *a2 < *(_QWORD *)(v5 + 32) )
  {
    if ( a1[1] == (__int64 *)0x555555555555555LL )
    {
      unknown_libname_7();
    }
    v8 = sub_14038E0B0((__int64)a1, 0x30uLL);
    *(_QWORD *)(v8 + 32) = *a2;
    *(_QWORD *)(v8 + 40) = 0LL;
    *(_QWORD *)v8 = v2;
    *(_QWORD *)(v8 + 8) = v2;
    *(_QWORD *)(v8 + 16) = v2;
    *(_WORD *)(v8 + 24) = 0;
    v5 = sub_1402DE890(a1, (__int64)&v10, v8);
  }
  return v5 + 40;
}

// --- End Function: sub_14188D0D0 (0x14188D0D0) ---

// --- Function: sub_141D9EE10 (0x141D9EE10) ---
char *__fastcall sub_141D9EE10(char **a1, char *a2, _QWORD *a3)
{
  __int64 v4; // rbx
  signed __int64 v5; // r15
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r14
  unsigned __int64 n0x6400000; // r14
  __int64 v13; // rax
  char *v14; // rdi
  char *v15; // r12
  char *v16; // rdx
  char *v17; // r8
  char *v18; // rcx
  char *v19; // rbx
  char *i; // rbp
  char *ptr_to_free; // rcx
  char *result; // rax

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    goto LABEL_25;
  }
  v11 = v8;
  if ( v10 + v9 >= v8 )
  {
    v11 = v10 + v9;
  }
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
  {
    goto LABEL_25;
  }
  n0x6400000 = 16 * v11;
  if ( n0x6400000 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      v14 = (char *)sub_1402A1E30(n0x6400000);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_13;
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_25:
    sub_1402DEE40();
  }
  v13 = sub_1402A1E30(n0x6400000 + 39);
  if ( !v13 )
  {
    goto LABEL_23;
  }
  v14 = (char *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v4 & 0xFFFFFFFFFFFFFFF0uLL];
  *(_QWORD *)v15 = *a3;
  sub_1403577A0((_QWORD *)v15 + 1, a3 + 1);
  v16 = a1[1];
  v17 = v14;
  v18 = *a1;
  if ( a2 != v16 )
  {
    sub_140B7AA40(v18, a2, v14);
    v16 = a1[1];
    v17 = v15 + 16;
    v18 = a2;
  }
  sub_140B7AA40(v18, v16, v17);
  v19 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v19 != i; v19 += 16 )
    {
      DestroyStringObject((_QWORD *)v19 + 1);
    }
    ptr_to_free = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
      goto LABEL_21;
    }
    if ( (unsigned __int64)&ptr_to_free[-*((_QWORD *)ptr_to_free - 1) - 8] <= 0x1F )
    {
      ptr_to_free = (char *)*((_QWORD *)ptr_to_free - 1);
LABEL_21:
      free_memory_wrapper(ptr_to_free);
      goto LABEL_22;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  *a1 = v14;
  result = v15;
  a1[1] = &v14[16 * v8];
  a1[2] = &v14[n0x6400000];
  return result;
}

// --- End Function: sub_141D9EE10 (0x141D9EE10) ---

// --- Function: sub_141F12DE0 (0x141F12DE0) ---
__int64 __fastcall sub_141F12DE0(__int64 a1, __int64 a2, __int64 i)
{
  __int64 i_1; // rbx
  _QWORD *i_2; // rdi
  __int64 result; // rax

  i_1 = i;
  while ( !*(_BYTE *)(i_1 + 25) )
  {
    sub_141F12DE0(a1, a2, *(_QWORD *)(i_1 + 16));
    i_2 = (_QWORD *)i_1;
    i_1 = *(_QWORD *)i_1;
    DestroyStringObject(i_2 + 4);
    free_memory_wrapper(i_2);
  }
  return result;
}

// --- End Function: sub_141F12DE0 (0x141F12DE0) ---

// --- Function: sub_142230BA0 (0x142230BA0) ---
unsigned __int64 __fastcall sub_142230BA0(__int64 a1)
{
  __int128 *v1; // rdx
  __int64 v3; // r8
  __int128 *v4; // rcx
  __int128 *v5; // rax
  unsigned __int64 v9; // rcx
  __int64 v10; // rdi
  __int64 v11; // rsi
  __int64 v12; // r14
  int v13; // eax
  __int64 v14; // r11
  __int128 *v15; // r9
  unsigned __int64 v17; // r10
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  __int64 v23; // r8
  unsigned __int64 v24; // rdx
  __int64 v25; // r8
  char v26; // r10
  bool v27; // zf
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // rax
  __int64 v31; // rax
  __int128 v32; // xmm3
  double v33; // xmm2_8
  __int64 v34; // rax
  unsigned __int64 result; // rax

  v1 = *(__int128 **)a1;
  v3 = *(_QWORD *)(a1 + 24);
  v4 = v1;
  v5 = (__int128 *)((char *)v1 + v3 + 1);
  if ( v1 != v5 )
  {
    _XMM3 = 0LL;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm3, xmmword ptr [rcx]
        vpandn  xmm1, xmm0, xmm4
      }
      *v4++ = _XMM1 | xmmword_147F33270;
    }
    while ( v4 != v5 );
  }
  *v5 = *v1;
  *((_BYTE *)v1 + v3) = -1;
  v9 = *(_QWORD *)(a1 + 24);
  v10 = 0LL;
  if ( v9 )
  {
    v11 = -16LL;
    do
    {
      if ( *(_BYTE *)(v10 + *(_QWORD *)a1) == 0xFE )
      {
        v12 = 24 * v10;
        v13 = psub_1403339F0(0xFFFFFFFF, 24 * v10 + *(_QWORD *)(a1 + 8), 16LL);
        v14 = *(_QWORD *)(a1 + 24);
        v15 = *(__int128 **)a1;
        _XMM1 = XMM4;
        v17 = (__PAIR128__((unsigned int)~v13, (unsigned int)~v13) * 0xDE5FB9D2630458E9uLL) >> 64;
        v18 = 0LL;
        v19 = v14 & (v17 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r9+rcx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v18 += 16LL;
          v19 = (v18 + v19) & v14;
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r9+rcx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v23, _EAX);
        v24 = v14 & (v17 >> 7);
        v25 = (v19 + v23) & v14;
        v26 = v17 & 0x7F;
        if ( (((v10 - v24) ^ (v25 - v24)) & v14 & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
        {
          v27 = *((_BYTE *)v15 + v25) == 0x80;
          v28 = 24 * v25;
          *((_BYTE *)v15 + v25) = v26;
          v29 = v25 - 16;
          if ( v27 )
          {
            *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v29) + *(_QWORD *)a1 + 1) = v26;
            v30 = *(_QWORD *)(a1 + 8);
            *(_OWORD *)(v28 + v30) = *(_OWORD *)(v12 + v30);
            *(double *)(v28 + v30 + 16) = *(double *)(v12 + v30 + 16);
            *(_BYTE *)(v10 + *(_QWORD *)a1) = 0x80;
            *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (v11 & *(_QWORD *)(a1 + 24)) + *(_QWORD *)a1 + 1) = 0x80;
          }
          else
          {
            --v10;
            --v11;
            *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v29) + *(_QWORD *)a1 + 1) = v26;
            v31 = *(_QWORD *)(a1 + 8);
            v32 = *(_OWORD *)(v12 + v31);
            v33 = *(double *)(v12 + v31 + 16);
            *(_OWORD *)(v12 + v31) = *(_OWORD *)(v28 + v31);
            *(double *)(v12 + v31 + 16) = *(double *)(v28 + v31 + 16);
            v34 = *(_QWORD *)(a1 + 8);
            *(_OWORD *)(v34 + 24 * v25) = v32;
            *(double *)(v34 + v28 + 16) = v33;
          }
        }
        else
        {
          *((_BYTE *)v15 + v10) = v26;
          *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v11) + *(_QWORD *)a1 + 1) = v26;
        }
      }
      v9 = *(_QWORD *)(a1 + 24);
      ++v10;
      ++v11;
    }
    while ( v10 != v9 );
  }
  result = v9 >> 3;
  *(_QWORD *)(a1 + 48) = v9 - (v9 >> 3) - *(_QWORD *)(a1 + 16);
  return result;
}

// --- End Function: sub_142230BA0 (0x142230BA0) ---

// --- Function: sub_1422335C0 (0x1422335C0) ---
__int64 __fastcall sub_1422335C0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  unsigned __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = XMM4;
  v4 = 0LL;
  v5 = a2 >> 7;
  v6 = 0LL;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 16LL;
    v9 = (v9 + v6) & v7;
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = (v9 + v13) & v7;
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_142230BA0((__int64)a1);
LABEL_11:
        v18 = a1[3];
        v19 = 0LL;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 16LL;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = (_RAX + v20) & v18;
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1LL;
    }
    sub_142235ED0(a1, v17);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_1422335C0 (0x1422335C0) ---

// --- Function: sub_142235ED0 (0x142235ED0) ---
unsigned __int64 __fastcall sub_142235ED0(const void **a1, unsigned __int64 a2)
{
  char *v2; // rbp
  __int64 v3; // r15
  __int64 v4; // r14
  unsigned __int64 v7; // rbx
  char *v8; // rax
  __int64 v9; // rbx
  unsigned __int64 result; // rax
  __int64 v11; // rdi
  int v12; // eax
  __int64 v13; // r9
  unsigned __int64 v15; // r11
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v21; // r8
  char v22; // r11
  __int64 v23; // r8
  __int64 v24; // rdx
  __int64 v25; // rax

  v2 = (char *)*a1;
  v3 = (__int64)a1[1];
  v4 = (__int64)a1[3];
  v7 = (a2 + 24) & 0xFFFFFFFFFFFFFFF8uLL;
  v8 = (char *)sub_1402A1E30(v7 + 24 * a2);
  *a1 = v8;
  a1[1] = &v8[v7];
  memset(v8, -128, a2 + 16);
  v9 = 0LL;
  *((_BYTE *)*a1 + a2) = -1;
  result = a2 >> 3;
  a1[3] = (const void *)a2;
  a1[6] = (const void *)(a2 - (a2 >> 3) - (_QWORD)a1[2]);
  if ( v4 )
  {
    do
    {
      if ( v2[v9] >= 0 )
      {
        v11 = v3 + 24 * v9;
        v12 = psub_1403339F0(0xFFFFFFFF, v11, 16LL);
        v13 = (__int64)a1[3];
        _XMM1 = XMM4;
        v15 = (__PAIR128__((unsigned int)~v12, (unsigned int)~v12) * 0xDE5FB9D2630458E9uLL) >> 64;
        v16 = 0LL;
        v17 = v13 & (v15 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r10+rcx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v16 += 16LL;
          v17 = (v16 + v17) & v13;
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r10+rcx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v21, _EAX);
        v22 = v15 & 0x7F;
        v23 = (v17 + v21) & v13;
        *((_BYTE *)*a1 + v23) = v22;
        v24 = 3 * v23;
        *((_BYTE *)*a1 + ((unsigned __int64)a1[3] & 0xF) + ((unsigned __int64)a1[3] & (v23 - 16)) + 1) = v22;
        v25 = (__int64)a1[1];
        *(_OWORD *)(v25 + 8 * v24) = *(_OWORD *)v11;
        *(double *)(v25 + 8 * v24 + 16) = *(double *)(v11 + 16);
      }
      ++v9;
    }
    while ( v9 != v4 );
    return free_memory_wrapper(v2);
  }
  return result;
}

// --- End Function: sub_142235ED0 (0x142235ED0) ---

// --- Function: sub_142474120 (0x142474120) ---
unsigned __int64 __fastcall sub_142474120(unsigned __int64 *a1, int a2, int *k)
{
  __int64 v4; // rbp
  unsigned __int64 v6; // r8
  int v7; // r9d
  int v8; // eax
  int v9; // edi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rax
  __int64 v13; // r9
  __int64 v14; // rax
  unsigned __int64 k_1; // r10
  _DWORD *k_3; // r9
  _DWORD *k_2; // rdx
  unsigned __int64 n4; // r8
  int v19; // eax
  unsigned __int64 v20; // r8
  _DWORD *k_4; // rdi
  unsigned __int64 i; // rcx
  int a4; // [rsp+58h] [rbp+10h] BYREF

  v4 = a2;
  v6 = *a1;
  v7 = *(_DWORD *)(*a1 - 4);
  v8 = 4 * v7;
  v9 = (v7 & 0x7FFFFFFF) + a2;
  if ( v7 >= 0 )
  {
    v10 = (unsigned __int64)v8 >> 2;
  }
  else
  {
    LODWORD(v10) = *(_DWORD *)(v8 + v6);
  }
  if ( v9 > (int)v10 )
  {
    v11 = 0;
    a4 = v9;
    if ( v7 )
    {
      v11 = v6;
    }
    v12 = sub_140306F70((__int64)a1, v11, v7 & 0x7FFFFFFF, &a4, 4u, 1);
    *a1 = v12;
    v6 = v12;
    if ( !v12 )
    {
      *a1 = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
      goto LABEL_12;
    }
    LODWORD(v10) = a4;
  }
  v13 = 4 * v9;
  *(_DWORD *)(v6 - 4) = v9;
  if ( 4LL * (int)v10 >= (unsigned __int64)(v13 + 4) )
  {
    *(_DWORD *)(v6 - 4) = v9 | 0x80000000;
    *(_DWORD *)(v13 + v6) = v10;
  }
LABEL_12:
  v14 = *(unsigned int *)(*a1 - 4);
  LODWORD(v14) = v14 & 0x7FFFFFFF;
  k_1 = *a1 + 4 * (v14 - v4);
  k_3 = (_DWORD *)(4 * v4 + k_1);
  k_2 = (_DWORD *)k_1;
  n4 = (unsigned __int64)(4 * v4) >> 2;
  if ( k_1 > (unsigned __int64)k_3 )
  {
    n4 = 0;
  }
  if ( n4 >= 4 && (k_1 > (unsigned __int64)k || k_1 - 4 + 4 * n4 < (unsigned __int64)k) )
  {
    v19 = *k;
    v20 = 4 * (n4 & 0xFFFFFFFFFFFFFFFCuLL);
    k_4 = (_DWORD *)k_1;
    for ( i = v20 >> 2; i; --i )
    {
      *k_4++ = v19;
    }
    k_2 = (_DWORD *)(v20 + k_1);
  }
  for ( ; k_2 != k_3; ++k_2 )
  {
    *k_2 = *k;
  }
  return k_1;
}

// --- End Function: sub_142474120 (0x142474120) ---

// --- Function: ??$_Find@PEAX@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@AEBQEAX@Z (0x142D08BA0) ---
__int64 __fastcall std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
        __int64 *a1,
        unsigned __int8 **a2)
{
  _BYTE v3[16]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v4; // [rsp+30h] [rbp-18h]

  sub_140432100(a1, (__int64)v3, a2);
  if ( sub_1411D1770((__int64)a1, v4, a2) )
  {
    return v4;
  }
  else
  {
    return *(_QWORD *)_((__int64)a1);
  }
}

// --- End Function: ??$_Find@PEAX@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@AEBQEAX@Z (0x142D08BA0) ---

// --- Function: ?find@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@AEBQEAX@Z (0x142D951B0) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::find(
        __int64 *a1,
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *a2,
        unsigned __int8 **a3)
{
  struct __crt_stdio_stream *v4; // [rsp+28h] [rbp-10h]

  _((__int64)a1);
  v4 = (struct __crt_stdio_stream *)std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
                                      a1,
                                      a3);
  _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(a2, v4);
  return a2;
}

// --- End Function: ?find@?$_Tree@V?$_Tmap_traits@PEAXU_Mutex_count_pair@?A0xd833279a@@U?$less@PEAX@std@@V?$_Crt_allocator@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@AEBQEAX@Z (0x142D951B0) ---

// --- Function: sub_14327BC00 (0x14327BC00) ---
__int64 *__fastcall sub_14327BC00(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rdi
  __int64 v5; // rbx
  __int64 *v6; // rdi
  __int64 v7; // rsi
  __int128 v8; // xmm0
  __int128 v10; // [rsp+20h] [rbp-38h] BYREF

  v2 = *(__int64 **)a1;
  DWORD2(v10) = 0;
  v5 = v2[1];
  *(_QWORD *)&v10 = v5;
  while ( !*(_BYTE *)(v5 + 25) )
  {
    *(_QWORD *)&v10 = v5;
    if ( (int)sub_1403DFBE0((unsigned __int8 **)(v5 + 32), a2) >= 0 )
    {
      v2 = (__int64 *)v5;
      DWORD2(v10) = 1;
      v5 = *(_QWORD *)v5;
    }
    else
    {
      v5 = *(_QWORD *)(v5 + 16);
      DWORD2(v10) = 0;
    }
  }
  if ( *((_BYTE *)v2 + 25) || (int)sub_1403DFBE0((unsigned __int8 **)a2, v2 + 4) < 0 )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x3FFFFFFFFFFFFFFLL )
    {
      unknown_libname_7();
    }
    v6 = *(__int64 **)a1;
    v7 = sub_1402A1E30(0x40uLL);
    sub_1403577A0((_QWORD *)(v7 + 32), a2);
    v8 = v10;
    *(_QWORD *)(v7 + 40) = 0LL;
    *(_QWORD *)(v7 + 48) = 0LL;
    *(_QWORD *)(v7 + 56) = 0LL;
    *(_QWORD *)v7 = v6;
    *(_QWORD *)(v7 + 8) = v6;
    *(_QWORD *)(v7 + 16) = v6;
    *(_WORD *)(v7 + 24) = 0;
    v10 = v8;
    v2 = (__int64 *)sub_1402DE890((__int64 **)a1, (__int64)&v10, v7);
  }
  return v2 + 5;
}

// --- End Function: sub_14327BC00 (0x14327BC00) ---

// --- Function: ??0?$_Yarn@_W@std@@QEAA@XZ (0x143675630) ---
__int64 __fastcall std::_Yarn<wchar_t>::_Yarn<wchar_t>(__int64 a1)
{
  *(_QWORD *)a1 = 0LL;
  *(_WORD *)(a1 + 8) = 0;
  return a1;
}

// --- End Function: ??0?$_Yarn@_W@std@@QEAA@XZ (0x143675630) ---

// --- Function: sub_1468DBFC0 (0x1468DBFC0) ---
__int64 __fastcall sub_1468DBFC0(__int64 a1)
{
  return *(unsigned int *)(a1 + 720);
}

// --- End Function: sub_1468DBFC0 (0x1468DBFC0) ---

// --- Function: sub_1469A4AA0 (0x1469A4AA0) ---
char __fastcall sub_1469A4AA0(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v11; // rsp
  __int64 v13; // [rsp+18h] [rbp-158h]
  __int64 v14[11]; // [rsp+30h] [rbp-140h] BYREF
  __int16 n256; // [rsp+88h] [rbp-E8h]
  __int64 n176; // [rsp+90h] [rbp-E0h]
  _QWORD *v17; // [rsp+98h] [rbp-D8h]
  const char *p_Int; // [rsp+A0h] [rbp-D0h]
  __int64 v19; // [rsp+A8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1404FE820)(__int64, __int64, __int64); // [rsp+B0h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1404FE820_1)(__int64, __int64, __int64); // [rsp+B8h] [rbp-B8h]
  __int64 v22; // [rsp+C0h] [rbp-B0h]
  bool (__fastcall *p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z)(__int64, __int64); // [rsp+C8h] [rbp-A8h]
  __int64 v24; // [rsp+D0h] [rbp-A0h]
  __int64 (__fastcall *p_sub_1403E02D0)(const void *); // [rsp+D8h] [rbp-98h]
  _OWORD *(__fastcall *p_sub_1403DFFC0)(_OWORD *); // [rsp+E0h] [rbp-90h]
  __int64 v27; // [rsp+E8h] [rbp-88h]
  char v28; // [rsp+F0h] [rbp-80h]
  char v29; // [rsp+F1h] [rbp-7Fh]
  __int64 n16; // [rsp+F8h] [rbp-78h]
  _QWORD *v31; // [rsp+100h] [rbp-70h]
  const char *p_Int_1; // [rsp+108h] [rbp-68h]
  __int64 v33; // [rsp+110h] [rbp-60h]
  __int64 (__fastcall *p_sub_1404FE820_2)(__int64, __int64, __int64); // [rsp+118h] [rbp-58h]
  __int64 (__fastcall *p_sub_1404FE820_3)(__int64, __int64, __int64); // [rsp+120h] [rbp-50h]
  __int64 v36; // [rsp+128h] [rbp-48h]
  bool (__fastcall *p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z_1)(__int64, __int64); // [rsp+130h] [rbp-40h]
  __int64 v38; // [rsp+138h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E02D0_1)(const void *); // [rsp+140h] [rbp-30h]
  _OWORD *(__fastcall *p_sub_1403DFFC0_1)(_OWORD *); // [rsp+148h] [rbp-28h]
  __int64 v41; // [rsp+150h] [rbp-20h]
  char v42; // [rsp+158h] [rbp-18h]
  char v43; // [rsp+159h] [rbp-17h]
  __int64 n16_1; // [rsp+160h] [rbp-10h]

  v11 = alloca(320);
  v14[0] = a9;
  n256 = 256;
  v14[2] = 0;
  v14[1] = (__int64)"TraceContext";
  v14[5] = 0;
  v14[3] = (__int64)sub_1403E6C00;
  v14[7] = 0;
  v14[4] = (__int64)sub_1403E6700;
  v14[10] = -1;
  v14[6] = (__int64)sub_1403E2C50;
  n176 = 176;
  v14[8] = (__int64)sub_1403E02C0;
  v14[9] = (__int64)sub_1403DFFB0;
  v17 = a10;
  p_Int = "Int";
  v29 = 0;
  v19 = *a10;
  v31 = a11;
  p_sub_1404FE820 = sub_1404FE820;
  p_sub_1404FE820_1 = sub_1404FE820;
  v22 = 0;
  p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z = FH4::HandlerMap4::iterator::operator==;
  v24 = 0;
  p_sub_1403E02D0 = sub_1403E02D0;
  p_sub_1403DFFC0 = sub_1403DFFC0;
  v27 = -1;
  v28 = 0;
  n16 = 16;
  p_Int_1 = "Int";
  v43 = 0;
  v33 = *a11;
  LODWORD(v13) = a6;
  p_sub_1404FE820_2 = sub_1404FE820;
  p_sub_1404FE820_3 = sub_1404FE820;
  v36 = 0;
  p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z_1 = FH4::HandlerMap4::iterator::operator==;
  v38 = 0;
  p_sub_1403E02D0_1 = sub_1403E02D0;
  p_sub_1403DFFC0_1 = sub_1403DFFC0;
  v41 = -1;
  v42 = 0;
  n16_1 = 16;
  return sub_140302350(n4, a2, a3, a4, (__int64)v14, 3, a5, v13, a7, a8);
}

// --- End Function: sub_1469A4AA0 (0x1469A4AA0) ---

// --- Function: sub_1471DC1C0 (0x1471DC1C0) ---
unsigned __int64 __fastcall sub_1471DC1C0(unsigned __int64 *a1, _OWORD *a2)
{
  unsigned __int64 v2; // r8
  int v5; // r9d
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // rdx
  unsigned __int64 v14; // rdx
  unsigned __int64 result; // rax
  _OWORD *v16; // rcx
  int a4; // [rsp+40h] [rbp+8h] BYREF

  v2 = *a1;
  v5 = *(_DWORD *)(*a1 - 4);
  v6 = v5 & 0x7FFFFFFF;
  v7 = 16 * v5;
  v8 = (v5 & 0x7FFFFFFF) + 1;
  if ( v5 >= 0 )
  {
    v9 = (unsigned __int64)v7 >> 4;
  }
  else
  {
    LODWORD(v9) = *(_DWORD *)(v2 + v7);
  }
  if ( v8 > (int)v9 )
  {
    v10 = 0;
    a4 = v6 + 1;
    if ( v5 )
    {
      v10 = v2;
    }
    v11 = sub_140448AD0((__int64)a1, v10, v6, &a4, 8u, 1u);
    *a1 = v11;
    v2 = v11;
    if ( !v11 )
    {
      *a1 = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
      goto LABEL_12;
    }
    LODWORD(v9) = a4;
  }
  v12 = 16 * v8;
  *(_DWORD *)(v2 - 4) = v8;
  if ( 16LL * (int)v9 >= (unsigned __int64)(v12 + 4) )
  {
    *(_DWORD *)(v2 - 4) = v8 | 0x80000000;
    *(_DWORD *)(v12 + v2) = v9;
  }
LABEL_12:
  v13 = *(unsigned int *)(*a1 - 4);
  LODWORD(v13) = v13 & 0x7FFFFFFF;
  v14 = *a1 + 16 * v13;
  result = v14 - 16;
  v16 = (_OWORD *)(v14 - 16);
  do
  {
    *v16++ = *a2;
  }
  while ( v16 != (_OWORD *)v14 );
  return result;
}

// --- End Function: sub_1471DC1C0 (0x1471DC1C0) ---

// --- Function: sub_147211F60 (0x147211F60) ---
__int64 __fastcall sub_147211F60(__int64 *a1, __int64 *a2)
{
  __int64 v2; // r9
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r8
  __int64 i; // rdx
  __int64 v8; // rcx
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rsi
  _QWORD *v13; // rbx
  __int64 v14; // rdi
  char v15; // bp

  v2 = *a2;
  v5 = -1;
  do
  {
    ++v5;
  }
  while ( *(_BYTE *)(v2 + v5) );
  v6 = 0;
  for ( i = 0xCBF29CE484222325uLL; v6 < v5; i = 0x100000001B3LL * (v8 ^ i) )
  {
    v8 = *(unsigned __int8 *)(v6 + v2);
    ++v6;
  }
  v9 = (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 64;
  v10 = sub_147217050(a1, a2, v9);
  if ( v10 != -1 )
  {
    return a1[1] + 16 * v10 + 8;
  }
  v11 = sub_14726BC00(a1, v9);
  v12 = 16 * v11;
  v13 = (_QWORD *)(16 * v11 + a1[1]);
  v14 = v11;
  sub_1403577A0(v13, a2);
  v15 = v9 & 0x7F;
  v13[1] = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
  *(_BYTE *)(v14 + *a1) = v15;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v14 - 16)) + *a1 + 1) = v15;
  return v12 + a1[1] + 8;
}

// --- End Function: sub_147211F60 (0x147211F60) ---

// --- Function: sub_147213CC0 (0x147213CC0) ---
char *__fastcall sub_147213CC0(_QWORD *a1, char *a2, __int64 a3)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // r15
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r14
  unsigned __int64 n0x6400000; // r14
  __int64 v13; // rax
  char *v14; // rdi
  char *v15; // r12
  char *v16; // rdx
  char *v17; // r8
  char *v18; // rcx
  char *v19; // rbx
  char *i; // rbp
  char *ptr_to_free; // rcx
  char *result; // rax

  v4 = (unsigned __int64)&a2[-*a1];
  v5 = (__int64)(a1[1] - *a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = v5 + 1;
  v9 = (__int64)(a1[2] - *a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    goto LABEL_25;
  }
  v11 = v8;
  if ( v10 + v9 >= v8 )
  {
    v11 = v10 + v9;
  }
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
  {
    goto LABEL_25;
  }
  n0x6400000 = 16 * v11;
  if ( n0x6400000 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      v14 = (char *)sub_1402A1E30(n0x6400000);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_13;
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_25:
    sub_1402DEE40();
  }
  v13 = sub_1402A1E30(n0x6400000 + 39);
  if ( !v13 )
  {
    goto LABEL_23;
  }
  v14 = (char *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v4 & 0xFFFFFFFFFFFFFFF0uLL];
  *(_QWORD *)v15 = *(_QWORD *)a3;
  sub_1403577C0((void **)v15 + 1, (const void **)(a3 + 8));
  v16 = (char *)a1[1];
  v17 = v14;
  v18 = (char *)*a1;
  if ( a2 != v16 )
  {
    sub_140B7AA40(v18, a2, v14);
    v16 = (char *)a1[1];
    v17 = v15 + 16;
    v18 = a2;
  }
  sub_140B7AA40(v18, v16, v17);
  v19 = (char *)*a1;
  if ( *a1 )
  {
    for ( i = (char *)a1[1]; v19 != i; v19 += 16 )
    {
      DestroyStringObject((_QWORD *)v19 + 1);
    }
    ptr_to_free = (char *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
      goto LABEL_21;
    }
    if ( (unsigned __int64)&ptr_to_free[-*((_QWORD *)ptr_to_free - 1) - 8] <= 0x1F )
    {
      ptr_to_free = (char *)*((_QWORD *)ptr_to_free - 1);
LABEL_21:
      free_memory_wrapper(ptr_to_free);
      goto LABEL_22;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  *a1 = v14;
  result = v15;
  a1[1] = &v14[16 * v8];
  a1[2] = &v14[n0x6400000];
  return result;
}

// --- End Function: sub_147213CC0 (0x147213CC0) ---

// --- Function: sub_147214DC0 (0x147214DC0) ---
__int64 __fastcall sub_147214DC0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  const void *v6; // rdi
  __int64 result; // rax

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    do
    {
      sub_147214DC0(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      sub_14036D3C0((__int64)v6 + 32);
      result = sub_14039EFB0(a2, v6, 0x38uLL);
    }
    while ( !*((_BYTE *)v3 + 25) );
  }
  return result;
}

// --- End Function: sub_147214DC0 (0x147214DC0) ---

// --- Function: sub_147215CE0 (0x147215CE0) ---
char *__fastcall sub_147215CE0(__int64 a1, unsigned __int64 a2, _QWORD *p__RSI)
{
  _QWORD *v3; // r10
  char *result; // rax
  unsigned __int64 v7; // rsi
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // r8
  __int64 v12; // r12
  char *v13; // r15
  unsigned __int64 v14; // rdx
  char *v15; // rcx

  v3 = *(_QWORD **)(a1 + 8);
  result = *(char **)a1;
  v7 = ((__int64)v3 - *(_QWORD *)a1) >> 3;
  if ( a2 >= v7 )
  {
    if ( a2 > v7 )
    {
      v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)result) >> 3;
      if ( a2 <= v9 )
      {
        result = (char *)sub_14034CC90(v3, a2 - v7, p__RSI);
        *(_QWORD *)(a1 + 8) = result;
      }
      else
      {
        v10 = 0x1FFFFFFFFFFFFFFFLL;
        if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
        {
          unknown_libname_10();
        }
        v11 = v9 >> 1;
        if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
        {
          v10 = v11 + v9;
          if ( v11 + v9 < a2 )
          {
            v10 = a2;
          }
        }
        v12 = 8 * v10;
        v13 = (char *)sub_14038E0B0(a1, 8 * v10);
        v14 = a2 - v7;
        v15 = &v13[8 * v7];
        if ( *p__RSI )
        {
          for ( ; v14; --v14 )
          {
            *(_QWORD *)v15 = *p__RSI;
            v15 += 8;
          }
        }
        else
        {
          memset(v15, 0, 8 * v14);
        }
        memmove(v13, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
        if ( *(_QWORD *)a1 )
        {
          sub_14039EFB0(a1, *(const void **)a1, (*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
        }
        *(_QWORD *)a1 = v13;
        *(_QWORD *)(a1 + 8) = &v13[8 * a2];
        result = &v13[v12];
        *(_QWORD *)(a1 + 16) = &v13[v12];
      }
    }
  }
  else
  {
    result += 8 * a2;
    *(_QWORD *)(a1 + 8) = result;
  }
  return result;
}

// --- End Function: sub_147215CE0 (0x147215CE0) ---

// --- Function: sub_147217050 (0x147217050) ---
__int64 __fastcall sub_147217050(_QWORD *a1, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v3; // rbp
  unsigned __int64 v4; // rsi
  __int64 i; // r14
  __int64 v13; // rdi
  __int64 v14; // rdi

  v3 = a1[3];
  v4 = v3 & (a3 >> 7);
  _XMM7 = a3 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  for ( i = 0LL; ; v4 = v3 & (v4 + i) )
  {
    _XMM6 = *(_OWORD *)(v4 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
    {
      break;
    }
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      return -1LL;
    }
    i += 16LL;
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v13, _EBX);
    v14 = v3 & (v13 + v4);
    if ( !(unsigned int)sub_1403DFBE0((unsigned __int8 **)(a1[1] + 16 * v14), a2) )
    {
      return v14;
    }
    _EBX &= _EBX - 1;
    if ( !_EBX )
    {
      goto LABEL_5;
    }
  }
}

// --- End Function: sub_147217050 (0x147217050) ---

// --- Function: sub_147217150 (0x147217150) ---
__int64 __fastcall sub_147217150(_QWORD *a1, const char **a2, unsigned __int64 a3)
{
  __int64 v3; // rbp
  unsigned __int64 v4; // rdi
  __int64 i; // r14
  __int64 v13; // rsi
  __int64 v14; // rsi

  v3 = a1[3];
  v4 = v3 & (a3 >> 7);
  _XMM7 = a3 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  for ( i = 0LL; ; v4 = v3 & (v4 + i) )
  {
    _XMM6 = *(_OWORD *)(v4 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
    {
      break;
    }
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      return -1LL;
    }
    i += 16LL;
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v13, _EBX);
    v14 = v3 & (v4 + v13);
    if ( !_stricmp(*(const char **)(a1[1] + 32 * v14), *a2) )
    {
      return v14;
    }
    _EBX &= _EBX - 1;
    if ( !_EBX )
    {
      goto LABEL_5;
    }
  }
}

// --- End Function: sub_147217150 (0x147217150) ---

// --- Function: sub_147217250 (0x147217250) ---
char __fastcall sub_147217250(
        int n4,
        __int64 a2,
        void *Level_data_loss:_Polymorphic_type_changed,
        __int64 Data_type_for_a_polymorphic_was_changed_in_DataForge_and_no_lon,
        __int64 a7,
        int a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 *ThreadLogContextSlot,
        __int64 *arg48,
        __int64 *a11,
        __int64 *a12,
        __int64 *p_s1,
        __int64 *a14)
{
  void *v14; // rsp
  __int64 a8; // [rsp+18h] [rbp-288h]
  __int64 a5[11]; // [rsp+30h] [rbp-270h] BYREF
  __int16 n256; // [rsp+88h] [rbp-218h]
  __int64 n176; // [rsp+90h] [rbp-210h]
  __int64 v20; // [rsp+98h] [rbp-208h]
  const char *p_Unnamed_Text; // [rsp+A0h] [rbp-200h]
  __int64 v22; // [rsp+A8h] [rbp-1F8h]
  __int64 (__fastcall *p_sub_1403E6970)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+B0h] [rbp-1F0h]
  __int64 (__fastcall *p_sub_1403E6380)(__int64, double *, unsigned __int64); // [rsp+B8h] [rbp-1E8h]
  __int64 v25; // [rsp+C0h] [rbp-1E0h]
  bool (__fastcall *p_sub_1403E2A50)(unsigned __int8 *, unsigned __int8 *); // [rsp+C8h] [rbp-1D8h]
  __int64 v27; // [rsp+D0h] [rbp-1D0h]
  __int64 (__fastcall *p_sub_1403E02C0)(const void *); // [rsp+D8h] [rbp-1C8h]
  __int64 (__fastcall *p_sub_1403DFFB0)(); // [rsp+E0h] [rbp-1C0h]
  __int64 v30; // [rsp+E8h] [rbp-1B8h]
  __int16 v31; // [rsp+F0h] [rbp-1B0h]
  __int64 n8; // [rsp+F8h] [rbp-1A8h]
  __int64 v33; // [rsp+100h] [rbp-1A0h]
  const char *p_Unnamed_Text_1; // [rsp+108h] [rbp-198h]
  __int64 v35; // [rsp+110h] [rbp-190h]
  __int64 (__fastcall *p_sub_1403E6970_1)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+118h] [rbp-188h]
  __int64 (__fastcall *p_sub_1403E6380_1)(__int64, double *, unsigned __int64); // [rsp+120h] [rbp-180h]
  __int64 v38; // [rsp+128h] [rbp-178h]
  bool (__fastcall *p_sub_1403E2A50_1)(unsigned __int8 *, unsigned __int8 *); // [rsp+130h] [rbp-170h]
  __int64 v40; // [rsp+138h] [rbp-168h]
  __int64 (__fastcall *p_sub_1403E02C0_1)(const void *); // [rsp+140h] [rbp-160h]
  __int64 (__fastcall *p_sub_1403DFFB0_1)(); // [rsp+148h] [rbp-158h]
  __int64 v43; // [rsp+150h] [rbp-150h]
  __int16 v44; // [rsp+158h] [rbp-148h]
  __int64 n8_1; // [rsp+160h] [rbp-140h]
  __int64 v46; // [rsp+168h] [rbp-138h]
  const char *p_Unnamed_Text_2; // [rsp+170h] [rbp-130h]
  __int64 v48; // [rsp+178h] [rbp-128h]
  __int64 (__fastcall *p_sub_1403E6970_2)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+180h] [rbp-120h]
  __int64 (__fastcall *p_sub_1403E6380_2)(__int64, double *, unsigned __int64); // [rsp+188h] [rbp-118h]
  __int64 v51; // [rsp+190h] [rbp-110h]
  bool (__fastcall *p_sub_1403E2A50_2)(unsigned __int8 *, unsigned __int8 *); // [rsp+198h] [rbp-108h]
  __int64 v53; // [rsp+1A0h] [rbp-100h]
  __int64 (__fastcall *p_sub_1403E02C0_2)(const void *); // [rsp+1A8h] [rbp-F8h]
  __int64 (__fastcall *p_sub_1403DFFB0_2)(); // [rsp+1B0h] [rbp-F0h]
  __int64 v56; // [rsp+1B8h] [rbp-E8h]
  __int16 v57; // [rsp+1C0h] [rbp-E0h]
  __int64 n8_2; // [rsp+1C8h] [rbp-D8h]
  __int64 s1; // [rsp+1D0h] [rbp-D0h]
  const char *p_Unnamed_Text_3; // [rsp+1D8h] [rbp-C8h]
  __int64 v61; // [rsp+1E0h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1403E6970_3)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+1E8h] [rbp-B8h]
  __int64 (__fastcall *p_sub_1403E6380_3)(__int64, double *, unsigned __int64); // [rsp+1F0h] [rbp-B0h]
  __int64 v64; // [rsp+1F8h] [rbp-A8h]
  bool (__fastcall *p_sub_1403E2A50_3)(unsigned __int8 *, unsigned __int8 *); // [rsp+200h] [rbp-A0h]
  __int64 v66; // [rsp+208h] [rbp-98h]
  __int64 (__fastcall *p_sub_1403E02C0_3)(const void *); // [rsp+210h] [rbp-90h]
  __int64 (__fastcall *p_sub_1403DFFB0_3)(); // [rsp+218h] [rbp-88h]
  __int64 v69; // [rsp+220h] [rbp-80h]
  __int16 v70; // [rsp+228h] [rbp-78h]
  __int64 n8_3; // [rsp+230h] [rbp-70h]
  __int64 v72; // [rsp+238h] [rbp-68h]
  const char *p_Unnamed_Text_4; // [rsp+240h] [rbp-60h]
  __int64 v74; // [rsp+248h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6970_4)(_BYTE *, _DWORD *, unsigned __int64, __int64, char); // [rsp+250h] [rbp-50h]
  __int64 (__fastcall *p_sub_1403E6380_4)(__int64, double *, unsigned __int64); // [rsp+258h] [rbp-48h]
  __int64 v77; // [rsp+260h] [rbp-40h]
  bool (__fastcall *p_sub_1403E2A50_4)(unsigned __int8 *, unsigned __int8 *); // [rsp+268h] [rbp-38h]
  __int64 v79; // [rsp+270h] [rbp-30h]
  __int64 (__fastcall *p_sub_1403E02C0_4)(const void *); // [rsp+278h] [rbp-28h]
  __int64 (__fastcall *p_sub_1403DFFB0_4)(); // [rsp+280h] [rbp-20h]
  __int64 v82; // [rsp+288h] [rbp-18h]
  __int16 v83; // [rsp+290h] [rbp-10h]
  __int64 n8_4; // [rsp+298h] [rbp-8h]

  v14 = alloca(624);
  a5[0] = (__int64)ThreadLogContextSlot;
  n256 = 256;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  a5[10] = -1;
  n176 = 176;
  a5[1] = (__int64)"TraceContext";
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)sub_1403E02C0;
  a5[9] = (__int64)sub_1403DFFB0;
  v20 = *arg48;
  p_Unnamed_Text = "Unnamed_Text";
  v31 = 0;
  v22 = 0;
  p_sub_1403E6970 = sub_1403E6970;
  p_sub_1403E6380 = sub_1403E6380;
  v25 = 0;
  p_sub_1403E2A50 = sub_1403E2A50;
  v27 = 0;
  p_sub_1403E02C0 = sub_1403E02C0;
  p_sub_1403DFFB0 = sub_1403DFFB0;
  v30 = -1;
  n8 = 8;
  v33 = *a11;
  p_Unnamed_Text_1 = "Unnamed_Text";
  v44 = 0;
  v35 = 0;
  p_sub_1403E6970_1 = sub_1403E6970;
  p_sub_1403E6380_1 = sub_1403E6380;
  v38 = 0;
  p_sub_1403E2A50_1 = sub_1403E2A50;
  v40 = 0;
  p_sub_1403E02C0_1 = sub_1403E02C0;
  p_sub_1403DFFB0_1 = sub_1403DFFB0;
  v43 = -1;
  n8_1 = 8;
  v46 = *a12;
  p_Unnamed_Text_2 = "Unnamed_Text";
  v57 = 0;
  v48 = 0;
  p_sub_1403E6970_2 = sub_1403E6970;
  p_sub_1403E6380_2 = sub_1403E6380;
  v51 = 0;
  p_sub_1403E2A50_2 = sub_1403E2A50;
  v53 = 0;
  p_sub_1403E02C0_2 = sub_1403E02C0;
  p_sub_1403DFFB0_2 = sub_1403DFFB0;
  v56 = -1;
  n8_2 = 8;
  s1 = *p_s1;
  p_Unnamed_Text_3 = "Unnamed_Text";
  v70 = 0;
  v61 = 0;
  p_sub_1403E6970_3 = sub_1403E6970;
  p_sub_1403E6380_3 = sub_1403E6380;
  v64 = 0;
  p_sub_1403E2A50_3 = sub_1403E2A50;
  v66 = 0;
  p_sub_1403E02C0_3 = sub_1403E02C0;
  p_sub_1403DFFB0_3 = sub_1403DFFB0;
  v69 = -1;
  n8_3 = 8;
  LODWORD(a8) = a6;
  v72 = *a14;
  p_Unnamed_Text_4 = "Unnamed_Text";
  v83 = 0;
  v74 = 0;
  p_sub_1403E6970_4 = sub_1403E6970;
  p_sub_1403E6380_4 = sub_1403E6380;
  v77 = 0;
  p_sub_1403E2A50_4 = sub_1403E2A50;
  v79 = 0;
  p_sub_1403E02C0_4 = sub_1403E02C0;
  p_sub_1403DFFB0_4 = sub_1403DFFB0;
  v82 = -1;
  n8_4 = 8;
  return sub_140302350(
           n4,
           a2,
           Level_data_loss:_Polymorphic_type_changed,
           Data_type_for_a_polymorphic_was_changed_in_DataForge_and_no_lon,
           (__int64)a5,
           6,
           a7,
           a8,
           a9,
           a10);
}

// --- End Function: sub_147217250 (0x147217250) ---

// --- Function: FindOrInsertHashMapEntry (0x147218280) ---
// Finds an entry in a custom hash map based on a key (string object) and derived
// hash, or inserts the key and associated value data if not found.  Uses a hash
// map structure with separate control and data blocks. Probing is accelerated
// using SIMD instructions to compare the low 7 bits of the derived hash against 16
// control bytes at a time.  @param pHashMap Pointer to the hash map structure.
// @param pResultPair Output pointer to a structure receiving the result:
// {pointer_to_control_entry, pointer_to_data_entry, inserted_flag (byte)}. @param
// ppKeyString Pointer to the key (string object) used for comparison via
// `sub_1403DFBE0`. @param derivedHash A hash value derived from the original key.
// @param comparisonContext Context parameter, potentially unused or passed down.
// @param pppKeyString Pointer to the pointer to the key string object, used during
// insertion by `sub_1403577A0`. @param pValueData Pointer to the value data to be
// inserted if the key is not found (copied by `sub_14721B460`). @return Pointer to
// the output result structure `pResultPair`.
_OWORD *__fastcall FindOrInsertHashMapEntry(
        __int64 *pHashMap,
        __int64 pResultPair,
        _QWORD *ppKeyString,
        unsigned __int64 derivedHash,
        int comparisonContext,
        __int64 **pppKeyString,
        __int64 *pValueData)
{
  __int64 capacityMask; // rbp
  __int64 probeOffset; // r14
  unsigned __int64 probeIndex; // rsi
  __int64 *pDataArrayBase; // r15
  __int64 matchBitIndex; // rdi
  __int64 foundEntryIndex; // rdi
  __int64 pFoundDataEntry; // rcx
  _OWORD *pResultPair_1; // rax
  __int64 insertIndex; // rsi
  _QWORD *pNewDataEntry; // rdi
  __int64 pSrcValueData; // rbx
  __int128 resultPair; // [rsp+20h] [rbp-68h]

  capacityMask = pHashMap[3];
  probeOffset = 0;
  probeIndex = capacityMask & (derivedHash >> 7);
  _XMM7 = derivedHash & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    pDataArrayBase = pHashMap + 1;
    _XMM6 = *(_OWORD *)(probeIndex + *pHashMap);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
    {
      break;
    }
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      goto LABEL_9;
    }
    probeOffset += 16;
    probeIndex = capacityMask & (probeOffset + probeIndex);
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&matchBitIndex, _EBX);
    foundEntryIndex = capacityMask & (probeIndex + matchBitIndex);
    if ( !(unsigned int)sub_1403DFBE0((unsigned __int8 **)(*pDataArrayBase + 72 * foundEntryIndex), ppKeyString) )
    {
      break;
    }
    _EBX &= _EBX - 1;
    if ( !_EBX )
    {
      goto LABEL_5;
    }
  }
  if ( foundEntryIndex != -1 )
  {
    *(_QWORD *)&resultPair = foundEntryIndex + *pHashMap;
    pFoundDataEntry = *pDataArrayBase + 72 * foundEntryIndex;
    pResultPair_1 = (_OWORD *)pResultPair;
    *(_BYTE *)(pResultPair + 16) = 0;
    goto LABEL_10;
  }
LABEL_9:
  insertIndex = sub_14726BE60(pHashMap, derivedHash);
  pNewDataEntry = (_QWORD *)(72 * insertIndex + *pDataArrayBase);
  pSrcValueData = *pValueData;
  sub_1403577A0(pNewDataEntry, *pppKeyString);
  sub_14721B460((__int64)(pNewDataEntry + 1), pSrcValueData);
  *(_BYTE *)(insertIndex + *pHashMap) = derivedHash & 0x7F;
  *(_BYTE *)((pHashMap[3] & 0xF) + (pHashMap[3] & (insertIndex - 16)) + *pHashMap + 1) = derivedHash & 0x7F;
  pResultPair_1 = (_OWORD *)pResultPair;
  *(_QWORD *)&resultPair = insertIndex + *pHashMap;
  pFoundDataEntry = 72 * insertIndex + *pDataArrayBase;
  *(_BYTE *)(pResultPair + 16) = 1;
LABEL_10:
  *((_QWORD *)&resultPair + 1) = pFoundDataEntry;
  *pResultPair_1 = resultPair;
  return pResultPair_1;
}

// --- End Function: FindOrInsertHashMapEntry (0x147218280) ---

// --- Function: sub_147218450 (0x147218450) ---
__int64 __fastcall sub_147218450(__int64 *a1, _QWORD *a2)
{
  int v4; // eax
  char *v5; // rbx
  char *v9; // r9
  int v13; // r8d
  bool v14; // zf
  int v15; // edx
  int v16; // eax
  bool v17; // r8
  char v18; // dl
  unsigned __int64 v19[4]; // [rsp+28h] [rbp-20h] BYREF

  v4 = psub_1403339F0(0xFFFFFFFF, (__int64)a2, 16);
  sub_1472187E0(a1, v19, a2, (__PAIR128__((unsigned int)~v4, (unsigned int)~v4) * 0xDE5FB9D2630458E9uLL) >> 64);
  v5 = (char *)v19[0];
  if ( v19[0] == a1[3] + *a1 )
  {
    return 0;
  }
  DestroyStringObject((_QWORD *)(v19[1] + 16));
  --a1[2];
  _XMM2 = xmmword_147F33270;
  __asm { vpcmpeqb xmm1, xmm2, xmmword ptr [rbx] }
  v9 = &v5[-*a1];
  __asm { vpmovmskb eax, xmm1 }
  __asm
  {
    vpcmpeqb xmm1, xmm2, xmmword ptr [rcx+r10]
    vpmovmskb ecx, xmm1
  }
  v17 = 0;
  if ( _ECX && _EAX )
  {
    _BitScanForward((unsigned int *)&v13, _EAX);
    v14 = !_BitScanReverse((unsigned int *)&v15, _ECX << 16);
    v16 = v14 ? 32 : 31 - v15;
    if ( (unsigned int)(v13 + v16) < 0x10 )
    {
      v17 = 1;
    }
  }
  v18 = -2;
  if ( v17 )
  {
    v18 = 0x80;
  }
  *v5 = v18;
  *(_BYTE *)((a1[3] & 0xF) + ((unsigned __int64)(v9 - 16) & a1[3]) + *a1 + 1) = v18;
  a1[6] += v17;
  return 1;
}

// --- End Function: sub_147218450 (0x147218450) ---

// --- Function: sub_147218570 (0x147218570) ---
__int64 __fastcall sub_147218570(_QWORD *a1, const char **a2)
{
  const char *v2; // r9
  unsigned int n40503; // r8d
  char v6; // al
  int v7; // edx
  unsigned __int128 v8; // rax
  char *v9; // rdi
  char *v13; // r9
  int v17; // r8d
  bool v18; // zf
  int v19; // edx
  int v20; // eax
  bool v21; // r8
  char v22; // dl
  _QWORD v23[4]; // [rsp+28h] [rbp-20h] BYREF

  v2 = *a2;
  n40503 = 40503;
  v6 = **a2;
  if ( v6 )
  {
    do
    {
      ++v2;
      v7 = v6 + 32;
      if ( (unsigned __int8)(v6 - 65) > 0x19u )
      {
        v7 = v6;
      }
      n40503 = ((1025 * (n40503 + v7)) >> 6) ^ (1025 * (n40503 + v7));
      v6 = *v2;
    }
    while ( *v2 );
  }
  v8 = 32769 * ((9 * n40503) ^ ((9 * n40503) >> 11)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  sub_140306C90(a1, v23, a2, *((_QWORD *)&v8 + 1) + v8);
  v9 = (char *)v23[0];
  if ( v23[0] == a1[3] + *a1 )
  {
    return 0;
  }
  DestroyStringObject((_QWORD *)v23[1]);
  --a1[2];
  _XMM1 = xmmword_147F33270;
  __asm { vpcmpeqb xmm0, xmm1, xmmword ptr [rdi] }
  v13 = &v9[-*a1];
  __asm { vpmovmskb eax, xmm0 }
  __asm
  {
    vpcmpeqb xmm1, xmm1, xmmword ptr [rcx+r10]
    vpmovmskb ecx, xmm1
  }
  v21 = 0;
  if ( _ECX && _EAX )
  {
    _BitScanForward((unsigned int *)&v17, _EAX);
    v18 = !_BitScanReverse((unsigned int *)&v19, _ECX << 16);
    v20 = v18 ? 32 : 31 - v19;
    if ( (unsigned int)(v17 + v20) < 0x10 )
    {
      v21 = 1;
    }
  }
  v22 = -2;
  if ( v21 )
  {
    v22 = 0x80;
  }
  *v9 = v22;
  *(_BYTE *)((a1[3] & 0xFLL) + ((unsigned __int64)(v13 - 16) & a1[3]) + *a1 + 1) = v22;
  a1[6] += v21;
  return 1;
}

// --- End Function: sub_147218570 (0x147218570) ---

// --- Function: sub_1472186C0 (0x1472186C0) ---
unsigned __int64 *__fastcall sub_1472186C0(__int64 *a1, unsigned __int64 *a2, _QWORD *a3)
{
  int v6; // eax
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r14
  unsigned __int128 v9; // rax
  unsigned __int64 v10; // r9
  __int64 v13; // rcx
  __int64 v17; // rcx
  unsigned __int64 v18; // rcx
  _QWORD *v19; // r8
  unsigned __int64 v22; // rdx

  v6 = psub_1403339F0(0xFFFFFFFF, (__int64)a3, 16);
  v7 = a1[3];
  v8 = 0;
  v9 = (unsigned int)~v6 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = v7 & ((*((_QWORD *)&v9 + 1) + (_QWORD)v9) >> 7);
  _XMM2 = (BYTE8(v9) + (_BYTE)v9) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v13 = *a1;
    _XMM1 = *(_OWORD *)(*a1 + v10);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
    {
      break;
    }
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = v7 + v13;
      return a2;
    }
    v8 += 16LL;
    v10 = v7 & (v8 + v10);
    if ( v8 > v7 )
    {
      __debugbreak();
    }
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v17, _EAX);
    v18 = v7 & (v10 + v17);
    v19 = (_QWORD *)(a1[1] + 24 * v18);
    if ( *v19 == *a3 && v19[1] == a3[1] )
    {
      break;
    }
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v13 = *a1;
      goto LABEL_7;
    }
  }
  v22 = v18 + *a1;
  a2[1] = (unsigned __int64)v19;
  *a2 = v22;
  return a2;
}

// --- End Function: sub_1472186C0 (0x1472186C0) ---

// --- Function: sub_1472187E0 (0x1472187E0) ---
unsigned __int64 *__fastcall sub_1472187E0(__int64 *a1, unsigned __int64 *a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // r10
  unsigned __int64 v11; // rdi
  __int64 v12; // rcx
  __int64 v16; // rcx
  unsigned __int64 v17; // rcx
  _QWORD *v18; // r8
  unsigned __int64 v21; // rdx

  v4 = a1[3];
  v5 = v4 & (a4 >> 7);
  _XMM2 = a4 & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  v11 = 0LL;
  while ( 1 )
  {
    v12 = *a1;
    _XMM1 = *(_OWORD *)(*a1 + v5);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
    {
      break;
    }
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = v4 + v12;
      return a2;
    }
    v11 += 16LL;
    v5 = v4 & (v11 + v5);
    if ( v11 > v4 )
    {
      __debugbreak();
    }
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v16, _EAX);
    v17 = (v16 + v5) & v4;
    v18 = (_QWORD *)(a1[1] + 24 * v17);
    if ( *v18 == *a3 && v18[1] == a3[1] )
    {
      break;
    }
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v12 = *a1;
      goto LABEL_7;
    }
  }
  v21 = v17 + *a1;
  a2[1] = (unsigned __int64)v18;
  *a2 = v21;
  return a2;
}

// --- End Function: sub_1472187E0 (0x1472187E0) ---

// --- Function: sub_1472188D0 (0x1472188D0) ---
_OWORD *__fastcall sub_1472188D0(_QWORD *a1, _OWORD *a2, __int64 *a3)
{
  __int64 v3; // r10
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx
  __int64 i; // rdx
  __int64 v9; // rax
  __int64 v10; // rbp
  unsigned __int128 v11; // rax
  unsigned __int64 v12; // r12
  __int64 v13; // rsi
  __int64 v19; // rdi
  __int64 v20; // rdi
  _OWORD *result; // rax
  __int128 v24; // [rsp+20h] [rbp-68h]

  v3 = *a3;
  v6 = -1;
  do
  {
    ++v6;
  }
  while ( *(_BYTE *)(v3 + v6) );
  v7 = 0;
  for ( i = 0xCBF29CE484222325uLL; v7 < v6; i = 0x100000001B3LL * (v9 ^ i) )
  {
    v9 = *(unsigned __int8 *)(v7 + v3);
    ++v7;
  }
  v10 = a1[3];
  v11 = (unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v12 = 0;
  v13 = v10 & (((_QWORD)v11 + *((_QWORD *)&v11 + 1)) >> 7);
  _XMM7 = ((_BYTE)v11 + BYTE8(v11)) & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v13 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
    {
      break;
    }
LABEL_9:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *(_QWORD *)&v24 = *a1 + a1[3];
      goto LABEL_14;
    }
    v12 += 16LL;
    v13 = v10 & (v12 + v13);
    if ( v12 > a1[3] )
    {
      __debugbreak();
    }
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v19, _EBX);
    v20 = v10 & (v13 + v19);
    if ( !(unsigned int)sub_1403DFBE0((unsigned __int8 **)(16 * v20 + a1[1]), a3) )
    {
      break;
    }
    _EBX &= _EBX - 1;
    if ( !_EBX )
    {
      goto LABEL_9;
    }
  }
  *(_QWORD *)&v24 = v20 + *a1;
  *((_QWORD *)&v24 + 1) = 16 * v20 + a1[1];
LABEL_14:
  result = a2;
  *a2 = v24;
  return result;
}

// --- End Function: sub_1472188D0 (0x1472188D0) ---

// --- Function: sub_147218A50 (0x147218A50) ---
_QWORD *__fastcall sub_147218A50(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // r15
  unsigned __int64 v6; // rsi
  __int64 v14; // rdi
  __int64 v15; // rdi
  _QWORD *v19; // [rsp+90h] [rbp+18h]

  v19 = a3;
  v4 = a1[3];
  v5 = 0LL;
  v6 = v4 & (a4 >> 7);
  _XMM7 = a4 & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v6 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
    {
      break;
    }
LABEL_5:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *a2 = *a1 + a1[3];
      return a2;
    }
    v5 += 16LL;
    v6 = v4 & (v6 + v5);
    if ( v5 > a1[3] )
    {
      __debugbreak();
    }
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v14, _EBX);
    v15 = v4 & (v14 + v6);
    if ( !(unsigned int)sub_1403DFBE0((unsigned __int8 **)(72 * v15 + a1[1]), a3) )
    {
      break;
    }
    a3 = v19;
    _EBX &= _EBX - 1;
    if ( !_EBX )
    {
      goto LABEL_5;
    }
  }
  *a2 = v15 + *a1;
  a2[1] = 72 * v15 + a1[1];
  return a2;
}

// --- End Function: sub_147218A50 (0x147218A50) ---

// --- Function: sub_147218B80 (0x147218B80) ---
__int64 *__fastcall sub_147218B80(__int64 **a1, __int64 *a2, _QWORD *p__RSI)
{
  __int64 *v3; // rdi
  __int64 v7; // r15
  __int64 *v8; // rbx
  __int64 v9; // rbx
  int v11[14]; // [rsp+20h] [rbp-38h] BYREF

  v3 = *a1;
  v7 = sub_14038E0B0((__int64)a1, 0x38u);
  sub_14035F230(v7 + 32, p__RSI);
  *(_QWORD *)(v7 + 48) = p__RSI[2];
  *(_QWORD *)v7 = v3;
  *(_QWORD *)(v7 + 8) = v3;
  *(_QWORD *)(v7 + 16) = v3;
  *(_WORD *)(v7 + 24) = 0;
  v8 = *a1;
  v11[2] = 0;
  v9 = v8[1];
  *(_QWORD *)v11 = v9;
  while ( !*(_BYTE *)(v9 + 25) )
  {
    *(_QWORD *)v11 = v9;
    if ( sub_14037CCB0((_QWORD *)(v7 + 32), (_QWORD *)(v9 + 32)) )
    {
      v9 = *(_QWORD *)v9;
      v11[2] = 1;
    }
    else
    {
      v9 = *(_QWORD *)(v9 + 16);
      v11[2] = 0;
    }
  }
  if ( a1[1] == (__int64 *)0x492492492492492LL )
  {
    unknown_libname_7();
  }
  *a2 = sub_1402DE890(a1, (__int64)v11, v7);
  return a2;
}

// --- End Function: sub_147218B80 (0x147218B80) ---

// --- Function: sub_147218DB0 (0x147218DB0) ---
__int64 __fastcall sub_147218DB0(__int64 *a1, __int64 a2, _QWORD *a3)
{
  int v6; // eax
  __int64 v7; // rdi
  __int64 v8; // r15
  __int64 v9; // rsi
  unsigned __int128 v10; // rax
  unsigned __int64 v11; // r12
  __int64 v12; // r9
  __int64 v18; // r10
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v23; // rcx
  __int64 v24; // rax
  __int128 v25; // xmm0
  char v26; // r12
  __int64 v27; // r8
  __int64 v28; // rcx
  __int64 result; // rax
  __int128 v30; // [rsp+20h] [rbp-38h]

  v6 = psub_1403339F0(0xFFFFFFFF, (__int64)a3, 16LL);
  v7 = a1[3];
  v8 = *a1;
  v9 = 0LL;
  v10 = (unsigned int)~v6 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v11 = *((_QWORD *)&v10 + 1) + v10;
  v12 = v7 & ((*((_QWORD *)&v10 + 1) + (_QWORD)v10) >> 7);
  _XMM2 = ((_BYTE)v10 + BYTE8(v10)) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    _XMM1 = *(_OWORD *)(v8 + v12);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
    {
      break;
    }
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      goto LABEL_11;
    }
    v9 += 16LL;
    v12 = v7 & (v9 + v12);
  }
  v18 = a1[1];
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v19, _EAX);
    v20 = (v19 + v12) & v7;
    if ( *(_QWORD *)(v18 + 24 * v20) == *a3 && *(_QWORD *)(v18 + 24 * v20 + 8) == a3[1] )
    {
      break;
    }
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      goto LABEL_7;
    }
  }
  if ( v20 != -1 )
  {
    *(_BYTE *)(a2 + 16) = 0;
    *(_QWORD *)&v30 = v20 + v8;
    v23 = v18 + 24 * v20;
    goto LABEL_12;
  }
LABEL_11:
  v24 = sub_1422335C0(a1, v11);
  v25 = *(_OWORD *)a3;
  *(_BYTE *)(a2 + 16) = 1;
  v26 = v11 & 0x7F;
  v27 = 24 * v24;
  v28 = a1[1];
  *(_OWORD *)(v27 + v28) = v25;
  *(_QWORD *)(v27 + v28 + 16) = 0LL;
  *(_BYTE *)(v24 + *a1) = v26;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v24 - 16)) + *a1 + 1) = v26;
  *(_QWORD *)&v30 = v24 + *a1;
  v23 = 24 * v24 + a1[1];
LABEL_12:
  result = a2;
  *((_QWORD *)&v30 + 1) = v23;
  *(_OWORD *)a2 = v30;
  return result;
}

// --- End Function: sub_147218DB0 (0x147218DB0) ---

// --- Function: sub_147218F50 (0x147218F50) ---
__int64 __fastcall sub_147218F50(__int64 *a1, __int64 a2, _QWORD *a3)
{
  int v6; // eax
  __int64 v7; // rbx
  __int64 v8; // r15
  __int64 v9; // rdi
  unsigned __int128 v10; // rax
  unsigned __int64 v11; // r12
  __int64 v12; // r9
  __int64 v18; // r10
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v23; // rcx
  __int64 v24; // rbx
  __int64 v25; // rcx
  __int64 v26; // rax
  char v27; // r12
  __int64 result; // rax
  __int128 v29; // [rsp+20h] [rbp-38h]

  v6 = psub_1403339F0(0xFFFFFFFF, (__int64)a3, 16LL);
  v7 = a1[3];
  v8 = *a1;
  v9 = 0LL;
  v10 = (unsigned int)~v6 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v11 = *((_QWORD *)&v10 + 1) + v10;
  v12 = v7 & ((*((_QWORD *)&v10 + 1) + (_QWORD)v10) >> 7);
  _XMM2 = ((_BYTE)v10 + BYTE8(v10)) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    _XMM1 = *(_OWORD *)(v8 + v12);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
    {
      break;
    }
LABEL_7:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      goto LABEL_11;
    }
    v9 += 16LL;
    v12 = v7 & (v9 + v12);
  }
  v18 = a1[1];
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v19, _EAX);
    v20 = (v19 + v12) & v7;
    if ( *(_QWORD *)(v18 + 24 * v20) == *a3 && *(_QWORD *)(v18 + 24 * v20 + 8) == a3[1] )
    {
      break;
    }
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      goto LABEL_7;
    }
  }
  if ( v20 != -1 )
  {
    *(_BYTE *)(a2 + 16) = 0;
    *(_QWORD *)&v29 = v20 + v8;
    v23 = v18 + 24 * v20;
    goto LABEL_12;
  }
LABEL_11:
  v24 = sub_14726BAD0(a1, v11);
  v25 = a1[1];
  *(_OWORD *)(24 * v24 + v25) = *(_OWORD *)a3;
  initializeEmptyStringStructure((_QWORD *)(24 * v24 + v25 + 16));
  v26 = *a1;
  v27 = v11 & 0x7F;
  *(_BYTE *)(a2 + 16) = 1;
  *(_BYTE *)(v24 + v26) = v27;
  *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v24 - 16)) + *a1 + 1) = v27;
  *(_QWORD *)&v29 = v24 + *a1;
  v23 = 24 * v24 + a1[1];
LABEL_12:
  result = a2;
  *((_QWORD *)&v29 + 1) = v23;
  *(_OWORD *)a2 = v29;
  return result;
}

// --- End Function: sub_147218F50 (0x147218F50) ---

// --- Function: sub_1472190F0 (0x1472190F0) ---
__int64 __fastcall sub_1472190F0(__int64 *a1, __int64 a2, const char **a3)
{
  const char *v3; // r11
  unsigned int n40503; // r10d
  char v8; // al
  int v9; // ecx
  unsigned __int128 v10; // rax
  unsigned __int64 v11; // r12
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rbx
  __int64 v16; // rdi
  char v17; // r12
  __int64 v18; // rcx
  __int128 v20; // [rsp+20h] [rbp-28h]

  v3 = *a3;
  n40503 = 40503;
  v8 = **a3;
  if ( v8 )
  {
    do
    {
      ++v3;
      v9 = v8 + 32;
      if ( (unsigned __int8)(v8 - 65) > 0x19u )
      {
        v9 = v8;
      }
      n40503 = ((1025 * (n40503 + v9)) >> 6) ^ (1025 * (n40503 + v9));
      v8 = *v3;
    }
    while ( *v3 );
  }
  v10 = 32769 * ((9 * n40503) ^ ((9 * n40503) >> 11)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v11 = *((_QWORD *)&v10 + 1) + v10;
  v12 = sub_147217150(a1, a3, *((_QWORD *)&v10 + 1) + v10);
  if ( v12 == -1 )
  {
    v13 = sub_14726BD30(a1, v11);
    v14 = 32 * v13;
    v15 = 32 * v13 + a1[1];
    v16 = v13;
    sub_1403577C0((void **)v15, (const void **)a3);
    *(_QWORD *)(v15 + 8) = 0;
    v17 = v11 & 0x7F;
    *(_BYTE *)(a2 + 16) = 1;
    *(_OWORD *)(v15 + 16) = 0;
    *(_BYTE *)(v16 + *a1) = v17;
    *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v16 - 16)) + *a1 + 1) = v17;
    *(_QWORD *)&v20 = v16 + *a1;
    *((_QWORD *)&v20 + 1) = v14 + a1[1];
  }
  else
  {
    v18 = v12 + *a1;
    *(_BYTE *)(a2 + 16) = 0;
    *((_QWORD *)&v20 + 1) = a1[1] + 32 * v12;
    *(_QWORD *)&v20 = v18;
  }
  *(_OWORD *)a2 = v20;
  return a2;
}

// --- End Function: sub_1472190F0 (0x1472190F0) ---

// --- Function: sub_147219260 (0x147219260) ---
__int64 __fastcall sub_147219260(__int64 *a1, __int64 a2, const char **a3)
{
  const char *v3; // r11
  unsigned int n40503; // r10d
  char v8; // al
  int v9; // ecx
  unsigned __int128 v10; // rax
  unsigned __int64 v11; // r12
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rbx
  __int64 v16; // rdi
  char v17; // r12
  __int64 v18; // rcx
  __int128 v20; // [rsp+20h] [rbp-28h]

  v3 = *a3;
  n40503 = 40503;
  v8 = **a3;
  if ( v8 )
  {
    do
    {
      ++v3;
      v9 = v8 + 32;
      if ( (unsigned __int8)(v8 - 65) > 0x19u )
      {
        v9 = v8;
      }
      n40503 = ((1025 * (n40503 + v9)) >> 6) ^ (1025 * (n40503 + v9));
      v8 = *v3;
    }
    while ( *v3 );
  }
  v10 = 32769 * ((9 * n40503) ^ ((9 * n40503) >> 11)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v11 = *((_QWORD *)&v10 + 1) + v10;
  v12 = sub_147217150(a1, a3, *((_QWORD *)&v10 + 1) + v10);
  if ( v12 == -1 )
  {
    v13 = sub_14726BD30(a1, v11);
    v14 = 32 * v13;
    v15 = 32 * v13 + a1[1];
    v16 = v13;
    sub_1403577A0((_QWORD *)v15, (__int64 *)a3);
    *(_QWORD *)(v15 + 8) = 0;
    v17 = v11 & 0x7F;
    *(_BYTE *)(a2 + 16) = 1;
    *(_OWORD *)(v15 + 16) = 0;
    *(_BYTE *)(v16 + *a1) = v17;
    *(_BYTE *)((a1[3] & 0xF) + (a1[3] & (v16 - 16)) + *a1 + 1) = v17;
    *(_QWORD *)&v20 = v16 + *a1;
    *((_QWORD *)&v20 + 1) = v14 + a1[1];
  }
  else
  {
    v18 = v12 + *a1;
    *(_BYTE *)(a2 + 16) = 0;
    *((_QWORD *)&v20 + 1) = a1[1] + 32 * v12;
    *(_QWORD *)&v20 = v18;
  }
  *(_OWORD *)a2 = v20;
  return a2;
}

// --- End Function: sub_147219260 (0x147219260) ---

// --- Function: sub_147219660 (0x147219660) ---
unsigned __int64 *__fastcall sub_147219660(unsigned __int64 *a1, _OWORD **a2)
{
  unsigned __int64 v3; // r14
  _OWORD *v4; // rbx
  int v5; // ecx
  int v6; // r8d
  unsigned int v7; // ebp
  int v8; // eax
  unsigned int v9; // edi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // rax
  _OWORD *v16; // rax
  _OWORD *i; // rdx
  int a4; // [rsp+50h] [rbp+8h] BYREF

  v3 = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
  *a1 = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
  v4 = *a2;
  v5 = *(_DWORD *)(((unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL) - 4);
  v6 = v5 & 0x7FFFFFFF;
  v7 = *((_DWORD *)*a2 - 1) & 0x7FFFFFFF;
  v8 = 16 * v5;
  v9 = (v5 & 0x7FFFFFFF) + v7;
  if ( v5 >= 0 )
  {
    v10 = (unsigned __int64)v8 >> 4;
  }
  else
  {
    LODWORD(v10) = *(_DWORD *)(v3 + v8);
  }
  v11 = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
  if ( v9 != (_DWORD)v10 )
  {
    v12 = 0;
    a4 = v6 + v7;
    if ( v5 )
    {
      v12 = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
    }
    v13 = sub_140448AD0((__int64)a1, v12, v6, &a4, 8u, 0);
    *a1 = v13;
    v11 = v13;
    if ( !v13 )
    {
      *a1 = v3;
      goto LABEL_12;
    }
    LODWORD(v10) = a4;
  }
  v14 = (int)(16 * v9);
  *(_DWORD *)(v11 - 4) = v9;
  if ( 16LL * (int)v10 >= (unsigned __int64)(v14 + 4) )
  {
    *(_DWORD *)(v11 - 4) = v9 | 0x80000000;
    *(_DWORD *)(v14 + v11) = v10;
  }
LABEL_12:
  v15 = *(unsigned int *)(*a1 - 4);
  LODWORD(v15) = v15 & 0x7FFFFFFF;
  v16 = (_OWORD *)(*a1 + 16 * (v15 - v7));
  for ( i = &v16[v7]; v16 != i; ++v4 )
  {
    *v16++ = *v4;
  }
  return a1;
}

// --- End Function: sub_147219660 (0x147219660) ---

// --- Function: sub_14721B420 (0x14721B420) ---
__int64 __fastcall sub_14721B420(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 0;
  result = a1;
  *(_OWORD *)(a1 + 4) = 0LL;
  return result;
}

// --- End Function: sub_14721B420 (0x14721B420) ---

// --- Function: sub_14721B440 (0x14721B440) ---
__int64 __fastcall sub_14721B440(__int64 a1)
{
  *(_QWORD *)a1 = 0LL;
  *(_DWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 12) = 0;
  return a1;
}

// --- End Function: sub_14721B440 (0x14721B440) ---

// --- Function: sub_14721B450 (0x14721B450) ---
_DWORD *__fastcall sub_14721B450(_DWORD *a1)
{
  *a1 = 0;
  a1[7] = 0;
  return a1;
}

// --- End Function: sub_14721B450 (0x14721B450) ---

// --- Function: sub_14721B460 (0x14721B460) ---
// Performs a deep copy of a 64-byte DataCore structure and its associated data.
// Copies the first 56 bytes directly. The QWORD at offset 56, which points to a
// dynamic DWORD array, is handled separately: 1. The destination array pointer
// (`a1 + 56`) is initialized. 2. The destination array is resized to accommodate
// the elements from the source array (`*(a2 + 56)`) potentially combined with
// elements from a default array (`unk_149808B07`). 3. Elements from the source
// array are copied into the destination array.  @param pDestStructData Pointer to
// the destination structure buffer (64 bytes). @param pSrcStructData Pointer to
// the source structure buffer (64 bytes). @return Returns the pointer to the
// destination structure buffer (`pDestStructData`).
__int64 __fastcall sub_14721B460(__int64 pDestStructData, __int64 pSrcStructData)
{
  unsigned __int64 pDefaultArrayData; // rsi
  int *pSrcArrayData; // rbx
  int defaultArraySizeAndFlag; // ecx
  int defaultArraySize; // r8d
  __int64 srcArraySize; // rbp
  int defaultArrayCapacity; // eax
  int newDestArraySize; // edi
  unsigned __int64 newDestArraySize_1; // rdx
  unsigned __int64 pDestArrayData; // r9
  unsigned __int64 pDataForRealloc; // rdx
  unsigned __int64 pDestArrayData_1; // rax
  __int64 newDestArraySizeBytes; // r8
  __int64 pFinalDestArrayData; // rcx
  __int64 finalDestArraySize; // rax
  _DWORD *pDestWritePos; // rax
  _DWORD *pDestWritePos_1; // r8
  int elementToCopy; // ecx
  int newSizeForRealloc; // [rsp+50h] [rbp+8h] BYREF

  *(_QWORD *)pDestStructData = *(_QWORD *)pSrcStructData;
  pDefaultArrayData = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
  *(_QWORD *)(pDestStructData + 8) = *(_QWORD *)(pSrcStructData + 8);
  *(_QWORD *)(pDestStructData + 16) = *(_QWORD *)(pSrcStructData + 16);
  *(_QWORD *)(pDestStructData + 24) = *(_QWORD *)(pSrcStructData + 24);
  *(_BYTE *)(pDestStructData + 32) = *(_BYTE *)(pSrcStructData + 32);
  *(_QWORD *)(pDestStructData + 40) = *(_QWORD *)(pSrcStructData + 40);
  *(_QWORD *)(pDestStructData + 48) = *(_QWORD *)(pSrcStructData + 48);
  *(_QWORD *)(pDestStructData + 56) = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
  pSrcArrayData = *(int **)(pSrcStructData + 56);
  defaultArraySizeAndFlag = *(_DWORD *)(((unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL) - 4);
  defaultArraySize = defaultArraySizeAndFlag & 0x7FFFFFFF;
  srcArraySize = (unsigned int)*(pSrcArrayData - 1);
  LODWORD(srcArraySize) = srcArraySize & 0x7FFFFFFF;
  defaultArrayCapacity = 4 * defaultArraySizeAndFlag;
  newDestArraySize = (defaultArraySizeAndFlag & 0x7FFFFFFF) + srcArraySize;
  if ( defaultArraySizeAndFlag >= 0 )
  {
    newDestArraySize_1 = (unsigned __int64)defaultArrayCapacity >> 2;
  }
  else
  {
    LODWORD(newDestArraySize_1) = *(_DWORD *)(pDefaultArrayData + defaultArrayCapacity);
  }
  pDestArrayData = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
  if ( newDestArraySize != (_DWORD)newDestArraySize_1 )
  {
    pDataForRealloc = 0;
    newSizeForRealloc = defaultArraySize + srcArraySize;
    if ( defaultArraySizeAndFlag )
    {
      pDataForRealloc = (unsigned __int64)&unk_149808B07 & 0xFFFFFFFFFFFFFFFCuLL;
    }
    pDestArrayData_1 = sub_140306F70(pDestStructData + 56, pDataForRealloc, defaultArraySize, &newSizeForRealloc, 4u, 0);
    *(_QWORD *)(pDestStructData + 56) = pDestArrayData_1;
    pDestArrayData = pDestArrayData_1;
    if ( !pDestArrayData_1 )
    {
      *(_QWORD *)(pDestStructData + 56) = pDefaultArrayData;
      goto LABEL_12;
    }
    LODWORD(newDestArraySize_1) = newSizeForRealloc;
  }
  newDestArraySizeBytes = 4 * newDestArraySize;
  *(_DWORD *)(pDestArrayData - 4) = newDestArraySize;
  if ( 4LL * (int)newDestArraySize_1 >= (unsigned __int64)(newDestArraySizeBytes + 4) )
  {
    *(_DWORD *)(pDestArrayData - 4) = newDestArraySize | 0x80000000;
    *(_DWORD *)(newDestArraySizeBytes + pDestArrayData) = newDestArraySize_1;
  }
LABEL_12:
  pFinalDestArrayData = *(_QWORD *)(pDestStructData + 56);
  finalDestArraySize = *(unsigned int *)(pFinalDestArrayData - 4);
  LODWORD(finalDestArraySize) = finalDestArraySize & 0x7FFFFFFF;
  pDestWritePos = (_DWORD *)(pFinalDestArrayData + 4 * (finalDestArraySize - (unsigned int)srcArraySize));
  for ( pDestWritePos_1 = &pDestWritePos[srcArraySize]; pDestWritePos != pDestWritePos_1; ++pDestWritePos )
  {
    elementToCopy = *pSrcArrayData++;
    *pDestWritePos = elementToCopy;
  }
  return pDestStructData;
}

// --- End Function: sub_14721B460 (0x14721B460) ---

// --- Function: sub_14721E880 (0x14721E880) ---
void *__fastcall sub_14721E880(const void **a1)
{
  __int64 v2; // rsi
  char *v3; // rdi
  void *result; // rax

  if ( a1[3] )
  {
    v2 = 0LL;
    v3 = 0LL;
    do
    {
      if ( *((char *)*a1 + (_QWORD)v3) >= 0 )
      {
        DestroyStringObject((char *)a1[1] + v2 + 16);
      }
      ++v3;
      v2 += 24LL;
    }
    while ( v3 != a1[3] );
    free_memory_wrapper(*a1);
    result = &unk_147F34520;
    a1[1] = 0LL;
    a1[2] = 0LL;
    a1[3] = 0LL;
    a1[6] = 0LL;
    *a1 = &unk_147F34520;
  }
  return result;
}

// --- End Function: sub_14721E880 (0x14721E880) ---

// --- Function: sub_14721E910 (0x14721E910) ---
void *__fastcall sub_14721E910(const void **a1)
{
  char *v2; // rsi
  __int64 v3; // r14
  _QWORD *v4; // rdi
  void *result; // rax

  if ( a1[3] )
  {
    v2 = 0LL;
    v3 = 0LL;
    do
    {
      if ( *((char *)*a1 + (_QWORD)v2) >= 0 )
      {
        v4 = (char *)a1[1] + v3;
        sub_1409310A0(v4 + 1, 0, 0);
        DestroyStringObject(v4);
      }
      ++v2;
      v3 += 16LL;
    }
    while ( v2 != a1[3] );
    free_memory_wrapper(*a1);
    result = &unk_147F34520;
    a1[1] = 0LL;
    a1[2] = 0LL;
    a1[3] = 0LL;
    a1[6] = 0LL;
    *a1 = &unk_147F34520;
  }
  return result;
}

// --- End Function: sub_14721E910 (0x14721E910) ---

// --- Function: sub_14721E9B0 (0x14721E9B0) ---
void *__fastcall sub_14721E9B0(const void **a1)
{
  __int64 v2; // rsi
  char *v3; // rdi
  void *result; // rax

  if ( a1[3] )
  {
    v2 = 0LL;
    v3 = 0LL;
    do
    {
      if ( *((char *)*a1 + (_QWORD)v3) >= 0 )
      {
        DestroyStringObject((char *)a1[1] + v2);
      }
      ++v3;
      v2 += 32LL;
    }
    while ( v3 != a1[3] );
    free_memory_wrapper(*a1);
    result = &unk_147F34520;
    a1[1] = 0LL;
    a1[2] = 0LL;
    a1[3] = 0LL;
    a1[6] = 0LL;
    *a1 = &unk_147F34520;
  }
  return result;
}

// --- End Function: sub_14721E9B0 (0x14721E9B0) ---

// --- Function: sub_14721EA30 (0x14721EA30) ---
void *__fastcall sub_14721EA30(const void **a1)
{
  char *v2; // rsi
  __int64 v3; // r14
  _QWORD *v4; // rdi
  void *result; // rax

  if ( a1[3] )
  {
    v2 = 0LL;
    v3 = 0LL;
    do
    {
      if ( *((char *)*a1 + (_QWORD)v2) >= 0 )
      {
        v4 = (char *)a1[1] + v3;
        vector_dword_set_size(v4 + 8, 0, 0);
        DestroyStringObject(v4);
      }
      ++v2;
      v3 += 72LL;
    }
    while ( v2 != a1[3] );
    free_memory_wrapper(*a1);
    result = &unk_147F34520;
    a1[1] = 0LL;
    a1[2] = 0LL;
    a1[3] = 0LL;
    a1[6] = 0LL;
    *a1 = &unk_147F34520;
  }
  return result;
}

// --- End Function: sub_14721EA30 (0x14721EA30) ---

// --- Function: sub_14721EFD0 (0x14721EFD0) ---
void *__fastcall sub_14721EFD0(__int64 a1)
{
  _QWORD *v2; // rsi
  _QWORD *i; // rbx
  __int64 v4; // rax
  const void *ptr_to_free; // rcx
  const void *ptr_to_free_1; // rcx
  const void *ptr_to_free_2; // rcx
  const void *ptr_to_free_3; // rcx
  const void *ptr_to_free_4; // rcx
  const void *ptr_to_free_5; // rcx
  const void *ptr_to_free_6; // rcx
  const void *ptr_to_free_7; // rcx
  const void *ptr_to_free_8; // rcx
  const void *ptr_to_free_9; // rcx
  const void *ptr_to_free_10; // rcx
  const void *ptr_to_free_11; // rcx
  const void *ptr_to_free_12; // rcx
  const void *ptr_to_free_13; // rcx
  const void *ptr_to_free_14; // rcx
  const void *ptr_to_free_15; // rcx
  const void *ptr_to_free_16; // rcx
  const void *ptr_to_free_17; // rcx
  const void *ptr_to_free_18; // rcx
  const void *ptr_to_free_19; // rcx
  const void *ptr_to_free_20; // rcx
  const void *ptr_to_free_21; // rcx
  const void *ptr_to_free_22; // rcx
  const void *ptr_to_free_23; // rcx
  const void *ptr_to_free_24; // rcx
  const void *ptr_to_free_25; // rcx
  const void *ptr_to_free_26; // rcx
  int n10004; // eax
  int n10004_1; // eax
  int n10004_2; // eax
  int n10004_3; // eax
  _QWORD *ptr_to_free_31; // rbx
  const void *ptr_to_free_27; // rcx
  _QWORD *ptr_to_free_32; // rbx
  const void *ptr_to_free_28; // rcx
  _QWORD *ptr_to_free_29; // rcx
  const void *ptr_to_free_30; // rcx

  *(_QWORD *)a1 = &DataCore;
  v2 = *(_QWORD **)(a1 + 384);
  for ( i = *(_QWORD **)(a1 + 376); i != v2; ++i )
  {
    if ( *i )
    {
      (**(void (__fastcall ***)(_QWORD, __int64))*i)(*i, 1);
    }
  }
  v4 = *(_QWORD *)(a1 + 376);
  if ( v4 != *(_QWORD *)(a1 + 384) )
  {
    *(_QWORD *)(a1 + 384) = v4;
  }
  ptr_to_free = *(const void **)(a1 + 504);
  if ( ptr_to_free )
  {
    free_memory_wrapper(ptr_to_free);
    *(_QWORD *)(a1 + 504) = 0;
  }
  ptr_to_free_1 = *(const void **)(a1 + 512);
  if ( ptr_to_free_1 )
  {
    free_memory_wrapper(ptr_to_free_1);
    *(_QWORD *)(a1 + 512) = 0;
  }
  ptr_to_free_2 = *(const void **)(a1 + 520);
  if ( ptr_to_free_2 )
  {
    free_memory_wrapper(ptr_to_free_2);
    *(_QWORD *)(a1 + 520) = 0;
  }
  ptr_to_free_3 = *(const void **)(a1 + 528);
  if ( ptr_to_free_3 )
  {
    free_memory_wrapper(ptr_to_free_3);
    *(_QWORD *)(a1 + 528) = 0;
  }
  ptr_to_free_4 = *(const void **)(a1 + 536);
  if ( ptr_to_free_4 )
  {
    free_memory_wrapper(ptr_to_free_4);
    *(_QWORD *)(a1 + 536) = 0;
  }
  ptr_to_free_5 = *(const void **)(a1 + 544);
  if ( ptr_to_free_5 )
  {
    free_memory_wrapper(ptr_to_free_5);
    *(_QWORD *)(a1 + 544) = 0;
  }
  ptr_to_free_6 = *(const void **)(a1 + 552);
  if ( ptr_to_free_6 )
  {
    free_memory_wrapper(ptr_to_free_6);
    *(_QWORD *)(a1 + 552) = 0;
  }
  ptr_to_free_7 = *(const void **)(a1 + 560);
  if ( ptr_to_free_7 )
  {
    free_memory_wrapper(ptr_to_free_7);
    *(_QWORD *)(a1 + 560) = 0;
  }
  ptr_to_free_8 = *(const void **)(a1 + 568);
  if ( ptr_to_free_8 )
  {
    free_memory_wrapper(ptr_to_free_8);
    *(_QWORD *)(a1 + 568) = 0;
  }
  ptr_to_free_9 = *(const void **)(a1 + 576);
  if ( ptr_to_free_9 )
  {
    free_memory_wrapper(ptr_to_free_9);
    *(_QWORD *)(a1 + 576) = 0;
  }
  ptr_to_free_10 = *(const void **)(a1 + 584);
  if ( ptr_to_free_10 )
  {
    free_memory_wrapper(ptr_to_free_10);
    *(_QWORD *)(a1 + 584) = 0;
  }
  ptr_to_free_11 = *(const void **)(a1 + 592);
  if ( ptr_to_free_11 )
  {
    free_memory_wrapper(ptr_to_free_11);
    *(_QWORD *)(a1 + 592) = 0;
  }
  ptr_to_free_12 = *(const void **)(a1 + 600);
  if ( ptr_to_free_12 )
  {
    free_memory_wrapper(ptr_to_free_12);
    *(_QWORD *)(a1 + 600) = 0;
  }
  ptr_to_free_13 = *(const void **)(a1 + 608);
  if ( ptr_to_free_13 )
  {
    free_memory_wrapper(ptr_to_free_13);
    *(_QWORD *)(a1 + 608) = 0;
  }
  ptr_to_free_14 = *(const void **)(a1 + 616);
  if ( ptr_to_free_14 )
  {
    free_memory_wrapper(ptr_to_free_14);
    *(_QWORD *)(a1 + 616) = 0;
  }
  ptr_to_free_15 = *(const void **)(a1 + 624);
  if ( ptr_to_free_15 )
  {
    free_memory_wrapper(ptr_to_free_15);
    *(_QWORD *)(a1 + 624) = 0;
  }
  ptr_to_free_16 = *(const void **)(a1 + 632);
  if ( ptr_to_free_16 )
  {
    free_memory_wrapper(ptr_to_free_16);
    *(_QWORD *)(a1 + 632) = 0;
  }
  ptr_to_free_17 = *(const void **)(a1 + 640);
  if ( ptr_to_free_17 )
  {
    free_memory_wrapper(ptr_to_free_17);
    *(_QWORD *)(a1 + 640) = 0;
  }
  ptr_to_free_18 = *(const void **)(a1 + 656);
  if ( ptr_to_free_18 )
  {
    free_memory_wrapper(ptr_to_free_18);
    *(_QWORD *)(a1 + 656) = 0;
  }
  ptr_to_free_19 = *(const void **)(a1 + 664);
  if ( ptr_to_free_19 )
  {
    free_memory_wrapper(ptr_to_free_19);
    *(_QWORD *)(a1 + 664) = 0;
  }
  ptr_to_free_20 = *(const void **)(a1 + 648);
  if ( ptr_to_free_20 )
  {
    free_memory_wrapper(ptr_to_free_20);
    *(_QWORD *)(a1 + 648) = 0;
  }
  ptr_to_free_21 = *(const void **)(a1 + 688);
  if ( ptr_to_free_21 )
  {
    free_memory_wrapper(ptr_to_free_21);
    *(_QWORD *)(a1 + 688) = 0;
  }
  ptr_to_free_22 = *(const void **)(a1 + 696);
  if ( ptr_to_free_22 )
  {
    free_memory_wrapper(ptr_to_free_22);
    *(_QWORD *)(a1 + 696) = 0;
  }
  ptr_to_free_23 = *(const void **)(a1 + 704);
  if ( ptr_to_free_23 )
  {
    free_memory_wrapper(ptr_to_free_23);
    *(_QWORD *)(a1 + 704) = 0;
  }
  ptr_to_free_24 = *(const void **)(a1 + 712);
  if ( ptr_to_free_24 )
  {
    free_memory_wrapper(ptr_to_free_24);
    *(_QWORD *)(a1 + 712) = 0;
  }
  ptr_to_free_25 = *(const void **)(a1 + 672);
  if ( ptr_to_free_25 )
  {
    free_memory_wrapper(ptr_to_free_25);
    *(_QWORD *)(a1 + 672) = 0;
  }
  ptr_to_free_26 = *(const void **)(a1 + 680);
  if ( ptr_to_free_26 )
  {
    free_memory_wrapper(ptr_to_free_26);
    *(_QWORD *)(a1 + 680) = 0;
  }
  if ( shutdown(*(int *)(a1 + 476), 2) == -1 )
  {
    n10004 = WSAGetLastError();
    sub_147267CC0(n10004);
  }
  if ( closesocket(*(int *)(a1 + 476)) == -1 )
  {
    n10004_1 = WSAGetLastError();
    sub_147267CC0(n10004_1);
  }
  if ( closesocket(*(int *)(a1 + 472)) == -1 )
  {
    n10004_2 = WSAGetLastError();
    sub_147267CC0(n10004_2);
  }
  if ( closesocket(*(int *)(a1 + 496)) == -1 )
  {
    n10004_3 = WSAGetLastError();
    sub_147267CC0(n10004_3);
  }
  sub_1402AF900((__int64 *)(a1 + 856));
  sub_1402AF900((__int64 *)(a1 + 792));
  ptr_to_free_31 = *(_QWORD **)(*(_QWORD *)(a1 + 776) + 8LL);
  while ( !*((_BYTE *)ptr_to_free_31 + 25) )
  {
    sub_1402A5FE0(a1 + 776, a1 + 776, ptr_to_free_31[2]);
    ptr_to_free_27 = ptr_to_free_31;
    ptr_to_free_31 = (_QWORD *)*ptr_to_free_31;
    free_memory_wrapper(ptr_to_free_27);
  }
  free_memory_wrapper(*(const void **)(a1 + 776));
  ptr_to_free_32 = *(_QWORD **)(*(_QWORD *)(a1 + 760) + 8LL);
  while ( !*((_BYTE *)ptr_to_free_32 + 25) )
  {
    sub_1402A5FE0(a1 + 760, a1 + 760, ptr_to_free_32[2]);
    ptr_to_free_28 = ptr_to_free_32;
    ptr_to_free_32 = (_QWORD *)*ptr_to_free_32;
    free_memory_wrapper(ptr_to_free_28);
  }
  free_memory_wrapper(*(const void **)(a1 + 760));
  DestroyStringObject((_QWORD *)(a1 + 488));
  sub_140B8CA90((__int64 *)(a1 + 448));
  sub_1402B0320((const void **)(a1 + 424));
  ptr_to_free_29 = *(_QWORD **)(a1 + 400);
  if ( ptr_to_free_29 )
  {
    if ( ((*(_QWORD *)(a1 + 416) - (_QWORD)ptr_to_free_29) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)ptr_to_free_29 - *(ptr_to_free_29 - 1) - 8 > 0x1F )
      {
        goto LABEL_84;
      }
      ptr_to_free_29 = (_QWORD *)*(ptr_to_free_29 - 1);
    }
    free_memory_wrapper(ptr_to_free_29);
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 416) = 0;
  }
  ptr_to_free_30 = *(const void **)(a1 + 376);
  if ( ptr_to_free_30 )
  {
    if ( ((*(_QWORD *)(a1 + 392) - (_QWORD)ptr_to_free_30) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_82:
      free_memory_wrapper(ptr_to_free_30);
      *(_QWORD *)(a1 + 376) = 0;
      *(_QWORD *)(a1 + 384) = 0;
      *(_QWORD *)(a1 + 392) = 0;
      goto LABEL_83;
    }
    if ( (unsigned __int64)ptr_to_free_30 - *((_QWORD *)ptr_to_free_30 - 1) - 8 <= 0x1F )
    {
      ptr_to_free_30 = (const void *)*((_QWORD *)ptr_to_free_30 - 1);
      goto LABEL_82;
    }
LABEL_84:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_83:
  sub_140996BE0(a1 + 360, a1 + 360, *(_QWORD *)(*(_QWORD *)(a1 + 360) + 8LL));
  free_memory_wrapper(*(const void **)(a1 + 360));
  sub_14721EA30((const void **)(a1 + 304));
  return sub_14721F750((const void **)a1);
}

// --- End Function: sub_14721EFD0 (0x14721EFD0) ---

// --- Function: sub_14721F750 (0x14721F750) ---
void *__fastcall sub_14721F750(const void **a1)
{
  void *result; // rax

  *a1 = off_1489FE900;
  sub_141F12DE0((__int64)(a1 + 36), (__int64)(a1 + 36), *((_QWORD *)a1[36] + 1));
  free_memory_wrapper(a1[36]);
  sub_14721E910(a1 + 29);
  sub_14721E880(a1 + 22);
  sub_14721E880(a1 + 15);
  result = sub_14721E9B0(a1 + 8);
  if ( a1[4] )
  {
    free_memory_wrapper(a1[1]);
    a1[1] = &unk_147F34520;
    result = 0LL;
    a1[2] = 0LL;
    a1[3] = 0LL;
    a1[4] = 0LL;
    a1[7] = 0LL;
  }
  return result;
}

// --- End Function: sub_14721F750 (0x14721F750) ---

// --- Function: sub_147220700 (0x147220700) ---
__int64 *__fastcall sub_147220700(__int64 **a1, const void **a2)
{
  __int64 *v2; // rdi
  __int64 v5; // rbx
  __int64 *v6; // rdi
  __int64 v7; // rsi
  __int128 v8; // xmm0
  __int128 v10; // [rsp+20h] [rbp-38h] BYREF

  v2 = *a1;
  DWORD2(v10) = 0;
  v5 = v2[1];
  *(_QWORD *)&v10 = v5;
  while ( !*(_BYTE *)(v5 + 25) )
  {
    *(_QWORD *)&v10 = v5;
    if ( (int)sub_1403DFBE0((unsigned __int8 **)(v5 + 32), a2) >= 0 )
    {
      v2 = (__int64 *)v5;
      DWORD2(v10) = 1;
      v5 = *(_QWORD *)v5;
    }
    else
    {
      v5 = *(_QWORD *)(v5 + 16);
      DWORD2(v10) = 0;
    }
  }
  if ( *((_BYTE *)v2 + 25) || (int)sub_1403DFBE0((unsigned __int8 **)a2, v2 + 4) < 0 )
  {
    if ( a1[1] == (__int64 *)0x492492492492492LL )
    {
      unknown_libname_7();
    }
    v6 = *a1;
    v7 = sub_1402A1E30(0x38uLL);
    sub_1403577C0((void **)(v7 + 32), a2);
    v8 = v10;
    *(_QWORD *)(v7 + 40) = 0LL;
    *(_QWORD *)(v7 + 48) = 0LL;
    *(_QWORD *)v7 = v6;
    *(_QWORD *)(v7 + 8) = v6;
    *(_QWORD *)(v7 + 16) = v6;
    *(_WORD *)(v7 + 24) = 0;
    v10 = v8;
    v2 = (__int64 *)sub_1402DE890(a1, (__int64)&v10, v7);
  }
  return v2 + 5;
}

// --- End Function: sub_147220700 (0x147220700) ---

// --- Function: sub_147222A40 (0x147222A40) ---
char *__fastcall sub_147222A40(_QWORD *ptr_to_free, char n3)
{
  __int64 v4; // rdi
  _QWORD *i; // rbx

  if ( (n3 & 2) != 0 )
  {
    v4 = *(ptr_to_free - 1);
    for ( i = &ptr_to_free[2 * v4]; v4; --v4 )
    {
      i -= 2;
      sub_14036D3C0((__int64)i);
    }
    if ( (n3 & 1) != 0 )
    {
      free_memory_wrapper(ptr_to_free - 1);
    }
    return (char *)(ptr_to_free - 1);
  }
  else
  {
    sub_14036D3C0((__int64)ptr_to_free);
    if ( (n3 & 1) != 0 )
    {
      free_memory_wrapper(ptr_to_free);
    }
    return (char *)ptr_to_free;
  }
}

// --- End Function: sub_147222A40 (0x147222A40) ---

// --- Function: sub_147222EB0 (0x147222EB0) ---
const void *__fastcall sub_147222EB0(const void *a1, char a2)
{
  sub_14721EFD0((__int64)a1);
  if ( (a2 & 1) != 0 )
  {
    free_memory_wrapper(a1);
  }
  return a1;
}

// --- End Function: sub_147222EB0 (0x147222EB0) ---

// --- Function: sub_1472269E0 (0x1472269E0) ---
__int64 __fastcall sub_1472269E0(__int64 a1, unsigned int *Src)
{
  unsigned int v2; // r8d
  __int64 n20; // rax

  v2 = 0;
  if ( *((_BYTE *)Src + 8) )
  {
    return 8;
  }
  else
  {
    switch ( *((_BYTE *)Src + 6) )
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 0xB:
      case 0xC:
      case 0xE:
        return LODWORD(qword_1497CC820[*((unsigned __int8 *)Src + 6)]);
      case 0xA:
      case 0xD:
      case 0xF:
        return 4;
      case 0x10:
        if ( !*((_BYTE *)Src + 7) )
        {
          return sub_147226AB0(a1, *(_QWORD *)(a1 + 512) + 16LL * *((unsigned __int16 *)Src + 2));
        }
        if ( *((_BYTE *)Src + 7) == 1 || *((_BYTE *)Src + 7) == 2 )
        {
          return 8;
        }
        if ( *((_BYTE *)Src + 7) != 3 )
        {
          return v2;
        }
        n20 = 20;
        break;
      default:
        return v2;
    }
  }
  return n20;
}

// --- End Function: sub_1472269E0 (0x1472269E0) ---

// --- Function: sub_147226AB0 (0x147226AB0) ---
__int64 __fastcall sub_147226AB0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  unsigned __int64 v3; // rbx
  unsigned int v6; // edi

  v2 = *(_DWORD *)(a2 + 4);
  v3 = 0LL;
  v6 = 0;
  if ( v2 != -1 )
  {
    v6 = sub_147226AB0(a1, *(_QWORD *)(a1 + 512) + 16LL * v2);
  }
  if ( *(_WORD *)(a2 + 8) )
  {
    do
    {
      v6 += sub_1472269E0(a1, *(_QWORD *)(a1 + 520) + 12 * (v3 + *(unsigned __int16 *)(a2 + 10)));
      ++v3;
    }
    while ( v3 < *(unsigned __int16 *)(a2 + 8) );
  }
  return v6;
}

// --- End Function: sub_147226AB0 (0x147226AB0) ---

// --- Function: sub_147229160 (0x147229160) ---
char *__fastcall sub_147229160(
        __int64 a1,
        __int64 _RSI_1,
        __int64 _R15_1,
        __int64 a4,
        __int64 **a5,
        __int64 **a6,
        char **a7)
{
  __int64 _RSI; // rsi
  unsigned __int64 v8; // r12
  __int64 v9; // r13
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r14
  __int64 _R15; // r15
  __int64 n2; // rdx
  __int64 v15; // rdi
  char v16; // cl
  __int64 v17; // rax
  __int64 v18; // rdi
  __int64 v19; // rsi
  __int64 v20; // rbx
  __int64 v21; // rcx
  __int64 v22; // rax
  __int128 v23; // xmm1
  double v24; // xmm0_8
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // r14
  __int64 v28; // r13
  unsigned __int64 v29; // rsi
  __int64 v30; // rax
  bool v31; // cf
  unsigned __int64 n0x6400000; // rax
  _QWORD *v33; // rax
  __int64 v34; // rdi
  unsigned __int64 v35; // rbx
  __int64 v36; // rbx
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *v37; // rdi
  char *result; // rax
  _QWORD *v39; // rbx
  __int64 i_1; // rax
  __int64 v41; // rcx
  __m128i _RSI_1_5; // xmm0
  char **v43; // rbx
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *v44; // rbx
  __int64 v45; // rax
  __int64 v46; // rdi
  __int64 v47; // rsi
  unsigned __int64 n0x6400000_1; // rbx
  void *v49; // rax
  size_t n0x6400000_2; // r8
  __int64 v51; // rax
  unsigned __int64 v52; // rbx
  __int64 v53; // rax
  unsigned __int64 v54; // rbx
  __int64 v55; // rax
  unsigned __int64 v56; // rbx
  __int64 v57; // rax
  __int64 v58; // r14
  __int64 v59; // rsi
  __int64 v60; // rdi
  __int64 v61; // rbx
  __int64 v62; // rax
  __int64 v63; // rdi
  __int64 v64; // rbx
  __int64 v65; // rax
  unsigned __int64 n0x6400000_4; // rsi
  void *v67; // rax
  __int64 v68; // rax
  __int64 v69; // rdi
  __int64 v70; // rsi
  unsigned __int64 v71; // rax
  __int64 v72; // rbx
  unsigned __int64 n0x6400000_3; // rax
  unsigned __int64 v74; // kr10_8
  __int64 v75; // rcx
  __int64 v76; // rax
  __int64 v77; // r14
  __int64 v78; // rsi
  unsigned __int64 j_1; // rdi
  unsigned __int64 _1; // rbx
  __int64 v81; // rax
  __int64 _RSI_4; // rbx
  __int64 v83; // r13
  unsigned __int64 v84; // r15
  __int64 v85; // rsi
  __int64 v86; // r12
  unsigned __int64 *v87; // r14
  unsigned __int64 v88; // rax
  unsigned __int64 v89; // rdx
  _QWORD *v90; // rbx
  __int64 v91; // r8
  __int64 v92; // rcx
  __m128i _RSI_1_1; // xmm0
  signed __int64 epi64; // rdi
  __int64 v95; // rax
  __int64 **v96; // rcx
  __int64 v97; // rsi
  __int64 v98; // r14
  unsigned __int64 v99; // rdx
  __int64 v100; // rcx
  _QWORD *v101; // rbx
  unsigned __int64 v102; // r8
  __int64 v103; // rax
  __m128i _RSI_1_2; // xmm0
  signed __int64 v105; // r15
  unsigned __int64 v106; // rdi
  __int64 v107; // rax
  __int64 v108; // rbx
  __int64 _R15_2; // rbx
  const char *v110; // rbx
  const char *v111; // rax
  const char *v112; // rbx
  const char *v113; // rax
  const char *v114; // rbx
  const char *v115; // rax
  const char *v116; // rbx
  const char *v117; // rax
  const char *v118; // rbx
  const char *v119; // rax
  const char *v120; // rbx
  const char *v121; // rax
  const char *v122; // rbx
  const char *v123; // rax
  const char *v124; // rbx
  const char *v125; // rax
  const char *v126; // rbx
  const char *v127; // rax
  const char *v128; // rbx
  const char *v129; // rax
  const char *v130; // rbx
  const char *v131; // rax
  const char *v132; // rbx
  const char *v133; // rax
  const char *v134; // rbx
  const char *v135; // rax
  const char *v136; // rbx
  const char *v137; // rax
  __int64 v138; // rax
  __int64 _R15_3; // r14
  unsigned __int64 *v140; // rsi
  unsigned __int64 v141; // rdx
  __int64 v142; // rcx
  _QWORD *v143; // rbx
  unsigned __int64 v144; // r8
  __int64 v145; // rax
  __m128i _RSI_1_3; // xmm0
  signed __int64 v147; // rdi
  __int64 v148; // rax
  __int64 **v149; // rcx
  __int64 _RSI_3; // rdi
  unsigned __int64 v151; // rdx
  __int64 v152; // rcx
  _QWORD *v153; // rbx
  unsigned __int64 v154; // r8
  __int64 v155; // rax
  __m128i _RSI_1_4; // xmm0
  __int64 v158; // [rsp+50h] [rbp-B8h] BYREF
  char *v159; // [rsp+58h] [rbp-B0h] BYREF
  __int64 _RSI_1a; // [rsp+60h] [rbp-A8h] BYREF
  __m128i _RSI_1_8; // [rsp+68h] [rbp-A0h] BYREF
  _lambda_17b8e77e04f0039ff1429d79b8271fa1_ *v162; // [rsp+78h] [rbp-90h]
  __int64 v163; // [rsp+80h] [rbp-88h] BYREF
  char *v164; // [rsp+88h] [rbp-80h] BYREF
  __int64 v165; // [rsp+90h] [rbp-78h] BYREF
  char *v166; // [rsp+98h] [rbp-70h] BYREF
  __int64 v167; // [rsp+A0h] [rbp-68h] BYREF
  char *v168; // [rsp+A8h] [rbp-60h] BYREF
  unsigned __int64 v169; // [rsp+B0h] [rbp-58h]
  unsigned __int64 i; // [rsp+B8h] [rbp-50h]
  wchar_t *v171[2]; // [rsp+C0h] [rbp-48h] BYREF
  __int64 v172; // [rsp+D0h] [rbp-38h]
  unsigned __int64 v173; // [rsp+D8h] [rbp-30h]
  __int64 v174; // [rsp+E0h] [rbp-28h] BYREF
  __int64 v175; // [rsp+E8h] [rbp-20h] BYREF
  _QWORD v176[2]; // [rsp+F0h] [rbp-18h] BYREF
  __int64 v177; // [rsp+100h] [rbp-8h] BYREF
  __int64 v178; // [rsp+110h] [rbp+8h] BYREF
  _QWORD v179[3]; // [rsp+120h] [rbp+18h] BYREF
  __int64 _R15_4; // [rsp+198h] [rbp+90h] BYREF
  __int64 v183; // [rsp+1A0h] [rbp+98h]

  v183 = a4;
  _R15_4 = _R15_1;
  _RSI = _RSI_1;
  v8 = 0;
  v9 = a1;
  v10 = *(int *)(a4 + 8);
  v11 = 0;
  v169 = 0;
  v12 = -1;
  _R15 = _R15_1;
  v173 = v10;
  for ( i = 0xCBF29CE484222325uLL; v11 < v173; v169 = v11 )
  {
    n2 = *(unsigned __int8 *)(*(_QWORD *)a4 + 40 * v11 + 25);
    v15 = *(_QWORD *)a4 + 40 * v11;
    v16 = *(_BYTE *)(v15 + 26);
    if ( (_BYTE)n2 == 3 )
    {
      v17 = *(_QWORD *)(v15 + 8);
      v18 = _RSI + v17;
      if ( v16 )
      {
        v19 = v17 + _R15;
        if ( v18 )
        {
          if ( v19 )
          {
            v20 = *(_QWORD *)(v18 + 24);
            if ( v20 )
            {
              sub_14726C030(v17 + _R15, *(_QWORD *)(v18 + 24));
              v21 = 0;
              do
              {
                v22 = *(_QWORD *)(v18 + 16);
                v21 += 24;
                v23 = *(_OWORD *)(v21 + v22 - 24);
                v24 = *(double *)(v21 + v22 - 8);
                v25 = *(_QWORD *)(v19 + 16);
                *(_OWORD *)(v25 + v21 - 24) = v23;
                *(double *)(v25 + v21 - 8) = v24;
                --v20;
              }
              while ( v20 );
            }
          }
        }
LABEL_9:
        _RSI = _RSI_1;
      }
      else
      {
        *(_OWORD *)(v17 + _R15) = *(_OWORD *)v18;
        *(double *)(v17 + _R15 + 16) = *(double *)(v18 + 16);
      }
    }
    else
    {
      if ( (_BYTE)n2 == 2 )
      {
        v26 = *(_QWORD *)(v15 + 8);
        v27 = _RSI + v26;
        if ( v16 )
        {
          v28 = v26 + _R15;
          if ( v27 && v28 )
          {
            v29 = *(_QWORD *)(v27 + 24);
            if ( v29 )
            {
              *(_QWORD *)(v28 + 24) = v29;
              *(_QWORD *)(v28 + 32) = v29;
              v30 = 16 * v29;
              if ( !is_mul_ok(v29, 0x10u) )
              {
                v30 = -1;
              }
              v31 = __CFADD__(v30, 8);
              n0x6400000 = v30 + 8;
              if ( v31 )
              {
                n0x6400000 = -1;
              }
              v33 = (_QWORD *)sub_1402A1E30(n0x6400000);
              if ( v33 )
              {
                v8 = (unsigned __int64)(v33 + 1);
                *v33 = v29;
                v34 = (__int64)(v33 + 1);
                v35 = v29;
                do
                {
                  sub_14035F240(v34);
                  v34 += 16;
                  --v35;
                }
                while ( v35 );
              }
              *(_QWORD *)(v28 + 16) = v8;
              v8 = 0;
              v36 = 0;
              *(_BYTE *)(v28 + 8) = 1;
              do
              {
                sub_14035F230((__int64)v171, (_QWORD *)(v36 + *(_QWORD *)(v27 + 16)));
                v37 = (_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *)(v36 + *(_QWORD *)(v28 + 16));
                if ( v171[0] )
                {
                  sub_14035F230((__int64)&_RSI_1_8, v171);
                  v162 = v37;
                  sub_147218B80(a5, &v174, &_RSI_1_8);
                  sub_14036D3C0((__int64)&_RSI_1_8);
                }
                _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
                  v37,
                  (const wchar_t **)v171);
                sub_14036D3C0((__int64)v171);
                v36 += 16;
                --v29;
              }
              while ( v29 );
              _RSI = _RSI_1;
              _R15 = _R15_1;
            }
            else
            {
              _RSI = _RSI_1;
            }
          }
LABEL_28:
          v9 = a1;
        }
        else
        {
          v44 = (_lambda_17b8e77e04f0039ff1429d79b8271fa1_ *)(v26 + _R15);
          sub_14035F230((__int64)&_RSI_1_8, (_QWORD *)(_RSI + v26));
          v162 = v44;
          sub_147218B80(a5, &v175, &_RSI_1_8);
          sub_14036D3C0((__int64)&_RSI_1_8);
          if ( *(_QWORD *)v27 )
          {
            _lambda_17b8e77e04f0039ff1429d79b8271fa1_::_lambda_17b8e77e04f0039ff1429d79b8271fa1_(
              v44,
              (const wchar_t **)v27);
          }
        }
      }
      else
      {
        if ( v16 )
        {
          switch ( *(_BYTE *)(v15 + 24) )
          {
            case 1:
            case 2:
            case 6:
              v45 = *(_QWORD *)(v15 + 8);
              v46 = v45 + _R15;
              v47 = v45 + _RSI;
              if ( !v47 )
              {
                goto LABEL_9;
              }
              if ( !v46 )
              {
                goto LABEL_9;
              }
              n0x6400000_1 = *(_QWORD *)(v47 + 24);
              if ( !n0x6400000_1 )
              {
                goto LABEL_9;
              }
              *(_QWORD *)(v46 + 24) = n0x6400000_1;
              *(_QWORD *)(v46 + 32) = n0x6400000_1;
              v49 = (void *)sub_1402A1E30(n0x6400000_1);
              n0x6400000_2 = n0x6400000_1;
              goto LABEL_51;
            case 3:
            case 7:
              v51 = *(_QWORD *)(v15 + 8);
              v46 = v51 + _R15;
              v47 = v51 + _RSI;
              if ( !v47 )
              {
                goto LABEL_9;
              }
              if ( !v46 )
              {
                goto LABEL_9;
              }
              v52 = *(_QWORD *)(v47 + 24);
              if ( !v52 )
              {
                goto LABEL_9;
              }
              *(_QWORD *)(v46 + 24) = v52;
              *(_QWORD *)(v46 + 32) = v52;
              v49 = (void *)sub_1402A1E30(saturated_mul(v52, 2u));
              n0x6400000_2 = 2 * v52;
              goto LABEL_51;
            case 4:
            case 8:
            case 0xB:
              v53 = *(_QWORD *)(v15 + 8);
              v46 = v53 + _R15;
              v47 = v53 + _RSI;
              if ( !v47 )
              {
                goto LABEL_9;
              }
              if ( !v46 )
              {
                goto LABEL_9;
              }
              v54 = *(_QWORD *)(v47 + 24);
              if ( !v54 )
              {
                goto LABEL_9;
              }
              *(_QWORD *)(v46 + 24) = v54;
              *(_QWORD *)(v46 + 32) = v54;
              v49 = (void *)sub_1402A1E30(saturated_mul(v54, 4u));
              n0x6400000_2 = 4 * v54;
              goto LABEL_51;
            case 5:
            case 9:
            case 0xC:
              v55 = *(_QWORD *)(v15 + 8);
              v46 = v55 + _R15;
              v47 = v55 + _RSI;
              if ( !v47 )
              {
                goto LABEL_9;
              }
              if ( !v46 )
              {
                goto LABEL_9;
              }
              v56 = *(_QWORD *)(v47 + 24);
              if ( !v56 )
              {
                goto LABEL_9;
              }
              *(_QWORD *)(v46 + 24) = v56;
              *(_QWORD *)(v46 + 32) = v56;
              v49 = (void *)sub_1402A1E30(saturated_mul(v56, 8u));
              n0x6400000_2 = 8 * v56;
LABEL_51:
              *(_QWORD *)(v46 + 16) = v49;
              *(_BYTE *)(v46 + 8) = 1;
              memcpy(v49, *(const void **)(v47 + 16), n0x6400000_2);
              _RSI = _RSI_1;
              goto LABEL_30;
            case 0xA:
              v57 = *(_QWORD *)(v15 + 8);
              v58 = v57 + _RSI;
              v59 = v57 + _R15;
              if ( v58 )
              {
                if ( v59 )
                {
                  v60 = *(_QWORD *)(v58 + 24);
                  if ( v60 )
                  {
                    sub_14726BF90(v57 + _R15, *(_QWORD *)(v58 + 24));
                    v61 = 0;
                    do
                    {
                      sub_140376300(v61 + *(_QWORD *)(v59 + 16), (ULONG_PTR **)(v61 + *(_QWORD *)(v58 + 16)));
                      v61 += 16;
                      --v60;
                    }
                    while ( v60 );
                  }
                }
              }
              break;
            case 0xD:
              v76 = *(_QWORD *)(v15 + 8);
              v77 = v76 + _RSI;
              v78 = v76 + _R15;
              if ( !v77 )
              {
                break;
              }
              if ( !v78 )
              {
                break;
              }
              j_1 = *(_QWORD *)(v77 + 24);
              if ( !j_1 )
              {
                break;
              }
              sub_14726C160(v76 + _R15, *(_QWORD *)(v77 + 24));
              for ( _1 = 0; _1 < j_1; ++_1 )
              {
                copyStringStructure(
                  (void **)(*(_QWORD *)(v78 + 16) + 8 * _1),
                  (const void **)(*(_QWORD *)(v77 + 16) + 8 * _1));
              }
              _RSI = _RSI_1;
              goto LABEL_29;
            case 0xE:
              v68 = *(_QWORD *)(v15 + 8);
              v69 = v68 + _R15;
              v70 = v68 + _RSI;
              if ( !v70 )
              {
                goto LABEL_9;
              }
              if ( !v69 )
              {
                goto LABEL_9;
              }
              v71 = *(int *)(v70 + 24);
              if ( (int)v71 <= 0 )
              {
                goto LABEL_9;
              }
              v72 = *(int *)(v70 + 24);
              *(_QWORD *)(v69 + 24) = v71;
              *(_QWORD *)(v69 + 32) = v71;
              v74 = v71;
              n0x6400000_3 = 16 * v71;
              if ( !is_mul_ok(v74, 0x10u) )
              {
                n0x6400000_3 = -1;
              }
              *(_QWORD *)(v69 + 16) = sub_1402A1E30(n0x6400000_3);
              *(_BYTE *)(v69 + 8) = 1;
              if ( !v72 )
              {
                goto LABEL_9;
              }
              v75 = 0;
              do
              {
                v75 += 16;
                *(_OWORD *)(v75 + *(_QWORD *)(v69 + 16) - 16) = *(_OWORD *)(v75 + *(_QWORD *)(v70 + 16) - 16);
                --v72;
              }
              while ( v72 );
              _RSI = _RSI_1;
              goto LABEL_30;
            case 0xF:
              v62 = *(_QWORD *)(v15 + 8);
              v63 = v62 + _RSI;
              v64 = v62 + _R15;
              if ( !(v62 + _RSI) || !v64 )
              {
                goto LABEL_30;
              }
              v65 = *(_QWORD *)(v63 + 24);
              if ( !v65 )
              {
                goto LABEL_9;
              }
              n0x6400000_4 = v65 * *(_QWORD *)(v63 + 40);
              *(_QWORD *)(v64 + 24) = v65;
              *(_QWORD *)(v64 + 32) = v65;
              v67 = (void *)sub_1402A1E30(n0x6400000_4);
              *(_QWORD *)(v64 + 16) = v67;
              *(_BYTE *)(v64 + 8) = 1;
              memcpy(v67, *(const void **)(v63 + 16), n0x6400000_4);
              _RSI = _RSI_1;
              goto LABEL_30;
            case 0x10:
              v81 = *(_QWORD *)(v15 + 8);
              if ( (_BYTE)n2 == 1 )
              {
                _RSI_4 = v81 + _RSI;
                v83 = v81 + _R15;
                _RSI_1a = v81 + _RSI;
                v84 = *(_QWORD *)(v81 + _RSI + 24);
                v172 = v83;
                if ( !v84 )
                {
                  v9 = a1;
                  _R15 = _R15_1;
                  goto LABEL_30;
                }
                sub_14726C0C0(v83, v84);
                v85 = 0;
                do
                {
                  v86 = *(_QWORD *)(v83 + 16);
                  v87 = (unsigned __int64 *)(v85 + *(_QWORD *)(_RSI_4 + 16));
                  if ( *v87 )
                  {
                    v163 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)*v87 + 8LL))(*v87);
                    sub_140357780(&v164, &v163);
                    v88 = -1;
                    do
                    {
                      ++v88;
                    }
                    while ( v164[v88] );
                    v89 = 0;
                    v90 = (_QWORD *)(a1 + 304);
                    v91 = 0xCBF29CE484222325uLL;
                    if ( v88 )
                    {
                      do
                      {
                        v92 = (unsigned __int8)v164[v89++];
                        v91 = 0x100000001B3LL * (v92 ^ v91);
                      }
                      while ( v89 < v88 );
                      v83 = v172;
                      v90 = (_QWORD *)(a1 + 304);
                    }
                    _RSI_1_1 = *(__m128i *)sub_147218A50(
                                             (_QWORD *)(a1 + 304),
                                             &v177,
                                             &v164,
                                             0xDE5FB9D2630458E9uLL * v91
                                           + (((unsigned __int64)v91 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                    v164 = (char *)&qword_149808ABC + 4;
                    _RSI_1_8 = _RSI_1_1;
                    DestroyStringObject(&v164);
                    if ( _RSI_1_8.m128i_i64[0] != *v90 + v90[3] )
                    {
                      epi64 = _mm_extract_epi64(_RSI_1_8, 1);
                      v95 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(epi64 + 24))(*(_QWORD *)(epi64 + 24), 0);
                      v96 = a6;
                      *(_QWORD *)(v86 + v85) = v95;
                      *(_BYTE *)(v86 + v85 + 8) = 1;
                      *(_QWORD *)sub_14188D0D0(v96, v87) = v95;
                      sub_147229160(a1, *v87, *(_QWORD *)(v86 + v85), epi64 + 8, a5, a6, a7);
                    }
                    _RSI_4 = _RSI_1a;
                  }
                  v85 += 16;
                  --v84;
                }
                while ( v84 );
                _RSI = _RSI_1;
                v8 = 0;
                _R15 = _R15_1;
                goto LABEL_28;
              }
              v97 = v81 + _RSI;
              v98 = v81 + _R15;
              if ( *(int *)(v97 + 24) > 0 )
              {
                v165 = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int64))(**(_QWORD **)(v97 + 16) + 8LL))(
                         *(_QWORD *)(v97 + 16),
                         n2,
                         0x140000000uLL);
                sub_140357780(&v166, &v165);
                v99 = -1;
                do
                {
                  ++v99;
                }
                while ( v166[v99] );
                v100 = 0xCBF29CE484222325uLL;
                v101 = (_QWORD *)(v9 + 304);
                v102 = 0;
                if ( v99 )
                {
                  do
                  {
                    v103 = (unsigned __int8)v166[v102++];
                    v100 = 0x100000001B3LL * (v103 ^ v100);
                  }
                  while ( v102 < v99 );
                  _R15 = _R15_1;
                  v101 = (_QWORD *)(v9 + 304);
                }
                _RSI_1_2 = *(__m128i *)sub_147218A50(
                                         (_QWORD *)(v9 + 304),
                                         &v178,
                                         &v166,
                                         0xDE5FB9D2630458E9uLL * v100
                                       + (((unsigned __int64)v100 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                v166 = (char *)&qword_149808ABC + 4;
                _RSI_1_8 = _RSI_1_2;
                DestroyStringObject(&v166);
                if ( _RSI_1_8.m128i_i64[0] != *v101 + v101[3] )
                {
                  v105 = _mm_extract_epi64(_RSI_1_8, 1);
                  *(_QWORD *)(v98 + 16) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v105 + 24))(
                                            *(_QWORD *)(v105 + 24),
                                            *(_QWORD *)(v97 + 24));
                  v106 = 0;
                  v107 = *(_QWORD *)(v97 + 24);
                  *(_QWORD *)(v98 + 24) = v107;
                  *(_QWORD *)(v98 + 32) = v107;
                  *(_QWORD *)(v98 + 40) = *(_QWORD *)(v97 + 40);
                  for ( *(_BYTE *)(v98 + 8) = 1; v106 < *(_QWORD *)(v97 + 24); ++v106 )
                  {
                    v108 = *(_QWORD *)(v98 + 40) * v106;
                    _RSI_1a = *(_QWORD *)(v97 + 16) + *(_QWORD *)(v97 + 40) * v106;
                    _R15_2 = *(_QWORD *)(v98 + 16) + v108;
                    *(_QWORD *)sub_14188D0D0(a6, (unsigned __int64 *)&_RSI_1a) = _R15_2;
                    sub_147229160(v9, _RSI_1a, _R15_2, v105 + 8, a5, a6, a7);
                  }
                  _RSI = _RSI_1;
                  _R15 = _R15_1;
                  goto LABEL_29;
                }
              }
              break;
            default:
              goto LABEL_30;
          }
        }
        else
        {
          switch ( *(_BYTE *)(v15 + 24) )
          {
            case 1:
              if ( *(_QWORD *)(v15 + 16) != 1 )
              {
                v130 = *(const char **)v15;
                v131 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v131,
                  v130);
              }
              goto LABEL_146;
            case 2:
              if ( *(_QWORD *)(v15 + 16) != 1 )
              {
                v110 = *(const char **)v15;
                v111 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v111,
                  v110);
              }
              goto LABEL_146;
            case 3:
              if ( *(_QWORD *)(v15 + 16) != 2 )
              {
                v112 = *(const char **)v15;
                v113 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v113,
                  v112);
              }
              goto LABEL_146;
            case 4:
              if ( *(_QWORD *)(v15 + 16) != 4 )
              {
                v114 = *(const char **)v15;
                v115 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v115,
                  v114);
              }
              goto LABEL_146;
            case 5:
              if ( *(_QWORD *)(v15 + 16) != 8 )
              {
                v116 = *(const char **)v15;
                v117 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v117,
                  v116);
              }
              goto LABEL_146;
            case 6:
              if ( *(_QWORD *)(v15 + 16) != 1 )
              {
                v118 = *(const char **)v15;
                v119 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v119,
                  v118);
              }
              goto LABEL_146;
            case 7:
              if ( *(_QWORD *)(v15 + 16) != 2 )
              {
                v120 = *(const char **)v15;
                v121 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v121,
                  v120);
              }
              goto LABEL_146;
            case 8:
              if ( *(_QWORD *)(v15 + 16) != 4 )
              {
                v122 = *(const char **)v15;
                v123 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v123,
                  v122);
              }
              goto LABEL_146;
            case 9:
              if ( *(_QWORD *)(v15 + 16) != 8 )
              {
                v124 = *(const char **)v15;
                v125 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v125,
                  v124);
              }
              goto LABEL_146;
            case 0xA:
              if ( *(_QWORD *)(v15 + 16) != 16 )
              {
                v132 = *(const char **)v15;
                v133 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Strings must be const char*",
                  v133,
                  v132);
              }
              sub_140376300(*(_QWORD *)(v15 + 8) + _R15, (ULONG_PTR **)(*(_QWORD *)(v15 + 8) + _RSI));
              goto LABEL_30;
            case 0xB:
              if ( *(_QWORD *)(v15 + 16) != 4 )
              {
                v126 = *(const char **)v15;
                v127 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v127,
                  v126);
              }
              goto LABEL_146;
            case 0xC:
              if ( *(_QWORD *)(v15 + 16) != 8 )
              {
                v128 = *(const char **)v15;
                v129 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                  v129,
                  v128);
              }
              goto LABEL_146;
            case 0xD:
              if ( *(_QWORD *)(v15 + 16) != 8 )
              {
                v136 = *(const char **)v15;
                v137 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Localisation fie"
                  "lds must be type CLocIdentifier",
                  v137,
                  v136);
              }
              copyStringStructure((void **)(*(_QWORD *)(v15 + 8) + _R15), (const void **)(*(_QWORD *)(v15 + 8) + _RSI));
              goto LABEL_30;
            case 0xE:
              if ( *(_QWORD *)(v15 + 16) != 16 )
              {
                v134 = *(const char **)v15;
                v135 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)_RSI + 8LL))(
                                       _RSI,
                                       n2,
                                       0x140000000uLL);
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Size Mismatch. Check registration of DataCore structure '%s' field '%s'. GUIDs must be CryGUID",
                  v135,
                  v134);
              }
              *(_OWORD *)(*(_QWORD *)(v15 + 8) + _R15) = *(_OWORD *)(*(_QWORD *)(v15 + 8) + _RSI);
              goto LABEL_30;
            case 0xF:
LABEL_146:
              memcpy(
                (void *)(*(_QWORD *)(v15 + 8) + _R15),
                (const void *)(*(_QWORD *)(v15 + 8) + _RSI),
                *(_QWORD *)(v15 + 16));
              goto LABEL_30;
            case 0x10:
              v138 = *(_QWORD *)(v15 + 8);
              _R15_3 = v138 + _R15;
              if ( (_BYTE)n2 == 1 )
              {
                v140 = (unsigned __int64 *)(v138 + _RSI);
                if ( *v140 )
                {
                  v167 = (*(__int64 (__fastcall **)(unsigned __int64, __int64, unsigned __int64))(*(_QWORD *)*v140 + 8LL))(
                           *v140,
                           n2,
                           0x140000000uLL);
                  sub_140357780(&v168, &v167);
                  v141 = -1;
                  do
                  {
                    ++v141;
                  }
                  while ( v168[v141] );
                  v142 = 0xCBF29CE484222325uLL;
                  v143 = (_QWORD *)(v9 + 304);
                  v144 = 0;
                  if ( v141 )
                  {
                    do
                    {
                      v145 = (unsigned __int8)v168[v144++];
                      v142 = 0x100000001B3LL * (v145 ^ v142);
                    }
                    while ( v144 < v141 );
                    _R15 = _R15_1;
                    v143 = (_QWORD *)(v9 + 304);
                  }
                  _RSI_1_3 = *(__m128i *)sub_147218A50(
                                           (_QWORD *)(v9 + 304),
                                           v179,
                                           &v168,
                                           0xDE5FB9D2630458E9uLL * v142
                                         + (((unsigned __int64)v142 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                  v168 = (char *)&qword_149808ABC + 4;
                  _RSI_1_8 = _RSI_1_3;
                  DestroyStringObject(&v168);
                  if ( _RSI_1_8.m128i_i64[0] != *v143 + v143[3] )
                  {
                    v147 = _mm_extract_epi64(_RSI_1_8, 1);
                    v148 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v147 + 24))(*(_QWORD *)(v147 + 24), 0);
                    v149 = a6;
                    *(_QWORD *)_R15_3 = v148;
                    *(_BYTE *)(_R15_3 + 8) = 1;
                    *(_QWORD *)sub_14188D0D0(v149, v140) = v148;
                    sub_147229160(v9, *v140, *(_QWORD *)_R15_3, v147 + 8, a5, a6, a7);
                    _RSI = _RSI_1;
                    goto LABEL_29;
                  }
                }
              }
              else
              {
                _RSI_3 = v138 + _RSI;
                v158 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)(v138 + _RSI) + 8LL))(
                         v138 + _RSI,
                         n2,
                         0x140000000uLL);
                sub_140357780(&v159, &v158);
                v151 = -1;
                do
                {
                  ++v151;
                }
                while ( v159[v151] );
                v152 = 0xCBF29CE484222325uLL;
                v153 = (_QWORD *)(v9 + 304);
                v154 = 0;
                if ( v151 )
                {
                  do
                  {
                    v155 = (unsigned __int8)v159[v154++];
                    v152 = 0x100000001B3LL * (v155 ^ v152);
                  }
                  while ( v154 < v151 );
                  _R15 = _R15_1;
                  v153 = (_QWORD *)(v9 + 304);
                }
                _RSI_1_4 = *(__m128i *)sub_147218A50(
                                         (_QWORD *)(v9 + 304),
                                         v176,
                                         &v159,
                                         0xDE5FB9D2630458E9uLL * v152
                                       + (((unsigned __int64)v152 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                v159 = (char *)&qword_149808ABC + 4;
                _RSI_1_8 = _RSI_1_4;
                DestroyStringObject(&v159);
                if ( _RSI_1_8.m128i_i64[0] != *v153 + v153[3] )
                {
                  sub_147229160(v9, _RSI_3, _R15_3, _mm_extract_epi64(_RSI_1_8, 1) + 8, a5, a6, a7);
                  _RSI = _RSI_1;
                  goto LABEL_29;
                }
              }
              break;
            default:
              goto LABEL_30;
          }
        }
        _RSI = _RSI_1;
      }
LABEL_29:
      v12 = -1;
    }
LABEL_30:
    a4 = v183;
    v11 = v169 + 1;
  }
  result = *(char **)(a4 + 24);
  if ( !result )
  {
    goto LABEL_40;
  }
  v158 = *(_QWORD *)(a4 + 24);
  sub_140357780(&v159, &v158);
  do
  {
    ++v12;
  }
  while ( v159[v12] );
  v39 = (_QWORD *)(v9 + 304);
  if ( v12 )
  {
    i_1 = 0xCBF29CE484222325uLL;
    do
    {
      v41 = (unsigned __int8)v159[v8++];
      i_1 = 0x100000001B3LL * (v41 ^ i_1);
    }
    while ( v8 < v12 );
    _R15 = _R15_1;
    v39 = (_QWORD *)(v9 + 304);
    i = i_1;
  }
  _RSI_1_5 = *(__m128i *)sub_147218A50(
                           (_QWORD *)(v9 + 304),
                           v176,
                           &v159,
                           (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 64);
  v159 = (char *)&qword_149808ABC + 4;
  _RSI_1_8 = _RSI_1_5;
  DestroyStringObject(&v159);
  if ( _RSI_1_8.m128i_i64[0] == *v39 + v39[3] )
  {
    result = (char *)sub_1405BD4A0(
                       8u,
                       0,
                       "structure inherited class [%s] is not registered",
                       *(const char **)(v183 + 24));
    a4 = v183;
LABEL_40:
    v43 = a7;
    goto LABEL_41;
  }
  v43 = a7;
  result = sub_147229160(v9, _RSI, _R15, _mm_extract_epi64(_RSI_1_8, 1) + 8, a5, a6, a7);
  a4 = v183;
LABEL_41:
  if ( *(_BYTE *)(a4 + 32) )
  {
    return sub_1402A4690(v43, &_R15_4);
  }
  return result;
}

// --- End Function: sub_147229160 (0x147229160) ---

// --- Function: sub_14722A370 (0x14722A370) ---
__int64 __fastcall sub_14722A370(__int64 rcx0, unsigned __int64 _RSI)
{
  __int64 v4; // rax
  signed __int64 v5; // rax
  __int64 v6; // rsi
  __int64 _R15; // r15
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rdi
  __int64 v11; // rcx
  __int64 v12; // rax
  __int128 v13; // xmm0
  __int64 v14; // rdi
  __int64 *j; // rbx
  __int64 *v16; // rcx
  __int64 v17; // rax
  __int64 **v18; // rax
  __int64 *i; // rax
  __int64 *v20; // rcx
  char *v21; // rdi
  char *v22; // rbx
  __int64 *v23; // rdx
  __int64 v24; // rbx
  const void *v25; // rdx
  const void *v26; // rdx
  _QWORD *v27; // rdi
  const void *v28; // rbx
  __int64 *a6; // [rsp+40h] [rbp-19h] BYREF
  __int64 v31; // [rsp+48h] [rbp-11h]
  __int64 a1[2]; // [rsp+50h] [rbp-9h] BYREF
  _OWORD v33[2]; // [rsp+60h] [rbp+7h] BYREF
  char *a7[2]; // [rsp+80h] [rbp+27h] BYREF
  __int64 v35; // [rsp+90h] [rbp+37h]

  if ( !_RSI )
  {
    return 0;
  }
  v4 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)_RSI + 8LL))(_RSI);
  v5 = DataCore::LookupDCStructDescByName(rcx0, v4);
  v6 = v5;
  if ( !v5 )
  {
    return 0;
  }
  _R15 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v5 + 16))(*(_QWORD *)(v5 + 16), 0);
  if ( !_R15 )
  {
    return 0;
  }
  *(_OWORD *)a1 = 0;
  v8 = sub_14038E0B0((__int64)a1, 0x38u);
  *(_QWORD *)v8 = v8;
  *(_QWORD *)(v8 + 8) = v8;
  *(_QWORD *)(v8 + 16) = v8;
  *(_WORD *)(v8 + 24) = 257;
  a1[0] = v8;
  a6 = 0;
  v31 = 0;
  v9 = sub_14038E0B0((__int64)&a6, 0x30u);
  v10 = v9;
  DWORD2(v33[0]) = 0;
  *(_QWORD *)v9 = v9;
  *(_QWORD *)(v9 + 8) = v9;
  *(_QWORD *)(v9 + 16) = v9;
  *(_WORD *)(v9 + 24) = 257;
  a6 = (__int64 *)v9;
  *(_OWORD *)a7 = 0;
  v35 = 0;
  v11 = *(_QWORD *)(v9 + 8);
  *(_QWORD *)&v33[0] = v11;
  while ( !*(_BYTE *)(v11 + 25) )
  {
    *(_QWORD *)&v33[0] = v11;
    if ( *(_QWORD *)(v11 + 32) >= _RSI )
    {
      v9 = v11;
      DWORD2(v33[0]) = 1;
      v11 = *(_QWORD *)v11;
    }
    else
    {
      v11 = *(_QWORD *)(v11 + 16);
      DWORD2(v33[0]) = 0;
    }
  }
  if ( *(_BYTE *)(v9 + 25) || _RSI < *(_QWORD *)(v9 + 32) )
  {
    if ( v31 == 0x555555555555555LL )
    {
      unknown_libname_7();
    }
    v12 = sub_14038E0B0((__int64)&a6, 0x30u);
    v13 = v33[0];
    *(_QWORD *)(v12 + 32) = _RSI;
    *(_QWORD *)(v12 + 40) = 0;
    *(_QWORD *)v12 = v10;
    *(_QWORD *)(v12 + 8) = v10;
    *(_QWORD *)(v12 + 16) = v10;
    *(_WORD *)(v12 + 24) = 0;
    v33[0] = v13;
    v9 = sub_1402DE890(&a6, (__int64)v33, v12);
  }
  *(_QWORD *)(v9 + 40) = _R15;
  sub_147229160(rcx0, _RSI, _R15, v6, (__int64 **)a1, &a6, a7);
  v14 = a1[0];
  j = *(__int64 **)a1[0];
  while ( j != (__int64 *)v14 )
  {
    sub_14035F230((__int64)v33, j + 4);
    v16 = a6;
    v17 = a6[1];
    while ( !*(_BYTE *)(v17 + 25) )
    {
      if ( *(_QWORD *)(v17 + 32) >= *(_QWORD *)&v33[0] )
      {
        v16 = (__int64 *)v17;
        v17 = *(_QWORD *)v17;
      }
      else
      {
        v17 = *(_QWORD *)(v17 + 16);
      }
    }
    if ( *((_BYTE *)v16 + 25) || *(_QWORD *)&v33[0] < (unsigned __int64)v16[4] )
    {
      v16 = a6;
    }
    if ( v16 != a6 )
    {
      *(_QWORD *)j[6] = v16[5];
    }
    sub_14036D3C0((__int64)v33);
    v18 = (__int64 **)j[2];
    if ( *((_BYTE *)v18 + 25) )
    {
      for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( j != (__int64 *)i[2] )
        {
          break;
        }
        j = i;
      }
      j = i;
    }
    else
    {
      v20 = *v18;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v20 + 25); v20 = (__int64 *)*v20 )
      {
        j = v20;
      }
    }
  }
  v21 = a7[1];
  v22 = a7[0];
  if ( a7[0] != a7[1] )
  {
    do
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)v22 + 40LL))(*(_QWORD *)v22);
      v22 += 8;
    }
    while ( v22 != v21 );
    v22 = a7[0];
  }
  if ( v22 )
  {
    sub_14039EFB0((__int64)a7, v22, (v35 - (_QWORD)v22) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_OWORD *)a7 = 0;
    v35 = 0;
  }
  v23 = a6;
  v24 = a6[1];
  if ( !*(_BYTE *)(v24 + 25) )
  {
    do
    {
      sub_140345820((__int64)&a6, (__int64)&a6, *(_QWORD *)(v24 + 16));
      v25 = (const void *)v24;
      v24 = *(_QWORD *)v24;
      sub_14039EFB0((__int64)&a6, v25, 0x30u);
    }
    while ( !*(_BYTE *)(v24 + 25) );
    v23 = a6;
  }
  sub_14039EFB0((__int64)&a6, v23, 0x30u);
  v26 = (const void *)a1[0];
  v27 = *(_QWORD **)(a1[0] + 8);
  if ( !*((_BYTE *)v27 + 25) )
  {
    do
    {
      sub_147214DC0((__int64)a1, (__int64)a1, v27[2]);
      v28 = v27;
      v27 = (_QWORD *)*v27;
      sub_14036D3C0((__int64)v28 + 32);
      sub_14039EFB0((__int64)a1, v28, 0x38u);
    }
    while ( !*((_BYTE *)v27 + 25) );
    v26 = (const void *)a1[0];
  }
  sub_14039EFB0((__int64)a1, v26, 0x38u);
  return _R15;
}

// --- End Function: sub_14722A370 (0x14722A370) ---

// --- Function: sub_14722A720 (0x14722A720) ---
void __fastcall sub_14722A720(__int64 rcx0, _QWORD *a2, __int64 *a3)
{
  unsigned __int64 v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rax
  unsigned __int64 v9; // rbx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 _RSI; // rcx
  __int64 v13; // rax
  signed __int64 v14; // rax
  __int64 v15; // rsi
  __int64 _R15_1; // rax
  __int64 *v17; // rdi
  __int64 _R15; // r14
  __int64 v19; // rax
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rdi
  __int64 *j; // rbx
  __int64 *v24; // rcx
  __int64 v25; // rax
  __int64 **v26; // rax
  __int64 *i; // rax
  __int64 *v28; // rcx
  char *v29; // rdi
  char *v30; // rbx
  __int64 v31; // rbx
  const void *v32; // rdx
  const void *v33; // rdx
  _QWORD *v34; // rdi
  const void *v35; // rbx
  __int64 *a6; // [rsp+40h] [rbp-29h] BYREF
  __int64 v37; // [rsp+48h] [rbp-21h]
  __int64 a1[2]; // [rsp+50h] [rbp-19h] BYREF
  unsigned __int64 v39; // [rsp+60h] [rbp-9h] BYREF
  int v40; // [rsp+68h] [rbp-1h]
  char *a7[2]; // [rsp+80h] [rbp+17h] BYREF
  __int64 v42; // [rsp+90h] [rbp+27h]
  __int64 _RSI_1; // [rsp+E0h] [rbp+77h] BYREF

  v6 = (a3[1] - *a3) >> 3;
  _RSI_1 = 0;
  sub_147215CE0((__int64)a2, v6, &_RSI_1);
  *(_OWORD *)a1 = 0;
  v7 = sub_14038E0B0((__int64)a1, 0x38u);
  *(_QWORD *)v7 = v7;
  *(_QWORD *)(v7 + 8) = v7;
  *(_QWORD *)(v7 + 16) = v7;
  *(_WORD *)(v7 + 24) = 257;
  a1[0] = v7;
  a6 = 0;
  v37 = 0;
  v8 = sub_14038E0B0((__int64)&a6, 0x30u);
  v9 = 0;
  *(_QWORD *)v8 = v8;
  *(_QWORD *)(v8 + 8) = v8;
  *(_QWORD *)(v8 + 16) = v8;
  *(_WORD *)(v8 + 24) = 257;
  v10 = a3[1];
  v11 = *a3;
  a6 = (__int64 *)v8;
  v42 = 0;
  *(_OWORD *)a7 = 0;
  if ( (v10 - v11) >> 3 )
  {
    do
    {
      if ( (v10 - v11) >> 3 <= v9 )
      {
        __debugbreak();
      }
      _RSI = *(_QWORD *)(*a3 + 8 * v9);
      _RSI_1 = _RSI;
      if ( _RSI )
      {
        v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)_RSI + 8LL))(_RSI);
        v14 = DataCore::LookupDCStructDescByName(rcx0, v13);
        v15 = v14;
        if ( v14 )
        {
          _R15_1 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v14 + 16))(*(_QWORD *)(v14 + 16), 0);
          v17 = a6;
          _R15 = _R15_1;
          v40 = 0;
          v19 = (__int64)a6;
          v20 = a6[1];
          v39 = v20;
          while ( !*(_BYTE *)(v20 + 25) )
          {
            v39 = v20;
            if ( *(_QWORD *)(v20 + 32) >= (unsigned __int64)_RSI_1 )
            {
              v19 = v20;
              v40 = 1;
              v20 = *(_QWORD *)v20;
            }
            else
            {
              v20 = *(_QWORD *)(v20 + 16);
              v40 = 0;
            }
          }
          if ( *(_BYTE *)(v19 + 25) || (unsigned __int64)_RSI_1 < *(_QWORD *)(v19 + 32) )
          {
            if ( v37 == 0x555555555555555LL )
            {
              unknown_libname_7();
            }
            v21 = sub_14038E0B0((__int64)&a6, 0x30u);
            *(_QWORD *)(v21 + 32) = _RSI_1;
            *(_QWORD *)(v21 + 40) = 0;
            *(_QWORD *)v21 = v17;
            *(_QWORD *)(v21 + 8) = v17;
            *(_QWORD *)(v21 + 16) = v17;
            *(_WORD *)(v21 + 24) = 0;
            v19 = sub_1402DE890(&a6, (__int64)&v39, v21);
          }
          *(_QWORD *)(v19 + 40) = _R15;
          sub_147229160(rcx0, _RSI_1, _R15, v15, (__int64 **)a1, &a6, a7);
          if ( (__int64)(a2[1] - *a2) >> 3 <= v9 )
          {
            __debugbreak();
          }
          *(_QWORD *)(*a2 + 8 * v9) = _R15;
        }
      }
      v10 = a3[1];
      ++v9;
      v11 = *a3;
    }
    while ( v9 < (v10 - *a3) >> 3 );
  }
  v22 = a1[0];
  j = *(__int64 **)a1[0];
  while ( j != (__int64 *)v22 )
  {
    sub_14035F230((__int64)&v39, j + 4);
    v24 = a6;
    v25 = a6[1];
    while ( !*(_BYTE *)(v25 + 25) )
    {
      if ( *(_QWORD *)(v25 + 32) >= v39 )
      {
        v24 = (__int64 *)v25;
        v25 = *(_QWORD *)v25;
      }
      else
      {
        v25 = *(_QWORD *)(v25 + 16);
      }
    }
    if ( *((_BYTE *)v24 + 25) || v39 < v24[4] )
    {
      v24 = a6;
    }
    if ( v24 != a6 )
    {
      *(_QWORD *)j[6] = v24[5];
    }
    sub_14036D3C0((__int64)&v39);
    v26 = (__int64 **)j[2];
    if ( *((_BYTE *)v26 + 25) )
    {
      for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( j != (__int64 *)i[2] )
        {
          break;
        }
        j = i;
      }
      j = i;
    }
    else
    {
      v28 = *v26;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v28 + 25); v28 = (__int64 *)*v28 )
      {
        j = v28;
      }
    }
  }
  v29 = a7[1];
  v30 = a7[0];
  if ( a7[0] != a7[1] )
  {
    do
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)v30 + 40LL))(*(_QWORD *)v30);
      v30 += 8;
    }
    while ( v30 != v29 );
    v30 = a7[0];
  }
  if ( v30 )
  {
    sub_14039EFB0((__int64)a7, v30, (v42 - (_QWORD)v30) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_OWORD *)a7 = 0;
    v42 = 0;
  }
  v31 = a6[1];
  while ( !*(_BYTE *)(v31 + 25) )
  {
    sub_140345820((__int64)&a6, (__int64)&a6, *(_QWORD *)(v31 + 16));
    v32 = (const void *)v31;
    v31 = *(_QWORD *)v31;
    sub_14039EFB0((__int64)&a6, v32, 0x30u);
  }
  sub_14039EFB0((__int64)&a6, a6, 0x30u);
  v33 = (const void *)a1[0];
  v34 = *(_QWORD **)(a1[0] + 8);
  if ( !*((_BYTE *)v34 + 25) )
  {
    do
    {
      sub_147214DC0((__int64)a1, (__int64)a1, v34[2]);
      v35 = v34;
      v34 = (_QWORD *)*v34;
      sub_14036D3C0((__int64)v35 + 32);
      sub_14039EFB0((__int64)a1, v35, 0x38u);
    }
    while ( !*((_BYTE *)v34 + 25) );
    v33 = (const void *)a1[0];
  }
  sub_14039EFB0((__int64)a1, v33, 0x38u);
}

// --- End Function: sub_14722A720 (0x14722A720) ---

// --- Function: sub_1472371D0 (0x1472371D0) ---
signed __int64 __fastcall sub_1472371D0(_QWORD *pDataCore, __int64 a2, unsigned __int8 n16, char n2)
{
  signed __int64 result; // rax
  const void *ptr_to_free_1; // rcx
  __int64 v8; // rax
  __int64 v9; // rsi
  const void *ptr_to_free; // r14
  __int64 j; // rdi
  __int64 v12; // rax
  __int64 v13; // rsi
  __int64 i; // rdi
  __int64 v15; // rax

  result = n16 - 1;
  switch ( n16 )
  {
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
    case 0xBu:
    case 0xCu:
    case 0xEu:
      return sub_14726A140(a2);
    case 0xAu:
      return sub_14726A180(a2);
    case 0xDu:
      return sub_14726A210(a2);
    case 0xFu:
      if ( *(_QWORD *)(a2 + 40) == 1 )
      {
        return sub_14726A140(a2);
      }
      result = *(_QWORD *)(a2 + 40) - 2LL;
      if ( *(_QWORD *)(a2 + 40) == 2 || *(_QWORD *)(a2 + 40) == 4 )
      {
        return sub_14726A140(a2);
      }
      return result;
    case 0x10u:
      switch ( n2 )
      {
        case 0:
          if ( *(_BYTE *)(a2 + 8) )
          {
            v15 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 16) + 8LL))(*(_QWORD *)(a2 + 16));
            result = DataCore::LookupDCStructDescByName((__int64)pDataCore, v15);
            if ( result )
            {
              (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(result + 16) + 8LL))(
                *(_QWORD *)(result + 16),
                *(_QWORD *)(a2 + 16));
              result = 0;
              *(_QWORD *)(a2 + 16) = 0;
              *(_QWORD *)(a2 + 24) = 0;
              *(_QWORD *)(a2 + 32) = 0;
              *(_BYTE *)(a2 + 8) = 0;
            }
          }
          return result;
        case 1:
          if ( !*(_BYTE *)(a2 + 8) )
          {
            return result;
          }
          v12 = *(_QWORD *)(a2 + 16);
          if ( !v12 )
          {
            goto LABEL_25;
          }
          v13 = *(_QWORD *)(v12 - 8);
          ptr_to_free = (const void *)(v12 - 8);
          for ( i = v12 + 16 * v13; v13; --v13 )
          {
            i -= 16;
            sub_14036D3C0(i);
          }
LABEL_24:
          free_memory_wrapper(ptr_to_free);
          goto LABEL_25;
        case 2:
          if ( !*(_BYTE *)(a2 + 8) )
          {
            return result;
          }
          v8 = *(_QWORD *)(a2 + 16);
          if ( !v8 )
          {
            goto LABEL_25;
          }
          v9 = *(_QWORD *)(v8 - 8);
          ptr_to_free = (const void *)(v8 - 8);
          for ( j = v8 + 16 * v9; v9; --v9 )
          {
            j -= 16;
            sub_14036D3C0(j);
          }
          goto LABEL_24;
        case 3:
          ptr_to_free_1 = *(const void **)(a2 + 16);
          if ( ptr_to_free_1 )
          {
            if ( *(_BYTE *)(a2 + 8) )
            {
              free_memory_wrapper(ptr_to_free_1);
LABEL_25:
              result = 0;
              *(_QWORD *)(a2 + 32) = 0;
              *(_QWORD *)(a2 + 24) = 0;
              *(_QWORD *)(a2 + 16) = 0;
              *(_BYTE *)(a2 + 8) = 0;
            }
          }
          break;
      }
      return result;
    default:
      return (unsigned int)n16 - 1;
  }
}

// --- End Function: sub_1472371D0 (0x1472371D0) ---

// --- Function: sub_1472390E0 (0x1472390E0) ---
bool __fastcall sub_1472390E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, const char *))(*(_QWORD *)qword_14981D238
                                                                                              + 336LL))(
           qword_14981D238,
           a1,
           a2,
           a3,
           a4,
           "FReadRawWithLog") == a3;
}

// --- End Function: sub_1472390E0 (0x1472390E0) ---

// --- Function: sub_14723A830 (0x14723A830) ---
void __fastcall sub_14723A830(_QWORD *rcx0, unsigned int *a2, __int64 a3, __int64 a4)
{
  __int64 v7; // rbp
  const char *v8; // rbp
  __int64 *v9; // rdi
  unsigned __int8 **v10; // rbx
  unsigned __int64 v11; // rcx
  __int64 **v12; // r12
  unsigned int *v13; // r13
  unsigned int *v14; // rdi
  __int64 v15; // r14
  __int64 v16; // rbp
  char *v17; // rbx
  _QWORD *v18; // r9
  unsigned __int64 v19; // rcx
  __int64 v20; // r14
  __int64 v21; // rbp
  char *v22; // rbx
  int v23; // r14d
  __int64 v24; // rbp
  const char *v25; // rbp
  __int64 *v26; // rdi
  unsigned __int8 **v27; // rbx
  const char *v28; // [rsp+20h] [rbp-58h] BYREF
  unsigned __int8 *v29; // [rsp+28h] [rbp-50h] BYREF
  const char *v30; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int8 *v31; // [rsp+38h] [rbp-40h] BYREF

  if ( a2 )
  {
    if ( *(_DWORD *)(rcx0[63] + 4LL) >= 6u )
    {
      v7 = rcx0[85];
    }
    else
    {
      v7 = rcx0[84];
    }
    v8 = (const char *)(*a2 + v7);
    v28 = v8;
    sub_140357780(&v29, &v28);
    v9 = (__int64 *)rcx0[36];
    v10 = (unsigned __int8 **)v9[1];
    while ( !*((_BYTE *)v10 + 25) )
    {
      if ( (int)sub_1403DFBE0(v10 + 4, &v29) >= 0 )
      {
        v9 = (__int64 *)v10;
        v10 = (unsigned __int8 **)*v10;
      }
      else
      {
        v10 = (unsigned __int8 **)v10[2];
      }
    }
    if ( *((_BYTE *)v9 + 25) || (int)sub_1403DFBE0(&v29, v9 + 4) < 0 )
    {
      v9 = (__int64 *)rcx0[36];
    }
    v29 = (unsigned __int8 *)&qword_149808ABC + 4;
    DestroyStringObject(&v29);
    if ( v9 == (__int64 *)rcx0[36] )
    {
      sub_1405BD4A0(8u, 2u, "[DataCore] Cannot get enum enumerable \"%s\" does not exist.", v8);
    }
    else
    {
      v11 = *((unsigned __int16 *)a2 + 2);
      v12 = (__int64 **)v9[6];
      v13 = a2 + 1;
      v14 = a2 + 1;
      if ( v11 > (__int64)(*(_QWORD *)(a3 + 16) - *(_QWORD *)a3) >> 3 )
      {
        v15 = 8 * v11;
        v16 = (__int64)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3;
        v17 = (char *)sub_14038E0B0(a3, 8 * v11);
        memmove(v17, *(const void **)a3, *(_QWORD *)(a3 + 8) - *(_QWORD *)a3);
        v18 = (_QWORD *)a3;
        if ( *(_QWORD *)a3 )
        {
          sub_14039EFB0(a3, *(const void **)a3, (*(_QWORD *)(a3 + 16) - *(_QWORD *)a3) & 0xFFFFFFFFFFFFFFF8uLL);
          v18 = (_QWORD *)a3;
          v14 = a2 + 1;
        }
        *v18 = v17;
        v18[1] = &v17[8 * v16];
        v18[2] = &v17[v15];
      }
      v19 = *(unsigned __int16 *)v13;
      if ( v19 > (__int64)(*(_QWORD *)(a4 + 16) - *(_QWORD *)a4) >> 2 )
      {
        v20 = 4 * v19;
        v21 = (__int64)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2;
        v22 = (char *)sub_14038E0B0(a4, 4 * v19);
        memmove(v22, *(const void **)a4, *(_QWORD *)(a4 + 8) - *(_QWORD *)a4);
        if ( *(_QWORD *)a4 )
        {
          sub_14039EFB0(a4, *(const void **)a4, (*(_QWORD *)(a4 + 16) - *(_QWORD *)a4) & 0xFFFFFFFFFFFFFFFCuLL);
        }
        *(_QWORD *)a4 = v22;
        *(_QWORD *)(a4 + 8) = &v22[4 * v21];
        v13 = v14;
        *(_QWORD *)(a4 + 16) = &v22[v20];
      }
      v23 = 0;
      if ( *(_WORD *)v13 )
      {
        do
        {
          if ( *(_DWORD *)(rcx0[63] + 4LL) >= 6u )
          {
            v24 = rcx0[85];
          }
          else
          {
            v24 = rcx0[84];
          }
          v25 = (const char *)(*(unsigned int *)(rcx0[89] + 4LL * (v23 + *((unsigned __int16 *)a2 + 3))) + v24);
          v28 = v25;
          sub_1402A4690((char **)a3, &v28);
          v30 = v25;
          sub_140357780(&v31, &v30);
          v26 = *v12;
          v27 = (unsigned __int8 **)(*v12)[1];
          while ( !*((_BYTE *)v27 + 25) )
          {
            if ( (int)sub_1403DFBE0(v27 + 4, &v31) >= 0 )
            {
              v26 = (__int64 *)v27;
              v27 = (unsigned __int8 **)*v27;
            }
            else
            {
              v27 = (unsigned __int8 **)v27[2];
            }
          }
          if ( *((_BYTE *)v26 + 25) || (int)sub_1403DFBE0(&v31, v26 + 4) < 0 )
          {
            v26 = *v12;
          }
          v31 = (unsigned __int8 *)&qword_149808ABC + 4;
          DestroyStringObject(&v31);
          if ( v26 == *v12 )
          {
            LODWORD(v28) = -1;
            sub_140892F20(a4, &v28);
            sub_1405BD4A0(8u, 2u, "[DataCore] Cannot get enum value \"%s\" does not exist.", v25);
          }
          else
          {
            sub_140341580((char **)a4, (_DWORD *)v26 + 10);
          }
          ++v23;
        }
        while ( v23 < *(unsigned __int16 *)v13 );
      }
    }
  }
}

// --- End Function: sub_14723A830 (0x14723A830) ---

// --- Function: sub_14723ABD0 (0x14723ABD0) ---
__int64 __fastcall sub_14723ABD0(_QWORD *pDataCore, const char *String1, const char *String1_2)
{
  __int64 *v6; // rbx
  const char *String1_1; // [rsp+20h] [rbp-18h] BYREF
  unsigned __int8 *v9[2]; // [rsp+28h] [rbp-10h] BYREF
  unsigned __int8 **v10; // [rsp+48h] [rbp+10h] BYREF

  if ( String1 && *String1 )
  {
    String1_1 = String1;
    sub_140357780(v9, &String1_1);
    sub_1404FAD80((unsigned __int8 ***)pDataCore + 36, &v10, v9);
    v9[0] = (unsigned __int8 *)&qword_149808ABC + 4;
    DestroyStringObject(v9);
    if ( v10 == (unsigned __int8 **)pDataCore[36] )
    {
      sub_1405BD4A0(8u, 2u, "[DataCore] Cannot get enum enumerable \"%s\" does not exist.", String1);
    }
    else
    {
      v6 = (__int64 *)v10[6];
      String1_1 = String1_2;
      sub_140357780(v9, &String1_1);
      std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::find(
        v6,
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&v10,
        v9);
      v9[0] = (unsigned __int8 *)&qword_149808ABC + 4;
      DestroyStringObject(v9);
      if ( v10 != (unsigned __int8 **)*v6 )
      {
        return *((unsigned int *)v10 + 10);
      }
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_14723ABD0 (0x14723ABD0) ---

// --- Function: sub_14723CB40 (0x14723CB40) ---
const ULONG_PTR *__fastcall sub_14723CB40(__int64 a1, _QWORD *a2)
{
  int v4; // eax
  __m128i *v5; // rax
  unsigned __int64 v7[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = psub_1403339F0(0xFFFFFFFF, (__int64)a2, 16LL);
  v5 = (__m128i *)sub_1472187E0(
                    (__int64 *)(a1 + 176),
                    v7,
                    a2,
                    (__PAIR128__((unsigned int)~v4, (unsigned int)~v4) * 0xDE5FB9D2630458E9uLL) >> 64);
  if ( v5->m128i_i64[0] == *(_QWORD *)(a1 + 176) + *(_QWORD *)(a1 + 200) )
  {
    return &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  }
  else
  {
    return *(const ULONG_PTR **)(_mm_extract_epi64(*v5, 1) + 16);
  }
}

// --- End Function: sub_14723CB40 (0x14723CB40) ---

// --- Function: sub_14723CBE0 (0x14723CBE0) ---
__int64 __fastcall sub_14723CBE0(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v6; // rdx
  int v7; // r14d
  __int64 *v8; // rsi
  __int64 v9; // rax
  _QWORD *v10; // rdi
  int v11; // eax
  __m128i *v12; // rax
  __int64 v13; // rbp
  __int64 v14; // r8
  signed __int64 epi64; // r13
  __int64 v16; // rdi
  unsigned __int64 v17; // r12
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // rcx
  __int64 v20; // rsi
  __int64 v21; // r15
  void **v22; // rdi
  __int64 v23; // rdx
  void **v24; // r8
  __int64 v25; // rcx
  unsigned __int64 v26; // [rsp+20h] [rbp-48h] BYREF
  char *v27; // [rsp+28h] [rbp-40h] BYREF
  __int64 v28; // [rsp+30h] [rbp-38h] BYREF
  __int64 v29; // [rsp+38h] [rbp-30h]
  __int64 *v30; // [rsp+70h] [rbp+8h]

  v26 = a2;
  sub_140357780(&v27, &v26);
  sub_1472188D0(a1 + 29, &v28, &v27);
  v27 = (char *)&qword_149808ABC + 4;
  DestroyStringObject(&v27);
  result = a1[29] + a1[32];
  if ( v28 != result )
  {
    v6 = v29;
    v7 = 0;
    result = *(_QWORD *)(v29 + 8);
    if ( (*(_DWORD *)(result - 4) & 0x7FFFFFFF) != 0 )
    {
      v8 = a1 + 22;
      v30 = v8;
      do
      {
        v9 = *(_QWORD *)(v6 + 8);
        if ( v7 >= (*(_DWORD *)(v9 - 4) & 0x7FFFFFFF) )
        {
          __debugbreak();
        }
        v10 = (_QWORD *)(v9 + 16LL * v7);
        v11 = psub_1403339F0(0xFFFFFFFF, (__int64)v10, 16LL);
        v12 = (__m128i *)sub_1472187E0(
                           v8,
                           &v26,
                           v10,
                           (__PAIR128__((unsigned int)~v11, (unsigned int)~v11) * 0xDE5FB9D2630458E9uLL) >> 64);
        if ( v12->m128i_i64[0] != *v8 + v8[3] )
        {
          v13 = *(_QWORD *)(a3 + 8);
          v14 = *(_QWORD *)(a3 + 16);
          epi64 = _mm_extract_epi64(*v12, 1);
          if ( v13 == v14 )
          {
            v16 = (v13 - *(_QWORD *)a3) >> 3;
            if ( v16 == 0x1FFFFFFFFFFFFFFFLL )
            {
              unknown_libname_10();
            }
            v17 = v16 + 1;
            v18 = (v14 - *(_QWORD *)a3) >> 3;
            v19 = v18 >> 1;
            if ( v18 <= 0x1FFFFFFFFFFFFFFFLL - (v18 >> 1) )
            {
              v20 = v19 + v18;
              if ( v19 + v18 < v17 )
              {
                v20 = v16 + 1;
              }
            }
            else
            {
              v20 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v21 = sub_14038E0B0(a3, 8 * v20);
            v22 = (void **)(v21 + 8 * v16);
            sub_1403577C0(v22, (const void **)(epi64 + 16));
            v23 = *(_QWORD *)(a3 + 8);
            v24 = (void **)v21;
            v25 = *(_QWORD *)a3;
            if ( v13 != v23 )
            {
              sub_14043A360(v25, v13, v21, a3);
              v23 = *(_QWORD *)(a3 + 8);
              v24 = v22 + 1;
              v25 = v13;
            }
            sub_14043A360(v25, v23, v24, a3);
            sub_1404F5D80(a3, v21, v17, v20);
            v8 = v30;
          }
          else
          {
            sub_1403577C0(*(void ***)(a3 + 8), (const void **)(epi64 + 16));
            *(_QWORD *)(a3 + 8) += 8LL;
          }
        }
        v6 = v29;
        ++v7;
        result = *(_QWORD *)(v29 + 8);
      }
      while ( v7 < (*(_DWORD *)(result - 4) & 0x7FFFFFFF) );
    }
  }
  return result;
}

// --- End Function: sub_14723CBE0 (0x14723CBE0) ---

// --- Function: sub_14723CE60 (0x14723CE60) ---
void **__fastcall sub_14723CE60(__int64 a1, void **a2, __int64 a3)
{
  const char *v5; // r9
  unsigned int n40503; // r8d
  char i; // al
  int v8; // edx
  unsigned __int128 v9; // rax
  __m128i v10; // xmm0
  __int64 v11; // rsi
  size_t Size; // rdi
  __int64 v14; // [rsp+20h] [rbp-78h] BYREF
  const char *v15; // [rsp+28h] [rbp-70h] BYREF
  __m128i v16; // [rsp+30h] [rbp-68h] BYREF
  _BYTE v17[8]; // [rsp+40h] [rbp-58h] BYREF
  __int64 v18; // [rsp+48h] [rbp-50h]
  char *v19; // [rsp+50h] [rbp-48h]
  char v20; // [rsp+58h] [rbp-40h] BYREF

  v14 = a3;
  sub_140357780(&v15, &v14);
  v5 = v15;
  n40503 = 40503;
  for ( i = *v15; *v5; i = *v5 )
  {
    ++v5;
    v8 = i + 32;
    if ( (unsigned __int8)(i - 65) > 0x19u )
    {
      v8 = i;
    }
    n40503 = ((1025 * (n40503 + v8)) >> 6) ^ (1025 * (n40503 + v8));
  }
  v9 = 32769 * ((9 * n40503) ^ ((9 * n40503) >> 11)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = *(__m128i *)sub_140306C90((_QWORD *)(a1 + 64), &v16, &v15, *((_QWORD *)&v9 + 1) + v9);
  v15 = (char *)&qword_149808ABC + 4;
  v16 = v10;
  DestroyStringObject(&v15);
  if ( v16.m128i_i64[0] == *(_QWORD *)(a1 + 64) + *(_QWORD *)(a1 + 88) )
  {
    CreateStringObjectFromString(a2, &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
  }
  else
  {
    v11 = sub_1402C23C0((__int64)v17, _mm_extract_epi64(v16, 1) + 16);
    sub_1403DBFB0(a2);
    Size = *(_QWORD *)v11;
    if ( *(_QWORD *)v11 )
    {
      sub_1403D95E0((char **)a2, *(_QWORD *)v11);
      sub_1403DD400(*a2, *(const void **)(v11 + 16), Size);
    }
    if ( v19 != &v20 )
    {
      qword_149808530 += -1 - v18;
      sub_14739AF10(v19);
    }
  }
  return a2;
}

// --- End Function: sub_14723CE60 (0x14723CE60) ---

// --- Function: sub_14723D000 (0x14723D000) ---
const ULONG_PTR *__fastcall sub_14723D000(_QWORD *a1, char *a2)
{
  int v3; // eax
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // rsi
  unsigned __int128 v6; // rax
  __int64 v7; // r9
  __int64 v10; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v19; // rdx
  __int64 v20; // rax
  __int128 v22; // [rsp+28h] [rbp-30h] BYREF

  v22 = *(_OWORD *)sub_1402BA020((__int64 *)&v22, a2);
  v3 = psub_1403339F0(0xFFFFFFFF, (__int64)&v22, 16LL);
  v4 = a1[18];
  v5 = 0LL;
  v6 = (unsigned int)~v3 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v7 = v4 & ((*((_QWORD *)&v6 + 1) + (_QWORD)v6) >> 7);
  _XMM2 = ((_BYTE)v6 + BYTE8(v6)) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v10 = a1[15];
    _XMM1 = *(_OWORD *)(v10 + v7);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
    {
      do
      {
        _BitScanForward((unsigned int *)&v14, _EAX);
        v15 = (v14 + v7) & v4;
        v16 = a1[16] + 24 * v15;
        if ( *(_OWORD *)v16 == v22 )
        {
          v19 = a1[15];
          v20 = v19 + v15;
          goto LABEL_11;
        }
        _EAX &= _EAX - 1;
      }
      while ( _EAX );
      v10 = a1[15];
    }
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_147F33270
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      break;
    }
    v5 += 16LL;
    v7 = (v5 + v7) & v4;
    if ( v5 > v4 )
    {
      __debugbreak();
    }
  }
  v16 = *((_QWORD *)&v22 + 1);
  v20 = v10 + v4;
  v19 = v10;
LABEL_11:
  if ( v20 == v4 + v19 )
  {
    return &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  }
  else
  {
    return *(const ULONG_PTR **)(v16 + 16);
  }
}

// --- End Function: sub_14723D000 (0x14723D000) ---

// --- Function: sub_14723D160 (0x14723D160) ---
const ULONG_PTR *__fastcall sub_14723D160(__int64 *a1, __int64 a2, int a3)
{
  __int64 v4; // rsi
  __int64 v5; // rax
  _QWORD *v6; // rbx
  int v7; // eax
  __m128i v8; // xmm0
  __int64 v10; // [rsp+20h] [rbp-28h] BYREF
  __int64 v11; // [rsp+28h] [rbp-20h] BYREF
  __int128 v12; // [rsp+30h] [rbp-18h] BYREF

  v10 = a2;
  v4 = a3;
  sub_140357780(&v11, &v10);
  sub_1472188D0(a1 + 29, &v12, &v11);
  v11 = (__int64)&qword_149808ABC + 4;
  DestroyStringObject(&v11);
  if ( (_QWORD)v12 == a1[29] + a1[32] )
  {
    return &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  }
  if ( (int)v4 < 0 )
  {
    return &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  }
  v5 = *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8LL);
  if ( (int)v4 >= (*(_DWORD *)(v5 - 4) & 0x7FFFFFFF) )
  {
    return &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  }
  v6 = (_QWORD *)(v5 + 16 * v4);
  v7 = psub_1403339F0(0xFFFFFFFF, (__int64)v6, 16);
  v8 = *(__m128i *)sub_1472187E0(
                     a1 + 15,
                     (unsigned __int64 *)&v12,
                     v6,
                     (__PAIR128__((unsigned int)~v7, (unsigned int)~v7) * 0xDE5FB9D2630458E9uLL) >> 64);
  if ( v8.m128i_i64[0] == a1[15] + a1[18] )
  {
    return &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  }
  else
  {
    return *(const ULONG_PTR **)(_mm_extract_epi64(v8, 1) + 16);
  }
}

// --- End Function: sub_14723D160 (0x14723D160) ---

// --- Function: sub_14723D290 (0x14723D290) ---
const ULONG_PTR *__fastcall sub_14723D290(__int64 a1, _QWORD *a2)
{
  int v4; // eax
  __m128i *v5; // rax
  unsigned __int64 v7[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = psub_1403339F0(0xFFFFFFFF, (__int64)a2, 16LL);
  v5 = (__m128i *)sub_1472187E0(
                    (__int64 *)(a1 + 120),
                    v7,
                    a2,
                    (__PAIR128__((unsigned int)~v4, (unsigned int)~v4) * 0xDE5FB9D2630458E9uLL) >> 64);
  if ( v5->m128i_i64[0] == *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 144) )
  {
    return &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
  }
  else
  {
    return *(const ULONG_PTR **)(_mm_extract_epi64(*v5, 1) + 16);
  }
}

// --- End Function: sub_14723D290 (0x14723D290) ---

// --- Function: sub_14723D330 (0x14723D330) ---
__int64 __fastcall sub_14723D330(__int64 *a1, _QWORD *a2, void ***a3, void ***a4)
{
  __int64 *v4; // r15
  __int64 result; // rax
  __int64 v8; // rdx
  int v9; // r13d
  __int64 v10; // rax
  _QWORD *v11; // rbp
  int v12; // eax
  __m128i *v13; // rax
  void **v14; // r14
  void **v15; // r8
  const void **v16; // rax
  __int64 v17; // rdi
  unsigned __int64 v18; // r12
  unsigned __int64 v19; // r8
  __int64 v20; // rbp
  unsigned __int64 v21; // rcx
  __int64 v22; // r15
  void **v23; // rdi
  void **v24; // rdx
  void **v25; // r8
  void **v26; // rcx
  int v27; // eax
  __m128i *v28; // rax
  void **v29; // r14
  void **v30; // r8
  const void **v31; // rax
  __int64 v32; // rdi
  unsigned __int64 v33; // r12
  unsigned __int64 v34; // r8
  __int64 v35; // rbp
  unsigned __int64 v36; // rcx
  __int64 v37; // r15
  void **v38; // rdi
  void **v39; // rdx
  void **v40; // r8
  void **v41; // rcx
  _QWORD *v42; // [rsp+20h] [rbp-78h] BYREF
  char *v43; // [rsp+28h] [rbp-70h] BYREF
  __int64 v44; // [rsp+30h] [rbp-68h] BYREF
  __int64 v45; // [rsp+38h] [rbp-60h]
  unsigned __int64 v46; // [rsp+40h] [rbp-58h] BYREF
  unsigned __int64 v47; // [rsp+50h] [rbp-48h] BYREF
  const void **v49; // [rsp+A8h] [rbp+10h]
  const void **v50; // [rsp+A8h] [rbp+10h]

  v4 = a1;
  v42 = a2;
  sub_140357780(&v43, &v42);
  sub_1472188D0(v4 + 29, &v44, &v43);
  v43 = (char *)&qword_149808ABC + 4;
  DestroyStringObject(&v43);
  result = v4[29] + v4[32];
  if ( v44 != result )
  {
    v8 = v45;
    v9 = 0;
    result = *(_QWORD *)(v45 + 8);
    if ( (*(_DWORD *)(result - 4) & 0x7FFFFFFF) != 0 )
    {
      do
      {
        v10 = *(_QWORD *)(v8 + 8);
        if ( v9 >= (*(_DWORD *)(v10 - 4) & 0x7FFFFFFF) )
        {
          __debugbreak();
        }
        v11 = (_QWORD *)(v10 + 16LL * v9);
        v42 = v11;
        v12 = psub_1403339F0(0xFFFFFFFF, (__int64)v11, 16LL);
        v13 = (__m128i *)sub_1472187E0(
                           v4 + 15,
                           &v46,
                           v11,
                           (__PAIR128__((unsigned int)~v12, (unsigned int)~v12) * 0xDE5FB9D2630458E9uLL) >> 64);
        if ( v13->m128i_i64[0] != v4[15] + v4[18] )
        {
          v14 = a3[1];
          v15 = a3[2];
          v16 = (const void **)(_mm_extract_epi64(*v13, 1) + 16);
          v49 = v16;
          if ( v14 == v15 )
          {
            v17 = v14 - *a3;
            if ( v17 == 0x1FFFFFFFFFFFFFFFLL )
            {
              goto LABEL_27;
            }
            v18 = v17 + 1;
            v19 = v15 - *a3;
            v20 = 0x1FFFFFFFFFFFFFFFLL;
            v21 = v19 >> 1;
            if ( v19 <= 0x1FFFFFFFFFFFFFFFLL - (v19 >> 1) )
            {
              v20 = v21 + v19;
              if ( v21 + v19 < v18 )
              {
                v20 = v17 + 1;
              }
            }
            v22 = sub_14038E0B0((__int64)a3, 8 * v20);
            v23 = (void **)(v22 + 8 * v17);
            sub_1403577C0(v23, v49);
            v24 = a3[1];
            v25 = (void **)v22;
            v26 = *a3;
            if ( v14 != v24 )
            {
              sub_14043A360(v26, v14, v22, a3);
              v24 = a3[1];
              v25 = v23 + 1;
              v26 = v14;
            }
            sub_14043A360(v26, v24, v25, a3);
            sub_1404F5D80(a3, v22, v18, v20);
            v11 = v42;
            v4 = a1;
          }
          else
          {
            sub_1403577C0(v14, v16);
            ++a3[1];
          }
        }
        v27 = psub_1403339F0(0xFFFFFFFF, (__int64)v11, 16LL);
        v28 = (__m128i *)sub_1472187E0(
                           v4 + 22,
                           &v47,
                           v11,
                           (__PAIR128__((unsigned int)~v27, (unsigned int)~v27) * 0xDE5FB9D2630458E9uLL) >> 64);
        if ( v28->m128i_i64[0] != v4[22] + v4[25] )
        {
          v29 = a4[1];
          v30 = a4[2];
          v31 = (const void **)(_mm_extract_epi64(*v28, 1) + 16);
          v50 = v31;
          if ( v29 == v30 )
          {
            v32 = v29 - *a4;
            if ( v32 == 0x1FFFFFFFFFFFFFFFLL )
            {
LABEL_27:
              unknown_libname_10();
            }
            v33 = v32 + 1;
            v34 = v30 - *a4;
            v35 = 0x1FFFFFFFFFFFFFFFLL;
            v36 = v34 >> 1;
            if ( v34 <= 0x1FFFFFFFFFFFFFFFLL - (v34 >> 1) )
            {
              v35 = v36 + v34;
              if ( v36 + v34 < v33 )
              {
                v35 = v32 + 1;
              }
            }
            v37 = sub_14038E0B0((__int64)a4, 8 * v35);
            v38 = (void **)(v37 + 8 * v32);
            sub_1403577C0(v38, v50);
            v39 = a4[1];
            v40 = (void **)v37;
            v41 = *a4;
            if ( v29 != v39 )
            {
              sub_14043A360(v41, v29, v37, a4);
              v39 = a4[1];
              v40 = v38 + 1;
              v41 = v29;
            }
            sub_14043A360(v41, v39, v40, a4);
            sub_1404F5D80(a4, v37, v33, v35);
            v4 = a1;
          }
          else
          {
            sub_1403577C0(v29, v31);
            ++a4[1];
          }
        }
        v8 = v45;
        ++v9;
        result = *(_QWORD *)(v45 + 8);
      }
      while ( v9 < (*(_DWORD *)(result - 4) & 0x7FFFFFFF) );
    }
  }
  return result;
}

// --- End Function: sub_14723D330 (0x14723D330) ---

// --- Function: sub_14723D6E0 (0x14723D6E0) ---
__int64 __fastcall sub_14723D6E0(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 *v3; // rsi
  __int64 result; // rax
  __int64 v6; // r15
  __int64 v7; // r12
  __int64 v8; // rbp
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 *v11; // r14
  __int64 v12; // r13
  __int64 *v13; // rdi
  _QWORD *i; // rsi
  int v15; // r14d
  __int64 *v16; // rsi
  __int64 v17; // rax
  _QWORD *v18; // rdi
  int v19; // eax
  __m128i *v20; // rax
  __int64 *v21; // rsi
  __int64 *v22; // r8
  signed __int64 epi64; // r13
  __int64 v24; // rdi
  unsigned __int64 v25; // r12
  unsigned __int64 v26; // r8
  unsigned __int64 v27; // rcx
  __int64 v28; // rbp
  _QWORD *v29; // r15
  void **v30; // rdi
  __int64 *v31; // rdx
  _QWORD *v32; // r8
  __int64 *v33; // rcx
  unsigned __int64 v34; // [rsp+20h] [rbp-48h] BYREF
  __int64 v35; // [rsp+28h] [rbp-40h] BYREF
  __int128 v36; // [rsp+30h] [rbp-38h] BYREF
  __int64 *v38; // [rsp+70h] [rbp+8h]

  v3 = a1;
  v34 = a2;
  sub_140357780(&v35, &v34);
  sub_1472188D0(v3 + 29, &v36, &v35);
  v35 = (__int64)&qword_149808ABC + 4;
  DestroyStringObject(&v35);
  result = v3[29] + v3[32];
  if ( (_QWORD)v36 != result )
  {
    v6 = *((_QWORD *)&v36 + 1);
    v7 = (__int64)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3;
    v8 = *(unsigned int *)(*(_QWORD *)(*((_QWORD *)&v36 + 1) + 8LL) - 4LL);
    LODWORD(v8) = v8 & 0x7FFFFFFF;
    v9 = v7 + v8;
    if ( v9 > (__int64)(*(_QWORD *)(a3 + 16) - *(_QWORD *)a3) >> 3 )
    {
      if ( v9 > 0x1FFFFFFFFFFFFFFFLL )
      {
LABEL_25:
        unknown_libname_10();
      }
      v10 = sub_14038E0B0(a3, 8 * v9);
      v11 = *(__int64 **)(a3 + 8);
      v12 = v10;
      v13 = *(__int64 **)a3;
      for ( i = (_QWORD *)v10; v13 != v11; ++v13 )
      {
        sub_1403577A0(i++, v13);
      }
      sub_1404F5D80(a3, v12, v7, v9);
      v3 = a1;
    }
    result = *(_QWORD *)(v6 + 8);
    v15 = 0;
    if ( (*(_DWORD *)(result - 4) & 0x7FFFFFFF) != 0 )
    {
      v16 = v3 + 15;
      v38 = v16;
      do
      {
        v17 = *(_QWORD *)(v6 + 8);
        if ( v15 >= (*(_DWORD *)(v17 - 4) & 0x7FFFFFFF) )
        {
          __debugbreak();
        }
        v18 = (_QWORD *)(v17 + 16LL * v15);
        v19 = psub_1403339F0(0xFFFFFFFF, (__int64)v18, 16);
        v20 = (__m128i *)sub_1472187E0(
                           v16,
                           &v34,
                           v18,
                           (__PAIR128__((unsigned int)~v19, (unsigned int)~v19) * 0xDE5FB9D2630458E9uLL) >> 64);
        if ( v20->m128i_i64[0] != *v16 + v16[3] )
        {
          v21 = *(__int64 **)(a3 + 8);
          v22 = *(__int64 **)(a3 + 16);
          epi64 = _mm_extract_epi64(*v20, 1);
          if ( v21 == v22 )
          {
            v24 = ((__int64)v21 - *(_QWORD *)a3) >> 3;
            if ( v24 == 0x1FFFFFFFFFFFFFFFLL )
            {
              goto LABEL_25;
            }
            v25 = v24 + 1;
            v26 = ((__int64)v22 - *(_QWORD *)a3) >> 3;
            v27 = v26 >> 1;
            if ( v26 <= 0x1FFFFFFFFFFFFFFFLL - (v26 >> 1) )
            {
              v28 = v27 + v26;
              if ( v27 + v26 < v25 )
              {
                v28 = v24 + 1;
              }
            }
            else
            {
              v28 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v29 = (_QWORD *)sub_14038E0B0(a3, 8 * v28);
            v30 = (void **)&v29[v24];
            sub_1403577C0(v30, (const void **)(epi64 + 16));
            v31 = *(__int64 **)(a3 + 8);
            v32 = v29;
            v33 = *(__int64 **)a3;
            if ( v21 != v31 )
            {
              sub_14043A360(v33, v21, v29);
              v31 = *(__int64 **)(a3 + 8);
              v32 = v30 + 1;
              v33 = v21;
            }
            sub_14043A360(v33, v31, v32);
            sub_1404F5D80(a3, (__int64)v29, v25, v28);
            v6 = *((_QWORD *)&v36 + 1);
          }
          else
          {
            sub_1403577C0(*(void ***)(a3 + 8), (const void **)(epi64 + 16));
            *(_QWORD *)(a3 + 8) += 8LL;
          }
          v16 = v38;
        }
        result = *(_QWORD *)(v6 + 8);
        ++v15;
      }
      while ( v15 < (*(_DWORD *)(result - 4) & 0x7FFFFFFF) );
    }
  }
  return result;
}

// --- End Function: sub_14723D6E0 (0x14723D6E0) ---

// --- Function: sub_14723D9D0 (0x14723D9D0) ---
_QWORD *__fastcall sub_14723D9D0(__int64 a1, _QWORD *a2, __int64 a3)
{
  const char *v5; // r9
  unsigned int n40503; // r8d
  char i; // al
  int v8; // edx
  unsigned __int128 v9; // rax
  __m128i v10; // xmm0
  __int64 v12; // [rsp+20h] [rbp-28h] BYREF
  const char *v13; // [rsp+28h] [rbp-20h] BYREF
  __m128i v14; // [rsp+30h] [rbp-18h] BYREF

  v12 = a3;
  sub_140357780(&v13, &v12);
  v5 = v13;
  n40503 = 40503;
  for ( i = *v13; *v5; i = *v5 )
  {
    ++v5;
    v8 = i + 32;
    if ( (unsigned __int8)(i - 65) > 0x19u )
    {
      v8 = i;
    }
    n40503 = ((1025 * (n40503 + v8)) >> 6) ^ (1025 * (n40503 + v8));
  }
  v9 = 32769 * ((9 * n40503) ^ ((9 * n40503) >> 11)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = *(__m128i *)sub_140306C90((_QWORD *)(a1 + 64), &v14, &v13, *((_QWORD *)&v9 + 1) + v9);
  v13 = (char *)&qword_149808ABC + 4;
  v14 = v10;
  DestroyStringObject(&v13);
  if ( v14.m128i_i64[0] == *(_QWORD *)(a1 + 64) + *(_QWORD *)(a1 + 88) )
  {
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(_mm_extract_epi64(v14, 1) + 16);
  }
  return a2;
}

// --- End Function: sub_14723D9D0 (0x14723D9D0) ---

// --- Function: sub_14723DCD0 (0x14723DCD0) ---
__int64 __fastcall sub_14723DCD0(_QWORD *a1, __int64 a2)
{
  __int64 v3; // r8
  int v4; // eax
  int v5; // r8d
  __int64 v6; // rdx
  __int64 *v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx

  v3 = -1LL;
  do
  {
    ++v3;
  }
  while ( *(_BYTE *)(a2 + v3) );
  v4 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_1495F6C20[0])(0xFFFFFFFF, a2, v3);
  v5 = ~v4;
  v6 = a1[108];
  v7 = (__int64 *)(a1[110]
                 + 16
                 * ((0x100000001B3LL
                   * (((unsigned __int64)(unsigned int)~v4 >> 24)
                    ^ (0x100000001B3LL
                     * ((unsigned __int8)((unsigned int)~v4 >> 16)
                      ^ (0x100000001B3LL
                       * ((0x100000001B3LL * ((unsigned __int8)~(_BYTE)v4 ^ 0xCBF29CE484222325uLL))
                        ^ (unsigned __int8)((unsigned __int16)~(_WORD)v4 >> 8)))))))
                  & a1[113]));
  v8 = v7[1];
  if ( v8 != v6 )
  {
    v9 = *v7;
    if ( v5 == *(_DWORD *)(v8 + 16) )
    {
      goto LABEL_9;
    }
    while ( v8 != v9 )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( v5 == *(_DWORD *)(v8 + 16) )
      {
        goto LABEL_9;
      }
    }
  }
  v8 = 0LL;
LABEL_9:
  if ( !v8 )
  {
    v8 = a1[108];
  }
  if ( v8 == v6 )
  {
    return 0LL;
  }
  else
  {
    return *(_QWORD *)(v8 + 24);
  }
}

// --- End Function: sub_14723DCD0 (0x14723DCD0) ---

// --- Function: sub_14723DDC0 (0x14723DDC0) ---
_BYTE *__fastcall sub_14723DDC0(_QWORD *pDataCore, __int64 a2, const char *s1, __int64 a4)
{
  unsigned __int8 ***v7; // rdi
  size_t n511; // rbx
  unsigned __int8 **v9; // r11
  unsigned __int64 v10; // r9
  unsigned __int8 **v11; // r10
  unsigned __int8 *v12; // rax
  int v13; // ecx
  int v14; // edx
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.; // rdi
  _BYTE *result; // rax

  v7 = (unsigned __int8 ***)DataCore::LookupDCStructDescByName((__int64)pDataCore, (__int64)s1);
  if ( v7 )
  {
    n511 = 0;
    while ( 1 )
    {
      v9 = v7[1];
      v10 = 0;
      if ( v9 )
      {
        break;
      }
LABEL_10:
      v7 = (unsigned __int8 ***)DataCore::LookupDCStructDescByName((__int64)pDataCore, (__int64)v7[3]);
      if ( !v7 )
      {
        goto LABEL_11;
      }
    }
    v11 = *v7;
    while ( 1 )
    {
      v12 = *v11;
      do
      {
        v13 = v12[a4 - (_QWORD)*v11];
        v14 = *v12 - v13;
        if ( v14 )
        {
          break;
        }
        ++v12;
      }
      while ( v13 );
      if ( !v14 )
      {
        break;
      }
      ++v10;
      v11 += 5;
      if ( v10 >= (unsigned __int64)v9 )
      {
        goto LABEL_10;
      }
    }
    if ( (unsigned __int8)(*((_BYTE *)v11 + 24) - 15) > 1u )
    {
      result = *(_BYTE **)(a2 + 16);
      *(_QWORD *)a2 = 0;
      *result = 0;
      return result;
    }
    p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (const ULONG_PTR *)v11[4];
    if ( p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. )
    {
      n511 = -1;
      do
      {
        ++n511;
      }
      while ( *((_BYTE *)p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. + n511) );
    }
  }
  else
  {
LABEL_11:
    p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
    n511 = -1;
    do
    {
      ++n511;
    }
    while ( *((_BYTE *)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp + n511) );
  }
  if ( n511 > *(_QWORD *)(a2 + 8) )
  {
    sub_1402A1D80((_QWORD *)a2);
    sub_1402A1C40((__int64 *)a2, n511);
  }
  memmove(*(void **)(a2 + 16), p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core., n511);
  result = *(_BYTE **)(a2 + 16);
  *(_QWORD *)a2 = n511;
  result[n511] = 0;
  return result;
}

// --- End Function: sub_14723DDC0 (0x14723DDC0) ---

// --- Function: sub_14723DF00 (0x14723DF00) ---
__int64 __fastcall sub_14723DF00(_QWORD *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  __int64 v7; // r8
  unsigned int v8; // eax
  __int64 v9; // r8
  unsigned int v10; // eax
  unsigned int v11; // ebp
  __int64 v12; // r8
  int v13; // eax
  __int64 *v14; // r8
  unsigned int v15; // eax
  __int64 *v16; // rdx
  __int64 *v17; // rcx
  signed __int64 i; // rbx
  unsigned __int8 *v20; // rdx
  __int64 v21; // r8
  int v22; // eax
  unsigned int v23; // eax
  __int64 *v24; // r8
  __int64 *v25; // rcx

  if ( a1[91] )
  {
    v7 = -1LL;
    do
    {
      ++v7;
    }
    while ( a4[v7] );
    v8 = ((__int64 (__fastcall *)(unsigned int, unsigned __int8 *, __int64))off_1495F6C30[0])(0xFFFFFFFF, a4, v7);
    v9 = -1LL;
    do
    {
      ++v9;
    }
    while ( a3[v9] );
    v10 = ((__int64 (__fastcall *)(unsigned int, unsigned __int8 *, __int64))off_1495F6C30[0])(v8, a3, v9);
    v11 = v10;
    v12 = -1LL;
    do
    {
      ++v12;
    }
    while ( a2[v12] );
    v13 = ((__int64 (__fastcall *)(unsigned int, unsigned __int8 *, __int64))off_1495F6C30[0])(v10, a2, v12);
    v14 = (__int64 *)a1[97];
    v15 = ~v13;
    v16 = v14;
    v17 = (__int64 *)v14[1];
    while ( !*((_BYTE *)v17 + 25) )
    {
      if ( *((_DWORD *)v17 + 7) >= v15 )
      {
        v16 = v17;
        v17 = (__int64 *)*v17;
      }
      else
      {
        v17 = (__int64 *)v17[2];
      }
    }
    if ( !*((_BYTE *)v16 + 25) && v15 >= *((_DWORD *)v16 + 7) && v16 != v14 )
    {
      return a1[94] + *((unsigned int *)v16 + 8);
    }
    for ( i = DataCore::LookupDCStructDescByName((__int64)a1, (__int64)a2);
          i;
          i = DataCore::LookupDCStructDescByName((__int64)a1, *(_QWORD *)(i + 24)) )
    {
      v20 = *(unsigned __int8 **)(i + 24);
      if ( !v20 )
      {
        break;
      }
      v21 = -1LL;
      do
      {
        ++v21;
      }
      while ( v20[v21] );
      v22 = ((__int64 (__fastcall *)(unsigned int, unsigned __int8 *, __int64))off_1495F6C30[0])(v11, v20, v21);
      v16 = (__int64 *)a1[97];
      v23 = ~v22;
      v24 = v16;
      v25 = (__int64 *)v16[1];
      if ( !*((_BYTE *)v25 + 25) )
      {
        do
        {
          if ( *((_DWORD *)v25 + 7) >= v23 )
          {
            v16 = v25;
            v25 = (__int64 *)*v25;
          }
          else
          {
            v25 = (__int64 *)v25[2];
          }
        }
        while ( !*((_BYTE *)v25 + 25) );
        v24 = (__int64 *)a1[97];
      }
      if ( !*((_BYTE *)v16 + 25) && v23 >= *((_DWORD *)v16 + 7) && v16 != v24 )
      {
        return a1[94] + *((unsigned int *)v16 + 8);
      }
    }
  }
  return 0LL;
}

// --- End Function: sub_14723DF00 (0x14723DF00) ---

// --- Function: sub_14723E0B0 (0x14723E0B0) ---
__int64 __fastcall sub_14723E0B0(_QWORD *rcx0, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  __int64 v9; // rdi
  unsigned __int64 n511_1; // rbx
  _BYTE *v11; // rax
  size_t Size; // r8
  size_t Size_1; // r8
  int v14; // eax
  __int64 *v15; // r8
  unsigned int v16; // eax
  __int64 *v17; // rdx
  __int64 *v18; // rcx
  unsigned __int64 n511_2; // [rsp+20h] [rbp-268h] BYREF
  __int64 n511; // [rsp+28h] [rbp-260h]
  void *v21; // [rsp+30h] [rbp-258h]
  _BYTE v22[520]; // [rsp+38h] [rbp-250h] BYREF

  if ( !rcx0[91] )
  {
    return 0;
  }
  v9 = 0;
  v22[0] = 0;
  v21 = v22;
  n511_2 = 0;
  n511 = 511;
  if ( a2 )
  {
    n511_1 = -1;
    do
    {
      ++n511_1;
    }
    while ( a2[n511_1] );
    if ( n511_1 )
    {
      v11 = v22;
      if ( n511_1 + 1 > 0x200 )
      {
        v11 = (_BYTE *)sub_14739AFC0(n511_1 + 1, 0);
        qword_149808368 += n511_1 + 1;
        n511 = n511_1;
      }
      v21 = v11;
      n511_2 = n511_1;
      v11[n511_1] = 0;
      memcpy(v21, a2, n511_1);
    }
  }
  if ( a3 )
  {
    Size = -1;
    do
    {
      ++Size;
    }
    while ( a3[Size] );
  }
  else
  {
    Size = 0;
  }
  sub_1402DC930(&n511_2, a3, Size);
  if ( a4 )
  {
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( a4[Size_1] );
  }
  else
  {
    Size_1 = 0;
  }
  sub_1402DC930(&n511_2, a4, Size_1);
  v14 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_1495F6C20[0])(0xFFFFFFFF, (__int64)v21, n511_2);
  v15 = (__int64 *)rcx0[95];
  v16 = ~v14;
  v17 = v15;
  v18 = (__int64 *)v15[1];
  while ( !*((_BYTE *)v18 + 25) )
  {
    if ( *((_DWORD *)v18 + 7) >= v16 )
    {
      v17 = v18;
      v18 = (__int64 *)*v18;
    }
    else
    {
      v18 = (__int64 *)v18[2];
    }
  }
  if ( !*((_BYTE *)v17 + 25) && v16 >= *((_DWORD *)v17 + 7) && v17 != v15 )
  {
    v9 = rcx0[94] + *((unsigned int *)v17 + 8);
  }
  if ( v21 != v22 )
  {
    qword_149808368 += -1 - n511;
    sub_14739AF10(v21);
  }
  return v9;
}

// --- End Function: sub_14723E0B0 (0x14723E0B0) ---

// --- Function: sub_14723E2B0 (0x14723E2B0) ---
__int64 __fastcall sub_14723E2B0(_QWORD *a1, __int64 a2)
{
  __int64 v3; // r8
  int v4; // eax
  int v5; // r8d
  __int64 v6; // rdx
  __int64 *v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx

  v3 = -1LL;
  do
  {
    ++v3;
  }
  while ( *(_BYTE *)(a2 + v3) );
  v4 = ((__int64 (__fastcall *)(unsigned int, __int64, __int64))off_1495F6C20[0])(0xFFFFFFFF, a2, v3);
  v5 = ~v4;
  v6 = a1[100];
  v7 = (__int64 *)(a1[102]
                 + 16
                 * ((0x100000001B3LL
                   * (((unsigned __int64)(unsigned int)~v4 >> 24)
                    ^ (0x100000001B3LL
                     * ((unsigned __int8)((unsigned int)~v4 >> 16)
                      ^ (0x100000001B3LL
                       * ((0x100000001B3LL * ((unsigned __int8)~(_BYTE)v4 ^ 0xCBF29CE484222325uLL))
                        ^ (unsigned __int8)((unsigned __int16)~(_WORD)v4 >> 8)))))))
                  & a1[105]));
  v8 = v7[1];
  if ( v8 != v6 )
  {
    v9 = *v7;
    if ( v5 == *(_DWORD *)(v8 + 16) )
    {
      goto LABEL_9;
    }
    while ( v8 != v9 )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( v5 == *(_DWORD *)(v8 + 16) )
      {
        goto LABEL_9;
      }
    }
  }
  v8 = 0LL;
LABEL_9:
  if ( !v8 )
  {
    v8 = a1[100];
  }
  if ( v8 == v6 )
  {
    return 0LL;
  }
  else
  {
    return *(_QWORD *)(v8 + 24);
  }
}

// --- End Function: sub_14723E2B0 (0x14723E2B0) ---

// --- Function: sub_14723E3A0 (0x14723E3A0) ---
void __fastcall sub_14723E3A0(__int64 a1, __int64 a2, char **a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // r10
  int v5; // r13d
  __int64 v6; // r9
  unsigned int v7; // r15d
  __int64 v8; // rax
  char *v9; // rdx
  char *v10; // rbx
  __int64 v11; // rcx
  __int64 v12; // r14
  void *v13; // rdi
  signed __int64 v14; // rsi
  unsigned __int64 v15; // r12
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rax
  char *v19; // rcx
  const void *v20; // rdx
  char *Size; // r8
  unsigned __int64 v22; // rdi
  __int64 v23; // [rsp+20h] [rbp-60h] BYREF
  void *Src[2]; // [rsp+28h] [rbp-58h] BYREF
  char *v25; // [rsp+38h] [rbp-48h]
  __int64 v26; // [rsp+90h] [rbp+10h]
  char **v28; // [rsp+A0h] [rbp+20h]

  if ( a2 )
  {
    v28 = a3;
    v26 = a1;
    v4 = a4;
    v5 = 0;
    v6 = a2;
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 504);
    *(_OWORD *)Src = 0;
    v9 = 0;
    v10 = 0;
    v25 = 0;
    if ( *(_DWORD *)(v8 + 16) )
    {
      do
      {
        v11 = *(_QWORD *)(a1 + 512);
        v12 = v11 + 16LL * (int)v7;
        v23 = v12;
        if ( v11 + 16LL * *(unsigned int *)(v12 + 4) == v6 )
        {
          sub_1402A4690(a3, &v23);
          v13 = Src[1];
          if ( Src[1] == v25 )
          {
            v14 = ((char *)Src[1] - (char *)Src[0]) >> 3;
            if ( v14 == 0x1FFFFFFFFFFFFFFFLL )
            {
              unknown_libname_10();
            }
            v15 = v14 + 1;
            v16 = (v25 - (char *)Src[0]) >> 3;
            v17 = v16 >> 1;
            if ( v16 <= 0x1FFFFFFFFFFFFFFFLL - (v16 >> 1) )
            {
              v18 = v17 + v16;
              if ( v17 + v16 < v15 )
              {
                v18 = v14 + 1;
              }
            }
            else
            {
              v18 = 0x1FFFFFFFFFFFFFFFLL;
            }
            v23 = 8 * v18;
            v10 = (char *)sub_14038E0B0((__int64)Src, 8 * v18);
            v19 = v10;
            *(_QWORD *)&v10[8 * v14] = v12;
            v20 = Src[0];
            if ( v13 == Src[1] )
            {
              Size = (char *)((char *)Src[1] - (char *)Src[0]);
            }
            else
            {
              memmove(v10, Src[0], (size_t)v13 - (unsigned __int64)Src[0]);
              v19 = &v10[8 * v14 + 8];
              Size = (char *)((char *)Src[1] - (char *)v13);
              v20 = v13;
            }
            memmove(v19, v20, (size_t)Size);
            if ( Src[0] )
            {
              sub_14039EFB0((__int64)Src, Src[0], (v25 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
            }
            v9 = &v10[8 * v15];
            Src[0] = v10;
            v25 = &v10[v23];
          }
          else
          {
            *(_QWORD *)Src[1] = v12;
            v10 = (char *)Src[0];
            v9 = (char *)Src[1] + 8;
          }
          v6 = a2;
          a3 = v28;
          Src[1] = v9;
        }
        a1 = v26;
        ++v7;
      }
      while ( v7 < *(_DWORD *)(*(_QWORD *)(v26 + 504) + 16LL) );
      v4 = a4;
    }
    if ( v4 && (v9 - v10) >> 3 )
    {
      v22 = 0;
      do
      {
        if ( (v9 - v10) >> 3 <= v22 )
        {
          __debugbreak();
        }
        sub_14723E3A0(a1, *(_QWORD *)&v10[8 * v22], a3, v4);
        v9 = (char *)Src[1];
        ++v5;
        v10 = (char *)Src[0];
        a3 = v28;
        v4 = a4;
        ++v22;
        a1 = v26;
      }
      while ( v5 < (unsigned __int64)(((char *)Src[1] - (char *)Src[0]) >> 3) );
    }
    if ( v10 )
    {
      sub_14039EFB0((__int64)Src, v10, (v25 - v10) & 0xFFFFFFFFFFFFFFF8uLL);
    }
  }
}

// --- End Function: sub_14723E3A0 (0x14723E3A0) ---

// --- Function: sub_14723E630 (0x14723E630) ---
__int64 __fastcall sub_14723E630(_QWORD *a1, __int64 a2, const char *s1)
{
  int v3; // ebx
  int v4; // r9d
  __int64 v7; // rdi
  int v8; // r14d
  unsigned int n6; // esi
  __int64 v10; // rax

  v3 = *(unsigned __int16 *)(a2 + 8);
  v4 = 0;
  if ( !*(_WORD *)(a2 + 8) )
  {
    return 0;
  }
  v7 = a1[65];
  v8 = *(unsigned __int16 *)(a2 + 10);
  n6 = *(_DWORD *)(a1[63] + 4LL);
  while ( 1 )
  {
    v10 = n6 >= 6 ? a1[85] : a1[84];
    if ( !strcmp(s1, (const char *)(*(unsigned int *)(v7 + 12LL * (v8 + v4)) + v10)) )
    {
      break;
    }
    if ( ++v4 >= v3 )
    {
      return 0;
    }
  }
  return v7 + 12LL * (v8 + v4);
}

// --- End Function: sub_14723E630 (0x14723E630) ---

// --- Function: sub_14723E6E0 (0x14723E6E0) ---
__int64 __fastcall sub_14723E6E0(_QWORD *a1, __int64 a2)
{
  char n15; // al
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v7; // rdx
  __int64 v8; // rax

  n15 = *(_BYTE *)(a2 + 6);
  if ( n15 == 16 )
  {
    v4 = *(unsigned int *)(a1[64] + 16LL * *(unsigned __int16 *)(a2 + 4));
    if ( *(_DWORD *)(a1[63] + 4LL) >= 6u )
    {
      v5 = a1[85];
    }
    else
    {
      v5 = a1[84];
    }
    return v4 + v5;
  }
  else if ( n15 == 15 )
  {
    v7 = *(unsigned int *)(a1[66] + 8LL * *(unsigned __int16 *)(a2 + 4));
    if ( *(_DWORD *)(a1[63] + 4LL) >= 6u )
    {
      v8 = a1[85];
    }
    else
    {
      v8 = a1[84];
    }
    return v7 + v8;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_14723E6E0 (0x14723E6E0) ---

// --- Function: sub_14723E760 (0x14723E760) ---
__int64 __fastcall sub_14723E760(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  if ( !a2 )
  {
    return 0LL;
  }
  v2 = *(unsigned int *)(a2 + 4);
  if ( (_DWORD)v2 == -1 )
  {
    return 0LL;
  }
  else
  {
    return *(_QWORD *)(a1 + 512) + 16 * v2;
  }
}

// --- End Function: sub_14723E760 (0x14723E760) ---

// --- Function: sub_14723E780 (0x14723E780) ---
__int64 __fastcall sub_14723E780(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned int v6; // esi
  unsigned int v7; // r10d
  __int64 v8; // rax
  __int64 v9; // rbx
  unsigned int *v10; // r9
  unsigned int *i; // r11
  __int64 v12; // rcx
  unsigned __int8 *v13; // rax
  __int64 v14; // r8
  int v15; // ecx
  int v16; // edx
  unsigned __int8 *v17; // rax
  __int64 v18; // r8
  int v19; // ecx
  int v20; // edx

  v3 = a1[91];
  if ( !v3 )
  {
    return 0LL;
  }
  v6 = *(_DWORD *)(v3 + 4);
  v7 = 0;
  if ( !v6 )
  {
    return 0LL;
  }
  v8 = a1[92];
  v9 = a1[94];
  v10 = (unsigned int *)(v8 + 8);
  for ( i = (unsigned int *)(v8 + 4); ; i += 4 )
  {
    v12 = *i;
    v13 = (unsigned __int8 *)(v9 + *(v10 - 2));
    if ( (_DWORD)v12 == -1 || !(v9 + v12) )
    {
      v14 = a2 - (_QWORD)v13;
      do
      {
        v15 = v13[v14];
        v16 = *v13 - v15;
        if ( v16 )
        {
          break;
        }
        ++v13;
      }
      while ( v15 );
      if ( !v16 )
      {
        v17 = (unsigned __int8 *)(v9 + *v10);
        v18 = a3 - (_QWORD)v17;
        do
        {
          v19 = v17[v18];
          v20 = *v17 - v19;
          if ( v20 )
          {
            break;
          }
          ++v17;
        }
        while ( v19 );
        if ( !v20 )
        {
          break;
        }
      }
    }
    ++v7;
    v10 += 4;
    if ( v7 >= v6 )
    {
      return 0LL;
    }
  }
  return v9 + v10[1];
}

// --- End Function: sub_14723E780 (0x14723E780) ---

// --- Function: sub_14723E870 (0x14723E870) ---
__int64 __fastcall sub_14723E870(_QWORD *a1, unsigned int *a2)
{
  __int64 v3; // rax

  if ( !a2 )
  {
    return 0LL;
  }
  if ( *(_DWORD *)(a1[63] + 4LL) >= 6u )
  {
    v3 = a1[85];
  }
  else
  {
    v3 = a1[84];
  }
  return *a2 + v3;
}

// --- End Function: sub_14723E870 (0x14723E870) ---

// --- Function: DataCore::GetStructFieldPointers (0x14723EB40) ---
// Retrieves pointers to the field descriptors for a given structure identifier
// within the DataCore object.  If `includeChain` is true, it traverses a chain of
// related structure descriptors (e.g., base types or includes) starting from the
// one identified by `structIdentifier`, collecting fields from all of them. Fields
// from chained descriptors are added after the fields from the initial descriptor.
// If `includeChain` is false, only fields from the structure directly identified
// by `structIdentifier` are retrieved.  The function resizes the output vector
// `pOutFieldPtrsVec` and populates it with pointers to the field descriptors (each
// assumed to be 40 bytes).  @param pDataCore Pointer to the CDataCore instance.
// @param structIdentifier Identifier (e.g., name hash or pointer) used to look up
// the initial structure descriptor. @param pOutFieldPtrsVec Pointer to a vector-
// like structure (`begin`, `end`, `capacity_end` pointers) that will be populated
// with field descriptor pointers. @param includeChain If true, retrieves fields
// from the entire structure chain; otherwise, only from the specified structure.
char *__fastcall DataCore::GetStructFieldPointers(
        __int64 pDataCore,
        __int64 structIdentifier,
        char **pOutFieldPtrsVec,
        char includeChain)
{
  char *chainDescIndex_1; // rax
  const char *pNextStructIdentifier; // rbx
  unsigned __int64 chainDescCount; // r14
  signed __int64 pCurrentChainDesc; // rax
  int logFlags; // r15d
  __int64 *pLogContext; // rax
  unsigned __int64 totalFieldCount; // r15
  unsigned __int64 outVecIndex; // rbx
  unsigned __int64 chainDescCount_1; // rax
  char *pDescFromBuffer; // rcx
  __int64 descFieldCount; // rdx
  __int64 chainDescIndex; // r11
  char *pDescFromBufferReverse; // r9
  unsigned __int64 chainDescIndex_3; // r10
  int chainDescIndex_2; // edx
  char *chainDescIndex_4; // r14
  unsigned __int64 totalFieldCount_1; // rbx
  int totalFieldCount_2; // esi
  unsigned __int64 outVecIndexSingle; // rdx
  __int64 descFieldIndexInc; // rcx
  __int64 pCurrentField; // r8
  int n232; // [rsp+50h] [rbp-B0h] BYREF
  int n31; // [rsp+54h] [rbp-ACh]
  __int64 p_n232; // [rsp+58h] [rbp-A8h] BYREF
  __int64 *p_p_n232; // [rsp+60h] [rbp-A0h]
  __int128 a7; // [rsp+68h] [rbp-98h] BYREF
  char *chainDescIndex_5; // [rsp+80h] [rbp-80h]
  __m256 v33; // [rsp+88h] [rbp-78h]
  __m256 v34; // [rsp+A8h] [rbp-58h]
  __m256 v35; // [rsp+C8h] [rbp-38h]
  __int128 v36; // [rsp+E8h] [rbp-18h]
  __int64 v37; // [rsp+F8h] [rbp-8h]

  if ( *pOutFieldPtrsVec != pOutFieldPtrsVec[1] )
  {
    pOutFieldPtrsVec[1] = *pOutFieldPtrsVec;
  }
  if ( includeChain )
  {
    chainDescIndex_1 = (char *)DataCore::LookupDCStructDescByName(pDataCore, structIdentifier);
    if ( chainDescIndex_1 )
    {
      pNextStructIdentifier = (const char *)*((_QWORD *)chainDescIndex_1 + 3);
      v37 = 0;
      chainDescIndex_5 = chainDescIndex_1;
      chainDescCount = 1;
      v33 = (__m256)0LL;
      v34 = (__m256)0LL;
      v35 = (__m256)0LL;
      v36 = 0;
      if ( pNextStructIdentifier )
      {
        while ( 1 )
        {
          __asm { vzeroupper }
          pCurrentChainDesc = DataCore::LookupDCStructDescByName(pDataCore, (__int64)pNextStructIdentifier);
          if ( !pCurrentChainDesc )
          {
            break;
          }
          pNextStructIdentifier = *(const char **)(pCurrentChainDesc + 24);
          (&chainDescIndex_5)[chainDescCount++] = (char *)pCurrentChainDesc;
          if ( !pNextStructIdentifier )
          {
            goto LABEL_11;
          }
        }
        n232 = 232;
        p_n232 = (__int64)&n232;
        n31 = 31;
        p_p_n232 = &p_n232;
        logFlags = invokeGlobalCallbackAndMaskStatusBits(
                     3,
                     (__int64)&p_n232,
                     (__int64)"[DataCore] CDataCore::GetStructDataFields - [%s] has no DCStructDesc",
                     pNextStructIdentifier);
        if ( (logFlags & 0xFFFFF) != 0 )
        {
          pLogContext = getThreadLogContextSlot();
          p_n232 = (__int64)&n232;
          p_p_n232 = &p_n232;
          n232 = 232;
          a7 = 0;
          n31 = 31;
          submitTraceContext(
            3,
            (__int64)&p_n232,
            "[DataCore] CDataCore::GetStructDataFields - [%s] has no DCStructDesc",
            (__int64)pNextStructIdentifier,
            1,
            logFlags,
            &a7,
            0,
            (__int64)pLogContext);
        }
      }
LABEL_11:
      totalFieldCount = 0;
      outVecIndex = 0;
      for ( chainDescCount_1 = 0; chainDescCount_1 < chainDescCount; ++chainDescCount_1 )
      {
        pDescFromBuffer = (&chainDescIndex_5)[chainDescCount_1];
        if ( pDescFromBuffer )
        {
          descFieldCount = *((_QWORD *)pDescFromBuffer + 1);
        }
        else
        {
          descFieldCount = 0;
        }
        totalFieldCount += descFieldCount;
      }
      __asm { vzeroupper }
      chainDescIndex_1 = ensureCapacityAndZeroFill(pOutFieldPtrsVec, totalFieldCount);
      if ( totalFieldCount )
      {
        chainDescIndex_1 = (char *)(unsigned int)(chainDescCount - 1);
        for ( chainDescIndex = (int)chainDescIndex_1; chainDescIndex >= 0; --chainDescIndex )
        {
          pDescFromBufferReverse = (&chainDescIndex_5)[chainDescIndex];
          if ( pDescFromBufferReverse )
          {
            chainDescIndex_3 = *((_QWORD *)pDescFromBufferReverse + 1);
            chainDescIndex_2 = 0;
            if ( chainDescIndex_3 )
            {
              chainDescIndex_1 = 0;
              do
              {
                if ( (pOutFieldPtrsVec[1] - *pOutFieldPtrsVec) >> 3 <= outVecIndex )
                {
                  __debugbreak();
                }
                ++chainDescIndex_2;
                *(_QWORD *)&(*pOutFieldPtrsVec)[8 * outVecIndex++] = *(_QWORD *)pDescFromBufferReverse
                                                                   + 40LL * (_QWORD)chainDescIndex_1;
                chainDescIndex_1 = (char *)chainDescIndex_2;
              }
              while ( chainDescIndex_2 < chainDescIndex_3 );
            }
          }
        }
      }
    }
  }
  else
  {
    chainDescIndex_1 = (char *)DataCore::LookupDCStructDescByName(pDataCore, structIdentifier);
    chainDescIndex_4 = chainDescIndex_1;
    if ( chainDescIndex_1 )
    {
      totalFieldCount_1 = *((_QWORD *)chainDescIndex_1 + 1);
      chainDescIndex_1 = ensureCapacityAndZeroFill(pOutFieldPtrsVec, totalFieldCount_1);
      totalFieldCount_2 = 0;
      if ( totalFieldCount_1 )
      {
        outVecIndexSingle = 0;
        descFieldIndexInc = 0;
        do
        {
          pCurrentField = *(_QWORD *)chainDescIndex_4 + 40 * descFieldIndexInc;
          if ( (pOutFieldPtrsVec[1] - *pOutFieldPtrsVec) >> 3 <= outVecIndexSingle )
          {
            __debugbreak();
          }
          chainDescIndex_1 = *pOutFieldPtrsVec;
          descFieldIndexInc = ++totalFieldCount_2;
          *(_QWORD *)&(*pOutFieldPtrsVec)[8 * outVecIndexSingle++] = pCurrentField;
        }
        while ( totalFieldCount_2 < totalFieldCount_1 );
      }
    }
  }
  return chainDescIndex_1;
}

// --- End Function: DataCore::GetStructFieldPointers (0x14723EB40) ---

// --- Function: DataCore::LookupDCStructDescByName (0x14723EDF0) ---
signed __int64 __fastcall sub_14723EDF0(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rdx
  __int64 i; // r8
  __int64 v6; // rcx
  __m128i v7; // xmm0
  __int64 v9; // [rsp+20h] [rbp-28h] BYREF
  char *v10; // [rsp+28h] [rbp-20h] BYREF
  __m128i v11; // [rsp+30h] [rbp-18h] BYREF

  v9 = a2;
  sub_140357780(&v10, &v9);
  v3 = -1LL;
  do
  {
    ++v3;
  }
  while ( v10[v3] );
  v4 = 0LL;
  for ( i = 0xCBF29CE484222325uLL; v4 < v3; i = 0x100000001B3LL * (v6 ^ i) )
  {
    v6 = (unsigned __int8)v10[v4++];
  }
  v7 = *(__m128i *)sub_147218A50(
                     (_QWORD *)(a1 + 304),
                     &v11,
                     &v10,
                     0xDE5FB9D2630458E9uLL * i
                   + (((unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
  v10 = (char *)&qword_149808ABC + 4;
  v11 = v7;
  DestroyStringObject(&v10);
  if ( v11.m128i_i64[0] == *(_QWORD *)(a1 + 304) + *(_QWORD *)(a1 + 328) )
  {
    return 0LL;
  }
  else
  {
    return _mm_extract_epi64(v11, 1) + 8;
  }
}

// --- End Function: DataCore::LookupDCStructDescByName (0x14723EDF0) ---

// --- Function: sub_14723EEF0 (0x14723EEF0) ---
__int64 __fastcall sub_14723EEF0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v6; // rax
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r9
  __int64 v10; // rcx
  _QWORD *v11; // rax
  __int64 *v12; // rax
  __int64 v14; // rbx
  __int128 v15; // [rsp+20h] [rbp-28h] BYREF
  __int64 v16; // [rsp+30h] [rbp-18h]

  v6 = (_QWORD *)DataCore::LookupDCStructDescByName(a1, a2);
  if ( !v6 )
  {
    return 0LL;
  }
  v7 = v6[1];
  v8 = 0LL;
  v9 = 0LL;
  if ( !v7 )
  {
LABEL_6:
    v16 = 0LL;
    v15 = 0LL;
    DataCore::GetStructFieldPointers(a1, a2, (char **)&v15, 1);
    if ( (__int64)(*((_QWORD *)&v15 + 1) - v15) >> 3 )
    {
      while ( 1 )
      {
        if ( (__int64)(*((_QWORD *)&v15 + 1) - v15) >> 3 <= v8 )
        {
          __debugbreak();
        }
        v12 = *(__int64 **)(v15 + 8 * v8);
        if ( v12[1] == a3 )
        {
          break;
        }
        if ( ++v8 >= (__int64)(*((_QWORD *)&v15 + 1) - v15) >> 3 )
        {
          goto LABEL_11;
        }
      }
      if ( (__int64)(*((_QWORD *)&v15 + 1) - v15) >> 3 <= v8 )
      {
        __debugbreak();
      }
      v14 = *v12;
      if ( (_QWORD)v15 )
      {
        sub_14039EFB0((__int64)&v15, (const void *)v15, (v16 - v15) & 0xFFFFFFFFFFFFFFF8uLL);
      }
      return v14;
    }
LABEL_11:
    if ( (_QWORD)v15 )
    {
      sub_14039EFB0((__int64)&v15, (const void *)v15, (v16 - v15) & 0xFFFFFFFFFFFFFFF8uLL);
    }
    return 0LL;
  }
  v10 = *v6;
  v11 = (_QWORD *)(*v6 + 8LL);
  while ( *v11 != a3 )
  {
    ++v9;
    v11 += 5;
    if ( v9 >= v7 )
    {
      goto LABEL_6;
    }
  }
  return *(_QWORD *)(v10 + 40 * v9);
}

// --- End Function: sub_14723EEF0 (0x14723EEF0) ---

// --- Function: sub_14723F2F0 (0x14723F2F0) ---
char *__fastcall sub_14723F2F0(__int64 a1, __int64 a2, unsigned __int8 *a3, char **a4, char a5)
{
  char *result; // rax
  const void *v6; // rcx
  __int128 v7; // [rsp+30h] [rbp-28h] BYREF
  __int64 v8; // [rsp+40h] [rbp-18h]

  v7 = 0LL;
  v8 = 0LL;
  result = sub_14723F370(a1, a2, a3, a4, (__int64 *)&v7, a5);
  v6 = (const void *)v7;
  if ( (_QWORD)v7 )
  {
    if ( ((v8 - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      v6 = *(const void **)(v7 - 8);
      if ( (unsigned __int64)(v7 - (_QWORD)v6 - 8) > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
    }
    return (char *)free_memory_wrapper(v6);
  }
  return result;
}

// --- End Function: sub_14723F2F0 (0x14723F2F0) ---

// --- Function: sub_14723F370 (0x14723F370) ---
const __m128i *__fastcall sub_14723F370(__int64 a1, __int64 a2, unsigned __int8 *a3, char **a4, __int64 *a5, char a6)
{
  int v7; // ebx
  char **v8; // r12
  unsigned __int8 *v9; // r15
  __int64 v10; // r14
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  __int64 i; // r8
  __int64 v14; // rax
  __m128i v15; // xmm0
  const __m128i *result; // rax
  _QWORD *_XMM2; // rdi
  __int64 *v18; // r13
  __m128i *v19; // rdx
  __int64 v20; // rsi
  __int64 v21; // rsi
  int v22; // edi
  void *v23; // rax
  __int64 v24; // rdi
  unsigned __int64 n0x6400000; // rdi
  char n3; // dl
  _QWORD *v27; // r13
  unsigned __int64 v28; // r12
  __int64 v29; // r15
  __int64 v30; // r14
  __int64 v31; // rsi
  unsigned __int8 (__fastcall *v32)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v33; // rax
  bool v34; // di
  unsigned __int64 v35; // r15
  __int64 v36; // r14
  bool v37; // zf
  __int64 v38; // r14
  __int64 v39; // rsi
  unsigned __int8 (__fastcall *v40)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v41; // rax
  bool v42; // di
  unsigned __int64 v43; // r12
  __int64 v44; // r15
  __int64 v45; // r14
  __int64 v46; // rsi
  unsigned __int8 (__fastcall *v47)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v48; // rax
  bool v49; // di
  _QWORD *v50; // r14
  __int64 v51; // rsi
  unsigned __int8 (__fastcall *v52)(__int64, __int64, unsigned __int8 *); // rdi
  __int64 v53; // rax
  bool v54; // di
  int v55; // [rsp+30h] [rbp-59h]
  __int64 v56; // [rsp+38h] [rbp-51h] BYREF
  char *v57; // [rsp+40h] [rbp-49h] BYREF
  _QWORD *_XMM2_1; // [rsp+48h] [rbp-41h] BYREF
  const void *v59; // [rsp+50h] [rbp-39h]
  const __m128i *v60; // [rsp+58h] [rbp-31h]
  __m128i v61; // [rsp+60h] [rbp-29h] BYREF
  _BYTE v62[8]; // [rsp+70h] [rbp-19h] BYREF
  const void *v63; // [rsp+78h] [rbp-11h]

  v7 = 0;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
  sub_140357780(&v57, &v56);
  v11 = -1;
  do
  {
    ++v11;
  }
  while ( v57[v11] );
  v12 = 0;
  for ( i = 0xCBF29CE484222325uLL; v12 < v11; i = 0x100000001B3LL * (v14 ^ i) )
  {
    v14 = (unsigned __int8)v57[v12++];
  }
  v15 = *(__m128i *)sub_147218A50(
                      (_QWORD *)(a1 + 304),
                      &v61,
                      &v57,
                      0xDE5FB9D2630458E9uLL * i
                    + (((unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
  v57 = (char *)&qword_149808ABC + 4;
  v61 = v15;
  DestroyStringObject(&v57);
  result = (const __m128i *)v61.m128i_i64[0];
  if ( v61.m128i_i64[0] != *(_QWORD *)(a1 + 304) + *(_QWORD *)(a1 + 328) )
  {
    _XMM2 = (_QWORD *)(_mm_extract_epi64(v61, 1) + 8);
    v18 = a5;
    _XMM2_1 = _XMM2;
    result = unknown_libname_247((const __m128i *)*a5, (const __m128i *)a5[1], (unsigned __int64)_XMM2);
    v19 = (__m128i *)a5[1];
    if ( result == v19 )
    {
      if ( v19 == (__m128i *)a5[2] )
      {
        result = (const __m128i *)sub_1402A47D0(a5, v19, &_XMM2_1);
      }
      else
      {
        v19->m128i_i64[0] = (__int64)_XMM2;
        a5[1] += 8;
      }
      v60 = 0;
      if ( _XMM2[1] )
      {
        v20 = 0;
        v61.m128i_i64[0] = 0;
        while ( 1 )
        {
          v21 = *_XMM2 + v20;
          if ( *(_BYTE *)(v21 + 24) == 16 )
          {
            break;
          }
LABEL_44:
          result = (const __m128i *)&v60->m128i_i8[1];
          v20 = v61.m128i_i64[0] + 40;
          v60 = result;
          v61.m128i_i64[0] += 40;
          if ( (unsigned __int64)result >= _XMM2[1] )
          {
            return result;
          }
        }
        v22 = sub_1402DFCB0(v9, -1);
        v55 = v22;
        v23 = 0;
        v59 = 0;
        if ( v9 )
        {
          v24 = -1;
          do
          {
            ++v24;
          }
          while ( v9[v24] );
          n0x6400000 = v24 + 1;
          if ( n0x6400000 )
          {
            v23 = (void *)sub_14739AFC0(n0x6400000, 0);
            v59 = v23;
          }
          memcpy(v23, v9, n0x6400000);
          v22 = v55;
        }
        n3 = *(_BYTE *)(v21 + 25);
        if ( !*(_BYTE *)(v21 + 26) )
        {
          if ( (unsigned __int8)(n3 - 1) <= 1u )
          {
            v50 = *(_QWORD **)(v10 + *(_QWORD *)(v21 + 8));
          }
          else
          {
            v50 = (_QWORD *)(*(_QWORD *)(v21 + 8) + v10);
            if ( n3 == 3 )
            {
              v50 = (_QWORD *)v50[2];
            }
          }
          v56 = (__int64)v50;
          v54 = 0;
          if ( v50 )
          {
            v7 |= 8u;
            if ( *(_DWORD *)(*(__int64 (__fastcall **)(_QWORD *, _BYTE *))(*v50 + 24LL))(v50, v62) == v22
              || (v51 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
                  v52 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v51 + 256LL),
                  v53 = (*(__int64 (__fastcall **)(_QWORD *))(*v50 + 8LL))(v50),
                  v52(v51, v53, v9)) )
            {
              v54 = 1;
            }
          }
          if ( (v7 & 8) != 0 )
          {
            v7 &= ~8u;
            if ( v63 )
            {
              sub_14739AF10(v63);
            }
          }
          if ( v54 )
          {
            sub_1402A4690(v8, &v56);
          }
          if ( a6 && v50 )
          {
            sub_14723F370(a1, (__int64)v50, v9, v8, v18, a6);
          }
          goto LABEL_40;
        }
        v27 = (_QWORD *)(v10 + *(_QWORD *)(v21 + 8));
        if ( (unsigned __int8)(n3 - 1) <= 1u )
        {
          v43 = 0;
          if ( v27[3] )
          {
            v44 = 0;
            do
            {
              v45 = *(_QWORD *)(v44 + v27[2]);
              v56 = v45;
              v49 = 0;
              if ( v45 )
              {
                v7 |= 1u;
                if ( *(_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v45 + 24LL))(v45, v62) == v22
                  || (v46 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
                      v47 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v46
                                                                                                  + 256LL),
                      v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 8LL))(v45),
                      v47(v46, v48, a3)) )
                {
                  v49 = 1;
                }
              }
              if ( (v7 & 1) != 0 )
              {
                v7 &= ~1u;
                if ( v63 )
                {
                  sub_14739AF10(v63);
                }
              }
              if ( v49 )
              {
                sub_1402A4690(a4, &v56);
              }
              if ( a6 && v45 )
              {
                sub_14723F370(a1, v45, a3, a4, a5, a6);
              }
              v22 = v55;
              ++v43;
              v44 += 16;
            }
            while ( v43 < v27[3] );
            goto LABEL_38;
          }
        }
        else
        {
          if ( n3 != 3 )
          {
            v35 = 0;
            if ( !v27[3] )
            {
              v9 = a3;
              v18 = a5;
              goto LABEL_41;
            }
            do
            {
              v36 = v27[5] * v35;
              v37 = v27[2] + v36 == 0;
              v38 = v27[2] + v36;
              v56 = v38;
              v42 = 0;
              if ( !v37 )
              {
                v7 |= 4u;
                if ( *(_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v38 + 24LL))(v38, v62) == v22
                  || (v39 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
                      v40 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v39
                                                                                                  + 256LL),
                      v41 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 8LL))(v38),
                      v40(v39, v41, a3)) )
                {
                  v42 = 1;
                }
              }
              if ( (v7 & 4) != 0 )
              {
                v7 &= ~4u;
                if ( v63 )
                {
                  sub_14739AF10(v63);
                }
              }
              if ( v42 )
              {
                sub_1402A4690(v8, &v56);
              }
              if ( a6 && v38 )
              {
                sub_14723F370(a1, v38, a3, v8, a5, a6);
              }
              v22 = v55;
              ++v35;
            }
            while ( v35 < v27[3] );
            goto LABEL_39;
          }
          v28 = 0;
          if ( v27[3] )
          {
            v29 = 0;
            do
            {
              v30 = *(_QWORD *)(v27[2] + v29 + 16);
              v56 = v30;
              v34 = 0;
              if ( v30 )
              {
                v7 |= 2u;
                if ( *(_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v30 + 24LL))(v30, v62) == v22
                  || (v31 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
                      v32 = *(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)v31
                                                                                                  + 256LL),
                      v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v30 + 8LL))(v30),
                      v32(v31, v33, a3)) )
                {
                  v34 = 1;
                }
              }
              if ( (v7 & 2) != 0 )
              {
                v7 &= ~2u;
                if ( v63 )
                {
                  sub_14739AF10(v63);
                }
              }
              if ( v34 )
              {
                sub_1402A4690(a4, &v56);
              }
              if ( a6 && v30 )
              {
                sub_14723F370(a1, v30, a3, a4, a5, a6);
              }
              v22 = v55;
              ++v28;
              v29 += 24;
            }
            while ( v28 < v27[3] );
LABEL_38:
            v8 = a4;
LABEL_39:
            v18 = a5;
            v9 = a3;
LABEL_40:
            v10 = a2;
LABEL_41:
            if ( v59 )
            {
              sub_14739AF10(v59);
            }
            _XMM2 = _XMM2_1;
            goto LABEL_44;
          }
        }
        v8 = a4;
        v18 = a5;
        goto LABEL_41;
      }
    }
  }
  return result;
}

// --- End Function: sub_14723F370 (0x14723F370) ---

// --- Function: sub_14723FCB0 (0x14723FCB0) ---
__int64 __fastcall sub_14723FCB0(_QWORD *a1, unsigned int *a2)
{
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 *v6; // rdi
  unsigned __int8 **v7; // rbx
  __int64 v9; // [rsp+20h] [rbp-18h] BYREF
  unsigned __int8 *v10[2]; // [rsp+28h] [rbp-10h] BYREF

  if ( !a2 )
  {
    return 0LL;
  }
  v3 = a1[63];
  v4 = *a2;
  if ( *(_DWORD *)(v3 + 4) >= 6u )
  {
    v5 = a1[85];
  }
  else
  {
    v5 = a1[84];
  }
  v9 = v4 + v5;
  sub_140357780(v10, &v9);
  v6 = (__int64 *)a1[36];
  v7 = (unsigned __int8 **)v6[1];
  while ( !*((_BYTE *)v7 + 25) )
  {
    if ( (int)sub_1403DFBE0(v7 + 4, v10) >= 0 )
    {
      v6 = (__int64 *)v7;
      v7 = (unsigned __int8 **)*v7;
    }
    else
    {
      v7 = (unsigned __int8 **)v7[2];
    }
  }
  if ( *((_BYTE *)v6 + 25) || (int)sub_1403DFBE0(v10, v6 + 4) < 0 )
  {
    v6 = (__int64 *)a1[36];
  }
  v10[0] = (unsigned __int8 *)&qword_149808ABC + 4;
  DestroyStringObject(v10);
  if ( v6 == (__int64 *)a1[36] )
  {
    return 0LL;
  }
  else
  {
    return v6[5];
  }
}

// --- End Function: sub_14723FCB0 (0x14723FCB0) ---

// --- Function: sub_147240310 (0x147240310) ---
char __fastcall sub_147240310(__int64 a1, const char *s2, const char *s1)
{
  _QWORD *v4; // rdi
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 i; // r8
  __int64 v9; // rax
  const char *s2_1; // [rsp+20h] [rbp-48h] BYREF
  char *v12; // [rsp+28h] [rbp-40h] BYREF
  __m128i v13; // [rsp+30h] [rbp-38h]
  _QWORD v14[5]; // [rsp+40h] [rbp-28h] BYREF

  v4 = (_QWORD *)(a1 + 304);
  while ( 1 )
  {
    s2_1 = s2;
    sub_140357780(&v12, &s2_1);
    v6 = -1;
    do
    {
      ++v6;
    }
    while ( v12[v6] );
    v7 = 0;
    for ( i = 0xCBF29CE484222325uLL; v7 < v6; i = 0x100000001B3LL * (v9 ^ i) )
    {
      v9 = (unsigned __int8)v12[v7++];
    }
    v13 = *(__m128i *)sub_147218A50(
                        v4,
                        v14,
                        &v12,
                        0xDE5FB9D2630458E9uLL * i
                      + (((unsigned __int64)i * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
    v12 = (char *)&qword_149808ABC + 4;
    DestroyStringObject(&v12);
    if ( v13.m128i_i64[0] == *v4 + v4[3] )
    {
      break;
    }
    s2 = *(const char **)(_mm_extract_epi64(v13, 1) + 32);
    if ( !s2 )
    {
      break;
    }
    if ( !strcmp(s1, s2) )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_147240310 (0x147240310) ---

// --- Function: sub_147242730 (0x147242730) ---
__int64 __fastcall sub_147242730(__int64 *a1)
{
  const void **v2; // rdx
  const void **v3; // rdi
  unsigned __int8 v4; // bp
  __int64 v5; // rsi
  __int64 v6; // rsi
  void *v7; // rax
  __int64 v8; // r8
  __int64 v9; // rbx
  void *v11[2]; // [rsp+30h] [rbp-68h] BYREF
  int n10496; // [rsp+40h] [rbp-58h] BYREF
  __int64 v13; // [rsp+44h] [rbp-54h]
  int v14; // [rsp+4Ch] [rbp-4Ch]
  __int64 v15; // [rsp+50h] [rbp-48h]
  unsigned __int64 v16; // [rsp+58h] [rbp-40h]
  __int64 v17; // [rsp+60h] [rbp-38h]
  __int64 v18; // [rsp+68h] [rbp-30h]

  n10496 = 10496;
  v13 = 0;
  v14 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v15 = 1;
  qword_149818EA0(
    &n10496,
    0,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  v2 = (const void **)&unk_1512CA590;
  if ( dword_1497CD7B8 )
  {
    v2 = (const void **)&unk_1512CA5A0;
  }
  sub_1403577C0(v11, v2);
  v3 = (const void **)(a1 + 50);
  v4 = sub_147242B20((__int64)a1, (char **)v11);
  v5 = a1[51];
  if ( v5 != a1[52] )
  {
    if ( *v3 == (const void *)v5 )
    {
      sub_1402B02C0(v3);
    }
    else
    {
      v6 = (v5 - (__int64)*v3) >> 3;
      v7 = (void *)sub_1402DFE40((__int64)(a1 + 50), v6);
      v8 = a1[51];
      v9 = (__int64)v7;
      memmove(v7, *v3, v8 - (_QWORD)*v3);
      sub_1402FD6B0(v3, v9, v6, v6);
    }
  }
  DestroyStringObject(v11);
  v16 = __rdtsc();
  qword_149818EA8(&n10496);
  return v4;
}

// --- End Function: sub_147242730 (0x147242730) ---

// --- Function: sub_147242B20 (0x147242B20) ---
__int64 __fastcall sub_147242B20(__int64 rcx0, char **rdx0)
{
  __int128 v3; // xmm6
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // r12
  int a6; // ebx
  __int64 *ThreadLogContextSlot; // rax
  unsigned __int8 v11; // bl
  _QWORD *v12; // rax
  _QWORD *v13; // rdx
  int v14; // ebx
  __int64 *ThreadLogContextSlot_1; // rax
  const char *p_Failed_to_read_DCB__file_is_too_small; // r9
  __int64 v17; // rax
  int v18; // ebx
  __int64 v19; // rcx
  int v20; // edx
  __int64 *ThreadLogContextSlot_2; // rax
  unsigned __int64 v22; // rcx
  char v23; // di
  unsigned int v24; // edi
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rbx
  __int64 v28; // rax
  unsigned int v29; // eax
  unsigned int v30; // esi
  __int64 v31; // rax
  unsigned __int64 v32; // kr00_8
  __int64 v33; // rax
  __int64 v34; // rbx
  __int64 v35; // rax
  __int64 v36; // rax
  unsigned __int64 v37; // rcx
  unsigned int v38; // esi
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rbx
  __int64 v42; // rax
  __int64 v43; // rax
  unsigned __int64 v44; // rcx
  unsigned int v45; // esi
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rbx
  __int64 v49; // rax
  __int64 v50; // rax
  unsigned __int64 v51; // rcx
  unsigned int v52; // esi
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rbx
  __int64 v56; // rax
  __int64 v57; // rcx
  __int64 v58; // rax
  __int64 v59; // rcx
  __int64 v60; // rax
  unsigned __int64 v61; // rcx
  __int64 v62; // rax
  __int64 v63; // rax
  __int64 v64; // rcx
  __int64 v65; // rax
  unsigned __int64 v66; // rcx
  __int64 v67; // rax
  __int64 v68; // rax
  __int64 v69; // rcx
  __int64 v70; // rax
  unsigned __int64 v71; // rcx
  __int64 v72; // rax
  __int64 v73; // rax
  __int64 v74; // rcx
  __int64 v75; // rcx
  __int64 v76; // rax
  __int64 v77; // rcx
  __int64 v78; // rax
  unsigned __int64 v79; // rcx
  __int64 v80; // rax
  __int64 v81; // rax
  __int64 v82; // rcx
  __int64 v83; // rax
  unsigned __int64 v84; // rcx
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // rcx
  __int64 v88; // rax
  unsigned __int64 v89; // rcx
  __int64 v90; // rax
  __int64 v91; // rax
  __int64 v92; // rcx
  __int64 v93; // rcx
  __int64 v94; // rax
  __int64 v95; // rcx
  __int64 v96; // rax
  unsigned __int64 v97; // rcx
  __int64 v98; // rax
  __int64 v99; // rax
  __int64 v100; // rcx
  __int64 v101; // rax
  char v102; // si
  unsigned __int64 v103; // rcx
  __int64 v104; // rax
  __int64 v105; // rax
  __int64 v106; // rcx
  __int64 v107; // rbx
  __int64 v108; // rax
  unsigned __int64 v109; // rcx
  __int64 v110; // rax
  __int64 v111; // rax
  __int64 v112; // rcx
  __int64 v113; // rax
  unsigned __int64 v114; // rcx
  __int64 v115; // rax
  __int64 v116; // rax
  __int64 v117; // rcx
  __int64 v118; // rax
  unsigned __int64 v119; // rcx
  __int64 v120; // rax
  __int64 v121; // rax
  __int64 v122; // rcx
  __int64 v123; // rax
  unsigned __int64 v124; // rcx
  __int64 v125; // rax
  __int64 v126; // rax
  __int64 v127; // rcx
  __int64 v128; // rax
  unsigned __int64 v129; // rcx
  unsigned int v130; // esi
  __int64 v131; // rax
  __int64 v132; // rax
  __int64 v133; // rbx
  __int64 v134; // rax
  __int64 v135; // rax
  unsigned __int64 v136; // rcx
  unsigned int v137; // esi
  __int64 v138; // rax
  __int64 v139; // rax
  __int64 v140; // rbx
  __int64 v141; // rax
  __int64 v142; // rax
  unsigned __int64 v143; // rcx
  unsigned int v144; // esi
  __int64 v145; // rax
  __int64 v146; // rax
  __int64 v147; // rbx
  __int64 v148; // rax
  __int64 v149; // rax
  unsigned __int64 v150; // rcx
  __int64 v151; // rax
  __int64 v152; // rax
  __int64 v153; // rcx
  __int64 v154; // rcx
  __int64 v155; // rax
  __int64 v156; // rcx
  unsigned __int64 n0x6400000; // rcx
  __int64 v158; // rax
  __int64 v159; // rcx
  _DWORD *v160; // rdx
  unsigned int v161; // r12d
  __int64 v162; // rdi
  __int64 v163; // rsi
  __int64 v164; // rcx
  _QWORD *v165; // rbx
  unsigned __int64 v166; // rcx
  __int64 v167; // rdx
  unsigned __int64 v168; // r8
  __int64 v169; // rax
  __int64 v170; // rbx
  bool v171; // zf
  _QWORD *v172; // rbx
  __int64 v173; // r12
  unsigned int *v174; // rsi
  unsigned __int64 n0x6400000_1; // r13
  bool v176; // cf
  __int64 v177; // rcx
  __int64 v178; // rax
  unsigned __int64 v179; // rcx
  __int64 v180; // rdx
  unsigned __int64 m; // r8
  __int64 v182; // rax
  __int64 v183; // rdi
  __int64 v184; // rbx
  __int64 v185; // rax
  unsigned int v186; // ebx
  _BYTE *v187; // rdx
  unsigned int *v188; // rax
  int v189; // ebx
  __int64 *ThreadLogContextSlot_3; // rax
  const char *p_DCB_file_is_smaller_than_expected; // r9
  _QWORD *v192; // r12
  unsigned __int64 n0x6400000_3; // rdi
  __int64 v194; // rbx
  __int64 v195; // r8
  __int64 v196; // r9
  __int64 v197; // rsi
  _BYTE *v198; // r13
  char *v199; // rsi
  __int64 v200; // rax
  unsigned __int64 v201; // rcx
  __int64 v202; // rdx
  unsigned __int64 v203; // r8
  __int64 v204; // rax
  __int64 v205; // r12
  __int64 v206; // r12
  __int64 v207; // rdi
  void **StringObjectFromString; // rax
  __int128 v209; // xmm0
  void **v210; // rbx
  __int128 v211; // xmm6
  __int64 v212; // rax
  __int64 *v213; // r13
  unsigned __int64 v214; // rdx
  __int64 v215; // r8
  unsigned __int64 v216; // r9
  __int64 v217; // rcx
  unsigned __int64 v218; // r12
  __int64 v219; // rax
  __int64 v220; // rdi
  _QWORD *v221; // rbx
  char v222; // r12
  __int64 v223; // rax
  unsigned __int64 v224; // rcx
  unsigned __int64 *v225; // rdi
  int v226; // r9d
  int v227; // r8d
  int v228; // eax
  int v229; // ebx
  unsigned __int64 v230; // rdx
  unsigned __int64 v231; // rax
  unsigned __int64 v232; // r8
  __int64 v233; // r9
  __int64 v234; // rdx
  __int64 v235; // rdx
  _OWORD *v236; // rax
  unsigned int i; // edi
  unsigned int *v238; // rbx
  __int64 v239; // rdx
  __int64 v240; // rdx
  __int64 v241; // r8
  unsigned int j; // ebx
  unsigned int *v243; // rdi
  __int64 v244; // rdx
  __int64 v245; // rdx
  __int64 v246; // r8
  char *v247; // rbx
  __int64 *v248; // rdi
  __int128 _XMM4; // xmm1
  __int64 v251; // rcx
  __int64 v252; // rdx
  __int64 v253; // r8
  unsigned int v254; // r8d
  __int64 v255; // rcx
  __int64 v256; // rdx
  __int64 v257; // rax
  __int64 v258; // rdx
  __int64 v259; // r8
  __int128 _XMM4_1; // xmm1
  __int64 v262; // rcx
  _QWORD *v263; // rax
  __int64 *v266; // rax
  _QWORD *v267; // rdi
  _QWORD *v268; // rbx
  __int64 v269; // rax
  _QWORD *v270; // rax
  __int64 v274; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v275; // [rsp+68h] [rbp-98h] BYREF
  __int64 v276; // [rsp+70h] [rbp-90h] BYREF
  char *v277; // [rsp+78h] [rbp-88h] BYREF
  __int64 a1[2]; // [rsp+80h] [rbp-80h] BYREF
  const void *ptr_to_free; // [rsp+90h] [rbp-70h]
  __int128 a7; // [rsp+98h] [rbp-68h] BYREF
  int a4[2]; // [rsp+A8h] [rbp-58h] BYREF
  __int64 v282; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 n0x6400000_2; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v284; // [rsp+C0h] [rbp-40h]
  __int64 v285; // [rsp+C8h] [rbp-38h] BYREF
  __int64 k; // [rsp+D0h] [rbp-30h] BYREF
  char v287[8]; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v288; // [rsp+E0h] [rbp-20h]
  __int64 a2[2]; // [rsp+F0h] [rbp-10h] BYREF
  __int128 v290; // [rsp+110h] [rbp+10h]

  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_14981D260 + 72LL))(qword_14981D260, &k);
  initializeEmptyStringStructure(&v282);
  v6 = sub_1403E2EC0(rdx0);
  v7 = sub_1403DD500((__int64)"Data/");
  sub_1403E4500((void **)&v282, v7 + v6);
  sub_140380E90((void **)&v282, "Data/");
  sub_140380E40((void **)&v282, rdx0);
  v284 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, _QWORD))(*(_QWORD *)qword_14981D238 + 312LL))(
           qword_14981D238,
           v282,
           "rb",
           0);
  v8 = v284;
  if ( !v284 )
  {
    v274 = 0x1C000000CELL;
    a2[0] = (__int64)&v274;
    a2[1] = (__int64)&v275;
    a6 = invokeGlobalCallbackAndMaskStatusBits(2, (__int64)a2, (__int64)"DataCore Load Failure", "Failed to find $$");
    if ( (a6 & 0xFFFFF) != 0 )
    {
      a1[1] = v282;
      a1[0] = 0;
      ptr_to_free = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v274 = 0x1C000000CELL;
      a2[0] = (__int64)&v274;
      a2[1] = (__int64)&v275;
      a7 = 0;
      sub_14043FDE0(
        2,
        (__int64)a2,
        "DataCore Load Failure",
        (__int64)"Failed to find $$",
        1,
        a6,
        &a7,
        0,
        (__int64)ThreadLogContextSlot,
        a1);
      free_memory_wrapper(ptr_to_free);
    }
    *(_DWORD *)(rcx0 + 720) = 0;
    v11 = 0;
    goto LABEL_262;
  }
  *(_DWORD *)(rcx0 + 720) = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)qword_14981D238 + 720LL))(
                              qword_14981D238,
                              v282,
                              0);
  v12 = (_QWORD *)sub_1402A1E30(0x78u);
  v13 = v12;
  if ( v12 )
  {
    v12[2] = 0;
    v12[3] = 0;
    v12[4] = 0;
    v12[5] = 0;
    v12[6] = 0;
    v12[7] = 0;
    v12[8] = 0;
    v12[9] = 0;
    v12[10] = 0;
    v12[11] = 0;
    v12[12] = 0;
    v12[13] = 0;
    v12[14] = 0;
  }
  else
  {
    v13 = 0;
  }
  *(_QWORD *)(rcx0 + 504) = v13;
  if ( (*(__int64 (__fastcall **)(__int64, _QWORD *, __int64))(*(_QWORD *)qword_14981D238 + 336LL))(
         qword_14981D238,
         v13,
         120) != 1 )
  {
    v274 = 0x1C000000CELL;
    a2[0] = (__int64)&v274;
    a2[1] = (__int64)&v275;
    v14 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)a2,
            (__int64)"DataCore Load Failure",
            "Failed to read header, DCB too small");
    if ( (v14 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      p_Failed_to_read_DCB__file_is_too_small = "Failed to read header, DCB too small";
LABEL_136:
      a2[0] = (__int64)&v274;
      a2[1] = (__int64)&v275;
      a7 = 0;
      v274 = 0x1C000000CELL;
      submitTraceContext(
        2,
        (__int64)a2,
        "DataCore Load Failure",
        (__int64)p_Failed_to_read_DCB__file_is_too_small,
        1,
        v14,
        &a7,
        0,
        (__int64)ThreadLogContextSlot_1);
      goto LABEL_137;
    }
    goto LABEL_137;
  }
  v17 = *(_QWORD *)(rcx0 + 504);
  if ( *(_DWORD *)(v17 + 4) < 5u )
  {
    v274 = 0x1C000000CELL;
    a2[0] = (__int64)&v274;
    a2[1] = (__int64)&v275;
    v18 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)a2,
            (__int64)"DataCore Load Failure",
            "Unsupported version DCB:$$ Game:$$");
    if ( (v18 & 0xFFFFF) != 0 )
    {
      v19 = *(_QWORD *)(rcx0 + 504);
      a2[0] = 0;
      LODWORD(a2[1]) = 5;
      v20 = *(_DWORD *)(v19 + 4);
      a1[0] = 0;
      LODWORD(a1[1]) = v20;
      ThreadLogContextSlot_2 = getThreadLogContextSlot();
      v274 = 0x1C000000CELL;
      v276 = (__int64)&v274;
      v277 = (char *)&v275;
      a7 = 0;
      sub_1469A4AA0(
        2,
        (__int64)&v276,
        "DataCore Load Failure",
        (__int64)"Unsupported version DCB:$$ Game:$$",
        1,
        v18,
        &a7,
        0,
        (__int64)ThreadLogContextSlot_2,
        a1,
        a2);
    }
    goto LABEL_137;
  }
  v22 = *(unsigned int *)(v17 + 16);
  v23 = 1;
  if ( (_DWORD)v22 )
  {
    v24 = *(_DWORD *)(v17 + 16);
    v25 = 16LL * v24;
    if ( !is_mul_ok(v22, 0x10u) )
    {
      v25 = -1;
    }
    v26 = qword_14981CFB8(v25, 0);
    v27 = v26;
    if ( v26 )
    {
      sub_1402B5F60(v26, 16, v24, sub_14721B440);
    }
    else
    {
      v27 = 0;
    }
    v28 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 512) = v27;
    v23 = sub_1472390E0(v27, 16, *(unsigned int *)(v28 + 16), v8);
  }
  v29 = *(_DWORD *)(*(_QWORD *)(rcx0 + 504) + 20LL);
  if ( v29 )
  {
    v30 = *(_DWORD *)(*(_QWORD *)(rcx0 + 504) + 20LL);
    v32 = v29;
    v31 = 12LL * v29;
    if ( !is_mul_ok(v32, 0xCu) )
    {
      v31 = -1;
    }
    v33 = qword_14981CFB8(v31, 0);
    v34 = v33;
    if ( v33 )
    {
      sub_1402B5F60(v33, 12, v30, std::_Yarn<wchar_t>::_Yarn<wchar_t>);
    }
    else
    {
      v34 = 0;
    }
    v35 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 520) = v34;
    v23 &= sub_1472390E0(v34, 12, *(unsigned int *)(v35 + 20), v8);
  }
  v36 = *(_QWORD *)(rcx0 + 504);
  v37 = *(unsigned int *)(v36 + 24);
  if ( (_DWORD)v37 )
  {
    v38 = *(_DWORD *)(v36 + 24);
    v39 = 8LL * v38;
    if ( !is_mul_ok(v37, 8u) )
    {
      v39 = -1;
    }
    v40 = qword_14981CFB8(v39, 0);
    v41 = v40;
    if ( v40 )
    {
      sub_1402B5F60(v40, 8, v38, (__int64 (__fastcall *)(__int64))sub_1405D5BC0);
    }
    else
    {
      v41 = 0;
    }
    v42 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 528) = v41;
    v23 &= sub_1472390E0(v41, 8, *(unsigned int *)(v42 + 24), v8);
  }
  v43 = *(_QWORD *)(rcx0 + 504);
  v44 = *(unsigned int *)(v43 + 28);
  if ( (_DWORD)v44 )
  {
    v45 = *(_DWORD *)(v43 + 28);
    v46 = 8LL * v45;
    if ( !is_mul_ok(v44, 8u) )
    {
      v46 = -1;
    }
    v47 = qword_14981CFB8(v46, 0);
    v48 = v47;
    if ( v47 )
    {
      sub_1402B5F60(v47, 8, v45, (__int64 (__fastcall *)(__int64))sub_1405D5BC0);
    }
    else
    {
      v48 = 0;
    }
    v49 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 544) = v48;
    v23 &= sub_1472390E0(v48, 8, *(unsigned int *)(v49 + 28), v8);
  }
  v50 = *(_QWORD *)(rcx0 + 504);
  v51 = *(unsigned int *)(v50 + 32);
  if ( (_DWORD)v51 )
  {
    v52 = *(_DWORD *)(v50 + 32);
    v53 = 32LL * v52;
    if ( !is_mul_ok(v51, 0x20u) )
    {
      v53 = -1;
    }
    v54 = qword_14981CFB8(v53, 0);
    v55 = v54;
    if ( v54 )
    {
      sub_1402B5F60(v54, 32, v52, (__int64 (__fastcall *)(__int64))sub_14721B450);
    }
    else
    {
      v55 = 0;
    }
    v56 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 536) = v55;
    v23 &= sub_1472390E0(v55, 32, *(unsigned int *)(v56 + 32), v8);
  }
  v57 = *(unsigned int *)(*(_QWORD *)(rcx0 + 504) + 40LL);
  if ( (_DWORD)v57 )
  {
    v58 = qword_14981CFB8(v57, 0);
    v59 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 560) = v58;
    v23 &= sub_1472390E0(v58, 1, *(unsigned int *)(v59 + 40), v8);
  }
  v60 = *(_QWORD *)(rcx0 + 504);
  v61 = *(unsigned int *)(v60 + 44);
  if ( (_DWORD)v61 )
  {
    v62 = 2LL * *(unsigned int *)(v60 + 44);
    if ( !is_mul_ok(v61, 2u) )
    {
      v62 = -1;
    }
    v63 = qword_14981CFB8(v62, 0);
    v64 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 568) = v63;
    v23 &= sub_1472390E0(v63, 2, *(unsigned int *)(v64 + 44), v8);
  }
  v65 = *(_QWORD *)(rcx0 + 504);
  v66 = *(unsigned int *)(v65 + 48);
  if ( (_DWORD)v66 )
  {
    v67 = 4LL * *(unsigned int *)(v65 + 48);
    if ( !is_mul_ok(v66, 4u) )
    {
      v67 = -1;
    }
    v68 = qword_14981CFB8(v67, 0);
    v69 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 576) = v68;
    v23 &= sub_1472390E0(v68, 4, *(unsigned int *)(v69 + 48), v8);
  }
  v70 = *(_QWORD *)(rcx0 + 504);
  v71 = *(unsigned int *)(v70 + 52);
  if ( (_DWORD)v71 )
  {
    v72 = 8LL * *(unsigned int *)(v70 + 52);
    if ( !is_mul_ok(v71, 8u) )
    {
      v72 = -1;
    }
    v73 = qword_14981CFB8(v72, 0);
    v74 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 584) = v73;
    v23 &= sub_1472390E0(v73, 8, *(unsigned int *)(v74 + 52), v8);
  }
  v75 = *(unsigned int *)(*(_QWORD *)(rcx0 + 504) + 56LL);
  if ( (_DWORD)v75 )
  {
    v76 = qword_14981CFB8(v75, 0);
    v77 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 592) = v76;
    v23 &= sub_1472390E0(v76, 1, *(unsigned int *)(v77 + 56), v8);
  }
  v78 = *(_QWORD *)(rcx0 + 504);
  v79 = *(unsigned int *)(v78 + 60);
  if ( (_DWORD)v79 )
  {
    v80 = 2LL * *(unsigned int *)(v78 + 60);
    if ( !is_mul_ok(v79, 2u) )
    {
      v80 = -1;
    }
    v81 = qword_14981CFB8(v80, 0);
    v82 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 600) = v81;
    v23 &= sub_1472390E0(v81, 2, *(unsigned int *)(v82 + 60), v8);
  }
  v83 = *(_QWORD *)(rcx0 + 504);
  v84 = *(unsigned int *)(v83 + 64);
  if ( (_DWORD)v84 )
  {
    v85 = 4LL * *(unsigned int *)(v83 + 64);
    if ( !is_mul_ok(v84, 4u) )
    {
      v85 = -1;
    }
    v86 = qword_14981CFB8(v85, 0);
    v87 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 608) = v86;
    v23 &= sub_1472390E0(v86, 4, *(unsigned int *)(v87 + 64), v8);
  }
  v88 = *(_QWORD *)(rcx0 + 504);
  v89 = *(unsigned int *)(v88 + 68);
  if ( (_DWORD)v89 )
  {
    v90 = 8LL * *(unsigned int *)(v88 + 68);
    if ( !is_mul_ok(v89, 8u) )
    {
      v90 = -1;
    }
    v91 = qword_14981CFB8(v90, 0);
    v92 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 616) = v91;
    v23 &= sub_1472390E0(v91, 8, *(unsigned int *)(v92 + 68), v8);
  }
  v93 = *(unsigned int *)(*(_QWORD *)(rcx0 + 504) + 36LL);
  if ( (_DWORD)v93 )
  {
    v94 = qword_14981CFB8(v93, 0);
    v95 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 552) = v94;
    v23 &= sub_1472390E0(v94, 1, *(unsigned int *)(v95 + 36), v8);
  }
  v96 = *(_QWORD *)(rcx0 + 504);
  v97 = *(unsigned int *)(v96 + 72);
  if ( (_DWORD)v97 )
  {
    v98 = 4LL * *(unsigned int *)(v96 + 72);
    if ( !is_mul_ok(v97, 4u) )
    {
      v98 = -1;
    }
    v99 = qword_14981CFB8(v98, 0);
    v100 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 624) = v99;
    v23 &= sub_1472390E0(v99, 4, *(unsigned int *)(v100 + 72), v8);
  }
  v101 = *(_QWORD *)(rcx0 + 504);
  v102 = v23;
  v103 = *(unsigned int *)(v101 + 76);
  if ( (_DWORD)v103 )
  {
    v104 = 8LL * *(unsigned int *)(v101 + 76);
    if ( !is_mul_ok(v103, 8u) )
    {
      v104 = -1;
    }
    v105 = qword_14981CFB8(v104, 0);
    v106 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 632) = v105;
    v107 = *(unsigned int *)(v106 + 76);
    v23 = 0;
    if ( (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64, const char *))(*(_QWORD *)qword_14981D238
                                                                                             + 336LL))(
           qword_14981D238,
           v105,
           8,
           (unsigned int)v107,
           v8,
           "FReadRawWithLog") == v107 )
    {
      v23 = v102;
    }
  }
  v108 = *(_QWORD *)(rcx0 + 504);
  v109 = *(unsigned int *)(v108 + 80);
  if ( (_DWORD)v109 )
  {
    v110 = 16LL * *(unsigned int *)(v108 + 80);
    if ( !is_mul_ok(v109, 0x10u) )
    {
      v110 = -1;
    }
    v111 = qword_14981CFB8(v110, 0);
    v112 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 640) = v111;
    v23 &= sub_1472390E0(v111, 16, *(unsigned int *)(v112 + 80), v8);
  }
  v113 = *(_QWORD *)(rcx0 + 504);
  v114 = *(unsigned int *)(v113 + 84);
  if ( (_DWORD)v114 )
  {
    v115 = 4LL * *(unsigned int *)(v113 + 84);
    if ( !is_mul_ok(v114, 4u) )
    {
      v115 = -1;
    }
    v116 = qword_14981CFB8(v115, 0);
    v117 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 656) = v116;
    v23 &= sub_1472390E0(v116, 4, *(unsigned int *)(v117 + 84), v8);
  }
  v118 = *(_QWORD *)(rcx0 + 504);
  v119 = *(unsigned int *)(v118 + 88);
  if ( (_DWORD)v119 )
  {
    v120 = 4LL * *(unsigned int *)(v118 + 88);
    if ( !is_mul_ok(v119, 4u) )
    {
      v120 = -1;
    }
    v121 = qword_14981CFB8(v120, 0);
    v122 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 664) = v121;
    v23 &= sub_1472390E0(v121, 4, *(unsigned int *)(v122 + 88), v8);
  }
  v123 = *(_QWORD *)(rcx0 + 504);
  v124 = *(unsigned int *)(v123 + 92);
  if ( (_DWORD)v124 )
  {
    v125 = 4LL * *(unsigned int *)(v123 + 92);
    if ( !is_mul_ok(v124, 4u) )
    {
      v125 = -1;
    }
    v126 = qword_14981CFB8(v125, 0);
    v127 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 648) = v126;
    v23 &= sub_1472390E0(v126, 4, *(unsigned int *)(v127 + 92), v8);
  }
  v128 = *(_QWORD *)(rcx0 + 504);
  v129 = *(unsigned int *)(v128 + 96);
  if ( (_DWORD)v129 )
  {
    v130 = *(_DWORD *)(v128 + 96);
    v131 = 8LL * v130;
    if ( !is_mul_ok(v129, 8u) )
    {
      v131 = -1;
    }
    v132 = qword_14981CFB8(v131, 0);
    v133 = v132;
    if ( v132 )
    {
      sub_1402B5F60(v132, 8, v130, (__int64 (__fastcall *)(__int64))sub_1405D5BC0);
    }
    else
    {
      v133 = 0;
    }
    v134 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 688) = v133;
    v23 &= sub_1472390E0(v133, 8, *(unsigned int *)(v134 + 96), v8);
  }
  v135 = *(_QWORD *)(rcx0 + 504);
  v136 = *(unsigned int *)(v135 + 100);
  if ( (_DWORD)v136 )
  {
    v137 = *(_DWORD *)(v135 + 100);
    v138 = 8LL * v137;
    if ( !is_mul_ok(v136, 8u) )
    {
      v138 = -1;
    }
    v139 = qword_14981CFB8(v138, 0);
    v140 = v139;
    if ( v139 )
    {
      sub_1402B5F60(v139, 8, v137, (__int64 (__fastcall *)(__int64))sub_1405D5BC0);
    }
    else
    {
      v140 = 0;
    }
    v141 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 696) = v140;
    v23 &= sub_1472390E0(v140, 8, *(unsigned int *)(v141 + 100), v8);
  }
  v142 = *(_QWORD *)(rcx0 + 504);
  v143 = *(unsigned int *)(v142 + 104);
  if ( (_DWORD)v143 )
  {
    v144 = *(_DWORD *)(v142 + 104);
    v145 = 20LL * v144;
    if ( !is_mul_ok(v143, 0x14u) )
    {
      v145 = -1;
    }
    v146 = qword_14981CFB8(v145, 0);
    v147 = v146;
    if ( v146 )
    {
      sub_1402B5F60(v146, 20, v144, sub_14721B420);
    }
    else
    {
      v147 = 0;
    }
    v148 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 704) = v147;
    v23 &= sub_1472390E0(v147, 20, *(unsigned int *)(v148 + 104), v8);
  }
  v149 = *(_QWORD *)(rcx0 + 504);
  v150 = *(unsigned int *)(v149 + 108);
  if ( (_DWORD)v150 )
  {
    v151 = 4LL * *(unsigned int *)(v149 + 108);
    if ( !is_mul_ok(v150, 4u) )
    {
      v151 = -1;
    }
    v152 = qword_14981CFB8(v151, 0);
    v153 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 712) = v152;
    v23 &= sub_1472390E0(v152, 4, *(unsigned int *)(v153 + 108), v8);
  }
  v154 = *(unsigned int *)(*(_QWORD *)(rcx0 + 504) + 112LL);
  if ( (_DWORD)v154 )
  {
    v155 = qword_14981CFB8(v154, 0);
    v156 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 672) = v155;
    v23 &= sub_1472390E0(v155, 1, *(unsigned int *)(v156 + 112), v8);
  }
  n0x6400000 = *(unsigned int *)(*(_QWORD *)(rcx0 + 504) + 116LL);
  if ( (_DWORD)n0x6400000 )
  {
    v158 = sub_1402A1E30(n0x6400000);
    v159 = *(_QWORD *)(rcx0 + 504);
    *(_QWORD *)(rcx0 + 680) = v158;
    v23 &= sub_1472390E0(v158, 1, *(unsigned int *)(v159 + 116), v8);
  }
  if ( !v23 )
  {
    v274 = 0x1C000000CELL;
    a2[0] = (__int64)&v274;
    a2[1] = (__int64)&v275;
    v14 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)a2,
            (__int64)"DataCore Load Failure",
            "Failed to read DCB, file is too small");
    if ( (v14 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      p_Failed_to_read_DCB__file_is_too_small = "Failed to read DCB, file is too small";
      goto LABEL_136;
    }
LABEL_137:
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_14981D238 + 464LL))(qword_14981D238, v8);
    v11 = 0;
    goto LABEL_262;
  }
  v160 = *(_DWORD **)(rcx0 + 504);
  v161 = 0;
  if ( v160[7] )
  {
    v162 = 0;
    do
    {
      v163 = *(_QWORD *)(rcx0 + 544);
      if ( *(_DWORD *)(v162 + v163) )
      {
        if ( v160[1] >= 6u )
        {
          v164 = *(_QWORD *)(rcx0 + 680);
        }
        else
        {
          v164 = *(_QWORD *)(rcx0 + 672);
        }
        v276 = *(unsigned int *)(*(_QWORD *)(rcx0 + 512) + 16LL * *(unsigned __int16 *)(v162 + v163 + 4)) + v164;
        v165 = (_QWORD *)(rcx0 + 304);
        sub_140357780(&v277, &v276);
        v166 = -1;
        do
        {
          ++v166;
        }
        while ( v277[v166] );
        v167 = 0xCBF29CE484222325uLL;
        v168 = 0;
        if ( v166 )
        {
          do
          {
            v169 = (unsigned __int8)v277[v168++];
            v167 = 0x100000001B3LL * (v169 ^ v167);
          }
          while ( v168 < v166 );
          v165 = (_QWORD *)(rcx0 + 304);
        }
        sub_147218A50(v165, a2, &v277, (__PAIR128__(v167, v167) * 0xDE5FB9D2630458E9uLL) >> 64);
        v277 = (char *)&qword_149808ABC + 4;
        DestroyStringObject(&v277);
        if ( a2[0] != *v165 + v165[3] )
        {
          v170 = a2[1];
          *(_QWORD *)(v170 + 56) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(a2[1] + 24))(
                                     *(_QWORD *)(a2[1] + 24),
                                     *(unsigned int *)(v162 + v163));
        }
      }
      v160 = *(_DWORD **)(rcx0 + 504);
      ++v161;
      v162 += 8;
    }
    while ( v161 < v160[7] );
  }
  v171 = v160[7] == 0;
  a4[0] = 0;
  if ( v171 )
  {
LABEL_183:
    v171 = v160[8] == 0;
    LODWORD(v275) = 0;
    if ( !v171 )
    {
      v192 = (_QWORD *)(rcx0 + 304);
      n0x6400000_2 = 0;
      n0x6400000_3 = 0;
      v290 = v3;
      while ( 1 )
      {
        v194 = *(_QWORD *)(rcx0 + 536);
        v195 = *(_QWORD *)(rcx0 + 672);
        v196 = *(unsigned int *)(n0x6400000_3 + v194);
        v197 = *(unsigned int *)(*(_QWORD *)(rcx0 + 512) + 16LL * *(unsigned int *)(n0x6400000_3 + v194 + 8));
        if ( v160[1] >= 6u )
        {
          v198 = (_BYTE *)(v196 + *(_QWORD *)(rcx0 + 680));
          v199 = (char *)(*(_QWORD *)(rcx0 + 680) + v197);
        }
        else
        {
          v198 = (_BYTE *)(v196 + v195);
          v199 = (char *)(v195 + v197);
        }
        v200 = v195 + *(unsigned int *)(n0x6400000_3 + v194 + 4);
        a1[0] = (__int64)v199;
        *(_QWORD *)a4 = v200;
        sub_140357780(&a1[1], a1);
        v201 = -1;
        do
        {
          ++v201;
        }
        while ( *(_BYTE *)(a1[1] + v201) );
        v202 = 0xCBF29CE484222325uLL;
        v203 = 0;
        if ( v201 )
        {
          do
          {
            v204 = *(unsigned __int8 *)(v203 + a1[1]);
            ++v203;
            v202 = 0x100000001B3LL * (v204 ^ v202);
          }
          while ( v203 < v201 );
          v192 = (_QWORD *)(rcx0 + 304);
        }
        sub_147218A50(v192, &a7, &a1[1], (__PAIR128__(v202, v202) * 0xDE5FB9D2630458E9uLL) >> 64);
        a1[1] = (__int64)&qword_149808ABC + 4;
        DestroyStringObject(&a1[1]);
        if ( (_QWORD)a7 != *v192 + v192[3] )
        {
          break;
        }
        sub_1405BD4A0(
          8u,
          2u,
          "[DataCore] BinaryLoad: Record was not loaded as structure %s could not be located in the game but has been exp"
          "orted from DataCore.",
          v199);
LABEL_220:
        n0x6400000_3 += 32LL;
        v160 = *(_DWORD **)(rcx0 + 504);
        LODWORD(v275) = v275 + 1;
        n0x6400000_2 = n0x6400000_3;
        if ( (unsigned int)v275 >= v160[8] )
        {
          goto LABEL_221;
        }
      }
      v205 = *(unsigned __int16 *)(n0x6400000_3 + v194 + 28);
      *(_OWORD *)a2 = *(_OWORD *)(n0x6400000_3 + v194 + 12);
      v206 = *(_QWORD *)(*((_QWORD *)&a7 + 1) + 56LL) + *(_QWORD *)(*((_QWORD *)&a7 + 1) + 48LL) * v205;
      v207 = sub_1402A1E30(0x28u);
      if ( v207 )
      {
        StringObjectFromString = CreateStringObjectFromString((void **)&v276, v198);
        v209 = *(_OWORD *)a2;
        v210 = StringObjectFromString;
        *(_QWORD *)(v207 + 8) = v206;
        *(_QWORD *)v207 = &off_1489FEA50;
        *(_OWORD *)(v207 + 16) = v209;
        sub_1403577C0((void **)(v207 + 32), (const void **)StringObjectFromString);
        DestroyStringObject(v210);
      }
      else
      {
        v207 = 0;
      }
      sub_147218DB0((__int64 *)(rcx0 + 8), (__int64)v287, a2);
      *(_QWORD *)(v288 + 16) = v207;
      v211 = *(_OWORD *)a2;
      CreateStringObjectFromString((void **)&v285, v198);
      sub_147219260((__int64 *)(rcx0 + 64), (__int64)v287, (const char **)&v285);
      v212 = v288;
      *(_QWORD *)(v288 + 8) = v207;
      *(_OWORD *)(v212 + 16) = v211;
      DestroyStringObject(&v285);
      sub_147218F50((__int64 *)(rcx0 + 120), (__int64)v287, a2);
      assignCStringToStringStructure((void **)(v288 + 16), v198);
      sub_147218F50((__int64 *)(rcx0 + 176), (__int64)v287, a2);
      assignCStringToStringStructure((void **)(v288 + 16), *(_BYTE **)a4);
      v213 = (__int64 *)(rcx0 + 232);
      CreateStringObjectFromString((void **)&v274, v199);
      v214 = -1;
      do
      {
        ++v214;
      }
      while ( *(_BYTE *)(v274 + v214) );
      v215 = 0xCBF29CE484222325uLL;
      v216 = 0;
      if ( v214 )
      {
        do
        {
          v217 = *(unsigned __int8 *)(v274 + v216++);
          v215 = 0x100000001B3LL * (v217 ^ v215);
        }
        while ( v216 < v214 );
        v213 = (__int64 *)(rcx0 + 232);
      }
      v218 = (__PAIR128__(v215, v215) * 0xDE5FB9D2630458E9uLL) >> 64;
      v219 = sub_147217050(v213, &v274, v218);
      if ( v219 == -1 )
      {
        v220 = sub_14726BC00(v213, v218);
        v221 = (_QWORD *)(16 * v220 + v213[1]);
        sub_1403577A0(v221, &v274);
        v222 = v218 & 0x7F;
        v221[1] = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
        *(_BYTE *)(v220 + *v213) = v222;
        *(_BYTE *)((v213[3] & 0xF) + (v213[3] & (v220 - 16)) + *v213 + 1) = v222;
        v223 = 16 * v220 + v213[1];
      }
      else
      {
        v223 = v213[1] + 16 * v219;
      }
      v224 = *(_QWORD *)(v223 + 8);
      v225 = (unsigned __int64 *)(v223 + 8);
      v226 = *(_DWORD *)(v224 - 4);
      v227 = v226 & 0x7FFFFFFF;
      v228 = 16 * v226;
      v229 = (v226 & 0x7FFFFFFF) + 1;
      if ( v226 >= 0 )
      {
        v230 = (unsigned __int64)v228 >> 4;
      }
      else
      {
        LODWORD(v230) = *(_DWORD *)(v228 + v224);
      }
      if ( v229 > (int)v230 )
      {
        a4[0] = v227 + 1;
        if ( !v226 )
        {
          v224 = 0;
        }
        v231 = sub_140448AD0((__int64)v225, v224, v227, a4, 8u, 1u);
        *v225 = v231;
        if ( !v231 )
        {
          *v225 = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
LABEL_216:
          v234 = *(unsigned int *)(*v225 - 4);
          LODWORD(v234) = v234 & 0x7FFFFFFF;
          v235 = *v225 + 16 * v234;
          v236 = (_OWORD *)(v235 - 16);
          do
          {
            *(_QWORD *)&_XMM0 = a2[0];
            *v236++ = *(_OWORD *)a2;
          }
          while ( v236 != (_OWORD *)v235 );
          DestroyStringObject(&v274);
          n0x6400000_3 = n0x6400000_2;
          v192 = (_QWORD *)(rcx0 + 304);
          goto LABEL_220;
        }
        LODWORD(v230) = a4[0];
      }
      v232 = *v225;
      v233 = 16 * v229;
      *(_DWORD *)(*v225 - 4) = v229;
      if ( 16LL * (int)v230 >= (unsigned __int64)(v233 + 4) )
      {
        *(_DWORD *)(v232 - 4) = v229 | 0x80000000;
        *(_DWORD *)(v233 + v232) = v230;
      }
      goto LABEL_216;
    }
LABEL_221:
    for ( i = 0; i < v160[4]; v160 = *(_DWORD **)(rcx0 + 504) )
    {
      v238 = (unsigned int *)(*(_QWORD *)(rcx0 + 512) + 16LL * i);
      if ( v160[1] >= 6u )
      {
        v239 = *(_QWORD *)(rcx0 + 680);
      }
      else
      {
        v239 = *(_QWORD *)(rcx0 + 672);
      }
      v240 = *v238 + v239;
      v241 = -1;
      do
      {
        ++v241;
      }
      while ( *(_BYTE *)(v240 + v241) );
      LODWORD(v275) = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_1495F6C20[0])(
                         0xFFFFFFFF,
                         v240,
                         v241);
      ++i;
      *(_QWORD *)(*(_QWORD *)sub_1402A8A70((unsigned __int64 **)(rcx0 + 792), (__int64)&a7, (unsigned __int8 *)&v275)
                + 24LL) = v238;
    }
    for ( j = 0; j < v160[6]; v160 = *(_DWORD **)(rcx0 + 504) )
    {
      v243 = (unsigned int *)(*(_QWORD *)(rcx0 + 528) + 8LL * j);
      if ( v160[1] >= 6u )
      {
        v244 = *(_QWORD *)(rcx0 + 680);
      }
      else
      {
        v244 = *(_QWORD *)(rcx0 + 672);
      }
      v245 = *v243 + v244;
      v246 = -1;
      do
      {
        ++v246;
      }
      while ( *(_BYTE *)(v245 + v246) );
      LODWORD(v275) = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_1495F6C20[0])(
                         0xFFFFFFFF,
                         v245,
                         v246);
      ++j;
      *(_QWORD *)(*(_QWORD *)sub_1402A8A70((unsigned __int64 **)(rcx0 + 856), (__int64)&a7, (unsigned __int8 *)&v275)
                + 24LL) = v243;
    }
    v247 = *(char **)(rcx0 + 304);
    v248 = *(__int64 **)(rcx0 + 312);
    if ( *v247 < -1 )
    {
      _XMM4 = XMM4;
      do
      {
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [rbx]
          vpmovmskb eax, xmm0
        }
        _BitScanForward((unsigned int *)&v251, _EAX + 1);
        v247 += (unsigned int)v251;
        v248 += 9 * v251;
      }
      while ( *v247 < -1 );
    }
    if ( v247 == (char *)(*(_QWORD *)(rcx0 + 328) + *(_QWORD *)(rcx0 + 304)) )
    {
LABEL_257:
      sub_14725DB10((_QWORD *)rcx0);
      sub_14725DFC0((_QWORD *)rcx0);
      v263 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_14981D260 + 72LL))(
                         qword_14981D260,
                         &v276);
      sub_140593A60(v263, &n0x6400000_2, &k);
      _XMM0 = sub_140593C00(*(double *)&_XMM0);
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      LogTraceConditional("[DataCore] Binary Data Loaded. Total Time took %fs", *(float *)&_XMM1);
      v266 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_14981D260 + 72LL))(
                          qword_14981D260,
                          &v276);
      v267 = *(_QWORD **)(rcx0 + 408);
      v268 = *(_QWORD **)(rcx0 + 400);
      for ( k = *v266; v268 != v267; ++v268 )
      {
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v268 + 40LL))(*v268);
      }
      v269 = *(_QWORD *)(rcx0 + 400);
      if ( v269 != *(_QWORD *)(rcx0 + 408) )
      {
        *(_QWORD *)(rcx0 + 408) = v269;
      }
      v270 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_14981D260 + 72LL))(
                         qword_14981D260,
                         &v276);
      sub_140593A60(v270, &n0x6400000_2, &k);
      _XMM0 = sub_140593C00(*(double *)_XMM0.m128_u64);
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      LogTraceConditional("[DataCore] Game Post Load. Total Time took %fs", *(float *)&_XMM1);
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_14981D238 + 464LL))(qword_14981D238, v284);
      v11 = 1;
      goto LABEL_262;
    }
    while ( 1 )
    {
      v252 = *v248;
      v253 = -1;
      do
      {
        ++v253;
      }
      while ( *(_BYTE *)(v252 + v253) );
      v254 = ~((unsigned int (__fastcall *)(unsigned int, __int64, __int64))off_1495F6C20[0])(0xFFFFFFFF, v252, v253);
      v255 = *(_QWORD *)(rcx0 + 800);
      v256 = *(_QWORD *)(rcx0 + 816);
      v257 = *(_QWORD *)(v256
                       + 16
                       * ((0x100000001B3LL
                         * (((unsigned __int64)v254 >> 24)
                          ^ (0x100000001B3LL
                           * (BYTE2(v254)
                            ^ (0x100000001B3LL
                             * (BYTE1(v254) ^ (0x100000001B3LL * ((unsigned __int8)v254 ^ 0xCBF29CE484222325uLL))))))))
                        & *(_QWORD *)(rcx0 + 840))
                       + 8);
      if ( v257 == v255 )
      {
        goto LABEL_247;
      }
      v258 = *(_QWORD *)(v256
                       + 16
                       * ((0x100000001B3LL
                         * (((unsigned __int64)v254 >> 24)
                          ^ (0x100000001B3LL
                           * (BYTE2(v254)
                            ^ (0x100000001B3LL
                             * (BYTE1(v254) ^ (0x100000001B3LL * ((unsigned __int8)v254 ^ 0xCBF29CE484222325uLL))))))))
                        & *(_QWORD *)(rcx0 + 840)));
      if ( v254 != *(_DWORD *)(v257 + 16) )
      {
        break;
      }
LABEL_248:
      if ( !v257 )
      {
        v257 = v255;
      }
      if ( v257 != v255 )
      {
        v259 = *(_QWORD *)(v257 + 24);
        if ( v259 )
        {
          sub_1472445D0(rcx0, v248 + 1, v259);
        }
      }
      ++v247;
      v248 += 9;
      if ( *v247 < -1 )
      {
        _XMM4_1 = XMM4;
        do
        {
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [rbx]
            vpmovmskb eax, xmm0
          }
          _BitScanForward((unsigned int *)&v262, _EAX + 1);
          v247 += (unsigned int)v262;
          v248 += 9 * v262;
        }
        while ( *v247 < -1 );
      }
      if ( v247 == (char *)(*(_QWORD *)(rcx0 + 328) + *(_QWORD *)(rcx0 + 304)) )
      {
        goto LABEL_257;
      }
    }
    while ( v257 != v258 )
    {
      v257 = *(_QWORD *)(v257 + 8);
      if ( v254 == *(_DWORD *)(v257 + 16) )
      {
        v255 = *(_QWORD *)(rcx0 + 800);
        goto LABEL_248;
      }
    }
    v255 = *(_QWORD *)(rcx0 + 800);
LABEL_247:
    v257 = 0;
    goto LABEL_248;
  }
  v172 = (_QWORD *)(rcx0 + 304);
  v173 = 0;
  while ( 1 )
  {
    v274 = *(_QWORD *)(rcx0 + 544);
    v174 = (unsigned int *)(*(_QWORD *)(rcx0 + 512) + 16LL * *(unsigned __int16 *)(v173 + v274 + 4));
    n0x6400000_1 = *(_DWORD *)(v173 + v274) * (unsigned int)*((unsigned __int16 *)v174 + 6);
    v176 = v160[1] < 6u;
    v177 = *v174;
    n0x6400000_2 = n0x6400000_1;
    if ( v176 )
    {
      v178 = *(_QWORD *)(rcx0 + 672);
    }
    else
    {
      v178 = *(_QWORD *)(rcx0 + 680);
    }
    v275 = v177 + v178;
    v276 = v177 + v178;
    sub_140357780(&v277, &v276);
    v179 = -1;
    do
    {
      ++v179;
    }
    while ( v277[v179] );
    v180 = 0xCBF29CE484222325uLL;
    for ( m = 0; m < v179; v180 = 0x100000001B3LL * (v182 ^ v180) )
    {
      v182 = (unsigned __int8)v277[m++];
    }
    sub_147218A50(v172, a2, &v277, (__PAIR128__(v180, v180) * 0xDE5FB9D2630458E9uLL) >> 64);
    v277 = (char *)&qword_149808ABC + 4;
    DestroyStringObject(&v277);
    if ( a2[0] == *v172 + v172[3] )
    {
      (*(void (__fastcall **)(__int64, __int64, _QWORD, __int64))(*(_QWORD *)qword_14981D238 + 448LL))(
        qword_14981D238,
        v284,
        (unsigned int)n0x6400000_1,
        1);
      goto LABEL_172;
    }
    v183 = a2[1];
    ptr_to_free = 0;
    *(_QWORD *)&_XMM0 = 0;
    *(_OWORD *)a1 = 0;
    if ( n0x6400000_1 )
    {
      a1[0] = sub_14038E0B0((__int64)a1, n0x6400000_1);
      v184 = a1[0] + n0x6400000_1;
      ptr_to_free = (const void *)(a1[0] + n0x6400000_1);
      memset((void *)a1[0], 0, n0x6400000_1);
      a1[1] = v184;
    }
    v185 = *(_QWORD *)qword_14981D238;
    v285 = a1[0];
    if ( (*(__int64 (__fastcall **)(__int64, __int64, __int64, unsigned __int64, __int64, const char *))(v185 + 336))(
           qword_14981D238,
           a1[0],
           1,
           n0x6400000_1,
           v284,
           "FReadRawWithLog") != n0x6400000_1 )
    {
      break;
    }
    v186 = 0;
    v187 = (_BYTE *)v285;
    v188 = (unsigned int *)v285;
    if ( *(_DWORD *)(v173 + v274) )
    {
      do
      {
        v188 = sub_14724D1A0(
                 (__int64 *)rcx0,
                 *(_QWORD *)(v183 + 56) + *(_QWORD *)(v183 + 48) * (int)v186++,
                 v275,
                 v183 + 8,
                 v174,
                 v188);
      }
      while ( v186 < *(_DWORD *)(v173 + v274) );
      n0x6400000_1 = n0x6400000_2;
      v187 = (_BYTE *)v285;
    }
    if ( (char *)v188 - v187 != n0x6400000_1 )
    {
      v274 = 0x1C000000CELL;
      a2[0] = (__int64)&v274;
      a2[1] = (__int64)&v275;
      v189 = invokeGlobalCallbackAndMaskStatusBits(
               2,
               (__int64)a2,
               (__int64)"DataCore Load Failure",
               "DCB file is larger than expected");
      if ( (v189 & 0xFFFFF) == 0 )
      {
        goto LABEL_180;
      }
      ThreadLogContextSlot_3 = getThreadLogContextSlot();
      p_DCB_file_is_smaller_than_expected = "DCB file is larger than expected";
      goto LABEL_179;
    }
    if ( a1[0] )
    {
      sub_14039EFB0((__int64)a1, (const void *)a1[0], (unsigned __int64)ptr_to_free - a1[0]);
    }
    v172 = (_QWORD *)(rcx0 + 304);
LABEL_172:
    v173 += 8;
    v160 = *(_DWORD **)(rcx0 + 504);
    if ( ++a4[0] >= v160[7] )
    {
      goto LABEL_183;
    }
  }
  v274 = 0x1C000000CELL;
  a2[0] = (__int64)&v274;
  a2[1] = (__int64)&v275;
  v189 = invokeGlobalCallbackAndMaskStatusBits(
           2,
           (__int64)a2,
           (__int64)"DataCore Load Failure",
           "DCB file is smaller than expected");
  if ( (v189 & 0xFFFFF) == 0 )
  {
    goto LABEL_180;
  }
  ThreadLogContextSlot_3 = getThreadLogContextSlot();
  p_DCB_file_is_smaller_than_expected = "DCB file is smaller than expected";
LABEL_179:
  a2[0] = (__int64)&v274;
  a2[1] = (__int64)&v275;
  a7 = 0;
  v274 = 0x1C000000CELL;
  submitTraceContext(
    2,
    (__int64)a2,
    "DataCore Load Failure",
    (__int64)p_DCB_file_is_smaller_than_expected,
    1,
    v189,
    &a7,
    0,
    (__int64)ThreadLogContextSlot_3);
LABEL_180:
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_14981D238 + 464LL))(qword_14981D238, v284);
  if ( a1[0] )
  {
    sub_14039EFB0((__int64)a1, (const void *)a1[0], (unsigned __int64)ptr_to_free - a1[0]);
  }
  v11 = 0;
LABEL_262:
  DestroyStringObject(&v282);
  return v11;
}

// --- End Function: sub_147242B20 (0x147242B20) ---

// --- Function: sub_1472445D0 (0x1472445D0) ---
_QWORD *__fastcall sub_1472445D0(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v3; // r13
  _QWORD *result; // rax
  __int64 v6; // r15
  unsigned __int8 **v7; // r12
  char n15; // r15
  int v9; // r11d
  int v10; // r9d
  __int64 v11; // rbx
  int v12; // r14d
  __int64 v13; // r10
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int8 *v16; // rax
  __int64 v17; // r8
  int v18; // ecx
  int v19; // edx
  char n15_1; // al
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v23; // rax
  unsigned __int8 **v24; // rbx
  _QWORD *v25; // rbx
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rdx
  __int64 v28; // r8
  __int64 v29; // rax
  __int64 v30; // [rsp+20h] [rbp-68h] BYREF
  char *v31; // [rsp+28h] [rbp-60h] BYREF
  __int64 v32; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int8 *v33; // [rsp+38h] [rbp-50h] BYREF
  _QWORD v34[2]; // [rsp+40h] [rbp-48h] BYREF
  __int64 v36; // [rsp+A0h] [rbp+18h]
  __int64 i; // [rsp+A8h] [rbp+20h]

  v36 = a3;
  v3 = 0;
  result = a2;
  if ( a2[1] )
  {
    v6 = 0;
    for ( i = 0; ; i += 40 )
    {
      v7 = (unsigned __int8 **)(v6 + *result);
      n15 = *((_BYTE *)v7 + 24);
      if ( (unsigned __int8)(n15 - 15) <= 1u )
      {
        v9 = *(unsigned __int16 *)(a3 + 8);
        v10 = 0;
        if ( *(_WORD *)(a3 + 8) )
        {
          break;
        }
      }
LABEL_35:
      ++v3;
      result = a2;
      v6 = i + 40;
      if ( v3 >= a2[1] )
      {
        return result;
      }
    }
    v11 = *(_QWORD *)(a1 + 520);
    v12 = *(unsigned __int16 *)(a3 + 10);
    while ( 1 )
    {
      v13 = v11 + 12LL * (v12 + v10);
      v14 = *(_DWORD *)(*(_QWORD *)(a1 + 504) + 4LL) >= 6u ? *(_QWORD *)(a1 + 680) : *(_QWORD *)(a1 + 672);
      v15 = *(unsigned int *)(v11 + 12LL * (v12 + v10)) + v14;
      v16 = *v7;
      v17 = v15 - (_QWORD)*v7;
      do
      {
        v18 = v16[v17];
        v19 = *v16 - v18;
        if ( v19 )
        {
          break;
        }
        ++v16;
      }
      while ( v18 );
      if ( !v19 )
      {
        break;
      }
      if ( ++v10 >= v9 )
      {
        goto LABEL_34;
      }
    }
    n15_1 = *(_BYTE *)(v13 + 6);
    if ( n15_1 == 16 )
    {
      v21 = *(unsigned int *)(*(_QWORD *)(a1 + 512) + 16LL * *(unsigned __int16 *)(v13 + 4));
    }
    else
    {
      if ( n15_1 != 15 )
      {
        v23 = 0;
LABEL_24:
        if ( n15 != 15 )
        {
          v30 = v23;
          v25 = (_QWORD *)(a1 + 304);
          sub_140357780(&v31, &v30);
          v26 = -1;
          do
          {
            ++v26;
          }
          while ( v31[v26] );
          v27 = 0;
          v28 = 0xCBF29CE484222325uLL;
          if ( v26 )
          {
            do
            {
              v29 = (unsigned __int8)v31[v27++];
              v28 = 0x100000001B3LL * (v29 ^ v28);
            }
            while ( v27 < v26 );
            v25 = (_QWORD *)(a1 + 304);
          }
          sub_147218A50(
            v25,
            v34,
            &v31,
            0xDE5FB9D2630458E9uLL * v28 + (((unsigned __int64)v28 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
          v31 = (char *)&qword_149808ABC + 4;
          DestroyStringObject(&v31);
          if ( v34[0] != *v25 + v25[3] )
          {
            v7[4] = *(unsigned __int8 **)v34[1];
          }
LABEL_34:
          a3 = v36;
          goto LABEL_35;
        }
        v32 = v23;
        sub_140357780(&v33, &v32);
        v24 = sub_140C9F2E0((unsigned __int8 ***)(a1 + 288), &v33);
        v33 = (unsigned __int8 *)&qword_149808ABC + 4;
        DestroyStringObject(&v33);
        a3 = v36;
        if ( v24 != *(unsigned __int8 ***)(a1 + 288) )
        {
          v7[4] = v24[4];
        }
        goto LABEL_35;
      }
      v21 = *(unsigned int *)(*(_QWORD *)(a1 + 528) + 8LL * *(unsigned __int16 *)(v13 + 4));
    }
    if ( *(_DWORD *)(*(_QWORD *)(a1 + 504) + 4LL) >= 6u )
    {
      v22 = *(_QWORD *)(a1 + 680);
    }
    else
    {
      v22 = *(_QWORD *)(a1 + 672);
    }
    v23 = v21 + v22;
    goto LABEL_24;
  }
  return result;
}

// --- End Function: sub_1472445D0 (0x1472445D0) ---

// --- Function: sub_147245730 (0x147245730) ---
char *__fastcall sub_147245730(__int64 *a1, __int64 a2, __int64 a3, __int64 **a4)
{
  char *result; // rax
  __int64 n7; // rcx
  Record **p_Record; // r8
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int128 **v11; // rax
  char *v12; // [rsp+20h] [rbp-38h] BYREF
  __int64 v13; // [rsp+28h] [rbp-30h]
  __int128 v14; // [rsp+30h] [rbp-28h] BYREF

  result = (char *)(*(__int64 (__fastcall **)(_QWORD))(**a4 + 56))(*a4);
  n7 = 0;
  p_Record = "Record";
  while ( 1 )
  {
    v9 = (unsigned __int8)result[n7++];
    if ( (_BYTE)v9 != aRecord[n7 - 1] )
    {
      break;
    }
    if ( n7 == 7 )
    {
      result = (char *)(*(__int64 (__fastcall **)(_QWORD, const char *, const char *))(**a4 + 272))(
                         *a4,
                         "__guid",
                         "Record");
      if ( (result && *result && (*result != 48 || result[1])
         || (result = (char *)(*(__int64 (__fastcall **)(_QWORD, int *))(**a4 + 272))(*a4, &dword_147F36950)) != 0)
        && *result
        && (*result != 48 || result[1]) )
      {
        v14 = *(_OWORD *)sub_1402BA020((__int64 *)&v14, result);
        sub_1472186C0(a1 + 1, (unsigned __int64 *)&v12, &v14);
        result = (char *)(a1[1] + a1[4]);
        if ( v12 != result )
        {
          result = (char *)v13;
          v10 = *(_QWORD *)(v13 + 16);
          if ( v10 )
          {
            v11 = (__int128 **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 16LL))(v10);
            result = (char *)sub_14725C2D0(a1, *v11, a4);
          }
        }
      }
      break;
    }
  }
  if ( *a4 )
  {
    return (char *)(*(__int64 (__fastcall **)(_QWORD, __int64, const char *))(**a4 + 40))(*a4, v9, p_Record);
  }
  return result;
}

// --- End Function: sub_147245730 (0x147245730) ---

// --- Function: sub_147245BC0 (0x147245BC0) ---
void __fastcall sub_147245BC0(__int64 a1, __int64 a2, const char **a3, _QWORD *a4)
{
  void **v8; // rax
  void **v9; // rax
  __int64 *v10; // rdi
  unsigned __int8 **v11; // rbx
  char *v12; // r13
  __int64 v13; // r15
  __int64 *v14; // rdi
  __int64 v15; // rbx
  __int64 *v16; // rdi
  __int64 v17; // rsi
  __int128 v18; // xmm0
  const char *Size; // r8
  const char *v20; // rax
  const char *v21; // rax
  unsigned __int8 *v22; // [rsp+30h] [rbp-30h] BYREF
  void *v23; // [rsp+38h] [rbp-28h] BYREF
  __int128 v24; // [rsp+40h] [rbp-20h] BYREF
  __int64 Src; // [rsp+B0h] [rbp+50h] BYREF
  const char *v26; // [rsp+B8h] [rbp+58h] BYREF

  initializeEmptyStringStructure(&Src);
  v9 = sub_1403A5050(v8, "__%s__type", *a3);
  sub_1403577C0(&v23, (const void **)v9);
  DestroyStringObject(&Src);
  initializeEmptyStringStructure(&v26);
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*a4 + 280LL))(*a4, *a3)
    && (*(unsigned __int8 (__fastcall **)(_QWORD, void *))(*(_QWORD *)*a4 + 280LL))(*a4, v23) )
  {
    (*(void (__fastcall **)(_QWORD, void *, const char **))(*(_QWORD *)*a4 + 128LL))(*a4, v23, &v26);
    v10 = *(__int64 **)(a1 + 288);
    v11 = (unsigned __int8 **)v10[1];
    while ( !*((_BYTE *)v11 + 25) )
    {
      if ( (int)sub_1403DFBE0(v11 + 4, &v26) >= 0 )
      {
        v10 = (__int64 *)v11;
        v11 = (unsigned __int8 **)*v11;
      }
      else
      {
        v11 = (unsigned __int8 **)v11[2];
      }
    }
    if ( *((_BYTE *)v10 + 25)
      || (int)sub_1403DFBE0((unsigned __int8 **)&v26, v10 + 4) < 0
      || v10 == *(__int64 **)(a1 + 288) )
    {
      v21 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
      sub_1405BD4A0(
        8u,
        2u,
        "[DataCore] Field \"%s\" enum \"%s\" was not found. Did you register it (see DataCore_GamePreInitialize())? \"%s\"",
        *a3,
        v26,
        v21);
    }
    else
    {
      v12 = (char *)&a3[1][a2];
      v13 = sub_147220700((__int64 **)(a1 + 288), (const void **)&v26)[1];
      initializeEmptyStringStructure(&v22);
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*a4 + 280LL))(*a4, *a3) )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD, unsigned __int8 **))(*(_QWORD *)*a4 + 128LL))(*a4, *a3, &v22);
        v14 = *(__int64 **)v13;
        DWORD2(v24) = 0;
        v15 = v14[1];
        *(_QWORD *)&v24 = v15;
        while ( !*(_BYTE *)(v15 + 25) )
        {
          *(_QWORD *)&v24 = v15;
          if ( (int)sub_1403DFBE0((unsigned __int8 **)(v15 + 32), &v22) >= 0 )
          {
            v14 = (__int64 *)v15;
            DWORD2(v24) = 1;
            v15 = *(_QWORD *)v15;
          }
          else
          {
            v15 = *(_QWORD *)(v15 + 16);
            DWORD2(v24) = 0;
          }
        }
        if ( *((_BYTE *)v14 + 25) || (int)sub_1403DFBE0(&v22, v14 + 4) < 0 )
        {
          if ( *(_QWORD *)(v13 + 8) == 0x555555555555555LL )
          {
            unknown_libname_7();
          }
          v16 = *(__int64 **)v13;
          v17 = sub_1402A1E30(0x30u);
          sub_1403577C0((void **)(v17 + 32), (const void **)&v22);
          v18 = v24;
          *(_DWORD *)(v17 + 40) = 0;
          *(_QWORD *)v17 = v16;
          *(_QWORD *)(v17 + 8) = v16;
          *(_QWORD *)(v17 + 16) = v16;
          *(_WORD *)(v17 + 24) = 0;
          v24 = v18;
          v14 = (__int64 *)sub_1402DE890((__int64 **)v13, (__int64)&v24, v17);
        }
        Size = a3[2];
        LODWORD(Src) = *((_DWORD *)v14 + 10);
        memcpy(v12, &Src, (size_t)Size);
        DestroyStringObject(&v22);
      }
      else
      {
        v20 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
        sub_1405BD4A0(
          8u,
          0,
          "[DataCore] Cannot locate default enum value for field '%s' in record '%s'. Please provide default value within"
          " the schema. Value will be UNINITIALIZED!",
          *a3,
          v20);
        DestroyStringObject(&v22);
      }
    }
  }
  DestroyStringObject(&v26);
  DestroyStringObject(&v23);
}

// --- End Function: sub_147245BC0 (0x147245BC0) ---

// --- Function: sub_147245E90 (0x147245E90) ---
void __fastcall sub_147245E90(__int64 a1, __int64 a2, const char **a3, _QWORD *a4)
{
  const char *v7; // r14
  void **v8; // rax
  void **v9; // rax
  int v10; // eax
  __int64 v11; // r13
  __int64 *v12; // rdi
  unsigned __int8 **v13; // rbx
  size_t *v14; // rax
  __int64 *v15; // rdi
  size_t Size; // r15
  const void *ptr_to_free; // rcx
  int v18; // esi
  __int64 v19; // r14
  _BYTE *v20; // r13
  __int64 *v21; // rbx
  __int64 v22; // rax
  __int64 v23; // rbx
  __int64 v24; // rdi
  const char *v25; // rax
  unsigned __int8 *v26; // [rsp+30h] [rbp-39h] BYREF
  __int64 v27; // [rsp+38h] [rbp-31h] BYREF
  int Src; // [rsp+40h] [rbp-29h] BYREF
  void *v29; // [rsp+48h] [rbp-21h] BYREF
  __int64 v30; // [rsp+50h] [rbp-19h] BYREF
  __int64 *v31; // [rsp+58h] [rbp-11h]
  void *v32; // [rsp+60h] [rbp-9h] BYREF
  const char *v33; // [rsp+68h] [rbp-1h]
  __int64 v34; // [rsp+70h] [rbp+7h] BYREF
  unsigned __int8 *v35; // [rsp+78h] [rbp+Fh] BYREF
  void *v36; // [rsp+80h] [rbp+17h]
  __int64 v39; // [rsp+E8h] [rbp+7Fh] BYREF

  (*(void (__fastcall **)(_QWORD, __int64 *, _QWORD))(*(_QWORD *)*a4 + 360LL))(*a4, &v27, *a3);
  v7 = &a3[1][a2];
  if ( v27 )
  {
    initializeEmptyStringStructure(&v39);
    v9 = sub_1403A5050(v8, "__%s__type", *a3);
    sub_1403577C0(&v29, (const void **)v9);
    DestroyStringObject(&v39);
    initializeEmptyStringStructure(&v26);
    if ( (*(unsigned __int8 (__fastcall **)(__int64, void *))(*(_QWORD *)v27 + 280LL))(v27, v29) )
    {
      (*(void (__fastcall **)(__int64, void *, unsigned __int8 **))(*(_QWORD *)v27 + 128LL))(v27, v29, &v26);
      v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 344LL))(v27);
      v11 = v10;
      LODWORD(v39) = v10;
      if ( v10 > 0 )
      {
        v12 = *(__int64 **)(a1 + 288);
        v13 = (unsigned __int8 **)v12[1];
        while ( !*((_BYTE *)v13 + 25) )
        {
          if ( (int)sub_1403DFBE0(v13 + 4, &v26) >= 0 )
          {
            v12 = (__int64 *)v13;
            v13 = (unsigned __int8 **)*v13;
          }
          else
          {
            v13 = (unsigned __int8 **)v13[2];
          }
        }
        if ( !*((_BYTE *)v12 + 25) && (int)sub_1403DFBE0(&v26, v12 + 4) >= 0 && v12 != *(__int64 **)(a1 + 288) )
        {
          v14 = (size_t *)sub_147220700((__int64 **)(a1 + 288), (const void **)&v26);
          v15 = (__int64 *)(v7 + 16);
          v33 = v7 + 16;
          Size = *v14;
          v31 = (__int64 *)v14[1];
          ptr_to_free = (const void *)*((_QWORD *)v7 + 2);
          *((_QWORD *)v7 + 3) = v11;
          if ( ptr_to_free )
          {
            free_memory_wrapper(ptr_to_free);
            *v15 = 0;
          }
          v18 = 0;
          v19 = 0;
          *v15 = sub_14739AFC0(Size * v11, 0);
          do
          {
            (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v27 + 352LL))(v27, &v30, (unsigned int)v18);
            v36 = (void *)(v19 + *v15);
            Src = 0;
            if ( v30
              && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v30 + 280LL))(v30, &dword_147F36950) )
            {
              v34 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v30 + 272LL))(v30, &dword_147F36950);
              v20 = (_BYTE *)v34;
              sub_140357780(&v35, &v34);
              v21 = v31;
              v22 = std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
                      v31,
                      &v35);
              v23 = *v21;
              v24 = v22;
              v35 = (unsigned __int8 *)&qword_149808ABC + 4;
              DestroyStringObject(&v35);
              if ( v24 != v23 )
              {
                CreateStringObjectFromString(&v32, v20);
                Src = *(_DWORD *)sub_1409A18C0((__int64 **)v31, (__int64 *)&v32);
                DestroyStringObject(&v32);
              }
              LODWORD(v11) = v39;
              v15 = (__int64 *)v33;
            }
            else
            {
              v25 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Cannot locate default enum array value for field '%s' in record '%s'. Please provide default "
                "value within the schema. Value will be UNINITIALIZED!",
                *a3,
                v25);
            }
            memcpy(v36, &Src, Size);
            if ( v30 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v30 + 40LL))(v30);
            }
            ++v18;
            v19 += Size;
          }
          while ( v18 < (int)v11 );
        }
      }
    }
    DestroyStringObject(&v26);
    DestroyStringObject(&v29);
    if ( v27 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v27 + 40LL))(v27);
    }
  }
}

// --- End Function: sub_147245E90 (0x147245E90) ---

// --- Function: sub_1472461B0 (0x1472461B0) ---
__int64 __fastcall sub_1472461B0(
        _QWORD *rcx0,
        char *a2,
        __int64 **a3,
        const char *a4,
        __int64 a5,
        __int64 a6,
        char *a7)
{
  __int128 v7; // xmm6
  __int128 v8; // xmm7
  char *v9; // rsi
  const char *v10; // r13
  __int64 v11; // r12
  __int64 **v12; // rdi
  __int64 v13; // r9
  char *v14; // r14
  _QWORD *v15; // r15
  unsigned int Src_5; // ebx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rax
  char n3; // r8
  const char **v20; // r13
  char v21; // dl
  __int64 v22; // rax
  __int64 v23; // rbx
  int v24; // eax
  int v25; // r15d
  int v26; // esi
  __int64 v27; // r14
  __int64 v28; // rdi
  _QWORD *v29; // rdi
  char *v30; // rax
  __int64 *v31; // rax
  __int64 *v34; // rcx
  __int64 result; // rax
  unsigned __int64 v36; // rdx
  _QWORD *v37; // rbx
  __int64 v38; // rcx
  unsigned __int64 v39; // r8
  __int64 v40; // rax
  const char *v41; // rcx
  int v42; // r14d
  int i; // esi
  int v44; // edi
  unsigned int j; // ebx
  const char *v46; // rdi
  char *v47; // rax
  char *v48; // rdx
  __int64 n5; // rcx
  char v50; // al
  __int64 *v51; // rax
  __int64 v54; // rbx
  int v55; // eax
  int v56; // r15d
  int v57; // edi
  __int64 v58; // r14
  _QWORD *v59; // rsi
  _BYTE *v60; // rax
  void **v61; // rbx
  void **v62; // rax
  __int64 v63; // rdx
  const char *v64; // rdi
  _BYTE *v65; // rax
  void **v66; // rbx
  void **v67; // rax
  __int64 v68; // rdx
  const char *v69; // r14
  int n0x6400000_1; // eax
  int n0x6400000_14; // esi
  int n0x6400000_15; // ebx
  __int64 v73; // rdi
  char v74; // al
  char v75; // dl
  const char *v76; // rax
  const char *v77; // r14
  int v78; // eax
  unsigned __int64 v79; // rsi
  unsigned __int64 n0x6400000_2; // rax
  int v81; // ebx
  __int64 v82; // rdi
  char v83; // al
  __int16 v84; // cx
  const char *v85; // rax
  const char *v86; // r14
  int v87; // eax
  unsigned __int64 v88; // rsi
  unsigned __int64 n0x6400000_3; // rax
  int v90; // ebx
  __int64 v91; // rdi
  const char *v92; // rax
  const char *v93; // r14
  int v94; // eax
  unsigned __int64 v95; // rsi
  unsigned __int64 n0x6400000_4; // rax
  int v97; // ebx
  __int64 v98; // rdi
  const char *v99; // rax
  const char *v100; // r14
  int n0x6400000_5; // eax
  int n0x6400000_16; // esi
  int n0x6400000_17; // ebx
  __int64 v104; // rdi
  char v105; // al
  char v106; // dl
  const char *v107; // rax
  const char *v108; // r14
  int v109; // eax
  unsigned __int64 v110; // rsi
  unsigned __int64 n0x6400000_6; // rax
  int v112; // ebx
  __int64 v113; // rdi
  char v114; // al
  __int16 v115; // cx
  const char *v116; // rax
  const char *v117; // r14
  int v118; // eax
  unsigned __int64 v119; // rsi
  unsigned __int64 n0x6400000_7; // rax
  int v121; // ebx
  __int64 v122; // rdi
  const char *v123; // rax
  const char *v124; // r14
  int v125; // eax
  unsigned __int64 v126; // rsi
  unsigned __int64 n0x6400000_8; // rax
  int v128; // ebx
  __int64 v129; // rdi
  const char *v130; // rax
  const char *v131; // r14
  int v132; // eax
  unsigned __int64 v133; // rsi
  unsigned __int64 n0x6400000_9; // rax
  int v135; // ebx
  __int64 v136; // rdi
  const char *v137; // rax
  const char *v138; // r14
  int v139; // eax
  unsigned __int64 v140; // rsi
  unsigned __int64 n0x6400000_10; // rax
  int v142; // ebx
  __int64 v143; // rdi
  const char *v144; // rax
  const char *v145; // rsi
  int n0x6400000; // eax
  int n0x6400000_12; // r14d
  int n0x6400000_13; // ebx
  __int64 v149; // rdi
  const char *v150; // rax
  __int64 v151; // r14
  int v152; // eax
  int v153; // esi
  int v154; // ebx
  __int64 v155; // rdi
  _BYTE *v156; // rax
  const char *v157; // rax
  int v158; // eax
  unsigned __int64 v159; // rsi
  const char *v160; // r14
  unsigned __int64 n0x6400000_11; // rax
  int v162; // ebx
  __int64 v163; // rdi
  int v164; // eax
  int v165; // esi
  __int64 v166; // r14
  int v167; // ebx
  __int64 v168; // rdi
  float Src_3; // eax
  __int64 *v170; // rdi
  int v171; // r12d
  double v172; // rbx
  __int64 *v173; // rax
  void **v174; // rdi
  __int64 v175; // rbx
  __int64 v176; // rax
  void **v177; // r15
  void **v178; // rax
  void **v179; // r14
  void **v180; // rax
  char *v181; // rdi
  void **v182; // rsi
  __int64 v183; // rbx
  __int64 v184; // rax
  char *v185; // rax
  char *v186; // rdi
  unsigned __int64 v187; // rdx
  __int64 v188; // rcx
  unsigned __int64 v189; // r8
  _QWORD *v190; // rbx
  __int64 v191; // rax
  __int64 v192; // rax
  __int64 *v193; // rbx
  char **v194; // rax
  _BYTE *v195; // rdx
  _QWORD *v196; // rax
  __int64 *v197; // rsi
  const char *v198; // r14
  unsigned __int64 v199; // rdx
  _QWORD *v200; // rbx
  __int64 v201; // rcx
  unsigned __int64 v202; // r8
  __int64 v203; // rax
  __int64 v204; // rbx
  int v205; // esi
  void **v206; // rdi
  __int64 v207; // rbx
  __int64 v208; // rax
  void **v209; // r15
  void **v210; // rax
  void **v211; // r14
  void **v212; // rax
  char *v213; // rdi
  void **v214; // rsi
  __int64 v215; // rbx
  __int64 v216; // rax
  __int64 *v217; // rbx
  __int64 v218; // rdi
  __int64 *v219; // rax
  char **v220; // rax
  const char *v221; // rbx
  const char *v222; // rax
  __int64 *v223; // rcx
  const char *v224; // rdx
  char v225; // al
  char v226; // dl
  const char *v227; // rbx
  const char *v228; // rax
  __int64 *v229; // rcx
  const char *v230; // rdx
  char v231; // al
  __int16 v232; // cx
  const char *v233; // rax
  const char *v234; // rbx
  const char *v235; // rax
  __int64 *v236; // rcx
  const char *v237; // rdx
  __int64 *v238; // rcx
  const char *v239; // rdx
  const char *v240; // rbx
  const char *v241; // rax
  __int64 *v242; // rcx
  const char *v243; // rdx
  __int64 *v244; // rcx
  const char *v245; // rdx
  const char *v246; // rbx
  const char *v247; // rax
  __int64 *v248; // rcx
  const char *v249; // rdx
  char v250; // al
  char v251; // dl
  const char *v252; // rbx
  const char *v253; // rax
  __int64 *v254; // rcx
  const char *v255; // rdx
  char v256; // al
  __int16 v257; // cx
  const char *v258; // rbx
  const char *v259; // rax
  __int64 *v260; // rcx
  const char *v261; // rdx
  __int64 *v262; // rcx
  const char *v263; // rdx
  const char *v264; // rbx
  const char *v265; // rax
  __int64 *v266; // rcx
  const char *v267; // rdx
  __int64 *v268; // rcx
  const char *v269; // rdx
  const char *v270; // rbx
  const char *v271; // rax
  __int64 *v272; // rcx
  const char *v273; // rdx
  __int64 *v274; // rcx
  const char *v275; // rdx
  const char *v276; // rax
  const char *v277; // rbx
  const char *v278; // rax
  __int64 *v279; // rcx
  const char *v280; // rdx
  __int64 *v281; // rcx
  const char *v282; // rdx
  const char *v283; // rax
  const char *v284; // rbx
  const char *v285; // rax
  __int64 *v286; // rcx
  const char *v287; // rdx
  __int64 *v288; // rcx
  const char *v289; // rdx
  const char *v290; // rbx
  const char *v291; // rax
  __int64 v292; // rbx
  _BYTE *v293; // rax
  const char *v294; // rbx
  const char *v295; // rax
  char *v296; // rax
  const char *v297; // rdi
  __int64 n36; // rcx
  const char *v299; // rbx
  const char *v300; // rax
  const char *v301; // rbx
  const char *v302; // rax
  _BYTE *v303; // rax
  __int64 *v304; // r15
  __int64 v305; // rcx
  __int64 v306; // rbx
  char *v307; // rax
  char *v308; // r14
  unsigned __int64 v309; // rdx
  _QWORD *v310; // rbx
  __int64 v311; // rcx
  unsigned __int64 v312; // r8
  __int64 v313; // rax
  char *v314; // rsi
  void **v315; // rdi
  __int64 v316; // rbx
  __int64 v317; // rax
  void **v318; // rax
  int Src_2; // ebx
  char **v320; // rax
  _BYTE *v321; // rdx
  char *v322; // r14
  char *v323; // rsi
  void **v324; // rdi
  __int64 v325; // rbx
  __int64 v326; // rax
  void **v327; // rax
  int Src_1; // ebx
  char *v329; // rdx
  __int64 *v330; // rax
  char **v331; // rax
  __int64 v332; // r8
  float Src; // [rsp+38h] [rbp-D0h] BYREF
  unsigned int Src_4; // [rsp+3Ch] [rbp-CCh]
  double v335; // [rsp+40h] [rbp-C8h] BYREF
  double v336; // [rsp+48h] [rbp-C0h] BYREF
  void *a1; // [rsp+50h] [rbp-B8h] BYREF
  void *v338; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v339; // [rsp+60h] [rbp-A8h] BYREF
  void *v340; // [rsp+68h] [rbp-A0h] BYREF
  __int64 *v341; // [rsp+70h] [rbp-98h] BYREF
  void *v342; // [rsp+78h] [rbp-90h] BYREF
  __int64 *v343; // [rsp+80h] [rbp-88h] BYREF
  void *v344; // [rsp+88h] [rbp-80h] BYREF
  void *v345; // [rsp+90h] [rbp-78h] BYREF
  __int64 *v346; // [rsp+98h] [rbp-70h] BYREF
  void *v347; // [rsp+A0h] [rbp-68h] BYREF
  void *v348; // [rsp+A8h] [rbp-60h] BYREF
  char *v349; // [rsp+B0h] [rbp-58h] BYREF
  void *v350; // [rsp+B8h] [rbp-50h] BYREF
  __int64 *v351; // [rsp+C0h] [rbp-48h] BYREF
  __int16 v352[2]; // [rsp+C8h] [rbp-40h] BYREF
  char v353[4]; // [rsp+CCh] [rbp-3Ch] BYREF
  __int16 v354[2]; // [rsp+D0h] [rbp-38h] BYREF
  char v355[4]; // [rsp+D4h] [rbp-34h] BYREF
  __int16 v356[2]; // [rsp+D8h] [rbp-30h] BYREF
  char v357[4]; // [rsp+DCh] [rbp-2Ch] BYREF
  __int16 v358; // [rsp+E0h] [rbp-28h] BYREF
  __int64 *v359; // [rsp+E8h] [rbp-20h] BYREF
  __int64 *v360; // [rsp+F0h] [rbp-18h] BYREF
  void *v361; // [rsp+F8h] [rbp-10h] BYREF
  void *v362; // [rsp+100h] [rbp-8h] BYREF
  __int64 *v363; // [rsp+108h] [rbp+0h] BYREF
  __int64 *v364; // [rsp+110h] [rbp+8h] BYREF
  void *v365; // [rsp+118h] [rbp+10h] BYREF
  void *v366; // [rsp+120h] [rbp+18h] BYREF
  __int64 v367; // [rsp+128h] [rbp+20h] BYREF
  __int64 v368; // [rsp+130h] [rbp+28h] BYREF
  __int64 v369; // [rsp+138h] [rbp+30h] BYREF
  __int64 v370; // [rsp+140h] [rbp+38h] BYREF
  __int64 v371; // [rsp+148h] [rbp+40h] BYREF
  __int64 v372; // [rsp+150h] [rbp+48h] BYREF
  __int64 v373; // [rsp+158h] [rbp+50h] BYREF
  __int64 v374; // [rsp+160h] [rbp+58h] BYREF
  __int64 v375; // [rsp+168h] [rbp+60h] BYREF
  __int64 v376; // [rsp+170h] [rbp+68h] BYREF
  __int64 v377; // [rsp+178h] [rbp+70h] BYREF
  __int64 v378; // [rsp+180h] [rbp+78h] BYREF
  __int64 v379; // [rsp+188h] [rbp+80h] BYREF
  __int64 v380; // [rsp+190h] [rbp+88h] BYREF
  __int64 v381; // [rsp+198h] [rbp+90h] BYREF
  __int64 v382; // [rsp+1A0h] [rbp+98h] BYREF
  __int64 v383; // [rsp+1A8h] [rbp+A0h] BYREF
  __int64 v384; // [rsp+1B0h] [rbp+A8h] BYREF
  __int64 v385; // [rsp+1B8h] [rbp+B0h] BYREF
  __int64 v386; // [rsp+1C0h] [rbp+B8h] BYREF
  __int64 v387; // [rsp+1C8h] [rbp+C0h] BYREF
  __int64 v388; // [rsp+1D0h] [rbp+C8h] BYREF
  __int64 v389; // [rsp+1D8h] [rbp+D0h] BYREF
  __int64 v390; // [rsp+1E0h] [rbp+D8h] BYREF
  __int64 v391; // [rsp+1E8h] [rbp+E0h] BYREF
  __int64 v392; // [rsp+1F0h] [rbp+E8h] BYREF
  _BYTE *v393; // [rsp+1F8h] [rbp+F0h] BYREF
  __int64 v394; // [rsp+200h] [rbp+F8h] BYREF
  __int64 v395; // [rsp+208h] [rbp+100h] BYREF
  void *v396; // [rsp+210h] [rbp+108h] BYREF
  void *v397; // [rsp+218h] [rbp+110h] BYREF
  void *v398; // [rsp+220h] [rbp+118h] BYREF
  void *v399; // [rsp+228h] [rbp+120h] BYREF
  __int64 *v400; // [rsp+230h] [rbp+128h] BYREF
  void *v401; // [rsp+238h] [rbp+130h] BYREF
  void *v402; // [rsp+240h] [rbp+138h] BYREF
  char *v403; // [rsp+248h] [rbp+140h] BYREF
  char v404[8]; // [rsp+250h] [rbp+148h] BYREF
  __int64 *v405; // [rsp+258h] [rbp+150h] BYREF
  __int64 *v406; // [rsp+260h] [rbp+158h]
  char *v407; // [rsp+268h] [rbp+160h] BYREF
  _QWORD *v408; // [rsp+270h] [rbp+168h] BYREF
  void *v409; // [rsp+278h] [rbp+170h] BYREF
  const char *v410; // [rsp+280h] [rbp+178h] BYREF
  void *v411; // [rsp+288h] [rbp+180h] BYREF
  char *v412; // [rsp+290h] [rbp+188h] BYREF
  char *v413; // [rsp+298h] [rbp+190h] BYREF
  __int64 *v414; // [rsp+2A0h] [rbp+198h] BYREF
  char *v415; // [rsp+2A8h] [rbp+1A0h] BYREF
  char *v416; // [rsp+2B0h] [rbp+1A8h] BYREF
  char *v417; // [rsp+2B8h] [rbp+1B0h] BYREF
  __int64 v418; // [rsp+2C0h] [rbp+1B8h] BYREF
  char *v419; // [rsp+2C8h] [rbp+1C0h] BYREF
  __int64 *v420; // [rsp+2D0h] [rbp+1C8h] BYREF
  char *v421; // [rsp+2D8h] [rbp+1D0h] BYREF
  __int64 v422; // [rsp+2E0h] [rbp+1D8h] BYREF
  unsigned __int64 v423; // [rsp+2E8h] [rbp+1E0h]
  _BYTE v424[24]; // [rsp+2F0h] [rbp+1E8h] BYREF
  void *v425; // [rsp+308h] [rbp+200h] BYREF
  __int64 v426; // [rsp+310h] [rbp+208h] BYREF
  void *v427; // [rsp+318h] [rbp+210h] BYREF
  void *v428; // [rsp+320h] [rbp+218h] BYREF
  __int64 v429; // [rsp+328h] [rbp+220h] BYREF
  void *v430; // [rsp+330h] [rbp+228h] BYREF
  void *v431; // [rsp+338h] [rbp+230h] BYREF
  void *v432; // [rsp+340h] [rbp+238h] BYREF
  void *v433; // [rsp+348h] [rbp+240h] BYREF
  void *v434; // [rsp+350h] [rbp+248h] BYREF
  unsigned __int64 v435; // [rsp+358h] [rbp+250h]
  void *v436; // [rsp+360h] [rbp+258h] BYREF
  void *v437; // [rsp+368h] [rbp+260h] BYREF
  void *v438; // [rsp+370h] [rbp+268h] BYREF
  void *v439; // [rsp+378h] [rbp+270h] BYREF
  void *v440; // [rsp+380h] [rbp+278h] BYREF
  __int64 v441; // [rsp+388h] [rbp+280h] BYREF
  void *v442; // [rsp+390h] [rbp+288h] BYREF
  __int64 v443; // [rsp+398h] [rbp+290h] BYREF
  __int64 v444; // [rsp+3A0h] [rbp+298h]
  __int64 v445; // [rsp+3A8h] [rbp+2A0h] BYREF
  __int64 v446; // [rsp+3B0h] [rbp+2A8h]
  __int64 v447; // [rsp+3B8h] [rbp+2B0h] BYREF
  __int64 v448; // [rsp+3C0h] [rbp+2B8h]
  __int64 v449; // [rsp+3C8h] [rbp+2C0h] BYREF
  __int64 v450; // [rsp+3D0h] [rbp+2C8h]
  __int64 v451[2]; // [rsp+3D8h] [rbp+2D0h] BYREF
  char v452[16]; // [rsp+3E8h] [rbp+2E0h] BYREF
  char v453[16]; // [rsp+3F8h] [rbp+2F0h] BYREF
  char v454[16]; // [rsp+408h] [rbp+300h] BYREF
  char v455[8]; // [rsp+418h] [rbp+310h] BYREF
  _OWORD v456[6]; // [rsp+428h] [rbp+320h]
  const char *v460; // [rsp+4B0h] [rbp+3A8h]

  v460 = a4;
  v9 = a7;
  v10 = a4;
  v11 = a5;
  v12 = a3;
  v13 = a6;
  v14 = a2;
  v456[1] = v7;
  v15 = rcx0;
  v456[0] = v8;
  while ( 2 )
  {
    LODWORD(v335) = 0;
    Src_5 = 0;
    v17 = *(int *)(v13 + 8);
    v18 = 0;
    Src_4 = 0;
    v423 = 0;
    v435 = v17;
    if ( !v17 )
    {
      goto LABEL_28;
    }
    do
    {
      n3 = *(_BYTE *)(*(_QWORD *)v13 + 40 * v18 + 25);
      v20 = (const char **)(*(_QWORD *)v13 + 40 * v18);
      v21 = *((_BYTE *)v20 + 26);
      if ( n3 == 3 )
      {
        v22 = **v12;
        if ( !v21 )
        {
          if ( (*(int (**)(void))(v22 + 344))() > 0 )
          {
            v42 = (*(__int64 (__fastcall **)(__int64 *))(**v12 + 344))(*v12);
            if ( v42 > 0 )
            {
              for ( i = 0; i < v42; ++i )
              {
                (*(void (__fastcall **)(__int64 *, __int64 **, _QWORD))(**v12 + 352))(*v12, &v343, (unsigned int)i);
                if ( (*(int (__fastcall **)(__int64 *))(*v343 + 344))(v343) > 0 )
                {
                  v336 = *(double *)&v343;
                  if ( *(double *)&v343 != 0.0 )
                  {
                    (*(void (__fastcall **)(__int64 *))(*v343 + 32))(v343);
                  }
                  sub_147245730(v15, (__int64)a7, (__int64)v20, (__int64 **)&v336);
                  v44 = (*(__int64 (__fastcall **)(__int64 *))(*v343 + 344))(v343);
                  for ( j = 0; (int)j < v44; ++j )
                  {
                    (*(void (__fastcall **)(__int64 *, __int64 **, _QWORD))(*v343 + 352))(v343, &v420, j);
                    if ( *(double *)&v420 != 0.0 )
                    {
                      v336 = *(double *)&v420;
                      (*(void (__fastcall **)(__int64 *))(*v420 + 32))(v420);
                      sub_147245730(v15, (__int64)a7, (__int64)v20, (__int64 **)&v336);
                      if ( *(double *)&v420 != 0.0 )
                      {
                        (*(void (__fastcall **)(__int64 *))(*v420 + 40))(v420);
                      }
                    }
                  }
                  v12 = a3;
                }
                if ( *(double *)&v343 != 0.0 )
                {
                  (*(void (__fastcall **)(__int64 *))(*v343 + 40))(v343);
                }
              }
              v11 = a5;
            }
          }
          v46 = &v20[1][v11];
          v47 = (char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(**a3 + 272))(*a3, *v20);
          v48 = v47;
          if ( v47 && *v47 )
          {
            n5 = 0;
            while ( 1 )
            {
              v50 = v48[n5++];
              if ( v50 != aNull[n5 - 1] )
              {
                break;
              }
              if ( n5 == 5 )
              {
                goto LABEL_57;
              }
            }
            v51 = sub_1402BA020((__int64 *)v453, v48);
            _RDX = (_BYTE *)v15[54];
            *(_QWORD *)v424 = v46;
            _XMM1 = *(_OWORD *)v51;
            *(_OWORD *)&v424[8] = *(_OWORD *)v51;
            if ( _RDX == (_BYTE *)v15[55] )
            {
              sub_1402A56E0(v15 + 53, _RDX, (__int64)v424);
            }
            else
            {
              *(_OWORD *)_RDX = *(_OWORD *)v424;
              __asm { vmovhpd qword ptr [rdx+10h], xmm1 }
              v15[54] += 24LL;
            }
          }
          else
          {
LABEL_57:
            *(_QWORD *)v46 = 0;
            *((_QWORD *)v46 + 1) = 0;
          }
          goto LABEL_25;
        }
        (*(void (__fastcall **)(__int64 *, __int64 **, const char *))(v22 + 360))(*v12, &v360, *v20);
        v23 = (__int64)&v20[1][v11];
        v335 = *(double *)&v23;
        if ( v360 )
        {
          v24 = (*(__int64 (__fastcall **)(__int64 *))(*v360 + 344))(v360);
          v25 = v24;
          if ( v24 > 0 )
          {
            sub_14726C030(v23, v24);
            v26 = 0;
            v27 = 0;
            do
            {
              (*(void (__fastcall **)(__int64 *, __int64 **, _QWORD))(*v360 + 352))(v360, &v359, (unsigned int)v26);
              if ( *(double *)&v359 != 0.0 )
              {
                v28 = *(_QWORD *)(v23 + 16);
                v336 = *(double *)&v359;
                v29 = (_QWORD *)(v27 + v28);
                (*(void (__fastcall **)(__int64 *))(*v359 + 32))(v359);
                sub_147245730(rcx0, (__int64)a7, (__int64)v20, (__int64 **)&v336);
                v30 = (char *)(*(__int64 (__fastcall **)(__int64 *, int *))(*v359 + 272))(v359, &dword_147F36950);
                if ( v30 && *v30 && (*v30 != 48 || v30[1]) )
                {
                  v31 = sub_1402BA020((__int64 *)v452, v30);
                  _RDX = (_BYTE *)rcx0[54];
                  *(_QWORD *)v424 = v29;
                  _XMM1 = *(_OWORD *)v31;
                  *(_OWORD *)&v424[8] = *(_OWORD *)v31;
                  if ( _RDX == (_BYTE *)rcx0[55] )
                  {
                    sub_1402A56E0(rcx0 + 53, _RDX, (__int64)v424);
                    *(double *)&v23 = v335;
                  }
                  else
                  {
                    *(double *)&v23 = v335;
                    *(_OWORD *)_RDX = *(_OWORD *)v424;
                    __asm { vmovhpd qword ptr [rdx+10h], xmm1 }
                    rcx0[54] += 24LL;
                  }
                }
                else
                {
                  *v29 = 0;
                  v29[1] = 0;
                }
                if ( *(double *)&v359 != 0.0 )
                {
                  (*(void (__fastcall **)(__int64 *))(*v359 + 40))(v359);
                }
              }
              ++v26;
              v27 += 24;
            }
            while ( v26 < v25 );
            v11 = a5;
          }
          v34 = v360;
          goto LABEL_22;
        }
        goto LABEL_25;
      }
      if ( n3 == 2 )
      {
        if ( v21 )
        {
          (*(void (__fastcall **)(__int64 *, __int64 **, const char *))(**v12 + 360))(*v12, &v364, *v20);
          v54 = (__int64)&v20[1][v11];
          v335 = *(double *)&v54;
          if ( v364 )
          {
            v55 = (*(__int64 (__fastcall **)(__int64 *))(*v364 + 344))(v364);
            v56 = v55;
            if ( v55 > 0 )
            {
              sub_14726C0C0(v54, v55);
              v57 = 0;
              v58 = 0;
              do
              {
                (*(void (__fastcall **)(__int64 *, __int64 **, _QWORD))(*v364 + 352))(v364, &v363, (unsigned int)v57);
                if ( *(double *)&v363 != 0.0 )
                {
                  v336 = *(double *)&v363;
                  (*(void (__fastcall **)(__int64 *))(*v363 + 32))(v363);
                  sub_147245730(rcx0, (__int64)v9, (__int64)v20, (__int64 **)&v336);
                  v59 = (_QWORD *)(v58 + *(_QWORD *)(v54 + 16));
                  v60 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, int *))(*v363 + 272))(v363, &dword_147F36950);
                  if ( *v60 != 48 || v60[1] )
                  {
                    v61 = CreateStringObjectFromString(&v434, v60);
                    v62 = CreateStringObjectFromString(&v437, a2);
                    sub_1403577C0(&v361, (const void **)v62);
                    sub_140380E90(&v361, ".");
                    sub_1403577C0(&v362, (const void **)&v361);
                    sub_140380E40(&v362, (char **)v61);
                    DestroyStringObject(&v361);
                    DestroyStringObject(&v437);
                    DestroyStringObject(&v434);
                    v408 = v59;
                    initializeEmptyStringStructure(&v409);
                    copyStringStructure(&v409, (const void **)&v362);
                    sub_1403BF6A0((char **)&v409);
                    v63 = rcx0[57];
                    if ( v63 == rcx0[58] )
                    {
                      sub_141D9EE10((char **)rcx0 + 56, (char *)v63, &v408);
                    }
                    else
                    {
                      *(_QWORD *)v63 = v408;
                      sub_1403577A0((_QWORD *)(v63 + 8), (__int64 *)&v409);
                      rcx0[57] += 16LL;
                    }
                    DestroyStringObject(&v409);
                    DestroyStringObject(&v362);
                    *(double *)&v54 = v335;
                  }
                  else
                  {
                    *v59 = 0;
                  }
                  if ( *(double *)&v363 != 0.0 )
                  {
                    (*(void (__fastcall **)(__int64 *))(*v363 + 40))(v363);
                  }
                  v9 = a7;
                }
                ++v57;
                v58 += 16;
              }
              while ( v57 < v56 );
              v11 = a5;
            }
            v34 = v364;
LABEL_22:
            if ( v34 )
            {
              (*(void (__fastcall **)(__int64 *))(*v34 + 40))(v34);
            }
LABEL_24:
            v15 = rcx0;
          }
        }
        else
        {
          v64 = &v20[1][v11];
          v65 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, const char *))(**a3 + 272))(*a3, *v20);
          if ( *v65 != 48 || v65[1] )
          {
            v66 = CreateStringObjectFromString(&v438, v65);
            v67 = CreateStringObjectFromString(&v436, v14);
            sub_1403577C0(&v365, (const void **)v67);
            sub_140380E90(&v365, ".");
            sub_1403577C0(&v366, (const void **)&v365);
            sub_140380E40(&v366, (char **)v66);
            DestroyStringObject(&v365);
            DestroyStringObject(&v436);
            DestroyStringObject(&v438);
            v410 = v64;
            initializeEmptyStringStructure(&v411);
            copyStringStructure(&v411, (const void **)&v366);
            sub_1403BF6A0((char **)&v411);
            v68 = v15[57];
            if ( v68 == v15[58] )
            {
              sub_141D9EE10((char **)v15 + 56, (char *)v68, &v410);
            }
            else
            {
              *(_QWORD *)v68 = v410;
              sub_1403577A0((_QWORD *)(v68 + 8), (__int64 *)&v411);
              v15[57] += 16LL;
            }
            DestroyStringObject(&v411);
            DestroyStringObject(&v366);
          }
          else
          {
            *(_QWORD *)v64 = 0;
          }
        }
LABEL_25:
        v13 = a6;
        goto LABEL_26;
      }
      if ( !v21 )
      {
        switch ( *((_BYTE *)v20 + 24) )
        {
          case 1:
            if ( v20[2] != (const char *)1 )
            {
              v284 = *v20;
              v285 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v285,
                v284);
            }
            v286 = *v12;
            v287 = *v20;
            LOBYTE(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v286 + 280))(v286, v287) )
            {
              goto LABEL_349;
            }
            v288 = *v12;
            v289 = *v20;
            LOBYTE(Src) = 0;
            (*(void (__fastcall **)(__int64 *, const char *, float *))(*v288 + 144))(v288, v289, &Src);
            goto LABEL_350;
          case 2:
            if ( v20[2] != (const char *)1 )
            {
              v221 = *v20;
              v222 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v222,
                v221);
            }
            v223 = *v12;
            v224 = *v20;
            LOBYTE(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v223 + 280))(v223, v224) )
            {
              goto LABEL_349;
            }
            v225 = (*(__int64 (__fastcall **)(__int64 *, const char *, char *))(**v12 + 256))(*v12, *v20, v355);
            v226 = 0;
            if ( v225 )
            {
              v226 = v355[0];
            }
            LOBYTE(Src) = v226;
            goto LABEL_350;
          case 3:
            if ( v20[2] != (const char *)2 )
            {
              v227 = *v20;
              v228 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v228,
                v227);
            }
            v229 = *v12;
            v230 = *v20;
            LOWORD(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v229 + 280))(v229, v230) )
            {
              goto LABEL_349;
            }
            v231 = (*(__int64 (__fastcall **)(__int64 *, const char *, __int16 *))(**v12 + 256))(*v12, *v20, v356);
            v232 = 0;
            if ( v231 )
            {
              v232 = v356[0];
            }
            LOWORD(Src) = v232;
            goto LABEL_350;
          case 4:
            if ( v20[2] != (const char *)4 )
            {
              v234 = *v20;
              v235 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v235,
                v234);
            }
            v236 = *v12;
            v237 = *v20;
            LODWORD(v335) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v236 + 280))(v236, v237) )
            {
              goto LABEL_383;
            }
            v238 = *v12;
            v239 = *v20;
            LODWORD(v335) = 0;
            (*(void (__fastcall **)(__int64 *, const char *, double *))(*v238 + 256))(v238, v239, &v335);
            goto LABEL_384;
          case 5:
            if ( v20[2] != (const char *)8 )
            {
              v240 = *v20;
              v241 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v241,
                v240);
            }
            v242 = *v12;
            v243 = *v20;
            v336 = 0.0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v242 + 280))(v242, v243) )
            {
              goto LABEL_389;
            }
            v244 = *v12;
            v245 = *v20;
            v336 = 0.0;
            (*(void (__fastcall **)(__int64 *, const char *, double *))(*v244 + 240))(v244, v245, &v336);
            goto LABEL_390;
          case 6:
            if ( v20[2] != (const char *)1 )
            {
              v246 = *v20;
              v247 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v247,
                v246);
            }
            v248 = *v12;
            v249 = *v20;
            LOBYTE(Src) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v248 + 280))(v248, v249) )
            {
              goto LABEL_349;
            }
            v250 = (*(__int64 (__fastcall **)(__int64 *, const char *, char *))(**v12 + 248))(*v12, *v20, v357);
            v251 = 0;
            if ( v250 )
            {
              v251 = v357[0];
            }
            LOBYTE(Src) = v251;
            goto LABEL_350;
          case 7:
            if ( v20[2] != (const char *)2 )
            {
              v252 = *v20;
              v253 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v253,
                v252);
            }
            v254 = *v12;
            v255 = *v20;
            LOWORD(Src) = 0;
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v254 + 280))(v254, v255) )
            {
              v256 = (*(__int64 (__fastcall **)(__int64 *, const char *, __int16 *))(**v12 + 248))(*v12, *v20, &v358);
              v257 = 0;
              if ( v256 )
              {
                v257 = v358;
              }
              LOWORD(Src) = v257;
            }
            else
            {
LABEL_349:
              v233 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Cannot locate default atomic value for field '%s' in record '%s'. Please provide default valu"
                "e within the schema. Value will be UNINITIALIZED!",
                *v20,
                v233);
            }
LABEL_350:
            memcpy((void *)&v20[1][v11], &Src, (size_t)v20[2]);
            goto LABEL_25;
          case 8:
            if ( v20[2] != (const char *)4 )
            {
              v258 = *v20;
              v259 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v259,
                v258);
            }
            v260 = *v12;
            v261 = *v20;
            LODWORD(v335) = 0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v260 + 280))(v260, v261) )
            {
              goto LABEL_383;
            }
            v262 = *v12;
            v263 = *v20;
            LODWORD(v335) = 0;
            (*(void (__fastcall **)(__int64 *, const char *, double *))(*v262 + 248))(v262, v263, &v335);
            goto LABEL_384;
          case 9:
            if ( v20[2] != (const char *)8 )
            {
              v264 = *v20;
              v265 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v265,
                v264);
            }
            v266 = *v12;
            v267 = *v20;
            v336 = 0.0;
            if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v266 + 280))(v266, v267) )
            {
              goto LABEL_389;
            }
            v268 = *v12;
            v269 = *v20;
            v336 = 0.0;
            (*(void (__fastcall **)(__int64 *, const char *, double *, _QWORD))(*v268 + 232))(v268, v269, &v336, 0);
            goto LABEL_390;
          case 0xA:
            if ( v20[2] != (const char *)16 )
            {
              v290 = *v20;
              v291 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Strings must be const char*",
                v291,
                v290);
            }
            v292 = (__int64)&v20[1][v11];
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(**v12 + 280))(*v12, *v20) )
            {
              v293 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, const char *))(**v12 + 272))(*v12, *v20);
              if ( v293 )
              {
                if ( *v293 )
                {
                  CreateStringObjectFromString(&a1, v293);
                  sub_1403E3F10(&a1, SubStr_, "&");
                  sub_1403E3F10(&a1, "&quot;", "\"");
                  sub_1403E3F10(&a1, "&apos;", "'");
                  sub_1403E3F10(&a1, SubStr__0, "<");
                  sub_1403E3F10(&a1, SubStr__1, ">");
                  sub_140376330(v292, a1);
                  DestroyStringObject(&a1);
                }
              }
            }
            goto LABEL_25;
          case 0xB:
            if ( v20[2] != (const char *)4 )
            {
              v270 = *v20;
              v271 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v271,
                v270);
            }
            v272 = *v12;
            v273 = *v20;
            *(float *)&v335 = 0.0;
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v272 + 280))(v272, v273) )
            {
              v274 = *v12;
              v275 = *v20;
              *(float *)&v335 = 0.0;
              (*(void (__fastcall **)(__int64 *, const char *, double *))(*v274 + 224))(v274, v275, &v335);
            }
            else
            {
LABEL_383:
              v276 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Cannot locate default atomic value for field '%s' in record '%s'. Please provide default valu"
                "e within the schema. Value will be UNINITIALIZED!",
                *v20,
                v276);
            }
LABEL_384:
            memcpy((void *)&v20[1][v11], &v335, (size_t)v20[2]);
            goto LABEL_25;
          case 0xC:
            if ( v20[2] != (const char *)8 )
            {
              v277 = *v20;
              v278 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Record %s field %s",
                v278,
                v277);
            }
            v279 = *v12;
            v280 = *v20;
            v336 = 0.0;
            if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(*v279 + 280))(v279, v280) )
            {
              v281 = *v12;
              v282 = *v20;
              v336 = 0.0;
              (*(void (__fastcall **)(__int64 *, const char *, double *))(*v281 + 216))(v281, v282, &v336);
            }
            else
            {
LABEL_389:
              v283 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Cannot locate default atomic value for field '%s' in record '%s'. Please provide default valu"
                "e within the schema. Value will be UNINITIALIZED!",
                *v20,
                v283);
            }
LABEL_390:
            memcpy((void *)&v20[1][v11], &v336, (size_t)v20[2]);
            goto LABEL_25;
          case 0xD:
            if ( v20[2] != (const char *)8 )
            {
              v301 = *v20;
              v302 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore structure %s field %s. Localisation field"
                "s must be type CLocIdentifier",
                v302,
                v301);
            }
            v303 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, const char *))(**v12 + 272))(*v12, *v20);
            if ( v303 && *v303 == 64 )
            {
              assignCStringToStringStructure((void **)&v20[1][v11], v303);
            }
            goto LABEL_25;
          case 0xE:
            if ( v20[2] != (const char *)16 )
            {
              v294 = *v20;
              v295 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore structure '%s' field '%s'. GUIDs must be CryGUID",
                v295,
                v294);
            }
            v296 = (char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(**v12 + 272))(*v12, *v20);
            v297 = v296;
            n36 = -1;
            do
            {
              ++n36;
            }
            while ( v296[n36] );
            if ( n36 == 36 )
            {
              *(_OWORD *)&v20[1][v11] = *(_OWORD *)sub_1402BA020((__int64 *)v455, v296);
            }
            else
            {
              v299 = *v20;
              v300 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] DataCore structure '%s' field '%s': Incoming field GUID '%s' is invalid (size is wrong).",
                v300,
                v299,
                v297);
            }
            goto LABEL_25;
          case 0xF:
            sub_147245BC0((__int64)v15, v11, v20, v12);
            goto LABEL_25;
          case 0x10:
            v304 = (__int64 *)&v20[1][v11];
            if ( n3 != 1 )
            {
              (*(void (__fastcall **)(__int64 *, __int64 **, const char *))(**v12 + 360))(*v12, &v351, *v20);
              if ( v351 )
              {
                v322 = (char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(*v351 + 272))(v351, "__type");
                if ( v9 )
                {
                  v323 = (char *)*v20;
                  Src_4 = Src_5 | 0x10;
                  v324 = CreateStringObjectFromString(&v442, ".");
                  initializeEmptyStringStructure(&v342);
                  v325 = sub_1403DD500((__int64)a7);
                  v326 = sub_1403E2EC0(v324);
                  sub_1403E4500(&v342, v326 + v325);
                  sub_140380E90(&v342, a7);
                  sub_140380E40(&v342, (char **)v324);
                  sub_1403577C0(&v402, (const void **)&v342);
                  sub_140380E90(&v402, v323);
                  v327 = &v402;
                  Src_1 = Src_4 | 0x60;
                  Src_4 |= 0x60u;
                }
                else
                {
                  v329 = (char *)*v20;
                  Src_1 = Src_5 | 0x80;
                  Src_4 = Src_1;
                  v327 = CreateStringObjectFromString(&v433, v329);
                }
                sub_1403577A0(&v403, (__int64 *)v327);
                if ( (Src_1 & 0x80u) != 0 )
                {
                  Src_1 &= ~0x80u;
                  Src_4 = Src_1;
                  DestroyStringObject(&v433);
                }
                if ( (Src_1 & 0x40) != 0 )
                {
                  Src_1 &= ~0x40u;
                  Src_4 = Src_1;
                  DestroyStringObject(&v402);
                }
                if ( (Src_1 & 0x20) != 0 )
                {
                  Src_1 &= ~0x20u;
                  Src_4 = Src_1;
                  DestroyStringObject(&v342);
                }
                if ( (Src_1 & 0x10) != 0 )
                {
                  Src_4 = Src_1 & 0xFFFFFFEF;
                  DestroyStringObject(&v442);
                }
                v407 = (char *)v351;
                if ( v351 )
                {
                  (*(void (__fastcall **)(__int64 *))(*v351 + 32))(v351);
                }
                v330 = (__int64 *)sub_1403BF6A0(&v403);
                sub_147245730(rcx0, *v330, (__int64)v20, (__int64 **)&v407);
                v331 = sub_1403BF6A0(&v403);
                v332 = (__int64)v304;
                v15 = rcx0;
                sub_14724E7E0(rcx0, a2, v332, v322, *v331, &v351);
                DestroyStringObject(&v403);
              }
              else
              {
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Non optional field \"%s\" doesn't exist in the source record \"%s\". Please add this field "
                  "to the schema and re-export the source record.",
                  *v20,
                  v14);
                v15 = rcx0;
              }
              if ( v351 )
              {
                (*(void (__fastcall **)(__int64 *))(*v351 + 40))(v351);
              }
              goto LABEL_25;
            }
            *v304 = 0;
            (*(void (__fastcall **)(__int64 *, __int64 **, const char *))(**v12 + 360))(*v12, &v341, *v20);
            if ( !v341 )
            {
              goto LABEL_24;
            }
            (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(*v341 + 360))(v341, &v422, "null");
            v305 = v422;
            if ( v422 )
            {
              goto LABEL_443;
            }
            v306 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*v341 + 272))(v341, "__type");
            v307 = (char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(*v341 + 272))(v341, "__polymorphicType");
            v308 = v307;
            if ( !v307 || !*v307 )
            {
              v308 = (char *)v306;
            }
            v416 = v308;
            sub_140357780(&v417, &v416);
            v309 = -1;
            do
            {
              ++v309;
            }
            while ( v417[v309] );
            v310 = rcx0 + 38;
            v311 = 0xCBF29CE484222325uLL;
            v312 = 0;
            if ( v309 )
            {
              do
              {
                v313 = (unsigned __int8)v417[v312++];
                v311 = 0x100000001B3LL * (v313 ^ v311);
              }
              while ( v312 < v309 );
              v11 = a5;
              v310 = rcx0 + 38;
            }
            sub_147218A50(
              rcx0 + 38,
              &v447,
              &v417,
              0xDE5FB9D2630458E9uLL * v311 + (((unsigned __int64)v311 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
            v417 = (char *)&qword_149808ABC + 4;
            DestroyStringObject(&v417);
            if ( v447 == *v310 + v310[3] )
            {
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Structure of type \"%s\" is not a game-registered structure. Is this defined in DataCorePreIn"
                "it.cpp or DataCoreGame.cpp?",
                v308);
            }
            else
            {
              v314 = (char *)*v20;
              if ( a7 )
              {
                Src_4 |= 1u;
                v315 = CreateStringObjectFromString(&v432, ".");
                initializeEmptyStringStructure(&v340);
                v316 = sub_1403DD500((__int64)a7);
                v317 = sub_1403E2EC0(v315);
                sub_1403E4500(&v340, v317 + v316);
                sub_140380E90(&v340, a7);
                sub_140380E40(&v340, (char **)v315);
                sub_1403577C0(&v401, (const void **)&v340);
                sub_140380E90(&v401, v314);
                v318 = &v401;
                Src_2 = Src_4 | 6;
                Src_4 |= 6u;
              }
              else
              {
                Src_2 = Src_4 | 8;
                Src_4 |= 8u;
                v318 = CreateStringObjectFromString(&v431, v314);
              }
              sub_1403577A0(&v421, (__int64 *)v318);
              if ( (Src_2 & 8) != 0 )
              {
                Src_2 &= ~8u;
                Src_4 = Src_2;
                DestroyStringObject(&v431);
              }
              if ( (Src_2 & 4) != 0 )
              {
                Src_2 &= ~4u;
                Src_4 = Src_2;
                DestroyStringObject(&v401);
              }
              if ( (Src_2 & 2) != 0 )
              {
                Src_2 &= ~2u;
                Src_4 = Src_2;
                DestroyStringObject(&v340);
              }
              if ( (Src_2 & 1) != 0 )
              {
                Src_4 = Src_2 & 0xFFFFFFFE;
                DestroyStringObject(&v432);
              }
              *v304 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v448 + 24))(*(_QWORD *)(v448 + 24), 0);
              v320 = sub_1403BF6A0(&v421);
              sub_14724E7E0(rcx0, a2, *v304, v308, *v320, &v341);
              v321 = (_BYTE *)rcx0[48];
              if ( v321 == (_BYTE *)rcx0[49] )
              {
                sub_1402A4BA0(rcx0 + 47, v321, v304);
              }
              else
              {
                *(_QWORD *)v321 = *v304;
                rcx0[48] += 8LL;
              }
              DestroyStringObject(&v421);
            }
            v305 = v422;
            if ( v422 )
            {
LABEL_443:
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v305 + 40LL))(v305);
            }
            v34 = v341;
            break;
          default:
            goto LABEL_26;
        }
        goto LABEL_22;
      }
      switch ( *((_BYTE *)v20 + 24) )
      {
        case 1:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v388, *v20);
          v145 = v20[1];
          if ( v388 )
          {
            n0x6400000 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v388 + 344LL))(v388);
            n0x6400000_12 = n0x6400000;
            if ( n0x6400000 > 0 )
            {
              *(_QWORD *)&v145[v11 + 24] = n0x6400000;
              *(_QWORD *)&v145[v11 + 32] = n0x6400000;
              *(_QWORD *)&v145[v11 + 16] = sub_1402A1E30(n0x6400000);
              n0x6400000_13 = 0;
              v145[v11 + 8] = 1;
              v149 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v388 + 352LL))(
                  v388,
                  &v387,
                  (unsigned int)n0x6400000_13);
                if ( v387
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v387 + 280LL))(
                       v387,
                       &dword_147F36950) )
                {
                  LOBYTE(Src) = 0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v387 + 144LL))(
                    v387,
                    &dword_147F36950,
                    &Src);
                  *(_BYTE *)(v149 + *(_QWORD *)&v145[v11 + 16]) = LOBYTE(Src);
                }
                else
                {
                  v150 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v150);
                }
                if ( v387 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v387 + 40LL))(v387);
                }
                ++n0x6400000_13;
                ++v149;
              }
              while ( n0x6400000_13 < n0x6400000_12 );
            }
            if ( v388 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v388 + 40LL))(v388);
            }
          }
          goto LABEL_25;
        case 2:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v368, *v20);
          v69 = v20[1];
          if ( v368 )
          {
            n0x6400000_1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v368 + 344LL))(v368);
            n0x6400000_14 = n0x6400000_1;
            if ( n0x6400000_1 > 0 )
            {
              *(_QWORD *)&v69[v11 + 24] = n0x6400000_1;
              *(_QWORD *)&v69[v11 + 32] = n0x6400000_1;
              *(_QWORD *)&v69[v11 + 16] = sub_1402A1E30(n0x6400000_1);
              n0x6400000_15 = 0;
              v69[v11 + 8] = 1;
              v73 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v368 + 352LL))(
                  v368,
                  &v367,
                  (unsigned int)n0x6400000_15);
                if ( v367
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v367 + 280LL))(
                       v367,
                       &dword_147F36950) )
                {
                  v74 = (*(__int64 (__fastcall **)(__int64, int *, char *))(*(_QWORD *)v367 + 256LL))(
                          v367,
                          &dword_147F36950,
                          v404);
                  v75 = 0;
                  if ( v74 )
                  {
                    v75 = v404[0];
                  }
                  *(_BYTE *)(v73 + *(_QWORD *)&v69[v11 + 16]) = v75;
                }
                else
                {
                  v76 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v76);
                }
                if ( v367 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v367 + 40LL))(v367);
                }
                ++n0x6400000_15;
                ++v73;
              }
              while ( n0x6400000_15 < n0x6400000_14 );
            }
            if ( v368 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v368 + 40LL))(v368);
            }
          }
          goto LABEL_25;
        case 3:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v370, *v20);
          v77 = v20[1];
          if ( v370 )
          {
            v78 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v370 + 344LL))(v370);
            v79 = v78;
            if ( v78 > 0 )
            {
              *(_QWORD *)&v77[v11 + 24] = v78;
              *(_QWORD *)&v77[v11 + 32] = v78;
              n0x6400000_2 = 2LL * v78;
              if ( !is_mul_ok(v79, 2u) )
              {
                n0x6400000_2 = -1;
              }
              *(_QWORD *)&v77[v11 + 16] = sub_1402A1E30(n0x6400000_2);
              v81 = 0;
              v77[v11 + 8] = 1;
              v82 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v370 + 352LL))(
                  v370,
                  &v369,
                  (unsigned int)v81);
                if ( v369
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v369 + 280LL))(
                       v369,
                       &dword_147F36950) )
                {
                  v83 = (*(__int64 (__fastcall **)(__int64, int *, __int16 *))(*(_QWORD *)v369 + 256LL))(
                          v369,
                          &dword_147F36950,
                          v352);
                  v84 = 0;
                  if ( v83 )
                  {
                    v84 = v352[0];
                  }
                  *(_WORD *)(v82 + *(_QWORD *)&v77[v11 + 16]) = v84;
                }
                else
                {
                  v85 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v85);
                }
                if ( v369 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v369 + 40LL))(v369);
                }
                ++v81;
                v82 += 2;
              }
              while ( v81 < (int)v79 );
              v15 = rcx0;
            }
            if ( v370 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v370 + 40LL))(v370);
            }
          }
          goto LABEL_25;
        case 4:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v372, *v20);
          v86 = v20[1];
          if ( v372 )
          {
            v87 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v372 + 344LL))(v372);
            v88 = v87;
            if ( v87 > 0 )
            {
              *(_QWORD *)&v86[v11 + 24] = v87;
              *(_QWORD *)&v86[v11 + 32] = v87;
              n0x6400000_3 = 4LL * v87;
              if ( !is_mul_ok(v88, 4u) )
              {
                n0x6400000_3 = -1;
              }
              *(_QWORD *)&v86[v11 + 16] = sub_1402A1E30(n0x6400000_3);
              v90 = 0;
              v86[v11 + 8] = 1;
              v91 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v372 + 352LL))(
                  v372,
                  &v371,
                  (unsigned int)v90);
                if ( v371
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v371 + 280LL))(
                       v371,
                       &dword_147F36950) )
                {
                  Src = 0.0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v371 + 256LL))(
                    v371,
                    &dword_147F36950,
                    &Src);
                  *(float *)(v91 + *(_QWORD *)&v86[v11 + 16]) = Src;
                }
                else
                {
                  v92 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v92);
                }
                if ( v371 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v371 + 40LL))(v371);
                }
                ++v90;
                v91 += 4;
              }
              while ( v90 < (int)v88 );
              v15 = rcx0;
            }
            if ( v372 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v372 + 40LL))(v372);
            }
          }
          goto LABEL_25;
        case 5:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v374, *v20);
          v93 = v20[1];
          if ( v374 )
          {
            v94 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v374 + 344LL))(v374);
            v95 = v94;
            if ( v94 > 0 )
            {
              *(_QWORD *)&v93[v11 + 24] = v94;
              *(_QWORD *)&v93[v11 + 32] = v94;
              n0x6400000_4 = 8LL * v94;
              if ( !is_mul_ok(v95, 8u) )
              {
                n0x6400000_4 = -1;
              }
              *(_QWORD *)&v93[v11 + 16] = sub_1402A1E30(n0x6400000_4);
              v97 = 0;
              v93[v11 + 8] = 1;
              v98 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v374 + 352LL))(
                  v374,
                  &v373,
                  (unsigned int)v97);
                if ( v373
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v373 + 280LL))(
                       v373,
                       &dword_147F36950) )
                {
                  v335 = 0.0;
                  (*(void (__fastcall **)(__int64, int *, double *))(*(_QWORD *)v373 + 240LL))(
                    v373,
                    &dword_147F36950,
                    &v335);
                  *(double *)(v98 + *(_QWORD *)&v93[v11 + 16]) = v335;
                }
                else
                {
                  v99 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v99);
                }
                if ( v373 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v373 + 40LL))(v373);
                }
                ++v97;
                v98 += 8;
              }
              while ( v97 < (int)v95 );
              v15 = rcx0;
            }
            if ( v374 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v374 + 40LL))(v374);
            }
          }
          goto LABEL_25;
        case 6:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v376, *v20);
          v100 = v20[1];
          if ( v376 )
          {
            n0x6400000_5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v376 + 344LL))(v376);
            n0x6400000_16 = n0x6400000_5;
            if ( n0x6400000_5 > 0 )
            {
              *(_QWORD *)&v100[v11 + 24] = n0x6400000_5;
              *(_QWORD *)&v100[v11 + 32] = n0x6400000_5;
              *(_QWORD *)&v100[v11 + 16] = sub_1402A1E30(n0x6400000_5);
              n0x6400000_17 = 0;
              v100[v11 + 8] = 1;
              v104 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v376 + 352LL))(
                  v376,
                  &v375,
                  (unsigned int)n0x6400000_17);
                if ( v375
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v375 + 280LL))(
                       v375,
                       &dword_147F36950) )
                {
                  v105 = (*(__int64 (__fastcall **)(__int64, int *, char *))(*(_QWORD *)v375 + 248LL))(
                           v375,
                           &dword_147F36950,
                           v353);
                  v106 = 0;
                  if ( v105 )
                  {
                    v106 = v353[0];
                  }
                  *(_BYTE *)(v104 + *(_QWORD *)&v100[v11 + 16]) = v106;
                }
                else
                {
                  v107 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v107);
                }
                if ( v375 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v375 + 40LL))(v375);
                }
                ++n0x6400000_17;
                ++v104;
              }
              while ( n0x6400000_17 < n0x6400000_16 );
            }
            if ( v376 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v376 + 40LL))(v376);
            }
          }
          goto LABEL_25;
        case 7:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v378, *v20);
          v108 = v20[1];
          if ( v378 )
          {
            v109 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v378 + 344LL))(v378);
            v110 = v109;
            if ( v109 > 0 )
            {
              *(_QWORD *)&v108[v11 + 24] = v109;
              *(_QWORD *)&v108[v11 + 32] = v109;
              n0x6400000_6 = 2LL * v109;
              if ( !is_mul_ok(v110, 2u) )
              {
                n0x6400000_6 = -1;
              }
              *(_QWORD *)&v108[v11 + 16] = sub_1402A1E30(n0x6400000_6);
              v112 = 0;
              v108[v11 + 8] = 1;
              v113 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v378 + 352LL))(
                  v378,
                  &v377,
                  (unsigned int)v112);
                if ( v377
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v377 + 280LL))(
                       v377,
                       &dword_147F36950) )
                {
                  v114 = (*(__int64 (__fastcall **)(__int64, int *, __int16 *))(*(_QWORD *)v377 + 248LL))(
                           v377,
                           &dword_147F36950,
                           v354);
                  v115 = 0;
                  if ( v114 )
                  {
                    v115 = v354[0];
                  }
                  *(_WORD *)(v113 + *(_QWORD *)&v108[v11 + 16]) = v115;
                }
                else
                {
                  v116 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v116);
                }
                if ( v377 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v377 + 40LL))(v377);
                }
                ++v112;
                v113 += 2;
              }
              while ( v112 < (int)v110 );
              v15 = rcx0;
            }
            if ( v378 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v378 + 40LL))(v378);
            }
          }
          goto LABEL_25;
        case 8:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v380, *v20);
          v117 = v20[1];
          if ( v380 )
          {
            v118 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v380 + 344LL))(v380);
            v119 = v118;
            if ( v118 > 0 )
            {
              *(_QWORD *)&v117[v11 + 24] = v118;
              *(_QWORD *)&v117[v11 + 32] = v118;
              n0x6400000_7 = 4LL * v118;
              if ( !is_mul_ok(v119, 4u) )
              {
                n0x6400000_7 = -1;
              }
              *(_QWORD *)&v117[v11 + 16] = sub_1402A1E30(n0x6400000_7);
              v121 = 0;
              v117[v11 + 8] = 1;
              v122 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v380 + 352LL))(
                  v380,
                  &v379,
                  (unsigned int)v121);
                if ( v379
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v379 + 280LL))(
                       v379,
                       &dword_147F36950) )
                {
                  Src = 0.0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v379 + 248LL))(
                    v379,
                    &dword_147F36950,
                    &Src);
                  *(float *)(v122 + *(_QWORD *)&v117[v11 + 16]) = Src;
                }
                else
                {
                  v123 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v123);
                }
                if ( v379 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v379 + 40LL))(v379);
                }
                ++v121;
                v122 += 4;
              }
              while ( v121 < (int)v119 );
              v15 = rcx0;
            }
            if ( v380 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v380 + 40LL))(v380);
            }
          }
          goto LABEL_25;
        case 9:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v382, *v20);
          v124 = v20[1];
          if ( v382 )
          {
            v125 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v382 + 344LL))(v382);
            v126 = v125;
            if ( v125 > 0 )
            {
              *(_QWORD *)&v124[v11 + 24] = v125;
              *(_QWORD *)&v124[v11 + 32] = v125;
              n0x6400000_8 = 8LL * v125;
              if ( !is_mul_ok(v126, 8u) )
              {
                n0x6400000_8 = -1;
              }
              *(_QWORD *)&v124[v11 + 16] = sub_1402A1E30(n0x6400000_8);
              v128 = 0;
              v124[v11 + 8] = 1;
              v129 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v382 + 352LL))(
                  v382,
                  &v381,
                  (unsigned int)v128);
                if ( v381
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v381 + 280LL))(
                       v381,
                       &dword_147F36950) )
                {
                  v335 = 0.0;
                  (*(void (__fastcall **)(__int64, int *, double *, _QWORD))(*(_QWORD *)v381 + 232LL))(
                    v381,
                    &dword_147F36950,
                    &v335,
                    0);
                  *(double *)(v129 + *(_QWORD *)&v124[v11 + 16]) = v335;
                }
                else
                {
                  v130 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v130);
                }
                if ( v381 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v381 + 40LL))(v381);
                }
                ++v128;
                v129 += 8;
              }
              while ( v128 < (int)v126 );
              v15 = rcx0;
            }
            if ( v382 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v382 + 40LL))(v382);
            }
          }
          goto LABEL_25;
        case 0xA:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v390, *v20);
          v151 = (__int64)&v20[1][v11];
          if ( v390 )
          {
            v152 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v390 + 344LL))(v390);
            v153 = v152;
            if ( v152 > 0 )
            {
              sub_14726BF90(v151, v152);
              v154 = 0;
              v155 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v390 + 352LL))(
                  v390,
                  &v389,
                  (unsigned int)v154);
                if ( v389
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v389 + 280LL))(
                       v389,
                       &dword_147F36950) )
                {
                  v156 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v389 + 272LL))(
                                    v389,
                                    &dword_147F36950);
                  sub_14035E310((__int64)v451, v156);
                  sub_1403762E0((__int64 *)(v155 + *(_QWORD *)(v151 + 16)), v451);
                  sub_14036F160((__int64)v451);
                }
                else
                {
                  v157 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v157);
                }
                if ( v389 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v389 + 40LL))(v389);
                }
                ++v154;
                v155 += 16;
              }
              while ( v154 < v153 );
            }
            if ( v390 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v390 + 40LL))(v390);
            }
          }
          goto LABEL_25;
        case 0xB:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v384, *v20);
          v131 = v20[1];
          if ( v384 )
          {
            v132 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v384 + 344LL))(v384);
            v133 = v132;
            if ( v132 > 0 )
            {
              *(_QWORD *)&v131[v11 + 24] = v132;
              *(_QWORD *)&v131[v11 + 32] = v132;
              n0x6400000_9 = 4LL * v132;
              if ( !is_mul_ok(v133, 4u) )
              {
                n0x6400000_9 = -1;
              }
              *(_QWORD *)&v131[v11 + 16] = sub_1402A1E30(n0x6400000_9);
              v135 = 0;
              v131[v11 + 8] = 1;
              v136 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v384 + 352LL))(
                  v384,
                  &v383,
                  (unsigned int)v135);
                if ( v383
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v383 + 280LL))(
                       v383,
                       &dword_147F36950) )
                {
                  Src = 0.0;
                  (*(void (__fastcall **)(__int64, int *, float *))(*(_QWORD *)v383 + 224LL))(
                    v383,
                    &dword_147F36950,
                    &Src);
                  *(float *)(v136 + *(_QWORD *)&v131[v11 + 16]) = Src;
                }
                else
                {
                  v137 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v137);
                }
                if ( v383 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v383 + 40LL))(v383);
                }
                ++v135;
                v136 += 4;
              }
              while ( v135 < (int)v133 );
            }
            if ( v384 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v384 + 40LL))(v384);
            }
          }
          goto LABEL_25;
        case 0xC:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v386, *v20);
          v138 = v20[1];
          if ( v386 )
          {
            v139 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v386 + 344LL))(v386);
            v140 = v139;
            if ( v139 > 0 )
            {
              *(_QWORD *)&v138[v11 + 24] = v139;
              *(_QWORD *)&v138[v11 + 32] = v139;
              n0x6400000_10 = 8LL * v139;
              if ( !is_mul_ok(v140, 8u) )
              {
                n0x6400000_10 = -1;
              }
              *(_QWORD *)&v138[v11 + 16] = sub_1402A1E30(n0x6400000_10);
              v142 = 0;
              v138[v11 + 8] = 1;
              v143 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v386 + 352LL))(
                  v386,
                  &v385,
                  (unsigned int)v142);
                if ( v385
                  && (*(unsigned __int8 (__fastcall **)(__int64, int *))(*(_QWORD *)v385 + 280LL))(
                       v385,
                       &dword_147F36950) )
                {
                  v335 = 0.0;
                  (*(void (__fastcall **)(__int64, int *, double *))(*(_QWORD *)v385 + 216LL))(
                    v385,
                    &dword_147F36950,
                    &v335);
                  *(double *)(v143 + *(_QWORD *)&v138[v11 + 16]) = v335;
                }
                else
                {
                  v144 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
                  sub_1405BD4A0(
                    8u,
                    0,
                    "[DataCore] Cannot locate default array value for field '%s' in record '%s'. Please provide default v"
                    "alue within the schema. Value will be UNINITIALIZED!",
                    *v20,
                    v144);
                }
                if ( v385 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v385 + 40LL))(v385);
                }
                ++v142;
                v143 += 8;
              }
              while ( v142 < (int)v140 );
            }
            if ( v386 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v386 + 40LL))(v386);
            }
          }
          goto LABEL_25;
        case 0xD:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v395, *v20);
          if ( v395 )
          {
            v164 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v395 + 344LL))(v395);
            v165 = v164;
            if ( v164 > 0 )
            {
              v166 = (__int64)&v20[1][v11];
              sub_14726C160(v166, v164);
              v167 = 0;
              v168 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v395 + 352LL))(
                  v395,
                  &v394,
                  (unsigned int)v167);
                if ( v394 )
                {
                  CreateStringObjectFromString((void **)&v393, 0);
                  (*(void (__fastcall **)(__int64, int *, _BYTE **))(*(_QWORD *)v394 + 128LL))(
                    v394,
                    &dword_147F36950,
                    &v393);
                  if ( v393 && *v393 == 64 )
                  {
                    assignCStringToStringStructure((void **)(v168 + *(_QWORD *)(v166 + 16)), v393);
                  }
                  DestroyStringObject(&v393);
                  if ( v394 )
                  {
                    (*(void (__fastcall **)(__int64))(*(_QWORD *)v394 + 40LL))(v394);
                  }
                }
                ++v167;
                v168 += 8;
              }
              while ( v167 < v165 );
            }
            if ( v395 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v395 + 40LL))(v395);
            }
          }
          goto LABEL_25;
        case 0xE:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v392, *v20);
          if ( v392 )
          {
            v158 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v392 + 344LL))(v392);
            v159 = v158;
            if ( v158 > 0 )
            {
              v160 = v20[1];
              n0x6400000_11 = 16LL * v158;
              *(_QWORD *)&v160[v11 + 24] = v159;
              *(_QWORD *)&v160[v11 + 32] = v159;
              if ( !is_mul_ok(v159, 0x10u) )
              {
                n0x6400000_11 = -1;
              }
              *(_QWORD *)&v160[v11 + 16] = sub_1402A1E30(n0x6400000_11);
              v162 = 0;
              v160[v11 + 8] = 1;
              v163 = 0;
              do
              {
                (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v392 + 352LL))(
                  v392,
                  &v391,
                  (unsigned int)v162);
                if ( v391 )
                {
                  CreateStringObjectFromString((void **)&v349, 0);
                  (*(void (__fastcall **)(__int64, int *, char **))(*(_QWORD *)v391 + 128LL))(
                    v391,
                    &dword_147F36950,
                    &v349);
                  if ( sub_1403E2EC0(&v349) == 36 )
                  {
                    *(_OWORD *)(*(_QWORD *)&v160[v11 + 16] + v163) = *(_OWORD *)sub_1402BA020((__int64 *)v454, v349);
                  }
                  DestroyStringObject(&v349);
                  if ( v391 )
                  {
                    (*(void (__fastcall **)(__int64))(*(_QWORD *)v391 + 40LL))(v391);
                  }
                }
                ++v162;
                v163 += 16;
              }
              while ( v162 < (int)v159 );
            }
            if ( v392 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v392 + 40LL))(v392);
            }
          }
          goto LABEL_25;
        case 0xF:
          sub_147245E90((__int64)v15, v11, v20, v12);
          goto LABEL_25;
        case 0x10:
          (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(**v12 + 360))(*v12, &v339, *v20);
          if ( v339 )
          {
            LODWORD(Src_3) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v339 + 344LL))(v339);
            Src = Src_3;
            if ( SLODWORD(Src_3) > 0 )
            {
              if ( *((_BYTE *)v20 + 25) == 1 )
              {
                *(_QWORD *)&v336 = &v20[1][v11];
                v170 = *(__int64 **)&v336;
                sub_14726C0C0(*(__int64 *)&v336, SLODWORD(Src_3));
                v171 = 0;
                v335 = 0.0;
                v172 = 0.0;
                do
                {
                  (*(void (__fastcall **)(__int64, __int64 **, _QWORD))(*(_QWORD *)v339 + 352LL))(
                    v339,
                    &v346,
                    (unsigned int)v171);
                  v173 = (__int64 *)(*(__int64 (__fastcall **)(__int64 *, const char *))(*v346 + 272))(v346, "__type");
                  v405 = v173;
                  if ( v173 && *(_BYTE *)v173 )
                  {
                    v406 = (__int64 *)(*(_QWORD *)&v172 + v170[2]);
                    initializeEmptyStringStructure(&v350);
                    if ( v9 )
                    {
                      v174 = CreateStringObjectFromString(&v439, ".");
                      initializeEmptyStringStructure(&v344);
                      v175 = sub_1403E2EC0(v174);
                      v176 = sub_1403DD500((__int64)v9);
                      sub_1403E4500(&v344, v176 + v175);
                      sub_140380E90(&v344, v9);
                      sub_140380E40(&v344, (char **)v174);
                      sub_140380E40(&v350, (char **)&v344);
                      DestroyStringObject(&v344);
                      DestroyStringObject(&v439);
                    }
                    v177 = CreateStringObjectFromString(&v425, "]");
                    initializeEmptyStringStructure(&v441);
                    v179 = sub_1403A5050(v178, "%i", v171);
                    v180 = CreateStringObjectFromString(&v440, "[");
                    v181 = (char *)*v20;
                    v182 = v180;
                    initializeEmptyStringStructure(&v345);
                    v183 = sub_1403E2EC0(v182);
                    v184 = sub_1403DD500((__int64)v181);
                    sub_1403E4500(&v345, v184 + v183);
                    sub_140380E90(&v345, v181);
                    sub_140380E40(&v345, (char **)v182);
                    sub_1403577C0(&v397, (const void **)&v345);
                    sub_140380E40(&v397, (char **)v179);
                    sub_1403577C0(&v396, (const void **)&v397);
                    sub_140380E40(&v396, (char **)v177);
                    sub_140380E40(&v350, (char **)&v396);
                    DestroyStringObject(&v396);
                    DestroyStringObject(&v397);
                    DestroyStringObject(&v345);
                    DestroyStringObject(&v440);
                    DestroyStringObject(&v441);
                    DestroyStringObject(&v425);
                    v185 = (char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(*v346 + 272))(
                                     v346,
                                     "__polymorphicType");
                    v186 = v185;
                    if ( !v185 || !*v185 )
                    {
                      v186 = (char *)v405;
                    }
                    v15 = rcx0;
                    v412 = v186;
                    sub_140357780(&v413, &v412);
                    v187 = -1;
                    do
                    {
                      ++v187;
                    }
                    while ( v413[v187] );
                    v188 = 0xCBF29CE484222325uLL;
                    v189 = 0;
                    v190 = rcx0 + 38;
                    if ( v187 )
                    {
                      do
                      {
                        v191 = (unsigned __int8)v413[v189++];
                        v188 = 0x100000001B3LL * (v191 ^ v188);
                      }
                      while ( v189 < v187 );
                      v15 = rcx0;
                      v190 = rcx0 + 38;
                    }
                    sub_147218A50(
                      rcx0 + 38,
                      &v443,
                      &v413,
                      0xDE5FB9D2630458E9uLL * v188
                    + (((unsigned __int64)v188 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                    v413 = (char *)&qword_149808ABC + 4;
                    DestroyStringObject(&v413);
                    if ( v443 != *v190 + v190[3] )
                    {
                      v192 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v444 + 24))(*(_QWORD *)(v444 + 24), 0);
                      v193 = v406;
                      *v406 = v192;
                      v194 = sub_1403BF6A0((char **)&v350);
                      sub_14724E7E0(v15, a2, *v193, v186, *v194, &v346);
                      v195 = (_BYTE *)v15[48];
                      if ( v195 == (_BYTE *)v15[49] )
                      {
                        sub_1402A4BA0(v15 + 47, v195, v193);
                      }
                      else
                      {
                        *(_QWORD *)v195 = *v193;
                        v15[48] += 8LL;
                      }
                    }
                    DestroyStringObject(&v350);
                    if ( v346 )
                    {
                      (*(void (__fastcall **)(__int64 *))(*v346 + 40))(v346);
                    }
                    v9 = a7;
                    v170 = *(__int64 **)&v336;
                    v172 = v335;
                  }
                  else if ( v346 )
                  {
                    (*(void (__fastcall **)(__int64 *))(*v346 + 40))(v346);
                  }
                  *(_QWORD *)&v172 += 16LL;
                  ++v171;
                  v335 = v172;
                }
                while ( v171 < SLODWORD(Src) );
                v11 = a5;
              }
              else
              {
                v196 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v339 + 352LL))(
                                   v339,
                                   &v426,
                                   0);
                v197 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*v196 + 272LL))(
                                    *v196,
                                    "__type");
                v407 = (char *)v197;
                if ( v426 )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v426 + 40LL))(v426);
                }
                v198 = v20[1];
                v406 = (__int64 *)v198;
                v414 = v197;
                sub_140357780(&v415, &v414);
                v199 = -1;
                do
                {
                  ++v199;
                }
                while ( v415[v199] );
                v200 = v15 + 38;
                v201 = 0xCBF29CE484222325uLL;
                v202 = 0;
                if ( v199 )
                {
                  do
                  {
                    v203 = (unsigned __int8)v415[v202++];
                    v201 = 0x100000001B3LL * (v203 ^ v201);
                  }
                  while ( v202 < v199 );
                  v11 = a5;
                  v200 = v15 + 38;
                }
                sub_147218A50(
                  v15 + 38,
                  &v445,
                  &v415,
                  0xDE5FB9D2630458E9uLL * v201
                + (((unsigned __int64)v201 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                v415 = (char *)&qword_149808ABC + 4;
                DestroyStringObject(&v415);
                if ( v445 == *v200 + v200[3] )
                {
                  sub_1405BD4A0(
                    8u,
                    2u,
                    "[DataCore] Type %s was determined for Array \"%s\" but this type does not exist in the game-side str"
                    "uctures. Has it been removed or renamed?",
                    (const char *)v197,
                    *v20);
                }
                else
                {
                  v204 = SLODWORD(Src);
                  *(_QWORD *)&v198[v11 + 16] = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v446 + 24))(
                                                 *(_QWORD *)(v446 + 24),
                                                 SLODWORD(Src));
                  v205 = 0;
                  LODWORD(v335) = 0;
                  v336 = 0.0;
                  *(_QWORD *)&v198[v11 + 24] = v204;
                  do
                  {
                    (*(void (__fastcall **)(__int64, __int64 **, _QWORD))(*(_QWORD *)v339 + 352LL))(
                      v339,
                      &v400,
                      (unsigned int)v205);
                    initializeEmptyStringStructure(&v338);
                    if ( a7 )
                    {
                      v206 = CreateStringObjectFromString(&v427, ".");
                      initializeEmptyStringStructure(&v347);
                      v207 = sub_1403DD500((__int64)a7);
                      v208 = sub_1403E2EC0(v206);
                      sub_1403E4500(&v347, v208 + v207);
                      sub_140380E90(&v347, a7);
                      sub_140380E40(&v347, (char **)v206);
                      sub_140380E40(&v338, (char **)&v347);
                      DestroyStringObject(&v347);
                      DestroyStringObject(&v427);
                    }
                    v209 = CreateStringObjectFromString(&v430, "]");
                    initializeEmptyStringStructure(&v429);
                    v211 = sub_1403A5050(v210, "%i", v205);
                    v212 = CreateStringObjectFromString(&v428, "[");
                    v213 = (char *)*v20;
                    v214 = v212;
                    initializeEmptyStringStructure(&v348);
                    v215 = sub_1403E2EC0(v214);
                    v216 = sub_1403DD500((__int64)v213);
                    sub_1403E4500(&v348, v216 + v215);
                    sub_140380E90(&v348, v213);
                    sub_140380E40(&v348, (char **)v214);
                    sub_1403577C0(&v399, (const void **)&v348);
                    sub_140380E40(&v399, (char **)v211);
                    sub_1403577C0(&v398, (const void **)&v399);
                    sub_140380E40(&v398, (char **)v209);
                    sub_140380E40(&v338, (char **)&v398);
                    DestroyStringObject(&v398);
                    DestroyStringObject(&v399);
                    DestroyStringObject(&v348);
                    DestroyStringObject(&v428);
                    DestroyStringObject(&v429);
                    DestroyStringObject(&v430);
                    v217 = *(__int64 **)&v336;
                    v405 = v400;
                    v218 = *(__int64 *)((char *)v406 + v11 + 16)
                         + *(__int64 *)((char *)v406 + v11 + 40) * *(_QWORD *)&v336;
                    if ( v400 )
                    {
                      (*(void (__fastcall **)(__int64 *))(*v400 + 32))(v400);
                    }
                    v219 = (__int64 *)sub_1403BF6A0((char **)&v338);
                    v15 = rcx0;
                    sub_147245730(rcx0, *v219, (__int64)v20, &v405);
                    v220 = sub_1403BF6A0((char **)&v338);
                    sub_14724E7E0(rcx0, a2, v218, v407, *v220, &v400);
                    DestroyStringObject(&v338);
                    if ( v400 )
                    {
                      (*(void (__fastcall **)(__int64 *))(*v400 + 40))(v400);
                    }
                    v205 = LODWORD(v335) + 1;
                    *(_QWORD *)&v336 = (char *)v217 + 1;
                    LODWORD(v335) = v205;
                  }
                  while ( v205 < SLODWORD(Src) );
                }
              }
            }
            if ( v339 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v339 + 40LL))(v339);
            }
          }
          goto LABEL_25;
        default:
          break;
      }
LABEL_26:
      v9 = a7;
      v18 = v423 + 1;
      v12 = a3;
      v14 = a2;
      Src_5 = Src_4;
      v423 = v18;
    }
    while ( v18 < v435 );
    v10 = v460;
LABEL_28:
    result = *(_QWORD *)(v13 + 24);
    if ( result )
    {
      v418 = *(_QWORD *)(v13 + 24);
      sub_140357780(&v419, &v418);
      v36 = -1;
      do
      {
        ++v36;
      }
      while ( v419[v36] );
      v37 = v15 + 38;
      v38 = 0xCBF29CE484222325uLL;
      v39 = 0;
      if ( v36 )
      {
        do
        {
          v40 = (unsigned __int8)v419[v39++];
          v38 = 0x100000001B3LL * (v40 ^ v38);
        }
        while ( v39 < v36 );
        v11 = a5;
        v37 = v15 + 38;
      }
      sub_147218A50(
        v15 + 38,
        &v449,
        &v419,
        0xDE5FB9D2630458E9uLL * v38 + (((unsigned __int64)v38 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
      v419 = (char *)&qword_149808ABC + 4;
      DestroyStringObject(&v419);
      v41 = *(const char **)(a6 + 24);
      if ( v449 != *v37 + v37[3] )
      {
        v10 = *(const char **)(a6 + 24);
        v12 = a3;
        v13 = v450 + 8;
        a6 = v450 + 8;
        v460 = v41;
        continue;
      }
      return sub_1405BD4A0(
               8u,
               0,
               "[DataCore] structure [%s] inherited class [%s] is not registered",
               v10,
               *(const char **)(a6 + 24));
    }
    return result;
  }
}

// --- End Function: sub_1472461B0 (0x1472461B0) ---

// --- Function: sub_14724D1A0 (0x14724D1A0) ---
unsigned int *sub_14724D1A0(__int64 *a1, ...)
{
  __int64 v1; // r13
  __int64 v2; // r15
  _BYTE *v4; // rdx
  __int64 *v5; // rcx
  __int64 v6; // r14
  unsigned int v7; // eax
  unsigned int *v8; // rbx
  __int64 v9; // rdi
  const char *v10; // rdi
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 i; // r8
  __int64 v14; // rax
  const char *v15; // rax
  signed __int64 v16; // r8
  int v17; // ecx
  int v18; // edx
  unsigned int v19; // eax
  unsigned int *v20; // r12
  _QWORD *v21; // r15
  unsigned __int64 v22; // rdi
  __int64 v23; // rbx
  unsigned __int64 v24; // r11
  unsigned __int8 *v25; // rbx
  unsigned __int64 v26; // r9
  _QWORD *v27; // r10
  unsigned __int8 *v28; // rax
  int v29; // ecx
  int v30; // edx
  int *k; // r8
  __int64 v32; // rdi
  __int64 v33; // r11
  unsigned __int64 v34; // r8
  __int64 v35; // rax
  __int64 v36; // r9
  unsigned int *Src_1; // r13
  __int64 v38; // rax
  char v39; // r10
  __int64 v40; // rcx
  __int64 v41; // r14
  const char *v42; // r14
  __int64 v43; // r15
  int n3; // r8d
  unsigned __int64 v45; // r12
  __int64 v46; // r14
  unsigned __int64 v47; // rbx
  unsigned int *v48; // rcx
  __int64 v49; // r13
  __int64 v50; // rdx
  _BYTE *v51; // rdx
  __int64 v52; // rdi
  __int64 v53; // rbx
  size_t *v54; // rax
  size_t Size; // r14
  __int64 **v56; // r15
  unsigned int v57; // ebx
  __int64 v58; // rdi
  unsigned __int64 v59; // r15
  __int64 v60; // rdi
  __int64 v61; // rbx
  __int64 v62; // rdi
  unsigned int v63; // ebx
  _BYTE *v64; // rdx
  __int64 v65; // r14
  unsigned int v66; // edi
  __int64 v67; // rbx
  __int64 v68; // rcx
  unsigned __int64 v69; // rcx
  __int64 v70; // r8
  unsigned __int64 v71; // rdx
  __int64 v72; // rax
  unsigned int *v73; // r8
  __int128 v74; // xmm0
  __int64 v75; // r13
  unsigned int v76; // edi
  __int64 v77; // rbx
  unsigned int *v78; // r14
  __int64 v79; // rcx
  unsigned __int64 v80; // rcx
  __int64 v81; // r8
  unsigned __int64 v82; // rdx
  __int64 v83; // rax
  __int64 v84; // r13
  unsigned int v85; // r14d
  __int64 v86; // rdi
  unsigned int *v87; // r15
  __int64 v88; // rcx
  unsigned __int64 v89; // rcx
  __int64 v90; // r8
  unsigned __int64 v91; // rdx
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rax
  __int64 v95; // rax
  unsigned __int64 v96; // rcx
  __int64 *v97; // rbx
  __int64 v98; // r8
  unsigned __int64 v99; // rdx
  __int64 v100; // rax
  __int64 v101; // rdx
  __int64 v102; // rcx
  __int64 v103; // rdx
  void **Src_2; // r12
  __int64 v105; // rcx
  __int64 v106; // rcx
  __int64 v107; // rcx
  __int64 v108; // rcx
  __int64 n8; // rcx
  unsigned int *v110; // rcx
  unsigned int *v111; // rcx
  unsigned int *v112; // rcx
  unsigned int *v113; // rcx
  __int64 v114; // r12
  const char *v115; // r12
  int v116; // r13d
  unsigned __int8 **v117; // rbx
  __int64 *v118; // rdi
  __int64 v119; // rbx
  _BYTE *v120; // rdx
  __int64 v121; // rax
  __int64 v122; // r14
  __int64 v123; // rcx
  unsigned int v124; // r8d
  __int64 v125; // rax
  _QWORD *v126; // rbx
  __int64 *v127; // rdi
  unsigned __int64 v128; // rcx
  __int64 v129; // r8
  unsigned __int64 v130; // rdx
  __int64 v131; // rax
  __int64 v132; // rax
  unsigned int v133; // eax
  __int64 v134; // rdi
  unsigned int *v135; // rcx
  __int64 v136; // rcx
  unsigned __int64 v137; // rcx
  __int64 v138; // r8
  unsigned __int64 v139; // rdx
  __int64 v140; // rax
  __int64 v141; // rax
  unsigned int *v142; // rdi
  __int64 v143; // rbx
  __int64 v144; // rbx
  unsigned __int64 v145; // rcx
  __int64 v146; // r8
  unsigned __int64 v147; // rdx
  __int64 v148; // rax
  unsigned int *v149; // rax
  unsigned int v150; // eax
  _QWORD *v152; // [rsp+30h] [rbp-D0h]
  unsigned int v153; // [rsp+38h] [rbp-C8h] BYREF
  const char *v154; // [rsp+40h] [rbp-C0h] BYREF
  int *Src; // [rsp+48h] [rbp-B8h] BYREF
  const char *v156; // [rsp+50h] [rbp-B0h] BYREF
  const char *v157; // [rsp+58h] [rbp-A8h] BYREF
  char *v158; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v159; // [rsp+68h] [rbp-98h] BYREF
  char *v160; // [rsp+70h] [rbp-90h] BYREF
  __int64 v161; // [rsp+78h] [rbp-88h] BYREF
  char *v162; // [rsp+80h] [rbp-80h] BYREF
  __int64 v163; // [rsp+88h] [rbp-78h] BYREF
  char *v164; // [rsp+90h] [rbp-70h] BYREF
  __int64 v165; // [rsp+98h] [rbp-68h] BYREF
  char *v166; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v167; // [rsp+A8h] [rbp-58h] BYREF
  char *v168; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v169; // [rsp+B8h] [rbp-48h] BYREF
  char *v170; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v171; // [rsp+C8h] [rbp-38h] BYREF
  char *v172; // [rsp+D0h] [rbp-30h] BYREF
  void *v173; // [rsp+D8h] [rbp-28h] BYREF
  unsigned __int64 v174; // [rsp+E0h] [rbp-20h]
  const char *v175; // [rsp+E8h] [rbp-18h] BYREF
  unsigned __int8 *v176; // [rsp+F0h] [rbp-10h] BYREF
  const char *v177; // [rsp+F8h] [rbp-8h] BYREF
  unsigned __int8 *v178; // [rsp+100h] [rbp+0h] BYREF
  __int128 v179; // [rsp+108h] [rbp+8h] BYREF
  __int64 v180; // [rsp+118h] [rbp+18h]
  __int64 v181; // [rsp+120h] [rbp+20h] BYREF
  __int64 v182; // [rsp+128h] [rbp+28h]
  __int128 v183; // [rsp+130h] [rbp+30h]
  __int64 v184; // [rsp+140h] [rbp+40h] BYREF
  __int64 v185; // [rsp+148h] [rbp+48h]
  __int64 v186; // [rsp+150h] [rbp+50h] BYREF
  __int64 v187; // [rsp+158h] [rbp+58h]
  _QWORD v188[2]; // [rsp+160h] [rbp+60h] BYREF
  __int64 v189; // [rsp+170h] [rbp+70h] BYREF
  __int64 v190; // [rsp+178h] [rbp+78h]
  __int64 v191; // [rsp+180h] [rbp+80h] BYREF
  __int64 v192; // [rsp+188h] [rbp+88h]
  _QWORD v193[8]; // [rsp+190h] [rbp+90h] BYREF
  __int64 v194; // [rsp+1E8h] [rbp+E8h] BYREF
  va_list va; // [rsp+1E8h] [rbp+E8h]
  const char *v196; // [rsp+1F0h] [rbp+F0h]
  __int64 v197; // [rsp+1F8h] [rbp+F8h]
  __int64 v198; // [rsp+200h] [rbp+100h]
  unsigned int *v199; // [rsp+208h] [rbp+108h]
  va_list va1; // [rsp+210h] [rbp+110h] BYREF

  va_start(va1, a1);
  va_start(va, a1);
  v194 = va_arg(va1, _QWORD);
  v196 = va_arg(va1, const char *);
  v197 = va_arg(va1, _QWORD);
  v198 = va_arg(va1, _QWORD);
  v199 = va_arg(va1, unsigned int *);
  v1 = v197;
  v2 = v194;
  if ( *(_BYTE *)(v197 + 32) )
  {
    v4 = (_BYTE *)a1[51];
    v5 = a1 + 50;
    if ( v4 == (_BYTE *)a1[52] )
    {
      sub_1402A4BA0(v5, v4, (__int64 *)va);
    }
    else
    {
      *(_QWORD *)v4 = v194;
      a1[51] += 8;
    }
  }
  v6 = v198;
  v7 = *(_DWORD *)(v198 + 4);
  if ( v7 == -1 )
  {
    v20 = v199;
    goto LABEL_24;
  }
  v8 = (unsigned int *)(a1[64] + 16LL * v7);
  if ( *(_DWORD *)(a1[63] + 4) >= 6u )
  {
    v9 = a1[85];
  }
  else
  {
    v9 = a1[84];
  }
  v10 = (const char *)(*v8 + v9);
  v157 = v10;
  sub_140357780(&v158, &v157);
  v11 = -1;
  do
  {
    ++v11;
  }
  while ( v158[v11] );
  v12 = 0xCBF29CE484222325uLL;
  for ( i = 0; i < v11; v12 = 0x100000001B3LL * (v14 ^ v12) )
  {
    v14 = (unsigned __int8)v158[i++];
  }
  sub_147218A50(a1 + 38, &v179, &v158, (__PAIR128__(v12, v12) * 0xDE5FB9D2630458E9uLL) >> 64);
  v158 = (char *)&qword_149808ABC + 4;
  DestroyStringObject(&v158);
  if ( (_QWORD)v179 == a1[38] + a1[41] )
  {
    sub_1405BD4A0(
      8u,
      2u,
      "[DataCore] Inherited structure [%s] is not a registered structure, data will not be loaded.",
      v10);
  }
  else
  {
    v15 = *(const char **)(v1 + 24);
    if ( v15 || !*v10 )
    {
      v16 = v10 - v15;
      do
      {
        v17 = (unsigned __int8)v15[v16];
        v18 = *(unsigned __int8 *)v15 - v17;
        if ( v18 )
        {
          break;
        }
        ++v15;
      }
      while ( v17 );
      if ( !v18 )
      {
        v20 = sub_14724D1A0(a1, v2, v10, *((_QWORD *)&v179 + 1) + 8LL, v8, v199);
        v199 = v20;
        goto LABEL_24;
      }
    }
  }
  v19 = sub_147226AB0((__int64)a1, (__int64)v8);
  v20 = (unsigned int *)((char *)v199 + v19);
  v199 = v20;
LABEL_24:
  v21 = (_QWORD *)(v1 + 56);
  v152 = (_QWORD *)(v1 + 56);
  if ( (*(_DWORD *)(*(_QWORD *)(v1 + 56) - 4LL) & 0x7FFFFFFF) == 0 && *(_WORD *)(v6 + 8) )
  {
    v22 = 0;
    do
    {
      if ( *(_DWORD *)(a1[63] + 4) >= 6u )
      {
        v23 = a1[85];
      }
      else
      {
        v23 = a1[84];
      }
      v24 = *(_QWORD *)(v1 + 8);
      v25 = (unsigned __int8 *)(*(unsigned int *)(a1[65] + 12 * (v22 + *(unsigned __int16 *)(v6 + 10))) + v23);
      v26 = 0;
      if ( v24 )
      {
        v27 = *(_QWORD **)v1;
        while ( 1 )
        {
          v28 = v25;
          do
          {
            v29 = v28[*v27 - (_QWORD)v25];
            v30 = *v28 - v29;
            if ( v30 )
            {
              break;
            }
            ++v28;
          }
          while ( v29 );
          if ( !v30 )
          {
            break;
          }
          ++v26;
          v27 += 5;
          if ( v26 >= v24 )
          {
            goto LABEL_37;
          }
        }
        LODWORD(v154) = v26;
        k = (int *)&v154;
      }
      else
      {
LABEL_37:
        v153 = -1;
        k = (int *)&v153;
      }
      sub_142474120((unsigned __int64 *)(v1 + 56), 1, k);
      ++v22;
    }
    while ( v22 < *(unsigned __int16 *)(v6 + 8) );
    v20 = v199;
  }
  v32 = v194;
  v33 = v194;
  v180 = v194;
  v34 = 0;
  v174 = 0;
  if ( *(_WORD *)(v6 + 8) )
  {
    while ( 1 )
    {
      v35 = a1[65];
      v36 = *(unsigned __int8 *)(v35 + 12 * (v34 + *(unsigned __int16 *)(v6 + 10)) + 6);
      Src_1 = (unsigned int *)(v35 + 12 * (v34 + *(unsigned __int16 *)(v6 + 10)));
      v38 = a1[63];
      v39 = *((_BYTE *)Src_1 + 8);
      v40 = *Src_1;
      Src = (int *)Src_1;
      if ( *(_DWORD *)(v38 + 4) >= 6u )
      {
        v41 = a1[85];
      }
      else
      {
        v41 = a1[84];
      }
      v42 = (const char *)(v40 + v41);
      if ( (int)v34 >= (*(_DWORD *)(*v21 - 4LL) & 0x7FFFFFFF) )
      {
        __debugbreak();
      }
      if ( *(_DWORD *)(4LL * (int)v34 + *v21) == -1 )
      {
        v20 = (unsigned int *)((char *)v20 + (unsigned int)sub_1472269E0((__int64)a1, Src_1));
        v199 = v20;
        goto LABEL_96;
      }
      if ( (int)v34 >= (*(_DWORD *)(*v21 - 4LL) & 0x7FFFFFFF) )
      {
        __debugbreak();
      }
      v43 = *(_QWORD *)v197 + 40LL * *(int *)(*v21 + 4LL * (int)v34);
      if ( *(_BYTE *)(v43 + 24) != (_BYTE)v36 )
      {
        break;
      }
      n3 = *(unsigned __int8 *)(v43 + 25);
      if ( (_BYTE)n3 != *((_BYTE *)Src_1 + 7) )
      {
        sub_1405BD4A0(
          8u,
          2u,
          "[DataCore] Field Option Mismatch (Reference, Optional, Pointer). Check registration of DataCore Struct name: \""
          "%s\" field name \"%s\"",
          v196,
          v42);
        goto LABEL_53;
      }
      if ( *(_BYTE *)(v43 + 26) )
      {
        if ( !v39 )
        {
          goto LABEL_170;
        }
        v45 = *v20;
        v46 = v33 + *(_QWORD *)(v43 + 8);
        LODWORD(v154) = v45;
        v47 = v199[1];
        v48 = v199 + 2;
        v153 = v199[1];
        v199 += 2;
        *(_QWORD *)(v46 + 16) = 0;
        switch ( (int)v36 )
        {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 11:
          case 12:
          case 14:
            *(_QWORD *)(v46 + 24) = v45;
            if ( (_DWORD)v45 )
            {
              switch ( (int)v36 )
              {
                case 1:
                  *(_QWORD *)(v46 + 16) = a1[69] + v47;
                  break;
                case 2:
                  *(_QWORD *)(v46 + 16) = a1[70] + v47;
                  break;
                case 3:
                  *(_QWORD *)(v46 + 16) = a1[71] + 2 * v47;
                  break;
                case 4:
                  *(_QWORD *)(v46 + 16) = a1[72] + 4 * v47;
                  break;
                case 5:
                  *(_QWORD *)(v46 + 16) = a1[73] + 8 * v47;
                  break;
                case 6:
                  *(_QWORD *)(v46 + 16) = a1[74] + v47;
                  break;
                case 7:
                  *(_QWORD *)(v46 + 16) = a1[75] + 2 * v47;
                  break;
                case 8:
                  *(_QWORD *)(v46 + 16) = a1[76] + 4 * v47;
                  break;
                case 9:
                  *(_QWORD *)(v46 + 16) = a1[77] + 8 * v47;
                  break;
                case 11:
                  *(_QWORD *)(v46 + 16) = a1[78] + 4 * v47;
                  break;
                case 12:
                  *(_QWORD *)(v46 + 16) = a1[79] + 8 * v47;
                  break;
                case 14:
                  *(_QWORD *)(v46 + 16) = a1[80] + 16 * v47;
                  break;
                default:
                  goto LABEL_94;
              }
            }
            goto LABEL_94;
          case 10:
            v59 = v45;
            sub_14726BF90(v46, v45);
            if ( !(_DWORD)v45 )
            {
              goto LABEL_94;
            }
            v60 = 0;
            v61 = 4 * v47;
            do
            {
              sub_140390550((void **)(v60 + *(_QWORD *)(v46 + 16)), (void *)(a1[84] + *(unsigned int *)(a1[82] + v61)));
              v60 += 16;
              v61 += 4;
              --v59;
            }
            while ( v59 );
            goto LABEL_93;
          case 13:
            v62 = *(_QWORD *)(v43 + 8) + v32;
            sub_14726C160(v62, v45);
            v63 = 0;
            if ( !(_DWORD)v45 )
            {
              goto LABEL_88;
            }
            do
            {
              v64 = (_BYTE *)(a1[84] + *(unsigned int *)(a1[83] + 4LL * (v63 + v153)));
              if ( v64 && *v64 == 64 )
              {
                assignCStringToStringStructure((void **)(*(_QWORD *)(v62 + 16) + 8LL * v63), v64);
              }
              ++v63;
            }
            while ( v63 < (unsigned int)v45 );
            goto LABEL_93;
          case 15:
            v49 = v32 + *(_QWORD *)(v43 + 8);
            v50 = *(unsigned int *)(a1[66] + 8LL * *((unsigned __int16 *)Src + 2));
            if ( *(_DWORD *)(a1[63] + 4) >= 6u )
            {
              v51 = (_BYTE *)(a1[85] + v50);
            }
            else
            {
              v51 = (_BYTE *)(a1[84] + v50);
            }
            CreateStringObjectFromString((void **)&v156, v51);
            v52 = a1[36];
            v53 = *(_QWORD *)(v52 + 8);
            while ( !*(_BYTE *)(v53 + 25) )
            {
              if ( (int)sub_1403DFBE0((unsigned __int8 **)(v53 + 32), &v156) >= 0 )
              {
                v52 = v53;
                v53 = *(_QWORD *)v53;
              }
              else
              {
                v53 = *(_QWORD *)(v53 + 16);
              }
            }
            if ( *(_BYTE *)(v52 + 25)
              || (int)sub_1403DFBE0((unsigned __int8 **)&v156, (_QWORD *)(v52 + 32)) < 0
              || v52 == a1[36] )
            {
              *(_BYTE *)(v49 + 8) = 1;
              *(_QWORD *)(v49 + 24) = 0;
              *(_QWORD *)(v49 + 16) = 0;
              sub_1405BD4A0(8u, 2u, "[DataCore] Enum named \"%s\" is not registered. This will be ignored.", v156);
              DestroyStringObject(&v156);
              v32 = v194;
            }
            else
            {
              v54 = (size_t *)sub_147220700((__int64 **)a1 + 36, (const void **)&v156);
              Size = *v54;
              v56 = (__int64 **)v54[1];
              *(_BYTE *)(v49 + 8) = 1;
              *(_QWORD *)(v49 + 24) = v45;
              if ( (_DWORD)v45 )
              {
                *(_QWORD *)(v49 + 16) = sub_14739AFC0(Size * v45, 0);
                v57 = 0;
                v58 = 0;
                do
                {
                  CreateStringObjectFromString(
                    &v173,
                    (_BYTE *)(a1[84] + *(unsigned int *)(a1[81] + 4LL * (v57 + v153))));
                  LODWORD(Src) = *(_DWORD *)sub_1409A18C0(v56, (__int64 *)&v173);
                  DestroyStringObject(&v173);
                  memcpy((void *)(v58 + *(_QWORD *)(v49 + 16)), &Src, Size);
                  ++v57;
                  v58 += Size;
                }
                while ( v57 < (unsigned int)v45 );
              }
              DestroyStringObject(&v156);
LABEL_88:
              v32 = v194;
            }
            goto LABEL_94;
          case 16:
            if ( *(_BYTE *)(v43 + 25) )
            {
              switch ( *(_BYTE *)(v43 + 25) )
              {
                case 1:
                  v84 = v32 + *(_QWORD *)(v43 + 8);
                  sub_14726C0C0(v84, v45);
                  v85 = 0;
                  if ( (_DWORD)v45 )
                  {
                    v86 = 0;
                    do
                    {
                      v87 = (unsigned int *)(a1[86] + 8LL * (v85 + (unsigned int)v47));
                      if ( v87[1] == -1 )
                      {
                        *(_QWORD *)(v86 + *(_QWORD *)(v84 + 16)) = 0;
                      }
                      else
                      {
                        if ( *(_DWORD *)(a1[63] + 4) >= 6u )
                        {
                          v88 = a1[85];
                        }
                        else
                        {
                          v88 = a1[84];
                        }
                        v45 = (unsigned __int64)(a1 + 38);
                        v163 = *(unsigned int *)(a1[64] + 16LL * *v87) + v88;
                        sub_140357780(&v164, &v163);
                        v89 = -1;
                        do
                        {
                          ++v89;
                        }
                        while ( v164[v89] );
                        v90 = 0xCBF29CE484222325uLL;
                        v91 = 0;
                        v47 = (unsigned __int64)(a1 + 38);
                        if ( v89 )
                        {
                          do
                          {
                            v92 = (unsigned __int8)v164[v91++];
                            v90 = 0x100000001B3LL * (v92 ^ v90);
                          }
                          while ( v91 < v89 );
                          v47 = (unsigned __int64)(a1 + 38);
                          v45 = (unsigned __int64)(a1 + 38);
                        }
                        sub_147218A50(
                          (_QWORD *)v45,
                          &v186,
                          &v164,
                          (((unsigned __int64)v90 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64)
                        - 0x21A0462D9CFBA717LL * v90);
                        v164 = (char *)&qword_149808ABC + 4;
                        DestroyStringObject(&v164);
                        v93 = *(_QWORD *)v47 + *(_QWORD *)(v47 + 24);
                        LODWORD(v45) = (_DWORD)v154;
                        LODWORD(v47) = v153;
                        if ( v186 != v93 )
                        {
                          *(_QWORD *)(v86 + *(_QWORD *)(v84 + 16)) = *(_QWORD *)(v187 + 56)
                                                                   + *(_QWORD *)(v187 + 48) * v87[1];
                        }
                      }
                      ++v85;
                      v86 += 16;
                    }
                    while ( v85 < (unsigned int)v45 );
                    goto LABEL_93;
                  }
                  break;
                case 2:
                  v75 = v32 + *(_QWORD *)(v43 + 8);
                  sub_14726C0C0(v75, v45);
                  v76 = 0;
                  if ( (_DWORD)v45 )
                  {
                    v77 = 0;
                    do
                    {
                      v78 = (unsigned int *)(a1[87] + 8LL * (v76 + v153));
                      if ( v78[1] == -1 )
                      {
                        *(_QWORD *)(v77 + *(_QWORD *)(v75 + 16)) = 0;
                      }
                      else
                      {
                        if ( *(_DWORD *)(a1[63] + 4) >= 6u )
                        {
                          v79 = a1[85];
                        }
                        else
                        {
                          v79 = a1[84];
                        }
                        v161 = *(unsigned int *)(a1[64] + 16LL * *v78) + v79;
                        sub_140357780(&v162, &v161);
                        v80 = -1;
                        do
                        {
                          ++v80;
                        }
                        while ( v162[v80] );
                        v81 = 0xCBF29CE484222325uLL;
                        v82 = 0;
                        if ( v80 )
                        {
                          do
                          {
                            v83 = (unsigned __int8)v162[v82++];
                            v81 = 0x100000001B3LL * (v83 ^ v81);
                          }
                          while ( v82 < v80 );
                          LODWORD(v45) = (_DWORD)v154;
                        }
                        sub_147218A50(
                          a1 + 38,
                          &v184,
                          &v162,
                          0xDE5FB9D2630458E9uLL * v81
                        + (((unsigned __int64)v81 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                        v162 = (char *)&qword_149808ABC + 4;
                        DestroyStringObject(&v162);
                        if ( v184 != a1[38] + a1[41] )
                        {
                          *(_QWORD *)(v77 + *(_QWORD *)(v75 + 16)) = *(_QWORD *)(v185 + 56)
                                                                   + *(_QWORD *)(v185 + 48) * v78[1];
                        }
                      }
                      ++v76;
                      v77 += 16;
                    }
                    while ( v76 < (unsigned int)v45 );
                  }
                  goto LABEL_93;
                case 3:
                  v65 = v32 + *(_QWORD *)(v43 + 8);
                  v183 = 0u;
                  sub_14726C030(v65, v45);
                  v66 = 0;
                  if ( (_DWORD)v45 )
                  {
                    v67 = 0;
                    do
                    {
                      if ( *(_DWORD *)(a1[63] + 4) >= 6u )
                      {
                        v68 = a1[85];
                      }
                      else
                      {
                        v68 = a1[84];
                      }
                      v159 = *(unsigned int *)(a1[64] + 16LL * *((unsigned __int16 *)Src_1 + 2)) + v68;
                      sub_140357780(&v160, &v159);
                      v69 = -1;
                      do
                      {
                        ++v69;
                      }
                      while ( v160[v69] );
                      v70 = 0xCBF29CE484222325uLL;
                      v71 = 0;
                      if ( v69 )
                      {
                        do
                        {
                          v72 = (unsigned __int8)v160[v71++];
                          v70 = 0x100000001B3LL * (v72 ^ v70);
                        }
                        while ( v71 < v69 );
                        LODWORD(v45) = (_DWORD)v154;
                      }
                      sub_147218A50(
                        a1 + 38,
                        &v181,
                        &v160,
                        0xDE5FB9D2630458E9uLL * v70
                      + (((unsigned __int64)v70 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                      v160 = (char *)&qword_149808ABC + 4;
                      DestroyStringObject(&v160);
                      if ( v181 != a1[38] + a1[41] )
                      {
                        v73 = (unsigned int *)(a1[88] + 20LL * (v66 + v153));
                        if ( *v73 == -1 )
                        {
                          v74 = v183;
                          *(_QWORD *)(v67 + *(_QWORD *)(v65 + 16) + 16) = 0;
                        }
                        else
                        {
                          *(_QWORD *)(v67 + *(_QWORD *)(v65 + 16) + 16) = *(_QWORD *)(v182 + 56)
                                                                        + *(_QWORD *)(v182 + 48) * *v73;
                          v74 = *(_OWORD *)(v73 + 1);
                        }
                        *(_OWORD *)(*(_QWORD *)(v65 + 16) + v67) = v74;
                      }
                      ++v66;
                      v67 += 24;
                    }
                    while ( v66 < (unsigned int)v45 );
                  }
LABEL_93:
                  v32 = v194;
                  break;
              }
            }
            else
            {
              v94 = *(unsigned int *)(a1[64] + 16LL * *((unsigned __int16 *)Src_1 + 2));
              if ( *(_DWORD *)(a1[63] + 4) >= 6u )
              {
                v95 = a1[85] + v94;
              }
              else
              {
                v95 = a1[84] + v94;
              }
              v165 = v95;
              sub_140357780(&v166, &v165);
              v96 = -1;
              do
              {
                ++v96;
              }
              while ( v166[v96] );
              v97 = a1 + 38;
              v98 = 0xCBF29CE484222325uLL;
              v99 = 0;
              if ( v96 )
              {
                do
                {
                  v100 = (unsigned __int8)v166[v99++];
                  v98 = 0x100000001B3LL * (v100 ^ v98);
                }
                while ( v99 < v96 );
                LODWORD(v45) = (_DWORD)v154;
                v97 = a1 + 38;
              }
              sub_147218A50(
                a1 + 38,
                v188,
                &v166,
                0xDE5FB9D2630458E9uLL * v98 + (((unsigned __int64)v98 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
              v166 = (char *)&qword_149808ABC + 4;
              DestroyStringObject(&v166);
              if ( v188[0] == *v97 + v97[3] )
              {
                goto LABEL_93;
              }
              v101 = *(_QWORD *)(v43 + 8);
              v32 = v194;
              v102 = v188[1];
              *(_QWORD *)(v101 + v194 + 24) = (unsigned int)v45;
              if ( (_DWORD)v45 )
              {
                *(_QWORD *)(v101 + v32 + 16) = *(_QWORD *)(v102 + 56) + *(_QWORD *)(v102 + 48) * v153;
              }
              else
              {
                *(_QWORD *)(v101 + v32 + 16) = 0;
              }
            }
LABEL_94:
            v20 = v199;
            break;
          default:
            v21 = v152;
            v20 = v48;
            goto LABEL_96;
        }
      }
      else
      {
        if ( v39 )
        {
LABEL_170:
          sub_1405BD4A0(
            8u,
            2u,
            "[DataCore] Field Storage Type Mismatch. Check registration of DataCore Struct name: \"%s\" field name \"%s\"",
            v196,
            v42);
          goto LABEL_53;
        }
        v103 = *(_QWORD *)(v43 + 8);
        Src_2 = (void **)(v103 + v33);
        Src = (int *)(v103 + v33);
        switch ( (int)v36 )
        {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 11:
          case 12:
          case 14:
            v105 = *(_QWORD *)(v43 + 16);
            if ( v105 != qword_1497CC820[v36] )
            {
              sub_1405BD4A0(
                8u,
                0,
                "[DataCore] Field Size Mismatch. Check registration of DataCore Struct %s field %s",
                v196,
                v42);
              return 0;
            }
            v106 = v105 - 1;
            if ( !v106 )
            {
              *(_BYTE *)Src_2 = *(_BYTE *)v199;
LABEL_183:
              v20 = (unsigned int *)((char *)v199 + *(_QWORD *)(v43 + 16));
              v199 = v20;
              break;
            }
            v107 = v106 - 1;
            if ( v107 )
            {
              v108 = v107 - 2;
              if ( v108 )
              {
                n8 = v108 - 4;
                if ( n8 )
                {
                  if ( n8 != 8 )
                  {
                    goto LABEL_183;
                  }
                  v110 = v199;
                  *(_OWORD *)Src_2 = *(_OWORD *)v199;
                  v20 = (unsigned int *)((char *)v110 + *(_QWORD *)(v43 + 16));
                  v199 = v20;
                }
                else
                {
                  v111 = v199;
                  *Src_2 = *(void **)v199;
                  v20 = (unsigned int *)((char *)v111 + *(_QWORD *)(v43 + 16));
                  v199 = v20;
                }
              }
              else
              {
                v112 = v199;
                *(_DWORD *)Src_2 = *v199;
                v20 = (unsigned int *)((char *)v112 + *(_QWORD *)(v43 + 16));
                v199 = v20;
              }
            }
            else
            {
              v113 = v199;
              *(_WORD *)Src_2 = *(_WORD *)v199;
              v20 = (unsigned int *)((char *)v113 + *(_QWORD *)(v43 + 16));
              v199 = v20;
            }
            break;
          case 10:
            sub_140390550(Src_2, (void *)(a1[84] + *v199));
            v20 = ++v199;
            break;
          case 13:
            v120 = (_BYTE *)(a1[84] + *v199);
            if ( v120 && *v120 == 64 )
            {
              assignCStringToStringStructure(Src_2, v120);
            }
            v20 = ++v199;
            break;
          case 15:
            v114 = *(unsigned int *)(a1[66] + 8LL * *((unsigned __int16 *)Src_1 + 2));
            if ( *(_DWORD *)(a1[63] + 4) >= 6u )
            {
              v115 = (const char *)(a1[85] + v114);
            }
            else
            {
              v115 = (const char *)(a1[84] + v114);
            }
            v116 = -1;
            v175 = v115;
            v154 = (const char *)(a1[84] + *v199);
            sub_140357780(&v176, &v175);
            v117 = sub_140C9F2E0((unsigned __int8 ***)a1 + 36, &v176);
            v176 = (unsigned __int8 *)&qword_149808ABC + 4;
            DestroyStringObject(&v176);
            if ( v117 == (unsigned __int8 **)a1[36] )
            {
              sub_1405BD4A0(8u, 0, "[DataCore] Field Enum [%s] does not exist, field name [%s].", v115, v42);
            }
            else
            {
              v118 = (__int64 *)v117[6];
              v177 = v154;
              sub_140357780(&v178, &v177);
              v119 = std::_Tree<std::_Tmap_traits<void *,`anonymous namespace'::_Mutex_count_pair,std::less<void *>,std::_Crt_allocator<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>,0>>::_Find<void *>(
                       v118,
                       &v178);
              v178 = (unsigned __int8 *)&qword_149808ABC + 4;
              DestroyStringObject(&v178);
              if ( v119 == *v118 )
              {
                sub_1405BD4A0(
                  8u,
                  0,
                  "[DataCore] Field Enum option [%s] does not exist in enum [%s], for field name %s.",
                  v154,
                  v115,
                  v42);
              }
              else
              {
                v116 = *(_DWORD *)(v119 + 40);
              }
            }
            switch ( *(_QWORD *)(v43 + 16) )
            {
              case 1LL:
                *(_BYTE *)Src = v116;
                break;
              case 2LL:
                *(_WORD *)Src = v116;
                break;
              case 4LL:
                *Src = v116;
                break;
            }
            v32 = v194;
            v20 = ++v199;
            break;
          case 16:
            if ( !(_BYTE)n3 )
            {
              v142 = (unsigned int *)(a1[64] + 16LL * *((unsigned __int16 *)Src_1 + 2));
              v143 = *v142;
              if ( *(_DWORD *)(a1[63] + 4) >= 6u )
              {
                v144 = a1[85] + v143;
              }
              else
              {
                v144 = a1[84] + v143;
              }
              v171 = v144;
              sub_140357780(&v172, &v171);
              v145 = -1;
              do
              {
                ++v145;
              }
              while ( v172[v145] );
              v146 = 0xCBF29CE484222325uLL;
              v147 = 0;
              if ( v145 )
              {
                do
                {
                  v148 = (unsigned __int8)v172[v147++];
                  v146 = 0x100000001B3LL * (v148 ^ v146);
                }
                while ( v147 < v145 );
                Src_2 = (void **)Src;
              }
              sub_147218A50(
                a1 + 38,
                v193,
                &v172,
                0xDE5FB9D2630458E9uLL * v146
              + (((unsigned __int64)v146 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
              v172 = (char *)&qword_149808ABC + 4;
              DestroyStringObject(&v172);
              if ( v193[0] == a1[38] + a1[41] )
              {
                v150 = sub_147226AB0((__int64)a1, (__int64)v142);
                v32 = v194;
                v20 = (unsigned int *)((char *)v199 + v150);
                v199 = v20;
              }
              else
              {
                v149 = sub_14724D1A0(a1, Src_2, v144, v193[1] + 8LL, v142, v199);
                v32 = v194;
                v20 = v149;
                v199 = v149;
              }
              break;
            }
            if ( n3 != 1 && n3 != 2 )
            {
              v20 = v199;
              if ( n3 == 3 )
              {
                v121 = a1[64];
                v122 = *v199;
                v123 = 2LL * *((unsigned __int16 *)Src_1 + 2);
                v20 = v199 + 5;
                v179 = *(_OWORD *)(v199 + 1);
                v199 += 5;
                v124 = *(_DWORD *)(v121 + 8 * v123);
                if ( *(_DWORD *)(a1[63] + 4) >= 6u )
                {
                  v125 = a1[85] + v124;
                }
                else
                {
                  v125 = a1[84] + v124;
                }
                v126 = (_QWORD *)(v103 + v32);
                v167 = v125;
                v127 = a1 + 38;
                sub_140357780(&v168, &v167);
                v128 = -1;
                do
                {
                  ++v128;
                }
                while ( v168[v128] );
                v129 = 0xCBF29CE484222325uLL;
                v130 = 0;
                if ( v128 )
                {
                  do
                  {
                    v131 = (unsigned __int8)v168[v130++];
                    v129 = 0x100000001B3LL * (v131 ^ v129);
                  }
                  while ( v130 < v128 );
                  v127 = a1 + 38;
                }
                sub_147218A50(
                  v127,
                  &v189,
                  &v168,
                  0xDE5FB9D2630458E9uLL * v129
                + (((unsigned __int64)v129 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
                v168 = (char *)&qword_149808ABC + 4;
                DestroyStringObject(&v168);
                if ( v189 == *v127 + v127[3] )
                {
                  v126[2] = 0;
                  *v126 = 0;
                  v126[1] = 0;
                  v32 = v194;
                }
                else
                {
                  if ( (_DWORD)v122 == -1 )
                  {
                    v132 = 0;
                  }
                  else
                  {
                    v132 = *(_QWORD *)(v190 + 56) + *(_QWORD *)(v190 + 48) * v122;
                  }
                  v32 = v194;
                  *(_OWORD *)v126 = v179;
                  v126[2] = v132;
                }
              }
              break;
            }
            v133 = *v199;
            v134 = v199[1];
            v135 = v199 + 2;
            v199 += 2;
            if ( v133 == -1 || (_DWORD)v134 == -1 )
            {
              v32 = v194;
              *Src_2 = 0;
              v20 = v135;
              break;
            }
            if ( *(_DWORD *)(a1[63] + 4) >= 6u )
            {
              v136 = a1[85];
            }
            else
            {
              v136 = a1[84];
            }
            v169 = *(unsigned int *)(a1[64] + 16LL * v133) + v136;
            sub_140357780(&v170, &v169);
            v137 = -1;
            do
            {
              ++v137;
            }
            while ( v170[v137] );
            v138 = 0xCBF29CE484222325uLL;
            v139 = 0;
            if ( v137 )
            {
              do
              {
                v140 = (unsigned __int8)v170[v139++];
                v138 = 0x100000001B3LL * (v140 ^ v138);
              }
              while ( v139 < v137 );
              Src_2 = (void **)Src;
            }
            sub_147218A50(
              a1 + 38,
              &v191,
              &v170,
              0xDE5FB9D2630458E9uLL * v138 + (((unsigned __int64)v138 * (unsigned __int128)0xDE5FB9D2630458E9uLL) >> 64));
            v170 = (char *)&qword_149808ABC + 4;
            DestroyStringObject(&v170);
            v21 = v152;
            *Src_2 = 0;
            if ( v191 == a1[38] + a1[41] )
            {
              v20 = v199;
              v32 = v194;
            }
            else
            {
              v141 = v134;
              v32 = v194;
              *Src_2 = (void *)(*(_QWORD *)(v192 + 56) + *(_QWORD *)(v192 + 48) * v141);
              v20 = v199;
            }
            goto LABEL_96;
          default:
            goto LABEL_94;
        }
      }
LABEL_95:
      v21 = v152;
LABEL_96:
      v6 = v198;
      v34 = v174 + 1;
      v174 = v34;
      if ( v34 >= *(unsigned __int16 *)(v198 + 8) )
      {
        return v20;
      }
      v33 = v180;
    }
    sub_1405BD4A0(
      8u,
      2u,
      "[DataCore] Field Type Mismatch. Check registration of  DataCore Struct name: \"%s\" field name \"%s\"",
      v196,
      v42);
LABEL_53:
    v20 = (unsigned int *)((char *)v20 + (unsigned int)sub_1472269E0((__int64)a1, Src_1));
    v199 = v20;
    goto LABEL_95;
  }
  return v20;
}

// --- End Function: sub_14724D1A0 (0x14724D1A0) ---

// --- Function: sub_14724E7E0 (0x14724E7E0) ---
__int64 __fastcall sub_14724E7E0(_QWORD *a1, char *a2, __int64 a3, char *a4, char *a5, __int64 **a6)
{
  __int64 v9; // r14
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r9
  __int64 i; // rdx
  __int64 v13; // rcx
  __int64 v15; // r13
  __int64 v16; // rax
  __int64 v17; // rbx
  __int64 v18; // rax
  _BYTE *v19; // rdx
  __int64 v20; // rax
  char *v21; // rcx
  int v22; // edx
  int v23; // r8d
  const char *v24; // rax
  __int64 v25; // rax
  char *v26; // rbx
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rdi
  __int64 v30; // rsi
  __int128 v31; // xmm0
  _BYTE *v32; // rdx
  _OWORD v33[2]; // [rsp+40h] [rbp-28h] BYREF
  _BYTE *v34; // [rsp+A0h] [rbp+38h] BYREF
  __int64 v35; // [rsp+B0h] [rbp+48h] BYREF

  v35 = a3;
  v9 = a3;
  CreateStringObjectFromString((void **)&v34, a4);
  v10 = -1;
  do
  {
    ++v10;
  }
  while ( v34[v10] );
  v11 = 0;
  for ( i = 0xCBF29CE484222325uLL; v11 < v10; i = 0x100000001B3LL * (v13 ^ i) )
  {
    v13 = (unsigned __int8)v34[v11++];
  }
  sub_147218A50(a1 + 38, v33, &v34, (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 64);
  DestroyStringObject(&v34);
  if ( *(_QWORD *)&v33[0] == a1[38] + a1[41] )
  {
    sub_1405BD4A0(8u, 2u, "[DataCore] %s was not a game-registered structure. Ignoring.", a4);
    return 0;
  }
  else
  {
    v15 = *((_QWORD *)&v33[0] + 1) + 8LL;
    v16 = (*(__int64 (**)(void))(*(_QWORD *)Parameter_3 + 584LL))();
    v17 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v16 + 472LL))(v16, a4);
    if ( !v9 )
    {
      v18 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v15 + 16))(*(_QWORD *)(v15 + 16), 0);
      v19 = (_BYTE *)a1[48];
      v9 = v18;
      v35 = v18;
      if ( v19 == (_BYTE *)a1[49] )
      {
        sub_1402A4BA0(a1 + 47, v19, &v35);
      }
      else
      {
        *(_QWORD *)v19 = v18;
        a1[48] += 8LL;
      }
      if ( !v9 )
      {
        goto LABEL_17;
      }
    }
    v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 8LL))(v9) - (_QWORD)a4;
    v21 = a4;
    do
    {
      v22 = (unsigned __int8)v21[v20];
      v23 = (unsigned __int8)*v21 - v22;
      if ( v23 )
      {
        break;
      }
      ++v21;
    }
    while ( v22 );
    if ( v23 )
    {
      v24 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 8LL))(v9);
      sub_1405BD4A0(8u, 2u, "[DataCore] Type \"%s\" does not match type \"%s\" in schema. Record \"%s\".", v24, a4, a2);
      return 0;
    }
    else
    {
LABEL_17:
      v25 = (*(__int64 (**)(void))(*(_QWORD *)Parameter_3 + 584LL))();
      (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v25 + 512LL))(v25, v17, 0, 0);
      v26 = a5;
      sub_1472461B0(a1, a2, a6, a4, v9, v15, a5);
      CreateStringObjectFromString((void **)&v34, v26);
      v27 = a1[45];
      DWORD2(v33[0]) = 0;
      v28 = *(_QWORD *)(v27 + 8);
      *(_QWORD *)&v33[0] = v28;
      while ( !*(_BYTE *)(v28 + 25) )
      {
        *(_QWORD *)&v33[0] = v28;
        if ( (int)sub_1403DFBE0((unsigned __int8 **)(v28 + 32), &v34) >= 0 )
        {
          v27 = v28;
          DWORD2(v33[0]) = 1;
          v28 = *(_QWORD *)v28;
        }
        else
        {
          v28 = *(_QWORD *)(v28 + 16);
          DWORD2(v33[0]) = 0;
        }
      }
      if ( *(_BYTE *)(v27 + 25) || (int)sub_1403DFBE0(&v34, (_QWORD *)(v27 + 32)) < 0 )
      {
        if ( a1[46] == 0x555555555555555LL )
        {
          unknown_libname_7();
        }
        v29 = a1[45];
        v30 = sub_1402A1E30(0x30u);
        sub_1403577A0((_QWORD *)(v30 + 32), (__int64 *)&v34);
        v31 = v33[0];
        *(_QWORD *)(v30 + 40) = 0;
        *(_QWORD *)v30 = v29;
        *(_QWORD *)(v30 + 8) = v29;
        *(_QWORD *)(v30 + 16) = v29;
        *(_WORD *)(v30 + 24) = 0;
        v33[0] = v31;
        v27 = sub_1402DE890((__int64 **)a1 + 45, (__int64)v33, v30);
      }
      *(_QWORD *)(v27 + 40) = v9;
      DestroyStringObject(&v34);
      if ( *(_BYTE *)(v15 + 32) )
      {
        v32 = (_BYTE *)a1[51];
        if ( v32 == (_BYTE *)a1[52] )
        {
          sub_1402A4BA0(a1 + 50, v32, &v35);
        }
        else
        {
          *(_QWORD *)v32 = v9;
          a1[51] += 8LL;
        }
      }
      return v9;
    }
  }
}

// --- End Function: sub_14724E7E0 (0x14724E7E0) ---

// --- Function: sub_147250D70 (0x147250D70) ---
double sub_147250D70()
{
  int n9984; // [rsp+30h] [rbp-58h] BYREF
  __int64 v2; // [rsp+34h] [rbp-54h]
  int v3; // [rsp+3Ch] [rbp-4Ch]
  __int64 v4; // [rsp+40h] [rbp-48h]
  unsigned __int64 v5; // [rsp+48h] [rbp-40h]
  __int64 v6; // [rsp+50h] [rbp-38h]
  __int64 v7; // [rsp+58h] [rbp-30h]

  n9984 = 9984;
  v2 = 0;
  v3 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v4 = 1;
  qword_149818EA0(
    &n9984,
    0,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  v5 = __rdtsc();
  return qword_149818EA8(&n9984);
}

// --- End Function: sub_147250D70 (0x147250D70) ---

// --- Function: sub_147251810 (0x147251810) ---
double __fastcall sub_147251810(_QWORD *pDataCore, __int64 *a2, _QWORD *a3, _QWORD *a4, char **a5)
{
  _QWORD *v8; // r13
  const char *s1; // rbx
  char v10; // r9
  const char *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.; // rax
  unsigned __int64 v12; // rdi
  signed __int64 v13; // rax
  _QWORD *v14; // rax
  _QWORD *v15; // r14
  __int64 v16; // rdx
  double result; // xmm0_8
  __int64 structIdentifier; // rax
  unsigned __int64 v19; // rbp
  __int64 v20; // rcx
  __int64 *v21; // rdx
  __int64 v22; // rdi
  __int64 v23; // rax
  int v24; // ecx
  int v25; // r8d
  __int128 pOutFieldPtrsVec_; // [rsp+30h] [rbp-58h] BYREF
  __int64 v27; // [rsp+40h] [rbp-48h]
  char v28; // [rsp+98h] [rbp+10h] BYREF
  _QWORD *v29; // [rsp+A8h] [rbp+20h]

  v29 = a4;
  v28 = 0;
  v8 = a4;
  (*(void (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*a3 + 144LL))(*a3, "__fullyInstanced", &v28);
  s1 = (const char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a3 + 272LL))(*a3, "__type");
  if ( v28 )
  {
    v10 = *((_BYTE *)a2 + 8);
    p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (const char *)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
    if ( v10 && *a2 )
    {
      p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (const char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 8LL))(*a2);
      v10 = *((_BYTE *)a2 + 8);
    }
    if ( strcmp(s1, p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.) )
    {
      v12 = 0;
      if ( v10 )
      {
        if ( *a2 )
        {
          (**(void (__fastcall ***)(_QWORD, __int64))*a2)(*a2, 1);
          *a2 = 0;
        }
        *((_BYTE *)a2 + 8) = 0;
      }
      v13 = DataCore::LookupDCStructDescByName((__int64)pDataCore, (__int64)s1);
      if ( v13 )
      {
        v14 = (_QWORD *)(***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v13 + 16))(*(_QWORD *)(v13 + 16), 0);
        *a2 = (__int64)v14;
        v15 = v14;
        if ( v14 )
        {
          v16 = *v14;
          result = 0.0;
          pOutFieldPtrsVec_ = 0;
          v27 = 0;
          structIdentifier = (*(__int64 (__fastcall **)(_QWORD *))(v16 + 8))(v14);
          DataCore::GetStructFieldPointers((__int64)pDataCore, structIdentifier, (char **)&pOutFieldPtrsVec_, 1);
          v19 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
          if ( v19 )
          {
            do
            {
              if ( (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3 <= v12 )
              {
                __debugbreak();
              }
              v20 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v12);
              v21 = (_QWORD *)((char *)v15 + *(_QWORD *)(v20 + 8));
              if ( !*(_BYTE *)(v20 + 26) )
              {
                switch ( *(_BYTE *)(v20 + 24) )
                {
                  case 1:
                  case 2:
                  case 6:
                    *(_BYTE *)v21 = 0;
                    break;
                  case 3:
                  case 7:
                    *(_WORD *)v21 = 0;
                    break;
                  case 4:
                  case 8:
                  case 0xB:
                    *(_DWORD *)v21 = 0;
                    break;
                  case 5:
                  case 9:
                  case 0xC:
                    *v21 = 0;
                    break;
                  case 0xF:
                    switch ( *(_QWORD *)(v20 + 16) )
                    {
                      case 1LL:
                        *(_BYTE *)v21 = -1;
                        break;
                      case 2LL:
                        *(_WORD *)v21 = -1;
                        break;
                      case 4LL:
                        *(_DWORD *)v21 = -1;
                        break;
                    }
                    break;
                  case 0x10:
                    if ( !*(_BYTE *)(v20 + 25) )
                    {
                      sub_147269A00(pDataCore, v21);
                    }
                    break;
                  default:
                    break;
                }
              }
              ++v12;
            }
            while ( v12 < v19 );
            v8 = v29;
          }
          if ( (_QWORD)pOutFieldPtrsVec_ )
          {
            sub_14039EFB0(
              (__int64)&pOutFieldPtrsVec_,
              (const void *)pOutFieldPtrsVec_,
              (v27 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
          }
        }
        *((_BYTE *)a2 + 8) = 1;
      }
    }
  }
  if ( *((_BYTE *)a2 + 8) )
  {
    v22 = *a2;
    if ( *a2 )
    {
      v23 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v22 + 8LL))(*a2) - (_QWORD)s1;
      do
      {
        v24 = (unsigned __int8)s1[v23];
        v25 = *(unsigned __int8 *)s1 - v24;
        if ( v25 )
        {
          break;
        }
        ++s1;
      }
      while ( v24 );
      if ( !v25 )
      {
        return sub_147251B00(pDataCore, v22, a3, v8, a5);
      }
    }
  }
  return result;
}

// --- End Function: sub_147251810 (0x147251810) ---

// --- Function: sub_147251B00 (0x147251B00) ---
double __fastcall sub_147251B00(_QWORD *pDataCore_1, __int64 rdx0, _QWORD *a3, _QWORD *a4, char **a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  char **v7; // rbx
  _QWORD *v8; // r13
  __int64 v10; // rdi
  _QWORD *pDataCore_2; // r14
  char *s1_1; // rax
  __int128 p__XMM0_1; // xmm0
  __int64 v14; // rsi
  __int64 v15; // rax
  unsigned __int64 v16; // rdx
  __int64 pOutFieldPtrsVec__1; // rcx
  __int64 v18; // rax
  __int64 v19; // r14
  int n16; // ebx
  int n2_1; // r12d
  char v22; // di
  __int64 v23; // r15
  __int64 v24; // rsi
  const char *s2; // rax
  int v26; // r8d
  __int64 v27; // rcx
  __int64 v28; // rax
  __int64 v29; // rbx
  _QWORD *v30; // rbx
  int v31; // ebx
  __int64 *ThreadLogContextSlot; // rax
  char v33; // al
  __int64 v35; // r9
  int v36; // eax
  __int64 v37; // r15
  __int64 n2; // r15
  __int64 *v39; // rax
  __int64 (__fastcall ***v40)(_QWORD); // rax
  __int64 v41; // rax
  char *String1_2; // rdi
  size_t n511_4; // rcx
  const char *p_Str; // rdx
  size_t n511_2; // rbx
  void *p_Str_2; // rax
  const char *v47; // r15
  const char *p_Str_3; // rbx
  int n511_8; // r14d
  int n511_35; // eax
  size_t n511_7; // rdi
  const char *v52; // r8
  int n511_34; // eax
  size_t n511_6; // rbx
  int v55; // r14d
  char *v56; // rdi
  size_t Size; // rbx
  __int64 *v58; // rbx
  __int64 v59; // rdx
  const char *v60; // rdi
  int String1_3; // eax
  unsigned __int64 n0x6400000; // r15
  unsigned __int64 v63; // r13
  const void *ptr_to_free; // rcx
  __int64 v65; // rax
  __int64 v66; // rbx
  _BYTE *ptr_to_free_1; // r9
  _BYTE *v68; // rdx
  unsigned __int64 n0x6400000_1; // rbx
  _QWORD *v70; // rax
  const void *ptr_to_free_2; // rcx
  __int64 v72; // rax
  __int64 v73; // rbx
  _BYTE *ptr_to_free_3; // r8
  _BYTE *v75; // rcx
  char v76; // di
  unsigned __int64 n0x6400000_2; // rbx
  _QWORD *v78; // rax
  const void *ptr_to_free_4; // rcx
  __int64 v80; // rax
  __int64 v81; // rbx
  char *ptr_to_free_5; // r9
  unsigned __int64 v83; // rdx
  _WORD *v84; // rcx
  __int16 v85; // di
  unsigned __int64 n0x6400000_3; // rbx
  _QWORD *v87; // rax
  const void *ptr_to_free_6; // rcx
  __int64 v89; // rax
  __int64 v90; // rbx
  char *ptr_to_free_7; // r9
  unsigned __int64 v92; // rdx
  _DWORD *v93; // rcx
  unsigned __int64 n0x6400000_4; // rbx
  _QWORD *v95; // rax
  const void *ptr_to_free_8; // rcx
  __int64 v97; // rax
  __int64 v98; // rbx
  char *ptr_to_free_9; // r9
  unsigned __int64 v100; // rdx
  _QWORD *v101; // rcx
  unsigned __int64 n0x6400000_5; // rbx
  _QWORD *v103; // rax
  const void *ptr_to_free_10; // rcx
  __int64 v105; // rax
  __int64 v106; // rbx
  _BYTE *ptr_to_free_11; // r8
  _BYTE *v108; // rcx
  char v109; // di
  unsigned __int64 n0x6400000_6; // rbx
  _QWORD *v111; // rax
  const void *ptr_to_free_12; // rcx
  __int64 v113; // rax
  __int64 v114; // rbx
  char *ptr_to_free_13; // r9
  unsigned __int64 v116; // rdx
  _WORD *v117; // rcx
  __int16 v118; // di
  unsigned __int64 n0x6400000_7; // rbx
  _QWORD *v120; // rax
  const void *ptr_to_free_14; // rcx
  __int64 v122; // rax
  __int64 v123; // rbx
  char *ptr_to_free_15; // r9
  unsigned __int64 v125; // rdx
  _DWORD *v126; // rcx
  unsigned __int64 n0x6400000_8; // rbx
  _QWORD *v128; // rax
  const void *ptr_to_free_16; // rcx
  __int64 v130; // rax
  __int64 v131; // rbx
  char *ptr_to_free_17; // r9
  unsigned __int64 v133; // rdx
  _QWORD *v134; // rcx
  unsigned __int64 n0x6400000_9; // rbx
  _QWORD *v136; // rax
  __int64 v137; // r9
  const void *ptr_to_free_18; // rcx
  __int64 v139; // rax
  __int64 v140; // rbx
  char *ptr_to_free_19; // r9
  unsigned __int64 v142; // rdx
  _DWORD *v143; // rcx
  unsigned __int64 n0x6400000_13; // rbx
  _QWORD *v145; // rax
  const void *ptr_to_free_20; // rcx
  __int64 v147; // rax
  __int64 v148; // rbx
  char *ptr_to_free_21; // r9
  unsigned __int64 v150; // rdx
  _QWORD *v151; // rcx
  unsigned __int64 n0x6400000_14; // rbx
  _QWORD *v153; // rax
  __int64 v154; // r9
  __int64 v155; // rdi
  const void *ptr_to_free_28; // rcx
  __int64 v157; // rax
  __int64 v158; // rbx
  char *ptr_to_free_29; // r9
  unsigned __int64 v160; // rdx
  _DWORD *v161; // rcx
  const void *ptr_to_free_26; // rcx
  __int64 v163; // rax
  __int64 v164; // rbx
  char *ptr_to_free_27; // r9
  unsigned __int64 v166; // rdx
  _WORD *v167; // rcx
  const void *ptr_to_free_24; // rcx
  __int64 v169; // rax
  __int64 v170; // rbx
  _BYTE *ptr_to_free_25; // r8
  _BYTE *v172; // rcx
  unsigned __int64 n0x6400000_19; // rbx
  _QWORD *v174; // rax
  int v175; // eax
  char *String1_6; // rcx
  __int64 v177; // rax
  __int64 v178; // r14
  __int64 v179; // rdi
  __int64 i; // rbx
  __int64 v181; // rax
  bool v182; // cf
  unsigned __int64 n0x6400000_10; // rax
  _QWORD *v184; // rax
  unsigned __int64 n0x6400000_11; // rdx
  _QWORD *v186; // rcx
  _QWORD *v187; // r12
  unsigned __int64 v188; // rdi
  __int64 v189; // r15
  __int64 v190; // rbx
  __int64 v191; // rdi
  __int64 j; // rbx
  unsigned __int64 n0x6400000_12; // rbx
  __int64 v194; // rdi
  _QWORD *v195; // rax
  __int64 v196; // r14
  __int64 v197; // rbx
  _QWORD *k; // rdi
  __int64 v199; // rax
  unsigned __int64 n0x6400000_15; // rax
  _QWORD *v201; // rax
  _QWORD *v202; // r14
  unsigned __int64 n0x6400000_16; // rbx
  _QWORD *v204; // rdi
  void **v205; // r12
  unsigned __int64 v206; // rdi
  __int64 v207; // r15
  void **v208; // rbx
  __int64 v209; // rbx
  _QWORD *m; // rdi
  unsigned __int64 n0x6400000_17; // rbx
  _QWORD *v212; // rax
  const void *ptr_to_free_22; // rcx
  __int64 v214; // rbx
  char *ptr_to_free_23; // rax
  unsigned __int64 v216; // rdx
  _OWORD *v217; // rcx
  unsigned __int64 n0x6400000_18; // rbx
  __int64 v219; // rdi
  _QWORD *v220; // rax
  __int64 *v221; // rax
  const void *ptr_to_free_30; // rcx
  __int64 v223; // rax
  __int64 v224; // r14
  unsigned __int64 n0x6400000_24; // rbx
  _QWORD *v226; // rdi
  unsigned __int64 v227; // rcx
  char *ptr_to_free_31; // r8
  __int64 v229; // rax
  char *v230; // rdx
  unsigned __int64 n0x6400000_25; // r14
  __int64 v232; // rbx
  _QWORD *v233; // rax
  __int64 *v234; // rax
  __int64 v235; // rdi
  __int64 (__fastcall ***v236)(_QWORD); // rax
  _QWORD *v237; // rcx
  size_t n511_12; // rbx
  __int64 v239; // rax
  unsigned __int64 n0x6400000_26; // rax
  _QWORD *v241; // rax
  _QWORD *v242; // r14
  unsigned __int64 n0x6400000_27; // rbx
  __int64 v244; // rdi
  _QWORD *v245; // rax
  unsigned __int64 String1_7; // r13
  __int64 v247; // rax
  const void *v248; // rdi
  char *v249; // rax
  char *v250; // rdx
  unsigned __int64 n511_14; // rcx
  char *v252; // rbx
  char *v253; // r15
  int n511_19; // r14d
  int n511_20; // eax
  char *v256; // r8
  int n511_36; // eax
  size_t n511_16; // rbx
  int v259; // r12d
  _BYTE *p_Src; // r14
  size_t n511_18; // rdi
  char *v262; // r15
  _BYTE *p_Src_2; // rax
  _BYTE *v264; // rax
  char *v265; // rdi
  unsigned __int64 v266; // rbx
  __int64 *v267; // r14
  __int64 v268; // rdx
  char *v269; // rcx
  unsigned __int64 v270; // rax
  _QWORD *v271; // rcx
  __int64 v272; // rax
  unsigned __int64 n0x6400000_21; // rax
  _QWORD *v274; // rax
  _QWORD *v275; // r14
  unsigned __int64 n0x6400000_22; // rbx
  __int64 v277; // rdi
  _QWORD *v278; // rax
  unsigned __int64 n0x6400000_23; // rbx
  char **v280; // rdi
  const char *s1_2; // rax
  __int64 v282; // rax
  _QWORD *v283; // rax
  __int64 v284; // rbx
  signed __int64 v285; // rax
  _QWORD *v286; // rbx
  unsigned __int64 n0x6400000_20; // rdi
  __int64 *v288; // rbx
  unsigned __int64 n0x6400000_41; // rdi
  unsigned __int64 n0x6400000_28; // rbx
  _QWORD *v291; // rax
  _QWORD *v292; // rax
  unsigned __int64 n0x6400000_29; // rbx
  _QWORD *v294; // rax
  _QWORD *v295; // rax
  unsigned __int64 n0x6400000_30; // rbx
  _QWORD *v297; // rax
  _QWORD *v298; // rax
  unsigned __int64 n0x6400000_31; // rbx
  _QWORD *v300; // rax
  _QWORD *v301; // rax
  unsigned __int64 n0x6400000_32; // rbx
  _QWORD *v303; // rax
  _QWORD *v304; // rax
  unsigned __int64 n0x6400000_33; // rbx
  _QWORD *v306; // rax
  _QWORD *v307; // rax
  unsigned __int64 n0x6400000_34; // rbx
  _QWORD *v309; // rax
  _QWORD *v310; // rax
  unsigned __int64 n0x6400000_35; // rbx
  _QWORD *v312; // rax
  _QWORD *v313; // rax
  unsigned __int64 n0x6400000_36; // rbx
  _QWORD *v315; // rax
  _QWORD *v316; // rax
  __int64 v317; // r9
  unsigned __int64 n0x6400000_38; // rbx
  _QWORD *v319; // rax
  _QWORD *v320; // rax
  unsigned __int64 n0x6400000_39; // rbx
  _QWORD *v322; // rax
  _QWORD *v323; // rax
  __int64 v324; // r9
  __int64 v325; // rdi
  unsigned __int64 n0x6400000_42; // rbx
  _QWORD *v327; // rax
  _QWORD *v328; // rax
  int v329; // eax
  unsigned __int64 n0x6400000_37; // rbx
  _QWORD *v331; // rax
  _QWORD *v332; // rax
  unsigned __int64 n0x6400000_40; // rbx
  _QWORD *v334; // rax
  _QWORD *v335; // rax
  _QWORD *v336; // rax
  _QWORD *v337; // rax
  __int64 v338; // rbx
  __int64 *v339; // rax
  unsigned __int64 n0x6400000_46; // r14
  __int64 *v341; // rax
  __int64 v342; // rdi
  __int64 v343; // rbx
  __int64 (__fastcall ***v344)(_QWORD); // rax
  unsigned __int64 n0x6400000_45; // r13
  __int64 v346; // rcx
  __int64 v347; // rax
  const void *v348; // rdi
  size_t n511_25; // rbx
  char *v350; // rdx
  unsigned __int64 n511_27; // rcx
  char *v352; // rbx
  char *v353; // r15
  int n511_30; // r14d
  int n511_31; // eax
  char *v356; // r8
  int n511_37; // eax
  size_t n511_29; // rbx
  int v359; // r12d
  unsigned __int64 n511_32; // rdi
  _BYTE *v361; // r14
  char *v362; // r15
  __int64 v363; // rbx
  char *v364; // rdi
  __int64 *v365; // r14
  __int64 v366; // rdx
  unsigned __int64 n0x6400000_44; // rbx
  char **v368; // rdi
  const char *s1_3; // rax
  __int64 v370; // rax
  _QWORD *v371; // rax
  __int64 v372; // rbx
  unsigned __int64 n0x6400000_43; // rbx
  __int64 v374; // rax
  signed __int64 v375; // rax
  __int64 v377; // [rsp+70h] [rbp-90h]
  int v380; // [rsp+88h] [rbp-78h] BYREF
  __int64 v381; // [rsp+90h] [rbp-70h] BYREF
  char **v382; // [rsp+98h] [rbp-68h]
  char v383; // [rsp+A0h] [rbp-60h] BYREF
  char v384; // [rsp+A1h] [rbp-5Fh] BYREF
  char v385; // [rsp+A2h] [rbp-5Eh] BYREF
  char v386[5]; // [rsp+A3h] [rbp-5Dh] BYREF
  char *String1; // [rsp+A8h] [rbp-58h] BYREF
  __int64 v388; // [rsp+B0h] [rbp-50h] BYREF
  int v389; // [rsp+B8h] [rbp-48h] BYREF
  int v390; // [rsp+BCh] [rbp-44h] BYREF
  float v391; // [rsp+C0h] [rbp-40h] BYREF
  int v392; // [rsp+C4h] [rbp-3Ch] BYREF
  int v393; // [rsp+C8h] [rbp-38h] BYREF
  float v394; // [rsp+CCh] [rbp-34h] BYREF
  char *s1; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v396; // [rsp+D8h] [rbp-28h] BYREF
  void *v397; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v398; // [rsp+E8h] [rbp-18h] BYREF
  __int16 v399[2]; // [rsp+F0h] [rbp-10h] BYREF
  __int16 v400; // [rsp+F4h] [rbp-Ch] BYREF
  char v401[4]; // [rsp+F8h] [rbp-8h] BYREF
  __int16 v402; // [rsp+FCh] [rbp-4h] BYREF
  __int16 v403[2]; // [rsp+100h] [rbp+0h] BYREF
  __int16 v404; // [rsp+104h] [rbp+4h] BYREF
  char v405[4]; // [rsp+108h] [rbp+8h] BYREF
  __int16 v406; // [rsp+10Ch] [rbp+Ch] BYREF
  _DWORD v407[2]; // [rsp+110h] [rbp+10h] BYREF
  _DWORD v408[2]; // [rsp+118h] [rbp+18h] BYREF
  __int64 v409; // [rsp+120h] [rbp+20h] BYREF
  _QWORD *v410; // [rsp+128h] [rbp+28h]
  __int64 v411; // [rsp+130h] [rbp+30h] BYREF
  char *String1_5; // [rsp+138h] [rbp+38h] BYREF
  __int64 v413; // [rsp+140h] [rbp+40h] BYREF
  char *String1_9; // [rsp+148h] [rbp+48h] BYREF
  __int64 v415; // [rsp+150h] [rbp+50h] BYREF
  __int64 v416; // [rsp+158h] [rbp+58h] BYREF
  __int64 v417; // [rsp+160h] [rbp+60h] BYREF
  __int128 pOutFieldPtrsVec_; // [rsp+168h] [rbp+68h] BYREF
  __int64 v419; // [rsp+178h] [rbp+78h]
  __int64 arg48; // [rsp+180h] [rbp+80h] BYREF
  double v421; // [rsp+188h] [rbp+88h] BYREF
  void *v422; // [rsp+190h] [rbp+90h] BYREF
  __int64 v423; // [rsp+198h] [rbp+98h] BYREF
  __int64 v424; // [rsp+1A0h] [rbp+A0h] BYREF
  __int64 v425; // [rsp+1A8h] [rbp+A8h] BYREF
  __int64 v426; // [rsp+1B0h] [rbp+B0h] BYREF
  __int64 v427; // [rsp+1B8h] [rbp+B8h] BYREF
  void *v428; // [rsp+1C0h] [rbp+C0h] BYREF
  unsigned __int64 v429; // [rsp+1C8h] [rbp+C8h]
  __int64 v430; // [rsp+1D0h] [rbp+D0h] BYREF
  __int64 v431; // [rsp+1D8h] [rbp+D8h] BYREF
  void *v432; // [rsp+1E0h] [rbp+E0h] BYREF
  unsigned __int64 v433; // [rsp+1E8h] [rbp+E8h] BYREF
  void *v434; // [rsp+1F0h] [rbp+F0h] BYREF
  __int64 v435; // [rsp+1F8h] [rbp+F8h] BYREF
  void *v436; // [rsp+200h] [rbp+100h] BYREF
  double v437; // [rsp+208h] [rbp+108h] BYREF
  __int64 v438; // [rsp+210h] [rbp+110h] BYREF
  __int64 v439; // [rsp+218h] [rbp+118h] BYREF
  __int64 v440; // [rsp+220h] [rbp+120h] BYREF
  __int64 v441; // [rsp+228h] [rbp+128h] BYREF
  __int64 v442; // [rsp+230h] [rbp+130h] BYREF
  __int64 v443; // [rsp+238h] [rbp+138h] BYREF
  __int64 v444; // [rsp+240h] [rbp+140h] BYREF
  __int64 v445; // [rsp+248h] [rbp+148h] BYREF
  __int64 v446; // [rsp+250h] [rbp+150h] BYREF
  __int64 v447; // [rsp+258h] [rbp+158h] BYREF
  __int64 v448; // [rsp+260h] [rbp+160h] BYREF
  __int64 v449; // [rsp+268h] [rbp+168h] BYREF
  __int64 v450; // [rsp+270h] [rbp+170h] BYREF
  __int64 v451; // [rsp+278h] [rbp+178h] BYREF
  _BYTE *v452; // [rsp+280h] [rbp+180h] BYREF
  __int64 v453; // [rsp+288h] [rbp+188h] BYREF
  _BYTE *v454; // [rsp+290h] [rbp+190h] BYREF
  __int64 v455; // [rsp+298h] [rbp+198h] BYREF
  char *v456; // [rsp+2A0h] [rbp+1A0h] BYREF
  __int64 v457; // [rsp+2A8h] [rbp+1A8h] BYREF
  char *v458; // [rsp+2B0h] [rbp+1B0h] BYREF
  __int64 v459; // [rsp+2B8h] [rbp+1B8h] BYREF
  __int64 v460; // [rsp+2C0h] [rbp+1C0h] BYREF
  __int64 v461; // [rsp+2C8h] [rbp+1C8h] BYREF
  __int64 v462; // [rsp+2D0h] [rbp+1D0h] BYREF
  __int64 v463; // [rsp+2D8h] [rbp+1D8h] BYREF
  __int64 v464; // [rsp+2E0h] [rbp+1E0h] BYREF
  __int64 v465; // [rsp+2E8h] [rbp+1E8h] BYREF
  __int64 v466; // [rsp+2F0h] [rbp+1F0h] BYREF
  __int64 v467; // [rsp+2F8h] [rbp+1F8h] BYREF
  __int64 v468; // [rsp+300h] [rbp+200h] BYREF
  __int64 v469; // [rsp+308h] [rbp+208h] BYREF
  __int64 v470; // [rsp+310h] [rbp+210h] BYREF
  __int64 v471; // [rsp+318h] [rbp+218h] BYREF
  __int64 v472; // [rsp+320h] [rbp+220h] BYREF
  __int64 v473; // [rsp+328h] [rbp+228h] BYREF
  __int64 v474; // [rsp+330h] [rbp+230h] BYREF
  __int64 v475; // [rsp+338h] [rbp+238h] BYREF
  __int64 v476; // [rsp+340h] [rbp+240h] BYREF
  __int64 v477; // [rsp+348h] [rbp+248h] BYREF
  __int64 v478; // [rsp+350h] [rbp+250h] BYREF
  __int64 v479; // [rsp+358h] [rbp+258h] BYREF
  __int64 v480; // [rsp+360h] [rbp+260h] BYREF
  __int64 v481; // [rsp+368h] [rbp+268h] BYREF
  __int64 v482; // [rsp+370h] [rbp+270h] BYREF
  __int64 v483; // [rsp+378h] [rbp+278h] BYREF
  __int64 v484; // [rsp+380h] [rbp+280h] BYREF
  __int64 v485; // [rsp+388h] [rbp+288h] BYREF
  _BYTE *v486; // [rsp+390h] [rbp+290h] BYREF
  __int64 v487; // [rsp+398h] [rbp+298h] BYREF
  __int64 v488; // [rsp+3A0h] [rbp+2A0h] BYREF
  _BYTE *v489; // [rsp+3A8h] [rbp+2A8h] BYREF
  __int64 v490; // [rsp+3B0h] [rbp+2B0h] BYREF
  __int64 v491; // [rsp+3B8h] [rbp+2B8h] BYREF
  char *v492; // [rsp+3C0h] [rbp+2C0h] BYREF
  char *v493; // [rsp+3C8h] [rbp+2C8h] BYREF
  __int64 v494; // [rsp+3D0h] [rbp+2D0h] BYREF
  unsigned __int64 v495; // [rsp+3D8h] [rbp+2D8h]
  __int64 v496; // [rsp+3E0h] [rbp+2E0h]
  __int64 v497; // [rsp+3E8h] [rbp+2E8h] BYREF
  __int64 v498; // [rsp+3F0h] [rbp+2F0h] BYREF
  __int64 v499; // [rsp+3F8h] [rbp+2F8h] BYREF
  __int64 v500; // [rsp+400h] [rbp+300h] BYREF
  int n5632; // [rsp+410h] [rbp+310h] BYREF
  __int64 v502; // [rsp+414h] [rbp+314h]
  int v503; // [rsp+41Ch] [rbp+31Ch]
  __int64 v504; // [rsp+420h] [rbp+320h]
  unsigned __int64 v505; // [rsp+428h] [rbp+328h]
  __int64 v506; // [rsp+430h] [rbp+330h]
  __int64 v507; // [rsp+438h] [rbp+338h]
  __int64 v508[2]; // [rsp+460h] [rbp+360h] BYREF
  _QWORD v509[2]; // [rsp+470h] [rbp+370h] BYREF
  __int128 v510; // [rsp+480h] [rbp+380h] BYREF
  char v511[16]; // [rsp+490h] [rbp+390h] BYREF
  char v512[16]; // [rsp+4A0h] [rbp+3A0h] BYREF
  char v513[16]; // [rsp+4B0h] [rbp+3B0h] BYREF
  char v514[16]; // [rsp+4C0h] [rbp+3C0h] BYREF
  char v515[16]; // [rsp+4D0h] [rbp+3D0h] BYREF
  char v516[16]; // [rsp+4E0h] [rbp+3E0h] BYREF
  __int128 p__XMM0; // [rsp+4F0h] [rbp+3F0h] BYREF
  __int128 _XMM0; // [rsp+500h] [rbp+400h] BYREF
  __int128 _XMM0_1; // [rsp+510h] [rbp+410h] BYREF
  size_t n511_13; // [rsp+520h] [rbp+420h]
  unsigned __int64 n511_10; // [rsp+528h] [rbp+428h]
  char *v522; // [rsp+530h] [rbp+430h]
  _BYTE v523[520]; // [rsp+538h] [rbp+438h] BYREF
  size_t n511_17; // [rsp+740h] [rbp+640h]
  __int64 n511_15; // [rsp+748h] [rbp+648h]
  void *p_Src_1; // [rsp+750h] [rbp+650h]
  _BYTE Src[520]; // [rsp+758h] [rbp+658h] BYREF
  size_t n511_21; // [rsp+960h] [rbp+860h]
  unsigned __int64 n511_11; // [rsp+968h] [rbp+868h]
  void *v530; // [rsp+970h] [rbp+870h]
  _BYTE v531[520]; // [rsp+978h] [rbp+878h] BYREF
  __int64 Size_1; // [rsp+B80h] [rbp+A80h] BYREF
  __int64 n511_5; // [rsp+B88h] [rbp+A88h]
  void *a2; // [rsp+B90h] [rbp+A90h]
  _BYTE v535[520]; // [rsp+B98h] [rbp+A98h] BYREF
  __int64 n511_38; // [rsp+DA0h] [rbp+CA0h] BYREF
  __int64 n511_28; // [rsp+DA8h] [rbp+CA8h]
  void *v538; // [rsp+DB0h] [rbp+CB0h]
  _BYTE v539[520]; // [rsp+DB8h] [rbp+CB8h] BYREF
  __int64 n511_26; // [rsp+FC0h] [rbp+EC0h] BYREF
  unsigned __int64 n511_23; // [rsp+FC8h] [rbp+EC8h]
  char *v542; // [rsp+FD0h] [rbp+ED0h]
  _BYTE v543[520]; // [rsp+FD8h] [rbp+ED8h] BYREF
  size_t n511_3; // [rsp+11E0h] [rbp+10E0h]
  __int64 n511_1; // [rsp+11E8h] [rbp+10E8h]
  void *p_Str_1; // [rsp+11F0h] [rbp+10F0h]
  char Str[520]; // [rsp+11F8h] [rbp+10F8h] BYREF
  __int64 n511_33; // [rsp+1400h] [rbp+1300h] BYREF
  unsigned __int64 n511_24; // [rsp+1408h] [rbp+1308h]
  void *v550; // [rsp+1410h] [rbp+1310h]
  _BYTE v551[520]; // [rsp+1418h] [rbp+1318h] BYREF
  __int64 v552; // [rsp+1620h] [rbp+1520h] BYREF
  __int64 n511; // [rsp+1628h] [rbp+1528h]
  char *String1_1; // [rsp+1630h] [rbp+1530h]
  _BYTE v555[520]; // [rsp+1638h] [rbp+1538h] BYREF
  __int64 v556; // [rsp+1840h] [rbp+1740h] BYREF
  __int64 n511_9; // [rsp+1848h] [rbp+1748h]
  char *String1_4; // [rsp+1850h] [rbp+1750h]
  _BYTE v559[520]; // [rsp+1858h] [rbp+1758h] BYREF
  __int64 v560; // [rsp+1A60h] [rbp+1960h] BYREF
  __int64 n511_22; // [rsp+1A68h] [rbp+1968h]
  char *String1_8; // [rsp+1A70h] [rbp+1970h]
  _BYTE v563[520]; // [rsp+1A78h] [rbp+1978h] BYREF
  __int128 v564; // [rsp+1C90h] [rbp+1B90h]
  __int128 v565; // [rsp+1CA0h] [rbp+1BA0h]

  v7 = a5;
  v8 = a4;
  v410 = a3;
  v10 = rdx0;
  v377 = rdx0;
  pDataCore_2 = pDataCore_1;
  v398 = rdx0;
  v382 = a5;
  v502 = 0;
  v503 = 0;
  v505 = 0;
  v506 = 0;
  v507 = 0;
  n5632 = 5632;
  v504 = 1;
  qword_149818EA0(
    &n5632,
    0,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  if ( v10 )
  {
    s1_1 = (char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a3 + 272LL))(*a3, "__type");
    s1 = s1_1;
    if ( s1_1 )
    {
      if ( *s1_1 )
      {
        p__XMM0_1 = 0;
        v496 = v10;
        v419 = 0;
        pOutFieldPtrsVec_ = 0;
        v14 = v10;
        DataCore::GetStructFieldPointers((__int64)pDataCore_2, (__int64)s1_1, (char **)&pOutFieldPtrsVec_, 1);
        v15 = *((_QWORD *)&pOutFieldPtrsVec_ + 1);
        v16 = 0;
        pOutFieldPtrsVec__1 = pOutFieldPtrsVec_;
        v429 = 0;
        v495 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
        if ( v495 )
        {
          v565 = v5;
          v564 = v6;
          while ( 1 )
          {
            if ( (v15 - pOutFieldPtrsVec__1) >> 3 <= v16 )
            {
              __debugbreak();
            }
            v18 = *(_QWORD *)(pOutFieldPtrsVec__1 + 8 * v16);
            v19 = *(_QWORD *)v18;
            n16 = *(unsigned __int8 *)(v18 + 24);
            n2_1 = *(unsigned __int8 *)(v18 + 25);
            v22 = *(_BYTE *)(v18 + 26);
            v23 = *(_QWORD *)(v18 + 16);
            v24 = *(_QWORD *)(v18 + 8) + v14;
            s2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v377 + 8LL))(v377);
            v26 = strcmp(s1, s2);
            v27 = *v410;
            if ( v26 )
            {
              break;
            }
            if ( !v22 )
            {
              String1 = 0;
              if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, char **))(*(_QWORD *)v27 + 264LL))(
                     v27,
                     v19,
                     &String1)
                || (_BYTE)n16 == 16 && (unsigned __int8)(n2_1 - 2) > 1u )
              {
                switch ( n16 )
                {
                  case 1:
                    v33 = *String1 == 49 && !String1[1] || !_stricmp(String1, "true");
                    goto LABEL_33;
                  case 2:
                  case 6:
                    v33 = atoi(String1);
LABEL_33:
                    *(_BYTE *)v24 = v33;
                    goto LABEL_34;
                  case 3:
                  case 7:
                    *(_WORD *)v24 = atoi(String1);
                    goto LABEL_34;
                  case 4:
                    *(_DWORD *)v24 = atoi(String1);
                    goto LABEL_34;
                  case 5:
                    *(_QWORD *)v24 = atoi64(String1);
                    goto LABEL_34;
                  case 8:
                    *(_DWORD *)v24 = atoll(String1);
                    goto LABEL_34;
                  case 9:
                    *(_QWORD *)v24 = strtoull(String1, 0, 10);
                    goto LABEL_34;
                  case 10:
                    sub_140376330(v24, String1);
                    goto LABEL_34;
                  case 11:
                    *(double *)&p__XMM0_1 = atof(String1);
                    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
                    *(float *)v24 = *(float *)&_XMM1;
                    goto LABEL_34;
                  case 12:
                    *(double *)v24 = atof(String1);
                    goto LABEL_34;
                  case 13:
                    if ( String1 && *String1 == 64 )
                    {
                      assignCStringToStringStructure((void **)v24, String1);
                    }
                    goto LABEL_34;
                  case 14:
                    v39 = sub_1402BA020((__int64 *)v511, String1);
                    p__XMM0_1 = *(_OWORD *)v39;
                    *(_OWORD *)v24 = *(_OWORD *)v39;
                    goto LABEL_34;
                  case 15:
                    v35 = v19;
                    v555[0] = 0;
                    pDataCore_2 = pDataCore_1;
                    String1_1 = v555;
                    v552 = 0;
                    n511 = 511;
                    sub_14723DDC0(pDataCore_1, (__int64)&v552, s1, v35);
                    v36 = sub_14723ABD0(pDataCore_1, String1_1, String1);
                    v37 = v23 - 1;
                    if ( v37 )
                    {
                      n2 = v37 - 1;
                      if ( n2 )
                      {
                        if ( n2 == 2 )
                        {
                          *(_DWORD *)v24 = v36;
                        }
                      }
                      else
                      {
                        *(_WORD *)v24 = v36;
                      }
                    }
                    else
                    {
                      *(_BYTE *)v24 = v36;
                    }
                    if ( String1_1 != v555 )
                    {
                      qword_149808368 += -1 - n511;
                      sub_14739AF10(String1_1);
                    }
                    v7 = v382;
                    goto LABEL_36;
                  case 16:
                    if ( !(_BYTE)n2_1 )
                    {
                      (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(*(_QWORD *)*v410 + 360LL))(*v410, &v411, v19);
                      v7 = v382;
                      pDataCore_2 = pDataCore_1;
                      if ( v411 )
                      {
                        sub_147251B00(pDataCore_1, v24, &v411, v8, v382);
                        if ( v411 )
                        {
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v411 + 40LL))(v411);
                        }
                      }
                      goto LABEL_36;
                    }
                    if ( n2_1 == 1 )
                    {
                      (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(*(_QWORD *)*v410 + 360LL))(*v410, &v409, v19);
                      v7 = v382;
                      pDataCore_2 = pDataCore_1;
                      if ( v409 )
                      {
                        sub_147251810(pDataCore_1, (__int64 *)v24, &v409, v8, v382);
                        if ( v409 )
                        {
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v409 + 40LL))(v409);
                        }
                      }
                      goto LABEL_36;
                    }
                    if ( n2_1 == 2 )
                    {
                      String1_2 = String1;
                      if ( String1 && *String1 )
                      {
                        Str[0] = 0;
                        n511_4 = 0;
                        n511_1 = 511;
                        p_Str = Str;
                        n511_3 = 0;
                        p_Str_1 = Str;
                        n511_2 = -1;
                        do
                        {
                          ++n511_2;
                        }
                        while ( String1[n511_2] );
                        if ( n511_2 )
                        {
                          p_Str_2 = Str;
                          if ( n511_2 + 1 > 0x200 )
                          {
                            p_Str_2 = (void *)sub_14739AFC0(n511_2 + 1, 0);
                            qword_149808368 += n511_2 + 1;
                            n511_1 = n511_2;
                          }
                          p_Str_1 = p_Str_2;
                          n511_3 = n511_2;
                          *((_BYTE *)p_Str_2 + n511_2) = 0;
                          memcpy(p_Str_1, String1_2, n511_2);
                          p_Str = (const char *)p_Str_1;
                          n511_4 = n511_3;
                        }
                        v47 = &p_Str[n511_4];
                        p_Str_3 = p_Str;
                        if ( p_Str >= &p_Str[n511_4]
                          || (p_Str
                            ? (n511_35 = strspn(p_Str, "."),
                               p_Str = (const char *)p_Str_1,
                               n511_8 = n511_35,
                               n511_4 = n511_3)
                            : (n511_8 = 0),
                              n511_7 = n511_8,
                              v52 = &p_Str_3[n511_8],
                              v52 >= v47) )
                        {
                          v535[0] = 0;
                          Size_1 = 0;
                          v55 = -1;
                          a2 = v535;
                          n511_5 = 511;
                        }
                        else
                        {
                          if ( v52 )
                          {
                            n511_34 = strcspn(&p_Str_3[n511_8], ".");
                            p_Str = (const char *)p_Str_1;
                            n511_4 = n511_3;
                          }
                          else
                          {
                            n511_34 = 0;
                          }
                          n511_6 = n511_34;
                          v55 = n511_34 + n511_8 + 1;
                          if ( n511_7 < n511_4 )
                          {
                            if ( n511_34 == -1 )
                            {
                              n511_6 = n511_4 - n511_7;
                            }
                            if ( n511_6 + n511_7 > n511_4 )
                            {
                              n511_6 = n511_4 - n511_7;
                            }
                            v60 = &p_Str[n511_7];
                            v535[0] = 0;
                            Size_1 = 0;
                            a2 = v535;
                            n511_5 = 511;
                            if ( n511_6 )
                            {
                              sub_1402A1C40(&Size_1, n511_6);
                              memcpy(a2, v60, n511_6);
                              p_Str = (const char *)p_Str_1;
                            }
                          }
                          else
                          {
                            v535[0] = 0;
                            a2 = v535;
                            Size_1 = 0;
                            n511_5 = 511;
                          }
                        }
                        v56 = (char *)&p_Str[v55];
                        sub_1403DBFB0(&v397);
                        Size = Size_1;
                        if ( Size_1 )
                        {
                          sub_1403D95E0((char **)&v397, Size_1);
                          sub_1403DD400(v397, a2, Size);
                        }
                        v58 = sub_14327BC00((__int64)(v8 + 1), (__int64 *)&v397);
                        DestroyStringObject(&v397);
                        v431 = v24;
                        CreateStringObjectFromString(&v432, v56);
                        v59 = v58[1];
                        if ( v59 == v58[2] )
                        {
                          sub_147213CC0(v58, (char *)v59, (__int64)&v431);
                        }
                        else
                        {
                          *(_QWORD *)v59 = v431;
                          sub_1403577C0((void **)(v59 + 8), (const void **)&v432);
                          v58[1] += 16;
                        }
                        ++*v8;
                        DestroyStringObject(&v432);
                        if ( a2 != v535 )
                        {
                          qword_149808368 += -1 - n511_5;
                          sub_14739AF10(a2);
                        }
                        if ( p_Str_1 != Str )
                        {
                          qword_149808368 += -1 - n511_1;
                          sub_14739AF10(p_Str_1);
                        }
                        pDataCore_2 = pDataCore_1;
                        v7 = v382;
                      }
                      else
                      {
                        pDataCore_2 = pDataCore_1;
                        v7 = v382;
                        *(_QWORD *)v24 = 0;
                      }
                      goto LABEL_36;
                    }
                    if ( n2_1 != 3 )
                    {
                      goto LABEL_34;
                    }
                    pDataCore_2 = pDataCore_1;
                    p__XMM0_1 = *(_OWORD *)sub_1402BA020((__int64 *)v512, String1);
                    p__XMM0 = p__XMM0_1;
                    v40 = (__int64 (__fastcall ***)(_QWORD))sub_1403B2070(pDataCore_1, &p__XMM0);
                    if ( v40 )
                    {
                      *((_QWORD *)&p__XMM0_1 + 1) = *((_QWORD *)&p__XMM0 + 1);
                      *(_OWORD *)v24 = p__XMM0;
                      v41 = (**v40)(v40);
                    }
                    else
                    {
                      *(_QWORD *)v24 = 0;
                      v41 = 0;
                      *(_QWORD *)(v24 + 8) = 0;
                    }
                    *(_QWORD *)(v24 + 16) = v41;
                    v10 = v398;
                    v377 = v398;
                    break;
                  default:
                    goto LABEL_34;
                }
LABEL_70:
                v7 = v382;
                goto LABEL_37;
              }
              goto LABEL_34;
            }
            (*(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v27 + 360LL))(v27, &v381, v19);
            if ( !v381 )
            {
              goto LABEL_34;
            }
            String1_3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v381 + 344LL))(v381);
            n0x6400000 = String1_3;
            v383 = 0;
            String1 = (char *)String1_3;
            (*(void (__fastcall **)(__int64, const char *, char *))(*(_QWORD *)v381 + 144LL))(
              v381,
              "__fullyInstanced",
              &v383);
            v63 = *(_QWORD *)(v24 + 24);
            arg48 = v63;
            if ( !n0x6400000 )
            {
              pDataCore_2 = pDataCore_1;
              if ( v383 && v63 )
              {
                sub_1472371D0(pDataCore_1, v24, n16, n2_1);
              }
              if ( v381 )
              {
                (*(void (__fastcall **)(__int64))(*(_QWORD *)v381 + 40LL))(v381);
              }
              v8 = a4;
              goto LABEL_35;
            }
            if ( v383 )
            {
              switch ( n16 )
              {
                case 1:
                  ptr_to_free = *(const void **)(v24 + 16);
                  if ( ptr_to_free && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v65 = sub_1402A1E30(n0x6400000);
                    v66 = v65;
                    ptr_to_free_1 = *(_BYTE **)(v24 + 16);
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v68 = (_BYTE *)v65;
                      do
                      {
                        *v68 = ptr_to_free_1[(_QWORD)v68 - v65];
                        ++v68;
                      }
                      while ( (unsigned __int64)&v68[-v65] < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_1);
                    }
                    *(_QWORD *)(v24 + 16) = v66;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  n0x6400000_1 = 0;
                  v384 = 0;
                  do
                  {
                    v70 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                      v381,
                                      &v439,
                                      (unsigned int)n0x6400000_1);
                    (*(void (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v70 + 144LL))(
                      *v70,
                      "value",
                      &v384);
                    if ( v439 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v439 + 40LL))(v439);
                    }
                    *(_BYTE *)(n0x6400000_1 + *(_QWORD *)(v24 + 16)) = v384;
                    ++n0x6400000_1;
                  }
                  while ( n0x6400000_1 < n0x6400000 );
                  break;
                case 2:
                  ptr_to_free_2 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_2 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_2);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v72 = sub_1402A1E30(n0x6400000);
                    v73 = v72;
                    ptr_to_free_3 = *(_BYTE **)(v24 + 16);
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v75 = (_BYTE *)v72;
                      do
                      {
                        *v75 = ptr_to_free_3[(_QWORD)v75 - v72];
                        ++v75;
                      }
                      while ( (unsigned __int64)&v75[-v72] < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_3);
                    }
                    *(_QWORD *)(v24 + 16) = v73;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  sub_14726CB20(v24, n0x6400000);
                  v76 = 0;
                  for ( n0x6400000_2 = 0; n0x6400000_2 < n0x6400000; ++n0x6400000_2 )
                  {
                    v78 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                      v381,
                                      &v440,
                                      (unsigned int)n0x6400000_2);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v78 + 256LL))(
                           *v78,
                           "value",
                           v399) )
                    {
                      v76 = v399[0];
                    }
                    if ( v440 )
                    {
                      (*(void (**)(void))(*(_QWORD *)v440 + 40LL))();
                    }
                    *(_BYTE *)(n0x6400000_2 + *(_QWORD *)(v24 + 16)) = v76;
                  }
                  break;
                case 3:
                  ptr_to_free_4 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_4 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_4);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v80 = sub_1402A1E30(saturated_mul(n0x6400000, 2u));
                    v81 = v80;
                    ptr_to_free_5 = *(char **)(v24 + 16);
                    v83 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v84 = (_WORD *)v80;
                      do
                      {
                        ++v83;
                        *v84 = *(_WORD *)&ptr_to_free_5[(_QWORD)v84 - v80];
                        ++v84;
                      }
                      while ( v83 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_5);
                    }
                    *(_QWORD *)(v24 + 16) = v81;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  sub_14726CBF0(v24, n0x6400000);
                  v85 = 0;
                  for ( n0x6400000_3 = 0; n0x6400000_3 < n0x6400000; ++n0x6400000_3 )
                  {
                    v87 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                      v381,
                                      &v441,
                                      (unsigned int)n0x6400000_3);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v87 + 256LL))(
                           *v87,
                           "value",
                           &v400) )
                    {
                      v85 = v400;
                    }
                    if ( v441 )
                    {
                      (*(void (**)(void))(*(_QWORD *)v441 + 40LL))();
                    }
                    *(_WORD *)(*(_QWORD *)(v24 + 16) + 2 * n0x6400000_3) = v85;
                  }
                  break;
                case 4:
                  ptr_to_free_6 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_6 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_6);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v89 = sub_1402A1E30(saturated_mul(n0x6400000, 4u));
                    v90 = v89;
                    ptr_to_free_7 = *(char **)(v24 + 16);
                    v92 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v93 = (_DWORD *)v89;
                      do
                      {
                        ++v92;
                        *v93 = *(_DWORD *)&ptr_to_free_7[(_QWORD)v93 - v89];
                        ++v93;
                      }
                      while ( v92 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_7);
                    }
                    *(_QWORD *)(v24 + 16) = v90;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  sub_14726CCD0(v24, n0x6400000);
                  v389 = 0;
                  for ( n0x6400000_4 = 0; n0x6400000_4 < n0x6400000; ++n0x6400000_4 )
                  {
                    v95 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                      v381,
                                      &v442,
                                      (unsigned int)n0x6400000_4);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v95 + 256LL))(
                      *v95,
                      "value",
                      &v389);
                    if ( v442 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v442 + 40LL))(v442);
                    }
                    *(_DWORD *)(*(_QWORD *)(v24 + 16) + 4 * n0x6400000_4) = v389;
                  }
                  break;
                case 5:
                  ptr_to_free_8 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_8 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_8);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v97 = sub_1402A1E30(saturated_mul(n0x6400000, 8u));
                    v98 = v97;
                    ptr_to_free_9 = *(char **)(v24 + 16);
                    v100 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v101 = (_QWORD *)v97;
                      do
                      {
                        ++v100;
                        *v101 = *(_QWORD *)&ptr_to_free_9[(_QWORD)v101 - v97];
                        ++v101;
                      }
                      while ( v100 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_9);
                    }
                    *(_QWORD *)(v24 + 16) = v98;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  n0x6400000_5 = 0;
                  v430 = 0;
                  do
                  {
                    v103 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v443,
                                       (unsigned int)n0x6400000_5);
                    (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v103 + 240LL))(
                      *v103,
                      "value",
                      &v430);
                    if ( v443 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v443 + 40LL))(v443);
                    }
                    *(_QWORD *)(*(_QWORD *)(v24 + 16) + 8 * n0x6400000_5++) = v430;
                  }
                  while ( n0x6400000_5 < n0x6400000 );
                  break;
                case 6:
                  ptr_to_free_10 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_10 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_10);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v105 = sub_1402A1E30(n0x6400000);
                    v106 = v105;
                    ptr_to_free_11 = *(_BYTE **)(v24 + 16);
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v108 = (_BYTE *)v105;
                      do
                      {
                        *v108 = ptr_to_free_11[(_QWORD)v108 - v105];
                        ++v108;
                      }
                      while ( (unsigned __int64)&v108[-v105] < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_11);
                    }
                    *(_QWORD *)(v24 + 16) = v106;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  v109 = 0;
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  for ( n0x6400000_6 = 0; n0x6400000_6 < n0x6400000; ++n0x6400000_6 )
                  {
                    v111 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v444,
                                       (unsigned int)n0x6400000_6);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v111 + 248LL))(
                           *v111,
                           "value",
                           v401) )
                    {
                      v109 = v401[0];
                    }
                    if ( v444 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v444 + 40LL))(v444);
                    }
                    *(_BYTE *)(n0x6400000_6 + *(_QWORD *)(v24 + 16)) = v109;
                  }
                  break;
                case 7:
                  ptr_to_free_12 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_12 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_12);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v113 = sub_1402A1E30(saturated_mul(n0x6400000, 2u));
                    v114 = v113;
                    ptr_to_free_13 = *(char **)(v24 + 16);
                    v116 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v117 = (_WORD *)v113;
                      do
                      {
                        ++v116;
                        *v117 = *(_WORD *)&ptr_to_free_13[(_QWORD)v117 - v113];
                        ++v117;
                      }
                      while ( v116 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_13);
                    }
                    *(_QWORD *)(v24 + 16) = v114;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  v118 = 0;
                  for ( n0x6400000_7 = 0; n0x6400000_7 < n0x6400000; ++n0x6400000_7 )
                  {
                    v120 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v445,
                                       (unsigned int)n0x6400000_7);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v120 + 248LL))(
                           *v120,
                           "value",
                           &v402) )
                    {
                      v118 = v402;
                    }
                    if ( v445 )
                    {
                      (*(void (**)(void))(*(_QWORD *)v445 + 40LL))();
                    }
                    *(_WORD *)(*(_QWORD *)(v24 + 16) + 2 * n0x6400000_7) = v118;
                  }
                  break;
                case 8:
                  ptr_to_free_14 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_14 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_14);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v122 = sub_1402A1E30(saturated_mul(n0x6400000, 4u));
                    v123 = v122;
                    ptr_to_free_15 = *(char **)(v24 + 16);
                    v125 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v126 = (_DWORD *)v122;
                      do
                      {
                        ++v125;
                        *v126 = *(_DWORD *)&ptr_to_free_15[(_QWORD)v126 - v122];
                        ++v126;
                      }
                      while ( v125 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_15);
                    }
                    *(_QWORD *)(v24 + 16) = v123;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  n0x6400000_8 = 0;
                  v390 = 0;
                  do
                  {
                    v128 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v446,
                                       (unsigned int)n0x6400000_8);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v128 + 248LL))(
                      *v128,
                      "value",
                      &v390);
                    if ( v446 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v446 + 40LL))(v446);
                    }
                    *(_DWORD *)(*(_QWORD *)(v24 + 16) + 4 * n0x6400000_8++) = v390;
                  }
                  while ( n0x6400000_8 < n0x6400000 );
                  break;
                case 9:
                  ptr_to_free_16 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_16 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_16);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v130 = sub_1402A1E30(saturated_mul(n0x6400000, 8u));
                    v131 = v130;
                    ptr_to_free_17 = *(char **)(v24 + 16);
                    v133 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v134 = (_QWORD *)v130;
                      do
                      {
                        ++v133;
                        *v134 = *(_QWORD *)&ptr_to_free_17[(_QWORD)v134 - v130];
                        ++v134;
                      }
                      while ( v133 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_17);
                    }
                    *(_QWORD *)(v24 + 16) = v131;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  n0x6400000_9 = 0;
                  v427 = 0;
                  do
                  {
                    v136 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v447,
                                       (unsigned int)n0x6400000_9);
                    LOBYTE(v137) = 1;
                    (*(void (__fastcall **)(_QWORD, const char *, __int64 *, __int64))(*(_QWORD *)*v136 + 232LL))(
                      *v136,
                      "value",
                      &v427,
                      v137);
                    if ( v447 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v447 + 40LL))(v447);
                    }
                    *(_QWORD *)(*(_QWORD *)(v24 + 16) + 8 * n0x6400000_9++) = v427;
                  }
                  while ( n0x6400000_9 < n0x6400000 );
                  break;
                case 10:
                  v178 = *(_QWORD *)(v24 + 16);
                  if ( v178 && *(_BYTE *)(v24 + 8) )
                  {
                    v179 = *(_QWORD *)(v178 - 8);
                    for ( i = v178 + 16 * v179; v179; --v179 )
                    {
                      i -= 16;
                      sub_14036F160(i);
                    }
                    free_memory_wrapper((const void *)(v178 - 8));
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v181 = 16 * n0x6400000;
                    if ( !is_mul_ok(n0x6400000, 0x10u) )
                    {
                      v181 = -1;
                    }
                    v182 = __CFADD__(v181, 8);
                    n0x6400000_10 = v181 + 8;
                    if ( v182 )
                    {
                      n0x6400000_10 = -1;
                    }
                    v184 = (_QWORD *)sub_1402A1E30(n0x6400000_10);
                    if ( v184 )
                    {
                      *v184 = n0x6400000;
                      n0x6400000_11 = n0x6400000;
                      v186 = v184 + 1;
                      do
                      {
                        *v186 = 0;
                        *((_BYTE *)v186 + 8) = 0;
                        v186 += 2;
                        --n0x6400000_11;
                      }
                      while ( n0x6400000_11 );
                      v187 = v184 + 1;
                    }
                    else
                    {
                      v187 = 0;
                    }
                    v188 = 0;
                    v189 = *(_QWORD *)(v24 + 16);
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v190 = (__int64)v187;
                      do
                      {
                        sub_140376300(v190, (ULONG_PTR **)(v189 - (_QWORD)v187 + v190));
                        ++v188;
                        v190 += 16;
                      }
                      while ( v188 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) && v189 )
                    {
                      v191 = *(_QWORD *)(v189 - 8);
                      for ( j = v189 + 16 * v191; v191; --v191 )
                      {
                        j -= 16;
                        sub_14036F160(j);
                      }
                      free_memory_wrapper((const void *)(v189 - 8));
                    }
                    n0x6400000 = (unsigned __int64)String1;
                    *(_QWORD *)(v24 + 32) = String1;
                    *(_QWORD *)(v24 + 16) = v187;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  sub_14726CDB0(v24, n0x6400000);
                  n0x6400000_12 = 0;
                  if ( n0x6400000 )
                  {
                    v194 = 0;
                    do
                    {
                      v195 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                         v381,
                                         &v451,
                                         (unsigned int)n0x6400000_12);
                      (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v195 + 264LL))(
                        *v195,
                        "value",
                        &v452);
                      if ( v451 )
                      {
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v451 + 40LL))(v451);
                      }
                      sub_140376330(v194 + *(_QWORD *)(v24 + 16), v452);
                      ++n0x6400000_12;
                      v194 += 16;
                    }
                    while ( n0x6400000_12 < n0x6400000 );
                  }
                  break;
                case 11:
                  ptr_to_free_18 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_18 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_18);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v139 = sub_1402A1E30(saturated_mul(n0x6400000, 4u));
                    v140 = v139;
                    ptr_to_free_19 = *(char **)(v24 + 16);
                    v142 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v143 = (_DWORD *)v139;
                      do
                      {
                        ++v142;
                        *v143 = *(_DWORD *)&ptr_to_free_19[(_QWORD)v143 - v139];
                        ++v143;
                      }
                      while ( v142 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_19);
                    }
                    *(_QWORD *)(v24 + 16) = v140;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  n0x6400000_13 = 0;
                  v391 = 0.0;
                  do
                  {
                    v145 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v448,
                                       (unsigned int)n0x6400000_13);
                    (*(void (__fastcall **)(_QWORD, const char *, float *))(*(_QWORD *)*v145 + 224LL))(
                      *v145,
                      "value",
                      &v391);
                    if ( v448 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v448 + 40LL))(v448);
                    }
                    p__XMM0_1 = LODWORD(v391);
                    *(float *)(*(_QWORD *)(v24 + 16) + 4 * n0x6400000_13++) = v391;
                  }
                  while ( n0x6400000_13 < n0x6400000 );
                  break;
                case 12:
                  ptr_to_free_20 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_20 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_20);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v147 = sub_1402A1E30(saturated_mul(n0x6400000, 8u));
                    v148 = v147;
                    ptr_to_free_21 = *(char **)(v24 + 16);
                    v150 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v151 = (_QWORD *)v147;
                      do
                      {
                        ++v150;
                        *v151 = *(_QWORD *)&ptr_to_free_21[(_QWORD)v151 - v147];
                        ++v151;
                      }
                      while ( v150 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_21);
                    }
                    *(_QWORD *)(v24 + 16) = v148;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  n0x6400000_14 = 0;
                  v421 = 0.0;
                  do
                  {
                    v153 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v449,
                                       (unsigned int)n0x6400000_14);
                    (*(void (__fastcall **)(_QWORD, const char *, double *))(*(_QWORD *)*v153 + 216LL))(
                      *v153,
                      "value",
                      &v421);
                    if ( v449 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v449 + 40LL))(v449);
                    }
                    p__XMM0_1 = *(unsigned __int64 *)&v421;
                    *(double *)(*(_QWORD *)(v24 + 16) + 8 * n0x6400000_14++) = v421;
                  }
                  while ( n0x6400000_14 < n0x6400000 );
                  break;
                case 13:
                  v196 = *(_QWORD *)(v24 + 16);
                  if ( v196 && *(_BYTE *)(v24 + 8) )
                  {
                    v197 = *(_QWORD *)(v196 - 8);
                    for ( k = (_QWORD *)(v196 + 8 * v197); v197; --v197 )
                    {
                      DestroyStringObject(--k);
                    }
                    free_memory_wrapper((const void *)(v196 - 8));
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v199 = 8 * n0x6400000;
                    if ( !is_mul_ok(n0x6400000, 8u) )
                    {
                      v199 = -1;
                    }
                    v182 = __CFADD__(v199, 8);
                    n0x6400000_15 = v199 + 8;
                    if ( v182 )
                    {
                      n0x6400000_15 = -1;
                    }
                    v201 = (_QWORD *)sub_1402A1E30(n0x6400000_15);
                    v202 = v201;
                    if ( v201 )
                    {
                      *v201 = n0x6400000;
                      n0x6400000_16 = n0x6400000;
                      v204 = v201 + 1;
                      do
                      {
                        initializeEmptyStringStructure(v204++);
                        --n0x6400000_16;
                      }
                      while ( n0x6400000_16 );
                      v205 = (void **)(v202 + 1);
                    }
                    else
                    {
                      v205 = 0;
                    }
                    v206 = 0;
                    v207 = *(_QWORD *)(v24 + 16);
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v208 = v205;
                      do
                      {
                        copyStringStructure(v208, (const void **)((char *)v208 + v207 - (_QWORD)v205));
                        ++v206;
                        ++v208;
                      }
                      while ( v206 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) && v207 )
                    {
                      v209 = *(_QWORD *)(v207 - 8);
                      for ( m = (_QWORD *)(v207 + 8 * v209); v209; --v209 )
                      {
                        DestroyStringObject(--m);
                      }
                      free_memory_wrapper((const void *)(v207 - 8));
                    }
                    n0x6400000 = (unsigned __int64)String1;
                    *(_QWORD *)(v24 + 32) = String1;
                    *(_QWORD *)(v24 + 16) = v205;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  sub_14726CF20(v24, n0x6400000);
                  for ( n0x6400000_17 = 0; n0x6400000_17 < n0x6400000; ++n0x6400000_17 )
                  {
                    v212 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v453,
                                       (unsigned int)n0x6400000_17);
                    (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v212 + 264LL))(
                      *v212,
                      "value",
                      &v454);
                    if ( v453 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v453 + 40LL))(v453);
                    }
                    if ( v454 && *v454 == 64 )
                    {
                      assignCStringToStringStructure((void **)(*(_QWORD *)(v24 + 16) + 8 * n0x6400000_17), v454);
                    }
                  }
                  break;
                case 14:
                  ptr_to_free_22 = *(const void **)(v24 + 16);
                  if ( ptr_to_free_22 && *(_BYTE *)(v24 + 8) )
                  {
                    free_memory_wrapper(ptr_to_free_22);
                    *(_QWORD *)(v24 + 24) = 0;
                    *(_QWORD *)(v24 + 32) = 0;
                    *(_QWORD *)(v24 + 16) = 0;
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                  {
                    v214 = sub_1402A1E30(saturated_mul(n0x6400000, 0x10u));
                    ptr_to_free_23 = *(char **)(v24 + 16);
                    v216 = 0;
                    if ( *(_QWORD *)(v24 + 24) )
                    {
                      v217 = (_OWORD *)v214;
                      do
                      {
                        *v217 = *(_OWORD *)&ptr_to_free_23[(_QWORD)v217 - v214];
                        ++v216;
                        ++v217;
                      }
                      while ( v216 < *(_QWORD *)(v24 + 24) );
                    }
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_23);
                    }
                    *(_QWORD *)(v24 + 16) = v214;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                  }
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  n0x6400000_18 = 0;
                  v219 = 0;
                  do
                  {
                    v220 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v455,
                                       (unsigned int)n0x6400000_18);
                    (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v220 + 264LL))(
                      *v220,
                      "value",
                      &v456);
                    if ( v455 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v455 + 40LL))(v455);
                    }
                    v221 = sub_1402BA020((__int64 *)v513, v456);
                    ++n0x6400000_18;
                    p__XMM0_1 = *(_OWORD *)v221;
                    *(_OWORD *)(*(_QWORD *)(v24 + 16) + v219) = *(_OWORD *)v221;
                    v219 += 16;
                  }
                  while ( n0x6400000_18 < n0x6400000 );
                  break;
                case 15:
                  v154 = v19;
                  v559[0] = 0;
                  pDataCore_2 = pDataCore_1;
                  String1_4 = v559;
                  v556 = 0;
                  n511_9 = 511;
                  sub_14723DDC0(pDataCore_1, (__int64)&v556, s1, v154);
                  v155 = *(_QWORD *)(v24 + 40);
                  if ( v155 == 1 )
                  {
                    ptr_to_free_24 = *(const void **)(v24 + 16);
                    if ( ptr_to_free_24 && *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_24);
                      *(_QWORD *)(v24 + 24) = 0;
                      *(_QWORD *)(v24 + 32) = 0;
                      *(_QWORD *)(v24 + 16) = 0;
                      *(_BYTE *)(v24 + 8) = 0;
                    }
                    if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                    {
                      v169 = sub_1402A1E30(n0x6400000);
                      v170 = v169;
                      ptr_to_free_25 = *(_BYTE **)(v24 + 16);
                      if ( *(_QWORD *)(v24 + 24) )
                      {
                        v172 = (_BYTE *)v169;
                        do
                        {
                          *v172 = ptr_to_free_25[(_QWORD)v172 - v169];
                          ++v172;
                        }
                        while ( (unsigned __int64)&v172[-v169] < *(_QWORD *)(v24 + 24) );
                      }
                      if ( *(_BYTE *)(v24 + 8) )
                      {
                        free_memory_wrapper(ptr_to_free_25);
                      }
                      *(_QWORD *)(v24 + 16) = v170;
                      *(_QWORD *)(v24 + 32) = n0x6400000;
                      *(_BYTE *)(v24 + 8) = 1;
                    }
                    sub_14726CB20(v24, n0x6400000);
                  }
                  else if ( *(_QWORD *)(v24 + 40) == 2 )
                  {
                    ptr_to_free_26 = *(const void **)(v24 + 16);
                    if ( ptr_to_free_26 && *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_26);
                      *(_QWORD *)(v24 + 24) = 0;
                      *(_QWORD *)(v24 + 32) = 0;
                      *(_QWORD *)(v24 + 16) = 0;
                      *(_BYTE *)(v24 + 8) = 0;
                    }
                    if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                    {
                      v163 = sub_1402A1E30(saturated_mul(n0x6400000, 2u));
                      v164 = v163;
                      ptr_to_free_27 = *(char **)(v24 + 16);
                      v166 = 0;
                      if ( *(_QWORD *)(v24 + 24) )
                      {
                        v167 = (_WORD *)v163;
                        do
                        {
                          ++v166;
                          *v167 = *(_WORD *)&ptr_to_free_27[(_QWORD)v167 - v163];
                          ++v167;
                        }
                        while ( v166 < *(_QWORD *)(v24 + 24) );
                      }
                      if ( *(_BYTE *)(v24 + 8) )
                      {
                        free_memory_wrapper(ptr_to_free_27);
                      }
                      *(_QWORD *)(v24 + 16) = v164;
                      *(_QWORD *)(v24 + 32) = n0x6400000;
                      *(_BYTE *)(v24 + 8) = 1;
                    }
                    sub_14726CBF0(v24, n0x6400000);
                  }
                  else if ( *(_QWORD *)(v24 + 40) == 4 )
                  {
                    ptr_to_free_28 = *(const void **)(v24 + 16);
                    if ( ptr_to_free_28 && *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_28);
                      *(_QWORD *)(v24 + 24) = 0;
                      *(_QWORD *)(v24 + 32) = 0;
                      *(_QWORD *)(v24 + 16) = 0;
                      *(_BYTE *)(v24 + 8) = 0;
                    }
                    if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                    {
                      v157 = sub_1402A1E30(saturated_mul(n0x6400000, 4u));
                      v158 = v157;
                      ptr_to_free_29 = *(char **)(v24 + 16);
                      v160 = 0;
                      if ( *(_QWORD *)(v24 + 24) )
                      {
                        v161 = (_DWORD *)v157;
                        do
                        {
                          ++v160;
                          *v161 = *(_DWORD *)&ptr_to_free_29[(_QWORD)v161 - v157];
                          ++v161;
                        }
                        while ( v160 < *(_QWORD *)(v24 + 24) );
                      }
                      if ( *(_BYTE *)(v24 + 8) )
                      {
                        free_memory_wrapper(ptr_to_free_29);
                      }
                      *(_QWORD *)(v24 + 16) = v158;
                      *(_QWORD *)(v24 + 32) = n0x6400000;
                      *(_BYTE *)(v24 + 8) = 1;
                    }
                    sub_14726CCD0(v24, n0x6400000);
                  }
                  initializeEmptyStringStructure(&String1_5);
                  for ( n0x6400000_19 = 0; n0x6400000_19 < n0x6400000; ++n0x6400000_19 )
                  {
                    v174 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v450,
                                       (unsigned int)n0x6400000_19);
                    (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v174 + 128LL))(
                      *v174,
                      "value",
                      &String1_5);
                    if ( v450 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v450 + 40LL))(v450);
                    }
                    v175 = sub_14723ABD0(pDataCore_1, String1_4, String1_5);
                    switch ( v155 )
                    {
                      case 1LL:
                        *(_BYTE *)(n0x6400000_19 + *(_QWORD *)(v24 + 16)) = v175;
                        break;
                      case 2LL:
                        *(_WORD *)(*(_QWORD *)(v24 + 16) + 2 * n0x6400000_19) = v175;
                        break;
                      case 4LL:
                        *(_DWORD *)(*(_QWORD *)(v24 + 16) + 4 * n0x6400000_19) = v175;
                        break;
                    }
                  }
                  DestroyStringObject(&String1_5);
                  String1_6 = String1_4;
                  if ( String1_4 == v559 )
                  {
                    goto LABEL_138;
                  }
                  v177 = -1 - n511_9;
                  goto LABEL_348;
                case 16:
                  if ( !(_BYTE)n2_1 )
                  {
                    v283 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v459,
                                       0);
                    v284 = (*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*v283 + 272LL))(*v283, "__type");
                    if ( v459 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v459 + 40LL))(v459);
                    }
                    pDataCore_2 = pDataCore_1;
                    v285 = DataCore::LookupDCStructDescByName((__int64)pDataCore_1, v284);
                    if ( v285 )
                    {
                      v286 = (_QWORD *)(v285 + 16);
                      if ( *(_BYTE *)(v24 + 8) )
                      {
                        (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v286 + 8LL))(*v286, *(_QWORD *)(v24 + 16));
                      }
                      v8 = a4;
                      *(_QWORD *)(v24 + 16) = (**(__int64 (__fastcall ***)(_QWORD, unsigned __int64))*v286)(
                                                *v286,
                                                n0x6400000);
                      n0x6400000_20 = 0;
                      *(_QWORD *)(v24 + 24) = n0x6400000;
                      *(_QWORD *)(v24 + 32) = n0x6400000;
                      *(_BYTE *)(v24 + 8) = 1;
                      do
                      {
                        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                          v381,
                          &v424,
                          (unsigned int)n0x6400000_20);
                        v288 = (__int64 *)(*(_QWORD *)(v24 + 16) + *(_QWORD *)(v24 + 40) * n0x6400000_20);
                        sub_147269A00(pDataCore_1, v288);
                        sub_147251B00(pDataCore_1, (__int64)v288, &v424, a4, v382);
                        if ( v424 )
                        {
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v424 + 40LL))(v424);
                        }
                        ++n0x6400000_20;
                      }
                      while ( n0x6400000_20 < n0x6400000 );
                      v10 = v377;
                      goto LABEL_140;
                    }
                    goto LABEL_138;
                  }
                  if ( n2_1 == 1 )
                  {
                    if ( *(_BYTE *)(v24 + 8) )
                    {
                      v271 = *(_QWORD **)(v24 + 16);
                      if ( v271 )
                      {
                        sub_147222A40(v271, 3);
                      }
                      *(_BYTE *)(v24 + 8) = 0;
                    }
                    v272 = 16 * n0x6400000;
                    if ( !is_mul_ok(n0x6400000, 0x10u) )
                    {
                      v272 = -1;
                    }
                    v182 = __CFADD__(v272, 8);
                    n0x6400000_21 = v272 + 8;
                    if ( v182 )
                    {
                      n0x6400000_21 = -1;
                    }
                    v274 = (_QWORD *)sub_1402A1E30(n0x6400000_21);
                    v275 = v274;
                    if ( v274 )
                    {
                      *v274 = n0x6400000;
                      n0x6400000_22 = n0x6400000;
                      v277 = (__int64)(v274 + 1);
                      do
                      {
                        sub_14035F240(v277);
                        v277 += 16;
                        --n0x6400000_22;
                      }
                      while ( n0x6400000_22 );
                      v278 = v275 + 1;
                    }
                    else
                    {
                      v278 = 0;
                    }
                    pDataCore_2 = pDataCore_1;
                    n0x6400000_23 = 0;
                    *(_QWORD *)(v24 + 16) = v278;
                    *(_QWORD *)(v24 + 24) = n0x6400000;
                    *(_QWORD *)(v24 + 32) = n0x6400000;
                    *(_BYTE *)(v24 + 8) = 1;
                    v280 = v382;
                    do
                    {
                      (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                        v381,
                        &v413,
                        (unsigned int)n0x6400000_23);
                      s1_2 = (const char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v413 + 272LL))(
                                             v413,
                                             "__type");
                      v282 = sub_14725D8A0(
                               pDataCore_1,
                               (_QWORD *)(*(_QWORD *)(v24 + 16) + *(_QWORD *)(v24 + 40) * n0x6400000_23),
                               s1_2,
                               1);
                      if ( v282 )
                      {
                        sub_147251B00(pDataCore_1, v282, &v413, a4, v280);
                      }
                      if ( v413 )
                      {
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v413 + 40LL))(v413);
                      }
                      ++n0x6400000_23;
                    }
                    while ( n0x6400000_23 < n0x6400000 );
                    v10 = v377;
                    v8 = a4;
                    goto LABEL_140;
                  }
                  if ( n2_1 != 2 )
                  {
                    if ( n2_1 != 3 )
                    {
                      goto LABEL_774;
                    }
                    ptr_to_free_30 = *(const void **)(v24 + 16);
                    if ( ptr_to_free_30 && *(_BYTE *)(v24 + 8) )
                    {
                      free_memory_wrapper(ptr_to_free_30);
                      *(_QWORD *)(v24 + 24) = 0;
                      *(_QWORD *)(v24 + 32) = 0;
                      *(_QWORD *)(v24 + 16) = 0;
                      *(_BYTE *)(v24 + 8) = 0;
                    }
                    if ( n0x6400000 > *(_QWORD *)(v24 + 32) )
                    {
                      v223 = sub_1402A1E30(saturated_mul(n0x6400000, 0x18u));
                      v224 = v223;
                      if ( v223 )
                      {
                        n0x6400000_24 = n0x6400000;
                        v226 = (_QWORD *)v223;
                        do
                        {
                          initialize_vector_empty(v226);
                          v226 += 3;
                          --n0x6400000_24;
                        }
                        while ( n0x6400000_24 );
                      }
                      else
                      {
                        v224 = 0;
                      }
                      v227 = 0;
                      ptr_to_free_31 = *(char **)(v24 + 16);
                      if ( *(_QWORD *)(v24 + 24) )
                      {
                        v229 = v224;
                        v230 = &ptr_to_free_31[-v224];
                        do
                        {
                          *(_OWORD *)v229 = *(_OWORD *)&v230[v229];
                          *(double *)(v229 + 16) = *(double *)&v230[v229 + 16];
                          ++v227;
                          v229 += 24;
                        }
                        while ( v227 < *(_QWORD *)(v24 + 24) );
                      }
                      if ( *(_BYTE *)(v24 + 8) )
                      {
                        free_memory_wrapper(ptr_to_free_31);
                      }
                      *(_QWORD *)(v24 + 16) = v224;
                      *(_QWORD *)(v24 + 32) = n0x6400000;
                      *(_BYTE *)(v24 + 8) = 1;
                    }
                    *(_QWORD *)(v24 + 24) = n0x6400000;
                    n0x6400000_25 = 0;
                    v232 = 0;
                    do
                    {
                      v233 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                         v381,
                                         &v457,
                                         (unsigned int)n0x6400000_25);
                      (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v233 + 264LL))(
                        *v233,
                        "value",
                        &v458);
                      if ( v457 )
                      {
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v457 + 40LL))(v457);
                      }
                      v234 = sub_1402BA020((__int64 *)v514, v458);
                      v235 = *(_QWORD *)(v24 + 16);
                      p__XMM0_1 = *(_OWORD *)v234;
                      _XMM0 = *(_OWORD *)v234;
                      v236 = (__int64 (__fastcall ***)(_QWORD))sub_1403B2070(pDataCore_1, &_XMM0);
                      if ( v236 )
                      {
                        *((_QWORD *)&p__XMM0_1 + 1) = *((_QWORD *)&_XMM0 + 1);
                        *(_OWORD *)(v232 + v235) = _XMM0;
                        v236 = (__int64 (__fastcall ***)(_QWORD))(**v236)(v236);
                      }
                      else
                      {
                        *(_QWORD *)(v232 + v235) = 0;
                        *(_QWORD *)(v232 + v235 + 8) = 0;
                      }
                      *(_QWORD *)(v232 + v235 + 16) = v236;
                      ++n0x6400000_25;
                      v232 += 24;
                    }
                    while ( n0x6400000_25 < n0x6400000 );
                    v10 = v398;
                    pDataCore_2 = pDataCore_1;
                    v377 = v398;
                    goto LABEL_139;
                  }
                  v523[0] = 0;
                  n511_13 = 0;
                  v522 = v523;
                  v530 = v531;
                  n511_10 = 511;
                  v531[0] = 0;
                  n511_21 = 0;
                  n511_11 = 511;
                  if ( *(_BYTE *)(v24 + 8) )
                  {
                    v237 = *(_QWORD **)(v24 + 16);
                    if ( v237 )
                    {
                      sub_147222A40(v237, 3);
                    }
                    *(_BYTE *)(v24 + 8) = 0;
                  }
                  n511_12 = -1;
                  v239 = 16 * n0x6400000;
                  if ( !is_mul_ok(n0x6400000, 0x10u) )
                  {
                    v239 = -1;
                  }
                  v182 = __CFADD__(v239, 8);
                  n0x6400000_26 = v239 + 8;
                  if ( v182 )
                  {
                    n0x6400000_26 = -1;
                  }
                  v241 = (_QWORD *)sub_1402A1E30(n0x6400000_26);
                  v242 = v241;
                  if ( v241 )
                  {
                    *v241 = n0x6400000;
                    n0x6400000_27 = n0x6400000;
                    v244 = (__int64)(v241 + 1);
                    do
                    {
                      sub_14035F240(v244);
                      v244 += 16;
                      --n0x6400000_27;
                    }
                    while ( n0x6400000_27 );
                    v245 = v242 + 1;
                    n511_12 = -1;
                  }
                  else
                  {
                    v245 = 0;
                  }
                  *(_QWORD *)(v24 + 16) = v245;
                  String1_7 = 0;
                  *(_QWORD *)(v24 + 24) = n0x6400000;
                  *(_QWORD *)(v24 + 32) = n0x6400000;
                  *(_BYTE *)(v24 + 8) = 1;
                  do
                  {
                    ++*a4;
                    (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                      v381,
                      &v423,
                      (unsigned int)String1_7);
                    v247 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v423 + 272LL))(v423, "value");
                    v248 = (const void *)v247;
                    if ( v247 )
                    {
                      do
                      {
                        ++n511_12;
                      }
                      while ( *(_BYTE *)(v247 + n511_12) );
                      if ( n511_12 > n511_10 )
                      {
                        if ( v522 != v523 )
                        {
                          qword_149808368 += -1LL - n511_10;
                          sub_14739AF10(v522);
                        }
                        v523[0] = 0;
                        v522 = v523;
                        n511_13 = 0;
                        n511_10 = 511;
                        if ( n511_12 )
                        {
                          v249 = v523;
                          if ( n511_12 + 1 > 0x200 )
                          {
                            v249 = (char *)sub_14739AFC0(n511_12 + 1, 0);
                            qword_149808368 += n511_12 + 1;
                            n511_10 = n511_12;
                          }
                          n511_13 = n511_12;
                          v522 = v249;
                          v249[n511_12] = 0;
                        }
                      }
                    }
                    else
                    {
                      n511_12 = 0;
                    }
                    memmove(v522, v248, n511_12);
                    n511_13 = n511_12;
                    v522[n511_12] = 0;
                    v250 = v522;
                    n511_14 = n511_13;
                    v252 = v522;
                    v253 = &v522[n511_13];
                    if ( v522 >= &v522[n511_13]
                      || (v522
                        ? (n511_20 = strspn(v522, "."), v250 = v522, n511_19 = n511_20, n511_14 = n511_13)
                        : (n511_19 = 0),
                          v256 = &v252[n511_19],
                          v256 >= v253) )
                    {
                      Src[0] = 0;
                      n511_17 = 0;
                      p_Src = Src;
                      n511_15 = 511;
                      v259 = -1;
                      p_Src_1 = Src;
                      n511_18 = 0;
                    }
                    else
                    {
                      if ( v256 )
                      {
                        n511_36 = strcspn(&v252[n511_19], ".");
                        v250 = v522;
                        n511_14 = n511_13;
                      }
                      else
                      {
                        n511_36 = 0;
                      }
                      n511_16 = n511_36;
                      v259 = n511_19 + n511_36 + 1;
                      if ( n511_19 < n511_14 )
                      {
                        if ( n511_36 == -1 )
                        {
                          n511_16 = n511_14 - n511_19;
                        }
                        if ( n511_16 + n511_19 > n511_14 )
                        {
                          n511_16 = n511_14 - n511_19;
                        }
                        v262 = &v250[n511_19];
                        Src[0] = 0;
                        n511_18 = 0;
                        n511_15 = 511;
                        n511_17 = 0;
                        p_Src = Src;
                        p_Src_1 = Src;
                        if ( n511_16 )
                        {
                          p_Src_2 = Src;
                          if ( n511_16 + 1 > 0x200 )
                          {
                            p_Src_2 = (_BYTE *)sub_14739AFC0(n511_16 + 1, 0);
                            qword_149808368 += n511_16 + 1;
                            n511_15 = n511_16;
                          }
                          p_Src_1 = p_Src_2;
                          n511_17 = n511_16;
                          p_Src_2[n511_16] = 0;
                          memcpy(p_Src_1, v262, n511_16);
                          p_Src = p_Src_1;
                          n511_18 = n511_17;
                        }
                      }
                      else
                      {
                        Src[0] = 0;
                        p_Src = Src;
                        n511_17 = 0;
                        p_Src_1 = Src;
                        n511_18 = 0;
                        n511_15 = 511;
                      }
                    }
                    if ( n511_18 > n511_11 )
                    {
                      if ( v530 != v531 )
                      {
                        qword_149808368 += -1LL - n511_11;
                        sub_14739AF10(v530);
                      }
                      v531[0] = 0;
                      v530 = v531;
                      n511_21 = 0;
                      n511_11 = 511;
                      if ( n511_18 )
                      {
                        v264 = v531;
                        if ( n511_18 + 1 > 0x200 )
                        {
                          v264 = (_BYTE *)sub_14739AFC0(n511_18 + 1, 0);
                          qword_149808368 += n511_18 + 1;
                          n511_11 = n511_18;
                        }
                        n511_21 = n511_18;
                        v530 = v264;
                        v264[n511_18] = 0;
                      }
                    }
                    memmove(v530, p_Src, n511_18);
                    n511_21 = n511_18;
                    *((_BYTE *)v530 + n511_18) = 0;
                    if ( p_Src_1 != Src )
                    {
                      qword_149808368 += -1 - n511_15;
                      sub_14739AF10(p_Src_1);
                    }
                    v265 = &v522[v259];
                    v266 = *(_QWORD *)(v24 + 16) + *(_QWORD *)(v24 + 40) * String1_7;
                    CreateStringObjectFromString(&v422, v530);
                    v267 = sub_14327BC00((__int64)(a4 + 1), (__int64 *)&v422);
                    DestroyStringObject(&v422);
                    v433 = v266;
                    CreateStringObjectFromString(&v434, v265);
                    v268 = v267[1];
                    if ( v268 == v267[2] )
                    {
                      sub_147213CC0(v267, (char *)v268, (__int64)&v433);
                    }
                    else
                    {
                      *(_QWORD *)v268 = v433;
                      sub_1403577C0((void **)(v268 + 8), (const void **)&v434);
                      v267[1] += 16;
                    }
                    DestroyStringObject(&v434);
                    if ( v423 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v423 + 40LL))(v423);
                    }
                    n511_12 = -1;
                    ++String1_7;
                  }
                  while ( String1_7 < (unsigned __int64)String1 );
                  if ( v530 != v531 )
                  {
                    qword_149808368 += -1LL - n511_11;
                    sub_14739AF10(v530);
                  }
                  v269 = v522;
                  if ( v522 != v523 )
                  {
                    v270 = -1LL - n511_10;
                    goto LABEL_515;
                  }
                  break;
                default:
                  goto LABEL_774;
              }
LABEL_137:
              pDataCore_2 = pDataCore_1;
LABEL_138:
              v10 = v377;
            }
            else
            {
              n0x6400000_41 = 0;
              v380 = 0;
              switch ( n16 )
              {
                case 1:
                  v385 = 0;
                  for ( n0x6400000_28 = 0; n0x6400000_28 < n0x6400000; ++n0x6400000_28 )
                  {
                    v291 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v460,
                                       (unsigned int)n0x6400000_28);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v291 + 256LL))(
                      *v291,
                      "__index",
                      &v380);
                    if ( v460 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v460 + 40LL))(v460);
                    }
                    v292 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v461,
                                       (unsigned int)n0x6400000_28);
                    (*(void (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v292 + 144LL))(
                      *v292,
                      "value",
                      &v385);
                    if ( v461 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v461 + 40LL))(v461);
                    }
                    if ( v380 < v63 )
                    {
                      *(_BYTE *)(v380 + *(_QWORD *)(v24 + 16)) = v385;
                    }
                  }
                  goto LABEL_137;
                case 2:
                  for ( n0x6400000_29 = 0; n0x6400000_29 < n0x6400000; ++n0x6400000_29 )
                  {
                    v294 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v462,
                                       (unsigned int)n0x6400000_29);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v294 + 256LL))(
                      *v294,
                      "__index",
                      &v380);
                    if ( v462 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v462 + 40LL))(v462);
                    }
                    v295 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v463,
                                       (unsigned int)n0x6400000_29);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v295 + 256LL))(
                           *v295,
                           "value",
                           v403) )
                    {
                      LOBYTE(n0x6400000_41) = v403[0];
                    }
                    if ( v463 )
                    {
                      (*(void (**)(void))(*(_QWORD *)v463 + 40LL))();
                    }
                    if ( v380 < v63 )
                    {
                      *(_BYTE *)(v380 + *(_QWORD *)(v24 + 16)) = n0x6400000_41;
                    }
                  }
                  goto LABEL_137;
                case 3:
                  for ( n0x6400000_30 = 0; n0x6400000_30 < n0x6400000; ++n0x6400000_30 )
                  {
                    v297 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v464,
                                       (unsigned int)n0x6400000_30);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v297 + 256LL))(
                      *v297,
                      "__index",
                      &v380);
                    if ( v464 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v464 + 40LL))(v464);
                    }
                    v298 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v465,
                                       (unsigned int)n0x6400000_30);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v298 + 256LL))(
                           *v298,
                           "value",
                           &v404) )
                    {
                      LOWORD(n0x6400000_41) = v404;
                    }
                    if ( v465 )
                    {
                      (*(void (**)(void))(*(_QWORD *)v465 + 40LL))();
                    }
                    if ( v380 < v63 )
                    {
                      *(_WORD *)(*(_QWORD *)(v24 + 16) + 2LL * v380) = n0x6400000_41;
                    }
                  }
                  goto LABEL_137;
                case 4:
                  v392 = 0;
                  for ( n0x6400000_31 = 0; n0x6400000_31 < n0x6400000; ++n0x6400000_31 )
                  {
                    v300 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v466,
                                       (unsigned int)n0x6400000_31);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v300 + 256LL))(
                      *v300,
                      "__index",
                      &v380);
                    if ( v466 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v466 + 40LL))(v466);
                    }
                    v301 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v467,
                                       (unsigned int)n0x6400000_31);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v301 + 256LL))(
                      *v301,
                      "value",
                      &v392);
                    if ( v467 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v467 + 40LL))(v467);
                    }
                    if ( v380 < v63 )
                    {
                      *(_DWORD *)(*(_QWORD *)(v24 + 16) + 4LL * v380) = v392;
                    }
                  }
                  goto LABEL_137;
                case 5:
                  v425 = 0;
                  for ( n0x6400000_32 = 0; n0x6400000_32 < n0x6400000; ++n0x6400000_32 )
                  {
                    v303 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v468,
                                       (unsigned int)n0x6400000_32);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v303 + 256LL))(
                      *v303,
                      "__index",
                      &v380);
                    if ( v468 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v468 + 40LL))(v468);
                    }
                    v304 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v469,
                                       (unsigned int)n0x6400000_32);
                    (*(void (__fastcall **)(_QWORD, const char *, __int64 *))(*(_QWORD *)*v304 + 240LL))(
                      *v304,
                      "value",
                      &v425);
                    if ( v469 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v469 + 40LL))(v469);
                    }
                    if ( v380 < v63 )
                    {
                      *(_QWORD *)(*(_QWORD *)(v24 + 16) + 8LL * v380) = v425;
                    }
                  }
                  goto LABEL_137;
                case 6:
                  for ( n0x6400000_33 = 0; n0x6400000_33 < n0x6400000; ++n0x6400000_33 )
                  {
                    v306 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v470,
                                       (unsigned int)n0x6400000_33);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v306 + 256LL))(
                      *v306,
                      "__index",
                      &v380);
                    if ( v470 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v470 + 40LL))(v470);
                    }
                    v307 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v471,
                                       (unsigned int)n0x6400000_33);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, char *))(*(_QWORD *)*v307 + 248LL))(
                           *v307,
                           "value",
                           v405) )
                    {
                      LOBYTE(n0x6400000_41) = v405[0];
                    }
                    if ( v471 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v471 + 40LL))(v471);
                    }
                    if ( v380 < v63 )
                    {
                      *(_BYTE *)(v380 + *(_QWORD *)(v24 + 16)) = n0x6400000_41;
                    }
                  }
                  goto LABEL_137;
                case 7:
                  for ( n0x6400000_34 = 0; n0x6400000_34 < n0x6400000; ++n0x6400000_34 )
                  {
                    v309 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v472,
                                       (unsigned int)n0x6400000_34);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v309 + 256LL))(
                      *v309,
                      "__index",
                      &v380);
                    if ( v472 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v472 + 40LL))(v472);
                    }
                    v310 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v473,
                                       (unsigned int)n0x6400000_34);
                    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int16 *))(*(_QWORD *)*v310 + 248LL))(
                           *v310,
                           "value",
                           &v406) )
                    {
                      LOWORD(n0x6400000_41) = v406;
                    }
                    if ( v473 )
                    {
                      (*(void (**)(void))(*(_QWORD *)v473 + 40LL))();
                    }
                    if ( v380 < v63 )
                    {
                      *(_WORD *)(*(_QWORD *)(v24 + 16) + 2LL * v380) = n0x6400000_41;
                    }
                  }
                  goto LABEL_137;
                case 8:
                  v393 = 0;
                  for ( n0x6400000_35 = 0; n0x6400000_35 < n0x6400000; ++n0x6400000_35 )
                  {
                    v312 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v474,
                                       (unsigned int)n0x6400000_35);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v312 + 256LL))(
                      *v312,
                      "__index",
                      &v380);
                    if ( v474 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v474 + 40LL))(v474);
                    }
                    v313 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v475,
                                       (unsigned int)n0x6400000_35);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v313 + 248LL))(
                      *v313,
                      "value",
                      &v393);
                    if ( v475 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v475 + 40LL))(v475);
                    }
                    if ( v380 < v63 )
                    {
                      *(_DWORD *)(*(_QWORD *)(v24 + 16) + 4LL * v380) = v393;
                    }
                  }
                  goto LABEL_137;
                case 9:
                  v426 = 0;
                  for ( n0x6400000_36 = 0; n0x6400000_36 < n0x6400000; ++n0x6400000_36 )
                  {
                    v315 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v476,
                                       (unsigned int)n0x6400000_36);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v315 + 256LL))(
                      *v315,
                      "__index",
                      &v380);
                    if ( v476 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v476 + 40LL))(v476);
                    }
                    v316 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v477,
                                       (unsigned int)n0x6400000_36);
                    LOBYTE(v317) = 1;
                    (*(void (__fastcall **)(_QWORD, const char *, __int64 *, __int64))(*(_QWORD *)*v316 + 232LL))(
                      *v316,
                      "value",
                      &v426,
                      v317);
                    if ( v477 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v477 + 40LL))(v477);
                    }
                    if ( v380 < v63 )
                    {
                      *(_QWORD *)(*(_QWORD *)(v24 + 16) + 8LL * v380) = v426;
                    }
                  }
                  goto LABEL_137;
                case 10:
                  for ( n0x6400000_37 = 0; n0x6400000_37 < n0x6400000; ++n0x6400000_37 )
                  {
                    v331 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v484,
                                       (unsigned int)n0x6400000_37);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v331 + 256LL))(
                      *v331,
                      "__index",
                      &v380);
                    if ( v484 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v484 + 40LL))(v484);
                    }
                    v332 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v485,
                                       (unsigned int)n0x6400000_37);
                    (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v332 + 264LL))(
                      *v332,
                      "value",
                      &v486);
                    if ( v485 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v485 + 40LL))(v485);
                    }
                    if ( v380 < v63 )
                    {
                      sub_140376330(*(_QWORD *)(v24 + 16) + 16LL * v380, v486);
                    }
                  }
                  goto LABEL_137;
                case 11:
                  n0x6400000_38 = 0;
                  v394 = 0.0;
                  do
                  {
                    v319 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v478,
                                       (unsigned int)n0x6400000_38);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v319 + 256LL))(
                      *v319,
                      "__index",
                      &v380);
                    if ( v478 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v478 + 40LL))(v478);
                    }
                    v320 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v479,
                                       (unsigned int)n0x6400000_38);
                    (*(void (__fastcall **)(_QWORD, const char *, float *))(*(_QWORD *)*v320 + 224LL))(
                      *v320,
                      "value",
                      &v394);
                    if ( v479 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v479 + 40LL))(v479);
                    }
                    if ( v380 < v63 )
                    {
                      p__XMM0_1 = LODWORD(v394);
                      *(float *)(*(_QWORD *)(v24 + 16) + 4LL * v380) = v394;
                    }
                    ++n0x6400000_38;
                  }
                  while ( n0x6400000_38 < n0x6400000 );
                  goto LABEL_137;
                case 12:
                  n0x6400000_39 = 0;
                  v437 = 0.0;
                  do
                  {
                    v322 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v480,
                                       (unsigned int)n0x6400000_39);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v322 + 256LL))(
                      *v322,
                      "__index",
                      &v380);
                    if ( v480 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v480 + 40LL))(v480);
                    }
                    v323 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v481,
                                       (unsigned int)n0x6400000_39);
                    (*(void (__fastcall **)(_QWORD, const char *, double *))(*(_QWORD *)*v323 + 216LL))(
                      *v323,
                      "value",
                      &v437);
                    if ( v481 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v481 + 40LL))(v481);
                    }
                    if ( v380 < v63 )
                    {
                      p__XMM0_1 = *(unsigned __int64 *)&v437;
                      *(double *)(*(_QWORD *)(v24 + 16) + 8LL * v380) = v437;
                    }
                    ++n0x6400000_39;
                  }
                  while ( n0x6400000_39 < n0x6400000 );
                  goto LABEL_137;
                case 13:
                  for ( n0x6400000_40 = 0; n0x6400000_40 < n0x6400000; ++n0x6400000_40 )
                  {
                    v334 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v487,
                                       (unsigned int)n0x6400000_40);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v334 + 256LL))(
                      *v334,
                      "__index",
                      &v380);
                    if ( v487 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v487 + 40LL))(v487);
                    }
                    v335 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v488,
                                       (unsigned int)n0x6400000_40);
                    (*(void (__fastcall **)(_QWORD, const char *, _BYTE **))(*(_QWORD *)*v335 + 264LL))(
                      *v335,
                      "value",
                      &v489);
                    if ( v488 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v488 + 40LL))(v488);
                    }
                    if ( v380 < v63 && v489 && *v489 == 64 )
                    {
                      assignCStringToStringStructure((void **)(*(_QWORD *)(v24 + 16) + 8LL * v380), v489);
                    }
                  }
                  goto LABEL_137;
                case 14:
                  do
                  {
                    v336 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v490,
                                       (unsigned int)n0x6400000_41);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v336 + 256LL))(
                      *v336,
                      "__index",
                      &v380);
                    if ( v490 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v490 + 40LL))(v490);
                    }
                    v337 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v491,
                                       (unsigned int)n0x6400000_41);
                    (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v337 + 264LL))(
                      *v337,
                      "value",
                      &v492);
                    if ( v491 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v491 + 40LL))(v491);
                    }
                    v338 = v380;
                    if ( v380 < v63 )
                    {
                      v339 = sub_1402BA020((__int64 *)v515, v492);
                      p__XMM0_1 = *(_OWORD *)v339;
                      *(_OWORD *)(*(_QWORD *)(v24 + 16) + 16 * v338) = *(_OWORD *)v339;
                    }
                    ++n0x6400000_41;
                  }
                  while ( n0x6400000_41 < n0x6400000 );
                  goto LABEL_137;
                case 15:
                  v324 = v19;
                  v563[0] = 0;
                  pDataCore_2 = pDataCore_1;
                  String1_8 = v563;
                  v560 = 0;
                  n511_22 = 511;
                  sub_14723DDC0(pDataCore_1, (__int64)&v560, s1, v324);
                  initializeEmptyStringStructure(&String1_9);
                  v325 = *(_QWORD *)(v24 + 40);
                  for ( n0x6400000_42 = 0; n0x6400000_42 < n0x6400000; ++n0x6400000_42 )
                  {
                    v327 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v482,
                                       (unsigned int)n0x6400000_42);
                    (*(void (__fastcall **)(_QWORD, const char *, int *))(*(_QWORD *)*v327 + 256LL))(
                      *v327,
                      "__index",
                      &v380);
                    if ( v482 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v482 + 40LL))(v482);
                    }
                    v328 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v483,
                                       (unsigned int)n0x6400000_42);
                    (*(void (__fastcall **)(_QWORD, const char *, char **))(*(_QWORD *)*v328 + 128LL))(
                      *v328,
                      "value",
                      &String1_9);
                    if ( v483 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v483 + 40LL))(v483);
                    }
                    if ( v380 < v63 )
                    {
                      v329 = sub_14723ABD0(pDataCore_1, String1_8, String1_9);
                      switch ( v325 )
                      {
                        case 1LL:
                          *(_BYTE *)(v380 + *(_QWORD *)(v24 + 16)) = v329;
                          break;
                        case 2LL:
                          *(_WORD *)(*(_QWORD *)(v24 + 16) + 2LL * v380) = v329;
                          break;
                        case 4LL:
                          *(_DWORD *)(*(_QWORD *)(v24 + 16) + 4LL * v380) = v329;
                          break;
                      }
                    }
                  }
                  DestroyStringObject(&String1_9);
                  String1_6 = String1_8;
                  if ( String1_8 != v563 )
                  {
                    v177 = -1 - n511_22;
LABEL_348:
                    qword_149808368 += v177;
                    sub_14739AF10(String1_6);
                  }
                  goto LABEL_138;
                case 16:
                  if ( !(_BYTE)n2_1 )
                  {
                    v371 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                                       v381,
                                       &v494,
                                       0);
                    v372 = (*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*v371 + 272LL))(*v371, "__type");
                    if ( v494 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v494 + 40LL))(v494);
                    }
                    pDataCore_2 = pDataCore_1;
                    if ( DataCore::LookupDCStructDescByName((__int64)pDataCore_1, v372) )
                    {
                      for ( n0x6400000_43 = 0; n0x6400000_43 < n0x6400000; ++n0x6400000_43 )
                      {
                        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                          v381,
                          &v417,
                          (unsigned int)n0x6400000_43);
                        if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, int *))(*(_QWORD *)v417 + 256LL))(
                               v417,
                               "__index",
                               &v380)
                          && v380 < v63 )
                        {
                          sub_147251B00(
                            pDataCore_1,
                            *(_QWORD *)(v24 + 16) + *(_QWORD *)(v24 + 40) * v380,
                            &v417,
                            a4,
                            v382);
                        }
                        if ( v417 )
                        {
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v417 + 40LL))(v417);
                        }
                      }
                      v10 = v377;
                      v8 = a4;
                    }
                    else
                    {
                      v8 = a4;
                      v10 = v377;
                    }
                    goto LABEL_140;
                  }
                  if ( n2_1 == 1 )
                  {
                    v386[0] = 0;
                    n0x6400000_44 = 0;
                    v368 = v382;
                    do
                    {
                      (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                        v381,
                        &v396,
                        (unsigned int)n0x6400000_44);
                      if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, int *))(*(_QWORD *)v396 + 256LL))(
                             v396,
                             "__index",
                             &v380)
                        && v380 < v63 )
                      {
                        (*(void (__fastcall **)(__int64, const char *, char *))(*(_QWORD *)v396 + 144LL))(
                          v396,
                          "__fullyInstanced",
                          v386);
                        s1_3 = (const char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v396 + 272LL))(
                                               v396,
                                               "__type");
                        pDataCore_2 = pDataCore_1;
                        v370 = sub_14725D8A0(
                                 pDataCore_1,
                                 (_QWORD *)(*(_QWORD *)(v24 + 16) + *(_QWORD *)(v24 + 40) * v380),
                                 s1_3,
                                 v386[0]);
                        if ( v370 )
                        {
                          sub_147251B00(pDataCore_1, v370, &v396, a4, v368);
                        }
                      }
                      else
                      {
                        pDataCore_2 = pDataCore_1;
                      }
                      if ( v396 )
                      {
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v396 + 40LL))(v396);
                      }
                      ++n0x6400000_44;
                    }
                    while ( n0x6400000_44 < n0x6400000 );
                    v10 = v377;
                    v8 = a4;
                    goto LABEL_140;
                  }
                  if ( n2_1 == 2 )
                  {
                    v543[0] = 0;
                    n511_26 = 0;
                    v542 = v543;
                    n511_23 = 511;
                    v551[0] = 0;
                    n0x6400000_45 = 0;
                    v550 = v551;
                    n511_33 = 0;
                    n511_24 = 511;
                    do
                    {
                      (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                        v381,
                        &v416,
                        (unsigned int)n0x6400000_45);
                      if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, int *))(*(_QWORD *)v416 + 256LL))(
                             v416,
                             "__index",
                             &v380)
                        && v380 < (unsigned __int64)arg48 )
                      {
                        v346 = v416;
                        ++*a4;
                        v347 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v346 + 272LL))(
                                 v346,
                                 "value");
                        v348 = (const void *)v347;
                        if ( v347 )
                        {
                          n511_25 = -1;
                          do
                          {
                            ++n511_25;
                          }
                          while ( *(_BYTE *)(v347 + n511_25) );
                          if ( n511_25 > n511_23 )
                          {
                            sub_1402A1D80(&n511_26);
                            sub_1402A1C40(&n511_26, n511_25);
                          }
                        }
                        else
                        {
                          n511_25 = 0;
                        }
                        memmove(v542, v348, n511_25);
                        n511_26 = n511_25;
                        v542[n511_25] = 0;
                        v350 = v542;
                        n511_27 = n511_26;
                        v352 = v542;
                        v353 = &v542[n511_26];
                        if ( v542 >= &v542[n511_26]
                          || (v542
                            ? (n511_31 = strspn(v542, "."), v350 = v542, n511_30 = n511_31, n511_27 = n511_26)
                            : (n511_30 = 0),
                              v356 = &v352[n511_30],
                              v356 >= v353) )
                        {
                          v539[0] = 0;
                          n511_38 = 0;
                          v361 = v539;
                          n511_28 = 511;
                          v359 = -1;
                          v538 = v539;
                          n511_32 = 0;
                        }
                        else
                        {
                          if ( v356 )
                          {
                            n511_37 = strcspn(&v352[n511_30], ".");
                            v350 = v542;
                            n511_27 = n511_26;
                          }
                          else
                          {
                            n511_37 = 0;
                          }
                          n511_29 = n511_37;
                          v359 = n511_30 + n511_37 + 1;
                          if ( n511_30 < n511_27 )
                          {
                            if ( n511_37 == -1 )
                            {
                              n511_29 = n511_27 - n511_30;
                            }
                            if ( n511_30 + n511_29 > n511_27 )
                            {
                              n511_29 = n511_27 - n511_30;
                            }
                            v362 = &v350[n511_30];
                            v539[0] = 0;
                            n511_32 = 0;
                            n511_28 = 511;
                            n511_38 = 0;
                            v361 = v539;
                            v538 = v539;
                            if ( n511_29 )
                            {
                              sub_1402A1C40(&n511_38, n511_29);
                              memcpy(v538, v362, n511_29);
                              v361 = v538;
                              n511_32 = n511_38;
                            }
                          }
                          else
                          {
                            n511_32 = 0;
                            v539[0] = 0;
                            v361 = v539;
                            n511_38 = 0;
                            v538 = v539;
                            n511_28 = 511;
                          }
                        }
                        if ( n511_32 > n511_24 )
                        {
                          sub_1402A1D80(&n511_33);
                          sub_1402A1C40(&n511_33, n511_32);
                        }
                        memmove(v550, v361, n511_32);
                        n511_33 = n511_32;
                        *((_BYTE *)v550 + n511_32) = 0;
                        if ( v538 != v539 )
                        {
                          qword_149808368 += -1 - n511_28;
                          sub_14739AF10(v538);
                        }
                        v363 = *(_QWORD *)(v24 + 16) + *(_QWORD *)(v24 + 40) * v380;
                        v364 = &v542[v359];
                        CreateStringObjectFromString(&v428, v550);
                        v365 = sub_14327BC00((__int64)(a4 + 1), (__int64 *)&v428);
                        DestroyStringObject(&v428);
                        v435 = v363;
                        CreateStringObjectFromString(&v436, v364);
                        v366 = v365[1];
                        if ( v366 == v365[2] )
                        {
                          sub_147213CC0(v365, (char *)v366, (__int64)&v435);
                        }
                        else
                        {
                          *(_QWORD *)v366 = v435;
                          sub_1403577C0((void **)(v366 + 8), (const void **)&v436);
                          v365[1] += 16;
                        }
                        DestroyStringObject(&v436);
                        n0x6400000 = (unsigned __int64)String1;
                      }
                      if ( v416 )
                      {
                        (*(void (__fastcall **)(__int64))(*(_QWORD *)v416 + 40LL))(v416);
                      }
                      ++n0x6400000_45;
                    }
                    while ( n0x6400000_45 < n0x6400000 );
                    v269 = v542;
                    if ( v550 != v551 )
                    {
                      qword_149808368 += -1LL - n511_24;
                      sub_14739AF10(v550);
                      v269 = v542;
                    }
                    if ( v269 != v543 )
                    {
                      v270 = -1LL - n511_23;
LABEL_515:
                      qword_149808368 += v270;
                      sub_14739AF10(v269);
                    }
                    goto LABEL_137;
                  }
                  if ( n2_1 != 3 )
                  {
                    goto LABEL_137;
                  }
                  for ( n0x6400000_46 = 0; n0x6400000_46 < n0x6400000; ++n0x6400000_46 )
                  {
                    (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v381 + 352LL))(
                      v381,
                      &v415,
                      (unsigned int)n0x6400000_46);
                    if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, int *))(*(_QWORD *)v415 + 256LL))(
                           v415,
                           "__index",
                           &v380)
                      && v380 < v63 )
                    {
                      (*(void (__fastcall **)(__int64, const char *, char **))(*(_QWORD *)v415 + 264LL))(
                        v415,
                        "value",
                        &v493);
                      v341 = sub_1402BA020((__int64 *)v516, v493);
                      v342 = *(_QWORD *)(v24 + 16);
                      v343 = *(_QWORD *)(v24 + 40) * v380;
                      p__XMM0_1 = *(_OWORD *)v341;
                      _XMM0_1 = *(_OWORD *)v341;
                      v344 = (__int64 (__fastcall ***)(_QWORD))sub_1403B2070(pDataCore_1, &_XMM0_1);
                      if ( v344 )
                      {
                        *((_QWORD *)&p__XMM0_1 + 1) = *((_QWORD *)&_XMM0_1 + 1);
                        *(_OWORD *)(v343 + v342) = _XMM0_1;
                        v344 = (__int64 (__fastcall ***)(_QWORD))(**v344)(v344);
                      }
                      else
                      {
                        *(_QWORD *)(v343 + v342) = 0;
                        *(_QWORD *)(v343 + v342 + 8) = 0;
                      }
                      *(_QWORD *)(v343 + v342 + 16) = v344;
                    }
                    if ( v415 )
                    {
                      (*(void (__fastcall **)(__int64))(*(_QWORD *)v415 + 40LL))(v415);
                    }
                  }
                  v10 = v398;
                  pDataCore_2 = pDataCore_1;
                  v377 = v398;
                  break;
                default:
LABEL_774:
                  pDataCore_2 = pDataCore_1;
                  goto LABEL_138;
              }
            }
LABEL_139:
            v8 = a4;
LABEL_140:
            if ( !v381 )
            {
              goto LABEL_70;
            }
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v381 + 40LL))(v381);
            v7 = v382;
LABEL_37:
            v16 = v429 + 1;
            v429 = v16;
            if ( v16 >= v495 )
            {
              goto LABEL_776;
            }
            v15 = *((_QWORD *)&pOutFieldPtrsVec_ + 1);
            pOutFieldPtrsVec__1 = pOutFieldPtrsVec_;
            v14 = v496;
          }
          (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v27 + 392LL))(v27, &v388);
LABEL_10:
          v28 = v388;
          while ( 1 )
          {
            v29 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v28 + 392LL))(v28, &v497);
            if ( v497 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v497 + 40LL))(v497);
            }
            if ( !v29 )
            {
              break;
            }
            v30 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v388 + 392LL))(v388, &v498);
            if ( *v30 )
            {
              (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v30 + 32LL))(*v30);
            }
            if ( v388 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v388 + 40LL))(v388);
            }
            v28 = *v30;
            v388 = *v30;
            if ( v498 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v498 + 40LL))(v498);
              goto LABEL_10;
            }
          }
          v407[0] = 232;
          v509[0] = v407;
          v407[1] = 31;
          v509[1] = v408;
          v31 = invokeGlobalCallbackAndMaskStatusBits(
                  4,
                  (__int64)v509,
                  (__int64)"Level data loss: Polymorphic type changed",
                  "Data type for a polymorphic was changed in DataForge and no longer matches DataCore Instanced Properti"
                  "es in the layer. There is no way to translate between the two, so the Instanced Properties have been i"
                  "gnored and may be lost on saving the level. The entity may need updating to account for the DataForge "
                  "changes. Affected Entity : $$, class: $$, GUID: $$. New structure $$, old structure $.");
          if ( (v31 & 0xFFFFF) != 0 )
          {
            v499 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v377 + 8LL))(v377);
            v500 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v388 + 272LL))(v388, "EntityClassGUID");
            v438 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v388 + 272LL))(v388, "EntityClass");
            arg48 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v388 + 272LL))(v388, "Name");
            ThreadLogContextSlot = getThreadLogContextSlot();
            v408[0] = 232;
            v408[1] = 31;
            v508[0] = (__int64)v408;
            v508[1] = (__int64)&v409;
            p__XMM0_1 = 0;
            v510 = 0;
            sub_147217250(
              4,
              (__int64)v508,
              "Level data loss: Polymorphic type changed",
              (__int64)"Data type for a polymorphic was changed in DataForge and no longer matches DataCore Instanced Pro"
                       "perties in the layer. There is no way to translate between the two, so the Instanced Properties h"
                       "ave been ignored and may be lost on saving the level. The entity may need updating to account for"
                       " the DataForge changes. Affected Entity : $$, class: $$, GUID: $$. New structure $$, old structure $.",
              1,
              v31,
              &v510,
              0,
              ThreadLogContextSlot,
              &arg48,
              &v438,
              &v500,
              (__int64 *)&s1,
              &v499);
          }
          if ( v388 )
          {
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v388 + 40LL))(v388);
          }
LABEL_34:
          pDataCore_2 = pDataCore_1;
LABEL_35:
          v7 = v382;
LABEL_36:
          v10 = v377;
          goto LABEL_37;
        }
LABEL_776:
        v374 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
        v375 = DataCore::LookupDCStructDescByName((__int64)pDataCore_2, v374);
        if ( v375 && *(_BYTE *)(v375 + 32) )
        {
          sub_1402A4690(v7, &v398);
        }
        if ( (_QWORD)pOutFieldPtrsVec_ )
        {
          sub_14039EFB0(
            (__int64)&pOutFieldPtrsVec_,
            (const void *)pOutFieldPtrsVec_,
            (v419 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
          pOutFieldPtrsVec_ = 0;
          v419 = 0;
        }
      }
    }
  }
  v505 = __rdtsc();
  return qword_149818EA8(&n5632);
}

// --- End Function: sub_147251B00 (0x147251B00) ---

// --- Function: sub_1472564E0 (0x1472564E0) ---
__int64 __fastcall sub_1472564E0(__int64 a1)
{
  _QWORD *v1; // rsi
  _QWORD *i; // rbx
  __int64 result; // rax

  v1 = *(_QWORD **)(a1 + 408);
  for ( i = *(_QWORD **)(a1 + 400); i != v1; ++i )
  {
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*i + 40LL))(*i);
  }
  result = *(_QWORD *)(a1 + 400);
  if ( result != *(_QWORD *)(a1 + 408) )
  {
    *(_QWORD *)(a1 + 408) = result;
  }
  return result;
}

// --- End Function: sub_1472564E0 (0x1472564E0) ---

// --- Function: RegisterDataCoreStruct (0x14725C050) ---
// Registers a named data structure within the DataCore system.  Initializes the
// structure data based on parameters, creates a managed string object for the
// name, performs a deep copy of the data, calculates an FNV-1a hash of the name,
// and attempts to insert the name and copied data into the central hash map
// located at `pDataCore + 304`. If an entry with the same name already exists,
// logs a fatal error. Cleans up temporary resources before returning.  @param
// pDataCore Pointer to the main DataCore object. @param pszStructName Null-
// terminated string representing the unique name for the structure. @param
// pDataParam1 Parameter passed to `InitializeDataCoreStructData` (maps to offset
// 0x10). @param pDataParam2 Parameter passed to `InitializeDataCoreStructData`
// (maps to offset 0x00). @param pDataParam3 Parameter passed to
// `InitializeDataCoreStructData` (maps to offset 0x08). @param pDataParam4
// Parameter passed to `InitializeDataCoreStructData` (maps to offset 0x18). @param
// pDataParam5 Parameter passed to `InitializeDataCoreStructData` (maps to offset
// 0x20). @param pDataParam6 Parameter passed to `InitializeDataCoreStructData`
// (maps to offset 0x28). @return Result of a cleanup operation
// (`vector_dword_set_size`), likely ignored.
_BYTE *__fastcall RegisterDataCoreStruct(
        __int64 pDataCore,
        _BYTE *pszStructName,
        __int64 initDataParam_16,
        __int64 initDataParam_0,
        __int64 initDataParam_8,
        __int64 initDataParam_24,
        char initDataParam_32,
        __int64 initDataParam_40)
{
  __int64 pInitializedStructData; // rbx
  unsigned __int64 structNameLen; // rax
  unsigned __int64 hashLoopIndex; // r8
  __int64 fnv1aHash; // rdx
  __int64 currentChar; // rcx
  _BYTE *result; // rax
  __int64 *ppStructNameStringObj; // [rsp+40h] [rbp-B8h] BYREF
  _BYTE *pCopiedStructData; // [rsp+48h] [rbp-B0h] BYREF
  _BYTE *pStructNameStringData; // [rsp+50h] [rbp-A8h] BYREF
  _BYTE copiedStructData[56]; // [rsp+58h] [rbp-A0h] BYREF
  unsigned __int64 tempContainer1; // [rsp+90h] [rbp-68h] BYREF
  _BYTE mapLookupResult[24]; // [rsp+98h] [rbp-60h] BYREF
  _BYTE structDataBuffer[56]; // [rsp+B0h] [rbp-48h] BYREF
  unsigned __int64 tempContainer2; // [rsp+E8h] [rbp-10h] BYREF

  pInitializedStructData = InitializeDataCoreStructData(
                             (__int64)structDataBuffer,
                             initDataParam_0,
                             initDataParam_8,
                             initDataParam_16,
                             initDataParam_24,
                             initDataParam_32,
                             initDataParam_40);
  CreateStringObjectFromString((void **)&pStructNameStringData, pszStructName);
  sub_14721B460((__int64)copiedStructData, pInitializedStructData);
  ppStructNameStringObj = (__int64 *)&pStructNameStringData;
  pCopiedStructData = copiedStructData;
  structNameLen = -1;
  do
  {
    ++structNameLen;
  }
  while ( pStructNameStringData[structNameLen] );
  hashLoopIndex = 0;
  for ( fnv1aHash = 0xCBF29CE484222325uLL;
        hashLoopIndex < structNameLen;
        fnv1aHash = 0x100000001B3LL * (currentChar ^ fnv1aHash) )
  {
    currentChar = (unsigned __int8)pStructNameStringData[hashLoopIndex++];
  }
  FindOrInsertHashMapEntry(
    (__int64 *)(pDataCore + 304),
    (__int64)mapLookupResult,
    &pStructNameStringData,
    (__PAIR128__(fnv1aHash, fnv1aHash) * 0xDE5FB9D2630458E9uLL) >> 64,
    (int)&byte_147F32801,
    &ppStructNameStringObj,
    (__int64 *)&pCopiedStructData);
  vector_dword_set_size(&tempContainer1, 0, 0);
  DestroyStringObject(&pStructNameStringData);
  result = (_BYTE *)vector_dword_set_size(&tempContainer2, 0, 0);
  if ( !mapLookupResult[16] )
  {
    return LogFatalError("[DataCore] RegisterStruct: Attempt to register '%s' multiple times", pszStructName);
  }
  return result;
}

// --- End Function: RegisterDataCoreStruct (0x14725C050) ---

// --- Function: sub_14725C2D0 (0x14725C2D0) ---
__int64 __fastcall sub_14725C2D0(__int64 *rcx0, __int128 *a2, __int64 **a3)
{
  _BYTE *v6; // rax
  _QWORD *p_SubStr; // rcx
  char v8; // al
  __int64 *v9; // rcx
  __int64 v10; // r8
  char *v11; // rax
  __int64 *v12; // rax
  __m128i v13; // xmm0
  __int64 v14; // rax
  int v15; // ebx
  const char *p___guid; // rdx
  __int64 v17; // rax
  __int64 *ThreadLogContextSlot; // rax
  char *v19; // rax
  __int64 *v20; // rax
  __m128i v21; // xmm0
  __int64 v22; // rax
  __int64 (__fastcall ***v23)(_QWORD); // rbx
  unsigned __int64 _XMM2; // rax
  __m128i *v25; // rax
  __int64 v26; // r8
  void (__fastcall ***v27)(_QWORD, __int64); // rax
  __int64 *v28; // r12
  unsigned __int64 *v29; // rbx
  _OWORD *v30; // rdx
  __int64 v31; // r8
  unsigned __int64 v32; // r8
  _OWORD *i; // rcx
  unsigned __int64 v34; // rdi
  __int64 v35; // rsi
  void **StringObjectFromString; // rax
  __m128i v37; // xmm6
  const void **v38; // rbx
  __m128i v39; // xmm6
  __int64 v40; // rax
  _BYTE *v41; // rbx
  unsigned __int64 v42; // rdx
  __int64 v43; // r8
  __int64 v44; // rcx
  unsigned __int64 v45; // r15
  __int64 v46; // rax
  __int64 v47; // rdi
  __int64 v48; // rbx
  char v49; // r15
  __int64 v50; // rax
  unsigned __int8 v51; // bl
  __int64 v53; // [rsp+28h] [rbp-D8h]
  void *v54[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int128 v55; // [rsp+70h] [rbp-90h] BYREF
  char *SubStr; // [rsp+80h] [rbp-80h] BYREF
  __int64 a1; // [rsp+88h] [rbp-78h] BYREF
  char *v58; // [rsp+90h] [rbp-70h] BYREF
  __int128 *v59; // [rsp+98h] [rbp-68h] BYREF
  char *v60; // [rsp+A0h] [rbp-60h]
  __int64 v61[4]; // [rsp+B0h] [rbp-50h] BYREF
  __m128i v62; // [rsp+D0h] [rbp-30h] BYREF

  v59 = a2;
  initializeEmptyStringStructure(v54);
  initializeEmptyStringStructure(&v58);
  if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(**a3 + 280))(*a3, "__type") )
  {
    sub_1405BD4A0(8u, 0, "[DataCore] - DataCore. Could not load %s, it has no __type attribute.", (const char *)v54[0]);
    goto LABEL_47;
  }
  v6 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, const char *))(**a3 + 272))(*a3, "__type");
  assignCStringToStringStructure((void **)&v58, v6);
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(**a3 + 280))(*a3, "__embeddedName") )
  {
    (*(void (__fastcall **)(_QWORD, const char *, void **))(**a3 + 128))(*a3, "__embeddedName", v54);
    sub_1403577C0((void **)&SubStr, (const void **)&v58);
    sub_140380E90((void **)&SubStr, ".");
    sub_1403577C0((void **)&a1, (const void **)&SubStr);
    sub_140380E40((void **)&a1, (char **)v54);
    sub_140374480(v54, (void **)&a1);
    DestroyStringObject(&a1);
    p_SubStr = &SubStr;
  }
  else
  {
    CreateStringObjectFromString((void **)&v55, a2);
    sub_1403AA930(&a1, &v55);
    DestroyStringObject(&v55);
    sub_1403577C0((void **)&SubStr, (const void **)&v58);
    sub_140380E90((void **)&SubStr, ".");
    if ( sub_1403BB9F0(&v58) || sub_1403E1240(&a1, SubStr, 0) )
    {
      sub_1403577C0((void **)&v55, (const void **)&SubStr);
      sub_140380E40((void **)&v55, (char **)&a1);
      sub_140374480(v54, (void **)&v55);
      DestroyStringObject(&v55);
    }
    else
    {
      copyStringStructure(v54, (const void **)&a1);
    }
    DestroyStringObject(&SubStr);
    p_SubStr = &a1;
  }
  DestroyStringObject(p_SubStr);
  v8 = (*(__int64 (__fastcall **)(_QWORD, const char *))(**a3 + 280))(*a3, "__hash");
  v9 = *a3;
  v10 = **a3;
  if ( v8 )
  {
    v11 = (char *)(*(__int64 (__fastcall **)(__int64 *, const char *))(v10 + 272))(v9, "__hash");
    v12 = sub_1402BA020(v61, v11);
    v13 = *(__m128i *)v12;
    v14 = *v12;
    v62 = v13;
    if ( !v14 && !_mm_extract_epi64(v13, 1) )
    {
      *(_QWORD *)&v55 = 0x1F000000E8LL;
      v59 = &v55;
      v60 = (char *)&v55 + 8;
      v15 = invokeGlobalCallbackAndMaskStatusBits(
              4,
              (__int64)&v59,
              (__int64)"[DataCore] $$ could not be loaded as GUID [$$] has incorrect format.",
              " The correct format is XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX where X stands for hexadecimal number.");
      if ( (v15 & 0xFFFFF) == 0 )
      {
LABEL_47:
        v51 = 0;
        goto LABEL_48;
      }
      p___guid = "__hash";
LABEL_14:
      v17 = (*(__int64 (__fastcall **)(_QWORD, const char *))(**a3 + 272))(*a3, p___guid);
      SubStr = (char *)v54[0];
      a1 = v17;
      ThreadLogContextSlot = getThreadLogContextSlot();
      *(_QWORD *)&v55 = 0x1F000000E8LL;
      v59 = &v55;
      v60 = (char *)&v55 + 8;
      LODWORD(v53) = v15;
      *(_OWORD *)v61 = 0;
      sub_14043A610(
        4,
        (__int64)&v59,
        "[DataCore] $$ could not be loaded as GUID [$$] has incorrect format.",
        (__int64)" The correct format is XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX where X stands for hexadecimal number.",
        1,
        v53,
        v61,
        0,
        (__int64)ThreadLogContextSlot,
        (__int64 *)&SubStr,
        &a1);
      goto LABEL_47;
    }
  }
  else if ( (*(unsigned __int8 (__fastcall **)(__int64 *, const char *))(v10 + 280))(v9, "__guid") )
  {
    v19 = (char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(**a3 + 272))(*a3, "__guid");
    v20 = sub_1402BA020(v61, v19);
    v21 = *(__m128i *)v20;
    v22 = *v20;
    v62 = v21;
    if ( !v22 && !_mm_extract_epi64(v21, 1) )
    {
      *(_QWORD *)&v55 = 0x1F000000E8LL;
      v59 = &v55;
      v60 = (char *)&v55 + 8;
      v15 = invokeGlobalCallbackAndMaskStatusBits(
              4,
              (__int64)&v59,
              (__int64)"[DataCore] $$ could not be loaded as GUID [$$] has incorrect format.",
              " The correct format is XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX where X stands for hexadecimal number.");
      if ( (v15 & 0xFFFFF) == 0 )
      {
        goto LABEL_47;
      }
      p___guid = "__guid";
      goto LABEL_14;
    }
  }
  else
  {
    sub_1405BD4A0(8u, 0, "[DataCore] %s could not be loaded it has no GUID associated.", (const char *)v54[0]);
  }
  sub_1472186C0(rcx0 + 1, (unsigned __int64 *)&v55, &v62);
  if ( (_QWORD)v55 == rcx0[1] + rcx0[4] )
  {
    sub_14039EBB0("[DataCore] [LiveEdit] %s was created.", (const char *)v54[0]);
    v28 = rcx0 + 29;
  }
  else
  {
    sub_14039EBB0("[DataCore] [LiveEdit] %s was modified.", (const char *)v54[0]);
    v23 = *(__int64 (__fastcall ****)(_QWORD))(*((_QWORD *)&v55 + 1) + 16LL);
    if ( v23 )
    {
      _XMM2 = (**v23)(*(_QWORD *)(*((_QWORD *)&v55 + 1) + 16LL));
      v25 = (__m128i *)unknown_libname_247((const __m128i *)rcx0[47], (const __m128i *)rcx0[48], _XMM2);
      v26 = rcx0[48];
      if ( v25 != (__m128i *)v26 )
      {
        memmove(v25, &v25->m128i_u64[1], v26 - (_QWORD)&v25->m128i_i64[1]);
        rcx0[48] -= 8;
      }
      v27 = (void (__fastcall ***)(_QWORD, __int64))(**v23)(v23);
      if ( v27 )
      {
        (**v27)(v27, 1);
      }
    }
    *(_OWORD *)v61 = v55;
    sub_14726B3A0(rcx0 + 1, (char **)&v55, v61);
    sub_147218570(rcx0 + 8, (const char **)v54);
    sub_147218450(rcx0 + 15, &v62);
    sub_147218450(rcx0 + 22, &v62);
    CreateStringObjectFromString((void **)&v55, v58);
    v28 = rcx0 + 29;
    v29 = (unsigned __int64 *)sub_147211F60(rcx0 + 29, (__int64 *)&v55);
    DestroyStringObject(&v55);
    v30 = (_OWORD *)*v29;
    v31 = *(unsigned int *)(*v29 - 4);
    LODWORD(v31) = v31 & 0x7FFFFFFF;
    v32 = *v29 + 16 * v31;
    if ( *v29 != v32 )
    {
      while ( *v30 != *(_OWORD *)&v62 )
      {
        if ( ++v30 == (_OWORD *)v32 )
        {
          goto LABEL_35;
        }
      }
      for ( i = v30 + 1; (unsigned __int64)i < v32; ++i )
      {
        *v30++ = *i;
      }
      sub_1409310A0(v29, (*(_DWORD *)(*v29 - 4) & 0x7FFFFFFF) - (i - v30), 1u);
    }
  }
LABEL_35:
  v34 = 0;
  v35 = sub_1402A1E30(0x28u);
  if ( v35 )
  {
    StringObjectFromString = CreateStringObjectFromString((void **)&v55, (_BYTE *)v54[0]);
    v37 = v62;
    v38 = (const void **)StringObjectFromString;
    *(_QWORD *)(v35 + 8) = sub_14724E7E0(rcx0, (char *)v54[0], 0, v58, (char *)v54[0], a3);
    *(_QWORD *)v35 = &off_1489FEA50;
    *(__m128i *)(v35 + 16) = v37;
    sub_1403577C0((void **)(v35 + 32), v38);
    DestroyStringObject(v38);
  }
  else
  {
    v35 = 0;
  }
  sub_147218DB0(rcx0 + 1, (__int64)v61, &v62);
  *(_QWORD *)(v61[1] + 16) = v35;
  v39 = v62;
  sub_1472190F0(rcx0 + 8, (__int64)v61, (const char **)v54);
  v40 = v61[1];
  *(_QWORD *)(v61[1] + 8) = v35;
  *(__m128i *)(v40 + 16) = v39;
  v41 = v54[0];
  sub_147218F50(rcx0 + 15, (__int64)v61, &v62);
  assignCStringToStringStructure((void **)(v61[1] + 16), v41);
  sub_147218F50(rcx0 + 22, (__int64)v61, &v62);
  assignCStringToStringStructure((void **)(v61[1] + 16), v59);
  v42 = -1;
  do
  {
    ++v42;
  }
  while ( v58[v42] );
  v43 = 0xCBF29CE484222325uLL;
  if ( v42 )
  {
    do
    {
      v44 = (unsigned __int8)v58[v34++];
      v43 = 0x100000001B3LL * (v44 ^ v43);
    }
    while ( v34 < v42 );
  }
  v45 = (__PAIR128__(v43, v43) * 0xDE5FB9D2630458E9uLL) >> 64;
  v46 = sub_147217050(v28, &v58, v45);
  if ( v46 == -1 )
  {
    v47 = sub_14726BC00(v28, v45);
    v48 = 16 * v47 + v28[1];
    sub_1403577C0((void **)v48, (const void **)&v58);
    v49 = v45 & 0x7F;
    *(_QWORD *)(v48 + 8) = (unsigned __int64)&unk_149808B0B & 0xFFFFFFFFFFFFFFF8uLL;
    *(_BYTE *)(v47 + *v28) = v49;
    *(_BYTE *)((v28[3] & 0xF) + (v28[3] & (v47 - 16)) + *v28 + 1) = v49;
    v50 = 16 * v47 + v28[1];
  }
  else
  {
    v50 = v28[1] + 16 * v46;
  }
  sub_1471DC1C0((unsigned __int64 *)(v50 + 8), &v62);
  sub_14725DB10(rcx0);
  sub_14725DFC0(rcx0);
  sub_1472564E0((__int64)rcx0);
  v51 = 1;
LABEL_48:
  DestroyStringObject(&v58);
  DestroyStringObject(v54);
  return v51;
}

// --- End Function: sub_14725C2D0 (0x14725C2D0) ---

// --- Function: sub_14725D8A0 (0x14725D8A0) ---
__int64 __fastcall sub_14725D8A0(_QWORD *pDataCore, _QWORD *a2, const char *s1, char a4)
{
  char v7; // r9
  const char *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.; // rax
  signed __int64 v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // r14
  __int64 v12; // rdx
  __int64 structIdentifier; // rax
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rsi
  __int64 v16; // rcx
  __int64 *v17; // rdx
  __int128 pOutFieldPtrsVec_; // [rsp+20h] [rbp-48h] BYREF
  __int64 v20; // [rsp+30h] [rbp-38h]

  if ( a4 )
  {
    v7 = *((_BYTE *)a2 + 8);
    p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (const char *)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
    if ( v7 && *a2 )
    {
      p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (const char *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 8LL))(*a2);
      v7 = *((_BYTE *)a2 + 8);
    }
    if ( strcmp(s1, p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.) )
    {
      if ( v7 )
      {
        if ( *a2 )
        {
          (**(void (__fastcall ***)(_QWORD, __int64))*a2)(*a2, 1);
          *a2 = 0;
        }
        *((_BYTE *)a2 + 8) = 0;
      }
      v9 = DataCore::LookupDCStructDescByName((__int64)pDataCore, (__int64)s1);
      if ( v9 )
      {
        v10 = (_QWORD *)(***(__int64 (__fastcall ****)(_QWORD, _QWORD))(v9 + 16))(*(_QWORD *)(v9 + 16), 0);
        *a2 = v10;
        v11 = v10;
        if ( v10 )
        {
          v12 = *v10;
          pOutFieldPtrsVec_ = 0;
          v20 = 0;
          structIdentifier = (*(__int64 (__fastcall **)(_QWORD *))(v12 + 8))(v10);
          DataCore::GetStructFieldPointers((__int64)pDataCore, structIdentifier, (char **)&pOutFieldPtrsVec_, 1);
          v14 = 0;
          v15 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
          if ( v15 )
          {
            do
            {
              if ( (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3 <= v14 )
              {
                __debugbreak();
              }
              v16 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v14);
              v17 = (_QWORD *)((char *)v11 + *(_QWORD *)(v16 + 8));
              if ( !*(_BYTE *)(v16 + 26) )
              {
                switch ( *(_BYTE *)(v16 + 24) )
                {
                  case 1:
                  case 2:
                  case 6:
                    *(_BYTE *)v17 = 0;
                    break;
                  case 3:
                  case 7:
                    *(_WORD *)v17 = 0;
                    break;
                  case 4:
                  case 8:
                  case 0xB:
                    *(_DWORD *)v17 = 0;
                    break;
                  case 5:
                  case 9:
                  case 0xC:
                    *v17 = 0;
                    break;
                  case 0xF:
                    switch ( *(_QWORD *)(v16 + 16) )
                    {
                      case 1LL:
                        *(_BYTE *)v17 = -1;
                        break;
                      case 2LL:
                        *(_WORD *)v17 = -1;
                        break;
                      case 4LL:
                        *(_DWORD *)v17 = -1;
                        break;
                    }
                    break;
                  case 0x10:
                    if ( !*(_BYTE *)(v16 + 25) )
                    {
                      sub_147269A00(pDataCore, v17);
                    }
                    break;
                  default:
                    break;
                }
              }
              ++v14;
            }
            while ( v14 < v15 );
          }
          if ( (_QWORD)pOutFieldPtrsVec_ )
          {
            sub_14039EFB0(
              (__int64)&pOutFieldPtrsVec_,
              (const void *)pOutFieldPtrsVec_,
              (v20 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
          }
        }
        *((_BYTE *)a2 + 8) = 1;
      }
    }
  }
  if ( *((_BYTE *)a2 + 8) )
  {
    return *a2;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_14725D8A0 (0x14725D8A0) ---

// --- Function: sub_14725DB10 (0x14725DB10) ---
__int64 __fastcall sub_14725DB10(_QWORD *a1)
{
  _QWORD *v2; // r12
  _QWORD *v3; // r15
  _QWORD *v4; // rdi
  __int64 *v5; // rax
  const char *v6; // r13
  int v7; // eax
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // r14
  unsigned __int64 v10; // rbx
  unsigned __int128 v11; // rax
  __int64 v12; // r9
  __int64 v18; // r10
  __int64 v19; // rcx
  __int64 v20; // rcx
  _OWORD *v23; // rbx
  __int64 result; // rax
  _BYTE v25[8]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v26; // [rsp+28h] [rbp-40h]

  v2 = (_QWORD *)a1[54];
  v3 = (_QWORD *)a1[53];
  if ( v3 != v2 )
  {
    v4 = v3 + 1;
    v5 = a1 + 15;
    do
    {
      sub_147218F50(v5, (__int64)v25, v4);
      v6 = *(const char **)(v26 + 16);
      v7 = psub_1403339F0(0xFFFFFFFF, (__int64)v4, 16LL);
      v8 = a1[4];
      v9 = 0LL;
      v10 = v8;
      v11 = (unsigned int)~v7 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
      v12 = v8 & ((*((_QWORD *)&v11 + 1) + (_QWORD)v11) >> 7);
      _XMM2 = ((_BYTE)v11 + BYTE8(v11)) & 0x7F;
      __asm { vpshufb xmm2, xmm2, xmm0 }
      while ( 1 )
      {
        _XMM1 = *(_OWORD *)(v12 + a1[1]);
        __asm
        {
          vpcmpeqb xmm0, xmm2, xmm1
          vpmovmskb eax, xmm0
        }
        if ( _EAX )
        {
          break;
        }
LABEL_9:
        __asm
        {
          vpcmpeqb xmm1, xmm1, cs:xmmword_147F33270
          vpmovmskb eax, xmm1
        }
        if ( _EAX )
        {
          goto LABEL_14;
        }
        v9 += 16LL;
        v12 = v10 & (v12 + v9);
        if ( v9 > v8 )
        {
          __debugbreak();
          v8 = a1[4];
        }
      }
      v18 = a1[2];
      while ( 1 )
      {
        _BitScanForward((unsigned int *)&v19, _EAX);
        v20 = (v19 + v12) & v10;
        if ( *(_QWORD *)(v18 + 24 * v20) == *v4 && *(_QWORD *)(v18 + 24 * v20 + 8) == v4[1] )
        {
          break;
        }
        _EAX &= _EAX - 1;
        if ( !_EAX )
        {
          goto LABEL_9;
        }
      }
      if ( v20 != a1[4] )
      {
        v23 = (_OWORD *)*v3;
        *(_OWORD *)*v3 = *(_OWORD *)v4;
        *((_QWORD *)v23 + 2) = (***(__int64 (__fastcall ****)(_QWORD))(v18 + 24 * v20 + 16))(*(_QWORD *)(v18 + 24 * v20 + 16));
        goto LABEL_15;
      }
LABEL_14:
      sub_1405BD4A0(8u, 0, "[DataCore] Attempting to resolve record reference for record [%s] failed.", v6);
LABEL_15:
      v3 += 3;
      v5 = a1 + 15;
      v4 += 3;
    }
    while ( v3 != v2 );
  }
  result = a1[53];
  if ( result != a1[54] )
  {
    a1[54] = result;
  }
  return result;
}

// --- End Function: sub_14725DB10 (0x14725DB10) ---

// --- Function: sub_14725DCF0 (0x14725DCF0) ---
__int64 __fastcall sub_14725DCF0(_QWORD *a1, __int64 a2, _QWORD *a3, char **a4, _QWORD *a5)
{
  return sub_147251B00(a1, a2, a5, a3, a4);
}

// --- End Function: sub_14725DCF0 (0x14725DCF0) ---

// --- Function: sub_14725DD10 (0x14725DD10) ---
void __fastcall sub_14725DD10(__int64 pDataCore, char *rdx0, _BYTE *a3, size_t *a4)
{
  __int64 structIdentifier; // rax
  unsigned __int64 v8; // r14
  __int64 v9; // rdi
  char v10; // r15
  char *Size; // rax
  char *Size_2; // rbx
  char *v13; // r12
  void **v14; // rax
  char *Size_1; // rbx
  char *v16; // rax
  void **v17; // rax
  __int64 v18; // rdx
  char *v19; // rbx
  char v20; // di
  char *v21; // rdx
  char v22; // [rsp+28h] [rbp-29h]
  __int64 v23; // [rsp+30h] [rbp-21h] BYREF
  int v24; // [rsp+38h] [rbp-19h]
  __int64 a1; // [rsp+40h] [rbp-11h] BYREF
  __int128 pOutFieldPtrsVec_; // [rsp+48h] [rbp-9h] BYREF
  __int64 v27; // [rsp+58h] [rbp+7h]
  char *String; // [rsp+60h] [rbp+Fh] BYREF
  void *a2; // [rsp+68h] [rbp+17h] BYREF
  void *v30; // [rsp+70h] [rbp+1Fh] BYREF
  unsigned __int64 v31; // [rsp+78h] [rbp+27h]

  if ( rdx0 )
  {
    structIdentifier = (*(__int64 (__fastcall **)(char *))(*(_QWORD *)rdx0 + 8LL))(rdx0);
    v8 = 0;
    v27 = 0;
    pOutFieldPtrsVec_ = 0;
    DataCore::GetStructFieldPointers(pDataCore, structIdentifier, (char **)&pOutFieldPtrsVec_, 1);
    v9 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
    v31 = v9;
    CreateStringObjectFromString((void **)&a1, a3);
    initializeEmptyStringStructure(&v23);
    v10 = 0;
    Size = sub_1403E1630(&a1, 46, 0);
    v24 = -1;
    Size_2 = Size;
    if ( Size == (char *)-1LL )
    {
      v10 = 1;
      copyStringStructure((void **)&v23, (const void **)&a1);
      v13 = rdx0;
    }
    else
    {
      v14 = sub_1403E6250(&a1, &a2, 0, (size_t)Size);
      sub_140374480((void **)&v23, v14);
      DestroyStringObject(&a2);
      v13 = &Size_2[a1 + 1];
    }
    Size_1 = sub_1403E1630(&v23, 91, 0);
    if ( Size_1 != (char *)-1LL )
    {
      v16 = sub_1403E1630(&v23, 93, 0);
      if ( v16 != (char *)-1LL )
      {
        sub_1403E6250(&v23, (void **)&String, (size_t)(Size_1 + 1), v16 - Size_1 - 1);
        v24 = atoi(String);
        v17 = sub_1403E6250(&v23, &v30, 0, (size_t)Size_1);
        sub_140374480((void **)&v23, v17);
        DestroyStringObject(&v30);
        DestroyStringObject(&String);
      }
    }
    if ( v9 )
    {
      do
      {
        if ( (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3 <= v8 )
        {
          __debugbreak();
        }
        v18 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v8);
        v19 = &rdx0[*(_QWORD *)(v18 + 8)];
        v20 = *(_BYTE *)(v18 + 25);
        v22 = *(_BYTE *)(v18 + 26);
        if ( *(_BYTE *)(v18 + 24) != 16 || (unsigned int)sub_1403DFC10((unsigned __int8 **)&v23, *(_QWORD *)v18) )
        {
          goto LABEL_27;
        }
        if ( v22 )
        {
          if ( v24 < *((_DWORD *)v19 + 6) )
          {
            if ( !v20 )
            {
              if ( v10 )
              {
                v19 = (char *)(*((_QWORD *)v19 + 2) + *((_QWORD *)v19 + 5) * v24);
LABEL_30:
                *a4 = (size_t)v19;
                break;
              }
              v21 = (char *)(*((_QWORD *)v19 + 2) + *((_QWORD *)v19 + 5) * v24);
              goto LABEL_26;
            }
            if ( v20 == 1 )
            {
              v21 = *(char **)(*((_QWORD *)v19 + 5) * v24 + *((_QWORD *)v19 + 2));
              if ( v10 )
              {
                *a4 = (size_t)v21;
                break;
              }
              goto LABEL_26;
            }
          }
        }
        else
        {
          if ( !v20 )
          {
            if ( v10 )
            {
              goto LABEL_30;
            }
            v21 = v19;
LABEL_26:
            sub_14725DD10(pDataCore, v21, v13, a4);
            goto LABEL_27;
          }
          if ( v20 == 1 )
          {
            v19 = *(char **)v19;
            if ( v10 )
            {
              goto LABEL_30;
            }
            v21 = v19;
            goto LABEL_26;
          }
        }
LABEL_27:
        ++v8;
      }
      while ( v8 < v31 );
    }
    DestroyStringObject(&v23);
    DestroyStringObject(&a1);
    if ( (_QWORD)pOutFieldPtrsVec_ )
    {
      sub_14039EFB0(
        (__int64)&pOutFieldPtrsVec_,
        (const void *)pOutFieldPtrsVec_,
        (v27 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
    }
  }
}

// --- End Function: sub_14725DD10 (0x14725DD10) ---

// --- Function: sub_14725DFC0 (0x14725DFC0) ---
void __fastcall sub_14725DFC0(_QWORD *a1)
{
  __int64 v2; // rsi
  __int64 i; // r15
  __int64 *v4; // rdi
  unsigned __int8 **v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rdi

  v2 = a1[56];
  for ( i = a1[57]; v2 != i; v2 += 16 )
  {
    v4 = (__int64 *)a1[45];
    v5 = (unsigned __int8 **)v4[1];
    while ( !*((_BYTE *)v5 + 25) )
    {
      if ( (int)sub_1403DFBE0(v5 + 4, (_QWORD *)(v2 + 8)) >= 0 )
      {
        v4 = (__int64 *)v5;
        v5 = (unsigned __int8 **)*v5;
      }
      else
      {
        v5 = (unsigned __int8 **)v5[2];
      }
    }
    if ( !*((_BYTE *)v4 + 25)
      && (int)sub_1403DFBE0((unsigned __int8 **)(v2 + 8), v4 + 4) >= 0
      && v4 != (__int64 *)a1[45] )
    {
      **(_QWORD **)v2 = v4[5];
    }
  }
  v6 = a1[56];
  v7 = a1[57];
  if ( v6 != v7 )
  {
    do
    {
      DestroyStringObject((_QWORD *)(v6 + 8));
      v6 += 16;
    }
    while ( v6 != v7 );
    a1[57] = a1[56];
  }
}

// --- End Function: sub_14725DFC0 (0x14725DFC0) ---

// --- Function: sub_147266E90 (0x147266E90) ---
void __fastcall sub_147266E90(__int64 a1)
{
  *(_DWORD *)(a1 + 720) = 0;
}

// --- End Function: sub_147266E90 (0x147266E90) ---

// --- Function: sub_147267CC0 (0x147267CC0) ---
__int64 __fastcall sub_147267CC0(int n10004)
{
  __int64 result; // rax

  if ( n10004 > 10004 )
  {
    switch ( n10004 )
    {
      case 10009:
        result = 4294967290LL;
        break;
      case 10013:
        result = 0xFFFFFFFFLL;
        break;
      case 10014:
        result = 4294967286LL;
        break;
      case 10022:
        result = 4294967282LL;
        break;
      case 10024:
        result = 4294967280LL;
        break;
      case 10035:
        result = 4294967268LL;
        break;
      case 10036:
        result = 4294967284LL;
        break;
      case 10037:
        result = 4294967291LL;
        break;
      case 10040:
        result = 4294967279LL;
        break;
      case 10042:
        result = 4294967276LL;
        break;
      case 10043:
      case 10047:
        result = 4294967292LL;
        break;
      case 10045:
        result = 4294967273LL;
        break;
      case 10048:
        result = 4294967294LL;
        break;
      case 10049:
        result = 4294967293LL;
        break;
      case 10051:
        result = 4294967278LL;
        break;
      case 10053:
        result = 4294967289LL;
        break;
      case 10054:
        result = 4294967287LL;
        break;
      case 10055:
        result = 4294967277LL;
        break;
      case 10056:
        result = 4294967281LL;
        break;
      case 10057:
        result = 4294967275LL;
        break;
      case 10059:
        result = 4294967269LL;
        break;
      case 10060:
        result = 4294967270LL;
        break;
      case 10061:
        result = 4294967288LL;
        break;
      case 10064:
        result = 4294967285LL;
        break;
      case 10093:
        result = 4294967274LL;
        break;
      default:
        goto LABEL_32;
    }
  }
  else if ( n10004 == 10004 )
  {
    return 4294967283LL;
  }
  else if ( n10004 )
  {
LABEL_32:
    sub_14039EBB0("CrySock could not translate OS error code %x, treating as miscellaneous", n10004);
    return 4294966296LL;
  }
  else
  {
    return 0LL;
  }
  return result;
}

// --- End Function: sub_147267CC0 (0x147267CC0) ---

// --- Function: sub_1472688E0 (0x1472688E0) ---
void __fastcall sub_1472688E0(__int64 a1)
{
  const void *ptr_to_free; // rcx

  *(_BYTE *)(a1 + 920) = 1;
  ptr_to_free = *(const void **)(a1 + 680);
  if ( ptr_to_free )
  {
    free_memory_wrapper(ptr_to_free);
    *(_QWORD *)(a1 + 680) = 0;
  }
}

// --- End Function: sub_1472688E0 (0x1472688E0) ---

// --- Function: sub_147269A00 (0x147269A00) ---
void __fastcall sub_147269A00(_QWORD *pDataCore, __int64 *a2)
{
  __int64 v2; // rax
  __int64 structIdentifier; // rax
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 *v9; // rdx
  __int128 pOutFieldPtrsVec_; // [rsp+20h] [rbp-38h] BYREF
  __int64 v11; // [rsp+30h] [rbp-28h]

  if ( a2 )
  {
    v2 = *a2;
    v11 = 0;
    pOutFieldPtrsVec_ = 0;
    structIdentifier = (*(__int64 (__fastcall **)(__int64 *))(v2 + 8))(a2);
    DataCore::GetStructFieldPointers((__int64)pDataCore, structIdentifier, (char **)&pOutFieldPtrsVec_, 1);
    v6 = 0;
    v7 = (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3;
    if ( v7 )
    {
      do
      {
        if ( (__int64)(*((_QWORD *)&pOutFieldPtrsVec_ + 1) - pOutFieldPtrsVec_) >> 3 <= v6 )
        {
          __debugbreak();
        }
        v8 = *(_QWORD *)(pOutFieldPtrsVec_ + 8 * v6);
        v9 = (__int64 *)((char *)a2 + *(_QWORD *)(v8 + 8));
        if ( !*(_BYTE *)(v8 + 26) )
        {
          switch ( *(_BYTE *)(v8 + 24) )
          {
            case 1:
            case 2:
            case 6:
              *(_BYTE *)v9 = 0;
              break;
            case 3:
            case 7:
              *(_WORD *)v9 = 0;
              break;
            case 4:
            case 8:
            case 0xB:
              *(_DWORD *)v9 = 0;
              break;
            case 5:
            case 9:
            case 0xC:
              *v9 = 0;
              break;
            case 0xF:
              switch ( *(_QWORD *)(v8 + 16) )
              {
                case 1LL:
                  *(_BYTE *)v9 = -1;
                  break;
                case 2LL:
                  *(_WORD *)v9 = -1;
                  break;
                case 4LL:
                  *(_DWORD *)v9 = -1;
                  break;
              }
              break;
            case 0x10:
              if ( !*(_BYTE *)(v8 + 25) )
              {
                sub_147269A00(pDataCore, v9);
              }
              break;
            default:
              break;
          }
        }
        ++v6;
      }
      while ( v6 < v7 );
    }
    if ( (_QWORD)pOutFieldPtrsVec_ )
    {
      sub_14039EFB0(
        (__int64)&pOutFieldPtrsVec_,
        (const void *)pOutFieldPtrsVec_,
        (v11 - pOutFieldPtrsVec_) & 0xFFFFFFFFFFFFFFF8uLL);
    }
  }
}

// --- End Function: sub_147269A00 (0x147269A00) ---

// --- Function: sub_14726A140 (0x14726A140) ---
__int64 __fastcall sub_14726A140(__int64 a1)
{
  const void *v2; // rcx
  __int64 result; // rax

  v2 = *(const void **)(a1 + 16);
  if ( v2 )
  {
    if ( *(_BYTE *)(a1 + 8) )
    {
      free_memory_wrapper(v2);
      result = 0LL;
      *(_QWORD *)(a1 + 24) = 0LL;
      *(_QWORD *)(a1 + 32) = 0LL;
      *(_QWORD *)(a1 + 16) = 0LL;
      *(_BYTE *)(a1 + 8) = 0;
    }
  }
  return result;
}

// --- End Function: sub_14726A140 (0x14726A140) ---

// --- Function: sub_14726A180 (0x14726A180) ---
__int64 __fastcall sub_14726A180(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rdi
  const void *v4; // r14
  __int64 i; // rbx

  result = *(_QWORD *)(a1 + 16);
  if ( result && *(_BYTE *)(a1 + 8) )
  {
    v3 = *(_QWORD *)(result - 8);
    v4 = (const void *)(result - 8);
    for ( i = result + 16 * v3; v3; --v3 )
    {
      i -= 16LL;
      sub_14036F160(i);
    }
    free_memory_wrapper(v4);
    result = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_BYTE *)(a1 + 8) = 0;
  }
  return result;
}

// --- End Function: sub_14726A180 (0x14726A180) ---

// --- Function: sub_14726A210 (0x14726A210) ---
__int64 __fastcall sub_14726A210(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rbx
  const void *v4; // r14
  _QWORD *i; // rdi

  result = *(_QWORD *)(a1 + 16);
  if ( result && *(_BYTE *)(a1 + 8) )
  {
    v3 = *(_QWORD *)(result - 8);
    v4 = (const void *)(result - 8);
    for ( i = (_QWORD *)(result + 8 * v3); v3; --v3 )
    {
      DestroyStringObject(--i);
    }
    free_memory_wrapper(v4);
    result = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_BYTE *)(a1 + 8) = 0;
  }
  return result;
}

// --- End Function: sub_14726A210 (0x14726A210) ---

// --- Function: sub_14726A540 (0x14726A540) ---
unsigned __int64 __fastcall sub_14726A540(__int64 a1)
{
  __int128 *v1; // rdx
  __int64 v3; // r8
  __int128 *v4; // rcx
  __int128 *v5; // rax
  unsigned __int64 v9; // rcx
  __int64 v10; // rsi
  __int64 v11; // rbp
  __int64 v12; // r15
  int v13; // eax
  __int64 v14; // r10
  __int128 *v15; // r9
  unsigned __int64 v17; // r11
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  __int64 v23; // r8
  unsigned __int64 v24; // rdx
  __int64 v25; // r8
  char v26; // r11
  __int64 v27; // r14
  bool v28; // zf
  __int64 v29; // rax
  __int64 v30; // rbx
  __int64 v31; // rbx
  __int64 v32; // rax
  __int64 v33; // rbx
  __int64 v34; // rax
  unsigned __int64 result; // rax
  __int128 v36; // [rsp+28h] [rbp-50h]
  __int64 v37; // [rsp+38h] [rbp-40h] BYREF

  v1 = *(__int128 **)a1;
  v3 = *(_QWORD *)(a1 + 24);
  v4 = v1;
  v5 = (__int128 *)((char *)v1 + v3 + 1);
  if ( v1 != v5 )
  {
    _XMM3 = 0LL;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm3, xmmword ptr [rcx]
        vpandn  xmm1, xmm0, xmm4
      }
      *v4++ = _XMM1 | xmmword_147F33270;
    }
    while ( v4 != v5 );
  }
  *v5 = *v1;
  *((_BYTE *)v1 + v3) = -1;
  v9 = *(_QWORD *)(a1 + 24);
  v10 = 0LL;
  if ( v9 )
  {
    v11 = -16LL;
    do
    {
      if ( *(_BYTE *)(v10 + *(_QWORD *)a1) == 0xFE )
      {
        v12 = 24 * v10;
        v13 = psub_1403339F0(0xFFFFFFFF, 24 * v10 + *(_QWORD *)(a1 + 8), 16LL);
        v14 = *(_QWORD *)(a1 + 24);
        v15 = *(__int128 **)a1;
        _XMM1 = XMM4;
        v17 = (__PAIR128__((unsigned int)~v13, (unsigned int)~v13) * 0xDE5FB9D2630458E9uLL) >> 64;
        v18 = 0LL;
        v19 = v14 & (v17 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [rcx+r9]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v18 += 16LL;
          v19 = (v18 + v19) & v14;
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [rcx+r9]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v23, _EAX);
        v24 = v14 & (v17 >> 7);
        v25 = (v19 + v23) & v14;
        v26 = v17 & 0x7F;
        if ( (((v10 - v24) ^ (v25 - v24)) & v14 & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
        {
          v27 = 24 * v25;
          v28 = *((_BYTE *)v15 + v25) == 0x80;
          *((_BYTE *)v15 + v25) = v26;
          *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + ((v25 - 16) & *(_QWORD *)(a1 + 24)) + *(_QWORD *)a1 + 1) = v26;
          if ( v28 )
          {
            v29 = *(_QWORD *)(a1 + 8);
            v30 = v12 + v29;
            *(_OWORD *)(v29 + 24 * v25) = *(_OWORD *)(v12 + v29);
            sub_1403577A0((_QWORD *)(v27 + v29 + 16), (__int64 *)(v12 + v29 + 16));
            DestroyStringObject((_QWORD *)(v30 + 16));
            *(_BYTE *)(v10 + *(_QWORD *)a1) = 0x80;
            *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v11) + *(_QWORD *)a1 + 1) = 0x80;
          }
          else
          {
            v31 = v12 + *(_QWORD *)(a1 + 8);
            v36 = *(_OWORD *)v31;
            sub_1403577A0(&v37, (__int64 *)(v31 + 16));
            DestroyStringObject((_QWORD *)(v31 + 16));
            v32 = *(_QWORD *)(a1 + 8);
            v33 = v27 + v32;
            *(_OWORD *)(v12 + v32) = *(_OWORD *)(v27 + v32);
            sub_1403577A0((_QWORD *)(v12 + v32 + 16), (__int64 *)(v27 + v32 + 16));
            DestroyStringObject((_QWORD *)(v33 + 16));
            v34 = *(_QWORD *)(a1 + 8);
            *(_OWORD *)(v27 + v34) = v36;
            sub_1403577A0((_QWORD *)(v27 + v34 + 16), &v37);
            DestroyStringObject(&v37);
            --v10;
            --v11;
          }
        }
        else
        {
          *((_BYTE *)v15 + v10) = v26;
          *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v11) + *(_QWORD *)a1 + 1) = v26;
        }
      }
      v9 = *(_QWORD *)(a1 + 24);
      ++v10;
      ++v11;
    }
    while ( v10 != v9 );
  }
  result = v9 >> 3;
  *(_QWORD *)(a1 + 48) = v9 - (v9 >> 3) - *(_QWORD *)(a1 + 16);
  return result;
}

// --- End Function: sub_14726A540 (0x14726A540) ---

// --- Function: sub_14726A860 (0x14726A860) ---
unsigned __int64 __fastcall sub_14726A860(__int64 a1)
{
  __int128 *v1; // rdx
  __int64 v3; // r8
  __int128 *v4; // rcx
  __int128 *v5; // rax
  __int64 v9; // r12
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rbp
  __int64 v13; // r13
  unsigned __int64 v14; // rcx
  __int64 v15; // r9
  unsigned __int64 i; // r8
  __int64 v17; // rax
  __int64 v18; // r8
  __int128 _XMM4; // xmm1
  unsigned __int64 v20; // r9
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v26; // r15
  unsigned __int64 v27; // rdx
  __int64 v28; // r15
  char v29; // r9
  _BYTE *v30; // rax
  __int64 v31; // rdx
  __int64 v32; // r15
  bool v33; // zf
  __int64 v34; // rax
  __int64 v35; // rsi
  __int64 v36; // rbx
  __int64 v37; // rdi
  __int64 v38; // rax
  __int64 v39; // rsi
  __int64 v40; // rbx
  _QWORD *v41; // rbx
  unsigned __int64 result; // rax
  __int64 v43; // [rsp+28h] [rbp-40h] BYREF
  _OWORD *v44; // [rsp+30h] [rbp-38h] BYREF

  v1 = *(__int128 **)a1;
  v3 = *(_QWORD *)(a1 + 24);
  v4 = v1;
  v5 = (__int128 *)((char *)v1 + v3 + 1);
  if ( v1 != v5 )
  {
    _XMM3 = 0;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm3, xmmword ptr [rcx]
        vpandn  xmm1, xmm0, xmm4
      }
      *v4++ = _XMM1 | xmmword_147F33270;
    }
    while ( v4 != v5 );
  }
  *v5 = *v1;
  *((_BYTE *)v1 + v3) = -1;
  v9 = 0;
  v10 = *(_QWORD *)(a1 + 24);
  if ( v10 )
  {
    v11 = 0xCBF29CE484222325uLL;
    v12 = 0;
    v13 = -16;
    do
    {
      if ( *(_BYTE *)(*(_QWORD *)a1 + v9) == 0xFE )
      {
        v14 = -1;
        v15 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + v12);
        do
        {
          ++v14;
        }
        while ( *(_BYTE *)(v15 + v14) );
        for ( i = 0; i < v14; v11 = 0x100000001B3LL * (v17 ^ v11) )
        {
          v17 = *(unsigned __int8 *)(i + v15);
          ++i;
        }
        v18 = *(_QWORD *)(a1 + 24);
        _XMM4 = XMM4;
        v20 = (__PAIR128__(v11, v11) * 0xDE5FB9D2630458E9uLL) >> 64;
        v21 = 0;
        v22 = v18 & (v20 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [rcx+r10]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v21 += 16;
          v22 = v18 & (v21 + v22);
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [rcx+r10]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v26, _EAX);
        v27 = v18 & (v20 >> 7);
        v28 = v18 & (v22 + v26);
        v29 = v20 & 0x7F;
        if ( (v18 & ((v9 - v27) ^ (v28 - v27)) & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
        {
          v30 = (_BYTE *)(*(_QWORD *)a1 + v28);
          v31 = v28 - 16;
          v32 = 16 * v28;
          v33 = *v30 == 0x80;
          *v30 = v29;
          *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (v31 & *(_QWORD *)(a1 + 24)) + *(_QWORD *)a1 + 1) = v29;
          if ( v33 )
          {
            v34 = *(_QWORD *)(a1 + 8);
            v35 = v34 + v12;
            v36 = v32 + v34;
            sub_1403577A0((_QWORD *)(v32 + v34), (__int64 *)(v34 + v12));
            sub_147219660((unsigned __int64 *)(v36 + 8), (_OWORD **)(v35 + 8));
            sub_1409310A0((unsigned __int64 *)(v35 + 8), 0, 0);
            DestroyStringObject((_QWORD *)v35);
            *(_BYTE *)(v9 + *(_QWORD *)a1) = 0x80;
            *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v13) + *(_QWORD *)a1 + 1) = 0x80;
          }
          else
          {
            v37 = v12 + *(_QWORD *)(a1 + 8);
            sub_1403577A0(&v43, (__int64 *)v37);
            sub_147219660((unsigned __int64 *)&v44, (_OWORD **)(v37 + 8));
            sub_1409310A0((unsigned __int64 *)(v37 + 8), 0, 0);
            DestroyStringObject((_QWORD *)v37);
            v38 = *(_QWORD *)(a1 + 8);
            v39 = v32 + v38;
            v40 = v38 + v12;
            sub_1403577A0((_QWORD *)(v38 + v12), (__int64 *)(v32 + v38));
            sub_147219660((unsigned __int64 *)(v40 + 8), (_OWORD **)(v39 + 8));
            sub_1409310A0((unsigned __int64 *)(v39 + 8), 0, 0);
            DestroyStringObject((_QWORD *)v39);
            v41 = (_QWORD *)(v32 + *(_QWORD *)(a1 + 8));
            sub_1403577A0(v41, &v43);
            sub_147219660(v41 + 1, &v44);
            sub_1409310A0((unsigned __int64 *)&v44, 0, 0);
            DestroyStringObject(&v43);
            --v9;
            v12 -= 16;
            --v13;
          }
        }
        else
        {
          *(_BYTE *)(*(_QWORD *)a1 + v9) = v29;
          *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v13) + *(_QWORD *)a1 + 1) = v29;
        }
        v11 = 0xCBF29CE484222325uLL;
      }
      v10 = *(_QWORD *)(a1 + 24);
      ++v9;
      v12 += 16;
      ++v13;
    }
    while ( v9 != v10 );
  }
  result = v10 >> 3;
  *(_QWORD *)(a1 + 48) = v10 - (v10 >> 3) - *(_QWORD *)(a1 + 16);
  return result;
}

// --- End Function: sub_14726A860 (0x14726A860) ---

// --- Function: sub_14726AC10 (0x14726AC10) ---
unsigned __int64 __fastcall sub_14726AC10(__int64 a1)
{
  __int128 *v1; // rdx
  __int64 v3; // r8
  __int128 *v4; // rcx
  __int128 *v5; // rax
  unsigned __int64 v9; // rcx
  __int64 v10; // r15
  __int64 v11; // rbp
  __int64 v12; // r12
  unsigned int n40503; // r8d
  char *v14; // r9
  char i; // al
  int v16; // edx
  __int128 _XMM4; // xmm1
  unsigned int v18; // eax
  __int64 v19; // r8
  unsigned __int128 v20; // rax
  __int64 v21; // rcx
  unsigned __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v27; // r14
  __int64 v28; // r14
  unsigned __int64 v29; // rdx
  char v30; // r9
  _BYTE *v31; // rax
  __int64 v32; // rdx
  __int64 v33; // r14
  bool v34; // zf
  __int64 v35; // rax
  __int64 v36; // rdi
  __int64 v37; // rbx
  __int64 v38; // rbx
  __int64 v39; // rax
  __int64 v40; // rdi
  __int64 v41; // rbx
  __int64 v42; // rbx
  unsigned __int64 result; // rax
  __int64 v44; // [rsp+28h] [rbp-50h] BYREF
  __int128 v45; // [rsp+30h] [rbp-48h]
  double v46; // [rsp+40h] [rbp-38h]

  v1 = *(__int128 **)a1;
  v3 = *(_QWORD *)(a1 + 24);
  v4 = v1;
  v5 = (__int128 *)((char *)v1 + v3 + 1);
  if ( v1 != v5 )
  {
    _XMM3 = 0;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm3, xmmword ptr [rcx]
        vpandn  xmm1, xmm0, xmm4
      }
      *v4++ = _XMM1 | xmmword_147F33270;
    }
    while ( v4 != v5 );
  }
  *v5 = *v1;
  *((_BYTE *)v1 + v3) = -1;
  v9 = *(_QWORD *)(a1 + 24);
  v10 = 0;
  if ( v9 )
  {
    v11 = -16;
    v12 = 0;
    do
    {
      if ( *(_BYTE *)(*(_QWORD *)a1 + v10) == 0xFE )
      {
        n40503 = 40503;
        v14 = *(char **)(v12 + *(_QWORD *)(a1 + 8));
        for ( i = *v14; *v14; i = *v14 )
        {
          ++v14;
          v16 = i + 32;
          if ( (unsigned __int8)(i - 65) > 0x19u )
          {
            v16 = i;
          }
          n40503 = ((1025 * (n40503 + v16)) >> 6) ^ (1025 * (n40503 + v16));
        }
        _XMM4 = XMM4;
        v18 = 9 * n40503;
        v19 = *(_QWORD *)(a1 + 24);
        v20 = 32769 * (v18 ^ (v18 >> 11)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
        v21 = 0;
        v22 = *((_QWORD *)&v20 + 1) + v20;
        v23 = v19 & ((*((_QWORD *)&v20 + 1) + (_QWORD)v20) >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [rdx+r10]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v21 += 16;
          v23 = v19 & (v21 + v23);
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [rdx+r10]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v27, _EAX);
        v28 = v19 & (v23 + v27);
        v29 = v19 & (v22 >> 7);
        v30 = v22 & 0x7F;
        if ( (v19 & ((v10 - v29) ^ (v28 - v29)) & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
        {
          v31 = (_BYTE *)(*(_QWORD *)a1 + v28);
          v32 = v28 - 16;
          v33 = 32 * v28;
          v34 = *v31 == 0x80;
          *v31 = v30;
          *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (v32 & *(_QWORD *)(a1 + 24)) + *(_QWORD *)a1 + 1) = v30;
          if ( v34 )
          {
            v35 = *(_QWORD *)(a1 + 8);
            v36 = v12 + v35;
            v37 = v35 + v33;
            sub_1403577A0((_QWORD *)(v35 + v33), (__int64 *)(v12 + v35));
            *(_OWORD *)(v37 + 8) = *(_OWORD *)(v36 + 8);
            *(double *)(v37 + 24) = *(double *)(v36 + 24);
            DestroyStringObject((_QWORD *)v36);
            *(_BYTE *)(v10 + *(_QWORD *)a1) = 0x80;
            *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v11) + *(_QWORD *)a1 + 1) = 0x80;
          }
          else
          {
            v38 = v12 + *(_QWORD *)(a1 + 8);
            sub_1403577A0(&v44, (__int64 *)v38);
            v45 = *(_OWORD *)(v38 + 8);
            v46 = *(double *)(v38 + 24);
            DestroyStringObject((_QWORD *)v38);
            v39 = *(_QWORD *)(a1 + 8);
            v40 = v33 + v39;
            v41 = v12 + v39;
            sub_1403577A0((_QWORD *)(v12 + v39), (__int64 *)(v33 + v39));
            *(_OWORD *)(v41 + 8) = *(_OWORD *)(v40 + 8);
            *(double *)(v41 + 24) = *(double *)(v40 + 24);
            DestroyStringObject((_QWORD *)v40);
            v42 = v33 + *(_QWORD *)(a1 + 8);
            sub_1403577A0((_QWORD *)v42, &v44);
            *(_OWORD *)(v42 + 8) = v45;
            *(double *)(v42 + 24) = v46;
            DestroyStringObject(&v44);
            --v10;
            --v11;
            v12 -= 32;
          }
        }
        else
        {
          *(_BYTE *)(*(_QWORD *)a1 + v10) = v30;
          *(_BYTE *)((*(_QWORD *)(a1 + 24) & 0xFLL) + (*(_QWORD *)(a1 + 24) & v11) + *(_QWORD *)a1 + 1) = v30;
        }
      }
      v9 = *(_QWORD *)(a1 + 24);
      ++v10;
      ++v11;
      v12 += 32;
    }
    while ( v10 != v9 );
  }
  result = v9 >> 3;
  *(_QWORD *)(a1 + 48) = v9 - (v9 >> 3) - *(_QWORD *)(a1 + 16);
  return result;
}

// --- End Function: sub_14726AC10 (0x14726AC10) ---

// --- Function: sub_14726AF80 (0x14726AF80) ---
unsigned __int64 __fastcall sub_14726AF80(__int64 pHashMap)
{
  __int128 *v1; // rdx
  __int64 v3; // r8
  __int128 *v4; // rcx
  __int128 *v5; // rax
  __int64 v9; // r14
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rbp
  __int64 v13; // r12
  __int128 *v14; // r10
  unsigned __int64 v15; // rcx
  __int64 v16; // r9
  unsigned __int64 i; // r8
  __int64 v18; // rax
  __int64 v19; // r9
  __int128 _XMM4; // xmm1
  unsigned __int64 v21; // r11
  __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  __int64 v27; // r8
  unsigned __int64 v28; // rdx
  __int64 v29; // r8
  char v30; // r11
  __int64 v31; // r15
  bool v32; // zf
  __int64 v33; // rax
  _QWORD *v34; // rdi
  __int64 v35; // rbx
  __int64 v36; // rbx
  __int64 v37; // rax
  _QWORD *v38; // rdi
  __int64 v39; // rbx
  _QWORD *v40; // rbx
  unsigned __int64 result; // rax
  __int64 v42; // [rsp+28h] [rbp-80h] BYREF
  _BYTE v43[56]; // [rsp+30h] [rbp-78h] BYREF
  unsigned __int64 v44; // [rsp+68h] [rbp-40h] BYREF

  v1 = *(__int128 **)pHashMap;
  v3 = *(_QWORD *)(pHashMap + 24);
  v4 = v1;
  v5 = (__int128 *)((char *)v1 + v3 + 1);
  if ( v1 != v5 )
  {
    _XMM3 = 0;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm3, xmmword ptr [rcx]
        vpandn  xmm1, xmm0, xmm4
      }
      *v4++ = _XMM1 | xmmword_147F33270;
    }
    while ( v4 != v5 );
  }
  *v5 = *v1;
  *((_BYTE *)v1 + v3) = -1;
  v9 = 0;
  v10 = *(_QWORD *)(pHashMap + 24);
  if ( v10 )
  {
    v11 = 0xCBF29CE484222325uLL;
    v12 = -16;
    v13 = 0;
    do
    {
      v14 = *(__int128 **)pHashMap;
      if ( *(_BYTE *)(*(_QWORD *)pHashMap + v9) == 0xFE )
      {
        v15 = -1;
        v16 = *(_QWORD *)(v13 + *(_QWORD *)(pHashMap + 8));
        do
        {
          ++v15;
        }
        while ( *(_BYTE *)(v16 + v15) );
        for ( i = 0; i < v15; v11 = 0x100000001B3LL * (v18 ^ v11) )
        {
          v18 = *(unsigned __int8 *)(i + v16);
          ++i;
        }
        v19 = *(_QWORD *)(pHashMap + 24);
        _XMM4 = XMM4;
        v21 = (__PAIR128__(v11, v11) * 0xDE5FB9D2630458E9uLL) >> 64;
        v22 = 0;
        v23 = v19 & (v21 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [rcx+r10]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v22 += 16;
          v23 = v19 & (v22 + v23);
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [rcx+r10]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v27, _EAX);
        v28 = v19 & (v21 >> 7);
        v29 = v19 & (v23 + v27);
        v30 = v21 & 0x7F;
        if ( (v19 & ((v9 - v28) ^ (v29 - v28)) & 0xFFFFFFFFFFFFFFF0uLL) != 0 )
        {
          v31 = 72 * v29;
          v32 = *((_BYTE *)v14 + v29) == 0x80;
          *((_BYTE *)v14 + v29) = v30;
          *(_BYTE *)((*(_QWORD *)(pHashMap + 24) & 0xFLL)
                   + ((v29 - 16) & *(_QWORD *)(pHashMap + 24))
                   + *(_QWORD *)pHashMap
                   + 1) = v30;
          if ( v32 )
          {
            v33 = *(_QWORD *)(pHashMap + 8);
            v34 = (_QWORD *)(v13 + v33);
            v35 = v31 + v33;
            sub_1403577A0((_QWORD *)(v31 + v33), (__int64 *)(v13 + v33));
            sub_14721B460(v35 + 8, (__int64)(v34 + 1));
            vector_dword_set_size(v34 + 8, 0, 0);
            DestroyStringObject(v34);
            *(_BYTE *)(v9 + *(_QWORD *)pHashMap) = 0x80;
            *(_BYTE *)((*(_QWORD *)(pHashMap + 24) & 0xFLL)
                     + (*(_QWORD *)(pHashMap + 24) & v12)
                     + *(_QWORD *)pHashMap
                     + 1) = 0x80;
          }
          else
          {
            v36 = v13 + *(_QWORD *)(pHashMap + 8);
            sub_1403577A0(&v42, (__int64 *)v36);
            sub_14721B460((__int64)v43, v36 + 8);
            vector_dword_set_size((unsigned __int64 *)(v36 + 64), 0, 0);
            DestroyStringObject((_QWORD *)v36);
            v37 = *(_QWORD *)(pHashMap + 8);
            v38 = (_QWORD *)(v31 + v37);
            v39 = v13 + v37;
            sub_1403577A0((_QWORD *)(v13 + v37), (__int64 *)(v31 + v37));
            sub_14721B460(v39 + 8, (__int64)(v38 + 1));
            vector_dword_set_size(v38 + 8, 0, 0);
            DestroyStringObject(v38);
            v40 = (_QWORD *)(v31 + *(_QWORD *)(pHashMap + 8));
            sub_1403577A0(v40, &v42);
            sub_14721B460((__int64)(v40 + 1), (__int64)v43);
            vector_dword_set_size(&v44, 0, 0);
            DestroyStringObject(&v42);
            --v9;
            v13 -= 72;
            --v12;
          }
        }
        else
        {
          *(_BYTE *)(*(_QWORD *)pHashMap + v9) = v30;
          *(_BYTE *)((*(_QWORD *)(pHashMap + 24) & 0xFLL) + (*(_QWORD *)(pHashMap + 24) & v12) + *(_QWORD *)pHashMap + 1) = v30;
        }
        v11 = 0xCBF29CE484222325uLL;
      }
      v10 = *(_QWORD *)(pHashMap + 24);
      ++v9;
      v13 += 72;
      ++v12;
    }
    while ( v9 != v10 );
  }
  result = v10 >> 3;
  *(_QWORD *)(pHashMap + 48) = v10 - (v10 >> 3) - *(_QWORD *)(pHashMap + 16);
  return result;
}

// --- End Function: sub_14726AF80 (0x14726AF80) ---

// --- Function: sub_14726B3A0 (0x14726B3A0) ---
char **__fastcall sub_14726B3A0(_QWORD *a1, char **a2, _OWORD *a3)
{
  char *v6; // rdx
  char *v7; // r8
  __int128 _XMM4; // xmm1
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v15; // r11
  int v19; // r8d
  bool v20; // zf
  int v21; // edx
  int v22; // eax
  bool v23; // al
  char v24; // r8
  __int64 v25; // rcx
  char **result; // rax

  *(_OWORD *)a2 = *a3;
  v6 = *a2 + 1;
  v7 = a2[1] + 24;
  *a2 = v6;
  a2[1] = v7;
  if ( *v6 < -1 )
  {
    _XMM4 = XMM4;
    do
    {
      __asm
      {
        vpcmpgtb xmm0, xmm1, xmmword ptr [rdx]
        vpmovmskb eax, xmm0
      }
      _BitScanForward((unsigned int *)&v11, _EAX + 1);
      v6 += (unsigned int)v11;
      *a2 = v6;
      v7 += 24 * v11;
      a2[1] = v7;
    }
    while ( *v6 < -1 );
  }
  v12 = *(_QWORD *)a3;
  --a1[2];
  _XMM2 = xmmword_147F33270;
  __asm { vpcmpeqb xmm1, xmm2, xmmword ptr [rax] }
  v15 = v12 - *a1;
  __asm { vpmovmskb eax, xmm1 }
  __asm
  {
    vpcmpeqb xmm1, xmm2, xmmword ptr [rcx+rbx]
    vpmovmskb ecx, xmm1
  }
  v23 = 0;
  if ( _ECX && _EAX )
  {
    _BitScanForward((unsigned int *)&v19, _EAX);
    v20 = !_BitScanReverse((unsigned int *)&v21, _ECX << 16);
    v22 = v20 ? 32 : 31 - v21;
    if ( (unsigned int)(v19 + v22) < 0x10 )
    {
      v23 = 1;
    }
  }
  v24 = -2;
  if ( v23 )
  {
    v24 = 0x80;
  }
  *(_BYTE *)(*a1 + v15) = v24;
  *(_BYTE *)((a1[3] & 0xFLL) + ((v15 - 16) & a1[3]) + *a1 + 1) = v24;
  v25 = v23;
  result = a2;
  a1[6] += v25;
  return result;
}

// --- End Function: sub_14726B3A0 (0x14726B3A0) ---

// --- Function: sub_14726BAD0 (0x14726BAD0) ---
__int64 __fastcall sub_14726BAD0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  unsigned __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = XMM4;
  v4 = 0LL;
  v5 = a2 >> 7;
  v6 = 0LL;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 16LL;
    v9 = (v9 + v6) & v7;
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = (v9 + v13) & v7;
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_14726A540((__int64)a1);
LABEL_11:
        v18 = a1[3];
        v19 = 0LL;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 16LL;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = (_RAX + v20) & v18;
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1LL;
    }
    sub_14726C350(a1, v17);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_14726BAD0 (0x14726BAD0) ---

// --- Function: sub_14726BC00 (0x14726BC00) ---
__int64 __fastcall sub_14726BC00(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  unsigned __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = XMM4;
  v4 = 0LL;
  v5 = a2 >> 7;
  v6 = 0LL;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 16LL;
    v9 = (v9 + v6) & v7;
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = (v9 + v13) & v7;
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_14726A860((__int64)a1);
LABEL_11:
        v18 = a1[3];
        v19 = 0LL;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 16LL;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = (_RAX + v20) & v18;
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1LL;
    }
    sub_14726C500(a1, v17);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_14726BC00 (0x14726BC00) ---

// --- Function: sub_14726BD30 (0x14726BD30) ---
__int64 __fastcall sub_14726BD30(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  unsigned __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = XMM4;
  v4 = 0LL;
  v5 = a2 >> 7;
  v6 = 0LL;
  v7 = a1[3];
  v8 = *a1;
  v9 = v7 & (a2 >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 16LL;
    v9 = (v9 + v6) & v7;
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = (v9 + v13) & v7;
  v15 = v14;
  v16 = v14;
  if ( !a1[6] && *(_BYTE *)(*a1 + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( a1[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_14726AC10((__int64)a1);
LABEL_11:
        v18 = a1[3];
        v19 = 0LL;
        v8 = *a1;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 16LL;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = (_RAX + v20) & v18;
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1LL;
    }
    sub_14726C710(a1, v17);
    goto LABEL_11;
  }
LABEL_14:
  ++a1[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  a1[6] -= v4;
  return result;
}

// --- End Function: sub_14726BD30 (0x14726BD30) ---

// --- Function: sub_14726BE60 (0x14726BE60) ---
__int64 __fastcall sub_14726BE60(__int64 *pHashMap, unsigned __int64 derivedHash)
{
  __int64 v4; // rsi
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  __int64 v13; // r10
  unsigned __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rcx
  unsigned __int64 v20; // rbx
  bool v24; // zf
  __int64 result; // rax

  _XMM6 = XMM4;
  v4 = 0LL;
  v5 = derivedHash >> 7;
  v6 = 0LL;
  v7 = pHashMap[3];
  v8 = *pHashMap;
  v9 = v7 & (derivedHash >> 7);
  __asm
  {
    vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
    vpmovmskb eax, xmm0
  }
  while ( !_EAX )
  {
    v6 += 16LL;
    v9 = (v9 + v6) & v7;
    __asm
    {
      vpcmpgtb xmm0, xmm6, xmmword ptr [r11+rdx]
      vpmovmskb eax, xmm0
    }
  }
  _BitScanForward((unsigned int *)&v13, _EAX);
  v14 = (v9 + v13) & v7;
  v15 = v14;
  v16 = v14;
  if ( !pHashMap[6] && *(_BYTE *)(*pHashMap + v14) != 0xFE )
  {
    if ( v7 )
    {
      if ( pHashMap[2] <= (v7 - (v7 >> 3)) >> 1 )
      {
        sub_14726AF80((__int64)pHashMap);
LABEL_11:
        v18 = pHashMap[3];
        v19 = 0LL;
        v8 = *pHashMap;
        v20 = v18 & v5;
        __asm
        {
          vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
          vpmovmskb eax, xmm0
        }
        while ( !(_DWORD)_RAX )
        {
          v19 += 16LL;
          v20 = v18 & (v19 + v20);
          __asm
          {
            vpcmpgtb xmm0, xmm6, xmmword ptr [r8+rbx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&_RAX, _RAX);
        v15 = (_RAX + v20) & v18;
        v16 = v15;
        goto LABEL_14;
      }
      v17 = 2 * v7 + 1;
    }
    else
    {
      v17 = 1LL;
    }
    sub_14726C910((__int64)pHashMap, v17);
    goto LABEL_11;
  }
LABEL_14:
  ++pHashMap[2];
  v24 = *(_BYTE *)(v15 + v8) == 0x80;
  result = v16;
  LOBYTE(v4) = v24;
  pHashMap[6] -= v4;
  return result;
}

// --- End Function: sub_14726BE60 (0x14726BE60) ---

// --- Function: sub_14726BF90 (0x14726BF90) ---
void __fastcall sub_14726BF90(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rax
  bool v5; // cf
  unsigned __int64 n0x6400000; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rdx
  _QWORD *v9; // rax

  *(_QWORD *)(a1 + 24) = a2;
  v2 = a2;
  *(_QWORD *)(a1 + 32) = a2;
  if ( a2 )
  {
    v4 = 16 * a2;
    if ( !is_mul_ok(a2, 0x10u) )
    {
      v4 = -1;
    }
    v5 = __CFADD__(v4, 8);
    n0x6400000 = v4 + 8;
    if ( v5 )
    {
      n0x6400000 = -1;
    }
    v7 = (_QWORD *)sub_1402A1E30(n0x6400000);
    if ( v7 )
    {
      v8 = v7 + 1;
      *v7 = v2;
      v9 = v7 + 1;
      do
      {
        *v9 = 0;
        *((_BYTE *)v9 + 8) = 0;
        v9 += 2;
        --v2;
      }
      while ( v2 );
      *(_QWORD *)(a1 + 16) = v8;
      *(_BYTE *)(a1 + 8) = 1;
    }
    else
    {
      *(_QWORD *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 8) = 1;
    }
  }
}

// --- End Function: sub_14726BF90 (0x14726BF90) ---

// --- Function: sub_14726C030 (0x14726C030) ---
void __fastcall sub_14726C030(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rax
  __int64 v5; // rbp
  _QWORD *v6; // rdi

  *(_QWORD *)(a1 + 24) = a2;
  v2 = a2;
  *(_QWORD *)(a1 + 32) = a2;
  if ( a2 )
  {
    v4 = sub_1402A1E30(saturated_mul(a2, 0x18uLL));
    v5 = v4;
    if ( v4 )
    {
      v6 = (_QWORD *)v4;
      do
      {
        initialize_vector_empty(v6);
        v6 += 3;
        --v2;
      }
      while ( v2 );
    }
    else
    {
      v5 = 0LL;
    }
    *(_QWORD *)(a1 + 16) = v5;
    *(_BYTE *)(a1 + 8) = 1;
  }
}

// --- End Function: sub_14726C030 (0x14726C030) ---

// --- Function: sub_14726C0C0 (0x14726C0C0) ---
void __fastcall sub_14726C0C0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rax
  bool v5; // cf
  unsigned __int64 n0x6400000; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rbp
  __int64 v9; // rdi

  *(_QWORD *)(a1 + 24) = a2;
  v2 = a2;
  *(_QWORD *)(a1 + 32) = a2;
  if ( a2 )
  {
    v4 = 16 * a2;
    if ( !is_mul_ok(a2, 0x10u) )
    {
      v4 = -1;
    }
    v5 = __CFADD__(v4, 8);
    n0x6400000 = v4 + 8;
    if ( v5 )
    {
      n0x6400000 = -1;
    }
    v7 = (_QWORD *)sub_1402A1E30(n0x6400000);
    if ( v7 )
    {
      v8 = v7 + 1;
      v9 = (__int64)(v7 + 1);
      *v7 = v2;
      do
      {
        sub_14035F240(v9);
        v9 += 16;
        --v2;
      }
      while ( v2 );
    }
    else
    {
      v8 = 0;
    }
    *(_QWORD *)(a1 + 16) = v8;
    *(_BYTE *)(a1 + 8) = 1;
  }
}

// --- End Function: sub_14726C0C0 (0x14726C0C0) ---

// --- Function: sub_14726C160 (0x14726C160) ---
void __fastcall sub_14726C160(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rax
  bool v5; // cf
  unsigned __int64 n0x6400000; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rbp
  _QWORD *v9; // rdi

  *(_QWORD *)(a1 + 24) = a2;
  v2 = a2;
  *(_QWORD *)(a1 + 32) = a2;
  if ( a2 )
  {
    v4 = 8 * a2;
    if ( !is_mul_ok(a2, 8u) )
    {
      v4 = -1;
    }
    v5 = __CFADD__(v4, 8);
    n0x6400000 = v4 + 8;
    if ( v5 )
    {
      n0x6400000 = -1;
    }
    v7 = (_QWORD *)sub_1402A1E30(n0x6400000);
    if ( v7 )
    {
      v8 = v7 + 1;
      v9 = v7 + 1;
      *v7 = v2;
      do
      {
        initializeEmptyStringStructure(v9++);
        --v2;
      }
      while ( v2 );
    }
    else
    {
      v8 = 0;
    }
    *(_QWORD *)(a1 + 16) = v8;
    *(_BYTE *)(a1 + 8) = 1;
  }
}

// --- End Function: sub_14726C160 (0x14726C160) ---

// --- Function: sub_14726C350 (0x14726C350) ---
unsigned __int64 __fastcall sub_14726C350(const void **a1, unsigned __int64 a2)
{
  char *v2; // rbp
  __int64 v3; // r12
  __int64 v4; // r14
  unsigned __int64 v7; // rbx
  char *v8; // rax
  __int64 v9; // rbx
  unsigned __int64 result; // rax
  __int64 v11; // rdi
  int v12; // eax
  __int64 v13; // r9
  unsigned __int64 v15; // r11
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v21; // r8
  char v22; // r11
  __int64 v23; // r8
  __int64 v24; // rax
  __int64 v25; // rdx

  v2 = (char *)*a1;
  v3 = (__int64)a1[1];
  v4 = (__int64)a1[3];
  v7 = (a2 + 24) & 0xFFFFFFFFFFFFFFF8uLL;
  v8 = (char *)sub_1402A1E30(v7 + 24 * a2);
  *a1 = v8;
  a1[1] = &v8[v7];
  memset(v8, -128, a2 + 16);
  v9 = 0LL;
  *((_BYTE *)*a1 + a2) = -1;
  result = a2 >> 3;
  a1[3] = (const void *)a2;
  a1[6] = (const void *)(a2 - (a2 >> 3) - (_QWORD)a1[2]);
  if ( v4 )
  {
    do
    {
      if ( v2[v9] >= 0 )
      {
        v11 = v3 + 24 * v9;
        v12 = psub_1403339F0(0xFFFFFFFF, v11, 16LL);
        v13 = (__int64)a1[3];
        _XMM1 = XMM4;
        v15 = (__PAIR128__((unsigned int)~v12, (unsigned int)~v12) * 0xDE5FB9D2630458E9uLL) >> 64;
        v16 = 0LL;
        v17 = v13 & (v15 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r10+rcx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v16 += 16LL;
          v17 = (v16 + v17) & v13;
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r10+rcx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v21, _EAX);
        v22 = v15 & 0x7F;
        v23 = (v17 + v21) & v13;
        *((_BYTE *)*a1 + v23) = v22;
        *((_BYTE *)*a1 + ((unsigned __int64)a1[3] & 0xF) + ((unsigned __int64)a1[3] & (v23 - 16)) + 1) = v22;
        v24 = (__int64)a1[1];
        v25 = 3 * v23 + 2;
        *(_OWORD *)(v24 + 8 * v25 - 16) = *(_OWORD *)v11;
        sub_1403577A0((_QWORD *)(v24 + 8 * v25), (__int64 *)(v11 + 16));
        DestroyStringObject((_QWORD *)(v11 + 16));
      }
      ++v9;
    }
    while ( v9 != v4 );
    return free_memory_wrapper(v2);
  }
  return result;
}

// --- End Function: sub_14726C350 (0x14726C350) ---

// --- Function: sub_14726C500 (0x14726C500) ---
unsigned __int64 __fastcall sub_14726C500(const void **a1, unsigned __int64 a2)
{
  char *v2; // rbp
  __int64 v3; // rsi
  __int64 v5; // r12
  unsigned __int64 v7; // rbx
  char *v8; // rax
  unsigned __int64 result; // rax
  __int64 v10; // rcx
  __int64 v11; // rdi
  __int64 v12; // r9
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r8
  __int64 i; // rdx
  __int64 v16; // rax
  __int64 v17; // r8
  unsigned __int64 v19; // r10
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v25; // rbx
  char v26; // r10
  __int64 v27; // rbx
  _QWORD *v28; // rbx

  v2 = (char *)*a1;
  v3 = (__int64)a1[1];
  v5 = (__int64)a1[3];
  v7 = (a2 + 24) & 0xFFFFFFFFFFFFFFF8uLL;
  v8 = (char *)sub_1402A1E30(v7 + 16 * a2);
  *a1 = v8;
  a1[1] = &v8[v7];
  memset(v8, -128, a2 + 16);
  *((_BYTE *)*a1 + a2) = -1;
  result = a2 >> 3;
  a1[3] = (const void *)a2;
  v10 = a2 - (a2 >> 3) - (_QWORD)a1[2];
  v11 = 0LL;
  a1[6] = (const void *)v10;
  if ( v5 )
  {
    do
    {
      if ( v2[v11] >= 0 )
      {
        v12 = *(_QWORD *)v3;
        v13 = -1LL;
        do
        {
          ++v13;
        }
        while ( *(_BYTE *)(v12 + v13) );
        v14 = 0LL;
        for ( i = 0xCBF29CE484222325uLL; v14 < v13; i = 0x100000001B3LL * (v16 ^ i) )
        {
          v16 = *(unsigned __int8 *)(v14 + v12);
          ++v14;
        }
        v17 = (__int64)a1[3];
        _XMM1 = XMM4;
        v19 = (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 64;
        v20 = 0LL;
        v21 = v17 & (v19 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r9+rcx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v20 += 16LL;
          v21 = (v20 + v21) & v17;
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r9+rcx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v25, _EAX);
        v26 = v19 & 0x7F;
        v27 = (v21 + v25) & v17;
        *((_BYTE *)*a1 + v27) = v26;
        *((_BYTE *)*a1 + ((unsigned __int64)a1[3] & 0xF) + ((unsigned __int64)a1[3] & (v27 - 16)) + 1) = v26;
        v28 = (char *)a1[1] + 16 * v27;
        sub_1403577A0(v28, (__int64 *)v3);
        sub_147219660(v28 + 1, (_OWORD **)(v3 + 8));
        sub_1409310A0((unsigned __int64 *)(v3 + 8), 0, 0);
        DestroyStringObject((_QWORD *)v3);
      }
      ++v11;
      v3 += 16LL;
    }
    while ( v11 != v5 );
    return free_memory_wrapper(v2);
  }
  return result;
}

// --- End Function: sub_14726C500 (0x14726C500) ---

// --- Function: sub_14726C710 (0x14726C710) ---
void __fastcall sub_14726C710(const void **a1, unsigned __int64 a2)
{
  _BYTE *ptr_to_free; // rbp
  char **v3; // rsi
  const void *v5; // r15
  unsigned __int64 v7; // rbx
  char *v8; // rax
  const void *v9; // rcx
  const void *v10; // rdi
  char *v11; // r9
  unsigned int n40503; // r8d
  char v13; // al
  int v14; // edx
  unsigned int v15; // eax
  unsigned __int64 v16; // r8
  __int128 _XMM4; // xmm1
  unsigned __int128 v18; // rax
  __int64 v19; // rcx
  char v20; // r10
  unsigned __int64 v21; // rdx
  __int64 v25; // rbx
  char v26; // r10
  unsigned __int64 v27; // rbx
  char *v28; // rbx

  ptr_to_free = *a1;
  v3 = (char **)a1[1];
  v5 = a1[3];
  v7 = (a2 + 24) & 0xFFFFFFFFFFFFFFF8uLL;
  v8 = (char *)sub_1402A1E30(v7 + 32 * a2);
  *a1 = v8;
  a1[1] = &v8[v7];
  memset(v8, -128, a2 + 16);
  *((_BYTE *)*a1 + a2) = -1;
  a1[3] = (const void *)a2;
  v9 = (const void *)(a2 - (a2 >> 3) - (_QWORD)a1[2]);
  v10 = 0;
  a1[6] = v9;
  if ( v5 )
  {
    do
    {
      if ( (char)ptr_to_free[(_QWORD)v10] >= 0 )
      {
        v11 = *v3;
        n40503 = 40503;
        v13 = **v3;
        if ( v13 )
        {
          do
          {
            ++v11;
            v14 = v13 + 32;
            if ( (unsigned __int8)(v13 - 65) > 0x19u )
            {
              v14 = v13;
            }
            n40503 = ((1025 * (n40503 + v14)) >> 6) ^ (1025 * (n40503 + v14));
            v13 = *v11;
          }
          while ( *v11 );
        }
        v15 = 9 * n40503;
        v16 = (unsigned __int64)a1[3];
        _XMM4 = XMM4;
        v18 = 32769 * (v15 ^ (v15 >> 11)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
        v19 = 0;
        v20 = BYTE8(v18) + v18;
        v21 = v16 & ((*((_QWORD *)&v18 + 1) + (_QWORD)v18) >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r9+rdx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v19 += 16;
          v21 = v16 & (v19 + v21);
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r9+rdx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v25, _EAX);
        v26 = v20 & 0x7F;
        v27 = v16 & (v21 + v25);
        *((_BYTE *)*a1 + v27) = v26;
        *((_BYTE *)*a1 + ((unsigned __int64)a1[3] & 0xF) + ((unsigned __int64)a1[3] & (v27 - 16)) + 1) = v26;
        v28 = (char *)a1[1] + 32 * v27;
        sub_1403577A0(v28, (__int64 *)v3);
        *(_OWORD *)(v28 + 8) = *(_OWORD *)(v3 + 1);
        *((double *)v28 + 3) = *((double *)v3 + 3);
        DestroyStringObject(v3);
      }
      v10 = (char *)v10 + 1;
      v3 += 4;
    }
    while ( v10 != v5 );
    free_memory_wrapper(ptr_to_free);
  }
}

// --- End Function: sub_14726C710 (0x14726C710) ---

// --- Function: sub_14726C910 (0x14726C910) ---
unsigned __int64 __fastcall sub_14726C910(__int64 pHashMap, unsigned __int64 a2)
{
  char *v2; // rbp
  __int64 v3; // r14
  __int64 v4; // r12
  unsigned __int64 v7; // rbx
  char *v8; // rax
  __int64 v9; // rsi
  unsigned __int64 result; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // r8
  __int64 i; // rdx
  __int64 v15; // rax
  __int64 v16; // r9
  unsigned __int64 v18; // r11
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  __int64 v24; // r8
  char v25; // r11
  __int64 v26; // r8
  _QWORD *v27; // rdi

  v2 = *(char **)pHashMap;
  v3 = *(_QWORD *)(pHashMap + 8);
  v4 = *(_QWORD *)(pHashMap + 24);
  v7 = (a2 + 24) & 0xFFFFFFFFFFFFFFF8uLL;
  v8 = (char *)sub_1402A1E30(v7 + 72 * a2);
  *(_QWORD *)pHashMap = v8;
  *(_QWORD *)(pHashMap + 8) = &v8[v7];
  memset(v8, -128, a2 + 16);
  v9 = 0LL;
  *(_BYTE *)(a2 + *(_QWORD *)pHashMap) = -1;
  result = a2 >> 3;
  *(_QWORD *)(pHashMap + 24) = a2;
  *(_QWORD *)(pHashMap + 48) = a2 - (a2 >> 3) - *(_QWORD *)(pHashMap + 16);
  if ( v4 )
  {
    do
    {
      if ( v2[v9] >= 0 )
      {
        v11 = *(_QWORD *)v3;
        v12 = -1LL;
        do
        {
          ++v12;
        }
        while ( *(_BYTE *)(v11 + v12) );
        v13 = 0LL;
        for ( i = 0xCBF29CE484222325uLL; v13 < v12; i = 0x100000001B3LL * (v15 ^ i) )
        {
          v15 = *(unsigned __int8 *)(v13 + v11);
          ++v13;
        }
        v16 = *(_QWORD *)(pHashMap + 24);
        _XMM1 = XMM4;
        v18 = (__PAIR128__(i, i) * 0xDE5FB9D2630458E9uLL) >> 64;
        v19 = 0LL;
        v20 = v16 & (v18 >> 7);
        __asm
        {
          vpcmpgtb xmm0, xmm1, xmmword ptr [r10+rcx]
          vpmovmskb eax, xmm0
        }
        while ( !_EAX )
        {
          v19 += 16LL;
          v20 = (v19 + v20) & v16;
          __asm
          {
            vpcmpgtb xmm0, xmm1, xmmword ptr [r10+rcx]
            vpmovmskb eax, xmm0
          }
        }
        _BitScanForward((unsigned int *)&v24, _EAX);
        v25 = v18 & 0x7F;
        v26 = (v20 + v24) & v16;
        *(_BYTE *)(*(_QWORD *)pHashMap + v26) = v25;
        *(_BYTE *)((*(_QWORD *)(pHashMap + 24) & 0xFLL)
                 + (*(_QWORD *)(pHashMap + 24) & (v26 - 16))
                 + *(_QWORD *)pHashMap
                 + 1) = v25;
        v27 = (_QWORD *)(*(_QWORD *)(pHashMap + 8) + 72 * v26);
        sub_1403577A0(v27, (__int64 *)v3);
        sub_14721B460((__int64)(v27 + 1), v3 + 8);
        vector_dword_set_size((unsigned __int64 *)(v3 + 64), 0, 0);
        DestroyStringObject((_QWORD *)v3);
      }
      ++v9;
      v3 += 72LL;
    }
    while ( v9 != v4 );
    return free_memory_wrapper(v2);
  }
  return result;
}

// --- End Function: sub_14726C910 (0x14726C910) ---

// --- Function: sub_14726CB20 (0x14726CB20) ---
void __fastcall sub_14726CB20(__int64 a1, unsigned __int64 n0x6400000)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  unsigned __int64 n0x6400000_1; // rcx
  __int64 v7; // rax
  __int64 v8; // rdi
  _BYTE *ptr_to_free; // rcx
  _BYTE *v10; // rdx

  if ( n0x6400000 <= *(_QWORD *)(a1 + 32) )
  {
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
  else
  {
    v4 = ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
       | ((unsigned int)(n0x6400000 - 1) >> 1)
       | (n0x6400000 - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    n0x6400000_1 = (v5 | HIWORD(v5)) + 1;
    *(_QWORD *)(a1 + 32) = (unsigned int)n0x6400000_1;
    v7 = sub_1402A1E30(n0x6400000_1);
    v8 = v7;
    ptr_to_free = *(_BYTE **)(a1 + 16);
    if ( *(_QWORD *)(a1 + 24) )
    {
      v10 = (_BYTE *)v7;
      do
      {
        *v10 = ptr_to_free[(_QWORD)v10 - v7];
        ++v10;
      }
      while ( (unsigned __int64)&v10[-v7] < *(_QWORD *)(a1 + 24) );
    }
    if ( *(_BYTE *)(a1 + 8) )
    {
      free_memory_wrapper(ptr_to_free);
    }
    *(_QWORD *)(a1 + 16) = v8;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
}

// --- End Function: sub_14726CB20 (0x14726CB20) ---

// --- Function: sub_14726CBF0 (0x14726CBF0) ---
void __fastcall sub_14726CBF0(__int64 a1, unsigned __int64 n0x6400000)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  __int64 v6; // rax
  char *ptr_to_free; // rcx
  unsigned __int64 v8; // r8
  __int64 v9; // rsi
  _WORD *v10; // rdx

  if ( n0x6400000 <= *(_QWORD *)(a1 + 32) )
  {
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
  else
  {
    v4 = ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
       | ((unsigned int)(n0x6400000 - 1) >> 1)
       | (n0x6400000 - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    *(_QWORD *)(a1 + 32) = (v5 | HIWORD(v5)) + 1;
    v6 = sub_1402A1E30(saturated_mul((v5 | HIWORD(v5)) + 1, 2u));
    ptr_to_free = *(char **)(a1 + 16);
    v8 = 0;
    v9 = v6;
    if ( *(_QWORD *)(a1 + 24) )
    {
      v10 = (_WORD *)v6;
      do
      {
        ++v8;
        *v10 = *(_WORD *)&ptr_to_free[(_QWORD)v10 - v6];
        ++v10;
      }
      while ( v8 < *(_QWORD *)(a1 + 24) );
    }
    if ( *(_BYTE *)(a1 + 8) )
    {
      free_memory_wrapper(ptr_to_free);
    }
    *(_QWORD *)(a1 + 16) = v9;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
}

// --- End Function: sub_14726CBF0 (0x14726CBF0) ---

// --- Function: sub_14726CCD0 (0x14726CCD0) ---
void __fastcall sub_14726CCD0(__int64 a1, unsigned __int64 n0x6400000)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  __int64 v6; // rax
  char *ptr_to_free; // rcx
  unsigned __int64 v8; // r8
  __int64 v9; // rsi
  _DWORD *v10; // rdx

  if ( n0x6400000 <= *(_QWORD *)(a1 + 32) )
  {
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
  else
  {
    v4 = ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
       | ((unsigned int)(n0x6400000 - 1) >> 1)
       | (n0x6400000 - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    *(_QWORD *)(a1 + 32) = (v5 | HIWORD(v5)) + 1;
    v6 = sub_1402A1E30(saturated_mul((v5 | HIWORD(v5)) + 1, 4u));
    ptr_to_free = *(char **)(a1 + 16);
    v8 = 0;
    v9 = v6;
    if ( *(_QWORD *)(a1 + 24) )
    {
      v10 = (_DWORD *)v6;
      do
      {
        ++v8;
        *v10 = *(_DWORD *)&ptr_to_free[(_QWORD)v10 - v6];
        ++v10;
      }
      while ( v8 < *(_QWORD *)(a1 + 24) );
    }
    if ( *(_BYTE *)(a1 + 8) )
    {
      free_memory_wrapper(ptr_to_free);
    }
    *(_QWORD *)(a1 + 16) = v9;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
}

// --- End Function: sub_14726CCD0 (0x14726CCD0) ---

// --- Function: sub_14726CDB0 (0x14726CDB0) ---
void __fastcall sub_14726CDB0(__int64 a1, unsigned __int64 n0x6400000)
{
  unsigned int v4; // r8d
  unsigned int v5; // r8d
  unsigned __int64 v6; // rdi
  __int64 v7; // rax
  bool v8; // cf
  unsigned __int64 n0x6400000_1; // rax
  _QWORD *v10; // rax
  unsigned __int64 v11; // rbx
  _QWORD *v12; // rbp
  _QWORD *i; // rax
  __int64 v14; // r15
  __int64 v15; // rdi
  __int64 v16; // rdi
  __int64 j; // rbx

  if ( n0x6400000 <= *(_QWORD *)(a1 + 32) )
  {
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
  else
  {
    v4 = ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
       | ((unsigned int)(n0x6400000 - 1) >> 1)
       | (n0x6400000 - 1);
    v5 = (((v4 >> 4) | v4) >> 8) | (v4 >> 4) | v4;
    v6 = (v5 | HIWORD(v5)) + 1;
    v7 = 16 * v6;
    *(_QWORD *)(a1 + 32) = v6;
    if ( !is_mul_ok(v6, 0x10u) )
    {
      v7 = -1;
    }
    v8 = __CFADD__(v7, 8);
    n0x6400000_1 = v7 + 8;
    if ( v8 )
    {
      n0x6400000_1 = -1;
    }
    v10 = (_QWORD *)sub_1402A1E30(n0x6400000_1);
    v11 = 0;
    if ( v10 )
    {
      *v10 = v6;
      v12 = v10 + 1;
      for ( i = v10 + 1; v6; --v6 )
      {
        *i = 0;
        *((_BYTE *)i + 8) = 0;
        i += 2;
      }
    }
    else
    {
      v12 = 0;
    }
    v14 = *(_QWORD *)(a1 + 16);
    if ( *(_QWORD *)(a1 + 24) )
    {
      v15 = (__int64)v12;
      do
      {
        sub_140376300(v15, (ULONG_PTR **)(v14 - (_QWORD)v12 + v15));
        ++v11;
        v15 += 16;
      }
      while ( v11 < *(_QWORD *)(a1 + 24) );
    }
    if ( *(_BYTE *)(a1 + 8) && v14 )
    {
      v16 = *(_QWORD *)(v14 - 8);
      for ( j = v14 + 16 * v16; v16; --v16 )
      {
        j -= 16;
        sub_14036F160(j);
      }
      free_memory_wrapper((const void *)(v14 - 8));
    }
    *(_QWORD *)(a1 + 16) = v12;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
}

// --- End Function: sub_14726CDB0 (0x14726CDB0) ---

// --- Function: sub_14726CF20 (0x14726CF20) ---
void __fastcall sub_14726CF20(__int64 a1, unsigned __int64 n0x6400000)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  bool v6; // cf
  unsigned __int64 n0x6400000_1; // rax
  _QWORD *v8; // rax
  unsigned __int64 v9; // rbp
  void **v10; // r14
  _QWORD *i; // rdi
  __int64 v12; // r15
  void **v13; // rbx
  __int64 v14; // rbx
  _QWORD *j; // rdi

  if ( n0x6400000 <= *(_QWORD *)(a1 + 32) )
  {
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
  else
  {
    v4 = (((((((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
            | ((unsigned int)(n0x6400000 - 1) >> 1)
            | ((_DWORD)n0x6400000 - 1)) >> 4)
          | ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
          | ((unsigned int)(n0x6400000 - 1) >> 1)
          | ((_DWORD)n0x6400000 - 1)) >> 8)
        | ((((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
          | ((unsigned int)(n0x6400000 - 1) >> 1)
          | ((_DWORD)n0x6400000 - 1)) >> 4)
        | ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
        | ((unsigned int)(n0x6400000 - 1) >> 1)
        | ((_DWORD)n0x6400000 - 1)
        | ((((((((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
              | ((unsigned int)(n0x6400000 - 1) >> 1)
              | ((_DWORD)n0x6400000 - 1)) >> 4)
            | ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
            | ((unsigned int)(n0x6400000 - 1) >> 1)
            | ((_DWORD)n0x6400000 - 1)) >> 8)
          | ((((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
            | ((unsigned int)(n0x6400000 - 1) >> 1)
            | ((_DWORD)n0x6400000 - 1)) >> 4)
          | ((((unsigned int)(n0x6400000 - 1) >> 1) | ((_DWORD)n0x6400000 - 1)) >> 2)
          | ((unsigned int)(n0x6400000 - 1) >> 1)
          | ((_DWORD)n0x6400000 - 1)) >> 16))
       + 1;
    v5 = 8 * v4;
    *(_QWORD *)(a1 + 32) = v4;
    if ( !is_mul_ok(v4, 8u) )
    {
      v5 = -1;
    }
    v6 = __CFADD__(v5, 8);
    n0x6400000_1 = v5 + 8;
    if ( v6 )
    {
      n0x6400000_1 = -1;
    }
    v8 = (_QWORD *)sub_1402A1E30(n0x6400000_1);
    v9 = 0;
    if ( v8 )
    {
      *v8 = v4;
      v10 = (void **)(v8 + 1);
      for ( i = v8 + 1; v4; --v4 )
      {
        initializeEmptyStringStructure(i++);
      }
    }
    else
    {
      v10 = 0;
    }
    v12 = *(_QWORD *)(a1 + 16);
    if ( *(_QWORD *)(a1 + 24) )
    {
      v13 = v10;
      do
      {
        copyStringStructure(v13, (const void **)((char *)v13 + v12 - (_QWORD)v10));
        ++v9;
        ++v13;
      }
      while ( v9 < *(_QWORD *)(a1 + 24) );
    }
    if ( *(_BYTE *)(a1 + 8) && v12 )
    {
      v14 = *(_QWORD *)(v12 - 8);
      for ( j = (_QWORD *)(v12 + 8 * v14); v14; --v14 )
      {
        DestroyStringObject(--j);
      }
      free_memory_wrapper((const void *)(v12 - 8));
    }
    *(_QWORD *)(a1 + 16) = v10;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)(a1 + 24) = n0x6400000;
  }
}

// --- End Function: sub_14726CF20 (0x14726CF20) ---

// --- Function: sub_147273B30 (0x147273B30) ---
__int64 sub_147273B30()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3400LL);
  if ( result )
  {
    return *(unsigned __int8 *)(result + 1);
  }
  return result;
}

// --- End Function: sub_147273B30 (0x147273B30) ---

// --- Function: sub_1473755E0 (0x1473755E0) ---
void __fastcall sub_1473755E0(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_147349F80(Buffer, 0xA0uLL, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1473755E0 (0x1473755E0) ---

// --- Function: sub_147397F30 (0x147397F30) ---
void __fastcall sub_147397F30(__int64 a1)
{
  sub_147397F40(a1);
}

// --- End Function: sub_147397F30 (0x147397F30) ---

// --- Function: sub_1473986B0 (0x1473986B0) ---
unsigned __int64 __fastcall sub_1473986B0(unsigned __int64 n0xE000, unsigned __int64 n0x10)
{
  return sub_1473986C0(n0xE000, n0x10);
}

// --- End Function: sub_1473986B0 (0x1473986B0) ---

// --- Function: sub_1473986C0 (0x1473986C0) ---
unsigned __int64 __fastcall sub_1473986C0(unsigned __int64 n0xE000, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000_1; // r11
  unsigned int v3; // r8d
  int n32; // eax
  unsigned int n32_1; // r8d
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 *v9; // r10
  __int64 v10; // r8
  __int64 v11; // rdi
  __int64 v12; // r11
  __int64 v13; // r8
  __int64 *v14; // rax
  __int64 v15; // rax
  unsigned __int64 v16; // r11
  unsigned __int64 result; // rax
  __int64 v18; // rcx
  _QWORD *v19; // r8
  _QWORD *v20; // r8

  n0xE000_1 = n0xE000;
  if ( n0x10 > 0x10 )
  {
    n0xE000_1 = ~(n0x10 - 1) & (n0x10 + n0xE000 - 1);
  }
  if ( n0xE000_1 > 0xE000 )
  {
    result = sub_147398850((__int64)&qword_1513BBF10, n0xE000_1);
  }
  else
  {
    _BitScanReverse(&v3, n0xE000_1 - 1);
    n32 = 32;
    n32_1 = v3 ^ 0x1F;
    if ( (_DWORD)n0xE000_1 != 1 )
    {
      n32 = n32_1;
    }
    v6 = 0;
    v7 = 0;
    v8 = (unsigned int)(32 - n32) - 8LL;
    if ( v8 >= 0 )
    {
      v7 = v8;
    }
    v9 = &qword_148A35270[3 * v7];
    LOBYTE(v6) = n0xE000_1 % *v9 == 0;
    v10 = n0xE000_1 / *v9 - v6;
    v11 = v10 + v9[1] - v9[2] / (unsigned __int64)*v9;
    v12 = *v9 * (v10 + 1);
    v13 = 16 * (v11 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3552;
    v14 = *(__int64 **)v13;
    if ( *(_QWORD *)v13 )
    {
      --*(_DWORD *)(v13 + 12);
      v18 = *v14;
      result = (unsigned __int64)v14 - v12 + 8;
      *(_QWORD *)v13 = v18;
    }
    else
    {
      v15 = sub_147399BF0(&qword_1513BBF20[4 * v11]);
      if ( v15 )
      {
        result = v15 - v16 + 8;
      }
      else
      {
        result = sub_147398A80((__int64)&qword_1513BBF10, v16, v11);
      }
    }
  }
  v19 = (_QWORD *)qword_1513BD1A0;
  if ( qword_1513BD1A0 )
  {
    while ( result < (unsigned __int64)v19 || result >= (unsigned __int64)v19 + v19[1] )
    {
      v19 = (_QWORD *)*v19;
      if ( !v19 )
      {
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    v20 = (_QWORD *)qword_1513BD0A0;
    if ( qword_1513BD0A0 )
    {
      while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
      {
        v20 = (_QWORD *)*v20;
        if ( !v20 )
        {
          goto LABEL_22;
        }
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1473986C0 (0x1473986C0) ---

// --- Function: sub_14739A8D0 (0x14739A8D0) ---
__int64 __fastcall sub_14739A8D0(unsigned __int64 n0x6400000)
{
  __int64 result; // rax
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1513BD53C == 1 )
  {
    sub_1417C3450(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_14981D4C4 = 1;
  ::n0x6400000 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
  {
    sub_1473755E0(n0x6400000);
  }
  n26880 = 26880;
  v5 = 0;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = 1;
  qword_149818EA0(
    &n26880,
    0,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  sub_1473755E0(n0x6400000);
  v8 = __rdtsc();
  qword_149818EA8(&n26880);
  return result;
}

// --- End Function: sub_14739A8D0 (0x14739A8D0) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(const void *a1)
{
  if ( a1 )
  {
    if ( qword_14981D3D8 && pCZoneSystem && a1 == (const void *)pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)a1 < qword_1497CE098 || (unsigned __int64)a1 >= qword_1497CE098 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_1497CE078 && (unsigned __int64)a1 < qword_1497CE078 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      }
      sub_147397F30((__int64)a1);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: sub_14739AFC0 (0x14739AFC0) ---
__int64 __fastcall sub_14739AFC0(unsigned __int64 n0x6400000, struct _exception *n0x10)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( n0x6400000 )
  {
    v4 = sub_147273B30();
    sub_140566BA0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(n0x10);
    result = sub_1473986B0(v5 + n0x6400000, (unsigned __int64)n0x10);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(n0x6400000);
  }
  return 0LL;
}

// --- End Function: sub_14739AFC0 (0x14739AFC0) ---

// --- Function: unknown_libname_247 (0x147DC63D0) ---
// Microsoft VisualC v14 64bit runtime
const __m128i *__fastcall unknown_libname_247(const __m128i *a1, const __m128i *a2, unsigned __int64 _XMM2)
{
  signed __int64 v3; // r9
  unsigned __int64 v5; // rdx
  const __m128i *v10; // rdx
  unsigned __int64 v13; // r9
  const __m128i *v14; // rdx
  __m128i v15; // xmm1
  __int64 v16; // rax

  v3 = (char *)a2 - (char *)a1;
  v5 = ((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL;
  if ( v5 && (dword_1497EA754 & 0x20) != 0 )
  {
    _XMM2 = _XMM2;
    _YMM2 = (__m256i)_XMM2;
    __asm
    {
      vpunpcklqdq xmm2, xmm2, xmm2
      vinsertf128 ymm2, ymm2, xmm2, 1
    }
    v10 = (const __m128i *)((char *)a1 + v5);
    while ( 1 )
    {
      __asm
      {
        vpcmpeqq ymm1, ymm2, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
      {
        break;
      }
      a1 += 2;
      if ( a1 == v10 )
      {
        v3 &= 0x1Fu;
        __asm { vzeroupper }
        goto LABEL_7;
      }
    }
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
LABEL_7:
    v13 = v3 & 0xFFFFFFFFFFFFFFF0uLL;
    if ( v13 && (dword_1497EA754 & 4) != 0 )
    {
      v14 = (const __m128i *)((char *)a1 + v13);
      v15 = _mm_unpacklo_epi64((__m128i)_XMM2, (__m128i)_XMM2);
      while ( 1 )
      {
        LODWORD(v16) = _mm_movemask_epi8(_mm_cmpeq_epi64(_mm_loadu_si128(a1), v15));
        if ( (_DWORD)v16 )
        {
          break;
        }
        if ( ++a1 == v14 )
        {
          goto LABEL_12;
        }
      }
      _BitScanForward((unsigned int *)&v16, v16);
      return (const __m128i *)((char *)a1 + v16);
    }
    else
    {
LABEL_12:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i64[0] == _XMM2 )
        {
          break;
        }
        a1 = (const __m128i *)((char *)a1 + 8);
      }
      return a1;
    }
  }
}

// --- End Function: unknown_libname_247 (0x147DC63D0) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---

// --- Function: __alloca_probe (0x147DC7830) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
  {
    StackLimit_1 = 0;
  }
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x147DC7830) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __tlregdtor (0x147DC7958) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6032);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6048);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6032) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100uLL);
    free_0(0LL);
    if ( !v3 )
    {
      return 0xFFFFFFFFLL;
    }
    v3[1] = *(_QWORD *)(v2 + 6032);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0LL;
}

// --- End Function: __tlregdtor (0x147DC7958) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memcpy (0x147E162BB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x147E162BB) ---

// --- Function: memmove (0x147E162C1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x147E162C1) ---

// --- Function: memset (0x147E162C7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x147E162C7) ---

// --- Function: strstr (0x147E162D9) ---
// attributes: thunk
char *__cdecl strstr(const char *Str, const char *SubStr)
{
  return __imp_strstr(Str, SubStr);
}

// --- End Function: strstr (0x147E162D9) ---

// --- Function: memcmp (0x147E162E5) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x147E162E5) ---

// --- Function: _CxxThrowException (0x147E1630F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x147E1630F) ---

// --- Function: sub_147E52AF0 (0x147E52AF0) ---
__int64 sub_147E52AF0()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = get_tls_data_offset_784();
  free_memory_wrapper(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = get_tls_data_offset_784();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0LL;
  return result;
}

// --- End Function: sub_147E52AF0 (0x147E52AF0) ---

