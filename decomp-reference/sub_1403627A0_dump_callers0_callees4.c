// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1403627A0 (sub_1403627A0)
// Caller Depth: 0
// Callee/Ref Depth: 4
// Total Functions Found: 11
// ------------------------------------------------------------

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_1403627A0 (0x1403627A0) ---
__int64 __fastcall sub_1403627A0(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        float a6,
        int a7,
        int a8,
        int a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  __int64 result; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a4;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x28) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x38) = &off_1481B0218;
  *(_OWORD *)(a1 + 0x40) = *(_OWORD *)(a5 + 8);
  *(double *)(a1 + 0x50) = *(double *)(a5 + 0x18);
  *(_DWORD *)(a1 + 0x70) = a7;
  *(_DWORD *)(a1 + 0x74) = a9;
  *(_DWORD *)(a1 + 0x78) = a8;
  *(_QWORD *)(a1 + 0x88) = a10;
  *(float *)(a1 + 0x64) = a6;
  *(float *)(a1 + 0x68) = a6;
  *(_DWORD *)(a1 + 0x58) = 0x3F800000;
  *(_QWORD *)(a1 + 0x5C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x6C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x7C) = 0;
  *(_BYTE *)(a1 + 0x80) = 0;
  *(_OWORD *)(a1 + 0x90) = *(_OWORD *)a11;
  *(double *)(a1 + 0xA0) = *(double *)(a11 + 0x10);
  *(double *)(a1 + 0xA8) = *(double *)a12;
  *(_DWORD *)(a1 + 0xB0) = *(_DWORD *)(a12 + 8);
  *(double *)(a1 + 0xB4) = *(double *)a13;
  *(_DWORD *)(a1 + 0xBC) = *(_DWORD *)(a13 + 8);
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_DWORD *)(a1 + 0xD8) = 0x3F800000;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_BYTE *)(a1 + 0x108) = 1;
  *(_QWORD *)(a1 + 0xDC) = 0;
  *(_QWORD *)(a1 + 0xE4) = 0;
  *(_WORD *)(a1 + 0xEC) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x110) = &off_1481B0218;
  *(_QWORD *)(a1 + 0x130) = 0;
  *(_DWORD *)(a1 + 0x138) = 0;
  *(_WORD *)(a1 + 0x13C) = 0;
  *(_DWORD *)(a1 + 0x140) = 0;
  *(_DWORD *)(a1 + 0x144) = 0x800000;
  *(_DWORD *)(a1 + 0x148) = 0x800000;
  *(_DWORD *)(a1 + 0x14C) = 0x800000;
  *(_DWORD *)(a1 + 0x150) = 0x800000;
  sub_1403B3F00((_WORD *)(a1 + 0x154), a2);
  result = a1;
  *(_QWORD *)(a1 + 0x158) = 0;
  return result;
}

// --- End Function: sub_1403627A0 (0x1403627A0) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 + 0xFFFFFFFA;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_1403B3F00 (0x1403B3F00) ---
_WORD *__fastcall sub_1403B3F00(_WORD *a1, unsigned __int64 a2)
{
  __int64 v4; // rbx
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int64 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int16 n4; // dx
  __int64 v10; // rbx
  __int64 v11; // rcx
  _BYTE v13[16]; // [rsp+20h] [rbp-38h] BYREF
  unsigned __int64 v14; // [rsp+68h] [rbp+10h] BYREF
  __int64 v15; // [rsp+70h] [rbp+18h] BYREF
  char v16; // [rsp+78h] [rbp+20h] BYREF

  v14 = a2;
  if ( !sub_14030EC00(&v14) )
    goto LABEL_13;
  v4 = a2 & 0xFFFFFFFFFFFFLL;
  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v4 + 0x340LL);
  n0xFFFF = n0xFFFF_29;
  if ( n0xFFFF_29 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v16,
                          "IActor");
    n0xFFFF_29 = n0xFFFF;
  }
  if ( (LOWORD(v15) = n0xFFFF, v7 = *(_QWORD *)v5(v4, v13, &v15), (v15 = v7) != 0)
    && (v8 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(
               gEnv,
               v7 & 0xFFFFFFFFFFFFLL,
               0),
        n4 = *(_WORD *)(v8 + 4),
        n4 != 4)
    && *(_WORD *)(v8 + 2) == (HIWORD(v7) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v15))
    && (v10 = v7 & 0xFFFFFFFFFFFFLL,
        (v11 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x758LL))(v10) + 8) & 0xFFFFFFFFFFFFLL) != 0)
    && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x20LL))(v11) )
  {
    (*(void (__fastcall **)(__int64, _WORD *))(*(_QWORD *)v10 + 0x7F8LL))(v10, a1);
    return a1;
  }
  else
  {
LABEL_13:
    *a1 = 0xFFFF;
    return a1;
  }
}

// --- End Function: sub_1403B3F00 (0x1403B3F00) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 0xC0LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

