// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146A48450 (sub_146A48450)
// Caller Depth: 1
// Callee/Ref Depth: 2
// Total Functions Found: 37
// ------------------------------------------------------------

// --- Function: sub_1402A65A0 (0x1402A65A0) ---
__int64 __fastcall sub_1402A65A0(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: sub_1402A65A0 (0x1402A65A0) ---

// --- Function: NtCurrentTeb_w (0x1402C8AD0) ---
__int64 sub_1402C8AD0()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C8AD0) ---

// --- Function: ?_Change_array@?$vector@IV?$allocator@I@std@@@std@@AEAAXQEAI_K1@Z (0x1402E10A0) ---
void __fastcall std::vector<unsigned int>::_Change_array(
        std::vector<unsigned int> *this,
        unsigned int *const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  __int64 v6; // rcx

  v6 = *(_QWORD *)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - v6) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_1402A6590(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@IV?$allocator@I@std@@@std@@AEAAXQEAI_K1@Z (0x1402E10A0) ---

// --- Function: sub_1402E3880 (0x1402E3880) ---
void __noreturn sub_1402E3880()
{
  stdext::exception *v0; // rax
  _BYTE v1[24]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B3D30(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E3880 (0x1402E3880) ---

// --- Function: unknown_libname_10 (0x1402E46A0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E46A0) ---

// --- Function: sub_140347870 (0x140347870) ---
int *__fastcall sub_140347870(__int64 a1, _BYTE *a2, int *a3)
{
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  int *v12; // rsi
  int *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  int *v16; // rbp
  size_t Size; // r8
  __int64 v18; // rcx
  int *result; // rax

  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 2;
  _Count = 0x3FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if ( v6 == 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 2;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x3FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<int>::allocate((std::allocator<int> *)a1, _Count);
  v12[v4] = *a3;
  v13 = v12;
  v14 = *(_BYTE **)(a1 + 8);
  v15 = *(_BYTE **)a1;
  v16 = &v12[v4];
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = v16 + 1;
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  v18 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - v18) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v18 = *(_QWORD *)(v18 - 8);
    }
    sub_1402A6590(v18);
  }
  *(_QWORD *)a1 = v12;
  result = v16;
  *(_QWORD *)(a1 + 8) = &v12[v10];
  *(_QWORD *)(a1 + 0x10) = &v12[_Count];
  return result;
}

// --- End Function: sub_140347870 (0x140347870) ---

// --- Function: rw_lock_acquire_read_lock_dispatch (0x1403CF2D0) ---
// Dispatches to either a profiled read lock acquisition function
// (`rw_lock_acquire_read_lock_profiled`) or a standard, unprofiled one
// (`rw_lock_acquire_read_lock_unprofiled`). The choice depends on a boolean flag
// (`is_profiled_mode`), a debug flag within the thread context (at offset `0x1C`),
// and the availability of the global environment (`gEnv`).
double __fastcall rw_lock_acquire_read_lock_dispatch(
        __int64 a1,
        signed __int64 a2,
        const char *a3,
        const char *a4,
        char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return rw_lock_acquire_read_lock_profiled(a1, a2, a3, a4);
  else
    return rw_lock_acquire_read_lock_unprofiled(a1, a2, a3, a4);
}

// --- End Function: rw_lock_acquire_read_lock_dispatch (0x1403CF2D0) ---

// --- Function: rw_lock_acquire_read_lock_profiled (0x1403CF350) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended, it retries. Upon successful acquisition,
// it logs detailed profiling information, including timestamps, lock name, lock
// owner, and caller, using a dedicated profiling system.
void __fastcall rw_lock_acquire_read_lock_profiled(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_Src; // rdx
  _BYTE v18[16]; // [rsp+30h] [rbp-29h] BYREF
  int n0x1600; // [rsp+40h] [rbp-19h] BYREF
  __int64 v20; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v22; // [rsp+50h] [rbp-9h]
  unsigned __int64 v23; // [rsp+58h] [rbp-1h]
  __int64 v24; // [rsp+60h] [rbp+7h]
  __int64 v25; // [rsp+68h] [rbp+Fh]
  char v26; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149C8E038;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 0xF8LL))(v4, v18, &v26);
  if ( (a2 & 0x200000) == 0 )
    return;
  v12 = (unsigned __int64)v11 << 0x20;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 0x124) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n0x1600 = 0x1600;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v20 = 1;
      n2 = 2;
      v22 = __rdtsc();
      qword_149C89AA0(
        &n0x1600,
        &word_149C7BF44,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      v15 = word_149C7BF44;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return;
  }
  *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n0x1600 = 0x1600;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v20 = 1;
  n2 = 2;
  v22 = __rdtsc();
  qword_149C89AA0(
    &n0x1600,
    &word_149C7BF48,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  v15 = word_149C7BF48;
LABEL_10:
  HIWORD(n0x1600) = v15;
  qword_149C89AE0("Lock: %s", a4);
  p_p_Src = &p_Src;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_Src = *(const ULONG_PTR **)(a1 + 8);
  qword_149C89AE0("LockOwner: %s", p_p_Src);
  qword_149C89AE0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 0xE8LL))(v4, v11);
  v23 = __rdtsc();
  qword_149C89AA8(&n0x1600);
}

// --- End Function: rw_lock_acquire_read_lock_profiled (0x1403CF350) ---

// --- Function: rw_lock_acquire_read_lock_unprofiled (0x1403CF580) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by a writer). It then attempts to atomically set the read lock flag using
// `_InterlockedCompareExchange64`. Upon successful acquisition, it logs basic
// information about the lock, its owner, and the caller. This version does not
// include detailed performance profiling.
void __fastcall rw_lock_acquire_read_lock_unprofiled(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_Src_1; // rdx
  int *p_n0x1600; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_Src; // rdx
  int v14; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v15[3]; // [rsp+34h] [rbp-65h] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v17; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v19; // [rsp+50h] [rbp-49h]
  unsigned __int64 v20; // [rsp+58h] [rbp-41h]
  __int64 v21; // [rsp+60h] [rbp-39h]
  __int64 v22; // [rsp+68h] [rbp-31h]
  int n0x1600; // [rsp+90h] [rbp-9h] BYREF
  __int64 v24; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v26; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+Fh]
  __int64 v28; // [rsp+B0h] [rbp+17h]
  __int64 v29; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x128LL))(qword_149C8E038, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n0x1600 = 0x1600;
        v24 = 1;
        n2 = 2;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v26 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF40,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(n0x1600) = word_149C7BF40;
        qword_149C89AE0("Lock: %s", a4);
        p_p_Src = &p_Src;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a3);
        v15[0] = v10;
        qword_149C78FC8(a1, v15, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n0x1600 = &n0x1600;
        v27 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return;
    }
    n0x1600_1 = 0x1600;
    v17 = 1;
    n2_1 = 2;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v19 = __rdtsc();
    qword_149C89AA0(
      &n0x1600_1,
      &word_149C7BF3C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(n0x1600_1) = word_149C7BF3C;
    qword_149C89AE0("Lock: %s", a4);
    p_p_Src_1 = &p_Src;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149C89AE0("LockOwner: %s", p_p_Src_1);
    qword_149C89AE0("Caller: %s", a3);
    v14 = v6;
    qword_149C78FC8(a1, &v14, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n0x1600 = &n0x1600_1;
    v20 = __rdtsc();
LABEL_13:
    qword_149C89AA8(p_n0x1600);
    goto LABEL_14;
  }
}

// --- End Function: rw_lock_acquire_read_lock_unprofiled (0x1403CF580) ---

// --- Function: rw_lock_handle_release_contention (0x1403CF7F0) ---
// Handles the release of a read-write lock when contention or specific lock flags
// are present. It continuously attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`. Depending on the resulting lock state, it may
// trigger further release operations (e.g., waking waiting threads via
// `qword_149B3B488`) or update thread context information related to lock
// ownership and counts.
__int64 __fastcall rw_lock_handle_release_contention(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v8 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
      break;
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
      return result;
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
    return qword_149C78FD0(a1, v4);
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v11,
      &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v7 & (v9 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(
             qword_149C8E038,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: rw_lock_handle_release_contention (0x1403CF7F0) ---

// --- Function: sub_1403E1120 (0x1403E1120) ---
__int64 __fastcall sub_1403E1120(__int64 a1, unsigned __int64 a2, __int64 a3, const char *a4, const char *a5, char a6)
{
  if ( a6 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403E1120 (0x1403E1120) ---

// --- Function: rw_lock_acquire_write_lock_profiled (0x1403E11B0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended (e.g., by readers or another writer), it
// waits. Upon successful acquisition, it logs detailed profiling information,
// including timestamps, lock name, lock owner, and caller, using a dedicated
// profiling system. It also sets the lock owner pointer at `p_rw_lock_state + 8`.
__int64 __fastcall rw_lock_acquire_write_lock_profiled(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5)
{
  __int64 v5; // r15
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r14d
  const char *v12; // r13
  bool v13; // zf
  signed __int64 v14; // rax
  __int64 result; // rax
  unsigned __int64 v16; // rdx
  signed __int64 v17; // rax
  const ULONG_PTR *p_p_Src; // rdx
  signed __int64 v19; // rax
  const ULONG_PTR *p_p_Src_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-91h] BYREF
  __int64 v22; // [rsp+34h] [rbp-8Dh]
  int n2; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 v24; // [rsp+40h] [rbp-81h]
  unsigned __int64 v25; // [rsp+48h] [rbp-79h]
  __int64 v26; // [rsp+50h] [rbp-71h]
  __int64 v27; // [rsp+58h] [rbp-69h]
  int n0x1600_1; // [rsp+80h] [rbp-41h] BYREF
  __int64 v29; // [rsp+84h] [rbp-3Dh]
  int n2_1; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 v31; // [rsp+90h] [rbp-31h]
  unsigned __int64 v32; // [rsp+98h] [rbp-29h]
  __int64 v33; // [rsp+A0h] [rbp-21h]
  __int64 v34; // [rsp+A8h] [rbp-19h]
  _BYTE v35[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char v36; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 v37; // [rsp+130h] [rbp+6Fh]

  v37 = a3;
  v5 = qword_149C8E038;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v5 + 0xF8LL))(v5, v35, &v36);
  v12 = a5;
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v16 = (unsigned __int64)v11 << 0x30;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v10 + 0x124) = HIWORD(a2);
        v17 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v16 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v13 = a2 == v17;
        a2 = v17;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v22 = 1;
          n2 = 2;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v24 = __rdtsc();
          qword_149C89AA0(
            &n0x1600,
            &word_149C7BF54,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(n0x1600) = word_149C7BF54;
          qword_149C89AE0("Lock: %s", v12);
          p_p_Src = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src);
          qword_149C89AE0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v25 = __rdtsc();
          qword_149C89AA8(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
        v19 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v16, a2);
        v13 = a2 == v19;
        a2 = v19;
        if ( v13 )
        {
          n0x1600_1 = 0x1600;
          v29 = 1;
          n2_1 = 2;
          v32 = 0;
          v33 = 0;
          v34 = 0;
          v31 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF58,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600_1) = word_149C7BF58;
          qword_149C89AE0("Lock: %s", v12);
          p_p_Src_1 = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v32 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | 0x200000, a2);
    v13 = a2 == v14;
    a2 = v14;
  }
  while ( !v13 );
  result = v37;
  *(_QWORD *)(a1 + 8) = v37;
  return result;
}

// --- End Function: rw_lock_acquire_write_lock_profiled (0x1403E11B0) ---

// --- Function: rw_lock_acquire_write_lock_unprofiled (0x1403E1470) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by readers). It then attempts to atomically set the write lock flag or
// increment a write lock count using `_InterlockedCompareExchange64`. Upon
// successful acquisition, it logs basic information about the lock, its owner, and
// the caller. This version does not include detailed performance profiling. It
// also sets the lock owner pointer at `p_rw_lock_state + 8`.
signed __int64 __fastcall rw_lock_acquire_write_lock_unprofiled(
        __int64 a1,
        signed __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5)
{
  char v5; // r14
  signed __int64 v9; // rcx
  bool v10; // zf
  signed __int64 result; // rax
  const ULONG_PTR *p_p_Src; // rdx
  int v13; // esi
  signed __int64 v14; // rax
  const ULONG_PTR *p_p_Src_1; // rdx
  int v16; // [rsp+38h] [rbp-81h] BYREF
  _DWORD v17[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int n0x1600; // [rsp+48h] [rbp-71h] BYREF
  __int64 v19; // [rsp+4Ch] [rbp-6Dh]
  int n2; // [rsp+54h] [rbp-65h]
  unsigned __int64 v21; // [rsp+58h] [rbp-61h]
  unsigned __int64 v22; // [rsp+60h] [rbp-59h]
  __int64 v23; // [rsp+68h] [rbp-51h]
  __int64 v24; // [rsp+70h] [rbp-49h]
  int n0x1600_1; // [rsp+98h] [rbp-21h] BYREF
  __int64 v26; // [rsp+9Ch] [rbp-1Dh]
  int n2_1; // [rsp+A4h] [rbp-15h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-11h]
  unsigned __int64 v29; // [rsp+B0h] [rbp-9h]
  __int64 v30; // [rsp+B8h] [rbp-1h]
  __int64 v31; // [rsp+C0h] [rbp+7h]

  v5 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149C8E038 + 0x128LL))(qword_149C8E038, a1);
      if ( (a2 & 0x2003FF) == 0 )
        break;
      if ( v5 )
      {
        n0x1600 = 0x1600;
        v19 = 1;
        n2 = 2;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v21 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF4C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(n0x1600) = word_149C7BF4C;
        qword_149C89AE0("Lock: %s", a5);
        p_p_Src = &p_Src;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a4);
        v16 = a2;
        qword_149C78FC8(a1, &v16, 4, 0xFFFFFFFFLL);
        a2 = *(_QWORD *)a1;
        v22 = __rdtsc();
        qword_149C89AA8(&n0x1600);
      }
      else
      {
        v13 = a2 + 0x400000;
        v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 + 0x400000, a2);
        v10 = a2 == v14;
        a2 = v14;
        if ( v10 )
        {
          v5 = 1;
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF50,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600_1) = word_149C7BF50;
          qword_149C89AE0("Lock: %s", a5);
          p_p_Src_1 = &p_Src;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a4);
          v17[0] = v13;
          qword_149C78FC8(a1, v17, 4, 0xFFFFFFFFLL);
          a2 = *(_QWORD *)a1;
          v29 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v9 = (a2 | 0x200000) - 0x400000;
    if ( !v5 )
      v9 = a2 | 0x200000;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v9, a2);
    v10 = a2 == result;
    a2 = result;
  }
  while ( !v10 );
  *(_QWORD *)(a1 + 8) = a3;
  return result;
}

// --- End Function: rw_lock_acquire_write_lock_unprofiled (0x1403E1470) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403E1740) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // rbx
  signed __int64 v4; // rdi
  signed __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v7; // r8
  int v8; // ecx
  __int64 v9; // r8
  unsigned __int64 v10; // rbx
  const ULONG_PTR *p_p_Src; // rax
  int v12; // [rsp+70h] [rbp+8h] BYREF
  int v13; // [rsp+78h] [rbp+10h] BYREF
  __int64 v14; // [rsp+80h] [rbp+18h] BYREF
  __int64 v15; // [rsp+88h] [rbp+20h] BYREF

  for ( i = a2; ; i = v5 )
  {
    v4 = i & 0xFFFFFFFFFFD003FFuLL;
    if ( (i & 0xFFFF00100000LL) != 0 )
    {
      v4 = i & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (i & 0xFFC003FF) == 0 && (i & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v15,
        &v13);
      v4 = i & 0xFFFFFFD003FFLL;
      a2 = *(unsigned int *)(((HIWORD(i) & (unsigned int)(v13 - 1)) << 9) + v15 + 0x124);
      if ( (_DWORD)a2 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)(unsigned int)a2 << 0x30;
    }
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v4, i);
    if ( i == v5 )
      break;
  }
  if ( (i & 0x3FF) != 0 )
  {
    if ( (i & 0x100000) != 0 )
      qword_149C78FD8(a1);
    if ( (i & 0xFFFF00000000LL) != 0 )
    {
      v6 = qword_149C8E038;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v14,
        &v12);
      v7 = v14 + ((WORD2(i) & (unsigned __int64)(unsigned int)(v12 - 1)) << 9);
      LODWORD(i) = *(_DWORD *)(v7 + 0x124);
      *(_DWORD *)(v7 + 0x11C) = (unsigned __int16)(WORD2(i) + v12);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xD8LL))(v6);
      while ( (_DWORD)i != 0xFFFFFFFF )
      {
        v8 = (unsigned __int16)(i + v12);
        v9 = v14 + ((unsigned __int64)((unsigned int)i & (v12 - 1)) << 9);
        LODWORD(i) = *(_DWORD *)(v9 + 0x124);
        *(_DWORD *)(v9 + 0x11C) = v8;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xD8LL))(v6);
      }
    }
  }
  else if ( (i & 0xFFC00000) != 0 )
  {
    qword_149C78FD0(a1, a2);
  }
  else if ( (i & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v14,
      &v12);
    v10 = HIWORD(i);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v10 & (v12 - 1)) << 9) + v14 + 0x11C) = (unsigned __int16)(v10 + v12);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(qword_149C8E038, (unsigned int)v10);
  }
  p_p_Src = &p_Src;
  *(_QWORD *)(a1 + 8) = &p_Src;
  return p_p_Src;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403E1740) ---

// --- Function: sub_14675E7F0 (0x14675E7F0) ---
_QWORD *__fastcall sub_14675E7F0(_QWORD *a1, char *p_CActorEntity::Step, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v8; // rax
  _QWORD *result; // rax

  *a1 = p_CActorEntity::Step;
  a1[1] = sub_1403E7AE0();
  a1[2] = a3;
  if ( !a4 )
  {
    a4 = a3 + 0x1C0;
    if ( !a3 )
      a4 = 0;
  }
  v8 = a5;
  a1[3] = a4;
  if ( a5 )
    goto LABEL_7;
  if ( a3 )
  {
    v8 = *(_QWORD *)(a3 + 0xB8);
LABEL_7:
    a1[4] = v8;
    return a1;
  }
  result = a1;
  a1[4] = 0;
  return result;
}

// --- End Function: sub_14675E7F0 (0x14675E7F0) ---

// --- Function: sub_146762B50 (0x146762B50) ---
unsigned __int64 *__fastcall sub_146762B50(__int64 a1)
{
  unsigned __int64 *result; // rax
  __int128 v6; // kr00_16
  const char *UNKNOWN; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 *v11; // rax
  __int64 v12; // rax
  const char *UNKNOWN_HOST_1; // rax
  const char *UNKNOWN_HOST; // rdx
  __int64 v19; // rcx
  __int64 v22; // rcx

  result = (unsigned __int64 *)(sub_1403E7AE0() - *(_QWORD *)(a1 + 8));
  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, rax }
  *((_QWORD *)&v6 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v6 = *(double *)&_XMM0 * *(double *)&qword_1516EFE10;
  _XMM1 = v6;
  __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
  if ( *(float *)&_XMM2 > 0.00050000002 )
  {
    qword_149C89AE0("HEAVY");
    UNKNOWN = "UNKNOWN!";
    if ( *(_QWORD *)a1 )
      UNKNOWN = *(const char **)a1;
    qword_149C89AE0((const char *)&format_string_, UNKNOWN);
    v10 = *(_QWORD *)(a1 + 0x10);
    if ( v10 )
      qword_149C89AE0("Entity %s", *(const char **)(v10 + 0xD8));
    v11 = *(__int64 **)(a1 + 0x20);
    if ( v11 )
    {
      v12 = *v11;
      if ( v12 )
      {
        UNKNOWN_HOST_1 = *(const char **)(v12 + 0xD8);
        UNKNOWN_HOST = "UNKNOWN HOST!";
        if ( UNKNOWN_HOST_1 )
          UNKNOWN_HOST = UNKNOWN_HOST_1;
      }
      else
      {
        UNKNOWN_HOST = "ROOT";
      }
      qword_149C89AE0("Host:%s", UNKNOWN_HOST);
    }
    result = *(unsigned __int64 **)(a1 + 0x18);
    if ( result )
    {
      _XMM0 = *result;
      __asm { vcvtpd2ps xmm0, xmm0 }
      qword_149C89AE8(v9, &unk_14A3BE550, "PosX");
      _XMM0 = *(unsigned __int64 *)(*(_QWORD *)(a1 + 0x18) + 8LL);
      __asm { vcvtpd2ps xmm0, xmm0 }
      qword_149C89AE8(v19, &unk_14A3BE554, "PosY");
      _XMM0 = *(unsigned __int64 *)(*(_QWORD *)(a1 + 0x18) + 0x10LL);
      __asm { vcvtpd2ps xmm0, xmm0 }
      return (unsigned __int64 *)qword_149C89AE8(v22, &unk_14A3BE558, "PosZ");
    }
  }
  return result;
}

// --- End Function: sub_146762B50 (0x146762B50) ---

// --- Function: sub_14679AB80 (0x14679AB80) ---
__int64 __fastcall sub_14679AB80(__int64 a1, int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 0xA0) + 8LL * a2);
}

// --- End Function: sub_14679AB80 (0x14679AB80) ---

// --- Function: sub_1467AA080 (0x1467AA080) ---
__int64 __fastcall sub_1467AA080(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // r9
  __int64 v3; // r8
  __int64 v4; // rdx
  _QWORD *v5; // r10
  __int64 v6; // rax

  v2 = *((unsigned int *)a2 + 2);
  v3 = *a2;
  v4 = a1[0x19];
  v5 = (_QWORD *)(a1[0x1B] + 0x10 * (a1[0x1E] & ((0x466F45D * v3) ^ (0x127409F * v2))));
  v6 = v5[1];
  if ( v6 == v4 )
  {
LABEL_6:
    v6 = 0;
  }
  else
  {
    while ( v3 != *(_QWORD *)(v6 + 0x10) || (_DWORD)v2 != *(_DWORD *)(v6 + 0x18) )
    {
      if ( v6 == *v5 )
        goto LABEL_6;
      v6 = *(_QWORD *)(v6 + 8);
    }
  }
  if ( !v6 )
    v6 = a1[0x19];
  if ( v6 == v4 )
    return 0;
  else
    return *(_QWORD *)(v6 + 0x20);
}

// --- End Function: sub_1467AA080 (0x1467AA080) ---

// --- Function: map_get_value_by_id (0x1467AA0F0) ---
// Searches for a specific integer ID (`target_id`) within a sorted array of `(ID,
// Value)` pairs (or similar structure) and returns the associated integer value.
// It employs a fast path using SIMD instructions (`vpcmpeqd`) for arrays up to
// 0x40 elements, and a binary search-like algorithm for larger arrays. An optional
// output pointer (`pp_found_entry`) can return the address of the found entry.
__int64 __fastcall map_get_value_by_id(__int64 a1, int a2, char **a3)
{
  unsigned int n0x40; // edx
  __int64 v8; // rax
  int v10; // r8d
  _QWORD *v11; // r10
  int v12; // r9d
  __int64 v15; // rdi
  __int64 v16; // rbp
  int n8; // r14d
  __int64 v18; // r11
  int n3; // ecx
  int n3_1; // ecx
  int n3_2; // ecx
  int n3_3; // ecx
  _QWORD *v31; // r11
  _QWORD *v32; // rdi
  __int64 v33; // rax
  __int64 v34; // rcx
  char *v35; // rcx
  char **v36; // r9
  _QWORD *v37; // r8
  char *v38; // r11
  char *v39; // r9
  char *v40; // rcx
  __int64 v41; // rcx

  if ( (*(_DWORD *)(a1 + 0x184) & 4) != 0 )
    return (*(__int64 (**)(void))(a1 + 0x190))();
  n0x40 = *(_DWORD *)(a1 + 0x170);
  if ( n0x40 )
  {
    if ( n0x40 == 1 )
      return **(_DWORD **)(a1 + 0x30) != a2;
    LODWORD(v8) = *(_DWORD *)(a1 + 0x170);
    if ( (int)n0x40 <= 0x40 )
    {
      _XMM2 = xmmword_148D30040;
      v10 = 0;
      v11 = (_QWORD *)(a1 + 0x40);
      v12 = 0;
      __asm
      {
        vpinsrd xmm2, xmm2, ebx, 0
        vpunpcklqdq xmm2, xmm2, xmm2
      }
      if ( (int)(n0x40 & 0xFFFFFFF8) <= 0 )
      {
LABEL_18:
        v31 = v11;
        v32 = v11;
        switch ( n0x40 & 7 )
        {
          case 1u:
            goto LABEL_39;
          case 2u:
            goto LABEL_37;
          case 3u:
            goto LABEL_35;
          case 4u:
            goto LABEL_33;
          case 5u:
            goto LABEL_31;
          case 6u:
            goto LABEL_29;
          case 7u:
            v33 = *v11;
            v34 = v12;
            if ( *(_DWORD *)(*v11 + 8LL * v12) == a2 )
              goto LABEL_40;
            v10 = 1;
            v31 = (_QWORD *)(a1 + 0x40);
LABEL_29:
            v32 = v31;
            v34 = v10 + v12;
            v33 = *v11;
            if ( *(_DWORD *)(*v11 + 8 * v34) == a2 )
              goto LABEL_40;
            ++v10;
LABEL_31:
            v34 = v10 + v12;
            v33 = *v11;
            if ( *(_DWORD *)(*v11 + 8 * v34) == a2 )
              goto LABEL_40;
            ++v10;
            v11 = v32;
LABEL_33:
            v34 = v10 + v12;
            v33 = *v11;
            if ( *(_DWORD *)(*v11 + 8 * v34) == a2 )
              goto LABEL_40;
            ++v10;
LABEL_35:
            v34 = v10 + v12;
            v33 = *v11;
            if ( *(_DWORD *)(*v11 + 8 * v34) == a2 )
              goto LABEL_40;
            ++v10;
LABEL_37:
            v34 = v10 + v12;
            v33 = *v11;
            if ( *(_DWORD *)(*v11 + 8 * v34) == a2 )
              goto LABEL_40;
            ++v10;
LABEL_39:
            v34 = v10 + v12;
            v33 = *v11;
            if ( *(_DWORD *)(*v11 + 8 * v34) == a2 )
LABEL_40:
              n0x40 = *(_DWORD *)(v33 + 8 * v34 + 4);
            break;
          default:
            return n0x40;
        }
      }
      else
      {
        v15 = *v11;
        v16 = 0;
        n8 = 8;
        v18 = *v11 + 0x20LL;
        while ( 1 )
        {
          _mm_prefetch((const char *)(v15 + 8LL * n8), 1);
          __asm
          {
            vpcmpeqd xmm1, xmm2, xmmword ptr [r11-20h]
            vmovmskps ecx, xmm1
          }
          n3 = _ECX - 1;
          if ( !n3 )
            return *(unsigned int *)(v15 + 8LL * v12 + 4);
          if ( n3 == 3 )
            return *(unsigned int *)(v15 + 8LL * v12 + 0xC);
          __asm
          {
            vpcmpeqd xmm1, xmm2, xmmword ptr [r11-10h]
            vmovmskps ecx, xmm1
          }
          n3_1 = _ECX - 1;
          if ( !n3_1 )
            return *(unsigned int *)(v15 + 8LL * v12 + 0x14);
          if ( n3_1 == 3 )
            return *(unsigned int *)(v15 + 8LL * v12 + 0x1C);
          __asm
          {
            vpcmpeqd xmm1, xmm2, xmmword ptr [r11]
            vmovmskps ecx, xmm1
          }
          n3_2 = _ECX - 1;
          if ( !n3_2 )
            return *(unsigned int *)(v15 + 8LL * v12 + 0x24);
          if ( n3_2 == 3 )
            return *(unsigned int *)(v15 + 8LL * v12 + 0x2C);
          __asm
          {
            vpcmpeqd xmm1, xmm2, xmmword ptr [r11+10h]
            vmovmskps ecx, xmm1
          }
          n3_3 = _ECX - 1;
          if ( !n3_3 )
            return *(unsigned int *)(v15 + 8LL * v12 + 0x34);
          if ( n3_3 == 3 )
            return *(unsigned int *)(v15 + 8LL * v12 + 0x3C);
          v12 += 8;
          n8 += 8;
          v16 += 8;
          v18 += 0x40;
          if ( v16 >= (int)(n0x40 & 0xFFFFFFF8) )
            goto LABEL_18;
        }
      }
      return n0x40;
    }
    if ( a3 )
    {
      v35 = *a3;
      v36 = (char **)(a1 + 0x40);
      *a3 = 0;
      v37 = (_QWORD *)(a1 + 0x40);
      v8 = *(int *)(a1 + 0x170);
      if ( v35 )
      {
        v38 = *v36;
        if ( *(_DWORD *)v35 >= a2 )
        {
          v39 = *v36;
          v37 = (_QWORD *)(a1 + 0x40);
          v40 = v35 + 8;
        }
        else
        {
          v39 = v35;
          v37 = (_QWORD *)(a1 + 0x40);
          v40 = &v38[8 * v8];
        }
        goto LABEL_48;
      }
    }
    else
    {
      v36 = (char **)(a1 + 0x40);
      v37 = (_QWORD *)(a1 + 0x40);
    }
    v39 = *v36;
    v40 = &v39[8 * (int)v8];
LABEL_48:
    v41 = (v40 - v39) >> 3;
    if ( v41 > 0 )
    {
      do
      {
        if ( *(_DWORD *)&v39[8 * ((unsigned __int64)v41 >> 1)] >= a2 )
        {
          v41 = (unsigned __int64)v41 >> 1;
        }
        else
        {
          v39 += 8 * ((unsigned __int64)v41 >> 1) + 8;
          v41 += 0xFFFFFFFFFFFFFFFFuLL - ((unsigned __int64)v41 >> 1);
        }
      }
      while ( v41 > 0 );
      v37 = (_QWORD *)(a1 + 0x40);
    }
    if ( v39 != (char *)(*v37 + 8LL * *(int *)(a1 + 0x170)) && *(_DWORD *)v39 == a2 )
    {
      if ( a3 )
        *a3 = v39;
      return *((unsigned int *)v39 + 1);
    }
  }
  return n0x40;
}

// --- End Function: map_get_value_by_id (0x1467AA0F0) ---

// --- Function: map_get_value_by_composite_key (0x1467DBA90) ---
// Searches for a specific composite key (an `unsigned __int64` and an `unsigned
// int`) within a sorted array of such pairs, and returns an associated `_DWORD`
// value. It primarily uses a binary search algorithm, accessing data via an
// auxiliary array of sorted indices. A special flag (`p_map_context + 0x184 & 4`)
// can force a less efficient linear search.
__int64 __fastcall map_get_value_by_composite_key(__int64 a1, unsigned __int64 *a2, unsigned int a3, _DWORD *a4)
{
  _DWORD *v5; // rsi
  __int64 v8; // rdx
  unsigned int v9; // r9d
  unsigned __int64 v10; // r8
  __int64 v11; // rcx
  __int64 i; // rax
  __int64 result; // rax
  __int64 v14; // rbp
  unsigned __int64 v15; // rcx
  __int64 v16; // r8
  unsigned int *v17; // r12
  unsigned int *v18; // rbx
  __int64 v19; // r15
  char v20; // dl
  __int64 v21; // r10

  v5 = a4;
  if ( (*(_DWORD *)(a1 + 0x184) & 4) == 0 )
  {
    v14 = *(int *)(a1 + 0x170);
    v15 = *a2;
    v16 = *(int *)(a1 + 0x170);
    v17 = *(unsigned int **)(a1 + 0x88);
    v18 = v17;
    if ( (int)v14 > 0 )
    {
      v19 = *(_QWORD *)(a1 + 0x80);
      do
      {
        if ( *(_QWORD *)(v19 + 0x10LL * (int)v18[v16 / 2]) >= v15 )
        {
          if ( *(_QWORD *)(v19 + 0x10LL * (int)v18[v16 / 2]) <= v15 )
          {
            if ( *(_DWORD *)(v19 + 0x10LL * (int)v18[v16 / 2] + 8) == a3 )
            {
              v20 = 0;
            }
            else
            {
              v20 = 0xFF;
              if ( *(_DWORD *)(v19 + 0x10LL * (int)v18[v16 / 2] + 8) >= a3 )
                v20 = 1;
            }
          }
          else
          {
            v20 = 1;
          }
        }
        else
        {
          v20 = 0xFF;
        }
        if ( v20 >= 0 )
        {
          v16 /= 2;
        }
        else
        {
          v18 += v16 / 2 + 1;
          v16 += 0xFFFFFFFFFFFFFFFFuLL - v16 / 2;
        }
      }
      while ( v16 > 0 );
      v17 = *(unsigned int **)(a1 + 0x88);
      v5 = a4;
    }
    LODWORD(v8) = v14;
    if ( v18 != &v17[v14] )
    {
      v21 = *(_QWORD *)(a1 + 0x80) + 0x10LL * (int)*v18;
      if ( *(_QWORD *)v21 == v15 && *(_DWORD *)(v21 + 8) == a3 )
      {
        *v5 = *(_DWORD *)(*(_QWORD *)(a1 + 0x30) + 4LL * (int)*v18);
        return *v18;
      }
    }
    return (unsigned int)v8;
  }
  v8 = *(int *)(a1 + 0x170);
  v9 = 0;
  if ( (int)v8 <= 0 )
    return (unsigned int)v8;
  v10 = *a2;
  v11 = 0;
  for ( i = *(_QWORD *)(a1 + 0x80); *(_QWORD *)i != v10 || *(_DWORD *)(i + 8) != a3; i += 0x10 )
  {
    ++v9;
    if ( ++v11 >= v8 )
      return (unsigned int)v8;
  }
  result = v9;
  *v5 = *(_DWORD *)(*(_QWORD *)(a1 + 0x30) + 4LL * (int)v9);
  return result;
}

// --- End Function: map_get_value_by_composite_key (0x1467DBA90) ---

// --- Function: sub_1467F5530 (0x1467F5530) ---
__int64 __fastcall sub_1467F5530(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &off_148D307B0;
  _InterlockedIncrement(&dword_15164C198);
  *(_DWORD *)(a1 + 0x14) = 0x7FFFFFFF;
  *(_QWORD *)a1 = &off_148D309D8;
  *(_DWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x28) = 0;
  *(_DWORD *)(a1 + 0xC) = 1;
  *(_DWORD *)(a1 + 0x10) = 0;
  result = a1;
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  return result;
}

// --- End Function: sub_1467F5530 (0x1467F5530) ---

// --- Function: sub_1467F6A30 (0x1467F6A30) ---
__int64 (__fastcall **__fastcall sub_1467F6A30(__int64 a1))()
{
  bool v1; // zf
  __int64 v3; // rcx
  __int64 (__fastcall **result)(); // rax

  v1 = *(_DWORD *)(a1 + 0x28) == 1;
  *(_QWORD *)a1 = &off_148D309D8;
  if ( v1 )
  {
    v3 = *(_QWORD *)(a1 + 0x20);
    if ( v3 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8LL))(v3);
  }
  _InterlockedDecrement(&dword_15164C198);
  result = &off_148D307B0;
  *(_QWORD *)a1 = &off_148D307B0;
  return result;
}

// --- End Function: sub_1467F6A30 (0x1467F6A30) ---

// --- Function: sub_146815CE0 (0x146815CE0) ---
__int64 __fastcall sub_146815CE0(__int64 a1, __int64 a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int128 v6; // xmm10
  __int128 v7; // xmm11
  __int128 v8; // xmm12
  float v10; // xmm12_4
  float v11; // xmm11_4
  float v12; // xmm10_4
  float v13; // xmm6_4
  float v14; // xmm5_4
  __m128 v15; // kr00_16
  float v18; // xmm1_4
  float v19; // xmm3_4
  float v20; // xmm4_4
  int v21; // eax
  __int64 result; // rax
  unsigned __int64 v23; // [rsp+28h] [rbp-79h]
  float v24; // [rsp+30h] [rbp-71h]
  float v25[6]; // [rsp+48h] [rbp-59h] BYREF
  float v26; // [rsp+60h] [rbp-41h]
  float v27; // [rsp+64h] [rbp-3Dh]
  float v28; // [rsp+68h] [rbp-39h]
  int v29; // [rsp+6Ch] [rbp-35h]
  __int64 v30; // [rsp+70h] [rbp-31h]
  int v31; // [rsp+78h] [rbp-29h]
  float v32; // [rsp+7Ch] [rbp-25h]
  float v33; // [rsp+80h] [rbp-21h]
  float v34; // [rsp+84h] [rbp-1Dh]
  __int128 v35; // [rsp+88h] [rbp-19h]
  __int128 v36; // [rsp+98h] [rbp-9h]
  __int128 v37; // [rsp+A8h] [rbp+7h]
  __int128 v38; // [rsp+B8h] [rbp+17h]
  __int128 v39; // [rsp+C8h] [rbp+27h]
  __int128 v40; // [rsp+D8h] [rbp+37h]
  __int128 v41; // [rsp+E8h] [rbp+47h]

  *(double *)(a1 + 0x34) = *(double *)a2;
  v41 = v2;
  v40 = v3;
  v39 = v4;
  v38 = v5;
  v37 = v6;
  v36 = v7;
  v35 = v8;
  *(_DWORD *)(a1 + 0x3C) = *(_DWORD *)(a2 + 8);
  *(double *)(a1 + 0x40) = *(double *)(a2 + 0xC);
  *(_DWORD *)(a1 + 0x48) = *(_DWORD *)(a2 + 0x14);
  v10 = *(float *)(a2 + 0x1C);
  *(float *)(a1 + 0x50) = v10;
  v11 = *(float *)(a2 + 0x18);
  *(float *)(a1 + 0x4C) = v11;
  v12 = *(float *)(a1 + 0x44);
  v13 = *(float *)(a1 + 0x48);
  v14 = 0.0;
  v26 = *(float *)(a1 + 0x40);
  v27 = v12;
  v28 = v13;
  if ( (float)((float)((float)((float)((float)(v12 * v12) + (float)(v26 * v26)) + (float)(v13 * v13)) * 0.80999994)
             - (float)(v26 * v26)) >= 0.0 )
  {
    LODWORD(v24) = LODWORD(v12) ^ 0x80000000;
    *(float *)&v23 = 0.0;
    *((float *)&v23 + 1) = v13;
  }
  else
  {
    LODWORD(v23) = LODWORD(v13) ^ 0x80000000;
    *((float *)&v23 + 1) = 0.0;
    v24 = v26;
  }
  v15 = (__m128)v23;
  v15.m128_f32[0] = (float)((float)(v15.m128_f32[0] * v15.m128_f32[0])
                          + (float)(*((float *)&v23 + 1) * *((float *)&v23 + 1)))
                  + (float)(v24 * v24);
  if ( v15.m128_f32[0] <= 9.9999997e-21 )
  {
    v19 = 1.0;
    v20 = 0.0;
  }
  else
  {
    _XMM0 = _mm_shuffle_ps(v15, v15, 0);
    __asm { vrsqrtps xmm3, xmm0 }
    _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
    v18 = (float)(1.5 - (float)((float)((float)(_XMM3.m128_f32[0] * v15.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
        * _XMM3.m128_f32[0];
    v14 = *((float *)&v23 + 1) * v18;
    v19 = v24 * v18;
    v20 = *(float *)&v23 * v18;
  }
  v21 = *(_DWORD *)(a1 + 0x3C);
  v25[3] = (float)(v12 * v19) - (float)(v13 * v14);
  v25[2] = v19;
  v25[4] = (float)(v13 * v20) - (float)(v26 * v19);
  v30 = *(_QWORD *)(a1 + 0x34);
  v29 = 1;
  v34 = v10 + v11;
  v25[0] = v20;
  v25[1] = v14;
  v25[5] = (float)(v26 * v14) - (float)(v12 * v20);
  v33 = v11;
  v32 = v11;
  v31 = v21;
  sub_146861B00(a1 + 0x58, v25);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 0x58) + 0x20LL))(a1 + 0x58, a1);
  result = a1;
  *(float *)(a1 + 0x10) = (float)(*(float *)(a1 + 0x4C) + *(float *)(a1 + 0x50)) * 0.000099999997;
  return result;
}

// --- End Function: sub_146815CE0 (0x146815CE0) ---

// --- Function: sub_1468408F0 (0x1468408F0) ---
__int64 __fastcall sub_1468408F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7)
{
  volatile signed __int32 *v9; // rbx
  __int64 result; // rax
  unsigned int v13; // edi
  __int64 v14; // rdx

  v9 = (volatile signed __int32 *)((char *)&unk_14A50FD7C + 0x1E86E8 * a7);
  if ( _InterlockedCompareExchange(v9, 0x10000, 0) )
    sub_1403A6590(v9, 0, 0x10000);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, __int64, int))(*(_QWORD *)a1 + 0x1E8LL))(
             a1,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7);
  v13 = result;
  v14 = (unsigned int)(_InterlockedExchangeAdd(v9, 0xFFFF0000) - 0x10000);
  if ( byte_149C78FC0 )
  {
    qword_149C78FD0(v9, v14);
    return v13;
  }
  return result;
}

// --- End Function: sub_1468408F0 (0x1468408F0) ---

// --- Function: sub_14688D900 (0x14688D900) ---
_BOOL8 __fastcall sub_14688D900(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // r10d
  int v4; // r11d
  float v5; // xmm9_4
  float v6; // xmm0_4
  float v7; // xmm1_4
  float v8; // xmm2_4
  float v9; // xmm3_4
  float v10; // xmm4_4
  float v11; // xmm5_4
  float v12; // xmm6_4
  float v13; // xmm14_4
  float v14; // xmm7_4
  float v15; // xmm4_4
  float v16; // xmm8_4
  float v17; // xmm6_4
  float v18; // xmm15_4
  float v19; // xmm2_4
  float v20; // xmm3_4
  float v21; // xmm4_4
  float v22; // xmm5_4
  float v23; // xmm13_4
  float v24; // xmm1_4
  float v25; // xmm6_4
  float v26; // xmm12_4
  float v27; // xmm11_4
  float v28; // kr00_4
  float v29; // xmm3_4
  float v30; // xmm0_4
  float v31; // xmm6_4
  float v32; // xmm4_4
  float v33; // xmm10_4
  float v34; // xmm1_4
  float v35; // xmm5_4
  float v36; // xmm9_4
  float v37; // xmm8_4
  float v38; // xmm7_4
  float v39; // xmm1_4
  float v40; // kr00_4
  float v41; // xmm7_4
  float v42; // xmm6_4
  float v43; // xmm5_4
  float v44; // xmm4_4
  float v45; // xmm3_4
  float v46; // xmm2_4
  float v47; // xmm0_4
  float v48; // xmm9_4
  float v49; // xmm12_4
  float v50; // xmm11_4
  float v51; // xmm13_4
  float v52; // xmm5_4
  float v53; // kr00_4
  float v54; // xmm6_4
  float v55; // xmm7_4
  float v56; // xmm10_4
  float v57; // xmm15_4
  float v58; // xmm14_4
  float v59; // xmm5_4
  float v60; // xmm6_4
  float v61; // xmm9_4
  float v63; // [rsp+B0h] [rbp+8h]
  float v64; // [rsp+B0h] [rbp+8h]

  v3 = *(_DWORD *)(a2 + 0x24);
  v4 = *(_DWORD *)(a1 + 0x24);
  if ( (v4 | (v3 << 0x10)) == *(_DWORD *)a3 )
  {
    v48 = *(float *)(a3 + 0x28);
  }
  else
  {
    if ( v4 )
    {
      if ( v3 )
      {
        v14 = *(float *)(a2 + 4);
        v15 = *(float *)(a1 + 4);
        v16 = *(float *)(a2 + 8);
        v17 = *(float *)(a1 + 8);
        v18 = *(float *)(a2 + 0x10);
        v63 = (float)((float)(v15 * v14) + (float)(*(float *)a1 * *(float *)a2)) + (float)(v17 * v16);
        v19 = (float)(v15 * v18) + (float)(*(float *)a1 * *(float *)(a2 + 0xC));
        v20 = v15 * *(float *)(a2 + 0x1C);
        v21 = *(float *)(a1 + 0xC);
        v22 = *(float *)(a1 + 0x14);
        v23 = v19 + (float)(v17 * *(float *)(a2 + 0x14));
        v24 = v17 * *(float *)(a2 + 0x20);
        v25 = *(float *)(a1 + 0x10);
        v26 = (float)(v20 + (float)(*(float *)a1 * *(float *)(a2 + 0x18))) + v24;
        v27 = (float)((float)(v25 * v14) + (float)(v21 * *(float *)a2)) + (float)(v22 * v16);
        v28 = (float)(v25 * v18) + (float)(v21 * *(float *)(a2 + 0xC));
        v29 = v25 * *(float *)(a2 + 0x1C);
        v30 = v21 * *(float *)(a2 + 0x18);
        v31 = *(float *)(a1 + 0x1C);
        v32 = *(float *)(a1 + 0x18);
        v33 = v28 + (float)(v22 * *(float *)(a2 + 0x14));
        v34 = v22 * *(float *)(a2 + 0x20);
        v35 = *(float *)(a1 + 0x20);
        v36 = (float)(v29 + v30) + v34;
        v37 = (float)((float)(v31 * v14) + (float)(v32 * *(float *)a2)) + (float)(v35 * v16);
        v38 = (float)((float)(v31 * v18) + (float)(v32 * *(float *)(a2 + 0xC))) + (float)(v35 * *(float *)(a2 + 0x14));
        v39 = v35 * *(float *)(a2 + 0x20);
        v40 = (float)(v31 * *(float *)(a2 + 0x1C)) + (float)(v32 * *(float *)(a2 + 0x18));
        *(float *)(a3 + 0x18) = v36;
        *(float *)(a3 + 0x1C) = v37;
        *(float *)(a3 + 4) = v63;
        v5 = v63;
        *(float *)(a3 + 8) = v23;
        *(float *)(a3 + 0xC) = v26;
        *(float *)(a3 + 0x10) = v27;
        *(float *)(a3 + 0x14) = v33;
        *(float *)(a3 + 0x20) = v38;
        v13 = v40 + v39;
      }
      else
      {
        v5 = *(float *)a1;
        *(float *)(a3 + 4) = *(float *)a1;
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a3 + 0xC) = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a3 + 0x10) = *(_DWORD *)(a1 + 0xC);
        *(_DWORD *)(a3 + 0x14) = *(_DWORD *)(a1 + 0x10);
        *(_DWORD *)(a3 + 0x18) = *(_DWORD *)(a1 + 0x14);
        *(_DWORD *)(a3 + 0x1C) = *(_DWORD *)(a1 + 0x18);
        *(_DWORD *)(a3 + 0x20) = *(_DWORD *)(a1 + 0x1C);
        v13 = *(float *)(a1 + 0x20);
      }
    }
    else
    {
      v5 = *(float *)a2;
      v6 = *(float *)(a2 + 0xC);
      v7 = *(float *)(a2 + 0x18);
      v8 = *(float *)(a2 + 4);
      v9 = *(float *)(a2 + 0x10);
      v10 = *(float *)(a2 + 0x1C);
      v11 = *(float *)(a2 + 8);
      v12 = *(float *)(a2 + 0x14);
      v13 = *(float *)(a2 + 0x20);
      *(float *)(a3 + 4) = *(float *)a2;
      *(float *)(a3 + 8) = v6;
      *(float *)(a3 + 0xC) = v7;
      *(float *)(a3 + 0x10) = v8;
      *(float *)(a3 + 0x14) = v9;
      *(float *)(a3 + 0x18) = v10;
      *(float *)(a3 + 0x1C) = v11;
      *(float *)(a3 + 0x20) = v12;
    }
    *(float *)(a3 + 0x24) = v13;
    *(float *)(a3 + 0x28) = v5;
    v41 = *(float *)(a3 + 8);
    *(float *)(a3 + 0x2C) = v41;
    v42 = *(float *)(a3 + 0xC);
    *(float *)(a3 + 0x30) = v42;
    v43 = *(float *)(a3 + 0x10);
    *(float *)(a3 + 0x34) = v43;
    v44 = *(float *)(a3 + 0x14);
    *(float *)(a3 + 0x38) = v44;
    v45 = *(float *)(a3 + 0x18);
    *(float *)(a3 + 0x3C) = v45;
    v46 = *(float *)(a3 + 0x1C);
    *(float *)(a3 + 0x40) = v46;
    v47 = *(float *)(a3 + 0x20);
    *(float *)(a3 + 0x44) = v47;
    *(float *)(a3 + 0x48) = COERCE_FLOAT(*(_DWORD *)(a3 + 0x24) & 0x7FFFFFFF);
    LODWORD(v48) = LODWORD(v5) & 0x7FFFFFFF;
    *(float *)(a3 + 0x28) = v48;
    *(float *)(a3 + 0x2C) = COERCE_FLOAT(LODWORD(v41) & 0x7FFFFFFF);
    *(float *)(a3 + 0x30) = COERCE_FLOAT(LODWORD(v42) & 0x7FFFFFFF);
    *(float *)(a3 + 0x34) = COERCE_FLOAT(LODWORD(v43) & 0x7FFFFFFF);
    *(float *)(a3 + 0x38) = COERCE_FLOAT(LODWORD(v44) & 0x7FFFFFFF);
    *(float *)(a3 + 0x3C) = COERCE_FLOAT(LODWORD(v45) & 0x7FFFFFFF);
    *(float *)(a3 + 0x40) = COERCE_FLOAT(LODWORD(v46) & 0x7FFFFFFF);
    *(float *)(a3 + 0x44) = COERCE_FLOAT(LODWORD(v47) & 0x7FFFFFFF);
    *(_DWORD *)a3 = *(_DWORD *)(a1 + 0x24) | (*(_DWORD *)(a2 + 0x24) << 0x10);
  }
  v49 = *(float *)(a1 + 0x38);
  v50 = *(float *)(a1 + 0x34);
  v51 = *(float *)(a1 + 0x3C);
  v52 = *(float *)(a2 + 0x2C) - *(float *)(a1 + 0x2C);
  v64 = (float)((float)(v50 + v49) + v51) * 0.000099999997;
  v53 = *(float *)(a2 + 0x28) - *(float *)(a1 + 0x28);
  v54 = *(float *)(a2 + 0x30) - *(float *)(a1 + 0x30);
  v55 = v53;
  v56 = v52;
  if ( *(_DWORD *)(a1 + 0x24) )
  {
    v55 = (float)((float)(v53 * *(float *)a1) + (float)(v52 * *(float *)(a1 + 4))) + (float)(v54 * *(float *)(a1 + 8));
    v56 = (float)((float)(v52 * *(float *)(a1 + 0x10)) + (float)(v53 * *(float *)(a1 + 0xC)))
        + (float)(v54 * *(float *)(a1 + 0x14));
    v54 = (float)((float)(v52 * *(float *)(a1 + 0x1C)) + (float)(v53 * *(float *)(a1 + 0x18)))
        + (float)(v54 * *(float *)(a1 + 0x20));
  }
  v57 = *(float *)(a2 + 0x38);
  v58 = *(float *)(a2 + 0x34);
  v59 = *(float *)(a2 + 0x3C);
  if ( COERCE_FLOAT(LODWORD(v55) & 0x7FFFFFFF) > (float)((float)((float)(v48 * v58)
                                                               + (float)(v57 * *(float *)(a3 + 0x2C)))
                                                       + (float)((float)(v59 * *(float *)(a3 + 0x30)) + v50)) )
    return 0;
  if ( COERCE_FLOAT(LODWORD(v56) & 0x7FFFFFFF) > (float)((float)((float)(v58 * *(float *)(a3 + 0x34))
                                                               + (float)(v57 * *(float *)(a3 + 0x38)))
                                                       + (float)((float)(v59 * *(float *)(a3 + 0x3C)) + v49)) )
    return 0;
  if ( COERCE_FLOAT(LODWORD(v54) & 0x7FFFFFFF) > (float)((float)((float)(v58 * *(float *)(a3 + 0x40))
                                                               + (float)(v57 * *(float *)(a3 + 0x44)))
                                                       + (float)((float)(v59 * *(float *)(a3 + 0x48)) + v51)) )
    return 0;
  if ( fabs(
         (float)((float)(v56 * *(float *)(a3 + 0x10)) + (float)(v55 * *(float *)(a3 + 4)))
       + (float)(v54 * *(float *)(a3 + 0x1C))) > (float)((float)((float)(v50 * v48)
                                                               + (float)(v49 * *(float *)(a3 + 0x34)))
                                                       + (float)((float)(v51 * *(float *)(a3 + 0x40)) + v58)) )
    return 0;
  if ( fabs(
         (float)((float)(v56 * *(float *)(a3 + 0x14)) + (float)(v55 * *(float *)(a3 + 8)))
       + (float)(v54 * *(float *)(a3 + 0x20))) > (float)((float)((float)(v49 * *(float *)(a3 + 0x38))
                                                               + (float)(v50 * *(float *)(a3 + 0x2C)))
                                                       + (float)((float)(v51 * *(float *)(a3 + 0x44)) + v57)) )
    return 0;
  if ( fabs(
         (float)((float)(v56 * *(float *)(a3 + 0x18)) + (float)(v55 * *(float *)(a3 + 0xC)))
       + (float)(v54 * *(float *)(a3 + 0x24))) > (float)((float)((float)(v49 * *(float *)(a3 + 0x3C))
                                                               + (float)(v50 * *(float *)(a3 + 0x30)))
                                                       + (float)((float)(v51 * *(float *)(a3 + 0x48))
                                                               + *(float *)(a2 + 0x3C))) )
    return 0;
  if ( fabs((float)(v54 * *(float *)(a3 + 0x10)) - (float)(v56 * *(float *)(a3 + 0x1C))) > (float)((float)((float)((float)(v49 * *(float *)(a3 + 0x40)) + (float)(v51 * *(float *)(a3 + 0x34))) + (float)((float)(v57 * *(float *)(a3 + 0x30)) + (float)(*(float *)(a2 + 0x3C) * *(float *)(a3 + 0x2C))))
                                                                                                 + v64) )
    return 0;
  if ( fabs((float)(v54 * *(float *)(a3 + 0x14)) - (float)(v56 * *(float *)(a3 + 0x20))) > (float)((float)((float)((float)(v48 * *(float *)(a2 + 0x3C)) + (float)(v58 * *(float *)(a3 + 0x30))) + (float)((float)(v49 * *(float *)(a3 + 0x44)) + (float)(v51 * *(float *)(a3 + 0x38))))
                                                                                                 + v64) )
    return 0;
  if ( fabs((float)(v54 * *(float *)(a3 + 0x18)) - (float)(v56 * *(float *)(a3 + 0x24))) > (float)((float)((float)((float)(v48 * v57) + (float)(v58 * *(float *)(a3 + 0x2C))) + (float)((float)(v49 * *(float *)(a3 + 0x48)) + (float)(v51 * *(float *)(a3 + 0x3C))))
                                                                                                 + v64) )
    return 0;
  if ( fabs((float)(v55 * *(float *)(a3 + 0x1C)) - (float)(v54 * *(float *)(a3 + 4))) > (float)((float)((float)((float)(v51 * v48) + (float)(v50 * *(float *)(a3 + 0x40))) + (float)((float)(*(float *)(a2 + 0x3C) * *(float *)(a3 + 0x38)) + (float)(v57 * *(float *)(a3 + 0x3C))))
                                                                                              + v64) )
    return 0;
  if ( fabs((float)(v55 * *(float *)(a3 + 0x20)) - (float)(v54 * *(float *)(a3 + 8))) > (float)((float)((float)((float)(v58 * *(float *)(a3 + 0x3C)) + (float)(*(float *)(a2 + 0x3C) * *(float *)(a3 + 0x34))) + (float)((float)(v50 * *(float *)(a3 + 0x44)) + (float)(v51 * *(float *)(a3 + 0x2C))))
                                                                                              + v64) )
    return 0;
  if ( fabs((float)(v55 * *(float *)(a3 + 0x24)) - (float)(v54 * *(float *)(a3 + 0xC))) > (float)((float)((float)((float)(v58 * *(float *)(a3 + 0x38)) + (float)(v57 * *(float *)(a3 + 0x34))) + (float)((float)(v50 * *(float *)(a3 + 0x48)) + (float)(v51 * *(float *)(a3 + 0x30))))
                                                                                                + v64) )
    return 0;
  v60 = *(float *)(a2 + 0x3C);
  if ( fabs((float)(v56 * *(float *)(a3 + 4)) - (float)(v55 * *(float *)(a3 + 0x10))) > (float)((float)((float)((float)(v60 * *(float *)(a3 + 0x44)) + (float)(v57 * *(float *)(a3 + 0x48))) + (float)((float)(v49 * v48) + (float)(v50 * *(float *)(a3 + 0x34))))
                                                                                              + v64) )
    return 0;
  v61 = *(float *)(a3 + 0x40);
  return fabs((float)(v56 * *(float *)(a3 + 8)) - (float)(v55 * *(float *)(a3 + 0x14))) <= (float)((float)((float)((float)(v58 * *(float *)(a3 + 0x48)) + (float)(v61 * v60)) + (float)((float)(v50 * *(float *)(a3 + 0x38)) + (float)(v49 * *(float *)(a3 + 0x2C))))
                                                                                                 + v64)
      && fabs((float)(v56 * *(float *)(a3 + 0xC)) - (float)(v55 * *(float *)(a3 + 0x18))) <= (float)((float)((float)((float)(v58 * *(float *)(a3 + 0x44)) + (float)(v61 * v57)) + (float)((float)(v50 * *(float *)(a3 + 0x3C)) + (float)(v49 * *(float *)(a3 + 0x30)))) + v64);
}

// --- End Function: sub_14688D900 (0x14688D900) ---

// --- Function: sub_146A48450 (0x146A48450) ---
__int64 __fastcall sub_146A48450(__int64 a1, int *a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int128 v6; // xmm10
  __int128 v7; // xmm11
  __int128 v8; // xmm12
  __int128 v9; // xmm13
  unsigned int v12; // r12d
  int n9; // eax
  volatile signed __int64 *p_rw_lock_state_2; // r15
  signed __int64 v15; // rdx
  __int64 v16; // rax
  float v17; // xmm2_4
  float v18; // xmm3_4
  __int64 v19; // rax
  __int64 v20; // rsi
  unsigned __int64 current_lock_value_1; // rdx
  volatile signed __int64 *p_rw_lock_state; // rcx
  volatile signed __int64 *p_rw_lock_state_1; // rsi
  signed __int64 v24; // rdx
  signed __int64 v25; // rdx
  __int64 v26; // rax
  float v27; // xmm2_4
  float v28; // xmm3_4
  float v29; // xmm6_4
  float v30; // xmm4_4
  __m128 v31; // xmm5
  float v32; // xmm7_4
  float v33; // eax
  __m128 v35; // kr00_16
  float v36; // xmm1_4
  float v37; // xmm3_4
  float v38; // xmm2_4
  float v40; // xmm1_4
  float v42; // xmm10_4
  float v43; // xmm11_4
  float v44; // xmm0_4
  float v45; // xmm2_4
  double v46; // xmm2_8
  double v47; // xmm4_8
  double v48; // xmm6_8
  double v49; // xmm5_8
  int v51; // eax
  signed __int64 v52; // rdx
  float v53; // eax
  __int64 v54; // xmm1_8
  float v55; // r13d
  __int128 v57; // xmm0
  __int64 v58; // rax
  __int64 v59; // r15
  unsigned __int64 current_lock_value; // rdx
  float v61; // xmm11_4
  float v62; // xmm12_4
  float v63; // xmm13_4
  float v64; // xmm4_4
  int v65; // eax
  int v70; // eax
  int v71; // eax
  __int64 v72; // rax
  __int64 n30; // rsi
  __int64 v74; // r13
  __int64 v75; // r8
  signed __int64 v76; // rax
  float v77; // xmm7_4
  float v78; // xmm6_4
  float v79; // xmm4_4
  double v81; // kr00_8
  unsigned __int64 n0x200000; // rax
  signed __int64 v83; // rdx
  float v84; // xmm2_4
  double v85; // xmm3_8
  float v86; // xmm4_4
  double v87; // xmm5_8
  double v88; // kr00_8
  float v89; // xmm8_4
  float v90; // xmm7_4
  float v91; // xmm10_4
  float v92; // xmm13_4
  float v93; // xmm12_4
  float v94; // xmm4_4
  float v95; // xmm11_4
  float v96; // xmm9_4
  float v97; // xmm5_4
  float v98; // kr00_4
  float v99; // xmm1_4
  double v100; // xmm4_8
  float v101; // xmm6_4
  float v102; // kr00_4
  double v103; // xmm5_8
  float v104; // xmm7_4
  float v105; // kr00_4
  float v106; // xmm9_4
  float v107; // xmm1_4
  float v108; // xmm0_4
  double v109; // xmm6_8
  double v110; // xmm2_8
  double v111; // xmm4_8
  float v112; // xmm6_4
  float v113; // xmm10_4
  float v114; // xmm11_4
  float v115; // xmm9_4
  float v116; // xmm12_4
  float v117; // xmm4_4
  float v118; // xmm13_4
  float v119; // xmm7_4
  float v120; // xmm5_4
  float v121; // xmm4_4
  float v122; // xmm8_4
  float v123; // xmm3_4
  float v124; // xmm5_4
  float v125; // xmm4_4
  float v126; // xmm12_4
  float v127; // xmm9_4
  float v128; // xmm13_4
  float v129; // xmm10_4
  float v130; // xmm4_4
  float v131; // xmm11_4
  float v132; // xmm8_4
  float v133; // kr00_4
  float v134; // xmm6_4
  float v135; // xmm4_4
  float v136; // xmm13_4
  float v137; // xmm11_4
  float v138; // xmm12_4
  float v139; // xmm9_4
  float v140; // xmm4_4
  float v141; // xmm10_4
  float v142; // xmm7_4
  float v143; // xmm8_4
  float v144; // xmm6_4
  float v145; // xmm4_4
  __int128 v146; // [rsp+58h] [rbp-B0h]
  __int64 v147; // [rsp+68h] [rbp-A0h] BYREF
  float v148; // [rsp+70h] [rbp-98h]
  __int64 v149; // [rsp+78h] [rbp-90h]
  _QWORD v150[2]; // [rsp+80h] [rbp-88h]
  __int64 v151; // [rsp+90h] [rbp-78h] BYREF
  int v152; // [rsp+98h] [rbp-70h]
  __int64 v153; // [rsp+A0h] [rbp-68h]
  __int64 v154; // [rsp+A8h] [rbp-60h]
  double v155[5]; // [rsp+B0h] [rbp-58h] BYREF
  double v156; // [rsp+D8h] [rbp-30h]
  _BYTE v157[12]; // [rsp+E0h] [rbp-28h] BYREF
  __int64 v158; // [rsp+ECh] [rbp-1Ch]
  int v159; // [rsp+F4h] [rbp-14h]
  __int128 v160; // [rsp+128h] [rbp+20h]
  __int128 v161; // [rsp+138h] [rbp+30h]
  __int128 v162; // [rsp+148h] [rbp+40h]
  __int128 v163; // [rsp+158h] [rbp+50h]
  __int128 v164; // [rsp+168h] [rbp+60h]
  __int128 v165; // [rsp+178h] [rbp+70h]
  __int128 v166; // [rsp+188h] [rbp+80h]
  __int128 v167; // [rsp+198h] [rbp+90h]
  float v168; // [rsp+1F8h] [rbp+F0h]

  v167 = v2;
  v166 = v3;
  v165 = v4;
  v164 = v5;
  v163 = v6;
  v162 = v7;
  v161 = v8;
  v160 = v9;
  v12 = 1;
  if ( (unsigned int)sub_146A8D150() )
    return v12;
  n9 = *a2;
  if ( *a2 != 2 )
  {
    if ( n9 == 53 )
    {
      p_rw_lock_state_1 = (volatile signed __int64 *)(a1 + 2424);
      v24 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 2424));
      if ( (v24 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(a1 + 2424, v24, "CActorEntity::GetStatus", "m_lockActor", 1);
      *(double *)(a2 + 21) = *(double *)(a1 + 2464);
      a2[23] = *(_DWORD *)(a1 + 2472);
      *(double *)(a2 + 1) = *(double *)(a1 + 2476);
      a2[3] = *(_DWORD *)(a1 + 2484);
      a2[16] = *(_DWORD *)(a1 + 2536);
      *((double *)a2 + 2) = *(double *)(a1 + 2488);
      a2[6] = *(_DWORD *)(a1 + 2496);
      a2[17] = *(_DWORD *)(a1 + 2540);
      *(double *)(a2 + 7) = *(double *)(a1 + 2500);
      a2[9] = *(_DWORD *)(a1 + 2508);
      a2[18] = *(_DWORD *)(a1 + 2544);
      *((double *)a2 + 5) = *(double *)(a1 + 2512);
      a2[12] = *(_DWORD *)(a1 + 2520);
      a2[19] = *(_DWORD *)(a1 + 2548);
      *(double *)(a2 + 13) = *(double *)(a1 + 2524);
      a2[15] = *(_DWORD *)(a1 + 2532);
      a2[20] = *(_DWORD *)(a1 + 2552);
    }
    else
    {
      if ( n9 != 8 )
      {
        if ( n9 == 9 )
          __debugbreak();
        v51 = *a2;
        if ( *a2 == 21 )
        {
          if ( (*(_DWORD *)(a1 + 520) & 0x420) == 0x400 )
          {
            v52 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 2424));
            if ( (v52 & 0x200000) != 0 )
              rw_lock_acquire_read_lock_dispatch(a1 + 2424, v52, "CActorEntity::GetStatus", "m_lockActor", 1);
            v53 = *(float *)(a1 + 1016);
            v54 = *(__int64 *)(a1 + 1008);
            v55 = *(float *)(a1 + 1004);
            _XMM14 = *(_OWORD *)(a1 + 448);
            v156 = *(double *)(a1 + 464);
            v57 = *(_OWORD *)(a1 + 472);
            v148 = v53;
            v58 = *(_QWORD *)(a1 + 1272);
            v146 = v57;
            v150[0] = *(_QWORD *)(a1 + 996);
            v147 = v54;
            v168 = v55;
            (*(void (__fastcall **)(__int64, _QWORD, _BYTE *))(v58 + 168))(a1 + 1272, 0, v157);
            v59 = *(_QWORD *)(a1 + 184);
            v151 = v158;
            v152 = v159;
            current_lock_value = _InterlockedDecrement64((volatile signed __int64 *)(a1 + 2424));
            if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
              rw_lock_handle_release_contention((volatile signed __int64 *)(a1 + 2424), current_lock_value);
            v153 = *((_QWORD *)a2 + 1);
            if ( (HIDWORD(v153) & 0xFFF40000) != 0xFFF40000 )
            {
              _XMM14 = *(_OWORD *)(a2 + 2);
              v156 = *((double *)a2 + 3);
            }
            if ( (a2[11] & 0xFFA00000) == 0xFFA00000 )
            {
              v64 = *((float *)&v57 + 3);
              v63 = *((float *)&v57 + 2);
              v62 = *((float *)&v57 + 1);
              LODWORD(v61) = v57;
            }
            else
            {
              LODWORD(v61) = a2[8];
              LODWORD(v62) = a2[9];
              LODWORD(v63) = a2[10];
              LODWORD(v64) = a2[11];
              *(_QWORD *)&v146 = __PAIR64__(LODWORD(v62), LODWORD(v61));
              *((_QWORD *)&v146 + 1) = __PAIR64__(LODWORD(v64), LODWORD(v63));
            }
            if ( (a2[12] & 0xFFA00000) != 0xFFA00000 )
            {
              v65 = a2[14];
              v147 = *((__int64 *)a2 + 6);
              v148 = *(float *)&v65;
            }
            _XMM3 = (unsigned int)a2[15];
            _XMM0 = a2[15] & 0xFFA00000;
            __asm
            {
              vpcmpeqd xmm2, xmm0, xmm1
              vblendvps xmm0, xmm3, xmm6, xmm2
            }
            *(float *)&v149 = *(float *)&_XMM0;
            if ( (a2[16] & 0xFFA00000) != 0xFFA00000 )
            {
              v70 = a2[18];
              v150[0] = *((_QWORD *)a2 + 8);
              v168 = *(float *)&v70;
            }
            if ( (a2[23] & 0xFFA00000) != 0xFFA00000 )
            {
              v71 = a2[25];
              v151 = *(__int64 *)(a2 + 23);
              v152 = v71;
            }
            if ( *((_QWORD *)a2 + 13) != -1 )
              v59 = *((_QWORD *)a2 + 13);
            v72 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
            v154 = v59;
            *(float *)&v147 = 1.05 * *(float *)&v147;
            *((float *)&v147 + 1) = 1.05 * *((float *)&v147 + 1);
            n30 = *(int *)(v72 + 2320);
            v148 = 1.05 * v148;
            v74 = *(_QWORD *)(a1 + 704) + 16 * (n30 + 34000);
            if ( (_DWORD)n30 == 30 )
            {
              v75 = *(_QWORD *)(NtCurrentTeb_w() + 32);
              v76 = _InterlockedCompareExchange64((volatile signed __int64 *)v74, 0x200000, 0);
              if ( v76 )
                sub_1403E1120(v74, v76, v75);
              else
                *(_QWORD *)(v74 + 8) = v75;
              LODWORD(v61) = v146;
              v62 = *((float *)&v146 + 1);
              v63 = *((float *)&v146 + 2);
              v64 = *((float *)&v146 + 3);
            }
            v77 = (float)((float)(v62 * v168) - (float)(*((float *)v150 + 1) * v63)) + (float)(*(float *)v150 * v64);
            v78 = (float)((float)(*(float *)v150 * v63) - (float)(v61 * v168)) + (float)(*((float *)v150 + 1) * v64);
            v79 = (float)((float)(v61 * *((float *)v150 + 1)) - (float)(v62 * *(float *)v150)) + (float)(v168 * v64);
            v155[0] = (float)((float)(*(float *)v150 + (float)((float)(v62 * v79) - (float)(v78 * v63)))
                            + (float)((float)(v62 * v79) - (float)(v78 * v63)))
                    + *(double *)&_XMM14;
            __asm { vunpckhpd xmm14, xmm14, xmm14 }
            v155[1] = (float)((float)(*((float *)v150 + 1) + (float)((float)(v77 * v63) - (float)(v61 * v79)))
                            + (float)((float)(v77 * v63) - (float)(v61 * v79)))
                    + *(double *)&_XMM14;
            v81 = (float)((float)(v168 + (float)((float)(v61 * v78) - (float)(v62 * v77)))
                        + (float)((float)(v61 * v78) - (float)(v62 * v77)));
            v155[2] = v81 + v156;
            sub_146A61FA0(a1, v155, (__int64)&v147, (__int64)(a2 + 19), (__int64)&v151, n30, v154);
            a2[22] = SLODWORD(v81);
            if ( v74 && (_DWORD)n30 == 30 )
            {
              n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v74, 0, 0x200000);
              if ( n0x200000 == 0x200000 )
                *(_QWORD *)(v74 + 8) = &p_Src;
              else
                rw_lock_handle_write_release_contention(v74, n0x200000);
            }
            if ( *((float *)a2 + 22) != 0.0 )
              return 0;
            return v12;
          }
        }
        else
        {
          switch ( v51 )
          {
            case '"':
              p_rw_lock_state_2 = (volatile signed __int64 *)(a1 + 2424);
              v83 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 2424));
              if ( (v83 & 0x200000) != 0 )
                rw_lock_acquire_read_lock_dispatch(a1 + 2424, v83, "CActorEntity::GetStatus", "m_lockActor", 1);
              if ( (*(_DWORD *)(a1 + 1068) & 0xFFA00000) == 0xFFA00000 )
              {
                v12 = 0;
              }
              else
              {
                *(double *)(a2 + 1) = *(double *)(a1 + 1068);
                a2[3] = *(_DWORD *)(a1 + 1076);
                *((double *)a2 + 2) = *(double *)(a1 + 1080);
                a2[6] = *(_DWORD *)(a1 + 1088);
              }
              goto LABEL_12;
            case '-':
              a2[1] = (*(unsigned __int16 *)(a1 + 2416) >> 2) & 3;
              if ( (*(_BYTE *)(a1 + 2416) & 4) != 0 )
              {
                a2[2] = *(_DWORD *)(a1 + 1688);
                *(double *)(a2 + 3) = *(double *)(a1 + 2360);
                a2[5] = *(_DWORD *)(a1 + 2368);
                if ( (*(_BYTE *)(a1 + 2416) & 8) != 0 )
                {
                  v84 = *(float *)(a1 + 2364);
                  v85 = *(double *)(a1 + 456);
                  v86 = *(float *)(a1 + 2368);
                  v87 = *(double *)(a1 + 464);
                  *((double *)a2 + 3) = *(float *)(a1 + 2360) + *(double *)(a1 + 448);
                  v88 = v86 + v87;
                  *((double *)a2 + 4) = v84 + v85;
                }
                else
                {
                  v89 = *(float *)(a1 + 480);
                  v90 = *(float *)(a1 + 472);
                  v91 = *(float *)(a1 + 476);
                  v92 = *(float *)(a1 + 2368);
                  v93 = *(float *)(a1 + 2364);
                  v94 = *(float *)(a1 + 484);
                  v95 = *(float *)(a1 + 2360);
                  v96 = (float)((float)(v92 * v91) - (float)(v93 * v89)) + (float)(v95 * v94);
                  v97 = (float)((float)(v95 * v89) - (float)(v90 * v92)) + (float)(v94 * v93);
                  v98 = (float)((float)(v90 * v93) - (float)(v95 * v91)) + (float)(v94 * v92);
                  v99 = v98 * v90;
                  v100 = *(double *)(a1 + 456);
                  v101 = (float)(v98 * v91) - (float)(v97 * v89);
                  v102 = v97 * v90;
                  v103 = *(double *)(a1 + 464);
                  v104 = v102 - (float)(v96 * v91);
                  v105 = v96 * v89;
                  v106 = *(float *)(a1 + 512);
                  *((double *)a2 + 3) = (float)((float)((float)(v101 + v95) + v101) * v106) + *(double *)(a1 + 448);
                  *((double *)a2 + 4) = (float)((float)((float)((float)(v105 - v99) + v93) + (float)(v105 - v99)) * v106)
                                      + v100;
                  v88 = (float)((float)((float)(v104 + v92) + v104) * v106) + v103;
                }
                *((double *)a2 + 5) = v88;
              }
              return v12;
            case '.':
              a2[1] = (*(unsigned __int16 *)(a1 + 2416) >> 4) & 0x1F;
              if ( (*(_BYTE *)(a1 + 2416) & 0x10) != 0 )
              {
                a2[2] = *(_DWORD *)(a1 + 1848);
                *(double *)(a2 + 3) = *(double *)(a1 + 2384);
                a2[5] = *(_DWORD *)(a1 + 2392);
                a2[18] = *(_DWORD *)(a1 + 2396);
                a2[19] = *(_DWORD *)(a1 + 2400);
                a2[20] = *(_DWORD *)(a1 + 2404);
                a2[21] = *(_DWORD *)(a1 + 2408);
                v107 = *(float *)(a1 + 2412);
                v108 = 0.0;
                if ( v107 > 0.0 )
                  v108 = 1.5707964 / v107;
                *((float *)a2 + 22) = v108;
                if ( (*(_BYTE *)(a1 + 2416) & 0x40) != 0 )
                {
                  v109 = *(float *)(a1 + 2392) + *(double *)(a1 + 464);
                  v110 = *(float *)(a1 + 2384) + *(double *)(a1 + 448);
                  v111 = *(float *)(a1 + 2388) + *(double *)(a1 + 456);
                }
                else
                {
                  v112 = *(float *)(a1 + 472);
                  v113 = *(float *)(a1 + 476);
                  v114 = *(float *)(a1 + 2392);
                  v115 = *(float *)(a1 + 480);
                  v116 = *(float *)(a1 + 2388);
                  v117 = *(float *)(a1 + 484);
                  v118 = *(float *)(a1 + 2384);
                  v119 = (float)((float)(v114 * v113) - (float)(v116 * v115)) + (float)(v118 * v117);
                  v120 = (float)((float)(v118 * v115) - (float)(v112 * v114)) + (float)(v117 * v116);
                  v121 = (float)((float)(v112 * v116) - (float)(v118 * v113)) + (float)(v117 * v114);
                  v122 = (float)(v121 * v113) - (float)(v120 * v115);
                  v123 = v120 * v112;
                  v124 = *(float *)(a1 + 512);
                  v125 = (float)(v119 * v115) - (float)(v121 * v112);
                  v109 = (float)((float)((float)((float)(v123 - (float)(v119 * v113)) + v114)
                                       + (float)(v123 - (float)(v119 * v113)))
                               * v124)
                       + *(double *)(a1 + 464);
                  v111 = (float)((float)((float)(v125 + v116) + v125) * v124) + *(double *)(a1 + 456);
                  v110 = (float)((float)((float)(v122 + v118) + v122) * v124) + *(double *)(a1 + 448);
                }
                *((double *)a2 + 3) = v110;
                *((double *)a2 + 4) = v111;
                *((double *)a2 + 5) = v109;
                if ( *(char *)(a1 + 2416) >= 0 )
                {
                  v136 = *(float *)(a1 + 2380);
                  v137 = *(float *)(a1 + 476);
                  v138 = *(float *)(a1 + 2376);
                  v139 = *(float *)(a1 + 480);
                  v140 = *(float *)(a1 + 484);
                  v141 = *(float *)(a1 + 2372);
                  v142 = *(float *)(a1 + 472);
                  v143 = (float)((float)(v137 * v136) - (float)(v139 * v138)) + (float)(v141 * v140);
                  v144 = (float)((float)(v141 * v139) - (float)(v142 * v136)) + (float)(v140 * v138);
                  v145 = (float)((float)(v142 * v138) - (float)(v141 * v137)) + (float)(v140 * v136);
                  *((float *)a2 + 15) = (float)((float)((float)(v145 * v137) - (float)(v144 * v139)) + v141)
                                      + (float)((float)(v145 * v137) - (float)(v144 * v139));
                  *((float *)a2 + 16) = (float)((float)((float)(v143 * v139) - (float)(v145 * v142)) + v138)
                                      + (float)((float)(v143 * v139) - (float)(v145 * v142));
                  *((float *)a2 + 17) = (float)((float)((float)(v144 * v142) - (float)(v143 * v137)) + v136)
                                      + (float)((float)(v144 * v142) - (float)(v143 * v137));
                  *((double *)a2 + 6) = *(double *)(a1 + 2372);
                  a2[14] = *(_DWORD *)(a1 + 2380);
                }
                else
                {
                  *(double *)(a2 + 15) = *(double *)(a1 + 2372);
                  a2[17] = *(_DWORD *)(a1 + 2380);
                  v126 = *(float *)(a1 + 2376);
                  v127 = *(float *)(a1 + 480);
                  v128 = *(float *)(a1 + 2380);
                  v129 = *(float *)(a1 + 476);
                  v130 = *(float *)(a1 + 484);
                  v131 = *(float *)(a1 + 2372);
                  v132 = *(float *)(a1 + 472);
                  v133 = (float)((float)(v127 * v126) - (float)(v129 * v128)) + (float)(v131 * v130);
                  v134 = (float)((float)(v132 * v128) - (float)(v131 * v127)) + (float)(v130 * v126);
                  v135 = (float)((float)(v131 * v129) - (float)(v132 * v126)) + (float)(v130 * v128);
                  *((float *)a2 + 12) = (float)((float)((float)(v134 * v127) - (float)(v135 * v129)) + v131)
                                      + (float)((float)(v134 * v127) - (float)(v135 * v129));
                  *((float *)a2 + 13) = (float)((float)((float)(v135 * v132) - (float)(v133 * v127)) + v126)
                                      + (float)((float)(v135 * v132) - (float)(v133 * v127));
                  *((float *)a2 + 14) = (float)((float)((float)(v133 * v129) - (float)(v134 * v132)) + v128)
                                      + (float)((float)(v133 * v129) - (float)(v134 * v132));
                }
              }
              return v12;
          }
        }
        return 0;
      }
      p_rw_lock_state_1 = (volatile signed __int64 *)(a1 + 2424);
      v25 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 2424));
      if ( (v25 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(a1 + 2424, v25, "CActorEntity::GetStatus", "m_lockActor", 1);
      *((double *)a2 + 4) = *(double *)(a1 + 972);
      a2[10] = *(_DWORD *)(a1 + 980);
      v26 = *(_QWORD *)(a1 + 2560);
      if ( v26 && *(_DWORD *)(v26 + 252) )
      {
        v27 = *(float *)(a1 + 1036);
        v28 = *(float *)(a1 + 1040);
        *((float *)a2 + 8) = *(float *)(a1 + 1032) + *((float *)a2 + 8);
        *((float *)a2 + 9) = v27 + *((float *)a2 + 9);
        *((float *)a2 + 10) = v28 + *((float *)a2 + 10);
      }
      v29 = 1.0 / *(float *)(a1 + 1244);
      v30 = *(float *)(a1 + 1128);
      v31 = (__m128)*(unsigned int *)(a1 + 1132);
      v32 = *(float *)(a1 + 1136);
      v33 = *(float *)(a1 + 1124);
      _XMM8 = *(unsigned int *)(a1 + 1140);
      v150[0] = *(_QWORD *)(a1 + 1116);
      *((float *)a2 + 14) = *(float *)v150 * v29;
      *((float *)a2 + 15) = v29 * *((float *)v150 + 1);
      v35 = v31;
      *((float *)a2 + 16) = v33 * v29;
      v35.m128_f32[0] = (float)((float)(v31.m128_f32[0] * v31.m128_f32[0]) + (float)(v30 * v30)) + (float)(v32 * v32);
      if ( v35.m128_f32[0] >= 0.0025000002 )
      {
        _XMM0 = _mm_shuffle_ps(v35, v35, 0);
        __asm { vrsqrtps xmm3, xmm0 }
        _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 255).m128_f32[0];
        v40 = (float)(1.5 - (float)((float)((float)(v35.m128_f32[0] * _XMM3.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
            * _XMM3.m128_f32[0];
        _XMM0.m128_i32[0] = -1082130432;
        v42 = v40 * v30;
        v43 = v40 * v31.m128_f32[0];
        if ( *(float *)&_XMM8 >= -1.0 )
          __asm { vminss  xmm0, xmm8, xmm9; X }
        v44 = acosf(_XMM0.m128_f32[0]);
        v45 = (float)(v44 + v44) * v29;
        v36 = (float)(v40 * v32) * v45;
        v37 = v43 * v45;
        v38 = v42 * v45;
      }
      else
      {
        v36 = (float)(v29 + v29) * v32;
        v37 = (float)(v29 + v29) * v31.m128_f32[0];
        v38 = (float)(v29 + v29) * v30;
      }
      *((float *)a2 + 11) = v38;
      *((float *)a2 + 12) = v37;
      *((float *)a2 + 13) = v36;
      v46 = *(double *)(a1 + 48);
      v47 = *(double *)(a1 + 24);
      v48 = *(double *)(a1 + 32);
      v49 = *(double *)(a1 + 56);
      *((double *)a2 + 1) = (*(double *)(a1 + 16) + *(double *)(a1 + 40)) * 0.5;
      *((double *)a2 + 2) = (v46 + v47) * 0.5;
      *((double *)a2 + 3) = (v49 + v48) * 0.5;
      a2[33] = *(_DWORD *)(a1 + 1180);
      *((double *)a2 + 13) = *(double *)(a1 + 960);
      a2[28] = *(_DWORD *)(a1 + 968);
    }
    current_lock_value_1 = _InterlockedDecrement64(p_rw_lock_state_1);
    if ( (current_lock_value_1 & 0x3FF) != 0 || (current_lock_value_1 & 0xFFFF0000FFC00000uLL) == 0 )
      return v12;
    p_rw_lock_state = p_rw_lock_state_1;
    goto LABEL_34;
  }
  p_rw_lock_state_2 = (volatile signed __int64 *)(a1 + 2424);
  v15 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 2424));
  if ( (v15 & 0x200000) != 0 )
    rw_lock_acquire_read_lock_dispatch(a1 + 2424, v15, "CActorEntity::GetStatus", "m_lockActor", 1);
  a2[1] = *(unsigned __int8 *)(a1 + 2418)
        & (*(unsigned __int8 *)(a1 + 2418) >> 1)
        & ((unsigned __int8)~*(_BYTE *)(a1 + 2418) >> 7);
  *((double *)a2 + 1) = *(double *)(a1 + 972);
  a2[4] = *(_DWORD *)(a1 + 980);
  v16 = *(_QWORD *)(a1 + 2560);
  if ( v16 && *(_DWORD *)(v16 + 252) )
  {
    v17 = *(float *)(a1 + 1036);
    v18 = *(float *)(a1 + 1040);
    *((float *)a2 + 2) = *((float *)a2 + 2) + *(float *)(a1 + 1032);
    *((float *)a2 + 3) = v17 + *((float *)a2 + 3);
    *((float *)a2 + 4) = v18 + *((float *)a2 + 4);
  }
  *(double *)(a2 + 5) = *(double *)(a1 + 972);
  a2[7] = *(_DWORD *)(a1 + 980);
  *((double *)a2 + 4) = *(double *)(a1 + 1020);
  a2[10] = *(_DWORD *)(a1 + 1028);
  *(double *)(a2 + 11) = *(double *)(a1 + 1032);
  a2[13] = *(_DWORD *)(a1 + 1040);
  a2[14] = *(_DWORD *)(a1 + 1240);
  *(double *)(a2 + 15) = *(double *)(a1 + 984);
  a2[17] = *(_DWORD *)(a1 + 992);
  a2[18] = *(_DWORD *)(a1 + 2604);
  a2[19] = *(_DWORD *)(a1 + 2608);
  a2[20] = *(_DWORD *)(a1 + 2620);
  v19 = *(_QWORD *)(a1 + 2560);
  if ( v19 )
    v20 = v19 | (*(_QWORD *)(v19 + 8) << 48);
  else
    v20 = 0;
  *((_QWORD *)a2 + 14) = v20;
  a2[30] = *(_DWORD *)(a1 + 2612);
  *(_OWORD *)(a2 + 22) = *(_OWORD *)(a1 + 2568);
  *((double *)a2 + 13) = *(double *)(a1 + 2584);
  a2[31] = (*(unsigned __int8 *)(a1 + 2418) >> 2) & 1;
  a2[33] = (*(unsigned __int8 *)(a1 + 2418) >> 3) & 1;
LABEL_12:
  current_lock_value_1 = _InterlockedDecrement64(p_rw_lock_state_2);
  if ( (current_lock_value_1 & 0x3FF) != 0 || (current_lock_value_1 & 0xFFFF0000FFC00000uLL) == 0 )
    return v12;
  p_rw_lock_state = p_rw_lock_state_2;
LABEL_34:
  rw_lock_handle_release_contention(p_rw_lock_state, current_lock_value_1);
  return v12;
}

// --- End Function: sub_146A48450 (0x146A48450) ---

// --- Function: sub_146A61FA0 (0x146A61FA0) ---
__m128 __fastcall sub_146A61FA0(
        __int64 a1,
        double *a2,
        float *a3,
        float a4,
        float *a5,
        _DWORD *a6,
        unsigned __int64 *a7,
        int n30,
        __int64 a9)
{
  __int128 v9; // xmm6
  __int128 v10; // xmm7
  __int128 v11; // xmm8
  __int128 v12; // xmm9
  __int128 v13; // xmm10
  __int128 v14; // xmm11
  __int128 v15; // xmm12
  __int128 v16; // xmm13
  __int128 v17; // xmm14
  __int128 v18; // xmm15
  float v22; // xmm1_4
  double v23; // xmm0_8
  int v24; // eax
  float v25; // xmm5_4
  float v26; // xmm6_4
  float v27; // xmm7_4
  float v28; // xmm3_4
  float v29; // xmm8_4
  float v30; // xmm3_4
  float v31; // xmm10_4
  float v32; // xmm9_4
  float v33; // xmm11_4
  float v34; // xmm14_4
  float v35; // xmm15_4
  __m128 v36; // xmm3
  float v37; // xmm5_4
  float v38; // xmm13_4
  float v39; // xmm12_4
  float v40; // xmm7_4
  float v41; // xmm6_4
  float v42; // xmm4_4
  float v43; // xmm2_4
  double v44; // xmm10_8
  double v45; // xmm11_8
  double v46; // xmm13_8
  float v47; // kr00_4
  double v48; // xmm7_8
  double v49; // xmm9_8
  int v53; // edx
  __int64 v54; // rcx
  __int64 v55; // rdi
  int v59; // eax
  float v60; // xmm14_4
  float v61; // xmm15_4
  float v62; // xmm12_4
  float v63; // kr00_4
  int v64; // ebx
  float v65; // xmm5_4
  float v66; // xmm4_4
  float v67; // xmm6_4
  float v68; // xmm8_4
  float v69; // xmm6_4
  float v70; // xmm8_4
  double v71; // kr00_8
  __int64 v72; // rax
  __int64 TlsIndex; // r15
  _QWORD *ThreadLocalStoragePointer; // r12
  _QWORD *v75; // rcx
  __int64 v76; // rax
  volatile signed __int64 *p_rw_lock_state; // r15
  signed __int64 v78; // rdx
  __int64 v79; // r9
  unsigned int v80; // r14d
  __int64 v81; // rsi
  __int64 v82; // rdx
  int v83; // eax
  __int64 v84; // r12
  __int64 v85; // rbx
  __int64 v86; // rcx
  __int64 v87; // rax
  __int64 v88; // rcx
  float v89; // xmm11_4
  float v90; // xmm12_4
  float v91; // xmm7_4
  float v92; // xmm9_4
  float v93; // xmm10_4
  float v94; // xmm13_4
  float v95; // xmm6_4
  float v96; // xmm14_4
  float v97; // xmm15_4
  float v98; // xmm8_4
  float v99; // xmm5_4
  float v100; // xmm3_4
  float v101; // xmm1_4
  float v102; // xmm6_4
  float v103; // xmm10_4
  float v104; // xmm3_4
  float v105; // xmm7_4
  float v106; // xmm4_4
  float v107; // xmm11_4
  float v108; // xmm9_4
  float v109; // xmm5_4
  float v110; // xmm8_4
  float v111; // xmm3_4
  __int64 v112; // rax
  float v113; // xmm13_4
  float v114; // xmm11_4
  float v115; // xmm6_4
  float v116; // xmm12_4
  float v117; // xmm7_4
  float v118; // xmm4_4
  float v119; // xmm9_4
  _QWORD *ThreadLocalStoragePointer_1; // r8
  float v121; // xmm10_4
  float v122; // xmm5_4
  float v123; // xmm4_4
  float v124; // xmm8_4
  float v125; // xmm0_4
  float v126; // xmm4_4
  float v127; // kr00_4
  double v128; // xmm5_8
  double v129; // xmm3_8
  unsigned __int64 current_lock_value_1; // rdx
  __int64 v131; // rbx
  volatile signed __int64 *v132; // rsi
  signed __int64 v133; // rdx
  float v134; // xmm4_4
  float v135; // xmm2_4
  float v136; // xmm5_4
  float v137; // xmm11_4
  float v138; // xmm6_4
  float v139; // xmm12_4
  float v140; // xmm0_4
  float v141; // xmm10_4
  float v142; // xmm8_4
  float v143; // xmm3_4
  float v144; // xmm9_4
  float v145; // xmm4_4
  float v146; // xmm5_4
  float v147; // xmm6_4
  float v148; // xmm2_4
  float v149; // xmm10_4
  float v150; // xmm4_4
  float v151; // xmm8_4
  __m128 v152; // xmm1
  float v153; // xmm0_4
  float v154; // xmm12_4
  float v155; // xmm11_4
  float v156; // xmm9_4
  float v157; // xmm5_4
  float v158; // xmm4_4
  float v159; // xmm7_4
  float v160; // xmm0_4
  double v161; // xmm4_8
  double v162; // xmm3_8
  unsigned __int64 current_lock_value_2; // rdx
  __int128 n0x501502F9; // xmm6
  __int64 v166; // rdx
  unsigned __int64 *v167; // rcx
  unsigned __int64 current_lock_value; // rdx
  unsigned __int64 current_lock_value_3; // rdx
  float v171; // [rsp+58h] [rbp-B0h]
  int v172; // [rsp+58h] [rbp-B0h]
  float v173; // [rsp+5Ch] [rbp-ACh]
  float v174; // [rsp+60h] [rbp-A8h]
  __int64 v175; // [rsp+68h] [rbp-A0h] BYREF
  float v176; // [rsp+70h] [rbp-98h]
  float v177; // [rsp+74h] [rbp-94h]
  __int64 v178; // [rsp+78h] [rbp-90h]
  unsigned __int64 *v179; // [rsp+80h] [rbp-88h] BYREF
  double v180; // [rsp+88h] [rbp-80h]
  double v181[3]; // [rsp+98h] [rbp-70h] BYREF
  float v182; // [rsp+B0h] [rbp-58h]
  float v183; // [rsp+B4h] [rbp-54h]
  float v184; // [rsp+B8h] [rbp-50h]
  float v185; // [rsp+BCh] [rbp-4Ch]
  float v186; // [rsp+C0h] [rbp-48h]
  float v187; // [rsp+C4h] [rbp-44h]
  float v188; // [rsp+C8h] [rbp-40h]
  float v189; // [rsp+CCh] [rbp-3Ch]
  float v190; // [rsp+D0h] [rbp-38h]
  float v191; // [rsp+D4h] [rbp-34h]
  int v192; // [rsp+D8h] [rbp-30h]
  int v193; // [rsp+DCh] [rbp-2Ch]
  unsigned int v194; // [rsp+E0h] [rbp-28h]
  float v195; // [rsp+E4h] [rbp-24h]
  float v196; // [rsp+E8h] [rbp-20h]
  float v197; // [rsp+ECh] [rbp-1Ch]
  double v198; // [rsp+F0h] [rbp-18h]
  int v200; // [rsp+108h] [rbp+0h]
  double v201; // [rsp+110h] [rbp+8h] BYREF
  __int128 v202; // [rsp+118h] [rbp+10h]
  __m256 v203; // [rsp+128h] [rbp+20h]
  float v204; // [rsp+148h] [rbp+40h]
  float v205; // [rsp+14Ch] [rbp+44h]
  float v206; // [rsp+150h] [rbp+48h]
  float v207; // [rsp+154h] [rbp+4Ch]
  __int128 v208; // [rsp+158h] [rbp+50h]
  double v210; // [rsp+178h] [rbp+70h]
  int v211; // [rsp+180h] [rbp+78h]
  __int64 v212; // [rsp+188h] [rbp+80h]
  float v213[3]; // [rsp+190h] [rbp+88h] BYREF
  double v214; // [rsp+19Ch] [rbp+94h]
  int v215; // [rsp+1A4h] [rbp+9Ch]
  float v216; // [rsp+1A8h] [rbp+A0h]
  float v217; // [rsp+1ACh] [rbp+A4h]
  double v218[3]; // [rsp+1B0h] [rbp+A8h] BYREF
  double v219[4]; // [rsp+1C8h] [rbp+C0h] BYREF
  int n0x2800; // [rsp+1E8h] [rbp+E0h] BYREF
  __int64 v221; // [rsp+1ECh] [rbp+E4h]
  int v222; // [rsp+1F4h] [rbp+ECh]
  unsigned __int64 v223; // [rsp+1F8h] [rbp+F0h]
  unsigned __int64 v224; // [rsp+200h] [rbp+F8h]
  __int64 v225; // [rsp+208h] [rbp+100h]
  __int64 v226; // [rsp+210h] [rbp+108h]
  _QWORD v227[2]; // [rsp+238h] [rbp+130h] BYREF
  float v228; // [rsp+248h] [rbp+140h]
  int n3; // [rsp+24Ch] [rbp+144h]
  int v230; // [rsp+250h] [rbp+148h]
  int n0x12; // [rsp+28Ch] [rbp+184h]
  __int64 (__fastcall **v232)(); // [rsp+290h] [rbp+188h]
  __int64 v233; // [rsp+2E0h] [rbp+1D8h]
  _BYTE v234[20]; // [rsp+2E8h] [rbp+1E0h] BYREF
  float v235; // [rsp+2FCh] [rbp+1F4h]
  _QWORD v236[6]; // [rsp+308h] [rbp+200h] BYREF
  _DWORD v237[18]; // [rsp+338h] [rbp+230h] BYREF
  double v238; // [rsp+380h] [rbp+278h]
  __m256 v239; // [rsp+388h] [rbp+280h]
  double v240; // [rsp+3A8h] [rbp+2A0h]
  int v241; // [rsp+3B0h] [rbp+2A8h]
  __int16 v242; // [rsp+3B4h] [rbp+2ACh]
  char v243; // [rsp+3B6h] [rbp+2AEh]
  __int64 v244; // [rsp+3B8h] [rbp+2B0h]
  __int64 v245; // [rsp+3C4h] [rbp+2BCh]
  __int64 v246; // [rsp+3D0h] [rbp+2C8h]
  __int128 v247; // [rsp+3E8h] [rbp+2E0h]
  __int128 v248; // [rsp+3F8h] [rbp+2F0h]
  __int128 v249; // [rsp+408h] [rbp+300h]
  __int128 v250; // [rsp+418h] [rbp+310h]
  __int128 v251; // [rsp+428h] [rbp+320h]
  __int128 v252; // [rsp+438h] [rbp+330h]
  __int128 v253; // [rsp+448h] [rbp+340h]
  __int128 v254; // [rsp+458h] [rbp+350h]
  __int128 v255; // [rsp+468h] [rbp+360h]
  __int128 v256; // [rsp+478h] [rbp+370h]

  v256 = v9;
  v255 = v10;
  v254 = v11;
  v253 = v12;
  v252 = v13;
  v251 = v14;
  v250 = v15;
  v249 = v16;
  v248 = v17;
  v247 = v18;
  v221 = 0;
  v222 = 0;
  v224 = 0;
  v225 = 0;
  v226 = 0;
  *(float *)&v178 = a4;
  v212 = (__int64)a6;
  n0x2800 = 0x2800;
  v223 = __rdtsc();
  qword_149C89AA0(
    &n0x2800,
    &word_1516E1350,
    "CActorEntity::UnprojectionNeeded",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryPhysics\\actorentity.cpp",
    0x9BB);
  HIWORD(n0x2800) = word_1516E1350;
  sub_14675E7F0(v236, "CActorEntity::UnprojectionNeeded", a1, (__int64)a2, a9);
  sub_1467F5530((__int64)v227);
  v230 = 1;
  _InterlockedExchangeAdd(&dword_15164C220, 1u);
  v233 = 1;
  v227[0] = off_148D32070;
  v232 = &off_148D27338;
  v228 = 0.0;
  n3 = 3;
  n0x12 = 0x12;
  _InterlockedIncrement(&dword_15164C224);
  v22 = a5[2];
  v216 = *a5;
  v23 = *(double *)a7;
  v227[0] = off_148D322D8;
  v24 = *((_DWORD *)a7 + 2);
  v214 = v23;
  v215 = v24;
  v217 = v22;
  v213[2] = 0.0;
  v213[1] = 0.0;
  v213[0] = 0.0;
  sub_146815CE0((__int64)v227, (__int64)v213);
  v25 = *a3;
  v26 = a3[1];
  v27 = a3[3];
  LODWORD(v28) = *(_DWORD *)a3 ^ 0x80000000;
  v29 = a3[2];
  *(float *)&v23 = v29 * v28;
  v30 = *a3 * v28;
  v177 = (float)((float)(v26 * v27) - *(float *)&v23) + (float)((float)(v26 * v27) - *(float *)&v23);
  v31 = v26 * (float)(v29 + v29);
  v173 = (float)((float)(v29 * v26) - (float)(v25 * v27)) + (float)((float)(v29 * v26) - (float)(v25 * v27));
  v174 = (float)((float)(v30 - (float)(v26 * v26)) + 1.0) + (float)(v30 - (float)(v26 * v26));
  v32 = 1.0 - (float)(v25 * (float)(v25 + v25));
  v33 = v27 * (float)(v25 + v25);
  v176 = v27 * (float)(v26 + v26);
  v171 = v25 * (float)(v29 + v29);
  v34 = v26 * (float)(v26 + v26);
  v35 = v25 * (float)(v26 + v26);
  v36 = (__m128)*a7;
  v37 = a5[2];
  v38 = v27 * (float)(v29 + v29);
  v39 = v29 * (float)(v29 + v29);
  v40 = (float)(v37 * *((float *)a7 + 2)) + *a5;
  v41 = (float)(_mm_shuffle_ps(v36, v36, 0x55).m128_f32[0] * v37) + *a5;
  v42 = (float)(v36.m128_f32[0] * v37) + *a5;
  v180 = (float)((float)((float)(fabs(v171 - v176) * v42) + (float)(fabs(v31 + v33) * v41))
               + (float)(fabs(v32 - v34) * v40));
  v43 = v31 - v33;
  v44 = a2[1];
  v45 = (float)((float)((float)(fabs(v38 + v35) * v42) + (float)(fabs(v32 - v39) * v41))
              + (float)(COERCE_FLOAT(LODWORD(v43) & 0x7FFFFFFF) * v40));
  *(float *)&v23 = v35 - v38;
  v46 = a2[2];
  v47 = (float)(fabs((float)(1.0 - v34) - v39) * v42) + (float)(COERCE_FLOAT(LODWORD(v23) & 0x7FFFFFFF) * v41);
  *(float *)&v23 = fabs(v171 + v176) * v40;
  v48 = *a2;
  v49 = (float)(v47 + *(float *)&v23);
  _XMM2 = COERCE_UNSIGNED_INT64(v173 * v45 + v177 * v49 + v174 * v180);
  __asm
  {
    vmaxsd  xmm0, xmm2, xmm12
    vcvtsd2ss xmm4, xmm0, xmm0
  }
  *(float *)&_XMM0 = *a5 + *(float *)&v178;
  v218[0] = (float)(*(float *)&_XMM4 * v177) + *a2 - v49;
  v219[0] = (float)(*(float *)&_XMM0 * v177) + v48 + v49;
  v218[1] = (float)(*(float *)&_XMM4 * v173) + v44 - v45;
  v218[2] = v46 - v180 + (float)(*(float *)&_XMM4 * v174);
  v195 = 0.0;
  v196 = 0.0;
  v219[1] = (float)(*(float *)&_XMM0 * v173) + v44 + v45;
  v219[2] = (float)(*(float *)&_XMM0 * v174) + v46 + v180;
  v53 = *(_DWORD *)(a1 + 0x4F0);
  v54 = *(_QWORD *)(a1 + 0x2C0);
  v55 = 0;
  _XMM0 = 0;
  __asm { vmovupd [rbp+3B0h+var_3C0], xmm0 }
  v208 = 0;
  v203 = ymmword_1483778E0;
  _XMM0 = 0;
  __asm { vmovupd [rbp+3B0h+var_350], xmm0 }
  *(float *)&v237[8] = 0.000001;
  _XMM1 = 0;
  v239 = ymmword_1489C3E40;
  v197 = 0.0;
  v206 = 0.0;
  v207 = 0.0;
  *(float *)&v237[0xA] = 0.0;
  *(float *)&v237[1] = 0.0;
  *(float *)&v237[2] = 0.0;
  *(float *)&v237[3] = 0.0;
  *(float *)&v237[0xE] = 0.0;
  *(float *)&v237[0xF] = 0.0;
  *(float *)&v237[0xB] = 0.0;
  *(float *)&v237[0xC] = 0.0;
  *(float *)&v237[0xD] = 0.0;
  *(float *)&v237[4] = 0.0;
  *(float *)&v237[5] = 0.0;
  *(float *)&v237[6] = 0.0;
  __asm { vmovupd [rbp+3B0h+var_3A0], xmm1 }
  *(float *)&v237[0x11] = 1.0e10;
  v198 = 0.0;
  v191 = 1.0;
  v201 = 0.0;
  v204 = 1.0;
  v210 = 0.0;
  v205 = 1.0;
  *(float *)&v237[9] = 0.017453292;
  *(float *)&v237[0x10] = 1.0;
  v238 = 1.999999999998e12;
  v240 = 1.999999999998e12;
  v200 = 0;
  v211 = 0;
  v237[0] = 0;
  v246 = 0;
  v241 = 0;
  v242 = 0;
  v243 = 0;
  v244 = 0;
  v245 = 0;
  __asm { vzeroupper }
  v59 = sub_146AD98E0(v54, v218, v219, &v175, v53 & 0xFFF7FEEF | 0x80000, a1, n30, a9, 0);
  v60 = *a3;
  v61 = a3[1];
  *(float *)&v46 = a3[2];
  v62 = a3[3];
  v63 = 1.0 - (float)((float)(v60 + v60) * v60);
  v64 = v59;
  v172 = v59;
  *(float *)&v44 = (float)(v61 + v61) * v61;
  *(float *)&v49 = v62 * (float)(v60 + v60);
  *(float *)&v48 = v62 * (float)(v61 + v61);
  v65 = *a3 * (float)(v61 + v61);
  v66 = (float)(*(float *)&v46 + *(float *)&v46) * *(float *)&v46;
  v182 = (float)(1.0 - *(float *)&v44) - v66;
  v67 = v60 * (float)(*(float *)&v46 + *(float *)&v46);
  v68 = v61 * (float)(*(float *)&v46 + *(float *)&v46);
  v184 = v67 + *(float *)&v48;
  v36.m128_f32[0] = v62 * (float)(*(float *)&v46 + *(float *)&v46);
  v185 = v36.m128_f32[0] + v65;
  v183 = v65 - v36.m128_f32[0];
  v186 = v63 - v66;
  v188 = v67 - *(float *)&v48;
  v187 = v68 - *(float *)&v49;
  v189 = v68 + *(float *)&v49;
  v190 = v63 - *(float *)&v44;
  v69 = -(float)(v60 * *(float *)&v178);
  v70 = v61 * *(float *)&v178;
  v181[0] = (float)((float)((float)(v61 * (float)(v62 * *(float *)&v178)) - (float)(*(float *)&v46 * v69))
                  + (float)((float)(v61 * (float)(v62 * *(float *)&v178)) - (float)(*(float *)&v46 * v69)))
          + *a2;
  v71 = (float)((float)((float)(v60 * v69) - (float)(v61 * v70))
              + (float)((float)((float)(v60 * v69) - (float)(v61 * v70)) + *(float *)&v178))
      + a2[2];
  LODWORD(_XMM2) = a6[1];
  v181[1] = (float)((float)((float)(*(float *)&v46 * v70) - (float)(v60 * (float)(v62 * *(float *)&v178)))
                  + (float)((float)(*(float *)&v46 * v70) - (float)(v60 * (float)(v62 * *(float *)&v178))))
          + a2[1];
  LODWORD(_XMM0) = *a6;
  v181[2] = v71;
  v72 = *(_QWORD *)(a1 + 0x4F8);
  v192 = _XMM0 ^ 0x80000000;
  v194 = a6[2] ^ 0x80000000;
  v193 = _XMM2 ^ 0x80000000;
  (*(void (__fastcall **)(__int64, _QWORD, _BYTE *))(v72 + 0xA8))(a1 + 0x4F8, 0, v234);
  *(float *)&v237[7] = (float)(*(float *)(a1 + 0x3F0) + *(float *)(a1 + 0x3F0))
                     + (float)((float)(v235 * *(float *)(a1 + 0x3F8)) + (float)(v235 * *(float *)(a1 + 0x3F8)));
  if ( v64 <= 0 )
  {
LABEL_32:
    n0x501502F9 = 0;
    goto LABEL_33;
  }
  TlsIndex = (unsigned int)::TlsIndex;
  ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
  while ( 1 )
  {
    v75 = *(_QWORD **)(v175 + 8 * v55);
    if ( v75 == (_QWORD *)a1 )
      goto LABEL_31;
    v76 = *(_QWORD *)(a1 + 0xC0);
    if ( v76 )
    {
      if ( v75[0x18] == v76 )
        goto LABEL_31;
    }
    if ( (__ROR8__(v75[0x43], 0x20) & *(_QWORD *)(a1 + 0x218)) != 0
      || (*(unsigned __int8 (__fastcall **)(_QWORD *, __int64, __int64))(*v75 + 0x1F8LL))(v75, a1, 1) )
    {
      goto LABEL_31;
    }
    if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(v175 + 8 * v55) + 8LL))(*(_QWORD *)(v175 + 8 * v55)) != 0xB )
    {
      p_rw_lock_state = (volatile signed __int64 *)(*(_QWORD *)(v175 + 8 * v55) + 0xC8LL);
      v78 = _InterlockedIncrement64(p_rw_lock_state);
      if ( (v78 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch(
          (__int64)p_rw_lock_state,
          v78,
          "CActorEntity::UnprojectionNeeded",
          "pentlist[i]->m_lockUpdate",
          1);
      v79 = v175;
      v80 = 0;
      v81 = 0;
      v82 = *(_QWORD *)(v175 + 8 * v55);
      v83 = (*(int *)(v82 + 0x294) >> 0x1F) & *(_DWORD *)(v82 + 0x290);
      v84 = v83 | *(_DWORD *)(v82 + 0x294) & ~(*(int *)(v82 + 0x294) >> 0x1F);
      if ( (v83 | *(_DWORD *)(v82 + 0x294) & ~(*(int *)(v82 + 0x294) >> 0x1F)) > 0 )
      {
        v85 = 0;
        while ( 1 )
        {
          v86 = *(_QWORD *)(v79 + 8 * v55);
          if ( (*(_QWORD *)(*(_QWORD *)(v86 + 0x240) + 8 * v81)
              & (((*(__int64 *)(*(_QWORD *)(v86 + 0x240) + 8 * v81) >> 0x12) & 1) - 1)
              & **(_QWORD **)(a1 + 0x248)) != 0 )
          {
            if ( (unsigned __int8)sub_146A94170(v86, v80, v218) )
            {
              v87 = *(_QWORD *)(v175 + 8 * v55);
              v88 = *(_QWORD *)(v87 + 0x230);
              v89 = *(float *)(v87 + 0x1D8);
              v90 = *(float *)(v87 + 0x1DC);
              v91 = *(float *)(v87 + 0x1E4);
              v92 = *(float *)(v87 + 0x1E0);
              v93 = *(float *)(v85 + v88);
              v94 = *(float *)(v85 + v88 + 8);
              v95 = *(float *)(v85 + v88 + 0xC);
              v96 = *(float *)(v85 + v88 + 4);
              v97 = (float)((float)((float)(v96 * v89) - (float)(v93 * v90)) + (float)(v94 * v91)) + (float)(v95 * v92);
              v98 = (float)((float)((float)(v93 * v92) - (float)(v94 * v89)) + (float)(v96 * v91)) + (float)(v95 * v90);
              v99 = (float)((float)((float)(v94 * v90) - (float)(v96 * v92)) + (float)(v93 * v91)) + (float)(v95 * v89);
              v100 = v95 * v91;
              v101 = v93 * v89;
              v102 = (float)(v98 + v98) * v99;
              v103 = (float)(v98 + v98) * v98;
              v104 = v100 - (float)((float)(v101 + (float)(v96 * v90)) + (float)(v94 * v92));
              v105 = (float)(v98 + v98) * v104;
              v106 = (float)(v97 + v97) * v99;
              v107 = 1.0 - (float)((float)(v99 + v99) * v99);
              v108 = (float)(v99 + v99) * v104;
              v109 = (float)(v97 + v97) * v97;
              v203.m256_f32[0] = (float)(1.0 - v103) - v109;
              v203.m256_f32[2] = v106 + v105;
              v203.m256_f32[4] = v107 - v109;
              v203.m256_f32[6] = v106 - v105;
              v110 = (float)(v97 + v97) * v98;
              v204 = v107 - v103;
              v111 = (float)(v97 + v97) * v104;
              v203.m256_f32[3] = v111 + v102;
              v203.m256_f32[5] = v110 - v108;
              v203.m256_f32[1] = v102 - v111;
              v203.m256_f32[7] = v110 + v108;
              v112 = *(_QWORD *)(v175 + 8 * v55);
              v113 = *(float *)(v85 + v88 + 0x18);
              v114 = *(float *)(v85 + v88 + 0x14);
              v115 = *(float *)(v85 + v88 + 0x10);
              v116 = *(float *)(v112 + 0x1DC);
              v117 = *(float *)(v112 + 0x1E0);
              v118 = *(float *)(v112 + 0x1E4);
              v119 = *(float *)(v112 + 0x1D8);
              ThreadLocalStoragePointer_1 = NtCurrentTeb()->ThreadLocalStoragePointer;
              v121 = (float)((float)(v113 * v116) - (float)(v114 * v117)) + (float)(v115 * v118);
              v122 = (float)((float)(v115 * v117) - (float)(v119 * v113)) + (float)(v118 * v114);
              v123 = (float)((float)(v119 * v114) - (float)(v115 * v116)) + (float)(v118 * v113);
              v124 = (float)((float)(v123 * v116) - (float)(v122 * v117))
                   + (float)((float)((float)(v123 * v116) - (float)(v122 * v117)) + v115);
              v125 = v123 * v119;
              v126 = *(float *)(v112 + 0x200);
              v127 = v122 * v119;
              v128 = *(double *)(v112 + 0x1D0);
              v129 = *(double *)(v112 + 0x1C8);
              v201 = (float)(v124 * v126) + *(double *)(v112 + 0x1C0);
              *(double *)&v202 = (float)((float)((float)((float)(v121 * v117) - v125)
                                               + (float)((float)((float)(v121 * v117) - v125) + v114))
                                       * v126)
                               + v129;
              *((double *)&v202 + 1) = (float)((float)((float)(v127 - (float)(v121 * v116))
                                                     + (float)((float)(v127 - (float)(v121 * v116)) + v113))
                                             * v126)
                                     + v128;
              v205 = *(float *)(*(_QWORD *)(v175 + 8 * v55) + 0x200LL) * *(float *)(v85 + v88 + 0x1C);
              if ( (unsigned int)sub_1468408F0(
                                   (__int64)v227,
                                   **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v175 + 8 * v55) + 0x238LL) + 8 * v81),
                                   (__int64)v181,
                                   (__int64)&v201,
                                   (__int64)v237,
                                   (__int64)&v179,
                                   *(_DWORD *)(ThreadLocalStoragePointer_1[::TlsIndex] + 0x910LL)) )
              {
                v166 = v212;
                v167 = v179;
                if ( (float)((float)((float)(*(float *)v212 * *(float *)v212)
                                   + (float)(*(float *)(v212 + 4) * *(float *)(v212 + 4)))
                           + (float)(*(float *)(v212 + 8) * *(float *)(v212 + 8))) == 0.0 )
                {
                  *(double *)v212 = *(double *)((char *)v179 + 0x6C);
                  *(_DWORD *)(v166 + 8) = *((_DWORD *)v167 + 0x1D);
                }
                _XMM6 = *v167;
                __asm { vcvtpd2ps xmm6, xmm6 }
                current_lock_value = _InterlockedDecrement64(p_rw_lock_state);
                if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
                  rw_lock_handle_release_contention(p_rw_lock_state, current_lock_value);
                goto LABEL_33;
              }
            }
            v79 = v175;
          }
          ++v80;
          ++v81;
          v85 += 0x20;
          if ( v81 >= v84 )
          {
            v64 = v172;
            break;
          }
        }
      }
      current_lock_value_1 = _InterlockedDecrement64(p_rw_lock_state);
      if ( (current_lock_value_1 & 0x3FF) == 0 && (current_lock_value_1 & 0xFFFF0000FFC00000uLL) != 0 )
        rw_lock_handle_release_contention(p_rw_lock_state, current_lock_value_1);
      TlsIndex = (unsigned int)::TlsIndex;
      ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
      goto LABEL_31;
    }
    v131 = *(_QWORD *)(v175 + 8 * v55);
    if ( (**(_QWORD **)(v131 + 0x240) & **(_QWORD **)(a1 + 0x248)) != 0 )
      break;
LABEL_30:
    v64 = v172;
LABEL_31:
    if ( ++v55 >= v64 )
      goto LABEL_32;
  }
  v132 = (volatile signed __int64 *)(v131 + 0xC8);
  v133 = _InterlockedIncrement64((volatile signed __int64 *)(v131 + 0xC8));
  if ( (v133 & 0x200000) != 0 )
    rw_lock_acquire_read_lock_dispatch(v131 + 0xC8, v133, "CActorEntity::UnprojectionNeeded", "pent->m_lockUpdate", 1);
  v134 = *(float *)(v131 + 0x1D8);
  v135 = *(float *)(v131 + 0x1DC);
  v136 = *(float *)(v131 + 0x1E0);
  v137 = (float)(v135 + v135) * v135;
  v138 = (float)(v135 + v135) * v134;
  v139 = 1.0 - (float)((float)(v134 + v134) * v134);
  v140 = *(float *)(v131 + 0x1E4);
  v141 = (float)(v134 + v134) * v140;
  v142 = (float)(v135 + v135) * v140;
  v143 = (float)(v136 + v136) * v140;
  v144 = v135 * (float)(v136 + v136);
  v203.m256_f32[1] = v138 - v143;
  v145 = (float)(v136 + v136) * v134;
  v146 = (float)(v136 + v136) * v136;
  v203.m256_f32[0] = (float)(1.0 - v137) - v146;
  v203.m256_f32[3] = v143 + v138;
  v203.m256_f32[2] = v145 + v142;
  v203.m256_f32[4] = v139 - v146;
  v203.m256_f32[6] = v145 - v142;
  v204 = v139 - v137;
  v203.m256_f32[5] = v144 - v141;
  v203.m256_f32[7] = v144 + v141;
  v147 = *(float *)(v131 + 0x1E0);
  v148 = *(float *)(v131 + 0x200);
  v149 = *(float *)(v131 + 0x1DC);
  v150 = *(float *)(v131 + 0x1E4);
  v151 = *(float *)(v131 + 0x1D8);
  v152 = (__m128)*(unsigned __int64 *)(v131 + 0x3E4);
  v153 = _mm_shuffle_ps(v152, v152, 0x55).m128_f32[0];
  v154 = (float)(v148 * *(float *)(v131 + 0x3EC)) + *(float *)(v131 + 0x490);
  v155 = v153 * v148;
  v156 = (float)((float)(v154 * v149) - (float)(v147 * (float)(v153 * v148)))
       + (float)(v150 * (float)(v152.m128_f32[0] * v148));
  v157 = (float)((float)(v147 * (float)(v152.m128_f32[0] * v148)) - (float)(v154 * v151))
       + (float)(v150 * (float)(v153 * v148));
  v158 = (float)((float)(v151 * (float)(v153 * v148)) - (float)(v149 * (float)(v152.m128_f32[0] * v148)))
       + (float)(v154 * v150);
  v159 = (float)((float)(v149 * v158) - (float)(v147 * v157))
       + (float)((float)(v152.m128_f32[0] * v148) + (float)((float)(v149 * v158) - (float)(v147 * v157)));
  v160 = v151 * v158;
  v161 = *(double *)(v131 + 0x1D0);
  v162 = *(double *)(v131 + 0x1C8);
  v201 = v159 + *(double *)(v131 + 0x1C0);
  *(double *)&v202 = (float)((float)((float)(v147 * v156) - v160) + (float)(v155 + (float)((float)(v147 * v156) - v160)))
                   + v162;
  *((double *)&v202 + 1) = (float)((float)((float)(v151 * v157) - (float)(v149 * v156))
                                 + (float)(v154 + (float)((float)(v151 * v157) - (float)(v149 * v156))))
                         + v161;
  v205 = *(float *)(*(_QWORD *)(v131 + 0x230) + 0x1CLL) * *(float *)(v131 + 0x200);
  if ( !(unsigned int)sub_1468408F0(
                        (__int64)v227,
                        ***(_QWORD ***)(v131 + 0x238),
                        (__int64)v181,
                        (__int64)&v201,
                        (__int64)v237,
                        (__int64)&v179,
                        *(_DWORD *)(ThreadLocalStoragePointer[TlsIndex] + 0x910LL)) )
  {
    current_lock_value_2 = _InterlockedDecrement64(v132);
    if ( (current_lock_value_2 & 0x3FF) == 0 && (current_lock_value_2 & 0xFFFF0000FFC00000uLL) != 0 )
      rw_lock_handle_release_contention((volatile signed __int64 *)(v131 + 0xC8), current_lock_value_2);
    goto LABEL_30;
  }
  current_lock_value_3 = _InterlockedDecrement64(v132);
  if ( (current_lock_value_3 & 0x3FF) == 0 && (current_lock_value_3 & 0xFFFF0000FFC00000uLL) != 0 )
    rw_lock_handle_release_contention((volatile signed __int64 *)(v131 + 0xC8), current_lock_value_3);
  n0x501502F9 = 0x501502F9u;
LABEL_33:
  _InterlockedExchangeAdd(&dword_15164C224, 0xFFFFFFFF);
  v232 = &off_148D26C98;
  _InterlockedExchangeAdd(&dword_15164C220, 0xFFFFFFFF);
  sub_1467F6A30((__int64)v227);
  sub_146762B50((__int64)v236);
  v224 = __rdtsc();
  qword_149C89AA8(&n0x2800);
  return (__m128)n0x501502F9;
}

// --- End Function: sub_146A61FA0 (0x146A61FA0) ---

// --- Function: sub_146A68B00 (0x146A68B00) ---
__int64 __fastcall sub_146A68B00(unsigned __int64 *a1, int *a2, _DWORD *a3, __int64 a4, float *a5, __int64 *a6)
{
  __int64 v10; // r8
  __int64 v11; // r14
  __int64 v12; // rdx
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // r12
  __int64 v17; // rdi
  __int64 v18; // r14
  __int64 v19; // rcx
  float v20; // xmm1_4
  int *v21; // r8
  int *v22; // r10
  __int64 v23; // rcx
  _DWORD *v24; // rdx
  int v25; // eax
  double v26; // xmm0_8
  __int64 result; // rax

  v10 = 0x555555555555555LL;
  v11 = (__int64)((__int64)a2 - *a1) / 0x30;
  v12 = (__int64)(a1[1] - *a1) / 0x30;
  if ( v12 == 0x555555555555555LL )
    unknown_libname_10();
  v13 = v12 + 1;
  v14 = (__int64)(a1[2] - *a1) / 0x30;
  v15 = v14 >> 1;
  if ( v14 <= 0x555555555555555LL - (v14 >> 1) )
  {
    v10 = v15 + v14;
    if ( v15 + v14 < v13 )
      v10 = v13;
  }
  v16 = 0x30 * v10;
  v17 = sub_140394E70((__int64)a1, 0x30 * v10);
  v18 = v17 + 0x30 * v11;
  v19 = *a6;
  v20 = *a5;
  *(_DWORD *)v18 = *a3;
  *(double *)(v18 + 4) = *(double *)(a4 + 0x10);
  *(_DWORD *)(v18 + 0xC) = *(_DWORD *)(a4 + 0x18);
  *(_DWORD *)(v18 + 0x1C) = *(_DWORD *)(a4 + 0xC);
  *(_DWORD *)(v18 + 0x10) = *(_DWORD *)a4;
  *(_DWORD *)(v18 + 0x14) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(v18 + 0x18) = *(_DWORD *)(a4 + 8);
  *(float *)(v18 + 0x20) = v20 * *(float *)(a4 + 0x1C);
  *(_QWORD *)(v18 + 0x28) = v19;
  v21 = (int *)a1[1];
  v22 = (int *)*a1;
  if ( a2 == v21 )
  {
    if ( v22 != v21 )
    {
      v23 = v17 + 0x14;
      v24 = v22 + 5;
      do
      {
        v25 = *v22;
        v22 += 0xC;
        *(_DWORD *)(v23 - 0x14) = v25;
        v23 += 0x30;
        v26 = *((double *)v24 + 0xFFFFFFFE);
        v24 += 0xC;
        *(double *)(v23 - 0x40) = v26;
        *(_DWORD *)(v23 - 0x38) = v24[0xFFFFFFF2];
        *(_DWORD *)(v23 - 0x28) = v24[0xFFFFFFF6];
        *(_DWORD *)(v23 - 0x34) = v24[0xFFFFFFF3];
        *(_DWORD *)(v23 - 0x30) = v24[0xFFFFFFF4];
        *(_DWORD *)(v23 - 0x2C) = v24[0xFFFFFFF5];
        *(_DWORD *)(v23 - 0x24) = v24[0xFFFFFFF7];
        *(_QWORD *)(v23 - 0x1C) = *(_QWORD *)(v24 + 0xFFFFFFF9);
      }
      while ( v22 != v21 );
    }
  }
  else
  {
    sub_146A69850(*a1, a2, v17, a1);
    sub_146A69850(a2, a1[1], v18 + 0x30, a1);
  }
  if ( *a1 )
    sub_1403A6820((__int64)a1, *a1, 0x30 * ((__int64)(a1[2] - *a1) / 0x30));
  *a1 = v17;
  result = v18;
  a1[1] = v17 + 0x30 * v13;
  a1[2] = v16 + v17;
  return result;
}

// --- End Function: sub_146A68B00 (0x146A68B00) ---

// --- Function: sub_146A8A730 (0x146A8A730) ---
char __fastcall sub_146A8A730(__int64 *a1, double *a2, double *a3, float *a4, float *a5)
{
  __int128 v5; // xmm14
  __int128 v6; // xmm15
  __int64 v7; // rax
  __int64 v12; // rax
  float *v14; // rax
  float *v15; // r15
  float v19; // xmm4_4
  float v20; // xmm7_4
  float v21; // xmm9_4
  float v22; // xmm10_4
  float v23; // xmm11_4
  float v24; // xmm12_4
  float v25; // xmm13_4
  float v26; // xmm8_4
  float v27; // xmm6_4
  float v28; // xmm4_4
  float *v29; // rbx
  float *v30; // rax
  float v31; // xmm12_4
  float v32; // xmm11_4
  float v33; // xmm13_4
  float v34; // xmm10_4
  float v35; // xmm9_4
  float v36; // xmm4_4
  float v37; // xmm7_4
  float v38; // xmm8_4
  float v39; // xmm6_4
  float v40; // xmm4_4
  __int64 v41; // rax
  double v42; // xmm1_8
  double *v43; // rax
  double v44; // xmm1_8
  double v45; // xmm1_8
  double *v46; // rax
  double v47; // xmm1_8
  float v49; // kr00_4
  __int128 v51; // [rsp+20h] [rbp-E0h] BYREF
  double v52; // [rsp+30h] [rbp-D0h]
  __int128 v53; // [rsp+38h] [rbp-C8h] BYREF
  double v54; // [rsp+48h] [rbp-B8h]
  int n8; // [rsp+50h] [rbp-B0h] BYREF
  _BYTE v56[24]; // [rsp+58h] [rbp-A8h]
  __int128 v57; // [rsp+70h] [rbp-90h]
  __int128 v58; // [rsp+80h] [rbp-80h]
  __int128 v59; // [rsp+90h] [rbp-70h]
  __int128 v60; // [rsp+A0h] [rbp-60h]
  __int128 v61; // [rsp+B0h] [rbp-50h]
  __int128 v62; // [rsp+C0h] [rbp-40h]
  float v63; // [rsp+D0h] [rbp-30h]
  float v64; // [rsp+D4h] [rbp-2Ch]
  float v65; // [rsp+D8h] [rbp-28h]
  int v66; // [rsp+DCh] [rbp-24h]
  __int128 v67; // [rsp+E0h] [rbp-20h]
  int v68; // [rsp+F0h] [rbp-10h]
  float v69; // [rsp+F4h] [rbp-Ch]
  unsigned int v70; // [rsp+F8h] [rbp-8h]
  int v71; // [rsp+FCh] [rbp-4h]
  __int128 v72; // [rsp+220h] [rbp+120h]
  double v73; // [rsp+230h] [rbp+130h]
  __int128 v74; // [rsp+240h] [rbp+140h]
  __int128 v75; // [rsp+250h] [rbp+150h]

  *(_OWORD *)a2 = *((_OWORD *)a1 + 0x1C);
  a2[2] = *((double *)a1 + 0x3A);
  v7 = a1[0x31];
  if ( !v7 )
  {
    v7 = sub_146A6A100(&off_149C001A0);
    a1[0x31] = v7;
  }
  *(_OWORD *)a3 = *(_OWORD *)(v7 + 0x30);
  a3[2] = *(double *)(v7 + 0x40);
  *a4 = 0.0;
  *a5 = 0.25 * 0.5;
  v12 = *a1;
  v75 = v5;
  v74 = v6;
  switch ( (*(unsigned int (__fastcall **)(__int64 *))(v12 + 8))(a1) )
  {
    case 2u:
    case 3u:
    case 0xAu:
    case 0xEu:
      *(_OWORD *)a2 = *(_OWORD *)(a1 + 0xC5);
      a2[2] = *((double *)a1 + 0xC7);
      *(_OWORD *)a3 = *((_OWORD *)a1 + 0x7C);
      a3[2] = *((double *)a1 + 0xFA);
      *(float *)&_XMM0 = (float)((float)(COERCE_FLOAT(*(__int64 *)((char *)a1 + 0x1F4)) * 2.0)
                               * (float)(_mm_shuffle_ps(
                                           (__m128)*(unsigned __int64 *)((char *)a1 + 0x1F4),
                                           (__m128)*(unsigned __int64 *)((char *)a1 + 0x1F4),
                                           0x55).m128_f32[0]
                                       * 2.0))
                       * (float)(2.0 * *((float *)a1 + 0x7F));
      goto LABEL_17;
    case 4u:
    case 5u:
    case 7u:
    case 8u:
      break;
    case 6u:
      sub_142144820(&n8);
      v41 = *a1;
      v71 = 0;
      if ( !(*(unsigned int (__fastcall **)(__int64 *, int *))(v41 + 0x28))(a1, &n8) )
        return 0;
      if ( (*((_BYTE *)a1 + 0x384) & 8) != 0 )
      {
        v42 = a2[2];
        v51 = *(_OWORD *)a2;
        v52 = v42;
        v43 = (double *)&v51;
      }
      else
      {
        v53 = *(_OWORD *)v56;
        v54 = *(double *)&v56[0x10];
        v43 = (double *)&v53;
      }
      v44 = v43[2];
      *(_OWORD *)a2 = *(_OWORD *)v43;
      a2[2] = v44;
      if ( (*((_BYTE *)a1 + 0x384) & 8) != 0 )
      {
        v45 = a3[2];
        v53 = *(_OWORD *)a3;
        v54 = v45;
        v46 = (double *)&v53;
      }
      else
      {
        v51 = v72;
        v52 = v73;
        v46 = (double *)&v51;
      }
      v47 = v46[2];
      *(_OWORD *)a3 = *(_OWORD *)v46;
      a3[2] = v47;
      _XMM0 = (unsigned __int64)a1[0xD8];
      __asm { vcvtpd2ps xmm0, xmm0 }
LABEL_17:
      *a4 = *(float *)&_XMM0;
      break;
    case 0xBu:
      v14 = (float *)(*(__int64 (__fastcall **)(__int64 *))(*a1 + 0x78))(a1);
      v15 = v14;
      if ( !v14 )
        return 0;
      if ( *((_QWORD *)v14 + 0x17) != a1[0x17] )
        return 0;
      _XMM1 = 0;
      *(double *)v56 = 0.0;
      __asm { vmovupd [rsp+2F0h+var_298+8], xmm1 }
      v57 = 0;
      v58 = 0;
      v59 = 0;
      v60 = 0;
      v61 = 0;
      v62 = 0;
      v67 = 0;
      v63 = 0.0;
      v64 = 0.0;
      v65 = 0.0;
      v69 = 0.0;
      v66 = 0;
      v68 = 0;
      v70 = 0x80000000;
      n8 = 8;
      v71 = 0;
      if ( !(*(unsigned int (__fastcall **)(float *, int *))(*(_QWORD *)v14 + 0x28LL))(v14, &n8) )
        return 0;
      _XMM0 = *((unsigned __int64 *)v15 + 0xD8);
      __asm { vcvtpd2ps xmm0, xmm0 }
      *a4 = *(float *)&_XMM0;
      v19 = *((float *)a1 + 0x79);
      v20 = *((float *)a1 + 0x76);
      v21 = *((float *)a1 + 0x78);
      v22 = v15[0x2C0];
      v23 = *((float *)a1 + 0x77);
      v24 = v15[0x2C1];
      v25 = v15[0x2C2];
      v26 = (float)((float)(v25 * v23) - (float)(v24 * v21)) + (float)(v22 * v19);
      v27 = (float)((float)(v22 * v21) - (float)(v20 * v25)) + (float)(v19 * v24);
      v28 = (float)((float)(v20 * v24) - (float)(v22 * v23)) + (float)(v19 * v25);
      *a2 = (float)((float)(v22 + (float)((float)(v23 * v28) - (float)(v21 * v27)))
                  + (float)((float)(v23 * v28) - (float)(v21 * v27)))
          + *a2;
      a2[1] = (float)((float)(v24 + (float)((float)(v21 * v26) - (float)(v20 * v28)))
                    + (float)((float)(v21 * v26) - (float)(v20 * v28)))
            + a2[1];
      a2[2] = (float)((float)(v25 + (float)((float)(v20 * v27) - (float)(v23 * v26)))
                    + (float)((float)(v20 * v27) - (float)(v23 * v26)))
            + a2[2];
      v29 = (float *)sub_146A8B2E0(a1);
      v30 = (float *)sub_146A8B2E0(a1);
      v31 = v29[0x1D];
      v32 = v29[0x1C];
      v33 = v29[0x1E];
      v34 = v30[0x13];
      v35 = v30[0x14];
      v36 = v30[0x15];
      v37 = v30[0x12];
      v38 = (float)((float)(v34 * v33) - (float)(v35 * v31)) + (float)(v32 * v36);
      v39 = (float)((float)(v32 * v35) - (float)(v37 * v33)) + (float)(v36 * v31);
      v40 = (float)((float)(v37 * v31) - (float)(v32 * v34)) + (float)(v36 * v33);
      *a3 = (float)((float)(v32 + (float)((float)(v34 * v40) - (float)(v35 * v39)))
                  + (float)((float)(v34 * v40) - (float)(v35 * v39)))
          + *a3;
      a3[1] = (float)((float)(v31 + (float)((float)(v35 * v38) - (float)(v37 * v40)))
                    + (float)((float)(v35 * v38) - (float)(v37 * v40)))
            + a3[1];
      a3[2] = (float)((float)(v33 + (float)((float)(v37 * v39) - (float)(v34 * v38)))
                    + (float)((float)(v37 * v39) - (float)(v34 * v38)))
            + a3[2];
      break;
    default:
      return 0;
  }
  if ( *a4 == 0.0
    && (v49 = (float)((float)(COERCE_FLOAT(*(__int64 *)((char *)a1 + 0x1F4)) * 2.0)
                    * (float)(_mm_shuffle_ps(
                                (__m128)*(unsigned __int64 *)((char *)a1 + 0x1F4),
                                (__m128)*(unsigned __int64 *)((char *)a1 + 0x1F4),
                                0x55).m128_f32[0]
                            * 2.0))
            * (float)(2.0 * *((float *)a1 + 0x7F)),
        *a4 = v49,
        v49 == 0.0) )
  {
    return 0;
  }
  else
  {
    return 1;
  }
}

// --- End Function: sub_146A8A730 (0x146A8A730) ---

// --- Function: sub_146A8D150 (0x146A8D150) ---
__int64 __fastcall sub_146A8D150(__int64 *a1, int *a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int128 v6; // xmm10
  __int128 v7; // xmm11
  __int128 v8; // xmm12
  __int128 v9; // xmm13
  __int128 v10; // xmm14
  __int128 v11; // xmm15
  int n0x30; // eax
  volatile signed __int64 *p_rw_lock_state; // r13
  unsigned int v16; // r12d
  int v17; // r15d
  signed __int64 v18; // rdx
  int value_by_id; // ecx
  __int64 value_by_id_1; // r14
  int n10102016; // edx
  unsigned __int64 current_lock_value; // r14
  __int64 result; // rax
  int v26; // r8d
  _DWORD *v27; // r11
  float v30; // xmm12_4
  float v31; // xmm13_4
  float v33; // xmm7_4
  __int64 v34; // rdx
  __int64 value_by_id_2; // r9
  __int64 v36; // r8
  __int64 v37; // rcx
  __int64 v38; // rax
  double v39; // xmm4_8
  double v40; // xmm6_8
  double v41; // xmm7_8
  __int128 v42; // xmm2
  double v43; // xmm3_8
  double v44; // xmm8_8
  double v45; // xmm9_8
  double v46; // xmm10_8
  double v47; // xmm5_8
  double v48; // xmm0_8
  __int128 v49; // kr00_16
  double v52; // xmm0_8
  _QWORD *v53; // r14
  __int64 v54; // rdx
  int v55; // r8d
  __int64 value_by_id_3; // r9
  __int64 v57; // r14
  float v58; // eax
  _DWORD *v59; // r13
  float v60; // xmm9_4
  float v61; // xmm7_4
  float v62; // kr00_4
  float v65; // xmm12_4
  float v67; // xmm13_4
  float v68; // xmm15_4
  float v69; // xmm9_4
  float v70; // xmm7_4
  float v71; // xmm6_4
  float v72; // xmm4_4
  float v73; // xmm5_4
  float v74; // xmm4_4
  float v75; // xmm2_4
  float v76; // xmm6_4
  float v77; // xmm0_4
  float v78; // xmm7_4
  double v79; // xmm5_8
  double v80; // xmm4_8
  __int64 v81; // rax
  double v84; // xmm8_8
  double v85; // xmm7_8
  __int128 v86; // kr00_16
  float v90; // xmm0_4
  __int64 v91; // rcx
  __int64 v92; // rcx
  __int64 v93; // rcx
  __int64 *v94; // rcx
  __int64 v95; // rax
  __int64 v96; // rax
  _DWORD *v97; // rcx
  double v98; // xmm1_8
  double v99; // xmm0_8
  volatile signed __int64 *p_rw_lock_state_5; // r15
  signed __int64 v101; // rdx
  __int64 v102; // rcx
  __int64 *v103; // rcx
  __int64 v104; // rax
  __int64 v105; // rax
  _DWORD *v106; // rcx
  unsigned __int64 current_lock_value_6; // r14
  volatile signed __int64 *p_rw_lock_state_1; // r15
  signed __int64 v109; // rdx
  int v110; // eax
  int v111; // r10d
  __int64 v112; // rdx
  _DWORD *v113; // rcx
  __int64 v114; // r13
  _QWORD *v115; // r14
  int v116; // eax
  unsigned __int64 current_lock_value_1; // r14
  volatile signed __int64 *p_rw_lock_state_2; // r15
  signed __int64 v119; // r12
  int value_by_id_6; // r12d
  unsigned int v121; // r8d
  int value_by_composite_key; // eax
  int value_by_id_5; // esi
  int n10102016_1; // edx
  __int64 v125; // rcx
  unsigned __int64 current_lock_value_2; // r14
  volatile signed __int64 *p_rw_lock_state_3; // r13
  signed __int64 v128; // r12
  __int64 v129; // r12
  _DWORD *v130; // rdx
  unsigned __int64 _Newcapacity; // r15
  signed __int64 _Newcapacity_1; // rsi
  unsigned __int64 allocSize; // rcx
  __int64 v134; // rax
  _QWORD *_Newvec; // r14
  __int64 v136; // rcx
  float *v137; // rdx
  float v138; // r8d
  unsigned __int64 current_lock_value_3; // r14
  volatile signed __int64 *p_rw_lock_state_4; // rsi
  signed __int64 v141; // rdx
  unsigned __int64 current_lock_value_4; // r14
  int v143; // esi
  signed __int64 v144; // rdx
  __int64 v145; // rax
  float v146; // xmm9_4
  float v147; // xmm6_4
  float v148; // xmm10_4
  float v149; // xmm8_4
  float v150; // xmm5_4
  float v151; // xmm12_4
  float v152; // xmm11_4
  __int128 v153; // xmm15
  int v154; // eax
  float v155; // xmm14_4
  float v156; // xmm13_4
  float v157; // xmm7_4
  float v158; // xmm3_4
  float v159; // xmm5_4
  float v160; // xmm11_4
  float v161; // xmm9_4
  float v162; // xmm7_4
  float v163; // xmm12_4
  float v164; // xmm10_4
  float v165; // xmm2_4
  float v166; // xmm1_4
  int v167; // eax
  float v168; // xmm8_4
  float v169; // xmm12_4
  float v170; // xmm11_4
  float v171; // xmm13_4
  float v172; // xmm3_4
  float v173; // xmm4_4
  float v174; // kr00_4
  float v175; // xmm10_4
  float v176; // xmm9_4
  float v177; // xmm7_4
  float v178; // xmm6_4
  float v179; // xmm4_4
  float v180; // xmm5_4
  float v181; // xmm4_4
  float v182; // xmm6_4
  double v183; // xmm13_8
  double v184; // xmm12_8
  double v185; // xmm11_8
  double v186; // xmm4_8
  double v187; // xmm6_8
  double v188; // xmm10_8
  __int128 v189; // xmm8
  __int128 v190; // kr00_16
  __int128 v191; // xmm7
  __int128 v192; // xmm4
  __int128 v193; // xmm5
  __int128 v194; // xmm6
  __int128 v197; // xmm7
  __m128 n0x3F800000; // kr00_16
  __m128 v203; // xmm3
  int v204; // r15d
  float v205; // eax
  int v206; // ecx
  int v207; // edx
  __int64 v208; // r15
  __int64 v209; // rdx
  __int64 v210; // rcx
  __int64 v211; // r15
  float v212; // xmm1_4
  unsigned __int64 current_lock_value_5; // r14
  __int64 *v214; // r15
  double v216; // xmm12_8
  double v217; // xmm13_8
  double v218; // xmm14_8
  float v219; // xmm11_4
  float v220; // xmm15_4
  __int64 v221; // rax
  double v222; // xmm8_8
  double v223; // xmm6_8
  double v224; // xmm4_8
  __int128 v225; // xmm5
  __int128 v226; // kr00_16
  __int128 v227; // xmm4
  __int128 v228; // xmm3
  __int128 v229; // xmm6
  __int128 v230; // xmm7
  __int128 v231; // xmm8
  __int128 v233; // kr00_16
  float v239; // xmm4_4
  float v240; // xmm2_4
  float v241; // xmm6_4
  float v242; // xmm5_4
  float v243; // xmm4_4
  float v244; // xmm9_4
  float v245; // xmm10_4
  float v246; // xmm8_4
  float v247; // xmm7_4
  float v248; // xmm4_4
  float v249; // xmm0_4
  float v250; // xmm12_4
  __int64 **v251; // rax
  float v252; // xmm13_4
  float v253; // xmm9_4
  float v254; // xmm10_4
  float v255; // xmm11_4
  float v256; // kr00_4
  float v259; // xmm7_4
  float v260; // xmm6_4
  float v261; // xmm4_4
  signed __int64 v262; // rdx
  __int64 *v263; // r15
  __int64 v264; // r15
  __int64 v265; // rax
  float **v266; // rax
  float **v267; // r15
  float **v268; // r12
  float *v269; // r14
  unsigned int (__fastcall **v270)(_QWORD); // r10
  float v271; // xmm9_4
  float v272; // xmm5_4
  float v273; // xmm10_4
  float v274; // xmm11_4
  float *v275; // rcx
  float *v276; // rdx
  float *v277; // rax
  __int64 v278; // r8
  __int64 n0x12; // r9
  float v280; // xmm7_4
  float v281; // xmm6_4
  float v282; // xmm13_4
  float v283; // xmm15_4
  float v284; // xmm14_4
  float v285; // xmm4_4
  float v286; // kr00_4
  float v287; // xmm7_4
  float v288; // xmm8_4
  float v289; // xmm3_4
  float v290; // xmm1_4
  float v291; // xmm9_4
  float v292; // xmm12_4
  float v293; // xmm1_4
  float v294; // xmm6_4
  float v295; // xmm5_4
  float v296; // xmm4_4
  float v297; // kr00_4
  float v298; // xmm6_4
  float v299; // xmm7_4
  float v300; // xmm12_4
  double v301; // xmm0_8
  float v305; // xmm10_4
  float v306; // xmm9_4
  float v307; // xmm8_4
  float v308; // xmm6_4
  float v309; // xmm4_4
  float v310; // xmm4_4
  float v311; // xmm2_4
  float v312; // xmm5_4
  bool v313; // cc
  __int128 n0x3F800000_1; // xmm4
  __int64 v315; // rax
  float v316; // xmm1_4
  float v321; // xmm2_4
  float v324; // xmm3_4
  __int64 v325; // rax
  float v326; // xmm1_4
  float v331; // xmm2_4
  int v334; // edx
  _OWORD *v335; // rsi
  __int64 v336; // rax
  int v343; // esi
  __int64 v344; // rcx
  __int64 v345; // rbx
  unsigned int epi32; // r8d
  double v347; // xmm1_8
  __int128 v348; // xmm0
  double v349; // xmm1_8
  _QWORD *v350; // rax
  __int64 v351; // rax
  float v352; // [rsp+38h] [rbp-D0h]
  float v353; // [rsp+38h] [rbp-D0h]
  float v354; // [rsp+3Ch] [rbp-CCh]
  float v355; // [rsp+40h] [rbp-C8h] BYREF
  float v356; // [rsp+44h] [rbp-C4h]
  float v357; // [rsp+48h] [rbp-C0h]
  float v358; // [rsp+4Ch] [rbp-BCh]
  float v359; // [rsp+50h] [rbp-B8h] BYREF
  float v360; // [rsp+54h] [rbp-B4h]
  float v361; // [rsp+58h] [rbp-B0h]
  float v362; // [rsp+5Ch] [rbp-ACh]
  float v363; // [rsp+60h] [rbp-A8h]
  float v364; // [rsp+64h] [rbp-A4h]
  __int64 v365; // [rsp+68h] [rbp-A0h] BYREF
  double v366; // [rsp+70h] [rbp-98h]
  __int64 v367; // [rsp+78h] [rbp-90h] BYREF
  __int64 v368; // [rsp+80h] [rbp-88h] BYREF
  double v369; // [rsp+88h] [rbp-80h]
  float v370; // [rsp+90h] [rbp-78h]
  double v371; // [rsp+98h] [rbp-70h]
  __int128 v372; // [rsp+A0h] [rbp-68h]
  double v373; // [rsp+B0h] [rbp-58h]
  __int128 v374; // [rsp+B8h] [rbp-50h]
  double v375; // [rsp+C8h] [rbp-40h]
  double v376; // [rsp+D0h] [rbp-38h]
  double v377; // [rsp+D8h] [rbp-30h]
  unsigned int v378; // [rsp+E0h] [rbp-28h]
  __int128 v379; // [rsp+E8h] [rbp-20h]
  double v380; // [rsp+F8h] [rbp-10h]
  float v381[10]; // [rsp+108h] [rbp+0h] BYREF
  __m128 v382; // [rsp+130h] [rbp+28h]
  float v383; // [rsp+140h] [rbp+38h]
  float v384; // [rsp+144h] [rbp+3Ch]
  __m128i v385; // [rsp+148h] [rbp+40h] BYREF
  double v386; // [rsp+158h] [rbp+50h]
  double v387; // [rsp+168h] [rbp+60h] BYREF
  double v388; // [rsp+170h] [rbp+68h] BYREF
  int v389; // [rsp+178h] [rbp+70h] BYREF
  unsigned __int64 v390; // [rsp+17Ch] [rbp+74h]
  int v391; // [rsp+184h] [rbp+7Ch]
  double v392; // [rsp+198h] [rbp+90h]
  double v393; // [rsp+1A0h] [rbp+98h]
  double v394; // [rsp+1A8h] [rbp+A0h]
  float v395; // [rsp+1B0h] [rbp+A8h]
  float v396; // [rsp+1B4h] [rbp+ACh]
  float v397; // [rsp+1B8h] [rbp+B0h]
  float v398; // [rsp+1BCh] [rbp+B4h]
  unsigned int v399; // [rsp+1C0h] [rbp+B8h]
  int v400; // [rsp+1C4h] [rbp+BCh]
  unsigned __int64 v401; // [rsp+1C8h] [rbp+C0h]
  float v402; // [rsp+1D0h] [rbp+C8h]
  int v403; // [rsp+1D4h] [rbp+CCh]
  int n8; // [rsp+1E8h] [rbp+E0h] BYREF
  double v406; // [rsp+1F0h] [rbp+E8h]
  __int128 v407; // [rsp+1F8h] [rbp+F0h]
  __int128 v408; // [rsp+208h] [rbp+100h]
  __int128 v409; // [rsp+218h] [rbp+110h]
  __int128 v410; // [rsp+228h] [rbp+120h]
  __int128 v411; // [rsp+238h] [rbp+130h]
  __int128 v412; // [rsp+248h] [rbp+140h]
  __int128 v413; // [rsp+258h] [rbp+150h]
  float v414; // [rsp+268h] [rbp+160h]
  float v415; // [rsp+26Ch] [rbp+164h]
  float v416; // [rsp+270h] [rbp+168h]
  int v417; // [rsp+274h] [rbp+16Ch]
  __int128 v418; // [rsp+278h] [rbp+170h]
  int v419; // [rsp+288h] [rbp+180h]
  float v420; // [rsp+28Ch] [rbp+184h]
  unsigned int v421; // [rsp+290h] [rbp+188h]
  unsigned int v422; // [rsp+294h] [rbp+18Ch]
  _DWORD v423[10]; // [rsp+298h] [rbp+190h] BYREF
  float v424; // [rsp+2C0h] [rbp+1B8h]
  float v425; // [rsp+2C4h] [rbp+1BCh]
  float v426; // [rsp+2C8h] [rbp+1C0h]
  float v427; // [rsp+2CCh] [rbp+1C4h]
  float v428; // [rsp+2D0h] [rbp+1C8h]
  float v429; // [rsp+2D4h] [rbp+1CCh]
  int n0x2800; // [rsp+2D8h] [rbp+1D0h] BYREF
  __int64 v431; // [rsp+2DCh] [rbp+1D4h]
  int v432; // [rsp+2E4h] [rbp+1DCh]
  unsigned __int64 v433; // [rsp+2E8h] [rbp+1E0h]
  unsigned __int64 v434; // [rsp+2F0h] [rbp+1E8h]
  __int64 v435; // [rsp+2F8h] [rbp+1F0h]
  __int64 v436; // [rsp+300h] [rbp+1F8h]
  double v437; // [rsp+338h] [rbp+230h]
  __m256 v438; // [rsp+348h] [rbp+240h] BYREF
  float v439; // [rsp+368h] [rbp+260h]
  int v440; // [rsp+36Ch] [rbp+264h]
  __int64 v441; // [rsp+370h] [rbp+268h]
  int v442; // [rsp+378h] [rbp+270h]
  __int64 v443; // [rsp+37Ch] [rbp+274h]
  int v444; // [rsp+384h] [rbp+27Ch]
  __int128 v445; // [rsp+388h] [rbp+280h] BYREF
  double v446; // [rsp+398h] [rbp+290h]
  __int64 v447; // [rsp+3B0h] [rbp+2A8h]
  float v448; // [rsp+3B8h] [rbp+2B0h]
  unsigned __int64 v449; // [rsp+3D0h] [rbp+2C8h]
  int v450; // [rsp+3D8h] [rbp+2D0h]
  _DWORD v451[20]; // [rsp+3E8h] [rbp+2E0h] BYREF
  __int128 v452; // [rsp+438h] [rbp+330h]
  __int128 v453; // [rsp+448h] [rbp+340h]
  __int128 v454; // [rsp+458h] [rbp+350h]
  __int128 v455; // [rsp+468h] [rbp+360h]
  __int128 v456; // [rsp+478h] [rbp+370h]
  __int128 v457; // [rsp+488h] [rbp+380h]
  __int128 v458; // [rsp+498h] [rbp+390h]
  __int128 v459; // [rsp+4A8h] [rbp+3A0h]
  __int128 v460; // [rsp+4B8h] [rbp+3B0h]
  __int128 v461; // [rsp+4C8h] [rbp+3C0h]
  int v462; // [rsp+520h] [rbp+418h]
  _QWORD *v463; // [rsp+520h] [rbp+418h]
  __int64 value_by_id_4; // [rsp+520h] [rbp+418h]
  float v465; // [rsp+520h] [rbp+418h]
  unsigned __int64 _Newsize; // [rsp+520h] [rbp+418h]
  int v467; // [rsp+520h] [rbp+418h]
  float v468; // [rsp+520h] [rbp+418h]
  float v469; // [rsp+520h] [rbp+418h]
  double v470; // [rsp+528h] [rbp+420h]
  float v471; // [rsp+528h] [rbp+420h]
  float v472; // [rsp+528h] [rbp+420h]
  float v473; // [rsp+528h] [rbp+420h]
  float v474; // [rsp+530h] [rbp+428h]
  float v475; // [rsp+530h] [rbp+428h]
  float v476; // [rsp+530h] [rbp+428h]
  float v477; // [rsp+530h] [rbp+428h]

  v461 = v2;
  v460 = v3;
  v459 = v4;
  v458 = v5;
  v457 = v6;
  v456 = v7;
  v455 = v8;
  v454 = v9;
  v453 = v10;
  v452 = v11;
  n0x30 = *a2;
  if ( *a2 == 1 )
  {
    p_rw_lock_state = a1 + 0x19;
    v16 = 1;
    v17 = (unsigned __int8)~*((_BYTE *)a2 + 0xC) & (unsigned __int8)-*(_BYTE *)(a1[0x58] + 0x2FC) & 2;
    if ( ((unsigned __int8)~*((_BYTE *)a2 + 0xC) & (unsigned __int8)-*(_BYTE *)(a1[0x58] + 0x2FC) & 2) != 0 )
    {
      v18 = _InterlockedIncrement64(p_rw_lock_state);
      if ( (v18 & 0x200000) != 0 )
        rw_lock_acquire_read_lock_dispatch((__int64)(a1 + 0x19), v18, "CPhysicalEntity::GetStatus", "m_lockUpdate", 1);
    }
    value_by_id = a2[2];
    value_by_id_1 = *((int *)a1 + 0xA4);
    _XMM0 = 0;
    _XMM4 = 0;
    v380 = 0.0;
    v437 = 0.0;
    __asm
    {
      vmovupd [rbp+400h+var_420], xmm0
      vmovupd [rbp+400h+var_330], xmm4
    }
    if ( value_by_id == 0xFFFFFFFF )
    {
      n10102016 = a2[1];
      if ( n10102016 >= 0 )
      {
        value_by_id = map_get_value_by_id(a1[0x54], n10102016, 0);
        if ( value_by_id == (_DWORD)value_by_id_1 )
          goto LABEL_8;
      }
    }
    if ( value_by_id < 0 )
    {
      v26 = a2[0x17];
      v27 = a2 + 0x17;
      v462 = v26;
      _XMM15 = *((_OWORD *)a1 + 0x1C);
      LODWORD(_XMM11) = *((_DWORD *)a1 + 0x76);
      v30 = *((float *)a1 + 0x77);
      v31 = *((float *)a1 + 0x78);
      LODWORD(_XMM14) = *((_DWORD *)a1 + 0x79);
      v33 = 1.0;
      v470 = *((double *)a1 + 0x3A);
      if ( v26 == 0xFFFFFFFF )
        goto LABEL_23;
      *((_QWORD *)a2 + 2) = 0;
      v34 = 0xFFFFFFFFLL;
      *((_QWORD *)a2 + 3) = 0xFFFFFFFFLL;
      if ( (int)value_by_id_1 <= 0 )
      {
        v38 = 0;
      }
      else
      {
        value_by_id_2 = 0;
        v36 = 0;
        do
        {
          v37 = *(_QWORD *)(a1[0x48] + 8 * value_by_id_2++);
          v36 |= v37;
          v34 &= v37;
          *((_QWORD *)a2 + 2) = v36;
          *((_QWORD *)a2 + 3) = v34;
        }
        while ( value_by_id_2 < value_by_id_1 );
        v26 = v462;
        v38 = **(_QWORD **)a1[0x47];
      }
      *((_QWORD *)a2 + 0xA) = v38;
      if ( v26 != 1 )
      {
LABEL_23:
        __asm { vmovupd xmm6, [rbp+400h+var_330] }
      }
      else
      {
        v39 = *((double *)a1 + 0x38);
        v40 = *((double *)a1 + 0x39);
        v41 = *((double *)a1 + 0x3A);
        v42 = (unsigned __int64)a1[5];
        v43 = *((double *)a1 + 6);
        v44 = *((double *)a1 + 2);
        v45 = *((double *)a1 + 3);
        v46 = *((double *)a1 + 4);
        v47 = *((double *)a1 + 7);
        *(double *)&v372 = v44 - v39;
        v373 = v46 - v41;
        *((double *)&v372 + 1) = v45 - v40;
        *(double *)&v374 = *(double *)&v42 - v39;
        v48 = v47 - v41;
        v33 = 1.0;
        *((double *)&v374 + 1) = v43 - v40;
        *((_QWORD *)&v49 + 1) = *((_QWORD *)&v42 + 1);
        *(double *)&v49 = (*(double *)&v42 + v44) * 0.5;
        _XMM4 = v49;
        v375 = v48;
        v437 = (v47 + v46) * 0.5;
        __asm { vunpcklpd xmm6, xmm4, xmm3 }
      }
      v52 = v470;
      v463 = a2 + 4;
      v53 = a2 + 6;
LABEL_37:
      *((_OWORD *)a2 + 2) = _XMM15;
      *((double *)a2 + 6) = v52;
      a2[0xE] = _XMM11;
      *((float *)a2 + 0xF) = v30;
      *((float *)a2 + 0x10) = v31;
      a2[0x11] = _XMM14;
      *((float *)a2 + 0x12) = v33;
      a2[0x13] = *((_DWORD *)a1 + 0x3F);
      if ( *v27 == 1 )
      {
        *((_QWORD *)a2 + 0xF) = 0;
        v93 = a1[0x17];
        *((_QWORD *)a2 + 0xC) = v93;
        if ( v93 )
        {
          *((_QWORD *)a2 + 0xD) = *(_QWORD *)(v93 + 0x178);
          *((_QWORD *)a2 + 0xE) = *(_QWORD *)sub_146ADA300(v93, &v388);
        }
        v94 = (__int64 *)*((_QWORD *)a2 + 0xC);
        if ( v94 )
        {
          v95 = *v94;
          *((_QWORD *)a2 + 0xF) = *v94;
          if ( v95 )
          {
            v96 = *v94;
            *((_OWORD *)a2 + 8) = *(_OWORD *)(*v94 + 0x1C0);
            *((double *)a2 + 0x12) = *(double *)(v96 + 0x1D0);
            v97 = (_DWORD *)*v94;
            a2[0x26] = v97[0x76];
            a2[0x27] = v97[0x77];
            a2[0x28] = v97[0x78];
            a2[0x29] = v97[0x79];
          }
        }
        v98 = v373;
        *(_OWORD *)(a2 + 0x2A) = v372;
        *((_OWORD *)a2 + 0xC) = v374;
        v99 = v437;
        *((double *)a2 + 0x17) = v98;
        *((double *)a2 + 0x1A) = v375;
        *(_OWORD *)(a2 + 0x36) = _XMM6;
        *((double *)a2 + 0x1D) = v99;
        *((double *)a2 + 0x1E) = *((double *)a1 + 0x3D);
        a2[0x3E] = *((_DWORD *)a1 + 0x7C);
        *(double *)(a2 + 0x3F) = *(double *)((char *)a1 + 0x1F4);
        a2[0x41] = *((_DWORD *)a1 + 0x7F);
      }
      if ( !*(_DWORD *)(a1[0x58] + 0x17C) && (a1[0x43] & 1) != 0 )
      {
        *v53 = 0;
        *v463 = 0;
      }
LABEL_9:
      if ( !v17 )
        return v16;
LABEL_10:
      current_lock_value = _InterlockedDecrement64(p_rw_lock_state);
      if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
        rw_lock_handle_release_contention(p_rw_lock_state, current_lock_value);
      return v16;
    }
    if ( value_by_id >= (int)value_by_id_1 )
    {
LABEL_8:
      v16 = 0;
      goto LABEL_9;
    }
    v54 = a1[0x46];
    v55 = a2[3];
    value_by_id_3 = value_by_id;
    value_by_id_4 = value_by_id;
    v57 = 0x20LL * value_by_id;
    v58 = *(float *)(v57 + v54 + 0x18);
    if ( (v55 & 1) != 0 )
    {
      v59 = a2 + 0x17;
      v450 = *(_DWORD *)(v57 + v54 + 0x18);
      LODWORD(_XMM11) = *(_DWORD *)(v57 + v54);
      v30 = *(float *)(v57 + v54 + 4);
      v31 = *(float *)(v57 + v54 + 8);
      LODWORD(_XMM14) = *(_DWORD *)(v57 + v54 + 0xC);
      v449 = *(_QWORD *)(v57 + v54 + 0x10);
      v380 = v58;
      *(double *)&v379 = *(float *)&v449;
      *((double *)&v379 + 1) = _mm_shuffle_ps((__m128)v449, (__m128)v449, 0x55).m128_f32[0];
      if ( a2[0x17] == 1 )
      {
        (*(void (__fastcall **)(__int64 *, _QWORD, _DWORD *))(*a1 + 0x330))(a1, (unsigned int)value_by_id, v423);
        v54 = a1[0x46];
        v55 = a2[3];
        value_by_id_3 = value_by_id_4;
        v60 = (float)((float)(COERCE_FLOAT(v423[3] & 0x7FFFFFFF) * v428)
                    + (float)(COERCE_FLOAT(v423[0] & 0x7FFFFFFF) * v427))
            + (float)(COERCE_FLOAT(v423[6] & 0x7FFFFFFF) * v429);
        v61 = (float)((float)(COERCE_FLOAT(v423[4] & 0x7FFFFFFF) * v428)
                    + (float)(COERCE_FLOAT(v423[1] & 0x7FFFFFFF) * v427))
            + (float)(COERCE_FLOAT(v423[7] & 0x7FFFFFFF) * v429);
        v62 = (float)((float)(COERCE_FLOAT(v423[5] & 0x7FFFFFFF) * v428)
                    + (float)(COERCE_FLOAT(v423[2] & 0x7FFFFFFF) * v427))
            + (float)(COERCE_FLOAT(v423[8] & 0x7FFFFFFF) * v429);
        *(double *)&v372 = (float)(v424 - v60);
        *((double *)&v372 + 1) = (float)(v425 - v61);
        v373 = (float)(v426 - v62);
        *(double *)&v374 = (float)(v60 + v424);
        v375 = (float)(v62 + v426);
        *((double *)&v374 + 1) = (float)(v61 + v425);
        _XMM2 = COERCE_UNSIGNED_INT64(v424);
        v437 = v426;
        __asm { vunpcklpd xmm6, xmm2, xmm1 }
        goto LABEL_33;
      }
    }
    else
    {
      _XMM11 = *((unsigned int *)a1 + 0x76);
      v65 = *((float *)a1 + 0x77);
      _XMM14 = *((unsigned int *)a1 + 0x78);
      v67 = *((float *)a1 + 0x79);
      v68 = *(float *)(v57 + v54 + 4);
      v69 = _mm_shuffle_ps(
              (__m128)*(unsigned __int64 *)(v57 + v54 + 0x10),
              (__m128)*(unsigned __int64 *)(v57 + v54 + 0x10),
              0x55).m128_f32[0];
      v447 = *(_QWORD *)(v57 + v54 + 0x10);
      v70 = (float)((float)(v58 * v65) - (float)(v69 * *(float *)&_XMM14)) + (float)(*(float *)&v447 * v67);
      v71 = (float)((float)(*(float *)&v447 * *(float *)&_XMM14) - (float)(v58 * *(float *)&_XMM11))
          + (float)(v69 * v67);
      v72 = (float)((float)(v69 * *(float *)&_XMM11) - (float)(*(float *)&v447 * v65)) + (float)(v58 * v67);
      v73 = (float)(v65 * v72) - (float)(*(float *)&_XMM14 * v71);
      v74 = (float)(*(float *)&_XMM14 * v70) - (float)(*(float *)&_XMM11 * v72);
      v75 = *(float *)&_XMM11 * v71;
      v76 = *(float *)(v57 + v54 + 8);
      v77 = v65 * v70;
      v78 = *(float *)(v57 + v54 + 0xC);
      v79 = (float)((float)(*(float *)&v447 + v73) + v73) + *((double *)a1 + 0x38);
      v80 = (float)((float)(v69 + v74) + v74) + *((double *)a1 + 0x39);
      v366 = (float)((float)(v58 + (float)(v75 - v77)) + (float)(v75 - v77)) + *((double *)a1 + 0x3A);
      v380 = v366;
      v376 = v80;
      *((double *)&v379 + 1) = v80;
      v371 = v79;
      *(double *)&v379 = v79;
      LODWORD(v79) = *(_DWORD *)(v57 + v54);
      v471 = (float)(v78 * v67)
           - (float)((float)((float)(*(float *)&v79 * *(float *)&_XMM11) + (float)(v68 * v65))
                   + (float)(v76 * *(float *)&_XMM14));
      v465 = (float)((float)((float)(*(float *)&v79 * *(float *)&_XMM14) - (float)(v76 * *(float *)&_XMM11))
                   + (float)(v68 * v67))
           + (float)(v78 * v65);
      v474 = (float)((float)((float)(v76 * v65) - (float)(v68 * *(float *)&_XMM14)) + (float)(*(float *)&v79 * v67))
           + (float)(v78 * *(float *)&_XMM11);
      v448 = v58;
      v59 = a2 + 0x17;
      v31 = (float)((float)((float)(v68 * *(float *)&_XMM11) - (float)(*(float *)&v79 * v65)) + (float)(v76 * v67))
          + (float)(v78 * *(float *)&_XMM14);
      if ( a2[0x17] == 1 )
      {
        v81 = a1[0x45];
        __asm { vinsertps xmm11, xmm11, xmm10, 0Eh }
        _XMM6 = *(_OWORD *)(v81 + 0x30LL * value_by_id + 0x18);
        _XMM5 = *(_OWORD *)(v81 + 0x30LL * value_by_id);
        v84 = *(double *)(v81 + 0x30LL * value_by_id + 0x28);
        v85 = *(double *)(v81 + 0x30LL * value_by_id + 0x10);
        *((_QWORD *)&v86 + 1) = *(_QWORD *)(v81 + 0x30LL * value_by_id + 8);
        *(double *)&v86 = (*(double *)&_XMM5 + *(double *)&_XMM6) * 0.5;
        _XMM9 = v86;
        __asm { vunpckhpd xmm3, xmm6, xmm6 }
        __asm { vunpckhpd xmm2, xmm5, xmm5 }
        v437 = (v84 + v85) * 0.5;
        *((double *)&v372 + 1) = *(double *)&_XMM2 - v376;
        *(double *)&v372 = *(double *)&_XMM5 - v371;
        *(double *)&v374 = *(double *)&_XMM6 - v371;
        v30 = v465;
        v373 = v85 - v366;
        __asm { vinsertps xmm14, xmm14, xmm8, 0Eh }
        *((double *)&v374 + 1) = *(double *)&_XMM3 - v376;
        v375 = v84 - v366;
        __asm { vunpcklpd xmm6, xmm9, xmm4 }
        goto LABEL_33;
      }
      *(float *)&_XMM11 = v474;
      v30 = v465;
      *(float *)&_XMM14 = v471;
    }
    __asm { vmovupd xmm6, [rbp+400h+var_330] }
LABEL_33:
    v463 = a2 + 4;
    v27 = v59;
    v90 = *(float *)(v54 + v57 + 0x1C);
    v53 = a2 + 6;
    v33 = v90 * *((float *)a1 + 0x80);
    a2[1] = *(_DWORD *)(a1[0x4A] + 4 * value_by_id_3);
    v91 = *(_QWORD *)(a1[0x48] + 8 * value_by_id_3);
    *((_QWORD *)a2 + 3) = v91;
    *((_QWORD *)a2 + 2) = v91;
    v92 = **(_QWORD **)(a1[0x47] + 8 * value_by_id_3);
    *((_QWORD *)a2 + 0xA) = v92;
    if ( (v55 & 4) != 0 )
    {
      v463 = a2 + 4;
      v53 = a2 + 6;
      if ( v92 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v92 + 0x10LL))(v92);
        v27 = v59;
        v463 = a2 + 4;
        v53 = a2 + 6;
      }
    }
    __asm { vmovupd xmm15, [rbp+400h+var_420] }
    v52 = v380;
    p_rw_lock_state = a1 + 0x19;
    goto LABEL_37;
  }
  if ( n0x30 != 0x23 )
  {
    switch ( n0x30 )
    {
      case 0xA:
        v16 = 1;
        p_rw_lock_state_1 = a1 + 0x19;
        v109 = _InterlockedIncrement64(a1 + 0x19);
        if ( (v109 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            (__int64)(a1 + 0x19),
            v109,
            "CPhysicalEntity::GetStatus",
            "m_lockUpdate",
            1);
        v110 = a2[1];
        v111 = *((_DWORD *)a1 + 0xA4);
        if ( v110 < 0 )
        {
          v110 = 0;
          if ( v111 - 1 > 0 )
          {
            v112 = 0;
            v113 = (_DWORD *)a1[0x4A];
            do
            {
              if ( *v113 == a2[2] )
                break;
              ++v110;
              ++v112;
              ++v113;
            }
            while ( v112 < v111 - 1 );
          }
        }
        if ( v110 >= v111
          || (v114 = v110,
              v115 = *(_QWORD **)(a1[0x47] + 8LL * v110),
              a2[3] >= (*(unsigned int (__fastcall **)(_QWORD))(*(_QWORD *)*v115 + 0x108LL))(*v115))
          || (*(unsigned int (__fastcall **)(_QWORD))(*(_QWORD *)*v115 + 8LL))(*v115) == 1 && a2[4] > 2 )
        {
          v16 = 0;
        }
        else
        {
          v116 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*v115 + 0xA0LL))(
                   *v115,
                   (unsigned int)a2[3],
                   (unsigned int)a2[4]);
          a2[5] = v116;
          a2[5] = v116 & ~(v116 >> 0x1F)
                | (v116 >> 0x1F) & ((int)(*(_DWORD *)(a1[0x4E] + 0x18 * v114 + 0x10) << 0xE) >> 0x16);
        }
        current_lock_value_1 = _InterlockedDecrement64(p_rw_lock_state_1);
        if ( (current_lock_value_1 & 0x3FF) != 0 || (current_lock_value_1 & 0xFFFF0000FFC00000uLL) == 0 )
          return v16;
        rw_lock_handle_release_contention(p_rw_lock_state_1, current_lock_value_1);
        return v16;
      case 0x2F:
        p_rw_lock_state_2 = a1 + 0x19;
        v119 = _InterlockedIncrement64(a1 + 0x19);
        if ( (v119 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            (__int64)(a1 + 0x19),
            v119,
            "CPhysicalEntity::GetStatus",
            "m_lockUpdate",
            1);
        value_by_id_6 = *((_DWORD *)a1 + 0xA4);
        if ( *((_QWORD *)a2 + 1) == 0xFFFFFFFFFFFFFFFFuLL || (v121 = a2[4], v121 == 0x80000000) )
        {
          value_by_id_5 = *((_DWORD *)a1 + 0xA4);
          n10102016_1 = a2[5];
          if ( a2[6] != 0x80000000 )
            value_by_id_5 = a2[6];
          if ( n10102016_1 != 0x80000000 )
            value_by_id_5 = map_get_value_by_id(a1[0x54], n10102016_1, 0);
          if ( value_by_id_5 < 0 || value_by_id_5 >= value_by_id_6 )
          {
            value_by_id_5 = 0xFFFFFFFF;
          }
          else
          {
            v125 = *(_QWORD *)(a1[0x54] + 0x80) + 0x10LL * value_by_id_5;
            *((_QWORD *)a2 + 1) = *(_QWORD *)v125;
            a2[4] = *(_DWORD *)(v125 + 8);
          }
        }
        else
        {
          value_by_composite_key = map_get_value_by_composite_key(a1[0x54], (unsigned __int64 *)a2 + 1, v121, a2 + 5);
          a2[6] = value_by_composite_key;
          value_by_id_5 = 0xFFFFFFFF;
          if ( value_by_composite_key < value_by_id_6 )
            value_by_id_5 = value_by_composite_key;
        }
        current_lock_value_2 = _InterlockedDecrement64(p_rw_lock_state_2);
        if ( (current_lock_value_2 & 0x3FF) == 0 && (current_lock_value_2 & 0xFFFF0000FFC00000uLL) != 0 )
          rw_lock_handle_release_contention(p_rw_lock_state_2, current_lock_value_2);
        return (unsigned int)value_by_id_5;
      case 0xC:
        p_rw_lock_state_3 = a1 + 0x19;
        v128 = _InterlockedIncrement64(a1 + 0x19);
        if ( (v128 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            (__int64)(a1 + 0x19),
            v128,
            "CPhysicalEntity::GetStatus",
            "m_lockUpdate",
            1);
        v129 = *((_QWORD *)a2 + 1);
        v130 = a1 + 0x52;
        _Newcapacity = *((int *)a1 + 0xA4);
        if ( v129 )
        {
          _Newcapacity_1 = 0;
          if ( _Newcapacity > (__int64)(*(_QWORD *)(v129 + 0x10) - *(_QWORD *)v129) >> 2 )
          {
            if ( _Newcapacity > 0x3FFFFFFFFFFFFFFFLL )
              unknown_libname_10();
            allocSize = 4 * _Newcapacity;
            _Newsize = (__int64)(*(_QWORD *)(v129 + 8) - *(_QWORD *)v129) >> 2;
            if ( 4 * _Newcapacity < 0x1000 )
            {
              if ( allocSize )
                _Newvec = (_QWORD *)sub_1402A65A0(allocSize);
              else
                _Newvec = 0;
            }
            else
            {
              if ( allocSize + 0x27 < allocSize )
                sub_1402E3880();
              v134 = sub_1402A65A0(allocSize + 0x27);
              if ( !v134 )
                invalid_parameter_noinfo_noreturn();
              _Newvec = (_QWORD *)((v134 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
              _Newvec[0xFFFFFFFF] = v134;
            }
            memmove(_Newvec, *(const void **)v129, *(_QWORD *)(v129 + 8) - *(_QWORD *)v129);
            std::vector<unsigned int>::_Change_array(
              (std::vector<unsigned int> *)v129,
              (unsigned int *const)_Newvec,
              _Newsize,
              _Newcapacity);
            v130 = a1 + 0x52;
          }
          if ( (int)_Newcapacity > 0 )
          {
            do
            {
              v136 = *((_QWORD *)a2 + 1);
              v137 = *(float **)(v136 + 8);
              v138 = *(float *)(a1[0x4A] + 4 * _Newcapacity_1);
              v359 = v138;
              if ( v137 == *(float **)(v136 + 0x10) )
              {
                sub_140347870(v136, v137, (int *)&v359);
              }
              else
              {
                *v137 = v138;
                *(_QWORD *)(v136 + 8) += 4LL;
              }
              ++_Newcapacity_1;
            }
            while ( _Newcapacity_1 < (__int64)_Newcapacity );
            v130 = a1 + 0x52;
          }
        }
        if ( a2[4] )
          LODWORD(_Newcapacity) = *v130 & (*((int *)a1 + 0xA5) >> 0x1F)
                                | *((_DWORD *)a1 + 0xA5) & ~(*((int *)a1 + 0xA5) >> 0x1F);
        current_lock_value_3 = _InterlockedDecrement64(p_rw_lock_state_3);
        if ( (current_lock_value_3 & 0x3FF) == 0 && (current_lock_value_3 & 0xFFFF0000FFC00000uLL) != 0 )
          rw_lock_handle_release_contention(p_rw_lock_state_3, current_lock_value_3);
        return (unsigned int)_Newcapacity;
      case 0x1E:
        return *((unsigned int *)a1 + 0xAA);
      case 7:
        return (*(__int64 (__fastcall **)(__int64 *, unsigned __int64))(*a1 + 0x270))(a1, 0xFFFFFFFFFFFFFFFFuLL);
      case 0xD:
        return sub_146A94710(a1, a2 + 2, 0x7FF);
      case 0x14:
        a2[1] = 0;
        return 1;
      case 0x18:
        *((float *)a2 + 2) = (*(float (__fastcall **)(__int64 *, _QWORD))(*a1 + 0x1A8))(a1, (unsigned int)a2[1]);
        return 1;
      case 0x24:
        v16 = 1;
        p_rw_lock_state_4 = a1 + 0x19;
        v141 = _InterlockedIncrement64(a1 + 0x19);
        if ( (v141 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            (__int64)(a1 + 0x19),
            v141,
            "CPhysicalEntity::GetStatus",
            "m_lockUpdate",
            1);
        *(_OWORD *)(a2 + 2) = *((_OWORD *)a1 + 0x1C);
        *((double *)a2 + 3) = *((double *)a1 + 0x3A);
        a2[8] = *((_DWORD *)a1 + 0x76);
        a2[9] = *((_DWORD *)a1 + 0x77);
        a2[0xA] = *((_DWORD *)a1 + 0x78);
        a2[0xB] = *((_DWORD *)a1 + 0x79);
        *((double *)a2 + 6) = *((double *)a1 + 0x3D);
        a2[0xE] = *((_DWORD *)a1 + 0x7C);
        *(double *)(a2 + 0xF) = *(double *)((char *)a1 + 0x1F4);
        a2[0x11] = *((_DWORD *)a1 + 0x7F);
        current_lock_value_4 = _InterlockedDecrement64(p_rw_lock_state_4);
        if ( (current_lock_value_4 & 0x3FF) != 0 || (current_lock_value_4 & 0xFFFF0000FFC00000uLL) == 0 )
          return v16;
        rw_lock_handle_release_contention(p_rw_lock_state_4, current_lock_value_4);
        return 1;
      case 0x25:
        v143 = 0;
        n0x2800 = 0x2800;
        v431 = 0;
        v432 = 0;
        v434 = 0;
        v435 = 0;
        v436 = 0;
        v433 = __rdtsc();
        qword_149C89AA0(
          &n0x2800,
          &word_1516E4B64,
          "GetStatus(pe_status_parts_in_box)",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryPhysics\\physicalentity.cpp",
          0xB88);
        HIWORD(n0x2800) = word_1516E4B64;
        v144 = _InterlockedIncrement64(a1 + 0x19);
        if ( (v144 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            (__int64)(a1 + 0x19),
            v144,
            "CPhysicalEntity::GetStatus",
            "m_lockUpdate",
            1);
        v145 = *((_QWORD *)a2 + 1);
        if ( v145 != *((_QWORD *)a2 + 2) )
          *((_QWORD *)a2 + 2) = v145;
        v146 = *((float *)a2 + 0x10);
        v147 = *((float *)a2 + 0x12);
        v148 = *((float *)a1 + 0x78);
        v149 = *((float *)a2 + 0x11);
        v150 = *((float *)a2 + 0x13);
        v151 = *((float *)a1 + 0x79);
        v152 = *((float *)a1 + 0x77);
        v153 = *((unsigned int *)a1 + 0x76);
        v154 = *((_DWORD *)a1 + 0x7C);
        v438 = ymmword_1483778E0;
        v439 = 1.0;
        v441 = a1[0x3D];
        v443 = *(__int64 *)((char *)a1 + 0x1F4);
        v155 = (float)((float)(*(float *)&v153 * v146) + (float)(v148 * v147))
             + (float)((float)(v151 * v150) + (float)(v152 * v149));
        v156 = (float)((float)((float)(v152 * v147) - (float)(v148 * v149)) + (float)(*(float *)&v153 * v150))
             - (float)(v151 * v146);
        v157 = (float)((float)((float)(v148 * v146) - (float)(*(float *)&v153 * v147)) + (float)(v152 * v150))
             - (float)(v151 * v149);
        v158 = v157 + v157;
        v159 = (float)((float)((float)(*(float *)&v153 * v149) - (float)(v152 * v146)) + (float)(v148 * v150))
             - (float)(v151 * v147);
        v160 = (float)(v157 + v157) * v157;
        v161 = (float)(v159 + v159) * v157;
        v162 = (float)(v159 + v159) * v156;
        v163 = 1.0 - (float)((float)(v156 + v156) * v156);
        v164 = (float)(v156 + v156) * v155;
        v165 = (float)(v159 + v159) * v159;
        v166 = (float)(v159 + v159) * v155;
        v442 = v154;
        v167 = *((_DWORD *)a1 + 0x7F);
        v381[5] = v161 - v164;
        v381[7] = v161 + v164;
        v381[0] = (float)(1.0 - v160) - v165;
        v381[1] = (float)(v158 * v156) - v166;
        v381[2] = v162 + (float)(v158 * v155);
        v381[3] = v166 + (float)(v158 * v156);
        v381[4] = v163 - v165;
        v381[6] = v162 - (float)(v158 * v155);
        v444 = v167;
        v440 = 0;
        v168 = v163 - v160;
        v169 = *((float *)a2 + 0x11);
        v170 = *((float *)a2 + 0x12);
        v171 = *((float *)a2 + 0x10);
        v172 = *((float *)a2 + 0x15);
        v173 = *((float *)a2 + 0x13);
        v174 = *((float *)a2 + 0x17) + *((float *)a2 + 0x14);
        v175 = (float)(*((float *)a2 + 0x16) + *((float *)a2 + 0x19)) * 0.5;
        v381[8] = v168;
        v176 = (float)(v172 + *((float *)a2 + 0x18)) * 0.5;
        v177 = (float)((float)(v169 * v175) - (float)(v170 * v176)) + (float)((float)(v174 * 0.5) * v173);
        v178 = (float)((float)((float)(v174 * 0.5) * v170) - (float)(v171 * v175)) + (float)(v173 * v176);
        v179 = (float)((float)(v171 * v176) - (float)((float)(v174 * 0.5) * v169)) + (float)(v173 * v175);
        v180 = (float)(v169 * v179) - (float)(v170 * v178);
        v181 = (float)(v170 * v177) - (float)(v171 * v179);
        v182 = (float)(v171 * v178) - (float)(v169 * v177);
        v183 = (float)((float)((float)(v174 * 0.5) + v180) + v180) + *((double *)a2 + 5) - *((double *)a1 + 0x38);
        v184 = (float)((float)(v176 + v181) + v181) + *((double *)a2 + 6) - *((double *)a1 + 0x39);
        v185 = (float)((float)(v182 + v175) + v182) + *((double *)a2 + 7) - *((double *)a1 + 0x3A);
        v186 = *((float *)a1 + 0x79);
        v187 = *((float *)a1 + 0x78);
        v188 = *((float *)a1 + 0x77);
        v189 = COERCE_UNSIGNED_INT64(v187 * v184 - v188 * v185 + v186 * v183);
        *((_QWORD *)&v190 + 1) = *((_QWORD *)&v153 + 1);
        *(double *)&v190 = *(float *)&v153 * v185 - v187 * v183 + v186 * v184;
        v191 = v190;
        *(double *)&v190 = v188 * v183 - *(float *)&v153 * v184 + v186 * v185;
        v192 = (unsigned __int64)v190;
        *((_QWORD *)&v190 + 1) = *((_QWORD *)&v191 + 1);
        *(double *)&v190 = *(double *)&v191 * v187 - *(double *)&v190 * v188;
        v193 = v190;
        *((_QWORD *)&v190 + 1) = *((_QWORD *)&v192 + 1);
        *(double *)&v190 = *(double *)&v192 * *(float *)&v153 - *(double *)&v189 * v187;
        v194 = v190;
        *((_QWORD *)&v190 + 1) = *((_QWORD *)&v193 + 1);
        *(double *)&v190 = *(double *)&v193 + v183 + *(double *)&v193;
        _XMM2 = v190;
        __asm { vcvtsd2ss xmm4, xmm2, xmm2 }
        *((_QWORD *)&v190 + 1) = *((_QWORD *)&v189 + 1);
        *(double *)&v190 = *(double *)&v189 * v188 - *(double *)&v191 * *(float *)&v153;
        v197 = v190;
        *((_QWORD *)&v190 + 1) = *((_QWORD *)&v194 + 1);
        *(double *)&v190 = *(double *)&v194 + v184 + *(double *)&v194;
        _XMM1 = v190;
        __asm { vcvtsd2ss xmm3, xmm1, xmm1 }
        *((_QWORD *)&v190 + 1) = *((_QWORD *)&v197 + 1);
        *(double *)&v190 = *(double *)&v197 + v185 + *(double *)&v197;
        _XMM0 = v190;
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
        *(float *)&_XMM0 = *((float *)a2 + 0x17) - *((float *)a2 + 0x14);
        v382.m128_f32[2] = *(float *)&_XMM1;
        *(float *)&_XMM1 = *((float *)a2 + 0x18) - *((float *)a2 + 0x15);
        v382.m128_f32[0] = *(float *)&_XMM4;
        *(float *)&v190 = *((float *)a2 + 0x19) - *((float *)a2 + 0x16);
        v382.m128_f32[1] = *(float *)&_XMM3;
        LODWORD(v381[9]) = 1;
        v384 = *(float *)&v190 * 0.5;
        v382.m128_f32[3] = *(float *)&_XMM0 * 0.5;
        v383 = *(float *)&_XMM1 * 0.5;
        v451[0] = 0xFFFFFFFF;
        __asm { vzeroupper }
        if ( sub_14688D900((__int64)&v438, (__int64)v381, (__int64)v451) )
        {
          n0x3F800000 = (__m128)0x3F800000u;
          n0x3F800000.m128_f32[0] = 1.0 / *((float *)a1 + 0x80);
          v203 = _mm_shuffle_ps(n0x3F800000, n0x3F800000, 0);
          v383 = v203.m128_f32[0] * v383;
          v384 = v203.m128_f32[0] * v384;
          v382 = _mm_mul_ps(v203, v382);
          v355 = 0.0;
          v204 = a2[0x1A]
               ? (*((int *)a1 + 0xA5) >> 0x1F) & a1[0x52] | *((_DWORD *)a1 + 0xA5) & ~(*((int *)a1 + 0xA5) >> 0x1F)
               : *((_DWORD *)a1 + 0xA4);
          v467 = v204;
          if ( v204 > 0 )
          {
            v205 = 0.0;
            v206 = 0;
            v207 = v204;
            do
            {
              v208 = v206;
              if ( (*(_QWORD *)(a1[0x48] + 8LL * SLODWORD(v205)) & *((_QWORD *)a2 + 4)) != 0 )
              {
                v451[0] = 0xFFFFFFFF;
                if ( sub_14688D900((__int64)v381, a1[0x4C] + ((__int64)v206 << 6), (__int64)v451) )
                {
                  v209 = *((_QWORD *)a2 + 2);
                  v210 = *(_QWORD *)(a1[0x47] + 8 * v208);
                  v211 = a1[0x46] + 0x20 * v208;
                  v368 = v210;
                  if ( v209 == *((_QWORD *)a2 + 3) )
                  {
                    sub_146A68B00((unsigned __int64 *)a2 + 1, (int *)v209, &v355, v211, (float *)a1 + 0x80, &v368);
                  }
                  else
                  {
                    v212 = *((float *)a1 + 0x80);
                    *(_DWORD *)v209 = v143;
                    *(double *)(v209 + 4) = *(double *)(v211 + 0x10);
                    *(_DWORD *)(v209 + 0xC) = *(_DWORD *)(v211 + 0x18);
                    *(_DWORD *)(v209 + 0x1C) = *(_DWORD *)(v211 + 0xC);
                    *(_DWORD *)(v209 + 0x10) = *(_DWORD *)v211;
                    *(_DWORD *)(v209 + 0x14) = *(_DWORD *)(v211 + 4);
                    *(_DWORD *)(v209 + 0x18) = *(_DWORD *)(v211 + 8);
                    *(float *)(v209 + 0x20) = v212 * *(float *)(v211 + 0x1C);
                    *(_QWORD *)(v209 + 0x28) = v210;
                    *((_QWORD *)a2 + 2) += 0x30LL;
                  }
                }
                v207 = v467;
              }
              LODWORD(v205) = v143 + 1;
              v355 = v205;
              v206 = ++v143;
            }
            while ( SLODWORD(v205) < v207 );
          }
        }
        current_lock_value_5 = _InterlockedDecrement64(a1 + 0x19);
        if ( (current_lock_value_5 & 0x3FF) == 0 && (current_lock_value_5 & 0xFFFF0000FFC00000uLL) != 0 )
          rw_lock_handle_release_contention(a1 + 0x19, current_lock_value_5);
        v434 = __rdtsc();
        qword_149C89AA8(&n0x2800);
        return 1;
      case 0x19:
        (*(void (__fastcall **)(__int64 *, int *, _QWORD))(*a1 + 0x1B0))(a1, a2 + 4, (unsigned int)a2[1]);
        return 1;
      case 0x1F:
        if ( !*((_QWORD *)a2 + 1) )
          *((_QWORD *)a2 + 1) = a1[0x58] + 0xCA0;
        v475 = 0.0;
        v352 = 0.0;
        v354 = 0.0;
        v362 = 0.0;
        v472 = 0.0;
        v214 = a1;
        v358 = 0.0;
        v355 = 0.0;
        v357 = 0.0;
        v363 = 1.0;
        v356 = 0.0;
        *(float *)&v366 = 1.0;
        _XMM0 = 0;
        v216 = 0.0;
        v217 = 0.0;
        v218 = 0.0;
        v219 = 0.0;
        v220 = 1.0;
        if ( a1 )
        {
          while ( *((_DWORD *)v214 + 0x3F) != 7 )
          {
            v408 = 0;
            v410 = 0;
            v412 = 0;
            v402 = 0.0;
            v406 = *(double *)&_XMM0;
            v414 = 0.0;
            v415 = 0.0;
            v416 = 0.0;
            v420 = 0.0;
            v385.m128i_i64[0] = 0x800000000000000FuLL;
            v385.m128i_i64[1] = 0x8000000080000000uLL;
            v389 = 1;
            v390 = 0xFFFFFFFFFFFFFFFFuLL;
            v391 = 0;
            v400 = 0;
            v403 = 0;
            v401 = 0xFFFFFFFFFFFFFFFFuLL;
            HIDWORD(v392) = 0xFFF7FFFF;
            v398 = NAN;
            v399 = 0xFFBFFFFF;
            __asm { vmovupd [rbp+400h+var_310], xmm0 }
            v409 = _XMM0;
            v411 = _XMM0;
            v413 = _XMM0;
            v417 = 0;
            v418 = _XMM0;
            v419 = 0;
            v421 = 0x80000000;
            v422 = 0x80000000;
            n8 = 8;
            (*(void (__fastcall **)(__int64 *, __m128i *))(*v214 + 0x20))(v214, &v385);
            if ( (v385.m128i_i8[4] & 0x20) != 0
              || !(*(unsigned int (__fastcall **)(__int64 *, int *))(*v214 + 0x28))(v214, &v389) )
            {
              return 0;
            }
            v221 = *v214;
            v222 = v396 * v218 - v397 * v217 + v398 * v216;
            v223 = v397 * v216 - v395 * v218 + v398 * v217;
            v224 = v395 * v217 - v396 * v216 + v398 * v218;
            v225 = COERCE_UNSIGNED_INT64(v224 * v396 - v223 * v397);
            *((_QWORD *)&v226 + 1) = 0;
            *(double *)&v226 = v222 * v397 - v224 * v395;
            v227 = v226;
            *((_QWORD *)&v226 + 1) = 0;
            *(double *)&v226 = v223 * v395 - v222 * v396;
            v228 = v226;
            *((_QWORD *)&v226 + 1) = *((_QWORD *)&v225 + 1);
            *(double *)&v226 = *(double *)&v225 + v216 + *(double *)&v225 + v392;
            v229 = v226;
            *((_QWORD *)&v226 + 1) = *((_QWORD *)&v227 + 1);
            *(double *)&v226 = *(double *)&v227 + v217 + *(double *)&v227 + v393;
            v230 = v226;
            *((_QWORD *)&v226 + 1) = *((_QWORD *)&v228 + 1);
            *(double *)&v226 = *(double *)&v228 + v218 + *(double *)&v228 + v394;
            v231 = v226;
            v388 = *(double *)&v226;
            v369 = *(double *)&v229;
            v387 = *(double *)&v230;
            if ( (*(unsigned int (__fastcall **)(__int64 *, int *))(v221 + 0x28))(v214, &n8) )
            {
              *((_QWORD *)&v233 + 1) = *((_QWORD *)&v229 + 1);
              *(double *)&v233 = *(double *)&v229 - v406;
              _XMM0 = v233;
              *((_QWORD *)&v233 + 1) = *((_QWORD *)&v230 + 1);
              *(double *)&v233 = *(double *)&v230 - *(double *)&v407;
              _XMM1 = v233;
              __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
              *((_QWORD *)&v233 + 1) = *((_QWORD *)&v231 + 1);
              *(double *)&v233 = *(double *)&v231 - *((double *)&v407 + 1);
              _XMM0 = v233;
              __asm
              {
                vcvtsd2ss xmm8, xmm0, xmm0
                vcvtsd2ss xmm7, xmm1, xmm1
              }
            }
            else
            {
              LODWORD(_XMM8) = 0;
              LODWORD(_XMM7) = 0;
              LODWORD(_XMM6) = 0;
            }
            v361 = *(float *)&_XMM6;
            v360 = *(float *)&_XMM7;
            v468 = *(float *)&_XMM8;
            if ( v214 == a1
              && (LODWORD(_XMM8) = 0,
                  LODWORD(_XMM7) = 0,
                  LODWORD(_XMM6) = 0,
                  v468 = 0.0,
                  v360 = 0.0,
                  v361 = 0.0,
                  *((_BYTE *)a2 + 0x28)) )
            {
              v239 = 0.0;
              v240 = 0.0;
            }
            else
            {
              v239 = *(float *)&v410;
              v240 = *((float *)&v409 + 3);
              v219 = *((float *)&v409 + 2);
            }
            *(float *)&v365 = v240 - (float)((float)(1.0 - v220) * *((float *)&v411 + 1));
            *((float *)&v409 + 3) = *(float *)&v365;
            *(float *)&v371 = v239 - (float)((float)(1.0 - v220) * *((float *)&v411 + 2));
            *(float *)&v410 = *(float *)&v371;
            v359 = (float)(*(float *)&_XMM8 * *(float *)&v409) - (float)(*((float *)&v409 + 1) * *(float *)&_XMM7);
            v364 = (float)(*((float *)&v409 + 1) * *(float *)&_XMM6) - (float)(*((float *)&v408 + 3) * *(float *)&_XMM8);
            *(float *)&v368 = (float)(*((float *)&v408 + 3) * *(float *)&_XMM7)
                            - (float)(*(float *)&_XMM6 * *(float *)&v409);
            *((float *)&v410 + 2) = *((float *)&v410 + 2) - (float)((float)(1.0 - v220) * *(float *)&v412);
            *(float *)&v376 = *((float *)&v410 + 2);
            v241 = (float)((float)(v396 * v472) - (float)(v397 * v362)) + (float)(v398 * v358);
            *((float *)&v410 + 1) = *((float *)&v410 + 1) - (float)((float)(1.0 - v220) * *((float *)&v411 + 3));
            *(float *)&v367 = *((float *)&v410 + 1);
            v242 = (float)((float)(v397 * v358) - (float)(v395 * v472)) + (float)(v398 * v362);
            v243 = (float)((float)(v395 * v362) - (float)(v396 * v358)) + (float)(v398 * v472);
            v244 = (float)(v396 * v243) - (float)(v397 * v242);
            v245 = (float)(v397 * v241) - (float)(v395 * v243);
            v246 = (float)((float)(v396 * v354) - (float)(v397 * v352)) + (float)(v398 * v475);
            *((float *)&v409 + 2) = v219 - (float)((float)(1.0 - v220) * *(float *)&v411);
            *((float *)&v410 + 3) = *((float *)&v410 + 3) - (float)((float)(1.0 - v220) * *((float *)&v412 + 1));
            v247 = (float)((float)(v397 * v475) - (float)(v395 * v354)) + (float)(v352 * v398);
            v248 = (float)((float)(v352 * v395) - (float)(v396 * v475)) + (float)(v398 * v354);
            v476 = (float)((float)((float)(v396 * v248) - (float)(v397 * v247)) + v475)
                 + (float)((float)(v396 * v248) - (float)(v397 * v247));
            v249 = (float)((float)((float)(v247 * v395) - (float)(v246 * v396)) + v354)
                 + (float)((float)(v247 * v395) - (float)(v246 * v396));
            v353 = (float)((float)((float)(v246 * v397) - (float)(v248 * v395)) + v352)
                 + (float)((float)(v246 * v397) - (float)(v248 * v395));
            v358 = (float)((float)((float)((float)((float)((float)(2.0 * *(float *)&v409) * v249)
                                                 - (float)((float)(*((float *)&v409 + 1) * 2.0) * v353))
                                         + *((float *)&v409 + 2))
                                 + (float)((float)(v244 + v358) + v244))
                         + (float)((float)(*(float *)&v409 * *(float *)&v368) - (float)(*((float *)&v409 + 1) * v364)))
                 + (float)((float)(*((float *)&v410 + 2) * v468) - (float)(*((float *)&v410 + 3) * v360));
            v250 = (float)((float)((float)((float)((float)((float)(*((float *)&v409 + 1) * 2.0) * v476)
                                                 - (float)((float)(*((float *)&v408 + 3) * 2.0) * v249))
                                         + *(float *)&v365)
                                 + (float)((float)(v245 + v362) + v245))
                         + (float)((float)(*((float *)&v409 + 1) * v359)
                                 - (float)(*((float *)&v408 + 3) * *(float *)&v368)))
                 + (float)((float)(*((float *)&v410 + 3) * v361) - (float)(*((float *)&v410 + 1) * v468));
            v362 = v250;
            v251 = (__int64 **)v214[0x17];
            v252 = (float)((float)((float)((float)((float)((float)(*((float *)&v408 + 3) * 2.0) * v353)
                                                 - (float)((float)(2.0 * *(float *)&v409) * v476))
                                         + *(float *)&v371)
                                 + (float)((float)((float)((float)(v395 * v242) - (float)(v396 * v241)) + v472)
                                         + (float)((float)(v395 * v242) - (float)(v396 * v241))))
                         + (float)((float)(*((float *)&v408 + 3) * v364) - (float)(v359 * *(float *)&v409)))
                 + (float)((float)(*((float *)&v410 + 1) * v360) - (float)(*((float *)&v410 + 2) * v361));
            v214 = *v251;
            v253 = (float)((float)((float)(v396 * v357) - (float)(v397 * v355)) + (float)(v398 * v356))
                 + (float)(v395 * v363);
            v254 = (float)((float)((float)(v397 * v356) - (float)(v395 * v357)) + (float)(v398 * v355))
                 + (float)(v396 * v363);
            v255 = (float)((float)((float)(v395 * v355) - (float)(v396 * v356)) + (float)(v398 * v357))
                 + (float)(v397 * v363);
            LODWORD(v220) = LODWORD(v366) ^ 0x80000000;
            v256 = (float)(v398 * v363)
                 - (float)((float)((float)(v396 * v355) + (float)(v395 * v356)) + (float)(v397 * v357));
            v363 = v256;
            v472 = v252;
            if ( v251 == *((__int64 ***)a2 + 1) )
            {
              _XMM15 = LODWORD(v358);
              __asm { vunpcklps xmm0, xmm15, xmm12 }
              *((double *)a2 + 2) = *(double *)&_XMM0;
              *((float *)a2 + 6) = v252;
              v259 = (float)((float)(v250 * v255) - (float)(v252 * v254)) + (float)(*(float *)&_XMM15 * v256);
              v260 = (float)((float)(v253 * v252) - (float)(*(float *)&_XMM15 * v255)) + (float)(v250 * v256);
              v261 = (float)((float)(*(float *)&_XMM15 * v254) - (float)(v253 * v250)) + (float)(v252 * v256);
              *((float *)a2 + 7) = (float)(*(float *)&_XMM15 + (float)((float)(v255 * v260) - (float)(v254 * v261)))
                                 + (float)((float)(v255 * v260) - (float)(v254 * v261));
              *((float *)a2 + 8) = (float)(v250 + (float)((float)(v253 * v261) - (float)(v255 * v259)))
                                 + (float)((float)(v253 * v261) - (float)(v255 * v259));
              *((float *)a2 + 9) = (float)(v252 + (float)((float)(v254 * v259) - (float)(v253 * v260)))
                                 + (float)((float)(v254 * v259) - (float)(v253 * v260));
              return 1;
            }
            v216 = v369;
            v217 = v387;
            v218 = v388;
            v475 = (float)(v359 + *(float *)&v408) + v476;
            v357 = v255;
            v354 = (float)(*((float *)&v408 + 2) + *(float *)&v368) + v249;
            v352 = (float)(*((float *)&v408 + 1) + v364) + v353;
            v356 = v253;
            v355 = v254;
            LODWORD(v366) ^= 0x80000000;
            v219 = 0.0;
            _XMM0 = 0;
            if ( !v214 )
              return 0;
          }
        }
        return 0;
      case 0x20:
        v16 = 1;
        p_rw_lock_state = a1 + 0x19;
        v262 = _InterlockedIncrement64(a1 + 0x19);
        if ( (v262 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            (__int64)(a1 + 0x19),
            v262,
            "CPhysicalEntity::GetStatus",
            "m_lockUpdate",
            1);
        v263 = (__int64 *)a1[0x44];
        if ( !v263 || (v264 = *v263, !*(_DWORD *)(v264 + 0x50)) )
        {
          v16 = 0;
          goto LABEL_10;
        }
        v265 = *((_QWORD *)a2 + 1);
        if ( v265 )
        {
          *(_QWORD *)v265 = 0;
          *(_DWORD *)(v265 + 8) = 0;
        }
        v266 = *(float ***)(v264 + 8);
        v267 = *(float ***)v264;
        if ( v267 == v266 )
          goto LABEL_10;
        v268 = v266;
        while ( 1 )
        {
          v269 = *v267;
          if ( (**(unsigned int (__fastcall ***)(float *))*v267)(*v267) == 0x18 )
          {
            v270 = (unsigned int (__fastcall **)(_QWORD))*((_QWORD *)v269 + 0x10);
            if ( v270 )
              break;
          }
LABEL_204:
          v267 += 0xF;
          if ( v267 == v268 )
          {
            v16 = 1;
            goto LABEL_10;
          }
        }
        v271 = *((float *)a1 + 0x77);
        v272 = *((float *)a1 + 0x76);
        v273 = *((float *)a1 + 0x78);
        v274 = *((float *)a1 + 0x79);
        v275 = (float *)(a2 + 7);
        v276 = (float *)(a2 + 8);
        v277 = (float *)(a1[0x46] + 0x20LL * *((int *)v267 + 0x1C));
        v278 = 0;
        n0x12 = 0;
        v280 = v277[1];
        v281 = v277[2];
        v282 = v277[3];
        v283 = (float)(v282 * v274)
             - (float)((float)((float)(*v277 * v272) + (float)(v280 * v271)) + (float)(v281 * v273));
        v284 = (float)((float)((float)(v281 * v271) - (float)(v280 * v273)) + (float)(*v277 * v274))
             + (float)(v282 * v272);
        v285 = (float)((float)(*v277 * v273) - (float)(v281 * v272)) + (float)(v280 * v274);
        v286 = v280 * v272;
        v287 = v269[0x18];
        v288 = v269[0x1A];
        v289 = v286 - (float)(*v277 * v271);
        v290 = v282 * v271;
        v291 = v269[0x1B];
        v292 = v285 + v290;
        v293 = v281 * v274;
        v294 = v269[0x19];
        v295 = (float)(v289 + v293) + (float)(v282 * v273);
        v469 = (float)(v283 * v291)
             - (float)((float)((float)(v292 * v294) + (float)(v284 * v287)) + (float)(v295 * v288));
        v296 = (float)((float)((float)(v292 * v288) - (float)(v295 * v294)) + (float)(v283 * v287))
             + (float)(v284 * v291);
        v473 = (float)((float)((float)(v295 * v287) - (float)(v284 * v288)) + (float)(v283 * v294))
             + (float)(v292 * v291);
        v297 = v284 * v294;
        v298 = v277[7];
        v299 = (float)((float)(v297 - (float)(v292 * v287)) + (float)(v283 * v288)) + (float)(v295 * v291);
        v356 = v299;
        *(float *)&v366 = v296;
        v477 = v298;
        while ( 1 )
        {
          v300 = *((float *)a2 + 4);
          v301 = *(double *)((char *)v270 + 0xC);
          v378 = *((_DWORD *)v270 + 5);
          v377 = v301;
          *(_DWORD *)((char *)&v377 + v278) = 0;
          _XMM13 = v378;
          _XMM14 = HIDWORD(v377);
          _XMM15 = LODWORD(v377);
          *(float *)&v371 = v300;
          v369 = 0.0;
          v370 = 0.0;
          *(_DWORD *)((char *)&v369 + v278) = 0x3F800000;
          if ( (LODWORD(v300) & 0xFFA00000) == 0xFFA00000 )
            break;
          v305 = *((float *)a2 + 6);
          v306 = *((float *)a2 + 5);
          v307 = (float)((float)(v306 * v299) - (float)(v473 * v305)) + (float)(v300 * v469);
          v308 = (float)((float)(v296 * v305) - (float)(v300 * v299)) + (float)(v306 * v469);
          v309 = (float)((float)(v300 * v473) - (float)(v306 * v296)) + (float)(v305 * v469);
          v310 = (float)((float)((float)(v306 + (float)((float)(v309 * *(float *)&v366) - (float)(v307 * v356)))
                               + (float)((float)(v309 * *(float *)&v366) - (float)(v307 * v356)))
                       * *((float *)&v369 + 1))
               + (float)((float)((float)(v300 + (float)((float)(v299 * v308) - (float)(v473 * v309)))
                               + (float)((float)(v299 * v308) - (float)(v473 * v309)))
                       * *(float *)&v369);
          v311 = (float)((float)(v305 + (float)((float)(v307 * v473) - (float)(v308 * *(float *)&v366)))
                       + (float)((float)(v307 * v473) - (float)(v308 * *(float *)&v366)))
               * v370;
          v298 = v477;
          v312 = v310 + v311;
          v313 = (float)(v310 + v311) <= 0.0;
          n0x3F800000_1 = 0x3F800000u;
          if ( !v313 )
            goto LABEL_195;
LABEL_198:
          LODWORD(v324) = LODWORD(v312) ^ 0x80000000;
          if ( COERCE_FLOAT(LODWORD(v312) ^ 0x80000000) <= 0.0 )
          {
            v275 = (float *)(a2 + 7);
            v276 = (float *)(a2 + 8);
          }
          else
          {
            v325 = *((_QWORD *)a2 + 1);
            v326 = (float)(v324 * *(float *)&v270[n0x12 + 9]) * v298;
            if ( v325 )
            {
              *(float *)(v278 + v325) = (float)((float)(v324 * *(float *)&v270[n0x12 + 9]) * v298)
                                      + *(float *)(v278 + v325);
              v275 = (float *)(a2 + 7);
              v276 = (float *)(a2 + 8);
            }
            *v275 = v326 + *v275;
            __asm
            {
              vcmpneqss xmm0, xmm14, xmm11
              vblendvps xmm1, xmm4, xmm14, xmm0
              vcmpneqss xmm0, xmm15, xmm11
              vblendvps xmm0, xmm4, xmm15, xmm0
            }
            v331 = *(float *)&_XMM1 * *(float *)&_XMM0;
            __asm
            {
              vcmpneqss xmm0, xmm13, xmm11
              vblendvps xmm1, xmm4, xmm13, xmm0
            }
            *v276 = (float)(v331 * (float)(*(float *)&_XMM1 * (float)(v324 * 4.0))) + *v276;
          }
          v296 = *(float *)&v366;
          v299 = v356;
          n0x12 += 6;
          v278 += 4;
          if ( n0x12 >= 0x12 )
            goto LABEL_204;
        }
        n0x3F800000_1 = 0x3F800000u;
        v312 = 1.0;
LABEL_195:
        v315 = *((_QWORD *)a2 + 1);
        v316 = (float)(v312 * *(float *)&v270[n0x12 + 6]) * v298;
        if ( v315 )
          *(float *)(v278 + v315) = (float)((float)(v312 * *(float *)&v270[n0x12 + 6]) * v298) + *(float *)(v278 + v315);
        *v275 = v316 + *v275;
        __asm
        {
          vcmpneqss xmm0, xmm14, xmm11
          vblendvps xmm1, xmm4, xmm14, xmm0
          vcmpneqss xmm0, xmm15, xmm11
          vblendvps xmm0, xmm4, xmm15, xmm0
        }
        v321 = *(float *)&_XMM1 * *(float *)&_XMM0;
        __asm
        {
          vcmpneqss xmm0, xmm13, xmm11
          vblendvps xmm0, xmm4, xmm13, xmm0
        }
        *v276 = (float)((float)(v321 * (float)(*(float *)&_XMM0 * 4.0)) * v312) + *v276;
        v276 = (float *)(a2 + 8);
        v275 = (float *)(a2 + 7);
        goto LABEL_198;
      case 0x21:
        return a1[0x44] != 0 ? 2 : 0;
      case 0x2A:
        return *(unsigned int *)(a1[0x54] + 0xB0);
      case 0x2B:
        v334 = a2[1];
        if ( v334 == 0x80000000 )
        {
          if ( !*((_QWORD *)a2 + 0xC) && !a2[0x1A] )
            return 0;
          v335 = a2 + 0x18;
          v336 = sub_1467AA080((_QWORD *)a1[0x54], (__int64 *)a2 + 0xC);
        }
        else
        {
          v335 = a2 + 0x18;
          v336 = sub_14679AB80(a1[0x54], v334);
        }
        if ( v336 )
        {
          *((double *)a2 + 1) = *(double *)(v336 + 0x40);
          a2[4] = *(_DWORD *)(v336 + 0x48);
          *(double *)(a2 + 5) = *(double *)(v336 + 0xC);
          a2[7] = *(_DWORD *)(v336 + 0x14);
          *((double *)a2 + 4) = *(double *)(v336 + 0x18);
          a2[0xA] = *(_DWORD *)(v336 + 0x20);
          *(double *)(a2 + 0xB) = *(double *)v336;
          a2[0xD] = *(_DWORD *)(v336 + 8);
          a2[0xE] = *(_DWORD *)(v336 + 0x24);
          a2[0xF] = *(_DWORD *)(v336 + 0x28);
          *((_QWORD *)a2 + 8) = *(_QWORD *)(v336 + 0x50);
          *((_QWORD *)a2 + 9) = *(_QWORD *)(v336 + 0x58);
          a2[0x14] = *(_DWORD *)(v336 + 0x80);
          a2[0x15] = *(_DWORD *)(v336 + 0x84);
          a2[0x16] = *(_DWORD *)(v336 + 0x88);
          *((_OWORD *)a2 + 7) = *(_OWORD *)(v336 + 0x60);
          *v335 = *(_OWORD *)(v336 + 0x70);
          a2[0x20] = *(_DWORD *)(v336 + 0x8C);
          a2[0x21] = *(_DWORD *)(v336 + 0x90);
          a2[0x22] = *(_DWORD *)(v336 + 0x94);
          a2[0x23] = *(_DWORD *)(v336 + 0x98);
          a2[0x24] = *(_DWORD *)(v336 + 0x9C);
          *((double *)a2 + 0x13) = *(double *)(v336 + 0xA0) * 0.000001;
          _XMM1 = *(unsigned __int64 *)(v336 + 0xA8);
          __asm { vcvtpd2ps xmm1, xmm1 }
          a2[0x28] = _XMM1;
          _XMM0 = *(unsigned __int64 *)(v336 + 0xB0);
          __asm { vcvtpd2ps xmm0, xmm0 }
          a2[0x29] = _XMM0;
          _XMM1 = *(unsigned __int64 *)(v336 + 0xB8);
          __asm { vcvtpd2ps xmm1, xmm1 }
          a2[0x2A] = _XMM1;
          a2[0x2C] = *(_DWORD *)(v336 + 0xC8);
          return 1;
        }
        return 0;
      case 0x2C:
        v343 = a2[1];
        if ( v343 == 0x80000000 )
        {
          v343 = 0;
          a2[1] = 0;
        }
        v344 = a1[0x54];
        v345 = *(_QWORD *)(v344 + 0x90) + 0x20LL * v343;
        epi32 = _mm_extract_epi32(*(__m128i *)v345, 2);
        v385 = *(__m128i *)v345;
        map_get_value_by_composite_key(v344, (unsigned __int64 *)&v385, epi32, a2 + 2);
        *((_OWORD *)a2 + 1) = *(_OWORD *)(v345 + 0x10);
        return 1;
    }
    if ( n0x30 == 0x30 && sub_146A8A730(a1, (double *)v385.m128i_i64, (double *)&v445, (float *)&v367, (float *)&v365) )
    {
      v347 = v386;
      *(__m128i *)(a2 + 2) = v385;
      v348 = v445;
      *((double *)a2 + 3) = v347;
      v349 = v446;
      *((_OWORD *)a2 + 2) = v348;
      LODWORD(v348) = v367;
      *((double *)a2 + 6) = v349;
      a2[0xF] = v365;
      a2[0xE] = v348;
      return 1;
    }
    if ( *a2 == 0x31 )
    {
      v350 = (_QWORD *)a1[0x5B];
      if ( v350 )
      {
        *((_QWORD *)a2 + 1) = *v350;
        a2[4] = *(_DWORD *)(a1[0x5B] + 0x1D0);
        a2[5] = *(_DWORD *)(a1[0x5B] + 0x1D4);
        a2[6] = *(_DWORD *)(a1[0x5B] + 0x1D8);
        a2[7] = *(_DWORD *)(a1[0x5B] + 0x1DC);
        a2[8] = *(_DWORD *)(a1[0x5B] + 0x1E0);
        v351 = a1[0x5B];
        *(_OWORD *)(a2 + 9) = *(_OWORD *)(v351 + 0x1E4);
        *(double *)(a2 + 0xD) = *(double *)(v351 + 0x1F4);
        result = 1;
        a2[0xF] = *(_DWORD *)(a1[0x5B] + 0x1FC);
        return result;
      }
    }
    else if ( *a2 == 0x34 )
    {
      value_by_id_5 = 1;
      *((_QWORD *)a2 + 1) = a1[0x18];
      a2[4] = *((__int16 *)a1 + 0x7A);
      a2[5] = *((__int16 *)a1 + 0x7B);
      return (unsigned int)value_by_id_5;
    }
    return 0;
  }
  v16 = 1;
  p_rw_lock_state_5 = a1 + 0x19;
  v101 = _InterlockedIncrement64(a1 + 0x19);
  if ( (v101 & 0x200000) != 0 )
    rw_lock_acquire_read_lock_dispatch((__int64)(a1 + 0x19), v101, "CPhysicalEntity::GetStatus", "m_lockUpdate", 1);
  *((_QWORD *)a2 + 4) = 0;
  v102 = a1[0x17];
  *((_QWORD *)a2 + 1) = v102;
  if ( v102 )
  {
    *((_QWORD *)a2 + 2) = *(_QWORD *)(v102 + 0x178);
    *((_QWORD *)a2 + 3) = *(_QWORD *)sub_146ADA300(v102, &v387);
  }
  v103 = (__int64 *)*((_QWORD *)a2 + 1);
  if ( v103 )
  {
    v104 = *v103;
    *((_QWORD *)a2 + 4) = *v103;
    if ( v104 )
    {
      v105 = *v103;
      *(_OWORD *)(a2 + 0xA) = *(_OWORD *)(*v103 + 0x1C0);
      *((double *)a2 + 7) = *(double *)(v105 + 0x1D0);
      v106 = (_DWORD *)*v103;
      a2[0x10] = v106[0x76];
      a2[0x11] = v106[0x77];
      a2[0x12] = v106[0x78];
      a2[0x13] = v106[0x79];
    }
  }
  current_lock_value_6 = _InterlockedDecrement64(p_rw_lock_state_5);
  if ( (current_lock_value_6 & 0x3FF) != 0 || (current_lock_value_6 & 0xFFFF0000FFC00000uLL) == 0 )
    return v16;
  rw_lock_handle_release_contention(p_rw_lock_state_5, current_lock_value_6);
  return 1;
}

// --- End Function: sub_146A8D150 (0x146A8D150) ---

// --- Function: sub_146A94170 (0x146A94170) ---
bool __fastcall sub_146A94170(__int64 a1, __int64 a2)
{
  bool result; // al
  __m256 v14; // [rsp+40h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0uLL;
  if ( (*(_BYTE *)(a1 + 0x384) & 0x20) != 0 && !*(_DWORD *)(*(_QWORD *)(a1 + 0x2C0) + 0x4ACLL) )
    sub_146A94220(a1, a2, _RBP + 0x20);
  _YMM4 = (__m256i)ymmword_148D30060;
  __asm
  {
    vmaskmovpd ymm1, ymm4, ymmword ptr [r9]
    vmaskmovpd ymm0, ymm4, ymmword ptr [rbx+18h]
    vmaskmovpd ymm2, ymm4, ymmword ptr [r9+18h]
    vcmpnge_uqpd ymm3, ymm0, ymm1
    vmaskmovpd ymm0, ymm4, ymmword ptr [rbx]
    vcmpnle_uqpd ymm1, ymm0, ymm2
  }
  _YMM0 = (__m256i)(unsigned __int128)(*(_OWORD *)_YMM1.m256i_i8 | *(_OWORD *)_YMM3.m256i_i8);
  __asm
  {
    vmovupd [rbp+50h+var_50], ymm0
    vzeroupper
    vmovupd ymm0, [rbp+50h+var_50]
    vmovmskpd eax, ymm0
  }
  result = (_EAX & 7) == 0;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_146A94170 (0x146A94170) ---

// --- Function: sub_146A94710 (0x146A94710) ---
__int64 __fastcall sub_146A94710(__int64 a1, unsigned __int64 *a2, __int64 n0x7FF)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int128 v5; // xmm8
  __int128 v6; // xmm9
  __int128 v7; // xmm10
  __int128 v8; // xmm11
  __int128 v9; // xmm12
  __int128 v10; // xmm13
  __int128 v11; // xmm14
  __int128 v12; // xmm15
  unsigned int v13; // r12d
  double v20; // xmm4_8
  double v21; // xmm7_8
  double v22; // xmm10_8
  double v23; // xmm9_8
  double v24; // xmm8_8
  double v25; // xmm6_8
  double v26; // xmm4_8
  double v27; // xmm5_8
  double v28; // xmm14_8
  double v29; // xmm15_8
  __int128 v31; // kr00_16
  __int128 v33; // kr00_16
  int v38; // r15d
  __int64 v39; // r14
  __int64 v40; // rsi
  __int64 v41; // rbx
  __int64 v42; // rax
  __int64 v43; // rax
  float v44; // xmm2_4
  float v45; // xmm0_4
  float v46; // xmm9_4
  float v47; // xmm10_4
  float v48; // xmm4_4
  float v49; // xmm1_4
  float v50; // kr00_4
  float v51; // xmm8_4
  __int64 v52; // rax
  float v53; // xmm7_4
  float v54; // xmm6_4
  float v55; // xmm4_4
  float v57[4]; // [rsp+30h] [rbp-D0h] BYREF
  double v58[4]; // [rsp+40h] [rbp-C0h] BYREF
  int n0x2800; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v60; // [rsp+64h] [rbp-9Ch]
  int v61; // [rsp+6Ch] [rbp-94h]
  unsigned __int64 v62; // [rsp+70h] [rbp-90h]
  unsigned __int64 v63; // [rsp+78h] [rbp-88h]
  __int64 v64; // [rsp+80h] [rbp-80h]
  __int64 v65; // [rsp+88h] [rbp-78h]
  __int128 v66; // [rsp+B0h] [rbp-50h]
  __int128 v67; // [rsp+C0h] [rbp-40h]
  __int128 v68; // [rsp+D0h] [rbp-30h]
  __int128 v69; // [rsp+E0h] [rbp-20h]
  __int128 v70; // [rsp+F0h] [rbp-10h]
  __int128 v71; // [rsp+100h] [rbp+0h]
  __int128 v72; // [rsp+110h] [rbp+10h]
  __int128 v73; // [rsp+120h] [rbp+20h]
  __int128 v74; // [rsp+130h] [rbp+30h]
  __int128 v75; // [rsp+140h] [rbp+40h]
  float v76; // [rsp+190h] [rbp+90h]
  float v77; // [rsp+198h] [rbp+98h]
  float v78; // [rsp+1A8h] [rbp+A8h]

  v75 = v3;
  v13 = 0;
  v74 = v4;
  v73 = v5;
  v72 = v6;
  v71 = v7;
  v70 = v8;
  v69 = v9;
  v68 = v10;
  v67 = v11;
  v66 = v12;
  n0x2800 = 0x2800;
  v60 = 1;
  v61 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v62 = __rdtsc();
  qword_149C89AA0(
    &n0x2800,
    &word_1516E4B9C,
    "CPhysicalEntity::PointInside",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryPhysics\\physicalentity.cpp",
    0x117C);
  _XMM13 = a2[2];
  _XMM12 = a2[1];
  _XMM11 = *a2;
  v20 = *(float *)(a1 + 0x1E4);
  v21 = *(float *)(a1 + 0x1D8);
  v22 = *(float *)(a1 + 0x1DC);
  v23 = *(float *)(a1 + 0x1E0);
  v24 = *(double *)&_XMM13 * v22 - *(double *)&_XMM12 * v23 + *(double *)&_XMM11 * v20;
  v25 = *(double *)&_XMM11 * v23 - v21 * *(double *)&_XMM13 + v20 * *(double *)&_XMM12;
  v26 = v21 * *(double *)&_XMM12 - *(double *)&_XMM11 * v22 + v20 * *(double *)&_XMM13;
  v27 = *(double *)&_XMM11 + v22 * v26 - v23 * v25 + v22 * v26 - v23 * v25 + *(double *)(a1 + 0x1C0);
  v28 = *(double *)&_XMM12 + *(double *)(a1 + 0x1C8) + v23 * v24 - v21 * v26 + v23 * v24 - v21 * v26;
  v29 = *(double *)&_XMM13 + *(double *)(a1 + 0x1D0) + v21 * v25 - v22 * v24 + v21 * v25 - v22 * v24;
  __asm { vcvtsd2ss xmm8, xmm13, xmm13 }
  v31 = _XMM8;
  *(float *)&v31 = *(float *)&_XMM8 - *(float *)(a1 + 0x1F0);
  v33 = v31 & 0x7FFFFFFF;
  *(float *)&v33 = *(float *)&v33 - *(float *)(a1 + 0x1FC);
  _XMM1 = v33;
  __asm { vcvtsd2ss xmm7, xmm12, xmm12 }
  __asm
  {
    vmaxss  xmm2, xmm1, xmm0
    vcvtsd2ss xmm4, xmm11, xmm11
  }
  __asm { vmaxss  xmm2, xmm2, xmm0 }
  v58[0] = v27;
  v58[1] = v28;
  v58[2] = v29;
  v76 = *(float *)&_XMM4;
  v77 = *(float *)&_XMM7;
  v78 = *(float *)&_XMM8;
  HIWORD(n0x2800) = word_1516E4B9C;
  if ( *(float *)&_XMM2 < 0.0 )
  {
    if ( *(_DWORD *)(a1 + 0x2A8) )
    {
      if ( (*(int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) <= 2 )
      {
        LOBYTE(v13) = sub_146A79BE0(a1, v58) < 0.0;
        goto LABEL_20;
      }
      v27 = v58[0];
      *(float *)&_XMM4 = v76;
    }
    v38 = 0;
    if ( *(int *)(a1 + 0x290) > 0 )
    {
      v39 = 0;
      v40 = 0;
      v41 = 0;
      while ( 1 )
      {
        if ( (n0x7FF & *(_QWORD *)(v39 + *(_QWORD *)(a1 + 0x240))) != 0 )
        {
          v42 = *(_QWORD *)(a1 + 0x228);
          if ( v27 >= *(double *)(v41 + v42)
            && v28 >= *(double *)(v41 + v42 + 8)
            && v29 >= *(double *)(v41 + v42 + 0x10)
            && v27 <= *(double *)(v41 + v42 + 0x18)
            && v28 <= *(double *)(v41 + v42 + 0x20)
            && v29 <= *(double *)(v41 + v42 + 0x28) )
          {
            v43 = *(_QWORD *)(a1 + 0x230);
            v44 = 1.0 / *(float *)(v40 + v43 + 0x1C);
            v45 = *(float *)&_XMM4 - *(float *)(v40 + v43 + 0x10);
            v46 = *(float *)(v40 + v43 + 8);
            v47 = *(float *)(v40 + v43 + 4);
            v48 = *(float *)(v40 + v43 + 0xC);
            v49 = *(float *)&_XMM7 - *(float *)(v40 + v43 + 0x14);
            v50 = *(float *)&_XMM8 - *(float *)(v40 + v43 + 0x18);
            v51 = *(float *)(v40 + v43);
            v52 = *(_QWORD *)(a1 + 0x238);
            v53 = (float)((float)(v46 * (float)(v49 * v44)) - (float)(v47 * (float)(v50 * v44)))
                + (float)(v48 * (float)(v45 * v44));
            v54 = (float)((float)(v51 * (float)(v50 * v44)) - (float)(v46 * (float)(v45 * v44)))
                + (float)(v48 * (float)(v49 * v44));
            v55 = (float)((float)(v47 * (float)(v45 * v44)) - (float)(v51 * (float)(v49 * v44)))
                + (float)(v48 * (float)(v50 * v44));
            v57[0] = (float)((float)(v45 * v44) + (float)((float)(v46 * v54) - (float)(v47 * v55)))
                   + (float)((float)(v46 * v54) - (float)(v47 * v55));
            v57[1] = (float)((float)(v49 * v44) + (float)((float)(v51 * v55) - (float)(v46 * v53)))
                   + (float)((float)(v51 * v55) - (float)(v46 * v53));
            v57[2] = (float)((float)(v50 * v44) + (float)((float)(v47 * v53) - (float)(v51 * v54)))
                   + (float)((float)(v47 * v53) - (float)(v51 * v54));
            if ( (*(unsigned int (__fastcall **)(_QWORD, float *))(***(_QWORD ***)(v39 + v52) + 0x40LL))(
                   **(_QWORD **)(v39 + v52),
                   v57) )
            {
              v13 = 1;
              break;
            }
            *(float *)&_XMM7 = v77;
            *(float *)&_XMM8 = v78;
          }
        }
        ++v38;
        v41 += 0x30;
        v40 += 0x20;
        v39 += 8;
        if ( v38 >= *(_DWORD *)(a1 + 0x290) )
          break;
        v27 = v58[0];
        *(float *)&_XMM4 = v76;
      }
    }
  }
LABEL_20:
  v63 = __rdtsc();
  qword_149C89AA8(&n0x2800);
  return v13;
}

// --- End Function: sub_146A94710 (0x146A94710) ---

// --- Function: sub_146AD98E0 (0x146AD98E0) ---
__int64 __fastcall sub_146AD98E0(
        __int64 a1,
        double *a2,
        double *a3,
        __int64 a4,
        int a5,
        __int64 a6,
        int a7,
        __int64 a8,
        __int64 a9)
{
  double v9; // xmm1_8
  int v12; // r14d
  __int128 v13; // xmm0
  double v14; // xmm1_8
  __int64 v15; // rdi
  double v17; // xmm1_8
  __int128 v18; // xmm0
  double v19; // xmm1_8
  const char *p_Unknown; // rax
  signed __int64 v21; // rbx
  unsigned int v22; // ebx
  __int64 v24; // [rsp+88h] [rbp-2C0h]
  __int128 v26; // [rsp+98h] [rbp-2B0h] BYREF
  double v27; // [rsp+A8h] [rbp-2A0h]
  __int128 v28; // [rsp+B0h] [rbp-298h] BYREF
  double v29; // [rsp+C0h] [rbp-288h]
  __int128 v30; // [rsp+C8h] [rbp-280h] BYREF
  double v31; // [rsp+D8h] [rbp-270h]
  __int128 v32; // [rsp+E0h] [rbp-268h]
  double v33; // [rsp+F0h] [rbp-258h]
  wchar_t String[256]; // [rsp+100h] [rbp-248h] BYREF

  v9 = a2[2];
  v12 = 0;
  v28 = *(_OWORD *)a2;
  v13 = *(_OWORD *)a3;
  v29 = v9;
  v14 = a3[2];
  v26 = v13;
  v27 = v14;
  v24 = sub_1467AC6C0();
  v15 = a8;
  if ( !a8 )
    v15 = a1 + 0xCA0;
  if ( a6 )
  {
    v12 = (((*(_DWORD *)(a6 + 0x208) & 0x8000) - 1) >> 0x1F) & (1 << *(_DWORD *)(a6 + 0xFC));
    if ( a8 )
    {
      v15 = a8;
      goto LABEL_9;
    }
    v15 = *(_QWORD *)(a6 + 0xB8);
  }
  if ( !v15 )
    __debugbreak();
LABEL_9:
  if ( *(_QWORD *)(v15 + 0x1C8) )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v15 + 0x1B8));
    if ( (a5 & 0x100) != 0 && **(_DWORD **)(v15 + 0x1C8) == 1 )
    {
      LOBYTE(String[0]) = 0;
      v17 = a2[2];
      v30 = *(_OWORD *)a2;
      v18 = *(_OWORD *)a3;
      v31 = v17;
      v19 = a3[2];
      v32 = v18;
      v33 = v19;
      if ( a6 )
        p_Unknown = (const char *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a6 + 0x118LL))(a6, 1);
      else
        p_Unknown = "Unknown";
      swprintf(String, 0x200u, "%s - %s", p_Unknown, "CPhysicalWorld::GetEntitiesAround");
      sub_1469F19C0(*(_QWORD *)v15, &v30, String, 1);
    }
    v21 = _InterlockedIncrement64((volatile signed __int64 *)(v15 + 0x198));
    if ( (v21 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(v15 + 0x198, v21, (const char *)&p_Src, (const char *)&p_Src, 1);
    v22 = sub_146B03560(a1, (unsigned int)&v28, (unsigned int)&v26, a5, v12, a7, a6, v15, a4, 0, v15 + 0x198, v24, a9);
    sub_146AF2940(v15);
    return v22;
  }
  else
  {
    LogTraceConditional("calling GetEntitiesAround on an uninitialized grid - skipping");
    if ( *(_DWORD *)(a1 + 0x244) )
      __debugbreak();
    return 0;
  }
}

// --- End Function: sub_146AD98E0 (0x146AD98E0) ---

// --- Function: sub_146ADA300 (0x146ADA300) ---
_QWORD *__fastcall sub_146ADA300(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x180);
  return a2;
}

// --- End Function: sub_146ADA300 (0x146ADA300) ---

// --- Function: __security_check_cookie (0x1481441B0) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x1481441B0) ---

// --- Function: memmove (0x148192BE1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148192BE1) ---

// --- Function: acosf (0x148192D2B) ---
// attributes: thunk
float __cdecl acosf(float X)
{
  return __imp_acosf(X);
}

// --- End Function: acosf (0x148192D2B) ---

