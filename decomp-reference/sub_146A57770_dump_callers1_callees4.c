// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146A57770 (sub_146A57770)
// Caller Depth: 1
// Callee/Ref Depth: 4
// Total Functions Found: 47
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: memory_deallocate_wrapper (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall memory_deallocate_wrapper(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: memory_deallocate_wrapper (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_Wrapper (0x1402A3D40) ---
// // A wrapper function for allocWithProfilerInfo that allocates memory // without
// providing specific profiler information. It simply forwards // the allocation
// size to the main allocation function with a null // profiler context. // //
// Parameters: //   allocSize: The size of memory in bytes to allocate. // //
// Returns: //   A pointer to the newly allocated memory block, or nullptr if
// allocation fails.
__int64 __fastcall allocWithProfilerInfo_Wrapper(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_Wrapper (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
__int64 *__fastcall sub_1402A6760(__int64 *this, __int64 *Whereptr, __int64 *val)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  __int64 *v15; // r14
  void *v16; // rcx
  __int64 *Whereptr_2; // r8
  _BYTE *Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  __int64 *result; // rax

  v3 = ((__int64)Whereptr - *this) >> 3;
  v5 = (this[1] - *this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (this[2] - *this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_Wrapper(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_Wrapper(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *val;
  v16 = v14;
  Whereptr_2 = (__int64 *)this[1];
  Whereptr_1 = (_BYTE *)*this;
  if ( Whereptr == Whereptr_2 )
  {
    Size = (char *)Whereptr_2 - Whereptr_1;
  }
  else
  {
    memmove(v14, Whereptr_1, (char *)Whereptr - Whereptr_1);
    v16 = v15 + 1;
    Size = this[1] - (_QWORD)Whereptr;
    Whereptr_1 = Whereptr;
  }
  memmove(v16, Whereptr_1, Size);
  v20 = (const void *)*this;
  if ( *this )
  {
    if ( ((this[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      memory_deallocate_wrapper(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *this = (__int64)v14;
  result = &v14[v3];
  this[1] = (__int64)&v14[v9];
  this[2] = (__int64)&v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: sub_1403081E0 (0x1403081E0) ---
__int64 *__fastcall sub_1403081E0(__int64 *this, __int64 *const where_ptr, __int64 *value)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _DWORD *v15; // r14
  void *v16; // rcx
  __int64 *_Whereptr_2; // r8
  _BYTE *_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  __int64 *result; // rax

  v3 = ((__int64)where_ptr - *this) >> 2;
  v5 = (this[1] - *this) >> 2;
  if ( v5 == 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (this[2] - *this) >> 2;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x3FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 4 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_Wrapper(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_Wrapper(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = (_DWORD *)v14 + v3;
  *v15 = *(_DWORD *)value;
  v16 = v14;
  _Whereptr_2 = (__int64 *)this[1];
  _Whereptr_1 = (_BYTE *)*this;
  if ( where_ptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - _Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)where_ptr - _Whereptr_1);
    v16 = v15 + 1;
    Size = this[1] - (_QWORD)where_ptr;
    _Whereptr_1 = where_ptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = (const void *)*this;
  if ( *this )
  {
    if ( ((this[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFFCuLL) < 0x1000 )
    {
LABEL_20:
      memory_deallocate_wrapper(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *this = (__int64)v14;
  result = (_QWORD *)((char *)v14 + 4 * v3);
  this[1] = (__int64)v14 + 4 * v9;
  this[2] = (__int64)v14 + allocSize;
  return result;
}

// --- End Function: sub_1403081E0 (0x1403081E0) ---

// --- Function: lookup_entry_in_hashtable (0x140309200) ---
// Looks up an entry in a hash table based on a case-insensitive string key.
// Calculates a hash of the input string, uses SIMD instructions to efficiently
// search the corresponding bucket, and verifies the match using `_stricmp`. The
// hash table structure is described by `hash_table_ctx`, the key is `key_ptr`, and
// the result (pointers to the entry and key) is stored in `result_out`.
_OWORD *__fastcall lookup_entry_in_hashtable(_QWORD *a1, _OWORD *a2, const char **a3)
{
  const char *v3; // r11
  unsigned int n0x9E37; // r10d
  char i; // r9
  int v8; // eax
  bool v9; // cc
  int v10; // ecx
  __int64 v11; // rbp
  unsigned __int64 v12; // r12
  unsigned __int128 v13; // rax
  __int64 v14; // rsi
  __int64 v20; // rdi
  __int64 v21; // rdi
  _OWORD *result; // rax
  __int128 v25; // [rsp+20h] [rbp-68h]

  v3 = *a3;
  n0x9E37 = 0x9E37;
  for ( i = **a3; i; n0x9E37 = ((0x401 * (n0x9E37 + v10)) >> 6) ^ (0x401 * (n0x9E37 + v10)) )
  {
    v8 = i;
    ++v3;
    v9 = (unsigned __int8)(i - 0x41) <= 0x19u;
    i = *v3;
    v10 = v8 + 0x20;
    if ( !v9 )
      v10 = v8;
  }
  v11 = a1[3];
  v12 = 0;
  v13 = 0x8001 * ((9 * n0x9E37) ^ ((9 * n0x9E37) >> 0xB)) * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v14 = v11 & ((*((_QWORD *)&v13 + 1) + (_QWORD)v13) >> 7);
  _XMM7 = (BYTE8(v13) + (_BYTE)v13) & 0x7F;
  __asm { vpshufb xmm7, xmm7, xmm0 }
  while ( 1 )
  {
    _XMM6 = *(_OWORD *)(v14 + *a1);
    __asm
    {
      vpcmpeqb xmm0, xmm7, xmm6
      vpmovmskb ebx, xmm0
    }
    if ( _EBX )
      break;
LABEL_9:
    __asm
    {
      vpcmpeqb xmm1, xmm6, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      *(_QWORD *)&v25 = *a1 + a1[3];
      goto LABEL_14;
    }
    v12 += 0x10LL;
    v14 = v11 & (v12 + v14);
    if ( v12 > a1[3] )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v20, _EBX);
    v21 = v11 & (v14 + v20);
    if ( !_stricmp(*(const char **)(0x20 * v21 + a1[1]), *a3) )
      break;
    _EBX &= _EBX - 1;
    if ( !_EBX )
      goto LABEL_9;
  }
  *(_QWORD *)&v25 = v21 + *a1;
  *((_QWORD *)&v25 + 1) = 0x20 * v21 + a1[1];
LABEL_14:
  result = a2;
  *a2 = v25;
  return result;
}

// --- End Function: lookup_entry_in_hashtable (0x140309200) ---

// --- Function: sub_14030A540 (0x14030A540) ---
__int64 __fastcall sub_14030A540(__int64 a1, __int64 a2)
{
  void *v3; // rcx
  _BYTE *v4; // rsi
  unsigned __int64 v5; // rbx
  unsigned __int64 allocSize; // rbx

  v3 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  v4 = *(_BYTE **)(a2 + 8);
  if ( v4 )
  {
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v5;
    while ( v4[v5] );
    allocSize = v5 + 1;
    if ( allocSize )
    {
      v3 = (void *)allocWithProfilerInfo(allocSize, 0);
      *(_QWORD *)(a1 + 8) = v3;
      *(_QWORD *)(a1 + 0x10) = allocSize;
    }
    memcpy(v3, v4, allocSize);
  }
  return a1;
}

// --- End Function: sub_14030A540 (0x14030A540) ---

// --- Function: AssignStringPointer (0x14035B120) ---
// // Copies a QWORD value from a source location to a destination. // It initially
// sets the destination to a default/empty string pointer // (likely related to
// std::string's Small String Optimization), // but then immediately overwrites it
// with the actual source value. // // Parameters: //   destination: Pointer to the
// QWORD where the value will be copied. //   source: Pointer to the QWORD from
// which the value will be read. // // Returns: //   The pointer to the destination
// (destination).
_QWORD *__fastcall AssignStringPointer(_QWORD *destination, _QWORD *source)
{
  *destination = (char *)&qword_149B3B33C + 4;
  *destination = *source;
  return destination;
}

// --- End Function: AssignStringPointer (0x14035B120) ---

// --- Function: sub_14035BF60 (0x14035BF60) ---
_OWORD *__fastcall sub_14035BF60(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_14035BF60 (0x14035BF60) ---

// --- Function: DecrementReferenceCountAndFree (0x140370D10) ---
// // Decrements a reference count associated with a managed object and //
// deallocates the object's memory if the reference count is still positive. //
// This pattern is characteristic of shared pointer or reference-counted // memory
// management, where the reference count is stored in a control block // located
// just before the actual data pointed to by *a1. // // Parameters: //
// pManagedObjectPtr: A pointer to a QWORD, where the QWORD itself points //
// to the managed data. The reference count is expected //                      at
// an offset of -8 bytes from this data pointer.
void __fastcall DecrementReferenceCountAndFree(_QWORD *pManagedObjectPtr)
{
  int *pControlBlock; // rcx

  pControlBlock = (int *)(*pManagedObjectPtr - 8LL);
  if ( pControlBlock[1] > 0 )
    sub_147605980(pControlBlock);
}

// --- End Function: DecrementReferenceCountAndFree (0x140370D10) ---

// --- Function: getModuleFunction (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: getModuleFunction (0x14039B170) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: rw_lock_acquire_write_lock_profiled (0x1403DCDF0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended (e.g., by readers or another writer), it
// waits. Upon successful acquisition, it logs detailed profiling information,
// including timestamps, lock name, lock owner, and caller, using a dedicated
// profiling system. It also sets the lock owner pointer at `p_rw_lock_state + 8`.
__int64 __fastcall rw_lock_acquire_write_lock_profiled(
        __int64 p_rw_lock_state,
        unsigned __int64 rw_lock_state,
        __int64 lock_owner_ptr,
        const char *caller_name,
        const char *lock_name)
{
  __int64 p_profiler_system; // r15
  __int64 thread_context_ptr; // rax
  __int64 p_thread_data; // rsi
  unsigned int thread_id; // r14d
  const char *lock_name_1; // r13
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_3; // rax
  __int64 lock_owner_ptr_2; // rax
  unsigned __int64 new_lock_value_with_thread_id; // rdx
  signed __int64 rw_lock_state_1; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  signed __int64 rw_lock_state_2; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int profiler_event_type_1; // [rsp+30h] [rbp-91h] BYREF
  __int64 profiler_event_flags_1; // [rsp+34h] [rbp-8Dh]
  int profiler_event_level_1; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 start_timestamp_1; // [rsp+40h] [rbp-81h]
  unsigned __int64 end_timestamp_1; // [rsp+48h] [rbp-79h]
  __int64 profiler_data_ptr_1_1; // [rsp+50h] [rbp-71h]
  __int64 profiler_data_ptr_2_1; // [rsp+58h] [rbp-69h]
  int n0x1600; // [rsp+80h] [rbp-41h] BYREF
  __int64 profiler_event_flags_2; // [rsp+84h] [rbp-3Dh]
  int n2; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 start_timestamp_2; // [rsp+90h] [rbp-31h]
  unsigned __int64 end_timestamp_2; // [rsp+98h] [rbp-29h]
  __int64 profiler_data_ptr_1_2; // [rsp+A0h] [rbp-21h]
  __int64 profiler_data_ptr_2_2; // [rsp+A8h] [rbp-19h]
  _BYTE profiler_data_buffer[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char profiler_data_buffer_char; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 lock_owner_ptr_1; // [rsp+130h] [rbp+6Fh]

  lock_owner_ptr_1 = lock_owner_ptr;
  p_profiler_system = ::p_profiler_system;
  thread_context_ptr = get_thread_context_ptr();
  p_thread_data = *(_QWORD *)thread_context_ptr;
  thread_id = *(_DWORD *)(*(_QWORD *)thread_context_ptr + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
    p_profiler_system,
    profiler_data_buffer,
    &profiler_data_buffer_char);
  lock_name_1 = lock_name;
  do
  {
    while ( (rw_lock_state & 0x2003FF) != 0 )
    {
      new_lock_value_with_thread_id = (unsigned __int64)thread_id << 0x30;
      if ( (rw_lock_state & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(p_thread_data + 0x124) = HIWORD(rw_lock_state);
        rw_lock_state_1 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            new_lock_value_with_thread_id | rw_lock_state & 0xFFFFFFFFFFFFLL,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_1;
        rw_lock_state = rw_lock_state_1;
        if ( is_exchange_successful )
        {
          profiler_event_type_1 = 0x1600;
          profiler_event_flags_1 = 1;
          profiler_event_level_1 = 2;
          end_timestamp_1 = 0;
          profiler_data_ptr_1_1 = 0;
          profiler_data_ptr_2_1 = 0;
          start_timestamp_1 = __rdtsc();
          isProfileFunctionsInitialized(
            &profiler_event_type_1,
            &word_149B3E394,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(profiler_event_type_1) = word_149B3E394;
          qword_149B4B8B0("Lock: %s", lock_name_1);
          lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
          qword_149B4B8B0("Caller: %s", caller_name);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(
            p_profiler_system,
            thread_id);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          thread_id = *(_DWORD *)(p_thread_data + 0x11C);
          end_timestamp_1 = __rdtsc();
          qword_149B4B878(&profiler_event_type_1);
        }
      }
      else
      {
        *(_DWORD *)(p_thread_data + 0x124) = 0xFFFFFFFF;
        rw_lock_state_2 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            rw_lock_state | new_lock_value_with_thread_id,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_2;
        rw_lock_state = rw_lock_state_2;
        if ( is_exchange_successful )
        {
          n0x1600 = 0x1600;
          profiler_event_flags_2 = 1;
          n2 = 2;
          end_timestamp_2 = 0;
          profiler_data_ptr_1_2 = 0;
          profiler_data_ptr_2_2 = 0;
          start_timestamp_2 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E398,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600) = word_149B3E398;
          qword_149B4B8B0("Lock: %s", lock_name_1);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", caller_name);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(
            p_profiler_system,
            thread_id);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          thread_id = *(_DWORD *)(p_thread_data + 0x11C);
          end_timestamp_2 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
    }
    rw_lock_state_3 = _InterlockedCompareExchange64(
                        (volatile signed __int64 *)p_rw_lock_state,
                        rw_lock_state | 0x200000,
                        rw_lock_state);
    is_exchange_successful = rw_lock_state == rw_lock_state_3;
    rw_lock_state = rw_lock_state_3;
  }
  while ( !is_exchange_successful );
  lock_owner_ptr_2 = lock_owner_ptr_1;
  *(_QWORD *)(p_rw_lock_state + 8) = lock_owner_ptr_1;
  return lock_owner_ptr_2;
}

// --- End Function: rw_lock_acquire_write_lock_profiled (0x1403DCDF0) ---

// --- Function: rw_lock_acquire_write_lock_unprofiled (0x1403DD0B0) ---
// Acquires a write lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by readers). It then attempts to atomically set the write lock flag or
// increment a write lock count using `_InterlockedCompareExchange64`. Upon
// successful acquisition, it logs basic information about the lock, its owner, and
// the caller. This version does not include detailed performance profiling. It
// also sets the lock owner pointer at `p_rw_lock_state + 8`.
signed __int64 __fastcall rw_lock_acquire_write_lock_unprofiled(
        __int64 p_rw_lock_state,
        signed __int64 rw_lock_state,
        __int64 lock_owner_ptr,
        const char *caller_name,
        const char *lock_name)
{
  char is_write_lock_incremented; // r14
  signed __int64 new_lock_value; // rcx
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_3; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  int lock_state_val_1; // esi
  signed __int64 rw_lock_state_2; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int rw_lock_state_1; // [rsp+38h] [rbp-81h] BYREF
  _DWORD lock_state_val_3[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int profiler_event_type_1; // [rsp+48h] [rbp-71h] BYREF
  __int64 profiler_event_flags_1; // [rsp+4Ch] [rbp-6Dh]
  int profiler_event_level_1; // [rsp+54h] [rbp-65h]
  unsigned __int64 start_timestamp_1; // [rsp+58h] [rbp-61h]
  unsigned __int64 end_timestamp_1; // [rsp+60h] [rbp-59h]
  __int64 profiler_data_ptr_1_1; // [rsp+68h] [rbp-51h]
  __int64 profiler_data_ptr_2_1; // [rsp+70h] [rbp-49h]
  int n0x1600; // [rsp+98h] [rbp-21h] BYREF
  __int64 profiler_event_flags_2; // [rsp+9Ch] [rbp-1Dh]
  int n2; // [rsp+A4h] [rbp-15h]
  unsigned __int64 start_timestamp_2; // [rsp+A8h] [rbp-11h]
  unsigned __int64 end_timestamp_2; // [rsp+B0h] [rbp-9h]
  __int64 profiler_data_ptr_1_2; // [rsp+B8h] [rbp-1h]
  __int64 profiler_data_ptr_2_2; // [rsp+C0h] [rbp+7h]

  is_write_lock_incremented = 0;
  do
  {
    while ( 1 )
    {
      if ( (rw_lock_state & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)p_profiler_system + 0x128LL))(
          p_profiler_system,
          p_rw_lock_state);
      if ( (rw_lock_state & 0x2003FF) == 0 )
        break;
      if ( is_write_lock_incremented )
      {
        profiler_event_type_1 = 0x1600;
        profiler_event_flags_1 = 1;
        profiler_event_level_1 = 2;
        end_timestamp_1 = 0;
        profiler_data_ptr_1_1 = 0;
        profiler_data_ptr_2_1 = 0;
        start_timestamp_1 = __rdtsc();
        isProfileFunctionsInitialized(
          &profiler_event_type_1,
          &word_149B3E38C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(profiler_event_type_1) = word_149B3E38C;
        qword_149B4B8B0("Lock: %s", lock_name);
        lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(p_rw_lock_state + 8) )
          lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
        qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
        qword_149B4B8B0("Caller: %s", caller_name);
        rw_lock_state_1 = rw_lock_state;
        qword_149B3B480(p_rw_lock_state, &rw_lock_state_1, 4, 0xFFFFFFFFLL);
        rw_lock_state = *(_QWORD *)p_rw_lock_state;
        end_timestamp_1 = __rdtsc();
        qword_149B4B878(&profiler_event_type_1);
      }
      else
      {
        lock_state_val_1 = rw_lock_state + 0x400000;
        rw_lock_state_2 = _InterlockedCompareExchange64(
                            (volatile signed __int64 *)p_rw_lock_state,
                            rw_lock_state + 0x400000,
                            rw_lock_state);
        is_exchange_successful = rw_lock_state == rw_lock_state_2;
        rw_lock_state = rw_lock_state_2;
        if ( is_exchange_successful )
        {
          is_write_lock_incremented = 1;
          n0x1600 = 0x1600;
          profiler_event_flags_2 = 1;
          n2 = 2;
          end_timestamp_2 = 0;
          profiler_data_ptr_1_2 = 0;
          profiler_data_ptr_2_2 = 0;
          start_timestamp_2 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E390,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600) = word_149B3E390;
          qword_149B4B8B0("Lock: %s", lock_name);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(p_rw_lock_state + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(p_rw_lock_state + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", caller_name);
          lock_state_val_3[0] = lock_state_val_1;
          qword_149B3B480(p_rw_lock_state, lock_state_val_3, 4, 0xFFFFFFFFLL);
          rw_lock_state = *(_QWORD *)p_rw_lock_state;
          end_timestamp_2 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
    }
    new_lock_value = (rw_lock_state | 0x200000) - 0x400000;
    if ( !is_write_lock_incremented )
      new_lock_value = rw_lock_state | 0x200000;
    rw_lock_state_3 = _InterlockedCompareExchange64(
                        (volatile signed __int64 *)p_rw_lock_state,
                        new_lock_value,
                        rw_lock_state);
    is_exchange_successful = rw_lock_state == rw_lock_state_3;
    rw_lock_state = rw_lock_state_3;
  }
  while ( !is_exchange_successful );
  *(_QWORD *)(p_rw_lock_state + 8) = lock_owner_ptr;
  return rw_lock_state_3;
}

// --- End Function: rw_lock_acquire_write_lock_unprofiled (0x1403DD0B0) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403DD380) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(
        __int64 p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  unsigned __int64 new_lock_value; // rdi
  unsigned int thread_context_owner_id; // edx
  signed __int64 current_lock_value_1; // rax
  __int64 p_profiler_system; // rdi
  __int64 thread_context_ptr_1; // r8
  int thread_context_owner_id_2; // ecx
  __int64 thread_context_ptr_2; // r8
  unsigned __int64 thread_id_high_word; // rbx
  const ULONG_PTR *default_lock_owner_ptr; // rax
  int thread_context_info_1; // [rsp+70h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+78h] [rbp+10h] BYREF
  __int64 thread_context_ptr_3; // [rsp+80h] [rbp+18h] BYREF
  __int64 thread_context_ptr_4; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value & 0xFFFFFFFFFFD003FFuLL;
    if ( (current_lock_value & 0xFFFF00100000LL) != 0 )
    {
      new_lock_value = current_lock_value & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (current_lock_value & 0xFFC003FF) == 0 && (current_lock_value & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_4,
        &thread_context_info_2);
      new_lock_value = current_lock_value & 0xFFFFFFD003FFLL;
      thread_context_owner_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_2 - 1)) << 9)
                                          + thread_context_ptr_4
                                          + 0x124);
      if ( thread_context_owner_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)thread_context_owner_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value,
                             current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0x3FF) != 0 )
  {
    if ( (current_lock_value & 0x100000) != 0 )
      qword_149B3B490(p_rw_lock_state);
    if ( (current_lock_value & 0xFFFF00000000LL) != 0 )
    {
      p_profiler_system = ::p_profiler_system;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_3,
        &thread_context_info_1);
      thread_context_ptr_1 = thread_context_ptr_3
                           + ((WORD2(current_lock_value) & (unsigned __int64)(unsigned int)(thread_context_info_1 - 1)) << 9);
      LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_1 + 0x124);
      *(_DWORD *)(thread_context_ptr_1 + 0x11C) = (unsigned __int16)(WORD2(current_lock_value) + thread_context_info_1);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      while ( (_DWORD)current_lock_value != 0xFFFFFFFF )
      {
        thread_context_owner_id_2 = (unsigned __int16)(current_lock_value + thread_context_info_1);
        thread_context_ptr_2 = thread_context_ptr_3
                             + ((unsigned __int64)((unsigned int)current_lock_value & (thread_context_info_1 - 1)) << 9);
        LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_2 + 0x124);
        *(_DWORD *)(thread_context_ptr_2 + 0x11C) = thread_context_owner_id_2;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      }
    }
  }
  else if ( (current_lock_value & 0xFFC00000) != 0 )
  {
    qword_149B3B488(p_rw_lock_state);
  }
  else if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
      ::p_profiler_system,
      &thread_context_ptr_3,
      &thread_context_info_1);
    thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)thread_id_high_word & (thread_context_info_1 - 1)) << 9)
              + thread_context_ptr_3
              + 0x11C) = (unsigned __int16)(thread_id_high_word + thread_context_info_1);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::p_profiler_system + 0xD8LL))(
      ::p_profiler_system,
      (unsigned int)thread_id_high_word);
  }
  default_lock_owner_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(p_rw_lock_state + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return default_lock_owner_ptr;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403DD380) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *stdioCommonVsprintfContext; // rax
  int formattedLength; // eax
  char errorMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, Format);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !gEnv || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    stdioCommonVsprintfContext = sub_1402A4380();
    formattedLength = _stdio_common_vsprintf(
                        *stdioCommonVsprintfContext | 2LL,
                        errorMessageBuffer,
                        0x1000u,
                        Format,
                        0,
                        args);
    if ( formattedLength < 0 )
      formattedLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedLength >= 0x1000 )
      errorMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      errorMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1413ED3E0 (0x1413ED3E0) ---
void __fastcall sub_1413ED3E0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rdi
  const void *v10; // rcx
  _QWORD *v11; // rcx

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v4 != i; v4 += 4 )
    {
      v10 = (const void *)v4[1];
      if ( v10 )
        sub_147605980(v10);
    }
    v11 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v11 - v11[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v11 = (_QWORD *)v11[0xFFFFFFFF];
    }
    memory_deallocate_wrapper(v11);
  }
  *a1 = a2;
  a1[1] = a2 + 0x20 * a3;
  a1[2] = a2 + 0x20 * a4;
}

// --- End Function: sub_1413ED3E0 (0x1413ED3E0) ---

// --- Function: sub_146A4AEC0 (0x146A4AEC0) ---
char *__fastcall sub_146A4AEC0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r14
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v13; // rax
  _DWORD *v14; // rbx
  unsigned __int64 v15; // r14
  __int64 v16; // rdx
  __int64 v17; // rcx

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 5;
  if ( v5 == 0x7FFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (a1[2] - *a1) >> 5;
  v9 = v8 >> 1;
  v10 = v5 + 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_19;
  v11 = v5 + 1;
  if ( v9 + v8 >= v10 )
    v11 = v9 + v8;
  if ( v11 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_19;
  allocSize = 0x20 * v11;
  if ( 0x20 * v11 < 0x1000 )
  {
    if ( allocSize )
      v14 = (_DWORD *)allocWithProfilerInfo_Wrapper(allocSize);
    else
      v14 = 0;
    goto LABEL_14;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_19:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_Wrapper(allocSize + 0x27);
  if ( !v13 )
    invalid_parameter_noinfo_noreturn();
  v14 = (_DWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)v14 + 0xFFFFFFFF) = v13;
LABEL_14:
  v15 = v4 & 0xFFFFFFFFFFFFFFE0uLL;
  sub_14030A540((__int64)v14 + v15, a3);
  *(_WORD *)((char *)v14 + v15 + 0x18) = *(_WORD *)(a3 + 0x18);
  v16 = a1[1];
  v17 = *a1;
  if ( a2 == v16 )
  {
    sub_146A4B9E0(v17, v16, v14, a1);
  }
  else
  {
    sub_146A4BA60(v17, a2, v14);
    sub_146A4BA60(a2, a1[1], (_DWORD *)((char *)v14 + v15 + 0x20));
  }
  sub_1413ED3E0(a1, v14, v10, v11);
  return (char *)v14 + v15;
}

// --- End Function: sub_146A4AEC0 (0x146A4AEC0) ---

// --- Function: sub_146A4B810 (0x146A4B810) ---
__int64 __fastcall sub_146A4B810(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r9
  int v5; // eax
  __int64 v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rcx

  if ( a2 != a1 )
  {
    v4 = a2 - 0x18;
    do
    {
      v5 = *(_DWORD *)(v4 - 8);
      v4 -= 0x20;
      v6 = *(_QWORD *)(a3 - 0x18);
      a3 -= 0x20;
      *(_DWORD *)a3 = v5;
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(v4 + 0x20);
      v7 = *(_QWORD *)(v4 + 0x28);
      *(_QWORD *)(v4 + 0x20) = v6;
      v8 = *(_QWORD *)(a3 + 0x10);
      *(_QWORD *)(a3 + 0x10) = v7;
      *(_QWORD *)(v4 + 0x28) = v8;
      *(_WORD *)(a3 + 0x18) = *(_WORD *)(v4 + 0x30);
    }
    while ( v4 + 0x18 != a1 );
  }
  return a3;
}

// --- End Function: sub_146A4B810 (0x146A4B810) ---

// --- Function: sub_146A4B9E0 (0x146A4B9E0) ---
__int64 __fastcall sub_146A4B9E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // r14
  _WORD *v8; // rdx
  __int16 v9; // cx

  v3 = a3;
  v5 = a1;
  if ( a1 != a2 )
  {
    v6 = a1 - a3;
    v7 = a3 - a1 + 0x18;
    do
    {
      sub_14030A540(v3, v5);
      v8 = (_WORD *)(v7 + v5);
      v3 += 0x20;
      v9 = *(_WORD *)(v7 + v5 + v6);
      v5 += 0x20;
      *v8 = v9;
    }
    while ( v5 != a2 );
  }
  return v3;
}

// --- End Function: sub_146A4B9E0 (0x146A4B9E0) ---

// --- Function: sub_146A4BA60 (0x146A4BA60) ---
_DWORD *__fastcall sub_146A4BA60(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // r9
  char *v5; // r10
  __int64 v6; // r8
  int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // rdx

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = (char *)a3 - a1;
    v6 = a1 + 0x10;
    do
    {
      *(_QWORD *)&v5[v6] = 0;
      *(_QWORD *)&v5[v6 - 8] = 0;
      v7 = *(_DWORD *)(v6 - 0x10);
      v6 += 0x20;
      *v3 = v7;
      v3 += 8;
      *(_QWORD *)&v5[v6 - 0x28] = *(_QWORD *)(v6 - 0x28);
      v8 = *(_QWORD *)(v6 - 0x20);
      *(_QWORD *)(v6 - 0x28) = 0;
      v9 = *(_QWORD *)&v5[v6 - 0x20];
      *(_QWORD *)&v5[v6 - 0x20] = v8;
      *(_QWORD *)(v6 - 0x20) = v9;
      *(_WORD *)&v5[v6 - 0x18] = *(_WORD *)(v6 - 0x18);
    }
    while ( v6 - 0x10 != a2 );
  }
  return v3;
}

// --- End Function: sub_146A4BA60 (0x146A4BA60) ---

// --- Function: sub_146A57770 (0x146A57770) ---
char __fastcall sub_146A57770(__int64 a1)
{
  __int64 v2; // rbx
  __int64 (__fastcall ***v3)(_QWORD, __int128 *); // rax
  __int64 (__fastcall ***v4)(_QWORD); // rax
  __int64 (__fastcall ***v5)(_QWORD); // rcx
  __int64 (__fastcall **v6)(_QWORD); // rax
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rax
  _QWORD *v10; // rcx
  _BYTE *v11; // r8
  _QWORD *v12; // rdx
  __int64 v13; // rdx
  _BYTE *v14; // rdx
  _QWORD *v15; // rdx
  __int64 v16; // r8
  unsigned __int64 v17; // rax
  __int64 *value_1; // rdi
  __int64 *value; // rbx
  __int64 where_ptr; // rdx
  unsigned __int64 v21; // rcx
  _DWORD *where_ptr_2; // rcx
  int v23; // r9d
  _WORD *where_ptr_1; // r8
  __int16 v25; // ax
  _WORD *where_ptr_3; // rcx
  __int64 **val_2; // rdi
  __int64 *val_1; // rbx
  __int64 Whereptr; // rdx
  unsigned __int64 v30; // rcx
  __int64 *Whereptr_2; // r8
  __int64 v32; // r9
  _QWORD *Whereptr_1; // rax
  int v34; // ecx
  _DWORD *Whereptr_3; // r8
  __int128 i; // rdi
  __int64 v37; // rbx
  unsigned __int64 v38; // rcx
  __int64 v39; // rax
  __int64 v40; // r15
  __int64 v41; // rdx
  __int64 v42; // rax
  const void *v43; // rcx
  __int64 v44; // rdx
  unsigned __int64 n0x200000; // rax
  _BYTE *v46; // rdx
  __int64 v47; // rbx
  __int64 v48; // rdi
  const void *v49; // rcx
  const void *v50; // rbx
  __int64 *v51; // rcx
  const void *value_3; // rcx
  __int16 v54; // [rsp+30h] [rbp-D0h] BYREF
  __int128 v55; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v56; // [rsp+48h] [rbp-B8h]
  const char *p_TagDatabase.TagDatabase; // [rsp+50h] [rbp-B0h] BYREF
  const char *v58; // [rsp+58h] [rbp-A8h] BYREF
  __int64 **val[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v60; // [rsp+70h] [rbp-90h]
  __int128 value_2; // [rsp+78h] [rbp-88h] BYREF
  __int64 v62; // [rsp+88h] [rbp-78h]
  __int64 v63; // [rsp+90h] [rbp-70h] BYREF
  _QWORD v64[2]; // [rsp+98h] [rbp-68h] BYREF
  int v65; // [rsp+A8h] [rbp-58h] BYREF
  const void *v66; // [rsp+B0h] [rbp-50h]
  __int64 v67; // [rsp+B8h] [rbp-48h]
  __int16 v68; // [rsp+C0h] [rbp-40h]
  int n0x1600; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v70; // [rsp+D4h] [rbp-2Ch]
  int v71; // [rsp+DCh] [rbp-24h]
  unsigned __int64 v72; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v73; // [rsp+E8h] [rbp-18h]
  __int64 v74; // [rsp+F0h] [rbp-10h]
  __int64 v75; // [rsp+F8h] [rbp-8h]
  __int128 v76; // [rsp+120h] [rbp+20h] BYREF
  __int128 v77; // [rsp+130h] [rbp+30h] BYREF
  int v78; // [rsp+148h] [rbp+48h]
  __int64 v79; // [rsp+158h] [rbp+58h]
  _QWORD v80[7]; // [rsp+160h] [rbp+60h] BYREF
  _QWORD *v81; // [rsp+198h] [rbp+98h]
  __int128 v82; // [rsp+1A0h] [rbp+A0h] BYREF
  __int64 v83; // [rsp+1B0h] [rbp+B0h]
  _BYTE v84[56]; // [rsp+1C0h] [rbp+C0h] BYREF
  _BYTE *v85; // [rsp+1F8h] [rbp+F8h]
  _BYTE v86[56]; // [rsp+200h] [rbp+100h] BYREF
  _BYTE *v87; // [rsp+238h] [rbp+138h]
  char _0_[512]; // [rsp+240h] [rbp+140h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0);
  p_TagDatabase.TagDatabase = "TagDatabase.TagDatabase";
  AssignStringPointer(&v58, &p_TagDatabase.TagDatabase);
  lookup_entry_in_hashtable((_QWORD *)(v2 + 0x40), &v77, &v58);
  v58 = (char *)&qword_149B3B33C + 4;
  DecrementReferenceCountAndFree(&v58);
  if ( (_QWORD)v77 == *(_QWORD *)(v2 + 0x40) + *(_QWORD *)(v2 + 0x58) )
  {
    v76 = 0u;
    sub_14035BF60(&v82, &v76);
    if ( !qword_149B4FCA0
      || !(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0)
      || (v3 = (__int64 (__fastcall ***)(_QWORD, __int128 *))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0
                                                                                                + 0x240LL))(qword_149B4FCA0),
          v4 = (__int64 (__fastcall ***)(_QWORD))(**v3)(v3, &v82),
          (v5 = v4) == 0) )
    {
      v7 = 0;
      goto LABEL_9;
    }
    v6 = *v4;
  }
  else
  {
    v8 = *((_QWORD *)&v77 + 1);
    sub_14035BF60(&v82, (_OWORD *)(*((_QWORD *)&v77 + 1) + 0x10LL));
    v5 = *(__int64 (__fastcall ****)(_QWORD))(v8 + 8);
    v6 = *v5;
  }
  v7 = (*v6)(v5);
LABEL_9:
  v83 = v7;
  if ( !v7 )
    return v7;
  n0x1600 = 0x1600;
  v70 = 1;
  v71 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v72 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x1600,
    &word_1515B0494,
    "CTagDatabase::LoadDatabase",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\TagSystem/TagDatabase.cpp",
    0x5B);
  HIWORD(n0x1600) = word_1515B0494;
  v62 = 0;
  v80[0] = off_148C205B8;
  v80[2] = &value_2;
  v80[3] = val;
  v80[4] = &v55;
  v80[5] = v84;
  v81 = v80;
  value_2 = 0;
  *(_OWORD *)val = 0;
  v60 = 0;
  v55 = 0;
  v56 = 0;
  v85 = 0;
  v80[1] = a1;
  v87 = 0;
  v9 = sub_146A61F80((__int64)v80, (__int64)v86);
  v10 = v81;
  v11 = (_BYTE *)v9;
  v87 = (_BYTE *)v9;
  if ( v81 )
  {
    v12 = v80;
    LOBYTE(v12) = v81 != v80;
    (*(void (__fastcall **)(_QWORD *, _QWORD *, __int64))(*v81 + 0x20LL))(v81, v12, v9);
    v11 = v87;
    v10 = 0;
    v81 = 0;
  }
  if ( v85 )
  {
    v10 = v85;
    if ( v85 == v84 )
    {
      v10 = (_QWORD *)(*(__int64 (__fastcall **)(_BYTE *, _QWORD *, _BYTE *))(*(_QWORD *)v85 + 8LL))(v85, v80, v11);
      v81 = v10;
      if ( !v85 )
      {
        v11 = v87;
        goto LABEL_19;
      }
      LOBYTE(v13) = v85 != v84;
      (*(void (__fastcall **)(_BYTE *, __int64))(*(_QWORD *)v85 + 0x20LL))(v85, v13);
      v10 = v81;
      v11 = v87;
    }
    else
    {
      v81 = v85;
    }
    v85 = 0;
  }
LABEL_19:
  if ( v11 )
  {
    if ( v11 == v86 )
    {
      v85 = (_BYTE *)(*(__int64 (__fastcall **)(_BYTE *, _BYTE *))(*(_QWORD *)v11 + 8LL))(v11, v84);
      if ( v87 )
      {
        v14 = v86;
        LOBYTE(v14) = v87 != v86;
        (*(void (__fastcall **)(_BYTE *, _BYTE *))(*(_QWORD *)v87 + 0x20LL))(v87, v14);
      }
      v10 = v81;
    }
    else
    {
      v85 = v11;
    }
  }
  if ( v10 )
  {
    v15 = v80;
    LOBYTE(v15) = v10 != v80;
    (*(void (__fastcall **)(_QWORD *, _QWORD *))(*v10 + 0x20LL))(v10, v15);
  }
  v16 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
  v17 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0x120), 0x200000, 0);
  if ( v17 )
    sub_1403DCD60(a1 + 0x120, v17, v16, "CTagDatabase::LoadDatabase", "m_tagDatabaseModificationLock", 1);
  else
    *(_QWORD *)(a1 + 0x128) = v16;
  strcpy(_0_, "/0");
  memset(&_0_[3], 0, 0x1FDu);
  v54 = 0xFFFF;
  v64[0] = _0_;
  v63 = 0;
  if ( !v85 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x146A580A0LL);
  }
  (*(void (__fastcall **)(_BYTE *, __int64, _QWORD *, __int64 *, __int16 *))(*(_QWORD *)v85 + 0x10LL))(
    v85,
    v83 + 8,
    v64,
    &v63,
    &v54);
  value_1 = (__int64 *)*((_QWORD *)&value_2 + 1);
  for ( value = (__int64 *)value_2; value != value_1; value = (__int64 *)((char *)value + 4) )
  {
    where_ptr = *(_QWORD *)(a1 + 0xF0);
    v21 = (*(_QWORD *)(a1 + 0xF8) - where_ptr) >> 2;
    while ( v21 )
    {
      if ( *(_WORD *)(where_ptr + 4 * (v21 >> 1)) >= *(_WORD *)value )
      {
        v21 >>= 1;
      }
      else
      {
        where_ptr += 4 * (v21 >> 1) + 4;
        v21 += 0xFFFFFFFFFFFFFFFFuLL - (v21 >> 1);
      }
    }
    where_ptr_2 = *(_DWORD **)(a1 + 0xF8);
    if ( (_DWORD *)where_ptr == where_ptr_2 || *(_WORD *)value < *(_WORD *)where_ptr )
    {
      if ( where_ptr_2 == *(_DWORD **)(a1 + 0x100) )
      {
        sub_1403081E0((__int64 *)(a1 + 0xF0), (__int64 *const)where_ptr, value);
      }
      else
      {
        v23 = *(_DWORD *)value;
        if ( (_DWORD *)where_ptr == where_ptr_2 )
        {
          *where_ptr_2 = v23;
          *(_QWORD *)(a1 + 0xF8) += 4LL;
        }
        else
        {
          where_ptr_1 = where_ptr_2 + 0xFFFFFFFF;
          *where_ptr_2 = where_ptr_2[0xFFFFFFFF];
          *(_QWORD *)(a1 + 0xF8) += 4LL;
          v78 = v23;
          if ( where_ptr_2 + 0xFFFFFFFF != (_DWORD *)where_ptr )
          {
            do
            {
              v25 = where_ptr_1[0xFFFFFFFE];
              where_ptr_3 = where_ptr_1;
              where_ptr_1 += 0xFFFFFFFE;
              *where_ptr_3 = v25;
              where_ptr_1[3] = where_ptr_1[1];
            }
            while ( where_ptr_1 != (_WORD *)where_ptr );
          }
          *(_WORD *)(where_ptr + 2) = HIWORD(v78);
          *(_WORD *)where_ptr = v23;
        }
      }
    }
  }
  val_2 = val[1];
  for ( val_1 = (__int64 *)val[0]; val_1 != (__int64 *)val_2; ++val_1 )
  {
    Whereptr = *(_QWORD *)(a1 + 0x108);
    v30 = (*(_QWORD *)(a1 + 0x110) - Whereptr) >> 3;
    while ( v30 )
    {
      if ( *(_DWORD *)(Whereptr + 8 * (v30 >> 1)) >= *(_DWORD *)val_1 )
      {
        v30 >>= 1;
      }
      else
      {
        Whereptr += 8 * (v30 >> 1) + 8;
        v30 += 0xFFFFFFFFFFFFFFFFuLL - (v30 >> 1);
      }
    }
    Whereptr_2 = *(__int64 **)(a1 + 0x110);
    if ( (__int64 *)Whereptr == Whereptr_2 || *(_DWORD *)val_1 < *(_DWORD *)Whereptr )
    {
      if ( Whereptr_2 == *(__int64 **)(a1 + 0x118) )
      {
        sub_1402A6760((__int64 *)(a1 + 0x108), (__int64 *)Whereptr, val_1);
      }
      else
      {
        v32 = *val_1;
        if ( (__int64 *)Whereptr == Whereptr_2 )
        {
          *Whereptr_2 = v32;
          *(_QWORD *)(a1 + 0x110) += 8LL;
        }
        else
        {
          Whereptr_1 = Whereptr_2 + 0xFFFFFFFF;
          *Whereptr_2 = Whereptr_2[0xFFFFFFFF];
          *(_QWORD *)(a1 + 0x110) += 8LL;
          v79 = v32;
          if ( Whereptr_2 + 0xFFFFFFFF != (__int64 *)Whereptr )
          {
            do
            {
              v34 = *((_DWORD *)Whereptr_1 + 0xFFFFFFFE);
              Whereptr_3 = Whereptr_1;
              Whereptr_1 += 0xFFFFFFFF;
              *Whereptr_3 = v34;
              *((_WORD *)Whereptr_1 + 6) = *((_WORD *)Whereptr_1 + 2);
            }
            while ( Whereptr_1 != (_QWORD *)Whereptr );
          }
          *(_WORD *)(Whereptr + 4) = WORD2(v79);
          *(_DWORD *)Whereptr = v32;
        }
      }
    }
  }
  for ( i = v55; (_QWORD)i != *((_QWORD *)&i + 1); *(_QWORD *)&i = i + 0x20 )
  {
    v37 = *(_QWORD *)(a1 + 0xC0);
    v38 = (*(_QWORD *)(a1 + 0xC8) - v37) >> 5;
    while ( v38 )
    {
      v39 = 0x20 * (v38 >> 1);
      if ( *(_DWORD *)(v39 + v37) >= *(_DWORD *)i )
      {
        v38 >>= 1;
      }
      else
      {
        v37 += v39 + 0x20;
        v38 += 0xFFFFFFFFFFFFFFFFuLL - (v38 >> 1);
      }
    }
    v40 = *(_QWORD *)(a1 + 0xC8);
    if ( v37 == v40 || *(_DWORD *)i < *(_DWORD *)v37 )
    {
      if ( v40 == *(_QWORD *)(a1 + 0xD0) )
      {
        sub_146A4AEC0(a1 + 0xC0, v37, i);
      }
      else if ( v37 == v40 )
      {
        sub_14030A540(*(_QWORD *)(a1 + 0xC8), i);
        *(_WORD *)(v40 + 0x18) = *(_WORD *)(i + 0x18);
        *(_QWORD *)(a1 + 0xC8) += 0x20LL;
      }
      else
      {
        v64[1] = a1 + 0xC0;
        sub_14030A540((__int64)&v65, i);
        v41 = v40 - 0x20;
        v68 = *(_WORD *)(i + 0x18);
        *(_DWORD *)v40 = *(_DWORD *)(v40 - 0x20);
        *(_QWORD *)(v40 + 8) = *(_QWORD *)(v40 - 0x18);
        v42 = *(_QWORD *)(v40 - 0x10);
        *(_QWORD *)(v41 + 8) = 0;
        *(_QWORD *)(v41 + 0x10) = 0;
        *(_QWORD *)(v40 + 0x10) = v42;
        *(_WORD *)(v40 + 0x18) = *(_WORD *)(v40 - 8);
        *(_QWORD *)(a1 + 0xC8) += 0x20LL;
        sub_146A4B810(v37, v40 - 0x20, v40);
        v43 = *(const void **)(v37 + 8);
        v44 = *(_QWORD *)(v37 + 0x10);
        *(_DWORD *)v37 = v65;
        *(_QWORD *)(v37 + 8) = v66;
        *(_QWORD *)(v37 + 0x10) = v67;
        *(_WORD *)(v37 + 0x18) = v68;
        v66 = v43;
        v67 = v44;
        if ( v43 )
          sub_147605980(v43);
      }
    }
  }
  if ( a1 != 0xFFFFFFFFFFFFFEE0uLL )
  {
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 0x120), 0, 0x200000);
    if ( n0x200000 == 0x200000 )
      *(_QWORD *)(a1 + 0x128) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      rw_lock_handle_write_release_contention(a1 + 0x120, n0x200000);
  }
  if ( v85 )
  {
    v46 = v84;
    LOBYTE(v46) = v85 != v84;
    (*(void (__fastcall **)(_BYTE *, _BYTE *))(*(_QWORD *)v85 + 0x20LL))(v85, v46);
    v85 = 0;
  }
  v47 = v55;
  if ( (_QWORD)v55 )
  {
    v48 = *((_QWORD *)&v55 + 1);
    if ( (_QWORD)v55 != *((_QWORD *)&v55 + 1) )
    {
      do
      {
        v49 = *(const void **)(v47 + 8);
        if ( v49 )
          sub_147605980(v49);
        v47 += 0x20;
      }
      while ( v47 != v48 );
    }
    v50 = (const void *)v55;
    if ( ((v56 - (_QWORD)v55) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      v50 = *(const void **)(v55 - 8);
      if ( (unsigned __int64)(v55 - (_QWORD)v50 - 8) > 0x1F )
        goto LABEL_99;
    }
    memory_deallocate_wrapper(v50);
    v55 = 0;
    v56 = 0;
  }
  v51 = (__int64 *)val[0];
  if ( val[0] )
  {
    if ( ((v60 - (unsigned __int64)val[0]) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000
      || (v51 = val[0][0xFFFFFFFF], (unsigned __int64)((char *)val[0] - (char *)v51 - 8) <= 0x1F) )
    {
      memory_deallocate_wrapper(v51);
      *(_OWORD *)val = 0;
      v60 = 0;
      goto LABEL_96;
    }
LABEL_99:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_96:
  value_3 = (const void *)value_2;
  if ( (_QWORD)value_2 )
  {
    if ( ((v62 - (_QWORD)value_2) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      value_3 = *(const void **)(value_2 - 8);
      if ( (unsigned __int64)(value_2 - (_QWORD)value_3 - 8) > 0x1F )
        goto LABEL_99;
    }
    memory_deallocate_wrapper(value_3);
    value_2 = 0;
    v62 = 0;
  }
  v73 = __rdtsc();
  qword_149B4B878(&n0x1600);
  LOBYTE(v7) = 1;
  return v7;
}

// --- End Function: sub_146A57770 (0x146A57770) ---

// --- Function: sub_146A61F80 (0x146A61F80) ---
__int64 __fastcall sub_146A61F80(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a2 = off_148C205B8;
  result = a2;
  *(__m256i *)(a2 + 8) = *(__m256i *)(a1 + 8);
  *(double *)(a2 + 0x28) = *(double *)(a1 + 0x28);
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_146A61F80 (0x146A61F80) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE58LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n0x6900 = 0x6900;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x6900,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    0xA7);
  HIWORD(n0x6900) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n0x6900);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: ?_Xbad_function_call@std@@YAXXZ (0x14803279A) ---
// attributes: thunk
void std::_Xbad_function_call(void)
{
  __imp_?_Xbad_function_call@std@@YAXXZ();
}

// --- End Function: ?_Xbad_function_call@std@@YAXXZ (0x14803279A) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: security_check_stack_cookie (0x148033700) ---
// Performs a runtime security check to detect stack-based buffer overflows. It
// compares the provided stack cookie with a global security cookie and performs
// additional integrity checks. If a mismatch or corruption is detected, it
// triggers a fatal error.
void __cdecl security_check_stack_cookie(uintptr_t current_stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( current_stack_cookie != _security_cookie )
ReportFailure:
    _report_gsfailure(current_stack_cookie);
  rotated_cookie = __ROL8__(current_stack_cookie, 0x10);
  if ( (_WORD)rotated_cookie )
  {
    current_stack_cookie = __ROR8__(rotated_cookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: security_check_stack_cookie (0x148033700) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

