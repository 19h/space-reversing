// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146A24990 (sub_146A24990)
// Caller Depth: 1
// Callee/Ref Depth: 3
// Total Functions Found: 62
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: rw_lock_release_read_lock (0x1402D2790) ---
// Releases a read lock on the provided lock structure. If the current thread is
// the owner and has acquired the lock recursively, it decrements a recursive
// count. Otherwise, it atomically decrements the main lock state. If the lock
// state transitions to a specific value (e.g., indicating no more readers or a
// pending write lock), it may trigger a contention handler to wake waiting
// threads.
unsigned __int64 __fastcall rw_lock_release_read_lock(__int64 p_rw_lock_state)
{
  unsigned __int64 thread_context_ptr; // rax
  unsigned __int64 lock_state_after_decrement; // rdx

  thread_context_ptr = get_thread_context_ptr();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(thread_context_ptr + 0x18)
    && (thread_context_ptr = *(unsigned int *)(p_rw_lock_state + 0x14), (_DWORD)thread_context_ptr) )
  {
    thread_context_ptr = (unsigned int)(thread_context_ptr - 1);
    *(_DWORD *)(p_rw_lock_state + 0x14) = thread_context_ptr;
  }
  else
  {
    lock_state_after_decrement = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (lock_state_after_decrement & 0x3FF) == 0 )
    {
      thread_context_ptr = 0xFFFF0000FFC00000uLL;
      if ( (lock_state_after_decrement & 0xFFFF0000FFC00000uLL) != 0 )
        return rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, lock_state_after_decrement);
    }
  }
  return thread_context_ptr;
}

// --- End Function: rw_lock_release_read_lock (0x1402D2790) ---

// --- Function: sub_1402DB100 (0x1402DB100) ---
const ULONG_PTR *__fastcall sub_1402DB100(__int64 a1)
{
  unsigned __int32 v1; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  v1 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
  if ( v1 != 1 )
    return sub_1403DB1F0(a1, v1);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402DB100 (0x1402DB100) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_descriptor_ptr)
{
  unsigned __int64 entity_descriptor_value; // r9
  __int64 entity_base_addr_or_id; // r10
  unsigned __int64 entity_type_and_flags; // r9
  __int64 alignment_boundary_value; // rax
  __int64 entity_base_addr_or_id_for_alignment; // r10
  __int64 entity_header_ptr; // rbx
  bool is_privileged_or_bypass_mode; // al

  entity_descriptor_value = *entity_descriptor_ptr;
  if ( !*entity_descriptor_ptr )
    return 0;
  entity_base_addr_or_id = entity_descriptor_value & 0xFFFFFFFFFFFFLL;
  entity_type_and_flags = HIWORD(entity_descriptor_value);
  if ( (entity_type_and_flags & 0xF000) != 0 )
  {
    alignment_boundary_value = map_flag_to_mask(0x2000u);
    entity_header_ptr = entity_base_addr_or_id_for_alignment & ~(alignment_boundary_value - 1);
  }
  else
  {
    entity_header_ptr = entity_base_addr_or_id - 6;
  }
  if ( *(_WORD *)(entity_header_ptr + 2) != (entity_type_and_flags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D)
    || (is_privileged_or_bypass_mode = is_thread_privileged_or_bypass_mode()) )
  {
    is_privileged_or_bypass_mode = 1;
  }
  return *(_WORD *)(entity_header_ptr + 4) == 2 && is_privileged_or_bypass_mode
      || validate_entity_descriptor_detailed_access(entity_descriptor_ptr) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int result_mask; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        result_mask = 0;
        if ( input_flag == 0x6000 )
          return 0x4000000;
        return result_mask;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_thread_context_ptr() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = pEntitySystem;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: validate_entity_descriptor_detailed_access (0x140392020) ---
// Performs detailed access validation for an entity descriptor. It extracts the
// entity's base address or ID from the descriptor. It then determines a pointer to
// entity metadata based on the highest bit of the descriptor (either by masking or
// by applying a -6 offset to the base address/ID). The function then dispatches to
// different validation logic based on the value of a status/type field at
// `entity_metadata_ptr + 4`: - If 0, returns false. - If 1, calls
// `check_thread_list_contains_value` with the entity's base address/ID. - If 2,
// checks for a privileged/bypass state (via `get_thread_context_ptr + 0x12D` or
// `is_thread_privileged_or_bypass_mode`). If privileged, returns true; otherwise,
// calls `validate_access_with_virtual_calls`. - If 3 or 4, checks thread data from
// `get_thread_context_ptr`. If a specific thread status is 1, it returns true if
// the entity's base address/ID is NOT equal to the magic value `0x13374770CLL`. -
// For any other status/type, returns false.
char __fastcall validate_entity_descriptor_detailed_access(_QWORD *entity_descriptor_ptr)
{
  _QWORD *entity_base_addr_or_id; // rbx
  __int64 entity_metadata_ptr; // rax
  __int64 thread_data_ptr; // rax

  entity_base_addr_or_id = (_QWORD *)(*entity_descriptor_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*entity_descriptor_ptr & 0xF000000000000000uLL) != 0 )
    entity_metadata_ptr = *entity_descriptor_ptr & 0xFFFFFF000000LL;
  else
    entity_metadata_ptr = (__int64)entity_base_addr_or_id + 0xFFFFFFFA;
  if ( !*(_WORD *)(entity_metadata_ptr + 4) )
    return 0;
  if ( *(_WORD *)(entity_metadata_ptr + 4) == 1 )
    return check_thread_list_contains_value((__int64)entity_base_addr_or_id);
  if ( *(_WORD *)(entity_metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(entity_metadata_ptr + 4) - 3 <= 1 )
    {
      thread_data_ptr = *(_QWORD *)(*(_QWORD *)(get_thread_context_ptr() + 0x10) + 8LL);
      if ( thread_data_ptr )
      {
        if ( *(_DWORD *)(thread_data_ptr + 8) == 1 )
          return *entity_base_addr_or_id != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)entity_base_addr_or_id);
}

// --- End Function: validate_entity_descriptor_detailed_access (0x140392020) ---

// --- Function: getModuleFunction (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: getModuleFunction (0x14039B170) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = p_profiler_system;
  v7 = get_thread_context_ptr();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = get_thread_context_ptr();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        isProfileFunctionsInitialized(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = get_thread_context_ptr();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403CA4D0 (0x1403CA4D0) ---
unsigned __int64 __fastcall sub_1403CA4D0(__int64 a1, unsigned __int64 a2, signed __int64 *a3)
{
  signed __int64 v6; // rdi
  unsigned __int64 v7; // r15
  int v8; // ebp
  signed __int32 v9; // r12d
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  __int64 v12; // rbp
  unsigned __int64 v13; // r9
  int v14; // eax

  v6 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 0x20), a2);
  v7 = v6 + a2;
  if ( v6 + a2 > *(_QWORD *)(a1 + 0x28) )
  {
    v8 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
    if ( *(_DWORD *)(a1 + 0x48) == v8 )
    {
      ++*(_DWORD *)(a1 + 0x4C);
    }
    else
    {
      v9 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x38), 1, 0);
      if ( v9 )
      {
        if ( *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
          sub_1403C3410(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
        else
          sub_1403C3680(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
      }
      else
      {
        *(_QWORD *)(a1 + 0x40) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      }
      *(_DWORD *)(a1 + 0x48) = v8;
    }
    v10 = *(_QWORD *)(a1 + 0x28);
    if ( v7 > v10 )
    {
      v11 = (v7 - v10) % *(_QWORD *)(a1 + 0x30);
      v12 = *(_QWORD *)(a1 + 0x30) + v7 - v10 - v11;
      v13 = *(_QWORD *)(a1 + 0x30) + v7 - v11;
      if ( v13 > *(_QWORD *)(a1 + 8) )
        LogFatalError(
          "Not enough storage reserved for thread safe container. Allocating %zu, Page size %u, Required %zu, Reserved %zu",
          a2,
          *(_DWORD *)(a1 + 0x14),
          v13,
          *(_QWORD *)(a1 + 8));
      sub_14056DA40(a1, *(_QWORD *)a1 + *(_QWORD *)(a1 + 0x28), v12);
      *(_QWORD *)(a1 + 0x28) += v12;
    }
    v14 = *(_DWORD *)(a1 + 0x4C);
    if ( v14 )
    {
      *(_DWORD *)(a1 + 0x4C) = v14 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x48) = 0xFFFFFFFF;
      sub_1402DB100(a1 + 0x38);
    }
  }
  if ( a3 )
    *a3 = v6;
  return v7 + *(_QWORD *)a1 - a2;
}

// --- End Function: sub_1403CA4D0 (0x1403CA4D0) ---

// --- Function: sub_1403CA640 (0x1403CA640) ---
const ULONG_PTR *__fastcall sub_1403CA640(__int64 a1, const void *a2, size_t Size)
{
  int v6; // esi
  signed __int32 v7; // edi
  __int64 v8; // r14
  __int64 v9; // rdi
  size_t v10; // rcx
  int v11; // eax
  const ULONG_PTR *result; // rax

  v6 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v6 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v7 )
    {
      if ( *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
        sub_1403C3410(a1, v7, "CWriteCopyUpdateContainerBase::PushBack");
      else
        sub_1403C3680(a1, v7, "CWriteCopyUpdateContainerBase::PushBack");
    }
    else
    {
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v6;
  }
  v8 = *(unsigned int *)(a1 + 0x28LL * *(_QWORD *)(a1 + 0x68) + 0x38);
  v9 = a1 + 0x28LL * *(_QWORD *)(a1 + 0x68);
  v10 = *(unsigned int *)(v9 + 0x3C);
  if ( v8 + Size > v10 )
  {
    if ( (unsigned __int64)(unsigned int)(v10 + *(_DWORD *)(v9 + 0x2C)) > *(_QWORD *)(v9 + 0x20) )
      LogFatalError("Out of Virtual Memory in CWriteCopyUpdateContainer");
    sub_14056DA40(v9 + 0x18, *(_QWORD *)(v9 + 0x18) + *(unsigned int *)(v9 + 0x3C), *(unsigned int *)(v9 + 0x2C));
    *(_DWORD *)(v9 + 0x3C) += *(_DWORD *)(v9 + 0x2C);
  }
  *(_DWORD *)(v9 + 0x38) += Size;
  memcpy((void *)(v8 + *(_QWORD *)(v9 + 0x18)), a2, Size);
  v11 = *(_DWORD *)(a1 + 0x14);
  if ( v11 )
  {
    result = (const ULONG_PTR *)(unsigned int)(v11 - 1);
    *(_DWORD *)(a1 + 0x14) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    return sub_1402DB100(a1);
  }
  return result;
}

// --- End Function: sub_1403CA640 (0x1403CA640) ---

// --- Function: rw_lock_acquire_read_lock_dispatch (0x1403CB300) ---
// Dispatches to either a profiled read lock acquisition function
// (`rw_lock_acquire_read_lock_profiled`) or a standard, unprofiled one
// (`rw_lock_acquire_read_lock_unprofiled`). The choice depends on a boolean flag
// (`is_profiled_mode`), a debug flag within the thread context (at offset `0x1C`),
// and the availability of the global environment (`gEnv`).
double __fastcall rw_lock_acquire_read_lock_dispatch(
        __int64 p_rw_lock_state,
        signed __int64 current_lock_value,
        const char *caller_name,
        const char *lock_name,
        char is_profiled_mode)
{
  if ( is_profiled_mode && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_read_lock_profiled(p_rw_lock_state, current_lock_value, caller_name, lock_name);
  else
    return rw_lock_acquire_read_lock_unprofiled(p_rw_lock_state, current_lock_value, caller_name, lock_name);
}

// --- End Function: rw_lock_acquire_read_lock_dispatch (0x1403CB300) ---

// --- Function: rw_lock_acquire_read_lock_profiled (0x1403CB380) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended, it retries. Upon successful acquisition,
// it logs detailed profiling information, including timestamps, lock name, lock
// owner, and caller, using a dedicated profiling system.
double __fastcall rw_lock_acquire_read_lock_profiled(
        __int64 p_rw_lock_state,
        signed __int64 current_lock_value,
        const char *caller_name,
        const char *lock_name)
{
  __int64 p_profiler_system; // r14
  __int64 thread_context_ptr; // rax
  __int64 p_thread_data; // rsi
  unsigned int thread_id; // r15d
  unsigned __int64 new_lock_value_with_thread_id; // rdx
  bool is_exchange_successful; // zf
  signed __int64 current_lock_value_1; // rax
  __int16 profiler_flags; // ax
  signed __int64 current_lock_value_2; // rax
  const ULONG_PTR *lock_owner_name_string_ptr; // rdx
  double result; // xmm0_8
  _BYTE profiler_data_buffer[16]; // [rsp+30h] [rbp-29h] BYREF
  int profiler_event_type; // [rsp+40h] [rbp-19h] BYREF
  __int64 profiler_event_flags; // [rsp+44h] [rbp-15h]
  int profiler_event_level; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 start_timestamp; // [rsp+50h] [rbp-9h]
  unsigned __int64 end_timestamp; // [rsp+58h] [rbp-1h]
  __int64 profiler_data_ptr_1; // [rsp+60h] [rbp+7h]
  __int64 profiler_data_ptr_2; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  p_profiler_system = ::p_profiler_system;
  thread_context_ptr = get_thread_context_ptr();
  p_thread_data = *(_QWORD *)thread_context_ptr;
  thread_id = *(_DWORD *)(*(_QWORD *)thread_context_ptr + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
    p_profiler_system,
    profiler_data_buffer,
    &v27);
  if ( (current_lock_value & 0x200000) == 0 )
    return result;
  new_lock_value_with_thread_id = (unsigned __int64)thread_id << 0x20;
  while ( (current_lock_value & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(p_thread_data + 0x124) = WORD2(current_lock_value);
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value_with_thread_id | current_lock_value & 0xFFFF0000FFFFFFFFuLL,
                             current_lock_value);
    is_exchange_successful = current_lock_value == current_lock_value_1;
    current_lock_value = current_lock_value_1;
    if ( is_exchange_successful )
    {
      profiler_event_type = 0x1600;
      end_timestamp = 0;
      profiler_data_ptr_1 = 0;
      profiler_data_ptr_2 = 0;
      profiler_event_flags = 1;
      profiler_event_level = 2;
      start_timestamp = __rdtsc();
      isProfileFunctionsInitialized(
        &profiler_event_type,
        &::profiler_flags,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      profiler_flags = ::profiler_flags;
      goto LABEL_10;
    }
LABEL_7:
    if ( (current_lock_value & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(p_thread_data + 0x124) = 0xFFFFFFFF;
  current_lock_value_2 = _InterlockedCompareExchange64(
                           (volatile signed __int64 *)p_rw_lock_state,
                           current_lock_value | new_lock_value_with_thread_id,
                           current_lock_value);
  is_exchange_successful = current_lock_value == current_lock_value_2;
  current_lock_value = current_lock_value_2;
  if ( !is_exchange_successful )
    goto LABEL_7;
  profiler_event_type = 0x1600;
  end_timestamp = 0;
  profiler_data_ptr_1 = 0;
  profiler_data_ptr_2 = 0;
  profiler_event_flags = 1;
  profiler_event_level = 2;
  start_timestamp = __rdtsc();
  isProfileFunctionsInitialized(
    &profiler_event_type,
    &profiler_flags_0,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  profiler_flags = profiler_flags_0;
LABEL_10:
  HIWORD(profiler_event_type) = profiler_flags;
  qword_149B4B8B0("Lock: %s", lock_name);
  lock_owner_name_string_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(p_rw_lock_state + 8) )
    lock_owner_name_string_ptr = *(const ULONG_PTR **)(p_rw_lock_state + 8);
  qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr);
  qword_149B4B8B0("Caller: %s", caller_name);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(p_profiler_system, thread_id);
  end_timestamp = __rdtsc();
  return qword_149B4B878(&profiler_event_type);
}

// --- End Function: rw_lock_acquire_read_lock_profiled (0x1403CB380) ---

// --- Function: rw_lock_acquire_read_lock_unprofiled (0x1403CB5B0) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by a writer). It then attempts to atomically set the read lock flag using
// `_InterlockedCompareExchange64`. Upon successful acquisition, it logs basic
// information about the lock, its owner, and the caller. This version does not
// include detailed performance profiling.
double __fastcall rw_lock_acquire_read_lock_unprofiled(
        __int64 p_rw_lock_state,
        signed __int64 rw_lock_state_2,
        const char *caller_name,
        const char *lock_name)
{
  signed __int64 rw_lock_state; // rbx
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  int *p_profiler_event_type; // rcx
  int new_lock_value; // edi
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_1; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_2; // rdx
  double result; // xmm0_8
  int rw_lock_state_3; // [rsp+30h] [rbp-69h] BYREF
  _DWORD lock_state_val_2[3]; // [rsp+34h] [rbp-65h] BYREF
  int profiler_event_type_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 profiler_event_flags_1; // [rsp+44h] [rbp-55h]
  int profiler_event_level_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 start_timestamp_1; // [rsp+50h] [rbp-49h]
  unsigned __int64 end_timestamp_1; // [rsp+58h] [rbp-41h]
  __int64 profiler_data_ptr_1_1; // [rsp+60h] [rbp-39h]
  __int64 profiler_data_ptr_2_1; // [rsp+68h] [rbp-31h]
  int profiler_event_type_2; // [rsp+90h] [rbp-9h] BYREF
  __int64 profiler_event_flags_2; // [rsp+94h] [rbp-5h]
  int profiler_event_level_2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 start_timestamp_2; // [rsp+A0h] [rbp+7h]
  unsigned __int64 end_timestamp_2; // [rsp+A8h] [rbp+Fh]
  __int64 profiler_data_ptr_1_2; // [rsp+B0h] [rbp+17h]
  __int64 profiler_data_ptr_2_2; // [rsp+B8h] [rbp+1Fh]

  if ( (rw_lock_state_2 & 0x200000) != 0 )
  {
    rw_lock_state = rw_lock_state_2;
    while ( 1 )
    {
      if ( (rw_lock_state & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)p_profiler_system + 0x128LL))(
          p_profiler_system,
          p_rw_lock_state);
      if ( (rw_lock_state & 0x100000) != 0 )
        break;
      new_lock_value = rw_lock_state | 0x100000;
      rw_lock_state_1 = _InterlockedCompareExchange64(
                          (volatile signed __int64 *)p_rw_lock_state,
                          rw_lock_state | 0x100000,
                          rw_lock_state);
      is_exchange_successful = rw_lock_state == rw_lock_state_1;
      rw_lock_state = rw_lock_state_1;
      if ( is_exchange_successful )
      {
        profiler_event_type_2 = 0x1600;
        profiler_event_flags_2 = 1;
        profiler_event_level_2 = 2;
        end_timestamp_2 = 0;
        profiler_data_ptr_1_2 = 0;
        profiler_data_ptr_2_2 = 0;
        start_timestamp_2 = __rdtsc();
        isProfileFunctionsInitialized(
          &profiler_event_type_2,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(profiler_event_type_2) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", lock_name);
        lock_owner_name_string_ptr_2 = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(p_rw_lock_state + 8) )
          lock_owner_name_string_ptr_2 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
        qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_2);
        qword_149B4B8B0("Caller: %s", caller_name);
        lock_state_val_2[0] = new_lock_value;
        qword_149B3B480(p_rw_lock_state, lock_state_val_2, 4, 0xFFFFFFFFLL);
        rw_lock_state = *(_QWORD *)p_rw_lock_state;
        p_profiler_event_type = &profiler_event_type_2;
        end_timestamp_2 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (rw_lock_state & 0x200000) == 0 )
        return result;
    }
    profiler_event_type_1 = 0x1600;
    profiler_event_flags_1 = 1;
    profiler_event_level_1 = 2;
    end_timestamp_1 = 0;
    profiler_data_ptr_1_1 = 0;
    profiler_data_ptr_2_1 = 0;
    start_timestamp_1 = __rdtsc();
    isProfileFunctionsInitialized(
      &profiler_event_type_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(profiler_event_type_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", lock_name);
    lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(p_rw_lock_state + 8) )
      lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
    qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
    qword_149B4B8B0("Caller: %s", caller_name);
    rw_lock_state_3 = rw_lock_state;
    qword_149B3B480(p_rw_lock_state, &rw_lock_state_3, 4, 0xFFFFFFFFLL);
    rw_lock_state = *(_QWORD *)p_rw_lock_state;
    p_profiler_event_type = &profiler_event_type_1;
    end_timestamp_1 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_profiler_event_type);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: rw_lock_acquire_read_lock_unprofiled (0x1403CB5B0) ---

// --- Function: rw_lock_handle_release_contention (0x1403CB820) ---
// Handles the release of a read-write lock when contention or specific lock flags
// are present. It continuously attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`. Depending on the resulting lock state, it may
// trigger further release operations (e.g., waking waiting threads via
// `qword_149B3B488`) or update thread context information related to lock
// ownership and counts.
__int64 __fastcall rw_lock_handle_release_contention(
        volatile signed __int64 *p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  unsigned __int64 new_lock_value; // rdx
  unsigned int lock_owner_thread_id; // r8d
  __int64 current_lock_value_1; // rax
  unsigned __int64 lock_thread_id_high_word; // rbx
  int thread_context_info_1; // [rsp+60h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+68h] [rbp+10h] BYREF
  __int64 thread_context_ptr_1; // [rsp+70h] [rbp+18h] BYREF
  __int64 thread_context_ptr_2; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value;
    if ( (current_lock_value & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
        p_profiler_system,
        &thread_context_ptr_1,
        &thread_context_info_1);
      new_lock_value = current_lock_value & 0xFFFFFFFFFFFFLL;
      lock_owner_thread_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_1 - 1)) << 9)
                                       + thread_context_ptr_1
                                       + 0x124);
      if ( lock_owner_thread_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)lock_owner_thread_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(p_rw_lock_state, new_lock_value, current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    if ( (current_lock_value_1 & 0x3FF) != 0
      || (current_lock_value_1 & 0x200000) != 0
      || (current_lock_value_1 & 0xFFFF0000FFC00000uLL) == 0 )
    {
      return current_lock_value_1;
    }
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0xFFC00000) != 0 )
    return qword_149B3B488(p_rw_lock_state);
  current_lock_value_1 = 0xFFFF000000000000uLL;
  if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
      p_profiler_system,
      &thread_context_ptr_2,
      &thread_context_info_2);
    lock_thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)lock_thread_id_high_word & (thread_context_info_2 - 1)) << 9)
              + thread_context_ptr_2
              + 0x11C) = (unsigned __int16)(lock_thread_id_high_word + thread_context_info_2);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xD8LL))(
             p_profiler_system,
             (unsigned int)lock_thread_id_high_word);
  }
  return current_lock_value_1;
}

// --- End Function: rw_lock_handle_release_contention (0x1403CB820) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
        p_profiler_system,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 0x10) & (unsigned int)(v9 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
      p_profiler_system,
      &v11,
      &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403E2E40 (0x1403E2E40) ---
__int64 __fastcall sub_1403E2E40(__int64 a1, __int64 a2)
{
  HMODULE hModule; // rax
  FARPROC ProcAddress; // rbx
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  ProcAddress = GetProcAddress(hModule, "___cigFetchNonWrapFunction___");
  if ( !ProcAddress )
  {
    hModule_1 = LoadLibraryA(0);
    if ( hModule_1 )
      ProcAddress = GetProcAddress(hModule_1, "___cigFetchNonWrapFunction___");
  }
  return ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a1, a2);
}

// --- End Function: sub_1403E2E40 (0x1403E2E40) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 thread_data_ptr; // rcx

  thread_data_ptr = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( thread_data_ptr )
    return *(_BYTE *)(thread_data_ptr + 0x42) != 0;
  else
    return *(_BYTE *)(get_thread_context_ptr() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10();
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DD10 (0x14056DD10) ---
// attributes: thunk
__int64 sub_14056DD10()
{
  return qword_149B4F990();
}

// --- End Function: sub_14056DD10 (0x14056DD10) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *stdioCommonVsprintfContext; // rax
  int formattedLength; // eax
  char errorMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, Format);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !gEnv || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    stdioCommonVsprintfContext = sub_1402A4380();
    formattedLength = _stdio_common_vsprintf(
                        *stdioCommonVsprintfContext | 2LL,
                        errorMessageBuffer,
                        0x1000u,
                        Format,
                        0,
                        args);
    if ( formattedLength < 0 )
      formattedLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedLength >= 0x1000 )
      errorMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      errorMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_146A1FC70 (0x146A1FC70) ---
__int64 __fastcall sub_146A1FC70(_QWORD *a1)
{
  int v2; // eax
  __int64 v3; // r8
  __int64 v4; // rdx
  __int64 v5; // r13
  __int64 v6; // r15
  signed __int64 v7; // rdx
  __int64 v8; // rsi
  unsigned __int64 i; // rbp
  __int64 v10; // rdi
  char v11; // r12
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rbx
  bool v17; // al
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // r13
  __int64 v19; // r12
  signed __int64 v20; // rbx
  __int64 v21; // rax
  unsigned __int64 v22; // rsi
  char *v23; // rbx
  __int64 v24; // rdi
  char v25; // bp
  char v26; // r15
  __int64 v27; // rbx
  int v28; // edi
  __int64 v29; // r8
  unsigned __int64 v30; // rax
  unsigned int n9; // eax
  int n0x242; // ecx
  unsigned int v33; // eax
  __int64 v34; // rdi
  int v35; // ecx
  unsigned __int64 n0x200000; // rax
  unsigned __int64 v38[9]; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int64 v39; // [rsp+80h] [rbp+8h] BYREF
  unsigned __int64 v40; // [rsp+90h] [rbp+18h] BYREF
  unsigned __int64 v41; // [rsp+98h] [rbp+20h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0x18LL))(p_profiler_system);
  v3 = v2;
  if ( v2 )
  {
    v4 = 0;
    do
    {
      v4 += 0x40;
      *(_DWORD *)(v4 + *(_QWORD *)(*a1 + 0x174070LL) - 0x40) = 0;
      *(_DWORD *)(*(_QWORD *)(*a1 + 0x174070LL) + v4 - 0x3C) = 0;
      --v3;
    }
    while ( v3 );
  }
  sub_146A405A0(*a1, *((unsigned int *)a1 + 4), v3);
  v5 = *a1;
  v6 = *a1 + 0xA0LL;
  if ( *(_DWORD *)(v6 + 0x10) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(v6 + 0x14);
  }
  else
  {
    v7 = _InterlockedIncrement64((volatile signed __int64 *)v6);
    if ( (v7 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        v6,
        v7,
        "CEntityComponentUpdateScheduler::ExecuteBackgroundDeferredActivateComponent",
        "m_arrBackgroundDeferredActivateComponentLock",
        1);
  }
  v39 = 0;
  v8 = sub_1403D7000(v5 + 0x30, &v39);
  for ( i = v39 >> 4; i; --i )
  {
    v10 = *(_QWORD *)v8;
    v11 = *(_BYTE *)(v8 + 8);
    if ( *(_QWORD *)v8 )
    {
      v12 = *(_QWORD *)(v10 + 8);
      v41 = v12;
      if ( v12 )
      {
        v13 = v12;
        v14 = HIWORD(v12);
        v15 = v13 & 0xFFFFFFFFFFFFLL;
        v16 = (v14 & 0xF000) != 0 ? v15 & 0xFFFFFF000000LL : v15 - 6;
        if ( *(_WORD *)(v16 + 2) == (v14 & 0xFFF) )
        {
          if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || (v17 = is_thread_privileged_or_bypass_mode()) )
            v17 = 1;
          if ( *(_WORD *)(v16 + 4) == 2 && v17 || validate_entity_descriptor_detailed_access(&v41) )
          {
            sub_146A24990(v5, v10, v11, 0);
            _InterlockedDecrement16((volatile signed __int16 *)(v10 + 0x22));
          }
        }
      }
    }
    v8 += 0x10;
  }
  rw_lock_release_read_lock(v6);
  sub_146A2EC80(*a1);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = *a1;
  v19 = *a1 + 0x1B0LL;
  if ( *(_DWORD *)(v19 + 0x10) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(v19 + 0x14);
  }
  else
  {
    v20 = _InterlockedIncrement64((volatile signed __int64 *)v19);
    if ( (v20 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        v19,
        v20,
        "CEntityComponentUpdateScheduler::ExecuteBackgroundDeferredComponentFrequencyUpdates",
        "m_arrBackgroundDeferredComponentFrequencyUpdateChangesLock",
        1);
  }
  v40 = 0;
  v21 = sub_1403D7000(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x140, &v40);
  v22 = v40 >> 4;
  if ( v40 >> 4 )
  {
    v23 = (char *)(v21 + 0xD);
    do
    {
      v24 = *(_QWORD *)(v23 + 0xFFFFFFF3);
      v25 = v23[0xFFFFFFFF];
      v26 = *v23;
      if ( v24 )
      {
        v38[0] = *(_QWORD *)(v24 + 8);
        if ( is_entity_descriptor_valid_or_accessible(v38) )
        {
          sub_146A42B10(p_p_p_p_p_p_p_p_p_p_p_p_Source, v24, v25, v26);
          _InterlockedDecrement16((volatile signed __int16 *)(v24 + 0x22));
        }
      }
      v23 += 0x10;
      --v22;
    }
    while ( v22 );
  }
  rw_lock_release_read_lock(v19);
  v27 = a1[1] + 8LL;
  v28 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(v27 + 0x10) == v28 )
  {
    ++*(_DWORD *)(v27 + 0x14);
  }
  else
  {
    v29 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    v30 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0x200000, 0);
    if ( v30 )
      sub_1403DCD60(
        v27,
        v30,
        v29,
        "CEntityComponentUpdateScheduler::QueueUpdateComponentPass::<lambda_1>::operator ()",
        "rPerPassState.bIsRunningLock",
        1);
    else
      *(_QWORD *)(v27 + 8) = v29;
    *(_DWORD *)(v27 + 0x10) = v28;
  }
  *(_BYTE *)(a1[1] + 1LL) = 1;
  sub_146A255F0(*a1);
  sub_146A367D0(*a1 + 0x174EF0LL, *(_QWORD *)(a1[1] + 0x440LL) >> 3);
  *(_QWORD *)(a1[1] + 0x470LL) = 0;
  n9 = *((_DWORD *)a1 + 4);
  if ( n9 <= 9 )
  {
    n0x242 = 0x242;
    if ( _bittest(&n0x242, n9) )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FBE8 + 0xD0LL))(qword_149B4FBE8);
  }
  v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0x18LL))(p_profiler_system);
  v34 = *(_QWORD *)(a1[1] + 0x440LL) >> 3;
  if ( v33 < (unsigned int)v34 )
    LODWORD(v34) = v33;
  if ( v27 )
  {
    v35 = *(_DWORD *)(v27 + 0x14);
    if ( v35 )
    {
      *(_DWORD *)(v27 + 0x14) = v35 - 1;
    }
    else
    {
      *(_DWORD *)(v27 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v27 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        rw_lock_handle_write_release_contention(v27, n0x200000);
    }
  }
  return (unsigned int)v34;
}

// --- End Function: sub_146A1FC70 (0x146A1FC70) ---

// --- Function: sub_146A24990 (0x146A24990) ---
double __fastcall sub_146A24990(__int64 a1, __int64 a2, char a3, char a4)
{
  __int64 v7; // r8
  unsigned __int64 v8; // rdx
  __int64 n0xE; // r12
  __int64 v10; // rbx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rcx
  __int64 v13; // rcx
  bool v14; // r15
  volatile signed __int64 *v15; // rdi
  signed __int64 v16; // rdx
  int n0xE_1; // ecx
  char v18; // si
  _OWORD *v19; // rax
  char v20; // si
  unsigned __int64 p_p_sub_146A26220[2]; // [rsp+30h] [rbp-69h] BYREF
  int n0x1000; // [rsp+40h] [rbp-59h] BYREF
  __int64 v24; // [rsp+44h] [rbp-55h]
  int v25; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v26; // [rsp+50h] [rbp-49h]
  unsigned __int64 v27; // [rsp+58h] [rbp-41h]
  __int64 v28; // [rsp+60h] [rbp-39h]
  __int64 v29; // [rsp+68h] [rbp-31h]
  __int128 v30; // [rsp+90h] [rbp-9h]
  __int128 v31; // [rsp+A0h] [rbp+7h] BYREF
  __int64 v32; // [rsp+B0h] [rbp+17h] BYREF
  char v33; // [rsp+B8h] [rbp+1Fh]
  __int64 v34; // [rsp+108h] [rbp+6Fh]

  n0x1000 = 0x1000;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v24 = 1;
  v26 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x1000,
    &word_1515B005C,
    "CEntityComponentUpdateScheduler::ActivateComponent",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0xF65);
  HIWORD(n0x1000) = word_1515B005C;
  p_p_sub_146A26220[0] = *(_QWORD *)(a2 + 8);
  if ( !is_entity_descriptor_valid_or_accessible(p_p_sub_146A26220) )
    goto LABEL_39;
  v7 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v8 = __popcnt(*(_QWORD *)(v7 + a1 + 0x42B8) & ((1LL << a3) - 1));
  n0xE = *(int *)(*(_QWORD *)(v7 + a1 + 0x4150) + 0x20 * v8 + 0xC);
  v10 = *(_QWORD *)(a2 + 0x18) + 0xC * v8;
  v11 = p_p_sub_146A26220[0];
  if ( p_p_sub_146A26220[0] )
  {
    v12 = (p_p_sub_146A26220[0] & 0xF000000000000000uLL) != 0
        ? p_p_sub_146A26220[0] & 0xFFFFFF000000LL
        : (p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v12 + 2) == (HIWORD(p_p_sub_146A26220[0]) & 0xFFF) )
    {
      if ( *(_WORD *)(v12 + 4) < 3u )
      {
LABEL_10:
        if ( (v11 & 0xFFFFFFFFFFFFLL) != 0 )
        {
          v13 = (v11 & 0xF000000000000000uLL) != 0 ? v11 & 0xFFFFFF000000LL : (v11 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v13 + 4) == 1 )
          {
            _InterlockedOr8((volatile signed __int8 *)(v10 + 0xB), 2u);
            goto LABEL_39;
          }
        }
        goto LABEL_16;
      }
      if ( check_thread_state_and_value_not_equal((_QWORD *)(p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL)) )
      {
        v11 = p_p_sub_146A26220[0];
        goto LABEL_10;
      }
    }
  }
LABEL_16:
  v14 = !is_thread_privileged_or_bypass_mode() && !*(_BYTE *)(get_thread_context_ptr() + 0x12D);
  v34 = a1 + 0x478 * n0xE;
  v15 = (volatile signed __int64 *)(v34 + 0x1D0);
  if ( *(_DWORD *)(v34 + 0x1E0) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(v34 + 0x1E4);
  }
  else
  {
    v16 = _InterlockedIncrement64(v15);
    if ( (v16 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        (__int64)v15,
        v16,
        "CEntityComponentUpdateScheduler::ActivateComponent",
        "m_perPassState[nPass].bIsRunningLock",
        1);
  }
  if ( a4
    || v14
    || (n0xE_1 = *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x920LL),
        n0xE_1 == 0x10)
    || n0xE_1 != (_DWORD)n0xE && *(_BYTE *)(v34 + 0x1C9) )
  {
    v33 = a3;
    v32 = a2;
    _InterlockedIncrement16((volatile signed __int16 *)(a2 + 0x22));
    sub_1403CA640(a1 + 0x30, &v32, 0x10u);
  }
  else if ( !*(_BYTE *)(v10 + 9) )
  {
    if ( n0xE_1 == (_DWORD)n0xE )
    {
      if ( !*(_BYTE *)(v10 + 0xA) )
      {
        v18 = *(_BYTE *)(v10 + 0xA);
        *(_BYTE *)(v10 + 0xA) = 1;
        if ( !v18 )
        {
          *(_QWORD *)&v30 = a2;
          BYTE8(v30) = a3;
          v19 = (_OWORD *)sub_1403CA4D0(a1 + 0x174970, 0x10u, 0);
          *v19 = v30;
        }
      }
    }
    else
    {
      v20 = *(_BYTE *)(v10 + 9);
      *(_BYTE *)(v10 + 9) = 1;
      if ( !v20 )
      {
        *(_BYTE *)(v10 + 7) = 0;
        *(_QWORD *)&v31 = a2;
        BYTE8(v31) = a3;
        if ( sub_146A4A420(
               (volatile signed __int64 *)((p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL) + 0x18 * (n0xE + 0x25)),
               &v31,
               0) )
        {
          sub_146A24D00(a1, p_p_sub_146A26220, (unsigned int)n0xE, 0);
        }
      }
    }
  }
  rw_lock_release_read_lock((__int64)v15);
LABEL_39:
  v27 = __rdtsc();
  return qword_149B4B878(&n0x1000);
}

// --- End Function: sub_146A24990 (0x146A24990) ---

// --- Function: sub_146A24D00 (0x146A24D00) ---
void __fastcall sub_146A24D00(__int64 a1, unsigned __int64 *p_p_sub_146A26220, unsigned __int64 n0xE, char a4)
{
  __int64 n0xE_1; // r12
  __int64 v8; // r15
  unsigned __int64 v9; // rsi
  __int64 v10; // rax
  unsigned __int64 v11; // rbx
  __int64 v12; // rax
  bool v13; // al
  volatile signed __int64 *v14; // rbx
  signed __int64 v15; // rdx
  unsigned __int64 current_lock_value; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v19; // [rsp+78h] [rbp+10h] BYREF

  n0xE_1 = (int)n0xE;
  v8 = 0x18LL * (int)n0xE;
  while ( 1 )
  {
    v9 = *p_p_sub_146A26220 & 0xFFFFFFFFFFFFLL;
    v10 = is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(v9 + 0x4C8))
        ? *(_QWORD *)(v9 + 0x4C8) & 0xFFFFFFFFFFFFLL
        : 0LL;
    if ( v9 == v10 )
      break;
    v11 = *p_p_sub_146A26220 & 0xFFFFFFFFFFFFLL;
    if ( !is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(v11 + 0x4C0))
      || (v12 = *(_QWORD *)(v11 + 0x4C0) & 0xFFFFFFFFFFFFLL, *(_BYTE *)(v12 + 0xD) >= 5u) )
    {
      v14 = (volatile signed __int64 *)(a1 + 0x1749C0);
      if ( !a4 )
      {
        v15 = _InterlockedIncrement64(v14);
        if ( (v15 & 0x200000) != 0 )
          rw_lock_acquire_read_lock_dispatch(
            a1 + 0x1749C0,
            v15,
            "CEntityComponentUpdateScheduler::ActivateComponent_AddToHierarchy_Recursive",
            "m_arDeferredECUSGroupsHierarchyUpdateLock",
            1);
        current_lock_value = _InterlockedDecrement64(v14);
        if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
          rw_lock_handle_release_contention((volatile signed __int64 *)(a1 + 0x1749C0), current_lock_value);
      }
      return;
    }
    if ( *(_DWORD *)(v8 + v9 + 0x374) != 0xFFFFFFFF )
      return;
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(v8 + v9 + 0x374), 0xFFFFFFFE, 0xFFFFFFFF) != 0xFFFFFFFF )
      return;
    v18 = 0xFFFFFFFFFFFFFFFFuLL;
    v13 = sub_146A4A620((volatile signed __int64 *)(v8 + v12 + 0x380), p_p_sub_146A26220, &v18);
    _InterlockedExchange((volatile __int32 *)(v8 + v9 + 0x374), v18);
    if ( !v13 )
      return;
    p_p_sub_146A26220 = (unsigned __int64 *)(v11 + 0x4C0);
  }
  if ( *(_DWORD *)(v8 + v9 + 0x370) == 0xFFFFFFFF
    && _InterlockedCompareExchange((volatile signed __int32 *)(v8 + v9 + 0x370), 0xFFFFFFFE, 0xFFFFFFFF) == 0xFFFFFFFF )
  {
    v19 = 0xFFFFFFFFFFFFFFFFuLL;
    v17 = (_QWORD *)sub_1403CA4D0(a1 + 0x478 * n0xE_1 + 0x5E8, 8u, (signed __int64 *)&v19);
    v19 >>= 3;
    *v17 = *p_p_sub_146A26220;
    _InterlockedExchange((volatile __int32 *)(v8 + v9 + 0x370), v19);
  }
}

// --- End Function: sub_146A24D00 (0x146A24D00) ---

// --- Function: sub_146A2E150 (0x146A2E150) ---
void __fastcall sub_146A2E150(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rbx
  int v5; // r12d
  __int64 v7; // r13
  unsigned __int64 v8; // rsi
  __int64 v9; // rdx
  unsigned __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  bool v13; // al
  unsigned __int64 v14; // rdx
  __int64 pEngineComponentScheduler; // rsi
  const char *v16; // r14
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rsi
  __int64 v18; // rcx
  const char *v19; // rax
  unsigned __int64 v20; // [rsp+80h] [rbp+8h] BYREF
  __int64 v21; // [rsp+88h] [rbp+10h]

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v5 = a3;
  v7 = p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0 * v3;
  v21 = (1LL << a3) - 1;
  v8 = __popcnt(*(_QWORD *)(v7 + 0x42B8) & v21);
  v9 = *(_QWORD *)(v7 + 0x4150) + 0x20 * v8;
  switch ( *(_WORD *)(v9 + 8) )
  {
    case 2:
    case 5:
    case 6:
    case 9:
    case 0xA:
    case 0xC:
    case 0xF:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
      v10 = *(_QWORD *)(a2 + 8);
      v20 = v10;
      if ( !v10 )
        goto LABEL_16;
      v11 = (v10 & 0xF000000000000000uLL) != 0 ? v10 & 0xFFFFFF000000LL : (v10 & 0xFFFFFFFFFFFFLL) - 6;
      if ( *(_WORD *)(v11 + 2) != (HIWORD(v10) & 0xFFF) )
        goto LABEL_16;
      if ( *(_WORD *)(v11 + 4) < 3u )
        goto LABEL_10;
      if ( check_thread_state_and_value_not_equal((_QWORD *)(v10 & 0xFFFFFFFFFFFFLL)) )
      {
        v10 = v20;
LABEL_10:
        if ( (v10 & 0xFFFFFFFFFFFFLL) != 0 )
        {
          v12 = (v10 & 0xF000000000000000uLL) != 0 ? v10 & 0xFFFFFF000000LL : (v10 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v12 + 4) == 1 )
          {
            _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a2 + 0x18) + 0xC * v8 + 0xB), 1u);
            return;
          }
        }
      }
LABEL_16:
      *(_BYTE *)(*(_QWORD *)(a2 + 0x18) + 0xC * v8) = 1;
      v13 = is_entity_descriptor_valid_or_accessible(&v20);
      v14 = v20 & 0xFFFFFFFFFFFFLL;
      if ( !v13 )
        v14 = 0;
      if ( sub_146A38570(p_p_p_p_p_p_p_p_p_p_p_p_Source, v14, a2, v7 + 0x4058, __popcnt(*(_QWORD *)(v7 + 0x42B8) & v21)) )
        sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a2, v5, 0);
      return;
    default:
      pEngineComponentScheduler = ::pEngineComponentScheduler;
      v16 = sub_1403AC700(*(_DWORD *)(v9 + 0xC));
      if ( (_WORD)v3 == 0xFFFF )
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const char **)(*(_QWORD *)(pEngineComponentScheduler + 0x38) + 8 * v3);
      if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a2 + 8)) )
        v18 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v18 = 0;
      v19 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x70LL))(v18);
      sub_1405C0E00(
        6u,
        2u,
        "EnableComponentUpdate called Component %s.%s for Pass %s (Id %d) which is not set to use the Manual update policy",
        v19,
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
        v16,
        v5);
      return;
  }
}

// --- End Function: sub_146A2E150 (0x146A2E150) ---

// --- Function: sub_146A2EC80 (0x146A2EC80) ---
void __fastcall sub_146A2EC80(__int64 a1)
{
  __int64 v1; // rbp
  int v3; // ebx
  __int64 v4; // r8
  unsigned __int64 v5; // rax
  __int64 v6; // rcx
  unsigned __int64 v7; // r12
  __int64 v8; // r14
  __int64 v9; // r15
  char v10; // r13
  _QWORD *v11; // rsi
  signed __int64 v12; // rdi
  __int64 v13; // rax
  _DWORD *v14; // rbx
  unsigned __int32 n0x40; // ecx
  __int64 v16; // rax
  int v17; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v19; // [rsp+30h] [rbp-58h]
  int v21; // [rsp+98h] [rbp+10h]
  unsigned __int64 v22; // [rsp+A0h] [rbp+18h] BYREF
  unsigned __int64 v23; // [rsp+A8h] [rbp+20h] BYREF

  v1 = a1 + 0x128;
  v19 = a1 + 0x128;
  v3 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(v1 + 0x10) == v3 )
  {
    ++*(_DWORD *)(v1 + 0x14);
  }
  else
  {
    v4 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)v1, 0x200000, 0);
    if ( v5 )
      sub_1403DCD60(
        v1,
        v5,
        v4,
        "CEntityComponentUpdateScheduler::ExecuteBackgroundDeferredQueueComponentEvents",
        "m_arrBackgroundDeferredQueueComponentEventsLock",
        1);
    else
      *(_QWORD *)(v1 + 8) = v4;
    *(_DWORD *)(v1 + 0x10) = v3;
  }
  v22 = 0;
  v6 = sub_1403D7000(a1 + 0xB8, &v22);
  v7 = v22 / 0x18;
  if ( v22 / 0x18 )
  {
    v8 = v6 + 8;
    do
    {
      v9 = *(_QWORD *)(v8 - 8);
      v10 = *(_BYTE *)(v8 + 8);
      v11 = *(_QWORD **)v8;
      v21 = *(_DWORD *)(v8 + 0xC);
      if ( v9 )
      {
        v23 = *(_QWORD *)(v9 + 8);
        if ( is_entity_descriptor_valid_or_accessible(&v23) )
        {
          while ( 1 )
          {
            v12 = v11[1];
            if ( v12 )
            {
              n0x40 = _InterlockedExchangeAdd((volatile signed __int32 *)(v12 + 8), 1u);
              if ( n0x40 < 0x40 )
              {
                *(_DWORD *)(v12 + 4LL * n0x40 + 0xC) = v21;
                *(_BYTE *)(*(_QWORD *)(v9 + 0x18)
                         + 0xC
                         * __popcnt(((1LL << v10) - 1) & *(_QWORD *)(0x2E0LL * *(unsigned __int16 *)(v9 + 0x10)
                                                                   + a1
                                                                   + 0x42B8))
                         + 1) = 1;
                sub_146A24990(a1, v9, v10, 0);
                _InterlockedDecrement16((volatile signed __int16 *)(v9 + 0x22));
                break;
              }
              if ( *(_QWORD *)v12 )
              {
                _InterlockedCompareExchange64(v11 + 1, *(_QWORD *)v12, v12);
              }
              else
              {
                v16 = allocWithProfilerInfo_Wrapper(0x110u);
                v14 = (_DWORD *)v16;
                if ( v16 )
                {
                  memset((void *)(v16 + 0xC), 0, 0x104u);
                  *(_QWORD *)v14 = 0;
                  v14[2] = 0;
                }
                else
                {
                  v14 = 0;
                }
                if ( v12 == _InterlockedCompareExchange64(v11 + 1, (signed __int64)v14, v12) )
                  *(_QWORD *)v12 = v14;
                else
LABEL_16:
                  sub_1402A3D30(v14);
              }
            }
            else
            {
              v13 = allocWithProfilerInfo_Wrapper(0x110u);
              v14 = (_DWORD *)v13;
              if ( v13 )
              {
                memset((void *)(v13 + 0xC), 0, 0x104u);
                *(_QWORD *)v14 = 0;
                v14[2] = 0;
              }
              else
              {
                v14 = 0;
              }
              if ( _InterlockedCompareExchange64(v11 + 1, (signed __int64)v14, 0) )
                goto LABEL_16;
              *v11 = v14;
            }
          }
        }
      }
      v8 += 0x18;
      --v7;
    }
    while ( v7 );
    v1 = v19;
  }
  if ( v1 )
  {
    v17 = *(_DWORD *)(v1 + 0x14);
    if ( v17 )
    {
      *(_DWORD *)(v1 + 0x14) = v17 - 1;
    }
    else
    {
      *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v1, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        rw_lock_handle_write_release_contention(v1, n0x200000);
    }
  }
}

// --- End Function: sub_146A2EC80 (0x146A2EC80) ---

// --- Function: sub_146A2F490 (0x146A2F490) ---
void __fastcall sub_146A2F490(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rdi
  __int64 v5; // r13
  volatile signed __int64 *v7; // rbx
  int v8; // ebp
  __int64 v9; // r8
  unsigned __int64 v10; // rax
  int v11; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v13; // r14
  __int64 v14; // r15
  __int64 v15; // rcx
  __int64 v16; // rbx
  char v17; // bp
  int v18; // ecx
  int v19; // ecx
  bool v20; // al
  unsigned __int64 v21; // [rsp+70h] [rbp+8h]
  __int64 v22; // [rsp+78h] [rbp+10h]

  v22 = a2;
  v3 = 0;
  v5 = 0x2E0LL * *(unsigned __int16 *)(a3 + 0x10) + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x4058;
  if ( *(_QWORD *)(v5 + 0x38) )
  {
    v7 = (volatile signed __int64 *)(v5 + 0x10);
    v8 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
    if ( *(_DWORD *)(v5 + 0x20) == v8 )
    {
      ++*(_DWORD *)(v5 + 0x24);
    }
    else
    {
      v9 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      v10 = _InterlockedCompareExchange64(v7, 0x200000, 0);
      if ( v10 )
        sub_1403DCD60(v5 + 0x10, v10, v9, "CEntityComponentUpdateScheduler::FinalizeComponent", "pAllocator->lock", 1);
      else
        *(_QWORD *)(v5 + 0x18) = v9;
      *(_DWORD *)(v5 + 0x20) = v8;
    }
    sub_146A41B00(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, v5);
    if ( v5 != 0xFFFFFFFFFFFFFFF0uLL )
    {
      v11 = *(_DWORD *)(v5 + 0x24);
      if ( v11 )
      {
        *(_DWORD *)(v5 + 0x24) = v11 - 1;
      }
      else
      {
        *(_DWORD *)(v5 + 0x20) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64(v7, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
          *(_QWORD *)(v5 + 0x18) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        else
          rw_lock_handle_write_release_contention(v5 + 0x10, n0x200000);
      }
    }
    a2 = v22;
  }
  v21 = *(_QWORD *)(v5 + 0x270) - *(_QWORD *)(v5 + 0x268);
  if ( v21 )
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = *(_QWORD *)(v5 + 0xF8);
      v16 = *(_QWORD *)(a3 + 0x18);
      v17 = *(_BYTE *)(v3 + *(_QWORD *)(v5 + 0x268));
      if ( *(_WORD *)(v15 + v14 + 8) == 1 )
      {
        v18 = *(unsigned __int8 *)(v15 + v14 + 0x11);
        if ( !v18 )
          goto LABEL_24;
        v19 = v18 - 1;
        if ( v19 )
        {
          if ( v19 != 1 )
            goto LABEL_25;
          v20 = !sub_140418C10(a2);
        }
        else
        {
          v20 = sub_140418C10(a2);
        }
        if ( v20 )
LABEL_24:
          sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, v17, 0);
      }
LABEL_25:
      if ( (*(_BYTE *)(v16 + v13 + 0xB) & 2) != 0 )
        sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, v17, 0);
      if ( (*(_BYTE *)(v16 + v13 + 0xB) & 1) != 0 )
        sub_146A2E150(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, v17);
      a2 = v22;
      ++v3;
      *(_BYTE *)(v16 + v13 + 0xB) = 0;
      v14 += 0x20;
      v13 += 0xC;
    }
    while ( v3 < v21 );
  }
}

// --- End Function: sub_146A2F490 (0x146A2F490) ---

// --- Function: sub_146A2FF70 (0x146A2FF70) ---
void __fastcall sub_146A2FF70(__int64 a1, __int64 a2, char a3)
{
  __int64 v4; // r12
  __int64 v5; // r10
  unsigned __int64 v6; // rbx
  _QWORD *v7; // rsi
  unsigned __int64 v8; // r13
  __int64 v9; // rdi
  __int64 v10; // r14
  char v11; // bp
  char v12; // al

  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a2 + 8)) )
  {
    v4 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFLL;
    if ( v4 )
    {
      if ( *(_BYTE *)((*(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
      {
        v5 = a1;
        v6 = 0;
        v7 = (_QWORD *)(0x2E0LL * *(unsigned __int16 *)(a2 + 0x10) + a1 + 0x4058);
        v8 = v7[0x4E] - v7[0x4D];
        if ( v8 )
        {
          v9 = 0;
          v10 = 0;
          do
          {
            v11 = *(_BYTE *)(v6 + v7[0x4D]);
            if ( *(_QWORD *)(v9 + v7[0x1F]) )
            {
              v12 = 0xFF;
              if ( a3 )
                v12 = 1;
              *(_BYTE *)(*(_QWORD *)(a2 + 0x18) + v10 + 3) += v12;
              if ( sub_146A38570(v5, v4, a2, (__int64)v7, __popcnt(v7[0x4C] & ((1LL << v11) - 1))) )
                sub_146A24990(a1, a2, v11, 0);
              v5 = a1;
            }
            ++v6;
            v9 += 0x20;
            v10 += 0xC;
          }
          while ( v6 < v8 );
        }
      }
    }
  }
}

// --- End Function: sub_146A2FF70 (0x146A2FF70) ---

// --- Function: sub_146A300D0 (0x146A300D0) ---
void __fastcall sub_146A300D0(__int64 a1, __int64 a2, char a3)
{
  unsigned __int64 v5; // rbx
  _QWORD *v6; // r14
  unsigned __int64 v7; // r12
  __int64 v8; // rdi
  __int64 v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // rdx
  char v12; // r15
  char v13; // al
  bool v14; // al
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // [rsp+78h] [rbp+10h] BYREF
  char v17; // [rsp+80h] [rbp+18h]

  v17 = a3;
  v16 = *(_QWORD *)(a2 + 8);
  if ( is_entity_descriptor_valid_or_accessible(&v16)
    && (v16 & 0xFFFFFFFFFFFFLL) != 0
    && *(_BYTE *)((v16 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
  {
    v5 = 0;
    v6 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10) + 0x4058);
    v7 = v6[0x4E] - v6[0x4D];
    if ( v7 )
    {
      v8 = 0;
      v9 = 0;
      do
      {
        v10 = v6[0x1F];
        v11 = *(_QWORD *)(a2 + 0x18);
        v12 = *(_BYTE *)(v5 + v6[0x4D]);
        if ( *(_QWORD *)(v10 + v9) )
        {
          switch ( *(_WORD *)(v10 + v9 + 8) )
          {
            case 3:
            case 4:
            case 7:
            case 8:
            case 0xB:
            case 0xD:
            case 0xE:
            case 0x11:
            case 0x12:
            case 0x15:
              goto LABEL_9;
            case 5:
            case 6:
            case 9:
            case 0xA:
            case 0xC:
            case 0xF:
            case 0x10:
            case 0x13:
            case 0x14:
            case 0x16:
              if ( *(_BYTE *)(v11 + v8) )
              {
LABEL_9:
                v13 = 0xFF;
                if ( v17 )
                  v13 = 1;
                *(_BYTE *)(v11 + v8 + 2) += v13;
              }
              break;
            default:
              break;
          }
          v14 = is_entity_descriptor_valid_or_accessible(&v16);
          v15 = v16 & 0xFFFFFFFFFFFFLL;
          if ( !v14 )
            v15 = 0;
          if ( sub_146A38570(a1, v15, a2, (__int64)v6, __popcnt(v6[0x4C] & ((1LL << v12) - 1))) )
            sub_146A24990(a1, a2, v12, 0);
        }
        ++v5;
        v9 += 0x20;
        v8 += 0xC;
      }
      while ( v5 < v7 );
    }
  }
}

// --- End Function: sub_146A300D0 (0x146A300D0) ---

// --- Function: sub_146A3A330 (0x146A3A330) ---
void __fastcall sub_146A3A330(
        __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
        __int64 a2,
        unsigned __int64 a3,
        int a4,
        int a5,
        char a6)
{
  unsigned __int64 v6; // r14
  char v7; // r15
  unsigned __int64 v8; // r12
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbp
  __int64 __Val_0__; // r13
  bool v11; // al
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdi
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_2; // r10
  _QWORD *v15; // r12
  __int64 v16; // rsi
  __int64 v17; // r14
  __int64 v18; // rbx
  __int64 v19; // rbp
  char v20; // r15
  bool v21; // al
  int v22; // eax
  __int16 n4; // ax
  bool v24; // al
  unsigned __int64 v25; // rbx
  __int64 v26; // rdi
  __int64 v27; // rbx
  int v28; // esi
  __int64 v29; // r8
  unsigned __int64 v30; // rax
  int v31; // eax
  unsigned __int64 n0x200000; // rax
  unsigned __int64 v33; // [rsp+30h] [rbp-68h] BYREF
  __int64 v34; // [rsp+38h] [rbp-60h] BYREF
  __int64 v35; // [rsp+40h] [rbp-58h]
  unsigned __int64 v36; // [rsp+48h] [rbp-50h]
  __int64 v38; // [rsp+A8h] [rbp+10h]

  if ( !a3 )
    return;
  v38 = a2;
  v6 = 0;
  v35 = 0;
  v7 = a4;
  v8 = a3;
  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
  do
  {
    __Val_0__ = *(_QWORD *)(a2 + 8 * v6);
    v33 = *(_QWORD *)(__Val_0__ + 8);
    v11 = is_entity_descriptor_valid_or_accessible(&v33);
    v12 = v33 & 0xFFFFFFFFFFFFLL;
    if ( !v11 )
      v12 = 0;
    v34 = v12;
    if ( !is_entity_descriptor_valid_or_accessible(&v33) || *(_BYTE *)((v33 & 0xFFFFFFFFFFFFLL) + 0xD) >= 5u )
      goto LABEL_26;
    v13 = 0;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    v15 = (_QWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source_1 + 0x2E0LL * *(unsigned __int16 *)(__Val_0__ + 0x10));
    v36 = v15[0x859] - v15[0x858];
    if ( !v36 )
      goto LABEL_25;
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = v17 + v15[0x82A];
      v19 = *(_QWORD *)(__Val_0__ + 0x18);
      v20 = *(_BYTE *)(v13 + v15[0x858]);
      if ( !*(_QWORD *)v18 )
        goto LABEL_23;
      switch ( *(_BYTE *)(v18 + 0x11) )
      {
        case 0:
          goto LABEL_17;
        case 1:
          v21 = sub_140418C10(v34);
          break;
        case 2:
          v21 = !sub_140418C10(v34);
          break;
        default:
          goto LABEL_23;
      }
      if ( v21 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
LABEL_17:
        v22 = 1 << *(_BYTE *)(v18 + 0xA);
        if ( (v22 & a4) != 0 && (v22 & a5) == 0 )
        {
          n4 = *(_WORD *)(v18 + 8);
          if ( n4 == 4 || n4 == 6 && *(_BYTE *)(v19 + v16) )
            sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source_2, __Val_0__, v20, a6);
        }
      }
LABEL_23:
      p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
      ++v13;
      v17 += 0x20;
      v16 += 0xC;
    }
    while ( v13 < v36 );
    v6 = v35;
    v7 = a4;
LABEL_25:
    v8 = a3;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
LABEL_26:
    v34 = *(_QWORD *)(__Val_0__ + 8);
    v24 = is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v34);
    v25 = v34 & 0xFFFFFFFFFFFFLL;
    if ( !v24 )
      v25 = 0;
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v34) && *(_BYTE *)(v25 + 0xD) < 5u )
    {
      v26 = 0x2E0LL * *(unsigned __int16 *)(__Val_0__ + 0x10);
      v27 = p_p_p_p_p_p_p_p_p_p_p_p_Source + v26 + 0x4068;
      v28 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
      if ( *(_DWORD *)(v27 + 0x10) == v28 )
      {
        ++*(_DWORD *)(v27 + 0x14);
      }
      else
      {
        v29 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
        v30 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0x200000, 0);
        if ( v30 )
          sub_1403DCD60(v27, v30, v29, "CEntityComponentUpdateScheduler::ActivateDebugUpdatesIf", "pAllocator->lock", 1);
        else
          *(_QWORD *)(v27 + 8) = v29;
        *(_DWORD *)(v27 + 0x10) = v28;
      }
      if ( (v7 & 2) != 0 && (a5 & 2) == 0 && *(_WORD *)(v26 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x4098) == 1 )
        sub_146A24F10(
          p_p_p_p_p_p_p_p_p_p_p_p_Source,
          (const vraudio::AudioBuffer *)__Val_0__,
          v26 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x4058);
      if ( v27 )
      {
        v31 = *(_DWORD *)(v27 + 0x14);
        if ( v31 )
        {
          *(_DWORD *)(v27 + 0x14) = v31 - 1;
        }
        else
        {
          *(_DWORD *)(v27 + 0x10) = 0xFFFFFFFF;
          n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0, 0x200000);
          if ( n0x200000 == 0x200000 )
            *(_QWORD *)(v27 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
          else
            rw_lock_handle_write_release_contention(v27, n0x200000);
        }
      }
    }
    a2 = v38;
    v35 = ++v6;
  }
  while ( v6 < v8 );
}

// --- End Function: sub_146A3A330 (0x146A3A330) ---

// --- Function: sub_146A3A670 (0x146A3A670) ---
void __fastcall sub_146A3A670(
        __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
        __int64 a2,
        unsigned __int64 a3,
        int a4,
        int a5,
        char a6)
{
  unsigned __int64 v6; // r14
  char v7; // r15
  unsigned __int64 v8; // r12
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbp
  __int64 __Val_0__; // r13
  bool v11; // al
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdi
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_2; // r10
  _QWORD *v15; // r12
  __int64 v16; // rsi
  __int64 v17; // r14
  __int64 v18; // rbx
  __int64 v19; // rbp
  char v20; // r15
  bool v21; // al
  int v22; // eax
  __int16 n0xE; // ax
  bool v24; // al
  unsigned __int64 v25; // rbx
  __int64 v26; // rdi
  __int64 v27; // rbx
  int v28; // esi
  __int64 v29; // r8
  unsigned __int64 v30; // rax
  int v31; // eax
  unsigned __int64 n0x200000; // rax
  unsigned __int64 v33; // [rsp+30h] [rbp-68h] BYREF
  __int64 v34; // [rsp+38h] [rbp-60h] BYREF
  __int64 v35; // [rsp+40h] [rbp-58h]
  unsigned __int64 v36; // [rsp+48h] [rbp-50h]
  __int64 v38; // [rsp+A8h] [rbp+10h]

  if ( !a3 )
    return;
  v38 = a2;
  v6 = 0;
  v35 = 0;
  v7 = a4;
  v8 = a3;
  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
  do
  {
    __Val_0__ = *(_QWORD *)(a2 + 8 * v6);
    v33 = *(_QWORD *)(__Val_0__ + 8);
    v11 = is_entity_descriptor_valid_or_accessible(&v33);
    v12 = v33 & 0xFFFFFFFFFFFFLL;
    if ( !v11 )
      v12 = 0;
    v34 = v12;
    if ( !is_entity_descriptor_valid_or_accessible(&v33) || *(_BYTE *)((v33 & 0xFFFFFFFFFFFFLL) + 0xD) >= 5u )
      goto LABEL_26;
    v13 = 0;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    v15 = (_QWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source_1 + 0x2E0LL * *(unsigned __int16 *)(__Val_0__ + 0x10));
    v36 = v15[0x859] - v15[0x858];
    if ( !v36 )
      goto LABEL_25;
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = v17 + v15[0x82A];
      v19 = *(_QWORD *)(__Val_0__ + 0x18);
      v20 = *(_BYTE *)(v13 + v15[0x858]);
      if ( !*(_QWORD *)v18 )
        goto LABEL_23;
      switch ( *(_BYTE *)(v18 + 0x11) )
      {
        case 0:
          goto LABEL_17;
        case 1:
          v21 = sub_140418C10(v34);
          break;
        case 2:
          v21 = !sub_140418C10(v34);
          break;
        default:
          goto LABEL_23;
      }
      if ( v21 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
LABEL_17:
        v22 = 1 << *(_BYTE *)(v18 + 0xA);
        if ( (v22 & a4) != 0 && (v22 & a5) == 0 )
        {
          n0xE = *(_WORD *)(v18 + 8);
          if ( n0xE == 0xE || n0xE == 0x10 && *(_BYTE *)(v19 + v16) )
            sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source_2, __Val_0__, v20, a6);
        }
      }
LABEL_23:
      p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
      ++v13;
      v17 += 0x20;
      v16 += 0xC;
    }
    while ( v13 < v36 );
    v6 = v35;
    v7 = a4;
LABEL_25:
    v8 = a3;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
LABEL_26:
    v34 = *(_QWORD *)(__Val_0__ + 8);
    v24 = is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v34);
    v25 = v34 & 0xFFFFFFFFFFFFLL;
    if ( !v24 )
      v25 = 0;
    if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v34) && *(_BYTE *)(v25 + 0xD) < 5u )
    {
      v26 = 0x2E0LL * *(unsigned __int16 *)(__Val_0__ + 0x10);
      v27 = p_p_p_p_p_p_p_p_p_p_p_p_Source + v26 + 0x4068;
      v28 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
      if ( *(_DWORD *)(v27 + 0x10) == v28 )
      {
        ++*(_DWORD *)(v27 + 0x14);
      }
      else
      {
        v29 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
        v30 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0x200000, 0);
        if ( v30 )
          sub_1403DCD60(v27, v30, v29, "CEntityComponentUpdateScheduler::ActivateDebugUpdatesIf", "pAllocator->lock", 1);
        else
          *(_QWORD *)(v27 + 8) = v29;
        *(_DWORD *)(v27 + 0x10) = v28;
      }
      if ( (v7 & 2) != 0 && (a5 & 2) == 0 && *(_WORD *)(v26 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x4098) == 2 )
        sub_146A24F10(
          p_p_p_p_p_p_p_p_p_p_p_p_Source,
          (const vraudio::AudioBuffer *)__Val_0__,
          v26 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x4058);
      if ( v27 )
      {
        v31 = *(_DWORD *)(v27 + 0x14);
        if ( v31 )
        {
          *(_DWORD *)(v27 + 0x14) = v31 - 1;
        }
        else
        {
          *(_DWORD *)(v27 + 0x10) = 0xFFFFFFFF;
          n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v27, 0, 0x200000);
          if ( n0x200000 == 0x200000 )
            *(_QWORD *)(v27 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
          else
            rw_lock_handle_write_release_contention(v27, n0x200000);
        }
      }
    }
    a2 = v38;
    v35 = ++v6;
  }
  while ( v6 < v8 );
}

// --- End Function: sub_146A3A670 (0x146A3A670) ---

// --- Function: sub_146A3A9B0 (0x146A3A9B0) ---
void __fastcall sub_146A3A9B0(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, int a5, char a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // r15
  bool v8; // al
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdi
  __int64 v11; // r10
  _QWORD *v12; // r13
  __int64 v13; // rsi
  __int64 v14; // r14
  __int64 v15; // rbx
  __int64 v16; // rbp
  char v17; // r12
  bool v18; // al
  int v19; // eax
  __int16 n3; // ax
  unsigned __int64 v21; // [rsp+20h] [rbp-68h] BYREF
  unsigned __int64 v22; // [rsp+28h] [rbp-60h]
  unsigned __int64 v23; // [rsp+30h] [rbp-58h]
  unsigned __int64 v24; // [rsp+38h] [rbp-50h]
  __int64 v26; // [rsp+98h] [rbp+10h]

  if ( a3 )
  {
    v26 = a2;
    v6 = 0;
    v23 = 0;
    while ( 1 )
    {
      v7 = *(_QWORD *)(a2 + 8 * v6);
      v21 = *(_QWORD *)(v7 + 8);
      v8 = is_entity_descriptor_valid_or_accessible(&v21);
      v9 = v21 & 0xFFFFFFFFFFFFLL;
      if ( !v8 )
        v9 = 0;
      v22 = v9;
      if ( is_entity_descriptor_valid_or_accessible(&v21) && *(_BYTE *)((v21 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
      {
        v10 = 0;
        v11 = a1;
        v12 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(v7 + 0x10));
        v24 = v12[0x859] - v12[0x858];
        if ( v24 )
          break;
      }
LABEL_24:
      a2 = v26;
      v6 = v23 + 1;
      v23 = v6;
      if ( v6 >= a3 )
        return;
    }
    v13 = 0;
    v14 = 0;
    while ( 1 )
    {
      v15 = v14 + v12[0x82A];
      v16 = *(_QWORD *)(v7 + 0x18);
      v17 = *(_BYTE *)(v10 + v12[0x858]);
      if ( *(_QWORD *)v15 )
      {
        switch ( *(_BYTE *)(v15 + 0x11) )
        {
          case 0:
            goto LABEL_17;
          case 1:
            v18 = sub_140418C10(v22);
            break;
          case 2:
            v18 = !sub_140418C10(v22);
            break;
          default:
            goto LABEL_23;
        }
        if ( v18 )
        {
          v11 = a1;
LABEL_17:
          v19 = 1 << *(_BYTE *)(v15 + 0xA);
          if ( (v19 & a4) != 0 && (v19 & a5) == 0 )
          {
            n3 = *(_WORD *)(v15 + 8);
            if ( n3 == 3 || n3 == 5 && *(_BYTE *)(v16 + v13) )
              sub_146A24990(v11, v7, v17, a6);
          }
        }
      }
LABEL_23:
      v11 = a1;
      ++v10;
      v14 += 0x20;
      v13 += 0xC;
      if ( v10 >= v24 )
        goto LABEL_24;
    }
  }
}

// --- End Function: sub_146A3A9B0 (0x146A3A9B0) ---

// --- Function: sub_146A3ABB0 (0x146A3ABB0) ---
void __fastcall sub_146A3ABB0(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, int a5, char a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // r15
  bool v8; // al
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdi
  __int64 v11; // r10
  _QWORD *v12; // r13
  __int64 v13; // rsi
  __int64 v14; // r14
  __int64 v15; // rbx
  __int64 v16; // rbp
  char v17; // r12
  bool v18; // al
  int v19; // eax
  __int16 n0xD; // ax
  unsigned __int64 v21; // [rsp+20h] [rbp-68h] BYREF
  unsigned __int64 v22; // [rsp+28h] [rbp-60h]
  unsigned __int64 v23; // [rsp+30h] [rbp-58h]
  unsigned __int64 v24; // [rsp+38h] [rbp-50h]
  __int64 v26; // [rsp+98h] [rbp+10h]

  if ( a3 )
  {
    v26 = a2;
    v6 = 0;
    v23 = 0;
    while ( 1 )
    {
      v7 = *(_QWORD *)(a2 + 8 * v6);
      v21 = *(_QWORD *)(v7 + 8);
      v8 = is_entity_descriptor_valid_or_accessible(&v21);
      v9 = v21 & 0xFFFFFFFFFFFFLL;
      if ( !v8 )
        v9 = 0;
      v22 = v9;
      if ( is_entity_descriptor_valid_or_accessible(&v21) && *(_BYTE *)((v21 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
      {
        v10 = 0;
        v11 = a1;
        v12 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(v7 + 0x10));
        v24 = v12[0x859] - v12[0x858];
        if ( v24 )
          break;
      }
LABEL_24:
      a2 = v26;
      v6 = v23 + 1;
      v23 = v6;
      if ( v6 >= a3 )
        return;
    }
    v13 = 0;
    v14 = 0;
    while ( 1 )
    {
      v15 = v14 + v12[0x82A];
      v16 = *(_QWORD *)(v7 + 0x18);
      v17 = *(_BYTE *)(v10 + v12[0x858]);
      if ( *(_QWORD *)v15 )
      {
        switch ( *(_BYTE *)(v15 + 0x11) )
        {
          case 0:
            goto LABEL_17;
          case 1:
            v18 = sub_140418C10(v22);
            break;
          case 2:
            v18 = !sub_140418C10(v22);
            break;
          default:
            goto LABEL_23;
        }
        if ( v18 )
        {
          v11 = a1;
LABEL_17:
          v19 = 1 << *(_BYTE *)(v15 + 0xA);
          if ( (v19 & a4) != 0 && (v19 & a5) == 0 )
          {
            n0xD = *(_WORD *)(v15 + 8);
            if ( n0xD == 0xD || n0xD == 0xF && *(_BYTE *)(v16 + v13) )
              sub_146A24990(v11, v7, v17, a6);
          }
        }
      }
LABEL_23:
      v11 = a1;
      ++v10;
      v14 += 0x20;
      v13 += 0xC;
      if ( v10 >= v24 )
        goto LABEL_24;
    }
  }
}

// --- End Function: sub_146A3ABB0 (0x146A3ABB0) ---

// --- Function: sub_146A3B6E0 (0x146A3B6E0) ---
void __fastcall sub_146A3B6E0(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, char a6)
{
  bool v7; // al
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  __int64 v10; // r10
  _QWORD *v11; // r15
  unsigned __int64 v12; // r12
  __int64 v13; // rsi
  __int64 v14; // r14
  __int64 v15; // rdi
  __int64 v16; // rbp
  char v17; // dl
  bool v18; // al
  int v19; // eax
  unsigned __int64 v20; // [rsp+20h] [rbp-48h] BYREF
  unsigned __int64 v21; // [rsp+28h] [rbp-40h]
  char v23; // [rsp+80h] [rbp+18h]

  v20 = *(_QWORD *)(a3 + 8);
  v7 = is_entity_descriptor_valid_or_accessible(&v20);
  v8 = 0;
  v9 = v20 & 0xFFFFFFFFFFFFLL;
  if ( !v7 )
    v9 = 0;
  v21 = v9;
  if ( is_entity_descriptor_valid_or_accessible(&v20) && *(_BYTE *)((v20 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
  {
    v10 = a1;
    v11 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(a3 + 0x10));
    v12 = v11[0x859] - v11[0x858];
    if ( v12 )
    {
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = v14 + v11[0x82A];
        v16 = *(_QWORD *)(a3 + 0x18);
        v17 = *(_BYTE *)(v8 + v11[0x858]);
        v23 = v17;
        if ( *(_QWORD *)v15 )
        {
          switch ( *(_BYTE *)(v15 + 0x11) )
          {
            case 0:
              goto LABEL_15;
            case 1:
              v18 = sub_140418C10(v21);
              break;
            case 2:
              v18 = !sub_140418C10(v21);
              break;
            default:
              goto LABEL_21;
          }
          if ( v18 )
          {
            v17 = v23;
            v10 = a1;
LABEL_15:
            v19 = 1 << *(_BYTE *)(v15 + 0xA);
            if ( (v19 & a4) != 0
              && (v19 & a5) == 0
              && (*(_WORD *)(v15 + 8) == 0xB || *(_WORD *)(v15 + 8) == 0xC && *(_BYTE *)(v16 + v13)) )
            {
              sub_146A24990(v10, a3, v17, a6);
            }
          }
        }
LABEL_21:
        v10 = a1;
        ++v8;
        v14 += 0x20;
        v13 += 0xC;
      }
      while ( v8 < v12 );
    }
  }
}

// --- End Function: sub_146A3B6E0 (0x146A3B6E0) ---

// --- Function: sub_146A3B880 (0x146A3B880) ---
void __fastcall sub_146A3B880(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, char a6)
{
  bool v7; // al
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  __int64 v10; // r10
  _QWORD *v11; // r15
  unsigned __int64 v12; // r12
  __int64 v13; // rsi
  __int64 v14; // r14
  __int64 v15; // rdi
  __int64 v16; // rbp
  char v17; // dl
  bool v18; // al
  int v19; // eax
  unsigned __int64 v20; // [rsp+20h] [rbp-48h] BYREF
  unsigned __int64 v21; // [rsp+28h] [rbp-40h]
  char v23; // [rsp+80h] [rbp+18h]

  v20 = *(_QWORD *)(a3 + 8);
  v7 = is_entity_descriptor_valid_or_accessible(&v20);
  v8 = 0;
  v9 = v20 & 0xFFFFFFFFFFFFLL;
  if ( !v7 )
    v9 = 0;
  v21 = v9;
  if ( is_entity_descriptor_valid_or_accessible(&v20) && *(_BYTE *)((v20 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
  {
    v10 = a1;
    v11 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(a3 + 0x10));
    v12 = v11[0x859] - v11[0x858];
    if ( v12 )
    {
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = v14 + v11[0x82A];
        v16 = *(_QWORD *)(a3 + 0x18);
        v17 = *(_BYTE *)(v8 + v11[0x858]);
        v23 = v17;
        if ( *(_QWORD *)v15 )
        {
          switch ( *(_BYTE *)(v15 + 0x11) )
          {
            case 0:
              goto LABEL_15;
            case 1:
              v18 = sub_140418C10(v21);
              break;
            case 2:
              v18 = !sub_140418C10(v21);
              break;
            default:
              goto LABEL_21;
          }
          if ( v18 )
          {
            v17 = v23;
            v10 = a1;
LABEL_15:
            v19 = 1 << *(_BYTE *)(v15 + 0xA);
            if ( (v19 & a4) != 0
              && (v19 & a5) == 0
              && (*(_WORD *)(v15 + 8) == 0x15 || *(_WORD *)(v15 + 8) == 0x16 && *(_BYTE *)(v16 + v13)) )
            {
              sub_146A24990(v10, a3, v17, a6);
            }
          }
        }
LABEL_21:
        v10 = a1;
        ++v8;
        v14 += 0x20;
        v13 += 0xC;
      }
      while ( v8 < v12 );
    }
  }
}

// --- End Function: sub_146A3B880 (0x146A3B880) ---

// --- Function: sub_146A3BF30 (0x146A3BF30) ---
double __fastcall sub_146A3BF30(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  int v4; // r8d
  __int64 v5; // r14
  __int64 v7; // rdi
  __int64 *v8; // rsi
  __int64 v9; // rbp
  bool v10; // al
  unsigned __int64 v11; // r12
  unsigned __int64 v12; // rbx
  _QWORD *v13; // r15
  __int64 v14; // rdi
  char v15; // r13
  bool v16; // al
  char v17; // di
  __int64 v18; // r8
  char v19; // cl
  unsigned __int64 v21; // [rsp+30h] [rbp-A8h] BYREF
  __int64 v22; // [rsp+38h] [rbp-A0h]
  unsigned __int64 v23; // [rsp+40h] [rbp-98h]
  __int64 *v24; // [rsp+48h] [rbp-90h]
  _DWORD v25[2]; // [rsp+50h] [rbp-88h] BYREF
  __int64 v26; // [rsp+58h] [rbp-80h]
  unsigned __int64 v27; // [rsp+60h] [rbp-78h]
  unsigned __int64 v28; // [rsp+68h] [rbp-70h]
  __int64 v29; // [rsp+70h] [rbp-68h]
  __int64 v30; // [rsp+78h] [rbp-60h]

  v4 = *(_DWORD *)(a2 + 0x2D8);
  v5 = 0;
  v25[0] = 0x1400;
  v26 = 0;
  v7 = a1;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v27 = __rdtsc();
  v25[1] = v4;
  isProfileFunctionsInitialized(
    v25,
    &word_1515B0070,
    "CEntityComponentUpdateScheduler::OnEntityAuthorityChanged",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0x129B);
  HIWORD(v25[0]) = word_1515B0070;
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 0xD) < 5u )
    {
      v8 = *(__int64 **)(a2 + 0x240);
      v24 = *(__int64 **)(a2 + 0x248);
      if ( v8 != v24 )
      {
        while ( 1 )
        {
          v22 = v7 + 0x2E0LL * *(unsigned __int16 *)((*v8 & 0xFFFFFFFFFFFFLL) + 0x10) + 0x4058;
          if ( is_valid_handle_typeA(v8) )
            v9 = *v8 & 0xFFFFFFFFFFFFLL;
          else
            v9 = 0;
          v21 = *(_QWORD *)(v9 + 8);
          v10 = is_entity_descriptor_valid_or_accessible(&v21);
          v11 = v21 & 0xFFFFFFFFFFFFLL;
          if ( !v10 )
            v11 = 0;
          if ( is_entity_descriptor_valid_or_accessible(&v21) && *(_BYTE *)((v21 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
          {
            v12 = 0;
            v13 = (_QWORD *)(v7 + 0x2E0LL * *(unsigned __int16 *)(v9 + 0x10));
            v23 = v13[0x859] - v13[0x858];
            if ( v23 )
              break;
          }
LABEL_27:
          if ( ++v8 == v24 )
            goto LABEL_28;
        }
        while ( 1 )
        {
          v14 = v13[0x82A];
          v15 = *(_BYTE *)(v12 + v13[0x858]);
          if ( *(_QWORD *)(v14 + v5) )
          {
            switch ( *(_BYTE *)(v14 + v5 + 0x11) )
            {
              case 0:
                goto LABEL_19;
              case 1:
                v16 = sub_140418C10(v11);
                break;
              case 2:
                v16 = !sub_140418C10(v11);
                break;
              default:
                goto LABEL_24;
            }
            if ( v16 )
            {
LABEL_19:
              v17 = *(_BYTE *)(v14 + v5 + 0x10);
              if ( is_valid_handle_typeA(v8) )
                v18 = *v8 & 0xFFFFFFFFFFFFLL;
              else
                v18 = 0;
              v19 = v17;
              v7 = a1;
              if ( sub_146A38570(a1, a2, v18, v22, __popcnt(*(_QWORD *)(v22 + 0x260) & ((1LL << v19) - 1))) )
                sub_146A24990(a1, v9, v15, a4);
              goto LABEL_25;
            }
          }
LABEL_24:
          v7 = a1;
LABEL_25:
          ++v12;
          v5 += 0x20;
          if ( v12 >= v23 )
          {
            v5 = 0;
            goto LABEL_27;
          }
        }
      }
    }
  }
LABEL_28:
  v28 = __rdtsc();
  return qword_149B4B878(v25);
}

// --- End Function: sub_146A3BF30 (0x146A3BF30) ---

// --- Function: sub_146A3C6E0 (0x146A3C6E0) ---
double __fastcall sub_146A3C6E0(__int64 a1, __int64 a2, int a3, int a4, char a5)
{
  bool v6; // cf
  __int64 *v7; // rax
  __int64 *v8; // r12
  __int64 v9; // rsi
  bool v10; // al
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdi
  __int64 v13; // r10
  _QWORD *v14; // r13
  __int64 v15; // r14
  __int64 v16; // r15
  unsigned __int64 v17; // r12
  __int64 v18; // rbx
  __int64 v19; // rbp
  char v20; // dl
  bool v21; // al
  int v22; // eax
  __int16 n8; // ax
  unsigned __int64 v25; // [rsp+30h] [rbp-B8h] BYREF
  unsigned __int64 v26; // [rsp+38h] [rbp-B0h]
  __int64 *v27; // [rsp+40h] [rbp-A8h]
  __int64 *v28; // [rsp+48h] [rbp-A0h]
  _DWORD v29[2]; // [rsp+50h] [rbp-98h] BYREF
  __int64 v30; // [rsp+58h] [rbp-90h]
  unsigned __int64 v31; // [rsp+60h] [rbp-88h]
  unsigned __int64 v32; // [rsp+68h] [rbp-80h]
  __int64 v33; // [rsp+70h] [rbp-78h]
  __int64 v34; // [rsp+78h] [rbp-70h]
  char v36; // [rsp+F8h] [rbp+10h]

  v29[0] = 0x1400;
  v30 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v31 = __rdtsc();
  v29[1] = *(_DWORD *)(a2 + 0x2D8);
  isProfileFunctionsInitialized(
    v29,
    &word_1515B0064,
    "CEntityComponentUpdateScheduler::OnEntityCompleteBoundsEnterInRange",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0x1226);
  v6 = *(_BYTE *)(a2 + 0xD) < 5u;
  HIWORD(v29[0]) = word_1515B0064;
  if ( v6 )
  {
    v7 = *(__int64 **)(a2 + 0x248);
    v8 = *(__int64 **)(a2 + 0x240);
    v27 = v8;
    v28 = v7;
    if ( v8 != v7 )
    {
      while ( 1 )
      {
        if ( is_valid_handle_typeA(v8) )
          v9 = *v8 & 0xFFFFFFFFFFFFLL;
        else
          v9 = 0;
        v25 = *(_QWORD *)(v9 + 8);
        v10 = is_entity_descriptor_valid_or_accessible(&v25);
        v11 = v25 & 0xFFFFFFFFFFFFLL;
        if ( !v10 )
          v11 = 0;
        v26 = v11;
        if ( is_entity_descriptor_valid_or_accessible(&v25) && *(_BYTE *)((v25 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
        {
          v12 = 0;
          v13 = a1;
          v14 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(v9 + 0x10));
          if ( v14[0x859] != v14[0x858] )
            break;
        }
LABEL_28:
        v27 = ++v8;
        if ( v8 == v28 )
          goto LABEL_29;
      }
      v15 = 0;
      v16 = 0;
      v17 = v14[0x859] - v14[0x858];
      while ( 1 )
      {
        v18 = v16 + v14[0x82A];
        v19 = *(_QWORD *)(v9 + 0x18);
        v20 = *(_BYTE *)(v12 + v14[0x858]);
        v36 = v20;
        if ( *(_QWORD *)v18 )
        {
          switch ( *(_BYTE *)(v18 + 0x11) )
          {
            case 0:
              goto LABEL_20;
            case 1:
              v21 = sub_140418C10(v26);
              break;
            case 2:
              v21 = !sub_140418C10(v26);
              break;
            default:
              goto LABEL_26;
          }
          if ( v21 )
          {
            v20 = v36;
            v13 = a1;
LABEL_20:
            v22 = 1 << *(_BYTE *)(v18 + 0xA);
            if ( (v22 & a3) != 0 && (v22 & a4) == 0 )
            {
              n8 = *(_WORD *)(v18 + 8);
              if ( n8 == 8 || n8 == 0xA && *(_BYTE *)(v19 + v15) )
                sub_146A24990(v13, v9, v20, a5);
            }
          }
        }
LABEL_26:
        v13 = a1;
        ++v12;
        v16 += 0x20;
        v15 += 0xC;
        if ( v12 >= v17 )
        {
          v8 = v27;
          goto LABEL_28;
        }
      }
    }
  }
LABEL_29:
  v32 = __rdtsc();
  return qword_149B4B878(v29);
}

// --- End Function: sub_146A3C6E0 (0x146A3C6E0) ---

// --- Function: sub_146A3C9C0 (0x146A3C9C0) ---
double __fastcall sub_146A3C9C0(__int64 a1, __int64 a2, int a3, int a4, char a5)
{
  bool v6; // cf
  __int64 *v7; // rax
  __int64 *v8; // r12
  __int64 v9; // rsi
  bool v10; // al
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdi
  __int64 v13; // r10
  _QWORD *v14; // r13
  __int64 v15; // r14
  __int64 v16; // r15
  unsigned __int64 v17; // r12
  __int64 v18; // rbx
  __int64 v19; // rbp
  char v20; // dl
  bool v21; // al
  int v22; // eax
  __int16 n0x12; // ax
  unsigned __int64 v25; // [rsp+30h] [rbp-B8h] BYREF
  unsigned __int64 v26; // [rsp+38h] [rbp-B0h]
  __int64 *v27; // [rsp+40h] [rbp-A8h]
  __int64 *v28; // [rsp+48h] [rbp-A0h]
  _DWORD v29[2]; // [rsp+50h] [rbp-98h] BYREF
  __int64 v30; // [rsp+58h] [rbp-90h]
  unsigned __int64 v31; // [rsp+60h] [rbp-88h]
  unsigned __int64 v32; // [rsp+68h] [rbp-80h]
  __int64 v33; // [rsp+70h] [rbp-78h]
  __int64 v34; // [rsp+78h] [rbp-70h]
  char v36; // [rsp+F8h] [rbp+10h]

  v29[0] = 0x1400;
  v30 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v31 = __rdtsc();
  v29[1] = *(_DWORD *)(a2 + 0x2D8);
  isProfileFunctionsInitialized(
    v29,
    &word_1515B006C,
    "CEntityComponentUpdateScheduler::OnEntityCompleteBoundsEnterIsVisible",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0x1274);
  v6 = *(_BYTE *)(a2 + 0xD) < 5u;
  HIWORD(v29[0]) = word_1515B006C;
  if ( v6 )
  {
    v7 = *(__int64 **)(a2 + 0x248);
    v8 = *(__int64 **)(a2 + 0x240);
    v27 = v8;
    v28 = v7;
    if ( v8 != v7 )
    {
      while ( 1 )
      {
        if ( is_valid_handle_typeA(v8) )
          v9 = *v8 & 0xFFFFFFFFFFFFLL;
        else
          v9 = 0;
        v25 = *(_QWORD *)(v9 + 8);
        v10 = is_entity_descriptor_valid_or_accessible(&v25);
        v11 = v25 & 0xFFFFFFFFFFFFLL;
        if ( !v10 )
          v11 = 0;
        v26 = v11;
        if ( is_entity_descriptor_valid_or_accessible(&v25) && *(_BYTE *)((v25 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
        {
          v12 = 0;
          v13 = a1;
          v14 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(v9 + 0x10));
          if ( v14[0x859] != v14[0x858] )
            break;
        }
LABEL_28:
        v27 = ++v8;
        if ( v8 == v28 )
          goto LABEL_29;
      }
      v15 = 0;
      v16 = 0;
      v17 = v14[0x859] - v14[0x858];
      while ( 1 )
      {
        v18 = v16 + v14[0x82A];
        v19 = *(_QWORD *)(v9 + 0x18);
        v20 = *(_BYTE *)(v12 + v14[0x858]);
        v36 = v20;
        if ( *(_QWORD *)v18 )
        {
          switch ( *(_BYTE *)(v18 + 0x11) )
          {
            case 0:
              goto LABEL_20;
            case 1:
              v21 = sub_140418C10(v26);
              break;
            case 2:
              v21 = !sub_140418C10(v26);
              break;
            default:
              goto LABEL_26;
          }
          if ( v21 )
          {
            v20 = v36;
            v13 = a1;
LABEL_20:
            v22 = 1 << *(_BYTE *)(v18 + 0xA);
            if ( (v22 & a3) != 0 && (v22 & a4) == 0 )
            {
              n0x12 = *(_WORD *)(v18 + 8);
              if ( n0x12 == 0x12 || n0x12 == 0x14 && *(_BYTE *)(v19 + v15) )
                sub_146A24990(v13, v9, v20, a5);
            }
          }
        }
LABEL_26:
        v13 = a1;
        ++v12;
        v16 += 0x20;
        v15 += 0xC;
        if ( v12 >= v17 )
        {
          v8 = v27;
          goto LABEL_28;
        }
      }
    }
  }
LABEL_29:
  v32 = __rdtsc();
  return qword_149B4B878(v29);
}

// --- End Function: sub_146A3C9C0 (0x146A3C9C0) ---

// --- Function: sub_146A3D560 (0x146A3D560) ---
double __fastcall sub_146A3D560(__int64 a1, __int64 a2, int a3, int a4, char a5)
{
  bool v6; // cf
  __int64 *v7; // rax
  __int64 *v8; // r12
  __int64 v9; // rsi
  bool v10; // al
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdi
  __int64 v13; // r10
  _QWORD *v14; // r13
  __int64 v15; // r14
  __int64 v16; // r15
  unsigned __int64 v17; // r12
  __int64 v18; // rbx
  __int64 v19; // rbp
  char v20; // dl
  bool v21; // al
  int v22; // eax
  __int16 n7; // ax
  unsigned __int64 v25; // [rsp+30h] [rbp-B8h] BYREF
  unsigned __int64 v26; // [rsp+38h] [rbp-B0h]
  __int64 *v27; // [rsp+40h] [rbp-A8h]
  __int64 *v28; // [rsp+48h] [rbp-A0h]
  _DWORD v29[2]; // [rsp+50h] [rbp-98h] BYREF
  __int64 v30; // [rsp+58h] [rbp-90h]
  unsigned __int64 v31; // [rsp+60h] [rbp-88h]
  unsigned __int64 v32; // [rsp+68h] [rbp-80h]
  __int64 v33; // [rsp+70h] [rbp-78h]
  __int64 v34; // [rsp+78h] [rbp-70h]
  char v36; // [rsp+F8h] [rbp+10h]

  v29[0] = 0x1400;
  v30 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v31 = __rdtsc();
  v29[1] = *(_DWORD *)(a2 + 0x2D8);
  isProfileFunctionsInitialized(
    v29,
    &word_1515B0060,
    "CEntityComponentUpdateScheduler::OnEntityRenderingBoundsEnterInRange",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0x11FF);
  v6 = *(_BYTE *)(a2 + 0xD) < 5u;
  HIWORD(v29[0]) = word_1515B0060;
  if ( v6 )
  {
    v7 = *(__int64 **)(a2 + 0x248);
    v8 = *(__int64 **)(a2 + 0x240);
    v27 = v8;
    v28 = v7;
    if ( v8 != v7 )
    {
      while ( 1 )
      {
        if ( is_valid_handle_typeA(v8) )
          v9 = *v8 & 0xFFFFFFFFFFFFLL;
        else
          v9 = 0;
        v25 = *(_QWORD *)(v9 + 8);
        v10 = is_entity_descriptor_valid_or_accessible(&v25);
        v11 = v25 & 0xFFFFFFFFFFFFLL;
        if ( !v10 )
          v11 = 0;
        v26 = v11;
        if ( is_entity_descriptor_valid_or_accessible(&v25) && *(_BYTE *)((v25 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
        {
          v12 = 0;
          v13 = a1;
          v14 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(v9 + 0x10));
          if ( v14[0x859] != v14[0x858] )
            break;
        }
LABEL_28:
        v27 = ++v8;
        if ( v8 == v28 )
          goto LABEL_29;
      }
      v15 = 0;
      v16 = 0;
      v17 = v14[0x859] - v14[0x858];
      while ( 1 )
      {
        v18 = v16 + v14[0x82A];
        v19 = *(_QWORD *)(v9 + 0x18);
        v20 = *(_BYTE *)(v12 + v14[0x858]);
        v36 = v20;
        if ( *(_QWORD *)v18 )
        {
          switch ( *(_BYTE *)(v18 + 0x11) )
          {
            case 0:
              goto LABEL_20;
            case 1:
              v21 = sub_140418C10(v26);
              break;
            case 2:
              v21 = !sub_140418C10(v26);
              break;
            default:
              goto LABEL_26;
          }
          if ( v21 )
          {
            v20 = v36;
            v13 = a1;
LABEL_20:
            v22 = 1 << *(_BYTE *)(v18 + 0xA);
            if ( (v22 & a3) != 0 && (v22 & a4) == 0 )
            {
              n7 = *(_WORD *)(v18 + 8);
              if ( n7 == 7 || n7 == 9 && *(_BYTE *)(v19 + v15) )
                sub_146A24990(v13, v9, v20, a5);
            }
          }
        }
LABEL_26:
        v13 = a1;
        ++v12;
        v16 += 0x20;
        v15 += 0xC;
        if ( v12 >= v17 )
        {
          v8 = v27;
          goto LABEL_28;
        }
      }
    }
  }
LABEL_29:
  v32 = __rdtsc();
  return qword_149B4B878(v29);
}

// --- End Function: sub_146A3D560 (0x146A3D560) ---

// --- Function: sub_146A3D840 (0x146A3D840) ---
double __fastcall sub_146A3D840(__int64 a1, __int64 a2, int a3, int a4, char a5)
{
  bool v6; // cf
  __int64 *v7; // rax
  __int64 *v8; // r12
  __int64 v9; // rsi
  bool v10; // al
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdi
  __int64 v13; // r10
  _QWORD *v14; // r13
  __int64 v15; // r14
  __int64 v16; // r15
  unsigned __int64 v17; // r12
  __int64 v18; // rbx
  __int64 v19; // rbp
  char v20; // dl
  bool v21; // al
  int v22; // eax
  __int16 n0x11; // ax
  unsigned __int64 v25; // [rsp+30h] [rbp-B8h] BYREF
  unsigned __int64 v26; // [rsp+38h] [rbp-B0h]
  __int64 *v27; // [rsp+40h] [rbp-A8h]
  __int64 *v28; // [rsp+48h] [rbp-A0h]
  _DWORD v29[2]; // [rsp+50h] [rbp-98h] BYREF
  __int64 v30; // [rsp+58h] [rbp-90h]
  unsigned __int64 v31; // [rsp+60h] [rbp-88h]
  unsigned __int64 v32; // [rsp+68h] [rbp-80h]
  __int64 v33; // [rsp+70h] [rbp-78h]
  __int64 v34; // [rsp+78h] [rbp-70h]
  char v36; // [rsp+F8h] [rbp+10h]

  v29[0] = 0x1400;
  v30 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v31 = __rdtsc();
  v29[1] = *(_DWORD *)(a2 + 0x2D8);
  isProfileFunctionsInitialized(
    v29,
    &word_1515B0068,
    "CEntityComponentUpdateScheduler::OnEntityRenderingBoundsEnterIsVisible",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0x124D);
  v6 = *(_BYTE *)(a2 + 0xD) < 5u;
  HIWORD(v29[0]) = word_1515B0068;
  if ( v6 )
  {
    v7 = *(__int64 **)(a2 + 0x248);
    v8 = *(__int64 **)(a2 + 0x240);
    v27 = v8;
    v28 = v7;
    if ( v8 != v7 )
    {
      while ( 1 )
      {
        if ( is_valid_handle_typeA(v8) )
          v9 = *v8 & 0xFFFFFFFFFFFFLL;
        else
          v9 = 0;
        v25 = *(_QWORD *)(v9 + 8);
        v10 = is_entity_descriptor_valid_or_accessible(&v25);
        v11 = v25 & 0xFFFFFFFFFFFFLL;
        if ( !v10 )
          v11 = 0;
        v26 = v11;
        if ( is_entity_descriptor_valid_or_accessible(&v25) && *(_BYTE *)((v25 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
        {
          v12 = 0;
          v13 = a1;
          v14 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(v9 + 0x10));
          if ( v14[0x859] != v14[0x858] )
            break;
        }
LABEL_28:
        v27 = ++v8;
        if ( v8 == v28 )
          goto LABEL_29;
      }
      v15 = 0;
      v16 = 0;
      v17 = v14[0x859] - v14[0x858];
      while ( 1 )
      {
        v18 = v16 + v14[0x82A];
        v19 = *(_QWORD *)(v9 + 0x18);
        v20 = *(_BYTE *)(v12 + v14[0x858]);
        v36 = v20;
        if ( *(_QWORD *)v18 )
        {
          switch ( *(_BYTE *)(v18 + 0x11) )
          {
            case 0:
              goto LABEL_20;
            case 1:
              v21 = sub_140418C10(v26);
              break;
            case 2:
              v21 = !sub_140418C10(v26);
              break;
            default:
              goto LABEL_26;
          }
          if ( v21 )
          {
            v20 = v36;
            v13 = a1;
LABEL_20:
            v22 = 1 << *(_BYTE *)(v18 + 0xA);
            if ( (v22 & a3) != 0 && (v22 & a4) == 0 )
            {
              n0x11 = *(_WORD *)(v18 + 8);
              if ( n0x11 == 0x11 || n0x11 == 0x13 && *(_BYTE *)(v19 + v15) )
                sub_146A24990(v13, v9, v20, a5);
            }
          }
        }
LABEL_26:
        v13 = a1;
        ++v12;
        v16 += 0x20;
        v15 += 0xC;
        if ( v12 >= v17 )
        {
          v8 = v27;
          goto LABEL_28;
        }
      }
    }
  }
LABEL_29:
  v32 = __rdtsc();
  return qword_149B4B878(v29);
}

// --- End Function: sub_146A3D840 (0x146A3D840) ---

// --- Function: sub_146A3E660 (0x146A3E660) ---
__int64 __fastcall sub_146A3E660(_QWORD *a1, unsigned int a2)
{
  unsigned __int64 n8_1; // r9
  __int64 v3; // r15
  _QWORD *v4; // r13
  unsigned int v5; // ebx
  __int64 v6; // r14
  _QWORD *v7; // rbx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rbp
  __int64 v10; // rsi
  unsigned __int64 n8; // rax
  __int64 v12; // rax
  _QWORD *v13; // r12
  __int64 v14; // r13
  __int64 v15; // rbx
  __int64 v16; // rdi
  __int64 v17; // rsi
  __int64 v18; // r14
  _QWORD *v19; // rdi
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rcx
  __int64 v22; // rax
  __int64 v23; // rbp
  _QWORD *v24; // r8
  __int64 v25; // r9
  __int64 v26; // rbx
  __int64 i; // rdi
  _QWORD *v28; // rdi
  __int64 j; // rbx
  char v30; // r8
  __int64 v31; // rdx
  _QWORD *v35; // [rsp+70h] [rbp+18h]

  n8_1 = a1[0x2E914];
  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( n8_1 >= 8 )
  {
    v6 = (int)a2;
    v7 = &a1[0x8F * (int)a2 + 0xBD];
    sub_146A161A0(
      a1[0x2E910],
      a1[0x2E910] + (n8_1 & 0xFFFFFFFFFFFFFFF8uLL),
      (__int64)(n8_1 & 0xFFFFFFFFFFFFFFF8uLL) >> 3,
      (unsigned __int8)a1);
    v8 = 0;
    v9 = v4[0x2E914] >> 3;
    if ( v9 )
    {
      do
      {
        v10 = *(_QWORD *)(v4[0x2E910] + 8 * v8);
        n8 = v7[4];
        if ( v10 != (n8 >> 3) - 1 )
        {
          if ( n8 >> 3 )
          {
            do
            {
              if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(*v7 + 8 * (n8 >> 3) - 8)) )
                break;
              sub_1403C6EB0((__int64)v7, 8);
              n8 = v7[4];
            }
            while ( n8 >= 8 );
          }
          v12 = v7[4] >> 3;
          if ( !v12 )
            break;
          *(_QWORD *)(*v7 + 8 * v10) = *(_QWORD *)(*v7 + 8 * v12 - 8);
          *(_DWORD *)((*(_QWORD *)(*v7 + 8 * v10) & 0xFFFFFFFFFFFFLL) + 0x18 * v6 + 0x370) = v10;
        }
        sub_1403C6EB0((__int64)v7, 8);
        ++v8;
      }
      while ( v8 < v9 );
    }
    v5 = a2;
  }
  sub_1403CF800(v4 + 0x2E910, 0xFFFFFFFFFFFFFFFFuLL);
  v13 = (_QWORD *)v4[0x2E924];
  v35 = &v13[v4[0x2E928] >> 3];
  if ( v13 != v35 )
  {
    v14 = 0x18LL * (int)v5;
    do
    {
      v15 = 0;
      v16 = 0;
      v17 = v14 + (*v13 & 0xFFFFFFFFFFFFLL) + 0x380;
      v18 = *(_WORD *)(v17 + 6) & 0x1FFF;
      if ( (*(_WORD *)(v17 + 6) & 0x1FFF) != 0 )
      {
        do
        {
          if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(8 * v16
                                                                           + (*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL))) )
          {
            if ( v16 != v15 )
            {
              *(_QWORD *)((*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL) + 8 * v15) = *(_QWORD *)((*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL)
                                                                                     + 8 * v16);
              *(_DWORD *)((*(_QWORD *)((*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL) + 8 * v15) & 0xFFFFFFFFFFFFLL) + v14 + 0x374) = v15;
            }
            ++v15;
          }
          ++v16;
        }
        while ( v16 != v18 );
        v3 = 0;
      }
      v19 = (_QWORD *)(*(_QWORD *)v17 & 0xFFFFFFFFFFFFLL);
      v20 = (v15 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
      if ( v20 == (((HIWORD(*(_QWORD *)v17) & 0x1FFFLL) + 3) & 0xFFFFFFFFFFFFFFFCuLL) )
      {
        v21 = (v15 << 0x30) ^ ((v15 << 0x30) ^ *(_QWORD *)v17) & 0xE000FFFFFFFFFFFFuLL;
      }
      else
      {
        v22 = allocWithProfilerInfo(8 * v20, (struct _exception *)8);
        v23 = v22;
        if ( v15 )
        {
          v24 = v19;
          v25 = v15;
          do
          {
            *(_QWORD *)((char *)v24 + v22 - (_QWORD)v19) = *v24;
            *v24++ = 0;
            --v25;
          }
          while ( v25 );
        }
        sub_147605980(v19);
        v21 = v23
            ^ (v23
             ^ (v15 << 0x30))
            & 0xFFFF000000000000uLL
            ^ (*(_QWORD *)v17
             ^ (v15 << 0x30))
            & 0xE000000000000000uLL;
      }
      ++v13;
      *(_QWORD *)v17 = v21;
    }
    while ( v13 != v35 );
    v4 = a1;
  }
  sub_1403CF800(v4 + 0x2E924, 0xFFFFFFFFFFFFFFFFuLL);
  v26 = v4[0x2E91A];
  for ( i = v26 + 8LL * (v4[0x2E91E] >> 3); v26 != i; v26 += 8 )
    sub_146A2C0D0(v4, v26, a2);
  sub_1403CF800(v4 + 0x2E91A, 0xFFFFFFFFFFFFFFFFuLL);
  v28 = v4 + 0x2E92E;
  for ( j = v4[0x2E932] >> 4; j; --j )
  {
    v30 = *(_BYTE *)(v3 + *v28 + 8);
    v31 = *(_QWORD *)(v3 + *v28);
    *(_BYTE *)(*(_QWORD *)(v31 + 0x18)
             + 0xC * __popcnt(((1LL << v30) - 1) & v4[0x5C * *(unsigned __int16 *)(v31 + 0x10) + 0x857])
             + 0xA) = 0;
    sub_146A24990((__int64)v4, v31, v30, 0);
    v3 += 0x10;
  }
  return sub_1403CF800(v28, 0xFFFFFFFFFFFFFFFFuLL);
}

// --- End Function: sub_146A3E660 (0x146A3E660) ---

// --- Function: sub_146A3F760 (0x146A3F760) ---
__int64 __fastcall sub_146A3F760(__int64 a1, __int64 a2, unsigned int *a3, __int64 a4)
{
  __int64 v7; // r13
  __int64 v8; // rbx
  unsigned __int64 v9; // rdx
  __int64 v10; // rcx
  char v11; // di
  bool v12; // al
  unsigned __int64 v13; // rcx
  char v14; // di
  unsigned int v15; // eax
  bool v16; // di
  char v17; // r14
  __int64 TlsIndex; // r12
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rcx
  bool v21; // zf
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // rcx
  __int64 v25; // rdx
  char v26; // r12
  __int64 v27; // rdi
  volatile signed __int64 *v28; // r14
  signed __int64 v29; // rdx
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rcx
  __int64 v32; // rcx
  volatile signed __int64 *v33; // rbx
  signed __int64 v34; // rsi
  unsigned __int8 v35; // bl
  signed __int64 v36; // rdx
  unsigned __int64 v38; // [rsp+30h] [rbp-89h] BYREF
  int v39; // [rsp+38h] [rbp-81h]
  __int64 v40; // [rsp+40h] [rbp-79h]
  __int64 v41; // [rsp+48h] [rbp-71h]
  __int64 v42; // [rsp+50h] [rbp-69h]
  __int64 v43; // [rsp+58h] [rbp-61h]
  __int64 v44; // [rsp+60h] [rbp-59h]
  __int64 v45; // [rsp+68h] [rbp-51h]
  int n0x1000; // [rsp+70h] [rbp-49h] BYREF
  __int64 v47; // [rsp+74h] [rbp-45h]
  int v48; // [rsp+7Ch] [rbp-3Dh]
  unsigned __int64 v49; // [rsp+80h] [rbp-39h]
  unsigned __int64 v50; // [rsp+88h] [rbp-31h]
  __int64 v51; // [rsp+90h] [rbp-29h]
  __int64 v52; // [rsp+98h] [rbp-21h]
  __int64 v53; // [rsp+C0h] [rbp+7h] BYREF
  unsigned __int64 n0x100; // [rsp+C8h] [rbp+Fh]
  char v55; // [rsp+D0h] [rbp+17h]
  unsigned int v56; // [rsp+D4h] [rbp+1Bh]
  char v58; // [rsp+128h] [rbp+6Fh]

  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v48 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  n0x1000 = 0x1000;
  v47 = 1;
  v49 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x1000,
    &word_1515B003C,
    "CEntityComponentUpdateScheduler::QueueEventToComponentInternal",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0x364);
  HIWORD(n0x1000) = word_1515B003C;
  v38 = *(_QWORD *)(a2 + 8);
  if ( !(unsigned __int8)sub_146A49F90(&v38)
    || !is_entity_descriptor_valid_or_accessible(&v38)
    || *(_BYTE *)((v38 & 0xFFFFFFFFFFFFLL) + 0xD) >= 5u
    || (_BYTE)isSandboxEditor && (*(_DWORD *)((v38 & 0xFFFFFFFFFFFFLL) + 8) & 2) != 0
    || dword_1515B1900 && (*(_BYTE *)((v38 & 0xFFFFFFFFFFFFLL) + 8) & 1) != 0 )
  {
    goto LABEL_93;
  }
  v7 = a1 + 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10) + 0x4058;
  v8 = *(_QWORD *)(v7 + 0xB0);
  v9 = (*(_QWORD *)(v7 + 0xB8) - v8) / 0x30;
  while ( v9 )
  {
    if ( *(_DWORD *)(v8 + 0x30 * (v9 >> 1)) >= *(_DWORD *)(a4 + 8) )
    {
      v9 >>= 1;
    }
    else
    {
      v8 += 0x30 * (v9 >> 1) + 0x30;
      v9 += 0xFFFFFFFFFFFFFFFFuLL - (v9 >> 1);
    }
  }
  v10 = *(_QWORD *)(v7 + 0xB8);
  if ( v8 == v10 )
    goto LABEL_93;
  if ( *(_DWORD *)(a4 + 8) < *(_DWORD *)v8 )
    v8 = *(_QWORD *)(v7 + 0xB8);
  if ( v8 == v10 )
    goto LABEL_93;
  v11 = *(_BYTE *)(v8 + 0x28);
  v12 = is_entity_descriptor_valid_or_accessible(&v38);
  v13 = v38 & 0xFFFFFFFFFFFFLL;
  if ( !v12 )
    v13 = 0;
  if ( !sub_146A37B60(v13, v11) || (*(_WORD *)(a1 + 0x174058) & *(_WORD *)(v8 + 0x2A)) == 0 )
  {
LABEL_93:
    v35 = 0;
    goto LABEL_94;
  }
  v14 = *(_BYTE *)(**(_QWORD **)(v7 + 0x18LL * *(int *)(v8 + 0x14) + 0x110) + 0x10LL);
  v58 = v14;
  if ( *a3 == 0xFFFFFFFF )
  {
    v15 = sub_146B296B0(qword_1515B19E8, a4);
    *a3 = v15;
    sub_146B277F0(qword_1515B19E8, v15);
  }
  sub_146B277F0(qword_1515B19E8, *a3);
  v39 = *(_DWORD *)(0x20 * __popcnt(*(_QWORD *)(v7 + 0x260) & ((1LL << v14) - 1)) + *(_QWORD *)(v7 + 0xF8) + 0xC);
  v16 = !is_thread_privileged_or_bypass_mode() && !*(_BYTE *)(get_thread_context_ptr() + 0x12D);
  v17 = 0;
  TlsIndex = (unsigned int)::TlsIndex;
  v19 = v38;
  if ( *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)::TlsIndex) + 0x920LL) == v39 )
  {
    if ( !v38
      || ((v38 & 0xF000000000000000uLL) == 0 ? (v20 = (v38 & 0xFFFFFFFFFFFFLL) - 6) : (v20 = v38 & 0xFFFFFF000000LL),
          *(_WORD *)(v20 + 2) != (HIWORD(v38) & 0xFFF)
       || *(_WORD *)(v20 + 4) >= 3u
       && (v21 = !check_thread_state_and_value_not_equal((_QWORD *)(v38 & 0xFFFFFFFFFFFFLL)), v19 = v38, v21)
       || (v19 & 0xFFFFFFFFFFFFLL) == 0
       || ((v19 & 0xF000000000000000uLL) == 0 ? (v22 = (v19 & 0xFFFFFFFFFFFFLL) - 6) : (v22 = v19 & 0xFFFFFF000000LL),
           *(_WORD *)(v22 + 4) != 1)) )
    {
      v17 = 1;
    }
  }
  if ( v16 )
  {
    if ( !v19 )
      goto LABEL_55;
    v23 = (v19 & 0xF000000000000000uLL) != 0 ? v19 & 0xFFFFFF000000LL : (v19 & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v23 + 2) != (HIWORD(v19) & 0xFFF) )
      goto LABEL_55;
    if ( *(_WORD *)(v23 + 4) >= 3u )
    {
      if ( !check_thread_state_and_value_not_equal((_QWORD *)(v19 & 0xFFFFFFFFFFFFLL)) )
      {
LABEL_55:
        v17 = 1;
        goto LABEL_56;
      }
      v19 = v38;
    }
    if ( (v19 & 0xFFFFFFFFFFFFLL) == 0 )
      goto LABEL_55;
    v24 = (v19 & 0xF000000000000000uLL) != 0 ? v19 & 0xFFFFFF000000LL : (v19 & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v24 + 4) != 1 )
      goto LABEL_55;
  }
LABEL_56:
  v25 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  v26 = v17;
  if ( *(_DWORD *)(v25 + 0x920) == 0x10 )
    v26 = 1;
  v27 = a1 + 0x478LL * v39;
  v28 = (volatile signed __int64 *)(v27 + 0x1D0);
  if ( *(_DWORD *)(v27 + 0x1E0) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(v27 + 0x1E4);
  }
  else
  {
    v29 = _InterlockedIncrement64(v28);
    if ( (v29 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        v27 + 0x1D0,
        v29,
        "CEntityComponentUpdateScheduler::QueueEventToComponentInternal",
        "m_perPassState[nPass].bIsRunningLock",
        1);
  }
  if ( *(_BYTE *)(v27 + 0x1C9) )
  {
    v30 = v38;
    if ( !v38 )
      goto LABEL_77;
    v31 = (v38 & 0xF000000000000000uLL) != 0 ? v38 & 0xFFFFFF000000LL : (v38 & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v31 + 2) != (HIWORD(v38) & 0xFFF) )
      goto LABEL_77;
    if ( *(_WORD *)(v31 + 4) >= 3u )
    {
      if ( !check_thread_state_and_value_not_equal((_QWORD *)(v38 & 0xFFFFFFFFFFFFLL)) )
      {
LABEL_77:
        v21 = *(_QWORD *)(a2 + 0x50) == 0;
        v55 = v58;
        v53 = a2;
        if ( v21 )
          __debugbreak();
        if ( (unsigned int)*(unsigned __int16 *)(a2 + 0x60) < *(_DWORD *)(v8 + 0x10) )
          __debugbreak();
        n0x100 = *(_QWORD *)(a2 + 0x50) + 0x10LL * *(unsigned int *)(v8 + 0x10);
        v56 = *a3;
        if ( n0x100 < 0x100 )
          __debugbreak();
        _InterlockedIncrement16((volatile signed __int16 *)(a2 + 0x22));
        v33 = (volatile signed __int64 *)(a1 + 0x128);
        if ( *(_DWORD *)(a1 + 0x138) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
        {
          ++*(_DWORD *)(a1 + 0x13C);
        }
        else
        {
          v34 = _InterlockedIncrement64(v33);
          if ( (v34 & 0x200000) != 0 )
            rw_lock_acquire_read_lock_dispatch(
              (__int64)v33,
              v34,
              "CEntityComponentUpdateScheduler::QueueEventToComponentInternal",
              "m_arrBackgroundDeferredQueueComponentEventsLock",
              1);
        }
        sub_1403CA640(a1 + 0xB8, &v53, 0x18u);
        rw_lock_release_read_lock((__int64)v33);
        v35 = 1;
        rw_lock_release_read_lock((__int64)v28);
        goto LABEL_94;
      }
      v30 = v38;
    }
    if ( (v30 & 0xFFFFFFFFFFFFLL) == 0 )
      goto LABEL_77;
    v32 = (v30 & 0xF000000000000000uLL) != 0 ? v30 & 0xFFFFFF000000LL : (v30 & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v32 + 4) != 1 )
      goto LABEL_77;
  }
  if ( v26 )
    goto LABEL_77;
  if ( *(_DWORD *)(v7 + 0x20) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(v7 + 0x24);
  }
  else
  {
    v36 = _InterlockedIncrement64((volatile signed __int64 *)(v7 + 0x10));
    if ( (v36 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        v7 + 0x10,
        v36,
        "CEntityComponentUpdateScheduler::QueueEventToComponentInternal",
        "pAllocator->lock",
        1);
  }
  *(_BYTE *)(*(_QWORD *)(a2 + 0x18) + 0xC * __popcnt(*(_QWORD *)(v7 + 0x260) & ((1LL << v58) - 1)) + 1) = 1;
  sub_146A4A310(*(_QWORD *)(a2 + 0x50) + 0x10LL * *(unsigned int *)(v8 + 0x10), a3);
  rw_lock_release_read_lock(v7 + 0x10);
  sub_146A24990(a1, a2, v58, 0);
  v35 = 1;
  rw_lock_release_read_lock((__int64)v28);
LABEL_94:
  v50 = __rdtsc();
  qword_149B4B878(&n0x1000);
  return v35;
}

// --- End Function: sub_146A3F760 (0x146A3F760) ---

// --- Function: sub_146A40B50 (0x146A40B50) ---
const ULONG_PTR *__fastcall sub_146A40B50(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_2, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r14
  __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // r13
  int v8; // esi
  unsigned __int32 v9; // eax
  int v10; // eax
  unsigned __int32 v11; // eax
  __int64 v12; // rbp
  int v13; // ebx
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // r12
  __int64 v18; // rax
  unsigned __int64 v19; // rdx
  __int64 v20; // rcx
  unsigned __int64 v21; // rbp
  __int64 v22; // r12
  __int64 v23; // r13
  __int64 v24; // rax
  __int64 v25; // rsi
  bool v26; // dl
  unsigned __int64 v27; // rcx
  unsigned __int16 v28; // ax
  unsigned __int64 v29; // rbx
  __int64 v30; // rcx
  __int64 v31; // rbx
  bool v32; // al
  __int64 v33; // rax
  unsigned __int64 v34; // rbx
  __int64 v35; // rax
  bool v36; // cf
  unsigned __int64 allocSize; // rax
  _QWORD *v38; // rax
  _QWORD *v39; // rcx
  _QWORD *i; // rax
  __int64 *v41; // rax
  __int64 v42; // rdx
  __int64 v43; // rsi
  const void *v44; // r14
  _QWORD *j; // rdi
  _QWORD *v46; // rbx
  const void *v47; // rcx
  int *v48; // r8
  int *k; // rdx
  int v50; // ecx
  bool v51; // dl
  unsigned __int64 v52; // rcx
  unsigned __int16 v53; // ax
  unsigned __int64 v54; // rcx
  unsigned __int64 v55; // rdi
  __int64 v56; // rbx
  __int64 v57; // rcx
  __int64 v58; // rbx
  __int64 v59; // r8
  __int64 v60; // rsi
  _QWORD *v61; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rax
  int v63; // eax
  unsigned __int64 n0x200000; // rax
  __int64 v65; // [rsp+30h] [rbp-58h]
  char v66; // [rsp+38h] [rbp-50h] BYREF
  char v68; // [rsp+98h] [rbp+10h]
  __int64 v69; // [rsp+A0h] [rbp+18h] BYREF
  __int64 v70; // [rsp+A8h] [rbp+20h]

  v69 = a3;
  v3 = 0;
  v4 = 0x2E0LL * *(unsigned __int16 *)(a3 + 0x10) + p_p_p_p_p_p_p_p_p_p_p_p_Source_2 + 0x4058;
  v5 = a3;
  v70 = v4;
  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
  if ( !*(_BYTE *)(v4 + 8) )
  {
    v8 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
    if ( *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x28) == v8 )
    {
      ++*(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2C);
    }
    else
    {
      v9 = _InterlockedCompareExchange((volatile signed __int32 *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18), 1, 0);
      if ( v9 )
        sub_1403C33A0(
          p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18,
          v9,
          "CEntityComponentUpdateScheduler::RegisterComponent",
          1);
      else
        *(_QWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x20) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x28) = v8;
    }
    v4 = v70;
    if ( !*(_BYTE *)(v70 + 8) )
      sub_146A34670(p_p_p_p_p_p_p_p_p_p_p_p_Source, v69);
    v10 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2C);
    if ( v10 )
    {
      *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2C) = v10 - 1;
    }
    else
    {
      *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x28) = 0xFFFFFFFF;
      v11 = _InterlockedCompareExchange((volatile signed __int32 *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18), 0, 1);
      if ( v11 == 1 )
        *(_QWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x20) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DB1F0(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18, v11);
    }
    v5 = v69;
  }
  v12 = v4 + 0x10;
  v65 = v4 + 0x10;
  v13 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(v4 + 0x20) == v13 )
  {
    ++*(_DWORD *)(v4 + 0x24);
  }
  else
  {
    v14 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    v15 = _InterlockedCompareExchange64((volatile signed __int64 *)v12, 0x200000, 0);
    if ( v15 )
      sub_1403DCD60(v4 + 0x10, v15, v14, "CEntityComponentUpdateScheduler::RegisterComponent", "pAllocator->lock", 1);
    else
      *(_QWORD *)(v4 + 0x18) = v14;
    *(_DWORD *)(v4 + 0x20) = v13;
  }
  v16 = *(_QWORD *)(v4 + 0x270) - *(_QWORD *)(v4 + 0x268);
  v17 = 0xFFFFFFFFFFFFFFFFuLL;
  v18 = allocWithProfilerInfo_Wrapper(saturated_mul(v16, 0xCu));
  if ( v18 )
  {
    v19 = v16;
    if ( v16 )
    {
      v20 = v18 + 2;
      do
      {
        *(_QWORD *)(v20 - 2) = 0;
        *(_DWORD *)(v20 + 6) = 0;
        v20 += 0xC;
        --v19;
      }
      while ( v19 );
    }
  }
  else
  {
    v18 = 0;
  }
  *(_QWORD *)(v5 + 0x18) = v18;
  if ( v16 )
  {
    v21 = v16;
    v22 = 0;
    v23 = 0;
    while ( 1 )
    {
      v24 = *(_QWORD *)(v4 + 0x268);
      v25 = *(_QWORD *)(v4 + 0xF8);
      v68 = *(_BYTE *)(v3 + v24);
      *(_BYTE *)(*(_QWORD *)(v5 + 0x18) + v22 + 5) = *(_BYTE *)(v25 + v23 + 0xB);
      v26 = sub_146B5A9D0(a2);
      if ( v26 )
        v27 = a2 & 0xFFFFFFFFFF000000uLL;
      else
        v27 = a2 - 6;
      v28 = *(_WORD *)(v27 + 2) | 0x2000;
      if ( !v26 )
        v28 = *(_WORD *)(v27 + 2);
      v29 = a2 | ((unsigned __int64)v28 << 0x30);
      if ( v29 )
      {
        if ( (v29 & 0xF000000000000000uLL) != 0 )
          v30 = v29 & 0xFFFFFF000000LL;
        else
          v30 = (v29 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v30 + 2) == (HIWORD(v29) & 0xFFF)
          && (*(_WORD *)(v30 + 4) < 3u || check_thread_state_and_value_not_equal((_QWORD *)(v29 & 0xFFFFFFFFFFFFLL)))
          && (v29 & 0xFFFFFFFFFFFFLL) != 0 )
        {
          v31 = (v29 & 0xF000000000000000uLL) != 0 ? v29 & 0xFFFFFF000000LL : (v29 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v31 + 4) == 1 )
            goto LABEL_56;
        }
        v5 = v69;
      }
      if ( *(_WORD *)(v25 + v23 + 8) == 1 )
      {
        switch ( *(_BYTE *)(v25 + v23 + 0x11) )
        {
          case 0:
            goto LABEL_55;
          case 1:
            v32 = sub_140418C10(a2);
            break;
          case 2:
            v32 = !sub_140418C10(a2);
            break;
          default:
            goto LABEL_56;
        }
        if ( v32 )
LABEL_55:
          sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source_2, v5, v68, 0);
      }
LABEL_56:
      v5 = v69;
      ++v3;
      v4 = v70;
      v23 += 0x20;
      v22 += 0xC;
      if ( v3 >= v21 )
      {
        v12 = v65;
        v17 = 0xFFFFFFFFFFFFFFFFuLL;
        p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
        break;
      }
    }
  }
  v33 = (__int64)(*(_QWORD *)(v4 + 0xD0) - *(_QWORD *)(v4 + 0xC8)) >> 3;
  if ( v33 )
  {
    *(_WORD *)(v5 + 0x60) = v33;
    v34 = (__int64)(*(_QWORD *)(v4 + 0xD0) - *(_QWORD *)(v4 + 0xC8)) >> 3;
    v35 = 0x10 * v34;
    if ( !is_mul_ok(v34, 0x10u) )
      v35 = 0xFFFFFFFFFFFFFFFFuLL;
    v36 = __CFADD__(v35, 8);
    allocSize = v35 + 8;
    if ( v36 )
      allocSize = 0xFFFFFFFFFFFFFFFFuLL;
    v38 = (_QWORD *)allocWithProfilerInfo_Wrapper(allocSize);
    if ( v38 )
    {
      *v38 = v34;
      v39 = v38 + 1;
      for ( i = v38 + 1; v34; --v34 )
      {
        *i = 0;
        i[1] = 0;
        i += 2;
      }
    }
    else
    {
      v39 = 0;
    }
    v41 = (__int64 *)(v5 + 0x50);
    if ( (char *)(v5 + 0x50) == &v66 )
    {
      if ( v39 )
      {
        v43 = v39[0xFFFFFFFF];
        v44 = v39 + 0xFFFFFFFF;
        for ( j = &v39[2 * v43]; v43; j[1] = 0 )
        {
          v46 = (_QWORD *)j[0xFFFFFFFE];
          j += 0xFFFFFFFE;
          --v43;
          while ( v46 )
          {
            v47 = v46;
            v46 = (_QWORD *)*v46;
            sub_1402A3D30(v47);
          }
          *j = 0;
        }
        sub_1402A3D30(v44);
        v5 = v69;
        v4 = v70;
      }
    }
    else
    {
      v42 = *v41;
      *v41 = (__int64)v39;
      if ( v42 )
        sub_140337DC0(v5 + 0x50, v42, 0);
    }
    *(_BYTE *)(v4 + 0x291) = 1;
  }
  *(_QWORD *)(v5 + 0x58) = 0xFFFFFFFFFFFFFFFFuLL;
  v48 = *(int **)(v4 + 0xE8);
  for ( k = *(int **)(v4 + 0xE0); k != v48; v17 &= ~(1LL << v50) )
  {
    v50 = *k++;
    *(_QWORD *)(v5 + 0x58) = v17 & ~(1LL << v50);
  }
  v51 = sub_146B5A9D0(a2);
  if ( v51 )
    v52 = a2 & 0xFFFFFFFFFF000000uLL;
  else
    v52 = a2 - 6;
  v53 = *(_WORD *)(v52 + 2) | 0x2000;
  if ( !v51 )
    v53 = *(_WORD *)(v52 + 2);
  v54 = a2 | ((unsigned __int64)v53 << 0x30);
  v55 = HIWORD(v54);
  if ( v54
    && ((v56 = v54 & 0xFFFFFFFFFFFFLL, (v54 & 0xF000000000000000uLL) == 0)
      ? (v57 = v56 - 6)
      : (v57 = v54 & 0xFFFFFF000000LL),
        *(_WORD *)(v57 + 2) == (v55 & 0xFFF)
     && (*(_WORD *)(v57 + 4) < 3u || check_thread_state_and_value_not_equal((_QWORD *)v56))
     && v56
     && ((v55 & 0xF000) == 0 ? (v58 = v56 - 6) : (v58 = v56 & 0xFFFFFF000000LL), *(_WORD *)(v58 + 4) == 1)) )
  {
    v60 = v69;
  }
  else
  {
    v59 = v4;
    v60 = v69;
    sub_146A41B00(p_p_p_p_p_p_p_p_p_p_p_p_Source, v69, v59);
  }
  v61 = sub_146AB80E0(a2, &v69);
  p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const ULONG_PTR *)sub_146B6C050(qword_1515B1A08, v61, v60);
  if ( v12 )
  {
    v63 = *(_DWORD *)(v12 + 0x14);
    if ( v63 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const ULONG_PTR *)(unsigned int)(v63 - 1);
      *(_DWORD *)(v12 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    }
    else
    {
      *(_DWORD *)(v12 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v12, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v12 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return rw_lock_handle_write_release_contention(v12, n0x200000);
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
}

// --- End Function: sub_146A40B50 (0x146A40B50) ---

// --- Function: sub_146A429B0 (0x146A429B0) ---
double __fastcall sub_146A429B0(__int64 a1, __int64 a2)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdi
  __int64 v4; // rax
  double result; // xmm0_8
  unsigned __int64 v6; // [rsp+38h] [rbp+10h] BYREF

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  if ( !*(_BYTE *)(a2 + 0x20) )
  {
    v6 = *(_QWORD *)(a2 + 8);
    if ( is_entity_descriptor_valid_or_accessible(&v6) && *(_BYTE *)((v6 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
    {
      v4 = *(unsigned __int16 *)(a2 + 0x10);
      *(_BYTE *)(a2 + 0x20) = 1;
      return sub_146A24990(
               p_p_p_p_p_p_p_p_p_p_p_p_Source,
               a2,
               *(_BYTE *)(**(_QWORD **)(p_p_p_p_p_p_p_p_p_p_p_p_Source
                                      + 0x2E0 * v4
                                      + 0x18LL * *(int *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0 * v4 + 0x4080)
                                      + 0x4168)
                        + 0x10LL),
               0);
    }
  }
  return result;
}

// --- End Function: sub_146A429B0 (0x146A429B0) ---

// --- Function: sub_146A42A40 (0x146A42A40) ---
double __fastcall sub_146A42A40(__int64 a1, __int64 a2, char a3)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rsi
  __int64 v5; // rdi
  __int64 v7; // rax
  unsigned __int64 v8; // r8
  char v9; // dl
  char *v10; // r8
  char *v11; // rax
  double result; // xmm0_8
  char v13; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v14; // [rsp+58h] [rbp+20h] BYREF

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v5 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v14 = *(_QWORD *)(a2 + 8);
  if ( is_entity_descriptor_valid_or_accessible(&v14) && *(_BYTE *)((v14 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
  {
    v13 = 1;
    v7 = *(_QWORD *)(a2 + 0x18);
    v8 = 3 * __popcnt(*(_QWORD *)(v5 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x42B8) & ((1LL << a3) - 1)) + 1;
    v9 = *(_BYTE *)(v7 + 4 * v8);
    v10 = (char *)(v7 + 4 * v8);
    v11 = &v13;
    if ( v9 )
      v11 = v10;
    *v10 = *v11;
    if ( !v9 )
      return sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a2, a3, 0);
  }
  return result;
}

// --- End Function: sub_146A42A40 (0x146A42A40) ---

// --- Function: sub_146A4A420 (0x146A4A420) ---
bool __fastcall sub_146A4A420(volatile signed __int64 *a1, _OWORD *a2, unsigned __int64 *a3)
{
  signed __int64 v3; // rax
  unsigned int v7; // rcx^4
  signed __int64 v8; // rtt
  unsigned __int64 v9; // rbx
  signed __int64 v10; // rtt
  __int64 v11; // rbp
  unsigned __int64 v12; // rdi
  __int64 v13; // r15
  unsigned __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // r14
  _OWORD *v17; // rdx
  __int64 v18; // r8
  unsigned __int64 v19; // rcx
  signed __int64 i; // rax
  int v22; // [rsp+50h] [rbp+8h] BYREF

  v3 = *a1;
  do
  {
    while ( (v3 & 0x4000000000000000LL) != 0 )
    {
      if ( v3 < 0 )
        goto LABEL_6;
      v7 = HIDWORD(v3) | 0x80000000;
      v8 = v3;
      v3 = _InterlockedCompareExchange64(a1, v3 | 0x8000000000000000uLL, v3);
      if ( v8 == v3 )
      {
        HIDWORD(v3) = v7;
LABEL_6:
        v22 = HIDWORD(v3);
        qword_149B3B480((char *)a1 + 4, &v22, 4, 0xFFFFFFFFLL);
        v3 = *a1;
      }
    }
    v9 = v3 | 0x4000000000000000LL;
    v10 = v3;
    v3 = _InterlockedCompareExchange64(a1, v3 | 0x4000000000000000LL, v3);
  }
  while ( v10 != v3 );
  v11 = HIWORD(v9) & 0x1FFF;
  v12 = v9 & 0x3FFFFFFFFFFFFFFFLL;
  v13 = v9 & 0xFFFFFFFFFFFFLL;
  v14 = (v11 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
  if ( v11 == v14 )
  {
    v15 = allocWithProfilerInfo(0x10 * (v14 + 4), (struct _exception *)8);
    v16 = v15;
    if ( v11 )
    {
      v17 = (_OWORD *)v15;
      v18 = HIWORD(v9) & 0x1FFF;
      do
      {
        *v17 = *(_OWORD *)((char *)v17 + v13 - v15);
        ++v17;
        --v18;
      }
      while ( v18 );
    }
    sub_147605980((const void *)(v9 & 0xFFFFFFFFFFFFLL));
    v13 = v16;
    v12 = v16 ^ (v16 ^ v12) & 0xFFFF000000000000uLL;
  }
  *(_OWORD *)(v13 + 0x10 * v11) = *a2;
  v19 = (v12 + 0x1000000000000LL) ^ (v12 ^ (v12 + 0x1000000000000LL)) & 0xE000FFFFFFFFFFFFuLL | 0x2000000000000000LL;
  for ( i = _InterlockedCompareExchange64(a1, v19, v9); i != v9; i = _InterlockedCompareExchange64(a1, v19, i) )
    v9 = i;
  if ( (v9 & 0x8000000000000000uLL) != 0LL )
    qword_149B3B490((char *)a1 + 4);
  if ( a3 )
    *a3 = HIWORD(v9) & 0x1FFF;
  return (v9 & 0x1FFF000000000000LL) == 0;
}

// --- End Function: sub_146A4A420 (0x146A4A420) ---

// --- Function: sub_146A4A620 (0x146A4A620) ---
bool __fastcall sub_146A4A620(volatile signed __int64 *a1, unsigned __int64 *p_p_sub_146A26220, unsigned __int64 *a3)
{
  signed __int64 v3; // rax
  unsigned int v7; // rcx^4
  signed __int64 v8; // rtt
  unsigned __int64 v9; // rbx
  signed __int64 v10; // rtt
  __int64 v11; // rbp
  unsigned __int64 v12; // rdi
  __int64 v13; // r14
  unsigned __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // r15
  _QWORD *v17; // r8
  __int64 v18; // r9
  unsigned __int64 v19; // rcx
  signed __int64 i; // rax
  int v22; // [rsp+50h] [rbp+8h] BYREF

  v3 = *a1;
  do
  {
    while ( (v3 & 0x4000000000000000LL) != 0 )
    {
      if ( v3 < 0 )
        goto LABEL_6;
      v7 = HIDWORD(v3) | 0x80000000;
      v8 = v3;
      v3 = _InterlockedCompareExchange64(a1, v3 | 0x8000000000000000uLL, v3);
      if ( v8 == v3 )
      {
        HIDWORD(v3) = v7;
LABEL_6:
        v22 = HIDWORD(v3);
        qword_149B3B480((char *)a1 + 4, &v22, 4, 0xFFFFFFFFLL);
        v3 = *a1;
      }
    }
    v9 = v3 | 0x4000000000000000LL;
    v10 = v3;
    v3 = _InterlockedCompareExchange64(a1, v3 | 0x4000000000000000LL, v3);
  }
  while ( v10 != v3 );
  v11 = HIWORD(v9) & 0x1FFF;
  v12 = v9 & 0x3FFFFFFFFFFFFFFFLL;
  v13 = v9 & 0xFFFFFFFFFFFFLL;
  v14 = (v11 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
  if ( v11 == v14 )
  {
    v15 = allocWithProfilerInfo(8 * v14 + 0x20, (struct _exception *)8);
    v16 = v15;
    if ( v11 )
    {
      v17 = (_QWORD *)(v9 & 0xFFFFFFFFFFFFLL);
      v18 = HIWORD(v9) & 0x1FFF;
      do
      {
        *(_QWORD *)((char *)v17 + v15 - v13) = *v17;
        *v17++ = 0;
        --v18;
      }
      while ( v18 );
    }
    sub_147605980((const void *)(v9 & 0xFFFFFFFFFFFFLL));
    v13 = v16;
    v12 = v16 ^ (v16 ^ v12) & 0xFFFF000000000000uLL;
  }
  *(_QWORD *)(v13 + 8 * v11) = *p_p_sub_146A26220;
  v19 = (v12 + 0x1000000000000LL) ^ (v12 ^ (v12 + 0x1000000000000LL)) & 0xE000FFFFFFFFFFFFuLL | 0x2000000000000000LL;
  for ( i = _InterlockedCompareExchange64(a1, v19, v9); i != v9; i = _InterlockedCompareExchange64(a1, v19, i) )
    v9 = i;
  if ( (v9 & 0x8000000000000000uLL) != 0LL )
    qword_149B3B490((char *)a1 + 4);
  if ( a3 )
    *a3 = HIWORD(v9) & 0x1FFF;
  return (v9 & 0x1FFF000000000000LL) == 0;
}

// --- End Function: sub_146A4A620 (0x146A4A620) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE58LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n0x6900 = 0x6900;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x6900,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    0xA7);
  HIWORD(n0x6900) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n0x6900);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
// // Standard compiler-generated security function to detect stack buffer
// overflows. // This function compares a provided stack cookie with a global
// security cookie. // If the values do not match, it indicates a potential stack
// corruption (e.g., // due to a buffer overflow) and triggers a fatal error report
// via _report_gsfailure. // // Parameters: //   stackCookie: The stack cookie
// value pushed onto the stack by the compiler.
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 rotatedCookie; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  rotatedCookie = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)rotatedCookie )
  {
    StackCookie = __ROR8__(rotatedCookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

