// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x140F9EEF0 (sub_140F9EEF0)
// Caller Depth: 2
// Callee/Ref Depth: 5
// Total Functions Found: 93
// ------------------------------------------------------------

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(__int64 a1)
{
  return sub_147605980(a1, (unsigned int)dword_149924818);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: sub_1402A3D40 (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: sub_1402A3D40 (0x1402A3D40) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  size_t Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  size_t v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  __int64 v17; // rbx

  Size_1 = (size_t)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = Size_1 + a2;
  v11 = (Size_1 + a2) | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v15 = 0;
      else
        v15 = (_QWORD *)sub_1402A3D40(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = sub_1402A3D40(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = (const void *)v10;
  v16 = (char *)v15 + Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, Size_1);
    memcpy((char *)v15 + Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = (__int64)*Src;
  memcpy(v15, *Src, Size_1);
  memcpy((char *)v15 + Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v17 - *(_QWORD *)(v17 - 8) - 8) <= 0x1F )
    {
      v17 = *(_QWORD *)(v17 - 8);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: sub_1402A9A00 (0x1402A9A00) ---
const void **__fastcall sub_1402A9A00(const void **Src, unsigned __int64 a2)
{
  char *v2; // r14
  __int64 v3; // rbx
  unsigned __int64 n0xF; // rbp
  char *v6; // r15
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v10; // rax
  _QWORD *v11; // rdi
  size_t Size; // r8
  __int64 v13; // rbx

  v2 = (char *)Src[2];
  v3 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)v2 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v6 = &v2[a2];
  v7 = (unsigned __int64)&v2[a2] | 0xF;
  if ( v7 > 0x7FFFFFFFFFFFFFFFLL || (v8 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v3 = v7;
    if ( v7 < v8 + n0xF )
      v3 = v8 + n0xF;
    if ( (unsigned __int64)(v3 + 1) < 0x1000 )
    {
      if ( v3 == -1 )
        v11 = 0;
      else
        v11 = (_QWORD *)sub_1402A3D40(v3 + 1);
      goto LABEL_15;
    }
    allocSize = v3 + 40;
    if ( v3 + 40 < (unsigned __int64)(v3 + 1) )
      sub_1402E1170();
  }
  v10 = sub_1402A3D40(allocSize);
  if ( !v10 )
    goto LABEL_20;
  v11 = (_QWORD *)((v10 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v11 - 1) = v10;
LABEL_15:
  Src[2] = v6;
  Size = (size_t)(v2 + 1);
  Src[3] = (const void *)v3;
  if ( n0xF <= 0xF )
  {
    memcpy(v11, Src, Size);
    goto LABEL_22;
  }
  v13 = (__int64)*Src;
  memcpy(v11, *Src, Size);
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v13 - *(_QWORD *)(v13 - 8) - 8) <= 0x1F )
    {
      v13 = *(_QWORD *)(v13 - 8);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v13);
LABEL_22:
  *Src = v11;
  return Src;
}

// --- End Function: sub_1402A9A00 (0x1402A9A00) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: sub_1402B1D80 (0x1402B1D80) ---
void __fastcall sub_1402B1D80(__int64 *a1)
{
  unsigned __int64 n0xF; // rdx
  __int64 v3; // rcx

  n0xF = a1[3];
  if ( n0xF > 0xF )
  {
    v3 = *a1;
    if ( n0xF + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = *(_QWORD *)(v3 - 8);
    }
    sub_1402A3D30(v3);
  }
  a1[2] = 0;
  a1[3] = 15;
  *(_BYTE *)a1 = 0;
}

// --- End Function: sub_1402B1D80 (0x1402B1D80) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 16LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_9 (0x1402E1F70) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E1F70) ---

// --- Function: sub_1402E2330 (0x1402E2330) ---
const void **__fastcall sub_1402E2330(const void **Src, const void *a2, unsigned __int64 Size_1)
{
  char *v5; // rcx
  unsigned __int64 n0xF; // r8
  void *Src_1; // rax
  char *v8; // rbx
  unsigned __int8 v10; // [rsp+40h] [rbp+8h]

  v5 = (char *)Src[2];
  n0xF = (unsigned __int64)Src[3];
  if ( Size_1 > n0xF - (unsigned __int64)v5 )
    return sub_1402A9870(Src, Size_1, v10, a2, Size_1);
  Src[2] = &v5[Size_1];
  Src_1 = Src;
  if ( n0xF > 0xF )
    Src_1 = (void *)*Src;
  v8 = &v5[(_QWORD)Src_1];
  memmove(&v5[(_QWORD)Src_1], a2, Size_1);
  v8[Size_1] = 0;
  return Src;
}

// --- End Function: sub_1402E2330 (0x1402E2330) ---

// --- Function: sub_1402E39E0 (0x1402E39E0) ---
const void **__fastcall sub_1402E39E0(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rbx
  const void **result; // rax

  if ( *(_QWORD *)(a1 + 24) < a2 )
  {
    v3 = *(_QWORD *)(a1 + 16);
    result = sub_1402A9A00((const void **)a1, a2 - v3);
    *(_QWORD *)(a1 + 16) = v3;
  }
  return result;
}

// --- End Function: sub_1402E39E0 (0x1402E39E0) ---

// --- Function: sub_1402FAE70 (0x1402FAE70) ---
__int64 *__fastcall sub_1402FAE70(__int64 *a1, void *Src, size_t Size)
{
  unsigned __int64 n0xF; // rbp
  void *v7; // rdi
  size_t v8; // rdi
  __int64 v9; // rdx
  unsigned __int64 allocSize; // rcx
  __int64 v11; // rax
  _QWORD *v12; // r14
  __int64 v13; // rcx

  n0xF = a1[3];
  if ( Size > n0xF )
  {
    v8 = 0x7FFFFFFFFFFFFFFFLL;
    if ( Size > 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_9();
    if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL || (v9 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
    {
      allocSize = 0x8000000000000027uLL;
    }
    else
    {
      v8 = Size | 0xF;
      if ( (Size | 0xF) < v9 + n0xF )
        v8 = v9 + n0xF;
      if ( v8 + 1 < 0x1000 )
      {
        if ( v8 == -1 )
          v12 = 0;
        else
          v12 = (_QWORD *)sub_1402A3D40(v8 + 1);
        goto LABEL_19;
      }
      allocSize = v8 + 40;
      if ( v8 + 40 < v8 + 1 )
        sub_1402E1170();
    }
    v11 = sub_1402A3D40(allocSize);
    if ( !v11 )
      goto LABEL_26;
    v12 = (_QWORD *)((v11 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v12 - 1) = v11;
LABEL_19:
    a1[2] = Size;
    a1[3] = v8;
    memcpy(v12, Src, Size);
    *((_BYTE *)v12 + Size) = 0;
    if ( n0xF <= 0xF )
    {
LABEL_24:
      *a1 = (__int64)v12;
      return a1;
    }
    v13 = *a1;
    if ( n0xF + 1 < 0x1000 )
    {
LABEL_23:
      sub_1402A3D30(v13);
      goto LABEL_24;
    }
    if ( (unsigned __int64)(v13 - *(_QWORD *)(v13 - 8) - 8) <= 0x1F )
    {
      v13 = *(_QWORD *)(v13 - 8);
      goto LABEL_23;
    }
LABEL_26:
    invalid_parameter_noinfo_noreturn();
  }
  v7 = a1;
  if ( n0xF > 0xF )
    v7 = (void *)*a1;
  a1[2] = Size;
  memmove(v7, Src, Size);
  *((_BYTE *)v7 + Size) = 0;
  return a1;
}

// --- End Function: sub_1402FAE70 (0x1402FAE70) ---

// --- Function: sub_1403090B0 (0x1403090B0) ---
__int64 __fastcall sub_1403090B0(unsigned int *a1)
{
  return *a1;
}

// --- End Function: sub_1403090B0 (0x1403090B0) ---

// --- Function: ?_Change_array@?$vector@V?$Triplet@NH@Eigen@@V?$allocator@V?$Triplet@NH@Eigen@@@std@@@std@@AEAAXQEAV?$Triplet@NH@Eigen@@_K1@Z (0x1403DEBC0) ---
void __fastcall std::vector<Eigen::Triplet<double,int>>::_Change_array(
        std::vector<Eigen::Triplet<double,int>> *this,
        Eigen::Triplet<double,int> *const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  __int64 v6; // rcx

  v6 = *(_QWORD *)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - v6) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_1402A3D30(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = (char *)_Newvec + 16 * _Newsize;
  *((_QWORD *)this + 2) = (char *)_Newvec + 16 * _Newcapacity;
}

// --- End Function: ?_Change_array@?$vector@V?$Triplet@NH@Eigen@@V?$allocator@V?$Triplet@NH@Eigen@@@std@@@std@@AEAAXQEAV?$Triplet@NH@Eigen@@_K1@Z (0x1403DEBC0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &word_14819E9C4,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_140C58D20 (0x140C58D20) ---
const void **__fastcall sub_140C58D20(const void **Src, unsigned __int64 a2, __int64 a3, size_t Size_1, char Val)
{
  size_t Size; // r14
  __int64 v6; // rbx
  size_t v9; // rbp
  unsigned __int64 v10; // rdx
  unsigned __int64 n0xF; // r13
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // rbp
  __int64 v17; // rbx

  Size = (size_t)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - Size < a2 )
    unknown_libname_9();
  v9 = Size + a2;
  v10 = (Size + a2) | 0xF;
  n0xF = (unsigned __int64)Src[3];
  if ( v10 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v10;
    if ( v10 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v15 = 0;
      else
        v15 = (_QWORD *)sub_1402A3D40(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = sub_1402A3D40(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = (const void *)v9;
  v16 = (char *)v15 + Size;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, Size);
    memset((char *)v15 + Size, Val, Size_1);
    v16[Size_1] = 0;
    goto LABEL_22;
  }
  v17 = (__int64)*Src;
  memcpy(v15, *Src, Size);
  memset((char *)v15 + Size, Val, Size_1);
  v16[Size_1] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v17 - *(_QWORD *)(v17 - 8) - 8) <= 0x1F )
    {
      v17 = *(_QWORD *)(v17 - 8);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_140C58D20 (0x140C58D20) ---

// --- Function: sub_140CB11B0 (0x140CB11B0) ---
const void **__fastcall sub_140CB11B0(_QWORD *a1, unsigned __int64 a2, char Val)
{
  unsigned __int64 v3; // r10
  unsigned __int64 *v4; // r9
  unsigned __int64 n0xF; // r11
  size_t Size; // rdi
  char *v7; // rbx
  const void **result; // rax
  unsigned __int8 v9; // [rsp+40h] [rbp+8h]

  v3 = a1[2];
  v4 = a1 + 2;
  if ( a2 > v3 )
  {
    n0xF = a1[3];
    Size = a2 - v3;
    if ( a2 - v3 > n0xF - v3 )
    {
      return sub_140C58D20((const void **)a1, a2 - v3, v9, a2 - v3, Val);
    }
    else
    {
      *v4 = a2;
      if ( n0xF > 0xF )
        a1 = (_QWORD *)*a1;
      v7 = (char *)a1 + v3;
      result = (const void **)memset((char *)a1 + v3, Val, Size);
      v7[Size] = 0;
    }
  }
  else
  {
    if ( a1[3] > 0xFu )
      a1 = (_QWORD *)*a1;
    *v4 = a2;
    *((_BYTE *)a1 + a2) = 0;
  }
  return result;
}

// --- End Function: sub_140CB11B0 (0x140CB11B0) ---

// --- Function: sub_140D0E630 (0x140D0E630) ---
__int64 __fastcall sub_140D0E630(__int64 a1)
{
  return sub_140D0E720(a1 + 8);
}

// --- End Function: sub_140D0E630 (0x140D0E630) ---

// --- Function: sub_140D0E640 (0x140D0E640) ---
__int64 __fastcall sub_140D0E640(unsigned __int64 *a1)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdx
  __int64 result; // rax
  __int64 v5; // [rsp+20h] [rbp-18h] BYREF
  __int64 *v6; // [rsp+28h] [rbp-10h]

  v2 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFFFFCuLL);
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v2 = (_QWORD *)*v2;
  if ( v2 )
  {
    sub_147BE0FE0(v2, &v5, 32);
    *v6 = v5;
    v6[1] = (__int64)sub_140D0E630;
    v3 = v5;
  }
  else
  {
    v3 = sub_1402A3D40(0x20u);
    if ( !v3 )
      goto LABEL_8;
  }
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 8) = 0;
LABEL_8:
  result = v3 + 8;
  *a1 = *(_DWORD *)a1 & 2 | (unsigned __int64)v3 | 1;
  *(_QWORD *)v3 = v2;
  return result;
}

// --- End Function: sub_140D0E640 (0x140D0E640) ---

// --- Function: sub_140D0E720 (0x140D0E720) ---
__int64 __fastcall sub_140D0E720(__int64 *a1)
{
  __int64 result; // rax
  __int64 v3; // rcx

  result = a1[1];
  if ( *a1 != result )
    result = sub_147BF2B20();
  v3 = *a1;
  if ( *a1 )
  {
    if ( ((a1[2] - v3) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = *(_QWORD *)(v3 - 8);
    }
    sub_1402A3D30(v3);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140D0E720 (0x140D0E720) ---

// --- Function: sub_140D13150 (0x140D13150) ---
char *__fastcall sub_140D13150(unsigned __int8 *a1, _QWORD *a2)
{
  __int64 v2; // r8
  char *result; // rax
  __int64 v5; // r8
  _QWORD v6[3]; // [rsp+20h] [rbp-18h] BYREF

  v2 = *a1;
  result = (char *)(a1 + 1);
  if ( (v2 & 0x80u) != 0LL )
  {
    v5 = ((unsigned __int8)*result << 7) + (int)v2 - 128;
    if ( *result < 0 )
    {
      sub_147BF2080(v6, a1, v5);
      *a2 = v6[1];
      return (char *)v6[0];
    }
    else
    {
      *a2 = (unsigned int)v5;
      return (char *)(a1 + 2);
    }
  }
  else
  {
    *a2 = v2;
  }
  return result;
}

// --- End Function: sub_140D13150 (0x140D13150) ---

// --- Function: sub_140F9EEF0 (0x140F9EEF0) ---
unsigned __int8 *__fastcall sub_140F9EEF0(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  int v6; // eax
  unsigned int n0x80; // edi
  unsigned __int8 *v8; // rsi
  unsigned __int64 v9; // rdx
  _QWORD *v10; // rdi
  _QWORD *v11; // rax
  const char *sc.internal.services.entitlement.v1.GrantCommand.Grant.account; // rdx
  __int128 v13; // xmm0
  unsigned __int8 *result; // rax
  unsigned __int64 v15; // rdx
  _QWORD *v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rdx
  _QWORD *v19; // rdi
  _QWORD *v20; // rax
  int v21; // edx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // edx
  __int64 v26; // rax
  __int64 v27; // r8
  unsigned __int64 v28; // rdx
  _QWORD *v29; // rdi
  _QWORD *v30; // rax
  unsigned __int64 v31; // rdx
  _QWORD *v32; // rdi
  _QWORD *v33; // rax
  unsigned __int64 v34; // rdx
  _QWORD *v35; // rdi
  _QWORD *v36; // rax
  unsigned int v37; // edx
  int v38; // edx
  int v39; // eax
  unsigned __int64 v40; // rdx
  _QWORD *v41; // rdi
  _QWORD *v42; // rax
  unsigned __int64 v43; // rdx
  _QWORD *v44; // rdi
  _QWORD *v45; // rax
  __int64 v46; // rax
  unsigned __int64 v47; // rcx
  __int64 v48; // rax
  unsigned __int64 v49; // rcx
  int v50; // edx
  int v51; // eax
  _QWORD *v52; // rcx
  unsigned __int64 v53; // rax
  _QWORD v54[3]; // [rsp+20h] [rbp-E8h] BYREF
  unsigned __int8 *v55; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v56; // [rsp+48h] [rbp-C0h]
  unsigned __int8 *v57; // [rsp+50h] [rbp-B8h] BYREF
  unsigned int n0x80_1; // [rsp+58h] [rbp-B0h]
  __int128 v59; // [rsp+68h] [rbp-A0h]
  __int128 v60; // [rsp+78h] [rbp-90h]
  __int128 v61; // [rsp+88h] [rbp-80h]
  unsigned __int8 *v62; // [rsp+98h] [rbp-70h] BYREF
  __int64 v63; // [rsp+A0h] [rbp-68h]
  unsigned __int8 *v64; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v65; // [rsp+B0h] [rbp-58h]
  _QWORD v66[2]; // [rsp+B8h] [rbp-50h] BYREF
  __int128 v67; // [rsp+C8h] [rbp-40h]
  __int128 v68; // [rsp+D8h] [rbp-30h]
  __int128 v69; // [rsp+E8h] [rbp-20h]
  unsigned __int8 *v70; // [rsp+F8h] [rbp-10h] BYREF
  unsigned int v71; // [rsp+100h] [rbp-8h]
  unsigned __int8 *v72; // [rsp+108h] [rbp+0h] BYREF
  __int64 v73; // [rsp+110h] [rbp+8h]
  __int128 v74; // [rsp+118h] [rbp+10h]
  __int128 v75; // [rsp+128h] [rbp+20h]
  unsigned __int8 *v76; // [rsp+138h] [rbp+30h] BYREF
  __int64 v77; // [rsp+140h] [rbp+38h]

  while ( (unsigned __int64)a2 < *(_QWORD *)a3 )
  {
LABEL_4:
    n0x80 = *a2;
    v8 = a2 + 1;
    if ( n0x80 >= 0x80 )
    {
      n0x80 = (*v8 << 7) + n0x80 - 128;
      if ( *v8 >= 0x80u )
      {
        sub_147BF1EE0(&v57, a2, n0x80);
        n0x80 = n0x80_1;
        v8 = v57;
      }
      else
      {
        v8 = a2 + 2;
      }
    }
    switch ( n0x80 >> 3 )
    {
      case 1u:
        if ( (_BYTE)n0x80 != 10 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v9 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v10 = (_QWORD *)sub_147BCA1B0(a1 + 16, v9);
        a2 = (unsigned __int8 *)sub_147BF17E0(v10);
        if ( !a2 )
          return 0;
        v11 = v10;
        if ( v10[3] > 0xFu )
          v11 = (_QWORD *)*v10;
        *(_QWORD *)&v59 = v11;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantCommand.Grant.urn";
        *((_QWORD *)&v59 + 1) = v10[2];
        v13 = v59;
        goto LABEL_17;
      case 2u:
        if ( (_BYTE)n0x80 != 18 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v15 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v15 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v16 = (_QWORD *)sub_147BCA1B0(a1 + 24, v15);
        a2 = (unsigned __int8 *)sub_147BF17E0(v16);
        if ( !a2 )
          return 0;
        v17 = v16;
        if ( v16[3] > 0xFu )
          v17 = (_QWORD *)*v16;
        *(_QWORD *)&v60 = v17;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantComman"
                                                                         "d.Grant.account_urn";
        *((_QWORD *)&v60 + 1) = v16[2];
        v13 = v60;
        goto LABEL_17;
      case 3u:
        if ( (_BYTE)n0x80 != 26 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v18 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v18 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v19 = (_QWORD *)sub_147BCA1B0(a1 + 32, v18);
        a2 = (unsigned __int8 *)sub_147BF17E0(v19);
        if ( !a2 )
          return 0;
        v20 = v19;
        if ( v19[3] > 0xFu )
          v20 = (_QWORD *)*v19;
        *(_QWORD *)&v61 = v20;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantComman"
                                                                         "d.Grant.player_urn";
        *((_QWORD *)&v61 + 1) = v19[2];
        v13 = v61;
        goto LABEL_17;
      case 4u:
        if ( (_BYTE)n0x80 != 32 )
          goto LABEL_139;
        v21 = *v8;
        if ( (v21 & 0x80u) != 0 )
        {
          if ( (v8[1] & 0x80u) != 0 )
          {
            sub_147BF2080(&v62, v8, v21 + (v8[1] << 7) - 128);
            v22 = v63;
            a2 = v62;
          }
          else
          {
            v22 = v21 + (v8[1] << 7) - 128;
            a2 = v8 + 2;
          }
        }
        else
        {
          v22 = *v8;
          a2 = v8 + 1;
        }
        if ( !a2 )
          return 0;
        *(_DWORD *)(a1 + 96) = v22;
        continue;
      case 5u:
        if ( (_BYTE)n0x80 != 40 )
          goto LABEL_139;
        v23 = *v8;
        if ( (v23 & 0x80u) != 0 )
        {
          if ( (v8[1] & 0x80u) != 0 )
          {
            sub_147BF2080(&v64, v8, v23 + (v8[1] << 7) - 128);
            v24 = v65;
            a2 = v64;
          }
          else
          {
            v24 = v23 + (v8[1] << 7) - 128;
            a2 = v8 + 2;
          }
        }
        else
        {
          v24 = *v8;
          a2 = v8 + 1;
        }
        if ( !a2 )
          return 0;
        *(_DWORD *)(a1 + 100) = v24;
        continue;
      case 6u:
        if ( (_BYTE)n0x80 != 48 )
          goto LABEL_139;
        v25 = *v8;
        if ( (v25 & 0x80u) != 0 )
        {
          v27 = v25 + (v8[1] << 7) - 128;
          if ( (v8[1] & 0x80u) != 0 )
          {
            sub_147BF2080(v66, v8, v27);
            v26 = v66[1];
            a2 = (unsigned __int8 *)v66[0];
          }
          else
          {
            v26 = (unsigned int)v27;
            a2 = v8 + 2;
          }
        }
        else
        {
          v26 = *v8;
          a2 = v8 + 1;
        }
        *(_BYTE *)(a1 + 104) = v26 != 0;
        if ( a2 )
          continue;
        return 0;
      case 7u:
        if ( (_BYTE)n0x80 != 58 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v28 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v28 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v29 = (_QWORD *)sub_147BCA1B0(a1 + 40, v28);
        a2 = (unsigned __int8 *)sub_147BF17E0(v29);
        if ( !a2 )
          return 0;
        v30 = v29;
        if ( v29[3] > 0xFu )
          v30 = (_QWORD *)*v29;
        *(_QWORD *)&v67 = v30;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantComman"
                                                                         "d.Grant.source_sku";
        *((_QWORD *)&v67 + 1) = v29[2];
        v13 = v67;
        goto LABEL_17;
      case 8u:
        if ( (_BYTE)n0x80 != 66 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v31 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v31 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v32 = (_QWORD *)sub_147BCA1B0(a1 + 48, v31);
        a2 = (unsigned __int8 *)sub_147BF17E0(v32);
        if ( !a2 )
          return 0;
        v33 = v32;
        if ( v32[3] > 0xFu )
          v33 = (_QWORD *)*v32;
        *(_QWORD *)&v68 = v33;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantCommand.Grant.name";
        *((_QWORD *)&v68 + 1) = v32[2];
        v13 = v68;
        goto LABEL_17;
      case 9u:
        if ( (_BYTE)n0x80 != 74 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v34 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v34 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v35 = (_QWORD *)sub_147BCA1B0(a1 + 56, v34);
        a2 = (unsigned __int8 *)sub_147BF17E0(v35);
        if ( !a2 )
          return 0;
        v36 = v35;
        if ( v35[3] > 0xFu )
          v36 = (_QWORD *)*v35;
        *(_QWORD *)&v69 = v36;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantComman"
                                                                         "d.Grant.entity_class_guid";
        *((_QWORD *)&v69 + 1) = v35[2];
        v13 = v69;
        goto LABEL_17;
      case 0xAu:
        if ( (_BYTE)n0x80 != 80 )
          goto LABEL_139;
        v37 = *v8;
        if ( (v37 & 0x80u) != 0 )
        {
          v37 = (v8[1] << 7) + v37 - 128;
          if ( (v8[1] & 0x80u) != 0 )
          {
            sub_147BF1FF0(&v70, v8, v37);
            v37 = v71;
            a2 = v70;
          }
          else
          {
            a2 = v8 + 2;
          }
        }
        else
        {
          a2 = v8 + 1;
        }
        *(_DWORD *)(a1 + 108) = v37;
        if ( a2 )
          continue;
        return 0;
      case 0xCu:
        if ( (_BYTE)n0x80 != 96 )
          goto LABEL_139;
        v38 = *v8;
        if ( (v38 & 0x80u) != 0 )
        {
          if ( (v8[1] & 0x80u) != 0 )
          {
            sub_147BF2080(&v72, v8, v38 + (v8[1] << 7) - 128);
            v39 = v73;
            a2 = v72;
          }
          else
          {
            v39 = v38 + (v8[1] << 7) - 128;
            a2 = v8 + 2;
          }
        }
        else
        {
          v39 = *v8;
          a2 = v8 + 1;
        }
        if ( !a2 )
          return 0;
        *(_DWORD *)(a1 + 112) = v39;
        continue;
      case 0xDu:
        if ( (_BYTE)n0x80 != 106 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v40 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v40 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v41 = (_QWORD *)sub_147BCA1B0(a1 + 64, v40);
        a2 = (unsigned __int8 *)sub_147BF17E0(v41);
        if ( !a2 )
          return 0;
        v42 = v41;
        if ( v41[3] > 0xFu )
          v42 = (_QWORD *)*v41;
        *(_QWORD *)&v74 = v42;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantComman"
                                                                         "d.Grant.log_message";
        *((_QWORD *)&v74 + 1) = v41[2];
        v13 = v74;
        goto LABEL_17;
      case 0xEu:
        if ( (_BYTE)n0x80 != 114 )
          goto LABEL_139;
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v43 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
        else
          v43 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
        v44 = (_QWORD *)sub_147BCA1B0(a1 + 72, v43);
        a2 = (unsigned __int8 *)sub_147BF17E0(v44);
        if ( !a2 )
          return 0;
        v45 = v44;
        if ( v44[3] > 0xFu )
          v45 = (_QWORD *)*v44;
        *(_QWORD *)&v75 = v45;
        sc.internal.services.entitlement.v1.GrantCommand.Grant.account = "sc.internal.services.entitlement.v1.GrantComman"
                                                                         "d.Grant.target_inventory";
        *((_QWORD *)&v75 + 1) = v44[2];
        v13 = v75;
LABEL_17:
        *(_OWORD *)&v54[1] = v13;
        if ( (unsigned __int8)sub_147BF2100(&v54[1], sc.internal.services.entitlement.v1.GrantCommand.Grant.account) )
          continue;
        return 0;
      case 0xFu:
        if ( (_BYTE)n0x80 != 122 )
          goto LABEL_139;
        v46 = *(_QWORD *)(a1 + 80);
        if ( !v46 )
        {
          if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
            v47 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
          else
            v47 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
          v46 = sub_14111A0C0(v47);
          *(_QWORD *)(a1 + 80) = v46;
        }
        a2 = (unsigned __int8 *)sub_147BF1C30(a3, v46, v8);
        if ( a2 )
          continue;
        return 0;
      case 0x10u:
        if ( (_BYTE)n0x80 != 0x82 )
          goto LABEL_139;
        v48 = *(_QWORD *)(a1 + 88);
        if ( !v48 )
        {
          if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
            v49 = *(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL);
          else
            v49 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFCuLL;
          v48 = sub_14111A370(v49);
          *(_QWORD *)(a1 + 88) = v48;
        }
        a2 = (unsigned __int8 *)sub_147BF1C30(a3, v48, v8);
        if ( a2 )
          continue;
        return 0;
      case 0x11u:
        if ( (_BYTE)n0x80 != 0x88 )
          goto LABEL_139;
        v50 = *v8;
        if ( (v50 & 0x80u) != 0 )
        {
          if ( (v8[1] & 0x80u) != 0 )
          {
            sub_147BF2080(&v76, v8, v50 + (v8[1] << 7) - 128);
            v51 = v77;
            a2 = v76;
          }
          else
          {
            v51 = v50 + (v8[1] << 7) - 128;
            a2 = v8 + 2;
          }
        }
        else
        {
          v51 = *v8;
          a2 = v8 + 1;
        }
        if ( !a2 )
          return 0;
        *(_DWORD *)(a1 + 116) = v51;
        continue;
      default:
LABEL_139:
        if ( !n0x80 || (n0x80 & 7) == 4 )
        {
          if ( !v8 )
            return 0;
          result = v8;
          *(_DWORD *)(a3 + 80) = n0x80 - 1;
          return result;
        }
        v52 = (_QWORD *)(a1 + 8);
        if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          v53 = (*v52 & 0xFFFFFFFFFFFFFFFCuLL) + 8;
        else
          v53 = sub_140D0E640(v52);
        a2 = (unsigned __int8 *)sub_147BF31D0(n0x80, v53, v8, a3);
        if ( !a2 )
          return 0;
        break;
    }
  }
  v6 = (_DWORD)a2 - *(_DWORD *)(a3 + 8);
  if ( v6 != *(_DWORD *)(a3 + 28) )
  {
    sub_147BF1510(a3, &v55, (unsigned int)v6, *(unsigned int *)(a3 + 92));
    a2 = v55;
    if ( (_BYTE)v56 )
      return a2;
    goto LABEL_4;
  }
  if ( v6 > 0 && !*(_QWORD *)(a3 + 16) )
    return 0;
  return a2;
}

// --- End Function: sub_140F9EEF0 (0x140F9EEF0) ---

// --- Function: sub_14111A0C0 (0x14111A0C0) ---
__int64 __fastcall sub_14111A0C0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = sub_147BE1260(a1, 40, 0);
    *(_QWORD *)(result + 8) = a1;
  }
  else
  {
    result = sub_1402A3D40(0x28u);
    if ( !result )
      return 0;
    *(_QWORD *)(result + 8) = 0;
  }
  *(_QWORD *)result = off_148397990;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = 0;
  return result;
}

// --- End Function: sub_14111A0C0 (0x14111A0C0) ---

// --- Function: sub_14111A370 (0x14111A370) ---
__int64 __fastcall sub_14111A370(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = sub_147BE1260(a1, 56, 0);
    *(_QWORD *)(result + 8) = a1;
    *(_QWORD *)result = &off_148397B58;
    *(_QWORD *)(result + 16) = a1;
  }
  else
  {
    result = sub_1402A3D40(0x38u);
    if ( !result )
      return 0;
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)result = &off_148397B58;
    *(_QWORD *)(result + 16) = 0;
  }
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 40) = &qword_15170F800;
  return result;
}

// --- End Function: sub_14111A370 (0x14111A370) ---

// --- Function: sub_147602930 (0x147602930) ---
__int64 __fastcall sub_147602930(__int64 a1)
{
  return sub_147602940(a1, 0);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147605980 (0x147605980) ---
__int64 __fastcall sub_147605980(const void *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898
      || (result = qword_149B00898 + 0x8000000000LL, (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL) )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      return sub_147602930((__int64)a1);
    }
  }
  return result;
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  unsigned __int8 v5; // bl
  __int64 v6; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    v5 = sub_14056A7D0(v4);
    v6 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v6 + allocSize, profilerInfo, v5);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ (0x1478AF9B0) ---
void __fastcall std::string::~string(std::string *this)
{
  unsigned __int64 n0x10; // rdx
  __int64 v3; // rcx

  n0x10 = *((_QWORD *)this + 3);
  if ( n0x10 >= 0x10 )
  {
    v3 = *(_QWORD *)this;
    if ( n0x10 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = *(_QWORD *)(v3 - 8);
    }
    sub_1402A3D30(v3);
  }
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 15;
  *(_BYTE *)this = 0;
}

// --- End Function: ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ (0x1478AF9B0) ---

// --- Function: unknown_libname_231 (0x1478B10A0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_231()
{
  std::_Xlength_error("vector<T> too long");
}

// --- End Function: unknown_libname_231 (0x1478B10A0) ---

// --- Function: sub_1479E2E90 (0x1479E2E90) ---
unsigned __int64 __fastcall sub_1479E2E90(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 n0x1000; // rax
  unsigned __int64 allocSize; // rcx
  __int64 v4; // rax
  __int64 v5; // rcx

  n0x1000 = 16 * a2;
  if ( a2 > 0xFFFFFFFFFFFFFFFLL )
  {
    n0x1000 = -1;
LABEL_4:
    allocSize = n0x1000 + 39;
    if ( n0x1000 + 39 < n0x1000 )
      allocSize = -1;
    v4 = sub_1402A3D40(allocSize);
    v5 = v4;
    if ( !v4 )
      invalid_parameter_noinfo_noreturn();
    n0x1000 = (v4 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
    *(_QWORD *)(n0x1000 - 8) = v5;
    return n0x1000;
  }
  if ( n0x1000 >= 0x1000 )
    goto LABEL_4;
  if ( n0x1000 )
    return sub_1402A3D40(16 * a2);
  return n0x1000;
}

// --- End Function: sub_1479E2E90 (0x1479E2E90) ---

// --- Function: sub_147BC9EB0 (0x147BC9EB0) ---
// attributes: thunk
__int64 sub_147BC9EB0()
{
  return sub_147BC9EC0();
}

// --- End Function: sub_147BC9EB0 (0x147BC9EB0) ---

// --- Function: sub_147BC9EC0 (0x147BC9EC0) ---
__int64 __fastcall sub_147BC9EC0(__int64 *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-28h] BYREF
  __int64 *v5; // [rsp+28h] [rbp-20h]
  __int64 v6; // [rsp+30h] [rbp-18h]

  v6 = -2;
  if ( a2 )
  {
    sub_147BE0FE0(a2, (__int64)&v4);
    *v5 = v4;
    v5[1] = (__int64)sub_1402B1D80;
    result = v4;
    *(_QWORD *)(v4 + 16) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 15;
    *(_BYTE *)result = 0;
    *a1 = result | 3;
  }
  else
  {
    result = sub_1402A3D40(0x20u);
    if ( result )
    {
      *(_QWORD *)(result + 16) = 0;
      *(_QWORD *)(result + 24) = 15;
      *(_BYTE *)result = 0;
      *a1 = result | 2;
    }
    else
    {
      *a1 = 2;
    }
  }
  return result;
}

// --- End Function: sub_147BC9EC0 (0x147BC9EC0) ---

// --- Function: sub_147BCA1B0 (0x147BCA1B0) ---
unsigned __int64 __fastcall sub_147BCA1B0(_QWORD *a1)
{
  if ( (*a1 & 2) != 0 )
    return *a1 & 0xFFFFFFFFFFFFFFFCuLL;
  else
    return sub_147BC9EB0();
}

// --- End Function: sub_147BCA1B0 (0x147BCA1B0) ---

// --- Function: sub_147BE05F0 (0x147BE05F0) ---
void __fastcall sub_147BE05F0(int a1, const char *a2, int a3, __int64 a4)
{
  const char *v4; // rdi
  __int64 v7; // rbx
  FILE *File; // rax
  Stream *Stream; // rax

  if ( a1 >= 0 )
  {
    v4 = (const char *)a4;
    if ( *(_QWORD *)(a4 + 24) >= 0x10u )
      v4 = *(const char **)a4;
    v7 = a1;
    File = __acrt_iob_func(2u);
    fprintf(File, "[libprotobuf %s %s:%d] %s\n", off_149B11BE0[v7], a2, a3, v4);// "INFO"
    Stream = __acrt_iob_func(2u);
    fflush(Stream);
  }
}

// --- End Function: sub_147BE05F0 (0x147BE05F0) ---

// --- Function: sub_147BE0710 (0x147BE0710) ---
// Hidden C++ exception states: #wind=1
_BYTE *__fastcall sub_147BE0710(_BYTE *p_pExceptionObject, __int64 a2, int a3, __int64 a4)
{
  *((_QWORD *)p_pExceptionObject + 1) = 0;
  *((_QWORD *)p_pExceptionObject + 2) = 0;
  *(_QWORD *)p_pExceptionObject = &google::protobuf::FatalException::`vftable';
  *((_QWORD *)p_pExceptionObject + 3) = a2;
  *((_DWORD *)p_pExceptionObject + 8) = a3;
  sub_1402FBA60((__int64)(p_pExceptionObject + 40), a4);
  return p_pExceptionObject;
}

// --- End Function: sub_147BE0710 (0x147BE0710) ---

// --- Function: sub_147BE0760 (0x147BE0760) ---
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_147BE0760(__int64 a1, int a2, __int64 a3, int a4)
{
  __int64 result; // rax

  *(_DWORD *)a1 = a2;
  result = a1;
  *(_QWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 15;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

// --- End Function: sub_147BE0760 (0x147BE0760) ---

// --- Function: ??1DsDevice@@QEAA@XZ (0x147BE0810) ---
// Hidden C++ exception states: #wind=1
void __fastcall DsDevice::~DsDevice(DsDevice *this)
{
  unsigned __int64 n0x10; // rdx
  __int64 v3; // rcx

  n0x10 = *((_QWORD *)this + 6);
  if ( n0x10 >= 0x10 )
  {
    v3 = *((_QWORD *)this + 3);
    if ( n0x10 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = *(_QWORD *)(v3 - 8);
    }
    sub_1402A3D30(v3);
  }
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 15;
  *((_BYTE *)this + 24) = 0;
}

// --- End Function: ??1DsDevice@@QEAA@XZ (0x147BE0810) ---

// --- Function: sub_147BE0880 (0x147BE0880) ---
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_147BE0880(__int64 a1, __int64 a2)
{
  return sub_147BE0AE0(a2);
}

// --- End Function: sub_147BE0880 (0x147BE0880) ---

// --- Function: sub_147BE0890 (0x147BE0890) ---
__int64 __fastcall sub_147BE0890(__int64 a1, unsigned __int64 *a2)
{
  const void *v3; // rax

  v3 = a2;
  if ( a2[3] >= 0x10 )
    v3 = (const void *)*a2;
  sub_1402E2330((const void **)(a1 + 24), v3, a2[2]);
  return a1;
}

// --- End Function: sub_147BE0890 (0x147BE0890) ---

// --- Function: sub_147BE0A00 (0x147BE0A00) ---
__int64 __fastcall sub_147BE0A00(__int64 a1, _BYTE *a2)
{
  unsigned __int64 Size; // r8

  Size = -1;
  do
    ++Size;
  while ( a2[Size] );
  sub_1402E2330((const void **)(a1 + 24), a2, Size);
  return a1;
}

// --- End Function: sub_147BE0A00 (0x147BE0A00) ---

// --- Function: sub_147BE0AE0 (0x147BE0AE0) ---
void __fastcall sub_147BE0AE0(__int64 a1)
{
  __int64 v2; // rdi
  _BYTE pExceptionObject[80]; // [rsp+20h] [rbp-68h] BYREF

  if ( *(_DWORD *)a1 == 3 || dword_15170F880 <= 0 )
  {
    v2 = a1 + 24;
    psub_147BE05F0(*(_DWORD *)a1, *(const char **)(a1 + 8), *(_DWORD *)(a1 + 16), a1 + 24);
  }
  else
  {
    v2 = a1 + 24;
  }
  if ( *(_DWORD *)a1 == 3 )
  {
    sub_147BE0710((__int64)pExceptionObject, *(_QWORD *)(a1 + 8), *(_DWORD *)(a1 + 16), v2);
    throw (google::protobuf::FatalException *)pExceptionObject;
  }
}

// --- End Function: sub_147BE0AE0 (0x147BE0AE0) ---

// --- Function: sub_147BE0BC0 (0x147BE0BC0) ---
__int64 __fastcall sub_147BE0BC0(_QWORD *a1, unsigned __int64 n0x10, __int64 a3)
{
  __int64 v5; // r8
  _QWORD *v6; // rcx
  __int64 v7; // r8

  if ( (a1[1] & 2) != 0 )
    return sub_147BE0EB0(a1, n0x10, a3);
  v5 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 6280LL;
  if ( *(_QWORD *)(v5 + 8) != *a1 )
  {
    v6 = (_QWORD *)a1[3];
    if ( v6 && *v6 == v5 )
      goto LABEL_6;
    return sub_147BE0EB0(a1, n0x10, a3);
  }
  v6 = *(_QWORD **)(v5 + 16);
LABEL_6:
  v7 = v6[5];
  if ( n0x10 > v6[6] - v7 )
    return sub_147BE0E80((__int64)v6, n0x10);
  v6[5] = v7 + n0x10;
  return v7;
}

// --- End Function: sub_147BE0BC0 (0x147BE0BC0) ---

// --- Function: sub_147BE0E80 (0x147BE0E80) ---
__int64 __fastcall sub_147BE0E80(_QWORD *a1, unsigned __int64 n0x10, __int128 *a3)
{
  __int64 result; // rax

  sub_147BE1480(a1, n0x10, a3);
  result = a1[5];
  a1[5] = result + n0x10;
  return result;
}

// --- End Function: sub_147BE0E80 (0x147BE0E80) ---

// --- Function: sub_147BE0EB0 (0x147BE0EB0) ---
__int64 __fastcall sub_147BE0EB0(_QWORD *a1, unsigned __int64 n0x10, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v6; // rdx
  _QWORD *v7; // rcx
  __int64 v8; // r9
  __int128 *v10; // rdi
  _QWORD *v11; // rax
  __int64 v12; // rdx

  v3 = a1[1];
  if ( (v3 & 2) != 0 )
  {
    (*(void (__fastcall **)(_QWORD, __int64, unsigned __int64))(**(_QWORD **)((v3 & 0xFFFFFFFFFFFFFFF8uLL) + 32) + 16LL))(
      *(_QWORD *)((v3 & 0xFFFFFFFFFFFFFFF8uLL) + 32),
      a3,
      n0x10);
    v6 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 6280LL;
    if ( *(_QWORD *)(v6 + 8) == *a1 )
    {
      v7 = *(_QWORD **)(v6 + 16);
LABEL_6:
      v8 = v7[5];
      if ( n0x10 > v7[6] - v8 )
        return sub_147BE0E80(v7, n0x10, (__int128 *)(a1[1] & 0xFFFFFFFFFFFFFFF8uLL));
      v7[5] = v8 + n0x10;
      return v8;
    }
    v7 = (_QWORD *)a1[3];
    if ( v7 && *v7 == v6 )
      goto LABEL_6;
    v3 = a1[1];
  }
  v10 = (__int128 *)(v3 & 0xFFFFFFFFFFFFFFF8uLL);
  v11 = sub_147BE1690(a1, *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 6280LL);
  v12 = v11[5];
  if ( n0x10 > v11[6] - v12 )
    return sub_147BE0E80(v11, n0x10, v10);
  v11[5] = v12 + n0x10;
  return v12;
}

// --- End Function: sub_147BE0EB0 (0x147BE0EB0) ---

// --- Function: sub_147BE0FE0 (0x147BE0FE0) ---
__int64 __fastcall sub_147BE0FE0(__int64 a1, __int64 a2)
{
  sub_147BE1000();
  return a2;
}

// --- End Function: sub_147BE0FE0 (0x147BE0FE0) ---

// --- Function: sub_147BE1000 (0x147BE1000) ---
_QWORD *__fastcall sub_147BE1000(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v5; // rcx
  _QWORD *v6; // r10
  __int64 v7; // r9
  __int64 v8; // rdx
  _QWORD *result; // rax

  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
    goto LABEL_9;
  v5 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 6280LL;
  if ( *(_QWORD *)(v5 + 8) != *(_QWORD *)a1 )
  {
    v6 = *(_QWORD **)(a1 + 24);
    if ( v6 && *v6 == v5 )
      goto LABEL_6;
LABEL_9:
    sub_147BE1120(a1, a2);
    return a2;
  }
  v6 = *(_QWORD **)(v5 + 16);
LABEL_6:
  v7 = v6[6];
  v8 = v6[5];
  if ( a3 + 16 <= (unsigned __int64)(v7 - v8) )
  {
    result = a2;
    v6[5] = v8 + a3;
    v6[6] = v7 - 16;
    *a2 = v8;
    a2[1] = v7 - 16;
  }
  else
  {
    sub_147BE10C0(v6, a2, a3, *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8uLL);
    return a2;
  }
  return result;
}

// --- End Function: sub_147BE1000 (0x147BE1000) ---

// --- Function: sub_147BE1260 (0x147BE1260) ---
// attributes: thunk
__int64 __fastcall sub_147BE1260(_QWORD *a1, unsigned __int64 a2, __int64 a3)
{
  return sub_147BE0BC0(a1, a2, a3);
}

// --- End Function: sub_147BE1260 (0x147BE1260) ---

// --- Function: sub_147BE1480 (0x147BE1480) ---
__int64 __fastcall sub_147BE1480(_QWORD *a1, unsigned __int64 n0x10, __int128 *a3)
{
  __int64 v5; // r8
  __m128i v6; // xmm1
  unsigned __int64 v7; // xmm0_8
  __int64 result; // rax
  __int64 v9[4]; // [rsp+28h] [rbp-20h] BYREF

  *(_QWORD *)(a1[1] + 16LL) = a1[6];
  v5 = a1[1];
  a1[3] += a1[5] - v5 - 24;
  v6 = *(__m128i *)sub_147BE1360(v9, a3, *(_QWORD *)(v5 + 8), n0x10);
  v7 = _mm_srli_si128(v6, 8).m128i_u64[0];
  a1[4] += v7;
  *(_QWORD *)v6.m128i_i64[0] = a1[1];
  result = v6.m128i_i64[0] + 24;
  *(_QWORD *)(v6.m128i_i64[0] + 8) = v7;
  *(_QWORD *)(v6.m128i_i64[0] + 16) = 0;
  a1[5] = v6.m128i_i64[0] + 24;
  a1[1] = v6.m128i_i64[0];
  a1[6] = v6.m128i_i64[0] + *(_QWORD *)(v6.m128i_i64[0] + 8);
  return result;
}

// --- End Function: sub_147BE1480 (0x147BE1480) ---

// --- Function: sub_147BE1690 (0x147BE1690) ---
_QWORD *__fastcall sub_147BE1690(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // r8
  signed __int64 v5; // rax
  signed __int64 v6; // rtt
  __int64 v7; // rcx
  __int128 v9; // [rsp+20h] [rbp-28h] BYREF
  __int64 v10[3]; // [rsp+30h] [rbp-18h] BYREF

  v2 = (_QWORD *)a1[2];
  if ( v2 )
  {
    while ( *v2 != a2 )
    {
      v2 = (_QWORD *)v2[2];
      if ( !v2 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    v9 = *(_OWORD *)sub_147BE1360(v10, (__int128 *)(a1[1] & 0xFFFFFFFFFFFFFFF8uLL), 0, 0x50u);
    v2 = (_QWORD *)sub_147BE1970(&v9, a2, 0);
    v5 = a1[2];
    do
    {
      v2[2] = v5;
      v6 = v5;
      v5 = _InterlockedCompareExchange64(a1 + 2, (signed __int64)v2, v5);
    }
    while ( v6 != v5 );
  }
  v7 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  *(_QWORD *)(v7 + 6296) = v2;
  *(_QWORD *)(v7 + 6288) = *a1;
  a1[3] = v2;
  return v2;
}

// --- End Function: sub_147BE1690 (0x147BE1690) ---

// --- Function: sub_147BEFC50 (0x147BEFC50) ---
// Hidden C++ exception states: #wind=4
void __fastcall sub_147BEFC50(__m128i *a1, __m128i *a2, const char *__3)
{
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 v10; // rbx
  const char *__2; // rax
  __int64 n2_3; // rax
  const char *p_; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 p___3; // rcx
  __int64 __5; // rcx
  _QWORD v19[2]; // [rsp+48h] [rbp-C0h] BYREF
  __int128 p___2; // [rsp+58h] [rbp-B0h] BYREF
  __int128 v21; // [rsp+68h] [rbp-A0h]
  const char *__4; // [rsp+78h] [rbp-90h] BYREF
  __int64 n2_2; // [rsp+88h] [rbp-80h]
  unsigned __int64 n15; // [rsp+90h] [rbp-78h]
  unsigned __int64 v25[2]; // [rsp+98h] [rbp-70h] BYREF
  __m128i si128; // [rsp+A8h] [rbp-60h]
  _QWORD v27[3]; // [rsp+B8h] [rbp-50h] BYREF
  unsigned __int64 n0x10; // [rsp+D0h] [rbp-38h]
  const char *__1; // [rsp+E8h] [rbp-20h] BYREF
  __int64 n2_1; // [rsp+F0h] [rbp-18h]
  const char *_a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send; // [rsp+118h] [rbp+10h] BYREF
  unsigned __int64 n74; // [rsp+120h] [rbp+18h]
  const char *_; // [rsp+148h] [rbp+40h] BYREF
  __int64 n2; // [rsp+150h] [rbp+48h]
  const char *p__; // [rsp+178h] [rbp+70h] BYREF
  __int64 v36; // [rsp+180h] [rbp+78h]
  const char *_contains_invalid_UTF_8_data_when; // [rsp+1A8h] [rbp+A0h] BYREF
  unsigned __int64 n34; // [rsp+1B0h] [rbp+A8h]
  _BYTE v39[56]; // [rsp+1D8h] [rbp+D0h] BYREF

  v19[1] = -2;
  n2_2 = 0;
  n15 = 15;
  LOBYTE(__4) = 0;
  *(_QWORD *)&v21 = 0;
  *((_QWORD *)&v21 + 1) = 15;
  LOBYTE(p___2) = 0;
  sub_1402FAE70((__int64 *)&p___2, (void *)&Source, 0);
  if ( a2->m128i_i64[1] )
  {
    v6 = *a2;
    if ( a1->m128i_i64[1] )
    {
      p__ = "'";
      v36 = 1;
      _contains_invalid_UTF_8_data_when = (const char *)v6.m128i_i64[0];
      n34 = _mm_srli_si128(v6, 8).m128i_u64[0];
      __1 = ".";
      n2_1 = 1;
      v7 = *a1;
      _a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send = (const char *)a1->m128i_i64[0];
      n74 = _mm_srli_si128(v7, 8).m128i_u64[0];
      _ = " '";
      n2 = 2;
      v8 = sub_147C66E30(
             (unsigned int)v27,
             (unsigned int)&_,
             (unsigned int)&_a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send,
             (unsigned int)&__1,
             (__int64)&_contains_invalid_UTF_8_data_when,
             (__int64)&p__);
      if ( &p___2 != (__int128 *)v8 )
      {
        std::string::~string((std::string *)&p___2);
        p___2 = *(_OWORD *)v8;
        v21 = *(_OWORD *)(v8 + 16);
        *(_QWORD *)(v8 + 16) = 0;
        *(_QWORD *)(v8 + 24) = 15;
        *(_BYTE *)v8 = 0;
      }
      if ( n0x10 >= 0x10 )
      {
        v9 = v27[0];
        if ( n0x10 + 1 >= 0x1000 )
        {
          v9 = *(_QWORD *)(v27[0] - 8LL);
          if ( (unsigned __int64)(v27[0] - v9 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
LABEL_15:
        sub_1402A3D30(v9);
      }
    }
    else
    {
      _ = "'";
      n2 = 1;
      _a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send = (const char *)v6.m128i_i64[0];
      n74 = _mm_srli_si128(v6, 8).m128i_u64[0];
      __1 = " '";
      n2_1 = 2;
      v10 = sub_147C66F70(v27, &__1, &_a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send, &_);
      if ( &p___2 != (__int128 *)v10 )
      {
        std::string::~string((std::string *)&p___2);
        p___2 = *(_OWORD *)v10;
        v21 = *(_OWORD *)(v10 + 16);
        *(_QWORD *)(v10 + 16) = 0;
        *(_QWORD *)(v10 + 24) = 15;
        *(_BYTE *)v10 = 0;
      }
      if ( n0x10 >= 0x10 )
      {
        v9 = v27[0];
        if ( n0x10 + 1 >= 0x1000 )
        {
          v9 = *(_QWORD *)(v27[0] - 8LL);
          if ( (unsigned __int64)(v27[0] - v9 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        goto LABEL_15;
      }
    }
  }
  __2 = (const char *)&__4;
  if ( n15 >= 0x10 )
    __2 = __4;
  _ = __2;
  n2 = n2_2;
  _a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send = " a protocol buffer. Use the 'bytes' type if you inten"
                                                                   "d to send raw bytes. ";
  n74 = 74;
  __1 = __3;
  n2_3 = -1;
  do
    ++n2_3;
  while ( __3[n2_3] );
  n2_1 = n2_3;
  _contains_invalid_UTF_8_data_when = " contains invalid UTF-8 data when ";
  n34 = 34;
  p_ = (const char *)&p___2;
  if ( *((_QWORD *)&v21 + 1) >= 0x10u )
    p_ = (const char *)p___2;
  p__ = p_;
  v36 = v21;
  v27[0] = "String field";
  v27[1] = 12;
  sub_147C66D70(
    (unsigned int)v25,
    (unsigned int)v27,
    (unsigned int)&p__,
    (unsigned int)&_contains_invalid_UTF_8_data_when,
    (__int64)&__1,
    (__int64)&_a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send,
    (__int64)&_);
  v14 = sub_147BE0760(
          (__int64)v39,
          2,
          (__int64)"D:\\grpc_build\\v1.49.2\\grpc\\third_party\\protobuf\\src\\google\\protobuf\\wire_format_lite.cc",
          618);
  v15 = sub_147BE0890(v14, v25);
  sub_147BE0880((__int64)v19, v15);
  DsDevice::~DsDevice((DsDevice *)v39);
  if ( si128.m128i_i64[1] >= 0x10uLL )
  {
    v16 = v25[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v16 = *(_QWORD *)(v25[0] - 8);
      if ( v25[0] - v16 - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A3D30(v16);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_1481AA760);
  LOBYTE(v25[0]) = 0;
  if ( *((_QWORD *)&v21 + 1) >= 0x10u )
  {
    p___3 = p___2;
    if ( (unsigned __int64)(*((_QWORD *)&v21 + 1) + 1LL) >= 0x1000 )
    {
      p___3 = *(_QWORD *)(p___2 - 8);
      if ( (unsigned __int64)(p___2 - p___3 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A3D30(p___3);
  }
  *(_QWORD *)&v21 = 0;
  *((_QWORD *)&v21 + 1) = 15;
  LOBYTE(p___2) = 0;
  if ( n15 >= 0x10 )
  {
    __5 = (__int64)__4;
    if ( n15 + 1 >= 0x1000 )
    {
      __5 = *((_QWORD *)__4 - 1);
      if ( (unsigned __int64)&__4[-__5 - 8] > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A3D30(__5);
  }
}

// --- End Function: sub_147BEFC50 (0x147BEFC50) ---

// --- Function: sub_147BF1510 (0x147BF1510) ---
__int64 __fastcall sub_147BF1510(__int64 a1, __int64 a2, int a3, int a4)
{
  unsigned int v5; // r12d
  __int64 v8; // rdx
  __int64 v9; // r8
  bool v10; // zf
  size_t n16; // rax
  __int128 v12; // xmm0
  bool v13; // cf
  int v14; // r9d
  __int64 v15; // rcx
  __int64 v16; // rax
  void *Src; // [rsp+20h] [rbp-58h] BYREF

  v5 = a3;
  if ( a3 <= *(_DWORD *)(a1 + 28) )
  {
    do
    {
      v8 = *(_QWORD *)(a1 + 16);
      if ( !v8 )
        goto LABEL_27;
      if ( v8 == a1 + 40 )
      {
        memmove((void *)(a1 + 40), *(const void **)(a1 + 8), 0x10u);
        if ( *(int *)(a1 + 84) <= 0 || a4 >= 0 && (unsigned __int8)sub_147BF1AD0(a1 + 40, v5, (unsigned int)a4) )
        {
LABEL_19:
          if ( *(_QWORD *)(a1 + 72) == 2 )
            *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 8) - a1 - 40;
          v9 = a1 + 56;
          *(_QWORD *)(a1 + 16) = 0;
          *(_QWORD *)(a1 + 8) = a1 + 56;
          v8 = a1 + 40;
          *(_DWORD *)(a1 + 24) = 0;
        }
        else
        {
          while ( 1 )
          {
            if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, void **, __int64))(**(_QWORD **)(a1 + 32) + 8LL))(
                    *(_QWORD *)(a1 + 32),
                    &Src,
                    a1 + 24) )
            {
              *(_DWORD *)(a1 + 84) = 0;
              goto LABEL_19;
            }
            n16 = *(int *)(a1 + 24);
            *(_DWORD *)(a1 + 84) -= n16;
            if ( (int)n16 > 16 )
              break;
            if ( (int)n16 > 0 )
            {
              memcpy((void *)(a1 + 56), Src, n16);
              v9 = *(int *)(a1 + 24) + a1 + 40;
              *(_QWORD *)(a1 + 16) = a1 + 40;
              goto LABEL_15;
            }
          }
          v9 = a1 + 56;
          v12 = *(_OWORD *)Src;
          *(_QWORD *)(a1 + 16) = Src;
          *(_OWORD *)(a1 + 56) = v12;
LABEL_15:
          v13 = *(_QWORD *)(a1 + 72) < 2u;
          *(_QWORD *)(a1 + 8) = v9;
          if ( !v13 )
            *(_QWORD *)(a1 + 72) = 1;
          v8 = a1 + 40;
        }
      }
      else
      {
        v9 = *(int *)(a1 + 24) + v8 - 16;
        *(_QWORD *)(a1 + 16) = a1 + 40;
        v10 = *(_QWORD *)(a1 + 72) == 1;
        *(_QWORD *)(a1 + 8) = v9;
        if ( v10 )
          *(_QWORD *)(a1 + 72) = 2;
      }
      if ( !v8 )
      {
LABEL_27:
        if ( v5 )
        {
          *(_QWORD *)a2 = 0;
        }
        else
        {
          v16 = *(_QWORD *)(a1 + 8);
          *(_QWORD *)a1 = v16;
          *(_DWORD *)(a1 + 80) = 1;
          *(_QWORD *)a2 = v16;
        }
        *(_BYTE *)(a2 + 8) = 1;
        return a2;
      }
      v14 = *(_DWORD *)(a1 + 28) + v8 - v9;
      v15 = v8 + (int)v5;
      v5 = v15 - v9;
      *(_DWORD *)(a1 + 28) = v14;
    }
    while ( (int)v15 - (int)v9 >= 0 );
    if ( v14 >= 0 )
      v14 = 0;
    *(_QWORD *)a1 = v9 + v14;
    *(_QWORD *)a2 = v15;
    *(_BYTE *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}

// --- End Function: sub_147BF1510 (0x147BF1510) ---

// --- Function: sub_147BF17E0 (0x147BF17E0) ---
__int64 __fastcall sub_147BF17E0(__int64 *a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 n0x80; // r8
  void *v6; // rbx
  __int64 n0x80_1; // rdi
  void *v9; // [rsp+20h] [rbp-18h] BYREF
  unsigned int n0x80_2; // [rsp+28h] [rbp-10h]

  n0x80 = *a2;
  if ( (unsigned int)n0x80 >= 0x80 )
  {
    sub_147BF1D50(&v9);
    n0x80 = n0x80_2;
    v6 = v9;
  }
  else
  {
    v6 = a2 + 1;
  }
  if ( !v6 )
    return 0;
  n0x80_1 = (int)n0x80;
  if ( (int)n0x80 > *(_QWORD *)(a3 + 8) - (_QWORD)v6 + 16LL )
    return sub_147BF1DF0(a3, v6, n0x80, a1);
  sub_1402FAE70(a1, v6, (int)n0x80);
  return (__int64)v6 + n0x80_1;
}

// --- End Function: sub_147BF17E0 (0x147BF17E0) ---

// --- Function: sub_147BF1890 (0x147BF1890) ---
__int64 __fastcall sub_147BF1890(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 result; // rax
  int v5; // eax
  bool v6; // sf
  int v7; // eax

  v2 = sub_147BF18F0(a1, 0, 0xFFFFFFFFLL);
  v3 = v2;
  if ( v2 )
  {
    v5 = v2 - *(_DWORD *)(a1 + 8);
    v6 = v5 + *(_DWORD *)(a1 + 28) < 0;
    *(_DWORD *)(a1 + 28) += v5;
    v7 = *(_DWORD *)(a1 + 28);
    if ( !v6 )
      v7 = 0;
    *(_QWORD *)a1 = *(_QWORD *)(a1 + 8) + v7;
    return v3;
  }
  else
  {
    *(_QWORD *)a1 = *(_QWORD *)(a1 + 8);
    result = 0;
    *(_DWORD *)(a1 + 80) = 1;
  }
  return result;
}

// --- End Function: sub_147BF1890 (0x147BF1890) ---

// --- Function: sub_147BF18F0 (0x147BF18F0) ---
__int64 __fastcall sub_147BF18F0(__int64 a1, unsigned int a2, int a3)
{
  __int64 v5; // rdx
  __int64 result; // rax
  __int64 v8; // rsi
  __int64 v9; // rdi
  __int64 v10; // rcx
  bool v11; // zf
  size_t n16; // rax
  __int64 v13; // rax
  __int128 v14; // xmm0
  void *Src; // [rsp+20h] [rbp-38h] BYREF

  v5 = *(_QWORD *)(a1 + 16);
  if ( !v5 )
    return 0;
  v8 = a1 + 40;
  v9 = a1 + 40;
  if ( v5 == a1 + 40 )
  {
    memmove((void *)(a1 + 40), *(const void **)(a1 + 8), 0x10u);
    if ( *(int *)(a1 + 84) <= 0 || a3 >= 0 && (unsigned __int8)sub_147BF1AD0(v9, a2, (unsigned int)a3) )
    {
LABEL_19:
      if ( *(_QWORD *)(a1 + 72) == 2 )
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 8) - a1 - 40;
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 8) = a1 + 56;
      result = v9;
      *(_DWORD *)(a1 + 24) = 0;
    }
    else
    {
      while ( 1 )
      {
        if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, void **, __int64))(**(_QWORD **)(a1 + 32) + 8LL))(
                *(_QWORD *)(a1 + 32),
                &Src,
                a1 + 24) )
        {
          *(_DWORD *)(a1 + 84) = 0;
          goto LABEL_19;
        }
        n16 = *(int *)(a1 + 24);
        *(_DWORD *)(a1 + 84) -= n16;
        if ( (int)n16 > 16 )
          break;
        if ( (int)n16 > 0 )
        {
          memcpy((void *)(a1 + 56), Src, n16);
          v13 = *(int *)(a1 + 24);
          *(_QWORD *)(a1 + 16) = v8;
          *(_QWORD *)(a1 + 8) = v13 + a1 + 40;
          goto LABEL_15;
        }
      }
      v14 = *(_OWORD *)Src;
      *(_QWORD *)(a1 + 16) = Src;
      *(_QWORD *)(a1 + 8) = a1 + 56;
      *(_OWORD *)(a1 + 56) = v14;
LABEL_15:
      if ( *(_QWORD *)(a1 + 72) >= 2u )
        *(_QWORD *)(a1 + 72) = 1;
      return v8;
    }
  }
  else
  {
    v10 = *(int *)(a1 + 24) + v5 - 16;
    *(_QWORD *)(a1 + 16) = v9;
    v11 = *(_QWORD *)(a1 + 72) == 1;
    *(_QWORD *)(a1 + 8) = v10;
    if ( v11 )
      *(_QWORD *)(a1 + 72) = 2;
    return v5;
  }
  return result;
}

// --- End Function: sub_147BF18F0 (0x147BF18F0) ---

// --- Function: sub_147BF1AD0 (0x147BF1AD0) ---
char __fastcall sub_147BF1AD0(__int64 a1, int a2, int a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int8 *v4; // rax
  __int64 n0x80; // r8
  signed int n0x80_1; // ecx
  unsigned __int8 *v9; // rax
  unsigned __int8 *v10; // [rsp+20h] [rbp-38h] BYREF
  int v11; // [rsp+28h] [rbp-30h]
  unsigned __int8 *v12; // [rsp+30h] [rbp-28h] BYREF
  signed int n0x80_2; // [rsp+38h] [rbp-20h]
  __int64 v14[3]; // [rsp+40h] [rbp-18h] BYREF

  v3 = a1 + 16;
  v4 = (unsigned __int8 *)(a1 + a2);
  if ( (unsigned __int64)v4 < a1 + 16 )
  {
    while ( 1 )
    {
      LODWORD(n0x80) = *v4;
      if ( (unsigned int)n0x80 >= 0x80 )
      {
        n0x80 = (v4[1] << 7) + (int)n0x80 - 128;
        if ( v4[1] >= 0x80u )
        {
          sub_147BF1EE0(&v10, v4, n0x80);
          LODWORD(n0x80) = v11;
          v4 = v10;
        }
        else
        {
          v4 += 2;
        }
      }
      else
      {
        ++v4;
      }
      if ( !v4 || (unsigned __int64)v4 > v3 )
        break;
      if ( !(_DWORD)n0x80 )
        return 1;
      switch ( n0x80 & 7 )
      {
        case 0LL:
          v4 = (unsigned __int8 *)sub_140D13150(v4, v14);
          if ( !v4 )
            return 0;
          break;
        case 1LL:
          v4 += 8;
          break;
        case 2LL:
          n0x80_1 = *v4;
          if ( (unsigned int)n0x80_1 >= 0x80 )
          {
            sub_147BF1D50(&v12);
            v9 = v12;
            n0x80_1 = n0x80_2;
          }
          else
          {
            v9 = v4 + 1;
          }
          if ( !v9 || n0x80_1 > (__int64)(v3 - (_QWORD)v9) )
            return 0;
          v4 = &v9[n0x80_1];
          break;
        case 3LL:
          ++a3;
          break;
        case 4LL:
          if ( --a3 < 0 )
            return 1;
          break;
        case 5LL:
          v4 += 4;
          break;
        default:
          return 0;
      }
      if ( (unsigned __int64)v4 >= v3 )
        return 0;
    }
  }
  return 0;
}

// --- End Function: sub_147BF1AD0 (0x147BF1AD0) ---

// --- Function: sub_147BF1C30 (0x147BF1C30) ---
__int64 __fastcall sub_147BF1C30(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax
  __int64 v6; // rcx
  bool v7; // sf
  int v8; // eax
  int v10; // [rsp+30h] [rbp+8h] BYREF

  v5 = sub_147BF1CC0(a1, a3, &v10);
  if ( v5 )
    v6 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a2 + 72LL))(a2, v5, a1);
  else
    v6 = 0;
  ++*(_DWORD *)(a1 + 88);
  if ( *(_DWORD *)(a1 + 80) )
    return 0;
  v7 = v10 + *(_DWORD *)(a1 + 28) < 0;
  *(_DWORD *)(a1 + 28) += v10;
  v8 = *(_DWORD *)(a1 + 28);
  if ( !v7 )
    v8 = 0;
  *(_QWORD *)a1 = *(_QWORD *)(a1 + 8) + v8;
  return v6;
}

// --- End Function: sub_147BF1C30 (0x147BF1C30) ---

// --- Function: sub_147BF1CC0 (0x147BF1CC0) ---
unsigned __int8 *__fastcall sub_147BF1CC0(__int64 a1, unsigned __int8 *a2, int *a3)
{
  unsigned int n0x80; // r8d
  unsigned __int8 *v6; // rdx
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  unsigned __int8 *v12; // [rsp+20h] [rbp-18h] BYREF
  unsigned int n0x80_1; // [rsp+28h] [rbp-10h]

  n0x80 = *a2;
  if ( n0x80 >= 0x80 )
  {
    sub_147BF1D50(&v12);
    v6 = v12;
    n0x80 = n0x80_1;
  }
  else
  {
    v6 = a2 + 1;
  }
  if ( v6 )
  {
    v8 = n0x80 + (_DWORD)v6 - *(_DWORD *)(a1 + 8);
    v9 = v8;
    if ( v8 >= 0 )
      v9 = 0;
    *(_QWORD *)a1 = *(_QWORD *)(a1 + 8) + v9;
    v10 = *(_DWORD *)(a1 + 28) - v8;
    *(_DWORD *)(a1 + 28) = v8;
    *a3 = v10;
    if ( --*(_DWORD *)(a1 + 88) < 0 )
      return 0;
    return v6;
  }
  else
  {
    *a3 = 0;
    return 0;
  }
}

// --- End Function: sub_147BF1CC0 (0x147BF1CC0) ---

// --- Function: sub_147BF1D50 (0x147BF1D50) ---
__int64 __fastcall sub_147BF1D50(__int64 a1, __int64 a2, int a3)
{
  unsigned __int8 *v4; // r11
  unsigned int n7; // ecx
  unsigned int v6; // ebx
  unsigned int n0x80; // r9d
  unsigned int n8; // ecx
  unsigned int n0x7FFFFFEF; // ecx
  __int64 result; // rax

  v4 = (unsigned __int8 *)(a2 + 1);
  n7 = 7;
  v6 = 1;
  do
  {
    n0x80 = *v4;
    a3 += (n0x80 - 1) << n7;
    if ( n0x80 < 0x80 )
    {
      *(_QWORD *)a1 = v6 + a2 + 1;
      result = a1;
      *(_DWORD *)(a1 + 8) = a3;
      return result;
    }
    ++v6;
    n7 += 7;
    ++v4;
  }
  while ( n7 < 0x1C );
  n8 = *(unsigned __int8 *)(a2 + 4);
  if ( n8 >= 8 || (n0x7FFFFFEF = a3 + ((n8 + 15) << 28), n0x7FFFFFEF > 0x7FFFFFEF) )
  {
    *(_QWORD *)a1 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = n0x7FFFFFEF;
    *(_QWORD *)a1 = a2 + 5;
    return a1;
  }
}

// --- End Function: sub_147BF1D50 (0x147BF1D50) ---

// --- Function: sub_147BF1DF0 (0x147BF1DF0) ---
char *__fastcall sub_147BF1DF0(__int64 a1, char *a2, int n50000000_1, __int64 a4)
{
  bool v4; // cf
  int Size_1; // ebp
  char *v7; // rbx
  _BYTE *v9; // rax
  __int64 v10; // rdi
  int n50000000; // eax
  int Size; // edi
  __int64 v13; // rax

  v4 = *(_QWORD *)(a4 + 24) < 0x10u;
  Size_1 = n50000000_1;
  v7 = a2;
  *(_QWORD *)(a4 + 16) = 0;
  v9 = (_BYTE *)a4;
  if ( !v4 )
    v9 = *(_BYTE **)a4;
  *v9 = 0;
  v10 = *(_QWORD *)(a1 + 8);
  if ( n50000000_1 <= v10 + *(int *)(a1 + 28) - (_QWORD)a2 )
  {
    n50000000 = n50000000_1;
    if ( n50000000_1 > 50000000 )
      n50000000 = 50000000;
    sub_1402E39E0(a4, *(_QWORD *)(a4 + 16) + n50000000);
    LODWORD(v10) = *(_DWORD *)(a1 + 8);
  }
  Size = v10 - (_DWORD)v7 + 16;
  while ( *(_QWORD *)(a1 + 16) )
  {
    sub_1402E2330((const void **)a4, v7, Size);
    Size_1 -= Size;
    if ( *(int *)(a1 + 28) <= 16 )
      break;
    v13 = sub_147BF1890(a1);
    if ( !v13 )
      break;
    v7 = (char *)(v13 + 16);
    Size = *(_DWORD *)(a1 + 8) - v13;
    if ( Size_1 <= Size )
    {
      sub_1402E2330((const void **)a4, v7, Size_1);
      return &v7[Size_1];
    }
  }
  return 0;
}

// --- End Function: sub_147BF1DF0 (0x147BF1DF0) ---

// --- Function: sub_147BF1EE0 (0x147BF1EE0) ---
__int64 __fastcall sub_147BF1EE0(__int64 a1, __int64 a2, int a3)
{
  unsigned __int8 *v4; // r10
  unsigned int n14; // ecx
  unsigned int n2; // r11d
  unsigned int n0x80; // r9d

  v4 = (unsigned __int8 *)(a2 + 2);
  n14 = 14;
  n2 = 2;
  while ( 1 )
  {
    n0x80 = *v4;
    a3 += (n0x80 - 1) << n14;
    if ( n0x80 < 0x80 )
      break;
    ++n2;
    n14 += 7;
    ++v4;
    if ( n14 >= 0x23 )
    {
      *(_QWORD *)a1 = 0;
      *(_DWORD *)(a1 + 8) = 0;
      return a1;
    }
  }
  *(_DWORD *)(a1 + 8) = a3;
  *(_QWORD *)a1 = n2 + a2 + 1;
  return a1;
}

// --- End Function: sub_147BF1EE0 (0x147BF1EE0) ---

// --- Function: sub_147BF1FF0 (0x147BF1FF0) ---
__int64 __fastcall sub_147BF1FF0(__int64 a1, __int64 a2, int a3)
{
  unsigned __int8 *v4; // r10
  unsigned int n14; // ecx
  unsigned int n2; // ebx
  unsigned int n0x80; // r9d
  __int64 n2_1; // rax
  _BYTE *i; // rcx

  v4 = (unsigned __int8 *)(a2 + 2);
  n14 = 14;
  n2 = 2;
  do
  {
    n0x80 = *v4;
    a3 += (n0x80 - 1) << n14;
    if ( n0x80 < 0x80 )
    {
      n2_1 = n2;
      goto LABEL_9;
    }
    ++n2;
    n14 += 7;
    ++v4;
  }
  while ( n14 < 0x23 );
  n2_1 = 5;
  for ( i = (_BYTE *)(a2 + 5); *i >= 0x80u; ++i )
  {
    n2_1 = (unsigned int)(n2_1 + 1);
    if ( (unsigned int)n2_1 >= 0xA )
    {
      *(_QWORD *)a1 = 0;
      *(_DWORD *)(a1 + 8) = 0;
      return a1;
    }
  }
LABEL_9:
  *(_DWORD *)(a1 + 8) = a3;
  *(_QWORD *)a1 = n2_1 + a2 + 1;
  return a1;
}

// --- End Function: sub_147BF1FF0 (0x147BF1FF0) ---

// --- Function: sub_147BF2080 (0x147BF2080) ---
_QWORD *__fastcall sub_147BF2080(_QWORD *a1, __int64 a2, unsigned int a3)
{
  __int64 v4; // rbx
  unsigned int n14; // ecx
  unsigned __int8 *v6; // r9
  unsigned int n2; // r10d
  unsigned __int64 n0x80; // r8
  _QWORD *result; // rax

  v4 = a3;
  n14 = 14;
  v6 = (unsigned __int8 *)(a2 + 2);
  n2 = 2;
  while ( 1 )
  {
    n0x80 = *v6;
    v4 += (n0x80 - 1) << n14;
    if ( n0x80 < 0x80 )
      break;
    ++n2;
    n14 += 7;
    ++v6;
    if ( n14 >= 0x46 )
    {
      *a1 = 0;
      a1[1] = 0;
      return a1;
    }
  }
  a1[1] = v4;
  result = a1;
  *a1 = n2 + a2 + 1;
  return result;
}

// --- End Function: sub_147BF2080 (0x147BF2080) ---

// --- Function: sub_147BF2100 (0x147BF2100) ---
char __fastcall sub_147BF2100(__m128i *a1, unsigned __int64 a2)
{
  __int64 v3; // rax
  __m128i v4; // xmm0
  __m128i v6; // [rsp+20h] [rbp-28h] BYREF
  __m128i v7; // [rsp+30h] [rbp-18h] BYREF

  if ( (unsigned __int8)sub_147C7CED0(a1->m128i_i64[0], _mm_srli_si128(*a1, 8).m128i_u64[0]) )
    return 1;
  v6 = (__m128i)a2;
  if ( a2 )
  {
    v3 = -1;
    do
      ++v3;
    while ( *(_BYTE *)(a2 + v3) );
    v6.m128i_i64[1] = v3;
  }
  v4 = v6;
  v6.m128i_i64[1] = 0;
  v6.m128i_i64[0] = (__int64)&Source;
  v7 = v4;
  sub_147BEFC50(&v6, &v7, "parsing");
  return 0;
}

// --- End Function: sub_147BF2100 (0x147BF2100) ---

// --- Function: sub_147BF2290 (0x147BF2290) ---
// Hidden C++ exception states: #wind=1
unsigned __int8 *__fastcall sub_147BF2290(unsigned __int64 a1, _QWORD *a2, unsigned __int8 *a3, __int64 a4)
{
  unsigned __int64 v7; // rsi
  char *v8; // rbx
  unsigned __int8 *result; // rax
  __int64 v10; // rax
  __int64 *v11; // rbp
  int n0x80; // r8d
  char *v13; // rbx
  __int64 n0x80_1; // rsi
  char *v15; // rbx
  int v17; // ecx
  __int64 v18; // rax
  __int64 v19; // rax
  unsigned int v20; // eax
  _BYTE v21[8]; // [rsp+20h] [rbp-88h] BYREF
  __int64 v22; // [rsp+28h] [rbp-80h] BYREF
  int n0x80_2; // [rsp+30h] [rbp-78h]
  __int64 v24; // [rsp+38h] [rbp-70h]
  _BYTE v25[56]; // [rsp+40h] [rbp-68h] BYREF

  v24 = -2;
  v7 = a1 >> 3;
  if ( !(unsigned int)(a1 >> 3) )
    return 0;
  switch ( a1 & 7 )
  {
    case 0uLL:
      v8 = sub_140D13150(a3, &v22);
      if ( !v8 )
        return 0;
      sub_147BF2AE0(*a2, (unsigned int)v7, v22);
      return (unsigned __int8 *)v8;
    case 1uLL:
      v10 = sub_1402A2660((__int64)a3);
      sub_147BF29A0(*a2, (unsigned int)v7, v10);
      return a3 + 8;
    case 2uLL:
      v11 = (__int64 *)sub_147BF2A60(*a2, (unsigned int)v7);
      n0x80 = *a3;
      if ( (unsigned int)n0x80 >= 0x80 )
      {
        sub_147BF1D50((__int64)&v22, (__int64)a3, n0x80);
        v13 = (char *)v22;
        n0x80 = n0x80_2;
      }
      else
      {
        v13 = (char *)(a3 + 1);
      }
      if ( !v13 )
        return 0;
      n0x80_1 = n0x80;
      if ( n0x80 > *(_QWORD *)(a4 + 8) - (_QWORD)v13 + 16LL )
      {
        v15 = sub_147BF1DF0(a4, v13, n0x80, (__int64)v11);
      }
      else
      {
        sub_1402FAE70(v11, v13, n0x80);
        v15 = &v13[n0x80_1];
      }
      goto LABEL_12;
    case 3uLL:
      v22 = sub_147BF29E0(*a2, (unsigned int)v7);
      if ( --*(_DWORD *)(a4 + 88) < 0 )
        return 0;
      ++*(_DWORD *)(a4 + 92);
      v15 = (char *)sub_147BF24D0(&v22, a3, a4);
      --*(_DWORD *)(a4 + 92);
      ++*(_DWORD *)(a4 + 88);
      v17 = *(_DWORD *)(a4 + 80);
      *(_DWORD *)(a4 + 80) = 0;
      if ( v17 != 8 * (_DWORD)v7 + 3 )
        return 0;
LABEL_12:
      if ( !v15 )
        return 0;
      goto LABEL_20;
    case 4uLL:
      v18 = sub_147BE0760(
              (__int64)v25,
              3,
              (__int64)"D:\\grpc_build\\v1.49.2\\grpc\\third_party\\protobuf\\src\\google/protobuf/parse_context.h",
              912);
      v19 = sub_147BE0A00(v18, "Can't happen");
      sub_147BE0880((__int64)v21, v19);
      DsDevice::~DsDevice((DsDevice *)v25);
      return a3;
    case 5uLL:
      v20 = sub_1403090B0((unsigned int *)a3);
      v15 = (char *)(a3 + 4);
      sub_147BF2960(*a2, (unsigned int)v7, v20);
LABEL_20:
      result = (unsigned __int8 *)v15;
      break;
    default:
      return 0;
  }
  return result;
}

// --- End Function: sub_147BF2290 (0x147BF2290) ---

// --- Function: sub_147BF24D0 (0x147BF24D0) ---
unsigned __int8 *__fastcall sub_147BF24D0(_QWORD *a1, unsigned __int8 *a2, __int64 a3)
{
  int v5; // eax
  unsigned int n0x80; // r8d
  unsigned __int8 *v7; // r10
  unsigned __int8 *v9; // [rsp+20h] [rbp-38h] BYREF
  char v10; // [rsp+28h] [rbp-30h]
  unsigned __int8 *v11; // [rsp+30h] [rbp-28h] BYREF
  unsigned int n0x80_1; // [rsp+38h] [rbp-20h]

  while ( 1 )
  {
    if ( (unsigned __int64)a2 < *(_QWORD *)a3 )
      goto LABEL_4;
    v5 = (_DWORD)a2 - *(_DWORD *)(a3 + 8);
    if ( v5 == *(_DWORD *)(a3 + 28) )
      break;
    sub_147BF1510(a3, (__int64)&v9, v5, *(_DWORD *)(a3 + 92));
    a2 = v9;
    if ( v10 )
      return a2;
LABEL_4:
    n0x80 = *a2;
    v7 = a2 + 1;
    if ( n0x80 >= 0x80 )
    {
      n0x80 = (*v7 << 7) + n0x80 - 128;
      if ( *v7 >= 0x80u )
      {
        sub_147BF1EE0((__int64)&v11, (__int64)a2, n0x80);
        n0x80 = n0x80_1;
        v7 = v11;
      }
      else
      {
        v7 = a2 + 2;
      }
    }
    if ( !v7 )
      return 0;
    if ( !n0x80 || (n0x80 & 7) == 4 )
    {
      *(_DWORD *)(a3 + 80) = n0x80 - 1;
      return v7;
    }
    a2 = sub_147BF2290(n0x80, a1, v7, a3);
    if ( !a2 )
      return 0;
  }
  if ( v5 > 0 && !*(_QWORD *)(a3 + 16) )
    return 0;
  return a2;
}

// --- End Function: sub_147BF24D0 (0x147BF24D0) ---

// --- Function: sub_147BF25E0 (0x147BF25E0) ---
unsigned __int64 __fastcall sub_147BF25E0(__int64 a1, _BYTE *a2, _OWORD *a3)
{
  _BYTE *v6; // rcx
  signed __int64 v7; // rsi
  __int64 v8; // rax
  unsigned __int64 _Newsize; // r15
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int64 _Newcapacity; // rbx
  char *_Newvec; // r14
  unsigned __int64 v14; // rsi
  _BYTE *v15; // r8
  _BYTE *v16; // rdx
  char *_Newvec_1; // rcx
  size_t Size; // r8

  v6 = *(_BYTE **)a1;
  v7 = a2 - v6;
  v8 = (__int64)(*(_QWORD *)(a1 + 8) - (_QWORD)v6) >> 4;
  if ( v8 == 0xFFFFFFFFFFFFFFFLL )
    unknown_libname_231(v6);
  _Newsize = v8 + 1;
  v10 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v6) >> 4;
  v11 = v10 >> 1;
  if ( v10 <= 0xFFFFFFFFFFFFFFFLL - (v10 >> 1) )
  {
    _Newcapacity = v11 + v10;
    if ( v11 + v10 < _Newsize )
      _Newcapacity = _Newsize;
  }
  else
  {
    _Newcapacity = _Newsize;
  }
  _Newvec = (char *)sub_1479E2E90(a1, _Newcapacity);
  v14 = v7 & 0xFFFFFFFFFFFFFFF0uLL;
  *(_OWORD *)&_Newvec[v14] = *a3;
  v15 = *(_BYTE **)(a1 + 8);
  v16 = *(_BYTE **)a1;
  _Newvec_1 = _Newvec;
  if ( a2 == v15 )
  {
    Size = v15 - v16;
  }
  else
  {
    memmove(_Newvec, v16, a2 - v16);
    _Newvec_1 = &_Newvec[v14 + 16];
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v16 = a2;
  }
  memmove(_Newvec_1, v16, Size);
  std::vector<Eigen::Triplet<double,int>>::_Change_array(
    (std::vector<Eigen::Triplet<double,int>> *)a1,
    (Eigen::Triplet<double,int> *const)_Newvec,
    _Newsize,
    _Newcapacity);
  return v14 + *(_QWORD *)a1;
}

// --- End Function: sub_147BF25E0 (0x147BF25E0) ---

// --- Function: sub_147BF2960 (0x147BF2960) ---
unsigned __int64 __fastcall sub_147BF2960(__int64 a1, unsigned int a2, int a3)
{
  _BYTE *v3; // rdx
  unsigned __int64 result; // rax
  __int128 v5; // [rsp+20h] [rbp-18h] BYREF

  *(_QWORD *)&v5 = a2 | 0x100000000LL;
  v3 = *(_BYTE **)(a1 + 8);
  DWORD2(v5) = a3;
  if ( *(_BYTE **)(a1 + 16) == v3 )
    return sub_147BF25E0(a1, v3, &v5);
  *(_OWORD *)v3 = v5;
  *(_QWORD *)(a1 + 8) += 16LL;
  return result;
}

// --- End Function: sub_147BF2960 (0x147BF2960) ---

// --- Function: sub_147BF29A0 (0x147BF29A0) ---
unsigned __int64 __fastcall sub_147BF29A0(__int64 a1, unsigned int a2, __int64 a3)
{
  _BYTE *v3; // rdx
  unsigned __int64 result; // rax
  __int128 v5; // [rsp+20h] [rbp-18h] BYREF

  *(_QWORD *)&v5 = a2 | 0x200000000LL;
  v3 = *(_BYTE **)(a1 + 8);
  *((_QWORD *)&v5 + 1) = a3;
  if ( *(_BYTE **)(a1 + 16) == v3 )
    return sub_147BF25E0(a1, v3, &v5);
  *(_OWORD *)v3 = v5;
  *(_QWORD *)(a1 + 8) += 16LL;
  return result;
}

// --- End Function: sub_147BF29A0 (0x147BF29A0) ---

// --- Function: sub_147BF29E0 (0x147BF29E0) ---
_QWORD *__fastcall sub_147BF29E0(__int64 a1, unsigned int a2)
{
  _QWORD *result; // rax
  _BYTE *v4; // rdx
  __int128 v5; // [rsp+20h] [rbp-18h] BYREF

  *(_QWORD *)&v5 = a2 | 0x400000000LL;
  result = (_QWORD *)sub_1402A3D40(0x18u);
  if ( result )
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  else
  {
    result = 0;
  }
  v4 = *(_BYTE **)(a1 + 8);
  *((_QWORD *)&v5 + 1) = result;
  if ( *(_BYTE **)(a1 + 16) == v4 )
  {
    sub_147BF25E0(a1, v4, &v5);
    return (_QWORD *)*((_QWORD *)&v5 + 1);
  }
  else
  {
    *(_OWORD *)v4 = v5;
    *(_QWORD *)(a1 + 8) += 16LL;
  }
  return result;
}

// --- End Function: sub_147BF29E0 (0x147BF29E0) ---

// --- Function: sub_147BF2A60 (0x147BF2A60) ---
__int64 __fastcall sub_147BF2A60(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  _BYTE *v4; // rdx
  __int128 v5; // [rsp+20h] [rbp-18h] BYREF

  *(_QWORD *)&v5 = a2 | 0x300000000LL;
  result = sub_1402A3D40(0x20u);
  if ( result )
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 15;
    *(_BYTE *)result = 0;
  }
  v4 = *(_BYTE **)(a1 + 8);
  *((_QWORD *)&v5 + 1) = result;
  if ( *(_BYTE **)(a1 + 16) == v4 )
  {
    sub_147BF25E0(a1, v4, &v5);
    return *((_QWORD *)&v5 + 1);
  }
  else
  {
    *(_OWORD *)v4 = v5;
    *(_QWORD *)(a1 + 8) += 16LL;
  }
  return result;
}

// --- End Function: sub_147BF2A60 (0x147BF2A60) ---

// --- Function: sub_147BF2AE0 (0x147BF2AE0) ---
unsigned __int64 __fastcall sub_147BF2AE0(__int64 a1, unsigned int a2, __int64 a3)
{
  _BYTE *v3; // rdx
  unsigned __int64 result; // rax
  __int128 v5; // [rsp+20h] [rbp-18h] BYREF

  *(_QWORD *)&v5 = a2;
  v3 = *(_BYTE **)(a1 + 8);
  *((_QWORD *)&v5 + 1) = a3;
  if ( *(_BYTE **)(a1 + 16) == v3 )
    return sub_147BF25E0(a1, v3, &v5);
  *(_OWORD *)v3 = v5;
  *(_QWORD *)(a1 + 8) += 16LL;
  return result;
}

// --- End Function: sub_147BF2AE0 (0x147BF2AE0) ---

// --- Function: sub_147BF2B20 (0x147BF2B20) ---
__int64 __fastcall sub_147BF2B20(__int64 *a1)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = (a1[1] - *a1) >> 4;
  do
  {
    LODWORD(v2) = v2 - 1;
    sub_147BF2C10(*a1 + 16LL * (int)v2);
  }
  while ( (int)v2 > 0 );
  result = *a1;
  a1[1] = *a1;
  return result;
}

// --- End Function: sub_147BF2B20 (0x147BF2B20) ---

// --- Function: sub_147BF2C10 (0x147BF2C10) ---
__int64 __fastcall sub_147BF2C10(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  __int64 v3; // rcx

  if ( *(_DWORD *)(a1 + 4) == 3 )
  {
    v3 = *(_QWORD *)(a1 + 8);
    if ( v3 )
      return sub_1402FBBA0(v3, 1);
  }
  else if ( *(_DWORD *)(a1 + 4) == 4 )
  {
    v1 = *(_QWORD *)(a1 + 8);
    if ( v1 )
    {
      sub_140D0E720(*(__int64 **)(a1 + 8));
      return sub_1402A3D30(v1);
    }
  }
  return result;
}

// --- End Function: sub_147BF2C10 (0x147BF2C10) ---

// --- Function: sub_147BF31D0 (0x147BF31D0) ---
unsigned __int8 *__fastcall sub_147BF31D0(unsigned __int64 n0x80, __int64 a2, unsigned __int8 *a3, __int64 a4)
{
  __int64 v5; // [rsp+38h] [rbp+10h] BYREF

  v5 = a2;
  return sub_147BF2290(n0x80, &v5, a3, a4);
}

// --- End Function: sub_147BF31D0 (0x147BF31D0) ---

// --- Function: sub_147C64FD0 (0x147C64FD0) ---
char *__fastcall sub_147C64FD0(char *a1, __int64 a2)
{
  size_t Size; // r8
  char *v4; // rbx

  Size = *(_QWORD *)(a2 + 8);
  v4 = a1;
  if ( Size )
  {
    memcpy(a1, *(const void **)a2, Size);
    v4 += *(_QWORD *)(a2 + 8);
  }
  return v4;
}

// --- End Function: sub_147C64FD0 (0x147C64FD0) ---

// --- Function: sub_147C65010 (0x147C65010) ---
char *__fastcall sub_147C65010(char *a1, __int64 a2, __int64 a3)
{
  size_t Size; // r8
  char *v6; // rbx
  size_t Size_1; // r8

  Size = *(_QWORD *)(a2 + 8);
  v6 = a1;
  if ( Size )
  {
    memcpy(a1, *(const void **)a2, Size);
    v6 += *(_QWORD *)(a2 + 8);
  }
  Size_1 = *(_QWORD *)(a3 + 8);
  if ( Size_1 )
  {
    memcpy(v6, *(const void **)a3, Size_1);
    v6 += *(_QWORD *)(a3 + 8);
  }
  return v6;
}

// --- End Function: sub_147C65010 (0x147C65010) ---

// --- Function: sub_147C65070 (0x147C65070) ---
char *__fastcall sub_147C65070(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  size_t Size; // r8
  char *v9; // rbx
  size_t Size_1; // r8
  size_t Size_2; // r8
  size_t Size_3; // r8

  Size = *(_QWORD *)(a2 + 8);
  v9 = a1;
  if ( Size )
  {
    memcpy(a1, *(const void **)a2, Size);
    v9 += *(_QWORD *)(a2 + 8);
  }
  Size_1 = *(_QWORD *)(a3 + 8);
  if ( Size_1 )
  {
    memcpy(v9, *(const void **)a3, Size_1);
    v9 += *(_QWORD *)(a3 + 8);
  }
  Size_2 = *(_QWORD *)(a4 + 8);
  if ( Size_2 )
  {
    memcpy(v9, *(const void **)a4, Size_2);
    v9 += *(_QWORD *)(a4 + 8);
  }
  Size_3 = *(_QWORD *)(a5 + 8);
  if ( Size_3 )
  {
    memcpy(v9, *(const void **)a5, Size_3);
    v9 += *(_QWORD *)(a5 + 8);
  }
  return v9;
}

// --- End Function: sub_147C65070 (0x147C65070) ---

// --- Function: sub_147C66D70 (0x147C66D70) ---
// Hidden C++ exception states: #wind=2
char *__fastcall sub_147C66D70(
        char *a1,
        __int64 a2,
        __int64 p_,
        __int64 p__contains_invalid_UTF_8_data_when,
        const char **p__,
        const char **p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send,
        const char **a7)
{
  char *v11; // rcx
  char *v12; // rax

  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 15;
  *a1 = 0;
  sub_140CB11B0(
    a1,
    (unsigned __int64)&p__[1][(unsigned __int64)&a7[1][(_QWORD)p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send[1]
                                                     + *(_QWORD *)(p__contains_invalid_UTF_8_data_when + 8)]
                            + *(_QWORD *)(a2 + 8)
                            + *(_QWORD *)(p_ + 8)],
    0);
  v11 = a1;
  if ( *((_QWORD *)a1 + 3) >= 0x10u )
    v11 = *(char **)a1;
  v12 = sub_147C65070(v11, a2, p_, p__contains_invalid_UTF_8_data_when, (__int64)p__);
  sub_147C65010(v12, (__int64)p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send, (__int64)a7);
  return a1;
}

// --- End Function: sub_147C66D70 (0x147C66D70) ---

// --- Function: sub_147C66E30 (0x147C66E30) ---
// Hidden C++ exception states: #wind=2
char *__fastcall sub_147C66E30(
        char *a1,
        __int64 p__,
        __int64 p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send,
        __int64 p_p_.,
        const char **p__contains_invalid_UTF_8_data_when,
        const char **p_)
{
  char *v10; // rcx
  char *v11; // rax

  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 15;
  *a1 = 0;
  sub_140CB11B0(
    a1,
    (unsigned __int64)&p_[1][*(_QWORD *)(p_p_. + 8)
                           + (_QWORD)p__contains_invalid_UTF_8_data_when[1]
                           + *(_QWORD *)(p__ + 8)
                           + *(_QWORD *)(p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send + 8)],
    0);
  v10 = a1;
  if ( *((_QWORD *)a1 + 3) >= 0x10u )
    v10 = *(char **)a1;
  v11 = sub_147C65070(
          v10,
          p__,
          p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_send,
          p_p_.,
          p__contains_invalid_UTF_8_data_when);
  sub_147C64FD0(v11, (__int64)p_);
  return a1;
}

// --- End Function: sub_147C66E30 (0x147C66E30) ---

// --- Function: sub_147C66F70 (0x147C66F70) ---
// Hidden C++ exception states: #wind=2
char *__fastcall sub_147C66F70(
        char *a1,
        __int64 p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_sen,
        __int64 a3,
        __int64 p_)
{
  char *v8; // rcx
  char *v9; // rax

  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 15;
  *a1 = 0;
  sub_140CB11B0(
    a1,
    *(_QWORD *)(a3 + 8)
  + *(_QWORD *)(p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_sen + 8)
  + *(_QWORD *)(p_ + 8),
    0);
  v8 = a1;
  if ( *((_QWORD *)a1 + 3) >= 0x10u )
    v8 = *(char **)a1;
  v9 = sub_147C65010(v8, (const char **)p__a_protocol_buffer._Use_the__bytes__type_if_you_intend_to_sen, a3);
  sub_147C64FD0(v9, (const char **)p_);
  return a1;
}

// --- End Function: sub_147C66F70 (0x147C66F70) ---

// --- Function: sub_147C7CED0 (0x147C7CED0) ---
bool __fastcall sub_147C7CED0(__int64 a1, unsigned int a2)
{
  int v4; // [rsp+40h] [rbp+18h] BYREF

  if ( !byte_151710C30 )
    return 1;
  v4 = 0;
  sub_147C7D120(&unk_148E9AFC0, a1, a2, &v4);
  return v4 == a2;
}

// --- End Function: sub_147C7CED0 (0x147C7CED0) ---

// --- Function: sub_147C7CF20 (0x147C7CF20) ---
__int64 __fastcall sub_147C7CF20(unsigned int *a1, unsigned __int8 *a2, int n7, _DWORD *a4)
{
  int v7; // r9d
  unsigned __int8 *v8; // rax
  __int64 v9; // r10
  unsigned __int64 v10; // rsi
  unsigned int v11; // r12d
  unsigned int v12; // r14d
  unsigned __int64 v13; // rbx
  unsigned int v14; // r15d
  __int64 v15; // rbp
  unsigned int n0xF0; // r11d
  int v17; // r9d
  int v18; // edx
  __int64 i; // rdx
  __int64 v20; // rcx
  unsigned int v21; // r8d
  unsigned int v22; // edx

  *a4 = 0;
  if ( !n7 )
    return 241;
  v7 = *a1;
  v8 = a2;
  v9 = *((_QWORD *)a1 + 7);
  v10 = (unsigned __int64)a2;
  v11 = a1[7];
  v12 = a1[4];
  v13 = (unsigned __int64)&a2[n7];
  v14 = a1[6];
  if ( n7 >= 7 )
    v10 = v13 - 7;
  v15 = *((_QWORD *)a1 + 4) + *a1;
  do
  {
    n0xF0 = 0;
    if ( ((unsigned __int8)v8 & 7) != 0 )
    {
      do
      {
        if ( (unsigned __int64)v8 >= v13 )
          break;
        if ( *(_BYTE *)(*v8 + v9) )
          break;
        ++v8;
      }
      while ( ((unsigned __int8)v8 & 7) != 0 );
      if ( ((unsigned __int8)v8 & 7) != 0 )
        goto LABEL_20;
    }
    if ( (unsigned __int64)v8 >= v10 )
      goto LABEL_20;
    while ( 1 )
    {
      v17 = *(_DWORD *)v8;
      v18 = *((_DWORD *)v8 + 1);
      v8 += 8;
      if ( (((v17 - v14) | (v18 - v14) | (v17 + v11) | (v18 + v11)) & 0x80808080) == 0 )
        goto LABEL_15;
      if ( *(_BYTE *)(*(v8 - 8) + v9)
         | (unsigned __int8)(*(_BYTE *)(*(v8 - 5) + v9) | *(_BYTE *)(*(v8 - 6) + v9) | *(_BYTE *)(*(v8 - 7) + v9)) )
      {
        break;
      }
      if ( *(_BYTE *)(*(v8 - 4) + v9)
         | (unsigned __int8)(*(_BYTE *)(*(v8 - 1) + v9) | *(_BYTE *)(*(v8 - 2) + v9) | *(_BYTE *)(*(v8 - 3) + v9)) )
      {
        v8 -= 4;
        goto LABEL_19;
      }
LABEL_15:
      if ( (unsigned __int64)v8 >= v10 )
        goto LABEL_19;
    }
    v8 -= 8;
LABEL_19:
    v7 = *a1;
LABEL_20:
    for ( i = v15; (unsigned __int64)v8 < v13; i = v15 + (int)(n0xF0 << v12) )
    {
      v20 = *v8++;
      n0xF0 = *(unsigned __int8 *)(v20 + i);
      if ( n0xF0 >= 0xF0 )
        break;
    }
    v21 = a1[1];
    v22 = i - v7 - a1[8];
    if ( n0xF0 < 0xF0 )
    {
      if ( v22 < v21 )
      {
        n0xF0 = 241;
      }
      else
      {
        n0xF0 = 240;
        do
          --v8;
        while ( v8 > a2 && (*v8 & 0xC0) == 0x80 );
      }
      break;
    }
    --v8;
    if ( v22 >= v21 )
    {
      do
        --v8;
      while ( v8 > a2 && (*v8 & 0xC0) == 0x80 );
    }
  }
  while ( n0xF0 == 253 );
  *a4 = (_DWORD)v8 - (_DWORD)a2;
  return n0xF0;
}

// --- End Function: sub_147C7CF20 (0x147C7CF20) ---

// --- Function: sub_147C7D120 (0x147C7D120) ---
__int64 __fastcall sub_147C7D120(unsigned int *a1, unsigned __int64 a2, int n7, _DWORD *a4)
{
  __int64 n253; // rax
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rdi
  int v12; // [rsp+60h] [rbp+18h] BYREF

  *a4 = 0;
  if ( !n7 )
    return 241;
  v9 = a2;
  v10 = a2;
  v11 = n7 + a2;
  if ( n7 >= 7 )
    v10 = n7 + a2 - 7;
  do
  {
    if ( (v9 & 7) == 0 )
      goto LABEL_10;
    do
    {
      if ( v9 >= v11 )
        break;
      if ( *(_BYTE *)v9 >= 0x80u )
        break;
      ++v9;
    }
    while ( (v9 & 7) != 0 );
    if ( (v9 & 7) == 0 )
    {
LABEL_10:
      while ( v9 < v10 )
      {
        if ( ((*(_DWORD *)v9 | *(_DWORD *)(v9 + 4)) & 0x80808080) != 0 )
          break;
        v9 += 8LL;
      }
    }
    for ( ; v9 < v11; ++v9 )
    {
      if ( *(_BYTE *)v9 >= 0x80u )
        break;
    }
    n253 = sub_147C7CF20(a1, (unsigned __int8 *)(a2 + (int)v9 - (int)a2), n7 - ((int)v9 - (int)a2), &v12);
    v9 += v12;
  }
  while ( (_DWORD)n253 == 253 );
  *a4 = v9 - a2;
  return n253;
}

// --- End Function: sub_147C7D120 (0x147C7D120) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  n2 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

