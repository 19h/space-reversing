// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x144E48B30 (sub_144E48B30)
// Caller Depth: 0
// Callee/Ref Depth: 5
// Total Functions Found: 51
// ------------------------------------------------------------

// --- Function: sub_1402A24F0 (0x1402A24F0) ---
__int64 __fastcall sub_1402A24F0(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1402A24F0 (0x1402A24F0) ---

// --- Function: sub_1402A2AD0 (0x1402A2AD0) ---
__int64 __fastcall sub_1402A2AD0(_QWORD *a1)
{
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 result; // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *))a1[1];
  if ( (unsigned __int64)n2 < 2 )
  {
    result = 0;
    *a1 = 0;
  }
  else
  {
    n2(2, a1);
    result = 0;
    a1[1] = 0;
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_1402A2AD0 (0x1402A2AD0) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: unknown_libname_472 (0x1402AE2A0) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_472(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_472 (0x1402AE2A0) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: j_cosf (0x140332E10) ---
// attributes: thunk
float __cdecl j_cosf(float X)
{
  return cosf(X);
}

// --- End Function: j_cosf (0x140332E10) ---

// --- Function: j_sinf (0x140333560) ---
// attributes: thunk
float __cdecl j_sinf(float X)
{
  return sinf(X);
}

// --- End Function: j_sinf (0x140333560) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 + 0xFFFFFFFA;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403A2CE0 (0x1403A2CE0) ---
__int64 sub_1403A2CE0(__int64 a1, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, a1);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
               qword_149B4FCB0,
               0,
               a1,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1403A2CE0 (0x1403A2CE0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 0xC0LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403E6750 (0x1403E6750) ---
unsigned __int64 __fastcall sub_1403E6750(unsigned __int64 *a1)
{
  if ( sub_14030EC00(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6750 (0x1403E6750) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1412A8110 (0x1412A8110) ---
__int64 *__fastcall sub_1412A8110(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        _DWORD *a4,
        __int64 a5,
        char a6,
        int a7,
        int a8,
        char a9)
{
  __int64 v10; // xmm1_8
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  _BYTE v16[40]; // [rsp+20h] [rbp-28h] BYREF

  *a1 = a2;
  a1[4] = *(_QWORD *)(a3 + 0x18);
  a1[1] = *(_QWORD *)a3;
  a1[2] = *(_QWORD *)(a3 + 8);
  a1[3] = *(_QWORD *)(a3 + 0x10);
  *(_OWORD *)(a1 + 5) = *(_OWORD *)(a3 + 0x20);
  v10 = *(__int64 *)(a3 + 0x30);
  a1[7] = v10;
  a1[8] = *(_QWORD *)(a3 + 0x38);
  a1[9] = 0;
  a1[0xA] = 0;
  a1[0xB] = 0;
  *((_DWORD *)a1 + 0x1B) = a4[3];
  *((_DWORD *)a1 + 0x18) = *a4;
  *((_DWORD *)a1 + 0x19) = a4[1];
  *((_DWORD *)a1 + 0x1A) = a4[2];
  v11 = *a1;
  a1[0xE] = *(__int64 *)a5;
  *((_DWORD *)a1 + 0x1E) = *(_DWORD *)(a5 + 8);
  *((_BYTE *)a1 + 0x7C) = a6;
  *((_BYTE *)a1 + 0x7F) = a9;
  *(_WORD *)((char *)a1 + 0x7D) = 0;
  if ( v11 )
  {
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
    if ( v12 )
    {
      v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x668LL))(v12);
      if ( v13 )
      {
        v14 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v13 + 0x170LL))(v13, v16, a1 + 5);
        *(_OWORD *)(a1 + 9) = *(_OWORD *)v14;
        a1[0xB] = *(__int64 *)(v14 + 0x10);
      }
      else
      {
        sub_1403A2CE0((__int64)"Constructing SActorTeleportParams with a zone entity id that does not host a zone.");
      }
      return a1;
    }
    else
    {
      sub_1403A2CE0((__int64)"Constructing SActorTeleportParams with invalid zone entity id.");
      return a1;
    }
  }
  else
  {
    *(_OWORD *)(a1 + 9) = *(_OWORD *)(a1 + 5);
    a1[0xB] = v10;
    return a1;
  }
}

// --- End Function: sub_1412A8110 (0x1412A8110) ---

// --- Function: sub_141848E00 (0x141848E00) ---
_QWORD *__fastcall sub_141848E00(_QWORD *p_pExceptionObject)
{
  p_pExceptionObject[1] = "bad allocation";
  *p_pExceptionObject = off_1481A05A8;
  return p_pExceptionObject;
}

// --- End Function: sub_141848E00 (0x141848E00) ---

// --- Function: sub_144E48B30 (0x144E48B30) ---
__int64 __fastcall sub_144E48B30(__int64 a1)
{
  __int64 v1; // rax
  __int64 v3; // rax
  const void *src; // rax
  const char *v5; // rax
  const char *v6; // rax
  const char *v7; // rax
  const char *v9; // rax
  const char *v11; // rax
  const char *v13; // rax
  float v20; // [rsp+58h] [rbp-380h]
  float v21; // [rsp+5Ch] [rbp-37Ch]
  float v22; // [rsp+60h] [rbp-378h]
  float v23; // [rsp+64h] [rbp-374h]
  float v24; // [rsp+68h] [rbp-370h]
  float v25; // [rsp+6Ch] [rbp-36Ch]
  float X; // [rsp+78h] [rbp-360h]
  float v27; // [rsp+94h] [rbp-344h]
  float v28; // [rsp+98h] [rbp-340h]
  unsigned __int64 *v29; // [rsp+A8h] [rbp-330h]
  unsigned int v30; // [rsp+F8h] [rbp-2E0h]
  __int64 v31; // [rsp+100h] [rbp-2D8h] BYREF
  unsigned int v32; // [rsp+108h] [rbp-2D0h]
  float v33; // [rsp+10Ch] [rbp-2CCh]
  float v34; // [rsp+110h] [rbp-2C8h]
  float v35; // [rsp+114h] [rbp-2C4h]
  float v36; // [rsp+118h] [rbp-2C0h]
  __int64 v37; // [rsp+120h] [rbp-2B8h]
  unsigned __int64 v38; // [rsp+130h] [rbp-2A8h]
  __int64 v39; // [rsp+138h] [rbp-2A0h]
  unsigned __int64 v40; // [rsp+140h] [rbp-298h] BYREF
  __int64 v41; // [rsp+148h] [rbp-290h]
  __int64 v42; // [rsp+158h] [rbp-280h]
  __int64 v43; // [rsp+160h] [rbp-278h]
  __int64 v44; // [rsp+168h] [rbp-270h]
  __int64 v45; // [rsp+170h] [rbp-268h]
  __int64 v46; // [rsp+178h] [rbp-260h]
  float dst__1[3]; // [rsp+180h] [rbp-258h] BYREF
  float src_[7]; // [rsp+190h] [rbp-248h] BYREF
  float v49[3]; // [rsp+1ACh] [rbp-22Ch] BYREF
  float v50[4]; // [rsp+1B8h] [rbp-220h] BYREF
  __int64 (__fastcall *v51)(__int64, _QWORD); // [rsp+1C8h] [rbp-210h]
  __int64 v52; // [rsp+1D0h] [rbp-208h]
  __int64 (*v53)(__int64, const char *, ...); // [rsp+1D8h] [rbp-200h]
  __int64 v54; // [rsp+1E0h] [rbp-1F8h]
  void (__fastcall *v55)(__int64, __int64 *, __int64); // [rsp+1E8h] [rbp-1F0h]
  __int64 v56; // [rsp+1F0h] [rbp-1E8h] BYREF
  __int64 (__fastcall *v57)(__int64, __int64); // [rsp+1F8h] [rbp-1E0h]
  __int64 (__fastcall *v58)(__int64, __int64); // [rsp+200h] [rbp-1D8h]
  __int64 (__fastcall *v59)(__int64, __int64); // [rsp+208h] [rbp-1D0h]
  __int64 (__fastcall *v60)(__int64, __int64); // [rsp+210h] [rbp-1C8h]
  __int64 (__fastcall *v61)(__int64, __int64); // [rsp+218h] [rbp-1C0h]
  __int64 (__fastcall *v62)(__int64, __int64); // [rsp+220h] [rbp-1B8h]
  __int64 v63; // [rsp+228h] [rbp-1B0h]
  void **v64; // [rsp+230h] [rbp-1A8h]
  __int64 v65; // [rsp+240h] [rbp-198h]
  __int64 *v66; // [rsp+248h] [rbp-190h]
  void (__fastcall *v67)(__int64, __int64 *); // [rsp+250h] [rbp-188h]
  void *v68; // [rsp+258h] [rbp-180h] BYREF
  void (__fastcall *v69)(unsigned __int64, __int64 *); // [rsp+268h] [rbp-170h]
  float *v70; // [rsp+270h] [rbp-168h]
  __int64 (__fastcall *v71)(__int64, _QWORD); // [rsp+278h] [rbp-160h]
  __int64 v72; // [rsp+280h] [rbp-158h]
  void (__fastcall *v73)(__int64, unsigned __int64 *, __int64); // [rsp+288h] [rbp-150h]
  __int64 (__fastcall *v74)(__int64, _BYTE *); // [rsp+290h] [rbp-148h]
  double v75; // [rsp+298h] [rbp-140h]
  double v76; // [rsp+2A0h] [rbp-138h]
  double v77; // [rsp+2A8h] [rbp-130h]
  double v78; // [rsp+2B0h] [rbp-128h]
  double v79; // [rsp+2C0h] [rbp-118h] BYREF
  double v80; // [rsp+2C8h] [rbp-110h]
  double v81; // [rsp+2D0h] [rbp-108h]
  double v82; // [rsp+2D8h] [rbp-100h]
  double dst_[4]; // [rsp+2E0h] [rbp-F8h] BYREF
  _QWORD v84[3]; // [rsp+300h] [rbp-D8h] BYREF
  _BYTE v85[8]; // [rsp+318h] [rbp-C0h] BYREF
  __int64 v86; // [rsp+320h] [rbp-B8h]
  _QWORD v87[3]; // [rsp+328h] [rbp-B0h] BYREF
  __int64 v88[19]; // [rsp+340h] [rbp-98h] BYREF

  if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) != 4
    && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) != 5
    && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) != 7
    && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) != 8 )
  {
    v1 = sub_1402A24F0((__int64)&qword_149B4FBE0);
    return (*(__int64 (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(v1 + 0xD0) + 0x28LL))(
             *(_QWORD *)(v1 + 0xD0),
             "Incorrect arguments. Usage: 'gotoZonePos px py pz <zonename>' or 'gotoZonePos px py pz yaw pitch roll <zonename>'");
  }
  v46 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
  v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v46 + 0xA0LL))(v46);
  v29 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x2D8LL))(v37);
  if ( !v29 )
  {
    v3 = sub_1402A24F0((__int64)&qword_149B4FBE0);
    return (*(__int64 (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(v3 + 0xD0) + 0x28LL))(
             *(_QWORD *)(v3 + 0xD0),
             "Could not find client actor.");
  }
  v38 = sub_1403E6750(v29 + 1);
  v69 = *(void (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v38 + 0x660LL);
  v69(v38, &v31);
  if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) == 5
    || (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) == 8 )
  {
    v39 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA0);
    v73 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v39 + 0x140LL);
    v71 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 0x10LL);
    v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) - 1;
    v72 = v71(a1, v30);
    v73(v39, &v40, v72);
    if ( !sub_14030EC00(&v40) )
    {
      v45 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xD0);
      v53 = *(__int64 (**)(__int64, const char *, ...))(*(_QWORD *)v45 + 0x28LL);
      v51 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 0x10LL);
      v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) - 1;
      v52 = v51(a1, v32);
      return v53(v45, "Could not find valid zone entity id with name '%s'.", v52);
    }
    v41 = sub_14030ECF0(&v40);
    v74 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v41 + 8LL);
    v31 = *(_QWORD *)v74(v41, v85);
  }
  v42 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA0);
  v55 = *(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v42 + 0x120LL);
  v54 = v31;
  v55(v42, &v56, v31);
  v43 = sub_14030ECF0(&v56);
  v86 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v43 + 0x668LL))(v43);
  v82 = 1.0;
  v79 = 0.0;
  v80 = 0.0;
  v81 = 0.0;
  unknown_libname_472(v87);
  qmemcpy(dst_, src, 0x18u);
  _XMM0 = 0x3FF0000000000000uLL;
  dst_[3] = 1.0;
  v57 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x10LL);
  v5 = (const char *)v57(a1, 1);
  dst_[0] = atof(v5);
  v58 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x10LL);
  v6 = (const char *)v58(a1, 2);
  dst_[1] = atof(v6);
  v59 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x10LL);
  v7 = (const char *)v59(a1, 3);
  dst_[2] = atof(v7);
  if ( (*(int (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1) >= 7 )
  {
    v60 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x10LL);
    v9 = (const char *)v60(a1, 4);
    *(double *)&_XMM0 = atof(v9);
    __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
    src_[0] = *(float *)&_XMM0;
    v61 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x10LL);
    v11 = (const char *)v61(a1, 5);
    *(double *)&_XMM0 = atof(v11);
    __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
    src_[1] = *(float *)&_XMM0;
    v62 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x10LL);
    v13 = (const char *)v62(a1, 6);
    *(double *)&_XMM0 = atof(v13);
    __asm { vcvtsd2ss xmm0, xmm0, xmm0 }
    src_[2] = *(float *)&_XMM0;
    qmemcpy(dst__1, src_, sizeof(dst__1));
    src_[4] = dst__1[0] * 3.1415927;
    src_[5] = dst__1[1] * 3.1415927;
    src_[6] = dst__1[2] * 3.1415927;
    v27 = (float)(dst__1[1] * 3.1415927) * (float)(1.0 / 180.0);
    v28 = (float)(dst__1[2] * 3.1415927) * (float)(1.0 / 180.0);
    X = (float)((float)(dst__1[0] * 3.1415927) * (float)(1.0 / 180.0)) * 0.5;
    v25 = j_sinf(X);
    v22 = j_cosf(X);
    v24 = j_sinf(v27 * 0.5);
    v21 = j_cosf(v27 * 0.5);
    v20 = j_sinf(v28 * 0.5);
    v23 = j_cosf(v28 * 0.5);
    v36 = (float)((float)(v22 * v21) * v23) + (float)((float)(v25 * v24) * v20);
    v33 = (float)((float)(v23 * v21) * v25) - (float)((float)(v20 * v24) * v22);
    v34 = (float)((float)(v23 * v24) * v22) + (float)((float)(v20 * v21) * v25);
    v35 = (float)((float)(v20 * v21) * v22) - (float)((float)(v23 * v24) * v25);
    v78 = v36;
    v75 = v33;
    v76 = v34;
    v77 = v35;
    v79 = v33;
    v80 = v34;
    v81 = v35;
    v82 = v36;
  }
  v44 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v29 + 0x830))(v29);
  v67 = *(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v44 + 0x118LL);
  memset(v84, 0, sizeof(v84));
  v64 = CreateStringObjectFromString(&v68, "SSCActorGotoCVars::CmdGotoZonePos");
  v49[2] = 0.0;
  v49[1] = 0.0;
  _XMM0 = 0;
  v49[0] = 0.0;
  v70 = v49;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+3D8h+var_100] }
  v50[3] = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+3D8h+var_118] }
  v50[0] = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+3D8h+var_110] }
  v50[1] = *(float *)&_XMM0;
  __asm { vcvtsd2ss xmm0, xmm0, [rsp+3D8h+var_108] }
  v50[2] = *(float *)&_XMM0;
  v63 = v31;
  v65 = v31;
  v66 = sub_1412A8110(v88, v31, (__int64)&v79, v50, (__int64)v49, 0, (int)v64, (int)v84, 0);
  v67(v44, v66);
  sub_140370D10(&v68);
  return sub_1402A2AD0(v84);
}

// --- End Function: sub_144E48B30 (0x144E48B30) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE58LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_1475B3F30 (0x1475B3F30) ---
int __fastcall sub_1475B3F30(char *Buffer, size_t BufferCount, unsigned __int64 n0x40000000)
{
  const char *p_%u.%u_MB; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-A8h]
  int v11; // [rsp+28h] [rbp-A0h]
  __m256 DstBuf_; // [rsp+40h] [rbp-88h] BYREF
  __m256 DstBuf__1; // [rsp+60h] [rbp-68h] BYREF
  __m256 v14; // [rsp+80h] [rbp-48h]

  DstBuf_ = (__m256)0LL;
  if ( n0x40000000 >= 0x10000000000LL )
  {
    p_%u.%u_MB = "%u.%u TB";
    v7 = (0xA * (n0x40000000 & 0xFFFFFFFFFFLL)) >> 0x28;
    v8 = n0x40000000 >> 0x28;
LABEL_7:
    v11 = v7;
    v10 = v8;
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, p_%u.%u_MB, v10, v11);
    goto LABEL_11;
  }
  if ( n0x40000000 >= 0x40000000 )
  {
    p_%u.%u_MB = "%u.%u GB";
    v7 = (0xA * (n0x40000000 & 0x3FFFFFFF)) >> 0x1E;
    v8 = n0x40000000 >> 0x1E;
    goto LABEL_7;
  }
  if ( n0x40000000 >= 0x100000 )
  {
    p_%u.%u_MB = "%u.%u MB";
    v7 = (0xA * (n0x40000000 & 0xFFFFF)) >> 0x14;
    v8 = n0x40000000 >> 0x14;
    goto LABEL_7;
  }
  if ( n0x40000000 < 0x400 )
  {
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, "%u byte(s)", n0x40000000);
  }
  else
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf_,
      0x20u,
      0xFFFFFFFFFFFFFFFFuLL,
      "%u.%u KB",
      n0x40000000 >> 0xA,
      (0xA * (n0x40000000 & 0x3FF)) >> 0xA);
  }
LABEL_11:
  DstBuf__1 = (__m256)0LL;
  v14 = (__m256)0LL;
  if ( byte_1516B60CF )
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf__1,
      0x40u,
      0xFFFFFFFFFFFFFFFFuLL,
      " (Started with < %u GB of available system memory.)",
      8);
  }
  __asm { vzeroupper }
  return snprintf_s(
           Buffer,
           BufferCount,
           0xFFFFFFFFFFFFFFFFuLL,
           "Out of system memory. Failed to allocate %s (%zu).%s",
           (const char *)&DstBuf_,
           n0x40000000,
           (const char *)&DstBuf__1);
}

// --- End Function: sub_1475B3F30 (0x1475B3F30) ---

// --- Function: sub_1475DF210 (0x1475DF210) ---
void __fastcall sub_1475DF210(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1475B3F30(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1475DF210 (0x1475DF210) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_147602A80 (0x147602A80) ---
void __fastcall sub_147602A80(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned __int32 v4; // eax
  __int64 v5; // r13
  int v6; // ebx
  unsigned int v7; // ebp
  unsigned __int32 v8; // r15d
  unsigned int v9; // ebx
  unsigned __int32 v10; // [rsp+20h] [rbp-88h]
  unsigned __int32 v11; // [rsp+20h] [rbp-88h]
  int n0x1600; // [rsp+30h] [rbp-78h] BYREF
  __int64 v13; // [rsp+34h] [rbp-74h]
  int n2; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v15; // [rsp+40h] [rbp-68h]
  unsigned __int64 v16; // [rsp+48h] [rbp-60h]
  __int64 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-50h]

  v3 = a1 + 0x12F0;
  v4 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0x12F0), 1u);
  v5 = a1 + 0x12F0 + 0x10 * (v4 & 0x1F);
  v6 = (v4 >> 5) & 0x7FFF;
  v7 = ((v4 - 0x20) >> 5) & 0x7FFF;
  v8 = *(_DWORD *)(v5 + 8);
  if ( (v8 & 0x7FFF) != v7 )
  {
    if ( qword_149B4FDB8 )
    {
      n0x1600 = 0x1600;
      v13 = 1;
      n2 = 2;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v15 = __rdtsc();
      qword_149B4B870(
        &n0x1600,
        &word_1517021C0,
        "Wait on Full Queue",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Containers/CigProducerConsumerQueue.h",
        0xB2);
      HIWORD(n0x1600) = word_1517021C0;
      LOBYTE(v11) = 0;
      sub_1407E63A0(v3, (volatile signed __int32 *)(v5 + 8), v8, v7, v11);
      v16 = __rdtsc();
      qword_149B4B878(&n0x1600);
    }
    else
    {
      LOBYTE(v10) = 0;
      sub_1407E63A0(a1 + 0x12F0, (volatile signed __int32 *)(v5 + 8), v8, v7, v10);
    }
  }
  *(_QWORD *)(v5 + 0x10) = a2;
  v9 = _InterlockedExchange((volatile __int32 *)(v5 + 0xC), v6);
  if ( (v9 & 0xFFFF8000) != 0 )
    sub_1407E6520(v3, v5 + 0xC, v9);
}

// --- End Function: sub_147602A80 (0x147602A80) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476030E0 (0x1476030E0) ---
unsigned __int64 __fastcall sub_1476030E0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n0x20; // eax
  unsigned int n0x20_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147603270((__int64)&qword_151700CC0, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n0x20 = 0x20;
    n0x20_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n0x20 = n0x20_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(0x20 - n0x20) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148D699B0[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 0x10 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xF00;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 0xC);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147604610(&unk_151700CD0[4 * v12]);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1476034A0((__int64)&qword_151700CC0, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_151701F50;
  if ( qword_151701F50 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_151701E50;
    if ( qword_151701E50 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1476030E0 (0x1476030E0) ---

// --- Function: sub_147603270 (0x147603270) ---
__int64 __fastcall sub_147603270(__int64 a1, unsigned __int64 n0xE000)
{
  unsigned __int64 n0xE000_2; // r13
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // rbx
  unsigned __int64 v5; // r12
  __int64 v6; // r15
  __int64 v7; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rsi
  unsigned __int64 v10; // r14
  __int64 v11; // r8
  __int64 v12; // rsi
  __int64 v13; // rax
  __int128 v15; // [rsp+30h] [rbp-40h] BYREF
  double v16; // [rsp+40h] [rbp-30h]
  __int64 v17; // [rsp+48h] [rbp-28h] BYREF
  __int128 v18; // [rsp+50h] [rbp-20h]
  double v19; // [rsp+60h] [rbp-10h]
  double v20; // [rsp+B0h] [rbp+40h] BYREF
  unsigned __int64 n0xE000_1; // [rsp+B8h] [rbp+48h]
  __int64 v22; // [rsp+C0h] [rbp+50h]

  n0xE000_1 = n0xE000;
  n0xE000_2 = n0xE000;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
  v5 = sub_147603A00(n0xE000, 1);
  v6 = ~(*(unsigned int *)(a1 + 0x1284) - 1LL) & (*(unsigned int *)(a1 + 0x1284) + n0xE000_2 - 1);
  v22 = v6;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x12C0));
  v20 = 0.0;
  v7 = sub_147602DF0(a1, v5, &v20);
  v8 = *(_QWORD **)(v7 + 8);
  if ( v8 )
  {
    *(_QWORD *)(v7 + 8) = *v8;
    v9 = v8[1];
    v8[1] = 0;
    *v8 = *(_QWORD *)(a1 + 0x12B8);
    *(_QWORD *)(a1 + 0x12B8) = v8;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 0x1290);
    if ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 )
    {
      do
      {
        v11 = *(unsigned int *)(a1 + 0x12AC);
        v12 = (v11 + 0x17) & ~(v11 - 1);
        *(__m256i *)(a1 + 0x1298) = *(__m256i *)sub_14056DBC0((__int64)&v17, 0x8000000000LL, v11, &off_148D699A8, 1, 0);// "StarAlloc-Large"
        v10 = (*(_QWORD *)(a1 + 0x1298) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
        __asm { vzeroupper }
        sub_14056DA40(a1 + 0x1298, v10, v12);
        *(_WORD *)(v10 + 0x15) = 0;
        *(_BYTE *)(v10 + 0x17) = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)(v10 + 0x10) = 0x1337;
        *(_BYTE *)(v10 + 0x14) = 0;
        *(_QWORD *)(v10 + 8) = v12;
        *(_QWORD *)v10 = *(_QWORD *)(a1 + 0x1290);
        *(_QWORD *)(a1 + 0x1290) = v10;
      }
      while ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 );
      v6 = v22;
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
      n0xE000_2 = n0xE000_1;
    }
    v13 = *(_QWORD *)(v10 + 8);
    v9 = v13 + v10;
    *(_QWORD *)(v10 + 8) = v5 + v13;
  }
  sub_14056DA40(a1 + 0x1270, v9, v6);
  v16 = v20;
  *(_QWORD *)&v15 = n0xE000_2;
  *((_QWORD *)&v15 + 1) = v6;
  v19 = v20;
  v17 = v9;
  v18 = v15;
  sub_1476044E0((__int64 *)(a1 + 0x1228), (__int64)&v15, &v17);
  LeaveCriticalSection(lpCriticalSection);
  return v9;
}

// --- End Function: sub_147603270 (0x147603270) ---

// --- Function: sub_1476034A0 (0x1476034A0) ---
unsigned __int64 __fastcall sub_1476034A0(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 n0x10)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 i; // rax
  __int64 v9; // r11
  signed __int32 v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rbp
  unsigned __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r12
  unsigned __int64 v16; // r15
  unsigned __int64 v17; // rax
  _QWORD *v18; // r8
  unsigned __int64 v19; // rax
  int v20; // r9d
  signed __int64 v21; // rdx
  int n2_1; // [rsp+20h] [rbp-48h] BYREF
  __int64 v24; // [rsp+28h] [rbp-40h]
  int n2; // [rsp+78h] [rbp+10h] BYREF
  __int64 v27; // [rsp+80h] [rbp+18h]

  v27 = a3;
  v4 = *(unsigned int *)(a1 + 0x11AC);
  v24 = v4;
  v5 = 0x20 * a3 + a1 + 0x10;
  v6 = a3;
  for ( i = sub_147604610((volatile signed __int64 *)v5); !i; i = sub_147604610((volatile signed __int64 *)v5) )
  {
    v10 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 1, 0) - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        n2 = 2;
        qword_149B3B480(v5 + 0x18, &n2, 4, 0xFFFFFFFFLL);
      }
      else
      {
        v11 = *(_QWORD *)(v5 + 0x10);
        if ( !v11 || 0x2000000LL - *(_QWORD *)(v11 + 0x20) - v4 < a2 )
        {
          sub_147602270(v9, a2, v6);
          v9 = a1;
        }
        v12 = *(_QWORD *)(v5 + 0x10);
        v13 = v12 - v4 + 0x2000000;
        v14 = *(_QWORD *)(v12 + 0x20);
        v15 = v14 + v12;
        if ( v12 + v14 + 0x20 * a2 < v13 )
          v13 = v12 + v14 + 0x20 * a2;
        v16 = ~(v24 - 1) & (v13 - v12 + v4 - 1);
        v17 = *(_QWORD *)(v12 + 0x18);
        if ( v16 > v17 )
        {
          sub_14056DA40(v9 + 0x1198, v17 + v12, v16 - v17);
          *(_QWORD *)(v12 + 0x18) = v16;
        }
        *(_QWORD *)(v12 + 0x20) = v13 - v12;
        v18 = (_QWORD *)(v15 + a2 - 8);
        v19 = v15 + 2 * a2;
        v20 = 1;
        v21 = (signed __int64)v18;
        for ( *v18 = 0; v19 <= v13; v19 += a2 )
        {
          *(_QWORD *)(v19 - 8) = v21;
          ++v20;
          v21 = v19 - 8;
        }
        sub_1476047E0((volatile signed __int64 *)v5, v21, v18, v20);
        if ( _InterlockedExchange((volatile __int32 *)(v5 + 0x18), 0) == 2 )
          qword_149B3B490(v5 + 0x18);
        v6 = v27;
        v4 = v24;
      }
    }
    else if ( (unsigned int)(_InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 2, 1) - 1) <= 1 )
    {
      n2_1 = 2;
      qword_149B3B480(v5 + 0x18, &n2_1, 4, 0xFFFFFFFFLL);
    }
  }
  return i - a2 + 8;
}

// --- End Function: sub_1476034A0 (0x1476034A0) ---

// --- Function: sub_147604610 (0x147604610) ---
__int64 __fastcall sub_147604610(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __int32 v5; // edx
  __m128i v6; // rt0
  signed __int64 v8; // [rsp+18h] [rbp-40h]
  __m128i v9; // [rsp+30h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    LODWORD(v8) = epi64 + 1;
    HIDWORD(v8) = HIDWORD(epi64) - 1;
    v6.m128i_i64[0] = v2.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v8, *(_QWORD *)v2.m128i_i64[0], v6.m128i_i64);
    v4 = v6.m128i_i64[0];
    v5 = v6.m128i_i32[2];
    v9 = v6;
    if ( v6.m128i_i64[0] == v2.m128i_i64[0] && v5 == (_DWORD)epi64 )
      break;
    v2 = v9;
    if ( !v4 )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_147604610 (0x147604610) ---

// --- Function: sub_1476046F0 (0x1476046F0) ---
char __fastcall sub_1476046F0(volatile signed __int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __m128i v4; // rt0
  __m128i v5; // xmm0
  signed __int64 epi64; // r9
  __int64 v7; // rdx
  __m128i v8; // rt0
  signed __int64 v10; // [rsp+18h] [rbp-40h]
  __m128i v11; // [rsp+30h] [rbp-28h]

  v4 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v4.m128i_i64);
  v5 = v4;
  if ( (unsigned int)(v4.m128i_i32[3] + 1) >= a3 )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v5, 1);
    *a2 = v5.m128i_i64[0];
    LODWORD(v10) = epi64 + 1;
    HIDWORD(v10) = HIDWORD(epi64) + 1;
    v8.m128i_i64[0] = v5.m128i_i64[0];
    v8.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v10, (signed __int64)a2, v8.m128i_i64);
    v7 = v8.m128i_i64[1];
    v11 = v8;
    if ( v8.m128i_i64[0] == v5.m128i_i64[0] && (_DWORD)v7 == (_DWORD)epi64 )
      break;
    v5 = v11;
    if ( (unsigned int)(HIDWORD(v7) + 1) >= a3 )
      return 0;
  }
  return 1;
}

// --- End Function: sub_1476046F0 (0x1476046F0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n0x6900 = 0x6900;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n0x6900,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    0xA7);
  HIWORD(n0x6900) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n0x6900);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 0x18B0);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 0x18C0);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 0x18B0) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 0x1E )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 0x18B0);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

// --- Function: cosf (0x148082233) ---
// attributes: thunk
float __cdecl cosf(float X)
{
  return __imp_cosf(X);
}

// --- End Function: cosf (0x148082233) ---

// --- Function: sinf (0x148082245) ---
// attributes: thunk
float __cdecl sinf(float X)
{
  return __imp_sinf(X);
}

// --- End Function: sinf (0x148082245) ---

// --- Function: sub_148177D00 (0x148177D00) ---
__int64 sub_148177D00()
{
  volatile signed __int64 *v0; // rdi
  __int64 ThreadLocalStoragePointer; // rax
  __int64 n0x8C; // rsi
  __int64 v3; // rbp
  __int64 v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *v6; // rax
  int v7; // r9d
  _QWORD *v8; // r8

  v0 = unk_151700CD0;
  ThreadLocalStoragePointer = (__int64)NtCurrentTeb()->ThreadLocalStoragePointer;
  n0x8C = 0x8C;
  v3 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF00LL;
  v4 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF10LL;
  do
  {
    v5 = *(_QWORD **)v4;
    if ( *(_QWORD *)v4 )
    {
      v6 = (_QWORD *)*v5;
      v7 = 1;
      v8 = *(_QWORD **)v4;
      if ( *v5 )
      {
        do
        {
          ++v7;
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while ( v6 );
      }
      ThreadLocalStoragePointer = sub_1476047E0(v0, (signed __int64)v5, v8, v7);
      *(_QWORD *)v4 = 0;
      *(_DWORD *)(v4 + 0xC) = 0;
    }
    v4 += 0x10;
    v0 += 4;
    --n0x8C;
  }
  while ( n0x8C );
  *(_BYTE *)(v3 + 1) = 1;
  return ThreadLocalStoragePointer;
}

// --- End Function: sub_148177D00 (0x148177D00) ---

