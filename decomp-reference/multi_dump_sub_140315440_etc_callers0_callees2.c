// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x140315440 (sub_140315440)
//   - 0x1403B1000 (sub_1403B1000)
//   - 0x145944C60 (sub_145944C60)
//   - 0x145978DF0 (sub_145978DF0)
//   - 0x14597D1E0 (sub_14597D1E0)
//   - 0x145991850 (sub_145991850)
//   - 0x146513000 (sub_146513000)
//   - 0x14652BC20 (sub_14652BC20)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 33
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall sub_1402A3D30(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: sub_1402CA4C0 (0x1402CA4C0) ---
__int64 __fastcall sub_1402CA4C0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
      break;
    v4 = 0;
    if ( (int)result < 0 )
      v4 = a1;
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402CA4C0 (0x1402CA4C0) ---

// --- Function: sub_1402D2830 (0x1402D2830) ---
__int64 __fastcall sub_1402D2830(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
      break;
    ++a4;
    if ( (a1 & 1) != 0 )
      a3 |= 1 << (a2 - v4);
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D2830 (0x1402D2830) ---

// --- Function: sub_1402E1FE0 (0x1402E1FE0) ---
__int64 __fastcall sub_1402E1FE0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
      break;
    v5 = v4 + 0x20;
    if ( (unsigned __int8)(v4 - 0x41) > 0x19u )
      v5 = v4;
    v6 = sub_1402D2830(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402CA4C0(0x4C11DB7, 1, (v6 << 0x19) ^ (unsigned int)((unsigned __int64)(v6 << 0x18) >> 0x1F) & 0x4C11DB7);
    v8 = sub_1402D2830(v7 >> 1, 0x20, v7 << 0x1F, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402E1FE0 (0x1402E1FE0) ---

// --- Function: sub_140315440 (0x140315440) ---
_QWORD *__fastcall sub_140315440(_QWORD *a1, char a2)
{
  __int64 v4; // rsi
  _QWORD *i; // rbx

  if ( (a2 & 2) != 0 )
  {
    v4 = a1[0xFFFFFFFF];
    for ( i = &a1[6 * v4]; v4; --v4 )
    {
      i += 0xFFFFFFFA;
      sub_140370D10(i + 5);
      sub_140370D10(i + 4);
      sub_140372C00((__int64)(i + 1));
      *i = &off_1481A0DB8;
    }
    if ( (a2 & 1) != 0 )
      sub_1402A3D30(a1 + 0xFFFFFFFF);
    return a1 + 0xFFFFFFFF;
  }
  else
  {
    sub_140370D10(a1 + 5);
    sub_140370D10(a1 + 4);
    sub_140372C00((__int64)(a1 + 1));
    *a1 = &off_1481A0DB8;
    if ( (a2 & 1) != 0 )
      sub_1402A3D30(a1);
    return a1;
  }
}

// --- End Function: sub_140315440 (0x140315440) ---

// --- Function: sub_14035B240 (0x14035B240) ---
void **__fastcall sub_14035B240(void **a1, _BYTE *a2, _BYTE *a3)
{
  size_t Size; // rdi
  _DWORD *v6; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = a3 - a2;
  if ( a3 != a2 )
  {
    v6 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v6 + 2;
    *v6 = Size;
    v6[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B240 (0x14035B240) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_140361E00 (0x140361E00) ---
_QWORD *__fastcall sub_140361E00(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

// --- End Function: sub_140361E00 (0x140361E00) ---

// --- Function: sub_140370D10 (0x140370D10) ---
// // Decrements a reference count associated with a managed object and //
// deallocates the object's memory if the reference count is still positive. //
// This pattern is characteristic of shared pointer or reference-counted // memory
// management, where the reference count is stored in a control block // located
// just before the actual data pointed to by *a1. // // Parameters: //
// pManagedObjectPtr: A pointer to a QWORD, where the QWORD itself points //
// to the managed data. The reference count is expected //                      at
// an offset of -8 bytes from this data pointer.
void __fastcall sub_140370D10(_QWORD *pManagedObjectPtr)
{
  int *v1; // rcx

  v1 = (int *)(*pManagedObjectPtr - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140372C00 (0x140372C00) ---
void __fastcall sub_140372C00(__int64 a1)
{
  const void *v2; // rcx

  v2 = *(const void **)a1;
  if ( v2 )
  {
    if ( !*(_BYTE *)(a1 + 8) )
      sub_1402A3D30(v2);
    *(_QWORD *)a1 = 0;
  }
}

// --- End Function: sub_140372C00 (0x140372C00) ---

// --- Function: sub_140377F00 (0x140377F00) ---
char **__fastcall sub_140377F00(char **a1, char **a2)
{
  char *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
    sub_1403E9810(a2, 0, 0x20);
  return a1;
}

// --- End Function: sub_140377F00 (0x140377F00) ---

// --- Function: sub_14037FC70 (0x14037FC70) ---
const ULONG_PTR *__fastcall sub_14037FC70(__int64 a1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)a1 )
    return *(const ULONG_PTR **)a1;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14037FC70 (0x14037FC70) ---

// --- Function: sub_1403B1000 (0x1403B1000) ---
__int64 __fastcall sub_1403B1000(__int64 a1, __int64 a2)
{
  *(_DWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 0x10) = 0;
  return a2;
}

// --- End Function: sub_1403B1000 (0x1403B1000) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 + 0xFFFFFFFE);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 + 0xFFFFFFFE) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 + 0xFFFFFFFF) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 + 0xFFFFFFFE) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 + 0xFFFFFFFE)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 + 0xFFFFFFFE));
  memset(&(*a1)[*((int *)v3 + 0xFFFFFFFE)], Val_1, Size);
  if ( *((int *)v3 + 0xFFFFFFFF) > 0 )
    sub_147605980(v3 + 0xFFFFFFF8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_140583FC0 (0x140583FC0) ---
// Decompilation FAILED for sub_140583FC0 (0x140583FC0) - Decompiler returned None
// --- End Function: sub_140583FC0 (0x140583FC0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !gEnv || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_145944C60 (0x145944C60) ---
__int64 __fastcall sub_145944C60(__int64 a1)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = off_148AF49D8;
  *(_BYTE *)(a1 + 0x10) = 0;
  *(_DWORD *)(a1 + 0x18) = 0x4C8;
  sub_14035B3E0((_QWORD *)(a1 + 0x20));
  sub_14035B3E0((_QWORD *)(a1 + 0x28));
  return a1;
}

// --- End Function: sub_145944C60 (0x145944C60) ---

// --- Function: sub_145978DF0 (0x145978DF0) ---
const char *sub_145978DF0()
{
  return "InputAction";
}

// --- End Function: sub_145978DF0 (0x145978DF0) ---

// --- Function: sub_14597D1E0 (0x14597D1E0) ---
__int64 __fastcall sub_14597D1E0(__int64 a1, __int64 a2)
{
  int v2; // edi
  int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  char *v7; // rax

  v2 = dword_149E66424;
  if ( !dword_149E66424 )
  {
    v4 = sub_1402D2830(0x4Bu, 8, 0, 2);
    v5 = sub_1402CA4C0(0x4C11DB7, 1, (v4 << 0x19) ^ (unsigned int)((unsigned __int64)(v4 << 0x18) >> 0x1F) & 0x4C11DB7);
    v6 = sub_1402D2830(v5 >> 1, 0x20, v5 << 0x1F, 2);
    v2 = sub_1402E1FE0((unsigned __int8 *)"nputAction", v6 ^ 0xFFFFFFu);
    v7 = (char *)allocWithProfilerInfo(0xCu, 0);
    *(double *)v7 = *(double *)"InputAction";
    strcpy(v7 + 8, "ion");
    dword_149E66424 = v2;
    if ( v7 )
    {
      sub_147605980(v7);
      v2 = dword_149E66424;
    }
  }
  *(_DWORD *)a2 = v2;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 0x10) = 0;
  return a2;
}

// --- End Function: sub_14597D1E0 (0x14597D1E0) ---

// --- Function: sub_145991850 (0x145991850) ---
void __fastcall sub_145991850(__int64 a1)
{
  const char *v2; // rax
  char *v3; // rax
  char *v4; // rsi
  char **v5; // rax
  ULONG_PTR *v6; // rax
  void **v7; // rax
  void *v8; // [rsp+30h] [rbp+8h] BYREF

  v2 = (const char *)sub_14037FC70(a1 + 8);
  v3 = strchr(v2, 0x3A);
  v4 = v3;
  if ( v3 )
  {
    *(_DWORD *)(a1 + 0x18) = sub_140583FC0(v3 + 1);
    v5 = (char **)CreateStringObjectFromString(&v8, v4 + 1);
    sub_140377F00((char **)(a1 + 0x28), v5);
    sub_140370D10(&v8);
    v6 = (ULONG_PTR *)sub_14037FC70(a1 + 8);
    v7 = sub_14035B240(&v8, v6, v4);
    sub_140377F00((char **)(a1 + 0x20), (char **)v7);
    sub_140370D10(&v8);
  }
}

// --- End Function: sub_145991850 (0x145991850) ---

// --- Function: sub_146513000 (0x146513000) ---
__int64 __fastcall sub_146513000(char a1)
{
  __int64 v2; // rax
  char v4; // [rsp+30h] [rbp-18h]

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0);
  if ( (dword_149E7EF8C & 1) == 0 )
  {
    n10_579 = 0xA;
    dword_149E7EF8C |= 1u;
    qword_149A8B620 = 0;
    word_149A8B640 = 0;
    byte_149A8B642 = 0;
    qword_149A8B648 = 0;
    byte_149A8B61A = 0;
    qword_149A8B628 = 0;
    qword_149A8B630 = 0;
    qword_149A8B638 = 0;
  }
  v4 = a1;
  // "actionName"
  return (*(__int64 (__fastcall **)(__int64, const char *, __int64 (__fastcall **)(), char **, __int64, _QWORD, char, __int64))(*(_QWORD *)v2 + 0x108LL))(
           v2,
           "InputAction",
           off_149A8B650,
           &off_149A8B600,
           1,
           0,
           v4,
           0x30);
}

// --- End Function: sub_146513000 (0x146513000) ---

// --- Function: sub_14652BC20 (0x14652BC20) ---
__int64 __fastcall sub_14652BC20(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 0x20) = 0x4C8;
  *(_QWORD *)a1 = off_148BDD428;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 8) = off_148AF49D8;
  *(_BYTE *)(a1 + 0x18) = 0;
  sub_14035B3E0((_QWORD *)(a1 + 0x28));
  sub_14035B3E0((_QWORD *)(a1 + 0x30));
  sub_140361E00((_QWORD *)(a1 + 0x38));
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x50) = off_1481ACA68;
  result = a1;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x78) = 0x10;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  return result;
}

// --- End Function: sub_14652BC20 (0x14652BC20) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE58LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n0x6900 = 0x6900;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  isProfileFunctionsInitialized(
    &n0x6900,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    0xA7);
  HIWORD(n0x6900) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n0x6900);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: strchr (0x148082143) ---
// attributes: thunk
char *__cdecl strchr(const char *Str, int Val)
{
  return __imp_strchr(Str, Val);
}

// --- End Function: strchr (0x148082143) ---

