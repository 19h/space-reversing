// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x1422BC915 (sub_1422BC170)
//   - 0x142432BA3 (sub_142432A30)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 70
// ------------------------------------------------------------

// --- Function: sub_1402A6590 (0x1402A6590) ---
__int64 __fastcall sub_1402A6590(__int64 a1)
{
  return sub_147715880(a1, (unsigned int)dword_149A5EC00);
}

// --- End Function: sub_1402A6590 (0x1402A6590) ---

// --- Function: sub_1402A65A0 (0x1402A65A0) ---
__int64 __fastcall sub_1402A65A0(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: sub_1402A65A0 (0x1402A65A0) ---

// --- Function: sub_1402A6BE0 (0x1402A6BE0) ---
void *sub_1402A6BE0()
{
  return &unk_149C78580;
}

// --- End Function: sub_1402A6BE0 (0x1402A6BE0) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8FF0) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  __int64 v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10(this);
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)sub_1402A65A0(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E3880();
  v13 = sub_1402A65A0(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(_QWORD *)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A6590(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A8FF0) ---

// --- Function: sub_1402ABF30 (0x1402ABF30) ---
const void **__fastcall sub_1402ABF30(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  size_t Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  size_t v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  __int64 v17; // rbx

  Size_1 = (size_t)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = Size_1 + a2;
  v11 = (Size_1 + a2) | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
        v15 = 0;
      else
        v15 = (_QWORD *)sub_1402A65A0(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 0x28;
    if ( v6 + 0x28 < (unsigned __int64)(v6 + 1) )
      sub_1402E3880();
  }
  v14 = sub_1402A65A0(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v15[0xFFFFFFFF] = v14;
LABEL_15:
  Src[2] = (const void *)v10;
  v16 = (char *)v15 + Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, Size_1);
    memcpy((char *)v15 + Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = (__int64)*Src;
  memcpy(v15, *Src, Size_1);
  memcpy((char *)v15 + Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v17 - *(_QWORD *)(v17 - 8) - 8) <= 0x1F )
    {
      v17 = *(_QWORD *)(v17 - 8);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A6590(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402ABF30 (0x1402ABF30) ---

// --- Function: sub_1402C6D50 (0x1402C6D50) ---
__int64 __fastcall sub_1402C6D50(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0x24;
  sub_1402C88C0(
    a1,
    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    *(unsigned __int8 *)(a2 + 7),
    *(unsigned __int8 *)(a2 + 6),
    *(unsigned __int8 *)(a2 + 5),
    *(unsigned __int8 *)(a2 + 4),
    HIBYTE(*(_DWORD *)a2),
    (unsigned __int8)BYTE2(*(_DWORD *)a2),
    BYTE1(*(_DWORD *)a2),
    (unsigned __int8)*(_DWORD *)a2,
    *(unsigned __int8 *)(a2 + 0xF),
    *(unsigned __int8 *)(a2 + 0xE),
    *(unsigned __int8 *)(a2 + 0xD),
    *(unsigned __int8 *)(a2 + 0xC),
    HIBYTE(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)BYTE2(*(_DWORD *)(a2 + 8)),
    BYTE1(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)*(_DWORD *)(a2 + 8));
  return a1;
}

// --- End Function: sub_1402C6D50 (0x1402C6D50) ---

// --- Function: sub_1402C88C0 (0x1402C88C0) ---
__int64 sub_1402C88C0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  unsigned __int64 v5; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( Buffer[v5] );
  sub_1402E0CC0(a1, Buffer);
  return a1;
}

// --- End Function: sub_1402C88C0 (0x1402C88C0) ---

// --- Function: NtCurrentTeb_w (0x1402C8AD0) ---
__int64 sub_1402C8AD0()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C8AD0) ---

// --- Function: fprintf (0x1402F9B00) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A6BE0();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F9B00) ---

// --- Function: sub_1402FD830 (0x1402FD830) ---
void *__fastcall sub_1402FD830(_QWORD *a1, const void *a2, size_t Size)
{
  __int64 n0x16; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n0x16 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 0xF;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_1402A65A0(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    v10[0xFFFFFFFF] = v9;
    goto LABEL_17;
  }
  n0x16 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n0x16 = 0x16;
  if ( (unsigned __int64)(n0x16 + 1) >= 0x1000 )
  {
    allocSize = n0x16 + 0x28;
    if ( n0x16 + 0x28 < (unsigned __int64)(n0x16 + 1) )
      sub_1402E3880();
    goto LABEL_6;
  }
  if ( n0x16 == 0xFFFFFFFFFFFFFFFFuLL )
    v10 = 0;
  else
    v10 = (_QWORD *)sub_1402A65A0(n0x16 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n0x16;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FD830 (0x1402FD830) ---

// --- Function: sub_1403005F0 (0x1403005F0) ---
__int64 __fastcall sub_1403005F0(char *a1, char *a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n0x100; // rax
  char *v7; // r15
  char *v8; // rdi
  char *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  char *v30; // rsi
  int v31; // [rsp+20h] [rbp-48h]
  char *v32; // [rsp+30h] [rbp-38h] BYREF
  char *v33; // [rsp+38h] [rbp-30h]
  __int64 v34; // [rsp+70h] [rbp+8h] BYREF

  n0x100 = (a2 - a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( v8 != v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 0x50) < *(_QWORD *)(*(_QWORD *)v8 + 0x50LL) )
          {
            n0x100 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i + 0xFFFFFFFF);
              i += 0xFFFFFFF8;
              n0x100 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n0x100 )
              {
                if ( *(_QWORD *)(v14 + 8) != n0x100 )
                  break;
                n0x100 = *(_QWORD *)(v17 + 0x50);
                if ( *(_QWORD *)(v14 + 0x50) >= (unsigned __int64)n0x100 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FFF10(&v32, v8, v7, a4);
      v9 = v32;
      v10 = v33;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((v32 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - v33) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1403005F0(v33, v7, a3, a4);
        v7 = v9;
      }
      else
      {
        sub_1403005F0(v8, v32, a3, a4);
        v8 = v10;
      }
      n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    v18 = (v7 - v8) >> 3;
    v19 = (v7 - v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 0x50) < *(_QWORD *)(v25 + 0x50) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 0x50) >= *(_QWORD *)(v21 + 0x50)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n0x100 = (v7 - v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v30 = v7 + 0xFFFFFFF8;
      do
      {
        v34 = *(_QWORD *)v30;
        *(_QWORD *)v30 = *(_QWORD *)v8;
        LOBYTE(v31) = a4;
        sub_1403001D0(v8, 0, (v30 - v8) >> 3, &v34, v31);
        v30 += 0xFFFFFFF8;
        n0x100 = (unsigned __int64)&v30[8LL - (_QWORD)v8] & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n0x100 >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_1403005F0 (0x1403005F0) ---

// --- Function: sub_140301AF0 (0x140301AF0) ---
_QWORD *__fastcall sub_140301AF0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __int64 p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __int64 p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)sub_1402A65A0(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)sub_1402A65A0(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    memset(&Src, 0, sizeof(Src));
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FD830(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402ABF30((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(_QWORD *)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = (__m256 *)p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = sub_1402A65A0(0x30u);
      *(_QWORD *)(v23 + 0x20) = 0;
      *(_QWORD *)(v23 + 0x28) = 0;
      *(__m256 *)(v23 + 0x10) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 0xF;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x10LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x28LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(_QWORD *)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
        if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A6590(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140301AF0 (0x140301AF0) ---

// --- Function: sub_1403023E0 (0x1403023E0) ---
bool __fastcall sub_1403023E0(__int64 a1, _QWORD *a2, __int64 *a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  __int64 __Val_0___1; // r10
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // bp
  __int64 v18; // rdi
  __int64 v19; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v21; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v23; // rdi
  unsigned __int64 v24; // r9
  char v25; // al
  __int64 v26; // r8
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rax
  unsigned __int64 v30; // [rsp+20h] [rbp-48h]
  bool v32; // [rsp+80h] [rbp+18h]

  v7 = sub_1403031E0(*((unsigned int *)a3 + 9), a2, a3[3], a1);
  if ( v9 + v7 > v10 )
    return 0;
  v13 = *((unsigned int *)a3 + 8);
  v17 = 0;
  if ( (_DWORD)v13 != 1 )
  {
    v14 = sub_1403031E0(v13, v8, v9, v10);
    if ( v15 + v14 < v16 )
      v17 = 1;
  }
  v18 = a3[1];
  v19 = *a3;
  v32 = v17;
  if ( (v18 - *a3) / 0x70 != _Newcapacity )
  {
    if ( v19 != v18 )
    {
      do
      {
        if ( *(_BYTE *)(v19 + 0x58) && *(_QWORD *)v19 )
          (*(void (**)(void))(v19 + 0x40))();
        v19 += 0x70;
      }
      while ( v19 != v18 );
      a3[1] = *a3;
    }
    sub_1403002C0(a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v17 = 1;
    v32 = 1;
  }
  _Newcapacity_2 = 0;
  v21 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v23 = __Val_0___1 + 0x30;
    v24 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v30 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v17 )
    {
      v21 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v23 + 0x18)
        && *(_QWORD *)v23 )
      {
        if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_1 )
          __debugbreak();
        v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v23)(*(_QWORD *)(v23 - 0x30), *(_QWORD *)(v24 + v23 + *a3));
        v24 = v30;
        v17 = v25 == 0;
        v32 = v25 == 0;
      }
      ++_Newcapacity_1;
      v23 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v17 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v27 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v21 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v27 + 0x38)
          && *(_QWORD *)(v27 + 0x20) )
        {
          if ( (a3[1] - *a3) / 0x70 <= _Newcapacity_2 )
            __debugbreak();
          v28 = v27 + v26 + *a3;
          if ( *(_BYTE *)(v28 + 0x58) )
          {
            if ( *(_QWORD *)v28 )
              (*(void (**)(void))(v28 + 0x40))();
          }
          v29 = (*(__int64 (__fastcall **)(_QWORD))(v27 + 0x38))(*(_QWORD *)(v27 - 0x10));
          v26 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v28 = v29;
          *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 - 8);
          *(_QWORD *)(v28 + 0x10) = *(_QWORD *)v27;
          *(_QWORD *)(v28 + 0x18) = *(_QWORD *)(v27 + 8);
          *(_QWORD *)(v28 + 0x20) = *(_QWORD *)(v27 + 0x10);
          *(_QWORD *)(v28 + 0x30) = *(_QWORD *)(v27 + 0x20);
          *(_QWORD *)(v28 + 0x28) = *(_QWORD *)(v27 + 0x18);
          *(_QWORD *)(v28 + 0x38) = *(_QWORD *)(v27 + 0x28);
          *(_QWORD *)(v28 + 0x40) = *(_QWORD *)(v27 + 0x30);
          *(_QWORD *)(v28 + 0x48) = *(_QWORD *)(v27 + 0x38);
          *(_QWORD *)(v28 + 0x50) = *(_QWORD *)(v27 + 0x40);
          *(_QWORD *)(v28 + 0x60) = *(_QWORD *)(v27 + 0x50);
          *(_QWORD *)(v28 + 0x68) = *(_QWORD *)(v27 + 0x58);
          *(_BYTE *)(v28 + 0x58) = 1;
          *(_BYTE *)(v28 + 0x59) = *(_BYTE *)(v27 + 0x49);
        }
        ++_Newcapacity_2;
        v27 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v17 = v32;
    }
    a3[3] = a1;
  }
  return v17;
}

// --- End Function: sub_1403023E0 (0x1403023E0) ---

// --- Function: sub_1403030E0 (0x1403030E0) ---
__int64 __fastcall sub_1403030E0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", v3 - 0x3E8 * v7) + 0x13);
}

// --- End Function: sub_1403030E0 (0x1403030E0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1403031A0) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149C78D00 )
    result = qword_149C78D00(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149C78D18 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149C78D20 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1403031A0) ---

// --- Function: sub_140304A70 (0x140304A70) ---
__int64 __fastcall sub_140304A70(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        __int64 a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  __int64 v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  unsigned int v87[2]; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149A5E708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149A5E720[0];
  }
  else
  {
    v17 = off_149A5E728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149A5E738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149A5E710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149A5E710 )
      {
        memcpy(Buffer, off_149A5E710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_140300EA0((double *)Buffer, Size, (int)Size_1 + 1LL, (const void **)v87, v21, (__int64)&off_149A5E710, "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149A5E710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149A5E710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149A5E710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149A5E710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149A5E730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149A5E730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149A5E730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149A5E730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149A5E710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  *(_QWORD *)v87 = v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149A5E710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149A5E710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149A5E710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = *(_QWORD *)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = v45 + 2;
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( Size_11 + v48 >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[v48];
  Size_12 = Size - v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140307B30(
          (_DWORD)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64)sub_1402FFA40);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149A5E710;
      *(_QWORD *)v87 = qword_149C789B0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149A5E710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_140300EA0(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149A5E718,
                        (const void **)(*(_QWORD *)v87 + Sizec),
                        (__int64)&off_149A5E710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149A5E710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149A5E710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149C78D18(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140304A70 (0x140304A70) ---

// --- Function: sub_140305570 (0x140305570) ---
__int64 __fastcall sub_140305570(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        char *a7,
        __int64 a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        __int64 a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_27; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  int n0xF_8; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  int n0xF_10; // ebp
  int n0xF_11; // r14d
  int n0xF_12; // r15d
  int n0xF_13; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_14; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_15; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_16; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_17; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_23; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_19; // edx
  int n0xF_20; // ecx
  bool v109; // r15
  int n0xF_21; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_24; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_25; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_26; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  __int64 *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  int n0xF_9; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  int n0xF_18; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_22; // [rsp+98h] [rbp-D0h]
  __int64 n0xF_5; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  __int64 v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, __int64, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 0x80;
  LODWORD(n0xF_5) = n4;
  v159 = a6;
  n0xF_22 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_27 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_140300DE0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_27 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_27;
  if ( n0xF_27 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_27 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149C78D28 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149C78D28(
              v162,
              v161,
              n4_1,
              v166,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149C78D20;
  v156 = v50;
  v51 = (a18 & 1) != 0 && ::n2 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_0 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149C78CF8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_9 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_95;
    }
    v53 = qword_149C78CF8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149C78CF8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_9 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_8 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_9 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_8 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_140301320(
            Buffer,
            n0xF_3,
            n0xF_2,
            (__int64)",\"@severity\":",
            &n0xF_5,
            ",\"severity\":\"",
            (__int64)&off_149A5E738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    LODWORD(n0xF_5) = n0xF_8;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149C789B0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_22 )
    {
LABEL_129:
      n0xF_3 = n0xF + 0x80;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_8 = n0xF_5;
      v62 = v160;
      v58 = v159;
      goto LABEL_131;
    }
    Size_7 = n0xF_22 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_22 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 0x22;
      }
      else
      {
LABEL_111:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_22 )
      goto LABEL_130;
    n2 = n0xF_22 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_8 = n0xF_5;
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_9 = n0xF_8;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149C789B0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_140301050(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_10 = n0xF_8;
    n0xF_11 = n0xF_6;
    v47 = 1;
    n0xF_12 = n0xF_2;
    n0xF_13 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_9 = n0xF_8;
LABEL_145:
  n0xF_10 = n0xF_8;
  n0xF_11 = n0xF_6;
  n0xF_12 = n0xF_2;
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_13;
      n0xF_9 = n0xF_8;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_9 = n0xF_10;
    n0xF_2 = n0xF_12 + 0xB;
    n0xF_6 = n0xF_11;
    n0xF_8 = n0xF_10;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_1403032F0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_14 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_14 = n0xF_2;
        n0xF_2 = n0xF_14;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_9 = n0xF_8;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_9 = n0xF_8;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_1403032F0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_15 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_15 = n0xF_2;
        n0xF_2 = n0xF_15;
      }
    }
    n0xF_8 = n0xF_9;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_209:
  n0xF_16 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140307B30((_DWORD)Buffer, n0xF, n0xF_2, v164, __Val_0___1, _Newcapacity, a11, 1, (__int64)sub_1402FFA80);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_16;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_17 = n0xF_29;
  v102 = 0;
  n0xF_5 = 0;
  v103 = 0;
  n0xF_23 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_23);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_8 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_18 = n0xF_8;
              n0xF_19 = n0xF_2;
              n0xF_20 = n0xF_8;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_21 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_19 = n0xF_2;
            n0xF_18 = n0xF_8;
            n0xF_20 = n0xF_8;
            n0xF_21 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_8 )
            {
LABEL_248:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_22 )
              {
                v105 = v160;
                n0xF_8 = n0xF_20;
                n0xF_2 = n0xF_19;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_255;
              }
              if ( n0xF_22 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 0x16;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_8 = n0xF_18;
                n0xF_2 = n0xF_21;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_8 = n0xF_18;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_21;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_21;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_8 && n0xF_2 + 1LL < n0xF_22 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_292;
                }
                if ( n0xF_22 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_23 = n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_23 = n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_8 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_20 = n0xF_8;
          n0xF_18 = n0xF_8;
          v47 = 1;
          n0xF_19 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_21 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_23 >= n0xF_17 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_24 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_24 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_25 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_25;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_8 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_22 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_22 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_315:
      n0xF_17 = n0xF_29;
      if ( (n0xF_23 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_8 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_17 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      n0xF_5 = ++n0xF_23;
      if ( n0xF_23 >= n0xF_17 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( (int)a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_8 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_8 )
  {
    v137 = sub_1403011A0(Buffer, n0xF_3, n0xF_2, (__int64)",\"EVT_COUNT\":", (int *)&a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149C78D30 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149C78D30(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_26 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_26 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_26, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (__int64 *)n0xF_26;
    v147 = v161;
    qword_149C78D20(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140305570 (0x140305570) ---

// --- Function: sub_140306C00 (0x140306C00) ---
void __fastcall sub_140306C00(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)sub_1402A65A0(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E3880();
      v8 = sub_1402A65A0(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_140306C00 (0x140306C00) ---

// --- Function: sub_140306CF0 (0x140306CF0) ---
char __fastcall sub_140306CF0(
        int n4_1,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 __Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // r14
  char result; // al
  unsigned __int64 n0x10; // rax
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v17; // r13
  char *v18; // r15
  __int64 v19; // r14
  const vraudio::AudioBuffer *__Val_0___2; // rdi
  unsigned __int8 v21; // si
  const vraudio::AudioBuffer *__Val_0___5; // r15
  __int64 *v23; // rax
  __int64 *v24; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v26; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v30; // r13
  __int64 (__fastcall *v31)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v32; // rax
  unsigned __int64 v33; // rcx
  __int64 *v34; // rdi
  _QWORD *v35; // r13
  bool v36; // zf
  _QWORD *v37; // rbx
  _QWORD *v38; // rax
  _BYTE *v39; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v42; // r9
  __int64 v43; // rcx
  __m256 *p_Src; // r14
  char *v45; // r14
  const vraudio::AudioBuffer *__Val_0___4; // r12
  unsigned __int64 n0xF; // r13
  __int64 p_Src_2; // r15
  _QWORD *v49; // r14
  _QWORD *v50; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v55; // rax
  __int64 *v56; // rcx
  __int64 v57; // rcx
  _QWORD *v58; // rbx
  __int64 v59; // rcx
  __int64 *v60; // r14
  __int64 p_Src_3; // rax
  __int64 *v62; // rax
  unsigned __int64 n0x400_3; // r15
  __int64 v64; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v68; // rax
  char *v69; // r11
  __int64 v70; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v72; // rdi
  int v73; // r13d
  __int64 v74; // rcx
  __int64 v75; // r9
  unsigned __int64 n0x400_4; // r8
  __int64 v77; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v82; // rax
  __int64 v83; // r15
  char *v84; // r14
  __int64 v85; // rax
  void *v86; // rsp
  __int64 (__fastcall *v87)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v88; // edx
  int v89; // r12d
  char v90; // cl
  int v91; // eax
  FILE *File; // rax
  int n2; // r8d
  FILE *File_1; // rax
  char v95; // al
  bool v96; // dl
  bool v97; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v99; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v104; // rax
  void *v105; // rsp
  char v106; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v109; // rsi
  _QWORD **v110; // rcx
  _QWORD *v111; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v113; // rdi
  __int64 v114; // rcx
  __int64 *v115; // rbx
  __int64 v116; // rcx
  int v117; // [rsp+90h] [rbp-10h]
  unsigned __int8 v118; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0x400_2; // [rsp+A8h] [rbp+8h]
  __int64 *v120; // [rsp+B0h] [rbp+10h]
  __int64 v121; // [rsp+B8h] [rbp+18h]
  int n4; // [rsp+C0h] [rbp+20h]
  __int64 v123; // [rsp+C8h] [rbp+28h] BYREF
  unsigned __int64 v124; // [rsp+D0h] [rbp+30h]
  char *v125; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  __int64 __Val_0___7; // [rsp+F0h] [rbp+50h]
  int v129[2]; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0__; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v131; // [rsp+108h] [rbp+68h] BYREF
  __int64 __Val_0___3; // [rsp+110h] [rbp+70h]
  __int64 v133; // [rsp+118h] [rbp+78h]
  void *v134; // [rsp+120h] [rbp+80h]
  __int64 v135; // [rsp+128h] [rbp+88h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+130h] [rbp+90h]
  _QWORD *v137; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___1; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v142; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v143; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v144; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v147[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v148[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v133 = a4;
  v134 = a3;
  v135 = a2;
  n4 = n4_1;
  __Val_0___7 = __Val_0___8;
  if ( qword_149C78C98 )
  {
    v12 = qword_149C78C98();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  *(_QWORD *)v129 = v12;
  if ( v11 )
  {
    result = sub_1403023E0(v12, v10, v11, __Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_149C78CF0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149C78CF0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149C78D60++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403030E0(Buffer, 0x20u, v12);
  v143 = (__int64 *)&v142;
  n0x10 = 0;
  v142 = 0;
  v15 = 0;
  v120 = 0;
  n0x400 = 0;
  n0x400_2 = 0;
  v17 = 0;
  v121 = 0;
  v18 = 0;
  n0x10_1 = 0;
  v19 = 0;
  v125 = 0;
  v123 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v72 = (char *)v148;
    goto LABEL_106;
  }
  __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___7;
  v21 = v118;
  __Val_0___3 = __Val_0___7;
  while ( 2 )
  {
    __Val_0___5 = __Val_0___2;
    if ( *((_BYTE *)__Val_0___2 + 0x59) && n0x10 < 0x10 )
    {
      v147[n0x10++] = __Val_0___2;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0__ = (unsigned __int64)__Val_0___2;
    if ( n0x400 < 0x400 )
    {
      v148[n0x400] = __Val_0___2;
LABEL_30:
      n0x400_2 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149A5E748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v23 = (__int64 *)sub_1402A65A0(0x18u);
        v15 = v23;
        v120 = v23;
        if ( v23 )
        {
          v24 = v23;
          *v23 = 0;
          n0x400_1 = 0;
          v23[1] = 0;
          v26 = (__int64)v23;
          v23[2] = 0;
        }
        else
        {
          v15 = 0;
          v24 = 0;
          n0x400_1 = 0;
          v120 = 0;
          v26 = 0;
        }
        sub_140306C00(v26, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v148;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v24[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v24[2] )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              (std::vector<vraudio::AudioBuffer const *> *)v15,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v24[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0x400_2;
        __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
        v19 = v123;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v15[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v15[2] )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          (std::vector<vraudio::AudioBuffer const *> *)v15,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0__);
      }
      else
      {
        *_Whereptr_1 = __Val_0___2;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v121 = *((_QWORD *)__Val_0___2 + 0xD) + v17;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___2 + 1) = sub_140301AF0(&v143, (__int64)__Val_0___2);
    v30 = v19;
    v31 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___2 + 7);
    v144 = v19++;
    v123 = v19;
    if ( !v31 )
    {
      v69 = v125;
      goto LABEL_98;
    }
    __Val_0__ = 0;
    v131 = 0;
    v32 = v31(*(_QWORD *)__Val_0___2, &v131, &__Val_0__);
    v33 = 0;
    v124 = 0;
    if ( !v131 )
      goto LABEL_94;
    v34 = v143;
    v35 = (_QWORD *)(v32 + 0x10);
    v137 = (_QWORD *)(v32 + 0x10);
    do
    {
      __Val_0___5 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      __Val_0___6 = (const vraudio::AudioBuffer *)(v35 + 0xFFFFFFFE);
      v36 = *v35 == 0;
      v123 = v19 + 1;
      v35[8] = v19;
      if ( v36 )
      {
        v58 = (_QWORD *)v35[0xFFFFFFFF];
        v60 = 0;
      }
      else
      {
        if ( !*v34 )
        {
          __asm { vzeroupper }
          v37 = (_QWORD *)sub_1402A65A0(0x10u);
          if ( v37 )
          {
            *v37 = 0;
            v37[1] = 0;
            v38 = (_QWORD *)sub_1402A65A0(0x30u);
            *v38 = v38;
            v38[1] = v38;
            *v37 = v38;
          }
          else
          {
            v37 = 0;
          }
          *v34 = (__int64)v37;
        }
        v39 = (_BYTE *)v35[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v39[Size_1] );
        __asm { vzeroupper }
        sub_1402FD830(&Src, v39, Size_1);
        v42 = (_BYTE *)*v35;
        do
          ++Size;
        while ( v42[Size] );
        v43 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402ABF30((const void **)&Src, Size, v21, v42, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v45 = (char *)p_Src + v43;
          memmove(v45, v42, Size);
          v45[Size] = 0;
        }
        __Val_0___4 = (const vraudio::AudioBuffer *)*v34;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(_QWORD *)Src.m256_f32;
        __Val_0___1 = __Val_0___4;
        v49 = *(_QWORD **)__Val_0___4;
        v50 = **(_QWORD ***)__Val_0___4;
        if ( v50 == *(_QWORD **)__Val_0___4 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v50[4];
          Buf1 = v50 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = (__m256 *)p_Src_2;
          if ( v50[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v50 = (_QWORD *)*v50;
        }
        while ( v50 != v49 );
        __Val_0___4 = __Val_0___1;
        if ( v50 == v49 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___4 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v55 = sub_1402A65A0(0x30u);
          *(_QWORD *)(v55 + 0x20) = 0;
          *(_QWORD *)(v55 + 0x28) = 0;
          *(__m256 *)(v55 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___4 + 1);
          v56 = (__int64 *)v49[1];
          *(_QWORD *)v55 = v49;
          *(_QWORD *)(v55 + 8) = v56;
          v49[1] = v55;
          *v56 = v55;
          v57 = *(_QWORD *)*v34;
          v58 = (_QWORD *)(*(_QWORD *)(v57 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v57 + 8) + 0x28LL) > 0xFu )
            v58 = (_QWORD *)*v58;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v59 = *(_QWORD *)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v59 = *(_QWORD *)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - v59 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A6590(v59);
          }
LABEL_66:
          v15 = v120;
          v60 = 0;
          v35 = v137;
          __Val_0___5 = __Val_0___6;
          v33 = v124;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v58 = v50 + 2;
        if ( v58[3] > 0xFu )
          v58 = (_QWORD *)*v58;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
          if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A6590(p_Src_2);
        v15 = v120;
        v60 = 0;
        v35 = v137;
        __Val_0___5 = __Val_0___6;
        v33 = v124;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___5 + 1) = v58;
      n0x400 = n0x400_2;
      __Val_0___1 = __Val_0___5;
      if ( n0x400_2 >= 0x400 )
      {
        if ( !byte_149A5E748 )
          goto LABEL_92;
        if ( !v15 )
        {
          __asm { vzeroupper }
          v62 = (__int64 *)sub_1402A65A0(0x18u);
          n0x400_3 = 0;
          v120 = v62;
          v15 = v62;
          if ( v62 )
          {
            *v62 = 0;
            v64 = (__int64)v62;
            v62[1] = 0;
            v62[2] = 0;
            v60 = v62;
          }
          else
          {
            v15 = 0;
            v120 = 0;
            v64 = 0;
          }
          sub_140306C00(v64, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v148;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v60[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v60[2] )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                (std::vector<vraudio::AudioBuffer const *> *)v15,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v60[1] += 8;
            }
            ++n0x400_3;
            ++__Val_0__1;
          }
          while ( n0x400_3 < 0x400 );
          n0x400 = n0x400_2;
          __Val_0___5 = __Val_0___6;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v15[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v15[2] )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            (std::vector<vraudio::AudioBuffer const *> *)v15,
            _Whereptr_3,
            &__Val_0___1);
        }
        else
        {
          *_Whereptr_3 = __Val_0___5;
          v15[1] += 8;
        }
        v33 = v124;
      }
      else
      {
        v148[n0x400_2] = __Val_0___5;
      }
      n0x400_2 = ++n0x400;
LABEL_92:
      ++v33;
      v68 = v35[0xB] + v121;
      v35 += 0xE;
      v19 = v123;
      v121 = v68;
      v124 = v33;
      v137 = v35;
    }
    while ( v33 < v131 );
    __Val_0___2 = (const vraudio::AudioBuffer *)__Val_0___3;
    v30 = v144;
LABEL_94:
    if ( __Val_0__ > 1 )
      v30 = 0xFFFFFFFFFFFFFFFFuLL;
    v69 = &v125[__Val_0__];
    v125 += __Val_0__;
LABEL_98:
    __Val_0___2 = (const vraudio::AudioBuffer *)((char *)__Val_0___2 + 0x70);
    v70 = v121;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___5 + 0xA) = v30;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___3 = (__int64)__Val_0___2;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v17 = v70;
      continue;
    }
    break;
  }
  v18 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  v125 = v69;
  if ( !v15 )
    goto LABEL_105;
  if ( !((v15[1] - *v15) >> 3) )
    __debugbreak();
  v72 = (char *)*v15;
  v120 = v15;
  n0x400_2 = n0x400;
  v121 = v70;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v125 = v69;
LABEL_106:
  __asm { vzeroupper }
  sub_1403005F0(v72, &v72[8 * n0x400], (__int64)(8 * n0x400) >> 3, v118);
  v73 = 0;
  v74 = 0;
  v75 = 0;
  for ( n0x400_4 = 0; n0x400_4 < n0x400; ++n0x400_4 )
  {
    v77 = *(_QWORD *)&v72[8 * n0x400_4];
    if ( v75 == *(_QWORD *)(v77 + 8) )
    {
      if ( ++v74 == 1 )
        *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 0x50LL) = v74;
    }
    else
    {
      v74 = 0;
      *(_QWORD *)(v77 + 0x50) = -(__int64)(*(_QWORD *)(v77 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v75 = *(_QWORD *)(*(_QWORD *)&v72[8 * n0x400_4] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = n0x8000_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
    n0x8000 = ::n0x8000;
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
    n0x100000 = ::n0x100000;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149A5E748 )
    p_n0x8000 = &n0x8000_1;
  if ( !n0x8000_0 )
    n0x8000_2 = (_QWORD)(v18 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v83 = 0;
  }
  else
  {
    v82 = sub_1402A65A0(n0x8000_2);
    v83 = v82;
    if ( v82 )
    {
      v84 = (char *)v82;
      goto LABEL_130;
    }
  }
  v85 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v85 = 0xFFFFFFFFFFFFFF0LL;
  v86 = alloca(v85 & 0xFFFFFFFFFFFFFFF0uLL);
  v84 = (char *)&v118;
LABEL_130:
  v87 = (__int64 (__fastcall *)(_QWORD, _QWORD, void *, __int64, __int64, __int64, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149C78D08;
  v88 = 1;
  *v84 = 0;
  v89 = 0;
  LODWORD(v123) = 0;
  LODWORD(v124) = 1;
  if ( v87 && qword_149C78D10 && byte_149A5E748 )
  {
    v88 = v87(*(_QWORD *)v129, (unsigned int)n4, v134, v135, v133, __Val_0___7, _Newcapacity, v147, n0x10_1, &a8);
    LODWORD(v124) = v88;
  }
  v90 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v91 = sub_140304A70(
            *(_QWORD *)&FileTime,
            *(__int64 *)v129,
            (__int64)String,
            n4,
            (__int64 *)v135,
            v134,
            v133,
            (_QWORD *)__Val_0___7,
            _Newcapacity,
            a7,
            v84,
            n0x8000_2,
            (int *)&v123,
            v88,
            &a8);
    v90 = a8;
    v89 = v91;
    v73 = v123;
  }
  if ( ::n2 == 1 && (v90 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v84);
    v90 = a8;
  }
  n2 = n2_0;
  if ( n2_0 == 1 && (v90 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(n2_0 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v84);
    n2 = n2_0;
  }
  v84[v89] = 0;
  v95 = a8;
  v96 = (a8 & 1) != 0 && ::n2 == 2;
  v97 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v96 || v97 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149A5E748 )
      p_n0x8000_1 = &n0x8000_1;
    v99 = qword_149C78D48;
    if ( !qword_149C78D48 )
      v99 = v121 + v89 + ((_QWORD)(v125 + 4) << 9);
    n0x8000_3 = v99 + 0x80;
    if ( *p_n0x8000_1 < v99 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = sub_1402A65A0(n0x8000_3);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v104 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v104 = 0xFFFFFFFFFFFFFF0LL;
    v105 = alloca(v104 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v118;
LABEL_166:
    v117 = v124;
    *(_BYTE *)Buffer_1 = 0;
    sub_140305570(
      *(_QWORD *)&FileTime,
      *(__int64 *)v129,
      Buffer,
      String,
      n4,
      (_QWORD *)v135,
      v134,
      v133,
      __Val_0___7,
      _Newcapacity,
      a7,
      (__int64)v72,
      n0x400_2,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v84[v73],
      v89 - v73,
      a8,
      v117);
    sub_1402A6590(Buffer_3);
    v95 = a8;
  }
  v106 = byte_149C789B8;
  if ( byte_149C789B8 )
  {
    if ( (v95 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v95 = a8;
      v106 = byte_149C789B8;
    }
    if ( v106 )
    {
      if ( (v95 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A6590(v83);
  v109 = v142;
  if ( v142 )
  {
    v110 = (_QWORD **)*v142;
    **(_QWORD **)(*v142 + 8) = 0;
    v111 = *v110;
    if ( *v110 )
    {
      do
      {
        n0xF_1 = v111[5];
        v113 = (_QWORD *)*v111;
        if ( n0xF_1 > 0xF )
        {
          v114 = v111[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v114 - *(_QWORD *)(v114 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v114 = *(_QWORD *)(v114 - 8);
          }
          sub_1402A6590(v114);
        }
        v111[4] = 0;
        v111[5] = 0xF;
        *((_BYTE *)v111 + 0x10) = 0;
        sub_1402A6590((__int64)v111);
        v111 = v113;
      }
      while ( v113 );
    }
    sub_1402A6590(*v109);
    result = sub_1402A6590((__int64)v109);
  }
  v115 = v120;
  if ( v120 )
  {
    v116 = *v120;
    if ( *v120 )
    {
      if ( ((v120[2] - v116) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v116 - *(_QWORD *)(v116 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v116 = *(_QWORD *)(v116 - 8);
      }
      sub_1402A6590(v116);
      *v115 = 0;
      v115[1] = 0;
      v115[2] = 0;
    }
    return sub_1402A6590((__int64)v115);
  }
  return result;
}

// --- End Function: sub_140306CF0 (0x140306CF0) ---

// --- Function: swprintf (0x140308540) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A6BE0();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: swprintf (0x140308540) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x1403114B0) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  char v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = is_thread_privileged_or_bypass_mode()) != 0 )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || (unsigned __int8)sub_140395410(a1) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x1403114B0) ---

// --- Function: map_flag_to_mask (0x140327450) ---
// Maps specific input flags to corresponding mask values. If the input flag is not
// recognized, the function returns 0. The known mappings are: - 0x2000 ->
// 0x1000000 - 0x4000 -> 0x2000000 - 0x6000 -> 0x4000000 - 0x8000 -> 0x8000000 -
// 0xA000 -> 0x20000000 - 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140327450) ---

// --- Function: sub_140354250 (0x140354250) ---
char __fastcall sub_140354250(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        __int64 a9)
{
  __int64 v10; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-18h]
  __int64 n0xB0; // [rsp+90h] [rbp-10h]
  __int64 n0xA8; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  __Val_0___[9] = sub_1403E8F30;
  LODWORD(v10) = a6;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  return sub_140306CF0(n4, a2, a3, a4, (__int64)__Val_0___, 1u, a5, v10, a7, a8);
}

// --- End Function: sub_140354250 (0x140354250) ---

// --- Function: check_thread_list_contains_value (0x140395170) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 a1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8LL))(a1, &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140395170) ---

// --- Function: sub_140395230 (0x140395230) ---
bool __fastcall sub_140395230(unsigned __int64 a1)
{
  __int64 v2; // r9
  unsigned __int64 *v3; // r10
  unsigned __int64 *v4; // r8
  unsigned __int64 v5; // rcx
  unsigned __int64 *v6; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) != 1 )
    return 0;
  v3 = *(unsigned __int64 **)(v2 + 0x30);
  v4 = *(unsigned __int64 **)(v2 + 0x28);
  v5 = v3 - v4;
  while ( (__int64)v5 > 0 )
  {
    if ( v4[v5 >> 1] >= a1 )
    {
      v5 >>= 1;
    }
    else
    {
      v4 += (v5 >> 1) + 1;
      v5 += 0xFFFFFFFFFFFFFFFFuLL - (v5 >> 1);
    }
  }
  if ( v4 == v3 || (v6 = v4 + 1, a1 < *v4) )
    v6 = v4;
  if ( v4 == v6 )
    v4 = *(unsigned __int64 **)(v2 + 0x30);
  return v4 != v3;
}

// --- End Function: sub_140395230 (0x140395230) ---

// --- Function: validate_access_with_virtual_calls (0x1403952D0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  v3 = qword_149C8DFC0;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149C8DFC0 + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8LL))(a1, &v7);
  return v4(v3, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x1403952D0) ---

// --- Function: sub_140395410 (0x140395410) ---
char __fastcall sub_140395410(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rbx
  __int64 v2; // rax

  payload_ptr_state1 = *a1 & 0xFFFFFFFFFFFFLL;
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
      return sub_140395230(payload_ptr_state1);
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (unsigned __int8)is_thread_privileged_or_bypass_mode() )
    return 1;
  else
    return validate_access_with_virtual_calls(payload_ptr_state1);
}

// --- End Function: sub_140395410 (0x140395410) ---

// --- Function: getModuleFunction (0x14039E810) ---
FARPROC __fastcall getModuleFunction(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: getModuleFunction (0x14039E810) ---

// --- Function: sub_1403B43F0 (0x1403B43F0) ---
_QWORD *__fastcall sub_1403B43F0(unsigned __int64 *a1, _QWORD *a2)
{
  if ( is_entity_descriptor_valid_or_accessible(a1) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B43F0 (0x1403B43F0) ---

// --- Function: sub_1403C6E80 (0x1403C6E80) ---
__int64 __fastcall sub_1403C6E80(__int64 a1, unsigned int a2, __int64 a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149C8E0F8 )
    return sub_1403C6EF0(a1, a2, a3);
  else
    return sub_1403C7160(a1, a2, a3);
}

// --- End Function: sub_1403C6E80 (0x1403C6E80) ---

// --- Function: sub_1403C6EF0 (0x1403C6EF0) ---
__int64 __fastcall sub_1403C6EF0(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_Src; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_Src_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149C8E038;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149C89AA0(
            &n0x1600,
            &word_149C7BF34,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_Src = &p_Src;
          HIWORD(n0x1600) = word_149C7BF34;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src);
          qword_149C89AE0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149C89AA8(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF38,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_Src_1 = &p_Src;
          HIWORD(n0x1600_1) = word_149C7BF38;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C6EF0 (0x1403C6EF0) ---

// --- Function: sub_1403C7160 (0x1403C7160) ---
__int64 __fastcall sub_1403C7160(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_Src; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_Src_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149C89AA0(
          &n0x1600,
          &word_149C7BF2C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_Src = &p_Src;
        HIWORD(n0x1600) = word_149C7BF2C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_Src = *(const ULONG_PTR **)(a1 + 8);
        qword_149C89AE0("LockOwner: %s", p_p_Src);
        qword_149C89AE0("Caller: %s", a3);
        v15 = a2;
        qword_149C78FC8(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149C89AA8(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149C89AA0(
            &n0x1600_1,
            &word_149C7BF30,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_Src_1 = &p_Src;
          HIWORD(n0x1600_1) = word_149C7BF30;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_Src_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149C89AE0("LockOwner: %s", p_p_Src_1);
          qword_149C89AE0("Caller: %s", a3);
          v16[0] = v12;
          qword_149C78FC8(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149C89AA8(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C7160 (0x1403C7160) ---

// --- Function: sub_1403DF590 (0x1403DF590) ---
const ULONG_PTR *__fastcall sub_1403DF590(__int64 a1, __int64 a2)
{
  unsigned __int32 i; // edi
  unsigned int v4; // ebx
  signed __int32 v5; // eax
  const ULONG_PTR *p_Src; // rax
  int v7; // [rsp+50h] [rbp+8h] BYREF
  int v8; // [rsp+58h] [rbp+10h] BYREF
  __int64 v9; // [rsp+60h] [rbp+18h] BYREF
  __int64 v10; // [rsp+68h] [rbp+20h] BYREF

  for ( i = a2; ; i = v5 )
  {
    v4 = i & 0xFFFFFFFE;
    if ( (i & 0xFFFE) == 0 && (i & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
        qword_149C8E038,
        &v9,
        &v8);
      v4 = (unsigned __int16)v4;
      a2 = *(unsigned int *)(((((unsigned __int64)i >> 0x10) & (unsigned int)(v8 - 1)) << 9) + v9 + 0x124);
      if ( (_DWORD)a2 != 0xFFFFFFFF )
      {
        a2 = (unsigned int)((_DWORD)a2 << 0x10);
        v4 = a2 | (unsigned __int16)v4;
      }
    }
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, i);
    if ( i == v5 )
      break;
  }
  if ( (i & 0xFFFE) != 0 )
  {
    qword_149C78FD0(a1, a2);
  }
  else if ( (i & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149C8E038 + 0xF8LL))(
      qword_149C8E038,
      &v10,
      &v7);
    *(_DWORD *)(((HIWORD(i) & (unsigned __int64)(unsigned int)(v7 - 1)) << 9) + v10 + 0x11C) = (unsigned __int16)(HIWORD(i) + v7);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149C8E038 + 0xD8LL))(qword_149C8E038);
  }
  p_Src = &::p_Src;
  *(_QWORD *)(a1 + 8) = &::p_Src;
  return p_Src;
}

// --- End Function: sub_1403DF590 (0x1403DF590) ---

// --- Function: sub_1403E8F30 (0x1403E8F30) ---
__int64 sub_1403E8F30()
{
  return sub_1402A65A0(1u);
}

// --- End Function: sub_1403E8F30 (0x1403E8F30) ---

// --- Function: sub_1403E8F70 (0x1403E8F70) ---
_QWORD *__fastcall sub_1403E8F70(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)sub_1402A65A0(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A6590(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)sub_1402A65A0(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E8F70 (0x1403E8F70) ---

// --- Function: sub_1403E9230 (0x1403E9230) ---
__int64 __fastcall sub_1403E9230(__int64 a1)
{
  return sub_1402A6590(a1);
}

// --- End Function: sub_1403E9230 (0x1403E9230) ---

// --- Function: sub_1403E9250 (0x1403E9250) ---
__int64 __fastcall sub_1403E9250(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_1402A6590(*(_QWORD *)(a1 + 0x10));
    return sub_1402A6590(a1);
  }
  return result;
}

// --- End Function: sub_1403E9250 (0x1403E9250) ---

// --- Function: sub_1403EBA20 (0x1403EBA20) ---
bool __fastcall sub_1403EBA20(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403EBA20 (0x1403EBA20) ---

// --- Function: sub_1403EBBC0 (0x1403EBBC0) ---
char __fastcall sub_1403EBBC0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403EBBC0 (0x1403EBBC0) ---

// --- Function: sub_1403EF370 (0x1403EF370) ---
__int64 __fastcall sub_1403EF370(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  const char *p_null; // r8

  p_null = "null";
  LOBYTE(a4) = 1;
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140303440(a2, a3, p_null, a4);
}

// --- End Function: sub_1403EF370 (0x1403EF370) ---

// --- Function: sub_1403EF4D0 (0x1403EF4D0) ---
__int64 __fastcall sub_1403EF4D0(__int64 a1, __int64 a2, unsigned __int64 n0xC_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n0xC_1 > 0 )
  {
    if ( n0xC_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n0xC_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F91E0(a1, (unsigned int)n0xC + a2, n0xC_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F8B80(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F8DD0(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    if ( n0xC_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n0xC_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F8A30(a1, n0xC + a2, n0xC_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n0xC_1 )
    {
LABEL_46:
      if ( n0xC_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EF4D0 (0x1403EF4D0) ---

// --- Function: sub_1403EF810 (0x1403EF810) ---
__int64 __fastcall sub_1403EF810(__int64 a1, void *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140303440(a2, Size_1, p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EF810 (0x1403EF810) ---

// --- Function: sub_1403EF930 (0x1403EF930) ---
// attributes: thunk
__int64 __fastcall sub_1403EF930(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1404F91E0(a1, a2, a3);
}

// --- End Function: sub_1403EF930 (0x1403EF930) ---

// --- Function: sub_1404B8EB0 (0x1404B8EB0) ---
_QWORD *sub_1404B8EB0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( !v0 )
  {
    sub_14053EF00("fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A65A0(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1481CF6E0);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B8EB0 (0x1404B8EB0) ---

// --- Function: getThreadLogContextSlot (0x1404C2CA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
int *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n0xF; // rax

  v0 = sub_1404B8EB0();
  v1 = v0;
  if ( !v0 )
    return &dword_149C83B90;
  n0xF = *v0;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (int *)&v1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404C2CA0) ---

// --- Function: sub_1404F8A30 (0x1404F8A30) ---
__int64 __fastcall sub_1404F8A30(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x28] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x28] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x29] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x29] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x2A] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x2A] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x2B] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x2B] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x2C] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x2C] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x2D] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x2D] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x2E] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x2E] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x2F] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x2F] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F8A30 (0x1404F8A30) ---

// --- Function: sub_1404F8B80 (0x1404F8B80) ---
__int64 __fastcall sub_1404F8B80(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x10] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x10] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x11] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x11] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x12] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x12] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x13] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x13] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x14] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x14] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x15] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x15] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x16] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x16] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x17] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x17] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[0x18] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[0x18] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[0x19] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[0x19] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0x1A] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0x1A] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0x1B] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0x1B] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0x1C] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0x1C] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0x1D] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0x1D] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0x1E] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0x1E] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0x1F] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0x1F] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F8B80 (0x1404F8B80) ---

// --- Function: sub_1404F8DD0 (0x1404F8DD0) ---
__int64 __fastcall sub_1404F8DD0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x20] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x20] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x21] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x21] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x22] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x22] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x23] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x23] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x24] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x24] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x25] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x25] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x26] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x26] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x27] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x27] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F8DD0 (0x1404F8DD0) ---

// --- Function: sub_1404F91E0 (0x1404F91E0) ---
__int64 __fastcall sub_1404F91E0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[5] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[6] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[7] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[8] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[9] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0xA] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0xA] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0xB] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0xB] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0xC] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0xC] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0xD] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0xD] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0xE] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0xE] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0xF] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0xF] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F91E0 (0x1404F91E0) ---

// --- Function: is_thread_privileged_or_bypass_mode (0x14053EF50) ---
// Checks if the current thread is operating in a privileged or bypass mode. It
// first attempts to retrieve a pointer from `get_thread_context_ptr() + 0x10`. If
// this pointer is valid, it returns the boolean value of the byte at `pointer +
// 0x42`. If the pointer is null, it instead returns the boolean value of the byte
// at `get_thread_context_ptr() + 0x12E`.
bool is_thread_privileged_or_bypass_mode()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: is_thread_privileged_or_bypass_mode (0x14053EF50) ---

// --- Function: LogFatalError (0x1405C60F0) ---
// // Logs a fatal error message. // This function first ensures that the fatal
// error handling system is initialized. // If critical global environment pointers
// (gEnv or qword_149B4FCA0) are uninitialized // when a fatal error occurs, it
// triggers a debug break and halts execution. // Otherwise, it formats the
// provided message and dispatches it to the registered // fatal error logging
// handler. // // Parameters: //   format: A printf-style format string for the
// error message. //   ...: Variadic arguments corresponding to the format string.
// // // Returns: //   The result of the underlying logging function, or may not
// return if a debug break is triggered.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC ModuleFunction; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149C8DEA0;
  if ( !qword_149C8DEA0 )
  {
    ModuleFunction = getModuleFunction(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))ModuleFunction)(&qword_149C8DEA0);
    v1 = (__int64 (*)(void))qword_149C8DEA0;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149C8E0F8 || !qword_149C8DFE0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A6BE0();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149C8DFE0 + 0x118LL))(
                      qword_149C8DFE0,
                      &format_string_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C60F0) ---

// --- Function: sub_14219AD20 (0x14219AD20) ---
char __fastcall sub_14219AD20(
        int n4,
        __int64 a2,
        void *p_Recv_Invalid_Remote_Method_Id,
        char *p_Ignoring_received_remote_method_call_because_index_[$$]_is_inva,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        int *ThreadLogContextSlot,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12,
        _QWORD *a13,
        _QWORD *a14)
{
  void *v18; // rsp
  __int64 v20; // [rsp+18h] [rbp-2B8h]
  _BYTE __Val_0___[592]; // [rsp+30h] [rbp-2A0h] BYREF

  v18 = alloca(0x2A0);
  sub_14219FD60((__int64)__Val_0___, (__int64)ThreadLogContextSlot, a10, a11, a12, a13, a14);
  LODWORD(v20) = a6;
  return sub_140306CF0(
           n4,
           a2,
           p_Recv_Invalid_Remote_Method_Id,
           (__int64)p_Ignoring_received_remote_method_call_because_index_[$$]_is_inva,
           (__int64)__Val_0___,
           6u,
           a5,
           v20,
           a7,
           a8);
}

// --- End Function: sub_14219AD20 (0x14219AD20) ---

// --- Function: sub_14219DF00 (0x14219DF00) ---
char __fastcall sub_14219DF00(
        int n4,
        __int64 a2,
        void *p_Remote_Method_Criteria,
        char *p_Remote_method_received_by_a_node_that_doesn_t_satisfy_receive_c,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 *a8,
        int *ThreadLogContextSlot,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12,
        _QWORD *a13,
        _QWORD *a14,
        _QWORD *a15,
        __int64 a16,
        __int64 a17)
{
  void *v21; // rsp
  const char *p_null; // r8
  unsigned __int64 v23; // rax
  const char *p_null_1; // rdx
  unsigned __int64 v25; // rcx
  __int64 v27; // [rsp+18h] [rbp-408h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-3F0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-398h]
  __int64 n0xB0; // [rsp+90h] [rbp-390h]
  __int64 n0xA8; // [rsp+98h] [rbp-388h]
  _QWORD *v32; // [rsp+A0h] [rbp-380h]
  const char *p_Name; // [rsp+A8h] [rbp-378h]
  __int64 v34; // [rsp+B0h] [rbp-370h]
  __int64 (__fastcall *p_sub_1403EF810)(__int64, void *, size_t, __int64, char); // [rsp+B8h] [rbp-368h]
  __int64 (__fastcall *p_sub_1403EF370)(__int64, __int64, __int64, __int64); // [rsp+C0h] [rbp-360h]
  __int64 v37; // [rsp+C8h] [rbp-358h]
  bool (__fastcall *p_sub_1403EBA20)(__int64, __int64); // [rsp+D0h] [rbp-350h]
  __int64 v39; // [rsp+D8h] [rbp-348h]
  __int64 (__fastcall *p_sub_1403E9250)(__int64); // [rsp+E0h] [rbp-340h]
  _QWORD *(__fastcall *p_sub_1403E8F70)(_QWORD *); // [rsp+E8h] [rbp-338h]
  unsigned __int64 v42; // [rsp+F0h] [rbp-330h]
  char v43; // [rsp+F8h] [rbp-328h]
  char v44; // [rsp+F9h] [rbp-327h]
  __int64 n0x18; // [rsp+100h] [rbp-320h]
  unsigned __int64 v46; // [rsp+108h] [rbp-318h]
  _QWORD *v47; // [rsp+110h] [rbp-310h]
  const char *p_NetworkNodeId; // [rsp+118h] [rbp-308h]
  __int64 v49; // [rsp+120h] [rbp-300h]
  __int64 (__fastcall *p_sub_1403EF810_1)(__int64, void *, size_t, __int64, char); // [rsp+128h] [rbp-2F8h]
  __int64 (__fastcall *p_sub_1403EF370_1)(__int64, __int64, __int64, __int64); // [rsp+130h] [rbp-2F0h]
  __int64 v52; // [rsp+138h] [rbp-2E8h]
  bool (__fastcall *p_sub_1403EBA20_1)(__int64, __int64); // [rsp+140h] [rbp-2E0h]
  __int64 v54; // [rsp+148h] [rbp-2D8h]
  __int64 (__fastcall *p_sub_1403E9250_1)(__int64); // [rsp+150h] [rbp-2D0h]
  _QWORD *(__fastcall *p_sub_1403E8F70_1)(_QWORD *); // [rsp+158h] [rbp-2C8h]
  unsigned __int64 v57; // [rsp+160h] [rbp-2C0h]
  char v58; // [rsp+168h] [rbp-2B8h]
  char v59; // [rsp+169h] [rbp-2B7h]
  __int64 n0x18_1; // [rsp+170h] [rbp-2B0h]
  unsigned __int64 v61; // [rsp+178h] [rbp-2A8h]
  __int64 v62; // [rsp+180h] [rbp-2A0h] BYREF

  v21 = alloca(0x3F0);
  p_null = "null";
  __Val_0___[0] = ThreadLogContextSlot;
  p_Name = "Name";
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EF930;
  __Val_0___[4] = sub_1403EF4D0;
  __Val_0___[6] = sub_1403EBBC0;
  __Val_0___[8] = sub_1403E9230;
  v32 = a10;
  __Val_0___[9] = sub_1403E8F30;
  v23 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v44 = 0;
  v34 = *a10;
  p_sub_1403EF810 = sub_1403EF810;
  p_sub_1403EF370 = sub_1403EF370;
  p_sub_1403EBA20 = sub_1403EBA20;
  p_sub_1403E9250 = sub_1403E9250;
  p_sub_1403E8F70 = sub_1403E8F70;
  v37 = 0;
  v39 = 0;
  v42 = 0xFFFFFFFFFFFFFFFFuLL;
  v43 = 0;
  n0x18 = 0x18;
  p_null_1 = "null";
  if ( a10[1] )
    p_null_1 = (const char *)a10[1];
  v25 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v25;
  while ( p_null_1[v25] );
  v46 = v25;
  p_NetworkNodeId = "NetworkNodeId";
  v47 = a11;
  v59 = 0;
  v49 = *a11;
  p_sub_1403EF810_1 = sub_1403EF810;
  p_sub_1403EF370_1 = sub_1403EF370;
  p_sub_1403EBA20_1 = sub_1403EBA20;
  p_sub_1403E9250_1 = sub_1403E9250;
  p_sub_1403E8F70_1 = sub_1403E8F70;
  v52 = 0;
  v54 = 0;
  v57 = 0xFFFFFFFFFFFFFFFFuLL;
  v58 = 0;
  n0x18_1 = 0x18;
  if ( a11[1] )
    p_null = (const char *)a11[1];
  do
    ++v23;
  while ( p_null[v23] );
  v61 = v23;
  sub_1421A1760((__int64)&v62, a12, a13, a14, a15, a16, a17);
  LODWORD(v27) = a6;
  return sub_140306CF0(
           n4,
           a2,
           p_Remote_Method_Criteria,
           (__int64)p_Remote_method_received_by_a_node_that_doesn_t_satisfy_receive_c,
           (__int64)__Val_0___,
           9u,
           a5,
           v27,
           a7,
           a8);
}

// --- End Function: sub_14219DF00 (0x14219DF00) ---

// --- Function: sub_14219FD60 (0x14219FD60) ---
__int64 __fastcall sub_14219FD60(
        __int64 __Val_0__,
        int *ThreadLogContextSlot,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        _QWORD *a7)
{
  unsigned __int64 v7; // r10
  const char *p_null; // r8
  const char *p_null_1; // rdx
  unsigned __int64 v10; // rax
  __int64 n6; // rax

  *(_QWORD *)__Val_0__ = ThreadLogContextSlot;
  v7 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(__Val_0__ + 0x70) = a3;
  *(_WORD *)(__Val_0__ + 0x58) = 0x100;
  *(_QWORD *)(__Val_0__ + 0x10) = 0;
  *(_QWORD *)(__Val_0__ + 8) = "TraceContext";
  *(_QWORD *)(__Val_0__ + 0x28) = 0;
  *(_QWORD *)(__Val_0__ + 0x18) = sub_1403EF930;
  *(_QWORD *)(__Val_0__ + 0x38) = 0;
  *(_QWORD *)(__Val_0__ + 0x20) = sub_1403EF4D0;
  *(_QWORD *)(__Val_0__ + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(__Val_0__ + 0x30) = sub_1403EBBC0;
  *(_QWORD *)(__Val_0__ + 0x60) = 0xB0;
  *(_QWORD *)(__Val_0__ + 0x40) = sub_1403E9230;
  *(_QWORD *)(__Val_0__ + 0x48) = sub_1403E8F30;
  *(_QWORD *)(__Val_0__ + 0x68) = 0xA8;
  *(_QWORD *)(__Val_0__ + 0x78) = "UInt";
  *(_BYTE *)(__Val_0__ + 0xC9) = 0;
  *(_QWORD *)(__Val_0__ + 0x80) = *a3;
  *(_QWORD *)(__Val_0__ + 0xB8) = sub_1403E8F40;
  *(_QWORD *)(__Val_0__ + 0xB0) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x88) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x90) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x98) = 0;
  *(_QWORD *)(__Val_0__ + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0xA8) = 0;
  *(_QWORD *)(__Val_0__ + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0xC8) = 0;
  *(_QWORD *)(__Val_0__ + 0xD0) = 0x10;
  *(_QWORD *)(__Val_0__ + 0xD8) = 0x15;
  *(_QWORD *)(__Val_0__ + 0xE0) = a4;
  *(_QWORD *)(__Val_0__ + 0xE8) = "UInt";
  *(_BYTE *)(__Val_0__ + 0x139) = 0;
  *(_QWORD *)(__Val_0__ + 0xF0) = *a4;
  *(_QWORD *)(__Val_0__ + 0x150) = a5;
  *(_QWORD *)(__Val_0__ + 0x128) = sub_1403E8F40;
  *(_QWORD *)(__Val_0__ + 0xF8) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x100) = sub_1403EF3A0;
  *(_QWORD *)(__Val_0__ + 0x108) = 0;
  *(_QWORD *)(__Val_0__ + 0x110) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0x118) = 0;
  *(_QWORD *)(__Val_0__ + 0x120) = sub_1403E9240;
  *(_QWORD *)(__Val_0__ + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x138) = 0;
  *(_QWORD *)(__Val_0__ + 0x140) = 0x10;
  *(_QWORD *)(__Val_0__ + 0x148) = 0x15;
  *(_QWORD *)(__Val_0__ + 0x158) = "EntityId";
  *(_BYTE *)(__Val_0__ + 0x1A9) = 1;
  *(_QWORD *)(__Val_0__ + 0x160) = *a5;
  *(_QWORD *)(__Val_0__ + 0x168) = sub_1403EF7E0;
  *(_QWORD *)(__Val_0__ + 0x170) = sub_1403EF240;
  *(_QWORD *)(__Val_0__ + 0x180) = std::error_category::operator==;
  *(_QWORD *)(__Val_0__ + 0x190) = sub_1403E9280;
  *(_QWORD *)(__Val_0__ + 0x198) = sub_1403E9050;
  *(_QWORD *)(__Val_0__ + 0x178) = 0;
  *(_QWORD *)(__Val_0__ + 0x188) = 0;
  *(_QWORD *)(__Val_0__ + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x1A8) = 0;
  *(_QWORD *)(__Val_0__ + 0x1C8) = "Name";
  p_null = "null";
  *(_QWORD *)(__Val_0__ + 0x1C0) = a6;
  *(_QWORD *)(__Val_0__ + 0x1B0) = 0x18;
  *(_QWORD *)(__Val_0__ + 0x1B8) = 0x17;
  *(_BYTE *)(__Val_0__ + 0x219) = 0;
  *(_QWORD *)(__Val_0__ + 0x1D0) = *a6;
  *(_QWORD *)(__Val_0__ + 0x1D8) = sub_1403EF810;
  *(_QWORD *)(__Val_0__ + 0x1E0) = sub_1403EF370;
  *(_QWORD *)(__Val_0__ + 0x1F0) = sub_1403EBA20;
  *(_QWORD *)(__Val_0__ + 0x200) = sub_1403E9250;
  *(_QWORD *)(__Val_0__ + 0x208) = sub_1403E8F70;
  *(_QWORD *)(__Val_0__ + 0x1E8) = 0;
  *(_QWORD *)(__Val_0__ + 0x1F8) = 0;
  *(_QWORD *)(__Val_0__ + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x218) = 0;
  *(_QWORD *)(__Val_0__ + 0x220) = 0x18;
  p_null_1 = "null";
  if ( a6[1] )
    p_null_1 = (const char *)a6[1];
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( p_null_1[v10] );
  *(_QWORD *)(__Val_0__ + 0x228) = v10;
  *(_QWORD *)(__Val_0__ + 0x238) = "NetworkNodeId";
  *(_QWORD *)(__Val_0__ + 0x230) = a7;
  *(_BYTE *)(__Val_0__ + 0x289) = 0;
  *(_QWORD *)(__Val_0__ + 0x240) = *a7;
  *(_QWORD *)(__Val_0__ + 0x248) = sub_1403EF810;
  *(_QWORD *)(__Val_0__ + 0x250) = sub_1403EF370;
  *(_QWORD *)(__Val_0__ + 0x260) = sub_1403EBA20;
  *(_QWORD *)(__Val_0__ + 0x270) = sub_1403E9250;
  *(_QWORD *)(__Val_0__ + 0x278) = sub_1403E8F70;
  *(_QWORD *)(__Val_0__ + 0x258) = 0;
  *(_QWORD *)(__Val_0__ + 0x268) = 0;
  *(_QWORD *)(__Val_0__ + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(__Val_0__ + 0x288) = 0;
  *(_QWORD *)(__Val_0__ + 0x290) = 0x18;
  if ( a7[1] )
    p_null = (const char *)a7[1];
  do
    ++v7;
  while ( p_null[v7] );
  n6 = 6;
  *(_QWORD *)(__Val_0__ + 0x298) = v7;
  return n6;
}

// --- End Function: sub_14219FD60 (0x14219FD60) ---

// --- Function: sub_1421A1760 (0x1421A1760) ---
__int64 __fastcall sub_1421A1760(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6, __int64 a7)
{
  const char *p_null; // rdx
  const char *p_null_2; // rax
  const char *p_null_1; // r8
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  __int64 n6; // rax

  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 8) = "EntityId";
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x18) = sub_1403EF7E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EF240;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x30) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x40) = sub_1403E9280;
  p_null = "null";
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x48) = sub_1403E9050;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  *(_QWORD *)(a1 + 0x68) = 0x17;
  *(_QWORD *)(a1 + 0x78) = "Text";
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EF810;
  *(_QWORD *)(a1 + 0x90) = sub_1403EF370;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403EBA20;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E9250;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E8F70;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  p_null_2 = (const char *)a3[1];
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( p_null_1[v10] );
  *(_QWORD *)(a1 + 0xD8) = v10;
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_QWORD *)(a1 + 0xE8) = "Text";
  *(_BYTE *)(a1 + 0x139) = 0;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EF810;
  *(_QWORD *)(a1 + 0x100) = sub_1403EF370;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = sub_1403EBA20;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_1403E9250;
  *(_QWORD *)(a1 + 0x128) = sub_1403E8F70;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x18;
  if ( a4[1] )
    p_null = (const char *)a4[1];
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v11;
  while ( p_null[v11] );
  *(_QWORD *)(a1 + 0x148) = v11;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_QWORD *)(a1 + 0x158) = "Int";
  *(_BYTE *)(a1 + 0x1A9) = 0;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x168) = sub_140509A20;
  *(_QWORD *)(a1 + 0x170) = sub_140509A20;
  *(_QWORD *)(a1 + 0x180) = FH4::HandlerMap4::iterator::operator==;
  *(_QWORD *)(a1 + 0x190) = sub_1403E9240;
  *(_QWORD *)(a1 + 0x198) = sub_1403E8F40;
  *(_QWORD *)(a1 + 0x1C0) = a6;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1C8) = "Boolean";
  *(_BYTE *)(a1 + 0x219) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x1B0) = 0x10;
  *(_QWORD *)(a1 + 0x1B8) = 0x15;
  *(_QWORD *)(a1 + 0x1D0) = *(_QWORD *)(a6 + 8);
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_BYTE *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x230) = a7;
  *(_QWORD *)(a1 + 0x238) = "Boolean";
  *(_BYTE *)(a1 + 0x289) = 0;
  *(_QWORD *)(a1 + 0x1D8) = sub_140ABCDB0;
  *(_QWORD *)(a1 + 0x1E0) = sub_140ABCC50;
  *(_QWORD *)(a1 + 0x1F0) = sub_140ABBCA0;
  *(_QWORD *)(a1 + 0x200) = sub_1403E9240;
  *(_QWORD *)(a1 + 0x208) = sub_1403E8F40;
  *(_QWORD *)(a1 + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x220) = 0x10;
  *(_QWORD *)(a1 + 0x228) = 0x15;
  *(_QWORD *)(a1 + 0x240) = *(_QWORD *)(a7 + 8);
  n6 = 6;
  *(_QWORD *)(a1 + 0x258) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_BYTE *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x248) = sub_140ABCDB0;
  *(_QWORD *)(a1 + 0x250) = sub_140ABCC50;
  *(_QWORD *)(a1 + 0x260) = sub_140ABBCA0;
  *(_QWORD *)(a1 + 0x270) = sub_1403E9240;
  *(_QWORD *)(a1 + 0x278) = sub_1403E8F40;
  *(_QWORD *)(a1 + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x290) = 0x10;
  *(_QWORD *)(a1 + 0x298) = 0x15;
  return n6;
}

// --- End Function: sub_1421A1760 (0x1421A1760) ---

// --- Function: sub_14225A120 (0x14225A120) ---
const char *__fastcall sub_14225A120(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // r8

  v2 = *(_QWORD *)(a1 + 0xF0);
  if ( a2 < (unsigned __int64)((*(_QWORD *)(a1 + 0xF8) - v2) / 0x38) )
    return *(const char **)(0x38LL * a2 + v2);
  else
    return "Unknown method";
}

// --- End Function: sub_14225A120 (0x14225A120) ---

// --- Function: sub_1422BC170 (0x1422BC170) ---
__int64 __fastcall sub_1422BC170(unsigned __int64 *a1, __int64 a2, unsigned __int16 *a3)
{
  unsigned __int64 *v3; // rsi
  __int128 *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rcx
  int v9; // eax
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rcx
  int v13; // r12d
  _BYTE *v14; // r14
  unsigned __int64 v15; // rax
  size_t Size; // r15
  char *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rax
  signed __int64 v21; // rcx
  int *ThreadLogContextSlot; // rax
  unsigned __int64 v23; // r14
  unsigned int v24; // r15d
  __int64 v25; // rax
  unsigned __int64 v26; // rcx
  __int64 v27; // rax
  bool v28; // bl
  __int64 v29; // rcx
  char v30; // al
  int v31; // edx
  int v32; // edx
  int v33; // r15d
  __int64 v34; // rcx
  char v35; // al
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // rcx
  __int64 v40; // rax
  int *ThreadLogContextSlot_1; // rax
  _QWORD *v42; // rcx
  __int128 v43; // xmm0
  __int64 v44; // rax
  char n0x65; // r12
  __int16 *v46; // rbx
  __int16 v47; // bx
  __int64 v48; // rcx
  int v49; // eax
  __int64 v50; // rcx
  const char *v51; // r14
  const char *v52; // r12
  const char *v53; // rbx
  __int16 v55; // [rsp+90h] [rbp-80h] BYREF
  int n0xD6; // [rsp+98h] [rbp-78h] BYREF
  int n0x67; // [rsp+9Ch] [rbp-74h]
  __int128 *v58; // [rsp+A0h] [rbp-70h] BYREF
  __int64 v59; // [rsp+A8h] [rbp-68h] BYREF
  size_t v60[2]; // [rsp+B0h] [rbp-60h] BYREF
  __int64 v61; // [rsp+C0h] [rbp-50h] BYREF
  const char *v62; // [rsp+C8h] [rbp-48h]
  __int64 v63; // [rsp+D0h] [rbp-40h]
  __int64 v64; // [rsp+D8h] [rbp-38h] BYREF
  __int64 v65; // [rsp+E0h] [rbp-30h]
  __int64 v66; // [rsp+E8h] [rbp-28h] BYREF
  __int64 v67; // [rsp+F0h] [rbp-20h]
  __int64 v68; // [rsp+F8h] [rbp-18h]
  __int128 v69; // [rsp+100h] [rbp-10h] BYREF
  __int128 v70; // [rsp+110h] [rbp+0h] BYREF
  __int128 v71; // [rsp+120h] [rbp+10h] BYREF
  __int64 v72; // [rsp+130h] [rbp+20h]
  _BYTE v73[2]; // [rsp+140h] [rbp+30h] BYREF
  __int16 v74; // [rsp+142h] [rbp+32h]
  int v75; // [rsp+144h] [rbp+34h]
  __int64 v76; // [rsp+148h] [rbp+38h]
  unsigned __int64 v77; // [rsp+150h] [rbp+40h]
  unsigned __int64 v78; // [rsp+158h] [rbp+48h]
  __int64 v79; // [rsp+160h] [rbp+50h]
  __int64 v80; // [rsp+168h] [rbp+58h]
  _DWORD v81[2]; // [rsp+190h] [rbp+80h] BYREF
  __int64 v82; // [rsp+198h] [rbp+88h]
  unsigned __int64 v83; // [rsp+1A0h] [rbp+90h]
  unsigned __int64 v84; // [rsp+1A8h] [rbp+98h]
  __int64 v85; // [rsp+1B0h] [rbp+A0h]
  __int64 v86; // [rsp+1B8h] [rbp+A8h]
  _QWORD v87[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  __int64 v88; // [rsp+1F0h] [rbp+E0h]
  _QWORD v89[2]; // [rsp+1F8h] [rbp+E8h] BYREF
  __int64 v90; // [rsp+208h] [rbp+F8h]
  _QWORD v91[2]; // [rsp+210h] [rbp+100h] BYREF
  _QWORD v92[2]; // [rsp+220h] [rbp+110h] BYREF
  _QWORD v93[2]; // [rsp+230h] [rbp+120h] BYREF
  _QWORD v94[2]; // [rsp+240h] [rbp+130h] BYREF
  _QWORD v95[2]; // [rsp+250h] [rbp+140h] BYREF
  size_t v96; // [rsp+260h] [rbp+150h]
  char v97; // [rsp+268h] [rbp+158h]
  _QWORD v98[2]; // [rsp+270h] [rbp+160h] BYREF
  char v99; // [rsp+280h] [rbp+170h]
  int n2; // [rsp+288h] [rbp+178h] BYREF
  __int128 v101; // [rsp+290h] [rbp+180h]
  char v102[8]; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 v103; // [rsp+2A8h] [rbp+198h]
  char *v104; // [rsp+2B0h] [rbp+1A0h]
  char v105; // [rsp+2B8h] [rbp+1A8h] BYREF
  char v106[8]; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 v107; // [rsp+2E8h] [rbp+1D8h]
  const char *v108; // [rsp+2F0h] [rbp+1E0h]
  char v109; // [rsp+2F8h] [rbp+1E8h] BYREF
  char v110[8]; // [rsp+320h] [rbp+210h] BYREF
  __int64 v111; // [rsp+328h] [rbp+218h]
  char *v112; // [rsp+330h] [rbp+220h]
  char v113; // [rsp+338h] [rbp+228h] BYREF

  v3 = a1 + 1;
  v58 = (__int128 *)a2;
  v6 = (__int128 *)a2;
  v7 = 0;
  if ( is_entity_descriptor_valid_or_accessible(a1 + 1) )
    v8 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v8 = 0;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 0x708LL))(v8, 0xFFFFFFFFFFFFLL);
  v81[0] = 0x6500;
  v82 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v81[1] = v9;
  v83 = __rdtsc();
  qword_149C89AA0(
    v81,
    &word_149F0860C,
    "CSerializedComponent::RecvRemoteMethodCall",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedComponent.cpp",
    0x327);
  v10 = a3[8];
  v11 = a1[0x1E];
  v12 = a1[0x1F];
  HIWORD(v81[0]) = word_149F0860C;
  v59 = v10;
  if ( v10 >= (__int64)(v12 - v11) / 0x38 )
  {
    n0xD6 = 0xD6;
    v91[0] = &n0xD6;
    n0x67 = 0x67;
    v91[1] = &v58;
    v13 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v91,
            (__int64)"Recv Invalid Remote Method Id",
            "Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$] fromNodeId=[$$]");
    if ( (v13 & 0xFFFFF) == 0 )
      goto LABEL_66;
    v70 = *v6;
    v14 = *(_BYTE **)(sub_1402C6D50((__int64)v110, (__int64)&v70) + 0x10);
    v61 = 0;
    sub_1402A6590(0);
    v15 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v14[++v15] != 0 )
      ;
    Size = v15 + 1;
    v18 = (char *)sub_1402A65A0(v15 + 1);
    v63 = (__int64)v18;
    v62 = v18;
    if ( !Size )
      goto LABEL_14;
    if ( v18 )
    {
      if ( v14 )
      {
        memcpy(v18, v14, Size);
LABEL_14:
        if ( v112 != &v113 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v111;
          sub_147715880(v112);
        }
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v19 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v19 = 0;
        v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x70LL))(v19);
        *(_QWORD *)&v71 = 0;
        *((_QWORD *)&v71 + 1) = v20;
        v72 = 0;
        sub_1403B43F0(v3, &v58);
        v67 = (__int64)v58;
        v21 = a1[0x1F] - a1[0x1E];
        v66 = 0;
        LOBYTE(v68) = 0;
        v60[0] = 0;
        v65 = v59;
        v60[1] = v21 / 0x38;
        v64 = 0;
        ThreadLogContextSlot = getThreadLogContextSlot();
        n0xD6 = 0xD6;
        v92[0] = &n0xD6;
        n0x67 = 0x67;
        v92[1] = &v58;
        v69 = 0;
        sub_14219AD20(
          2,
          (__int64)v92,
          "Recv Invalid Remote Method Id",
          (__int64)"Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$]"
                   " fromNodeId=[$$]",
          1,
          v13,
          &v69,
          0,
          (__int64)ThreadLogContextSlot,
          (__int64)&v64,
          (__int64)v60,
          (__int64)&v66,
          (__int64)&v71,
          (__int64)&v61);
        sub_1402A6590(v72);
        sub_1402A6590(v63);
        goto LABEL_66;
      }
      memset(v18, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
    goto LABEL_14;
  }
  v23 = v11 + 0x38 * v10;
  v24 = 8 * **(_DWORD **)a3;
  v25 = *(_QWORD *)(v23 + 0x20);
  if ( v25 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v25 + 0x20));
    _InterlockedAdd((volatile signed __int32 *)(v25 + 0x24), v24);
  }
  v26 = a1[0x1C];
  if ( v26 )
    (*(void (__fastcall **)(unsigned __int64, _QWORD, _QWORD))(*(_QWORD *)v26 + 0x40LL))(v26, (unsigned int)v10, v24);
  if ( BYTE1(qword_149C8E516) )
  {
    v27 = *(_QWORD *)(v23 + 0x28);
    v28 = v27 && *(_BYTE *)(v27 + 0x8D);
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v29 = *v3 & 0xFFFFFFFFFFFFLL;
    else
      v29 = 0;
    v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x720LL))(v29);
    v31 = *(_DWORD *)(v23 + 0x10);
    if ( v31 )
    {
      v32 = v31 - 1;
      if ( v32 )
      {
        if ( v32 != 1 )
          goto LABEL_39;
      }
      else
      {
        v30 = v28;
      }
    }
    else
    {
      v30 = v30 == 0;
    }
    if ( !v30 )
    {
LABEL_39:
      n0xD6 = 0xD6;
      v93[0] = &n0xD6;
      n0x67 = 0xD6;
      v93[1] = &v58;
      v33 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)v93,
              (__int64)"Remote Method Criteria",
              "Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], entit"
              "yId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]");
      if ( (v33 & 0xFFFFF) != 0 )
      {
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v34 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v34 = 0;
        v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x720LL))(v34);
        v65 = 0;
        LOBYTE(v64) = v35;
        DWORD2(v70) = *(_DWORD *)(v23 + 0x10);
        LOBYTE(v69) = v28;
        *((_QWORD *)&v69 + 1) = 0;
        *(_QWORD *)&v70 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v36 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v36 = 0;
        v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x20LL))(v36);
        v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x18LL))(v37);
        v66 = 0;
        v67 = v38;
        v68 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v39 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v39 = 0;
        v40 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x70LL))(v39);
        v89[0] = 0;
        v89[1] = v40;
        v90 = 0;
        sub_1403B43F0(v3, v60);
        v98[1] = v60[0];
        v98[0] = 0;
        v99 = 0;
        sub_1402C6D50((__int64)v102, (__int64)v58);
        v87[1] = v104;
        v62 = *(const char **)v23;
        v87[0] = 0;
        v88 = 0;
        v61 = 0;
        v63 = 0;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v59 = 0xD6000000D6LL;
        v94[0] = &v59;
        v94[1] = v60;
        v71 = 0;
        sub_14219DF00(
          3,
          (__int64)v94,
          "Remote Method Criteria",
          (__int64)"Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], "
                   "entityId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]",
          1,
          v33,
          &v71,
          0,
          (__int64)ThreadLogContextSlot_1,
          &v61,
          v87,
          (__int64)v98,
          (__int64)v89,
          (__int64)&v66,
          (__int64)&v70,
          (__int64)&v69,
          (__int64)&v64);
        sub_1402A6590(v63);
        sub_1402A6590(v88);
        if ( v104 != &v105 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v103;
          sub_147715880(v104);
        }
        sub_1402A6590(v90);
        sub_1402A6590(v68);
      }
      goto LABEL_66;
    }
    v6 = v58;
  }
  v42 = (_QWORD *)(*(_QWORD *)a3 + 8LL);
  if ( *(_DWORD *)(*(_QWORD *)a3 + 4LL) > 0x10u )
    v42 = (_QWORD *)*v42;
  v43 = *v6;
  v95[1] = v24;
  v95[0] = v42;
  v96 = 0;
  v97 = 1;
  v44 = *(_QWORD *)(v23 + 0x20);
  n2 = 2;
  v101 = v43;
  if ( v44 )
  {
    n0x65 = *(_BYTE *)(v44 + 0x12);
    v46 = (__int16 *)(v44 + 0x70);
  }
  else
  {
    n0x65 = 0x65;
    v46 = &word_1486949F4;
  }
  v47 = *v46;
  if ( is_entity_descriptor_valid_or_accessible(v3) )
    v48 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v48 = 0;
  v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x708LL))(v48);
  v55 = v47;
  v74 = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v75 = v49;
  v77 = __rdtsc();
  v73[1] = n0x65;
  v73[0] = 0;
  qword_149C89AA0(v73, &v55, &p_Src, &p_Src, 0);
  v50 = *(_QWORD *)(v23 + 0x18);
  v74 = v55;
  (*(void (__fastcall **)(__int64, int *, _QWORD *))(*(_QWORD *)v50 + 0x10LL))(v50, &n2, v95);
  v78 = __rdtsc();
  qword_149C89AA8(v73);
  v60[0] = v96;
  if ( ((v96 + 7) & 0xFFFFFFFFFFFFFFF8uLL) != v24 )
  {
    v51 = *(const char **)v23;
    sub_1402C6D50((__int64)v106, (__int64)v58);
    v52 = v108;
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v7 = *v3 & 0xFFFFFFFFFFFFLL;
    v53 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x70LL))(v7);
    sub_1403B43F0(v3, &v58);
    LogFatalError(
      "Remote Method deserializing stream size mismatch entityId=%llu, entityName=\"%s\", fromNodeId=%s, methodName=\"%s\""
      ", streamSize=%zu, bufferSize=%u",
      v58,
      v53,
      v52,
      v51,
      v60[0],
      v24);
    if ( v108 != &v109 )
    {
      qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v107;
      sub_147715880(v108);
    }
  }
LABEL_66:
  v84 = __rdtsc();
  return qword_149C89AA8(v81);
}

// --- End Function: sub_1422BC170 (0x1422BC170) ---

// --- Function: sub_1422BC170 (0x1422BC915) ---
__int64 __fastcall sub_1422BC170(unsigned __int64 *a1, __int64 a2, unsigned __int16 *a3)
{
  unsigned __int64 *v3; // rsi
  __int128 *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rcx
  int v9; // eax
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rcx
  int v13; // r12d
  _BYTE *v14; // r14
  unsigned __int64 v15; // rax
  size_t Size; // r15
  char *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rax
  signed __int64 v21; // rcx
  int *ThreadLogContextSlot; // rax
  unsigned __int64 v23; // r14
  unsigned int v24; // r15d
  __int64 v25; // rax
  unsigned __int64 v26; // rcx
  __int64 v27; // rax
  bool v28; // bl
  __int64 v29; // rcx
  char v30; // al
  int v31; // edx
  int v32; // edx
  int v33; // r15d
  __int64 v34; // rcx
  char v35; // al
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // rcx
  __int64 v40; // rax
  int *ThreadLogContextSlot_1; // rax
  _QWORD *v42; // rcx
  __int128 v43; // xmm0
  __int64 v44; // rax
  char n0x65; // r12
  __int16 *v46; // rbx
  __int16 v47; // bx
  __int64 v48; // rcx
  int v49; // eax
  __int64 v50; // rcx
  const char *v51; // r14
  const char *v52; // r12
  const char *v53; // rbx
  __int16 v55; // [rsp+90h] [rbp-80h] BYREF
  int n0xD6; // [rsp+98h] [rbp-78h] BYREF
  int n0x67; // [rsp+9Ch] [rbp-74h]
  __int128 *v58; // [rsp+A0h] [rbp-70h] BYREF
  __int64 v59; // [rsp+A8h] [rbp-68h] BYREF
  size_t v60[2]; // [rsp+B0h] [rbp-60h] BYREF
  __int64 v61; // [rsp+C0h] [rbp-50h] BYREF
  const char *v62; // [rsp+C8h] [rbp-48h]
  __int64 v63; // [rsp+D0h] [rbp-40h]
  __int64 v64; // [rsp+D8h] [rbp-38h] BYREF
  __int64 v65; // [rsp+E0h] [rbp-30h]
  __int64 v66; // [rsp+E8h] [rbp-28h] BYREF
  __int64 v67; // [rsp+F0h] [rbp-20h]
  __int64 v68; // [rsp+F8h] [rbp-18h]
  __int128 v69; // [rsp+100h] [rbp-10h] BYREF
  __int128 v70; // [rsp+110h] [rbp+0h] BYREF
  __int128 v71; // [rsp+120h] [rbp+10h] BYREF
  __int64 v72; // [rsp+130h] [rbp+20h]
  _BYTE v73[2]; // [rsp+140h] [rbp+30h] BYREF
  __int16 v74; // [rsp+142h] [rbp+32h]
  int v75; // [rsp+144h] [rbp+34h]
  __int64 v76; // [rsp+148h] [rbp+38h]
  unsigned __int64 v77; // [rsp+150h] [rbp+40h]
  unsigned __int64 v78; // [rsp+158h] [rbp+48h]
  __int64 v79; // [rsp+160h] [rbp+50h]
  __int64 v80; // [rsp+168h] [rbp+58h]
  _DWORD v81[2]; // [rsp+190h] [rbp+80h] BYREF
  __int64 v82; // [rsp+198h] [rbp+88h]
  unsigned __int64 v83; // [rsp+1A0h] [rbp+90h]
  unsigned __int64 v84; // [rsp+1A8h] [rbp+98h]
  __int64 v85; // [rsp+1B0h] [rbp+A0h]
  __int64 v86; // [rsp+1B8h] [rbp+A8h]
  _QWORD v87[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  __int64 v88; // [rsp+1F0h] [rbp+E0h]
  _QWORD v89[2]; // [rsp+1F8h] [rbp+E8h] BYREF
  __int64 v90; // [rsp+208h] [rbp+F8h]
  _QWORD v91[2]; // [rsp+210h] [rbp+100h] BYREF
  _QWORD v92[2]; // [rsp+220h] [rbp+110h] BYREF
  _QWORD v93[2]; // [rsp+230h] [rbp+120h] BYREF
  _QWORD v94[2]; // [rsp+240h] [rbp+130h] BYREF
  _QWORD v95[2]; // [rsp+250h] [rbp+140h] BYREF
  size_t v96; // [rsp+260h] [rbp+150h]
  char v97; // [rsp+268h] [rbp+158h]
  _QWORD v98[2]; // [rsp+270h] [rbp+160h] BYREF
  char v99; // [rsp+280h] [rbp+170h]
  int n2; // [rsp+288h] [rbp+178h] BYREF
  __int128 v101; // [rsp+290h] [rbp+180h]
  char v102[8]; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 v103; // [rsp+2A8h] [rbp+198h]
  char *v104; // [rsp+2B0h] [rbp+1A0h]
  char v105; // [rsp+2B8h] [rbp+1A8h] BYREF
  char v106[8]; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 v107; // [rsp+2E8h] [rbp+1D8h]
  const char *v108; // [rsp+2F0h] [rbp+1E0h]
  char v109; // [rsp+2F8h] [rbp+1E8h] BYREF
  char v110[8]; // [rsp+320h] [rbp+210h] BYREF
  __int64 v111; // [rsp+328h] [rbp+218h]
  char *v112; // [rsp+330h] [rbp+220h]
  char v113; // [rsp+338h] [rbp+228h] BYREF

  v3 = a1 + 1;
  v58 = (__int128 *)a2;
  v6 = (__int128 *)a2;
  v7 = 0;
  if ( is_entity_descriptor_valid_or_accessible(a1 + 1) )
    v8 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v8 = 0;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 0x708LL))(v8, 0xFFFFFFFFFFFFLL);
  v81[0] = 0x6500;
  v82 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v81[1] = v9;
  v83 = __rdtsc();
  qword_149C89AA0(
    v81,
    &word_149F0860C,
    "CSerializedComponent::RecvRemoteMethodCall",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Serialized/SerializedComponent.cpp",
    0x327);
  v10 = a3[8];
  v11 = a1[0x1E];
  v12 = a1[0x1F];
  HIWORD(v81[0]) = word_149F0860C;
  v59 = v10;
  if ( v10 >= (__int64)(v12 - v11) / 0x38 )
  {
    n0xD6 = 0xD6;
    v91[0] = &n0xD6;
    n0x67 = 0x67;
    v91[1] = &v58;
    v13 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v91,
            (__int64)"Recv Invalid Remote Method Id",
            "Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$] fromNodeId=[$$]");
    if ( (v13 & 0xFFFFF) == 0 )
      goto LABEL_66;
    v70 = *v6;
    v14 = *(_BYTE **)(sub_1402C6D50((__int64)v110, (__int64)&v70) + 0x10);
    v61 = 0;
    sub_1402A6590(0);
    v15 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v14[++v15] != 0 )
      ;
    Size = v15 + 1;
    v18 = (char *)sub_1402A65A0(v15 + 1);
    v63 = (__int64)v18;
    v62 = v18;
    if ( !Size )
      goto LABEL_14;
    if ( v18 )
    {
      if ( v14 )
      {
        memcpy(v18, v14, Size);
LABEL_14:
        if ( v112 != &v113 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v111;
          sub_147715880(v112);
        }
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v19 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v19 = 0;
        v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x70LL))(v19);
        *(_QWORD *)&v71 = 0;
        *((_QWORD *)&v71 + 1) = v20;
        v72 = 0;
        sub_1403B43F0(v3, &v58);
        v67 = (__int64)v58;
        v21 = a1[0x1F] - a1[0x1E];
        v66 = 0;
        LOBYTE(v68) = 0;
        v60[0] = 0;
        v65 = v59;
        v60[1] = v21 / 0x38;
        v64 = 0;
        ThreadLogContextSlot = getThreadLogContextSlot();
        n0xD6 = 0xD6;
        v92[0] = &n0xD6;
        n0x67 = 0x67;
        v92[1] = &v58;
        v69 = 0;
        sub_14219AD20(
          2,
          (__int64)v92,
          "Recv Invalid Remote Method Id",
          (__int64)"Ignoring received remote method call because index=[$$] is invalid numMethods=[$$] eid=[$$] name=[$$]"
                   " fromNodeId=[$$]",
          1,
          v13,
          &v69,
          0,
          (__int64)ThreadLogContextSlot,
          (__int64)&v64,
          (__int64)v60,
          (__int64)&v66,
          (__int64)&v71,
          (__int64)&v61);
        sub_1402A6590(v72);
        sub_1402A6590(v63);
        goto LABEL_66;
      }
      memset(v18, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
    goto LABEL_14;
  }
  v23 = v11 + 0x38 * v10;
  v24 = 8 * **(_DWORD **)a3;
  v25 = *(_QWORD *)(v23 + 0x20);
  if ( v25 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v25 + 0x20));
    _InterlockedAdd((volatile signed __int32 *)(v25 + 0x24), v24);
  }
  v26 = a1[0x1C];
  if ( v26 )
    (*(void (__fastcall **)(unsigned __int64, _QWORD, _QWORD))(*(_QWORD *)v26 + 0x40LL))(v26, (unsigned int)v10, v24);
  if ( BYTE1(qword_149C8E516) )
  {
    v27 = *(_QWORD *)(v23 + 0x28);
    v28 = v27 && *(_BYTE *)(v27 + 0x8D);
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v29 = *v3 & 0xFFFFFFFFFFFFLL;
    else
      v29 = 0;
    v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x720LL))(v29);
    v31 = *(_DWORD *)(v23 + 0x10);
    if ( v31 )
    {
      v32 = v31 - 1;
      if ( v32 )
      {
        if ( v32 != 1 )
          goto LABEL_39;
      }
      else
      {
        v30 = v28;
      }
    }
    else
    {
      v30 = v30 == 0;
    }
    if ( !v30 )
    {
LABEL_39:
      n0xD6 = 0xD6;
      v93[0] = &n0xD6;
      n0x67 = 0xD6;
      v93[1] = &v58;
      v33 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)v93,
              (__int64)"Remote Method Criteria",
              "Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], entit"
              "yId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]");
      if ( (v33 & 0xFFFFF) != 0 )
      {
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v34 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v34 = 0;
        v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x720LL))(v34);
        v65 = 0;
        LOBYTE(v64) = v35;
        DWORD2(v70) = *(_DWORD *)(v23 + 0x10);
        LOBYTE(v69) = v28;
        *((_QWORD *)&v69 + 1) = 0;
        *(_QWORD *)&v70 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v36 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v36 = 0;
        v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x20LL))(v36);
        v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x18LL))(v37);
        v66 = 0;
        v67 = v38;
        v68 = 0;
        if ( is_entity_descriptor_valid_or_accessible(v3) )
          v39 = *v3 & 0xFFFFFFFFFFFFLL;
        else
          v39 = 0;
        v40 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x70LL))(v39);
        v89[0] = 0;
        v89[1] = v40;
        v90 = 0;
        sub_1403B43F0(v3, v60);
        v98[1] = v60[0];
        v98[0] = 0;
        v99 = 0;
        sub_1402C6D50((__int64)v102, (__int64)v58);
        v87[1] = v104;
        v62 = *(const char **)v23;
        v87[0] = 0;
        v88 = 0;
        v61 = 0;
        v63 = 0;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        v59 = 0xD6000000D6LL;
        v94[0] = &v59;
        v94[1] = v60;
        v71 = 0;
        sub_14219DF00(
          3,
          (__int64)v94,
          "Remote Method Criteria",
          (__int64)"Remote method received by a node that doesn't satisfy receive criteria - method[$$], fromNodeId[$$], "
                   "entityId[$$], entityName[$$], entityClass[$$], direction[$$], localIsTokenOwner[$$], hasAuthority[$$]",
          1,
          v33,
          &v71,
          0,
          (__int64)ThreadLogContextSlot_1,
          &v61,
          v87,
          (__int64)v98,
          (__int64)v89,
          (__int64)&v66,
          (__int64)&v70,
          (__int64)&v69,
          (__int64)&v64);
        sub_1402A6590(v63);
        sub_1402A6590(v88);
        if ( v104 != &v105 )
        {
          qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v103;
          sub_147715880(v104);
        }
        sub_1402A6590(v90);
        sub_1402A6590(v68);
      }
      goto LABEL_66;
    }
    v6 = v58;
  }
  v42 = (_QWORD *)(*(_QWORD *)a3 + 8LL);
  if ( *(_DWORD *)(*(_QWORD *)a3 + 4LL) > 0x10u )
    v42 = (_QWORD *)*v42;
  v43 = *v6;
  v95[1] = v24;
  v95[0] = v42;
  v96 = 0;
  v97 = 1;
  v44 = *(_QWORD *)(v23 + 0x20);
  n2 = 2;
  v101 = v43;
  if ( v44 )
  {
    n0x65 = *(_BYTE *)(v44 + 0x12);
    v46 = (__int16 *)(v44 + 0x70);
  }
  else
  {
    n0x65 = 0x65;
    v46 = &word_1486949F4;
  }
  v47 = *v46;
  if ( is_entity_descriptor_valid_or_accessible(v3) )
    v48 = *v3 & 0xFFFFFFFFFFFFLL;
  else
    v48 = 0;
  v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x708LL))(v48);
  v55 = v47;
  v74 = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v75 = v49;
  v77 = __rdtsc();
  v73[1] = n0x65;
  v73[0] = 0;
  qword_149C89AA0(v73, &v55, &p_Src, &p_Src, 0);
  v50 = *(_QWORD *)(v23 + 0x18);
  v74 = v55;
  (*(void (__fastcall **)(__int64, int *, _QWORD *))(*(_QWORD *)v50 + 0x10LL))(v50, &n2, v95);
  v78 = __rdtsc();
  qword_149C89AA8(v73);
  v60[0] = v96;
  if ( ((v96 + 7) & 0xFFFFFFFFFFFFFFF8uLL) != v24 )
  {
    v51 = *(const char **)v23;
    sub_1402C6D50((__int64)v106, (__int64)v58);
    v52 = v108;
    if ( is_entity_descriptor_valid_or_accessible(v3) )
      v7 = *v3 & 0xFFFFFFFFFFFFLL;
    v53 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x70LL))(v7);
    sub_1403B43F0(v3, &v58);
    LogFatalError(
      "Remote Method deserializing stream size mismatch entityId=%llu, entityName=\"%s\", fromNodeId=%s, methodName=\"%s\""
      ", streamSize=%zu, bufferSize=%u",
      v58,
      v53,
      v52,
      v51,
      v60[0],
      v24);
    if ( v108 != &v109 )
    {
      qword_149C78848 += 0xFFFFFFFFFFFFFFFFuLL - v107;
      sub_147715880(v108);
    }
  }
LABEL_66:
  v84 = __rdtsc();
  return qword_149C89AA8(v81);
}

// --- End Function: sub_1422BC170 (0x1422BC915) ---

// --- Function: sub_142432A30 (0x142432BA3) ---
__int64 __fastcall sub_142432A30(__int64 a1, __int128 *a2, unsigned __int16 *a3)
{
  int v6; // r14d
  unsigned int v7; // eax
  __int64 v8; // rcx
  unsigned __int64 *v9; // rcx
  int v10; // eax
  unsigned __int32 v11; // eax
  int v12; // ebx
  int *ThreadLogContextSlot; // rax
  int n0x6400; // [rsp+50h] [rbp-89h] BYREF
  __int64 v16; // [rsp+54h] [rbp-85h]
  int v17; // [rsp+5Ch] [rbp-7Dh]
  unsigned __int64 v18; // [rsp+60h] [rbp-79h]
  unsigned __int64 v19; // [rsp+68h] [rbp-71h]
  __int64 v20; // [rsp+70h] [rbp-69h]
  __int64 v21; // [rsp+78h] [rbp-61h]
  _QWORD v22[2]; // [rsp+A0h] [rbp-39h] BYREF
  _QWORD v23[2]; // [rsp+B0h] [rbp-29h] BYREF
  __int128 v24; // [rsp+C0h] [rbp-19h] BYREF
  __int128 v25; // [rsp+D0h] [rbp-9h] BYREF
  unsigned __int64 v26; // [rsp+E0h] [rbp+7h] BYREF
  int n0x8A; // [rsp+E8h] [rbp+Fh]
  _BYTE v28[4]; // [rsp+ECh] [rbp+13h] BYREF

  n0x6400 = 0x6400;
  v17 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v16 = 1;
  v18 = __rdtsc();
  qword_149C89AA0(
    &n0x6400,
    &word_149F0991C,
    "CEntityComponentNetwork::RecvRemoteMethodCall",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryAction\\Network/EntityComponentNetwork.cpp",
    0x109);
  HIWORD(n0x6400) = word_149F0991C;
  if ( *(_QWORD *)(a1 + 0x98) && (v26 = *(_QWORD *)(a1 + 8), is_entity_descriptor_valid_or_accessible(&v26)) )
  {
    v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x80) == v6 )
    {
      ++*(_DWORD *)(a1 + 0x84);
    }
    else
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x70), 1, 0);
      if ( v7 )
        sub_1403C6E80(a1 + 0x70, v7, (__int64)"CEntityComponentNetwork::RecvRemoteMethodCall", 1);
      else
        *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      *(_DWORD *)(a1 + 0x80) = v6;
    }
    if ( *(_DWORD *)(a1 + 0xA0) != 1
      || (is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 8))
        ? (v8 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL)
        : (v8 = 0),
          (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x58LL))(v8)) )
    {
      sub_14225A120(*(_QWORD *)(a1 + 0x98), a3[8]);
    }
    else
    {
      v9 = *(unsigned __int64 **)(a1 + 0x98);
      v24 = *a2;
      sub_1422BC170(v9, (__int64)&v24, a3);
    }
    v10 = *(_DWORD *)(a1 + 0x84);
    if ( v10 )
    {
      *(_DWORD *)(a1 + 0x84) = v10 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x80) = 0xFFFFFFFF;
      v11 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x70), 0, 1);
      if ( v11 == 1 )
        *(_QWORD *)(a1 + 0x78) = &p_Src;
      else
        sub_1403DF590(a1 + 0x70, v11);
    }
  }
  else
  {
    v26 = 0x67000000D6LL;
    v22[0] = &v26;
    v22[1] = v28;
    n0x8A = 0x8A;
    v12 = invokeGlobalCallbackAndMaskStatusBits(
            2,
            (__int64)v22,
            (__int64)"Received Remote Method Wrong EntityId",
            "Remote method dispatch to incorrect network component");
    if ( (v12 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot = getThreadLogContextSlot();
      v23[0] = &v26;
      v23[1] = v28;
      v26 = 0x67000000D6LL;
      v25 = 0;
      n0x8A = 0x8A;
      sub_140354250(
        2,
        (__int64)v23,
        "Received Remote Method Wrong EntityId",
        (__int64)"Remote method dispatch to incorrect network component",
        1,
        v12,
        &v25,
        0,
        (__int64)ThreadLogContextSlot);
    }
  }
  v19 = __rdtsc();
  return qword_149C89AA8(&n0x6400);
}

// --- End Function: sub_142432A30 (0x142432BA3) ---

// --- Function: sub_147712830 (0x147712830) ---
__int64 __fastcall sub_147712830(__int64 a1)
{
  return sub_147712840(a1, 0);
}

// --- End Function: sub_147712830 (0x147712830) ---

// --- Function: sub_147715880 (0x147715880) ---
__int64 __fastcall sub_147715880(const void *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( qword_149C8E0F8 && qword_149C8DF28 && a1 == (const void *)qword_149C8DF28 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149C3E3B8
      || (result = qword_149C3E3B8 + 0x8000000000LL, (unsigned __int64)a1 >= qword_149C3E3B8 + 0x8000000000LL) )
    {
      if ( (unsigned __int64)a1 >= qword_149C3E398 && (unsigned __int64)a1 < qword_149C3E398 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      return sub_147712830(a1);
    }
  }
  return result;
}

// --- End Function: sub_147715880 (0x147715880) ---

// --- Function: allocWithProfilerInfo (0x147715930) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  unsigned __int8 v5; // bl
  __int64 v6; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1475EE1F0();
    v5 = sub_14056F960(v4);
    v6 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_147712FD0(v6 + allocSize, profilerInfo, v5);
    if ( result )
      return result;
    sub_1477151F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147715930) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14814323E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14814323E) ---

// --- Function: __alloca_probe (0x148144150) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x148144150) ---

// --- Function: __security_check_cookie (0x1481441B0) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x1481441B0) ---

// --- Function: __report_gsfailure (0x1481443AC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151877A00 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1518779F0 = 0xC0000409;
  dword_1518779F4 = 1;
  dword_151877A08 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1481443AC) ---

// --- Function: memcpy (0x148192BDB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x148192BDB) ---

// --- Function: memmove (0x148192BE1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148192BE1) ---

// --- Function: memset (0x148192BE7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148192BE7) ---

// --- Function: memcmp (0x148192C05) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148192C05) ---

