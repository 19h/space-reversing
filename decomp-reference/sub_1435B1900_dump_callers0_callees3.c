// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1435B1900 (sub_1435B1900)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 120
// ------------------------------------------------------------

// --- Function: sub_1402A24F0 (0x1402A24F0) ---
__int64 __fastcall sub_1402A24F0(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1402A24F0 (0x1402A24F0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 39 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 39);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 - 1) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_9 (0x1402E1F70) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E1F70) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n22 = 22;
  if ( n22 + 1 >= 0x1000 )
  {
    allocSize = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n22 == -1 )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FD310 (0x1402FD310) ---
__int64 __fastcall sub_1402FD310(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  if ( a4 < a5 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(a3 + 112 * a4 + 24))(
             *(_QWORD *)(a3 + 112 * a4),
             a1,
             a2,
             a4 - a5 + 1);
  else
    return 0;
}

// --- End Function: sub_1402FD310 (0x1402FD310) ---

// --- Function: sub_1402FD350 (0x1402FD350) ---
__int64 __fastcall sub_1402FD350(_BYTE *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  _BYTE v6[24]; // [rsp+40h] [rbp-18h] BYREF

  return sub_1402FF680((__int64)v6, a1, a2, a3, a4, a5);
}

// --- End Function: sub_1402FD350 (0x1402FD350) ---

// --- Function: sub_1402FD7E0 (0x1402FD7E0) ---
__int64 **__fastcall sub_1402FD7E0(__int64 **a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v6; // rcx
  __int64 *v7; // rbx
  __int64 n40; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 *v12; // rbp
  __int64 *v13; // rdx
  __int64 *v14; // r8
  __int64 *v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // r9
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  __int64 *v24; // rdx
  __int64 *v25; // r9
  __int64 v26; // rsi
  __int64 v27; // rdi
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r10
  __int64 v30; // rax
  bool v31; // zf
  __int64 *v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rsi
  unsigned __int64 v35; // rdi
  unsigned __int64 v36; // r11
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 **result; // rax

  v6 = a2;
  v7 = &a2[(__int64)(a3 - (_QWORD)a2) >> 4];
  n40 = (__int64)(a3 - 8 - (_QWORD)a2) >> 3;
  if ( n40 <= 40 )
  {
    v14 = (__int64 *)(a3 - 8);
  }
  else
  {
    v9 = (n40 + 1) >> 3;
    v10 = 16 * v9;
    v11 = 8 * v9;
    v12 = &a2[v9];
    sub_1402FD760(a2, v12, &a2[2 * v9]);
    sub_1402FD760(&v7[v11 / 0xFFFFFFFFFFFFFFF8uLL], v7, &v7[(unsigned __int64)v11 / 8]);
    sub_1402FD760((__int64 *)(a3 - 8 - v10), (__int64 *)(a3 - 8 - v11), (__int64 *)(a3 - 8));
    v14 = v13;
    v6 = v12;
  }
  sub_1402FD760(v6, v7, v14);
  v15 = v7 + 1;
  if ( a2 < v7 )
  {
    v16 = *v7;
    do
    {
      v17 = *(v7 - 1);
      v18 = *(_QWORD *)(v16 + 8);
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 < v18 || v19 == v18 && *(_QWORD *)(v17 + 80) < *(_QWORD *)(v16 + 80) )
        break;
      if ( v18 < v19 || v18 == v19 && *(_QWORD *)(v16 + 80) < *(_QWORD *)(v17 + 80) )
        break;
      --v7;
      v16 = v17;
    }
    while ( a2 < v7 );
  }
  if ( (unsigned __int64)v15 < a3 )
  {
    v20 = *v7;
    v21 = *(_QWORD *)(*v7 + 8);
    do
    {
      v22 = *v15;
      v23 = *(_QWORD *)(*v15 + 8);
      if ( v23 < v21 || v23 == v21 && *(_QWORD *)(v22 + 80) < *(_QWORD *)(v20 + 80) )
        break;
      if ( v21 < v23 || v21 == v23 && *(_QWORD *)(v20 + 80) < *(_QWORD *)(v22 + 80) )
        break;
      ++v15;
    }
    while ( (unsigned __int64)v15 < a3 );
  }
  v24 = v15;
  v25 = v7;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( (unsigned __int64)v24 < a3 )
      {
        v26 = *v24;
        v27 = *v7;
        v28 = *(_QWORD *)(*v24 + 8);
        v29 = *(_QWORD *)(*v7 + 8);
        if ( v29 >= v28 && (v29 != v28 || *(_QWORD *)(v27 + 80) >= *(_QWORD *)(v26 + 80)) )
        {
          if ( v28 < v29 || v28 == v29 && *(_QWORD *)(v26 + 80) < *(_QWORD *)(v27 + 80) )
            break;
          if ( v15 != v24 )
          {
            v30 = *v15;
            *v15 = v26;
            *v24 = v30;
          }
          ++v15;
        }
        ++v24;
      }
      v31 = v25 == a2;
      if ( v25 <= a2 )
        goto LABEL_46;
      v32 = v25 - 1;
      while ( 1 )
      {
        v33 = *v7;
        v34 = *v32;
        v35 = *(_QWORD *)(*v7 + 8);
        v36 = *(_QWORD *)(*v32 + 8);
        if ( v36 >= v35 && (v36 != v35 || *(_QWORD *)(v34 + 80) >= *(_QWORD *)(v33 + 80)) )
          break;
LABEL_44:
        --v25;
        --v32;
        if ( a2 >= v25 )
          goto LABEL_45;
      }
      if ( v35 >= v36 && (v35 != v36 || *(_QWORD *)(v33 + 80) >= *(_QWORD *)(v34 + 80)) )
      {
        if ( --v7 != v32 )
        {
          v37 = *v7;
          *v7 = v34;
          *v32 = v37;
        }
        goto LABEL_44;
      }
LABEL_45:
      v31 = v25 == a2;
LABEL_46:
      if ( !v31 )
      {
        --v25;
        if ( v24 == (__int64 *)a3 )
        {
          if ( v25 != --v7 )
          {
            v40 = *v25;
            *v25 = *v7;
            *v7 = v40;
          }
          v41 = *--v15;
          v42 = *v7;
          *v7 = v41;
          *v15 = v42;
        }
        else
        {
          v43 = *v24;
          *v24++ = *v25;
          *v25 = v43;
        }
        continue;
      }
      break;
    }
    if ( v24 != (__int64 *)a3 )
    {
      if ( v15 != v24 )
      {
        v38 = *v7;
        *v7 = *v15;
        *v15 = v38;
      }
      ++v15;
      v39 = *v7;
      *v7++ = *v24;
      *v24++ = v39;
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v7;
  a1[1] = v15;
  return result;
}

// --- End Function: sub_1402FD7E0 (0x1402FD7E0) ---

// --- Function: sub_1402FDAA0 (0x1402FDAA0) ---
unsigned __int64 __fastcall sub_1402FDAA0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rdi
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r11
  __int64 v11; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 n2; // rax
  unsigned __int64 v15; // r11
  __int64 v16; // rcx
  __int64 v17; // r8
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v10 = 2 * v9;
      v11 = *(_QWORD *)(a1 + 16 * v9 + 16);
      v12 = *(_QWORD *)(a1 + 16 * v9 + 8);
      v13 = *(_QWORD *)(v11 + 8);
      if ( v13 < *(_QWORD *)(v12 + 8) || v13 == *(_QWORD *)(v12 + 8) && *(_QWORD *)(v11 + 80) < *(_QWORD *)(v12 + 80) )
        n2 = 1;
      else
        n2 = 2;
      v9 = v10 + n2;
      *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * (v10 + n2));
      a2 = v10 + n2;
    }
    while ( v10 + n2 < v5 );
  }
  if ( v9 == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v8 >= a2 )
  {
    result = *a4;
    *(_QWORD *)(a1 + 8 * a2) = *a4;
  }
  else
  {
    while ( 1 )
    {
      v15 = *a4;
      v16 = (a2 - 1) >> 1;
      v17 = *(_QWORD *)(a1 + 8 * v16);
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(*a4 + 8) )
      {
        if ( result != *(_QWORD *)(*a4 + 8) )
          break;
        result = *(_QWORD *)(v15 + 80);
        if ( *(_QWORD *)(v17 + 80) >= result )
          break;
      }
      *(_QWORD *)(a1 + 8 * a2) = v17;
      a2 = (a2 - 1) >> 1;
      if ( v8 >= v16 )
      {
        result = *a4;
        *(_QWORD *)(a1 + 8 * v16) = *a4;
        return result;
      }
    }
    *(_QWORD *)(a1 + 8 * a2) = v15;
  }
  return result;
}

// --- End Function: sub_1402FDAA0 (0x1402FDAA0) ---

// --- Function: sub_1402FDB90 (0x1402FDB90) ---
unsigned __int64 __fastcall sub_1402FDB90(__int64 *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  _QWORD *v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v7 = ((__int64)v2 - *a1) / 112;
  if ( a2 < v7 )
  {
    v8 = v4 + 112 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 112 )
    {
      if ( *(_BYTE *)(i + 88) )
      {
        if ( *(_QWORD *)i )
          result = (*(__int64 (**)(void))(i + 64))();
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
    return result;
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v11 = v10 / 112;
  if ( a2 > v10 / 112 )
  {
    if ( a2 > 0x249249249249249LL )
      unknown_libname_10();
    v12 = v11 >> 1;
    if ( v11 <= 0x249249249249249LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x249249249249249LL )
          goto LABEL_29;
      }
      else
      {
        v13 = a2;
      }
      allocSize = 112 * v13;
      if ( 112 * v13 < 0x1000 )
      {
        if ( allocSize )
          v16 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
        else
          v16 = 0;
LABEL_23:
        v17 = &v16[14 * v7];
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 14;
            --v18;
          }
          while ( v18 );
        }
        sub_1402FE290(*a1, a1[1], v16);
        return sub_1402FFAF0(a1, (__int64)v16, a2, v13);
      }
      if ( allocSize + 39 >= allocSize )
      {
        v15 = allocWithProfilerInfo_w(allocSize + 39);
        if ( !v15 )
          invalid_parameter_noinfo_noreturn();
        v16 = (_QWORD *)((v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v16 - 1) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402E1170();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 14;
  }
  a1[1] = (__int64)v2;
  return result;
}

// --- End Function: sub_1402FDB90 (0x1402FDB90) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)v8 + 80LL) )
          {
            n256 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i - 1);
              i -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                  break;
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30-- - v8) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: sub_1402FE6B0 (0x1402FE6B0) ---
__int64 __fastcall sub_1402FE6B0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
      return 0xFFFFFFFFLL;
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAu;
    *(_BYTE *)(v6 + v5) = v9 + 48;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_1402FE6B0 (0x1402FE6B0) ---

// --- Function: sub_1402FE770 (0x1402FE770) ---
__int64 __fastcall sub_1402FE770(
        double *Buffer,
        unsigned __int64 Size,
        __int64 a3,
        const void **a4,
        const void **a5,
        const void **a6,
        _BYTE *p_])
{
  _BYTE *v7; // rdi
  size_t Size_1; // rbx
  char *v12; // rcx
  size_t Size_2; // rsi
  size_t Size_3; // rdi
  __int64 v15; // r14
  _BYTE *v16; // rsi
  char *v17; // rcx
  size_t Size_4; // rbp
  int v19; // eax
  int v20; // ecx
  __int64 result; // rax

  v7 = *a4;
  Size_1 = -1;
  do
    ++Size_1;
  while ( v7[Size_1] );
  if ( Size_1 + a3 >= Size )
    return 0xFFFFFFFFLL;
  v12 = (char *)Buffer + a3;
  Size_2 = Size - a3;
  if ( Size_1 )
  {
    if ( !v12 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v7 && Size_2 >= Size_1 )
    {
      memcpy(v12, *a4, Size_1);
    }
    else
    {
      memset(v12, 0, Size - a3);
      if ( !v7 )
        goto LABEL_6;
      if ( Size_2 < Size_1 )
      {
        *errno() = 34;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size_1 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  Size_3 = -1;
  v15 = a3 + (int)Size_1;
  v16 = *a5;
  do
    ++Size_3;
  while ( v16[Size_3] );
  if ( Size_3 + v15 >= Size )
    return 0xFFFFFFFFLL;
  v17 = (char *)Buffer + v15;
  Size_4 = Size - v15;
  if ( !Size_3 )
    goto LABEL_28;
  if ( !v17 )
    goto LABEL_20;
  if ( v16 && Size_4 >= Size_3 )
  {
    memcpy(v17, *a5, Size_3);
  }
  else
  {
    memset(v17, 0, Size - v15);
    if ( !v16 )
    {
LABEL_20:
      *errno() = 22;
LABEL_27:
      invalid_parameter_noinfo();
      goto LABEL_28;
    }
    if ( Size_4 < Size_3 )
    {
      *errno() = 34;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( (Size_3 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v19 = sub_1402FE920(Buffer, Size, v15 + (int)Size_3, a6, p_]);
  if ( v19 < 0 )
    return 0xFFFFFFFFLL;
  v20 = Size_3 + v19;
  result = (unsigned int)(Size_1 + Size_3 + v19);
  if ( v20 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_1402FE770 (0x1402FE770) ---

// --- Function: sub_1402FE920 (0x1402FE920) ---
__int64 __fastcall sub_1402FE920(double *Buffer, unsigned __int64 n0xF, __int64 a3, const void **a4, _BYTE *_)
{
  _BYTE *v5; // rsi
  size_t Size; // rbx
  char *v10; // rcx
  size_t Size_1; // rbp
  __int64 v12; // rcx
  size_t Size_2; // rdi
  _BYTE *v14; // rcx

  v5 = *a4;
  Size = -1;
  do
    ++Size;
  while ( v5[Size] );
  if ( Size + a3 >= n0xF )
    return 0xFFFFFFFFLL;
  v10 = (char *)Buffer + a3;
  Size_1 = n0xF - a3;
  if ( !Size )
    goto LABEL_14;
  if ( !v10 )
    goto LABEL_6;
  if ( v5 && Size_1 >= Size )
  {
    memcpy(v10, v5, Size);
  }
  else
  {
    memset(v10, 0, n0xF - a3);
    if ( !v5 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( Size_1 < Size )
    {
      *errno() = 34;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v12 = a3 + (int)Size;
  if ( v12 + 1 >= n0xF )
    return 0xFFFFFFFFLL;
  Size_2 = n0xF - v12;
  v14 = (char *)Buffer + v12;
  if ( !v14 )
  {
LABEL_17:
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(Size + 1);
  }
  if ( _ && Size_2 )
  {
    *v14 = *_;
    return (unsigned int)(Size + 1);
  }
  else
  {
    memset(v14, 0, Size_2);
    if ( !_ )
      goto LABEL_17;
    if ( !Size_2 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(Size + 1);
  }
}

// --- End Function: sub_1402FE920 (0x1402FE920) ---

// --- Function: sub_1402FEA70 (0x1402FEA70) ---
__int64 __fastcall sub_1402FEA70(double *Buffer, unsigned __int64 n0xF, __int64 a3, char *p____EVT_COUNT__:, int *a5)
{
  unsigned __int64 n0xD; // rdi
  char *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r10
  int v13; // ecx
  int v14; // r9d
  __int64 v15; // rdi
  __int64 i; // r8
  __int64 v17; // r11
  int v18; // eax
  char *v19; // r8
  char *v20; // rax
  __int64 v21; // r10
  char v22; // cl
  char v23; // dl
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v10 = (char *)Buffer + a3;
  if ( !v10 )
    goto LABEL_3;
  if ( p____EVT_COUNT__: && n0xD >= 0xD )
  {
    *(double *)v10 = *(double *)p____EVT_COUNT__:;
    *((_DWORD *)v10 + 2) = *((_DWORD *)p____EVT_COUNT__: + 2);
    v10[0xC] = p____EVT_COUNT__:[0xC];
    goto LABEL_11;
  }
  memset(v10, 0, n0xF - a3);
  if ( p____EVT_COUNT__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v11 = n0xF - (a3 + 0xD);
  v12 = (__int64)Buffer + a3 + 0xD;
  v13 = *a5;
  if ( *a5 >= 0 )
  {
    v14 = 0;
  }
  else if ( v11 )
  {
    *(_BYTE *)v12 = 0x2D;
    v13 = -v13 & 0x7FFFFFFF;
    v14 = 1;
  }
  else
  {
    v14 = 0xFFFFFFFF;
  }
  v15 = v14;
  for ( i = v14; ; ++i )
  {
    v17 = v14;
    if ( v14 >= (int)v11 || i < 0 )
      break;
    ++v14;
    v18 = v13 % 0xA;
    v13 /= 0xA;
    *(_BYTE *)(i + v12) = v18 + 0x30;
    if ( !v13 )
    {
      if ( v15 < v17 )
      {
        v19 = (char *)(v17 + v12);
        v20 = (char *)(v15 + v12);
        v21 = -v12;
        do
        {
          v22 = *v19--;
          v23 = *v20;
          *v20++ = v22;
          v19[1] = v23;
        }
        while ( (__int64)&v20[v21] < (__int64)&v19[v21] );
      }
      result = (unsigned int)(v14 + 0xD);
      if ( v14 >= 0 )
        return result;
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEA70 (0x1402FEA70) ---

// --- Function: sub_1402FEBF0 (0x1402FEBF0) ---
__int64 __fastcall sub_1402FEBF0(
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a3,
        char *p____@severity__:,
        unsigned int *p_n0xF,
        char *___severity__:_,
        const void **a7,
        char *p______tags__:[)
{
  unsigned __int64 n0xD; // rbx
  char *v13; // rcx
  int v14; // ebx
  __int64 v15; // rsi
  __int64 v16; // rcx
  unsigned int n0xF_1; // r9d
  __int64 v18; // r8
  __int64 v19; // r11
  unsigned int v20; // eax
  char *v21; // rdx
  __int64 v22; // r9
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v13 = (char *)Buffer + a3;
  if ( !v13 )
    goto LABEL_3;
  if ( p____@severity__: && n0xD >= 0xD )
  {
    *(double *)v13 = *(double *)p____@severity__:;
    *((_DWORD *)v13 + 2) = *((_DWORD *)p____@severity__: + 2);
    v13[0xC] = p____@severity__:[0xC];
    goto LABEL_11;
  }
  memset(v13, 0, n0xF - a3);
  if ( p____@severity__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v14 = 0;
  v15 = a3 + 0xD;
  v16 = 0;
  n0xF_1 = *p_n0xF;
  v18 = (__int64)Buffer + v15;
  while ( 1 )
  {
    v19 = v14;
    if ( v14 >= (int)n0xF - (int)v15 || v16 < 0 )
      break;
    ++v14;
    v20 = n0xF_1 % 0xA;
    n0xF_1 /= 0xAu;
    *(_BYTE *)(v16 + v18) = v20 + 0x30;
    ++v16;
    if ( !n0xF_1 )
    {
      if ( (int)v19 > 0 )
      {
        v21 = (char *)(v19 + v18);
        v22 = -v18;
        do
        {
          v23 = *v21--;
          v24 = *(_BYTE *)v18;
          *(_BYTE *)v18++ = v23;
          v21[1] = v24;
        }
        while ( v22 + v18 < (__int64)&v21[v22] );
      }
      if ( v14 >= 0 )
      {
        v25 = sub_1402FED90(Buffer, n0xF, v15 + v14, ___severity__:_, a7, p______tags__:[);
        if ( v25 >= 0 )
        {
          v26 = v14 + v25;
          result = (unsigned int)(v14 + v25 + 0xD);
          if ( v26 < 0 )
            return 0xFFFFFFFFLL;
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEBF0 (0x1402FEBF0) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---
void __fastcall std::vector<vraudio::AudioBuffer const *>::_Change_array(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  _QWORD *v6; // rcx

  v6 = *(_QWORD **)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)*(v6 - 1);
    }
    sub_1402A3D30(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(__int64 a1, _QWORD *a2, __int64 a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(a3 + 36));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(a3 + 32);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(a3 + 8);
  v18 = *(_QWORD *)a3;
  v31 = v16;
  if ( (v17 - *(_QWORD *)a3) / 112 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 88) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 64))();
        v18 += 112;
      }
      while ( v18 != v17 );
      *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
    }
    sub_1402FDB90((__int64 *)a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 48;
    v23 = -48 - __Val_0___1;
    v29 = -48 - __Val_0___1;
    while ( !v16 )
    {
      v20 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 24)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 112LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 48),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)a3));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 112;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = -16 - __Val_0__;
      v26 = __Val_0__ + 16;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 56)
          && *(_QWORD *)(v26 + 32) )
        {
          if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 112LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)a3;
          if ( *(_BYTE *)(v27 + 88) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 64))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 56))(*(_QWORD *)(v26 - 16));
          v25 = -16 - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 16) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 24) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 32) = *(_QWORD *)(v26 + 16);
          *(_QWORD *)(v27 + 48) = *(_QWORD *)(v26 + 32);
          *(_QWORD *)(v27 + 40) = *(_QWORD *)(v26 + 24);
          *(_QWORD *)(v27 + 56) = *(_QWORD *)(v26 + 40);
          *(_QWORD *)(v27 + 64) = *(_QWORD *)(v26 + 48);
          *(_QWORD *)(v27 + 72) = *(_QWORD *)(v26 + 56);
          *(_QWORD *)(v27 + 80) = *(_QWORD *)(v26 + 64);
          *(_QWORD *)(v27 + 96) = *(_QWORD *)(v26 + 80);
          *(_QWORD *)(v27 + 104) = *(_QWORD *)(v26 + 88);
          *(_BYTE *)(v27 + 88) = 1;
          *(_BYTE *)(v27 + 89) = *(_BYTE *)(v26 + 73);
        }
        ++_Newcapacity_2;
        v26 += 112;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(a3 + 24) = a1;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 19), SizeInBytes - 19, ".%03dZ", v3 - 1000 * v7) + 19);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149B3B1F0 )
    result = qword_149B3B1F0(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149B3B208 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140300AB0 (0x140300AB0) ---
__int64 __fastcall sub_140300AB0(int a1)
{
  __int64 n1000; // rax

  switch ( a1 )
  {
    case 2:
      n1000 = 1000;
      break;
    case 3:
      n1000 = 5000;
      break;
    case 4:
      n1000 = 15000;
      break;
    case 5:
      n1000 = 30000;
      break;
    case 6:
      n1000 = 60000;
      break;
    case 7:
      n1000 = 300000;
      break;
    case 8:
      n1000 = 900000;
      break;
    case 9:
      n1000 = 1800000;
      break;
    default:
      n1000 = 0;
      break;
  }
  return n1000;
}

// --- End Function: sub_140300AB0 (0x140300AB0) ---

// --- Function: sub_140300BC0 (0x140300BC0) ---
__int64 __fastcall sub_140300BC0(_WORD *a1, int a2, char n37)
{
  unsigned int n2_1; // r10d
  __int64 n2; // rax

  n2_1 = 0;
  switch ( n37 )
  {
    case 8:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 25180;
      n2 = 2;
      break;
    case 9:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29788;
      n2 = 2;
      break;
    case 10:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 28252;
      n2 = 2;
      break;
    case 12:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 26204;
      n2 = 2;
      break;
    case 13:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29276;
      n2 = 2;
      break;
    case 34:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 8796;
      n2 = 2;
      break;
    case 92:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 23644;
      n2 = 2;
      break;
    default:
      if ( a2 > 0 )
      {
        *(_BYTE *)a1 = n37;
        n2_1 = 1;
      }
LABEL_18:
      n2 = n2_1;
      break;
  }
  return n2;
}

// --- End Function: sub_140300BC0 (0x140300BC0) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        char *a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = -1;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = -1;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 22;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 22;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 34;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 91;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = -1;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 31;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = -1;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 22;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 34;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 22;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 34;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 15392;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 22;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 34;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = -1;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 22;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 34;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = -1;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 22;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 34;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 8254;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 34;
  }
  else
  {
    *errno() = 22;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = -1;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 34;
  }
  else
  {
LABEL_108:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 32;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = -1;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 91;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 34;
            }
            else
            {
              *errno() = 22;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 22;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 34;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = -1;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 22;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 34;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 14;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 11822;
      Buffer_3[Size - 2] = 46;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        char *a7,
        char *a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 128;
  n0xF_5[0] = n4;
  v159 = a6;
  n0xF_17 = n0xF + 128;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 1886216564;
    *((_WORD *)Buffer + 6) = 14882;
    *((_BYTE *)Buffer + 14) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = -1;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 15 >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_25 = -1;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 15;
  Size_1 = n0xF_1 - 15;
  if ( Size )
  {
    if ( Buffer == (double *)-15LL )
    {
LABEL_11:
      *errno() = 22;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 15);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 34;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 15LL;
  if ( (int)Size + 24LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 22;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 34;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 34;
LABEL_28:
  v34 = (int)Size + 24LL;
  Size_3 = -1;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 22;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 34;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 13 >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 22;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 34;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 578315369;
  *((_BYTE *)v39 + 12) = 58;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 13, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 13;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_25 = v45 + 15;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 31;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              v162,
              v161,
              n4_1,
              v166,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (a18 & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 128;
      n0xF_26 = n0xF + 128;
      n0xF_18 = n0xF + 128;
      goto LABEL_95;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 128;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 128;
      n0xF_18 = n0xF + 128;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 128;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 128;
  n0xF_18 = n0xF + 128;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 22;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 34;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 34;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = -1;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_129:
      n0xF_3 = n0xF + 128;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      v58 = v159;
      goto LABEL_131;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 34;
      }
      else
      {
LABEL_111:
        *errno() = 22;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 128;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_130;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 11298;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 22;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 34;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 34;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_145:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 11LL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 22;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 34;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 14882;
      *((_BYTE *)v88 + 10) = 34;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 11;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 128;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 13LL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 22;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 34;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 975332711;
      *((_BYTE *)v94 + 12) = 34;
    }
    n0xF_2 += 13;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 128;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 34;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 11LL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 22;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 34;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 11;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 11;
    *((_WORD *)v97 + 4) = 14882;
    *((_BYTE *)v97 + 10) = 34;
  }
LABEL_209:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            v164,
            __Val_0___1,
            _Newcapacity,
            a11,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 22;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 34;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 34;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 80);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != -1;
              n0xF_16 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 22;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 34;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 11357;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 80);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != -1;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_248:
              v115 = n0xF + 128;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 22;
                goto LABEL_255;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 34;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 128;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 34;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = -1;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 22;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 34;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 128;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 22;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 34;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 14882;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != -1 )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 22;
                  goto LABEL_292;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 34;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 91;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 80);
          v102 = v114 != -1;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 80);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != -1;
          n0xF_16 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 22;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 34;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 44;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 44;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 34;
      }
      else
      {
        *errno() = 22;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 32))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 128;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 128;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 22;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 34;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 1819635234;
          v136[2] = 8812;
        }
      }
LABEL_315:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 22;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 34;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 93;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 13LL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 22;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 34;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 975329103;
        *((_BYTE *)v139 + 12) = 49;
      }
      n0xF_2 += 13;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 22;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 34;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 2685;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    v147 = v161;
    qword_149B3B210(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 39 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 39);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(_Newvec - 1) = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
char __fastcall sub_1403045C0(
        unsigned int n4_1,
        __int64 *a2,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  char result; // al
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned __int64 n0x10; // rax
  __int64 *v17; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v19; // r13
  char *v20; // r15
  __int64 v21; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v23; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  __int64 *v25; // rax
  __int64 *v26; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v28; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  __int64 v32; // r13
  __int64 (__fastcall *v33)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v34; // rax
  unsigned __int64 v35; // rcx
  __int64 *v36; // rdi
  _QWORD *v37; // r13
  bool v38; // zf
  _QWORD *v39; // rbx
  _QWORD *v40; // rax
  _BYTE *v41; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v44; // r9
  __int64 v45; // rcx
  __m256 *p_Src; // r14
  char *v47; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __int64 p_Src_2; // r15
  _QWORD *v51; // r14
  _QWORD *v52; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v57; // rax
  __int64 *v58; // rcx
  __int64 v59; // rcx
  _QWORD *v60; // rbx
  __int64 v61; // rcx
  __int64 *v62; // r14
  __int64 p_Src_3; // rax
  __int64 *v64; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v66; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v70; // rax
  char *v71; // r11
  unsigned __int64 _Newcapacity_1; // r10
  char *v73; // rdi
  int v74; // r13d
  __int64 v75; // rcx
  __int64 v76; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v78; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v83; // rax
  __int64 v84; // r15
  char *v85; // r14
  __int64 v86; // rax
  void *v87; // rsp
  __int64 (__fastcall *v88)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v89; // edx
  int v90; // r12d
  char v91; // cl
  int v92; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v96; // al
  bool v97; // dl
  bool v98; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v100; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v105; // rax
  void *v106; // rsp
  char v107; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v110; // rsi
  _QWORD **v111; // rcx
  _QWORD *v112; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v114; // rdi
  __int64 v115; // rcx
  __int64 *v116; // rbx
  __int64 v117; // rcx
  int v118; // [rsp+90h] [rbp-10h]
  unsigned __int8 v119; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  __int64 *v121; // [rsp+B0h] [rbp+10h]
  __int64 v122; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v124; // [rsp+C8h] [rbp+28h] BYREF
  int v125[2]; // [rsp+D0h] [rbp+30h]
  char *v126; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v130; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v132; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v134; // [rsp+118h] [rbp+78h]
  char *v135; // [rsp+120h] [rbp+80h]
  __int64 *v136; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v138; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v143; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v144; // [rsp+168h] [rbp+C8h] BYREF
  __int64 v145; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v148[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v149[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v134 = a4;
  v135 = a3;
  v136 = a2;
  n4 = n4_1;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v130 = v12;
  if ( v11 )
  {
    result = sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v144 = (__int64 *)&v143;
  n0x10 = 0;
  v143 = 0;
  v17 = 0;
  v121 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v19 = 0;
  v122 = 0;
  v20 = 0;
  n0x10_1 = 0;
  v21 = 0;
  v126 = 0;
  v124 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v73 = (char *)v149;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v23 = v119;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 89) && n0x10 < 0x10 )
    {
      v148[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v149[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v17 )
      {
        __asm { vzeroupper }
        v25 = (__int64 *)allocWithProfilerInfo_w(0x18u);
        v17 = v25;
        v121 = v25;
        if ( v25 )
        {
          v26 = v25;
          *v25 = 0;
          n0x400_1 = 0;
          v25[1] = 0;
          v28 = (__int64)v25;
          v25[2] = 0;
        }
        else
        {
          v17 = 0;
          v26 = 0;
          n0x400_1 = 0;
          v121 = 0;
          v28 = 0;
        }
        sub_1403044D0(v28, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v149;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v26[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v26[2] )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              (std::vector<vraudio::AudioBuffer const *> *)v17,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v26[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v21 = v124;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v17[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v17[2] )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          (std::vector<vraudio::AudioBuffer const *> *)v17,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        v17[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v122 = *((_QWORD *)__Val_0___1 + 13) + v19;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v144, __Val_0___1, v14, v15);
    v32 = v21;
    v33 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v145 = v21++;
    v124 = v21;
    if ( !v33 )
    {
      v71 = v126;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v132 = 0;
    v34 = v33(*(_QWORD *)__Val_0___1, &v132, &__Val_0___4);
    v35 = 0;
    *(_QWORD *)v125 = 0;
    if ( !v132 )
      goto LABEL_94;
    v36 = v144;
    v37 = (_QWORD *)(v34 + 16);
    v138 = (_QWORD *)(v34 + 16);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v37 - 2);
      __Val_0___5 = (vraudio::AudioBuffer *)(v37 - 2);
      v38 = *v37 == 0;
      v124 = v21 + 1;
      v37[8] = v21;
      if ( v38 )
      {
        v60 = (_QWORD *)*(v37 - 1);
        v62 = 0;
      }
      else
      {
        if ( !*v36 )
        {
          __asm { vzeroupper }
          v39 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v39 )
          {
            *v39 = 0;
            v39[1] = 0;
            v40 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v40 = v40;
            v40[1] = v40;
            *v39 = v40;
          }
          else
          {
            v39 = 0;
          }
          *v36 = (__int64)v39;
        }
        v41 = (_BYTE *)*(v37 - 1);
        Size = -1;
        memset(&Src, 0, sizeof(Src));
        Size_1 = -1;
        do
          ++Size_1;
        while ( v41[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v41, Size_1, v15);
        v44 = (_BYTE *)*v37;
        do
          ++Size;
        while ( v44[Size] );
        v45 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v23, v44, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v47 = (char *)p_Src + v45;
          memmove(v47, v44, Size);
          v47[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v36;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(_QWORD *)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v51 = *(_QWORD **)__Val_0___7;
        v52 = **(_QWORD ***)__Val_0___7;
        if ( v52 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v52[4];
          Buf1 = v52 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = (__m256 *)p_Src_2;
          if ( v52[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v52 = (_QWORD *)*v52;
        }
        while ( v52 != v51 );
        __Val_0___7 = __Val_0___6;
        if ( v52 == v51 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v57 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v57 + 32) = 0;
          *(_QWORD *)(v57 + 40) = 0;
          *(__m256 *)(v57 + 16) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v58 = (__int64 *)v51[1];
          *(_QWORD *)v57 = v51;
          *(_QWORD *)(v57 + 8) = v58;
          v51[1] = v57;
          *v58 = v57;
          v59 = *(_QWORD *)*v36;
          v60 = (_QWORD *)(*(_QWORD *)(v59 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v59 + 8) + 40LL) > 0xFu )
            v60 = (_QWORD *)*v60;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v61 = *(_QWORD *)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v61 = *(_QWORD *)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - v61 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v61);
          }
LABEL_66:
          v17 = v121;
          v62 = 0;
          v37 = v138;
          __Val_0___3 = __Val_0___5;
          v35 = *(_QWORD *)v125;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          goto LABEL_74;
        }
        v60 = v52 + 2;
        if ( v60[3] > 0xFu )
          v60 = (_QWORD *)*v60;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
          if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v17 = v121;
        v62 = 0;
        v37 = v138;
        __Val_0___3 = __Val_0___5;
        v35 = *(_QWORD *)v125;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 15;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v60;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v17 )
        {
          __asm { vzeroupper }
          v64 = (__int64 *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v121 = v64;
          v17 = v64;
          if ( v64 )
          {
            *v64 = 0;
            v66 = (__int64)v64;
            v64[1] = 0;
            v64[2] = 0;
            v62 = v64;
          }
          else
          {
            v17 = 0;
            v121 = 0;
            v66 = 0;
          }
          sub_1403044D0(v66, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v149;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v62[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v62[2] )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                (std::vector<vraudio::AudioBuffer const *> *)v17,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v62[1] += 8;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v17[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v17[2] )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            (std::vector<vraudio::AudioBuffer const *> *)v17,
            _Whereptr_3,
            &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          v17[1] += 8;
        }
        v35 = *(_QWORD *)v125;
      }
      else
      {
        v149[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v35;
      v70 = v37[11] + v122;
      v37 += 14;
      v21 = v124;
      v122 = v70;
      *(_QWORD *)v125 = v35;
      v138 = v37;
    }
    while ( v35 < v132 );
    __Val_0___1 = __Val_0___2;
    v32 = v145;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v32 = -1;
    v71 = &v126[__Val_0___4];
    v126 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 112);
    v14 = v122;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 10) = v32;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v19 = v14;
      continue;
    }
    break;
  }
  v20 = v71;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  v126 = v71;
  if ( !v17 )
    goto LABEL_105;
  if ( !((v17[1] - *v17) >> 3) )
    __debugbreak();
  v73 = (char *)*v17;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v126 = v71;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v73, (unsigned __int64)&v73[8 * n0x400], (__int64)(8 * n0x400) >> 3, v119);
  v74 = 0;
  v75 = 0;
  v76 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v78 = *(_QWORD *)&v73[8 * n0x400_3];
    if ( v76 == *(_QWORD *)(v78 + 8) )
    {
      if ( ++v75 == 1 )
        *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3 - 8] + 80LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 80LL) = v75;
    }
    else
    {
      v75 = 0;
      *(_QWORD *)(v78 + 80) = -(__int64)(*(_QWORD *)(v78 + 80) != -1);
      v76 = *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v20 + 1) << 10;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v84 = 0;
  }
  else
  {
    v83 = allocWithProfilerInfo_w(n0x8000_2);
    v84 = v83;
    if ( v83 )
    {
      v85 = (char *)v83;
      goto LABEL_130;
    }
  }
  v86 = n0x8000_2 + 15;
  if ( n0x8000_2 + 15 < n0x8000_2 )
    v86 = 0xFFFFFFFFFFFFFF0LL;
  v87 = alloca(v86 & 0xFFFFFFFFFFFFFFF0uLL);
  v85 = (char *)&v119;
LABEL_130:
  v88 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v89 = 1;
  *v85 = 0;
  v90 = 0;
  LODWORD(v124) = 0;
  v125[0] = 1;
  if ( v88 && qword_149B3B200 && byte_149924748 )
  {
    v89 = v88(v130, n4, v135, v136, v134, __Val_0__, _Newcapacity, v148, n0x10_1, &a8);
    v125[0] = v89;
  }
  v91 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v92 = sub_140302340(
            *(_QWORD *)&FileTime,
            v130,
            (__int64)String,
            n4,
            v136,
            v135,
            v134,
            __Val_0__,
            _Newcapacity,
            a7,
            v85,
            n0x8000_2,
            (int *)&v124,
            v89,
            &a8);
    v91 = a8;
    v90 = v92;
    v74 = v124;
  }
  if ( n2_125 == 1 && (v91 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v85);
    v91 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v91 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v85);
    n2_126 = ::n2_126;
  }
  v85[v90] = 0;
  v96 = a8;
  v97 = (a8 & 1) != 0 && n2_125 == 2;
  v98 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v97 || v98 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v100 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v100 = v122 + v90 + ((_QWORD)(v126 + 4) << 9);
    n0x8000_3 = v100 + 128;
    if ( *p_n0x8000_1 < v100 + 128 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v105 = n0x8000_3 + 15;
    if ( n0x8000_3 + 15 < n0x8000_3 )
      v105 = 0xFFFFFFFFFFFFFF0LL;
    v106 = alloca(v105 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v119;
LABEL_166:
    v118 = v125[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v130,
      Buffer,
      String,
      n4,
      v136,
      v135,
      v134,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v73,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 128,
      (__int64)&v85[v74],
      v90 - v74,
      a8,
      v118);
    sub_1402A3D30(Buffer_3);
    v96 = a8;
  }
  v107 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v96 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v96 = a8;
      v107 = byte_149B3AEA8;
    }
    if ( v107 )
    {
      if ( (v96 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A3D30(v84);
  v110 = v143;
  if ( v143 )
  {
    v111 = (_QWORD **)*v143;
    **(_QWORD **)(*v143 + 8) = 0;
    v112 = *v111;
    if ( *v111 )
    {
      do
      {
        n0xF_1 = v112[5];
        v114 = (_QWORD *)*v112;
        if ( n0xF_1 > 0xF )
        {
          v115 = v112[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v115 - *(_QWORD *)(v115 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v115 = *(_QWORD *)(v115 - 8);
          }
          sub_1402A3D30(v115);
        }
        v112[4] = 0;
        v112[5] = 15;
        *((_BYTE *)v112 + 16) = 0;
        sub_1402A3D30((__int64)v112);
        v112 = v114;
      }
      while ( v114 );
    }
    sub_1402A3D30(*v110);
    result = sub_1402A3D30((__int64)v110);
  }
  v116 = v121;
  if ( v121 )
  {
    v117 = *v121;
    if ( *v121 )
    {
      if ( ((v121[2] - v117) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v117 - *(_QWORD *)(v117 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v117 = *(_QWORD *)(v117 - 8);
      }
      sub_1402A3D30(v117);
      *v116 = 0;
      v116[1] = 0;
      v116[2] = 0;
    }
    return sub_1402A3D30((__int64)v116);
  }
  return result;
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: sub_140305400 (0x140305400) ---
__int64 __fastcall sub_140305400(
        __int64 a1,
        __int64 a2,
        int a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        __int64 (__fastcall *a9)(__int64, __int64, __int64, __int64, __int64, _BYTE *))
{
  __int64 v9; // rbp
  int v11; // ecx
  int v12; // esi
  char n37; // r8
  __int64 v14; // r15
  char *v15; // rbx
  __int64 v17; // rcx
  char n36; // cl
  __int64 v19; // rdi
  _BYTE *v20; // r11
  unsigned __int64 n0x39; // rcx
  char *v22; // r10
  int n31_2; // r8d
  __int64 n31; // rdx
  __int64 v25; // r9
  int n31_1; // eax
  __int64 n31_3; // rcx
  int v28; // eax
  int v29; // edi
  _BYTE *v30; // rbp
  int n31_5; // r9d
  __int64 n31_6; // r8
  char *v33; // r11
  __int64 v34; // r10
  unsigned __int64 n0x39_1; // rdx
  int n31_4; // eax
  int v37; // eax
  int v38; // eax
  __int64 v39; // rax
  _BYTE *v41; // [rsp+28h] [rbp-90h]
  char String[4]; // [rsp+30h] [rbp-88h] BYREF
  int v43; // [rsp+34h] [rbp-84h]
  __int64 (__fastcall *v44)(__int64, __int64, __int64, __int64, __int64, _BYTE *); // [rsp+38h] [rbp-80h]
  __int64 v45; // [rsp+40h] [rbp-78h]
  _BYTE v46[32]; // [rsp+48h] [rbp-70h] BYREF

  v9 = a5;
  v11 = a3;
  v12 = a3;
  v45 = a5;
  n37 = *a4;
  v14 = 0;
  v44 = a9;
  v15 = a4;
  v43 = v11;
  if ( n37 )
  {
    do
    {
      v17 = 0x3FF6C0900000000LL;
      if ( n37 == 36 )
      {
        n36 = *++v15;
        v19 = 0;
        if ( n36 == 36 )
        {
LABEL_6:
          v19 = v14++;
        }
        else
        {
          while ( (unsigned __int8)(n36 - 48) <= 9u )
          {
            String[0] = n36;
            ++v15;
            v19 = atoi(String) + 10 * v19;
            n36 = *v15;
            if ( *v15 == 36 )
              goto LABEL_6;
          }
          --v15;
        }
        v20 = 0;
        if ( v15[1] == 123 )
        {
          n0x39 = (unsigned __int8)v15[2];
          v22 = v15;
          v15 += 2;
          n31_2 = 0;
          n31 = 0;
          if ( (_BYTE)n0x39 != 125 )
          {
            do
            {
              if ( n31 >= 31 || (unsigned __int8)n0x39 > 0x39u || (v25 = 0x3FF6C0900000000LL, !_bittest64(&v25, n0x39)) )
              {
                v15 = v22;
                goto LABEL_20;
              }
              ++v15;
              v46[n31] = n0x39;
              ++n31_2;
              ++n31;
              n0x39 = (unsigned __int8)*v15;
            }
            while ( (_BYTE)n0x39 != 125 );
            if ( n31_2 > 0 )
            {
              n31_1 = 31;
              if ( n31_2 < 31 )
                n31_1 = n31_2;
              n31_3 = n31_1;
              if ( (unsigned __int64)n31_1 >= 0x20 )
LABEL_55:
                _report_rangecheckfailure(n31_3);
              v46[n31_1] = 0;
              v20 = v46;
            }
          }
        }
LABEL_20:
        if ( v12 < (int)a2 )
        {
          v28 = v44(v12 + a1, a2 - v12, v9, v19 + a7, a6, v20);
          if ( v28 >= 0 )
            v12 += v28;
        }
        v29 = a2;
      }
      else if ( n37 == 37 )
      {
        v30 = 0;
        n31_5 = 0;
        n31_6 = 0;
        v33 = v15;
        v34 = 0;
        while ( 2 )
        {
          n0x39_1 = *++v15;
          switch ( (int)n0x39_1 )
          {
            case 0:
              v15 = v33 + 1;
              goto LABEL_39;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64:
            case 66:
            case 68:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 84:
            case 85:
            case 86:
            case 87:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            case 96:
            case 98:
            case 104:
            case 106:
            case 107:
            case 108:
            case 109:
            case 113:
            case 114:
            case 116:
            case 118:
            case 119:
              v17 = 0x3FF6C0900000000LL;
              goto LABEL_28;
            case 37:
            case 65:
            case 67:
            case 69:
            case 70:
            case 71:
            case 83:
            case 88:
            case 90:
            case 97:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 105:
            case 110:
            case 111:
            case 112:
            case 115:
            case 117:
            case 120:
              if ( n31_5 <= 0 )
                goto LABEL_37;
              n31_4 = 31;
              if ( n31_5 < 31 )
                n31_4 = n31_5;
              n31_3 = n31_4;
              if ( (unsigned __int64)n31_4 >= 0x20 )
                goto LABEL_55;
              v46[n31_4] = 0;
              v30 = v46;
LABEL_37:
              v34 = v14++;
LABEL_39:
              v29 = a2;
              if ( v12 >= (int)a2 )
              {
                v9 = v45;
              }
              else
              {
                v41 = v30;
                v9 = v45;
                v37 = v44(v12 + a1, a2 - v12, v45, v34 + a7, a6, v41);
                if ( v37 >= 0 )
                  v12 += v37;
              }
              break;
            default:
LABEL_28:
              if ( n31_6 < 31 && (unsigned __int8)n0x39_1 <= 0x39u && _bittest64(&v17, n0x39_1) )
              {
                ++n31_5;
                v46[n31_6++] = n0x39_1;
              }
              continue;
          }
          break;
        }
      }
      else
      {
        v29 = a2;
        if ( a8 )
        {
          if ( v12 < (int)a2 )
          {
            v38 = sub_140300BC0((_WORD *)(v12 + a1), (int)a2 - v12, n37);
            if ( v38 >= 0 )
              v12 += v38;
          }
        }
        else if ( v12 < (int)a2 )
        {
          v39 = v12++;
          *(_BYTE *)(v39 + a1) = n37;
        }
      }
      n37 = *++v15;
    }
    while ( n37 );
    v11 = v43;
  }
  else
  {
    v29 = a2;
  }
  if ( v12 < v29 )
    *(_BYTE *)(v12 + a1) = 0;
  return (unsigned int)(v12 - v11);
}

// --- End Function: sub_140305400 (0x140305400) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: unknown_libname_19 (0x14030E880) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_19(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: unknown_libname_19 (0x14030E880) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: sub_14031FF80 (0x14031FF80) ---
__int64 __fastcall sub_14031FF80(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x48);
}

// --- End Function: sub_14031FF80 (0x14031FF80) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 24576 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_140370F70 (0x140370F70) ---
__int64 __fastcall sub_140370F70(__int64 a1)
{
  return sub_1402A3D30(*(const void **)(a1 + 0x10));
}

// --- End Function: sub_140370F70 (0x140370F70) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1 & 0xFFFFFFFFFFFFLL, 0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_1403B3E40 (0x1403B3E40) ---
const char *sub_1403B3E40()
{
  return "Name";
}

// --- End Function: sub_1403B3E40 (0x1403B3E40) ---

// --- Function: sub_1403B3E60 (0x1403B3E60) ---
const char *sub_1403B3E60()
{
  return "TraceContext";
}

// --- End Function: sub_1403B3E60 (0x1403B3E60) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 sub_1403E4B50()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4B90 (0x1403E4B90) ---
_QWORD *__fastcall sub_1403E4B90(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A3D30(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)allocWithProfilerInfo_w(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E4B90 (0x1403E4B90) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
__int64 __fastcall sub_1403E4E60(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4E80 (0x1403E4E80) ---
__int64 __fastcall sub_1403E4E80(const void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_1402A3D30(a1[2]);
    return sub_1402A3D30(a1);
  }
  return result;
}

// --- End Function: sub_1403E4E80 (0x1403E4E80) ---

// --- Function: sub_1403E75F0 (0x1403E75F0) ---
bool __fastcall sub_1403E75F0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  __int64 v2; // r8
  int v3; // eax
  int v4; // edx

  if ( a1 == a2 )
    return 1;
  if ( !a1 || !a2 )
    return 0;
  v2 = a2 - a1;
  do
  {
    v3 = a1[v2];
    v4 = *a1 - v3;
    if ( v4 )
      break;
    ++a1;
  }
  while ( v3 );
  return !v4;
}

// --- End Function: sub_1403E75F0 (0x1403E75F0) ---

// --- Function: sub_1403E7650 (0x1403E7650) ---
bool __fastcall sub_1403E7650(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E7650 (0x1403E7650) ---

// --- Function: sub_1403EAF40 (0x1403EAF40) ---
__int64 __fastcall sub_1403EAF40(int *a1, __int64 a2, __int64 a3)
{
  return sub_14035AB90(a2, a3, 0, *a1);
}

// --- End Function: sub_1403EAF40 (0x1403EAF40) ---

// --- Function: sub_1403EAF60 (0x1403EAF60) ---
__int64 __fastcall sub_1403EAF60(const char *p_null_1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EAF60 (0x1403EAF60) ---

// --- Function: sub_1403EB0E0 (0x1403EB0E0) ---
__int64 __fastcall sub_1403EB0E0(__int64 a1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EB0E0 (0x1403EB0E0) ---

// --- Function: sub_1403EB4B0 (0x1403EB4B0) ---
__int64 __fastcall sub_1403EB4B0(const char *Val, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( Val )
    p_null = Val;
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = -1;
  Size = -1;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB4B0 (0x1403EB4B0) ---

// --- Function: sub_1403EB580 (0x1403EB580) ---
__int64 __fastcall sub_1403EB580(__int64 a1, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB580 (0x1403EB580) ---

// --- Function: sub_140445520 (0x140445520) ---
__int64 __fastcall sub_140445520(__int64 a1, const char *p_null_2, __int64 a3, const char *p_null_4, _QWORD *a5)
{
  const char *p_null; // r9
  unsigned __int64 v8; // r8
  const char *p_null_1; // r10
  unsigned __int64 v10; // rax
  const char *p_null_3; // rdx
  unsigned __int64 v12; // rax
  __int64 n4; // rax

  *(_QWORD *)a1 = p_null_2;
  *(_WORD *)(a1 + 0x58) = 0;
  p_null = "null";
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 3;
  p_null_1 = "null";
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  if ( p_null_2 )
    p_null_1 = p_null_2;
  *(_QWORD *)(a1 + 8) = "Unnamed_Text";
  *(_QWORD *)(a1 + 0x18) = sub_1403EB4B0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EAF60;
  *(_QWORD *)(a1 + 0x30) = sub_1403E75F0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( p_null_1[v10] );
  p_null_3 = "null";
  *(_QWORD *)(a1 + 0x68) = v10 + 2;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Unnamed_Int";
  if ( p_null_4 )
    p_null_3 = p_null_4;
  *(_WORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0x88) = sub_1403EAF40;
  *(_QWORD *)(a1 + 0x90) = sub_1403EAF40;
  *(_QWORD *)(a1 + 0xA0) = unknown_libname_19;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0xB8) = allocWithProfilerInfo_ww;
  v12 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 4;
  *(_QWORD *)(a1 + 0xD8) = 0x15;
  *(_QWORD *)(a1 + 0xE0) = p_null_4;
  *(_QWORD *)(a1 + 0xE8) = "Unnamed_Text";
  *(_WORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EB4B0;
  *(_QWORD *)(a1 + 0x100) = sub_1403EAF60;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = sub_1403E75F0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x128) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x140) = 0xC;
  do
    ++v12;
  while ( p_null_3[v12] );
  *(_QWORD *)(a1 + 0x148) = v12 + 2;
  *(_QWORD *)(a1 + 0x158) = "Function";
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_BYTE *)(a1 + 0x1A9) = 1;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x168) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x170) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x180) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x190) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x198) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0x18;
  if ( a5[1] )
    p_null = (const char *)a5[1];
  do
    ++v8;
  while ( p_null[v8] );
  n4 = 4;
  *(_QWORD *)(a1 + 0x1B8) = v8;
  return n4;
}

// --- End Function: sub_140445520 (0x140445520) ---

// --- Function: sub_1404457C0 (0x1404457C0) ---
__int64 __fastcall sub_1404457C0(
        __int64 a1,
        const char *p_null_1,
        __int64 a3,
        int a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  const char *p_null; // r8
  unsigned __int64 v13; // rax

  *(_QWORD *)a1 = p_null_1;
  *(_WORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 8) = "Unnamed_Text";
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB4B0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EAF60;
  p_null = "null";
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E75F0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  if ( p_null_1 )
    p_null = p_null_1;
  *(_QWORD *)(a1 + 0x60) = 3;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  v13 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v13;
  while ( p_null[v13] );
  *(_QWORD *)(a1 + 0x68) = v13 + 2;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Unnamed_Int";
  *(_QWORD *)(a1 + 0x88) = sub_1403EAF40;
  *(_QWORD *)(a1 + 0x90) = sub_1403EAF40;
  *(_QWORD *)(a1 + 0xA0) = unknown_libname_19;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0xB8) = allocWithProfilerInfo_ww;
  *(_WORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 4;
  *(_QWORD *)(a1 + 0xD8) = 0x15;
  return sub_1404488F0((int)a1 + 0xE0, a4, a5, a6, a7, a8, a9, a10) + 2;
}

// --- End Function: sub_1404457C0 (0x1404457C0) ---

// --- Function: sub_1404488F0 (0x1404488F0) ---
__int64 __fastcall sub_1404488F0(
        __int64 a1,
        const char **a2,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        __int64 a7,
        __int64 a8)
{
  const char *p_null_2; // rax
  const char *p_null; // r9
  unsigned __int64 v12; // r8
  const char *p_null_1; // rdx
  unsigned __int64 v14; // rax
  const char *p_null_3; // rdx
  unsigned __int64 v16; // rax
  const char *p_null_4; // rdx
  unsigned __int64 v18; // rax

  p_null_2 = *a2;
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = "Unnamed_Text";
  *(_WORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB4B0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EAF60;
  p_null = "null";
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E75F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  v12 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  *(_QWORD *)(a1 + 0x60) = 8;
  v14 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v14;
  while ( p_null_1[v14] );
  *(_QWORD *)(a1 + 0x68) = v14 + 2;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Name";
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  p_null_3 = "null";
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  if ( a3[1] )
    p_null_3 = (const char *)a3[1];
  v16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v16;
  while ( p_null_3[v16] );
  *(_QWORD *)(a1 + 0xD8) = v16;
  p_null_4 = "null";
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_QWORD *)(a1 + 0xE8) = "Name";
  *(_BYTE *)(a1 + 0x139) = 0;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x100) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x128) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x18;
  if ( a4[1] )
    p_null_4 = (const char *)a4[1];
  v18 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v18;
  while ( p_null_4[v18] );
  *(_QWORD *)(a1 + 0x148) = v18;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_QWORD *)(a1 + 0x158) = "EntityId";
  *(_BYTE *)(a1 + 0x1A9) = 1;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x168) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x170) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0x180) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x190) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0x198) = sub_1403E4C70;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0x18;
  *(_QWORD *)(a1 + 0x1B8) = 0x17;
  *(_QWORD *)(a1 + 0x1C0) = a6;
  *(_QWORD *)(a1 + 0x1C8) = "Name";
  *(_BYTE *)(a1 + 0x219) = 0;
  *(_QWORD *)(a1 + 0x1D0) = *a6;
  *(_QWORD *)(a1 + 0x1D8) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x1E0) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x200) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x208) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0x18;
  if ( a6[1] )
    p_null = (const char *)a6[1];
  do
    ++v12;
  while ( p_null[v12] );
  *(_QWORD *)(a1 + 0x228) = v12;
  return sub_14044AC50(a1 + 0x230, a7, a8) + 5;
}

// --- End Function: sub_1404488F0 (0x1404488F0) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1480BE950, v3);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n15; // rax

  v0 = sub_1404B3EA0();
  v1 = v0;
  if ( !v0 )
    return &dword_149B45F40;
  n15 = *v0;
  if ( n15 > 0xF )
    n15 = 15;
  return (__int64 *)&v1[22 * n15 + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_140539D30 (0x140539D30) ---
__int64 (__fastcall *__fastcall sub_140539D30(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_14039B170(0, "__InitializeThreadInfoBlock__", 0);
  if ( result )
    return (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}

// --- End Function: sub_140539D30 (0x140539D30) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_1415361F0 (0x1415361F0) ---
float __fastcall sub_1415361F0(__int64 a1)
{
  return *(float *)(a1 + 0x44);
}

// --- End Function: sub_1415361F0 (0x1415361F0) ---

// --- Function: sub_1415846D0 (0x1415846D0) ---
bool __fastcall sub_1415846D0(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 0x48) > a2;
}

// --- End Function: sub_1415846D0 (0x1415846D0) ---

// --- Function: sub_141E70C20 (0x141E70C20) ---
_QWORD *__fastcall sub_141E70C20(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x1E8);
  return a2;
}

// --- End Function: sub_141E70C20 (0x141E70C20) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || sub_140539D80() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: sub_142744750 (0x142744750) ---
__int64 __fastcall sub_142744750(unsigned __int8 a1)
{
  return (unsigned int)a1 + 0xC7;
}

// --- End Function: sub_142744750 (0x142744750) ---

// --- Function: _Mtx_getconcrtcs (0x14277C5B0) ---
void *__cdecl Mtx_getconcrtcs(_Mtx_t a1)
{
  return (char *)a1 + 8;
}

// --- End Function: _Mtx_getconcrtcs (0x14277C5B0) ---

// --- Function: unknown_libname_84 (0x142C361A0) ---
// Microsoft VisualC v14 64bit runtime
_BOOL8 __fastcall unknown_libname_84(_QWORD *a1)
{
  return *a1 != 0;
}

// --- End Function: unknown_libname_84 (0x142C361A0) ---

// --- Function: sub_143565E70 (0x143565E70) ---
__int64 __fastcall sub_143565E70(
        __int64 a1,
        __int64 a2,
        const char *p_null,
        __int64 a4,
        const char *p_null_1,
        _QWORD *a6)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1404B8D00();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = &sub_140504CA0;
  *(_QWORD *)(a1 + 0x20) = &sub_140504800;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = fabs_w_1;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 4;
  *(_QWORD *)(a1 + 0x68) = 0x1C;
  return sub_140445520(a1 + 0x70, p_null, a4, p_null_1, a6) + 1;
}

// --- End Function: sub_143565E70 (0x143565E70) ---

// --- Function: sub_143565F90 (0x143565F90) ---
__int64 __fastcall sub_143565F90(
        __int64 a1,
        __int64 a2,
        const char *p_null,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1404B8D00();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = &sub_140504CA0;
  *(_QWORD *)(a1 + 0x20) = &sub_140504800;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = fabs_w_1;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 4;
  *(_QWORD *)(a1 + 0x68) = 0x1C;
  return sub_1404457C0(a1 + 0x70, p_null, a4, a5, a6, a7, a8, a9, a10, a11) + 1;
}

// --- End Function: sub_143565F90 (0x143565F90) ---

// --- Function: sub_143566200 (0x143566200) ---
__int64 __fastcall sub_143566200(
        __int64 a1,
        __int64 a2,
        const char *p_null,
        __int64 a4,
        const char *p_null_1,
        _QWORD *a6)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_140445520(a1 + 0x70, p_null, a4, p_null_1, a6) + 1;
}

// --- End Function: sub_143566200 (0x143566200) ---

// --- Function: sub_143566320 (0x143566320) ---
__int64 __fastcall sub_143566320(
        __int64 a1,
        __int64 a2,
        const char *p_null,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_1404457C0(a1 + 0x70, p_null, a4, a5, a6, a7, a8, a9, a10, a11) + 1;
}

// --- End Function: sub_143566320 (0x143566320) ---

// --- Function: sub_143567220 (0x143567220) ---
__int64 __fastcall sub_143567220(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, __int64 a7)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14356CE30((int)a1 + 0x70, a3, a4, a5, a6, a7) + 1;
}

// --- End Function: sub_143567220 (0x143567220) ---

// --- Function: sub_143567340 (0x143567340) ---
__int64 __fastcall sub_143567340(
        __int64 a1,
        __int64 a2,
        int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14356D010((int)a1 + 0x70, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) + 1;
}

// --- End Function: sub_143567340 (0x143567340) ---

// --- Function: sub_1435674B0 (0x1435674B0) ---
__int64 __fastcall sub_1435674B0(
        __int64 a1,
        __int64 *ThreadLogContextSlot,
        int a3,
        int a4,
        const char *p_SV,
        __int64 a6,
        char *p_NULL_ENTITY,
        __int64 a8)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14356D240((int)a1 + 0x70, a3, a4, (_DWORD)p_SV, a6, (__int64)p_NULL_ENTITY, a8) + 1;
}

// --- End Function: sub_1435674B0 (0x1435674B0) ---

// --- Function: sub_1435675E0 (0x1435675E0) ---
__int64 __fastcall sub_1435675E0(
        __int64 a1,
        __int64 *ThreadLogContextSlot,
        int a3,
        int a4,
        const char *p_SV,
        __int64 a6,
        const char **p_p_NOT_INIT,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14356D430((int)a1 + 0x70, a3, a4, (_DWORD)p_SV, a6, (__int64)p_p_NOT_INIT, a8, a9, a10, a11, a12, a13) + 1;
}

// --- End Function: sub_1435675E0 (0x1435675E0) ---

// --- Function: sub_143568000 (0x143568000) ---
__int64 __fastcall sub_143568000(
        __int64 a1,
        __int64 *ThreadLogContextSlot,
        int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        const char *p_SV,
        __int64 a8,
        char *p_NULL_ENTITY,
        __int64 a10)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14356E1B0((int)a1 + 0x70, a3, a4, a5, a6, (__int64)p_SV, a8, (__int64)p_NULL_ENTITY, a10) + 1;
}

// --- End Function: sub_143568000 (0x143568000) ---

// --- Function: sub_143568770 (0x143568770) ---
__int64 __fastcall sub_143568770(
        __int64 a1,
        __int64 *ThreadLogContextSlot,
        int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        const char *p_SV,
        __int64 a8,
        char *p_NULL_ENTITY,
        __int64 a10)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14356EF00((int)a1 + 0x70, a3, a4, a5, a6, (__int64)p_SV, a8, (__int64)p_NULL_ENTITY, a10) + 1;
}

// --- End Function: sub_143568770 (0x143568770) ---

// --- Function: sub_1435688C0 (0x1435688C0) ---
__int64 __fastcall sub_1435688C0(
        __int64 a1,
        __int64 *ThreadLogContextSlot,
        int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        const char *p_SV,
        __int64 a8,
        const char **p_p_NOT_INIT,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_14356F110(
           (int)a1 + 0x70,
           a3,
           a4,
           a5,
           a6,
           (__int64)p_SV,
           a8,
           (__int64)p_p_NOT_INIT,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15)
       + 1;
}

// --- End Function: sub_1435688C0 (0x1435688C0) ---

// --- Function: sub_143569480 (0x143569480) ---
__int64 __fastcall sub_143569480(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        const char *p_null,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1404B8D00();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = &sub_140504CA0;
  *(_QWORD *)(a1 + 0x20) = &sub_140504800;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = fabs_w_1;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 4;
  *(_QWORD *)(a1 + 0x68) = 0x1C;
  return sub_143565F90(a1 + 0x70, a3, p_null, a5, a6, a7, a8, a9, a10, a11, a12) + 1;
}

// --- End Function: sub_143569480 (0x143569480) ---

// --- Function: sub_14356CE30 (0x14356CE30) ---
__int64 __fastcall sub_14356CE30(
        __int64 a1,
        _QWORD *a2,
        const char *p_null_1,
        __int64 a4,
        const char *p_null_2,
        _QWORD *a6)
{
  unsigned __int64 v7; // [rsp+30h] [rbp-48h]
  const char *p_null; // [rsp+40h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v7 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v7;
  while ( p_null[v7] );
  *(_QWORD *)(a1 + 0x68) = v7;
  return sub_140445520(a1 + 0x70, p_null_1, a4, p_null_2, a6) + 1;
}

// --- End Function: sub_14356CE30 (0x14356CE30) ---

// --- Function: sub_14356D010 (0x14356D010) ---
__int64 __fastcall sub_14356D010(
        __int64 a1,
        _QWORD *a2,
        const char *p_null_1,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11)
{
  unsigned __int64 v12; // [rsp+50h] [rbp-48h]
  const char *p_null; // [rsp+60h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v12 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v12;
  while ( p_null[v12] );
  *(_QWORD *)(a1 + 0x68) = v12;
  return sub_1404457C0(a1 + 0x70, p_null_1, a4, a5, a6, a7, a8, a9, a10, a11) + 1;
}

// --- End Function: sub_14356D010 (0x14356D010) ---

// --- Function: sub_14356D240 (0x14356D240) ---
__int64 __fastcall sub_14356D240(
        __int64 a1,
        _QWORD *a2,
        __int64 a3,
        const char *p_SV,
        __int64 a5,
        char *p_NULL_ENTITY,
        _QWORD *a7)
{
  unsigned __int64 v8; // [rsp+30h] [rbp-48h]
  const char *p_null; // [rsp+40h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v8;
  while ( p_null[v8] );
  *(_QWORD *)(a1 + 0x68) = v8;
  return sub_143565E70(a1 + 0x70, a3, p_SV, a5, p_NULL_ENTITY, a7) + 1;
}

// --- End Function: sub_14356D240 (0x14356D240) ---

// --- Function: sub_14356D430 (0x14356D430) ---
__int64 __fastcall sub_14356D430(
        __int64 a1,
        _QWORD *a2,
        __int64 a3,
        const char *p_SV,
        __int64 a5,
        const char **p_p_NOT_INIT,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  unsigned __int64 v13; // [rsp+60h] [rbp-48h]
  const char *p_null; // [rsp+70h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v13 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v13;
  while ( p_null[v13] );
  *(_QWORD *)(a1 + 0x68) = v13;
  return sub_143565F90(a1 + 0x70, a3, p_SV, a5, (__int64)p_p_NOT_INIT, a7, a8, a9, a10, a11, a12) + 1;
}

// --- End Function: sub_14356D430 (0x14356D430) ---

// --- Function: sub_14356D680 (0x14356D680) ---
__int64 __fastcall sub_14356D680(
        __int64 a1,
        _QWORD *a2,
        int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned __int64 v9; // [rsp+40h] [rbp-48h]
  const char *p_null; // [rsp+50h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v9 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v9;
  while ( p_null[v9] );
  *(_QWORD *)(a1 + 0x68) = v9;
  return sub_143569360((int)a1 + 0x70, a3, a4, a5, a6, a7, a8) + 1;
}

// --- End Function: sub_14356D680 (0x14356D680) ---

// --- Function: sub_14356D880 (0x14356D880) ---
__int64 __fastcall sub_14356D880(
        __int64 a1,
        _QWORD *a2,
        __int64 a3,
        __int64 a4,
        const char *p_null_1,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  unsigned __int64 v14; // [rsp+60h] [rbp-48h]
  const char *p_null; // [rsp+70h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v14 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v14;
  while ( p_null[v14] );
  *(_QWORD *)(a1 + 0x68) = v14;
  return sub_143569480(a1 + 0x70, a3, a4, p_null_1, a6, a7, a8, a9, a10, a11, a12, a13) + 1;
}

// --- End Function: sub_14356D880 (0x14356D880) ---

// --- Function: sub_14356E1B0 (0x14356E1B0) ---
__int64 __fastcall sub_14356E1B0(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        int a4,
        __int64 a5,
        const char *p_SV,
        __int64 a7,
        char *p_NULL_ENTITY,
        __int64 a9)
{
  unsigned __int64 v10; // [rsp+40h] [rbp-48h]
  const char *p_null; // [rsp+50h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( p_null[v10] );
  *(_QWORD *)(a1 + 0x68) = v10;
  return sub_14356D680(a1 + 0x70, a3, a4, a5, (__int64)p_SV, a7, (__int64)p_NULL_ENTITY, a9) + 1;
}

// --- End Function: sub_14356E1B0 (0x14356E1B0) ---

// --- Function: sub_14356E3C0 (0x14356E3C0) ---
__int64 __fastcall sub_14356E3C0(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        __int64 a4,
        __int64 a5,
        const char *p_SV,
        __int64 a7,
        const char **p_p_NOT_INIT,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14)
{
  unsigned __int64 v15; // [rsp+70h] [rbp-48h]
  const char *p_null; // [rsp+80h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v15 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v15;
  while ( p_null[v15] );
  *(_QWORD *)(a1 + 0x68) = v15;
  return sub_14356D880(a1 + 0x70, a3, a4, a5, p_SV, a7, (__int64)p_p_NOT_INIT, a9, a10, a11, a12, a13, a14) + 1;
}

// --- End Function: sub_14356E3C0 (0x14356E3C0) ---

// --- Function: sub_14356EF00 (0x14356EF00) ---
__int64 __fastcall sub_14356EF00(
        __int64 a1,
        _QWORD *a2,
        int a3,
        int a4,
        __int64 a5,
        const char *p_SV,
        __int64 a7,
        char *p_NULL_ENTITY,
        __int64 a9)
{
  unsigned __int64 v10; // [rsp+40h] [rbp-48h]
  const char *p_null; // [rsp+50h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v10 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v10;
  while ( p_null[v10] );
  *(_QWORD *)(a1 + 0x68) = v10;
  return sub_143570350((int)a1 + 0x70, a3, a4, a5, (__int64)p_SV, a7, (__int64)p_NULL_ENTITY, a9) + 1;
}

// --- End Function: sub_14356EF00 (0x14356EF00) ---

// --- Function: sub_14356F110 (0x14356F110) ---
__int64 __fastcall sub_14356F110(
        __int64 a1,
        _QWORD *a2,
        int a3,
        int a4,
        __int64 a5,
        const char *p_SV,
        __int64 a7,
        const char **p_p_NOT_INIT,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14)
{
  unsigned __int64 v15; // [rsp+70h] [rbp-48h]
  const char *p_null; // [rsp+80h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v15 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v15;
  while ( p_null[v15] );
  *(_QWORD *)(a1 + 0x68) = v15;
  return sub_143570550(
           (int)a1 + 0x70,
           a3,
           a4,
           a5,
           (__int64)p_SV,
           a7,
           (__int64)p_p_NOT_INIT,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14)
       + 1;
}

// --- End Function: sub_14356F110 (0x14356F110) ---

// --- Function: sub_143570350 (0x143570350) ---
__int64 __fastcall sub_143570350(
        __int64 a1,
        _QWORD *a2,
        int a3,
        int a4,
        const char *p_SV,
        __int64 a6,
        char *p_NULL_ENTITY,
        __int64 a8)
{
  unsigned __int64 v9; // [rsp+40h] [rbp-48h]
  const char *p_null; // [rsp+50h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v9 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v9;
  while ( p_null[v9] );
  *(_QWORD *)(a1 + 0x68) = v9;
  return sub_143571D20((int)a1 + 0x70, a3, a4, (_DWORD)p_SV, a6, (__int64)p_NULL_ENTITY, a8) + 1;
}

// --- End Function: sub_143570350 (0x143570350) ---

// --- Function: sub_143570550 (0x143570550) ---
__int64 __fastcall sub_143570550(
        __int64 a1,
        _QWORD *a2,
        int a3,
        int a4,
        const char *p_SV,
        __int64 a6,
        const char **p_p_NOT_INIT,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  unsigned __int64 v14; // [rsp+60h] [rbp-48h]
  const char *p_null; // [rsp+70h] [rbp-38h]

  *(_QWORD *)a1 = sub_1402A24F0((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3E40();
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v14 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v14;
  while ( p_null[v14] );
  *(_QWORD *)(a1 + 0x68) = v14;
  return sub_143571E40((int)a1 + 0x70, a3, a4, (_DWORD)p_SV, a6, (__int64)p_p_NOT_INIT, a8, a9, a10, a11, a12, a13) + 1;
}

// --- End Function: sub_143570550 (0x143570550) ---

// --- Function: sub_1435B1900 (0x1435B1900) ---
char __fastcall sub_1435B1900(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rax
  unsigned __int64 *v4; // rax
  _QWORD *v5; // rax
  void *v6; // rsp
  void *v7; // rsp
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  unsigned __int64 *v12; // rax
  _QWORD *v13; // rax
  void *v14; // rsp
  void *v15; // rsp
  _QWORD *v16; // rax
  _QWORD *v17; // rax
  _QWORD *v18; // rax
  unsigned __int64 *v19; // rax
  _QWORD *v20; // rax
  void *v21; // rsp
  void *v22; // rsp
  _QWORD *v23; // rax
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  unsigned __int64 *v26; // rax
  _QWORD *v27; // rax
  void *v28; // rsp
  void *v29; // rsp
  _QWORD *v30; // rax
  _QWORD *v31; // rax
  _QWORD *v32; // rax
  _QWORD *v33; // rax
  unsigned __int64 *v34; // rax
  _QWORD *v35; // rax
  void *v36; // rsp
  void *v37; // rsp
  _QWORD *v38; // rax
  _QWORD *v39; // rax
  _QWORD *v40; // rax
  unsigned __int64 *v41; // rax
  _QWORD *v42; // rax
  void *v43; // rsp
  void *v44; // rsp
  __int64 v45; // rax
  _QWORD *v46; // rax
  _QWORD *v47; // rax
  _QWORD *v48; // rax
  unsigned __int64 *v49; // rax
  _QWORD *v50; // rax
  void *v51; // rsp
  void *v52; // rsp
  _QWORD *v53; // rax
  _QWORD *v54; // rax
  _QWORD *v55; // rax
  unsigned __int64 *v56; // rax
  _QWORD *v57; // rax
  void *v58; // rsp
  void *v59; // rsp
  __int64 v60; // [rsp+18h] [rbp-668h]
  __int64 v61; // [rsp+18h] [rbp-668h]
  _QWORD v62[16]; // [rsp+60h] [rbp-620h] BYREF
  __int64 v63; // [rsp+F8h] [rbp-588h]
  _BYTE v64[16]; // [rsp+140h] [rbp-540h] BYREF
  __int64 v65; // [rsp+168h] [rbp-518h]
  _BYTE v66[16]; // [rsp+1B0h] [rbp-4D0h] BYREF
  __int64 v67; // [rsp+1D8h] [rbp-4A8h]
  _BYTE v68[16]; // [rsp+220h] [rbp-460h] BYREF
  __int64 v69; // [rsp+248h] [rbp-438h]
  _BYTE v70[128]; // [rsp+290h] [rbp-3F0h] BYREF
  __int64 v71; // [rsp+328h] [rbp-358h]
  _BYTE v72[16]; // [rsp+370h] [rbp-310h] BYREF
  __int64 v73; // [rsp+398h] [rbp-2E8h]
  _BYTE v74[16]; // [rsp+3E0h] [rbp-2A0h] BYREF
  __int64 v75; // [rsp+408h] [rbp-278h]
  _BYTE v76[432]; // [rsp+450h] [rbp-230h] BYREF
  const char *v77; // [rsp+620h] [rbp-60h]
  const char *v78; // [rsp+628h] [rbp-58h]
  const char *v79; // [rsp+630h] [rbp-50h]
  const char *v80; // [rsp+638h] [rbp-48h]
  const char *v81; // [rsp+640h] [rbp-40h]
  int v82; // [rsp+680h] [rbp+0h]
  vraudio::AudioBuffer *__Val_0___4; // [rsp+688h] [rbp+8h]
  int v100; // [rsp+6A0h] [rbp+20h]
  int v101; // [rsp+6A4h] [rbp+24h]
  int v102; // [rsp+6A8h] [rbp+28h]
  int v103; // [rsp+6ACh] [rbp+2Ch]
  int v104; // [rsp+6B0h] [rbp+30h]
  int v105; // [rsp+6B4h] [rbp+34h]
  int v106; // [rsp+6B8h] [rbp+38h]
  int v107; // [rsp+6BCh] [rbp+3Ch]
  int v108; // [rsp+6C0h] [rbp+40h]
  int v109; // [rsp+6C4h] [rbp+44h]
  int v110; // [rsp+6C8h] [rbp+48h]
  int v111; // [rsp+6CCh] [rbp+4Ch]
  int v112; // [rsp+6D0h] [rbp+50h]
  int v113; // [rsp+6D4h] [rbp+54h]
  int v114; // [rsp+6D8h] [rbp+58h]
  int v115; // [rsp+6DCh] [rbp+5Ch]
  int v116; // [rsp+6E0h] [rbp+60h] BYREF
  int v117; // [rsp+6E4h] [rbp+64h] BYREF
  int v118; // [rsp+6E8h] [rbp+68h] BYREF
  int v119; // [rsp+6ECh] [rbp+6Ch] BYREF
  int v120; // [rsp+6F0h] [rbp+70h] BYREF
  int v121; // [rsp+6F4h] [rbp+74h] BYREF
  int v122; // [rsp+6F8h] [rbp+78h] BYREF
  int v123; // [rsp+6FCh] [rbp+7Ch] BYREF
  int v124; // [rsp+700h] [rbp+80h] BYREF
  int v125; // [rsp+704h] [rbp+84h] BYREF
  int v126; // [rsp+708h] [rbp+88h] BYREF
  int v127; // [rsp+70Ch] [rbp+8Ch] BYREF
  int v128; // [rsp+710h] [rbp+90h] BYREF
  float v129; // [rsp+714h] [rbp+94h]
  int v130; // [rsp+718h] [rbp+98h] BYREF
  float v131; // [rsp+71Ch] [rbp+9Ch] BYREF
  float v132; // [rsp+720h] [rbp+A0h] BYREF
  int v133; // [rsp+724h] [rbp+A4h] BYREF
  float v134; // [rsp+728h] [rbp+A8h] BYREF
  float v135; // [rsp+72Ch] [rbp+ACh] BYREF
  int v136; // [rsp+730h] [rbp+B0h] BYREF
  _DWORD v137[2]; // [rsp+738h] [rbp+B8h] BYREF
  char v138; // [rsp+740h] [rbp+C0h] BYREF
  _DWORD v139[2]; // [rsp+748h] [rbp+C8h] BYREF
  char v140; // [rsp+750h] [rbp+D0h] BYREF
  _DWORD v141[2]; // [rsp+758h] [rbp+D8h] BYREF
  char v142; // [rsp+760h] [rbp+E0h] BYREF
  _DWORD v143[2]; // [rsp+768h] [rbp+E8h] BYREF
  char v144; // [rsp+770h] [rbp+F0h] BYREF
  _DWORD v145[2]; // [rsp+778h] [rbp+F8h] BYREF
  char v146; // [rsp+780h] [rbp+100h] BYREF
  _DWORD v147[2]; // [rsp+788h] [rbp+108h] BYREF
  char v148; // [rsp+790h] [rbp+110h] BYREF
  _DWORD v149[2]; // [rsp+798h] [rbp+118h] BYREF
  char v150; // [rsp+7A0h] [rbp+120h] BYREF
  _DWORD v151[2]; // [rsp+7A8h] [rbp+128h] BYREF
  char v152; // [rsp+7B0h] [rbp+130h] BYREF
  _DWORD v153[2]; // [rsp+7B8h] [rbp+138h] BYREF
  char v154; // [rsp+7C0h] [rbp+140h] BYREF
  _DWORD v155[2]; // [rsp+7C8h] [rbp+148h] BYREF
  char v156; // [rsp+7D0h] [rbp+150h] BYREF
  _DWORD v157[2]; // [rsp+7D8h] [rbp+158h] BYREF
  char v158; // [rsp+7E0h] [rbp+160h] BYREF
  _DWORD v159[2]; // [rsp+7E8h] [rbp+168h] BYREF
  char v160; // [rsp+7F0h] [rbp+170h] BYREF
  _DWORD v161[2]; // [rsp+7F8h] [rbp+178h] BYREF
  char v162; // [rsp+800h] [rbp+180h] BYREF
  _DWORD v163[2]; // [rsp+808h] [rbp+188h] BYREF
  char v164; // [rsp+810h] [rbp+190h] BYREF
  _DWORD v165[2]; // [rsp+818h] [rbp+198h] BYREF
  char v166; // [rsp+820h] [rbp+1A0h] BYREF
  _DWORD v167[2]; // [rsp+828h] [rbp+1A8h] BYREF
  char v168; // [rsp+830h] [rbp+1B0h] BYREF
  _DWORD v169[2]; // [rsp+838h] [rbp+1B8h] BYREF
  char v170; // [rsp+840h] [rbp+1C0h] BYREF
  _DWORD v171[2]; // [rsp+848h] [rbp+1C8h] BYREF
  char v172; // [rsp+850h] [rbp+1D0h] BYREF
  _DWORD v173[2]; // [rsp+858h] [rbp+1D8h] BYREF
  char v174; // [rsp+860h] [rbp+1E0h] BYREF
  _DWORD v175[2]; // [rsp+868h] [rbp+1E8h] BYREF
  char v176; // [rsp+870h] [rbp+1F0h] BYREF
  _DWORD v177[2]; // [rsp+878h] [rbp+1F8h] BYREF
  char v178; // [rsp+880h] [rbp+200h] BYREF
  _DWORD v179[2]; // [rsp+888h] [rbp+208h] BYREF
  char v180; // [rsp+890h] [rbp+210h] BYREF
  _DWORD v181[2]; // [rsp+898h] [rbp+218h] BYREF
  char v182; // [rsp+8A0h] [rbp+220h] BYREF
  _DWORD v183[2]; // [rsp+8A8h] [rbp+228h] BYREF
  char v184; // [rsp+8B0h] [rbp+230h] BYREF
  _DWORD v185[2]; // [rsp+8B8h] [rbp+238h] BYREF
  char v186; // [rsp+8C0h] [rbp+240h] BYREF
  _DWORD v187[2]; // [rsp+8C8h] [rbp+248h] BYREF
  char v188; // [rsp+8D0h] [rbp+250h] BYREF
  _DWORD v189[2]; // [rsp+8D8h] [rbp+258h] BYREF
  char v190; // [rsp+8E0h] [rbp+260h] BYREF
  _DWORD v191[2]; // [rsp+8E8h] [rbp+268h] BYREF
  char v192; // [rsp+8F0h] [rbp+270h] BYREF
  _DWORD v193[2]; // [rsp+8F8h] [rbp+278h] BYREF
  char v194; // [rsp+900h] [rbp+280h] BYREF
  _DWORD v195[2]; // [rsp+908h] [rbp+288h] BYREF
  char v196; // [rsp+910h] [rbp+290h] BYREF
  _DWORD v197[2]; // [rsp+918h] [rbp+298h] BYREF
  char v198; // [rsp+920h] [rbp+2A0h] BYREF
  _DWORD v199[2]; // [rsp+928h] [rbp+2A8h] BYREF
  char v200; // [rsp+930h] [rbp+2B0h] BYREF
  __int64 v201; // [rsp+938h] [rbp+2B8h]
  __int64 v202; // [rsp+940h] [rbp+2C0h]
  __int64 v203; // [rsp+948h] [rbp+2C8h]
  const char *p_NULL_ZONE_6; // [rsp+950h] [rbp+2D0h]
  __int64 v205; // [rsp+958h] [rbp+2D8h]
  __int64 v206; // [rsp+960h] [rbp+2E0h]
  __int64 v207; // [rsp+968h] [rbp+2E8h]
  __int64 v208; // [rsp+970h] [rbp+2F0h]
  __int64 v209; // [rsp+978h] [rbp+2F8h]
  __int64 v210; // [rsp+980h] [rbp+300h]
  __int64 v211; // [rsp+988h] [rbp+308h]
  __int64 v212; // [rsp+990h] [rbp+310h]
  __int64 v213; // [rsp+998h] [rbp+318h]
  __int64 v214; // [rsp+9A0h] [rbp+320h]
  __int64 v215; // [rsp+9A8h] [rbp+328h]
  const char *p_NULL_SYSTEM_6; // [rsp+9B0h] [rbp+330h]
  __int64 v217; // [rsp+9B8h] [rbp+338h]
  __int64 v218; // [rsp+9C0h] [rbp+340h]
  const char *p_NOT_AUTH_6; // [rsp+9C8h] [rbp+348h]
  const char *p_NOT_INIT_12; // [rsp+9D0h] [rbp+350h]
  __int64 v221; // [rsp+9D8h] [rbp+358h]
  _BYTE *v222; // [rsp+9E0h] [rbp+360h]
  const char *p_SV_12; // [rsp+9E8h] [rbp+368h]
  vraudio::AudioBuffer *__Val_0___12; // [rsp+9F0h] [rbp+370h]
  __int64 v225; // [rsp+9F8h] [rbp+378h]
  _BYTE *v226; // [rsp+A00h] [rbp+380h]
  const char *p_SV_13; // [rsp+A08h] [rbp+388h]
  vraudio::AudioBuffer *__Val_0___13; // [rsp+A10h] [rbp+390h]
  __int64 v229; // [rsp+A18h] [rbp+398h]
  __int64 v230; // [rsp+A20h] [rbp+3A0h]
  __int64 v231; // [rsp+A28h] [rbp+3A8h]
  __int64 v232; // [rsp+A30h] [rbp+3B0h]
  __int64 v233; // [rsp+A38h] [rbp+3B8h]
  const char *p_NULL_ZONE_5; // [rsp+A40h] [rbp+3C0h]
  __int64 v235; // [rsp+A48h] [rbp+3C8h]
  __int64 v236; // [rsp+A50h] [rbp+3D0h]
  __int64 v237; // [rsp+A58h] [rbp+3D8h]
  __int64 v238; // [rsp+A60h] [rbp+3E0h]
  __int64 v239; // [rsp+A68h] [rbp+3E8h]
  __int64 v240; // [rsp+A70h] [rbp+3F0h]
  __int64 v241; // [rsp+A78h] [rbp+3F8h]
  __int64 v242; // [rsp+A80h] [rbp+400h]
  __int64 v243; // [rsp+A88h] [rbp+408h]
  __int64 v244; // [rsp+A90h] [rbp+410h]
  __int64 v245; // [rsp+A98h] [rbp+418h]
  const char *p_NULL_SYSTEM_5; // [rsp+AA0h] [rbp+420h]
  __int64 v247; // [rsp+AA8h] [rbp+428h]
  __int64 v248; // [rsp+AB0h] [rbp+430h]
  const char *p_NOT_AUTH_5; // [rsp+AB8h] [rbp+438h]
  const char *p_NOT_INIT_10; // [rsp+AC0h] [rbp+440h]
  __int64 v251; // [rsp+AC8h] [rbp+448h]
  __int64 v252; // [rsp+AD0h] [rbp+450h]
  _QWORD *v253; // [rsp+AD8h] [rbp+458h]
  _BYTE *v254; // [rsp+AE0h] [rbp+460h]
  const char *p_SV_10; // [rsp+AE8h] [rbp+468h]
  vraudio::AudioBuffer *__Val_0___10; // [rsp+AF0h] [rbp+470h]
  __int64 v257; // [rsp+AF8h] [rbp+478h]
  __int64 v258; // [rsp+B00h] [rbp+480h]
  _QWORD *v259; // [rsp+B08h] [rbp+488h]
  _BYTE *v260; // [rsp+B10h] [rbp+490h]
  const char *p_SV_11; // [rsp+B18h] [rbp+498h]
  vraudio::AudioBuffer *__Val_0___11; // [rsp+B20h] [rbp+4A0h]
  __int64 v263; // [rsp+B28h] [rbp+4A8h]
  __int64 v264; // [rsp+B30h] [rbp+4B0h]
  __int64 v265; // [rsp+B38h] [rbp+4B8h]
  __int64 v266; // [rsp+B40h] [rbp+4C0h]
  __int64 v267; // [rsp+B48h] [rbp+4C8h]
  const char *p_NULL_ZONE; // [rsp+B50h] [rbp+4D0h]
  __int64 v269; // [rsp+B58h] [rbp+4D8h]
  __int64 v270; // [rsp+B60h] [rbp+4E0h]
  __int64 v271; // [rsp+B68h] [rbp+4E8h]
  __int64 v272; // [rsp+B70h] [rbp+4F0h]
  __int64 v273; // [rsp+B78h] [rbp+4F8h]
  __int64 v274; // [rsp+B80h] [rbp+500h]
  __int64 v275; // [rsp+B88h] [rbp+508h]
  __int64 v276; // [rsp+B90h] [rbp+510h]
  __int64 v277; // [rsp+B98h] [rbp+518h]
  __int64 v278; // [rsp+BA0h] [rbp+520h]
  __int64 v279; // [rsp+BA8h] [rbp+528h]
  const char *p_NULL_SYSTEM; // [rsp+BB0h] [rbp+530h]
  __int64 v281; // [rsp+BB8h] [rbp+538h]
  __int64 v282; // [rsp+BC0h] [rbp+540h]
  const char *p_NOT_AUTH; // [rsp+BC8h] [rbp+548h]
  const char *p_NOT_INIT; // [rsp+BD0h] [rbp+550h]
  __int64 v285; // [rsp+BD8h] [rbp+558h]
  __int64 v286; // [rsp+BE0h] [rbp+560h]
  _BYTE *v287; // [rsp+BE8h] [rbp+568h]
  const char *p_SV; // [rsp+BF0h] [rbp+570h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+BF8h] [rbp+578h]
  __int64 v290; // [rsp+C00h] [rbp+580h]
  __int64 v291; // [rsp+C08h] [rbp+588h]
  _BYTE *v292; // [rsp+C10h] [rbp+590h]
  const char *p_SV_1; // [rsp+C18h] [rbp+598h]
  vraudio::AudioBuffer *__Val_0___1; // [rsp+C20h] [rbp+5A0h]
  __int64 v295; // [rsp+C28h] [rbp+5A8h]
  __int64 v296; // [rsp+C30h] [rbp+5B0h]
  __int64 v297; // [rsp+C38h] [rbp+5B8h]
  __int64 v298; // [rsp+C40h] [rbp+5C0h]
  __int64 v299; // [rsp+C48h] [rbp+5C8h]
  const char *p_NULL_ZONE_4; // [rsp+C50h] [rbp+5D0h]
  __int64 v301; // [rsp+C58h] [rbp+5D8h]
  __int64 v302; // [rsp+C60h] [rbp+5E0h]
  __int64 v303; // [rsp+C68h] [rbp+5E8h]
  __int64 v304; // [rsp+C70h] [rbp+5F0h]
  __int64 v305; // [rsp+C78h] [rbp+5F8h]
  __int64 v306; // [rsp+C80h] [rbp+600h]
  __int64 v307; // [rsp+C88h] [rbp+608h]
  __int64 v308; // [rsp+C90h] [rbp+610h]
  __int64 v309; // [rsp+C98h] [rbp+618h]
  __int64 v310; // [rsp+CA0h] [rbp+620h]
  __int64 v311; // [rsp+CA8h] [rbp+628h]
  const char *p_NULL_SYSTEM_4; // [rsp+CB0h] [rbp+630h]
  __int64 v313; // [rsp+CB8h] [rbp+638h]
  __int64 v314; // [rsp+CC0h] [rbp+640h]
  const char *p_NOT_AUTH_4; // [rsp+CC8h] [rbp+648h]
  const char *p_NOT_INIT_8; // [rsp+CD0h] [rbp+650h]
  __int64 v317; // [rsp+CD8h] [rbp+658h]
  __int64 v318; // [rsp+CE0h] [rbp+660h]
  _BYTE *v319; // [rsp+CE8h] [rbp+668h]
  const char *p_SV_8; // [rsp+CF0h] [rbp+670h]
  vraudio::AudioBuffer *__Val_0___8; // [rsp+CF8h] [rbp+678h]
  __int64 v322; // [rsp+D00h] [rbp+680h]
  __int64 v323; // [rsp+D08h] [rbp+688h]
  _BYTE *v324; // [rsp+D10h] [rbp+690h]
  const char *p_SV_9; // [rsp+D18h] [rbp+698h]
  vraudio::AudioBuffer *__Val_0___9; // [rsp+D20h] [rbp+6A0h]
  __int64 v327; // [rsp+D28h] [rbp+6A8h]
  __int64 v328; // [rsp+D30h] [rbp+6B0h]
  __int64 v329; // [rsp+D38h] [rbp+6B8h]
  __int64 v330; // [rsp+D40h] [rbp+6C0h]
  __int64 v331; // [rsp+D48h] [rbp+6C8h]
  const char *p_NULL_ZONE_3; // [rsp+D50h] [rbp+6D0h]
  __int64 v333; // [rsp+D58h] [rbp+6D8h]
  __int64 v334; // [rsp+D60h] [rbp+6E0h]
  __int64 v335; // [rsp+D68h] [rbp+6E8h]
  __int64 v336; // [rsp+D70h] [rbp+6F0h]
  __int64 v337; // [rsp+D78h] [rbp+6F8h]
  __int64 v338; // [rsp+D80h] [rbp+700h]
  __int64 v339; // [rsp+D88h] [rbp+708h]
  __int64 v340; // [rsp+D90h] [rbp+710h]
  __int64 v341; // [rsp+D98h] [rbp+718h]
  __int64 v342; // [rsp+DA0h] [rbp+720h]
  __int64 v343; // [rsp+DA8h] [rbp+728h]
  const char *p_NULL_SYSTEM_3; // [rsp+DB0h] [rbp+730h]
  __int64 v345; // [rsp+DB8h] [rbp+738h]
  __int64 v346; // [rsp+DC0h] [rbp+740h]
  const char *p_NOT_AUTH_3; // [rsp+DC8h] [rbp+748h]
  const char *p_NOT_INIT_6; // [rsp+DD0h] [rbp+750h]
  __int64 v349; // [rsp+DD8h] [rbp+758h]
  __int64 v350; // [rsp+DE0h] [rbp+760h]
  _BYTE *v351; // [rsp+DE8h] [rbp+768h]
  const char *p_SV_6; // [rsp+DF0h] [rbp+770h]
  vraudio::AudioBuffer *__Val_0___6; // [rsp+DF8h] [rbp+778h]
  __int64 v354; // [rsp+E00h] [rbp+780h]
  __int64 v355; // [rsp+E08h] [rbp+788h]
  _BYTE *v356; // [rsp+E10h] [rbp+790h]
  const char *p_SV_7; // [rsp+E18h] [rbp+798h]
  vraudio::AudioBuffer *__Val_0___7; // [rsp+E20h] [rbp+7A0h]
  __int64 v359; // [rsp+E28h] [rbp+7A8h]
  __int64 v360; // [rsp+E30h] [rbp+7B0h]
  __int64 v361; // [rsp+E38h] [rbp+7B8h]
  __int64 v362; // [rsp+E40h] [rbp+7C0h]
  __int64 v363; // [rsp+E48h] [rbp+7C8h]
  const char *p_NULL_ZONE_1; // [rsp+E50h] [rbp+7D0h]
  __int64 v365; // [rsp+E58h] [rbp+7D8h]
  __int64 v366; // [rsp+E60h] [rbp+7E0h]
  __int64 v367; // [rsp+E68h] [rbp+7E8h]
  __int64 v368; // [rsp+E70h] [rbp+7F0h]
  __int64 v369; // [rsp+E78h] [rbp+7F8h]
  __int64 v370; // [rsp+E80h] [rbp+800h]
  __int64 v371; // [rsp+E88h] [rbp+808h]
  __int64 v372; // [rsp+E90h] [rbp+810h]
  __int64 v373; // [rsp+E98h] [rbp+818h]
  __int64 v374; // [rsp+EA0h] [rbp+820h]
  __int64 v375; // [rsp+EA8h] [rbp+828h]
  const char *p_NULL_SYSTEM_1; // [rsp+EB0h] [rbp+830h]
  __int64 v377; // [rsp+EB8h] [rbp+838h]
  __int64 v378; // [rsp+EC0h] [rbp+840h]
  const char *p_NOT_AUTH_1; // [rsp+EC8h] [rbp+848h]
  const char *p_NOT_INIT_2; // [rsp+ED0h] [rbp+850h]
  __int64 v381; // [rsp+ED8h] [rbp+858h]
  __int64 v382; // [rsp+EE0h] [rbp+860h]
  __int64 v383; // [rsp+EE8h] [rbp+868h]
  _QWORD *v384; // [rsp+EF0h] [rbp+870h]
  const char *p_SV_2; // [rsp+EF8h] [rbp+878h]
  vraudio::AudioBuffer *__Val_0___2; // [rsp+F00h] [rbp+880h]
  __int64 v387; // [rsp+F08h] [rbp+888h]
  __int64 v388; // [rsp+F10h] [rbp+890h]
  __int64 v389; // [rsp+F18h] [rbp+898h]
  _BYTE *v390; // [rsp+F20h] [rbp+8A0h]
  const char *p_SV_3; // [rsp+F28h] [rbp+8A8h]
  vraudio::AudioBuffer *__Val_0___3; // [rsp+F30h] [rbp+8B0h]
  __int64 v393; // [rsp+F38h] [rbp+8B8h]
  __int64 v394; // [rsp+F40h] [rbp+8C0h]
  __int64 v395; // [rsp+F48h] [rbp+8C8h]
  __int64 v396; // [rsp+F50h] [rbp+8D0h]
  __int64 v397; // [rsp+F58h] [rbp+8D8h]
  __int64 v398; // [rsp+F60h] [rbp+8E0h]
  const char *p_NULL_ZONE_2; // [rsp+F68h] [rbp+8E8h]
  __int64 v400; // [rsp+F70h] [rbp+8F0h]
  __int64 v401; // [rsp+F78h] [rbp+8F8h]
  __int64 v402; // [rsp+F80h] [rbp+900h]
  __int64 v403; // [rsp+F88h] [rbp+908h]
  __int64 v404; // [rsp+F90h] [rbp+910h]
  __int64 v405; // [rsp+F98h] [rbp+918h]
  __int64 v406; // [rsp+FA0h] [rbp+920h]
  __int64 v407; // [rsp+FA8h] [rbp+928h]
  __int64 v408; // [rsp+FB0h] [rbp+930h]
  __int64 v409; // [rsp+FB8h] [rbp+938h]
  __int64 v410; // [rsp+FC0h] [rbp+940h]
  const char *p_NULL_SYSTEM_2; // [rsp+FC8h] [rbp+948h]
  __int64 v412; // [rsp+FD0h] [rbp+950h]
  __int64 v413; // [rsp+FD8h] [rbp+958h]
  const char *p_NOT_AUTH_2; // [rsp+FE0h] [rbp+960h]
  const char *p_NOT_INIT_4; // [rsp+FE8h] [rbp+968h]
  __int64 v416; // [rsp+FF0h] [rbp+970h]
  __int64 v417; // [rsp+FF8h] [rbp+978h]
  __int64 v418; // [rsp+1000h] [rbp+980h]
  __int64 v419; // [rsp+1008h] [rbp+988h]
  _QWORD *v420; // [rsp+1010h] [rbp+990h]
  const char *p_SV_4; // [rsp+1018h] [rbp+998h]
  __int64 v422; // [rsp+1020h] [rbp+9A0h]
  __int64 v423; // [rsp+1028h] [rbp+9A8h]
  __int64 v424; // [rsp+1030h] [rbp+9B0h]
  __int64 v425; // [rsp+1038h] [rbp+9B8h]
  _BYTE *v426; // [rsp+1040h] [rbp+9C0h]
  const char *p_SV_5; // [rsp+1048h] [rbp+9C8h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+1050h] [rbp+9D0h]
  __int64 v429; // [rsp+1058h] [rbp+9D8h]
  __int64 v430; // [rsp+1060h] [rbp+9E0h]
  __int64 v431; // [rsp+1068h] [rbp+9E8h]
  __int64 v432; // [rsp+1070h] [rbp+9F0h]
  const char *p_NULL_ZONE_7; // [rsp+1078h] [rbp+9F8h]
  __int64 v434; // [rsp+1080h] [rbp+A00h]
  __int64 v435; // [rsp+1088h] [rbp+A08h]
  __int64 v436; // [rsp+1090h] [rbp+A10h]
  __int64 v437; // [rsp+1098h] [rbp+A18h]
  __int64 v438; // [rsp+10A0h] [rbp+A20h]
  __int64 v439; // [rsp+10A8h] [rbp+A28h]
  __int64 v440; // [rsp+10B0h] [rbp+A30h]
  __int64 v441; // [rsp+10B8h] [rbp+A38h]
  __int64 v442; // [rsp+10C0h] [rbp+A40h]
  __int64 v443; // [rsp+10C8h] [rbp+A48h]
  __int64 v444; // [rsp+10D0h] [rbp+A50h]
  const char *p_NULL_SYSTEM_7; // [rsp+10D8h] [rbp+A58h]
  __int64 v446; // [rsp+10E0h] [rbp+A60h]
  __int64 v447; // [rsp+10E8h] [rbp+A68h]
  const char *p_NOT_AUTH_7; // [rsp+10F0h] [rbp+A70h]
  const char *p_NOT_INIT_14; // [rsp+10F8h] [rbp+A78h]
  __int64 v450; // [rsp+1100h] [rbp+A80h]
  _BYTE *v451; // [rsp+1108h] [rbp+A88h]
  const char *p_SV_14; // [rsp+1110h] [rbp+A90h]
  vraudio::AudioBuffer *__Val_0___14; // [rsp+1118h] [rbp+A98h]
  __int64 v454; // [rsp+1120h] [rbp+AA0h]
  _BYTE *v455; // [rsp+1128h] [rbp+AA8h]
  const char *p_SV_15; // [rsp+1130h] [rbp+AB0h]
  vraudio::AudioBuffer *__Val_0___15; // [rsp+1138h] [rbp+AB8h]
  __int64 v458; // [rsp+1140h] [rbp+AC0h]
  __int64 v459; // [rsp+1148h] [rbp+AC8h]
  __int64 v460; // [rsp+1150h] [rbp+AD0h]
  _QWORD *v461; // [rsp+1158h] [rbp+AD8h]
  __int64 *ThreadLogContextSlot_15; // [rsp+1160h] [rbp+AE0h]
  unsigned __int64 v463; // [rsp+1168h] [rbp+AE8h] BYREF
  __int64 v464; // [rsp+1170h] [rbp+AF0h] BYREF
  __int64 (__fastcall *v465)(__int64, _BYTE *); // [rsp+1178h] [rbp+AF8h]
  __int64 v466; // [rsp+1180h] [rbp+B00h] BYREF
  __int64 (__fastcall *v467)(__int64, _BYTE *); // [rsp+1188h] [rbp+B08h]
  __int64 v468; // [rsp+1190h] [rbp+B10h] BYREF
  __int64 (__fastcall *v469)(__int64, _BYTE *); // [rsp+1198h] [rbp+B18h]
  __int64 v470; // [rsp+11A0h] [rbp+B20h]
  __int64 v471; // [rsp+11A8h] [rbp+B28h] BYREF
  __int64 (__fastcall *v472)(__int64, _BYTE *); // [rsp+11B0h] [rbp+B30h]
  __int64 *v473; // [rsp+11B8h] [rbp+B38h]
  __int64 v474; // [rsp+11C0h] [rbp+B40h]
  __int64 v475; // [rsp+11C8h] [rbp+B48h] BYREF
  __int64 v476; // [rsp+11D0h] [rbp+B50h]
  __int64 v477; // [rsp+11D8h] [rbp+B58h]
  __int64 v478; // [rsp+11E0h] [rbp+B60h]
  __int64 (__fastcall *v479)(__int64, _BYTE *, __int64); // [rsp+11E8h] [rbp+B68h]
  __int64 v480; // [rsp+11F0h] [rbp+B70h]
  __int64 v481; // [rsp+11F8h] [rbp+B78h]
  __int64 (__fastcall *v482)(__int64, _BYTE *, __int64); // [rsp+1200h] [rbp+B80h]
  __int64 v483; // [rsp+1208h] [rbp+B88h] BYREF
  __int64 v484; // [rsp+1210h] [rbp+B90h] BYREF
  __int64 v485; // [rsp+1218h] [rbp+B98h]
  _QWORD *v486; // [rsp+1220h] [rbp+BA0h]
  _QWORD *v487; // [rsp+1228h] [rbp+BA8h]
  _QWORD *v488; // [rsp+1230h] [rbp+BB0h]
  _QWORD *v489; // [rsp+1238h] [rbp+BB8h]
  _QWORD *v490; // [rsp+1240h] [rbp+BC0h]
  _QWORD *v491; // [rsp+1248h] [rbp+BC8h]
  const char *p_NOT_INIT_13; // [rsp+1250h] [rbp+BD0h] BYREF
  __int64 *ThreadLogContextSlot_12; // [rsp+1258h] [rbp+BD8h]
  __int64 v494; // [rsp+1260h] [rbp+BE0h]
  _QWORD *v495; // [rsp+1268h] [rbp+BE8h]
  __int64 *ThreadLogContextSlot_13; // [rsp+1270h] [rbp+BF0h]
  unsigned __int64 v497; // [rsp+1278h] [rbp+BF8h] BYREF
  __int64 v498; // [rsp+1280h] [rbp+C00h] BYREF
  __int64 (__fastcall *v499)(__int64, _BYTE *); // [rsp+1288h] [rbp+C08h]
  __int64 v500; // [rsp+1290h] [rbp+C10h] BYREF
  __int64 (__fastcall *v501)(__int64, _BYTE *); // [rsp+1298h] [rbp+C18h]
  __int64 v502; // [rsp+12A0h] [rbp+C20h] BYREF
  __int64 (__fastcall *v503)(__int64, _BYTE *); // [rsp+12A8h] [rbp+C28h]
  __int64 v504; // [rsp+12B0h] [rbp+C30h]
  __int64 v505; // [rsp+12B8h] [rbp+C38h] BYREF
  __int64 (__fastcall *v506)(__int64, _BYTE *); // [rsp+12C0h] [rbp+C40h]
  __int64 *v507; // [rsp+12C8h] [rbp+C48h]
  __int64 v508; // [rsp+12D0h] [rbp+C50h]
  __int64 v509; // [rsp+12D8h] [rbp+C58h] BYREF
  __int64 v510; // [rsp+12E0h] [rbp+C60h]
  __int64 v511; // [rsp+12E8h] [rbp+C68h]
  __int64 v512; // [rsp+12F0h] [rbp+C70h]
  __int64 (__fastcall *v513)(__int64, _BYTE *, __int64); // [rsp+12F8h] [rbp+C78h]
  __int64 v514; // [rsp+1300h] [rbp+C80h]
  __int64 v515; // [rsp+1308h] [rbp+C88h]
  __int64 (__fastcall *v516)(__int64, _BYTE *, __int64); // [rsp+1310h] [rbp+C90h]
  __int64 v517; // [rsp+1318h] [rbp+C98h] BYREF
  __int64 v518; // [rsp+1320h] [rbp+CA0h] BYREF
  __int64 v519; // [rsp+1328h] [rbp+CA8h]
  __int64 v520; // [rsp+1330h] [rbp+CB0h]
  __int64 v521; // [rsp+1338h] [rbp+CB8h] BYREF
  __int64 v522; // [rsp+1340h] [rbp+CC0h]
  _QWORD *v523; // [rsp+1348h] [rbp+CC8h]
  _QWORD *v524; // [rsp+1350h] [rbp+CD0h]
  _QWORD *v525; // [rsp+1358h] [rbp+CD8h]
  _QWORD *v526; // [rsp+1360h] [rbp+CE0h]
  _QWORD *v527; // [rsp+1368h] [rbp+CE8h]
  _QWORD *v528; // [rsp+1370h] [rbp+CF0h]
  _QWORD *v529; // [rsp+1378h] [rbp+CF8h]
  const char *p_NOT_INIT_11; // [rsp+1380h] [rbp+D00h] BYREF
  _QWORD *v531; // [rsp+1388h] [rbp+D08h]
  __int64 *ThreadLogContextSlot_10; // [rsp+1390h] [rbp+D10h]
  __int64 v533; // [rsp+1398h] [rbp+D18h]
  __int64 v534; // [rsp+13A0h] [rbp+D20h]
  __int64 v535; // [rsp+13A8h] [rbp+D28h] BYREF
  __int64 v536; // [rsp+13B0h] [rbp+D30h]
  _QWORD *v537; // [rsp+13B8h] [rbp+D38h]
  _QWORD *v538; // [rsp+13C0h] [rbp+D40h]
  _QWORD *v539; // [rsp+13C8h] [rbp+D48h]
  __int64 *ThreadLogContextSlot_11; // [rsp+13D0h] [rbp+D50h]
  __int64 v541; // [rsp+13D8h] [rbp+D58h]
  unsigned __int64 v542; // [rsp+13E0h] [rbp+D60h] BYREF
  __int64 v543; // [rsp+13E8h] [rbp+D68h] BYREF
  __int64 (__fastcall *v544)(__int64, _BYTE *); // [rsp+13F0h] [rbp+D70h]
  __int64 v545; // [rsp+13F8h] [rbp+D78h] BYREF
  __int64 (__fastcall *v546)(__int64, _BYTE *); // [rsp+1400h] [rbp+D80h]
  __int64 v547; // [rsp+1408h] [rbp+D88h] BYREF
  __int64 (__fastcall *v548)(__int64, _BYTE *); // [rsp+1410h] [rbp+D90h]
  __int64 v549; // [rsp+1418h] [rbp+D98h]
  __int64 v550; // [rsp+1420h] [rbp+DA0h] BYREF
  __int64 (__fastcall *v551)(__int64, _BYTE *); // [rsp+1428h] [rbp+DA8h]
  __int64 *v552; // [rsp+1430h] [rbp+DB0h]
  __int64 v553; // [rsp+1438h] [rbp+DB8h]
  __int64 v554; // [rsp+1440h] [rbp+DC0h] BYREF
  __int64 v555; // [rsp+1448h] [rbp+DC8h]
  __int64 v556; // [rsp+1450h] [rbp+DD0h]
  __int64 v557; // [rsp+1458h] [rbp+DD8h]
  __int64 (__fastcall *v558)(__int64, _BYTE *, __int64); // [rsp+1460h] [rbp+DE0h]
  __int64 v559; // [rsp+1468h] [rbp+DE8h]
  __int64 v560; // [rsp+1470h] [rbp+DF0h]
  __int64 (__fastcall *v561)(__int64, _BYTE *, __int64); // [rsp+1478h] [rbp+DF8h]
  __int64 v562; // [rsp+1480h] [rbp+E00h] BYREF
  __int64 v563; // [rsp+1488h] [rbp+E08h] BYREF
  __int64 v564; // [rsp+1490h] [rbp+E10h]
  __int64 v565; // [rsp+1498h] [rbp+E18h]
  __int64 v566; // [rsp+14A0h] [rbp+E20h] BYREF
  __int64 v567; // [rsp+14A8h] [rbp+E28h]
  _QWORD *v568; // [rsp+14B0h] [rbp+E30h]
  _QWORD *v569; // [rsp+14B8h] [rbp+E38h]
  _QWORD *v570; // [rsp+14C0h] [rbp+E40h]
  _QWORD *v571; // [rsp+14C8h] [rbp+E48h]
  _QWORD *v572; // [rsp+14D0h] [rbp+E50h]
  _QWORD *v573; // [rsp+14D8h] [rbp+E58h]
  const char *p_NOT_INIT_1; // [rsp+14E0h] [rbp+E60h] BYREF
  _QWORD *v575; // [rsp+14E8h] [rbp+E68h]
  __int64 *ThreadLogContextSlot; // [rsp+14F0h] [rbp+E70h]
  __int64 v577; // [rsp+14F8h] [rbp+E78h]
  __int64 v578; // [rsp+1500h] [rbp+E80h]
  __int64 v579; // [rsp+1508h] [rbp+E88h] BYREF
  __int64 v580; // [rsp+1510h] [rbp+E90h]
  _QWORD *v581; // [rsp+1518h] [rbp+E98h]
  _QWORD *v582; // [rsp+1520h] [rbp+EA0h]
  __int64 *ThreadLogContextSlot_1; // [rsp+1528h] [rbp+EA8h]
  __int64 v584; // [rsp+1530h] [rbp+EB0h]
  __int64 v585; // [rsp+1538h] [rbp+EB8h]
  _QWORD *v586; // [rsp+1540h] [rbp+EC0h]
  __int64 v587; // [rsp+1548h] [rbp+EC8h]
  unsigned __int64 v588; // [rsp+1550h] [rbp+ED0h] BYREF
  __int64 v589; // [rsp+1558h] [rbp+ED8h] BYREF
  __int64 (__fastcall *v590)(__int64, _BYTE *); // [rsp+1560h] [rbp+EE0h]
  __int64 v591; // [rsp+1568h] [rbp+EE8h] BYREF
  __int64 (__fastcall *v592)(__int64, _BYTE *); // [rsp+1570h] [rbp+EF0h]
  __int64 v593; // [rsp+1578h] [rbp+EF8h] BYREF
  __int64 (__fastcall *v594)(__int64, _BYTE *); // [rsp+1580h] [rbp+F00h]
  __int64 v595; // [rsp+1588h] [rbp+F08h]
  __int64 v596; // [rsp+1590h] [rbp+F10h] BYREF
  __int64 (__fastcall *v597)(__int64, _BYTE *); // [rsp+1598h] [rbp+F18h]
  __int64 *v598; // [rsp+15A0h] [rbp+F20h]
  __int64 v599; // [rsp+15A8h] [rbp+F28h]
  __int64 v600; // [rsp+15B0h] [rbp+F30h] BYREF
  __int64 v601; // [rsp+15B8h] [rbp+F38h]
  __int64 v602; // [rsp+15C0h] [rbp+F40h]
  __int64 v603; // [rsp+15C8h] [rbp+F48h]
  __int64 (__fastcall *v604)(__int64, _BYTE *, __int64); // [rsp+15D0h] [rbp+F50h]
  __int64 v605; // [rsp+15D8h] [rbp+F58h]
  __int64 v606; // [rsp+15E0h] [rbp+F60h]
  __int64 (__fastcall *v607)(__int64, _BYTE *, __int64); // [rsp+15E8h] [rbp+F68h]
  __int64 v608; // [rsp+15F0h] [rbp+F70h] BYREF
  __int64 v609; // [rsp+15F8h] [rbp+F78h] BYREF
  __int64 v610; // [rsp+1600h] [rbp+F80h]
  __int64 v611; // [rsp+1608h] [rbp+F88h]
  __int64 v612; // [rsp+1610h] [rbp+F90h] BYREF
  __int64 v613; // [rsp+1618h] [rbp+F98h]
  _QWORD *v614; // [rsp+1620h] [rbp+FA0h]
  _QWORD *v615; // [rsp+1628h] [rbp+FA8h]
  _QWORD *v616; // [rsp+1630h] [rbp+FB0h]
  _QWORD *v617; // [rsp+1638h] [rbp+FB8h]
  _QWORD *v618; // [rsp+1640h] [rbp+FC0h]
  _QWORD *v619; // [rsp+1648h] [rbp+FC8h]
  const char *p_NOT_INIT_9; // [rsp+1650h] [rbp+FD0h] BYREF
  _QWORD *v621; // [rsp+1658h] [rbp+FD8h]
  __int64 *ThreadLogContextSlot_8; // [rsp+1660h] [rbp+FE0h]
  __int64 v623; // [rsp+1668h] [rbp+FE8h]
  __int64 v624; // [rsp+1670h] [rbp+FF0h]
  __int64 v625; // [rsp+1678h] [rbp+FF8h] BYREF
  __int64 v626; // [rsp+1680h] [rbp+1000h]
  _QWORD *v627; // [rsp+1688h] [rbp+1008h]
  _QWORD *v628; // [rsp+1690h] [rbp+1010h]
  __int64 *ThreadLogContextSlot_9; // [rsp+1698h] [rbp+1018h]
  unsigned __int64 v630; // [rsp+16A0h] [rbp+1020h] BYREF
  __int64 v631; // [rsp+16A8h] [rbp+1028h] BYREF
  __int64 (__fastcall *v632)(__int64, _BYTE *); // [rsp+16B0h] [rbp+1030h]
  __int64 v633; // [rsp+16B8h] [rbp+1038h] BYREF
  __int64 (__fastcall *v634)(__int64, _BYTE *); // [rsp+16C0h] [rbp+1040h]
  __int64 v635; // [rsp+16C8h] [rbp+1048h] BYREF
  __int64 (__fastcall *v636)(__int64, _BYTE *); // [rsp+16D0h] [rbp+1050h]
  __int64 v637; // [rsp+16D8h] [rbp+1058h]
  __int64 v638; // [rsp+16E0h] [rbp+1060h] BYREF
  __int64 (__fastcall *v639)(__int64, _BYTE *); // [rsp+16E8h] [rbp+1068h]
  __int64 *v640; // [rsp+16F0h] [rbp+1070h]
  __int64 v641; // [rsp+16F8h] [rbp+1078h]
  __int64 v642; // [rsp+1700h] [rbp+1080h] BYREF
  __int64 v643; // [rsp+1708h] [rbp+1088h]
  __int64 v644; // [rsp+1710h] [rbp+1090h]
  __int64 v645; // [rsp+1718h] [rbp+1098h]
  __int64 (__fastcall *v646)(__int64, _BYTE *, __int64); // [rsp+1720h] [rbp+10A0h]
  __int64 v647; // [rsp+1728h] [rbp+10A8h]
  __int64 v648; // [rsp+1730h] [rbp+10B0h]
  __int64 (__fastcall *v649)(__int64, _BYTE *, __int64); // [rsp+1738h] [rbp+10B8h]
  __int64 v650; // [rsp+1740h] [rbp+10C0h] BYREF
  __int64 v651; // [rsp+1748h] [rbp+10C8h] BYREF
  __int64 v652; // [rsp+1750h] [rbp+10D0h]
  __int64 v653; // [rsp+1758h] [rbp+10D8h]
  __int64 v654; // [rsp+1760h] [rbp+10E0h] BYREF
  __int64 v655; // [rsp+1768h] [rbp+10E8h]
  _QWORD *v656; // [rsp+1770h] [rbp+10F0h]
  _QWORD *v657; // [rsp+1778h] [rbp+10F8h]
  _QWORD *v658; // [rsp+1780h] [rbp+1100h]
  _QWORD *v659; // [rsp+1788h] [rbp+1108h]
  _QWORD *v660; // [rsp+1790h] [rbp+1110h]
  _QWORD *v661; // [rsp+1798h] [rbp+1118h]
  const char *p_NOT_INIT_7; // [rsp+17A0h] [rbp+1120h] BYREF
  __int64 v663; // [rsp+17A8h] [rbp+1128h]
  _QWORD *v664; // [rsp+17B0h] [rbp+1130h]
  __int64 *ThreadLogContextSlot_6; // [rsp+17B8h] [rbp+1138h]
  __int64 v666; // [rsp+17C0h] [rbp+1140h]
  __int64 v667; // [rsp+17C8h] [rbp+1148h]
  __int64 v668; // [rsp+17D0h] [rbp+1150h] BYREF
  __int64 v669; // [rsp+17D8h] [rbp+1158h]
  _QWORD *v670; // [rsp+17E0h] [rbp+1160h]
  __int64 v671; // [rsp+17E8h] [rbp+1168h]
  _QWORD *v672; // [rsp+17F0h] [rbp+1170h]
  __int64 *ThreadLogContextSlot_7; // [rsp+17F8h] [rbp+1178h]
  __int64 v674; // [rsp+1800h] [rbp+1180h]
  unsigned __int64 v675; // [rsp+1808h] [rbp+1188h] BYREF
  __int64 v676; // [rsp+1810h] [rbp+1190h] BYREF
  __int64 (__fastcall *v677)(__int64, _BYTE *); // [rsp+1818h] [rbp+1198h]
  __int64 v678; // [rsp+1820h] [rbp+11A0h] BYREF
  __int64 (__fastcall *v679)(__int64, _BYTE *); // [rsp+1828h] [rbp+11A8h]
  __int64 v680; // [rsp+1830h] [rbp+11B0h] BYREF
  __int64 (__fastcall *v681)(__int64, _BYTE *); // [rsp+1838h] [rbp+11B8h]
  __int64 v682; // [rsp+1840h] [rbp+11C0h]
  __int64 v683; // [rsp+1848h] [rbp+11C8h] BYREF
  __int64 (__fastcall *v684)(__int64, _BYTE *); // [rsp+1850h] [rbp+11D0h]
  __int64 *v685; // [rsp+1858h] [rbp+11D8h]
  __int64 v686; // [rsp+1860h] [rbp+11E0h]
  __int64 v687; // [rsp+1868h] [rbp+11E8h] BYREF
  __int64 v688; // [rsp+1870h] [rbp+11F0h]
  __int64 v689; // [rsp+1878h] [rbp+11F8h]
  __int64 v690; // [rsp+1880h] [rbp+1200h]
  __int64 (__fastcall *v691)(__int64, _BYTE *, __int64); // [rsp+1888h] [rbp+1208h]
  __int64 v692; // [rsp+1890h] [rbp+1210h]
  __int64 v693; // [rsp+1898h] [rbp+1218h]
  __int64 (__fastcall *v694)(__int64, _BYTE *, __int64); // [rsp+18A0h] [rbp+1220h]
  __int64 v695; // [rsp+18A8h] [rbp+1228h] BYREF
  __int64 v696; // [rsp+18B0h] [rbp+1230h] BYREF
  __int64 v697; // [rsp+18B8h] [rbp+1238h]
  __int64 v698; // [rsp+18C0h] [rbp+1240h]
  __int64 v699; // [rsp+18C8h] [rbp+1248h] BYREF
  __int64 v700; // [rsp+18D0h] [rbp+1250h]
  __int64 v701; // [rsp+18D8h] [rbp+1258h]
  __int64 v702; // [rsp+18E0h] [rbp+1260h] BYREF
  __int64 v703; // [rsp+18E8h] [rbp+1268h]
  _QWORD *v704; // [rsp+18F0h] [rbp+1270h]
  _QWORD *v705; // [rsp+18F8h] [rbp+1278h]
  _QWORD *v706; // [rsp+1900h] [rbp+1280h]
  _QWORD *v707; // [rsp+1908h] [rbp+1288h]
  _QWORD *v708; // [rsp+1910h] [rbp+1290h]
  _QWORD *v709; // [rsp+1918h] [rbp+1298h]
  const char *p_NOT_INIT_3; // [rsp+1920h] [rbp+12A0h] BYREF
  __int64 v711; // [rsp+1928h] [rbp+12A8h] BYREF
  __int64 v712; // [rsp+1930h] [rbp+12B0h] BYREF
  _QWORD *v713; // [rsp+1938h] [rbp+12B8h]
  _QWORD *v714; // [rsp+1940h] [rbp+12C0h]
  __int64 *ThreadLogContextSlot_2; // [rsp+1948h] [rbp+12C8h]
  __int64 v716; // [rsp+1950h] [rbp+12D0h]
  __int64 v717; // [rsp+1958h] [rbp+12D8h]
  __int64 v718; // [rsp+1960h] [rbp+12E0h] BYREF
  __int64 v719; // [rsp+1968h] [rbp+12E8h]
  __int64 v720; // [rsp+1970h] [rbp+12F0h]
  __int64 v721; // [rsp+1978h] [rbp+12F8h] BYREF
  __int64 v722; // [rsp+1980h] [rbp+1300h]
  _QWORD *v723; // [rsp+1988h] [rbp+1308h]
  __int64 v724; // [rsp+1990h] [rbp+1310h] BYREF
  __int64 v725; // [rsp+1998h] [rbp+1318h] BYREF
  _QWORD *v726; // [rsp+19A0h] [rbp+1320h]
  _QWORD *v727; // [rsp+19A8h] [rbp+1328h]
  __int64 *ThreadLogContextSlot_3; // [rsp+19B0h] [rbp+1330h]
  unsigned __int64 v729; // [rsp+19B8h] [rbp+1338h] BYREF
  __int64 v730; // [rsp+19C0h] [rbp+1340h] BYREF
  __int64 (__fastcall *v731)(__int64, _BYTE *); // [rsp+19C8h] [rbp+1348h]
  __int64 v732; // [rsp+19D0h] [rbp+1350h] BYREF
  __int64 (__fastcall *v733)(__int64, _BYTE *); // [rsp+19D8h] [rbp+1358h]
  __int64 v734; // [rsp+19E0h] [rbp+1360h] BYREF
  __int64 (__fastcall *v735)(__int64, _BYTE *); // [rsp+19E8h] [rbp+1368h]
  __int64 v736; // [rsp+19F0h] [rbp+1370h]
  __int64 v737; // [rsp+19F8h] [rbp+1378h] BYREF
  __int64 (__fastcall *v738)(__int64, _BYTE *); // [rsp+1A00h] [rbp+1380h]
  __int64 *v739; // [rsp+1A08h] [rbp+1388h]
  __int64 v740; // [rsp+1A10h] [rbp+1390h]
  __int64 v741; // [rsp+1A18h] [rbp+1398h] BYREF
  __int64 v742; // [rsp+1A20h] [rbp+13A0h]
  __int64 v743; // [rsp+1A28h] [rbp+13A8h]
  __int64 v744; // [rsp+1A30h] [rbp+13B0h]
  __int64 (__fastcall *v745)(__int64, _BYTE *, __int64); // [rsp+1A38h] [rbp+13B8h]
  __int64 v746; // [rsp+1A40h] [rbp+13C0h]
  __int64 v747; // [rsp+1A48h] [rbp+13C8h]
  __int64 (__fastcall *v748)(__int64, _BYTE *, __int64); // [rsp+1A50h] [rbp+13D0h]
  __int64 v749; // [rsp+1A58h] [rbp+13D8h] BYREF
  __int64 v750; // [rsp+1A60h] [rbp+13E0h] BYREF
  __int64 v751; // [rsp+1A68h] [rbp+13E8h]
  __int64 v752; // [rsp+1A70h] [rbp+13F0h]
  __int64 v753; // [rsp+1A78h] [rbp+13F8h] BYREF
  __int64 v754; // [rsp+1A80h] [rbp+1400h]
  __int64 v755; // [rsp+1A88h] [rbp+1408h]
  __int64 v756; // [rsp+1A90h] [rbp+1410h] BYREF
  __int64 v757; // [rsp+1A98h] [rbp+1418h]
  __int64 *ThreadLogContextSlot_4; // [rsp+1AA0h] [rbp+1420h]
  _QWORD *v759; // [rsp+1AA8h] [rbp+1428h]
  _QWORD *v760; // [rsp+1AB0h] [rbp+1430h]
  _QWORD *v761; // [rsp+1AB8h] [rbp+1438h]
  _QWORD *v762; // [rsp+1AC0h] [rbp+1440h]
  _QWORD *v763; // [rsp+1AC8h] [rbp+1448h]
  _QWORD *v764; // [rsp+1AD0h] [rbp+1450h]
  const char *p_NOT_INIT_5; // [rsp+1AD8h] [rbp+1458h] BYREF
  _QWORD *v766; // [rsp+1AE0h] [rbp+1460h]
  _QWORD *v767; // [rsp+1AE8h] [rbp+1468h]
  __int64 v768; // [rsp+1AF0h] [rbp+1470h]
  __int64 v769; // [rsp+1AF8h] [rbp+1478h]
  __int64 v770; // [rsp+1B00h] [rbp+1480h] BYREF
  __int64 v771; // [rsp+1B08h] [rbp+1488h]
  __int64 v772; // [rsp+1B10h] [rbp+1490h]
  __int64 v773; // [rsp+1B18h] [rbp+1498h] BYREF
  __int64 v774; // [rsp+1B20h] [rbp+14A0h]
  _QWORD *v775; // [rsp+1B28h] [rbp+14A8h]
  _QWORD *v776; // [rsp+1B30h] [rbp+14B0h]
  _QWORD *v777; // [rsp+1B38h] [rbp+14B8h]
  __int64 *ThreadLogContextSlot_5; // [rsp+1B40h] [rbp+14C0h]
  unsigned __int64 v779; // [rsp+1B48h] [rbp+14C8h] BYREF
  __int64 v780; // [rsp+1B50h] [rbp+14D0h] BYREF
  __int64 (__fastcall *v781)(__int64, _BYTE *); // [rsp+1B58h] [rbp+14D8h]
  __int64 v782; // [rsp+1B60h] [rbp+14E0h] BYREF
  __int64 (__fastcall *v783)(__int64, _BYTE *); // [rsp+1B68h] [rbp+14E8h]
  __int64 v784; // [rsp+1B70h] [rbp+14F0h] BYREF
  __int64 (__fastcall *v785)(__int64, _BYTE *); // [rsp+1B78h] [rbp+14F8h]
  __int64 v786; // [rsp+1B80h] [rbp+1500h]
  __int64 v787; // [rsp+1B88h] [rbp+1508h] BYREF
  __int64 (__fastcall *v788)(__int64, _BYTE *); // [rsp+1B90h] [rbp+1510h]
  __int64 *v789; // [rsp+1B98h] [rbp+1518h]
  __int64 v790; // [rsp+1BA0h] [rbp+1520h]
  __int64 v791; // [rsp+1BA8h] [rbp+1528h] BYREF
  __int64 v792; // [rsp+1BB0h] [rbp+1530h]
  __int64 v793; // [rsp+1BB8h] [rbp+1538h]
  __int64 v794; // [rsp+1BC0h] [rbp+1540h]
  __int64 (__fastcall *v795)(__int64, _BYTE *, __int64); // [rsp+1BC8h] [rbp+1548h]
  __int64 v796; // [rsp+1BD0h] [rbp+1550h]
  __int64 v797; // [rsp+1BD8h] [rbp+1558h]
  __int64 (__fastcall *v798)(__int64, _BYTE *, __int64); // [rsp+1BE0h] [rbp+1560h]
  __int64 v799; // [rsp+1BE8h] [rbp+1568h] BYREF
  __int64 v800; // [rsp+1BF0h] [rbp+1570h] BYREF
  __int64 v801; // [rsp+1BF8h] [rbp+1578h]
  _QWORD *v802; // [rsp+1C00h] [rbp+1580h]
  _QWORD *v803; // [rsp+1C08h] [rbp+1588h]
  _QWORD *v804; // [rsp+1C10h] [rbp+1590h]
  _QWORD *v805; // [rsp+1C18h] [rbp+1598h]
  _QWORD *v806; // [rsp+1C20h] [rbp+15A0h]
  _QWORD *v807; // [rsp+1C28h] [rbp+15A8h]
  const char *p_NOT_INIT_15; // [rsp+1C30h] [rbp+15B0h] BYREF
  __int64 *ThreadLogContextSlot_14; // [rsp+1C38h] [rbp+15B8h]
  __int64 v810; // [rsp+1C40h] [rbp+15C0h]
  _QWORD v811[3]; // [rsp+1C48h] [rbp+15C8h] BYREF
  _QWORD v812[3]; // [rsp+1C60h] [rbp+15E0h] BYREF
  _QWORD v813[3]; // [rsp+1C78h] [rbp+15F8h] BYREF
  _QWORD v814[3]; // [rsp+1C90h] [rbp+1610h] BYREF
  _QWORD v815[3]; // [rsp+1CA8h] [rbp+1628h] BYREF
  _QWORD v816[3]; // [rsp+1CC0h] [rbp+1640h] BYREF
  _QWORD v817[3]; // [rsp+1CD8h] [rbp+1658h] BYREF
  _QWORD v818[3]; // [rsp+1CF0h] [rbp+1670h] BYREF
  _QWORD v819[3]; // [rsp+1D08h] [rbp+1688h] BYREF
  _QWORD v820[3]; // [rsp+1D20h] [rbp+16A0h] BYREF
  _QWORD v821[3]; // [rsp+1D38h] [rbp+16B8h] BYREF
  _QWORD v822[3]; // [rsp+1D50h] [rbp+16D0h] BYREF
  _QWORD v823[3]; // [rsp+1D68h] [rbp+16E8h] BYREF
  _QWORD v824[3]; // [rsp+1D80h] [rbp+1700h] BYREF
  _QWORD v825[3]; // [rsp+1D98h] [rbp+1718h] BYREF
  _QWORD v826[3]; // [rsp+1DB0h] [rbp+1730h] BYREF
  _QWORD v827[3]; // [rsp+1DC8h] [rbp+1748h] BYREF
  _QWORD v828[3]; // [rsp+1DE0h] [rbp+1760h] BYREF
  _QWORD v829[3]; // [rsp+1DF8h] [rbp+1778h] BYREF
  _QWORD v830[3]; // [rsp+1E10h] [rbp+1790h] BYREF
  _QWORD v831[3]; // [rsp+1E28h] [rbp+17A8h] BYREF
  _QWORD v832[3]; // [rsp+1E40h] [rbp+17C0h] BYREF
  _QWORD v833[3]; // [rsp+1E58h] [rbp+17D8h] BYREF
  _QWORD v834[3]; // [rsp+1E70h] [rbp+17F0h] BYREF
  _QWORD v835[3]; // [rsp+1E88h] [rbp+1808h] BYREF
  _QWORD v836[3]; // [rsp+1EA0h] [rbp+1820h] BYREF
  _QWORD v837[3]; // [rsp+1EB8h] [rbp+1838h] BYREF
  _QWORD v838[3]; // [rsp+1ED0h] [rbp+1850h] BYREF
  _QWORD v839[3]; // [rsp+1EE8h] [rbp+1868h] BYREF
  _QWORD v840[3]; // [rsp+1F00h] [rbp+1880h] BYREF
  _QWORD v841[3]; // [rsp+1F18h] [rbp+1898h] BYREF
  _QWORD v842[3]; // [rsp+1F30h] [rbp+18B0h] BYREF
  _QWORD v843[3]; // [rsp+1F48h] [rbp+18C8h] BYREF
  _QWORD v844[3]; // [rsp+1F60h] [rbp+18E0h] BYREF
  _QWORD v845[3]; // [rsp+1F78h] [rbp+18F8h] BYREF
  _QWORD v846[3]; // [rsp+1F90h] [rbp+1910h] BYREF
  _QWORD v847[3]; // [rsp+1FA8h] [rbp+1928h] BYREF
  _QWORD v848[3]; // [rsp+1FC0h] [rbp+1940h] BYREF
  _QWORD v849[3]; // [rsp+1FD8h] [rbp+1958h] BYREF
  _QWORD v850[3]; // [rsp+1FF0h] [rbp+1970h] BYREF
  _QWORD v851[3]; // [rsp+2008h] [rbp+1988h] BYREF
  _QWORD v852[3]; // [rsp+2020h] [rbp+19A0h] BYREF
  _QWORD v853[3]; // [rsp+2038h] [rbp+19B8h] BYREF
  _QWORD v854[3]; // [rsp+2050h] [rbp+19D0h] BYREF
  _QWORD v855[3]; // [rsp+2068h] [rbp+19E8h] BYREF
  _QWORD v856[3]; // [rsp+2080h] [rbp+1A00h] BYREF
  _QWORD v857[3]; // [rsp+2098h] [rbp+1A18h] BYREF
  _QWORD v858[3]; // [rsp+20B0h] [rbp+1A30h] BYREF
  _QWORD v859[3]; // [rsp+20C8h] [rbp+1A48h] BYREF
  _QWORD v860[3]; // [rsp+20E0h] [rbp+1A60h] BYREF
  _QWORD v861[3]; // [rsp+20F8h] [rbp+1A78h] BYREF
  _QWORD v862[3]; // [rsp+2110h] [rbp+1A90h] BYREF
  _QWORD v863[3]; // [rsp+2128h] [rbp+1AA8h] BYREF
  _QWORD v864[3]; // [rsp+2140h] [rbp+1AC0h] BYREF
  _QWORD v865[3]; // [rsp+2158h] [rbp+1AD8h] BYREF
  _QWORD v866[3]; // [rsp+2170h] [rbp+1AF0h] BYREF
  _QWORD v867[3]; // [rsp+2188h] [rbp+1B08h] BYREF
  _QWORD v868[3]; // [rsp+21A0h] [rbp+1B20h] BYREF
  _QWORD v869[3]; // [rsp+21B8h] [rbp+1B38h] BYREF
  _QWORD v870[3]; // [rsp+21D0h] [rbp+1B50h] BYREF
  _QWORD v871[3]; // [rsp+21E8h] [rbp+1B68h] BYREF
  _QWORD v872[3]; // [rsp+2200h] [rbp+1B80h] BYREF
  _QWORD v873[3]; // [rsp+2218h] [rbp+1B98h] BYREF
  _QWORD v874[3]; // [rsp+2230h] [rbp+1BB0h] BYREF
  _QWORD v875[3]; // [rsp+2248h] [rbp+1BC8h] BYREF
  _QWORD v876[3]; // [rsp+2260h] [rbp+1BE0h] BYREF
  _QWORD src__6[2]; // [rsp+2278h] [rbp+1BF8h] BYREF
  _QWORD src__28[2]; // [rsp+2288h] [rbp+1C08h] BYREF
  _QWORD src__29[2]; // [rsp+2298h] [rbp+1C18h] BYREF
  _QWORD v880[2]; // [rsp+22A8h] [rbp+1C28h] BYREF
  _QWORD src__30[2]; // [rsp+22B8h] [rbp+1C38h] BYREF
  _QWORD src__31[2]; // [rsp+22C8h] [rbp+1C48h] BYREF
  _QWORD v883[2]; // [rsp+22D8h] [rbp+1C58h] BYREF
  _QWORD src__24[2]; // [rsp+22E8h] [rbp+1C68h] BYREF
  _QWORD src__25[2]; // [rsp+22F8h] [rbp+1C78h] BYREF
  _QWORD v886[2]; // [rsp+2308h] [rbp+1C88h] BYREF
  _QWORD src__26[2]; // [rsp+2318h] [rbp+1C98h] BYREF
  _QWORD src__27[2]; // [rsp+2328h] [rbp+1CA8h] BYREF
  _QWORD v889[2]; // [rsp+2338h] [rbp+1CB8h] BYREF
  _QWORD src__20[2]; // [rsp+2348h] [rbp+1CC8h] BYREF
  _QWORD src__21[2]; // [rsp+2358h] [rbp+1CD8h] BYREF
  _QWORD v892[2]; // [rsp+2368h] [rbp+1CE8h] BYREF
  _QWORD src__22[2]; // [rsp+2378h] [rbp+1CF8h] BYREF
  _QWORD src__23[2]; // [rsp+2388h] [rbp+1D08h] BYREF
  _QWORD v895[2]; // [rsp+2398h] [rbp+1D18h] BYREF
  _QWORD src_[2]; // [rsp+23A8h] [rbp+1D28h] BYREF
  _QWORD src__1[2]; // [rsp+23B8h] [rbp+1D38h] BYREF
  _QWORD v898[2]; // [rsp+23C8h] [rbp+1D48h] BYREF
  _QWORD src__2[2]; // [rsp+23D8h] [rbp+1D58h] BYREF
  _QWORD src__3[2]; // [rsp+23E8h] [rbp+1D68h] BYREF
  _QWORD v901[2]; // [rsp+23F8h] [rbp+1D78h] BYREF
  _QWORD src__16[2]; // [rsp+2408h] [rbp+1D88h] BYREF
  _QWORD src__17[2]; // [rsp+2418h] [rbp+1D98h] BYREF
  _QWORD v904[2]; // [rsp+2428h] [rbp+1DA8h] BYREF
  _QWORD src__18[2]; // [rsp+2438h] [rbp+1DB8h] BYREF
  _QWORD src__19[2]; // [rsp+2448h] [rbp+1DC8h] BYREF
  _QWORD v907[2]; // [rsp+2458h] [rbp+1DD8h] BYREF
  _QWORD src__12[2]; // [rsp+2468h] [rbp+1DE8h] BYREF
  _QWORD src__13[2]; // [rsp+2478h] [rbp+1DF8h] BYREF
  _QWORD v910[2]; // [rsp+2488h] [rbp+1E08h] BYREF
  _QWORD src__14[2]; // [rsp+2498h] [rbp+1E18h] BYREF
  _QWORD src__15[2]; // [rsp+24A8h] [rbp+1E28h] BYREF
  _QWORD v913[2]; // [rsp+24B8h] [rbp+1E38h] BYREF
  _QWORD src__4[2]; // [rsp+24C8h] [rbp+1E48h] BYREF
  _QWORD src__5[2]; // [rsp+24D8h] [rbp+1E58h] BYREF
  _QWORD v916[2]; // [rsp+24E8h] [rbp+1E68h] BYREF
  _QWORD src__7[2]; // [rsp+24F8h] [rbp+1E78h] BYREF
  _QWORD v918[2]; // [rsp+2508h] [rbp+1E88h] BYREF
  _QWORD src__8[2]; // [rsp+2518h] [rbp+1E98h] BYREF
  _QWORD src__9[2]; // [rsp+2528h] [rbp+1EA8h] BYREF
  _QWORD v921[2]; // [rsp+2538h] [rbp+1EB8h] BYREF
  _QWORD src__10[2]; // [rsp+2548h] [rbp+1EC8h] BYREF
  _QWORD src__11[2]; // [rsp+2558h] [rbp+1ED8h] BYREF
  _QWORD v924[2]; // [rsp+2568h] [rbp+1EE8h] BYREF
  _QWORD v925[2]; // [rsp+2578h] [rbp+1EF8h] BYREF
  char v926; // [rsp+2588h] [rbp+1F08h]
  _QWORD v927[2]; // [rsp+2590h] [rbp+1F10h] BYREF
  char v928; // [rsp+25A0h] [rbp+1F20h]
  _QWORD v929[2]; // [rsp+25A8h] [rbp+1F28h] BYREF
  char v930; // [rsp+25B8h] [rbp+1F38h]
  _QWORD v931[2]; // [rsp+25C0h] [rbp+1F40h] BYREF
  char v932; // [rsp+25D0h] [rbp+1F50h]
  _QWORD v933[2]; // [rsp+25D8h] [rbp+1F58h] BYREF
  char v934; // [rsp+25E8h] [rbp+1F68h]
  _QWORD v935[2]; // [rsp+25F0h] [rbp+1F70h] BYREF
  char v936; // [rsp+2600h] [rbp+1F80h]
  _QWORD v937[2]; // [rsp+2608h] [rbp+1F88h] BYREF
  char v938; // [rsp+2618h] [rbp+1F98h]
  _QWORD v939[2]; // [rsp+2620h] [rbp+1FA0h] BYREF
  char v940; // [rsp+2630h] [rbp+1FB0h]
  __int64 dst__27[2]; // [rsp+2638h] [rbp+1FB8h] BYREF
  _BYTE dst__20[16]; // [rsp+2648h] [rbp+1FC8h] BYREF
  __int64 dst__21[2]; // [rsp+2658h] [rbp+1FD8h] BYREF
  _BYTE dst__22[16]; // [rsp+2668h] [rbp+1FE8h] BYREF
  __int64 dst__23[2]; // [rsp+2678h] [rbp+1FF8h] BYREF
  _BYTE dst_[16]; // [rsp+2688h] [rbp+2008h] BYREF
  __int64 dst__1[2]; // [rsp+2698h] [rbp+2018h] BYREF
  _BYTE dst__2[16]; // [rsp+26A8h] [rbp+2028h] BYREF
  __int64 dst__3[2]; // [rsp+26B8h] [rbp+2038h] BYREF
  _BYTE dst__16[16]; // [rsp+26C8h] [rbp+2048h] BYREF
  __int64 dst__17[2]; // [rsp+26D8h] [rbp+2058h] BYREF
  _BYTE dst__18[16]; // [rsp+26E8h] [rbp+2068h] BYREF
  __int64 dst__19[2]; // [rsp+26F8h] [rbp+2078h] BYREF
  _BYTE dst__12[16]; // [rsp+2708h] [rbp+2088h] BYREF
  __int64 dst__13[2]; // [rsp+2718h] [rbp+2098h] BYREF
  _BYTE dst__14[16]; // [rsp+2728h] [rbp+20A8h] BYREF
  __int64 dst__15[2]; // [rsp+2738h] [rbp+20B8h] BYREF
  _BYTE dst__4[16]; // [rsp+2748h] [rbp+20C8h] BYREF
  __int64 dst__5[2]; // [rsp+2758h] [rbp+20D8h] BYREF
  _BYTE dst__6[16]; // [rsp+2768h] [rbp+20E8h] BYREF
  __int64 dst__7[2]; // [rsp+2778h] [rbp+20F8h] BYREF
  _BYTE dst__8[16]; // [rsp+2788h] [rbp+2108h] BYREF
  __int64 dst__9[2]; // [rsp+2798h] [rbp+2118h] BYREF
  _BYTE dst__10[16]; // [rsp+27A8h] [rbp+2128h] BYREF
  __int64 dst__11[4]; // [rsp+27B8h] [rbp+2138h] BYREF
  _BYTE v966[8]; // [rsp+27D8h] [rbp+2158h] BYREF
  _BYTE v967[8]; // [rsp+27E0h] [rbp+2160h] BYREF
  _BYTE v968[8]; // [rsp+27E8h] [rbp+2168h] BYREF
  _BYTE v969[8]; // [rsp+27F0h] [rbp+2170h] BYREF
  _BYTE v970[8]; // [rsp+27F8h] [rbp+2178h] BYREF
  _BYTE v971[8]; // [rsp+2800h] [rbp+2180h] BYREF
  __int64 n0xB_1; // [rsp+2808h] [rbp+2188h]
  _BYTE v973[8]; // [rsp+2810h] [rbp+2190h] BYREF
  _BYTE v974[8]; // [rsp+2818h] [rbp+2198h] BYREF
  _BYTE v975[8]; // [rsp+2820h] [rbp+21A0h] BYREF
  _BYTE v976[8]; // [rsp+2828h] [rbp+21A8h] BYREF
  _BYTE v977[8]; // [rsp+2830h] [rbp+21B0h] BYREF
  _BYTE v978[8]; // [rsp+2838h] [rbp+21B8h] BYREF
  __int64 n5; // [rsp+2840h] [rbp+21C0h]
  __int64 n0xA; // [rsp+2848h] [rbp+21C8h]
  _BYTE v981[8]; // [rsp+2850h] [rbp+21D0h] BYREF
  _BYTE v982[8]; // [rsp+2858h] [rbp+21D8h] BYREF
  _BYTE v983[8]; // [rsp+2860h] [rbp+21E0h] BYREF
  _BYTE v984[8]; // [rsp+2868h] [rbp+21E8h] BYREF
  _BYTE v985[8]; // [rsp+2870h] [rbp+21F0h] BYREF
  _BYTE v986[8]; // [rsp+2878h] [rbp+21F8h] BYREF
  __int64 n5_1; // [rsp+2880h] [rbp+2200h]
  __int64 n0xA_1; // [rsp+2888h] [rbp+2208h]
  _BYTE v989[8]; // [rsp+2890h] [rbp+2210h] BYREF
  _BYTE v990[8]; // [rsp+2898h] [rbp+2218h] BYREF
  _BYTE v991[8]; // [rsp+28A0h] [rbp+2220h] BYREF
  _BYTE v992[8]; // [rsp+28A8h] [rbp+2228h] BYREF
  _BYTE v993[8]; // [rsp+28B0h] [rbp+2230h] BYREF
  _BYTE v994[8]; // [rsp+28B8h] [rbp+2238h] BYREF
  __int64 n9_1; // [rsp+28C0h] [rbp+2240h]
  __int64 n0xE_1; // [rsp+28C8h] [rbp+2248h]
  _BYTE v997[8]; // [rsp+28D0h] [rbp+2250h] BYREF
  _BYTE v998[8]; // [rsp+28D8h] [rbp+2258h] BYREF
  _BYTE v999[8]; // [rsp+28E0h] [rbp+2260h] BYREF
  _BYTE v1000[8]; // [rsp+28E8h] [rbp+2268h] BYREF
  _BYTE v1001[8]; // [rsp+28F0h] [rbp+2270h] BYREF
  __int64 n9; // [rsp+28F8h] [rbp+2278h]
  __int64 n0xE; // [rsp+2900h] [rbp+2280h]
  _BYTE v1004[8]; // [rsp+2908h] [rbp+2288h] BYREF
  _BYTE v1005[8]; // [rsp+2910h] [rbp+2290h] BYREF
  _BYTE v1006[8]; // [rsp+2918h] [rbp+2298h] BYREF
  _BYTE v1007[8]; // [rsp+2920h] [rbp+22A0h] BYREF
  _BYTE v1008[8]; // [rsp+2928h] [rbp+22A8h] BYREF
  _BYTE v1009[8]; // [rsp+2930h] [rbp+22B0h] BYREF
  _BYTE v1010[8]; // [rsp+2938h] [rbp+22B8h] BYREF
  __int64 n7; // [rsp+2940h] [rbp+22C0h]
  __int64 n0xC; // [rsp+2948h] [rbp+22C8h]
  _BYTE v1013[8]; // [rsp+2950h] [rbp+22D0h] BYREF
  _BYTE v1014[8]; // [rsp+2958h] [rbp+22D8h] BYREF
  _BYTE v1015[8]; // [rsp+2960h] [rbp+22E0h] BYREF
  _BYTE v1016[8]; // [rsp+2968h] [rbp+22E8h] BYREF
  _BYTE v1017[8]; // [rsp+2970h] [rbp+22F0h] BYREF
  _BYTE v1018[8]; // [rsp+2978h] [rbp+22F8h] BYREF
  __int64 n6; // [rsp+2980h] [rbp+2300h]
  __int64 n0xB; // [rsp+2988h] [rbp+2308h]
  _BYTE v1021[8]; // [rsp+2990h] [rbp+2310h] BYREF
  _BYTE v1022[8]; // [rsp+2998h] [rbp+2318h] BYREF
  _BYTE v1023[8]; // [rsp+29A0h] [rbp+2320h] BYREF
  _BYTE v1024[8]; // [rsp+29A8h] [rbp+2328h] BYREF
  _BYTE v1025[8]; // [rsp+29B0h] [rbp+2330h] BYREF
  _BYTE v1026[8]; // [rsp+29B8h] [rbp+2338h] BYREF
  __int64 v1027; // [rsp+29C0h] [rbp+2340h] BYREF
  __int64 v1028; // [rsp+29C8h] [rbp+2348h] BYREF
  _BYTE dst__28[16]; // [rsp+29D0h] [rbp+2350h] BYREF
  __int64 dst__29[2]; // [rsp+29E0h] [rbp+2360h] BYREF
  _BYTE dst__30[16]; // [rsp+29F0h] [rbp+2370h] BYREF
  __int64 dst__31[2]; // [rsp+2A00h] [rbp+2380h] BYREF
  _BYTE dst__24[16]; // [rsp+2A10h] [rbp+2390h] BYREF
  __int64 dst__25[2]; // [rsp+2A20h] [rbp+23A0h] BYREF
  _BYTE dst__26[16]; // [rsp+2A30h] [rbp+23B0h] BYREF
  __int64 n6_1; // [rsp+2A40h] [rbp+23C0h]

  v82 = 0;
  if ( AssetMeta::HasActorSubresource((__int64 *)(a1 + 0x138)) )
  {
    if ( *(_BYTE *)(a1 + 0x122) )
    {
      if ( Handle::IsValid((_QWORD *)(a1 + 0x830)) )
      {
        v541 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
        if ( (unsigned int)Mtx_getconcrtcs_w_2(v541) == 3 )
        {
          if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
          {
            v542 = *(_QWORD *)(a1 + 8);
            if ( sub_14030EC00(&v542) )
            {
              v163[0] = sub_142744750(0x1Cu);
              v163[1] = 0x51;
              src_[0] = v163;
              src_[1] = &v164;
              qmemcpy(dst_, src_, sizeof(dst_));
              v105 = invokeGlobalCallbackAndMaskStatusBits(
                       5,
                       (__int64)dst_,
                       (__int64)"Drive Cannot Tune",
                       "Linked jump point $$ is closing! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                       v77,
                       (_DWORD)v78,
                       v79);
              if ( (v105 & 0xFFFFF) != 0 )
              {
                v849[0] = 0;
                v849[1] = "CSCItemJumpDrive::CanTune";
                v849[2] = 0;
                v568 = v849;
                v543 = *(_QWORD *)(a1 + 8);
                v263 = sub_14030ECF0(&v543);
                v544 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v263 + 0x158LL);
                v23 = (_QWORD *)v544(v263, v971);
                v264 = sub_14030ECF0(v23);
                if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v264 + 0x648LL))(v264) )
                {
                  v545 = *(_QWORD *)(a1 + 8);
                  v265 = sub_14030ECF0(&v545);
                  v546 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v265 + 0x158LL);
                  v24 = (_QWORD *)v546(v265, v970);
                  v266 = sub_14030ECF0(v24);
                  v267 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v266 + 0x648LL))(v266);
                  p_NULL_ZONE = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v267 + 0x1F0LL))(v267);
                }
                else
                {
                  p_NULL_ZONE = "NULL ZONE";
                }
                v850[0] = 0;
                v850[1] = p_NULL_ZONE;
                v850[2] = 0;
                v569 = v850;
                v547 = *(_QWORD *)(a1 + 8);
                v269 = sub_14030ECF0(&v547);
                v548 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v269 + 0x158LL);
                v25 = (_QWORD *)v548(v269, v969);
                v270 = sub_14030ECF0(v25);
                v549 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v270 + 0x70LL))(v270);
                v851[0] = 0;
                v851[1] = v549;
                v851[2] = 0;
                v570 = v851;
                v550 = *(_QWORD *)(a1 + 8);
                v271 = sub_14030ECF0(&v550);
                v551 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v271 + 8LL);
                v552 = (__int64 *)v551(v271, v968);
                v553 = sub_1402A24F0(*v552);
                v933[0] = 0;
                v933[1] = v553;
                v934 = 0;
                v571 = v933;
                v554 = *(_QWORD *)(a1 + 8);
                v272 = sub_14030ECF0(&v554);
                v555 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v272 + 0x70LL))(v272);
                v852[0] = 0;
                v852[1] = v555;
                v852[2] = 0;
                v572 = v852;
                v273 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                v274 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v273 + 0xA0LL))(v273);
                v275 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v274 + 0x1D0LL))(v274);
                v558 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v275 + 0x100LL);
                v556 = *(_QWORD *)(a1 + 8);
                v557 = v556;
                v26 = (unsigned __int64 *)v558(v275, v967, v556);
                if ( sub_14030EC00(v26) )
                {
                  v276 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                  v277 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v276 + 0xA0LL))(v276);
                  v278 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v277 + 0x1D0LL))(v277);
                  v561 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v278 + 0x100LL);
                  v559 = *(_QWORD *)(a1 + 8);
                  v560 = v559;
                  v27 = (_QWORD *)v561(v278, v966, v559);
                  v279 = sub_14030ECF0(v27);
                  p_NULL_SYSTEM = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v279 + 0x70LL))(v279);
                }
                else
                {
                  p_NULL_SYSTEM = "NULL SYSTEM";
                }
                v853[0] = 0;
                v853[1] = p_NULL_SYSTEM;
                v853[2] = 0;
                v573 = v853;
                v562 = *(_QWORD *)(a1 + 8);
                v281 = sub_14030ECF0(&v562);
                if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v281 + 0x50LL))(v281) )
                {
                  v563 = *(_QWORD *)(a1 + 8);
                  v282 = sub_14030ECF0(&v563);
                  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v282 + 0x720LL))(v282) )
                    p_NOT_AUTH = "AUTH";
                  else
                    p_NOT_AUTH = "NOT AUTH";
                  p_NOT_INIT = p_NOT_AUTH;
                }
                else
                {
                  p_NOT_INIT = "NOT INIT";
                }
                p_NOT_INIT_1 = p_NOT_INIT;
                v285 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                v121 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v285 + 0x6B0LL))(v285);
                v564 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                if ( *(_BYTE *)(v564 + 0x5F5) )
                  p_SV = "CL";
                else
                  p_SV = "SV";
                v565 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                v566 = *(_QWORD *)(v565 + 8);
                v286 = sub_14030ECF0(&v566);
                v567 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v286 + 0x70LL))(v286);
                v854[0] = 0;
                v854[1] = v567;
                v854[2] = 0;
                v575 = v854;
                ThreadLogContextSlot = getThreadLogContextSlot();
                v898[0] = 0;
                v898[1] = 0;
                v165[0] = sub_142744750(0x1Cu);
                v165[1] = 0x51;
                src__1[0] = v165;
                src__1[1] = &v166;
                qmemcpy(dst__1, src__1, sizeof(dst__1));
                dst__11[3] = 0xB;
                v28 = alloca(0x4D0);
                v287 = v66;
                __Val_0__ = (vraudio::AudioBuffer *)v66;
                sub_143567340(
                  (unsigned int)v66,
                  (_DWORD)ThreadLogContextSlot,
                  (_DWORD)v575,
                  (_DWORD)p_SV,
                  (__int64)&v121,
                  (__int64)&p_NOT_INIT_1,
                  (__int64)v573,
                  (__int64)v572,
                  (__int64)v571,
                  (__int64)v570,
                  (__int64)v569,
                  (__int64)v568);
                LODWORD(v65) = v105;
                sub_1403045C0(
                  5u,
                  dst__1,
                  "Drive Cannot Tune",
                  "Linked jump point $$ is closing! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                  __Val_0__,
                  0xBu,
                  1,
                  v65,
                  v898,
                  0);
                sub_140370F70(v854);
                sub_140370F70(v853);
                sub_140370F70(v852);
                sub_140370F70(v851);
                sub_140370F70(v850);
                sub_140370F70(v849);
              }
            }
            else
            {
              v167[0] = sub_142744750(0x1Cu);
              v167[1] = 0x51;
              src__2[0] = v167;
              src__2[1] = &v168;
              qmemcpy(dst__2, src__2, sizeof(dst__2));
              v106 = invokeGlobalCallbackAndMaskStatusBits(
                       5,
                       (__int64)dst__2,
                       (__int64)"Drive Cannot Tune",
                       "Linked jump point $$ is closing! | %s%d | %s | $$",
                       v77,
                       (_DWORD)v78,
                       v79);
              if ( (v106 & 0xFFFFF) != 0 )
              {
                v847[0] = 0;
                v847[1] = "CSCItemJumpDrive::CanTune";
                v847[2] = 0;
                v581 = v847;
                v290 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                v122 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v290 + 0x6B0LL))(v290);
                v577 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                if ( *(_BYTE *)(v577 + 0x5F5) )
                  p_SV_1 = "CL";
                else
                  p_SV_1 = "SV";
                v578 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                v579 = *(_QWORD *)(v578 + 8);
                v291 = sub_14030ECF0(&v579);
                v580 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v291 + 0x70LL))(v291);
                v848[0] = 0;
                v848[1] = v580;
                v848[2] = 0;
                v582 = v848;
                ThreadLogContextSlot_1 = getThreadLogContextSlot();
                v901[0] = 0;
                v901[1] = 0;
                v169[0] = sub_142744750(0x1Cu);
                v169[1] = 0x51;
                src__3[0] = v169;
                src__3[1] = &v170;
                qmemcpy(dst__3, src__3, sizeof(dst__3));
                dst__11[2] = 6;
                v29 = alloca(0x2A0);
                v292 = v74;
                __Val_0___1 = (vraudio::AudioBuffer *)v74;
                sub_143567220(
                  (unsigned int)v74,
                  (_DWORD)ThreadLogContextSlot_1,
                  (_DWORD)v582,
                  (_DWORD)p_SV_1,
                  (__int64)&v122,
                  (__int64)"NULL ENTITY",
                  (__int64)v581);
                LODWORD(v73) = v106;
                sub_1403045C0(
                  5u,
                  dst__3,
                  "Drive Cannot Tune",
                  "Linked jump point $$ is closing! | %s%d | %s | $$",
                  __Val_0___1,
                  6u,
                  1,
                  v73,
                  v901,
                  0);
                sub_140370F70(v848);
                sub_140370F70(v847);
              }
            }
          }
          return 0;
        }
        else
        {
          v584 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
          v30 = sub_141E70C20(v584, &v1028);
          if ( Handle::IsValid(v30)
            && (v585 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL,
                v586 = sub_141E70C20(v585, &v1027),
                v587 = *v586 & 0xFFFFFFFFFFFFLL,
                (unsigned __int8)sub_143E73770(v587)) )
          {
            if ( *(float *)(a1 + 0x8A8) >= 1.0 )
            {
              v674 = a1 + 0xF10;
              v45 = sub_14031FF80(a1 + 0xF60);
              if ( sub_1415846D0(a1 + 0xF10, v45) )
              {
                if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
                {
                  v675 = *(_QWORD *)(a1 + 8);
                  if ( sub_14030EC00(&v675) )
                  {
                    v187[0] = sub_142744750(0x1Cu);
                    v187[1] = 0x51;
                    src__4[0] = v187;
                    src__4[1] = &v188;
                    qmemcpy(dst__4, src__4, sizeof(dst__4));
                    v111 = invokeGlobalCallbackAndMaskStatusBits(
                             5,
                             (__int64)dst__4,
                             (__int64)"Drive Cannot Tune",
                             "Ship $$ is too large for $$! Limit Size is %d, current size is %d | %s%d | %s | $$ | $$ [$$"
                             "] (adam: $$ in zone $$) | $$",
                             (_DWORD)v77,
                             (_DWORD)v78,
                             v79,
                             (_DWORD)v80,
                             v81);
                    if ( (v111 & 0xFFFFF) != 0 )
                    {
                      v824[0] = 0;
                      v824[1] = "CSCItemJumpDrive::CanTune";
                      v824[2] = 0;
                      v704 = v824;
                      v676 = *(_QWORD *)(a1 + 8);
                      v359 = sub_14030ECF0(&v676);
                      v677 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v359 + 0x158LL);
                      v46 = (_QWORD *)v677(v359, v1010);
                      v360 = sub_14030ECF0(v46);
                      if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v360 + 0x648LL))(v360) )
                      {
                        v678 = *(_QWORD *)(a1 + 8);
                        v361 = sub_14030ECF0(&v678);
                        v679 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v361 + 0x158LL);
                        v47 = (_QWORD *)v679(v361, v1008);
                        v362 = sub_14030ECF0(v47);
                        v363 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v362 + 0x648LL))(v362);
                        p_NULL_ZONE_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v363 + 0x1F0LL))(v363);
                      }
                      else
                      {
                        p_NULL_ZONE_1 = "NULL ZONE";
                      }
                      v825[0] = 0;
                      v825[1] = p_NULL_ZONE_1;
                      v825[2] = 0;
                      v705 = v825;
                      v680 = *(_QWORD *)(a1 + 8);
                      v365 = sub_14030ECF0(&v680);
                      v681 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v365 + 0x158LL);
                      v48 = (_QWORD *)v681(v365, v1007);
                      v366 = sub_14030ECF0(v48);
                      v682 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v366 + 0x70LL))(v366);
                      v826[0] = 0;
                      v826[1] = v682;
                      v826[2] = 0;
                      v706 = v826;
                      v683 = *(_QWORD *)(a1 + 8);
                      v367 = sub_14030ECF0(&v683);
                      v684 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v367 + 8LL);
                      v685 = (__int64 *)v684(v367, v1006);
                      v686 = sub_1402A24F0(*v685);
                      v939[0] = 0;
                      v939[1] = v686;
                      v940 = 0;
                      v707 = v939;
                      v687 = *(_QWORD *)(a1 + 8);
                      v368 = sub_14030ECF0(&v687);
                      v688 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v368 + 0x70LL))(v368);
                      v827[0] = 0;
                      v827[1] = v688;
                      v827[2] = 0;
                      v708 = v827;
                      v369 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                      v370 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v369 + 0xA0LL))(v369);
                      v371 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v370 + 0x1D0LL))(v370);
                      v691 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v371 + 0x100LL);
                      v689 = *(_QWORD *)(a1 + 8);
                      v690 = v689;
                      v49 = (unsigned __int64 *)v691(v371, v1005, v689);
                      if ( sub_14030EC00(v49) )
                      {
                        v372 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                        v373 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v372 + 0xA0LL))(v372);
                        v417 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v373 + 0x1D0LL))(v373);
                        v694 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v417 + 0x100LL);
                        v692 = *(_QWORD *)(a1 + 8);
                        v693 = v692;
                        v50 = (_QWORD *)v694(v417, v1004, v692);
                        v375 = sub_14030ECF0(v50);
                        p_NULL_SYSTEM_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v375 + 0x70LL))(v375);
                      }
                      else
                      {
                        p_NULL_SYSTEM_1 = "NULL SYSTEM";
                      }
                      v828[0] = 0;
                      v828[1] = p_NULL_SYSTEM_1;
                      v828[2] = 0;
                      v709 = v828;
                      v695 = *(_QWORD *)(a1 + 8);
                      v377 = sub_14030ECF0(&v695);
                      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v377 + 0x50LL))(v377) )
                      {
                        v696 = *(_QWORD *)(a1 + 8);
                        v378 = sub_14030ECF0(&v696);
                        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v378 + 0x720LL))(v378) )
                          p_NOT_AUTH_1 = "AUTH";
                        else
                          p_NOT_AUTH_1 = "NOT AUTH";
                        p_NOT_INIT_2 = p_NOT_AUTH_1;
                      }
                      else
                      {
                        p_NOT_INIT_2 = "NOT INIT";
                      }
                      p_NOT_INIT_3 = p_NOT_INIT_2;
                      v381 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                      v127 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v381 + 0x6B0LL))(v381);
                      v697 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                      if ( *(_BYTE *)(v697 + 0x5F5) )
                        p_SV_2 = "CL";
                      else
                        p_SV_2 = "SV";
                      v711 = sub_14031FF80(a1 + 0xF10);
                      v712 = sub_14031FF80(a1 + 0xF60);
                      v698 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                      v699 = *(_QWORD *)(v698 + 8);
                      v382 = sub_14030ECF0(&v699);
                      v700 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v382 + 0x70LL))(v382);
                      v829[0] = 0;
                      v829[1] = v700;
                      v829[2] = 0;
                      v713 = v829;
                      v701 = *(_QWORD *)(a1 + 0x138) & 0xFFFFFFFFFFFFLL;
                      v702 = *(_QWORD *)(v701 + 8);
                      v383 = sub_14030ECF0(&v702);
                      v703 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v383 + 0x70LL))(v383);
                      v838[0] = 0;
                      v838[1] = v703;
                      v838[2] = 0;
                      v714 = v838;
                      ThreadLogContextSlot_2 = getThreadLogContextSlot();
                      v916[0] = 0;
                      v916[1] = 0;
                      v189[0] = sub_142744750(0x1Cu);
                      v189[1] = 0x51;
                      src__5[0] = v189;
                      src__5[1] = &v190;
                      qmemcpy(dst__5, src__5, sizeof(dst__5));
                      n0xE = 0xE;
                      v51 = alloca(0x620);
                      v384 = v62;
                      __Val_0___2 = (vraudio::AudioBuffer *)v62;
                      sub_1435688C0(
                        (unsigned int)v62,
                        (_DWORD)ThreadLogContextSlot_2,
                        (_DWORD)v714,
                        (_DWORD)v713,
                        (__int64)&v712,
                        (__int64)&v711,
                        (__int64)p_SV_2,
                        (__int64)&v127,
                        (__int64)&p_NOT_INIT_3,
                        (__int64)v709,
                        (__int64)v708,
                        (__int64)v707,
                        (__int64)v706,
                        (__int64)v705,
                        (__int64)v704);
                      LODWORD(v60) = v111;
                      sub_1403045C0(
                        5u,
                        dst__5,
                        "Drive Cannot Tune",
                        "Ship $$ is too large for $$! Limit Size is %d, current size is %d | %s%d | %s | $$ | $$ [$$] (ad"
                        "am: $$ in zone $$) | $$",
                        __Val_0___2,
                        0xEu,
                        1,
                        v60,
                        v916,
                        0);
                      sub_140370F70(v838);
                      sub_140370F70(v829);
                      sub_140370F70(v828);
                      sub_140370F70(v827);
                      sub_140370F70(v826);
                      sub_140370F70(v825);
                      sub_140370F70(v824);
                    }
                  }
                  else
                  {
                    v191[0] = sub_142744750(0x1Cu);
                    v191[1] = 0x51;
                    src__6[0] = v191;
                    src__6[1] = &v192;
                    qmemcpy(dst__6, src__6, sizeof(dst__6));
                    v112 = invokeGlobalCallbackAndMaskStatusBits(
                             5,
                             (__int64)dst__6,
                             (__int64)"Drive Cannot Tune",
                             "Ship $$ is too large for $$! Limit Size is %d, current size is %d | %s%d | %s | $$",
                             (_DWORD)v77,
                             (_DWORD)v78,
                             v79,
                             (_DWORD)v80,
                             v81);
                    if ( (v112 & 0xFFFFF) != 0 )
                    {
                      v821[0] = 0;
                      v821[1] = "CSCItemJumpDrive::CanTune";
                      v821[2] = 0;
                      v723 = v821;
                      v387 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                      v128 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v387 + 0x6B0LL))(v387);
                      v716 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                      if ( *(_BYTE *)(v716 + 0x5F5) )
                        p_SV_3 = "CL";
                      else
                        p_SV_3 = "SV";
                      v724 = sub_14031FF80(a1 + 0xF10);
                      v725 = sub_14031FF80(a1 + 0xF60);
                      v717 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                      v718 = *(_QWORD *)(v717 + 8);
                      v388 = sub_14030ECF0(&v718);
                      v719 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v388 + 0x70LL))(v388);
                      v822[0] = 0;
                      v822[1] = v719;
                      v822[2] = 0;
                      v726 = v822;
                      v720 = *(_QWORD *)(a1 + 0x138) & 0xFFFFFFFFFFFFLL;
                      v721 = *(_QWORD *)(v720 + 8);
                      v389 = sub_14030ECF0(&v721);
                      v722 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v389 + 0x70LL))(v389);
                      v823[0] = 0;
                      v823[1] = v722;
                      v823[2] = 0;
                      v727 = v823;
                      ThreadLogContextSlot_3 = getThreadLogContextSlot();
                      v918[0] = 0;
                      v918[1] = 0;
                      v193[0] = sub_142744750(0x1Cu);
                      v193[1] = 0x51;
                      src__7[0] = v193;
                      src__7[1] = &v194;
                      qmemcpy(dst__7, src__7, sizeof(dst__7));
                      n9 = 9;
                      v52 = alloca(0x3F0);
                      v390 = v70;
                      __Val_0___3 = (vraudio::AudioBuffer *)v70;
                      sub_143568770(
                        (unsigned int)v70,
                        (_DWORD)ThreadLogContextSlot_3,
                        (_DWORD)v727,
                        (_DWORD)v726,
                        (__int64)&v725,
                        (__int64)&v724,
                        (__int64)p_SV_3,
                        (__int64)&v128,
                        (__int64)"NULL ENTITY",
                        (__int64)v723);
                      LODWORD(v69) = v112;
                      sub_1403045C0(
                        5u,
                        dst__7,
                        "Drive Cannot Tune",
                        "Ship $$ is too large for $$! Limit Size is %d, current size is %d | %s%d | %s | $$",
                        __Val_0___3,
                        9u,
                        1,
                        v69,
                        v918,
                        0);
                      sub_140370F70(v823);
                      sub_140370F70(v822);
                      sub_140370F70(v821);
                    }
                  }
                }
                return 0;
              }
              else
              {
                if ( !is_valid_handle_typeA((__int64 *)(a1 + 0x148)) )
                  return 1;
                v393 = *(_QWORD *)(a1 + 0x148) & 0xFFFFFFFFFFFFLL;
                v129 = (*(float (__fastcall **)(__int64))(*(_QWORD *)v393 + 0x5D0LL))(v393);
                if ( v129 >= sub_1415361F0(a1 + 0xDF0) || dword_149E26FC4 )
                {
                  return 1;
                }
                else
                {
                  if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
                  {
                    v729 = *(_QWORD *)(a1 + 8);
                    if ( sub_14030EC00(&v729) )
                    {
                      v195[0] = sub_142744750(0x1Cu);
                      v195[1] = 0x51;
                      src__8[0] = v195;
                      src__8[1] = &v196;
                      qmemcpy(dst__8, src__8, sizeof(dst__8));
                      v113 = invokeGlobalCallbackAndMaskStatusBits(
                               5,
                               (__int64)dst__8,
                               (__int64)"Drive Cannot Tune",
                               "Ship $$ does not have enough Quantum Fuel for Jump Point $$! Required fuel is %.2f, curre"
                               "nt fuel is %.2f | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                               *(double *)&v77,
                               *(double *)&v78,
                               v79,
                               (_DWORD)v80,
                               v81);
                      if ( (v113 & 0xFFFFF) != 0 )
                      {
                        v814[0] = 0;
                        v814[1] = "CSCItemJumpDrive::CanTune";
                        v814[2] = 0;
                        v759 = v814;
                        v730 = *(_QWORD *)(a1 + 8);
                        v394 = sub_14030ECF0(&v730);
                        v731 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v394 + 0x158LL);
                        v53 = (_QWORD *)v731(v394, v1001);
                        v395 = sub_14030ECF0(v53);
                        if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v395 + 0x648LL))(v395) )
                        {
                          v732 = *(_QWORD *)(a1 + 8);
                          v396 = sub_14030ECF0(&v732);
                          v733 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v396 + 0x158LL);
                          v54 = (_QWORD *)v733(v396, v1009);
                          v397 = sub_14030ECF0(v54);
                          v398 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v397 + 0x648LL))(v397);
                          p_NULL_ZONE_2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v398 + 0x1F0LL))(v398);
                        }
                        else
                        {
                          p_NULL_ZONE_2 = "NULL ZONE";
                        }
                        v815[0] = 0;
                        v815[1] = p_NULL_ZONE_2;
                        v815[2] = 0;
                        v760 = v815;
                        v734 = *(_QWORD *)(a1 + 8);
                        v400 = sub_14030ECF0(&v734);
                        v735 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v400 + 0x158LL);
                        v55 = (_QWORD *)v735(v400, v1000);
                        v401 = sub_14030ECF0(v55);
                        v736 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v401 + 0x70LL))(v401);
                        v816[0] = 0;
                        v816[1] = v736;
                        v816[2] = 0;
                        v761 = v816;
                        v737 = *(_QWORD *)(a1 + 8);
                        v402 = sub_14030ECF0(&v737);
                        v738 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v402 + 8LL);
                        v739 = (__int64 *)v738(v402, v999);
                        v740 = sub_1402A24F0(*v739);
                        v925[0] = 0;
                        v925[1] = v740;
                        v926 = 0;
                        v762 = v925;
                        v741 = *(_QWORD *)(a1 + 8);
                        v403 = sub_14030ECF0(&v741);
                        v742 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v403 + 0x70LL))(v403);
                        v817[0] = 0;
                        v817[1] = v742;
                        v817[2] = 0;
                        v763 = v817;
                        v404 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                        v405 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v404 + 0xA0LL))(v404);
                        v406 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v405 + 0x1D0LL))(v405);
                        v745 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v406 + 0x100LL);
                        v743 = *(_QWORD *)(a1 + 8);
                        v744 = v743;
                        v56 = (unsigned __int64 *)v745(v406, v998, v743);
                        if ( sub_14030EC00(v56) )
                        {
                          v407 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                          v408 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v407 + 0xA0LL))(v407);
                          v409 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v408 + 0x1D0LL))(v408);
                          v748 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v409 + 0x100LL);
                          v746 = *(_QWORD *)(a1 + 8);
                          v747 = v746;
                          v57 = (_QWORD *)v748(v409, v997, v746);
                          v410 = sub_14030ECF0(v57);
                          p_NULL_SYSTEM_2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v410 + 0x70LL))(v410);
                        }
                        else
                        {
                          p_NULL_SYSTEM_2 = "NULL SYSTEM";
                        }
                        v818[0] = 0;
                        v818[1] = p_NULL_SYSTEM_2;
                        v818[2] = 0;
                        v764 = v818;
                        v749 = *(_QWORD *)(a1 + 8);
                        v412 = sub_14030ECF0(&v749);
                        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v412 + 0x50LL))(v412) )
                        {
                          v750 = *(_QWORD *)(a1 + 8);
                          v413 = sub_14030ECF0(&v750);
                          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v413 + 0x720LL))(v413) )
                            p_NOT_AUTH_2 = "AUTH";
                          else
                            p_NOT_AUTH_2 = "NOT AUTH";
                          p_NOT_INIT_4 = p_NOT_AUTH_2;
                        }
                        else
                        {
                          p_NOT_INIT_4 = "NOT INIT";
                        }
                        p_NOT_INIT_5 = p_NOT_INIT_4;
                        v416 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                        v130 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v416 + 0x6B0LL))(v416);
                        v751 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                        if ( *(_BYTE *)(v751 + 0x5F5) )
                          p_SV_4 = "CL";
                        else
                          p_SV_4 = "SV";
                        v460 = *(_QWORD *)(a1 + 0x148) & 0xFFFFFFFFFFFFLL;
                        v131 = (*(float (__fastcall **)(__int64))(*(_QWORD *)v460 + 0x5D0LL))(v460);
                        v132 = sub_1415361F0(a1 + 0xDF0);
                        v752 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                        v753 = *(_QWORD *)(v752 + 8);
                        v418 = sub_14030ECF0(&v753);
                        v754 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v418 + 0x70LL))(v418);
                        v819[0] = 0;
                        v819[1] = v754;
                        v819[2] = 0;
                        v766 = v819;
                        v755 = *(_QWORD *)(a1 + 0x138) & 0xFFFFFFFFFFFFLL;
                        v756 = *(_QWORD *)(v755 + 8);
                        v419 = sub_14030ECF0(&v756);
                        v757 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v419 + 0x70LL))(v419);
                        v820[0] = 0;
                        v820[1] = v757;
                        v820[2] = 0;
                        v767 = v820;
                        ThreadLogContextSlot_4 = getThreadLogContextSlot();
                        v921[0] = 0;
                        v921[1] = 0;
                        v197[0] = sub_142744750(0x1Cu);
                        v197[1] = 0x51;
                        src__9[0] = v197;
                        src__9[1] = &v198;
                        qmemcpy(dst__9, src__9, sizeof(dst__9));
                        n0xE_1 = 0xE;
                        v58 = alloca(0x620);
                        v420 = v62;
                        __Val_0___4 = (vraudio::AudioBuffer *)v62;
                        v62[0] = ThreadLogContextSlot_4;
                        v62[1] = sub_1403B3E60();
                        *((_BYTE *)__Val_0___4 + 0x59) = 1;
                        *((_QWORD *)__Val_0___4 + 2) = 0;
                        *((_QWORD *)__Val_0___4 + 3) = sub_1403EB6A0;
                        *((_QWORD *)__Val_0___4 + 4) = sub_1403EB240;
                        *((_QWORD *)__Val_0___4 + 5) = 0;
                        *((_QWORD *)__Val_0___4 + 6) = sub_1403E77F0;
                        *((_QWORD *)__Val_0___4 + 7) = 0;
                        *((_QWORD *)__Val_0___4 + 8) = sub_1403E4E60;
                        *((_QWORD *)__Val_0___4 + 9) = allocWithProfilerInfo_ww;
                        *((_QWORD *)__Val_0___4 + 0xA) = 0xFFFFFFFFFFFFFFFFuLL;
                        *((_BYTE *)__Val_0___4 + 0x58) = 0;
                        *((_QWORD *)__Val_0___4 + 0xC) = 0xB0;
                        *((_QWORD *)__Val_0___4 + 0xD) = 0xA8;
                        sub_14356E3C0(
                          (_DWORD)__Val_0___4 + 0x70,
                          (_DWORD)v767,
                          (_DWORD)v766,
                          (unsigned int)&v132,
                          (__int64)&v131,
                          (__int64)p_SV_4,
                          (__int64)&v130,
                          (__int64)&p_NOT_INIT_5,
                          (__int64)v764,
                          (__int64)v763,
                          (__int64)v762,
                          (__int64)v761,
                          (__int64)v760,
                          (__int64)v759);
                        LODWORD(v61) = v113;
                        sub_1403045C0(
                          5u,
                          dst__9,
                          "Drive Cannot Tune",
                          "Ship $$ does not have enough Quantum Fuel for Jump Point $$! Required fuel is %.2f, current fu"
                          "el is %.2f | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                          __Val_0___4,
                          0xEu,
                          1,
                          v61,
                          v921,
                          0);
                        sub_140370F70(v820);
                        sub_140370F70(v819);
                        sub_140370F70(v818);
                        sub_140370F70(v817);
                        sub_140370F70(v816);
                        sub_140370F70(v815);
                        sub_140370F70(v814);
                      }
                    }
                    else
                    {
                      v199[0] = sub_142744750(0x1Cu);
                      v199[1] = 0x51;
                      src__10[0] = v199;
                      src__10[1] = &v200;
                      qmemcpy(dst__10, src__10, sizeof(dst__10));
                      v114 = invokeGlobalCallbackAndMaskStatusBits(
                               5,
                               (__int64)dst__10,
                               (__int64)"Drive Cannot Tune",
                               "Ship $$ does not have enough Quantum Fuel for Jump Point $$! Required fuel is %.2f, curre"
                               "nt fuel is %.2f | %s%d | %s | $$",
                               *(double *)&v77,
                               *(double *)&v78,
                               v79,
                               (_DWORD)v80,
                               v81);
                      if ( (v114 & 0xFFFFF) != 0 )
                      {
                        v811[0] = 0;
                        v811[1] = "CSCItemJumpDrive::CanTune";
                        v811[2] = 0;
                        v775 = v811;
                        v422 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                        v133 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v422 + 0x6B0LL))(v422);
                        v768 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                        if ( *(_BYTE *)(v768 + 0x5F5) )
                          p_SV_5 = "CL";
                        else
                          p_SV_5 = "SV";
                        v423 = *(_QWORD *)(a1 + 0x148) & 0xFFFFFFFFFFFFLL;
                        v134 = (*(float (__fastcall **)(__int64))(*(_QWORD *)v423 + 0x5D0LL))(v423);
                        v135 = sub_1415361F0(a1 + 0xDF0);
                        v769 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                        v770 = *(_QWORD *)(v769 + 8);
                        v424 = sub_14030ECF0(&v770);
                        v771 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v424 + 0x70LL))(v424);
                        v812[0] = 0;
                        v812[1] = v771;
                        v812[2] = 0;
                        v776 = v812;
                        v772 = *(_QWORD *)(a1 + 0x138) & 0xFFFFFFFFFFFFLL;
                        v773 = *(_QWORD *)(v772 + 8);
                        v425 = sub_14030ECF0(&v773);
                        v774 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v425 + 0x70LL))(v425);
                        v813[0] = 0;
                        v813[1] = v774;
                        v813[2] = 0;
                        v777 = v813;
                        ThreadLogContextSlot_5 = getThreadLogContextSlot();
                        v924[0] = 0;
                        v924[1] = 0;
                        v137[0] = sub_142744750(0x1Cu);
                        v137[1] = 0x51;
                        src__11[0] = v137;
                        src__11[1] = &v138;
                        qmemcpy(dst__11, src__11, 0x10u);
                        n9_1 = 9;
                        v59 = alloca(0x3F0);
                        v426 = v70;
                        __Val_0___5 = (vraudio::AudioBuffer *)v70;
                        sub_143568000(
                          (unsigned int)v70,
                          (_DWORD)ThreadLogContextSlot_5,
                          (_DWORD)v777,
                          (_DWORD)v776,
                          (__int64)&v135,
                          (__int64)&v134,
                          (__int64)p_SV_5,
                          (__int64)&v133,
                          (__int64)"NULL ENTITY",
                          (__int64)v775);
                        LODWORD(v69) = v114;
                        sub_1403045C0(
                          5u,
                          dst__11,
                          "Drive Cannot Tune",
                          "Ship $$ does not have enough Quantum Fuel for Jump Point $$! Required fuel is %.2f, current fu"
                          "el is %.2f | %s%d | %s | $$",
                          __Val_0___5,
                          9u,
                          1,
                          v69,
                          v924,
                          0);
                        sub_140370F70(v813);
                        sub_140370F70(v812);
                        sub_140370F70(v811);
                      }
                    }
                  }
                  return 0;
                }
              }
            }
            else
            {
              if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
              {
                v630 = *(_QWORD *)(a1 + 8);
                if ( sub_14030EC00(&v630) )
                {
                  v179[0] = sub_142744750(0x1Cu);
                  v179[1] = 0x51;
                  src__12[0] = v179;
                  src__12[1] = &v180;
                  qmemcpy(dst__12, src__12, sizeof(dst__12));
                  v109 = invokeGlobalCallbackAndMaskStatusBits(
                           5,
                           (__int64)dst__12,
                           (__int64)"Drive Cannot Tune",
                           "Not fully aligned to $$! Only %.2f aligned | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                           *(double *)&v77,
                           v78,
                           (_DWORD)v79,
                           v80);
                  if ( (v109 & 0xFFFFF) != 0 )
                  {
                    v832[0] = 0;
                    v832[1] = "CSCItemJumpDrive::CanTune";
                    v832[2] = 0;
                    v656 = v832;
                    v631 = *(_QWORD *)(a1 + 8);
                    v327 = sub_14030ECF0(&v631);
                    v632 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v327 + 0x158LL);
                    v38 = (_QWORD *)v632(v327, v1018);
                    v328 = sub_14030ECF0(v38);
                    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v328 + 0x648LL))(v328) )
                    {
                      v633 = *(_QWORD *)(a1 + 8);
                      v329 = sub_14030ECF0(&v633);
                      v634 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v329 + 0x158LL);
                      v39 = (_QWORD *)v634(v329, v1017);
                      v330 = sub_14030ECF0(v39);
                      v331 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v330 + 0x648LL))(v330);
                      p_NULL_ZONE_3 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v331 + 0x1F0LL))(v331);
                    }
                    else
                    {
                      p_NULL_ZONE_3 = "NULL ZONE";
                    }
                    v833[0] = 0;
                    v833[1] = p_NULL_ZONE_3;
                    v833[2] = 0;
                    v657 = v833;
                    v635 = *(_QWORD *)(a1 + 8);
                    v333 = sub_14030ECF0(&v635);
                    v636 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v333 + 0x158LL);
                    v40 = (_QWORD *)v636(v333, v1016);
                    v334 = sub_14030ECF0(v40);
                    v637 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v334 + 0x70LL))(v334);
                    v834[0] = 0;
                    v834[1] = v637;
                    v834[2] = 0;
                    v658 = v834;
                    v638 = *(_QWORD *)(a1 + 8);
                    v335 = sub_14030ECF0(&v638);
                    v639 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v335 + 8LL);
                    v640 = (__int64 *)v639(v335, v1015);
                    v641 = sub_1402A24F0(*v640);
                    v937[0] = 0;
                    v937[1] = v641;
                    v938 = 0;
                    v659 = v937;
                    v642 = *(_QWORD *)(a1 + 8);
                    v336 = sub_14030ECF0(&v642);
                    v643 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v336 + 0x70LL))(v336);
                    v835[0] = 0;
                    v835[1] = v643;
                    v835[2] = 0;
                    v660 = v835;
                    v337 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                    v338 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v337 + 0xA0LL))(v337);
                    v339 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v338 + 0x1D0LL))(v338);
                    v646 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v339 + 0x100LL);
                    v644 = *(_QWORD *)(a1 + 8);
                    v645 = v644;
                    v41 = (unsigned __int64 *)v646(v339, v1014, v644);
                    if ( sub_14030EC00(v41) )
                    {
                      v340 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                      v341 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v340 + 0xA0LL))(v340);
                      v342 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v341 + 0x1D0LL))(v341);
                      v649 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v342 + 0x100LL);
                      v647 = *(_QWORD *)(a1 + 8);
                      v648 = v647;
                      v42 = (_QWORD *)v649(v342, v1013, v647);
                      v343 = sub_14030ECF0(v42);
                      p_NULL_SYSTEM_3 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v343 + 0x70LL))(v343);
                    }
                    else
                    {
                      p_NULL_SYSTEM_3 = "NULL SYSTEM";
                    }
                    v836[0] = 0;
                    v836[1] = p_NULL_SYSTEM_3;
                    v836[2] = 0;
                    v661 = v836;
                    v650 = *(_QWORD *)(a1 + 8);
                    v345 = sub_14030ECF0(&v650);
                    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v345 + 0x50LL))(v345) )
                    {
                      v651 = *(_QWORD *)(a1 + 8);
                      v346 = sub_14030ECF0(&v651);
                      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v346 + 0x720LL))(v346) )
                        p_NOT_AUTH_3 = "AUTH";
                      else
                        p_NOT_AUTH_3 = "NOT AUTH";
                      p_NOT_INIT_6 = p_NOT_AUTH_3;
                    }
                    else
                    {
                      p_NOT_INIT_6 = "NOT INIT";
                    }
                    p_NOT_INIT_7 = p_NOT_INIT_6;
                    v349 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                    v125 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v349 + 0x6B0LL))(v349);
                    v652 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                    if ( *(_BYTE *)(v652 + 0x5F5) )
                      p_SV_6 = "CL";
                    else
                      p_SV_6 = "SV";
                    v663 = a1 + 0x8A8;
                    v653 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                    v654 = *(_QWORD *)(v653 + 8);
                    v350 = sub_14030ECF0(&v654);
                    v655 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v350 + 0x70LL))(v350);
                    v837[0] = 0;
                    v837[1] = v655;
                    v837[2] = 0;
                    v664 = v837;
                    ThreadLogContextSlot_6 = getThreadLogContextSlot();
                    v910[0] = 0;
                    v910[1] = 0;
                    v181[0] = sub_142744750(0x1Cu);
                    v181[1] = 0x51;
                    src__13[0] = v181;
                    src__13[1] = &v182;
                    qmemcpy(dst__13, src__13, sizeof(dst__13));
                    n0xC = 0xC;
                    v43 = alloca(0x540);
                    v351 = v64;
                    __Val_0___6 = (vraudio::AudioBuffer *)v64;
                    sub_1435675E0(
                      (unsigned int)v64,
                      (_DWORD)ThreadLogContextSlot_6,
                      (_DWORD)v664,
                      v663,
                      (__int64)p_SV_6,
                      (__int64)&v125,
                      (__int64)&p_NOT_INIT_7,
                      (__int64)v661,
                      (__int64)v660,
                      (__int64)v659,
                      (__int64)v658,
                      (__int64)v657,
                      (__int64)v656);
                    LODWORD(v63) = v109;
                    sub_1403045C0(
                      5u,
                      dst__13,
                      "Drive Cannot Tune",
                      "Not fully aligned to $$! Only %.2f aligned | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                      __Val_0___6,
                      0xCu,
                      1,
                      v63,
                      v910,
                      0);
                    sub_140370F70(v837);
                    sub_140370F70(v836);
                    sub_140370F70(v835);
                    sub_140370F70(v834);
                    sub_140370F70(v833);
                    sub_140370F70(v832);
                  }
                }
                else
                {
                  v183[0] = sub_142744750(0x1Cu);
                  v183[1] = 0x51;
                  src__14[0] = v183;
                  src__14[1] = &v184;
                  qmemcpy(dst__14, src__14, sizeof(dst__14));
                  v110 = invokeGlobalCallbackAndMaskStatusBits(
                           5,
                           (__int64)dst__14,
                           (__int64)"Drive Cannot Tune",
                           "Not fully aligned to $$! Only %.2f aligned | %s%d | %s | $$",
                           *(double *)&v77,
                           v78,
                           (_DWORD)v79,
                           v80);
                  if ( (v110 & 0xFFFFF) != 0 )
                  {
                    v830[0] = 0;
                    v830[1] = "CSCItemJumpDrive::CanTune";
                    v830[2] = 0;
                    v670 = v830;
                    v354 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                    v126 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v354 + 0x6B0LL))(v354);
                    v666 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                    if ( *(_BYTE *)(v666 + 0x5F5) )
                      p_SV_7 = "CL";
                    else
                      p_SV_7 = "SV";
                    v671 = a1 + 0x8A8;
                    v667 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                    v668 = *(_QWORD *)(v667 + 8);
                    v355 = sub_14030ECF0(&v668);
                    v669 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v355 + 0x70LL))(v355);
                    v831[0] = 0;
                    v831[1] = v669;
                    v831[2] = 0;
                    v672 = v831;
                    ThreadLogContextSlot_7 = getThreadLogContextSlot();
                    v913[0] = 0;
                    v913[1] = 0;
                    v185[0] = sub_142744750(0x1Cu);
                    v185[1] = 0x51;
                    src__15[0] = v185;
                    src__15[1] = &v186;
                    qmemcpy(dst__15, src__15, sizeof(dst__15));
                    n7 = 7;
                    v44 = alloca(0x310);
                    v356 = v72;
                    __Val_0___7 = (vraudio::AudioBuffer *)v72;
                    sub_1435674B0(
                      (unsigned int)v72,
                      (_DWORD)ThreadLogContextSlot_7,
                      (_DWORD)v672,
                      v671,
                      (__int64)p_SV_7,
                      (__int64)&v126,
                      (__int64)"NULL ENTITY",
                      (__int64)v670);
                    LODWORD(v71) = v110;
                    sub_1403045C0(
                      5u,
                      dst__15,
                      "Drive Cannot Tune",
                      "Not fully aligned to $$! Only %.2f aligned | %s%d | %s | $$",
                      __Val_0___7,
                      7u,
                      1,
                      v71,
                      v913,
                      0);
                    sub_140370F70(v831);
                    sub_140370F70(v830);
                  }
                }
              }
              return 0;
            }
          }
          else
          {
            if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
            {
              v588 = *(_QWORD *)(a1 + 8);
              if ( sub_14030EC00(&v588) )
              {
                v171[0] = sub_142744750(0x1Cu);
                v171[1] = 0x51;
                src__16[0] = v171;
                src__16[1] = &v172;
                qmemcpy(dst__16, src__16, sizeof(dst__16));
                v107 = invokeGlobalCallbackAndMaskStatusBits(
                         5,
                         (__int64)dst__16,
                         (__int64)"Drive Cannot Tune",
                         "Linked jump point $$ has no valid tunnel host! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                         v77,
                         (_DWORD)v78,
                         v79);
                if ( (v107 & 0xFFFFF) != 0 )
                {
                  v841[0] = 0;
                  v841[1] = "CSCItemJumpDrive::CanTune";
                  v841[2] = 0;
                  v614 = v841;
                  v589 = *(_QWORD *)(a1 + 8);
                  v295 = sub_14030ECF0(&v589);
                  v590 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v295 + 0x158LL);
                  v31 = (_QWORD *)v590(v295, v1026);
                  v296 = sub_14030ECF0(v31);
                  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v296 + 0x648LL))(v296) )
                  {
                    v591 = *(_QWORD *)(a1 + 8);
                    v297 = sub_14030ECF0(&v591);
                    v592 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v297 + 0x158LL);
                    v32 = (_QWORD *)v592(v297, v1025);
                    v298 = sub_14030ECF0(v32);
                    v299 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v298 + 0x648LL))(v298);
                    p_NULL_ZONE_4 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v299 + 0x1F0LL))(v299);
                  }
                  else
                  {
                    p_NULL_ZONE_4 = "NULL ZONE";
                  }
                  v842[0] = 0;
                  v842[1] = p_NULL_ZONE_4;
                  v842[2] = 0;
                  v615 = v842;
                  v593 = *(_QWORD *)(a1 + 8);
                  v301 = sub_14030ECF0(&v593);
                  v594 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v301 + 0x158LL);
                  v33 = (_QWORD *)v594(v301, v1024);
                  v302 = sub_14030ECF0(v33);
                  v595 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v302 + 0x70LL))(v302);
                  v843[0] = 0;
                  v843[1] = v595;
                  v843[2] = 0;
                  v616 = v843;
                  v596 = *(_QWORD *)(a1 + 8);
                  v303 = sub_14030ECF0(&v596);
                  v597 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v303 + 8LL);
                  v598 = (__int64 *)v597(v303, v1023);
                  v599 = sub_1402A24F0(*v598);
                  v935[0] = 0;
                  v935[1] = v599;
                  v936 = 0;
                  v617 = v935;
                  v600 = *(_QWORD *)(a1 + 8);
                  v304 = sub_14030ECF0(&v600);
                  v601 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v304 + 0x70LL))(v304);
                  v844[0] = 0;
                  v844[1] = v601;
                  v844[2] = 0;
                  v618 = v844;
                  v305 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                  v306 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v305 + 0xA0LL))(v305);
                  v307 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v306 + 0x1D0LL))(v306);
                  v604 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v307 + 0x100LL);
                  v602 = *(_QWORD *)(a1 + 8);
                  v603 = v602;
                  v34 = (unsigned __int64 *)v604(v307, v1022, v602);
                  if ( sub_14030EC00(v34) )
                  {
                    v308 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                    v309 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v308 + 0xA0LL))(v308);
                    v310 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v309 + 0x1D0LL))(v309);
                    v607 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v310 + 0x100LL);
                    v605 = *(_QWORD *)(a1 + 8);
                    v606 = v605;
                    v35 = (_QWORD *)v607(v310, v1021, v605);
                    v311 = sub_14030ECF0(v35);
                    p_NULL_SYSTEM_4 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v311 + 0x70LL))(v311);
                  }
                  else
                  {
                    p_NULL_SYSTEM_4 = "NULL SYSTEM";
                  }
                  v845[0] = 0;
                  v845[1] = p_NULL_SYSTEM_4;
                  v845[2] = 0;
                  v619 = v845;
                  v608 = *(_QWORD *)(a1 + 8);
                  v313 = sub_14030ECF0(&v608);
                  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v313 + 0x50LL))(v313) )
                  {
                    v609 = *(_QWORD *)(a1 + 8);
                    v314 = sub_14030ECF0(&v609);
                    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v314 + 0x720LL))(v314) )
                      p_NOT_AUTH_4 = "AUTH";
                    else
                      p_NOT_AUTH_4 = "NOT AUTH";
                    p_NOT_INIT_8 = p_NOT_AUTH_4;
                  }
                  else
                  {
                    p_NOT_INIT_8 = "NOT INIT";
                  }
                  p_NOT_INIT_9 = p_NOT_INIT_8;
                  v317 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                  v123 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v317 + 0x6B0LL))(v317);
                  v610 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                  if ( *(_BYTE *)(v610 + 0x5F5) )
                    p_SV_8 = "CL";
                  else
                    p_SV_8 = "SV";
                  v611 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                  v612 = *(_QWORD *)(v611 + 8);
                  v318 = sub_14030ECF0(&v612);
                  v613 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v318 + 0x70LL))(v318);
                  v846[0] = 0;
                  v846[1] = v613;
                  v846[2] = 0;
                  v621 = v846;
                  ThreadLogContextSlot_8 = getThreadLogContextSlot();
                  v904[0] = 0;
                  v904[1] = 0;
                  v173[0] = sub_142744750(0x1Cu);
                  v173[1] = 0x51;
                  src__17[0] = v173;
                  src__17[1] = &v174;
                  qmemcpy(dst__17, src__17, sizeof(dst__17));
                  n0xB = 0xB;
                  v36 = alloca(0x4D0);
                  v319 = v66;
                  __Val_0___8 = (vraudio::AudioBuffer *)v66;
                  sub_143567340(
                    (unsigned int)v66,
                    (_DWORD)ThreadLogContextSlot_8,
                    (_DWORD)v621,
                    (_DWORD)p_SV_8,
                    (__int64)&v123,
                    (__int64)&p_NOT_INIT_9,
                    (__int64)v619,
                    (__int64)v618,
                    (__int64)v617,
                    (__int64)v616,
                    (__int64)v615,
                    (__int64)v614);
                  LODWORD(v65) = v107;
                  sub_1403045C0(
                    5u,
                    dst__17,
                    "Drive Cannot Tune",
                    "Linked jump point $$ has no valid tunnel host! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                    __Val_0___8,
                    0xBu,
                    1,
                    v65,
                    v904,
                    0);
                  sub_140370F70(v846);
                  sub_140370F70(v845);
                  sub_140370F70(v844);
                  sub_140370F70(v843);
                  sub_140370F70(v842);
                  sub_140370F70(v841);
                }
              }
              else
              {
                v175[0] = sub_142744750(0x1Cu);
                v175[1] = 0x51;
                src__18[0] = v175;
                src__18[1] = &v176;
                qmemcpy(dst__18, src__18, sizeof(dst__18));
                v108 = invokeGlobalCallbackAndMaskStatusBits(
                         5,
                         (__int64)dst__18,
                         (__int64)"Drive Cannot Tune",
                         "Linked jump point $$ has no valid tunnel host! | %s%d | %s | $$",
                         v77,
                         (_DWORD)v78,
                         v79);
                if ( (v108 & 0xFFFFF) != 0 )
                {
                  v839[0] = 0;
                  v839[1] = "CSCItemJumpDrive::CanTune";
                  v839[2] = 0;
                  v627 = v839;
                  v322 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
                  v124 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v322 + 0x6B0LL))(v322);
                  v623 = sub_1402A24F0((__int64)&qword_149B4FBE0);
                  if ( *(_BYTE *)(v623 + 0x5F5) )
                    p_SV_9 = "CL";
                  else
                    p_SV_9 = "SV";
                  v624 = *(_QWORD *)(a1 + 0x830) & 0xFFFFFFFFFFFFLL;
                  v625 = *(_QWORD *)(v624 + 8);
                  v323 = sub_14030ECF0(&v625);
                  v626 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v323 + 0x70LL))(v323);
                  v840[0] = 0;
                  v840[1] = v626;
                  v840[2] = 0;
                  v628 = v840;
                  ThreadLogContextSlot_9 = getThreadLogContextSlot();
                  v907[0] = 0;
                  v907[1] = 0;
                  v177[0] = sub_142744750(0x1Cu);
                  v177[1] = 0x51;
                  src__19[0] = v177;
                  src__19[1] = &v178;
                  qmemcpy(dst__19, src__19, sizeof(dst__19));
                  n6 = 6;
                  v37 = alloca(0x2A0);
                  v324 = v74;
                  __Val_0___9 = (vraudio::AudioBuffer *)v74;
                  sub_143567220(
                    (unsigned int)v74,
                    (_DWORD)ThreadLogContextSlot_9,
                    (_DWORD)v628,
                    (_DWORD)p_SV_9,
                    (__int64)&v124,
                    (__int64)"NULL ENTITY",
                    (__int64)v627);
                  LODWORD(v73) = v108;
                  sub_1403045C0(
                    5u,
                    dst__19,
                    "Drive Cannot Tune",
                    "Linked jump point $$ has no valid tunnel host! | %s%d | %s | $$",
                    __Val_0___9,
                    6u,
                    1,
                    v73,
                    v907,
                    0);
                  sub_140370F70(v840);
                  sub_140370F70(v839);
                }
              }
            }
            return 0;
          }
        }
      }
      else
      {
        if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
        {
          v497 = *(_QWORD *)(a1 + 8);
          if ( sub_14030EC00(&v497) )
          {
            v155[0] = sub_142744750(0x1Cu);
            v155[1] = 0x51;
            src__20[0] = v155;
            src__20[1] = &v156;
            qmemcpy(dst__20, src__20, sizeof(dst__20));
            v103 = invokeGlobalCallbackAndMaskStatusBits(
                     5,
                     (__int64)dst__20,
                     (__int64)"Drive Cannot Tune",
                     "Drive has no linked jump point! ($$ is nearby) | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                     v77,
                     (_DWORD)v78,
                     v79);
            if ( (v103 & 0xFFFFF) != 0 )
            {
              v858[0] = 0;
              v858[1] = "CSCItemJumpDrive::CanTune";
              v858[2] = 0;
              v524 = v858;
              v498 = *(_QWORD *)(a1 + 8);
              v229 = sub_14030ECF0(&v498);
              v499 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v229 + 0x158LL);
              v16 = (_QWORD *)v499(v229, v978);
              v230 = sub_14030ECF0(v16);
              if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v230 + 0x648LL))(v230) )
              {
                v500 = *(_QWORD *)(a1 + 8);
                v231 = sub_14030ECF0(&v500);
                v501 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v231 + 0x158LL);
                v17 = (_QWORD *)v501(v231, v977);
                v232 = sub_14030ECF0(v17);
                v233 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v232 + 0x648LL))(v232);
                p_NULL_ZONE_5 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v233 + 0x1F0LL))(v233);
              }
              else
              {
                p_NULL_ZONE_5 = "NULL ZONE";
              }
              v859[0] = 0;
              v859[1] = p_NULL_ZONE_5;
              v859[2] = 0;
              v525 = v859;
              v502 = *(_QWORD *)(a1 + 8);
              v235 = sub_14030ECF0(&v502);
              v503 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v235 + 0x158LL);
              v18 = (_QWORD *)v503(v235, v976);
              v236 = sub_14030ECF0(v18);
              v504 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v236 + 0x70LL))(v236);
              v860[0] = 0;
              v860[1] = v504;
              v860[2] = 0;
              v526 = v860;
              v505 = *(_QWORD *)(a1 + 8);
              v237 = sub_14030ECF0(&v505);
              v506 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v237 + 8LL);
              v507 = (__int64 *)v506(v237, v975);
              v508 = sub_1402A24F0(*v507);
              v931[0] = 0;
              v931[1] = v508;
              v932 = 0;
              v527 = v931;
              v509 = *(_QWORD *)(a1 + 8);
              v238 = sub_14030ECF0(&v509);
              v510 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v238 + 0x70LL))(v238);
              v861[0] = 0;
              v861[1] = v510;
              v861[2] = 0;
              v528 = v861;
              v239 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
              v240 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v239 + 0xA0LL))(v239);
              v241 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v240 + 0x1D0LL))(v240);
              v513 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v241 + 0x100LL);
              v511 = *(_QWORD *)(a1 + 8);
              v512 = v511;
              v19 = (unsigned __int64 *)v513(v241, v974, v511);
              if ( sub_14030EC00(v19) )
              {
                v242 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
                v243 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v242 + 0xA0LL))(v242);
                v244 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v243 + 0x1D0LL))(v243);
                v516 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v244 + 0x100LL);
                v514 = *(_QWORD *)(a1 + 8);
                v515 = v514;
                v20 = (_QWORD *)v516(v244, v973, v514);
                v245 = sub_14030ECF0(v20);
                p_NULL_SYSTEM_5 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v245 + 0x70LL))(v245);
              }
              else
              {
                p_NULL_SYSTEM_5 = "NULL SYSTEM";
              }
              v862[0] = 0;
              v862[1] = p_NULL_SYSTEM_5;
              v862[2] = 0;
              v529 = v862;
              v517 = *(_QWORD *)(a1 + 8);
              v247 = sub_14030ECF0(&v517);
              if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v247 + 0x50LL))(v247) )
              {
                v518 = *(_QWORD *)(a1 + 8);
                v248 = sub_14030ECF0(&v518);
                if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v248 + 0x720LL))(v248) )
                  p_NOT_AUTH_5 = "AUTH";
                else
                  p_NOT_AUTH_5 = "NOT AUTH";
                p_NOT_INIT_10 = p_NOT_AUTH_5;
              }
              else
              {
                p_NOT_INIT_10 = "NOT INIT";
              }
              p_NOT_INIT_11 = p_NOT_INIT_10;
              v251 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
              v119 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v251 + 0x6B0LL))(v251);
              v519 = sub_1402A24F0((__int64)&qword_149B4FBE0);
              if ( *(_BYTE *)(v519 + 0x5F5) )
                p_SV_10 = "CL";
              else
                p_SV_10 = "SV";
              if ( Handle::IsValid((_QWORD *)(a1 + 0x808)) )
              {
                v520 = *(_QWORD *)(a1 + 0x808) & 0xFFFFFFFFFFFFLL;
                v521 = *(_QWORD *)(v520 + 8);
                v252 = sub_14030ECF0(&v521);
                v82 |= 1u;
                v522 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v252 + 0x70LL))(v252);
                v863[0] = 0;
                v863[1] = v522;
                v863[2] = 0;
                v253 = v863;
              }
              else
              {
                v82 |= 2u;
                v864[0] = 0;
                v864[1] = "No jump point";
                v864[2] = 0;
                v253 = v864;
              }
              v523 = v253;
              v531 = v253;
              ThreadLogContextSlot_10 = getThreadLogContextSlot();
              v892[0] = 0;
              v892[1] = 0;
              v157[0] = sub_142744750(0x1Cu);
              v157[1] = 0x51;
              src__21[0] = v157;
              src__21[1] = &v158;
              qmemcpy(dst__21, src__21, sizeof(dst__21));
              n0xB_1 = 0xB;
              v21 = alloca(0x4D0);
              v254 = v66;
              __Val_0___10 = (vraudio::AudioBuffer *)v66;
              sub_143567340(
                (unsigned int)v66,
                (_DWORD)ThreadLogContextSlot_10,
                (_DWORD)v531,
                (_DWORD)p_SV_10,
                (__int64)&v119,
                (__int64)&p_NOT_INIT_11,
                (__int64)v529,
                (__int64)v528,
                (__int64)v527,
                (__int64)v526,
                (__int64)v525,
                (__int64)v524);
              LODWORD(v65) = v103;
              sub_1403045C0(
                5u,
                dst__21,
                "Drive Cannot Tune",
                "Drive has no linked jump point! ($$ is nearby) | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                __Val_0___10,
                0xBu,
                1,
                v65,
                v892,
                0);
              if ( (v82 & 2) != 0 )
              {
                v82 &= ~2u;
                sub_140370F70(v864);
              }
              if ( (v82 & 1) != 0 )
              {
                v82 &= ~1u;
                sub_140370F70(v863);
              }
              sub_140370F70(v862);
              sub_140370F70(v861);
              sub_140370F70(v860);
              sub_140370F70(v859);
              sub_140370F70(v858);
            }
          }
          else
          {
            v159[0] = sub_142744750(0x1Cu);
            v159[1] = 0x51;
            src__22[0] = v159;
            src__22[1] = &v160;
            qmemcpy(dst__22, src__22, sizeof(dst__22));
            v104 = invokeGlobalCallbackAndMaskStatusBits(
                     5,
                     (__int64)dst__22,
                     (__int64)"Drive Cannot Tune",
                     "Drive has no linked jump point! ($$ is nearby) | %s%d | %s | $$",
                     v77,
                     (_DWORD)v78,
                     v79);
            if ( (v104 & 0xFFFFF) != 0 )
            {
              v855[0] = 0;
              v855[1] = "CSCItemJumpDrive::CanTune";
              v855[2] = 0;
              v538 = v855;
              v257 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
              v120 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v257 + 0x6B0LL))(v257);
              v533 = sub_1402A24F0((__int64)&qword_149B4FBE0);
              if ( *(_BYTE *)(v533 + 0x5F5) )
                p_SV_11 = "CL";
              else
                p_SV_11 = "SV";
              if ( Handle::IsValid((_QWORD *)(a1 + 0x808)) )
              {
                v534 = *(_QWORD *)(a1 + 0x808) & 0xFFFFFFFFFFFFLL;
                v535 = *(_QWORD *)(v534 + 8);
                v258 = sub_14030ECF0(&v535);
                v82 |= 4u;
                v536 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v258 + 0x70LL))(v258);
                v856[0] = 0;
                v856[1] = v536;
                v856[2] = 0;
                v259 = v856;
              }
              else
              {
                v82 |= 8u;
                v857[0] = 0;
                v857[1] = "No jump point";
                v857[2] = 0;
                v259 = v857;
              }
              v537 = v259;
              v539 = v259;
              ThreadLogContextSlot_11 = getThreadLogContextSlot();
              v895[0] = 0;
              v895[1] = 0;
              v161[0] = sub_142744750(0x1Cu);
              v161[1] = 0x51;
              src__23[0] = v161;
              src__23[1] = &v162;
              qmemcpy(dst__23, src__23, sizeof(dst__23));
              n6_1 = 6;
              v22 = alloca(0x2A0);
              v260 = v74;
              __Val_0___11 = (vraudio::AudioBuffer *)v74;
              sub_143567220(
                (unsigned int)v74,
                (_DWORD)ThreadLogContextSlot_11,
                (_DWORD)v539,
                (_DWORD)p_SV_11,
                (__int64)&v120,
                (__int64)"NULL ENTITY",
                (__int64)v538);
              LODWORD(v73) = v104;
              sub_1403045C0(
                5u,
                dst__23,
                "Drive Cannot Tune",
                "Drive has no linked jump point! ($$ is nearby) | %s%d | %s | $$",
                __Val_0___11,
                6u,
                1,
                v73,
                v895,
                0);
              if ( (v82 & 8) != 0 )
              {
                v82 &= ~8u;
                sub_140370F70(v857);
              }
              if ( (v82 & 4) != 0 )
              {
                v82 &= ~4u;
                sub_140370F70(v856);
              }
              sub_140370F70(v855);
            }
          }
        }
        return 0;
      }
    }
    else
    {
      if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
      {
        v463 = *(_QWORD *)(a1 + 8);
        if ( sub_14030EC00(&v463) )
        {
          v147[0] = sub_142744750(0x1Cu);
          v147[1] = 0x51;
          src__24[0] = v147;
          src__24[1] = &v148;
          qmemcpy(dst__24, src__24, sizeof(dst__24));
          v101 = invokeGlobalCallbackAndMaskStatusBits(
                   5,
                   (__int64)dst__24,
                   (__int64)"Drive Cannot Tune",
                   "Drive is not functional! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                   v77,
                   (_DWORD)v78,
                   v79);
          if ( (v101 & 0xFFFFF) != 0 )
          {
            v866[0] = 0;
            v866[1] = "CSCItemJumpDrive::CanTune";
            v866[2] = 0;
            v486 = v866;
            v464 = *(_QWORD *)(a1 + 8);
            v458 = sub_14030ECF0(&v464);
            v465 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v458 + 0x158LL);
            v9 = (_QWORD *)v465(v458, v986);
            v459 = sub_14030ECF0(v9);
            if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v459 + 0x648LL))(v459) )
            {
              v466 = *(_QWORD *)(a1 + 8);
              v201 = sub_14030ECF0(&v466);
              v467 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v201 + 0x158LL);
              v10 = (_QWORD *)v467(v201, v985);
              v202 = sub_14030ECF0(v10);
              v203 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v202 + 0x648LL))(v202);
              p_NULL_ZONE_6 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v203 + 0x1F0LL))(v203);
            }
            else
            {
              p_NULL_ZONE_6 = "NULL ZONE";
            }
            v867[0] = 0;
            v867[1] = p_NULL_ZONE_6;
            v867[2] = 0;
            v487 = v867;
            v468 = *(_QWORD *)(a1 + 8);
            v205 = sub_14030ECF0(&v468);
            v469 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v205 + 0x158LL);
            v11 = (_QWORD *)v469(v205, v984);
            v206 = sub_14030ECF0(v11);
            v470 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v206 + 0x70LL))(v206);
            v869[0] = 0;
            v869[1] = v470;
            v869[2] = 0;
            v488 = v869;
            v471 = *(_QWORD *)(a1 + 8);
            v207 = sub_14030ECF0(&v471);
            v472 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v207 + 8LL);
            v473 = (__int64 *)v472(v207, v983);
            v474 = sub_1402A24F0(*v473);
            v929[0] = 0;
            v929[1] = v474;
            v930 = 0;
            v489 = v929;
            v475 = *(_QWORD *)(a1 + 8);
            v208 = sub_14030ECF0(&v475);
            v476 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v208 + 0x70LL))(v208);
            v870[0] = 0;
            v870[1] = v476;
            v870[2] = 0;
            v490 = v870;
            v209 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
            v210 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v209 + 0xA0LL))(v209);
            v211 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v210 + 0x1D0LL))(v210);
            v479 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v211 + 0x100LL);
            v477 = *(_QWORD *)(a1 + 8);
            v478 = v477;
            v12 = (unsigned __int64 *)v479(v211, v982, v477);
            if ( sub_14030EC00(v12) )
            {
              v212 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
              v213 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v212 + 0xA0LL))(v212);
              v214 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v213 + 0x1D0LL))(v213);
              v482 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v214 + 0x100LL);
              v480 = *(_QWORD *)(a1 + 8);
              v481 = v480;
              v13 = (_QWORD *)v482(v214, v981, v480);
              v215 = sub_14030ECF0(v13);
              p_NULL_SYSTEM_6 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v215 + 0x70LL))(v215);
            }
            else
            {
              p_NULL_SYSTEM_6 = "NULL SYSTEM";
            }
            v871[0] = 0;
            v871[1] = p_NULL_SYSTEM_6;
            v871[2] = 0;
            v491 = v871;
            v483 = *(_QWORD *)(a1 + 8);
            v217 = sub_14030ECF0(&v483);
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v217 + 0x50LL))(v217) )
            {
              v484 = *(_QWORD *)(a1 + 8);
              v218 = sub_14030ECF0(&v484);
              if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v218 + 0x720LL))(v218) )
                p_NOT_AUTH_6 = "AUTH";
              else
                p_NOT_AUTH_6 = "NOT AUTH";
              p_NOT_INIT_12 = p_NOT_AUTH_6;
            }
            else
            {
              p_NOT_INIT_12 = "NOT INIT";
            }
            p_NOT_INIT_13 = p_NOT_INIT_12;
            v221 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
            v117 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v221 + 0x6B0LL))(v221);
            v485 = sub_1402A24F0((__int64)&qword_149B4FBE0);
            if ( *(_BYTE *)(v485 + 0x5F5) )
              p_SV_12 = "CL";
            else
              p_SV_12 = "SV";
            ThreadLogContextSlot_12 = getThreadLogContextSlot();
            v886[0] = 0;
            v886[1] = 0;
            v149[0] = sub_142744750(0x1Cu);
            v149[1] = 0x51;
            src__25[0] = v149;
            src__25[1] = &v150;
            qmemcpy(dst__25, src__25, sizeof(dst__25));
            n0xA = 0xA;
            v14 = alloca(0x460);
            v222 = v68;
            __Val_0___12 = (vraudio::AudioBuffer *)v68;
            sub_143566320(
              (unsigned int)v68,
              (_DWORD)ThreadLogContextSlot_12,
              (_DWORD)p_SV_12,
              (unsigned int)&v117,
              (__int64)&p_NOT_INIT_13,
              (__int64)v491,
              (__int64)v490,
              (__int64)v489,
              (__int64)v488,
              (__int64)v487,
              (__int64)v486);
            LODWORD(v67) = v101;
            sub_1403045C0(
              5u,
              dst__25,
              "Drive Cannot Tune",
              "Drive is not functional! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
              __Val_0___12,
              0xAu,
              1,
              v67,
              v886,
              0);
            sub_140370F70(v871);
            sub_140370F70(v870);
            sub_140370F70(v869);
            sub_140370F70(v867);
            sub_140370F70(v866);
          }
        }
        else
        {
          v151[0] = sub_142744750(0x1Cu);
          v151[1] = 0x51;
          src__26[0] = v151;
          src__26[1] = &v152;
          qmemcpy(dst__26, src__26, sizeof(dst__26));
          v102 = invokeGlobalCallbackAndMaskStatusBits(
                   5,
                   (__int64)dst__26,
                   (__int64)"Drive Cannot Tune",
                   "Drive is not functional! | %s%d | %s | $$",
                   v77,
                   (_DWORD)v78,
                   v79);
          if ( (v102 & 0xFFFFF) != 0 )
          {
            v865[0] = 0;
            v865[1] = "CSCItemJumpDrive::CanTune";
            v865[2] = 0;
            v495 = v865;
            v225 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
            v118 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v225 + 0x6B0LL))(v225);
            v494 = sub_1402A24F0((__int64)&qword_149B4FBE0);
            if ( *(_BYTE *)(v494 + 0x5F5) )
              p_SV_13 = "CL";
            else
              p_SV_13 = "SV";
            ThreadLogContextSlot_13 = getThreadLogContextSlot();
            v889[0] = 0;
            v889[1] = 0;
            v153[0] = sub_142744750(0x1Cu);
            v153[1] = 0x51;
            src__27[0] = v153;
            src__27[1] = &v154;
            qmemcpy(dst__27, src__27, sizeof(dst__27));
            n5 = 5;
            v15 = alloca(0x230);
            v226 = v76;
            __Val_0___13 = (vraudio::AudioBuffer *)v76;
            sub_143566200(
              (unsigned int)v76,
              (_DWORD)ThreadLogContextSlot_13,
              (_DWORD)p_SV_13,
              (unsigned int)&v118,
              (__int64)"NULL ENTITY",
              (__int64)v495);
            LODWORD(v75) = v102;
            sub_1403045C0(
              5u,
              dst__27,
              "Drive Cannot Tune",
              "Drive is not functional! | %s%d | %s | $$",
              __Val_0___13,
              5u,
              1,
              v75,
              v889,
              0);
            sub_140370F70(v865);
          }
        }
      }
      return 0;
    }
  }
  else
  {
    if ( a1 && (unsigned __int8)sub_1436090E0(a1 + 0x70) )
    {
      v779 = *(_QWORD *)(a1 + 8);
      if ( sub_14030EC00(&v779) )
      {
        v139[0] = sub_142744750(0x1Cu);
        v139[1] = 0x51;
        src__28[0] = v139;
        src__28[1] = &v140;
        qmemcpy(dst__28, src__28, sizeof(dst__28));
        v115 = invokeGlobalCallbackAndMaskStatusBits(
                 4,
                 (__int64)dst__28,
                 (__int64)"Drive Cannot Tune",
                 "Drive has no vehicle! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
                 v77,
                 (_DWORD)v78,
                 v79);
        if ( (v115 & 0xFFFFF) != 0 )
        {
          v873[0] = 0;
          v873[1] = "CSCItemJumpDrive::CanTune";
          v873[2] = 0;
          v802 = v873;
          v780 = *(_QWORD *)(a1 + 8);
          v374 = sub_14030ECF0(&v780);
          v781 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v374 + 0x158LL);
          v1 = (_QWORD *)v781(v374, v994);
          v429 = sub_14030ECF0(v1);
          if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v429 + 0x648LL))(v429) )
          {
            v782 = *(_QWORD *)(a1 + 8);
            v430 = sub_14030ECF0(&v782);
            v783 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v430 + 0x158LL);
            v2 = (_QWORD *)v783(v430, v993);
            v431 = sub_14030ECF0(v2);
            v432 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v431 + 0x648LL))(v431);
            p_NULL_ZONE_7 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v432 + 0x1F0LL))(v432);
          }
          else
          {
            p_NULL_ZONE_7 = "NULL ZONE";
          }
          v874[0] = 0;
          v874[1] = p_NULL_ZONE_7;
          v874[2] = 0;
          v803 = v874;
          v784 = *(_QWORD *)(a1 + 8);
          v434 = sub_14030ECF0(&v784);
          v785 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v434 + 0x158LL);
          v3 = (_QWORD *)v785(v434, v992);
          v435 = sub_14030ECF0(v3);
          v786 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v435 + 0x70LL))(v435);
          v875[0] = 0;
          v875[1] = v786;
          v875[2] = 0;
          v804 = v875;
          v787 = *(_QWORD *)(a1 + 8);
          v436 = sub_14030ECF0(&v787);
          v788 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v436 + 8LL);
          v789 = (__int64 *)v788(v436, v991);
          v790 = sub_1402A24F0(*v789);
          v927[0] = 0;
          v927[1] = v790;
          v928 = 0;
          v805 = v927;
          v791 = *(_QWORD *)(a1 + 8);
          v437 = sub_14030ECF0(&v791);
          v792 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v437 + 0x70LL))(v437);
          v876[0] = 0;
          v876[1] = v792;
          v876[2] = 0;
          v806 = v876;
          v438 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
          v439 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v438 + 0xA0LL))(v438);
          v440 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v439 + 0x1D0LL))(v439);
          v795 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v440 + 0x100LL);
          v793 = *(_QWORD *)(a1 + 8);
          v794 = v793;
          v4 = (unsigned __int64 *)v795(v440, v990, v793);
          if ( sub_14030EC00(v4) )
          {
            v441 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
            v442 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v441 + 0xA0LL))(v441);
            v443 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v442 + 0x1D0LL))(v442);
            v798 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v443 + 0x100LL);
            v796 = *(_QWORD *)(a1 + 8);
            v797 = v796;
            v5 = (_QWORD *)v798(v443, v989, v796);
            v444 = sub_14030ECF0(v5);
            p_NULL_SYSTEM_7 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v444 + 0x70LL))(v444);
          }
          else
          {
            p_NULL_SYSTEM_7 = "NULL SYSTEM";
          }
          v868[0] = 0;
          v868[1] = p_NULL_SYSTEM_7;
          v868[2] = 0;
          v807 = v868;
          v799 = *(_QWORD *)(a1 + 8);
          v446 = sub_14030ECF0(&v799);
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v446 + 0x50LL))(v446) )
          {
            v800 = *(_QWORD *)(a1 + 8);
            v447 = sub_14030ECF0(&v800);
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v447 + 0x720LL))(v447) )
              p_NOT_AUTH_7 = "AUTH";
            else
              p_NOT_AUTH_7 = "NOT AUTH";
            p_NOT_INIT_14 = p_NOT_AUTH_7;
          }
          else
          {
            p_NOT_INIT_14 = "NOT INIT";
          }
          p_NOT_INIT_15 = p_NOT_INIT_14;
          v450 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
          v136 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v450 + 0x6B0LL))(v450);
          v801 = sub_1402A24F0((__int64)&qword_149B4FBE0);
          if ( *(_BYTE *)(v801 + 0x5F5) )
            p_SV_14 = "CL";
          else
            p_SV_14 = "SV";
          ThreadLogContextSlot_14 = getThreadLogContextSlot();
          v880[0] = 0;
          v880[1] = 0;
          v141[0] = sub_142744750(0x1Cu);
          v141[1] = 0x51;
          src__29[0] = v141;
          src__29[1] = &v142;
          qmemcpy(dst__29, src__29, sizeof(dst__29));
          n0xA_1 = 0xA;
          v6 = alloca(0x460);
          v451 = v68;
          __Val_0___14 = (vraudio::AudioBuffer *)v68;
          sub_143566320(
            (unsigned int)v68,
            (_DWORD)ThreadLogContextSlot_14,
            (_DWORD)p_SV_14,
            (unsigned int)&v136,
            (__int64)&p_NOT_INIT_15,
            (__int64)v807,
            (__int64)v806,
            (__int64)v805,
            (__int64)v804,
            (__int64)v803,
            (__int64)v802);
          LODWORD(v67) = v115;
          sub_1403045C0(
            4u,
            dst__29,
            "Drive Cannot Tune",
            "Drive has no vehicle! | %s%d | %s | $$ | $$ [$$] (adam: $$ in zone $$) | $$",
            __Val_0___14,
            0xAu,
            1,
            v67,
            v880,
            0);
          sub_140370F70(v868);
          sub_140370F70(v876);
          sub_140370F70(v875);
          sub_140370F70(v874);
          sub_140370F70(v873);
        }
      }
      else
      {
        v143[0] = sub_142744750(0x1Cu);
        v143[1] = 0x51;
        src__30[0] = v143;
        src__30[1] = &v144;
        qmemcpy(dst__30, src__30, sizeof(dst__30));
        v100 = invokeGlobalCallbackAndMaskStatusBits(
                 4,
                 (__int64)dst__30,
                 (__int64)"Drive Cannot Tune",
                 "Drive has no vehicle! | %s%d | %s | $$",
                 v77,
                 (_DWORD)v78,
                 v79);
        if ( (v100 & 0xFFFFF) != 0 )
        {
          v872[0] = 0;
          v872[1] = "CSCItemJumpDrive::CanTune";
          v872[2] = 0;
          v461 = v872;
          v454 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xC0);
          v116 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v454 + 0x6B0LL))(v454);
          v810 = sub_1402A24F0((__int64)&qword_149B4FBE0);
          if ( *(_BYTE *)(v810 + 0x5F5) )
            p_SV_15 = "CL";
          else
            p_SV_15 = "SV";
          ThreadLogContextSlot_15 = getThreadLogContextSlot();
          v883[0] = 0;
          v883[1] = 0;
          v145[0] = sub_142744750(0x1Cu);
          v145[1] = 0x51;
          src__31[0] = v145;
          src__31[1] = &v146;
          qmemcpy(dst__31, src__31, sizeof(dst__31));
          n5_1 = 5;
          v7 = alloca(0x230);
          v455 = v76;
          __Val_0___15 = (vraudio::AudioBuffer *)v76;
          sub_143566200(
            (unsigned int)v76,
            (_DWORD)ThreadLogContextSlot_15,
            (_DWORD)p_SV_15,
            (unsigned int)&v116,
            (__int64)"NULL ENTITY",
            (__int64)v461);
          LODWORD(v75) = v100;
          sub_1403045C0(
            4u,
            dst__31,
            "Drive Cannot Tune",
            "Drive has no vehicle! | %s%d | %s | $$",
            __Val_0___15,
            5u,
            1,
            v75,
            v883,
            0);
          sub_140370F70(v872);
        }
      }
    }
    return 0;
  }
}

// --- End Function: sub_1435B1900 (0x1435B1900) ---

// --- Function: sub_1436090E0 (0x1436090E0) ---
__int64 __fastcall sub_1436090E0(__int64 a1)
{
  __int64 v1; // rax
  unsigned __int8 v3; // [rsp+20h] [rbp-38h]
  __int64 v4; // [rsp+38h] [rbp-20h] BYREF
  __int64 v5; // [rsp+40h] [rbp-18h]

  v3 = 0;
  if ( n2_170 > 0 )
  {
    if ( n2_170 == 2 )
      return 1;
    v4 = *(_QWORD *)(a1 - 0x68);
    v1 = sub_14030ECF0(&v4);
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x720LL))(v1) )
      return 1;
    if ( Handle::IsValid((_QWORD *)(a1 + 0xE8)) )
    {
      v5 = *(_QWORD *)(a1 + 0xE8) & 0xFFFFFFFFFFFFLL;
      if ( sub_143AE86A0(v5) )
        return 1;
    }
  }
  return v3;
}

// --- End Function: sub_1436090E0 (0x1436090E0) ---

// --- Function: sub_143AE86A0 (0x143AE86A0) ---
bool __fastcall sub_143AE86A0(__int64 a1)
{
  return (*(_BYTE *)(a1 + 0x360) & 2) != 0;
}

// --- End Function: sub_143AE86A0 (0x143AE86A0) ---

// --- Function: _Mtx_getconcrtcs_w_2 (0x143E5D470) ---
__int64 __fastcall Mtx_getconcrtcs_w_2(__int64 a1)
{
  return *(unsigned int *)Mtx_getconcrtcs((_Mtx_t)(a1 + 0x108));
}

// --- End Function: _Mtx_getconcrtcs_w_2 (0x143E5D470) ---

// --- Function: sub_143E73770 (0x143E73770) ---
bool __fastcall sub_143E73770(__int64 a1)
{
  return *(_BYTE *)(a1 + 0x3DA)
      && is_valid_handle_typeA((__int64 *)(a1 + 0x188))
      && unknown_libname_84((_QWORD *)(a1 + 0x190));
}

// --- End Function: sub_143E73770 (0x143E73770) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6320);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6336);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6320) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 6320);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: sub_1480BE950 (0x1480BE950) ---
__int64 sub_1480BE950()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = NtCurrentTeb_w();
  sub_1402A3D30(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = NtCurrentTeb_w();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0;
  return result;
}

// --- End Function: sub_1480BE950 (0x1480BE950) ---

