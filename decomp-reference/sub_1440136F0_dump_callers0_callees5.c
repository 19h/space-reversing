// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1440136F0 (sub_1440136F0)
// Caller Depth: 0
// Callee/Ref Depth: 5
// Total Functions Found: 321
// ------------------------------------------------------------

// --- Function: sub_1402A24F0 (0x1402A24F0) ---
__int64 __fastcall sub_1402A24F0(__int64 a1)
{
  return a1;
}

// --- End Function: sub_1402A24F0 (0x1402A24F0) ---

// --- Function: sub_1402A2B40 (0x1402A2B40) ---
void __fastcall sub_1402A2B40(__int64 a1)
{
  unsigned __int64 v1; // rax
  const void *v2; // rcx

  if ( *(_QWORD *)(a1 + 0x10) != a1 + 0x18 )
  {
    v1 = 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
    v2 = *(const void **)(a1 + 0x10);
    qword_149B3AB68 += v1;
    sub_147605980(v2);
  }
}

// --- End Function: sub_1402A2B40 (0x1402A2B40) ---

// --- Function: sub_1402A2B80 (0x1402A2B80) ---
__int64 __fastcall sub_1402A2B80(__int64 a1, __int64 a2)
{
  return a2;
}

// --- End Function: sub_1402A2B80 (0x1402A2B80) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: ?do_is_equal@_Identity_equal_resource@pmr@std@@MEBA_NAEBVmemory_resource@23@@Z (0x1402A3450) ---
bool __fastcall std::pmr::_Identity_equal_resource::do_is_equal(
        std::pmr::_Identity_equal_resource *this,
        const struct std::pmr::memory_resource *this_1)
{
  return this == this_1;
}

// --- End Function: ?do_is_equal@_Identity_equal_resource@pmr@std@@MEBA_NAEBVmemory_resource@23@@Z (0x1402A3450) ---

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
void __fastcall sub_1402A3D30(const void *a1)
{
  sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall allocWithProfilerInfo_w(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A3D90) ---
unsigned __int8 *__fastcall AK::WriteBytesMem::Bytes(AK::WriteBytesMem *this)
{
  return (unsigned __int8 *)*((_QWORD *)this + 2);
}

// --- End Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A3D90) ---

// --- Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---
_QWORD *__fastcall std::_Allocate<16,std::_Default_allocate_traits,0>(unsigned __int64 _Bytes)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  _QWORD *result; // rax

  if ( _Bytes < 0x1000 )
  {
    if ( _Bytes )
      return (_QWORD *)allocWithProfilerInfo_w(_Bytes);
    else
      return 0;
  }
  else
  {
    if ( _Bytes + 0x27 < _Bytes )
      sub_1402E1170();
    v1 = allocWithProfilerInfo_w(_Bytes + 0x27);
    v2 = v1;
    if ( !v1 )
      invalid_parameter_noinfo_noreturn();
    result = (_QWORD *)((v1 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    result[0xFFFFFFFF] = v2;
  }
  return result;
}

// --- End Function: ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z (0x1402A5B70) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall sub_1402A6760(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 0x28;
    if ( v6 + 0x28 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v15[0xFFFFFFFF] = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - v17[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v17 = (_QWORD *)v17[0xFFFFFFFF];
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: sub_1402AE3D0 (0x1402AE3D0) ---
__int64 *__fastcall sub_1402AE3D0(__int64 *a1, const char *a2, __int64 a3, char a4)
{
  *a1 = a3;
  sub_1402CD240(a3, a2, a4);
  return a1;
}

// --- End Function: sub_1402AE3D0 (0x1402AE3D0) ---

// --- Function: sub_1402B1490 (0x1402B1490) ---
// local variable allocation has failed, the output may be wrong!
_QWORD *__fastcall sub_1402B1490(_QWORD *a1, double a2)
{
  __int128 v3; // kr00_16

  *((double *)&v3 + 1) = *(&a2 + 1);
  *(double *)&v3 = a2 * 10000000.0;
  _XMM0 = v3;
  __asm { vcvttsd2si rax, xmm0 }
  *a1 = _RAX;
  return a1;
}

// --- End Function: sub_1402B1490 (0x1402B1490) ---

// --- Function: sub_1402B15B0 (0x1402B15B0) ---
_QWORD *__fastcall sub_1402B15B0(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return a1;
}

// --- End Function: sub_1402B15B0 (0x1402B15B0) ---

// --- Function: sub_1402B1820 (0x1402B1820) ---
const ULONG_PTR *__fastcall sub_1402B1820(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v4; // eax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 0x14);
  if ( v2 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v4 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v1, v4);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402B1820 (0x1402B1820) ---

// --- Function: sub_1402B4590 (0x1402B4590) ---
void *(__fastcall **__fastcall sub_1402B4590(_QWORD *a1))(FDefaultModuleImpl *__hidden this, unsigned int)
{
  void *(__fastcall **result)(FDefaultModuleImpl *__hidden, unsigned int); // rax

  result = &off_1481A0DB8;
  *a1 = &off_1481A0DB8;
  return result;
}

// --- End Function: sub_1402B4590 (0x1402B4590) ---

// --- Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B4B80) ---
bool __fastcall std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B4B80) ---

// --- Function: LogTraceConditional (0x1402C1000) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
        qword_149B4FCB0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C1000) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402C7230 (0x1402C7230) ---
__int64 sub_1402C7230()
{
  return qword_149B4FCA0;
}

// --- End Function: sub_1402C7230 (0x1402C7230) ---

// --- Function: sub_1402CA4C0 (0x1402CA4C0) ---
__int64 __fastcall sub_1402CA4C0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
      break;
    v4 = 0;
    if ( (int)result < 0 )
      v4 = a1;
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402CA4C0 (0x1402CA4C0) ---

// --- Function: sub_1402CD240 (0x1402CD240) ---
__int64 __fastcall sub_1402CD240(__int64 a1, const char *a2, char a3)
{
  __int64 result; // rax
  int v7; // edi
  unsigned __int32 v8; // eax

  result = NtCurrentTeb_w();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v8 )
    {
      result = sub_1403C33A0(a1, v8, a2, a3);
    }
    else
    {
      result = NtCurrentTeb_w();
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v7;
  }
  return result;
}

// --- End Function: sub_1402CD240 (0x1402CD240) ---

// --- Function: sub_1402D2710 (0x1402D2710) ---
double __fastcall sub_1402D2710(__int64 a1, const char *a2, const char *a3, char a4)
{
  signed __int64 v8; // rdx
  double result; // xmm0_8

  if ( *(_DWORD *)(a1 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)a1);
    if ( (v8 & 0x200000) != 0 )
      return sub_1403CB300(a1, v8, a2, a3, a4);
  }
  return result;
}

// --- End Function: sub_1402D2710 (0x1402D2710) ---

// --- Function: sub_1402D2790 (0x1402D2790) ---
unsigned __int64 __fastcall sub_1402D2790(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 0x10) == *(_DWORD *)(result + 0x18) && (result = *(unsigned int *)(a1 + 0x14), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 0x14) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CB820((volatile signed __int64 *)a1, v3);
    }
  }
  return result;
}

// --- End Function: sub_1402D2790 (0x1402D2790) ---

// --- Function: sub_1402D2830 (0x1402D2830) ---
__int64 __fastcall sub_1402D2830(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
      break;
    ++a4;
    if ( (a1 & 1) != 0 )
      a3 |= 1 << (a2 - v4);
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D2830 (0x1402D2830) ---

// --- Function: sub_1402E07B0 (0x1402E07B0) ---
__int64 __fastcall sub_1402E07B0(__int64 this)
{
  return this + 8;
}

// --- End Function: sub_1402E07B0 (0x1402E07B0) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: sub_1402E1FE0 (0x1402E1FE0) ---
__int64 __fastcall sub_1402E1FE0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
      break;
    v5 = v4 + 0x20;
    if ( (unsigned __int8)(v4 - 0x41) > 0x19u )
      v5 = v4;
    v6 = sub_1402D2830(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402CA4C0(0x4C11DB7, 1, (v6 << 0x19) ^ (unsigned int)((unsigned __int64)(v6 << 0x18) >> 0x1F) & 0x4C11DB7);
    v8 = sub_1402D2830(v7 >> 1, 0x20, v7 << 0x1F, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402E1FE0 (0x1402E1FE0) ---

// --- Function: ?allocate@?$allocator@H@std@@QEAAPEAH_K@Z (0x1402E2100) ---
int *__fastcall std::allocator<int>::allocate(std::allocator<int> *this, unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  int *result; // rax

  if ( _Count > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  allocSize = 4 * _Count;
  if ( 4 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (int *)allocWithProfilerInfo_w(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E1170();
  v3 = allocWithProfilerInfo_w(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (int *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@H@std@@QEAAPEAH_K@Z (0x1402E2100) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: NtCurrentTeb_ww_0 (0x1402E2480) ---
__int64 NtCurrentTeb_ww_0()
{
  return *(unsigned __int8 *)(NtCurrentTeb_w() + 0x12D);
}

// --- End Function: NtCurrentTeb_ww_0 (0x1402E2480) ---

// --- Function: ?fpclassify@@YAHM@Z (0x1402E3440) ---
int __fastcall fpclassify(float X)
{
  return fdclass(X);
}

// --- End Function: ?fpclassify@@YAHM@Z (0x1402E3440) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FAB90 (0x1402FAB90) ---
unsigned __int64 __fastcall sub_1402FAB90(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  unsigned __int64 result; // rax

  if ( a2 > 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v3 = 4 * a2;
  if ( 4 * a2 < 0x1000 )
  {
    if ( v3 )
      v6 = allocWithProfilerInfo_w(4 * a2);
    else
      v6 = 0;
  }
  else
  {
    if ( v3 + 0x27 < v3 )
      sub_1402E1170();
    v4 = allocWithProfilerInfo_w(v3 + 0x27);
    v5 = v4;
    if ( !v4 )
      invalid_parameter_noinfo_noreturn();
    v6 = (v4 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
    *(_QWORD *)(v6 - 8) = v5;
  }
  *a1 = v6;
  a1[1] = v6;
  result = v3 + v6;
  a1[2] = result;
  return result;
}

// --- End Function: sub_1402FAB90 (0x1402FAB90) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n0x16; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n0x16 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 0xF;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    v10[0xFFFFFFFF] = v9;
    goto LABEL_17;
  }
  n0x16 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n0x16 = 0x16;
  if ( n0x16 + 1 >= 0x1000 )
  {
    allocSize = n0x16 + 0x28;
    if ( n0x16 + 0x28 < n0x16 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n0x16 == 0xFFFFFFFFFFFFFFFFuLL )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n0x16 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n0x16;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: ?fpclassify@@YAHN@Z (0x1402FC530) ---
int __fastcall fpclassify(double X)
{
  return dclass(X);
}

// --- End Function: ?fpclassify@@YAHN@Z (0x1402FC530) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n0x100; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n0x100 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 0x50) < *(_QWORD *)(*(_QWORD *)v8 + 0x50LL) )
          {
            n0x100 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i + 0xFFFFFFFF);
              i += 0xFFFFFFF8;
              n0x100 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n0x100 )
              {
                if ( *(_QWORD *)(v14 + 8) != n0x100 )
                  break;
                n0x100 = *(_QWORD *)(v17 + 0x50);
                if ( *(_QWORD *)(v14 + 0x50) >= (unsigned __int64)n0x100 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n0x100 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 0x50) < *(_QWORD *)(v25 + 0x50) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 0x50) >= *(_QWORD *)(v21 + 0x50)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n0x100 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30 - v8) >> 3, &v33);
        v30 += 0xFFFFFFFF;
        n0x100 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n0x100 >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: sub_1402FE6B0 (0x1402FE6B0) ---
__int64 __fastcall sub_1402FE6B0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
      return 0xFFFFFFFFLL;
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAu;
    *(_BYTE *)(v6 + v5) = v9 + 0x30;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_1402FE6B0 (0x1402FE6B0) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    memset(&Src, 0, sizeof(Src));
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 0x20) = 0;
      *(_QWORD *)(v23 + 0x28) = 0;
      *(__m256 *)(v23 + 0x10) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 0xF;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x10LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x28LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(__int64 a1, _QWORD *a2, __int64 a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  unsigned __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  unsigned __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(a3 + 0x24));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(a3 + 0x20);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(a3 + 8);
  v18 = *(_QWORD *)a3;
  v31 = v16;
  if ( (v17 - *(_QWORD *)a3) / 0x70 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 0x58) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 0x40))();
        v18 += 0x70;
      }
      while ( v18 != v17 );
      *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
    }
    sub_1402FDB90((__int64 *)a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 0x30;
    v23 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v29 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v16 )
    {
      v20 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 0x18)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 0x70LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 0x30),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)a3));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v26 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 0x38)
          && *(_QWORD *)(v26 + 0x20) )
        {
          if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 0x70LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)a3;
          if ( *(_BYTE *)(v27 + 0x58) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 0x40))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 0x38))(*(_QWORD *)(v26 - 0x10));
          v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 0x10) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 0x18) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 0x20) = *(_QWORD *)(v26 + 0x10);
          *(_QWORD *)(v27 + 0x30) = *(_QWORD *)(v26 + 0x20);
          *(_QWORD *)(v27 + 0x28) = *(_QWORD *)(v26 + 0x18);
          *(_QWORD *)(v27 + 0x38) = *(_QWORD *)(v26 + 0x28);
          *(_QWORD *)(v27 + 0x40) = *(_QWORD *)(v26 + 0x30);
          *(_QWORD *)(v27 + 0x48) = *(_QWORD *)(v26 + 0x38);
          *(_QWORD *)(v27 + 0x50) = *(_QWORD *)(v26 + 0x40);
          *(_QWORD *)(v27 + 0x60) = *(_QWORD *)(v26 + 0x50);
          *(_QWORD *)(v27 + 0x68) = *(_QWORD *)(v26 + 0x58);
          *(_BYTE *)(v27 + 0x58) = 1;
          *(_BYTE *)(v27 + 0x59) = *(_BYTE *)(v26 + 0x49);
        }
        ++_Newcapacity_2;
        v26 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(a3 + 0x18) = a1;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", v3 - 0x3E8 * v7) + 0x13);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149B3B1F0 )
    result = qword_149B3B1F0(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149B3B208 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140300D10 (0x140300D10) ---
__int64 __fastcall sub_140300D10(_BYTE *a1, int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // r10
  int v8; // edx
  int v9; // ebp
  unsigned __int64 i; // rbx
  int v11; // r11d
  int v12; // r9d
  _WORD *v13; // r8
  __int64 v14; // rax
  unsigned int v15; // edx

  v4 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v4;
  while ( *(_BYTE *)(a3 + v4) );
  v8 = 0;
  v9 = 0;
  if ( a4 )
  {
    if ( a2 <= 0 )
    {
      v9 = 1;
    }
    else
    {
      *a1 = 0x22;
      v8 = 1;
    }
  }
  for ( i = 0; i < v4; ++i )
  {
    if ( v8 >= a2 )
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = a2 - v8;
      v13 = &a1[v8];
      switch ( *(_BYTE *)(i + a3) )
      {
        case 8:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x625C;
          v8 += 2;
          break;
        case 9:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x745C;
          v8 += 2;
          break;
        case 0xA:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x6E5C;
          v8 += 2;
          break;
        case 0xC:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x665C;
          v8 += 2;
          break;
        case 0xD:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x725C;
          v8 += 2;
          break;
        case 0x22:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x225C;
          v8 += 2;
          break;
        case 0x5C:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 0x5C5C;
          v8 += 2;
          break;
        default:
          if ( v12 > 0 )
          {
            *(_BYTE *)v13 = *(_BYTE *)(i + a3);
            v11 = 1;
          }
LABEL_26:
          v8 += v11;
          break;
      }
    }
  }
  if ( a4 )
  {
    if ( v8 < a2 )
    {
      v14 = v8;
      v15 = v8 + 1;
      if ( v9 )
        v15 = 0xFFFFFFFF;
      a1[v14] = 0x22;
      return v15;
    }
    v9 = 1;
  }
  if ( v9 )
    return 0xFFFFFFFF;
  return (unsigned int)v8;
}

// --- End Function: sub_140300D10 (0x140300D10) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        char *a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        char *a7,
        char *a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 0x80;
  n0xF_5[0] = n4;
  v159 = a6;
  n0xF_17 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_25 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_25 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              v162,
              v161,
              n4_1,
              v166,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (a18 & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_26 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_95;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_18 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_129:
      n0xF_3 = n0xF + 0x80;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      v58 = v159;
      goto LABEL_131;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 0x22;
      }
      else
      {
LABEL_111:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_130;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_145:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 0xB;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_209:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            v164,
            __Val_0___1,
            _Newcapacity,
            a11,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_16 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_248:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_255;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 0x16;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_292;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_16 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_315:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    v147 = v161;
    qword_149B3B210(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
void __fastcall sub_1403045C0(
        unsigned int n4_1,
        __int64 *a2,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 v84; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char v89; // cl
  int v90; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v94; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  const void *Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *v110; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v112; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int v116; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v128; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v132; // [rsp+118h] [rbp+78h]
  char *v133; // [rsp+120h] [rbp+80h]
  __int64 *v134; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v132 = a4;
  v133 = a3;
  v134 = a2;
  n4 = n4_1;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  v128 = v12;
  if ( v11 && !sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity) )
    return;
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v20 = v117;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v147[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400_1 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400_1 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            sub_1402A6760(v14, _Whereptr, __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        sub_1402A6760(v14, _Whereptr_1, (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)__Val_0___1 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v142, __Val_0___1);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)__Val_0___1, &v130, &__Val_0___4);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      __Val_0___5 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v48 = *(_QWORD **)__Val_0___7;
        v49 = **(_QWORD ***)__Val_0___7;
        if ( v49 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        __Val_0___7 = __Val_0___6;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          __Val_0___3 = __Val_0___5;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        __Val_0___3 = __Val_0___5;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v57;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              sub_1402A6760(v14, _Whereptr_2, __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          sub_1402A6760(v14, _Whereptr_3, &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    __Val_0___1 = __Val_0___2;
    v29 = v143;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[__Val_0___4];
    v124 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 0x70);
    v69 = v120;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 0xA) = v29;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * n0x400], (__int64)(8 * n0x400) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v76 = *(_QWORD *)&v71[8 * n0x400_3];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_130;
    }
  }
  v84 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v84 = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(v84 & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_130:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(v128, n4, v133, v134, v132, __Val_0__, _Newcapacity, v146, n0x10_1, &a8);
    v123[0] = v87;
  }
  v89 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&FileTime,
            v128,
            (__int64)String,
            n4,
            v134,
            v133,
            v132,
            __Val_0__,
            _Newcapacity,
            a7,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &a8);
    v89 = a8;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (v89 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v83);
    v89 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v89 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v83);
    n2_126 = ::n2_126;
  }
  v83[v88] = 0;
  v94 = a8;
  v95 = (a8 & 1) != 0 && n2_125 == 2;
  v96 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = (const void *)Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v117;
LABEL_166:
    v116 = v123[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v128,
      Buffer,
      String,
      n4,
      v134,
      v133,
      v132,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v71,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      a8,
      v116);
    sub_1402A3D30(Buffer_3);
    v94 = a8;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v94 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v94 = a8;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (v94 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    v110 = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = v110[5];
        v112 = (_QWORD *)*v110;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)v110[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_190;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        v110[4] = 0;
        v110[5] = 0xF;
        *((_BYTE *)v110 + 0x10) = 0;
        sub_1402A3D30(v110);
        v110 = v112;
      }
      while ( v112 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: sub_1403090C0 (0x1403090C0) ---
void __fastcall sub_1403090C0(__int64 a1)
{
  const void *v1; // rcx

  v1 = *(const void **)(a1 + 8);
  if ( v1 )
    sub_147605980(v1);
}

// --- End Function: sub_1403090C0 (0x1403090C0) ---

// --- Function: unknown_libname_19 (0x14030E880) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_19(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: unknown_libname_19 (0x14030E880) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: sub_14031FF80 (0x14031FF80) ---
__int64 __fastcall sub_14031FF80(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x48);
}

// --- End Function: sub_14031FF80 (0x14031FF80) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_140332970 (0x140332970) ---
__int64 __fastcall sub_140332970(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v2 = (_QWORD *)*a1;
  if ( v2 )
  {
    sub_140307710(v2, a1[1], a1);
    v3 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_140332970 (0x140332970) ---

// --- Function: sub_140332A60 (0x140332A60) ---
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_140332A60(double a1)
{
  return (__m128)(*(_OWORD *)&a1 & xmmword_14819F760);
}

// --- End Function: sub_140332A60 (0x140332A60) ---

// --- Function: sub_1403335B0 (0x1403335B0) ---
__int64 __fastcall sub_1403335B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_1403335B0 (0x1403335B0) ---

// --- Function: unknown_libname_23 (0x1403376F0) ---
// Microsoft VisualC v14 64bit runtime
bool __fastcall unknown_libname_23(_QWORD *a1, _QWORD *a2)
{
  return *a1 != *a2;
}

// --- End Function: unknown_libname_23 (0x1403376F0) ---

// --- Function: sub_140337B60 (0x140337B60) ---
double *__fastcall sub_140337B60(double *a1, double *a2, double *a3)
{
  double v3; // xmm4_8
  double *result; // rax
  double v5; // xmm9_8
  double v6; // xmm11_8
  double v7; // xmm12_8
  double v8; // xmm13_8
  double v9; // xmm8_8
  double v10; // xmm6_8
  double v11; // xmm4_8
  double v12; // xmm3_8
  double v13; // kr00_8
  double v14; // xmm2_8
  double v15; // xmm1_8
  double v16; // xmm2_8

  v3 = a2[3];
  result = a1;
  v5 = a2[2];
  v6 = a2[1];
  v7 = a3[1];
  v8 = a3[2];
  v9 = v8 * v6 - v7 * v5 + *a3 * v3;
  v10 = *a3 * v5 - *a2 * v8 + v3 * v7;
  v11 = *a2 * v7 - *a3 * v6 + v3 * v8;
  v12 = *a2 * v10 - v6 * v9;
  v13 = v5 * v9 - *a2 * v11;
  v14 = v13 + a2[5];
  *a1 = v6 * v11 - v5 * v10 + a2[4] + *a3 + v6 * v11 - v5 * v10;
  v15 = v14 + v7 + v13;
  v16 = v12 + a2[6];
  a1[1] = v15;
  a1[2] = v16 + v8 + v12;
  return result;
}

// --- End Function: sub_140337B60 (0x140337B60) ---

// --- Function: sub_140337D80 (0x140337D80) ---
__int64 __fastcall sub_140337D80(__int64 a1, _QWORD *a2)
{
  *a2 = 0xFFFFFFFFFFFFFFFFuLL;
  return a1;
}

// --- End Function: sub_140337D80 (0x140337D80) ---

// --- Function: sub_14033A380 (0x14033A380) ---
_QWORD *__fastcall sub_14033A380(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_29;
  if ( n0xFFFF_29 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "IActor");
    n0xFFFF_29 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033A380 (0x14033A380) ---

// --- Function: sub_14033B1A0 (0x14033B1A0) ---
_QWORD *__fastcall sub_14033B1A0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_35;
  if ( n0xFFFF_35 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "IVehicle");
    n0xFFFF_35 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033B1A0 (0x14033B1A0) ---

// --- Function: sub_140342810 (0x140342810) ---
__int64 __fastcall sub_140342810(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  char *v3; // rbx
  unsigned __int64 v5; // r14
  __int64 v6; // rdi
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rdx
  _QWORD *v10; // rcx
  __int64 result; // rax
  char *v12; // r8
  unsigned __int64 v13; // r15
  char *v14; // rbp
  char *v15; // r15
  char *v16; // rbp
  __int64 v17; // rdi

  v3 = (char *)*a1;
  v5 = a3;
  v6 = a2;
  v7 = (__int64)(a1[2] - *a1) >> 6;
  if ( a3 <= v7 )
  {
    v12 = (char *)a1[1];
    v13 = (v12 - v3) >> 6;
    if ( v5 <= v13 )
    {
      v15 = &v3[0x40 * v5];
      if ( v5 )
      {
        v16 = v3 + 0xC;
        v17 = a2 + 8;
        do
        {
          *(_QWORD *)v3 = *(_QWORD *)(v17 - 8);
          *((_DWORD *)v16 + 0xFFFFFFFF) = *(_DWORD *)v17;
          *(double *)v16 = *(double *)(v17 + 4);
          *((_DWORD *)v16 + 2) = *(_DWORD *)(v17 + 0xC);
          *(double *)(v16 + 0xC) = *(double *)(v17 + 0x10);
          *((_DWORD *)v16 + 5) = *(_DWORD *)(v17 + 0x18);
          if ( v16 + 0x1C != (char *)(v17 + 0x20) )
            sub_140342500(
              v16 + 0x1C,
              *(_QWORD *)(v17 + 0x20),
              (__int64)(*(_QWORD *)(v17 + 0x28) - *(_QWORD *)(v17 + 0x20)) >> 3);
          v3 += 0x40;
          v16 += 0x40;
          v17 += 0x40;
          --v5;
        }
        while ( v5 );
      }
      result = sub_140307710(v15, a1[1], a1);
      a1[1] = (unsigned __int64)v15;
    }
    else
    {
      if ( v3 != v12 )
      {
        v14 = v3 + 0xC;
        do
        {
          *(_QWORD *)v3 = *(_QWORD *)v6;
          *((_DWORD *)v14 + 0xFFFFFFFF) = *(_DWORD *)(v6 + 8);
          *(double *)v14 = *(double *)(v6 + 0xC);
          *((_DWORD *)v14 + 2) = *(_DWORD *)(v6 + 0x14);
          *(double *)(v14 + 0xC) = *(double *)(v6 + 0x18);
          *((_DWORD *)v14 + 5) = *(_DWORD *)(v6 + 0x20);
          if ( v14 + 0x1C != (char *)(v6 + 0x28) )
            sub_140342500(
              v14 + 0x1C,
              *(_QWORD *)(v6 + 0x28),
              (__int64)(*(_QWORD *)(v6 + 0x30) - *(_QWORD *)(v6 + 0x28)) >> 3);
          v12 = (char *)a1[1];
          v3 += 0x40;
          v14 += 0x40;
          v6 += 0x40;
        }
        while ( v3 != v12 );
      }
      result = sub_14034F060(v6, v5 - v13, v12, a1);
      a1[1] = result;
    }
  }
  else
  {
    v8 = 0x3FFFFFFFFFFFFFFLL;
    if ( a3 > 0x3FFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = v7 >> 1;
    if ( v7 <= 0x3FFFFFFFFFFFFFFLL - (v7 >> 1) )
    {
      v8 = v9 + v7;
      if ( v9 + v7 < a3 )
        v8 = a3;
    }
    if ( v3 )
    {
      sub_140307710(v3, a1[1], a1);
      v10 = (_QWORD *)*a1;
      if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v10 - v10[0xFFFFFFFF] - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v10 = (_QWORD *)v10[0xFFFFFFFF];
      }
      sub_1402A3D30(v10);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    sub_140332540(a1, v8);
    result = sub_14034F060(v6, v5, *a1, a1);
    a1[1] = result;
  }
  return result;
}

// --- End Function: sub_140342810 (0x140342810) ---

// --- Function: sub_140344E10 (0x140344E10) ---
int *__fastcall sub_140344E10(__int64 a1, _BYTE *a2, int *a3)
{
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  int *v12; // rsi
  int *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  int *v16; // rbp
  size_t Size; // r8
  _QWORD *v18; // rcx
  int *result; // rax

  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 2;
  _Count = 0x3FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if ( v6 == 0x3FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 2;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x3FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<int>::allocate((std::allocator<int> *)a1, _Count);
  v12[v4] = *a3;
  v13 = v12;
  v14 = *(_BYTE **)(a1 + 8);
  v15 = *(_BYTE **)a1;
  v16 = &v12[v4];
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = v16 + 1;
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  v18 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v18) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v18 - v18[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v18 = (_QWORD *)v18[0xFFFFFFFF];
    }
    sub_1402A3D30(v18);
  }
  *(_QWORD *)a1 = v12;
  result = v16;
  *(_QWORD *)(a1 + 8) = &v12[v10];
  *(_QWORD *)(a1 + 0x10) = &v12[_Count];
  return result;
}

// --- End Function: sub_140344E10 (0x140344E10) ---

// --- Function: sub_140356FD0 (0x140356FD0) ---
__int64 __fastcall sub_140356FD0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  const char *p_null_1; // rax
  const char *p_null; // rdx
  unsigned __int64 v7; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Name";
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_1 = (const char *)a2[1];
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  v7 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v7;
  while ( p_null[v7] );
  *(_QWORD *)(a1 + 0x68) = v7;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "EntityId";
  *(_BYTE *)(a1 + 0xC9) = 1;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x90) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0xA0) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4C70;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  *(_QWORD *)(a1 + 0xD8) = 0x17;
  return sub_140356B50(a1 + 0xE0, a4, a5) + 2;
}

// --- End Function: sub_140356FD0 (0x140356FD0) ---

// --- Function: sub_140359B80 (0x140359B80) ---
__int64 __fastcall sub_140359B80(unsigned int a1)
{
  return a1;
}

// --- End Function: sub_140359B80 (0x140359B80) ---

// --- Function: sub_14035AA80 (0x14035AA80) ---
__int64 __fastcall sub_14035AA80(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 0x2D;
    v6 = 1;
    a4 = -a4 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = 0xFFFFFFFF;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
      return 0xFFFFFFFFLL;
    ++v6;
    v10 = a4 % 0xA;
    a4 /= 0xA;
    *(_BYTE *)(v8 + v4) = v10 + 0x30;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_14035AA80 (0x14035AA80) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035BDF0 (0x14035BDF0) ---
__int64 __fastcall sub_14035BDF0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  unsigned __int64 *v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rcx
  __int64 v9; // rbx
  __int64 v10; // rbx
  bool v11; // al
  char v13; // [rsp+40h] [rbp+8h] BYREF

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v3 = 0;
  *(double *)(a1 + 0x10) = *(double *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  if ( a3 )
  {
    v5 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a3 + 0x38LL))(a3, &v13);
    v6 = *v5;
    *(_QWORD *)(a1 + 0x18) = *v5;
    if ( v6 )
    {
      v7 = v6;
      v8 = HIWORD(v6);
      v9 = v7 & 0xFFFFFFFFFFFFLL;
      v10 = (v8 & 0xF000) != 0 ? v9 & 0xFFFFFF000000LL : v9 - 6;
      if ( *(_WORD *)(v10 + 2) == (v8 & 0xFFF) )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v11 = sub_140539D80()) )
          v11 = 1;
        if ( *(_WORD *)(v10 + 4) == 2 && v11 || sub_140392020((_QWORD *)(a1 + 0x18)) )
          v3 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)(a1 + 0x18)
                                                                                 & 0xFFFFFFFFFFFFLL)
                                                                     + 8LL))(
                            *(_QWORD *)(a1 + 0x18) & 0xFFFFFFFFFFFFLL,
                            &v13);
      }
    }
    *(_QWORD *)(a1 + 0x20) = v3;
  }
  return a1;
}

// --- End Function: sub_14035BDF0 (0x14035BDF0) ---

// --- Function: sub_140362070 (0x140362070) ---
__int64 __fastcall sub_140362070(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        float a9,
        float a10,
        float a11,
        float a12,
        float a13,
        float a14,
        float a15,
        int a16)
{
  *(_QWORD *)(a1 + 0x18) = a5;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a4;
  *(_QWORD *)(a1 + 0x40) = &off_1481B0218;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_DWORD *)(a1 + 0x20) = 0;
  *(_OWORD *)(a1 + 0x48) = *(_OWORD *)(a6 + 8);
  *(double *)(a1 + 0x58) = *(double *)(a6 + 0x18);
  *(_OWORD *)(a1 + 0x60) = *(_OWORD *)a7;
  *(double *)(a1 + 0x70) = *(double *)(a7 + 0x10);
  *(double *)(a1 + 0x78) = *(double *)a8;
  *(_DWORD *)(a1 + 0x80) = *(_DWORD *)(a8 + 8);
  *(_QWORD *)(a1 + 0xB8) = (char *)&qword_149B3B33C + 4;
  *(_QWORD *)(a1 + 0x84) = 0;
  *(_DWORD *)(a1 + 0x8C) = 0x3F800000;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_DWORD *)(a1 + 0xD0) = 0;
  *(float *)(a1 + 0x90) = a9;
  *(float *)(a1 + 0x9C) = a11;
  *(float *)(a1 + 0x94) = a10;
  *(float *)(a1 + 0xA4) = a13;
  *(float *)(a1 + 0xA0) = a12;
  *(_DWORD *)(a1 + 0xC0) = a16;
  *(float *)(a1 + 0xB0) = a15;
  *(float *)(a1 + 0xAC) = a14;
  *(_DWORD *)(a1 + 0x98) = 0;
  *(_DWORD *)(a1 + 0xA8) = 0;
  *(_WORD *)(a1 + 0xC4) = 0x100;
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xF4) = 0;
  *(_BYTE *)(a1 + 0xFC) = 1;
  *(_QWORD *)(a1 + 0x108) = (char *)&qword_149B3B33C + 4;
  *(_QWORD *)(a1 + 0x110) = (char *)&qword_149B3B33C + 4;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_DWORD *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x13C) = 0x3F800000;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_QWORD *)(a1 + 0x170) = 0;
  *(_DWORD *)(a1 + 0xE0) = 0;
  *(_WORD *)(a1 + 0xE4) = 0;
  *(_DWORD *)(a1 + 0xE8) = 0;
  *(_QWORD *)(a1 + 0xEC) = 0x3F800000;
  *(_WORD *)(a1 + 0x100) = 0;
  *(_DWORD *)(a1 + 0x120) = 0x3F800000;
  *(_DWORD *)(a1 + 0x124) = 0xBF800000;
  *(_DWORD *)(a1 + 0x128) = 0;
  *(_BYTE *)(a1 + 0x12C) = 0;
  *(_QWORD *)(a1 + 0x130) = 4;
  *(_DWORD *)(a1 + 0x144) = 0x43FA0000;
  *(_DWORD *)(a1 + 0x148) = 0xBF800000;
  *(_DWORD *)(a1 + 0x14C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x150) = 0x3F933333;
  *(_DWORD *)(a1 + 0x154) = 0x3F800000;
  *(_DWORD *)(a1 + 0x158) = 0x3F800000;
  *(_WORD *)(a1 + 0x15C) = 0;
  *(_QWORD *)(a1 + 0x178) = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
  return a1;
}

// --- End Function: sub_140362070 (0x140362070) ---

// --- Function: sub_1403624E0 (0x1403624E0) ---
__int64 __fastcall sub_1403624E0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a2 + 0x20);
  *(_DWORD *)(a1 + 0x28) = *(_DWORD *)(a2 + 0x28);
  *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = &off_1481B0218;
  *(_OWORD *)(a1 + 0x40) = *(_OWORD *)(a2 + 0x40);
  *(double *)(a1 + 0x50) = *(double *)(a2 + 0x50);
  *(_DWORD *)(a1 + 0x58) = *(_DWORD *)(a2 + 0x58);
  *(_DWORD *)(a1 + 0x5C) = *(_DWORD *)(a2 + 0x5C);
  *(_DWORD *)(a1 + 0x60) = *(_DWORD *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x64) = *(_DWORD *)(a2 + 0x64);
  *(_DWORD *)(a1 + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x6C) = *(_DWORD *)(a2 + 0x6C);
  *(_DWORD *)(a1 + 0x70) = *(_DWORD *)(a2 + 0x70);
  *(_DWORD *)(a1 + 0x74) = *(_DWORD *)(a2 + 0x74);
  *(_DWORD *)(a1 + 0x78) = *(_DWORD *)(a2 + 0x78);
  *(_DWORD *)(a1 + 0x7C) = *(_DWORD *)(a2 + 0x7C);
  *(_BYTE *)(a1 + 0x80) = *(_BYTE *)(a2 + 0x80);
  *(_QWORD *)(a1 + 0x88) = *(_QWORD *)(a2 + 0x88);
  *(_OWORD *)(a1 + 0x90) = *(_OWORD *)(a2 + 0x90);
  *(double *)(a1 + 0xA0) = *(double *)(a2 + 0xA0);
  *(double *)(a1 + 0xA8) = *(double *)(a2 + 0xA8);
  *(_DWORD *)(a1 + 0xB0) = *(_DWORD *)(a2 + 0xB0);
  *(double *)(a1 + 0xB4) = *(double *)(a2 + 0xB4);
  *(_DWORD *)(a1 + 0xBC) = *(_DWORD *)(a2 + 0xBC);
  *(double *)(a1 + 0xC0) = *(double *)(a2 + 0xC0);
  *(_DWORD *)(a1 + 0xC8) = *(_DWORD *)(a2 + 0xC8);
  *(_DWORD *)(a1 + 0xD8) = *(_DWORD *)(a2 + 0xD8);
  *(_DWORD *)(a1 + 0xCC) = *(_DWORD *)(a2 + 0xCC);
  *(_DWORD *)(a1 + 0xD0) = *(_DWORD *)(a2 + 0xD0);
  *(_DWORD *)(a1 + 0xD4) = *(_DWORD *)(a2 + 0xD4);
  *(_DWORD *)(a1 + 0xDC) = *(_DWORD *)(a2 + 0xDC);
  *(_DWORD *)(a1 + 0xE0) = *(_DWORD *)(a2 + 0xE0);
  *(_BYTE *)(a1 + 0xE4) = *(_BYTE *)(a2 + 0xE4);
  *(_BYTE *)(a1 + 0xE5) = *(_BYTE *)(a2 + 0xE5);
  *(_BYTE *)(a1 + 0xE6) = *(_BYTE *)(a2 + 0xE6);
  *(_BYTE *)(a1 + 0xE7) = *(_BYTE *)(a2 + 0xE7);
  *(_BYTE *)(a1 + 0xE8) = *(_BYTE *)(a2 + 0xE8);
  *(_BYTE *)(a1 + 0xE9) = *(_BYTE *)(a2 + 0xE9);
  *(_BYTE *)(a1 + 0xEA) = *(_BYTE *)(a2 + 0xEA);
  *(_BYTE *)(a1 + 0xEB) = *(_BYTE *)(a2 + 0xEB);
  *(_BYTE *)(a1 + 0xEC) = *(_BYTE *)(a2 + 0xEC);
  *(_BYTE *)(a1 + 0xED) = *(_BYTE *)(a2 + 0xED);
  *(_QWORD *)(a1 + 0xF0) = *(_QWORD *)(a2 + 0xF0);
  *(_DWORD *)(a1 + 0xF8) = *(_DWORD *)(a2 + 0xF8);
  *(_OWORD *)(a1 + 0xFC) = *(_OWORD *)(a2 + 0xFC);
  *(_QWORD *)(a1 + 0x110) = &off_1481B0218;
  *(_OWORD *)(a1 + 0x118) = *(_OWORD *)(a2 + 0x118);
  *(double *)(a1 + 0x128) = *(double *)(a2 + 0x128);
  *(_DWORD *)(a1 + 0x130) = *(_DWORD *)(a2 + 0x130);
  *(_DWORD *)(a1 + 0x134) = *(_DWORD *)(a2 + 0x134);
  *(_DWORD *)(a1 + 0x138) = *(_DWORD *)(a2 + 0x138);
  *(_BYTE *)(a1 + 0x13C) = *(_BYTE *)(a2 + 0x13C);
  *(_BYTE *)(a1 + 0x13D) = *(_BYTE *)(a2 + 0x13D);
  *(_DWORD *)(a1 + 0x140) = *(_DWORD *)(a2 + 0x140);
  *(_OWORD *)(a1 + 0x144) = *(_OWORD *)(a2 + 0x144);
  *(_WORD *)(a1 + 0x154) = *(_WORD *)(a2 + 0x154);
  *(_QWORD *)(a1 + 0x158) = *(_QWORD *)(a2 + 0x158);
  return a1;
}

// --- End Function: sub_1403624E0 (0x1403624E0) ---

// --- Function: sub_1403627A0 (0x1403627A0) ---
__int64 __fastcall sub_1403627A0(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        float a6,
        int a7,
        int a8,
        int a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  __int64 result; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a4;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x28) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x38) = &off_1481B0218;
  *(_OWORD *)(a1 + 0x40) = *(_OWORD *)(a5 + 8);
  *(double *)(a1 + 0x50) = *(double *)(a5 + 0x18);
  *(_DWORD *)(a1 + 0x70) = a7;
  *(_DWORD *)(a1 + 0x74) = a9;
  *(_DWORD *)(a1 + 0x78) = a8;
  *(_QWORD *)(a1 + 0x88) = a10;
  *(float *)(a1 + 0x64) = a6;
  *(float *)(a1 + 0x68) = a6;
  *(_DWORD *)(a1 + 0x58) = 0x3F800000;
  *(_QWORD *)(a1 + 0x5C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x6C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x7C) = 0;
  *(_BYTE *)(a1 + 0x80) = 0;
  *(_OWORD *)(a1 + 0x90) = *(_OWORD *)a11;
  *(double *)(a1 + 0xA0) = *(double *)(a11 + 0x10);
  *(double *)(a1 + 0xA8) = *(double *)a12;
  *(_DWORD *)(a1 + 0xB0) = *(_DWORD *)(a12 + 8);
  *(double *)(a1 + 0xB4) = *(double *)a13;
  *(_DWORD *)(a1 + 0xBC) = *(_DWORD *)(a13 + 8);
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_DWORD *)(a1 + 0xD8) = 0x3F800000;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_BYTE *)(a1 + 0x108) = 1;
  *(_QWORD *)(a1 + 0xDC) = 0;
  *(_QWORD *)(a1 + 0xE4) = 0;
  *(_WORD *)(a1 + 0xEC) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x110) = &off_1481B0218;
  *(_QWORD *)(a1 + 0x130) = 0;
  *(_DWORD *)(a1 + 0x138) = 0;
  *(_WORD *)(a1 + 0x13C) = 0;
  *(_DWORD *)(a1 + 0x140) = 0;
  *(_DWORD *)(a1 + 0x144) = 0x800000;
  *(_DWORD *)(a1 + 0x148) = 0x800000;
  *(_DWORD *)(a1 + 0x14C) = 0x800000;
  *(_DWORD *)(a1 + 0x150) = 0x800000;
  sub_1403B3F00((_WORD *)(a1 + 0x154), a2);
  result = a1;
  *(_QWORD *)(a1 + 0x158) = 0;
  return result;
}

// --- End Function: sub_1403627A0 (0x1403627A0) ---

// --- Function: sub_140362C80 (0x140362C80) ---
__int64 __fastcall sub_140362C80(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *a2;
  result = a1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

// --- End Function: sub_140362C80 (0x140362C80) ---

// --- Function: sub_14036BD90 (0x14036BD90) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_14036BD90(__int64 a1, __int64 a2, double a3)
{
  __m128 v3; // xmm2
  __int64 result; // rax

  v3 = _mm_shuffle_ps(*(__m128 *)&a3, *(__m128 *)&a3, 0);
  *(__m128 *)(a1 + 8) = v3;
  *(float *)(a1 + 0x18) = v3.m128_f32[0];
  *(_QWORD *)a1 = &off_1481B0218;
  result = a1;
  *(float *)(a1 + 0x1C) = v3.m128_f32[0];
  return result;
}

// --- End Function: sub_14036BD90 (0x14036BD90) ---

// --- Function: sub_14036BE70 (0x14036BE70) ---
_QWORD *__fastcall sub_14036BE70(_QWORD *a1)
{
  *a1 = &off_1481B0218;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  return a1;
}

// --- End Function: sub_14036BE70 (0x14036BE70) ---

// --- Function: sub_14036C130 (0x14036C130) ---
__int64 __fastcall sub_14036C130(__int64 a1, const void **a2)
{
  char *v4; // rdi
  int *v5; // rax
  size_t Size; // rsi
  _DWORD *v7; // rax
  _BYTE *v8; // rbx
  unsigned __int64 n0x25; // r15
  unsigned __int64 v10; // rbp
  _DWORD *v11; // rax
  size_t Size_1; // r8
  const void *v13; // rdx
  _DWORD *v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  char *v17; // rdi
  __int128 v18; // xmm0
  const void **v19; // rbx
  void *v20; // rcx
  char **v21; // rax
  char *v22; // rdx
  __int128 v24; // [rsp+20h] [rbp-68h] BYREF
  __int64 v25[3]; // [rsp+30h] [rbp-58h] BYREF

  v4 = (char *)&qword_149B3B33C + 4;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = (char *)&qword_149B3B33C + 4;
  *(_QWORD *)(a1 + 0x18) = (char *)&qword_149B3B33C + 4;
  v5 = (int *)*a2;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( (unsigned int)Size > 0x24 && *((_BYTE *)v5 + 0x24) == 0x7C )
  {
    v7 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    v8 = v7 + 2;
    *v7 = Size;
    v7[1] = Size;
    *((_BYTE *)v7 + Size + 8) = 0;
    if ( v7 + 2 != *a2 )
      memcpy(v7 + 2, *a2, Size);
    n0x25 = *((int *)v8 + 0xFFFFFFFE);
    if ( n0x25 > 0x24 && v8[0x24] == 0x7C )
    {
      v10 = n0x25 - 0x25;
      if ( n0x25 - 0x25 <= n0x25 )
      {
        if ( n0x25 == 0x25
          || (v11 = (_DWORD *)allocWithProfilerInfo(n0x25 - 0x1C, 0),
              v4 = (char *)(v11 + 2),
              *v11 = v10,
              v11[1] = v10,
              *((_BYTE *)v11 + v10 + 8) = 0,
              v11 + 2 == (_DWORD *)(v8 + 0x25)) )
        {
LABEL_15:
          v15 = *(_QWORD *)(a1 + 0x10);
          *(_QWORD *)(a1 + 0x10) = v4;
          *(_QWORD *)&v24 = v15;
          if ( *(_DWORD *)(v15 - 8) )
          {
            sub_1403E9810((char **)&v24, 0, 0x20);
            v15 = v24;
          }
          if ( *(int *)(v15 - 4) > 0 )
            sub_147605980((const void *)(v15 - 8));
          if ( (unsigned __int64)*((int *)v8 + 0xFFFFFFFE) > 0x24 && v8[0x24] == 0x7C )
          {
            v16 = allocWithProfilerInfo(0x2Eu, 0);
            v17 = (char *)(v16 + 8);
            *(_DWORD *)v16 = 0x25;
            *(_DWORD *)(v16 + 4) = 0x25;
            *(_BYTE *)(v16 + 0x2D) = 0;
            if ( (_BYTE *)(v16 + 8) != v8 )
              memcpy((void *)(v16 + 8), v8, 0x25u);
            v18 = *(_OWORD *)sub_1402BC380(v25, v17);
            v24 = v18;
            if ( *((int *)v17 + 0xFFFFFFFF) <= 0 )
              goto LABEL_27;
            sub_147605980(v17 + 0xFFFFFFF8);
          }
          else
          {
            v24 = 0u;
          }
          v18 = v24;
LABEL_27:
          *(_OWORD *)a1 = v18;
          if ( *((int *)v8 + 0xFFFFFFFF) > 0 )
            sub_147605980(v8 + 0xFFFFFFF8);
          goto LABEL_32;
        }
        Size_1 = n0x25 - 0x25;
        v13 = v8 + 0x25;
LABEL_14:
        memcpy(v4, v13, Size_1);
        goto LABEL_15;
      }
    }
    else if ( !(_DWORD)n0x25 )
    {
      goto LABEL_15;
    }
    v14 = (_DWORD *)allocWithProfilerInfo(n0x25 + 9, 0);
    v4 = (char *)(v14 + 2);
    *v14 = n0x25;
    v14[1] = n0x25;
    *((_BYTE *)v14 + n0x25 + 8) = 0;
    if ( v14 + 2 == (_DWORD *)v8 )
      goto LABEL_15;
    Size_1 = n0x25;
    v13 = v8;
    goto LABEL_14;
  }
  sub_1403E9810((char **)(a1 + 0x10), v5[0xFFFFFFFE], 0x20);
  v19 = (const void **)(a1 + 0x10);
  if ( (_DWORD)Size )
  {
    v19 = (const void **)(a1 + 0x10);
    v20 = *(void **)(a1 + 0x10);
    if ( v20 != *a2 )
    {
      memcpy(v20, *a2, Size);
LABEL_32:
      v19 = (const void **)(a1 + 0x10);
    }
  }
  v21 = (char **)sub_1403D8000((void **)&v24, v19);
  v22 = *v21;
  *v21 = (char *)*v19;
  *v19 = v22;
  if ( *((_DWORD *)*v21 + 0xFFFFFFFE) )
    sub_1403E9810(v21, 0, 0x20);
  if ( *(int *)(v24 - 4) > 0 )
    sub_147605980((const void *)(v24 - 8));
  sub_1403CE720((void **)v19);
  return a1;
}

// --- End Function: sub_14036C130 (0x14036C130) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_1403715C0 (0x1403715C0) ---
__int64 __fastcall sub_1403715C0(__int64 *a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x48LL))(v2);
  *a1 = 0;
  return result;
}

// --- End Function: sub_1403715C0 (0x1403715C0) ---

// --- Function: sub_140372C50 (0x140372C50) ---
void __fastcall sub_140372C50(_QWORD *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rcx

  sub_1403E9FB0(a1 + 0x2F, 0, 0);
  sub_140332970(a1 + 0x2C);
  v2 = a1[0x23];
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 0x48LL))(v2);
  a1[0x23] = 0;
  if ( *(int *)(a1[0x22] - 4LL) > 0 )
    sub_147605980((const void *)(a1[0x22] - 8LL));
  if ( *(int *)(a1[0x21] - 4LL) > 0 )
    sub_147605980((const void *)(a1[0x21] - 8LL));
  if ( *(int *)(a1[0x17] - 4LL) > 0 )
    sub_147605980((const void *)(a1[0x17] - 8LL));
  a1[8] = &off_1481A0DB8;
  v3 = (_QWORD *)a1[5];
  if ( v3 )
  {
    if ( ((a1[7] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    a1[5] = 0;
    a1[6] = 0;
    a1[7] = 0;
  }
}

// --- End Function: sub_140372C50 (0x140372C50) ---

// --- Function: sub_140372D50 (0x140372D50) ---
void *(__fastcall **__fastcall sub_140372D50(__int64 a1))(FDefaultModuleImpl *__hidden this, unsigned int)
{
  void *(__fastcall **result)(FDefaultModuleImpl *__hidden, unsigned int); // rax

  result = &off_1481A0DB8;
  *(_QWORD *)(a1 + 0x110) = &off_1481A0DB8;
  *(_QWORD *)(a1 + 0x38) = &off_1481A0DB8;
  return result;
}

// --- End Function: sub_140372D50 (0x140372D50) ---

// --- Function: assignCStringToStringStructure (0x140377FA0) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **a1, _BYTE *a2)
{
  unsigned __int64 Size; // rax

  if ( a2 )
  {
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DE230(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DE230(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x140377FA0) ---

// --- Function: sub_1403790A0 (0x1403790A0) ---
unsigned __int64 *__fastcall sub_1403790A0(unsigned __int64 *a1, __int64 *a2)
{
  if ( a1 != (unsigned __int64 *)a2 )
    sub_140342810(a1, *a2, (a2[1] - *a2) >> 6);
  return a1;
}

// --- End Function: sub_1403790A0 (0x1403790A0) ---

// --- Function: sub_14037A290 (0x14037A290) ---
__int64 __fastcall sub_14037A290(__int64 a1, __int64 a2)
{
  unsigned __int64 *v4; // rcx
  unsigned __int64 Size; // rsi
  const void *v6; // rdx
  void *v7; // rcx
  unsigned __int64 Size_1; // rsi
  const void *v9; // rdx
  void *v10; // rcx
  unsigned __int64 Size_2; // rsi
  const void *v12; // rdx
  void *v13; // rcx
  __int64 v14; // rsi
  __int64 v15; // rcx

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  *(_DWORD *)(a1 + 0x20) = *(_DWORD *)(a2 + 0x20);
  v4 = (unsigned __int64 *)(a1 + 0x28);
  if ( v4 != (unsigned __int64 *)(a2 + 0x28) )
    sub_1403074A0(v4, *(char **)(a2 + 0x28), (__int64)(*(_QWORD *)(a2 + 0x30) - *(_QWORD *)(a2 + 0x28)) >> 3);
  *(_DWORD *)(a1 + 0x48) = *(_DWORD *)(a2 + 0x48);
  *(_DWORD *)(a1 + 0x4C) = *(_DWORD *)(a2 + 0x4C);
  *(_DWORD *)(a1 + 0x50) = *(_DWORD *)(a2 + 0x50);
  *(_DWORD *)(a1 + 0x54) = *(_DWORD *)(a2 + 0x54);
  *(_DWORD *)(a1 + 0x58) = *(_DWORD *)(a2 + 0x58);
  *(_DWORD *)(a1 + 0x5C) = *(_DWORD *)(a2 + 0x5C);
  *(_OWORD *)(a1 + 0x60) = *(_OWORD *)(a2 + 0x60);
  *(double *)(a1 + 0x70) = *(double *)(a2 + 0x70);
  *(double *)(a1 + 0x78) = *(double *)(a2 + 0x78);
  *(_DWORD *)(a1 + 0x80) = *(_DWORD *)(a2 + 0x80);
  *(double *)(a1 + 0x84) = *(double *)(a2 + 0x84);
  *(_DWORD *)(a1 + 0x8C) = *(_DWORD *)(a2 + 0x8C);
  *(_DWORD *)(a1 + 0x90) = *(_DWORD *)(a2 + 0x90);
  *(_DWORD *)(a1 + 0x94) = *(_DWORD *)(a2 + 0x94);
  *(_DWORD *)(a1 + 0x98) = *(_DWORD *)(a2 + 0x98);
  *(_DWORD *)(a1 + 0x9C) = *(_DWORD *)(a2 + 0x9C);
  *(_DWORD *)(a1 + 0xA0) = *(_DWORD *)(a2 + 0xA0);
  *(_DWORD *)(a1 + 0xA4) = *(_DWORD *)(a2 + 0xA4);
  *(_DWORD *)(a1 + 0xA8) = *(_DWORD *)(a2 + 0xA8);
  *(_DWORD *)(a1 + 0xAC) = *(_DWORD *)(a2 + 0xAC);
  *(_DWORD *)(a1 + 0xB0) = *(_DWORD *)(a2 + 0xB0);
  Size = *(int *)(*(_QWORD *)(a2 + 0xB8) - 8LL);
  sub_1403E9810((char **)(a1 + 0xB8), Size, 0x20);
  if ( Size )
  {
    v6 = *(const void **)(a2 + 0xB8);
    v7 = *(void **)(a1 + 0xB8);
    if ( v7 != v6 )
      memcpy(v7, v6, Size);
  }
  *(_DWORD *)(a1 + 0xC0) = *(_DWORD *)(a2 + 0xC0);
  *(_BYTE *)(a1 + 0xC4) = *(_BYTE *)(a2 + 0xC4);
  *(_BYTE *)(a1 + 0xC5) = *(_BYTE *)(a2 + 0xC5);
  *(double *)(a1 + 0xC8) = *(double *)(a2 + 0xC8);
  *(_DWORD *)(a1 + 0xD0) = *(_DWORD *)(a2 + 0xD0);
  *(_QWORD *)(a1 + 0xD8) = *(_QWORD *)(a2 + 0xD8);
  *(_DWORD *)(a1 + 0xE0) = *(_DWORD *)(a2 + 0xE0);
  *(_BYTE *)(a1 + 0xE4) = *(_BYTE *)(a2 + 0xE4);
  *(_BYTE *)(a1 + 0xE5) = *(_BYTE *)(a2 + 0xE5);
  *(_DWORD *)(a1 + 0xE8) = *(_DWORD *)(a2 + 0xE8);
  *(_DWORD *)(a1 + 0xEC) = *(_DWORD *)(a2 + 0xEC);
  *(_OWORD *)(a1 + 0xF0) = *(_OWORD *)(a2 + 0xF0);
  *(_WORD *)(a1 + 0x100) = *(_WORD *)(a2 + 0x100);
  Size_1 = *(int *)(*(_QWORD *)(a2 + 0x108) - 8LL);
  sub_1403E9810((char **)(a1 + 0x108), Size_1, 0x20);
  if ( Size_1 )
  {
    v9 = *(const void **)(a2 + 0x108);
    v10 = *(void **)(a1 + 0x108);
    if ( v10 != v9 )
      memcpy(v10, v9, Size_1);
  }
  Size_2 = *(int *)(*(_QWORD *)(a2 + 0x110) - 8LL);
  sub_1403E9810((char **)(a1 + 0x110), Size_2, 0x20);
  if ( Size_2 )
  {
    v12 = *(const void **)(a2 + 0x110);
    v13 = *(void **)(a1 + 0x110);
    if ( v13 != v12 )
      memcpy(v13, v12, Size_2);
  }
  v14 = *(_QWORD *)(a2 + 0x118);
  if ( *(_QWORD *)(a1 + 0x118) != v14 )
  {
    if ( v14 )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v14 + 0x40LL))(*(_QWORD *)(a2 + 0x118));
    v15 = *(_QWORD *)(a1 + 0x118);
    if ( v15 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x48LL))(v15);
    *(_QWORD *)(a1 + 0x118) = v14;
  }
  *(_DWORD *)(a1 + 0x120) = *(_DWORD *)(a2 + 0x120);
  *(_DWORD *)(a1 + 0x124) = *(_DWORD *)(a2 + 0x124);
  *(_DWORD *)(a1 + 0x128) = *(_DWORD *)(a2 + 0x128);
  *(_BYTE *)(a1 + 0x12C) = *(_BYTE *)(a2 + 0x12C);
  *(_DWORD *)(a1 + 0x130) = *(_DWORD *)(a2 + 0x130);
  *(double *)(a1 + 0x134) = *(double *)(a2 + 0x134);
  *(_DWORD *)(a1 + 0x13C) = *(_DWORD *)(a2 + 0x13C);
  *(_DWORD *)(a1 + 0x140) = *(_DWORD *)(a2 + 0x140);
  *(_DWORD *)(a1 + 0x144) = *(_DWORD *)(a2 + 0x144);
  *(_DWORD *)(a1 + 0x148) = *(_DWORD *)(a2 + 0x148);
  *(_DWORD *)(a1 + 0x14C) = *(_DWORD *)(a2 + 0x14C);
  *(_DWORD *)(a1 + 0x150) = *(_DWORD *)(a2 + 0x150);
  *(_DWORD *)(a1 + 0x154) = *(_DWORD *)(a2 + 0x154);
  *(_DWORD *)(a1 + 0x158) = *(_DWORD *)(a2 + 0x158);
  *(_WORD *)(a1 + 0x15C) = *(_WORD *)(a2 + 0x15C);
  if ( a1 + 0x160 != a2 + 0x160 )
    sub_140342810(
      (unsigned __int64 *)(a1 + 0x160),
      *(_QWORD *)(a2 + 0x160),
      (__int64)(*(_QWORD *)(a2 + 0x168) - *(_QWORD *)(a2 + 0x160)) >> 6);
  sub_1403780D0(a1 + 0x178, a2 + 0x178);
  return a1;
}

// --- End Function: sub_14037A290 (0x14037A290) ---

// --- Function: sub_14037F610 (0x14037F610) ---
bool __fastcall sub_14037F610(__int64 a1, __int64 a2)
{
  return a1 != a2;
}

// --- End Function: sub_14037F610 (0x14037F610) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1 & 0xFFFFFFFFFFFFLL, 0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: sub_14037FC70 (0x14037FC70) ---
const ULONG_PTR *__fastcall sub_14037FC70(__int64 a1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)a1 )
    return *(const ULONG_PTR **)a1;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14037FC70 (0x14037FC70) ---

// --- Function: sub_140380170 (0x140380170) ---
__int64 __fastcall sub_140380170(__int64 a1, __int64 a2, float *a3)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &off_1481B0218;
  result = a1;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(double *)(a1 + 0x18) = *(double *)(a2 + 0x18);
  *(float *)(a1 + 8) = a3[2] * *(float *)(a1 + 8);
  *(float *)(a1 + 0xC) = a3[3] * *(float *)(a1 + 0xC);
  *(float *)(a1 + 0x10) = a3[4] * *(float *)(a1 + 0x10);
  *(float *)(a1 + 0x14) = a3[5] * *(float *)(a1 + 0x14);
  *(float *)(a1 + 0x18) = a3[6] * *(float *)(a1 + 0x18);
  *(float *)(a1 + 0x1C) = a3[7] * *(float *)(a1 + 0x1C);
  return result;
}

// --- End Function: sub_140380170 (0x140380170) ---

// --- Function: sub_140380200 (0x140380200) ---
__int64 __fastcall sub_140380200(__int64 a1, __int64 a2, __int64 _R8)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &off_1481B0218;
  result = a1;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(double *)(a1 + 0x18) = *(double *)(a2 + 0x18);
  __asm { vbroadcastss xmm2, dword ptr [r8] }
  *(__m128 *)(a1 + 8) = _mm_mul_ps(_XMM2, *(__m128 *)(a1 + 8));
  *(float *)(a1 + 0x18) = _XMM2.m128_f32[0] * *(float *)(a1 + 0x18);
  *(float *)(a1 + 0x1C) = _XMM2.m128_f32[0] * *(float *)(a1 + 0x1C);
  return result;
}

// --- End Function: sub_140380200 (0x140380200) ---

// --- Function: sub_1403803F0 (0x1403803F0) ---
__int64 __fastcall sub_1403803F0(__int64 a1, __int64 a2, float *a3)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &off_1481B0218;
  result = a1;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(double *)(a1 + 0x18) = *(double *)(a2 + 0x18);
  *(float *)(a1 + 8) = *(float *)(a1 + 8) - a3[2];
  *(float *)(a1 + 0xC) = *(float *)(a1 + 0xC) - a3[3];
  *(float *)(a1 + 0x10) = *(float *)(a1 + 0x10) - a3[4];
  *(float *)(a1 + 0x14) = *(float *)(a1 + 0x14) - a3[5];
  *(float *)(a1 + 0x18) = *(float *)(a1 + 0x18) - a3[6];
  *(float *)(a1 + 0x1C) = *(float *)(a1 + 0x1C) - a3[7];
  return result;
}

// --- End Function: sub_1403803F0 (0x1403803F0) ---

// --- Function: sub_140380680 (0x140380680) ---
bool __fastcall sub_140380680(float *a1, float a2)
{
  return a2 >= (float)((float)((float)((float)((float)(a1[3] + a1[2]) + a1[4]) + a1[5]) + a1[6]) + a1[7]);
}

// --- End Function: sub_140380680 (0x140380680) ---

// --- Function: sub_140384920 (0x140384920) ---
float *__fastcall sub_140384920(float *a1, float *a2)
{
  a1[2] = a2[2] + a1[2];
  a1[3] = a2[3] + a1[3];
  a1[4] = a2[4] + a1[4];
  a1[5] = a2[5] + a1[5];
  a1[6] = a2[6] + a1[6];
  a1[7] = a2[7] + a1[7];
  return a1;
}

// --- End Function: sub_140384920 (0x140384920) ---

// --- Function: sub_140384A00 (0x140384A00) ---
float *__fastcall sub_140384A00(float *a1, float *a2)
{
  a1[2] = a1[2] - a2[2];
  a1[3] = a1[3] - a2[3];
  a1[4] = a1[4] - a2[4];
  a1[5] = a1[5] - a2[5];
  a1[6] = a1[6] - a2[6];
  a1[7] = a1[7] - a2[7];
  return a1;
}

// --- End Function: sub_140384A00 (0x140384A00) ---

// --- Function: p_p_p_sub_140384A94 (0x140384A94) ---
void __fastcall p_p_p_sub_140384A94(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
}

// --- End Function: p_p_p_sub_140384A94 (0x140384A94) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 + 0xFFFFFFFA;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_14039B2F0 (0x14039B2F0) ---
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_14039B2F0(__int64 a1, double a2)
{
  _XMM2 = *(_OWORD *)(a1 + 8);
  _mm_shuffle_ps(*(__m128 *)&a2, *(__m128 *)&a2, 0);
  __asm { vmaxps  xmm2, xmm2, xmm3 }
  *(_OWORD *)(a1 + 8) = _XMM2;
  _XMM0 = *(unsigned int *)(a1 + 0x18);
  __asm { vmaxss  xmm1, xmm0, xmm3 }
  *(float *)(a1 + 0x18) = *(float *)&_XMM1;
  _XMM0 = *(unsigned int *)(a1 + 0x1C);
  __asm { vmaxss  xmm1, xmm0, xmm3 }
  *(float *)(a1 + 0x1C) = *(float *)&_XMM1;
}

// --- End Function: sub_14039B2F0 (0x14039B2F0) ---

// --- Function: sub_14039B330 (0x14039B330) ---
void __fastcall sub_14039B330(float *a1, unsigned int *a2)
{
  _XMM0 = a2[2];
  __asm { vminss  xmm1, xmm0, dword ptr [rcx+8] }
  a1[2] = *(float *)&_XMM1;
  _XMM0 = a2[3];
  __asm { vminss  xmm1, xmm0, dword ptr [rcx+0Ch] }
  a1[3] = *(float *)&_XMM1;
  _XMM0 = a2[4];
  __asm { vminss  xmm1, xmm0, dword ptr [rcx+10h] }
  a1[4] = *(float *)&_XMM1;
  _XMM0 = a2[5];
  __asm { vminss  xmm1, xmm0, dword ptr [rcx+14h] }
  a1[5] = *(float *)&_XMM1;
  _XMM0 = a2[6];
  __asm { vminss  xmm1, xmm0, dword ptr [rcx+18h] }
  a1[6] = *(float *)&_XMM1;
  _XMM0 = a2[7];
  __asm { vminss  xmm1, xmm0, dword ptr [rcx+1Ch] }
  a1[7] = *(float *)&_XMM1;
}

// --- End Function: sub_14039B330 (0x14039B330) ---

// --- Function: sub_1403AD990 (0x1403AD990) ---
float __fastcall sub_1403AD990(__int64 a1, int a2)
{
  return *(float *)(a1 + 4LL * a2 + 8);
}

// --- End Function: sub_1403AD990 (0x1403AD990) ---

// --- Function: sub_1403AD9A0 (0x1403AD9A0) ---
__int64 *__fastcall sub_1403AD9A0(_QWORD *a1)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx
  int *v3; // rbx
  int *v4; // rax
  int v5; // esi
  int v6; // ebp
  void (__fastcall ***v7)(_QWORD, __int64); // rbx
  int *v9; // rbx
  int *v10; // rax
  int v11; // ebx
  int v12; // esi
  void (__fastcall ***v13)(_QWORD, __int64); // rcx
  char v14[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v15; // [rsp+28h] [rbp-30h]
  char v16[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v17; // [rsp+40h] [rbp-18h]

  v2 = (void (__fastcall ***)(_QWORD, __int64))*a1;
  if ( !v2 )
    goto LABEL_19;
  v3 = (int *)((__int64 (__fastcall *)(_QWORD, char *))(*v2)[3])(v2, v16);
  v4 = (int *)sub_1403DA590((__int64)v14);
  v5 = *v3;
  v6 = *v4;
  if ( v15 )
    sub_147605980(v15);
  if ( v17 )
    sub_147605980(v17);
  v7 = (void (__fastcall ***)(_QWORD, __int64))*a1;
  if ( v5 == v6 )
  {
    if ( *((_BYTE *)a1 + 8) )
    {
      if ( v7 )
        (**v7)(*a1, 1);
    }
    return (__int64 *)v7;
  }
  v9 = (int *)((__int64 (__fastcall *)(_QWORD, char *))(*v7)[3])(*a1, v14);
  v10 = (int *)sub_1403DA680(v16);
  v11 = *v9;
  v12 = *v10;
  if ( v17 )
    sub_147605980(v17);
  if ( v15 )
    sub_147605980(v15);
  if ( v11 == v12 && (v13 = (void (__fastcall ***)(_QWORD, __int64))*a1) != 0 )
  {
    v7 = v13 + 5;
    if ( !*((_BYTE *)a1 + 8) )
      return (__int64 *)v7;
    (**v13)(v13, 1);
    return (__int64 *)v7;
  }
  else
  {
LABEL_19:
    if ( (dword_149B3E338 & 1) == 0 )
    {
      dword_149B3E338 |= 1u;
      qword_149B3E318 = (__int64)&off_1481B0218;
      *(float *)&dword_149B3E330 = 0.0;
      *(float *)&dword_149B3E334 = 0.0;
      xmmword_149B3E320 = 0;
      atexit(sub_1480BD320);
    }
    if ( *((_BYTE *)a1 + 8) && *a1 )
      (**(void (__fastcall ***)(_QWORD, __int64))*a1)(*a1, 1);
    return &qword_149B3E318;
  }
}

// --- End Function: sub_1403AD9A0 (0x1403AD9A0) ---

// --- Function: sub_1403ADDB0 (0x1403ADDB0) ---
__int64 __fastcall sub_1403ADDB0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a2 = 0;
  *(_BYTE *)(a2 + 0x18) = 0;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  result = a2;
  *(_QWORD *)(a2 + 8) = 0x1FF;
  return result;
}

// --- End Function: sub_1403ADDB0 (0x1403ADDB0) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B0A70 (0x1403B0A70) ---
_QWORD *__fastcall sub_1403B0A70(unsigned __int64 *a1, _QWORD *a2)
{
  if ( sub_14030EC00(a1) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B0A70 (0x1403B0A70) ---

// --- Function: sub_1403B3F00 (0x1403B3F00) ---
_WORD *__fastcall sub_1403B3F00(_WORD *a1, unsigned __int64 a2)
{
  __int64 v4; // rbx
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int64 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int16 n4; // dx
  __int64 v10; // rbx
  __int64 v11; // rcx
  _BYTE v13[16]; // [rsp+20h] [rbp-38h] BYREF
  unsigned __int64 v14; // [rsp+68h] [rbp+10h] BYREF
  __int64 v15; // [rsp+70h] [rbp+18h] BYREF
  char v16; // [rsp+78h] [rbp+20h] BYREF

  v14 = a2;
  if ( !sub_14030EC00(&v14) )
    goto LABEL_13;
  v4 = a2 & 0xFFFFFFFFFFFFLL;
  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v4 + 0x340LL);
  n0xFFFF = n0xFFFF_29;
  if ( n0xFFFF_29 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v16,
                          "IActor");
    n0xFFFF_29 = n0xFFFF;
  }
  if ( (LOWORD(v15) = n0xFFFF, v7 = *(_QWORD *)v5(v4, v13, &v15), (v15 = v7) != 0)
    && (v8 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(
               gEnv,
               v7 & 0xFFFFFFFFFFFFLL,
               0),
        n4 = *(_WORD *)(v8 + 4),
        n4 != 4)
    && *(_WORD *)(v8 + 2) == (HIWORD(v7) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v15))
    && (v10 = v7 & 0xFFFFFFFFFFFFLL,
        (v11 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x758LL))(v10) + 8) & 0xFFFFFFFFFFFFLL) != 0)
    && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x20LL))(v11) )
  {
    (*(void (__fastcall **)(__int64, _WORD *))(*(_QWORD *)v10 + 0x7F8LL))(v10, a1);
    return a1;
  }
  else
  {
LABEL_13:
    *a1 = 0xFFFF;
    return a1;
  }
}

// --- End Function: sub_1403B3F00 (0x1403B3F00) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403B7840 (0x1403B7840) ---
__m128 __fastcall sub_1403B7840(__int64 a1)
{
  __int128 v1; // kr00_16

  v1 = *(unsigned int *)(a1 + 0xC);
  *(float *)&v1 = (float)((float)((float)((float)(*(float *)(a1 + 0xC) + *(float *)(a1 + 8)) + *(float *)(a1 + 0x10))
                                + *(float *)(a1 + 0x14))
                        + *(float *)(a1 + 0x18))
                + *(float *)(a1 + 0x1C);
  return (__m128)v1;
}

// --- End Function: sub_1403B7840 (0x1403B7840) ---

// --- Function: sub_1403BA280 (0x1403BA280) ---
bool __fastcall sub_1403BA280(float *a1)
{
  return (float)((float)((float)((float)((float)(a1[3] + a1[2]) + a1[4]) + a1[5]) + a1[6]) + a1[7]) > 0.00000011920929;
}

// --- End Function: sub_1403BA280 (0x1403BA280) ---

// --- Function: get_event_key_from_source_location (0x1403BB9D0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149B3D530;
  if ( !qword_149B3D530 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149B3D530 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BB9D0) ---

// --- Function: sub_1403C1370 (0x1403C1370) ---
bool __fastcall sub_1403C1370(__int64 a1)
{
  return *(_DWORD *)(a1 + 0x18) != 0;
}

// --- End Function: sub_1403C1370 (0x1403C1370) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149B4FCF8;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403C3D30 (0x1403C3D30) ---
__int64 __fastcall sub_1403C3D30(__int64 a1, unsigned int *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &off_1481B0218;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  result = a1;
  _XMM0 = a2[2];
  __asm { vmaxss  xmm1, xmm0, dword ptr [r8+8] }
  *(float *)(a1 + 8) = *(float *)&_XMM1;
  _XMM2 = a2[3];
  __asm { vmaxss  xmm0, xmm2, dword ptr [r8+0Ch] }
  *(float *)(a1 + 0xC) = *(float *)&_XMM0;
  _XMM1 = a2[4];
  __asm { vmaxss  xmm2, xmm1, dword ptr [r8+10h] }
  *(float *)(a1 + 0x10) = *(float *)&_XMM2;
  _XMM0 = a2[5];
  __asm { vmaxss  xmm1, xmm0, dword ptr [r8+14h] }
  *(float *)(a1 + 0x14) = *(float *)&_XMM1;
  _XMM2 = a2[6];
  __asm { vmaxss  xmm0, xmm2, dword ptr [r8+18h] }
  *(float *)(a1 + 0x18) = *(float *)&_XMM0;
  _XMM1 = a2[7];
  __asm { vmaxss  xmm2, xmm1, dword ptr [r8+1Ch] }
  *(float *)(a1 + 0x1C) = *(float *)&_XMM2;
  return result;
}

// --- End Function: sub_1403C3D30 (0x1403C3D30) ---

// --- Function: sub_1403D4870 (0x1403D4870) ---
void __fastcall sub_1403D4870(__int64 a1, _BYTE *a2, float a3, float a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  size_t Size; // r8
  unsigned __int64 Size_1; // rax
  __int64 v9; // rax
  __int64 v10; // r9
  _QWORD *v11; // rax
  __int64 v12; // rcx
  _QWORD *v13; // rdi
  __int64 v14; // [rsp+20h] [rbp-288h] BYREF
  _BYTE v15[16]; // [rsp+28h] [rbp-280h] BYREF
  __int64 v16; // [rsp+38h] [rbp-270h]
  __int64 v17; // [rsp+40h] [rbp-268h]
  __int64 v18; // [rsp+50h] [rbp-258h]
  __int64 n0x1FF; // [rsp+58h] [rbp-250h]
  _BYTE *v20; // [rsp+60h] [rbp-248h]
  _BYTE v21[520]; // [rsp+68h] [rbp-240h] BYREF
  __int128 v22; // [rsp+280h] [rbp-28h]
  __int128 v23; // [rsp+290h] [rbp-18h]

  v23 = v4;
  v22 = v5;
  if ( a2 )
  {
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( a2[Size_1] );
    Size = (int)Size_1;
  }
  else
  {
    Size = 0;
  }
  sub_1403DE230((void **)(a1 + 0x110), a2, Size);
  v9 = *(_QWORD *)(a1 + 0x110);
  *(float *)(a1 + 0x120) = a3;
  if ( *(_DWORD *)(v9 - 8) )
  {
    v21[0] = 0;
    v20 = v21;
    v18 = 0;
    n0x1FF = 0x1FF;
    sub_14036C130((__int64)v15, (const void **)(a1 + 0x110));
    if ( v20 != v21 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v20);
    }
    LOBYTE(v10) = 1;
    v11 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _BYTE *, __int64))(*(_QWORD *)qword_149B4FC30 + 0x48LL))(
                      qword_149B4FC30,
                      &v14,
                      v15,
                      v10);
    v12 = *(_QWORD *)(a1 + 0x118);
    v13 = v11;
    *(_QWORD *)(a1 + 0x118) = *v11;
    *v11 = v12;
    if ( v12 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x48LL))(v12);
    *v13 = 0;
    if ( v14 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x48LL))(v14);
    if ( *(int *)(v17 - 4) > 0 )
      sub_147605980((const void *)(v17 - 8));
    if ( *(int *)(v16 - 4) > 0 )
      sub_147605980((const void *)(v16 - 8));
  }
  *(float *)(a1 + 0x128) = a4;
}

// --- End Function: sub_1403D4870 (0x1403D4870) ---

// --- Function: sub_1403D5240 (0x1403D5240) ---
void __fastcall sub_1403D5240(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 0xE0) = a2;
}

// --- End Function: sub_1403D5240 (0x1403D5240) ---

// --- Function: sub_1403D54E0 (0x1403D54E0) ---
__int64 __fastcall sub_1403D54E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 0xC4) = 1;
  *(double *)(a1 + 0xC8) = *(double *)a2;
  result = *(unsigned int *)(a2 + 8);
  *(_DWORD *)(a1 + 0xD0) = result;
  *(_QWORD *)(a1 + 0xD8) = a3;
  return result;
}

// --- End Function: sub_1403D54E0 (0x1403D54E0) ---

// --- Function: sub_1403D6030 (0x1403D6030) ---
void *__fastcall sub_1403D6030(__int64 a1, _BYTE *a2)
{
  void **v2; // rcx
  unsigned __int64 Size; // rax

  v2 = (void **)(a1 + 0xB8);
  if ( !a2 )
    return sub_1403DE230(v2, 0, 0);
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  return sub_1403DE230(v2, a2, (int)Size);
}

// --- End Function: sub_1403D6030 (0x1403D6030) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 0xC0LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x10LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403DA590 (0x1403DA590) ---
__int64 __fastcall sub_1403DA590(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  char *v6; // rax

  v1 = dword_149B3DFB0;
  if ( !dword_149B3DFB0 )
  {
    v3 = sub_1402D2830(0x4Du, 8, 0x80u, 2);
    v4 = sub_1402CA4C0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D2830(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402E1FE0((unsigned __int8 *)"amageInfo", v5 ^ 0xFFFFFFu);
    v6 = (char *)allocWithProfilerInfo(0xBu, 0);
    *(double *)v6 = *(double *)"DamageInfo";
    strcpy(v6 + 8, "fo");
    dword_149B3DFB0 = v1;
    if ( v6 )
    {
      sub_147605980(v6);
      v1 = dword_149B3DFB0;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_1403DA590 (0x1403DA590) ---

// --- Function: sub_1403DA680 (0x1403DA680) ---
__int64 __fastcall sub_1403DA680(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  char *v6; // rax

  v1 = dword_149B3DFB4;
  if ( !dword_149B3DFB4 )
  {
    v3 = sub_1402D2830(0x4Du, 8, 0x80u, 2);
    v4 = sub_1402CA4C0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D2830(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402E1FE0((unsigned __int8 *)"amageParams", v5 ^ 0xFFFFFFu);
    v6 = (char *)allocWithProfilerInfo(0xDu, 0);
    *(double *)v6 = *(double *)"DamageParams";
    strcpy(v6 + 8, "rams");
    dword_149B3DFB4 = v1;
    if ( v6 )
    {
      sub_147605980(v6);
      v1 = dword_149B3DFB4;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_1403DA680 (0x1403DA680) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 0x10) & (unsigned int)(v9 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
      qword_149B4FCF8,
      &v11,
      &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 0xD8LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: _stricmp_w_3 (0x1403E4950) ---
int __fastcall sub_1403E4950(const char **a1, const char *String2)
{
  return _stricmp(*a1, String2);
}

// --- End Function: _stricmp_w_3 (0x1403E4950) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 allocWithProfilerInfo_ww()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4B60 (0x1403E4B60) ---
_OWORD *__fastcall sub_1403E4B60(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)allocWithProfilerInfo_w(0x10u);
  if ( result )
    *result = *a1;
  return result;
}

// --- End Function: sub_1403E4B60 (0x1403E4B60) ---

// --- Function: sub_1403E4B90 (0x1403E4B90) ---
_QWORD *__fastcall sub_1403E4B90(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A3D30(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)allocWithProfilerInfo_w(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E4B90 (0x1403E4B90) ---

// --- Function: sub_1403E4C70 (0x1403E4C70) ---
__int64 __fastcall sub_1403E4C70(__int64 a1)
{
  __int64 result; // rax

  result = allocWithProfilerInfo_w(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 0x10) = *(double *)(a1 + 0x10);
  }
  return result;
}

// --- End Function: sub_1403E4C70 (0x1403E4C70) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
void __fastcall sub_1403E4E60(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4E70 (0x1403E4E70) ---
void __fastcall sub_1403E4E70(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E70 (0x1403E4E70) ---

// --- Function: sub_1403E4E80 (0x1403E4E80) ---
void __fastcall sub_1403E4E80(const void **a1)
{
  if ( a1 )
  {
    sub_1402A3D30(a1[2]);
    sub_1402A3D30(a1);
  }
}

// --- End Function: sub_1403E4E80 (0x1403E4E80) ---

// --- Function: sub_1403E4EB0 (0x1403E4EB0) ---
void __fastcall sub_1403E4EB0(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4EB0 (0x1403E4EB0) ---

// --- Function: sub_1403E5570 (0x1403E5570) ---
bool __fastcall sub_1403E5570(_QWORD *a1)
{
  return !*a1 || !*(_BYTE *)*a1;
}

// --- End Function: sub_1403E5570 (0x1403E5570) ---

// --- Function: sub_1403E6720 (0x1403E6720) ---
__int64 __fastcall sub_1403E6720(__int64 *a1)
{
  if ( AssetMeta::HasActorSubresource(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6720 (0x1403E6720) ---

// --- Function: sub_1403E6750 (0x1403E6750) ---
unsigned __int64 __fastcall sub_1403E6750(unsigned __int64 *a1)
{
  if ( sub_14030EC00(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6750 (0x1403E6750) ---

// --- Function: sub_1403E6790 (0x1403E6790) ---
__int64 __fastcall sub_1403E6790(__int64 a1)
{
  return *(unsigned int *)(a1 + 0x21C);
}

// --- End Function: sub_1403E6790 (0x1403E6790) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---

// --- Function: sub_1403E7650 (0x1403E7650) ---
bool __fastcall sub_1403E7650(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E7650 (0x1403E7650) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403E9FB0 (0x1403E9FB0) ---
unsigned __int64 __fastcall sub_1403E9FB0(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // r10
  int v6; // ecx
  int v7; // eax
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rdx
  int v10; // eax
  unsigned __int64 v11; // rax
  unsigned __int64 result; // rax
  __int64 v13; // rdx
  int v14; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v6 = *(_DWORD *)(*a1 - 4);
  v7 = 8 * v6;
  if ( v6 >= 0 )
    v8 = (unsigned __int64)v7 >> 3;
  else
    LODWORD(v8) = *(_DWORD *)(v7 + v3);
  v9 = 0;
  v10 = 0;
  if ( a3 )
    LOBYTE(v10) = a2 > (int)v8;
  else
    LOBYTE(v10) = a2 != (_DWORD)v8;
  if ( v10 )
  {
    v14 = a2;
    if ( v6 )
      v9 = v3;
    v11 = sub_14035A0F0((__int64)a1, v9, v6 & 0x7FFFFFFF, &v14, 4u, a3);
    *a1 = v11;
    v3 = v11;
    if ( !v11 )
    {
      result = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
      *a1 = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
      return result;
    }
    LODWORD(v8) = v14;
  }
  v13 = 8 * a2;
  *(_DWORD *)(v3 - 4) = a2;
  result = v13 + 4;
  if ( 8LL * (int)v8 >= (unsigned __int64)(v13 + 4) )
  {
    *(_DWORD *)(v3 - 4) = a2 | 0x80000000;
    *(_DWORD *)(v13 + v3) = v8;
  }
  return result;
}

// --- End Function: sub_1403E9FB0 (0x1403E9FB0) ---

// --- Function: sub_1403EAFB0 (0x1403EAFB0) ---
__int64 __fastcall sub_1403EAFB0(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 0x10) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 0x22;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      v6 = sub_14035AA80((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    *a2 = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FE6B0((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
    return 0xFFFFFFFFLL;
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
    return 0xFFFFFFFFLL;
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 0x22;
    }
    else
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403EAFB0 (0x1403EAFB0) ---

// --- Function: sub_1403EB0E0 (0x1403EB0E0) ---
__int64 __fastcall sub_1403EB0E0(__int64 a1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EB0E0 (0x1403EB0E0) ---

// --- Function: sub_1403EB110 (0x1403EB110) ---
__int64 __fastcall sub_1403EB110(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_14035AA80(a2, a3, 0, *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1403EB110 (0x1403EB110) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n12_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n0xC + a2), n12_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB550 (0x1403EB550) ---
__int64 __fastcall sub_1403EB550(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 0x10) )
    return sub_14035AA80(a2, a3, 0, v3);
  else
    return sub_1402FE6B0(a2, a3, 0, v3);
}

// --- End Function: sub_1403EB550 (0x1403EB550) ---

// --- Function: sub_1403EB580 (0x1403EB580) ---
__int64 __fastcall sub_1403EB580(__int64 a1, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB580 (0x1403EB580) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: sub_140455210 (0x140455210) ---
__int64 __fastcall sub_140455210(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x58) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  result = a1;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_DWORD *)(a1 + 0x48) = 0;
  *(_DWORD *)(a1 + 0x4C) = 8;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_DWORD *)(a1 + 0x60) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x64) = 0;
  return result;
}

// --- End Function: sub_140455210 (0x140455210) ---

// --- Function: sub_1404640D0 (0x1404640D0) ---
void __fastcall sub_1404640D0(__int64 a1)
{
  __int64 v2; // rbx
  int v3; // edi
  __int64 v4; // r8
  unsigned __int64 v5; // rax
  const void *v6; // rcx
  int v7; // eax
  unsigned __int64 n0x200000; // rax

  v2 = a1 + 0x50;
  v3 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v3 )
  {
    ++*(_DWORD *)(v2 + 0x14);
  }
  else
  {
    v4 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v5 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( v5 )
      sub_1403DCD60(
        v2,
        v5,
        v4,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source,
        0);
    else
      *(_QWORD *)(v2 + 8) = v4;
    *(_DWORD *)(v2 + 0x10) = v3;
  }
  v6 = *(const void **)(a1 + 0x40);
  if ( v6 )
    sub_147605980(v6);
  if ( v2 )
  {
    v7 = *(_DWORD *)(v2 + 0x14);
    if ( v7 )
    {
      *(_DWORD *)(v2 + 0x14) = v7 - 1;
    }
    else
    {
      *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v2 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DD380(v2, n0x200000);
    }
  }
}

// --- End Function: sub_1404640D0 (0x1404640D0) ---

// --- Function: sub_140464CC0 (0x140464CC0) ---
void __fastcall sub_140464CC0(__int64 a1)
{
  __int64 v2; // rsi
  volatile signed __int32 *v3; // rbx
  int v4; // ebp
  unsigned __int32 v5; // eax
  int v6; // eax
  unsigned __int32 v7; // eax

  if ( *(_DWORD *)a1 )
  {
    v2 = (*(__int64 (**)(void))(*(_QWORD *)qword_149B4FC78 + 0x2C8LL))();
    if ( !(unsigned __int8)sub_140500AC0(v2 + 0x240, *(_DWORD *)a1) )
    {
      v3 = (volatile signed __int32 *)(v2 + 0x2D8);
      v4 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
      if ( *(_DWORD *)(v2 + 0x2E8) == v4 )
      {
        ++*(_DWORD *)(v2 + 0x2EC);
      }
      else
      {
        v5 = _InterlockedCompareExchange(v3, 1, 0);
        if ( v5 )
          sub_1403C33A0(
            v2 + 0x2D8,
            v5,
            "DeferredActionQueue<struct DefaultRayCaster<47>,struct RayCastRequest,struct RayCastResult,struct DefaultCon"
            "tention>::Cancel",
            1);
        else
          *(_QWORD *)(v2 + 0x2E0) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
        *(_DWORD *)(v2 + 0x2E8) = v4;
      }
      sub_1405002A0(v2 + 0x228, (_DWORD *)a1);
      v6 = *(_DWORD *)(v2 + 0x2EC);
      if ( v6 )
      {
        *(_DWORD *)(v2 + 0x2EC) = v6 - 1;
      }
      else
      {
        *(_DWORD *)(v2 + 0x2E8) = 0xFFFFFFFF;
        v7 = _InterlockedCompareExchange(v3, 0, 1);
        if ( v7 == 1 )
          *(_QWORD *)(v2 + 0x2E0) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        else
          sub_1403DB1F0(v2 + 0x2D8, v7);
      }
    }
    *(_DWORD *)a1 = 0;
  }
  *(_DWORD *)(a1 + 0x18) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
}

// --- End Function: sub_140464CC0 (0x140464CC0) ---

// --- Function: sub_140497F10 (0x140497F10) ---
unsigned __int64 __fastcall sub_140497F10(__int64 a1, __int64 a2)
{
  return sub_1403BE7B0(a2, *(_DWORD *)(*(_QWORD *)(a1 + 0x10) + 4LL), *(_QWORD *)(a1 + 0x10));
}

// --- End Function: sub_140497F10 (0x140497F10) ---

// --- Function: sub_140498A60 (0x140498A60) ---
void __fastcall sub_140498A60(
        int a1,
        unsigned __int64 (__fastcall **a2)(__int64 a1, __int64 a2),
        unsigned __int64 (__fastcall **a3)(__int64 a1, __int64 a2))
{
  int v4; // ecx
  unsigned __int64 (__fastcall *v5)(__int64, __int64); // rdi
  unsigned __int64 (__fastcall *v6)(__int64, __int64); // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A3D30(a2[2]);
        a2[2] = 0;
        *a2 = 0;
        a2[1] = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        a2[2] = a3[2];
        *a2 = *a3;
        a2[1] = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = a3[2];
    if ( *a3 )
    {
      if ( a3[1] == (unsigned __int64 (__fastcall *)(__int64, __int64))1 )
      {
        a2[2] = 0;
        *a2 = *a3;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))1;
      }
      else
      {
        v6 = (unsigned __int64 (__fastcall *)(__int64, __int64))allocWithProfilerInfo_w(8u);
        if ( v6 )
          *(_QWORD *)v6 = *(_QWORD *)v5;
        else
          v6 = 0;
        a2[2] = v6;
        *a2 = sub_140497F10;
        a2[1] = (unsigned __int64 (__fastcall *)(__int64, __int64))sub_140498A60;
      }
    }
  }
}

// --- End Function: sub_140498A60 (0x140498A60) ---

// --- Function: sub_1404B2D60 (0x1404B2D60) ---
__int64 __fastcall sub_1404B2D60(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(a1 + 0x10);
  if ( v2 )
    return *(unsigned __int16 *)(v2 + 0x88);
  else
    return a2;
}

// --- End Function: sub_1404B2D60 (0x1404B2D60) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_1480BE950);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n0xF; // rax

  v0 = sub_1404B3EA0();
  v1 = v0;
  if ( !v0 )
    return &dword_149B45F40;
  n0xF = *v0;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&v1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_1404F3FB0 (0x1404F3FB0) ---
__int64 __fastcall sub_1404F3FB0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x28] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x28] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x29] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x29] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x2A] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x2A] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x2B] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x2B] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x2C] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x2C] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x2D] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x2D] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x2E] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x2E] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x2F] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x2F] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F3FB0 (0x1404F3FB0) ---

// --- Function: sub_1404F4100 (0x1404F4100) ---
__int64 __fastcall sub_1404F4100(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x10] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x10] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x11] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x11] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x12] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x12] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x13] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x13] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x14] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x14] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x15] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x15] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x16] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x16] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x17] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x17] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[0x18] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[0x18] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[0x19] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[0x19] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0x1A] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0x1A] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0x1B] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0x1B] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0x1C] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0x1C] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0x1D] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0x1D] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0x1E] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0x1E] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0x1F] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0x1F] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F4100 (0x1404F4100) ---

// --- Function: sub_1404F4350 (0x1404F4350) ---
__int64 __fastcall sub_1404F4350(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n0x10; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[0x20] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[0x20] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[0x21] >> 4];
  a2[3] = _0123456789abcdef_[a1[0x21] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[0x22] >> 4];
  a2[5] = _0123456789abcdef_[a1[0x22] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[0x23] >> 4];
  a2[7] = _0123456789abcdef_[a1[0x23] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[0x24] >> 4];
  a2[9] = _0123456789abcdef_[a1[0x24] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[0x25] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[0x25] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[0x26] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[0x26] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[0x27] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[0x27] & 0xF];
  n0x10 = 0x10;
  a2[0x10] = 0;
  return n0x10;
}

// --- End Function: sub_1404F4350 (0x1404F4350) ---

// --- Function: sub_1404F4760 (0x1404F4760) ---
__int64 __fastcall sub_1404F4760(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n0x20; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[0xA] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[0xB] = _0123456789abcdef_[a1[5] & 0xF];
  a2[0xC] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[0xD] = _0123456789abcdef_[a1[6] & 0xF];
  a2[0xE] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[0xF] = _0123456789abcdef_[a1[7] & 0xF];
  a2[0x10] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[0x11] = _0123456789abcdef_[a1[8] & 0xF];
  a2[0x12] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[0x13] = _0123456789abcdef_[a1[9] & 0xF];
  a2[0x14] = _0123456789abcdef_[(unsigned __int64)a1[0xA] >> 4];
  a2[0x15] = _0123456789abcdef_[a1[0xA] & 0xF];
  a2[0x16] = _0123456789abcdef_[(unsigned __int64)a1[0xB] >> 4];
  a2[0x17] = _0123456789abcdef_[a1[0xB] & 0xF];
  a2[0x18] = _0123456789abcdef_[(unsigned __int64)a1[0xC] >> 4];
  a2[0x19] = _0123456789abcdef_[a1[0xC] & 0xF];
  a2[0x1A] = _0123456789abcdef_[(unsigned __int64)a1[0xD] >> 4];
  a2[0x1B] = _0123456789abcdef_[a1[0xD] & 0xF];
  a2[0x1C] = _0123456789abcdef_[(unsigned __int64)a1[0xE] >> 4];
  a2[0x1D] = _0123456789abcdef_[a1[0xE] & 0xF];
  a2[0x1E] = _0123456789abcdef_[(unsigned __int64)a1[0xF] >> 4];
  a2[0x1F] = _0123456789abcdef_[a1[0xF] & 0xF];
  n0x20 = 0x20;
  a2[0x20] = 0;
  return n0x20;
}

// --- End Function: sub_1404F4760 (0x1404F4760) ---

// --- Function: sub_1404FA510 (0x1404FA510) ---
_BYTE *__fastcall sub_1404FA510(__int64 *a1, __int64 n0x3F_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0x3F; // rcx

  result = a1 + 3;
  if ( n0x3F_1 )
  {
    allocSize = n0x3F_1 + 1;
    if ( (unsigned __int64)(n0x3F_1 + 1) <= 0x40 )
    {
      n0x3F = 0x3F;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B473F8 += allocSize;
      n0x3F = n0x3F_1;
    }
    a1[1] = n0x3F;
    *a1 = n0x3F_1;
    a1[2] = (__int64)result;
    result[n0x3F_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0x3F;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1404FA510 (0x1404FA510) ---

// --- Function: sub_140501090 (0x140501090) ---
__int64 __fastcall sub_140501090(__int64 *a1)
{
  if ( is_valid_handle_typeA(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_140501090 (0x140501090) ---

// --- Function: sub_140522CF0 (0x140522CF0) ---
__int64 __fastcall sub_140522CF0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC00 + 0x228LL))(qword_149B4FC00, a1);
}

// --- End Function: sub_140522CF0 (0x140522CF0) ---

// --- Function: sub_140539D30 (0x140539D30) ---
__int64 (__fastcall *__fastcall sub_140539D30(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_14039B170(0, "__InitializeThreadInfoBlock__", 0);
  if ( result )
    return (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}

// --- End Function: sub_140539D30 (0x140539D30) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056CEA0 (0x14056CEA0) ---
__m128 sub_14056CEA0()
{
  __int128 v0; // kr00_16

  v0 = 0;
  *(float *)&v0 = (float)(unsigned int)sub_14056D140((__int64)&unk_1499305A0);
  *(float *)&v0 = *(float *)&v0 * 2.3283064e-10;
  return (__m128)v0;
}

// --- End Function: sub_14056CEA0 (0x14056CEA0) ---

// --- Function: sub_1405975C0 (0x1405975C0) ---
_QWORD *__fastcall sub_1405975C0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_1405975C0 (0x1405975C0) ---

// --- Function: sub_140597630 (0x140597630) ---
bool __fastcall sub_140597630(_QWORD *a1, _QWORD *a2)
{
  return *a1 < *a2;
}

// --- End Function: sub_140597630 (0x140597630) ---

// --- Function: sub_140597760 (0x140597760) ---
__m128 sub_140597760()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_140597760 (0x140597760) ---

// --- Function: sub_1405AA0C0 (0x1405AA0C0) ---
bool __fastcall sub_1405AA0C0(unsigned __int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  unsigned __int64 v3; // rbx
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int64 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v6; // rbx
  unsigned __int64 v8; // [rsp+40h] [rbp+8h] BYREF
  __int64 v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF
  char v11; // [rsp+58h] [rbp+20h] BYREF

  v8 = a1;
  if ( sub_14030EC00(&v8)
    && *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC00 + 0xF0LL))(qword_149B4FC00) + 0x40C) )
  {
    v1 = (*(__int64 (__fastcall **)(unsigned __int64, _QWORD))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x4F8LL))(
           v8 & 0xFFFFFFFFFFFFLL,
           0);
    if ( v1 )
    {
      v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x68LL))(v1);
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 0xB0LL))(v2) )
        return 1;
    }
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int64 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_7;
    if ( n0xFFFF_7 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v10,
                            "IItemPortContainer");
      n0xFFFF_7 = n0xFFFF;
    }
    LOWORD(v9) = n0xFFFF;
    v6 = *(_QWORD *)v4(v3, &v11, &v9);
    v9 = v6;
    if ( AssetMeta::HasActorSubresource(&v9) )
    {
      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v6 & 0xFFFFFFFFFFFFLL) + 0x750LL))(v6 & 0xFFFFFFFFFFFFLL) )
        return (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v6 & 0xFFFFFFFFFFFFLL) + 0x758LL))(v6 & 0xFFFFFFFFFFFFLL) != 0;
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1405AA0C0 (0x1405AA0C0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_140970360 (0x140970360) ---
__int64 __fastcall sub_140970360(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xE8);
}

// --- End Function: sub_140970360 (0x140970360) ---

// --- Function: sub_1411DB480 (0x1411DB480) ---
__int64 __fastcall sub_1411DB480(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))a1)(a2, *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1411DB480 (0x1411DB480) ---

// --- Function: sub_1412A4810 (0x1412A4810) ---
__int64 __fastcall sub_1412A4810(__int64 a1, __int64 a2, float *a3, float a4)
{
  double v4; // xmm1_8
  float v5; // xmm4_4
  float v6; // xmm8_4
  float v7; // xmm5_4
  __m128 v8; // kr00_16
  float v11; // xmm2_4
  __m128 v12; // xmm2
  float v13; // xmm3_4
  __m128 n0x3FC00000; // kr00_16
  float v15; // xmm6_4
  float v18; // xmm1_4
  float v19; // xmm6_4
  float v20; // xmm3_4
  double v21; // xmm1_8
  __m128 v22; // kr00_16
  float v25; // xmm1_4
  float v26; // xmm9_4
  float v27; // xmm7_4
  __m128 v28; // xmm6
  __m128 v29; // kr00_16
  __m128 v30; // kr00_16
  float v33; // xmm1_4
  float v34; // xmm0_4
  float v35; // xmm2_4
  __m128 v36; // kr00_16
  __m128 v39; // xmm1
  float v40; // xmm3_4
  float v41; // xmm4_4
  float v42; // xmm5_4
  __m128 v43; // kr00_16
  float v44; // xmm0_4
  float v45; // xmm6_4
  float v46; // xmm8_4
  float v49; // xmm1_4
  float v50; // xmm11_4
  float v51; // xmm13_4
  float v52; // xmm14_4
  __m128 v53; // kr00_16
  float v56; // xmm4_4
  float v58; // [rsp+Ch] [rbp-BCh]
  float v59; // [rsp+D0h] [rbp+8h]
  float v60; // [rsp+D8h] [rbp+10h]
  float v61; // [rsp+D8h] [rbp+10h]
  float v62; // [rsp+E8h] [rbp+20h]

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0x3FF0000000000000LL;
  *(_OWORD *)(a1 + 0x20) = *(_OWORD *)a2;
  v4 = *(double *)(a2 + 0x10);
  *(double *)(a1 + 0x38) = a4;
  *(double *)(a1 + 0x30) = v4;
  v5 = *a3;
  v6 = 0.0;
  if ( *a3 != 0.0 || a3[1] != 0.0 || a3[2] != 0.0 )
  {
    v7 = a3[1];
    if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) > 1.0e-10 || COERCE_FLOAT(LODWORD(v7) & 0x7FFFFFFF) > 1.0e-10 )
    {
      v22 = (__m128)*(unsigned int *)a3;
      v22.m128_f32[0] = (float)((float)(v5 * v5) + (float)(v7 * v7)) + 1.1754944e-38;
      v60 = (float)(v5 * v5) + (float)(v7 * v7);
      _XMM0 = _mm_shuffle_ps(v22, v22, 0);
      __asm { vrsqrtps xmm3, xmm0 }
      _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
      v25 = (float)(1.5 - (float)((float)((float)(_XMM3.m128_f32[0] * v22.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
          * _XMM3.m128_f32[0];
      v26 = v7 * v25;
      v27 = (float)(v7 * v25) + 1.0;
      v29 = (__m128)*(unsigned int *)a3;
      v29.m128_f32[0] = v5 * v25;
      v28 = v29;
      if ( v27 <= 0.000099999997 )
      {
        v34 = (float)((float)((float)((float)(1.0 * 1.0) * 1.0) * 0.5) - 1.5) * 1.0;
        v35 = 0.0;
      }
      else
      {
        v30 = (__m128)(*(_OWORD *)&v29 ^ 0x80000000);
        v30.m128_f32[0] = (float)(v30.m128_f32[0] * v30.m128_f32[0]) + (float)(v27 * v27);
        _XMM2 = _mm_shuffle_ps(v30, v30, 0);
        __asm { vrsqrtps xmm4, xmm2 }
        _XMM4.m128_f32[0] = _mm_shuffle_ps(_XMM4, _XMM4, 0xFF).m128_f32[0];
        v33 = (float)(1.5 - (float)((float)((float)(_XMM4.m128_f32[0] * v30.m128_f32[0]) * _XMM4.m128_f32[0]) * 0.5))
            * _XMM4.m128_f32[0];
        v34 = v33 * COERCE_FLOAT(v28.m128_i32[0] ^ 0x80000000);
        v35 = v33 * v27;
      }
      v59 = v34;
      v36 = (__m128)*((unsigned int *)a3 + 2);
      v62 = v35;
      v36.m128_f32[0] = (float)((float)(a3[2] * a3[2]) + v60) + 1.1754944e-38;
      _XMM0 = _mm_shuffle_ps(v36, v36, 0);
      __asm { vrsqrtps xmm4, xmm0 }
      _XMM4.m128_f32[0] = _mm_shuffle_ps(_XMM4, _XMM4, 0xFF).m128_f32[0];
      v39 = (__m128)*(unsigned __int64 *)a3;
      v40 = (float)(1.5 - (float)((float)((float)(_XMM4.m128_f32[0] * v36.m128_f32[0]) * _XMM4.m128_f32[0]) * 0.5))
          * _XMM4.m128_f32[0];
      v41 = v40 * a3[2];
      _XMM0.m128_f32[0] = _mm_shuffle_ps(v39, v39, 0x55).m128_f32[0];
      v61 = _XMM0.m128_f32[0] * v40;
      v42 = (float)((float)((float)(_XMM0.m128_f32[0] * v40) * v26)
                  + (float)((float)(v39.m128_f32[0] * v40) * v28.m128_f32[0]))
          + 1.0;
      if ( v42 <= 0.000099999997 )
      {
        if ( (float)((float)((float)((float)(v26 * v26) + (float)(v28.m128_f32[0] * v28.m128_f32[0])) * 0.80999994)
                   - (float)(v28.m128_f32[0] * v28.m128_f32[0])) >= 0.0 )
          LODWORD(v58) = LODWORD(v26) ^ 0x80000000;
        else
          v58 = v28.m128_f32[0];
        v53 = 0u;
        v53.m128_f32[0] = (float)((float)((float)(0.0 * 0.0) + (float)(0.0 * 0.0)) + (float)(v58 * v58)) + 1.1754944e-38;
        _XMM2 = _mm_shuffle_ps(v53, v53, 0);
        __asm { vrsqrtps xmm3, xmm2 }
        _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
        v56 = (float)(1.5 - (float)((float)((float)(_XMM3.m128_f32[0] * v53.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5))
            * _XMM3.m128_f32[0];
        v52 = v56 * v58;
        v51 = _mm_shuffle_ps((__m128)0LL, (__m128)0LL, 0x55).m128_f32[0] * v56;
        v50 = 0.0 * v56;
      }
      else
      {
        v43 = v28;
        v44 = v41 * v28.m128_f32[0];
        v45 = (float)(v28.m128_f32[0] * v61) - (float)(v26 * (float)(v39.m128_f32[0] * v40));
        v46 = v41 * v26;
        v43.m128_f32[0] = (float)((float)(v45 * v45)
                                + (float)(COERCE_FLOAT(LODWORD(v44) ^ 0x80000000)
                                        * COERCE_FLOAT(LODWORD(v44) ^ 0x80000000)))
                        + (float)((float)(v46 * v46) + (float)(v42 * v42));
        _XMM3 = _mm_shuffle_ps(v43, v43, 0);
        __asm { vrsqrtps xmm4, xmm3 }
        _XMM4.m128_f32[0] = _mm_shuffle_ps(_XMM4, _XMM4, 0xFF).m128_f32[0];
        v49 = (float)(1.5 - (float)((float)((float)(_XMM4.m128_f32[0] * v43.m128_f32[0]) * _XMM4.m128_f32[0]) * 0.5))
            * _XMM4.m128_f32[0];
        v50 = v49 * v46;
        v6 = v49 * v42;
        v51 = v49 * COERCE_FLOAT(LODWORD(v44) ^ 0x80000000);
        v52 = v49 * v45;
      }
      v21 = (float)((float)((float)((float)(v50 * 0.0) - (float)(v51 * 0.0)) + (float)(v6 * v59)) + (float)(v62 * v52));
      *(double *)a1 = (float)((float)((float)((float)(v51 * v59) - (float)(v52 * 0.0)) + (float)(v6 * 0.0))
                            + (float)(v62 * v50));
      *(double *)(a1 + 8) = (float)((float)((float)((float)(v52 * 0.0) - (float)(v50 * v59)) + (float)(v6 * 0.0))
                                  + (float)(v62 * v51));
      *(double *)(a1 + 0x18) = (float)((float)(v62 * v6)
                                     - (float)((float)((float)(v51 * 0.0) + (float)(v50 * 0.0)) + (float)(v52 * v59)));
    }
    else
    {
      v8 = (__m128)*((unsigned int *)a3 + 2);
      v8.m128_f32[0] = (float)((float)(a3[2] * a3[2]) + (float)((float)(v5 * v5) + (float)(v7 * v7))) + 1.1754944e-38;
      _XMM1 = _mm_shuffle_ps(v8, v8, 0);
      __asm { vrsqrtps xmm3, xmm1 }
      _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
      v11 = (float)((float)(_XMM3.m128_f32[0] * v8.m128_f32[0]) * _XMM3.m128_f32[0]) * 0.5;
      n0x3FC00000 = (__m128)0x3FC00000u;
      n0x3FC00000.m128_f32[0] = 1.5 - v11;
      v12 = (__m128)*(unsigned __int64 *)a3;
      v13 = n0x3FC00000.m128_f32[0] * _XMM3.m128_f32[0];
      n0x3FC00000.m128_f32[0] = v13 * a3[2];
      v15 = (float)(_mm_shuffle_ps(v12, v12, 0x55).m128_f32[0] * v13) + 1.0;
      if ( v15 <= 0.000099999997 )
      {
        v20 = (float)((float)((float)((float)(1.0 * 1.0) * 1.0) * 0.5) - 1.5) * 1.0;
        v19 = 0.0;
      }
      else
      {
        n0x3FC00000.m128_f32[0] = (float)((float)(n0x3FC00000.m128_f32[0] * n0x3FC00000.m128_f32[0]) + (float)(v15 * v15))
                                + (float)((float)-(float)(v12.m128_f32[0] * v13) * (float)-(float)(v12.m128_f32[0] * v13));
        _XMM0 = _mm_shuffle_ps(n0x3FC00000, n0x3FC00000, 0);
        __asm { vrsqrtps xmm4, xmm0 }
        _XMM4.m128_f32[0] = _mm_shuffle_ps(_XMM4, _XMM4, 0xFF).m128_f32[0];
        v18 = (float)(1.5
                    - (float)((float)((float)(_XMM4.m128_f32[0] * n0x3FC00000.m128_f32[0]) * _XMM4.m128_f32[0]) * 0.5))
            * _XMM4.m128_f32[0];
        v6 = v18 * v15;
        v19 = v18 * (float)(v13 * a3[2]);
        v20 = v18 * (float)-(float)(v12.m128_f32[0] * v13);
      }
      *(double *)a1 = v19;
      *(double *)(a1 + 8) = 0;
      *(double *)(a1 + 0x18) = v6;
      v21 = v20;
    }
    *(double *)(a1 + 0x10) = v21;
  }
  return a1;
}

// --- End Function: sub_1412A4810 (0x1412A4810) ---

// --- Function: sub_1413F3740 (0x1413F3740) ---
_QWORD *__fastcall sub_1413F3740(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_76;
  if ( n0xFFFF_76 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "IEntityComponentHostility");
    n0xFFFF_76 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1413F3740 (0x1413F3740) ---

// --- Function: sub_14152AE40 (0x14152AE40) ---
_QWORD *__fastcall sub_14152AE40(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_77;
  if ( n0xFFFF_77 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "IEntityComponentRoomOccupant");
    n0xFFFF_77 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14152AE40 (0x14152AE40) ---

// --- Function: sub_141810760 (0x141810760) ---
__int64 __fastcall sub_141810760(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x100);
}

// --- End Function: sub_141810760 (0x141810760) ---

// --- Function: sub_141848E00 (0x141848E00) ---
_QWORD *__fastcall sub_141848E00(_QWORD *p_pExceptionObject)
{
  p_pExceptionObject[1] = "bad allocation";
  *p_pExceptionObject = off_1481A05A8;
  return p_pExceptionObject;
}

// --- End Function: sub_141848E00 (0x141848E00) ---

// --- Function: sub_141886BE0 (0x141886BE0) ---
__int64 __fastcall sub_141886BE0(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 0x28) = 0xFFFFFFFF;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  sub_14036BE70((_QWORD *)(a1 + 0x38));
  *(_DWORD *)(a1 + 0x58) = 0x3F800000;
  *(_QWORD *)(a1 + 0x5C) = 0x3F800000;
  *(_QWORD *)(a1 + 0x64) = 0;
  *(_DWORD *)(a1 + 0x6C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x70) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x74) = 0;
  *(_DWORD *)(a1 + 0x78) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x7C) = 0;
  *(_BYTE *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_DWORD *)(a1 + 0xD8) = 0x3F800000;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0xDC) = 0;
  *(_QWORD *)(a1 + 0xE4) = 0;
  *(_WORD *)(a1 + 0xEC) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_BYTE *)(a1 + 0x108) = 1;
  sub_14036BE70((_QWORD *)(a1 + 0x110));
  result = a1;
  *(_QWORD *)(a1 + 0x130) = 0;
  *(_DWORD *)(a1 + 0x138) = 0;
  *(_WORD *)(a1 + 0x13C) = 0;
  *(_QWORD *)(a1 + 0x158) = 0;
  *(_DWORD *)(a1 + 0x144) = 0x800000;
  *(_DWORD *)(a1 + 0x148) = 0x800000;
  *(_DWORD *)(a1 + 0x14C) = 0x800000;
  *(_DWORD *)(a1 + 0x150) = 0x800000;
  *(_WORD *)(a1 + 0x154) = 0xFFFF;
  return result;
}

// --- End Function: sub_141886BE0 (0x141886BE0) ---

// --- Function: sub_141DA58F0 (0x141DA58F0) ---
void __fastcall sub_141DA58F0(
        unsigned int n5,
        __int64 *a2,
        char *p_Projectile_Hit_Discarded,
        char *p_$$:_Projectile_owned_by__$$__[$$]_discarded_due_to_invalid_targ,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 *ThreadLogContextSlot,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12)
{
  void *v15; // rsp
  const char *p_null; // r8
  const char *p_null_1; // rdx
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rcx
  __int64 v20; // [rsp+18h] [rbp-1D8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-1C0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-168h]
  __int64 n0xB0; // [rsp+90h] [rbp-160h]
  __int64 n0xA8; // [rsp+98h] [rbp-158h]
  _QWORD *v25; // [rsp+A0h] [rbp-150h]
  const char *p_Function; // [rsp+A8h] [rbp-148h]
  __int64 v27; // [rsp+B0h] [rbp-140h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+B8h] [rbp-138h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+C0h] [rbp-130h]
  __int64 v30; // [rsp+C8h] [rbp-128h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+D0h] [rbp-120h]
  __int64 v32; // [rsp+D8h] [rbp-118h]
  void (__fastcall *p_sub_1403E4E80)(const void **); // [rsp+E0h] [rbp-110h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+E8h] [rbp-108h]
  unsigned __int64 v35; // [rsp+F0h] [rbp-100h]
  char v36; // [rsp+F8h] [rbp-F8h]
  char v37; // [rsp+F9h] [rbp-F7h]
  __int64 n0x18; // [rsp+100h] [rbp-F0h]
  unsigned __int64 v39; // [rsp+108h] [rbp-E8h]
  _QWORD *v40; // [rsp+110h] [rbp-E0h]
  const char *p_Name; // [rsp+118h] [rbp-D8h]
  __int64 v42; // [rsp+120h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1403EB580_1)(__int64, _BYTE *, size_t, __int64, char); // [rsp+128h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403EB0E0_1)(__int64, _BYTE *, int); // [rsp+130h] [rbp-C0h]
  __int64 v45; // [rsp+138h] [rbp-B8h]
  bool (__fastcall *p_sub_1403E7650_1)(__int64, __int64); // [rsp+140h] [rbp-B0h]
  __int64 v47; // [rsp+148h] [rbp-A8h]
  void (__fastcall *p_sub_1403E4E80_1)(const void **); // [rsp+150h] [rbp-A0h]
  _QWORD *(__fastcall *p_sub_1403E4B90_1)(_QWORD *); // [rsp+158h] [rbp-98h]
  unsigned __int64 v50; // [rsp+160h] [rbp-90h]
  char v51; // [rsp+168h] [rbp-88h]
  char v52; // [rsp+169h] [rbp-87h]
  __int64 n0x18_1; // [rsp+170h] [rbp-80h]
  unsigned __int64 v54; // [rsp+178h] [rbp-78h]
  _QWORD *v55; // [rsp+180h] [rbp-70h]
  const char *p_EntityId; // [rsp+188h] [rbp-68h]
  __int64 v57; // [rsp+190h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB550)(__int64, __int64, __int64); // [rsp+198h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EAFB0)(__int64, _BYTE *, unsigned __int64); // [rsp+1A0h] [rbp-50h]
  __int64 v60; // [rsp+1A8h] [rbp-48h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+1B0h] [rbp-40h]
  __int64 v62; // [rsp+1B8h] [rbp-38h]
  void (__fastcall *p_sub_1403E4EB0)(const void *); // [rsp+1C0h] [rbp-30h]
  __int64 (__fastcall *p_sub_1403E4C70)(__int64); // [rsp+1C8h] [rbp-28h]
  unsigned __int64 v65; // [rsp+1D0h] [rbp-20h]
  char v66; // [rsp+1D8h] [rbp-18h]
  char v67; // [rsp+1D9h] [rbp-17h]
  __int64 n0x18_2; // [rsp+1E0h] [rbp-10h]
  __int64 n0x17; // [rsp+1E8h] [rbp-8h]

  v15 = alloca(0x1C0);
  p_null = "null";
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  p_Function = "Function";
  v25 = a10;
  __Val_0___[0] = ThreadLogContextSlot;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v37 = 1;
  v27 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v30 = 0;
  v32 = 0;
  v35 = 0xFFFFFFFFFFFFFFFFuLL;
  v36 = 0;
  n0x18 = 0x18;
  p_null_1 = "null";
  if ( a10[1] )
    p_null_1 = (const char *)a10[1];
  v18 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v18;
  while ( p_null_1[v18] );
  v39 = v18;
  p_Name = "Name";
  v40 = a11;
  v52 = 0;
  v42 = *a11;
  p_sub_1403EB580_1 = sub_1403EB580;
  p_sub_1403EB0E0_1 = sub_1403EB0E0;
  p_sub_1403E7650_1 = sub_1403E7650;
  p_sub_1403E4E80_1 = sub_1403E4E80;
  p_sub_1403E4B90_1 = sub_1403E4B90;
  v45 = 0;
  v47 = 0;
  v50 = 0xFFFFFFFFFFFFFFFFuLL;
  v51 = 0;
  n0x18_1 = 0x18;
  if ( a11[1] )
    p_null = (const char *)a11[1];
  v19 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v19;
  while ( p_null[v19] );
  v54 = v19;
  v55 = a12;
  p_EntityId = "EntityId";
  v67 = 1;
  v57 = *a12;
  p_sub_1403EB550 = sub_1403EB550;
  p_sub_1403EAFB0 = sub_1403EAFB0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E4EB0 = sub_1403E4EB0;
  p_sub_1403E4C70 = sub_1403E4C70;
  LODWORD(v20) = a6;
  v60 = 0;
  v62 = 0;
  v65 = 0xFFFFFFFFFFFFFFFFuLL;
  v66 = 0;
  n0x18_2 = 0x18;
  n0x17 = 0x17;
  sub_1403045C0(
    n5,
    a2,
    p_Projectile_Hit_Discarded,
    p_$$:_Projectile_owned_by__$$__[$$]_discarded_due_to_invalid_targ,
    (vraudio::AudioBuffer *)__Val_0___,
    4u,
    a5,
    v20,
    a7,
    a8);
}

// --- End Function: sub_141DA58F0 (0x141DA58F0) ---

// --- Function: sub_141DA5C20 (0x141DA5C20) ---
__int64 __fastcall sub_141DA5C20(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  const char *p_null; // rdx
  const char *p_null_2; // rax
  const char *p_null_1; // r8
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rax
  __int64 n4; // rax

  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  p_null = "null";
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x78) = "Function";
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  *(_BYTE *)(a1 + 0xC9) = 1;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  p_null_2 = (const char *)a3[1];
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v8;
  while ( p_null_1[v8] );
  *(_QWORD *)(a1 + 0xD8) = v8;
  *(_QWORD *)(a1 + 0xE8) = "Name";
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_BYTE *)(a1 + 0x139) = 0;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x100) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x110) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x120) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x128) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x18;
  if ( a4[1] )
    p_null = (const char *)a4[1];
  v9 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v9;
  while ( p_null[v9] );
  *(_QWORD *)(a1 + 0x148) = v9;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_QWORD *)(a1 + 0x158) = "EntityId";
  *(_BYTE *)(a1 + 0x1A9) = 1;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x168) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x170) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0x180) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x190) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0x198) = sub_1403E4C70;
  n4 = 4;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0x18;
  *(_QWORD *)(a1 + 0x1B8) = 0x17;
  return n4;
}

// --- End Function: sub_141DA5C20 (0x141DA5C20) ---

// --- Function: sub_141F6B8A0 (0x141F6B8A0) ---
_QWORD *__fastcall sub_141F6B8A0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 (__fastcall *v4)(unsigned __int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v8; // [rsp+48h] [rbp+10h] BYREF
  char v9; // [rsp+50h] [rbp+18h] BYREF
  char v10; // [rsp+58h] [rbp+20h] BYREF

  v8 = a2;
  if ( sub_14030EC00(&v8) )
  {
    v3 = v8 & 0xFFFFFFFFFFFFLL;
    v4 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(v8 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_78;
    if ( n0xFFFF_78 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v9,
                            "IEntityAudioControllerComponent");
      n0xFFFF_78 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    *a1 = *(_QWORD *)v4(v3, &v10, &n0xFFFF_1);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

// --- End Function: sub_141F6B8A0 (0x141F6B8A0) ---

// --- Function: sub_1425D62E0 (0x1425D62E0) ---
_QWORD *__fastcall sub_1425D62E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_31;
  if ( n0xFFFF_31 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "Actor");
    n0xFFFF_31 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D62E0 (0x1425D62E0) ---

// --- Function: sub_1425D6660 (0x1425D6660) ---
_QWORD *__fastcall sub_1425D6660(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_79;
  if ( n0xFFFF_79 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "ObservableComponent");
    n0xFFFF_79 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D6660 (0x1425D6660) ---

// --- Function: ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@1@@Z (0x1426FC3B0) ---
Parameter *__fastcall std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
        Parameter *Parameter_1,
        __int64 a2)
{
  *(_QWORD *)Parameter_1 = a2;
  _StarEngineModule__((ULONG_PTR)Parameter_1);
  return Parameter_1;
}

// --- End Function: ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@1@@Z (0x1426FC3B0) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142705140 (0x142705140) ---
__int64 __fastcall sub_142705140(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x10);
}

// --- End Function: sub_142705140 (0x142705140) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || sub_140539D80() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: unknown_libname_484 (0x142739050) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
__int64 __fastcall unknown_libname_484(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: unknown_libname_484 (0x142739050) ---

// --- Function: sub_142744750 (0x142744750) ---
__int64 __fastcall sub_142744750(unsigned __int8 a1)
{
  return (unsigned int)a1 + 0xC7;
}

// --- End Function: sub_142744750 (0x142744750) ---

// --- Function: ?is_valid@?$__crt_unique_heap_ptr@_WU__crt_internal_free_policy@@@@QEBA_NXZ (0x1427493B0) ---
// Microsoft VisualC v14 64bit runtime
_BOOL8 __fastcall __crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid(_QWORD *a1)
{
  return *a1 != 0;
}

// --- End Function: ?is_valid@?$__crt_unique_heap_ptr@_WU__crt_internal_free_policy@@@@QEBA_NXZ (0x1427493B0) ---

// --- Function: _Mtx_getconcrtcs (0x14277C5B0) ---
void *__cdecl Mtx_getconcrtcs(_Mtx_t a1)
{
  return (char *)a1 + 8;
}

// --- End Function: _Mtx_getconcrtcs (0x14277C5B0) ---

// --- Function: unknown_libname_67 (0x14277CFC0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_67()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_67 (0x14277CFC0) ---

// --- Function: sub_142A6B3F0 (0x142A6B3F0) ---
_QWORD *__fastcall sub_142A6B3F0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_80;
  if ( n0xFFFF_80 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "SCPlayerGameRulesNetworkComponent");
    n0xFFFF_80 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_142A6B3F0 (0x142A6B3F0) ---

// --- Function: sub_142C32150 (0x142C32150) ---
const ULONG_PTR *__fastcall sub_142C32150(__int64 a1)
{
  return sub_142CA7C80(a1);
}

// --- End Function: sub_142C32150 (0x142C32150) ---

// --- Function: sub_142CBE270 (0x142CBE270) ---
__int64 __fastcall sub_142CBE270(__int64 a1)
{
  bool v2; // [rsp+20h] [rbp-88h]
  __int64 v3; // [rsp+28h] [rbp-80h]
  __int64 v4; // [rsp+30h] [rbp-78h]
  __int64 v5; // [rsp+38h] [rbp-70h]
  _DWORD *v6; // [rsp+48h] [rbp-60h]
  _DWORD *v7; // [rsp+50h] [rbp-58h]
  const char *v8; // [rsp+58h] [rbp-50h]
  __int64 v9; // [rsp+60h] [rbp-48h]
  unsigned __int8 (__fastcall *v10)(__int64, __int64, const char *); // [rsp+68h] [rbp-40h]
  _BYTE v11[24]; // [rsp+70h] [rbp-38h] BYREF
  _BYTE v12[32]; // [rsp+88h] [rbp-20h] BYREF

  if ( !a1 )
    return 0;
  v7 = (_DWORD *)sub_142D00F20(v12);
  v6 = (_DWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 0x18LL))(a1, v11);
  v2 = unknown_libname_19(v7, v6);
  sub_1403090C0((__int64)v11);
  sub_1403090C0((__int64)v12);
  if ( v2 )
    return a1;
  if ( sub_1402C7230()
    && (v3 = sub_1402C7230(), (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x240LL))(v3))
    && (v4 = sub_1402C7230(),
        v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x240LL))(v4),
        v10 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v5 + 0x100LL),
        v8 = sub_142D00F00(),
        v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1),
        v10(v5, v9, v8)) )
  {
    return a1;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_142CBE270 (0x142CBE270) ---

// --- Function: sub_142CBEFA0 (0x142CBEFA0) ---
__int64 __fastcall sub_142CBEFA0(__int64 a1)
{
  return sub_142CBE270(*(_QWORD *)(a1 + 0xE0));
}

// --- End Function: sub_142CBEFA0 (0x142CBEFA0) ---

// --- Function: sub_142CE4F70 (0x142CE4F70) ---
__int64 __fastcall sub_142CE4F70(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = a1 + 0xE0;
  if ( !__crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid((_QWORD *)(a1 + 0xE0)) )
    return 0;
  v2 = unknown_libname_484(v1);
  if ( !__crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid((_QWORD *)(v2 + 8)) )
    return 0;
  v3 = unknown_libname_484(v1);
  return unknown_libname_484(v3 + 8) + 0x18;
}

// --- End Function: sub_142CE4F70 (0x142CE4F70) ---

// --- Function: sub_142D00F00 (0x142D00F00) ---
const char *sub_142D00F00()
{
  return "BulletProjectileParams";
}

// --- End Function: sub_142D00F00 (0x142D00F00) ---

// --- Function: sub_142D00F20 (0x142D00F20) ---
__int64 __fastcall sub_142D00F20(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  BulletProjectileParams *BulletProjectileParams; // rcx

  v1 = dword_149E11988;
  if ( !dword_149E11988 )
  {
    v3 = sub_1402D2830(0x4Eu, 8, 0x80u, 2);
    v4 = sub_1402CA4C0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D2830(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402E1FE0((unsigned __int8 *)"ulletProjectileParams", v5 ^ 0xFFFFFFu);
    BulletProjectileParams = (char *)allocWithProfilerInfo(0x17u, 0);
    strcpy(BulletProjectileParams, "BulletProjectileParams");
    dword_149E11988 = v1;
    if ( BulletProjectileParams )
    {
      sub_147605980(BulletProjectileParams);
      v1 = dword_149E11988;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_142D00F20 (0x142D00F20) ---

// --- Function: sub_142D013E0 (0x142D013E0) ---
__int64 __fastcall sub_142D013E0(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  ProjectileParams *ProjectileParams; // rax

  v1 = dword_149E113A8;
  if ( !dword_149E113A8 )
  {
    v3 = sub_1402D2830(0x47u, 8, 0x80u, 2);
    v4 = sub_1402CA4C0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D2830(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402E1FE0((unsigned __int8 *)"rojectileParams", v5 ^ 0xFFFFFFu);
    ProjectileParams = (char *)allocWithProfilerInfo(0x11u, 0);
    strcpy(ProjectileParams, "ProjectileParams");
    dword_149E113A8 = v1;
    if ( ProjectileParams )
    {
      sub_147605980(ProjectileParams);
      v1 = dword_149E113A8;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_142D013E0 (0x142D013E0) ---

// --- Function: sub_143068F20 (0x143068F20) ---
__int64 __fastcall sub_143068F20(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  unsigned __int64 v7; // rax
  const char *p_null; // rdx

  *(_QWORD *)a1 = a2;
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  v7 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Function";
  *(_BYTE *)(a1 + 0xC9) = 1;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_BYTE *)(a1 + 0xC8) = 0;
  p_null = "null";
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  if ( a3[1] )
    p_null = (const char *)a3[1];
  do
    ++v7;
  while ( p_null[v7] );
  *(_QWORD *)(a1 + 0xD8) = v7;
  return sub_140356FD0(a1 + 0xE0, a4, a5, a6, a7) + 2;
}

// --- End Function: sub_143068F20 (0x143068F20) ---

// --- Function: sub_1431B0E90 (0x1431B0E90) ---
__int64 __fastcall sub_1431B0E90(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_DWORD *)(a1 + 0x18) = 0;
  sub_142C85310(a1);
  return a1;
}

// --- End Function: sub_1431B0E90 (0x1431B0E90) ---

// --- Function: sub_143268A80 (0x143268A80) ---
__int64 __fastcall sub_143268A80(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  SEntityParticlePhysicsControllerParams *SEntityParticlePhysicsControllerParams; // rcx
  __int64 result; // rax

  v1 = dword_149E20CF0;
  if ( !dword_149E20CF0 )
  {
    v3 = sub_1402D2830(0x46u, 8, 0, 2);
    v4 = sub_1402CA4C0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D2830(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402E1FE0((unsigned __int8 *)"EntityParticlePhysicsControllerParams", v5 ^ 0xFFFFFFu);
    SEntityParticlePhysicsControllerParams = (char *)allocWithProfilerInfo(0x27u, 0);
    strcpy(SEntityParticlePhysicsControllerParams, "SEntityParticlePhysicsControllerParams");
    dword_149E20CF0 = v1;
    if ( SEntityParticlePhysicsControllerParams )
    {
      __asm { vzeroupper }
      sub_147605980(SEntityParticlePhysicsControllerParams);
      v1 = dword_149E20CF0;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_143268A80 (0x143268A80) ---

// --- Function: sub_143417000 (0x143417000) ---
unsigned __int64 __fastcall sub_143417000(__int64 a1, _QWORD *a2)
{
  _QWORD *i; // rbx
  __int64 v5; // rbx
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rsi
  __int64 v10; // rbx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rcx
  __int64 v13; // rsi

  sub_140525360(a1, (__int64)"pZoneHost", a2);
  sub_140525200(a1);
  sub_140525200(a1);
  sub_140525200(a1);
  for ( i = a2 + 9; i != a2 + 0xC; i = (_QWORD *)((char *)i + 4) )
    sub_1405251E0(a1);
  sub_1405252B0(a1);
  sub_140525250(a1);
  sub_140525250(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405253C0(a1);
  sub_1405252E0(a1, (__int64)"sound_name", a2 + 0x17);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405253C0(a1);
  sub_140525250(a1);
  sub_140525200(a1);
  sub_1405251C0(a1);
  sub_1405252E0(a1, (__int64)"customMaterialEffect", a2 + 0x21);
  sub_1405252E0(a1, (__int64)"effectName", a2 + 0x22);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  v5 = a2[0x2D];
  v6 = a2[0x2C];
  v7 = (v5 - v6) >> 6;
  v8 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  do
  {
    v7 >>= 7;
    v8 += 8LL;
  }
  while ( v7 );
  *(_QWORD *)(a1 + 8) = v8;
  if ( v6 != v5 )
  {
    v9 = v6 + 0xC;
    do
    {
      sub_140525360(a1, (__int64)"pEntityPtr", (unsigned __int64 *)(v9 - 0xC));
      sub_1405251E0(a1);
      sub_140525250(a1);
      sub_140525250(a1);
      v9 += 0x40;
    }
    while ( v9 - 0xC != v5 );
  }
  v10 = a2[0x2F];
  v11 = *(unsigned int *)(v10 - 4);
  LODWORD(v11) = v11 & 0x7FFFFFFF;
  v12 = (*(_QWORD *)(a1 + 8) + 7LL) & 0xFFFFFFFFFFFFFFF8uLL;
  v13 = v10 + 8 * v11;
  do
  {
    v11 >>= 7;
    v12 += 8LL;
  }
  while ( v11 );
  for ( *(_QWORD *)(a1 + 8) = v12; v10 != v13; v10 += 8 )
  {
    sub_1405251E0(a1);
    sub_1405251E0(a1);
  }
  sub_1405253C0(a1);
  sub_1405253C0(a1);
  sub_1405251E0(a1);
  sub_140525250(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  sub_1405251E0(a1);
  return sub_1405251E0(a1);
}

// --- End Function: sub_143417000 (0x143417000) ---

// --- Function: sub_143452980 (0x143452980) ---
__int64 __fastcall sub_143452980(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  __int64 v5; // rsi
  __int64 v6; // rsi
  __int16 v7; // dx
  __int64 (__fastcall *v8)(int *, _QWORD *); // rax
  _BYTE v9[8]; // [rsp+30h] [rbp-78h] BYREF
  void *(__fastcall **v10)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+38h] [rbp-70h] BYREF
  __int64 v11; // [rsp+40h] [rbp-68h]
  _QWORD v12[2]; // [rsp+48h] [rbp-60h] BYREF
  _QWORD v13[3]; // [rsp+58h] [rbp-50h] BYREF
  int v14; // [rsp+70h] [rbp-38h] BYREF
  __int128 v15; // [rsp+78h] [rbp-30h]

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) + 0x720LL))(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( !(_BYTE)result )
    return sub_1405C0E00(
             0xAu,
             0,
             "%s can only be initiated from the server with authority",
             "CSCPlayerGameRulesNetworkComponent::Explosion");
  v5 = *(_QWORD *)(a1 + 0xF8);
  v14 = 0;
  v9[0] = 0;
  v15 = xmmword_1487B5488;
  v6 = v5 & 0xFFFFFFFFFFFFLL;
  if ( v6 )
  {
    v11 = 0;
    v10 = &off_1481AF030;
    sub_143417000((__int64)&v10, a2);
    v7 = *(_WORD *)(a1 + 0x100);
    v13[0] = sub_1434864B0;
    v13[1] = a2;
    v12[0] = v13;
    v12[1] = sub_1411DB480;
    result = (*(__int64 (__fastcall **)(__int64, _QWORD, int *, __int64, _QWORD *, _BYTE *))(*(_QWORD *)v6 + 8LL))(
               v6,
               v7 & 0x3FFF,
               &v14,
               v11,
               v12,
               v9);
    if ( v9[0] )
    {
      v8 = *(__int64 (__fastcall **)(int *, _QWORD *))(a1 + 0xE0);
      if ( *(_QWORD *)(a1 + 0xE8) == 1 )
        return v8(&v14, a2);
      else
        return ((__int64 (__fastcall *)(__int64, int *, _QWORD *))v8)(a1 + 0xE0, &v14, a2);
    }
  }
  return result;
}

// --- End Function: sub_143452980 (0x143452980) ---

// --- Function: sub_1434864B0 (0x1434864B0) ---
__int64 __fastcall sub_1434864B0(__int64 a1)
{
  _QWORD v2[3]; // [rsp+20h] [rbp-18h] BYREF

  v2[1] = a1;
  v2[0] = &off_1481AF030;
  return sub_143417C10(v2);
}

// --- End Function: sub_1434864B0 (0x1434864B0) ---

// --- Function: sub_14396A280 (0x14396A280) ---
__int64 __fastcall sub_14396A280(__int64 a1)
{
  return a1 + 0xA8;
}

// --- End Function: sub_14396A280 (0x14396A280) ---

// --- Function: sub_143B72180 (0x143B72180) ---
_QWORD *__fastcall sub_143B72180(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // [rsp+28h] [rbp-70h]
  _QWORD *v5; // [rsp+30h] [rbp-68h]
  _QWORD v6[2]; // [rsp+40h] [rbp-58h] BYREF
  _QWORD src_[2]; // [rsp+50h] [rbp-48h] BYREF
  __int64 v8; // [rsp+60h] [rbp-38h] BYREF
  _BYTE dst_[16]; // [rsp+70h] [rbp-28h] BYREF

  src_[0] = p_p_p_sub_140384A94;
  LODWORD(src_[1]) = 0;
  qmemcpy(dst_, src_, sizeof(dst_));
  _StarEngineModule__(0);
  v2 = sub_1402A24F0((__int64)&qword_149B4FBE0);
  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(v2 + 0xA0) + 0x118LL))(*(_QWORD *)(v2 + 0xA0), a2);
  if ( v4 )
  {
    v5 = sub_142A6B3F0(v4, &v8);
  }
  else
  {
    v6[0] = 0;
    v5 = v6;
  }
  v6[1] = v5;
  *a1 = *v5;
  return a1;
}

// --- End Function: sub_143B72180 (0x143B72180) ---

// --- Function: sub_143C89900 (0x143C89900) ---
__int64 __fastcall sub_143C89900(__int64 a1, __int64 a2, float a3, char a4)
{
  _QWORD *v7; // rdi
  ULONG_PTR *v8; // rax
  __int64 v9; // rdi
  float v10; // xmm9_4
  float v11; // xmm7_4
  float v12; // xmm1_4
  float v13; // xmm6_4
  ULONG_PTR *v14; // rax
  ULONG_PTR *v15; // rax
  __int64 v16; // r14
  __int64 result; // rax
  __int64 (__fastcall *v18)(__int64, const ULONG_PTR *, const ULONG_PTR *); // rdi
  __int64 v19; // rax
  const ULONG_PTR *v20; // rax
  __int64 v21; // rcx
  const ULONG_PTR *v22; // rbx
  __int64 v23; // rax
  const ULONG_PTR *v24; // rax

  if ( !a4 || (v7 = (_QWORD *)(a1 + 0x100), sub_1403E5570((_QWORD *)(a1 + 0x100))) )
    v7 = (_QWORD *)(a1 + 0xE0);
  if ( !sub_1403E5570(v7) )
  {
    v8 = (ULONG_PTR *)sub_14037FC70((__int64)v7);
    sub_1403D6030(a2, v8);
  }
  *(float *)(a2 + 0x98) = a3 * *(float *)(a1 + 0x14);
  if ( !a4 || (v9 = a1 + 0xB8, sub_1403E5570((_QWORD *)(a1 + 0xB8))) )
    v9 = a1 + 0xA0;
  v10 = *(float *)(a1 + 0x64);
  if ( *(_BYTE *)(a1 + 0x74) )
  {
    v11 = *(float *)(a1 + 0x6C);
    v12 = *(float *)(a1 + 0x70) - v11;
    v13 = (float)(sub_14056CEA0().m128_f32[0] * v12) + v11;
  }
  else
  {
    v13 = *(float *)(a1 + 0x68);
  }
  v14 = (ULONG_PTR *)sub_14037FC70(v9);
  sub_1403D4870(a2, v14, v13 * a3, v10);
  *(_DWORD *)(a2 + 0x124) = *(_DWORD *)(a1 + 0x178);
  if ( __crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid((_QWORD *)(a1 + 0x118)) )
  {
    *(_DWORD *)(a2 + 0xE8) = *(_DWORD *)(unknown_libname_484(a1 + 0x118) + 8);
    *(_DWORD *)(a2 + 0xEC) = *(_DWORD *)(unknown_libname_484(a1 + 0x118) + 0xC);
  }
  v15 = (ULONG_PTR *)sub_14037FC70(a1 + 0xC8);
  assignCStringToStringStructure((void **)(a2 + 0x108), v15);
  v16 = qword_149B4FCF0;
  result = __crt_unique_heap_ptr<wchar_t,__crt_internal_free_policy>::is_valid((_QWORD *)(a1 + 0x138));
  if ( (_BYTE)result )
  {
    if ( v16 )
    {
      v18 = *(__int64 (__fastcall **)(__int64, const ULONG_PTR *, const ULONG_PTR *))(*(_QWORD *)v16 + 0x38LL);
      v19 = unknown_libname_484(a1 + 0x138);
      v20 = sub_14037FC70(v19 + 0x18);
      v21 = a1 + 0x138;
      v22 = v20;
      v23 = unknown_libname_484(v21);
      v24 = sub_14037FC70(v23 + 8);
      result = v18(v16, v24, v22);
      *(_WORD *)(a2 + 0x100) = result;
    }
  }
  return result;
}

// --- End Function: sub_143C89900 (0x143C89900) ---

// --- Function: sub_143CF4820 (0x143CF4820) ---
__int64 __fastcall sub_143CF4820(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rdi
  const char *String2; // rax

  result = *(unsigned int *)(a1 + 0x1B8);
  if ( (_DWORD)result == 0xFFFFFFFF )
  {
    v3 = sub_1464E7930(qword_149E7E438);
    if ( v3 )
    {
      String2 = (const char *)sub_14037FC70(a1 + 0x88);
      *(_DWORD *)(a1 + 0x1B8) = sub_146481FD0(v3, String2);
    }
    result = *(unsigned int *)(a1 + 0x1B8);
    if ( (int)result <= 0 )
    {
      result = sub_140359B80(5u);
      *(_DWORD *)(a1 + 0x1B8) = result;
    }
  }
  return result;
}

// --- End Function: sub_143CF4820 (0x143CF4820) ---

// --- Function: sub_143D7C7A0 (0x143D7C7A0) ---
__int64 __fastcall sub_143D7C7A0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_BYTE *)(a2 + 0x12C) = 1;
  *(_DWORD *)(a2 + 0x130) = *(_DWORD *)(a1 + 8);
  *(double *)(a2 + 0x134) = *(double *)(a1 + 0x18);
  *(_DWORD *)(a2 + 0x13C) = *(_DWORD *)(a1 + 0x20);
  *(_DWORD *)(a2 + 0x140) = *(_DWORD *)(a1 + 0x28);
  *(_DWORD *)(a2 + 0x144) = *(_DWORD *)(a1 + 0x2C);
  *(_DWORD *)(a2 + 0x148) = *(_DWORD *)(a1 + 0x30);
  *(_DWORD *)(a2 + 0x14C) = *(_DWORD *)(a1 + 0x34);
  *(_DWORD *)(a2 + 0x150) = *(_DWORD *)(a1 + 0x38);
  *(_DWORD *)(a2 + 0x154) = *(_DWORD *)(a1 + 0x3C);
  result = *(unsigned int *)(a1 + 0x40);
  *(_DWORD *)(a2 + 0x158) = result;
  return result;
}

// --- End Function: sub_143D7C7A0 (0x143D7C7A0) ---

// --- Function: sub_143FF78C0 (0x143FF78C0) ---
__int64 __fastcall sub_143FF78C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v7; // [rsp+30h] [rbp-28h]
  __int64 v8; // [rsp+38h] [rbp-20h] BYREF
  __int64 v9; // [rsp+40h] [rbp-18h]
  __int64 v10; // [rsp+48h] [rbp-10h]

  v8 = a3;
  v9 = a3;
  v10 = a4;
  while ( a1 != a2 )
  {
    sub_143FF3EA0(&v8, a1);
    a1 += 0x40;
  }
  v8 = v9;
  v7 = v9;
  sub_143FFC6E0(&v8);
  return v7;
}

// --- End Function: sub_143FF78C0 (0x143FF78C0) ---

// --- Function: sub_143FFCC30 (0x143FFCC30) ---
void *(__fastcall **__fastcall sub_143FFCC30(_QWORD *a1))(FDefaultModuleImpl *__hidden this, unsigned int)
{
  _QWORD *v2; // rcx
  void *(__fastcall **result)(FDefaultModuleImpl *__hidden, unsigned int); // rax

  v2 = (_QWORD *)a1[5];
  if ( v2 )
  {
    if ( ((a1[7] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[5] = 0;
    a1[6] = 0;
    a1[7] = 0;
  }
  result = &off_1481A0DB8;
  *a1 = &off_1481A0DB8;
  return result;
}

// --- End Function: sub_143FFCC30 (0x143FFCC30) ---

// --- Function: sub_143FFEA60 (0x143FFEA60) ---
const ULONG_PTR *__fastcall sub_143FFEA60(__int64 a1, int a2)
{
  __int64 v3; // rbx
  int v5; // esi
  unsigned __int32 v6; // eax
  int v7; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v9; // eax

  v3 = a1 + 0x308;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v5 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v6 )
      sub_1403C33A0(v3, v6, "CProjectile::AppendProjectileFlags", 1);
    else
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v3 + 0x10) = v5;
  }
  *(_DWORD *)(a1 + 0x200) |= a2;
  v7 = *(_DWORD *)(v3 + 0x14);
  if ( v7 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v7 - 1);
    *(_DWORD *)(v3 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 0, 1);
    if ( v9 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v3 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v3, v9);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_143FFEA60 (0x143FFEA60) ---

// --- Function: sub_144002630 (0x144002630) ---
const ULONG_PTR *__fastcall sub_144002630(__int64 a1, int a2)
{
  __int64 v3; // rbx
  int v5; // ebp
  unsigned __int32 v6; // eax
  int v7; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v9; // eax

  v3 = a1 + 0x308;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v3 + 0x10) == v5 )
  {
    ++*(_DWORD *)(v3 + 0x14);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v6 )
      sub_1403C33A0(v3, v6, "CProjectile::ClearProjectileFlags", 1);
    else
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v3 + 0x10) = v5;
  }
  *(_DWORD *)(a1 + 0x200) &= ~a2;
  v7 = *(_DWORD *)(v3 + 0x14);
  if ( v7 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v7 - 1);
    *(_DWORD *)(v3 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v3 + 0x10) = 0xFFFFFFFF;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 0, 1);
    if ( v9 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v3 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v3, v9);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_144002630 (0x144002630) ---

// --- Function: sub_1440066E0 (0x1440066E0) ---
double __fastcall sub_1440066E0(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rcx
  int v6; // eax
  _DWORD v8[2]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v9; // [rsp+38h] [rbp-50h]
  unsigned __int64 v10; // [rsp+40h] [rbp-48h]
  unsigned __int64 v11; // [rsp+48h] [rbp-40h]
  __int64 v12; // [rsp+50h] [rbp-38h]
  __int64 v13; // [rsp+58h] [rbp-30h]

  v4 = 0;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v5 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v5 = 0;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 0x708LL))(v5);
  v8[0] = 0x4600;
  v9 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v8[1] = v6;
  v10 = __rdtsc();
  qword_149B4B870(
    v8,
    &word_149E38D68,
    "CBullet::DestroyAtHitPosition",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Bullet.cpp",
    0x15E);
  HIWORD(v8[0]) = word_149E38D68;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v4 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 0x2C0LL))(v4, a2, 2);
  sub_145D15910(a1);
  v11 = __rdtsc();
  return qword_149B4B878(v8);
}

// --- End Function: sub_1440066E0 (0x1440066E0) ---

// --- Function: sub_14400A130 (0x14400A130) ---
__int64 __fastcall sub_14400A130(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // rax
  _DWORD *v8; // rax
  char v10; // [rsp+30h] [rbp-48h] BYREF

  *(_QWORD *)a2 = &off_1481B0218;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 0x340);
  *(double *)(a2 + 0x18) = *(double *)(a1 + 0x350);
  v6 = sub_142705140(a1 + 0xB0);
  v7 = sub_142CBEFA0(v6);
  if ( v7 )
  {
    v8 = (_DWORD *)sub_145D0D920((unsigned int)&v10, a2, v7, (int)a1 + 0x218, a3);
    *(_DWORD *)(a2 + 8) = v8[2];
    *(_DWORD *)(a2 + 0xC) = v8[3];
    *(_DWORD *)(a2 + 0x10) = v8[4];
    *(_DWORD *)(a2 + 0x14) = v8[5];
    *(_DWORD *)(a2 + 0x18) = v8[6];
    *(_DWORD *)(a2 + 0x1C) = v8[7];
  }
  sub_140384A00((float *)a2, (float *)(a1 + 0x358));
  sub_14039B2F0(a2, 0.0);
  return a2;
}

// --- End Function: sub_14400A130 (0x14400A130) ---

// --- Function: sub_14400AA90 (0x14400AA90) ---
__int64 __fastcall sub_14400AA90(__int64 a1)
{
  __int64 v2; // rdi
  const char *String2; // rax

  if ( *(_DWORD *)(a1 + 0x150) != 0xFFFFFFFF )
    return *(unsigned int *)(a1 + 0x150);
  v2 = sub_1464E7930(qword_149E7E438);
  if ( v2 )
  {
    String2 = (const char *)sub_14037FC70(a1 + 0x28);
    *(_DWORD *)(a1 + 0x150) = sub_146481FD0(v2, String2);
  }
  return *(unsigned int *)(a1 + 0x150);
}

// --- End Function: sub_14400AA90 (0x14400AA90) ---

// --- Function: sub_1440136F0 (0x1440136F0) ---
const ULONG_PTR *__fastcall sub_1440136F0(__int64 a1, __int64 a2)
{
  __int64 v2; // r15
  int v5; // ebx
  unsigned __int32 v6; // eax
  __int64 gEnv; // rdi
  void (__fastcall *v8)(__int64, unsigned __int64 *, _QWORD); // rbx
  _QWORD *v9; // rax
  int v10; // xmm6_4
  _BYTE *concrtcs; // rax
  __int64 v12; // rbx
  char v13; // r13
  char v14; // r12
  __int64 v15; // rdi
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // r14
  __int64 v18; // rax
  unsigned __int64 v19; // r9
  __int64 v20; // r14
  __int64 v21; // rdi
  float *v22; // rax
  unsigned __int8 v23; // bl
  __int64 v24; // rax
  __int64 v25; // rax
  _QWORD *v26; // rbx
  const ULONG_PTR *v27; // rsi
  __int64 v28; // rcx
  __int64 v29; // rax
  char v31; // r12
  __int64 v32; // rcx
  __int64 v33; // rcx
  _QWORD *v34; // rax
  __int64 v35; // rax
  float *v36; // rax
  __int64 v38; // rcx
  __int64 v39; // rdx
  __int64 v40; // rax
  __int64 v41; // rdi
  void (__fastcall *v42)(__int64, _BYTE *, __int64, bool); // rsi
  bool v43; // bl
  __int64 v44; // rax
  __int64 v45; // rcx
  __int64 v46; // rax
  __int64 v47; // rax
  unsigned __int64 *v48; // rcx
  const char *v49; // rdi
  __int64 v50; // rcx
  const char *v51; // rax
  int v52; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v54; // eax
  __int64 v55; // [rsp+78h] [rbp-90h] BYREF
  __int64 v56; // [rsp+80h] [rbp-88h] BYREF
  float _R8_; // [rsp+88h] [rbp-80h] BYREF
  unsigned __int64 v58; // [rsp+90h] [rbp-78h] BYREF
  __int64 v59; // [rsp+98h] [rbp-70h]
  __int64 v60; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v61; // [rsp+A8h] [rbp-60h] BYREF
  unsigned __int64 v62; // [rsp+B0h] [rbp-58h] BYREF
  unsigned __int64 v63; // [rsp+B8h] [rbp-50h] BYREF
  int n0x4600; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v65; // [rsp+CCh] [rbp-3Ch]
  int v66; // [rsp+D4h] [rbp-34h]
  unsigned __int64 v67; // [rsp+D8h] [rbp-30h]
  unsigned __int64 v68; // [rsp+E0h] [rbp-28h]
  __int64 v69; // [rsp+E8h] [rbp-20h]
  __int64 v70; // [rsp+F0h] [rbp-18h]
  int v71; // [rsp+118h] [rbp+10h] BYREF
  unsigned __int64 v72; // [rsp+11Ch] [rbp+14h]
  int v73; // [rsp+124h] [rbp+1Ch]
  __int128 v74; // [rsp+138h] [rbp+30h]
  __int64 v75; // [rsp+148h] [rbp+40h]
  unsigned int v76; // [rsp+15Ch] [rbp+54h]
  unsigned int v77; // [rsp+160h] [rbp+58h]
  int v78; // [rsp+164h] [rbp+5Ch]
  __int64 v79; // [rsp+168h] [rbp+60h] BYREF
  float v80; // [rsp+170h] [rbp+68h]
  int v81; // [rsp+174h] [rbp+6Ch]
  int n8; // [rsp+178h] [rbp+70h] BYREF
  double v83; // [rsp+180h] [rbp+78h]
  __int128 v85; // [rsp+198h] [rbp+90h]
  __int128 v86; // [rsp+1A8h] [rbp+A0h]
  __int128 v87; // [rsp+1B8h] [rbp+B0h]
  __int128 v88; // [rsp+1C8h] [rbp+C0h]
  __int128 v89; // [rsp+1D8h] [rbp+D0h]
  __int128 v90; // [rsp+1E8h] [rbp+E0h]
  float v91; // [rsp+1F8h] [rbp+F0h]
  float v92; // [rsp+1FCh] [rbp+F4h]
  float v93; // [rsp+200h] [rbp+F8h]
  int v94; // [rsp+204h] [rbp+FCh]
  __int128 v95; // [rsp+208h] [rbp+100h]
  int v96; // [rsp+218h] [rbp+110h]
  float v97; // [rsp+21Ch] [rbp+114h]
  unsigned int v98; // [rsp+220h] [rbp+118h]
  unsigned int v99; // [rsp+224h] [rbp+11Ch]
  int n8_1; // [rsp+228h] [rbp+120h] BYREF
  double v101; // [rsp+230h] [rbp+128h]
  __int128 v103; // [rsp+248h] [rbp+140h]
  __int128 v104; // [rsp+258h] [rbp+150h]
  __int128 v105; // [rsp+268h] [rbp+160h]
  __int128 v106; // [rsp+278h] [rbp+170h]
  __int128 v107; // [rsp+288h] [rbp+180h]
  __int128 v108; // [rsp+298h] [rbp+190h]
  float v109; // [rsp+2A8h] [rbp+1A0h]
  float v110; // [rsp+2ACh] [rbp+1A4h]
  float v111; // [rsp+2B0h] [rbp+1A8h]
  int v112; // [rsp+2B4h] [rbp+1ACh]
  __int128 v113; // [rsp+2B8h] [rbp+1B0h]
  int v114; // [rsp+2C8h] [rbp+1C0h]
  float v115; // [rsp+2CCh] [rbp+1C4h]
  unsigned int v116; // [rsp+2D0h] [rbp+1C8h]
  unsigned int v117; // [rsp+2D4h] [rbp+1CCh]
  _BYTE v118[32]; // [rsp+2D8h] [rbp+1D0h] BYREF
  __int128 v119; // [rsp+2F8h] [rbp+1F0h]
  __int64 v120; // [rsp+308h] [rbp+200h]
  char v121[24]; // [rsp+318h] [rbp+210h] BYREF
  char v122[24]; // [rsp+330h] [rbp+228h] BYREF
  float v123[8]; // [rsp+348h] [rbp+240h] BYREF
  char v124[32]; // [rsp+368h] [rbp+260h] BYREF
  char v125[32]; // [rsp+388h] [rbp+280h] BYREF

  v2 = a1 + 0x290;
  v60 = a2;
  v56 = a1;
  v5 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(v2 + 0x10) == v5 )
  {
    ++*(_DWORD *)(v2 + 0x14);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 1, 0);
    if ( v6 )
      sub_1403C33A0(v2, v6, "CBullet::OnCollisionLogged", 1);
    else
      *(_QWORD *)(v2 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    *(_DWORD *)(v2 + 0x10) = v5;
  }
  n0x4600 = 0x4600;
  v65 = 1;
  v66 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v67 = __rdtsc();
  qword_149B4B870(
    &n0x4600,
    &word_149E38D64,
    "CBullet::OnCollisionLogged",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Bullet.cpp",
    0xB9);
  HIWORD(n0x4600) = word_149E38D64;
  if ( (*(_DWORD *)(a1 + 0x188) & 0x10) == 0 && a2 )
  {
    sub_143FFEA60(a1 - 0x78, 8);
    sub_14400A130(a1 - 0x78, v123, a2 + 0x48);
    gEnv = ::gEnv;
    v8 = *(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)::gEnv + 0x120LL);
    v9 = (_QWORD *)sub_1402E07B0(a1 + 0x60);
    v8(gEnv, &v63, *v9);
    (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)::gEnv + 0x120LL))(
      ::gEnv,
      &v62,
      *(_QWORD *)(a1 + 0x170));
    (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)::gEnv + 0x120LL))(
      ::gEnv,
      &v61,
      *(_QWORD *)(a1 + 0x178));
    (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)::gEnv + 0x120LL))(
      ::gEnv,
      &v58,
      *(_QWORD *)(a1 + 0x180));
    v10 = *((_DWORD *)Mtx_getconcrtcs((_Mtx_t)(a1 + 0xD0)) + 0xC);
    concrtcs = Mtx_getconcrtcs((_Mtx_t)(a1 + 0xD0));
    v12 = *(_QWORD *)(a1 - 0x70);
    v13 = *(_BYTE *)(a1 + 0x188) & 1;
    v14 = concrtcs[0x66];
    v15 = v61;
    v16 = v62;
    v17 = v63;
    v18 = sub_142705140(v56 + 0x38);
    v19 = v17;
    v20 = v60;
    v59 = v56 + 0x1A0;
    _R8_ = sub_145D216C0(
             v60,
             v123,
             v18,
             v19,
             v16,
             v15,
             v12,
             (double *)(v56 + 0x1A0),
             v13,
             v14,
             v10,
             (_QWORD *)(v56 + 0x2A8),
             v56 + 0x30C,
             &v58);
    v21 = v56;
    if ( sub_14030EC00(&v58) )
      *(_QWORD *)(v56 + 0x180) = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)(v58 & 0xFFFFFFFFFFFFLL) + 8LL))(
                                              v58 & 0xFFFFFFFFFFFFLL,
                                              &v60);
    v22 = (float *)sub_140380200((__int64)v124, v21 + 0x2C0, (__int64)&_R8_);
    sub_140384920((float *)(v21 + 0x2E0), v22);
    sub_14039B330((float *)(v21 + 0x2E0), (unsigned int *)(v21 + 0x2C0));
    v23 = *((_BYTE *)Mtx_getconcrtcs((_Mtx_t)(v21 + 0xD0)) + 0x63);
    v24 = sub_142705140(v21 + 0x38);
    v25 = sub_145D21330(v24, v23);
    v26 = (_QWORD *)(v21 - 0x70);
    v27 = sub_14037FC70(v25 + 0x38);
    if ( sub_14030EC00((unsigned __int64 *)(v21 - 0x70)) )
      v28 = *v26 & 0xFFFFFFFFFFFFLL;
    else
      v28 = 0;
    v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x20LL))(v28);
    sub_145D3E0C0(v20, v29, (__int64)v27);
    _XMM0 = 0;
    v94 = 0;
    __asm { vmovupd [rbp+300h+var_280], xmm0 }
    v85 = 0;
    v86 = 0;
    v87 = 0;
    v88 = 0;
    v89 = 0;
    v90 = 0;
    v95 = 0;
    v83 = 0.0;
    v91 = 0.0;
    v92 = 0.0;
    v93 = 0.0;
    v97 = 0.0;
    v96 = 0;
    v98 = 0x80000000;
    v99 = 0x80000000;
    n8 = 8;
    v31 = sub_144023AB0(v21 - 0x78);
    sub_145D31FB0(v21 - 0x78, v20);
    if ( !*(_BYTE *)(sub_142CBE270(*(_QWORD *)(v21 + 0x58)) + 0x44) )
    {
      if ( v31 )
      {
        sub_1440066E0(v21 - 0x78, v20 + 0x48);
      }
      else
      {
        if ( sub_14030EC00((unsigned __int64 *)(v21 - 0x70)) )
          v33 = *v26 & 0xFFFFFFFFFFFFLL;
        else
          v33 = 0;
        v34 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v33 + 0x3B8LL))(v33, &v56);
        if ( (*(unsigned int (__fastcall **)(__int64, int *))(*(_QWORD *)(*v34 & 0xFFFFFFFFFFFFLL) + 0x28LL))(
               *v34 & 0xFFFFFFFFFFFFLL,
               &n8)
          && (float)((float)((float)(*(float *)&v85 * *(float *)&v85)
                           + (float)(*((float *)&v85 + 1) * *((float *)&v85 + 1)))
                   + (float)(*((float *)&v85 + 2) * *((float *)&v85 + 2))) <= 0.1 )
        {
          sub_143FFEA60(v21 - 0x78, 0x20);
        }
      }
    }
    if ( (*(_BYTE *)(v21 + 0x188) & 0x34) == 0
      && (sub_14030EC00((unsigned __int64 *)(v21 - 0x70))
        ? (v32 = *(_QWORD *)(v21 - 0x70) & 0xFFFFFFFFFFFFLL)
        : (v32 = 0),
          v35 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)v32 + 0x2C8LL))(v32, v121, 0),
          v36 = (float *)sub_14400A130(v21 - 0x78, v125, v35),
          sub_1403BA280(v36))
      || *(_BYTE *)(sub_142CBE270(*(_QWORD *)(v21 + 0x58)) + 0x44) )
    {
      if ( *(_QWORD *)(v21 + 0x198) )
      {
        v71 = 1;
        v72 = 0xFFFFFFFFFFFFFFFFuLL;
        v80 = 0.0;
        v73 = 0;
        v78 = 0;
        v81 = 0;
        sub_140337D80((__int64)&v55, &v79);
        _XMM0 = 0;
        v38 = *(_QWORD *)(v21 + 0x190) & 0xFFFFFFFFFFFFLL;
        DWORD1(v74) = 0xFFF7FFFF;
        v101 = 0.0;
        v109 = 0.0;
        v110 = 0.0;
        v111 = 0.0;
        v115 = 0.0;
        v76 = 0xFFBFFFFF;
        v77 = 0xFFBFFFFF;
        __asm { vmovupd [rbp+300h+var_1D0], xmm0 }
        v103 = 0;
        v104 = 0;
        v105 = 0;
        v106 = 0;
        v107 = 0;
        v108 = 0;
        v112 = 0;
        v113 = 0;
        v114 = 0;
        v116 = 0x80000000;
        v117 = 0x80000000;
        n8_1 = 8;
        if ( (*(unsigned int (__fastcall **)(__int64, int *))(*(_QWORD *)v38 + 0x28LL))(v38, &n8_1)
          && (*(unsigned int (__fastcall **)(__int64, int *))(*(_QWORD *)(*(_QWORD *)(v21 + 0x190) & 0xFFFFFFFFFFFFLL)
                                                            + 0x28LL))(
               *(_QWORD *)(v21 + 0x190) & 0xFFFFFFFFFFFFLL,
               &v71) )
        {
          (*(void (__fastcall **)(__int64, _BYTE *, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x2F8LL))(
            qword_149B4FBE8,
            v118,
            *(_QWORD *)(v21 + 0x198) + 0x10LL,
            2);
          v39 = *(_QWORD *)(v21 + 0x198);
          v119 = v74;
          v120 = v75;
          v40 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x60LL))(
                  qword_149B4FBE8,
                  v39 + 0x10);
          v41 = *(_QWORD *)(v21 + 0x198);
          v42 = *(void (__fastcall **)(__int64, _BYTE *, __int64, bool))(*(_QWORD *)v41 + 0x1E8LL);
          v43 = *(float *)&v103 != 0.0 || *((float *)&v103 + 1) != 0.0 || *((float *)&v103 + 2) != 0.0;
          v44 = (*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)v40 + 0xF8LL))(v40, v122, v59);
          v42(v41, v118, v44, v43);
        }
        else
        {
          if ( sub_14030EC00((unsigned __int64 *)(v21 - 0x70)) )
            v45 = *v26 & 0xFFFFFFFFFFFFLL;
          else
            v45 = 0;
          v46 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 0x20LL))(v45);
          v47 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v46 + 0x18LL))(v46);
          v48 = (unsigned __int64 *)(v21 - 0x70);
          v49 = (const char *)v47;
          if ( sub_14030EC00(v48) )
            v50 = *v26 & 0xFFFFFFFFFFFFLL;
          else
            v50 = 0;
          v51 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v50 + 0x70LL))(v50);
          LogTraceConditional("CBullet::Update couldn't get physics status for '%s-%s'!", v51, v49);
        }
      }
    }
    *(_QWORD *)v123 = &off_1481A0DB8;
  }
  v68 = __rdtsc();
  qword_149B4B878(&n0x4600);
  v52 = *(_DWORD *)(v2 + 0x14);
  if ( v52 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v52 - 1);
    *(_DWORD *)(v2 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
    v54 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 0, 1);
    if ( v54 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v2 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v2, v54);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1440136F0 (0x1440136F0) ---

// --- Function: sub_144023AB0 (0x144023AB0) ---
bool __fastcall sub_144023AB0(__int64 a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  float *v4; // rax
  _BYTE v6[24]; // [rsp+28h] [rbp-50h] BYREF
  _BYTE v7[32]; // [rsp+40h] [rbp-38h] BYREF

  v2 = 0;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v2 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  v3 = (*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v2 + 0x2C8LL))(v2, v6, 0);
  v4 = (float *)sub_14400A130(a1, (__int64)v7, v3);
  return sub_140380680(v4, 0.0) && !*(_BYTE *)(sub_142CBE270(*(_QWORD *)(a1 + 0xD0)) + 0x44);
}

// --- End Function: sub_144023AB0 (0x144023AB0) ---

// --- Function: sub_1442E10A0 (0x1442E10A0) ---
__int64 __fastcall sub_1442E10A0(__int64 a1)
{
  return sub_14277D6A0((_QWORD *)(a1 + 0xE8));
}

// --- End Function: sub_1442E10A0 (0x1442E10A0) ---

// --- Function: sub_14444F060 (0x14444F060) ---
_WORD *__fastcall sub_14444F060(_WORD *a1)
{
  unsigned __int16 *v1; // rax
  _BYTE v3[8]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v4; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, const char *); // [rsp+30h] [rbp-18h]

  if ( n0xFFFF_81 == (__int16)0xFFFF )
  {
    v4 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA8);
    v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)v4 + 0x10LL);
    v1 = (unsigned __int16 *)v5(v4, v3, "EntityComponentHoloField");
    n0xFFFF_81 = sub_14030ECE0(v1);
  }
  sub_1403235B0(a1, n0xFFFF_81);
  return a1;
}

// --- End Function: sub_14444F060 (0x14444F060) ---

// --- Function: sub_144462BB0 (0x144462BB0) ---
void __fastcall sub_144462BB0(__int64 a1, __int64 a2)
{
  __int64 v3; // r9
  __int128 v4; // kr00_16
  __int64 v6; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned int i; // [rsp+40h] [rbp-3F8h]
  double *v17; // [rsp+48h] [rbp-3F0h]
  double v18; // [rsp+50h] [rbp-3E8h]
  __int64 dst; // [rsp+58h] [rbp-3E0h]
  double v20; // [rsp+70h] [rbp-3C8h]
  double v21; // [rsp+78h] [rbp-3C0h]
  double v22; // [rsp+80h] [rbp-3B8h]
  double v23; // [rsp+88h] [rbp-3B0h]
  double v24; // [rsp+90h] [rbp-3A8h]
  double v25; // [rsp+98h] [rbp-3A0h]
  double v26; // [rsp+A0h] [rbp-398h]
  double v27; // [rsp+A8h] [rbp-390h]
  double v28; // [rsp+B0h] [rbp-388h]
  double v29; // [rsp+B8h] [rbp-380h]
  double v30; // [rsp+C0h] [rbp-378h]
  double v31; // [rsp+C8h] [rbp-370h]
  double v32; // [rsp+D0h] [rbp-368h]
  double v33; // [rsp+D8h] [rbp-360h]
  double v34; // [rsp+E0h] [rbp-358h]
  double v35; // [rsp+F8h] [rbp-340h]
  double v36; // [rsp+100h] [rbp-338h]
  double v37; // [rsp+118h] [rbp-320h]
  double v38; // [rsp+120h] [rbp-318h]
  float v39; // [rsp+134h] [rbp-304h]
  float v40; // [rsp+13Ch] [rbp-2FCh]
  __int64 v41; // [rsp+140h] [rbp-2F8h] BYREF
  __int64 v42; // [rsp+148h] [rbp-2F0h] BYREF
  float v43; // [rsp+150h] [rbp-2E8h]
  float v44; // [rsp+154h] [rbp-2E4h]
  int v45; // [rsp+158h] [rbp-2E0h]
  float *v46; // [rsp+160h] [rbp-2D8h]
  __int64 v47; // [rsp+168h] [rbp-2D0h]
  __int64 v48; // [rsp+170h] [rbp-2C8h]
  __int64 v49; // [rsp+178h] [rbp-2C0h]
  __int64 v50; // [rsp+180h] [rbp-2B8h]
  void *v51; // [rsp+188h] [rbp-2B0h] BYREF
  __int64 v52; // [rsp+190h] [rbp-2A8h]
  unsigned __int64 v53; // [rsp+198h] [rbp-2A0h]
  float *v54; // [rsp+1A0h] [rbp-298h]
  float *v55; // [rsp+1A8h] [rbp-290h]
  unsigned __int64 v56; // [rsp+1B0h] [rbp-288h]
  float *v57; // [rsp+1B8h] [rbp-280h]
  float *v58; // [rsp+1C0h] [rbp-278h]
  double v59; // [rsp+1C8h] [rbp-270h]
  double v60; // [rsp+1D0h] [rbp-268h]
  double v61; // [rsp+1D8h] [rbp-260h]
  __int64 v62; // [rsp+1E0h] [rbp-258h]
  float src_[3]; // [rsp+1E8h] [rbp-250h] BYREF
  float src__1[3]; // [rsp+1F4h] [rbp-244h] BYREF
  float src__2[3]; // [rsp+200h] [rbp-238h] BYREF
  __int64 v66; // [rsp+210h] [rbp-228h]
  __int64 v67; // [rsp+218h] [rbp-220h]
  void (__fastcall *v68)(__int64, __int64 *, __int64, __int64, unsigned __int64, __int64 *, __int16, _QWORD); // [rsp+220h] [rbp-218h]
  __int64 v69; // [rsp+228h] [rbp-210h] BYREF
  __int64 v70; // [rsp+230h] [rbp-208h]
  __int64 v71; // [rsp+238h] [rbp-200h] BYREF
  __int64 v72; // [rsp+240h] [rbp-1F8h] BYREF
  double v73; // [rsp+248h] [rbp-1F0h]
  double v74; // [rsp+250h] [rbp-1E8h]
  double v75; // [rsp+258h] [rbp-1E0h]
  __int64 v76; // [rsp+260h] [rbp-1D8h]
  __int64 v77; // [rsp+268h] [rbp-1D0h]
  double v78; // [rsp+270h] [rbp-1C8h]
  __int64 v79; // [rsp+278h] [rbp-1C0h]
  __int64 v80; // [rsp+280h] [rbp-1B8h]
  __int64 (__fastcall *v81)(unsigned __int64, _BYTE *, _QWORD); // [rsp+288h] [rbp-1B0h]
  __int64 v82; // [rsp+290h] [rbp-1A8h]
  __int64 v83; // [rsp+298h] [rbp-1A0h]
  __int64 (__fastcall *v84)(__int64, _QWORD); // [rsp+2A0h] [rbp-198h]
  float v85; // [rsp+2A8h] [rbp-190h]
  __int64 (__fastcall *v86)(__int64, _QWORD); // [rsp+2B0h] [rbp-188h]
  void (__fastcall *v87)(__int64, __int64 *, _BYTE *, __int64); // [rsp+2B8h] [rbp-180h]
  __int64 v88; // [rsp+2C0h] [rbp-178h]
  double v89; // [rsp+2C8h] [rbp-170h]
  double v90; // [rsp+2D0h] [rbp-168h]
  double v91; // [rsp+2D8h] [rbp-160h]
  double v92; // [rsp+2E0h] [rbp-158h]
  double v93; // [rsp+2E8h] [rbp-150h]
  double v94; // [rsp+2F0h] [rbp-148h]
  __int64 v95; // [rsp+2F8h] [rbp-140h]
  unsigned __int64 v96; // [rsp+300h] [rbp-138h]
  _BYTE v97[64]; // [rsp+310h] [rbp-128h] BYREF
  _BYTE v98[96]; // [rsp+350h] [rbp-E8h] BYREF
  _BYTE v99[16]; // [rsp+3B0h] [rbp-88h] BYREF
  __int64 v100; // [rsp+3C0h] [rbp-78h] BYREF
  __int64 v101; // [rsp+3C8h] [rbp-70h] BYREF
  _QWORD v102[4]; // [rsp+3D0h] [rbp-68h] BYREF
  _QWORD v103[4]; // [rsp+3F0h] [rbp-48h] BYREF

  if ( *(_BYTE *)(a1 + 0x505) )
  {
    v50 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
    v86 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v50 + 0x38LL);
    v69 = *(_QWORD *)v86(v50, 0);
    CreateStringObjectFromString(&v51, off_149A266C0);// "DFM_FX.HoloField.Impact"
    sub_14036C130((__int64)v99, (const void **)&v51);
    sub_140370D10(&v51);
    v52 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x50);
    v87 = *(void (__fastcall **)(__int64, __int64 *, _BYTE *, __int64))(*(_QWORD *)v52 + 0x48LL);
    LOBYTE(v3) = 1;
    v87(v52, &v41, v99, v3);
    v88 = v41;
    if ( v41 )
    {
      v47 = v41;
      v68 = *(void (__fastcall **)(__int64, __int64 *, __int64, __int64, unsigned __int64, __int64 *, __int16, _QWORD))(*(_QWORD *)v41 + 8LL);
      v96 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
      v53 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
      v66 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v53 + 0x648LL))(v53);
      v95 = sub_1403335B0(a1);
      v67 = sub_1412A4810((__int64)v97, a2 + 0x90, (float *)(a2 + 0xB4), *(float *)(v95 + 0x68));
      v68(v47, &v42, v67, v66, v96, &v101, 1, 0);
      if ( v42 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)(v42 + 0x30) + 0x10LL))(v42 + 0x30);
      v42 = 0;
    }
    for ( i = 0; ; ++i )
    {
      if ( i >= *(_DWORD *)(a1 + 0x500) )
      {
        if ( *(_DWORD *)(a1 + 0x500) >= 0x10u )
        {
          sub_1403715C0(&v41);
          sub_140370D10(&v101);
          sub_140370D10(&v100);
        }
        else
        {
          v45 = (*(_DWORD *)(a1 + 0x500))++;
          dst = a1 + 0x48LL * v45 + 0x80;
          v56 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
          v81 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, _QWORD))(*(_QWORD *)v56 + 0x260LL);
          v17 = (double *)v81(v56, v98, 0);
          v20 = *v17;
          v21 = v17[1];
          v22 = v17[2];
          v23 = v17[3];
          v24 = v17[4];
          v25 = v17[5];
          v26 = v17[6];
          v27 = v17[7];
          v28 = v17[8];
          v29 = v17[9];
          v30 = v17[0xA];
          v31 = v17[0xB];
          v32 = v30 * v25 - v26 * v29;
          v33 = v22 * v29 - v30 * v21;
          v34 = v26 * v21 - v22 * v25;
          v18 = 1.0 / (*v17 * v32 + v24 * v33 + v28 * v34);
          v35 = (v30 * *v17 - v22 * v28) * v18;
          v36 = (v22 * v24 - v26 * *v17) * v18;
          v37 = (v28 * v21 - *v17 * v29) * v18;
          v38 = (*v17 * v25 - v24 * v21) * v18;
          v92 = v32 * v18 * *(double *)(a2 + 0x90)
              + v33 * v18 * *(double *)(a2 + 0x98)
              + v34 * v18 * *(double *)(a2 + 0xA0)
              + (v30 * v27 * v21
               + v22 * v31 * v25
               + v26 * v23 * v29
               - (v26 * v31 * v21
                + v30 * v23 * v25
                + v22 * v27 * v29))
              * v18;
          v93 = (v26 * v28 - v30 * v24) * v18 * *(double *)(a2 + 0x90)
              + v35 * *(double *)(a2 + 0x98)
              + v36 * *(double *)(a2 + 0xA0)
              + (v26 * v31 * v20
               + v30 * v23 * v24
               + v22 * v27 * v28
               - (v30 * v27 * v20
                + v22 * v31 * v24
                + v26 * v23 * v28))
              * v18;
          _XMM0 = COERCE_UNSIGNED_INT64(
                    (v24 * v29 - v28 * v25) * v18 * *(double *)(a2 + 0x90)
                  + v37 * *(double *)(a2 + 0x98)
                  + v38 * *(double *)(a2 + 0xA0)
                  + (v28 * v25 * v23
                   + v20 * v29 * v27
                   + v24 * v21 * v31
                   - (v24 * v29 * v23
                    + v28 * v21 * v27
                    + v20 * v25 * v31))
                  * v18);
          v94 = (v24 * v29 - v28 * v25) * v18 * *(double *)(a2 + 0x90)
              + v37 * *(double *)(a2 + 0x98)
              + v38 * *(double *)(a2 + 0xA0)
              + (v28 * v25 * v23
               + v20 * v29 * v27
               + v24 * v21 * v31
               - (v24 * v29 * v23
                + v28 * v21 * v27
                + v20 * v25 * v31))
              * v18;
          __asm { vcvtsd2ss xmm0, xmm0, [rsp+438h+var_158] }
          src_[0] = *(float *)&_XMM0;
          __asm { vcvtsd2ss xmm0, xmm0, [rsp+438h+var_150] }
          src_[1] = *(float *)&_XMM0;
          __asm { vcvtsd2ss xmm0, xmm0, [rsp+438h+var_148] }
          src_[2] = *(float *)&_XMM0;
          qmemcpy((void *)dst, src_, 0xCu);
          v48 = a2 + 0x90;
          __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax] }
          src__1[0] = *(float *)&_XMM0;
          __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+8] }
          src__1[1] = *(float *)&_XMM0;
          __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+10h] }
          src__1[2] = *(float *)&_XMM0;
          qmemcpy((void *)(dst + 0xC), src__1, 0xCu);
          v82 = sub_1403335B0(a1);
          v14 = sub_140380200((__int64)v103, a2 + 0x38, v82 + 0x60);
          *(float *)(dst + 0x18) = sub_1403B7840(v14).m128_f32[0];
          sub_1402B4590(v103);
          v15 = sub_1403335B0(a1);
          v83 = v15;
          v57 = (float *)(v15 + 0x64);
          v58 = (float *)(dst + 0x18);
          if ( *(float *)(dst + 0x18) <= *(float *)(v15 + 0x64) )
            v40 = *v58;
          else
            v40 = *v57;
          *(float *)(dst + 0x18) = v40;
          *(_DWORD *)(dst + 0x40) = 0;
          src__2[0] = 1.0;
          src__2[1] = 1.0;
          src__2[2] = 1.0;
          qmemcpy((void *)(dst + 0x34), src__2, 0xCu);
          v62 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x60);
          v84 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v62 + 0x38LL);
          *(_QWORD *)(dst + 0x28) = *(_QWORD *)v84(v62, 0);
          *(float *)(dst + 0x30) = *(float *)(sub_1403335B0(a1) + 0x54);
          *(float *)(dst + 0x1C) = *(float *)(sub_1403335B0(a1) + 0x50);
          *(float *)(dst + 0x20) = 0x3F800000;
          *(_BYTE *)(a1 + 0x504) = 1;
          sub_1403715C0(&v41);
          sub_140370D10(&v101);
          sub_140370D10(&v100);
        }
        return;
      }
      sub_1405975C0(&v69, &v72, (_QWORD *)(a1 + 0x48LL * (int)i + 0xA8));
      v70 = sub_1403335B0(a1);
      *((_QWORD *)&v4 + 1) = *((_QWORD *)&_XMM0 + 1);
      *(double *)&v4 = *(float *)(v70 + 0x58);
      _XMM0 = v4;
      __asm { vmovupd xmm1, xmm0 }
      sub_1402B1490(&v71, *(double *)&_XMM1);
      if ( sub_140597630(&v72, &v71) )
        break;
    }
    v46 = (float *)(a1 + 0x48LL * (int)i + 0x8C);
    v89 = *v46;
    v90 = *(float *)(a1 + 0x48LL * (int)i + 0x90);
    v91 = *(float *)(a1 + 0x48LL * (int)i + 0x94);
    v49 = a2 + 0x90;
    v75 = v91 - *(double *)(a2 + 0xA0);
    v74 = v90 - *(double *)(a2 + 0x98);
    v73 = v89 - *(double *)(a2 + 0x90);
    v59 = v73;
    v60 = v74;
    v61 = v75;
    v78 = v73 * v73 + v74 * v74 + v75 * v75;
    v76 = sub_1403335B0(a1);
    v77 = sub_1403335B0(a1);
    v85 = (float)(v78 < (float)(*(float *)(v76 + 0x5C) * *(float *)(v77 + 0x5C)));
    v79 = sub_1403335B0(a1);
    v6 = sub_140380200((__int64)v102, a2 + 0x38, v79 + 0x60);
    v44 = sub_1403B7840(v6).m128_f32[0];
    v43 = *(float *)(a1 + 0x48LL * (int)i + 0x98);
    *(float *)(a1 + 0x48LL * (int)i + 0x98) = v43 + v44;
    sub_1402B4590(v102);
    v80 = sub_1403335B0(a1);
    v54 = (float *)(v80 + 0x64);
    v55 = (float *)(a1 + 0x48LL * (int)i + 0x98);
    if ( *v55 <= *(float *)(v80 + 0x64) )
      v39 = *v55;
    else
      v39 = *v54;
    *(float *)(a1 + 0x48LL * (int)i + 0x98) = v39;
    sub_1403715C0(&v41);
    sub_140370D10(&v101);
    sub_140370D10(&v100);
  }
}

// --- End Function: sub_144462BB0 (0x144462BB0) ---

// --- Function: sub_1448F74B0 (0x1448F74B0) ---
__int64 __fastcall sub_1448F74B0(__crt_strtox *a1, __int64 a2, unsigned __int8 **a3)
{
  unsigned __int64 v3; // rdx
  _WORD v5[7]; // [rsp+32h] [rbp-D6h] BYREF
  __int64 v6; // [rsp+40h] [rbp-C8h]
  __crt_strtox *v7; // [rsp+48h] [rbp-C0h]
  __int64 v8; // [rsp+50h] [rbp-B8h]
  __crt_strtox *v9; // [rsp+58h] [rbp-B0h]
  __int64 v10; // [rsp+60h] [rbp-A8h]
  _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *v11; // [rsp+68h] [rbp-A0h]
  __int64 v12; // [rsp+70h] [rbp-98h]
  __crt_strtox *v13; // [rsp+78h] [rbp-90h]
  __int64 v14; // [rsp+80h] [rbp-88h]
  __int64 v15; // [rsp+88h] [rbp-80h]
  __int64 v16; // [rsp+90h] [rbp-78h]
  __int64 v17; // [rsp+98h] [rbp-70h]
  __int64 inserted; // [rsp+A0h] [rbp-68h]
  __int64 *src_[2]; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v20; // [rsp+B8h] [rbp-50h]
  _BYTE v21[8]; // [rsp+C0h] [rbp-48h] BYREF
  _BYTE v22[24]; // [rsp+C8h] [rbp-40h] BYREF
  _BYTE dst_[40]; // [rsp+E0h] [rbp-28h] BYREF

  sub_142BA10D0((__int64)a1, src_, a3);
  *(_QWORD *)&v5[3] = v20;
  *(_DWORD *)&v5[1] = !*(_BYTE *)(v20 + 0x19)
                   && (v9 = a1,
                       v8 = *(_QWORD *)&v5[3] + 0x20LL,
                       !(unsigned __int8)sub_140383560((__int64)a1, a3, (_QWORD *)(*(_QWORD *)&v5[3] + 0x20LL)));
  if ( LOBYTE(v5[1]) )
  {
    *(_QWORD *)a2 = v20;
    *(_BYTE *)(a2 + 8) = 0;
  }
  else
  {
    sub_142C05A30(a1, v3);
    v7 = a1;
    v10 = sub_1402A24F0((__int64)v5);
    v11 = _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
            (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v21,
            (const struct __crt_stdio_stream *)a3);
    v12 = *(_QWORD *)v7;
    v13 = a1;
    v14 = sub_1448EAFB0((__int64)v22, (__int64)a1, v12, &byte_14819E9C1, v11, v10);
    v15 = 0;
    v6 = v14 + 8;
    v16 = *(_QWORD *)(v14 + 8);
    *(_QWORD *)(v14 + 8) = 0;
    v17 = v16;
    sub_1448FE060((__int64)v22);
    qmemcpy(dst_, src_, 0x10u);
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>::_Insert_node(
                 v7,
                 dst_,
                 v17);
    *(_QWORD *)a2 = inserted;
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}

// --- End Function: sub_1448F74B0 (0x1448F74B0) ---

// --- Function: sub_14490F860 (0x14490F860) ---
__int64 sub_14490F860()
{
  __int64 v0; // rax

  v0 = sub_1402A24F0((__int64)&qword_149B4FBE0);
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v0 + 0x98) + 0x250LL))(*(_QWORD *)(v0 + 0x98));
}

// --- End Function: sub_14490F860 (0x14490F860) ---

// --- Function: sub_144911680 (0x144911680) ---
const char *__fastcall sub_144911680(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  unsigned __int64 *v3; // rax
  _BYTE v5[16]; // [rsp+38h] [rbp-10h] BYREF

  v2 = sub_1402A24F0((__int64)&qword_149B4FBE0);
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(_QWORD, _BYTE *, _QWORD))(**(_QWORD **)(v2 + 0xA0) + 0x120LL))(
                             *(_QWORD *)(v2 + 0xA0),
                             v5,
                             *a2);
  return sub_144911610(a1, *v3);
}

// --- End Function: sub_144911680 (0x144911680) ---

// --- Function: sub_1449461C0 (0x1449461C0) ---
__int64 __fastcall sub_1449461C0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  float v3; // [rsp+24h] [rbp-14h]

  v3 = sub_1403B7840(a2 + 0x38).m128_f32[0];
  result = a1;
  *(float *)(a1 + 0xA0) = *(float *)(a1 + 0xA0) + v3;
  return result;
}

// --- End Function: sub_1449461C0 (0x1449461C0) ---

// --- Function: sub_1449473E0 (0x1449473E0) ---
const ULONG_PTR *__fastcall sub_1449473E0(__int64 a1, __int64 a2)
{
  const ULONG_PTR *result; // rax
  _QWORD *v3; // rax
  float v4; // [rsp+20h] [rbp-108h]
  float v5; // [rsp+24h] [rbp-104h]
  __int64 v6; // [rsp+28h] [rbp-100h]
  const char *v7; // [rsp+30h] [rbp-F8h]
  __int64 v8; // [rsp+40h] [rbp-E8h] BYREF
  float *v9; // [rsp+48h] [rbp-E0h]
  void *v10; // [rsp+50h] [rbp-D8h] BYREF
  __int64 v11; // [rsp+58h] [rbp-D0h]
  float *v12; // [rsp+60h] [rbp-C8h]
  void *v13; // [rsp+68h] [rbp-C0h] BYREF
  _QWORD *v14; // [rsp+70h] [rbp-B8h]
  void *v15; // [rsp+78h] [rbp-B0h] BYREF
  __int64 v16; // [rsp+80h] [rbp-A8h]
  __int64 *v17; // [rsp+88h] [rbp-A0h]
  __int64 v18; // [rsp+90h] [rbp-98h]
  __int64 v19; // [rsp+98h] [rbp-90h]
  __crt_strtox *v20; // [rsp+A0h] [rbp-88h]
  __crt_strtox *v21; // [rsp+A8h] [rbp-80h]
  __crt_strtox *v22; // [rsp+B0h] [rbp-78h]
  __crt_strtox *v23[4]; // [rsp+B8h] [rbp-70h] BYREF
  __int64 v24; // [rsp+D8h] [rbp-50h] BYREF
  __int64 v25; // [rsp+E8h] [rbp-40h] BYREF
  _BYTE v26[16]; // [rsp+F0h] [rbp-38h] BYREF
  _BYTE v27[16]; // [rsp+100h] [rbp-28h] BYREF
  _BYTE v28[24]; // [rsp+110h] [rbp-18h] BYREF

  result = (const ULONG_PTR *)sub_14030EC00((unsigned __int64 *)(a2 + 0x10));
  if ( (_BYTE)result )
  {
    sub_1431B0E90((__int64)v23, a1 + 0x250, a1 + 0x260);
    if ( sub_14030EC00((unsigned __int64 *)(a2 + 8)) )
    {
      v16 = sub_14030ECF0((_QWORD *)(a2 + 8));
      v17 = sub_14033B1A0(v16, &v24);
      v18 = *v17;
      v8 = v18;
      if ( AssetMeta::HasActorSubresource(&v8) )
        v6 = v8 & 0xFFFFFFFFFFFFLL;
      else
        v6 = 0;
    }
    else
    {
      v6 = 0;
    }
    v11 = v6;
    v19 = a2 + 0x10;
    v3 = sub_1403B0A70((unsigned __int64 *)(a2 + 0x10), &v25);
    v7 = sub_144911680(a1, v3);
    if ( v11 )
      LODWORD(v4) = sub_1403B7840(a2 + 0x38).m128_u32[0];
    else
      v4 = 0.0;
    CreateStringObjectFromString(&v10, v7);
    v20 = v23[0];
    v9 = (float *)(*(_QWORD *)sub_1448F74B0(v23[0], (__int64)v26, (unsigned __int8 **)&v10) + 0x28LL);
    *v9 = *v9 + v4;
    sub_140370D10(&v10);
    if ( v11 )
      v5 = 0.0;
    else
      LODWORD(v5) = sub_1403B7840(a2 + 0x38).m128_u32[0];
    CreateStringObjectFromString(&v13, v7);
    v21 = v23[0];
    v12 = (float *)(*(_QWORD *)sub_1448F74B0(v23[0], (__int64)v27, (unsigned __int8 **)&v13) + 0x2CLL);
    *v12 = *v12 + v5;
    sub_140370D10(&v13);
    CreateStringObjectFromString(&v15, v7);
    v22 = v23[0];
    v14 = (_QWORD *)(*(_QWORD *)sub_1448F74B0(v23[0], (__int64)v28, (unsigned __int8 **)&v15) + 0x38LL);
    ++*v14;
    sub_140370D10(&v15);
    ++*(_DWORD *)(a1 + 0xAC);
    return sub_142C32150((__int64)v23);
  }
  return result;
}

// --- End Function: sub_1449473E0 (0x1449473E0) ---

// --- Function: sub_144947720 (0x144947720) ---
__int64 __fastcall sub_144947720(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  float v3; // [rsp+24h] [rbp-14h]

  ++*(_DWORD *)(a1 + 0xA4);
  v3 = sub_1403B7840(a2 + 0x38).m128_f32[0];
  result = a1;
  *(float *)(a1 + 0x9C) = *(float *)(a1 + 0x9C) + v3;
  return result;
}

// --- End Function: sub_144947720 (0x144947720) ---

// --- Function: sub_1457239F0 (0x1457239F0) ---
__int64 __fastcall sub_1457239F0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_145D1AC10(a2, a3);
  return a2;
}

// --- End Function: sub_1457239F0 (0x1457239F0) ---

// --- Function: sub_145733E00 (0x145733E00) ---
bool __fastcall sub_145733E00(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

// --- End Function: sub_145733E00 (0x145733E00) ---

// --- Function: sub_1457346C0 (0x1457346C0) ---
bool __fastcall sub_1457346C0(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == 1;
}

// --- End Function: sub_1457346C0 (0x1457346C0) ---

// --- Function: sub_145C26F50 (0x145C26F50) ---
bool __fastcall sub_145C26F50(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  double v5; // xmm0_8
  float v6; // xmm7_4
  __int64 v7; // rdi
  void (__fastcall *v8)(__int64, _QWORD); // rbx
  char v14; // [rsp+60h] [rbp+18h] BYREF

  if ( !sub_1465D09B0(a1) )
    return 1;
  if ( sub_1464E7930(qword_149E7E438) && (v2 = sub_1464E7930(qword_149E7E438), sub_1464831B0(v2)) )
  {
    v3 = sub_1464E7930(qword_149E7E438);
    v4 = sub_1464831B0(v3);
    v5 = (*(double (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x6B8LL))(v4);
    v6 = *(float *)&v5;
  }
  else
  {
    v6 = 0.0;
  }
  v7 = qword_149B4FC40;
  v8 = *(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40 + 0x38LL);
  (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 0x638LL))(a1, &v14);
  _XMM0 = sub_140597760();
  __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
  v8(v7, 0);
  _XMM0 = sub_140597760();
  __asm { vcvtsd2ss xmm2, xmm0, xmm0 }
  return *(float *)&_XMM2 < (float)(*(float *)&_XMM6 + v6);
}

// --- End Function: sub_145C26F50 (0x145C26F50) ---

// --- Function: sub_145C7AAE0 (0x145C7AAE0) ---
_QWORD *__fastcall sub_145C7AAE0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rax
  __int64 v4; // [rsp+20h] [rbp-38h]
  _QWORD *v5; // [rsp+28h] [rbp-30h]
  _BYTE v6[8]; // [rsp+40h] [rbp-18h] BYREF
  __int64 v7; // [rsp+48h] [rbp-10h] BYREF

  v4 = sub_145C78B90(a1);
  if ( v4 )
  {
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v4 + 0xD8LL))(v4, v6);
  }
  else
  {
    sub_1402B1640(&v7);
    v5 = v2;
  }
  *a2 = *v5;
  return a2;
}

// --- End Function: sub_145C7AAE0 (0x145C7AAE0) ---

// --- Function: sub_145D00DD0 (0x145D00DD0) ---
__int64 __fastcall sub_145D00DD0(__int64 a1)
{
  __int64 v1; // rsi
  int *v2; // rbx
  int *v3; // rax
  int v4; // ebx
  int v5; // edi
  __int64 v7; // rdi
  unsigned __int8 (__fastcall *v8)(__int64, __int64, const char *); // rbx
  __int64 v9; // rax
  _BYTE v10[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v11; // [rsp+28h] [rbp-30h]
  _BYTE v12[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v13; // [rsp+40h] [rbp-18h]

  v1 = *(_QWORD *)(a1 + 0xE0);
  if ( !v1 )
    return 0;
  v2 = (int *)sub_142D013E0((__int64)v12);
  v3 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v1 + 0x18LL))(v1, v10);
  v4 = *v2;
  v5 = *v3;
  if ( v11 )
    sub_147605980(v11);
  if ( v13 )
    sub_147605980(v13);
  if ( v4 == v5 )
    return v1;
  if ( qword_149B4FCA0
    && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0)
    && (v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0),
        v8 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v7 + 0x100LL),
        v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 8LL))(v1),
        v8(v7, v9, "ProjectileParams")) )
  {
    return v1;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_145D00DD0 (0x145D00DD0) ---

// --- Function: sub_145D02D70 (0x145D02D70) ---
unsigned __int64 __fastcall sub_145D02D70(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5; // r15
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 allocSize; // r14
  unsigned __int64 allocSize_1; // rcx
  unsigned __int64 v13; // r14
  __int64 v14; // rax
  __int64 v15; // rsi
  unsigned __int64 v16; // r13
  __int64 v17; // rdx
  __int64 v18; // r8
  __int64 v19; // rcx
  _QWORD *v20; // rbx
  _QWORD *i; // rbp
  _QWORD *v22; // rcx
  unsigned __int64 result; // rax

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 6;
  if ( v5 == 0x3FFFFFFFFFFFFFFLL )
    unknown_libname_67();
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 6;
  v10 = v9 >> 1;
  if ( v9 <= 0x3FFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    v13 = v8;
    if ( v10 + v9 >= v8 )
      v13 = v10 + v9;
    if ( v13 > 0x3FFFFFFFFFFFFFFLL )
      goto LABEL_25;
    allocSize = v13 << 6;
    if ( allocSize < 0x1000 )
    {
      if ( allocSize )
        v15 = allocWithProfilerInfo_w(allocSize);
      else
        v15 = 0;
      goto LABEL_14;
    }
    allocSize_1 = allocSize + 0x27;
    if ( allocSize + 0x27 < allocSize )
LABEL_25:
      sub_1402E1170();
  }
  else
  {
    allocSize = 0xFFFFFFFFFFFFFFC0uLL;
    allocSize_1 = 0xFFFFFFFFFFFFFFE7uLL;
  }
  v14 = allocWithProfilerInfo_w(allocSize_1);
  if ( !v14 )
    goto LABEL_24;
  v15 = (v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v15 - 8) = v14;
LABEL_14:
  v16 = (v4 & 0xFFFFFFFFFFFFFFC0uLL) + v15;
  sub_145D05F60(a1, v16, a3);
  v17 = a1[1];
  v18 = v15;
  v19 = *a1;
  if ( a2 != v17 )
  {
    sub_143FF78C0(v19, a2, v15, (__int64)a1);
    v17 = a1[1];
    v18 = v16 + 0x40;
    v19 = a2;
  }
  sub_143FF78C0(v19, v17, v18, (__int64)a1);
  v20 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v20 != i; v20 += 8 )
      sub_143FFCC30(v20);
    v22 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFC0uLL) < 0x1000 )
      goto LABEL_22;
    if ( (unsigned __int64)v22 - v22[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v22 = (_QWORD *)v22[0xFFFFFFFF];
LABEL_22:
      sub_1402A3D30(v22);
      goto LABEL_23;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *a1 = v15;
  result = v16;
  a1[1] = v15 + (v8 << 6);
  a1[2] = allocSize + v15;
  return result;
}

// --- End Function: sub_145D02D70 (0x145D02D70) ---

// --- Function: sub_145D048F0 (0x145D048F0) ---
void __fastcall sub_145D048F0(
        unsigned int n5,
        __int64 *a2,
        char *p_Projectile_Hit_Discarded,
        char *p_$$:_Projectile_owned_by__$$__[$$]_discarded_due_to_being_consid,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 *ThreadLogContextSlot,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15)
{
  void *v19; // rsp
  __int64 v20; // [rsp+18h] [rbp-328h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-310h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-2B8h]
  __int64 n0xB0; // [rsp+90h] [rbp-2B0h]
  __int64 n0xA8; // [rsp+98h] [rbp-2A8h]
  __int64 v25; // [rsp+A0h] [rbp-2A0h] BYREF

  v19 = alloca(0x310);
  __Val_0___[0] = ThreadLogContextSlot;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_145D051D0((unsigned int)&v25, a10, a11, a12, a13, a14, a15);
  LODWORD(v20) = a6;
  sub_1403045C0(
    n5,
    a2,
    p_Projectile_Hit_Discarded,
    p_$$:_Projectile_owned_by__$$__[$$]_discarded_due_to_being_consid,
    (vraudio::AudioBuffer *)__Val_0___,
    7u,
    a5,
    v20,
    a7,
    a8);
}

// --- End Function: sub_145D048F0 (0x145D048F0) ---

// --- Function: sub_145D051D0 (0x145D051D0) ---
__int64 __fastcall sub_145D051D0(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  const char *p_null; // r8
  const char *p_null_2; // rax
  const char *p_null_1; // rdx
  unsigned __int64 v11; // rax
  const char *p_null_3; // rdx
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rax
  __int64 n6; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Function";
  *(_BYTE *)(a1 + 0x59) = 1;
  p_null = "null";
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_2 = (const char *)a2[1];
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v11;
  while ( p_null_1[v11] );
  *(_QWORD *)(a1 + 0x68) = v11;
  *(_QWORD *)(a1 + 0x78) = "Name";
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  p_null_3 = "null";
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  if ( a3[1] )
    p_null_3 = (const char *)a3[1];
  v13 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v13;
  while ( p_null_3[v13] );
  *(_QWORD *)(a1 + 0xD8) = v13;
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_QWORD *)(a1 + 0xE8) = "EntityId";
  *(_BYTE *)(a1 + 0x139) = 1;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0x120) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0x128) = sub_1403E4C70;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x100) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x18;
  *(_QWORD *)(a1 + 0x148) = 0x17;
  *(_QWORD *)(a1 + 0x150) = a5;
  *(_QWORD *)(a1 + 0x158) = "Name";
  *(_BYTE *)(a1 + 0x1A9) = 0;
  *(_QWORD *)(a1 + 0x160) = *a5;
  *(_QWORD *)(a1 + 0x168) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x170) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x178) = 0;
  *(_QWORD *)(a1 + 0x180) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x188) = 0;
  *(_QWORD *)(a1 + 0x190) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x198) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x1A0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x1A8) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0x18;
  if ( a5[1] )
    p_null = (const char *)a5[1];
  v14 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v14;
  while ( p_null[v14] );
  *(_QWORD *)(a1 + 0x1B8) = v14;
  *(_QWORD *)(a1 + 0x1C0) = a6;
  *(_QWORD *)(a1 + 0x1C8) = "EntityId";
  *(_BYTE *)(a1 + 0x219) = 1;
  *(_QWORD *)(a1 + 0x1D0) = *a6;
  *(_QWORD *)(a1 + 0x200) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0x208) = sub_1403E4C70;
  *(_QWORD *)(a1 + 0x230) = a7;
  *(_QWORD *)(a1 + 0x1D8) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x1E0) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_QWORD *)(a1 + 0x1F0) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_QWORD *)(a1 + 0x210) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x218) = 0;
  *(_QWORD *)(a1 + 0x220) = 0x18;
  *(_QWORD *)(a1 + 0x228) = 0x17;
  *(_QWORD *)(a1 + 0x238) = "Count";
  *(_BYTE *)(a1 + 0x289) = 0;
  *(_QWORD *)(a1 + 0x240) = *a7;
  *(_QWORD *)(a1 + 0x248) = sub_1403EB110;
  *(_QWORD *)(a1 + 0x250) = sub_1403EB110;
  *(_QWORD *)(a1 + 0x260) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x270) = sub_1403E4E70;
  *(_QWORD *)(a1 + 0x278) = sub_1403E4B60;
  n6 = 6;
  *(_QWORD *)(a1 + 0x258) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x280) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x288) = 0;
  *(_QWORD *)(a1 + 0x290) = 0x10;
  *(_QWORD *)(a1 + 0x298) = 0x15;
  return n6;
}

// --- End Function: sub_145D051D0 (0x145D051D0) ---

// --- Function: sub_145D05F60 (0x145D05F60) ---
unsigned __int64 __fastcall sub_145D05F60(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // rsi
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx
  const void *v7; // rdx
  unsigned __int64 v8; // rdi
  signed __int64 Size; // rbx

  v3 = (unsigned __int64 *)(a2 + 0x28);
  *(_QWORD *)a2 = &off_1481B0218;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
  *(double *)(a2 + 0x18) = *(double *)(a3 + 0x18);
  *(_QWORD *)(a2 + 0x20) = *(_QWORD *)(a3 + 0x20);
  result = 0;
  *(_QWORD *)(a2 + 0x28) = 0;
  *(_QWORD *)(a2 + 0x30) = 0;
  *(_QWORD *)(a2 + 0x38) = 0;
  v6 = (__int64)(*(_QWORD *)(a3 + 0x30) - *(_QWORD *)(a3 + 0x28)) >> 2;
  if ( v6 )
  {
    sub_1402FAB90(v3, v6);
    v7 = *(const void **)(a3 + 0x28);
    v8 = *v3;
    Size = *(_QWORD *)(a3 + 0x30) - (_QWORD)v7;
    memmove((void *)*v3, v7, Size);
    result = v8 + 4 * (Size >> 2);
    v3[1] = result;
  }
  return result;
}

// --- End Function: sub_145D05F60 (0x145D05F60) ---

// --- Function: sub_145D0D920 (0x145D0D920) ---
__int64 __fastcall sub_145D0D920(__int64 a1, __int64 a2, __int64 a3, double *a4, double *a5)
{
  _QWORD *v6; // rbp
  double v7; // xmm3_8
  double v8; // xmm4_8
  __int128 v10; // xmm0
  __int64 *v15; // rbx
  __int64 v16; // rax
  unsigned int *v17; // rax
  float *v18; // rbx
  __int64 *v19; // rax
  float *v20; // rax
  _DWORD *v21; // rax
  _QWORD v23[2]; // [rsp+20h] [rbp-118h] BYREF
  _QWORD v24[2]; // [rsp+30h] [rbp-108h] BYREF
  void *(__fastcall **v25)(AK::ReadBytesMem *__hidden, unsigned int); // [rsp+40h] [rbp-F8h] BYREF
  __int128 v26; // [rsp+48h] [rbp-F0h]
  double v27; // [rsp+58h] [rbp-E0h]
  _BYTE v28[32]; // [rsp+60h] [rbp-D8h] BYREF
  _QWORD v29[4]; // [rsp+80h] [rbp-B8h] BYREF
  _BYTE v30[32]; // [rsp+A0h] [rbp-98h] BYREF
  _BYTE v31[32]; // [rsp+C0h] [rbp-78h] BYREF
  _BYTE v32[32]; // [rsp+E0h] [rbp-58h] BYREF

  *(_QWORD *)a1 = &off_1481B0218;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(double *)(a1 + 0x18) = *(double *)(a2 + 0x18);
  v6 = *(_QWORD **)(a3 + 0x58);
  if ( v6 )
  {
    v7 = a4[1] - a5[1];
    v8 = a4[2] - a5[2];
    _XMM2 = COERCE_UNSIGNED_INT64((*a4 - *a5) * (*a4 - *a5) + v7 * v7 + v8 * v8);
    v10 = *(_OWORD *)(a2 + 8);
    __asm { vmovddup xmm1, xmm2 }
    __asm { vsqrtpd xmm6, xmm1 }
    *(_QWORD *)&_XMM1 = *(_QWORD *)(a2 + 0x18);
    v25 = &off_1481B0218;
    v27 = *(double *)&_XMM1;
    v26 = v10;
    sub_14036BE70(v29);
    sub_140362C80((__int64)v24, v6 + 1);
    __asm
    {
      vunpckhpd xmm6, xmm6, xmm6
      vcvtsd2ss xmm2, xmm6, xmm6
    }
    v15 = sub_1403AD9A0(v24);
    v16 = sub_14036BD90((__int64)v30, 0, *(double *)&_XMM2);
    v17 = (unsigned int *)sub_1403803F0((__int64)v31, v16, (float *)v15);
    v18 = (float *)sub_1403C3D30((__int64)v32, v17);
    sub_140362C80((__int64)v23, v6 + 3);
    v19 = sub_1403AD9A0(v23);
    v20 = (float *)sub_140380170((__int64)v28, (__int64)v19, v18);
    sub_140384A00((float *)a1, v20);
    sub_140362C80((__int64)v23, v6 + 5);
    sub_1403AD9A0(v23);
    v21 = (_DWORD *)sub_1403C3D30((__int64)v28, (unsigned int *)a1);
    *(_DWORD *)(a1 + 8) = v21[2];
    *(_DWORD *)(a1 + 0xC) = v21[3];
    *(_DWORD *)(a1 + 0x10) = v21[4];
    *(_DWORD *)(a1 + 0x14) = v21[5];
    *(_DWORD *)(a1 + 0x18) = v21[6];
    *(_DWORD *)(a1 + 0x1C) = v21[7];
    sub_14039B330((float *)a1, (unsigned int *)&v25);
  }
  return a1;
}

// --- End Function: sub_145D0D920 (0x145D0D920) ---

// --- Function: sub_145D128A0 (0x145D128A0) ---
char __fastcall sub_145D128A0(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rbx
  __int64 *v5; // rax
  __int64 v6; // rbx
  __int64 *v7; // rax
  __int64 v8; // rax
  __int64 *v9; // rax
  __int64 v10; // rbx
  unsigned __int64 *v11; // rax
  unsigned __int64 *v12; // rax
  __int64 *v13; // rax
  __int64 v14; // rdi
  unsigned __int64 v16; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v17; // [rsp+48h] [rbp+10h] BYREF
  __int64 v18; // [rsp+50h] [rbp+18h] BYREF
  __int64 v19; // [rsp+58h] [rbp+20h] BYREF

  v17 = a2;
  if ( !a1 || !sub_14030EC00(&v17) )
    return 1;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x50LL))(a1)
    || !(*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v17 & 0xFFFFFFFFFFFFLL) + 0x50LL))(v17 & 0xFFFFFFFFFFFFLL) )
  {
    return 0;
  }
  v3 = *sub_1464E73E0(qword_149E7E438, &v16);
  if ( !(*(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)(v17 & 0xFFFFFFFFFFFFLL) + 8LL))(
                      v17 & 0xFFFFFFFFFFFFLL,
                      &v18) == v3
       ? *(_DWORD *)(qword_149E7E430 + 0x12FC)
       : *(_DWORD *)(qword_149E7E430 + 0x12F8))
    && !byte_149B4FE81 )
  {
    v5 = sub_1413F3740(v17 & 0xFFFFFFFFFFFFLL, &v16);
    v6 = sub_140501090(v5);
    if ( v6 )
    {
      v7 = sub_1413F3740(a1, &v18);
      v8 = sub_140501090(v7);
      if ( v8 )
      {
        if ( (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v6 + 0x5C0LL))(v6, v8, 0) )
          return 0;
      }
    }
  }
  if ( sub_14030EC00(&v17) && a1 == (v17 & 0xFFFFFFFFFFFFLL) )
    return 0;
  if ( sub_14030EC00(&v17)
    && (((*(void (__fastcall **)(unsigned __int64, unsigned __int64 *))(*(_QWORD *)(v17 & 0xFFFFFFFFFFFFLL) + 0x150LL))(
           v17 & 0xFFFFFFFFFFFFLL,
           &v16),
         v9 = sub_14033A380(v17 & 0xFFFFFFFFFFFFLL, &v18),
         v10 = sub_1403E6720(v9),
         sub_14030EC00(&v16))
     && (v16 & 0xFFFFFFFFFFFFLL) == a1
     || v10
     && (v11 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v10 + 0x618LL))(v10, &v19),
         sub_14030EC00(v11))
     && (v12 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v10 + 0x618LL))(v10, &v19),
         sub_1403E6750(v12) == a1)
     || (v13 = sub_14033A380(a1, &v19), v14 = sub_1403E6720(v13), v10)
     && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x6F0LL))(v10)
     && v14
     && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x6F0LL))(v14)) )
  {
    return 0;
  }
  else
  {
    return 1;
  }
}

// --- End Function: sub_145D128A0 (0x145D128A0) ---

// --- Function: sub_145D12D60 (0x145D12D60) ---
__int64 __fastcall sub_145D12D60(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  _QWORD *v4; // rax
  _QWORD *v6; // rcx
  unsigned __int8 v7; // r15
  int v9; // edi
  double v10; // xmm1_8
  __int64 v11; // rdx
  __int128 v12; // xmm0
  double v13; // xmm1_8
  __int64 v14; // rax
  unsigned __int64 *v15; // r14
  void *Src_1; // rdi
  signed __int64 Size; // r13
  unsigned __int64 v18; // rbx
  int **v19; // rsi
  __int64 v20; // rax
  int *v21; // rdx
  __int64 v22; // rax
  __int64 v23; // rbx
  __int16 n0xFFFF; // cx
  __int64 (__fastcall *v25)(__int64, char *, __int16 *); // r14
  __int64 v26; // rbx
  __int64 v27; // r14
  __int64 v28; // rax
  __int16 n4; // cx
  int *v30; // rbx
  int *v31; // rsi
  _BYTE *Src_2; // rax
  __int16 n0xFFFF_1; // [rsp+20h] [rbp-49h] BYREF
  __int64 v35; // [rsp+28h] [rbp-41h] BYREF
  char v36[16]; // [rsp+30h] [rbp-39h] BYREF
  void *(__fastcall **v37)(AK::ReadBytesMem *__hidden, unsigned int); // [rsp+40h] [rbp-29h] BYREF
  __int128 v38; // [rsp+48h] [rbp-21h]
  double v39; // [rsp+58h] [rbp-11h]
  __int64 v40; // [rsp+60h] [rbp-9h]
  void *Src; // [rsp+68h] [rbp-1h] BYREF
  __int128 v42; // [rsp+70h] [rbp+7h]

  v4 = (_QWORD *)*a4;
  v6 = (_QWORD *)a4[1];
  v7 = 0;
  LODWORD(v35) = a3;
  v9 = a3;
  if ( v4 == v6 )
  {
LABEL_4:
    v10 = *(double *)(a2 + 0x18);
    v38 = *(_OWORD *)(a2 + 8);
    v40 = a1;
    v37 = &off_1481B0218;
    Src = 0;
    v42 = 0;
    v39 = v10;
    sub_140344E10((__int64)&Src, 0, (int *)&v35);
    v11 = a4[1];
    if ( v11 == a4[2] )
    {
      sub_145D02D70(a4, v11, (__int64)&v37);
      Src_1 = Src;
    }
    else
    {
      v12 = v38;
      v13 = v39;
      v14 = v40;
      v15 = (unsigned __int64 *)(v11 + 0x28);
      *(_QWORD *)v11 = &off_1481B0218;
      Src_1 = Src;
      *(_OWORD *)(v11 + 8) = v12;
      *(double *)(v11 + 0x18) = v13;
      *(_QWORD *)(v11 + 0x20) = v14;
      Size = v42 - (_QWORD)Src_1;
      *(_QWORD *)(v11 + 0x28) = 0;
      *(_QWORD *)(v11 + 0x30) = 0;
      *(_QWORD *)(v11 + 0x38) = 0;
      if ( Size >> 2 )
      {
        sub_1402FAB90(v15, Size >> 2);
        v18 = *v15;
        memmove((void *)*v15, Src_1, Size);
        v15[1] = v18 + 4 * (Size >> 2);
      }
      a4[1] += 0x40;
    }
    if ( Src_1 )
    {
      Src_2 = Src_1;
      if ( ((*((_QWORD *)&v42 + 1) - (_QWORD)Src_1) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
      {
        Src_1 = (void *)*((_QWORD *)Src_1 + 0xFFFFFFFF);
        if ( (unsigned __int64)(Src_2 - (_BYTE *)Src_1 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(Src_1);
    }
  }
  else
  {
    while ( v4[4] != a1 )
    {
      v4 += 8;
      if ( v4 == v6 )
        goto LABEL_4;
    }
    v19 = (int **)(v4 + 5);
    v20 = unknown_libname_247(v4[5], v4[6], a3);
    v21 = v19[1];
    if ( (int *)v20 != v21 )
      return 1;
    if ( v21 == v19[2] )
    {
      sub_140344E10((__int64)v19, v21, (int *)&v35);
    }
    else
    {
      *v21 = v9;
      ++v19[1];
    }
    v22 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv, a1);
    v23 = v22;
    if ( v22 )
    {
      n0xFFFF = n0xFFFF_75;
      v25 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v22 + 0x340LL);
      if ( n0xFFFF_75 == (__int16)0xFFFF )
      {
        n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                        + 0x10LL))(
                              qword_149B4FC88,
                              &v35,
                              "SCBodyHealthComponent");
        n0xFFFF_75 = n0xFFFF;
      }
      n0xFFFF_1 = n0xFFFF;
      v26 = *(_QWORD *)v25(v23, v36, &n0xFFFF_1);
      v35 = v26;
      if ( v26 )
      {
        v27 = v26 & 0xFFFFFFFFFFFFLL;
        v28 = sub_1403B4B50(v26 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(v28 + 4);
        if ( n4 != 4
          && *(_WORD *)(v28 + 2) == (HIWORD(v26) & 0xFFF)
          && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_142714E30(&v35)) )
        {
          v30 = *v19;
          v31 = v19[1];
          if ( v30 != v31 )
          {
            while ( v9 == *v30 || !sub_1462FC8C0(v27, *v30, v9) )
            {
              if ( ++v30 == v31 )
                return v7;
            }
            return 1;
          }
        }
      }
    }
  }
  return v7;
}

// --- End Function: sub_145D12D60 (0x145D12D60) ---

// --- Function: sub_145D15910 (0x145D15910) ---
__int64 __fastcall sub_145D15910(__int64 a1)
{
  char v2; // r13
  __int64 v3; // r15
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // rdi
  __int64 v9; // rbp
  __int64 v10; // rax
  __int128 v11; // xmm0
  char v12; // al
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // rbx
  void (__fastcall *v16)(__int64, _QWORD, _QWORD); // rdi
  __int64 v17; // rcx
  int v18; // eax
  __int64 v19; // r9
  char v21; // [rsp+20h] [rbp-C8h]
  int v22; // [rsp+20h] [rbp-C8h]
  __m256 v23; // [rsp+40h] [rbp-A8h] BYREF
  __int128 v24; // [rsp+60h] [rbp-88h]
  __int64 v25; // [rsp+70h] [rbp-78h]
  _BYTE v26[72]; // [rsp+78h] [rbp-70h] BYREF

  sub_144002630(a1, 0xC000);
  (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 0x570LL))(a1, 0, 0);
  v2 = *(_BYTE *)(a1 + 0x2AC);
  v3 = 0;
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v4 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v4 = 0;
  v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 0x648LL))(v4, 0xFFFFFFFFFFFFLL);
  v6 = *(_QWORD *)(a1 + 0x1E8);
  v7 = v5;
  v8 = *(_QWORD *)(a1 + 0xE0);
  v9 = *(_QWORD *)(a1 + 0xC0);
  v21 = 0;
  v10 = (*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD, char))(*(_QWORD *)(*(_QWORD *)(a1 + 8)
                                                                                      & 0xFFFFFFFFFFFFLL)
                                                                          + 0x1E8LL))(
          *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL,
          v26,
          0,
          0,
          v21);
  v11 = *(_OWORD *)(v10 + 0x20);
  v23 = *(__m256 *)v10;
  v25 = *(_QWORD *)(v10 + 0x30);
  v24 = v11;
  __asm { vzeroupper }
  v12 = sub_145D3E760((unsigned int)&v23, (int)a1 + 0x240, v9, v8, v6, v7, v2);
  v14 = *(_QWORD *)(a1 + 0x210);
  *(_BYTE *)(a1 + 0x2AC) = v12;
  if ( v14 )
  {
    LOBYTE(v22) = 0;
    LOBYTE(v13) = 1;
    (*(void (__fastcall **)(__int64, __int64, __int64, __int64, int))(*(_QWORD *)qword_149B4FBE8 + 0x468LL))(
      qword_149B4FBE8,
      0xD3F3,
      v14 + 0x28,
      v13,
      v22);
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x210) + 0x190LL))(*(_QWORD *)(a1 + 0x210));
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x210) + 0x48LL))(*(_QWORD *)(a1 + 0x210));
    *(_QWORD *)(a1 + 0x210) = 0;
  }
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x5D8LL))(a1);
  *(float *)(a1 + 0x294) = (*(float (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x5D8LL))(a1);
  sub_143FFEA60(a1, 0x20);
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v15 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v15 = 0;
  v16 = *(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v15 + 0x4E8LL);
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v17 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  else
    v17 = 0;
  v18 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v17 + 0x4F0LL))(v17, 0);
  v16(v15, 0, v18 & 0xFFFFFFFE);
  if ( sub_14030EC00((unsigned __int64 *)(a1 + 8)) )
    v3 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  LOBYTE(v19) = 1;
  return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64))(*(_QWORD *)v3 + 0x5B0LL))(v3, 0, 0x13, v19);
}

// --- End Function: sub_145D15910 (0x145D15910) ---

// --- Function: sub_145D16C80 (0x145D16C80) ---
void __fastcall sub_145D16C80(unsigned __int64 *a1, __int64 a2)
{
  __int128 v2; // xmm6
  __int128 v3; // xmm7
  __int128 v4; // xmm8
  __int128 v5; // xmm9
  __int128 v6; // xmm10
  __int128 v7; // xmm11
  __int128 v8; // xmm12
  __int128 v9; // xmm13
  __int128 v10; // xmm14
  __int128 v11; // xmm15
  unsigned __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 v16; // rax
  unsigned __int64 *v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rax
  double v20; // xmm4_8
  double v21; // xmm13_8
  double v24; // xmm10_8
  double v25; // xmm12_8
  double v26; // xmm7_8
  double v27; // xmm6_8
  double v28; // xmm3_8
  double v29; // xmm4_8
  float v36; // xmm8_4
  __int64 v37; // rcx
  __int64 v44; // rcx
  unsigned __int64 v45; // rax
  __int64 v47; // rax
  unsigned __int64 *v48; // rax
  float v57; // xmm7_4
  float v58; // xmm5_4
  __int64 v59; // rcx
  __int64 v60; // rax
  unsigned __int64 v61; // rax
  char *v62; // rcx
  _QWORD *v63; // rdi
  _QWORD *v64; // rbx
  _QWORD *v65; // rcx
  char *v66; // rax
  _QWORD v67[4]; // [rsp+28h] [rbp-E0h] BYREF
  double v68; // [rsp+48h] [rbp-C0h]
  double v69; // [rsp+50h] [rbp-B8h]
  double v70; // [rsp+58h] [rbp-B0h]
  float v71; // [rsp+60h] [rbp-A8h]
  float v72; // [rsp+64h] [rbp-A4h]
  float v73; // [rsp+68h] [rbp-A0h]
  float v74; // [rsp+6Ch] [rbp-9Ch]
  float v75; // [rsp+70h] [rbp-98h]
  float v76; // [rsp+74h] [rbp-94h]
  int v77; // [rsp+78h] [rbp-90h]
  bool v78; // [rsp+7Ch] [rbp-8Ch]
  _QWORD *v79; // [rsp+80h] [rbp-88h]
  __int128 v80; // [rsp+88h] [rbp-80h]
  int v81; // [rsp+98h] [rbp-70h] BYREF
  _BYTE v82[12]; // [rsp+9Ch] [rbp-6Ch]
  double v83; // [rsp+B0h] [rbp-58h]
  double v84; // [rsp+B8h] [rbp-50h]
  double v85; // [rsp+C0h] [rbp-48h]
  double v86; // [rsp+C8h] [rbp-40h]
  double v87; // [rsp+D0h] [rbp-38h]
  float v88; // [rsp+D8h] [rbp-30h]
  float v89; // [rsp+DCh] [rbp-2Ch]
  __int64 v90; // [rsp+E0h] [rbp-28h]
  unsigned __int64 v91; // [rsp+E8h] [rbp-20h]
  double v92; // [rsp+F0h] [rbp-18h]
  int n8; // [rsp+F8h] [rbp-10h] BYREF
  double v94; // [rsp+100h] [rbp-8h]
  __int128 v96; // [rsp+118h] [rbp+10h]
  __int128 v97; // [rsp+128h] [rbp+20h]
  __int128 v98; // [rsp+138h] [rbp+30h]
  __int128 v99; // [rsp+148h] [rbp+40h]
  __int128 v100; // [rsp+158h] [rbp+50h]
  __int128 v101; // [rsp+168h] [rbp+60h]
  float v102; // [rsp+178h] [rbp+70h]
  float v103; // [rsp+17Ch] [rbp+74h]
  float v104; // [rsp+180h] [rbp+78h]
  int v105; // [rsp+184h] [rbp+7Ch]
  __int128 v106; // [rsp+188h] [rbp+80h]
  int v107; // [rsp+198h] [rbp+90h]
  float v108; // [rsp+19Ch] [rbp+94h]
  unsigned int v109; // [rsp+1A0h] [rbp+98h]
  unsigned int v110; // [rsp+1A4h] [rbp+9Ch]
  _BYTE v111[56]; // [rsp+1A8h] [rbp+A0h] BYREF
  __int128 v112; // [rsp+1E8h] [rbp+E0h]
  __int128 v113; // [rsp+1F8h] [rbp+F0h]
  __int128 v114; // [rsp+208h] [rbp+100h]
  __int128 v115; // [rsp+218h] [rbp+110h]
  __int128 v116; // [rsp+228h] [rbp+120h]
  __int128 v117; // [rsp+238h] [rbp+130h]
  __int128 v118; // [rsp+248h] [rbp+140h]
  __int128 v119; // [rsp+258h] [rbp+150h]
  __int128 v120; // [rsp+268h] [rbp+160h]
  __int128 v121; // [rsp+278h] [rbp+170h]
  double v122; // [rsp+2B8h] [rbp+1B0h] BYREF
  double v123; // [rsp+2C8h] [rbp+1C0h]

  if ( (a1[0x40] & 0x44) == 0 )
  {
    v121 = v2;
    v120 = v3;
    v119 = v4;
    v118 = v5;
    v117 = v6;
    v116 = v7;
    v115 = v8;
    v114 = v9;
    v14 = a1[0x41];
    v79 = 0;
    v80 = 0;
    if ( !v14 )
      goto LABEL_5;
    v15 = (__int64 *)(v14 & 0xFFFFFFFFFFFFLL);
    if ( *(_QWORD *)((v14 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v14) )
    {
      v92 = 0.0;
      v81 = 1;
      *(_QWORD *)v82 = 0xFFFFFFFFFFFFFFFFuLL;
      *(_DWORD *)&v82[8] = 0;
      v91 = 0xFFFFFFFFFFFFFFFFuLL;
      HIDWORD(v84) = 0xFFF7FFFF;
      v89 = NAN;
      v90 = 0xFFBFFFFFLL;
      v16 = *v15;
      v113 = v10;
      v112 = v11;
      (*(void (__fastcall **)(__int64 *, int *))(v16 + 0x28))(v15, &v81);
      v17 = a1 + 1;
      v18 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(a1[1] & 0xFFFFFFFFFFFFLL) + 0x648LL))(a1[1] & 0xFFFFFFFFFFFFLL);
      v19 = (*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v18 + 0x68LL))(v18, v111, 0);
      v20 = *(double *)(v19 + 0x18);
      v21 = *(double *)v19;
      _XMM14 = *(unsigned __int64 *)(v19 + 8);
      _XMM15 = *(unsigned __int64 *)(v19 + 0x10);
      v24 = *(double *)(v19 + 0x28);
      v25 = *(double *)(v19 + 0x30);
      v26 = v86 * *(double *)&_XMM14 - v85 * *(double *)&_XMM15 + v84 * v20;
      v27 = v84 * *(double *)&_XMM15 - v86 * *(double *)v19 + v85 * v20;
      v28 = v85 * *(double *)v19 - v84 * *(double *)&_XMM14;
      v122 = v20;
      v29 = v28 + v86 * v20;
      v68 = v84
          + *(double *)&_XMM14 * v29
          - *(double *)&_XMM15 * v27
          + *(double *)&_XMM14 * v29
          - *(double *)&_XMM15 * v27
          + *(double *)(v19 + 0x20);
      v69 = v85 + *(double *)&_XMM15 * v26 - v21 * v29 + *(double *)&_XMM15 * v26 - v21 * v29 + v24;
      v70 = v86 + v21 * v27 - *(double *)&_XMM14 * v26 + v21 * v27 - *(double *)&_XMM14 * v26 + v25;
      v123 = v21;
      _XMM4 = *(unsigned __int64 *)&v122;
      _XMM7 = *(unsigned __int64 *)&v21;
      *(float *)&v21 = (float)((float)((float)(v89 * v89) + (float)(v89 * v89))
                             + (float)((float)(*((float *)&v87 + 1) * *((float *)&v87 + 1))
                                     + (float)(*((float *)&v87 + 1) * *((float *)&v87 + 1))))
                     - 1.0;
      *(float *)&v25 = (float)((float)(v89 * *(float *)&v87) + (float)(v89 * *(float *)&v87))
                     + (float)((float)(*((float *)&v87 + 1) * v88) + (float)(*((float *)&v87 + 1) * v88));
      __asm { vcvtsd2ss xmm11, xmm14, xmm14 }
      __asm { vcvtsd2ss xmm9, xmm15, xmm15 }
      __asm { vcvtpd2ps xmm4, xmm4 }
      *(float *)&v24 = (float)((float)(*((float *)&v87 + 1) * *(float *)&v87) - (float)(v89 * v88))
                     + (float)((float)(*((float *)&v87 + 1) * *(float *)&v87) - (float)(v89 * v88));
      __asm { vcvtpd2ps xmm7, xmm7 }
      v36 = (float)((float)(*(float *)&_XMM11 * *(float *)&v25) - (float)(*(float *)&_XMM9 * *(float *)&v21))
          + (float)(*(float *)&_XMM4 * *(float *)&v24);
      *(float *)&v27 = (float)((float)(*(float *)&_XMM9 * *(float *)&v24) - (float)(*(float *)&_XMM7 * *(float *)&v25))
                     + (float)(*(float *)&_XMM4 * *(float *)&v21);
      *(float *)&_XMM4 = (float)((float)(*(float *)&_XMM7 * *(float *)&v21) - (float)(*(float *)&_XMM11 * *(float *)&v24))
                       + (float)(*(float *)&_XMM4 * *(float *)&v25);
      v71 = (float)(*(float *)&v24
                  + (float)((float)(*(float *)&_XMM11 * *(float *)&_XMM4) - (float)(*(float *)&_XMM9 * *(float *)&v27)))
          + (float)((float)(*(float *)&_XMM11 * *(float *)&_XMM4) - (float)(*(float *)&_XMM9 * *(float *)&v27));
      v73 = (float)(*(float *)&v25
                  + (float)((float)(*(float *)&_XMM7 * *(float *)&v27) - (float)(*(float *)&_XMM11 * v36)))
          + (float)((float)(*(float *)&_XMM7 * *(float *)&v27) - (float)(*(float *)&_XMM11 * v36));
      v72 = (float)((float)((float)(*(float *)&_XMM9 * v36) - (float)(*(float *)&_XMM7 * *(float *)&_XMM4))
                  + *(float *)&v21)
          + (float)((float)(*(float *)&_XMM9 * v36) - (float)(*(float *)&_XMM7 * *(float *)&_XMM4));
    }
    else
    {
LABEL_5:
      v17 = a1 + 1;
      v37 = sub_14030EC00(a1 + 1) ? *v17 & 0xFFFFFFFFFFFFLL : 0LL;
      (*(void (__fastcall **)(__int64, int *, _QWORD))(*(_QWORD *)v37 + 0x210LL))(v37, &v81, 0);
      v69 = v87;
      _XMM1 = *(unsigned __int64 *)&v82[4];
      v68 = v83;
      __asm { vcvtpd2ps xmm1, xmm1 }
      v71 = *(float *)&_XMM1;
      _XMM1 = (unsigned __int64)v90;
      v70 = v92;
      _XMM0 = *(unsigned __int64 *)&v85;
      __asm
      {
        vcvtpd2ps xmm1, xmm1
        vcvtpd2ps xmm0, xmm0
      }
      v73 = *(float *)&_XMM1;
      v72 = *(float *)&_XMM0;
    }
    v67[0] = a1[0x1C];
    v67[1] = a1[0x3E];
    sub_1403B0A70(v17, &v122);
    *(double *)&v67[2] = v122;
    v44 = a2 ? *(_QWORD *)(*(__int64 (__fastcall **)(__int64, double *))(*(_QWORD *)a2 + 8LL))(a2, &v122) : 0LL;
    v45 = a1[0x41];
    v67[3] = v44;
    v105 = 0;
    v107 = 0;
    v109 = 0x80000000;
    v110 = 0x80000000;
    n8 = 8;
    _XMM1 = 0;
    v94 = 0.0;
    v102 = 0.0;
    v103 = 0.0;
    v104 = 0.0;
    v108 = 0.0;
    __asm { vmovupd [rbp+1A0h+var_1A0], xmm1 }
    v96 = 0;
    v97 = 0;
    v98 = 0;
    v99 = 0;
    v100 = 0;
    v101 = 0;
    v106 = 0;
    if ( !v45 )
      goto LABEL_16;
    if ( *(_QWORD *)((v45 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v45)
      && (*(unsigned int (__fastcall **)(unsigned __int64, int *))(*(_QWORD *)(v45 & 0xFFFFFFFFFFFFLL) + 0x28LL))(
           v45 & 0xFFFFFFFFFFFFLL,
           &n8) )
    {
      v47 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(*v17 & 0xFFFFFFFFFFFFLL) + 0x648LL))(*v17 & 0xFFFFFFFFFFFFLL);
      v48 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v47 + 0x68LL))(
                                  v47,
                                  v111,
                                  0);
      _XMM11 = v48[1];
      _XMM8 = v48[2];
      _XMM4 = v48[3];
      _XMM10 = *v48;
      __asm
      {
        vcvtpd2ps xmm4, xmm4
        vcvtpd2ps xmm11, xmm11
        vcvtpd2ps xmm8, xmm8
        vcvtpd2ps xmm10, xmm10
      }
      v57 = (float)((float)(*(float *)&_XMM11 * *((float *)&v96 + 2)) - (float)(*(float *)&_XMM8 * *((float *)&v96 + 1)))
          + (float)(*(float *)&_XMM4 * *(float *)&v96);
      v58 = (float)((float)(*(float *)&_XMM8 * *(float *)&v96) - (float)(*(float *)&_XMM10 * *((float *)&v96 + 2)))
          + (float)(*(float *)&_XMM4 * *((float *)&v96 + 1));
      *(float *)&_XMM4 = (float)((float)(*(float *)&_XMM10 * *((float *)&v96 + 1))
                               - (float)(*(float *)&_XMM11 * *(float *)&v96))
                       + (float)(*(float *)&_XMM4 * *((float *)&v96 + 2));
      v76 = (float)(*((float *)&v96 + 2) + (float)((float)(*(float *)&_XMM10 * v58) - (float)(*(float *)&_XMM11 * v57)))
          + (float)((float)(*(float *)&_XMM10 * v58) - (float)(*(float *)&_XMM11 * v57));
      v74 = (float)(*(float *)&v96
                  + (float)((float)(*(float *)&_XMM11 * *(float *)&_XMM4) - (float)(*(float *)&_XMM8 * v58)))
          + (float)((float)(*(float *)&_XMM11 * *(float *)&_XMM4) - (float)(*(float *)&_XMM8 * v58));
      v75 = (float)(*((float *)&v96 + 1)
                  + (float)((float)(*(float *)&_XMM8 * v57) - (float)(*(float *)&_XMM10 * *(float *)&_XMM4)))
          + (float)((float)(*(float *)&_XMM8 * v57) - (float)(*(float *)&_XMM10 * *(float *)&_XMM4));
    }
    else
    {
LABEL_16:
      v76 = 0.0;
      v75 = 0.0;
      v74 = 0.0;
    }
    v59 = sub_14030EC00(v17) ? *v17 & 0xFFFFFFFFFFFFLL : 0LL;
    v60 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v59 + 0x20LL))(v59);
    v77 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v60 + 0x28LL))(v60);
    v61 = *a1;
    v78 = a2 != 0;
    (*(void (__fastcall **)(unsigned __int64 *, _QWORD *))(v61 + 0x608))(a1, v67);
    v62 = (char *)v79;
    if ( v79 )
    {
      v63 = (_QWORD *)v80;
      if ( v79 != (_QWORD *)v80 )
      {
        v64 = v79 + 7;
        do
        {
          v65 = (_QWORD *)v64[0xFFFFFFFE];
          if ( v65 )
          {
            if ( ((*v64 - (_QWORD)v65) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
            {
              if ( (unsigned __int64)v65 - v65[0xFFFFFFFF] - 8 > 0x1F )
                goto LABEL_32;
              v65 = (_QWORD *)v65[0xFFFFFFFF];
            }
            sub_1402A3D30(v65);
            v64[0xFFFFFFFE] = 0;
            v64[0xFFFFFFFF] = 0;
            *v64 = 0;
          }
          v64 += 8;
        }
        while ( v64 + 0xFFFFFFF9 != v63 );
        v62 = (char *)v79;
      }
      v66 = v62;
      if ( ((*((_QWORD *)&v80 + 1) - (_QWORD)v62) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
      {
        v62 = (char *)*((_QWORD *)v62 + 0xFFFFFFFF);
        if ( (unsigned __int64)(v66 - v62 - 8) > 0x1F )
LABEL_32:
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v62);
    }
  }
}

// --- End Function: sub_145D16C80 (0x145D16C80) ---

// --- Function: sub_145D17670 (0x145D17670) ---
void __fastcall sub_145D17670(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6,
        __int64 *a7,
        char a8)
{
  __int64 *v10; // r12
  bool v13; // zf
  __int64 v14; // rax
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // rcx
  __int64 *v18; // rax
  __int128 v19; // xmm0
  __int128 v20; // xmm1
  __int64 v21; // rcx
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // r13
  float v25; // xmm0_4
  __int64 v26; // rax
  __int64 v27; // r12
  float v28; // xmm9_4
  float v29; // xmm8_4
  unsigned __int64 v30; // r15
  __int64 v31; // r14
  __int64 v32; // rsi
  __int64 v33; // rdi
  double *v34; // rax
  __int128 v35; // xmm7
  double v36; // xmm6_8
  __int64 v37; // rbx
  __int128 v38; // xmm0
  float v39; // xmm1_4
  __int64 v40; // rax
  char *v41; // rcx
  _QWORD *v42; // rdi
  _QWORD *v43; // rbx
  _QWORD *v44; // rcx
  char *v45; // rax
  __int64 v46; // rax
  _QWORD *v47; // rdi
  _QWORD *v48; // rbx
  _QWORD *v49; // rcx
  char *v50; // rax
  unsigned __int64 v51; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v52; // [rsp+28h] [rbp-D8h] BYREF
  _QWORD v53[4]; // [rsp+30h] [rbp-D0h] BYREF
  __int128 v54; // [rsp+50h] [rbp-B0h] BYREF
  __int128 v55; // [rsp+60h] [rbp-A0h]
  __int128 v56; // [rsp+70h] [rbp-90h]
  int v57; // [rsp+80h] [rbp-80h]
  char v58; // [rsp+84h] [rbp-7Ch]
  _QWORD *v59; // [rsp+88h] [rbp-78h]
  __int128 v60; // [rsp+90h] [rbp-70h]
  unsigned __int64 v61; // [rsp+A0h] [rbp-60h] BYREF
  char v62[8]; // [rsp+A8h] [rbp-58h] BYREF
  char v63[8]; // [rsp+B0h] [rbp-50h] BYREF
  char v64[8]; // [rsp+B8h] [rbp-48h] BYREF
  double v65[3]; // [rsp+C0h] [rbp-40h] BYREF
  double v66[7]; // [rsp+D8h] [rbp-28h] BYREF
  _QWORD v67[8]; // [rsp+110h] [rbp+10h] BYREF
  __int128 v68; // [rsp+150h] [rbp+50h]
  int v69; // [rsp+160h] [rbp+60h]
  float v70; // [rsp+164h] [rbp+64h]
  float v71; // [rsp+174h] [rbp+74h]
  float v72; // [rsp+178h] [rbp+78h]
  int n5; // [rsp+184h] [rbp+84h]
  __int64 v74; // [rsp+198h] [rbp+98h]
  __int128 v75; // [rsp+1A0h] [rbp+A0h]
  double v76; // [rsp+1B0h] [rbp+B0h]
  char v77; // [rsp+1F4h] [rbp+F4h]
  char v78; // [rsp+1F5h] [rbp+F5h]
  bool v79; // [rsp+1FAh] [rbp+FAh]
  void *(__fastcall **v80)(FDefaultModuleImpl *__hidden, unsigned int); // [rsp+220h] [rbp+120h]

  v10 = a7;
  (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)gEnv + 0x120LL))(gEnv, &v61, a5);
  v13 = *(_DWORD *)(a2 + 8) == 0;
  v51 = v61;
  if ( v13
    || sub_14030EC00(&v51)
    && (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v51 & 0xFFFFFFFFFFFFLL) + 0x720LL))(v51 & 0xFFFFFFFFFFFFLL)
    && *(_DWORD *)(a2 + 8) == 1 )
  {
    if ( sub_1464E7930(qword_149E7E438) )
    {
      if ( v10 )
      {
        v14 = sub_145D00DD0(a2);
        if ( v14 )
        {
          if ( *(_QWORD *)(v14 + 8) )
          {
            v15 = *(_QWORD *)(a1 + 0x18);
            if ( v15 && *(_QWORD *)((v15 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v15) )
              v16 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)gEnv + 0x188LL))(gEnv, &v52);
            else
              v16 = 0;
            _XMM0 = 0;
            v51 = v16;
            v55 = 0u;
            __asm { vmovupd [rsp+2F0h+var_2A0], xmm0 }
            v56 = 0;
            v60 = 0;
            v59 = 0;
            v53[0] = a3;
            v53[1] = a5;
            v53[2] = *sub_1403B0A70(&a6, &v52);
            v18 = sub_1403B0A70(&v51, &v52);
            v19 = *(_OWORD *)(a1 + 0x48);
            v20 = *(_OWORD *)(a1 + 0x58);
            v21 = *v18;
            LODWORD(v56) = *(_DWORD *)(a1 + 0x68);
            HIDWORD(v56) = *(_DWORD *)(a1 + 0x74);
            v22 = *v10;
            v54 = v19;
            *(_QWORD *)&v19 = *(_QWORD *)(a1 + 0x6C);
            v53[3] = v21;
            v55 = v20;
            *(double *)((char *)&v56 + 4) = *(double *)&v19;
            v58 = 1;
            v57 = (*(__int64 (__fastcall **)(__int64 *))(v22 + 0x28))(v10);
            v23 = sub_142CE4F70(a2);
            v24 = v23;
            if ( !v23
              || (v25 = sub_1403AD990(v23 + 0x198, 2),
                  fabs(v25 - sub_1403B7840(v24 + 0x198).m128_f32[0]) >= 0.00000011920929) )
            {
              v46 = sub_1464E7930(qword_149E7E438);
              sub_14646AC20(v46, v53);
              v41 = (char *)v59;
              if ( !v59 )
                return;
              v47 = (_QWORD *)v60;
              if ( v59 != (_QWORD *)v60 )
              {
                v48 = v59 + 7;
                do
                {
                  v49 = (_QWORD *)v48[0xFFFFFFFE];
                  if ( v49 )
                  {
                    if ( ((*v48 - (_QWORD)v49) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
                    {
                      if ( (unsigned __int64)v49 - v49[0xFFFFFFFF] - 8 > 0x1F )
                        goto LABEL_43;
                      v49 = (_QWORD *)v49[0xFFFFFFFF];
                    }
                    sub_1402A3D30(v49);
                    v48[0xFFFFFFFE] = 0;
                    v48[0xFFFFFFFF] = 0;
                    *v48 = 0;
                  }
                  v48 += 8;
                }
                while ( v48 + 0xFFFFFFF9 != v47 );
                v41 = (char *)v59;
              }
              v50 = v41;
              if ( ((*((_QWORD *)&v60 + 1) - (_QWORD)v41) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
              {
                v41 = (char *)*((_QWORD *)v41 + 0xFFFFFFFF);
                if ( (unsigned __int64)(v50 - v41 - 8) > 0x1F )
LABEL_43:
                  invalid_parameter_noinfo_noreturn();
              }
              goto LABEL_44;
            }
            v26 = sub_145D1BE90(v53);
            v27 = v26;
            if ( v26 )
            {
              (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v26 + 0x78LL))(v26, v66, 0);
              v28 = *(float *)(v24 + 0x10);
              v29 = *(float *)(v24 + 0xC);
              v30 = v51;
              v31 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)gEnv + 0x120LL))(
                                 gEnv,
                                 &v52,
                                 a5);
              v32 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)gEnv + 0x120LL))(
                                 gEnv,
                                 v62,
                                 a4);
              v33 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *, __int64))(*(_QWORD *)gEnv + 0x120LL))(
                                 gEnv,
                                 v63,
                                 a3);
              v34 = sub_140337B60(v65, v66, (double *)&v54);
              v35 = *(_OWORD *)v34;
              v36 = v34[2];
              v37 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v27 + 0x38LL))(v27, v64);
              sub_141886BE0((__int64)v67);
              v38 = *(_OWORD *)(v24 + 0x1A0);
              v39 = *(float *)(v24 + 0x1B4);
              v79 = *(_DWORD *)(v24 + 8) != 0;
              v68 = v38;
              v69 = *(_DWORD *)(v24 + 0x1B0);
              v70 = v39;
              v72 = v29;
              v71 = v28;
              v74 = v37;
              v75 = v35;
              v76 = v36;
              v67[0] = v33;
              v67[3] = v32;
              v67[2] = v31;
              v67[1] = v30;
              n5 = 5;
              v78 = 1;
              v77 = a8;
              v40 = sub_1464E7930(qword_149E7E438);
              sub_146465830(v40, (__int64)v67);
              v80 = &off_1481A0DB8;
              v67[7] = &off_1481A0DB8;
            }
            else
            {
              sub_1405C0E00(0xAu, 2u, "Distortion explosion queued without a valid Zone! Skipping explosion.");
            }
            v41 = (char *)v59;
            if ( v59 )
            {
              v42 = (_QWORD *)v60;
              if ( v59 != (_QWORD *)v60 )
              {
                v43 = v59 + 7;
                do
                {
                  v44 = (_QWORD *)v43[0xFFFFFFFE];
                  if ( v44 )
                  {
                    if ( ((*v43 - (_QWORD)v44) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
                    {
                      if ( (unsigned __int64)v44 - v44[0xFFFFFFFF] - 8 > 0x1F )
                        goto LABEL_30;
                      v44 = (_QWORD *)v44[0xFFFFFFFF];
                    }
                    sub_1402A3D30(v44);
                    v43[0xFFFFFFFE] = 0;
                    v43[0xFFFFFFFF] = 0;
                    *v43 = 0;
                  }
                  v43 += 8;
                }
                while ( v43 + 0xFFFFFFF9 != v42 );
                v41 = (char *)v59;
              }
              v45 = v41;
              if ( ((*((_QWORD *)&v60 + 1) - (_QWORD)v41) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
              {
                v41 = (char *)*((_QWORD *)v41 + 0xFFFFFFFF);
                if ( (unsigned __int64)(v45 - v41 - 8) > 0x1F )
LABEL_30:
                  invalid_parameter_noinfo_noreturn();
              }
LABEL_44:
              sub_1402A3D30(v41);
            }
          }
        }
      }
    }
  }
}

// --- End Function: sub_145D17670 (0x145D17670) ---

// --- Function: sub_145D18520 (0x145D18520) ---
double __fastcall sub_145D18520(
        __int64 a1,
        unsigned __int64 a2,
        float *a3,
        int a4,
        double *a5,
        float *a6,
        __int64 a7,
        char a8,
        unsigned __int64 a9,
        unsigned __int64 a10,
        __int64 a11,
        char a12,
        int a13,
        _QWORD *a14,
        __int64 a15,
        int a16,
        int a17)
{
  __int128 v17; // xmm7
  __int128 v18; // xmm8
  __int128 v19; // xmm9
  __int128 v20; // xmm10
  __int128 v21; // xmm11
  __int128 v22; // xmm12
  __int128 v23; // xmm13
  __int128 v24; // xmm14
  __int64 v25; // rbx
  __int64 v26; // r13
  _QWORD *v27; // r14
  __int64 v30; // rsi
  int v31; // edi
  const char *p_unknown_2; // rax
  __int64 *ThreadLogContextSlot_2; // rax
  int v34; // edi
  const char *p_unknown_1; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  unsigned int v37; // ebx
  _QWORD *v38; // rax
  int v39; // ebx
  __int64 v40; // rax
  const char *p_unknown; // rax
  __int64 *ThreadLogContextSlot; // rax
  __int64 v43; // rax
  __int64 v44; // rbx
  float v45; // xmm10_4
  float v46; // xmm9_4
  float v47; // xmm8_4
  float v56; // xmm7_4
  float v57; // xmm6_4
  float v58; // xmm4_4
  float v59; // xmm5_4
  float v60; // xmm3_4
  float v61; // xmm4_4
  float v62; // xmm1_4
  float v63; // xmm8_4
  float v64; // xmm2_4
  float v65; // xmm10_4
  float v66; // xmm0_4
  float v67; // xmm9_4
  float v68; // xmm7_4
  float v69; // xmm6_4
  float v70; // xmm4_4
  double *v71; // r12
  __int64 v72; // rbx
  int v73; // eax
  int v74; // r15d
  __int64 v75; // rdi
  int v76; // r14d
  bool v77; // al
  __int64 v78; // rsi
  unsigned __int64 v79; // rdx
  __int64 v80; // r14
  __int64 v81; // rcx
  float v82; // xmm5_4
  double v83; // xmm2_8
  double v84; // kr00_8
  float v88; // xmm1_4
  __int128 n0x3F800000_1; // xmm0
  __int128 n0x3F800000; // kr00_16
  __int64 v94; // rdi
  bool v95; // zf
  __m128 v96; // kr00_16
  __m128 v97; // xmm0
  _DWORD *v98; // rcx
  __int64 v99; // rax
  unsigned __int64 v100; // rax
  __int64 v101; // rcx
  __int64 *v102; // r8
  __int64 v103; // rax
  unsigned __int64 v104; // rax
  __int64 i; // rbx
  __int64 v106; // rcx
  __int64 v107; // rax
  __int128 v109; // [rsp+80h] [rbp-80h] BYREF
  __int128 v110; // [rsp+90h] [rbp-70h] BYREF
  const void *v111; // [rsp+A0h] [rbp-60h]
  __int64 v112; // [rsp+A8h] [rbp-58h] BYREF
  __int64 v113; // [rsp+B0h] [rbp-50h] BYREF
  const char *p_ProjectileUtils::GenerateHit; // [rsp+B8h] [rbp-48h]
  const void *v115; // [rsp+C0h] [rbp-40h]
  __int64 v116; // [rsp+C8h] [rbp-38h] BYREF
  __int64 v117; // [rsp+D0h] [rbp-30h]
  const void *v118; // [rsp+D8h] [rbp-28h]
  int v119; // [rsp+E0h] [rbp-20h]
  double *v120; // [rsp+E8h] [rbp-18h] BYREF
  float *v121; // [rsp+F0h] [rbp-10h]
  __int64 v122; // [rsp+F8h] [rbp-8h]
  __int64 v123; // [rsp+100h] [rbp+0h]
  int n0x4600; // [rsp+110h] [rbp+10h] BYREF
  __int64 v125; // [rsp+114h] [rbp+14h]
  int v126; // [rsp+11Ch] [rbp+1Ch]
  unsigned __int64 v127; // [rsp+120h] [rbp+20h]
  unsigned __int64 v128; // [rsp+128h] [rbp+28h]
  __int64 v129; // [rsp+130h] [rbp+30h]
  __int64 v130; // [rsp+138h] [rbp+38h]
  _QWORD v131[2]; // [rsp+160h] [rbp+60h] BYREF
  const void *v132; // [rsp+170h] [rbp+70h]
  double v133[2]; // [rsp+178h] [rbp+78h] BYREF
  char v134; // [rsp+188h] [rbp+88h]
  _QWORD v135[2]; // [rsp+190h] [rbp+90h] BYREF
  _QWORD v136[2]; // [rsp+1A0h] [rbp+A0h] BYREF
  _QWORD v137[2]; // [rsp+1B0h] [rbp+B0h] BYREF
  _QWORD v138[2]; // [rsp+1C0h] [rbp+C0h] BYREF
  _QWORD v139[2]; // [rsp+1D0h] [rbp+D0h] BYREF
  _QWORD v140[2]; // [rsp+1E0h] [rbp+E0h] BYREF
  _QWORD v141[2]; // [rsp+1F0h] [rbp+F0h] BYREF
  char v142; // [rsp+200h] [rbp+100h]
  _DWORD v143[14]; // [rsp+210h] [rbp+110h] BYREF
  unsigned __int64 v144; // [rsp+248h] [rbp+148h]
  __int64 v145; // [rsp+250h] [rbp+150h]
  unsigned __int64 v146; // [rsp+258h] [rbp+158h]
  __int64 v147; // [rsp+260h] [rbp+160h]
  unsigned __int64 v148; // [rsp+268h] [rbp+168h]
  unsigned int v149; // [rsp+270h] [rbp+170h]
  unsigned int v150; // [rsp+274h] [rbp+174h]
  unsigned int v151; // [rsp+278h] [rbp+178h]
  unsigned int v152; // [rsp+27Ch] [rbp+17Ch]
  unsigned __int64 v153; // [rsp+280h] [rbp+180h]
  unsigned int v154; // [rsp+288h] [rbp+188h]
  unsigned __int64 v155; // [rsp+290h] [rbp+190h]
  unsigned int v156; // [rsp+298h] [rbp+198h]
  unsigned __int64 v157; // [rsp+2A0h] [rbp+1A0h]
  unsigned int v158; // [rsp+2ACh] [rbp+1ACh]
  int v159; // [rsp+2B0h] [rbp+1B0h]
  unsigned int v160; // [rsp+2B4h] [rbp+1B4h]
  unsigned __int64 v161; // [rsp+2B8h] [rbp+1B8h]
  __int128 v162; // [rsp+2C0h] [rbp+1C0h]
  __int128 v163; // [rsp+2D0h] [rbp+1D0h]
  unsigned int v164; // [rsp+2E0h] [rbp+1E0h]
  unsigned int v165; // [rsp+2E4h] [rbp+1E4h]
  unsigned int v166; // [rsp+2E8h] [rbp+1E8h]
  unsigned __int64 v167; // [rsp+2F0h] [rbp+1F0h]
  unsigned int v168; // [rsp+2F8h] [rbp+1F8h]
  unsigned __int64 v169; // [rsp+300h] [rbp+200h]
  unsigned int v170; // [rsp+308h] [rbp+208h]
  __int64 v171; // [rsp+310h] [rbp+210h]
  int v172; // [rsp+318h] [rbp+218h]
  __int64 v173; // [rsp+320h] [rbp+220h]
  double v174[8]; // [rsp+330h] [rbp+230h] BYREF
  _BYTE v175[24]; // [rsp+370h] [rbp+270h] BYREF
  __int64 v176; // [rsp+388h] [rbp+288h]
  __int64 v177; // [rsp+390h] [rbp+290h]
  int v178; // [rsp+398h] [rbp+298h]
  unsigned __int64 v179; // [rsp+3A0h] [rbp+2A0h]
  float v180; // [rsp+3D0h] [rbp+2D0h]
  int v181; // [rsp+3D4h] [rbp+2D4h]
  int v182; // [rsp+3D8h] [rbp+2D8h]
  int v183; // [rsp+3E8h] [rbp+2E8h]
  char v184; // [rsp+3F0h] [rbp+2F0h]
  int v185; // [rsp+44Ch] [rbp+34Ch]
  char v186; // [rsp+454h] [rbp+354h]
  __int64 v187; // [rsp+460h] [rbp+360h]
  int v188; // [rsp+46Ch] [rbp+36Ch]
  int v189; // [rsp+470h] [rbp+370h]
  int v190; // [rsp+474h] [rbp+374h]
  int n0xE4; // [rsp+4D0h] [rbp+3D0h] BYREF
  int n0x79; // [rsp+4D4h] [rbp+3D4h]
  int n0x44; // [rsp+4D8h] [rbp+3D8h]
  _BYTE v194[4]; // [rsp+4DCh] [rbp+3DCh] BYREF
  __int128 v195; // [rsp+4F0h] [rbp+3F0h]
  __int128 v196; // [rsp+500h] [rbp+400h]
  __int128 v197; // [rsp+510h] [rbp+410h]
  __int128 v198; // [rsp+520h] [rbp+420h]
  __int128 v199; // [rsp+530h] [rbp+430h]
  __int128 v200; // [rsp+540h] [rbp+440h]
  __int128 v201; // [rsp+550h] [rbp+450h]
  __int128 v202; // [rsp+560h] [rbp+460h]
  unsigned __int64 v203; // [rsp+5D8h] [rbp+4D8h] BYREF

  v203 = a2;
  v25 = a7;
  v26 = 0;
  v27 = a14;
  v122 = a7;
  v126 = 0;
  v128 = 0;
  v129 = 0;
  v130 = 0;
  v119 = a4;
  v121 = a3;
  v112 = a1;
  n0x4600 = 0x4600;
  v125 = 1;
  v127 = __rdtsc();
  qword_149B4B870(
    &n0x4600,
    &word_149E71870,
    "ProjectileUtils::GenerateHit",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileUtils.cpp",
    0xA6);
  HIWORD(n0x4600) = word_149E71870;
  v123 = sub_142CBEFA0(v25);
  v30 = v123;
  if ( v123 )
  {
    if ( sub_1403BA280(a3) )
    {
      if ( sub_14030EC00(&v203) )
      {
        v37 = *(_DWORD *)(a1 + 0x90);
        v38 = (_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, double **))(*(_QWORD *)(v203 & 0xFFFFFFFFFFFFLL)
                                                                               + 8LL))(
                          v203 & 0xFFFFFFFFFFFFLL,
                          &v120);
        if ( (unsigned __int8)sub_145D12D60(*v38, a3, v37, v27) )
        {
          if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
          {
            n0xE4 = 0xE4;
            v139[0] = &n0xE4;
            n0x79 = 0x79;
            v139[1] = v194;
            n0x44 = 0x44;
            v39 = invokeGlobalCallbackAndMaskStatusBits(
                    5,
                    (__int64)v139,
                    (__int64)"Projectile Hit Discarded",
                    "$$: Projectile owned by '$$' [$$] discarded due to being considered too similar to previous hit on '"
                    "$$' [$$], $$ hits stored.");
            if ( (v39 & 0xFFFFF) != 0 )
            {
              *((_QWORD *)&v109 + 1) = (__int64)(v27[1] - *v27) >> 6;
              *(_QWORD *)&v109 = 0;
              v141[1] = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)(v203 & 0xFFFFFFFFFFFFLL)
                                                                                          + 8LL))(
                                     v203 & 0xFFFFFFFFFFFFLL,
                                     &v112);
              v141[0] = 0;
              v142 = 0;
              v40 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v203 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v203 & 0xFFFFFFFFFFFFLL);
              v116 = 0;
              v117 = v40;
              v118 = 0;
              v133[1] = *(double *)sub_1403B0A70(&a9, &v120);
              v133[0] = 0.0;
              v134 = 0;
              if ( sub_14030EC00(&a9) )
                p_unknown = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(a9 & 0xFFFFFFFFFFFFLL)
                                                                                      + 0x70LL))(a9 & 0xFFFFFFFFFFFFLL);
              else
                p_unknown = "unknown";
              v131[1] = p_unknown;
              p_ProjectileUtils::GenerateHit = "ProjectileUtils::GenerateHit";
              v131[0] = 0;
              v132 = 0;
              v113 = 0;
              v115 = 0;
              ThreadLogContextSlot = getThreadLogContextSlot();
              n0xE4 = 0xE4;
              v140[0] = &n0xE4;
              n0x79 = 0x79;
              v140[1] = v194;
              n0x44 = 0x44;
              v110 = 0;
              sub_145D048F0(
                5,
                (unsigned int)v140,
                (unsigned int)"Projectile Hit Discarded",
                (unsigned int)"$$: Projectile owned by '$$' [$$] discarded due to being considered too similar to previou"
                              "s hit on '$$' [$$], $$ hits stored.",
                1,
                v39,
                (__int64)&v110,
                0,
                (__int64)ThreadLogContextSlot,
                (__int64)&v113,
                (__int64)v131,
                (__int64)v133,
                (__int64)&v116,
                (__int64)v141,
                (__int64)&v109);
              sub_1402A3D30(v115);
              sub_1402A3D30(v132);
              sub_1402A3D30(v118);
            }
          }
        }
        else
        {
          v202 = v17;
          v201 = v18;
          v200 = v19;
          v43 = *(_QWORD *)(v203 & 0xFFFFFFFFFFFFLL);
          v199 = v20;
          v198 = v21;
          v197 = v22;
          v196 = v23;
          v195 = v24;
          v44 = (*(__int64 (__fastcall **)(unsigned __int64))(v43 + 0x648))(v203 & 0xFFFFFFFFFFFFLL);
          (*(void (__fastcall **)(__int64, double *, _QWORD))(*(_QWORD *)v44 + 0x78LL))(v44, v174, 0);
          v45 = *(float *)(a1 + 0x68);
          v46 = *(float *)(a1 + 0x64);
          v47 = *(float *)(a1 + 0x60);
          _XMM14 = *(unsigned __int64 *)&v174[1];
          _XMM12 = *(unsigned __int64 *)&v174[2];
          _XMM11 = *(unsigned __int64 *)&v174[3];
          _XMM13 = *(unsigned __int64 *)&v174[0];
          __asm
          {
            vcvtpd2ps xmm14, xmm14
            vcvtpd2ps xmm12, xmm12
            vcvtpd2ps xmm11, xmm11
            vcvtpd2ps xmm13, xmm13
          }
          v56 = (float)((float)(v45 * *(float *)&_XMM14) - (float)(v46 * *(float *)&_XMM12))
              + (float)(v47 * *(float *)&_XMM11);
          v57 = (float)((float)(v47 * *(float *)&_XMM12) - (float)(v45 * *(float *)&_XMM13))
              + (float)(v46 * *(float *)&_XMM11);
          v58 = (float)((float)(v46 * *(float *)&_XMM13) - (float)(v47 * *(float *)&_XMM14))
              + (float)(v45 * *(float *)&_XMM11);
          v59 = (float)(*(float *)&_XMM14 * v58) - (float)(*(float *)&_XMM12 * v57);
          v60 = (float)(*(float *)&_XMM13 * v57) - (float)(*(float *)&_XMM14 * v56);
          v61 = (float)(*(float *)&_XMM12 * v56) - (float)(*(float *)&_XMM13 * v58);
          v62 = v47 + v59;
          v63 = *a6;
          *(float *)&v110 = v62 + v59;
          v64 = v45 + v60;
          v65 = a6[2];
          v66 = v46 + v61;
          v67 = a6[1];
          *((float *)&v110 + 1) = v66 + v61;
          *((float *)&v110 + 2) = v64 + v60;
          v68 = (float)((float)(v65 * *(float *)&_XMM14) - (float)(v67 * *(float *)&_XMM12))
              + (float)(v63 * *(float *)&_XMM11);
          v69 = (float)((float)(v63 * *(float *)&_XMM12) - (float)(v65 * *(float *)&_XMM13))
              + (float)(v67 * *(float *)&_XMM11);
          v70 = (float)((float)(v67 * *(float *)&_XMM13) - (float)(v63 * *(float *)&_XMM14))
              + (float)(v65 * *(float *)&_XMM11);
          *(float *)&v109 = (float)(v63 + (float)((float)(*(float *)&_XMM14 * v70) - (float)(*(float *)&_XMM12 * v69)))
                          + (float)((float)(*(float *)&_XMM14 * v70) - (float)(*(float *)&_XMM12 * v69));
          v120 = (double *)(a1 + 0x48);
          *((float *)&v109 + 2) = (float)(v65
                                        + (float)((float)(*(float *)&_XMM13 * v69) - (float)(*(float *)&_XMM14 * v68)))
                                + (float)((float)(*(float *)&_XMM13 * v69) - (float)(*(float *)&_XMM14 * v68));
          *((float *)&v109 + 1) = (float)(v67
                                        + (float)((float)(*(float *)&_XMM12 * v68) - (float)(*(float *)&_XMM13 * v70)))
                                + (float)((float)(*(float *)&_XMM12 * v68) - (float)(*(float *)&_XMM13 * v70));
          v71 = sub_140337B60(v133, v174, (double *)(a1 + 0x48));
          v72 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v44 + 0x38LL))(v44, &n0xE4);
          v73 = sub_14400AA90(v30);
          v74 = *(_DWORD *)(a1 + 0x90);
          v75 = v203;
          v76 = v73;
          v77 = sub_14030EC00(&a9);
          v78 = a10;
          v79 = a10;
          if ( v77 )
            v79 = a9;
          sub_1403627A0(
            (__int64)v175,
            v79,
            v75,
            a11,
            (__int64)v121,
            0.0,
            v119,
            v74,
            v76,
            v72,
            (__int64)v71,
            (__int64)&v109,
            (__int64)&v110);
          v80 = v123;
          v81 = *(_QWORD *)(v123 + 0x68);
          v82 = *(float *)(v122 + 0x40);
          if ( v81 )
          {
            v83 = a5[1] - v120[1];
            v84 = a5[2] - v120[2];
            _XMM2 = COERCE_UNSIGNED_INT64(v83 * v83 + (*a5 - *v120) * (*a5 - *v120) + v84 * v84);
            __asm
            {
              vmovddup xmm1, xmm2
              vsqrtpd xmm4, xmm1
            }
            v88 = *(float *)(v81 + 8);
            __asm
            {
              vunpckhpd xmm4, xmm4, xmm4
              vcvtsd2ss xmm0, xmm4, xmm4
            }
            if ( *(float *)&_XMM0 > v88 )
            {
              n0x3F800000 = 0x3F800000u;
              *(float *)&n0x3F800000 = 1.0 - (float)((float)(*(float *)&_XMM0 - v88) * *(float *)(v81 + 0xC));
              n0x3F800000_1 = n0x3F800000;
              __asm { vmaxss  xmm0, xmm0, dword ptr [rcx+10h] }
            }
            else
            {
              LODWORD(_XMM0) = 0x3F800000;
            }
            v82 = v82 * *(float *)&_XMM0;
          }
          v94 = v112;
          v186 = a8;
          v95 = *(_DWORD *)(v112 + 0x30) == 0xE;
          v96 = (__m128)*(unsigned int *)(v112 + 0x6C);
          v96.m128_f32[0] = (float)((float)(*(float *)(v112 + 0x6C) * *(float *)(v112 + 0x6C))
                                  + (float)(*(float *)(v112 + 0x70) * *(float *)(v112 + 0x70)))
                          + (float)(*(float *)(v112 + 0x74) * *(float *)(v112 + 0x74));
          v97 = _mm_sqrt_ps(_mm_shuffle_ps(v96, v96, 0));
          v180 = (float)(_mm_shuffle_ps(v97, v97, 0xFF).m128_f32[0] * *(float *)(v112 + 0x84)) * v82;
          v177 = a15;
          v182 = a17;
          v181 = a16;
          v176 = v78;
          v187 = v112;
          v184 = a12;
          if ( v95 )
            v178 = *(_DWORD *)(v112 + 0x20);
          v98 = *(_DWORD **)(v123 + 0x100);
          if ( v98 )
          {
            v188 = v98[2];
            v189 = v98[3];
            v190 = v98[4];
          }
          if ( sub_14030EC00((unsigned __int64 *)&a15) )
          {
            v99 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a15 & 0xFFFFFFFFFFFFLL) + 0x20LL))(a15 & 0xFFFFFFFFFFFFLL);
            v185 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v99 + 0x28LL))(v99);
          }
          v100 = *(_QWORD *)(v94 + 0x18);
          if ( v100 )
          {
            v101 = *(_QWORD *)(v94 + 0x18) & 0xFFFFFFFFFFFFLL;
            LOBYTE(v100) = *(_QWORD *)(v101 + 8) == HIWORD(v100);
          }
          else
          {
            v101 = 0;
          }
          v102 = 0;
          if ( (_BYTE)v100 )
            v102 = (__int64 *)v101;
          if ( v183 != 0xFFFFFFFF )
          {
            if ( v102 )
            {
              v143[1] = v183;
              v103 = *v102;
              v162 = xmmword_14819FFD0;
              v144 = 0x8000000000000000uLL;
              v163 = xmmword_148B31B30;
              v143[0] = 6;
              v143[4] = 0xFFBFFFFF;
              v143[0xA] = 0xFFBFFFFF;
              v143[0xD] = 0xFFBFFFFF;
              v143[2] = 0x80000000;
              v149 = 0xFFBFFFFF;
              v150 = 0xFFBFFFFF;
              v153 = 0xFFFFFFFFFFFFFFFFuLL;
              v154 = 0x80000000;
              v155 = 0xFFFFFFFFFFFFFFFFuLL;
              v157 = 0xFFFFFFFFFFFFFFFFuLL;
              v151 = 0xFFBFFFFF;
              v152 = 0xFFBFFFFF;
              v156 = 0x80000000;
              v158 = 0xFFBFFFFF;
              v160 = 0x80000000;
              v161 = 0xFFFFFFFFFFFFFFFFuLL;
              v164 = 0xFFBFFFFF;
              v165 = 0xFFBFFFFF;
              v166 = 0xFFBFFFFF;
              v169 = 0xFFFFFFFFFFFFFFFFuLL;
              v143[0xB] = 0x80000000;
              v170 = 0xFFBFFFFF;
              v167 = 0xFFFFFFFFFFFFFFFFuLL;
              v168 = 0x80000000;
              v143[0xC] = 0;
              v143[3] = 1;
              v159 = 0;
              v147 = 0;
              v145 = 0;
              v148 = 0xFFFFFFFFFFFFFFFFuLL;
              v146 = 0xFFFFFFFFFFFFFFFFuLL;
              v171 = 0;
              v172 = 0;
              v173 = 0;
              if ( (*(unsigned int (__fastcall **)(__int64 *, _DWORD *))(v103 + 0x20))(v102, v143) )
              {
                v104 = v179;
                if ( (v162 & 0x42) != 0 )
                  v104 = v161;
                v179 = v104;
              }
            }
          }
          for ( i = *(_QWORD *)(v80 + 0x138); i; --i )
          {
            v106 = *(_QWORD *)(*(_QWORD *)(v80 + 0x130) + v26);
            if ( v106 )
              (*(void (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v106 + 0x30LL))(v106, v175, v102);
            v26 += 0x10;
          }
          v107 = sub_1464E7930(qword_149E7E438);
          sub_146465830(v107, (__int64)v175);
        }
      }
      else if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
      {
        n0xE4 = 0xE4;
        v137[0] = &n0xE4;
        n0x79 = 0x79;
        v137[1] = v194;
        n0x44 = 0x44;
        v34 = invokeGlobalCallbackAndMaskStatusBits(
                5,
                (__int64)v137,
                (__int64)"Projectile Hit Discarded",
                "$$: Projectile owned by '$$' [$$] discarded due to invalid target.");
        if ( (v34 & 0xFFFFF) != 0 )
        {
          v117 = *sub_1403B0A70(&a9, &v112);
          v116 = 0;
          LOBYTE(v118) = 0;
          if ( sub_14030EC00(&a9) )
            p_unknown_1 = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(a9 & 0xFFFFFFFFFFFFLL)
                                                                                    + 0x70LL))(a9 & 0xFFFFFFFFFFFFLL);
          else
            p_unknown_1 = "unknown";
          *((_QWORD *)&v110 + 1) = p_unknown_1;
          p_ProjectileUtils::GenerateHit = "ProjectileUtils::GenerateHit";
          *(_QWORD *)&v110 = 0;
          v111 = 0;
          v113 = 0;
          v115 = 0;
          ThreadLogContextSlot_1 = getThreadLogContextSlot();
          n0xE4 = 0xE4;
          v138[0] = &n0xE4;
          n0x79 = 0x79;
          v138[1] = v194;
          n0x44 = 0x44;
          v109 = 0;
          sub_141DA58F0(
            5,
            (unsigned int)v138,
            (unsigned int)"Projectile Hit Discarded",
            (unsigned int)"$$: Projectile owned by '$$' [$$] discarded due to invalid target.",
            1,
            v34,
            (__int64)&v109,
            0,
            (__int64)ThreadLogContextSlot_1,
            (__int64)&v113,
            (__int64)&v110,
            (__int64)&v116);
          sub_1402A3D30(v115);
          sub_1402A3D30(v111);
        }
      }
    }
    else if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
    {
      n0xE4 = 0xE4;
      v135[0] = &n0xE4;
      n0x79 = 0x79;
      v135[1] = v194;
      n0x44 = 0x44;
      v31 = invokeGlobalCallbackAndMaskStatusBits(
              5,
              (__int64)v135,
              (__int64)"Projectile Hit Discarded",
              "$$: Projectile owned by '$$' [$$] discarded due to having no damage.");
      if ( (v31 & 0xFFFFF) != 0 )
      {
        v117 = *sub_1403B0A70(&a9, &v112);
        v116 = 0;
        LOBYTE(v118) = 0;
        if ( sub_14030EC00(&a9) )
          p_unknown_2 = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(a9 & 0xFFFFFFFFFFFFLL)
                                                                                  + 0x70LL))(a9 & 0xFFFFFFFFFFFFLL);
        else
          p_unknown_2 = "unknown";
        p_ProjectileUtils::GenerateHit = p_unknown_2;
        *((_QWORD *)&v110 + 1) = "ProjectileUtils::GenerateHit";
        v113 = 0;
        v115 = 0;
        *(_QWORD *)&v110 = 0;
        v111 = 0;
        ThreadLogContextSlot_2 = getThreadLogContextSlot();
        n0xE4 = 0xE4;
        v136[0] = &n0xE4;
        n0x79 = 0x79;
        v136[1] = v194;
        n0x44 = 0x44;
        v109 = 0;
        sub_141DA58F0(
          5,
          (unsigned int)v136,
          (unsigned int)"Projectile Hit Discarded",
          (unsigned int)"$$: Projectile owned by '$$' [$$] discarded due to having no damage.",
          1,
          v31,
          (__int64)&v109,
          0,
          (__int64)ThreadLogContextSlot_2,
          (__int64)&v110,
          (__int64)&v113,
          (__int64)&v116);
        sub_1402A3D30(v111);
        sub_1402A3D30(v115);
      }
    }
  }
  v128 = __rdtsc();
  return qword_149B4B878(&n0x4600);
}

// --- End Function: sub_145D18520 (0x145D18520) ---

// --- Function: sub_145D1AC10 (0x145D1AC10) ---
__int64 __fastcall sub_145D1AC10(__int64 a1, __int64 a2)
{
  const char *v3; // r15
  __int64 v4; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rsi
  __int64 v7; // rdi
  double *v8; // rax
  double v9; // xmm1_8
  char *String2; // [rsp+20h] [rbp-68h] BYREF
  __int128 v12; // [rsp+28h] [rbp-60h] BYREF
  __int64 v13; // [rsp+38h] [rbp-50h]
  _QWORD v14[3]; // [rsp+40h] [rbp-48h] BYREF

  if ( a2 )
  {
    v3 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 0x18LL))(a2);
    CreateStringObjectFromString((void **)&String2, v3);
    v4 = qword_149E71640;
    v5 = qword_149E71638;
    v6 = (qword_149E71640 - qword_149E71638) >> 5;
    if ( v6 )
    {
      do
      {
        v7 = 0x20 * (v6 >> 1);
        if ( _stricmp(*(const char **)(v7 + v5), String2) >= 0 )
        {
          v6 >>= 1;
        }
        else
        {
          v5 += v7 + 0x20;
          v6 += 0xFFFFFFFFFFFFFFFFuLL - (v6 >> 1);
        }
      }
      while ( v6 );
      v4 = qword_149E71640;
    }
    if ( v5 != v4 && _stricmp(String2, *(const char **)v5) < 0 )
      v5 = qword_149E71640;
    sub_140370D10(&String2);
    if ( v5 == qword_149E71640 )
    {
      sub_142BCC2B0((__int64)"Failed to spawn ammo '%s'! Unknown class or entity class not registered...", v3);
      sub_140361E00(&v12);
    }
    else
    {
      v12 = *(_OWORD *)(v5 + 8);
      v13 = *(_QWORD *)(v5 + 0x18);
    }
    v8 = (double *)&v12;
  }
  else
  {
    sub_140361E00(v14);
    v8 = (double *)v14;
  }
  v9 = v8[2];
  *(_OWORD *)a1 = *(_OWORD *)v8;
  *(double *)(a1 + 0x10) = v9;
  return a1;
}

// --- End Function: sub_145D1AC10 (0x145D1AC10) ---

// --- Function: sub_145D1BE90 (0x145D1BE90) ---
__int64 __fastcall sub_145D1BE90(_QWORD *a1)
{
  unsigned __int64 v2; // rdi
  __int64 (__fastcall *v3)(unsigned __int64, __int64 *, __int64 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v5; // rdi
  __int64 v6; // rax
  __int16 n4; // cx
  __int64 result; // rax
  __int64 v9; // rdi
  __int64 v10; // rsi
  bool v11; // al
  __int64 v12; // rdi
  __int64 (__fastcall *v13)(__int64, _BYTE *, __int64 *); // rsi
  __int16 n257; // ax
  __int64 v15; // rdi
  __int64 v16; // rax
  __int16 n4_1; // dx
  unsigned __int64 v18; // [rsp+20h] [rbp-10h] BYREF
  _BYTE v19[8]; // [rsp+28h] [rbp-8h] BYREF
  __int64 v20; // [rsp+60h] [rbp+30h] BYREF
  char v21; // [rsp+68h] [rbp+38h] BYREF
  __int64 v22; // [rsp+70h] [rbp+40h] BYREF
  unsigned __int64 v23; // [rsp+78h] [rbp+48h] BYREF

  (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)gEnv + 0x120LL))(gEnv, &v23, a1[3]);
  if ( sub_14030EC00(&v23) )
  {
    v2 = v23 & 0xFFFFFFFFFFFFLL;
    v3 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *, __int64 *))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x340LL);
    n0xFFFF = n0xFFFF_35;
    if ( n0xFFFF_35 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            &v21,
                            "IVehicle");
      n0xFFFF_35 = n0xFFFF;
    }
    LOWORD(v20) = n0xFFFF;
    v5 = *(_QWORD *)v3(v2, &v22, &v20);
    v20 = v5;
    if ( !v5 )
      return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v23 & 0xFFFFFFFFFFFFLL);
    v6 = sub_1403B4B50(v5 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v6 + 4);
    if ( n4 == 4 || *(_WORD *)(v6 + 2) != (HIWORD(v5) & 0xFFF) )
      return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v23 & 0xFFFFFFFFFFFFLL);
    if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_140391F30(&v20) )
      return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v23 & 0xFFFFFFFFFFFFLL);
    result = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v23 & 0xFFFFFFFFFFFFLL);
    if ( !result )
      return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v23 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v23 & 0xFFFFFFFFFFFFLL);
    return result;
  }
  (*(void (__fastcall **)(__int64, unsigned __int64 *, _QWORD))(*(_QWORD *)gEnv + 0x120LL))(gEnv, &v18, a1[2]);
  if ( sub_14030EC00(&v18) )
    return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v18 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v18 & 0xFFFFFFFFFFFFLL);
  (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)gEnv + 0x120LL))(gEnv, &v22, a1[1]);
  v9 = v22;
  if ( !v22 )
    return 0;
  v10 = (v22 & 0xF000000000000000uLL) != 0 ? v22 & 0xFFFFFF000000LL : (v22 & 0xFFFFFFFFFFFFLL) - 6;
  if ( *(_WORD *)(v10 + 2) != (HIWORD(v22) & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v11 = sub_140539D80(), v9 = v22, v11) )
    v11 = 1;
  if ( *(_WORD *)(v10 + 4) == 2 && v11 )
    goto LABEL_26;
  if ( !sub_140392020(&v22) )
    return 0;
  v9 = v22;
LABEL_26:
  v12 = v9 & 0xFFFFFFFFFFFFLL;
  v13 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v12 + 0x340LL);
  n257 = n257_0;
  if ( n257_0 == (__int16)0xFFFF )
  {
    n257 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                       qword_149B4FC88,
                       &v21,
                       "SCItemWeaponComponent");
    n257_0 = n257;
  }
  LOWORD(v20) = n257;
  v15 = *(_QWORD *)v13(v12, v19, &v20);
  v20 = v15;
  if ( !is_valid_handle_typeA(&v20) )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v22 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v22 & 0xFFFFFFFFFFFFLL);
  if ( v15 )
  {
    v16 = sub_1403B4B50(v15 & 0xFFFFFFFFFFFFLL);
    n4_1 = *(_WORD *)(v16 + 4);
    if ( n4_1 != 4
      && *(_WORD *)(v16 + 2) == (HIWORD(v15) & 0xFFF)
      && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v20)) )
    {
      return sub_145D21630(v15 & 0xFFFFFFFFFFFFLL);
    }
  }
  return sub_145D21630(0);
}

// --- End Function: sub_145D1BE90 (0x145D1BE90) ---

// --- Function: sub_145D1F380 (0x145D1F380) ---
__int64 __fastcall sub_145D1F380(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rsi
  int *v3; // rbx
  int *v4; // rax
  int v5; // ebx
  int v6; // edi
  __int64 v7; // rdi
  unsigned __int8 (__fastcall *v8)(__int64, __int64, const char *); // rbx
  __int64 v9; // rax
  _BYTE v11[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v12; // [rsp+28h] [rbp-30h]
  _BYTE v13[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v14; // [rsp+40h] [rbp-18h]

  v1 = *(_QWORD *)(a1 + 0xC0);
  if ( !v1 )
    return 0;
  v2 = *(_QWORD *)(v1 + 0x18);
  if ( !v2 )
    return 0;
  v3 = (int *)sub_143268A80((__int64)v13);
  v4 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v2 + 0x18LL))(v2, v11);
  v5 = *v3;
  v6 = *v4;
  if ( v12 )
    sub_147605980(v12);
  if ( v14 )
    sub_147605980(v14);
  if ( v5 != v6 )
  {
    if ( !qword_149B4FCA0 )
      return 0;
    if ( !(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0) )
      return 0;
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0);
    v8 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v7 + 0x100LL);
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 8LL))(v2);
    if ( !v8(v7, v9, "SEntityParticlePhysicsControllerParams") )
      return 0;
  }
  return v2;
}

// --- End Function: sub_145D1F380 (0x145D1F380) ---

// --- Function: sub_145D21330 (0x145D21330) ---
__int64 __fastcall sub_145D21330(__int64 a1, char a2)
{
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rcx

  result = sub_142CBEFA0(a1);
  v4 = result;
  if ( result )
  {
    result += 0xA0;
    if ( a2 )
    {
      v5 = *(_QWORD *)(v4 + 0xF0);
      if ( v5 )
        return v5;
    }
  }
  return result;
}

// --- End Function: sub_145D21330 (0x145D21330) ---

// --- Function: sub_145D21630 (0x145D21630) ---
__int64 __fastcall sub_145D21630(__int64 a1)
{
  unsigned __int64 v3; // [rsp+38h] [rbp+10h] BYREF
  unsigned __int64 v4; // [rsp+40h] [rbp+18h] BYREF

  sub_145C7AAE0(a1, &v3);
  if ( sub_14030EC00(&v3) )
    return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v3 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v3 & 0xFFFFFFFFFFFFLL);
  v4 = *(_QWORD *)(a1 + 8);
  if ( sub_14030EC00(&v4) )
    return (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v4 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v4 & 0xFFFFFFFFFFFFLL);
  else
    return 0;
}

// --- End Function: sub_145D21630 (0x145D21630) ---

// --- Function: sub_145D216C0 (0x145D216C0) ---
float __fastcall sub_145D216C0(
        __int64 a1,
        float *a2,
        __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5,
        __int64 a6,
        __int64 a7,
        double *a8,
        char a9,
        char a10,
        int a11,
        _QWORD *a12,
        __int64 a13,
        _QWORD *a14)
{
  unsigned __int64 v18; // rax
  unsigned int v19; // ebp
  float v21; // xmm4_4
  __m128 v22; // kr00_16
  __m128 v24; // xmm1
  float v25; // xmm4_4
  bool v26; // al
  unsigned __int64 v27; // rcx
  __int64 *v28; // rax
  bool v29; // al
  unsigned __int64 v30; // r8
  unsigned __int64 v32; // [rsp+90h] [rbp-68h] BYREF
  __int64 v33; // [rsp+98h] [rbp-60h] BYREF
  float v34; // [rsp+A8h] [rbp-50h] BYREF
  float v35; // [rsp+ACh] [rbp-4Ch]
  float v36; // [rsp+B0h] [rbp-48h]

  if ( sub_142CBEFA0(a3)
    && (sub_1403B7840((__int64)a2).m128_f32[0] >= 0.0099999998
     || *(_DWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC00 + 0xF0LL))(qword_149B4FC00) + 0x40C)) )
  {
    (*(void (__fastcall **)(__int64, float *, __int64))(*(_QWORD *)qword_149B4FDA8 + 0x38LL))(qword_149B4FDA8, a2, a1);
    if ( *(_DWORD *)(a1 + 0x34) == 2 )
      v18 = *(_QWORD *)(a1 + 0x28);
    else
      v18 = 0;
    v19 = *(__int16 *)(a1 + 0x96);
    v22 = (__m128)*(unsigned int *)(a1 + 0x6C);
    _XMM0.m128_f32[0] = *(float *)(a1 + 0x70) * *(float *)(a1 + 0x70);
    v22.m128_f32[0] = (float)((float)(*(float *)(a1 + 0x6C) * *(float *)(a1 + 0x6C)) + _XMM0.m128_f32[0])
                    + (float)(*(float *)(a1 + 0x74) * *(float *)(a1 + 0x74));
    v21 = v22.m128_f32[0];
    v34 = 0.0;
    v35 = 0.0;
    v36 = 0.0;
    v32 = v18;
    if ( v22.m128_f32[0] > 0.000001 )
    {
      v22.m128_f32[0] = v22.m128_f32[0] + 1.1754944e-38;
      _XMM0 = _mm_shuffle_ps(v22, v22, 0);
      __asm { vrsqrtps xmm3, xmm0 }
      _XMM3.m128_f32[0] = _mm_shuffle_ps(_XMM3, _XMM3, 0xFF).m128_f32[0];
      v24 = (__m128)*(unsigned __int64 *)(a1 + 0x6C);
      v25 = (float)(1.5
                  - (float)((float)((float)(_XMM3.m128_f32[0] * (float)(v21 + 1.1754944e-38)) * _XMM3.m128_f32[0]) * 0.5))
          * _XMM3.m128_f32[0];
      _XMM0.m128_f32[0] = _mm_shuffle_ps(v24, v24, 0x55).m128_f32[0];
      _XMM3.m128_f32[0] = v24.m128_f32[0] * v25;
      v33 = *(_QWORD *)(a1 + 0x6C);
      v24.m128_f32[0] = v25 * *(float *)(a1 + 0x74);
      v35 = _XMM0.m128_f32[0] * v25;
      v36 = v24.m128_f32[0];
      v34 = _XMM3.m128_f32[0];
    }
    v26 = sub_14030EC00(&v32);
    v27 = v32 & 0xFFFFFFFFFFFFLL;
    if ( !v26 )
      v27 = 0;
    if ( (unsigned __int8)sub_145D128A0(v27, a4) )
    {
      if ( v32 != *a14 )
      {
        if ( sub_14030EC00(&v32) )
        {
          v28 = sub_1425D62E0(v32 & 0xFFFFFFFFFFFFLL, &v33);
          if ( is_valid_handle_typeA(v28) )
            *a14 = v32;
        }
        if ( !(unsigned __int8)sub_1405AA0C0() )
          *(double *)_XMM0.m128_u64 = sub_145D18520(
                                        a1,
                                        v32,
                                        a2,
                                        v19,
                                        a8,
                                        &v34,
                                        a3,
                                        a9,
                                        a4,
                                        a5,
                                        a6,
                                        a10,
                                        a11,
                                        a12,
                                        a7,
                                        0,
                                        0);
      }
      if ( byte_149B4FE80 )
      {
        v29 = sub_14030EC00(&v32);
        v30 = v32 & 0xFFFFFFFFFFFFLL;
        if ( !v29 )
          v30 = 0;
        sub_145D37BA0(a1, a4, v30, v19);
      }
      sub_145D224C0(a1, a3, (unsigned int)&v34, (_DWORD)a2, a13);
    }
    else
    {
      _XMM0.m128_i32[0] = 0;
    }
  }
  else
  {
    _XMM0.m128_i32[0] = 0x3F800000;
  }
  return _XMM0.m128_f32[0];
}

// --- End Function: sub_145D216C0 (0x145D216C0) ---

// --- Function: sub_145D224C0 (0x145D224C0) ---
double __fastcall sub_145D224C0(__int64 a1, __int64 a2, float *a3, __int64 a4, int *a5)
{
  __int128 v5; // xmm6
  __int64 v9; // xmm6_8
  double result; // xmm0_8
  float *v11; // rdi
  _BYTE *v12; // rax
  __int64 v13; // rsi
  float v14; // kr00_4
  unsigned int n0xA; // ecx
  int n4; // eax
  float v17; // xmm1_4
  float v18; // xmm0_4
  float v19; // xmm1_4
  double v20; // kr00_8
  int n0x4600; // [rsp+30h] [rbp-51h] BYREF
  __int64 v22; // [rsp+34h] [rbp-4Dh]
  int v23; // [rsp+3Ch] [rbp-45h]
  unsigned __int64 v24; // [rsp+40h] [rbp-41h]
  unsigned __int64 v25; // [rsp+48h] [rbp-39h]
  __int64 v26; // [rsp+50h] [rbp-31h]
  __int64 v27; // [rsp+58h] [rbp-29h]
  float v28[4]; // [rsp+80h] [rbp-1h]
  __int128 v29; // [rsp+A0h] [rbp+1Fh]

  v29 = v5;
  v9 = 0;
  if ( *(_DWORD *)(a1 + 0x30) != 0xE
    && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 0x10) & 0xFFFFFFFFFFFFLL) + 8LL))(*(_QWORD *)(a1 + 0x10) & 0xFFFFFFFFFFFFLL) != 5 )
  {
    return 0.0;
  }
  v11 = (float *)sub_142CBEFA0(a2);
  if ( !v11 )
    return 0.0;
  v12 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC00 + 0x180LL))(
                   qword_149B4FC00,
                   (unsigned int)*(__int16 *)(a1 + 0x96));
  if ( *(_DWORD *)(a1 + 0x40) == 0xFFFFFFFF || (*v12 & 0xFu) < 0xA )
    goto LABEL_16;
  v13 = sub_145D1F380(a2);
  if ( !v13 )
    return 0.0;
  n0x4600 = 0x4600;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v22 = 1;
  v24 = __rdtsc();
  qword_149B4B870(
    &n0x4600,
    &word_149E71874,
    "ProjectileUtils::GetPierceableSurfaceDamageReduction",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileUtils.cpp",
    0x1E7);
  v14 = (float)((float)(*(float *)(a1 + 0x64) * a3[1]) + (float)(*(float *)(a1 + 0x60) * *a3))
      + (float)(*(float *)(a1 + 0x68) * a3[2]);
  HIWORD(n0x4600) = word_149E71874;
  if ( v14 >= 0.0 )
  {
    v25 = __rdtsc();
    qword_149B4B878(&n0x4600);
    return 0.0;
  }
  n0xA = *(_DWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC00 + 0x180LL))(
                      qword_149B4FC00,
                      (unsigned int)*(__int16 *)(a1 + 0x96))
       & 0xF;
  n4 = *a5 + 1;
  *a5 = n4;
  if ( *(_DWORD *)(a1 + 0x40) == 0xFFFFFFFF || n0xA <= *(_DWORD *)(v13 + 0x40) || n4 >= 4 )
  {
    v25 = __rdtsc();
    qword_149B4B878(&n0x4600);
LABEL_16:
    *(_QWORD *)&result = 0x3F800000;
    return result;
  }
  v17 = v11[0x20];
  v28[0] = 100.0;
  v18 = v11[0x21];
  v28[1] = v17;
  v19 = v11[0x22];
  v28[2] = v18;
  v28[3] = v19;
  if ( n0xA < 0xA )
    v9 = LODWORD(v28[dword_148B34018[n0xA]]);
  v25 = __rdtsc();
  qword_149B4B878(&n0x4600);
  HIDWORD(v20) = HIDWORD(v9);
  *(float *)&v20 = *(float *)&v9 * 0.0099999998;
  return v20;
}

// --- End Function: sub_145D224C0 (0x145D224C0) ---

// --- Function: sub_145D30170 (0x145D30170) ---
char __fastcall sub_145D30170(__int64 a1, AK::WriteBytesMem *a2, __int64 a3, __int64 *a4)
{
  char result; // al
  unsigned int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdi
  __int64 v12; // r15
  void (__fastcall *v13)(__int64, _QWORD, _QWORD, float *); // rbx
  unsigned int v14; // eax
  void (__fastcall *v15)(__int64, __int128 *, float *, _QWORD, __int64 *, int, __int64, _DWORD, _DWORD, _QWORD, float *, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD); // r14
  __int64 v16; // rsi
  int v17; // eax
  double v18; // xmm7_8
  __int128 v19; // xmm6
  __int128 v20; // xmm3
  double v23; // kr00_8
  __int128 v25; // kr00_16
  int v27; // edi
  __int64 v28; // rax
  __int64 v31; // rax
  unsigned int v32; // [rsp+80h] [rbp-80h] BYREF
  float v33; // [rsp+88h] [rbp-78h] BYREF
  float v34; // [rsp+8Ch] [rbp-74h]
  float v35; // [rsp+90h] [rbp-70h]
  float v36[4]; // [rsp+98h] [rbp-68h] BYREF
  float v37[10]; // [rsp+A8h] [rbp-58h] BYREF
  __int128 v38; // [rsp+D0h] [rbp-30h] BYREF
  double v39; // [rsp+E0h] [rbp-20h]
  _BYTE v40[32]; // [rsp+F0h] [rbp-10h] BYREF

  result = sub_1403C1370((__int64)a2);
  if ( result )
  {
    __crt_strtox::big_integer::big_integer((__crt_strtox::big_integer *)&v32);
    v8 = AK::WriteBytesMem::Count(a2);
    sub_1403C94D0(&v32, v8);
    v9 = sub_1464E7810(qword_149E7E438);
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x30LL))(v9);
    v11 = qword_149B4FC98;
    v33 = 0.0;
    v34 = 0.0;
    v35 = 0.0;
    v12 = v10;
    v13 = *(void (__fastcall **)(__int64, _QWORD, _QWORD, float *))(*(_QWORD *)qword_149B4FC98 + 0x148LL);
    v14 = sub_1403090B0(&v32);
    v13(v11, v14, 0, &v33);
    if ( v12 )
    {
      v15 = *(void (__fastcall **)(__int64, __int128 *, float *, _QWORD, __int64 *, int, __int64, _DWORD, _DWORD, _QWORD, float *, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD))(*(_QWORD *)v12 + 8LL);
      v37[3] = 1.0;
      v37[0] = 0.0;
      v37[1] = 0.0;
      v37[2] = 0.0;
      v37[4] = 0.0;
      v37[5] = 0.0;
      v37[6] = 0.0;
      v16 = sub_1464E8330(qword_149E7E438) + 0x110;
      v17 = sub_1403090B0(&v32);
      v18 = *(double *)(a3 + 8);
      v19 = *(unsigned __int64 *)(a3 + 0x18);
      v20 = COERCE_UNSIGNED_INT64(v18 * *(double *)(a3 + 0x10));
      _XMM0 = COERCE_UNSIGNED_INT64(
                v18 * *(double *)a3
              - *(double *)&v19 * *(double *)(a3 + 0x10)
              + v18 * *(double *)a3
              - *(double *)&v19 * *(double *)(a3 + 0x10));
      __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      v36[0] = *(float *)&_XMM1;
      *((_QWORD *)&v25 + 1) = *((_QWORD *)&v19 + 1);
      v23 = *(double *)&v19 * *(double *)&v19;
      *(double *)&v19 = *(double *)&v19 * *(double *)a3;
      *(double *)&v25 = v23 + v23 + v18 * v18 + v18 * v18 - 1.0;
      _XMM1 = v25;
      __asm { vcvtsd2ss xmm0, xmm1, xmm1 }
      *((_QWORD *)&v25 + 1) = *((_QWORD *)&v20 + 1);
      v36[1] = *(float *)&_XMM0;
      v27 = v17;
      v28 = *a4;
      *(double *)&v25 = *(double *)&v20 + *(double *)&v20 + *(double *)&v19 + *(double *)&v19;
      _XMM0 = v25;
      __asm { vcvtsd2ss xmm2, xmm0, xmm0 }
      v36[2] = *(float *)&_XMM2;
      v31 = (*(__int64 (__fastcall **)(__int64 *, _BYTE *, __int64))(v28 + 0xF8))(a4, v40, a3 + 0x20);
      *(_QWORD *)&_XMM1 = *(_QWORD *)(v31 + 0x10);
      v38 = *(_OWORD *)v31;
      v39 = *(double *)&_XMM1;
      v15(v12, &v38, v36, 0, a4, v27, v16, LODWORD(v34), LODWORD(v33), 0, v37, 0, 0, 0, 0, 0);
    }
    return sub_140372840(&v32);
  }
  return result;
}

// --- End Function: sub_145D30170 (0x145D30170) ---

// --- Function: sub_145D31FB0 (0x145D31FB0) ---
void __fastcall sub_145D31FB0(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  __int16 n4; // dx
  double v7; // xmm1_8
  __int64 v8; // rax
  __int64 v9; // rax
  double v10; // xmm4_8
  double v11; // xmm2_8
  double v12; // xmm3_8
  __int64 v13; // rbx
  __int128 v14; // kr00_16
  __int64 v17; // rdi
  char v18; // bl
  __int64 *v19; // rax
  unsigned __int64 v20; // [rsp+60h] [rbp+8h] BYREF

  if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64 *))(*a1 + 0x610))(a1) )
  {
    v4 = a1[0x60];
    v20 = v4;
    if ( v4 )
    {
      v5 = sub_1403B4B50(v4 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v5 + 4);
      if ( n4 != 4
        && *(_WORD *)(v5 + 2) == (HIWORD(v4) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v20)) )
      {
        if ( a2 )
        {
          v7 = *((double *)a1 + 0x4A);
          *((_OWORD *)a1 + 0x2E) = *((_OWORD *)a1 + 0x24);
          *((double *)a1 + 0x5E) = v7;
          *((_WORD *)a1 + 0x17C) = *(_WORD *)(a2 + 0x96);
        }
        if ( *((double *)a1 + 0x5C) != 0.0 || *((double *)a1 + 0x5D) != 0.0 || *((double *)a1 + 0x5E) != 0.0 )
        {
          v8 = (*(__int64 (**)(void))(*(_QWORD *)qword_149B4FC78 + 0x108LL))();
          v9 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v8 + 0x20LL))(
                 v8,
                 *((unsigned __int16 *)a1 + 0x17C));
          v10 = *((double *)a1 + 0x49) - *((double *)a1 + 0x5D);
          v11 = *((double *)a1 + 0x48) - *((double *)a1 + 0x5C);
          v12 = *((double *)a1 + 0x4A) - *((double *)a1 + 0x5E);
          v13 = v4 & 0xFFFFFFFFFFFFLL;
          *((_QWORD *)&v14 + 1) = 0;
          *(double *)&v14 = v11 * v11 + v10 * v10 + v12 * v12;
          _XMM2 = v14;
          __asm { vcvtsd2ss xmm2, xmm2, xmm2 }
          v17 = v9;
          (*(void (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(v13 + 0x70) + 0x30LL))(
            v13 + 0x70,
            *((unsigned int *)a1 + 0xBF),
            *(_QWORD *)(v13 + 0x70),
            0);
          (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(v13 + 0x70) + 0x28LL))(
            v13 + 0x70,
            *(unsigned int *)(v17 + 0x30),
            *(unsigned int *)(v17 + 0x34));
        }
      }
    }
    if ( a2 )
    {
      if ( (a1[0x40] & 0x44) == 0 )
      {
        v18 = *((_BYTE *)a1 + 0x1B2);
        v19 = (__int64 *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(a1[1] & 0xFFFFFFFFFFFFLL) + 0x20LL))(a1[1] & 0xFFFFFFFFFFFFLL);
        sub_145D17670(a2, a1[0x18], a1[0x1C], a1[0x3D], a1[0x3E], a1[1], v19, v18);
        sub_143FFEA60((__int64)a1, 4);
        (*(void (__fastcall **)(unsigned __int64 *))(*a1 + 0x600))(a1);
      }
    }
    else
    {
      sub_145D16C80(a1, 0);
    }
  }
  else
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*a1 + 0x620))(a1);
  }
}

// --- End Function: sub_145D31FB0 (0x145D31FB0) ---

// --- Function: sub_145D37BA0 (0x145D37BA0) ---
void __fastcall sub_145D37BA0(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned int a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int128 v9; // xmm11
  __int128 v10; // xmm12
  __int128 v11; // xmm13
  __int128 v12; // xmm14
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  float v20; // xmm0_4
  float v21; // xmm14_4
  __int64 v22; // rax
  __int64 v23; // r15
  _BYTE *p_Src; // rsi
  unsigned __int64 n0x3F_3; // rdi
  size_t n0x3F_1; // rbx
  _BYTE *p_Src_2; // rax
  _BYTE *v28; // rcx
  unsigned __int64 v30; // rdx
  __int64 *v31; // rcx
  __int64 v32; // rax
  __int64 v34; // rbx
  __int64 n0xF000; // rdx
  __int64 v36; // rdi
  bool v37; // al
  unsigned __int64 v38; // rcx
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rax
  __int64 v42; // rax
  unsigned __int64 *v43; // rax
  __int64 v44; // rdi
  __int64 v45; // rbx
  bool v46; // al
  double v47; // rbx
  unsigned __int64 v48; // rax
  __int64 v49; // rsi
  void (__fastcall *v50)(__int64, double *, __int64, __int64); // rdi
  __int64 v51; // rbx
  __int64 v52; // rax
  double *v53; // rax
  double v54; // xmm1_8
  __int64 *v55; // rax
  _QWORD *v56; // rax
  _QWORD *v57; // rbx
  __int64 v58; // rcx
  __int64 (__fastcall *v59)(_QWORD *, _BYTE *, _QWORD); // r9
  float *v60; // rdi
  __int64 v61; // rcx
  double *v62; // rax
  float v63; // xmm13_4
  float v64; // xmm12_4
  float v65; // xmm11_4
  double v66; // xmm10_8
  double v67; // xmm9_8
  double v68; // xmm4_8
  __int64 v69; // rdi
  double v70; // xmm13_8
  double v71; // xmm12_8
  double v72; // xmm11_8
  double v73; // kr00_8
  double v74; // xmm5_8
  double v75; // xmm7_8
  __int128 v76; // kr00_16
  double v77; // xmm6_8
  __int64 v80; // rax
  void (__fastcall *v81)(__int64, double *, __int64, __int64); // rbx
  __int64 v82; // rax
  __int64 v83; // rax
  double *v84; // rax
  __int64 v85; // rax
  __int64 v86; // rdi
  __int128 v87; // xmm0
  double v88; // xmm1_8
  __int64 v89; // rax
  void (__fastcall *v90)(__int64, double *, __int64, __int64); // rbx
  __int64 v91; // rax
  __int128 v93; // xmm4
  __int128 v98; // kr00_16
  __int64 v100; // rbx
  __int64 v101; // rcx
  __int64 v102; // rcx
  volatile signed __int32 *v103; // rbx
  const void *v104; // rcx
  unsigned __int64 v105; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int64 v106; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int64 v107; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v108; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v109; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v110; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v111; // [rsp+60h] [rbp-A0h]
  int n0x23; // [rsp+70h] [rbp-90h] BYREF
  __int64 v113; // [rsp+78h] [rbp-88h]
  _QWORD v114[4]; // [rsp+80h] [rbp-80h] BYREF
  float v116; // [rsp+B0h] [rbp-50h]
  float v117; // [rsp+B4h] [rbp-4Ch]
  float v118; // [rsp+B8h] [rbp-48h]
  float v119; // [rsp+BCh] [rbp-44h]
  __int128 v120; // [rsp+C0h] [rbp-40h] BYREF
  double v121; // [rsp+D0h] [rbp-30h]
  _BYTE v122[8]; // [rsp+D8h] [rbp-28h] BYREF
  _BYTE v123[8]; // [rsp+E0h] [rbp-20h] BYREF
  _BYTE v124[8]; // [rsp+E8h] [rbp-18h] BYREF
  _BYTE v125[8]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v126; // [rsp+F8h] [rbp-8h] BYREF
  __int64 v127; // [rsp+100h] [rbp+0h] BYREF
  _BYTE v128[8]; // [rsp+108h] [rbp+8h] BYREF
  _BYTE v129[8]; // [rsp+110h] [rbp+10h] BYREF
  __int128 v130; // [rsp+118h] [rbp+18h] BYREF
  double v131; // [rsp+128h] [rbp+28h]
  __m256 v132; // [rsp+130h] [rbp+30h] BYREF
  double v133; // [rsp+150h] [rbp+50h]
  double v134[4]; // [rsp+158h] [rbp+58h] BYREF
  __int128 v135; // [rsp+178h] [rbp+78h]
  double v136; // [rsp+188h] [rbp+88h]
  double v137[3]; // [rsp+198h] [rbp+98h] BYREF
  double v138[3]; // [rsp+1B0h] [rbp+B0h] BYREF
  _BYTE v139[32]; // [rsp+1C8h] [rbp+C8h] BYREF
  double v140[7]; // [rsp+1E8h] [rbp+E8h] BYREF
  double v141[7]; // [rsp+220h] [rbp+120h] BYREF
  _BYTE v142[64]; // [rsp+258h] [rbp+158h] BYREF
  _BYTE v143[72]; // [rsp+298h] [rbp+198h] BYREF
  __m256 v144; // [rsp+2E0h] [rbp+1E0h] BYREF
  double v145; // [rsp+300h] [rbp+200h]
  float v146; // [rsp+308h] [rbp+208h]
  float v147; // [rsp+30Ch] [rbp+20Ch]
  float v148; // [rsp+310h] [rbp+210h]
  unsigned __int64 n0x3F_5; // [rsp+318h] [rbp+218h] BYREF
  __int64 n0x3F_4; // [rsp+320h] [rbp+220h]
  void *v151; // [rsp+328h] [rbp+228h]
  _BYTE v152[64]; // [rsp+330h] [rbp+230h] BYREF
  unsigned __int64 v153; // [rsp+370h] [rbp+270h]
  __int64 v154; // [rsp+378h] [rbp+278h]
  __int64 v155; // [rsp+380h] [rbp+280h]
  __int64 v156; // [rsp+388h] [rbp+288h]
  __int128 v157; // [rsp+390h] [rbp+290h]
  __int64 v158; // [rsp+3A0h] [rbp+2A0h]
  __int64 v159; // [rsp+3A8h] [rbp+2A8h]
  float v160; // [rsp+3B0h] [rbp+2B0h]
  char v161; // [rsp+3B4h] [rbp+2B4h]
  __int64 v162; // [rsp+3B8h] [rbp+2B8h]
  volatile signed __int32 *v163; // [rsp+3C0h] [rbp+2C0h]
  char v164; // [rsp+3C8h] [rbp+2C8h]
  int v165; // [rsp+3D0h] [rbp+2D0h]
  double v166; // [rsp+3D8h] [rbp+2D8h]
  __int128 v168; // [rsp+3F0h] [rbp+2F0h]
  __int64 v169; // [rsp+400h] [rbp+300h]
  size_t n0x3F_2; // [rsp+410h] [rbp+310h]
  __int64 n0x3F; // [rsp+418h] [rbp+318h]
  void *p_Src_1; // [rsp+420h] [rbp+320h]
  _BYTE Src[72]; // [rsp+428h] [rbp+328h] BYREF
  __int128 v174; // [rsp+480h] [rbp+380h]
  __int128 v175; // [rsp+490h] [rbp+390h]
  __int128 v176; // [rsp+4A0h] [rbp+3A0h]
  __int128 v177; // [rsp+4B0h] [rbp+3B0h]
  __int128 v178; // [rsp+4C0h] [rbp+3C0h]
  __int128 v179; // [rsp+4D0h] [rbp+3D0h]
  __int128 v180; // [rsp+4E0h] [rbp+3E0h]
  __int128 v181; // [rsp+4F0h] [rbp+3F0h]
  __int128 v182; // [rsp+500h] [rbp+400h]
  unsigned __int64 v183; // [rsp+568h] [rbp+468h] BYREF

  v183 = a2;
  if ( !qword_149B4FC70 || !sub_14030EC00(&v183) )
    return;
  v16 = *(_QWORD *)qword_149B4FBE0;
  v182 = v4;
  v181 = v5;
  v174 = v12;
  v17 = (*(__int64 (**)(void))(v16 + 0x418))();
  v18 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v17 + 0x88LL))(v17, a4, 0);
  if ( v18 && (v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x68LL))(v18)) != 0 )
    v20 = *(float *)(v19 + 4);
  else
    v20 = 20.0;
  v21 = v20 * *(float *)(qword_149E7E430 + 0x1498);
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC70 + 0x88LL))(qword_149B4FC70);
  v23 = 0;
  Src[0] = 0;
  p_Src = Src;
  v111 = v22;
  n0x3F_2 = 0;
  n0x3F_3 = 0;
  p_Src_1 = Src;
  n0x3F = 0x3F;
  n0x3F_1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0x3F_1;
  while ( aBullethit[n0x3F_1] );
  if ( n0x3F_1 )
  {
    p_Src_2 = Src;
    if ( n0x3F_1 + 1 > 0x40 )
    {
      p_Src_2 = (_BYTE *)allocWithProfilerInfo(n0x3F_1 + 1, 0);
      qword_149B473F8 += n0x3F_1 + 1;
      n0x3F = n0x3F_1;
    }
    p_Src_1 = p_Src_2;
    n0x3F_2 = n0x3F_1;
    p_Src_2[n0x3F_1] = 0;
    memcpy(p_Src_1, "BulletHit", n0x3F_1);
    p_Src = p_Src_1;
    n0x3F_3 = n0x3F_2;
  }
  *(_QWORD *)&v144.m256_f32[6] = 0;
  v28 = v152;
  v151 = v152;
  v145 = 0.0;
  v152[0] = 0;
  n0x3F_5 = 0;
  n0x3F_4 = 0x3F;
  _XMM0 = 0;
  *(double *)&v144.m256_f32[4] = 0.0;
  v146 = 0.0;
  v147 = 0.0;
  v148 = 0.0;
  __asm { vmovupd xmmword ptr [rbp+450h+var_270], xmm0 }
  if ( n0x3F_3 > 0x3F )
  {
    sub_1404FA510((__int64 *)&n0x3F_5, n0x3F_3);
    v28 = v151;
  }
  memmove(v28, p_Src, n0x3F_3);
  n0x3F_5 = n0x3F_3;
  *((_BYTE *)v151 + n0x3F_3) = 0;
  v153 = 0;
  v154 = 0;
  v155 = 0;
  v156 = 0;
  v158 = 0;
  v159 = 0;
  v161 = 0xFF;
  v162 = 0;
  v163 = 0;
  v164 = 0;
  v165 = 0;
  v169 = 0;
  v160 = 0.0;
  v166 = 0.0;
  v157 = 0;
  __asm { vmovupd [rbp+450h+var_170], xmm0 }
  v168 = 0;
  if ( p_Src_1 != Src )
  {
    qword_149B473F8 += 0xFFFFFFFFFFFFFFFFuLL - n0x3F;
    sub_147605980(p_Src_1);
  }
  v30 = *(_QWORD *)(a1 + 0x10);
  LODWORD(v159) = 1;
  v153 = v183;
  if ( v30 && *(_QWORD *)((v30 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v30) || (v30 = *(_QWORD *)(a1 + 0x18)) != 0 )
  {
    v31 = (__int64 *)(v30 & 0xFFFFFFFFFFFFLL);
    if ( *(_QWORD *)((v30 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v30) )
    {
      v32 = *v31;
      _XMM0 = 0;
      *(double *)&v114[3] = 0.0;
      v119 = 1.0;
      v116 = 0.0;
      v117 = 0.0;
      v118 = 0.0;
      v113 = 0;
      memset(v114, 0, 0x18);
      __asm { vmovupd [rbp+450h+var_4B0], xmm0 }
      n0x23 = 0x23;
      if ( (*(unsigned int (__fastcall **)(__int64 *, int *))(v32 + 0x28))(v31, &n0x23) )
      {
        v34 = v114[0];
        n0xF000 = 0xF000;
        if ( v114[0] )
        {
          v36 = (v114[0] & 0xF000000000000000uLL) != 0 ? v114[0] & 0xFFFFFF000000LL : (v114[0] & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v36 + 2) == (HIWORD(v114[0]) & 0xFFF) )
          {
            if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v37 = sub_140539D80(), v34 = v114[0], v37) )
              v37 = 1;
            if ( *(_WORD *)(v36 + 4) == 2 && v37 )
              goto LABEL_34;
            if ( sub_140392020(v114) )
            {
              v34 = v114[0];
LABEL_34:
              v38 = v34 & 0xFFFFFFFFFFFFLL;
              v39 = *(_QWORD *)(v34 & 0xFFFFFFFFFFFFLL);
              goto LABEL_37;
            }
          }
        }
        v40 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(
                qword_149B4FC78,
                n0xF000);
        v41 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v40 + 0x1D0LL))(v40);
        (*(void (__fastcall **)(__int64, unsigned __int64 *, unsigned __int64))(*(_QWORD *)v41 + 0x100LL))(
          v41,
          &v107,
          v183);
        if ( !sub_14030EC00(&v107) )
          goto LABEL_38;
        v38 = v107 & 0xFFFFFFFFFFFFLL;
        v39 = *(_QWORD *)(v107 & 0xFFFFFFFFFFFFLL);
LABEL_37:
        v23 = (*(__int64 (__fastcall **)(unsigned __int64))(v39 + 0x668))(v38);
LABEL_38:
        v42 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FBE8 + 0x10LL))(qword_149B4FBE8);
        sub_14035BDF0((__int64)&v132, a1 + 0x48, v42);
        v144 = v132;
        v145 = v133;
        if ( !v23 )
        {
LABEL_58:
          __asm { vzeroupper }
          if ( sub_14030EC00(&v183) )
          {
            v55 = sub_1425D62E0(v183 & 0xFFFFFFFFFFFFLL, &v126);
            v56 = (_QWORD *)sub_140501090(v55);
            v57 = v56;
            if ( v56 )
            {
              v58 = *v56;
              v180 = v6;
              v179 = v7;
              v178 = v8;
              v59 = *(__int64 (__fastcall **)(_QWORD *, _BYTE *, _QWORD))(v58 + 0x5D8);
              v177 = v9;
              v176 = v10;
              v175 = v11;
              v60 = (float *)v59(v56, v139, 0);
              if ( sub_14030EC00(v57 + 1) )
                v61 = v57[1] & 0xFFFFFFFFFFFFLL;
              else
                v61 = 0;
              v62 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v61 + 0x1E8LL))(
                                v61,
                                v142,
                                2);
              v63 = v60[6];
              v64 = v60[5];
              v65 = v60[4];
              v66 = v62[1];
              v67 = v62[2];
              v68 = v62[3];
              v69 = qword_149B4FBE8;
              v70 = v63;
              v71 = v64;
              v72 = v65;
              v73 = v72 * v67 - *v62 * v70 + v68 * v71;
              v74 = (*v62 * v71 - v72 * v66 + v68 * v70) * v66 - v73 * v67;
              v75 = v62[7];
              *((_QWORD *)&v76 + 1) = 0;
              v77 = v73 * *v62 - (v66 * v70 - v67 * v71 + v68 * v72) * v66;
              *(double *)&v76 = (v74 + v72 + v74) * v75 + v62[4];
              _XMM5 = v76;
              __asm { vunpcklpd xmm1, xmm5, xmm3 }
              *(double *)&v76 = (v77 + v70 + v77) * v75 + v62[6];
              v80 = *(_QWORD *)qword_149B4FBE8;
              v136 = *(double *)&v76;
              v135 = _XMM1;
              v130 = _XMM1;
              v81 = *(void (__fastcall **)(__int64, double *, __int64, __int64))(v80 + 0x480);
              v82 = *(_QWORD *)(v183 & 0xFFFFFFFFFFFFLL);
              v131 = *(double *)&v76;
              v83 = (*(__int64 (__fastcall **)(unsigned __int64))(v82 + 0x648))(v183 & 0xFFFFFFFFFFFFLL);
              v81(v69, v141, v83, v23);
              v84 = sub_140337B60((double *)&v120, v141, (double *)&v130);
            }
            else
            {
              v85 = (*(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int64))(*(_QWORD *)(v183 & 0xFFFFFFFFFFFFLL)
                                                                                  + 0x1E8LL))(
                      v183 & 0xFFFFFFFFFFFFLL,
                      v143,
                      2);
              v86 = qword_149B4FBE8;
              v87 = *(_OWORD *)(v85 + 0x20);
              v88 = *(double *)(v85 + 0x30);
              v89 = *(_QWORD *)qword_149B4FBE8;
              v120 = v87;
              v121 = v88;
              v90 = *(void (__fastcall **)(__int64, double *, __int64, __int64))(v89 + 0x480);
              v91 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v183 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v183 & 0xFFFFFFFFFFFFLL);
              v90(v86, v134, v91, v23);
              v84 = sub_140337B60(v138, v134, (double *)&v120);
            }
            _XMM1 = COERCE_UNSIGNED_INT64(*v84 - *(double *)v144.m256_f32);
            v93 = *((unsigned __int64 *)v84 + 2);
            _XMM0 = COERCE_UNSIGNED_INT64(v84[1] - *(double *)&v144.m256_f32[2]);
            __asm
            {
              vcvtsd2ss xmm2, xmm1, xmm1
              vcvtsd2ss xmm1, xmm0, xmm0
            }
            v146 = *(float *)&_XMM2;
            *((_QWORD *)&v98 + 1) = *((_QWORD *)&v93 + 1);
            *(double *)&v98 = *(double *)&v93 - *(double *)&v144.m256_f32[4];
            _XMM2 = v98;
            __asm { vcvtsd2ss xmm0, xmm2, xmm2 }
            v148 = *(float *)&_XMM0;
            v147 = *(float *)&_XMM1;
            sub_1413F3740(v183 & 0xFFFFFFFFFFFFLL, &v108);
            if ( is_valid_handle_typeA(&v108) )
              v161 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v108 & 0xFFFFFFFFFFFFLL) + 0x570LL))(v108 & 0xFFFFFFFFFFFFLL);
            sub_1425D6660(v183 & 0xFFFFFFFFFFFFLL, &v109);
            if ( is_valid_handle_typeA(&v109) )
              HIDWORD(v159) = *(_DWORD *)sub_14396A280(v109 & 0xFFFFFFFFFFFFLL);
          }
          v100 = *sub_14152AE40(v153 & 0xFFFFFFFFFFFFLL, &v127);
          v110 = v100;
          if ( is_valid_handle_typeA(&v110) )
            v101 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)(v100 & 0xFFFFFFFFFFFFLL)
                                                                          + 0x590LL))(
                                v100 & 0xFFFFFFFFFFFFLL,
                                v128);
          else
            v101 = 0;
          v156 = v101;
          if ( a3 )
            v102 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a3 + 0x18LL))(a3, v129);
          else
            v102 = 0;
          v154 = v102;
          v160 = v21;
          (*(void (__fastcall **)(__int64, __m256 *))(*(_QWORD *)v111 + 8LL))(v111, &v144);
          goto LABEL_76;
        }
        __asm { vzeroupper }
        v43 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v23 + 0x38LL))(v23, v122);
        v44 = *(_QWORD *)&v144.m256_f32[6];
        v106 = *v43;
        if ( !*(_QWORD *)&v144.m256_f32[6] )
          goto LABEL_53;
        v45 = (HIWORD(v144.m256_f32[7]) & 0xF000) != 0
            ? *(_QWORD *)&v144.m256_f32[6] & 0xFFFFFF000000LL
            : (*(_QWORD *)&v144.m256_f32[6] & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v45 + 2) != (HIWORD(v144.m256_f32[7]) & 0xFFF) )
          goto LABEL_53;
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v46 = sub_140539D80(), v44 = *(_QWORD *)&v144.m256_f32[6], v46) )
          v46 = 1;
        if ( *(_WORD *)(v45 + 4) != 2 || !v46 )
        {
          if ( !sub_140392020(&v144.m256_f32[6]) )
            goto LABEL_53;
          v44 = *(_QWORD *)&v144.m256_f32[6];
        }
        v47 = v145;
        if ( *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)(v44 & 0xFFFFFFFFFFFFLL) + 8LL))(
                          v44 & 0xFFFFFFFFFFFFLL,
                          v123) == *(_QWORD *)&v47 )
        {
          v48 = *(_QWORD *)&v144.m256_f32[6];
LABEL_54:
          v105 = v48;
          if ( sub_14030EC00(&v105) && sub_14030EC00(&v106) && v106 != v105 )
          {
            v49 = qword_149B4FBE8;
            v50 = *(void (__fastcall **)(__int64, double *, __int64, __int64))(*(_QWORD *)qword_149B4FBE8 + 0x480LL);
            v51 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v106 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v106 & 0xFFFFFFFFFFFFLL);
            v52 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v105 & 0xFFFFFFFFFFFFLL) + 0x668LL))(v105 & 0xFFFFFFFFFFFFLL);
            v50(v49, v140, v52, v51);
            v53 = sub_140337B60(v137, v140, (double *)v144.m256_f32);
            *(_OWORD *)v144.m256_f32 = *(_OWORD *)v53;
            v54 = v53[2];
            *(_QWORD *)&v144.m256_f32[6] = v106;
            *(double *)&v144.m256_f32[4] = v54;
            v145 = *(double *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)(v106 & 0xFFFFFFFFFFFFLL)
                                                                                   + 8LL))(
                                v106 & 0xFFFFFFFFFFFFLL,
                                v125);
          }
          goto LABEL_58;
        }
LABEL_53:
        v48 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, double))(*(_QWORD *)gEnv + 0x120LL))(
                           gEnv,
                           v124,
                           COERCE_DOUBLE(*(_QWORD *)&v145));
        *(_QWORD *)&v144.m256_f32[6] = v48;
        goto LABEL_54;
      }
    }
  }
LABEL_76:
  v103 = v163;
  if ( v163 )
  {
    if ( _InterlockedExchangeAdd(v163 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v103)(v103);
      if ( _InterlockedExchangeAdd(v103 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v103 + 8LL))(v103);
    }
  }
  v104 = (const void *)v157;
  if ( (_QWORD)v157 )
  {
    if ( ((v158 - (_QWORD)v157) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      v104 = *(const void **)(v157 - 8);
      if ( (unsigned __int64)(v157 - (_QWORD)v104 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_1402A3D30(v104);
    v157 = 0;
    v158 = 0;
  }
  if ( v151 != v152 )
  {
    qword_149B473F8 += 0xFFFFFFFFFFFFFFFFuLL - n0x3F_4;
    sub_147605980(v151);
  }
}

// --- End Function: sub_145D37BA0 (0x145D37BA0) ---

// --- Function: sub_145D3E0C0 (0x145D3E0C0) ---
void __fastcall sub_145D3E0C0(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall ***v6)(_QWORD, __int64, __int64, __int64); // rax

  if ( qword_149B4FCF0 )
  {
    v6 = (void (__fastcall ***)(_QWORD, __int64, __int64, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF0 + 0xF0LL))(qword_149B4FCF0);
    if ( v6 )
      (**v6)(v6, a1, a2, a3);
  }
}

// --- End Function: sub_145D3E0C0 (0x145D3E0C0) ---

// --- Function: sub_145D3E120 (0x145D3E120) ---
__int64 __fastcall sub_145D3E120(
        __int64 a1,
        double *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 *a6,
        char a7,
        double *a8)
{
  __int128 v8; // xmm6
  __int128 v9; // xmm7
  __int128 v10; // xmm8
  __int128 v11; // xmm9
  __int128 v12; // xmm10
  __int128 v13; // xmm11
  __int128 v14; // xmm12
  __int128 v15; // xmm13
  __int128 v16; // xmm14
  __int128 v17; // xmm15
  AK::WriteBytesMem *v22; // r12
  double v23; // xmm7_8
  double v24; // xmm8_8
  double v25; // xmm9_8
  double v26; // xmm10_8
  double v27; // xmm11_8
  double v28; // xmm12_8
  double v29; // xmm13_8
  double v30; // xmm14_8
  double v31; // xmm15_8
  double v32; // xmm2_8
  double v33; // xmm1_8
  double v34; // xmm2_8
  __int128 v35; // xmm6
  double v36; // xmm10_8
  double v38; // xmm12_8
  __int128 v41; // kr00_16
  double v44; // xmm7_8
  __int128 v60; // kr00_16
  __int128 v65; // xmm7
  double v66; // xmm3_8
  __int128 v67; // kr00_16
  __int128 v69; // xmm9
  __int64 v71; // rax
  __int64 v72; // rax
  __int64 v73; // r15
  __int64 v74; // rax
  __int128 v76; // kr00_16
  float v82; // kr00_4
  __int64 v83; // rax
  __int64 v84; // rax
  unsigned int event_key_from_source_location; // ebx
  __int64 v86; // rdi
  void (__fastcall *v87)(__int64, _QWORD, unsigned __int64 (__fastcall **)(__int64, __int64)); // rsi
  _QWORD *v88; // rax
  unsigned __int8 v89; // bl
  double v91; // [rsp+38h] [rbp-D0h]
  __int64 v92; // [rsp+38h] [rbp-D0h]
  double v93; // [rsp+40h] [rbp-C8h]
  double v94; // [rsp+40h] [rbp-C8h]
  double v95; // [rsp+48h] [rbp-C0h]
  double v96; // [rsp+50h] [rbp-B8h]
  double v97; // [rsp+68h] [rbp-A0h]
  unsigned __int64 (__fastcall *p_sub_140497F10)(__int64, __int64); // [rsp+70h] [rbp-98h] BYREF
  void (__fastcall *p_sub_140498A60)(int, unsigned __int64 (__fastcall **)(__int64, __int64), unsigned __int64 (__fastcall **)(__int64, __int64)); // [rsp+78h] [rbp-90h]
  _QWORD *v100; // [rsp+80h] [rbp-88h]
  double v101; // [rsp+88h] [rbp-80h]
  __int64 v102; // [rsp+90h] [rbp-78h] BYREF
  __int64 v103; // [rsp+98h] [rbp-70h] BYREF
  int n0x4600; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v105; // [rsp+ACh] [rbp-5Ch]
  int v106; // [rsp+B4h] [rbp-54h]
  unsigned __int64 v107; // [rsp+B8h] [rbp-50h]
  unsigned __int64 v108; // [rsp+C0h] [rbp-48h]
  __int64 v109; // [rsp+C8h] [rbp-40h]
  __int64 v110; // [rsp+D0h] [rbp-38h]
  __m256 v111; // [rsp+F8h] [rbp-10h] BYREF
  __int128 v112; // [rsp+118h] [rbp+10h]
  double v113; // [rsp+128h] [rbp+20h]
  __int128 v114; // [rsp+138h] [rbp+30h]
  __int128 v115; // [rsp+148h] [rbp+40h]
  __int128 v116; // [rsp+158h] [rbp+50h]
  __int128 v117; // [rsp+168h] [rbp+60h]
  __int128 v118; // [rsp+178h] [rbp+70h]
  __int128 v119; // [rsp+188h] [rbp+80h]
  __int128 v120; // [rsp+198h] [rbp+90h]
  __int128 v121; // [rsp+1A8h] [rbp+A0h]
  __int128 v122; // [rsp+1B8h] [rbp+B0h]
  __int128 v123; // [rsp+1C8h] [rbp+C0h]

  v123 = v8;
  v122 = v9;
  v121 = v10;
  v120 = v11;
  v119 = v12;
  v118 = v13;
  v117 = v14;
  v116 = v15;
  v115 = v16;
  v114 = v17;
  n0x4600 = 0x4600;
  v105 = 1;
  v106 = 0;
  v108 = 0;
  v109 = 0;
  v110 = 0;
  v107 = __rdtsc();
  qword_149B4B870(
    &n0x4600,
    &word_149E7187C,
    "ProjectileUtils::TryWhizSound",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\ProjectileUtils.cpp",
    0x2FE);
  HIWORD(n0x4600) = word_149E7187C;
  if ( BYTE1(qword_149B501D6) )
    goto LABEL_30;
  if ( a7 )
    goto LABEL_30;
  v22 = (AK::WriteBytesMem *)(a3 + 0x48);
  if ( !sub_1403C1370(a3 + 0x48) )
    goto LABEL_30;
  if ( (*(_QWORD *)a8 & 0x7FF0000000000000LL) == 0x7FF0000000000000LL )
    goto LABEL_30;
  if ( ((_QWORD)a8[1] & 0x7FF0000000000000LL) == 0x7FF0000000000000LL )
    goto LABEL_30;
  if ( ((_QWORD)a8[2] & 0x7FF0000000000000LL) == 0x7FF0000000000000LL )
    goto LABEL_30;
  v23 = a2[1];
  v24 = *(double *)(a1 + 0x28);
  v25 = *a2;
  v26 = *(double *)(a1 + 0x20);
  v27 = a2[2];
  v28 = *(double *)(a1 + 0x30);
  v29 = v23 - v24;
  v30 = *a2 - v26;
  v31 = v27 - v28;
  if ( v30 * v30 + v29 * v29 + v31 * v31 < 0.0000001192092895507812 )
    goto LABEL_30;
  v93 = v24 - v23;
  v91 = v28 - v27;
  v96 = v26 - v25;
  v32 = (v23 - a8[1]) * (v24 - v23) + (v25 - *a8) * (v26 - v25) + (v27 - a8[2]) * (v28 - v27);
  if ( v32 * v32
     - ((v24 - a8[1]) * (v24 - a8[1])
      + (v26 - *a8) * (v26 - *a8)
      + (v28 - a8[2]) * (v28 - a8[2])
      - (float)(*(float *)(a3 + 0x68) * *(float *)(a3 + 0x68)))
     * ((v24 - v23) * (v24 - v23) + (v26 - v25) * (v26 - v25) + (v28 - v27) * (v28 - v27)) < 0.0 )
    goto LABEL_30;
  v33 = a8[1];
  v34 = a8[2];
  v35 = COERCE_UNSIGNED_INT64(v33 - v24);
  v36 = *a8 - v26;
  _XMM8 = COERCE_UNSIGNED_INT64(v33 - v23);
  v38 = v34 - v28;
  _XMM5 = COERCE_UNSIGNED_INT64(v34 - v27);
  _XMM4 = COERCE_UNSIGNED_INT64(*a8 - v25);
  if ( v36 * v30 + *(double *)&v35 * v29 + v38 * v31 <= 0.0
    || *(double *)&_XMM8 * v93 + *(double *)&_XMM4 * v96 + *(double *)&_XMM5 * v91 <= 0.0 )
  {
LABEL_30:
    v89 = 0;
  }
  else
  {
    *((_QWORD *)&v41 + 1) = *((_QWORD *)&v35 + 1);
    *(double *)&v41 = *(double *)&v35 * *(double *)&v35 + v36 * v36 + v38 * v38;
    _XMM3 = v41;
    if ( *(double *)&_XMM8 * *(double *)&_XMM8
       + *(double *)&_XMM4 * *(double *)&_XMM4
       + *(double *)&_XMM5 * *(double *)&_XMM5 <= *(double *)&v41 )
    {
      _XMM6 = *(_OWORD *)a2;
      v44 = a2[2];
    }
    else
    {
      _XMM6 = *(_OWORD *)(a1 + 0x20);
      v44 = *(double *)(a1 + 0x30);
    }
    _XMM1 = *(unsigned __int64 *)&v93;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm13, xmm1, xmm13, xmm0
    }
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm0, xmm4, xmm10, xmm0
    }
    v94 = *(double *)&_XMM0;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm0, xmm5, xmm12, xmm0
    }
    v101 = *(double *)&_XMM0;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm0, xmm8, xmm1, xmm0
    }
    _XMM1 = *(unsigned __int64 *)&v96;
    v95 = *(double *)&_XMM0;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm4, xmm1, xmm14, xmm0
    }
    _XMM1 = *(unsigned __int64 *)&v91;
    __asm
    {
      vcmpltsd xmm0, xmm3, xmm9
      vblendvpd xmm3, xmm1, xmm15, xmm0
    }
    *((_QWORD *)&v60 + 1) = *((_QWORD *)&_XMM4 + 1);
    *(double *)&v60 = *(double *)&_XMM4 * *(double *)&_XMM4
                    + *(double *)&_XMM13 * *(double *)&_XMM13
                    + *(double *)&_XMM3 * *(double *)&_XMM3;
    _XMM1 = v60;
    v97 = v44;
    if ( *(double *)&v60 <= 0.0 )
    {
      v69 = *(unsigned __int64 *)&v44;
      __asm
      {
        vunpckhpd xmm8, xmm6, xmm6
        vmovupd xmm10, xmm6
      }
    }
    else
    {
      __asm { vmovddup xmm0, xmm1 }
      __asm
      {
        vsqrtpd xmm2, xmm0
        vunpckhpd xmm2, xmm2, xmm2
      }
      v65 = COERCE_UNSIGNED_INT64(1.0 / *(double *)&_XMM2 * *(double *)&_XMM3);
      v66 = 1.0 / *(double *)&_XMM2 * *(double *)&_XMM13 * v95
          + 1.0 / *(double *)&_XMM2 * *(double *)&_XMM4 * v94
          + 1.0 / *(double *)&_XMM2 * *(double *)&_XMM3 * v101;
      *((_QWORD *)&v67 + 1) = 0;
      *(double *)&v67 = 1.0 / *(double *)&_XMM2 * *(double *)&_XMM13 * v66 + *((double *)&_XMM6 + 1);
      _XMM8 = v67;
      *((_QWORD *)&v67 + 1) = *((_QWORD *)&v65 + 1);
      *(double *)&v67 = *(double *)&v65 * v66 + v97;
      v69 = v67;
      *((_QWORD *)&v67 + 1) = 0;
      *(double *)&v67 = 1.0 / *(double *)&_XMM2 * *(double *)&_XMM4 * v66 + *(double *)&_XMM6;
      _XMM10 = v67;
      v44 = *(double *)&v69;
      __asm { vunpcklpd xmm6, xmm10, xmm8 }
    }
    v71 = sub_140970360(qword_149E7E438);
    v72 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v71 + 0x2D8LL))(v71);
    v73 = v72;
    if ( !v72
      || (sub_1403B0A70((unsigned __int64 *)(v72 + 8), &v102), a4 != v102)
      && (a4 == a5
       || (v74 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v73 + 0x6F0LL))(v73)) == 0
       || (sub_1403B0A70((unsigned __int64 *)(v74 + 8), &v103), a5 != v103)) )
    {
      v111 = *(__m256 *)a1;
      v112 = _XMM6;
      v113 = v44;
      __asm { vzeroupper }
      sub_145D30170((__int64)"Whiz", v22, (__int64)&v111, a6);
      *((_QWORD *)&v76 + 1) = *((_QWORD *)&_XMM10 + 1);
      *(double *)&v76 = *(double *)&_XMM10 - *a8;
      _XMM0 = v76;
      *((_QWORD *)&v76 + 1) = *((_QWORD *)&_XMM8 + 1);
      *(double *)&v76 = *(double *)&_XMM8 - a8[1];
      _XMM1 = v76;
      __asm { vcvtsd2ss xmm3, xmm0, xmm0 }
      *((_QWORD *)&v76 + 1) = *((_QWORD *)&v69 + 1);
      *(double *)&v76 = *(double *)&v69 - a8[2];
      _XMM0 = v76;
      __asm
      {
        vcvtsd2ss xmm2, xmm1, xmm1
        vcvtsd2ss xmm4, xmm0, xmm0
      }
      v82 = (float)((float)(*(float *)&_XMM2 * *(float *)&_XMM2) + (float)(*(float *)&_XMM3 * *(float *)&_XMM3))
          + (float)(*(float *)&_XMM4 * *(float *)&_XMM4);
      v83 = sub_1464E7810(qword_149E7E438);
      v84 = sub_14031FF80(v83);
      event_key_from_source_location = event_key_from_source_location_29;
      v86 = v84;
      if ( !event_key_from_source_location_29 )
        event_key_from_source_location = get_event_key_from_source_location(
                                           &event_key_from_source_location_29,
                                           (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/Audio/Game.h",
                                           0x1C);
      *(float *)&v92 = v82;
      HIDWORD(v92) = event_key_from_source_location;
      v87 = *(void (__fastcall **)(__int64, _QWORD, unsigned __int64 (__fastcall **)(__int64, __int64)))(*(_QWORD *)v86 + 0x20LL);
      v88 = (_QWORD *)allocWithProfilerInfo_w(8u);
      if ( v88 )
      {
        *v88 = v92;
        v100 = v88;
      }
      else
      {
        v100 = 0;
      }
      p_sub_140497F10 = sub_140497F10;
      p_sub_140498A60 = sub_140498A60;
      v87(v86, event_key_from_source_location, &p_sub_140497F10);
      if ( (unsigned __int64)p_sub_140498A60 >= 2 )
        ((void (__fastcall *)(__int64, unsigned __int64 (__fastcall **)(__int64, __int64)))p_sub_140498A60)(
          2,
          &p_sub_140497F10);
    }
    v89 = 1;
  }
  v108 = __rdtsc();
  qword_149B4B878(&n0x4600);
  return v89;
}

// --- End Function: sub_145D3E120 (0x145D3E120) ---

// --- Function: sub_145D3E760 (0x145D3E760) ---
char __fastcall sub_145D3E760(__int64 a1, double *a2, __int64 a3, __int64 a4, __int64 a5, __int64 *a6, char a7)
{
  char result; // al
  __int64 v12; // r8
  unsigned __int64 v13; // [rsp+40h] [rbp-28h] BYREF
  double v14[4]; // [rsp+48h] [rbp-20h] BYREF

  (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)qword_149B4FC98 + 0xF8LL))(qword_149B4FC98, &v13);
  result = sub_14030EC00(&v13);
  if ( result )
  {
    LOBYTE(v12) = 1;
    (*(void (__fastcall **)(unsigned __int64, double *, __int64))(*(_QWORD *)(v13 & 0xFFFFFFFFFFFFLL) + 0x2C8LL))(
      v13 & 0xFFFFFFFFFFFFLL,
      v14,
      v12);
    return sub_145D3E120(a1, a2, a3, a4, a5, a6, a7, v14);
  }
  return result;
}

// --- End Function: sub_145D3E760 (0x145D3E760) ---

// --- Function: sub_1462FC8C0 (0x1462FC8C0) ---
bool __fastcall sub_1462FC8C0(__int64 a1, int a2, int a3)
{
  return *(_QWORD *)(a1 + 0x258)
      && a2 >= 0
      && a2 < (unsigned __int64)((*(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x80LL)
                                - *(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x78LL))
                               / 0x18LL)
      && a3 >= 0
      && a3 < (unsigned __int64)((*(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x80LL)
                                - *(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x78LL))
                               / 0x18LL)
      && *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x78LL) + 0x18LL * a2 + 0x10) == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x258) + 0x78LL) + 0x18LL * a3 + 0x10);
}

// --- End Function: sub_1462FC8C0 (0x1462FC8C0) ---

// --- Function: sub_14644AD00 (0x14644AD00) ---
_QWORD *__fastcall sub_14644AD00(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x420);
  return a2;
}

// --- End Function: sub_14644AD00 (0x14644AD00) ---

// --- Function: sub_14645D130 (0x14645D130) ---
_QWORD *__fastcall sub_14645D130(__int64 a1, _QWORD *a2)
{
  __int16 v3; // [rsp+20h] [rbp-38h] BYREF
  _WORD *v4; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v5)(__int64, _BYTE *, _WORD *); // [rsp+30h] [rbp-28h]
  __int64 *v6; // [rsp+38h] [rbp-20h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  _BYTE v8[16]; // [rsp+48h] [rbp-10h] BYREF

  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, _WORD *))(*(_QWORD *)a1 + 0x340LL);
  v4 = sub_14444F060(&v3);
  v6 = (__int64 *)v5(a1, v8, v4);
  v7 = *v6;
  *a2 = v7;
  return a2;
}

// --- End Function: sub_14645D130 (0x14645D130) ---

// --- Function: sub_14645EEC0 (0x14645EEC0) ---
__int64 __fastcall sub_14645EEC0(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+28h] [rbp-80h]
  __int64 v4; // [rsp+78h] [rbp-30h]

  if ( a1[2] <= (unsigned __int64)(a1[4] + 1LL) )
    sub_146475360(a1, 1);
  a1[3] &= a1[2] - 1LL;
  v3 = (a1[2] - 1LL) & (a1[4] + a1[3]);
  if ( !*(_QWORD *)(a1[1] + 8 * v3) )
    *(_QWORD *)(a1[1] + 8 * v3) = std::_Allocate<16,std::_Default_allocate_traits,0>(0x160u);
  v4 = sub_1402A2B80(0x160, *(_QWORD *)(a1[1] + 8 * v3));
  sub_1403624E0(v4, a2);
  result = a1[4] + 1LL;
  a1[4] = result;
  return result;
}

// --- End Function: sub_14645EEC0 (0x14645EEC0) ---

// --- Function: sub_14645F0E0 (0x14645F0E0) ---
__int64 __fastcall sub_14645F0E0(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 _Bytes; // rax
  __int64 result; // rax
  unsigned __int64 v4; // [rsp+20h] [rbp-78h]
  unsigned __int64 v5; // [rsp+30h] [rbp-68h]

  if ( !((a1[4] + a1[3]) % 2uLL) && a1[2] <= (a1[4] + 2LL) / 2uLL )
    sub_1439BE2E0(a1, 1);
  a1[3] &= 2LL * a1[2] - 1;
  v5 = a1[4] + a1[3];
  v4 = (a1[2] - 1LL) & (v5 / 2);
  if ( !*(_QWORD *)(a1[1] + 8 * v4) )
  {
    _Bytes = sub_1402A8570(2u);
    *(_QWORD *)(a1[1] + 8 * v4) = std::_Allocate<16,std::_Default_allocate_traits,0>(_Bytes);
  }
  *(_QWORD *)sub_1402A2B80(8, *(_QWORD *)(a1[1] + 8 * v4) + 8 * (v5 % 2)) = *a2;
  result = a1[4] + 1LL;
  a1[4] = result;
  return result;
}

// --- End Function: sub_14645F0E0 (0x14645F0E0) ---

// --- Function: sub_14645F2F0 (0x14645F2F0) ---
__int64 __fastcall sub_14645F2F0(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+28h] [rbp-90h]
  __int64 v4; // [rsp+40h] [rbp-78h]

  if ( a1[2] <= (unsigned __int64)(a1[4] + 1LL) )
    sub_146474FB0(a1, 1);
  a1[3] &= a1[2] - 1LL;
  v3 = (a1[2] - 1LL) & (a1[4] + a1[3]);
  if ( !*(_QWORD *)(a1[1] + 8 * v3) )
    *(_QWORD *)(a1[1] + 8 * v3) = std::_Allocate<16,std::_Default_allocate_traits,0>(0x168u);
  v4 = sub_1402A2B80(0x168, *(_QWORD *)(a1[1] + 8 * v3));
  sub_1403624E0(v4, a2);
  *(_DWORD *)(v4 + 0x160) = *(_DWORD *)(a2 + 0x160);
  result = a1[4] + 1LL;
  a1[4] = result;
  return result;
}

// --- End Function: sub_14645F2F0 (0x14645F2F0) ---

// --- Function: sub_146460C10 (0x146460C10) ---
__int64 __fastcall sub_146460C10(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 0x48) = 0x3DCCCCCD;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_BYTE *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  result = a1;
  *(_QWORD *)(a1 + 0x58) = 0x3F800000;
  *(_DWORD *)(a1 + 0x70) = 0xBF800000;
  return result;
}

// --- End Function: sub_146460C10 (0x146460C10) ---

// --- Function: sub_146460C40 (0x146460C40) ---
__int64 __fastcall sub_146460C40(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 0x28) = 0x3F800000;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x30) = 0;
  result = a1;
  *(_DWORD *)(a1 + 0x34) = 4;
  *(_DWORD *)(a1 + 0x38) = 0x45D7A000;
  *(_DWORD *)(a1 + 0x3C) = 0x4788B800;
  *(_DWORD *)(a1 + 0x40) = 0x3DCCCCCD;
  *(_DWORD *)(a1 + 0x44) = 0x3F900000;
  *(_DWORD *)(a1 + 0x48) = 0x3F800000;
  *(_DWORD *)(a1 + 0x4C) = 0x3F800000;
  *(_DWORD *)(a1 + 0x50) = 0xBF800000;
  return result;
}

// --- End Function: sub_146460C40 (0x146460C40) ---

// --- Function: sub_146463D30 (0x146463D30) ---
void __fastcall sub_146463D30(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  float *v5; // [rsp+20h] [rbp-3C8h]
  char is_equal; // [rsp+30h] [rbp-3B8h]
  char v7; // [rsp+34h] [rbp-3B4h]
  float v8; // [rsp+3Ch] [rbp-3ACh]
  float v9; // [rsp+44h] [rbp-3A4h]
  unsigned int v10; // [rsp+48h] [rbp-3A0h]
  unsigned int v11; // [rsp+48h] [rbp-3A0h]
  float v12; // [rsp+5Ch] [rbp-38Ch]
  int n0x10; // [rsp+64h] [rbp-384h]
  float v14; // [rsp+68h] [rbp-380h]
  unsigned int v15; // [rsp+80h] [rbp-368h]
  unsigned int v16; // [rsp+88h] [rbp-360h]
  __int64 v17; // [rsp+90h] [rbp-358h]
  float dst__2[4]; // [rsp+98h] [rbp-350h] BYREF
  __int64 v19; // [rsp+A8h] [rbp-340h] BYREF
  __int64 v20; // [rsp+B0h] [rbp-338h]
  __int64 v21; // [rsp+B8h] [rbp-330h]
  float *v22; // [rsp+C0h] [rbp-328h]
  float *v23; // [rsp+C8h] [rbp-320h]
  float *v24; // [rsp+D0h] [rbp-318h]
  float *v25; // [rsp+D8h] [rbp-310h]
  float *v26; // [rsp+E0h] [rbp-308h]
  float *v27; // [rsp+E8h] [rbp-300h]
  __int64 v28; // [rsp+F0h] [rbp-2F8h]
  __int64 v29; // [rsp+F8h] [rbp-2F0h]
  __int64 v30; // [rsp+100h] [rbp-2E8h]
  __int64 v31; // [rsp+108h] [rbp-2E0h]
  __int64 v32; // [rsp+110h] [rbp-2D8h]
  __int64 v33; // [rsp+118h] [rbp-2D0h]
  __int64 v34; // [rsp+120h] [rbp-2C8h]
  __int64 v35; // [rsp+128h] [rbp-2C0h]
  __int64 v36; // [rsp+130h] [rbp-2B8h]
  __int64 v37; // [rsp+138h] [rbp-2B0h]
  float *dst; // [rsp+140h] [rbp-2A8h]
  float dst__3[3]; // [rsp+148h] [rbp-2A0h] BYREF
  __int64 *v40; // [rsp+158h] [rbp-290h]
  __int64 v41; // [rsp+160h] [rbp-288h]
  void (__fastcall *v42)(__int64, _BYTE *, _BYTE *, __int64, int); // [rsp+168h] [rbp-280h]
  __int64 (__fastcall *v43)(__int64, _BYTE *); // [rsp+170h] [rbp-278h]
  struct std::pmr::memory_resource *v44; // [rsp+178h] [rbp-270h]
  std::pmr::_Identity_equal_resource *v45; // [rsp+180h] [rbp-268h]
  float *v46; // [rsp+188h] [rbp-260h]
  float *v47; // [rsp+190h] [rbp-258h]
  void (__fastcall *v48)(__int64, _BYTE *, _BYTE *, __int64, int); // [rsp+198h] [rbp-250h]
  void (__fastcall *v49)(__int64, __int64 *, _BYTE *, __int64, int); // [rsp+1A0h] [rbp-248h]
  __int64 (__fastcall *v50)(__int64, const char *, _QWORD, _QWORD, _DWORD); // [rsp+1A8h] [rbp-240h]
  float *v51; // [rsp+1B0h] [rbp-238h]
  void (__fastcall *v52)(__int64, _QWORD, _BYTE *); // [rsp+1B8h] [rbp-230h]
  __int64 (__fastcall *v53)(__int64, const char *, _QWORD, _QWORD, float *); // [rsp+1C0h] [rbp-228h]
  float *v54; // [rsp+1C8h] [rbp-220h]
  void (__fastcall *v55)(__int64, _QWORD, _BYTE *); // [rsp+1D0h] [rbp-218h]
  __int64 (__fastcall *v56)(__int64, __int64 *); // [rsp+1D8h] [rbp-210h]
  _BYTE dst_[24]; // [rsp+1E0h] [rbp-208h] BYREF
  _BYTE dst__1[24]; // [rsp+1F8h] [rbp-1F0h] BYREF
  float v59; // [rsp+210h] [rbp-1D8h]
  float v60; // [rsp+214h] [rbp-1D4h]
  float v61; // [rsp+218h] [rbp-1D0h]
  float v62; // [rsp+21Ch] [rbp-1CCh]
  unsigned int n0x10_1; // [rsp+220h] [rbp-1C8h]
  int v64; // [rsp+224h] [rbp-1C4h]
  float v65; // [rsp+228h] [rbp-1C0h]
  int v66; // [rsp+22Ch] [rbp-1BCh]
  _BYTE dst__4[12]; // [rsp+230h] [rbp-1B8h] BYREF
  __int64 v68; // [rsp+248h] [rbp-1A0h]
  __int64 v69; // [rsp+270h] [rbp-178h] BYREF
  _BYTE dst__5[24]; // [rsp+278h] [rbp-170h] BYREF
  _DWORD dst__6[16]; // [rsp+290h] [rbp-158h] BYREF
  _BYTE v72[8]; // [rsp+2D8h] [rbp-110h] BYREF
  __m128 v73; // [rsp+2E0h] [rbp-108h]
  __int128 v74; // [rsp+2F0h] [rbp-F8h]
  __int128 v75; // [rsp+300h] [rbp-E8h]
  __m128 v76; // [rsp+310h] [rbp-D8h]
  float v77[4]; // [rsp+320h] [rbp-C8h] BYREF
  float v78[4]; // [rsp+330h] [rbp-B8h] BYREF
  __int128 v79; // [rsp+340h] [rbp-A8h]
  _BYTE v80[112]; // [rsp+350h] [rbp-98h] BYREF

  v7 = 0;
  sub_146460C10((__int64)dst_);
  qmemcpy(dst_, (const void *)(a2 + 0x60), sizeof(dst_));
  v59 = *(float *)(a2 + 0x90);
  v60 = *(float *)(a2 + 0x94);
  if ( v60 >= 0.000099999997 )
    v12 = v60;
  else
    v12 = 0.000099999997;
  v60 = v12;
  v61 = v59;
  v62 = 0.0;
  qmemcpy(dst__1, (const void *)(a2 + 0x60), sizeof(dst__1));
  v8 = (float)((float)(*(float *)(a2 + 0x78) * *(float *)(a2 + 0x78))
             + (float)(*(float *)(a2 + 0x7C) * *(float *)(a2 + 0x7C)))
     + (float)(*(float *)(a2 + 0x80) * *(float *)(a2 + 0x80));
  if ( v8 <= 0.00000011920929 )
  {
    qmemcpy(dst__2, &n0x3FC00000, 0xCu);
  }
  else
  {
    v76 = _mm_shuffle_ps((__m128)LODWORD(v8), (__m128)LODWORD(v8), 0);
    v73 = v76;
    __asm { vrsqrtps xmm0, [rsp+3E8h+var_108] }
    v74 = _XMM0;
    v75 = _XMM0;
    v79 = _XMM0;
    v9 = *((float *)&_XMM0 + 3)
       * (float)(1.5 - (float)((float)((float)(v8 * *((float *)&_XMM0 + 3)) * *((float *)&_XMM0 + 3)) * 0.5));
    qmemcpy(dst__3, (const void *)(a2 + 0x78), sizeof(dst__3));
    dst__2[0] = dst__3[0] * v9;
    dst__2[1] = dst__3[1] * v9;
    dst__2[2] = dst__3[2] * v9;
  }
  dst = dst__2;
  qmemcpy(dst__4, dst__2, sizeof(dst__4));
  v64 = 0;
  if ( a4 )
  {
    v56 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a4 + 0x18LL);
    v7 = 1;
    v40 = (__int64 *)v56(a4, &v19);
    v17 = *v40;
  }
  else
  {
    v17 = 0;
  }
  v68 = v17;
  if ( (v7 & 1) != 0 )
  {
    v41 = 0;
    if ( v19 )
      sub_140522CF0(v19);
  }
  v65 = 0.07;
  sub_140455210((__int64)v80);
  sub_146467000(a1, a2, v80);
  v66 = *(_DWORD *)(a2 + 0xB0);
  if ( v60 <= 50.0 )
    n0x10 = 0x10;
  else
    n0x10 = 0;
  n0x10_1 = n0x10;
  v20 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x20);
  v42 = *(void (__fastcall **)(__int64, _BYTE *, _BYTE *, __int64, int))(*(_QWORD *)v20 + 0x200LL);
  v42(v20, dst_, v80, 0x16, 0x1E);
  is_equal = *(_BYTE *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x2A0);
  if ( *(_BYTE *)(a2 + 0xE5) && sub_14037F610(*(_QWORD *)(a2 + 8), 0) )
  {
    v44 = *(struct std::pmr::memory_resource **)(a2 + 8);
    v21 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x98);
    v43 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v21 + 0x78LL);
    v45 = *(std::pmr::_Identity_equal_resource **)v43(v21, v72);
    is_equal = std::pmr::_Identity_equal_resource::do_is_equal(v45, v44);
  }
  if ( is_equal )
  {
    sub_14648CE80(a1, a3, dst_, a4);
    sub_146489B70(a1, a2, a3);
  }
  v62 = *(float *)(a2 + 0xAC);
  v22 = (float *)(a2 + 0xA0);
  v23 = (float *)(a2 + 0x9C);
  if ( *(float *)(a2 + 0x9C) <= *(float *)(a2 + 0xA0) )
    v24 = v23;
  else
    v24 = v22;
  v46 = v24;
  v59 = *v24;
  v25 = (float *)(a2 + 0xA0);
  v26 = (float *)(a2 + 0x9C);
  if ( *(float *)(a2 + 0xA0) <= *(float *)(a2 + 0x9C) )
    v27 = v26;
  else
    v27 = v25;
  v47 = v27;
  v60 = *v27;
  if ( v60 < 0.00000011920929 )
    v60 = 0.1;
  v61 = v59;
  n0x10_1 = 0xFFFFFFFF;
  v28 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x20);
  v48 = *(void (__fastcall **)(__int64, _BYTE *, _BYTE *, __int64, int))(*(_QWORD *)v28 + 0x200LL);
  v48(v28, dst_, v80, 0x80017, 0x1E);
  if ( *(_BYTE *)(a2 + 0x12C) )
  {
    sub_146460C40((__int64)&v69);
    v69 = v68;
    qmemcpy(dst__5, dst__1, sizeof(dst__5));
    qmemcpy(dst__6, (const void *)(a2 + 0x134), 0x10u);
    *(float *)&dst__6[4] = v60;
    dst__6[5] = *(_DWORD *)(a2 + 0x130);
    dst__6[6] = *(_DWORD *)(a2 + 0x144);
    if ( *(float *)(a2 + 0x148) < 0.0 )
      v14 = v62;
    else
      v14 = *(float *)(a2 + 0x148);
    *(float *)&dst__6[7] = v14;
    dst__6[8] = *(_DWORD *)(a2 + 0x14C);
    dst__6[9] = *(_DWORD *)(a2 + 0x150);
    dst__6[0xA] = *(_DWORD *)(a2 + 0x154);
    dst__6[0xB] = *(_DWORD *)(a2 + 0x158);
    v29 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x20);
    v49 = *(void (__fastcall **)(__int64, __int64 *, _BYTE *, __int64, int))(*(_QWORD *)v29 + 0x208LL);
    v49(v29, &v69, v80, 0x17, 0x1E);
  }
  if ( *(int *)(qword_149E7E430 + 0x1A8) > 0 && a4 )
  {
    v30 = sub_140970360(qword_149E7E438);
    v31 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v30 + 0x330LL))(v30);
    v50 = *(__int64 (__fastcall **)(__int64, const char *, _QWORD, _QWORD, _DWORD))(*(_QWORD *)v31 + 8LL);
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 0x1F8LL))(a4);
    v10 = v50(v31, "MinExplosionRadius", 0, v15, 0);
    v32 = sub_140970360(qword_149E7E438);
    v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x330LL))(v32);
    v52 = *(void (__fastcall **)(__int64, _QWORD, _BYTE *))(*(_QWORD *)v33 + 0x10LL);
    v77[0] = 0.0;
    v77[1] = 0.50199997;
    v77[2] = 0.0;
    v77[3] = 1.0;
    v51 = v77;
    v5 = v77;
    v52(v33, v10, dst_);
    v34 = sub_140970360(qword_149E7E438);
    v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x330LL))(v34);
    v53 = *(__int64 (__fastcall **)(__int64, const char *, _QWORD, _QWORD, float *))(*(_QWORD *)v35 + 8LL);
    v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 0x1F8LL))(a4);
    LODWORD(v5) = 0;
    v11 = v53(v35, "ExplosionRadius", 0, v16, v5);
    v36 = sub_140970360(qword_149E7E438);
    v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x330LL))(v36);
    v55 = *(void (__fastcall **)(__int64, _QWORD, _BYTE *))(*(_QWORD *)v37 + 0x10LL);
    v78[0] = 1.0;
    v78[1] = 0.0;
    v78[2] = 0.0;
    v78[3] = 1.0;
    v54 = v78;
    v55(v37, v11, dst_);
  }
  sub_1404640D0((__int64)v80);
}

// --- End Function: sub_146463D30 (0x146463D30) ---

// --- Function: sub_146465830 (0x146465830) ---
const ULONG_PTR *__fastcall sub_146465830(__int64 a1, __int64 a2)
{
  void *v2; // rsp
  __int64 v4; // rdx
  void *v5; // rsp
  void *v6; // rsp
  __int64 v7; // rax
  __int64 v8; // [rsp+18h] [rbp-2B8h]
  _BYTE v9[176]; // [rsp+30h] [rbp-2A0h] BYREF
  __int64 v10; // [rsp+F8h] [rbp-1D8h]
  _BYTE v11[368]; // [rsp+110h] [rbp-1C0h] BYREF
  char v12; // [rsp+2D0h] [rbp+0h]
  char v13; // [rsp+2D1h] [rbp+1h]
  char v14; // [rsp+2D2h] [rbp+2h]
  char v15; // [rsp+2D3h] [rbp+3h]
  __int64 v17; // [rsp+2D8h] [rbp+8h]
  char v18; // [rsp+2E0h] [rbp+10h]
  char v19; // [rsp+2E1h] [rbp+11h]
  char v20; // [rsp+2E2h] [rbp+12h]
  char v21; // [rsp+2E3h] [rbp+13h]
  char v22; // [rsp+2E4h] [rbp+14h]
  char v23; // [rsp+2E5h] [rbp+15h]
  _QWORD *v24; // [rsp+2E8h] [rbp+18h]
  int v25; // [rsp+2F0h] [rbp+20h]
  int v26; // [rsp+2F4h] [rbp+24h]
  int v27; // [rsp+2F8h] [rbp+28h]
  _QWORD *v28; // [rsp+300h] [rbp+30h]
  __int64 v29; // [rsp+308h] [rbp+38h]
  __int64 v30; // [rsp+310h] [rbp+40h]
  __int64 v31; // [rsp+318h] [rbp+48h]
  __int64 v32; // [rsp+320h] [rbp+50h] BYREF
  __int64 v33; // [rsp+328h] [rbp+58h] BYREF
  unsigned int v34; // [rsp+330h] [rbp+60h] BYREF
  int v35; // [rsp+334h] [rbp+64h]
  __int64 v36; // [rsp+338h] [rbp+68h]
  __int64 v37; // [rsp+340h] [rbp+70h]
  _DWORD v38[2]; // [rsp+348h] [rbp+78h] BYREF
  char v39; // [rsp+350h] [rbp+80h] BYREF
  _DWORD v40[2]; // [rsp+358h] [rbp+88h] BYREF
  char v41; // [rsp+360h] [rbp+90h] BYREF
  _DWORD v42[2]; // [rsp+368h] [rbp+98h] BYREF
  char v43; // [rsp+370h] [rbp+A0h] BYREF
  _DWORD v44[2]; // [rsp+378h] [rbp+A8h] BYREF
  char v45; // [rsp+380h] [rbp+B0h] BYREF
  _DWORD v46[2]; // [rsp+388h] [rbp+B8h] BYREF
  char v47; // [rsp+390h] [rbp+C0h] BYREF
  _DWORD v48[2]; // [rsp+398h] [rbp+C8h] BYREF
  char v49; // [rsp+3A0h] [rbp+D0h] BYREF
  __int64 v50; // [rsp+3A8h] [rbp+D8h] BYREF
  __int64 v51; // [rsp+3B0h] [rbp+E0h]
  __int64 v52; // [rsp+3B8h] [rbp+E8h] BYREF
  __int64 v53; // [rsp+3C0h] [rbp+F0h]
  __int64 v54; // [rsp+3C8h] [rbp+F8h]
  __int64 v55; // [rsp+3D0h] [rbp+100h]
  __int64 v56; // [rsp+3D8h] [rbp+108h]
  __int64 v57; // [rsp+3E0h] [rbp+110h]
  const char *p_unknown; // [rsp+3E8h] [rbp+118h]
  _BYTE *v59; // [rsp+3F0h] [rbp+120h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+3F8h] [rbp+128h]
  __int64 v61; // [rsp+400h] [rbp+130h]
  __int64 v62; // [rsp+408h] [rbp+138h]
  __int64 v63; // [rsp+410h] [rbp+140h]
  __int64 v64; // [rsp+418h] [rbp+148h]
  _BYTE *v65; // [rsp+420h] [rbp+150h]
  vraudio::AudioBuffer *__Val_0___1; // [rsp+428h] [rbp+158h]
  __int64 v67; // [rsp+430h] [rbp+160h]
  __int64 v68; // [rsp+438h] [rbp+168h]
  __int64 v69; // [rsp+440h] [rbp+170h]
  __int64 v70; // [rsp+448h] [rbp+178h]
  const char *p_unknown_1; // [rsp+450h] [rbp+180h]
  __int64 v72; // [rsp+458h] [rbp+188h] BYREF
  const char *p_unknown_2; // [rsp+460h] [rbp+190h]
  _BYTE *v74; // [rsp+468h] [rbp+198h]
  vraudio::AudioBuffer *__Val_0___2; // [rsp+470h] [rbp+1A0h]
  __int64 v76; // [rsp+478h] [rbp+1A8h] BYREF
  __int64 v77; // [rsp+480h] [rbp+1B0h] BYREF
  ULONG_PTR Parameter; // [rsp+488h] [rbp+1B8h]
  _QWORD *v79; // [rsp+490h] [rbp+1C0h]
  __int64 *ThreadLogContextSlot_2; // [rsp+498h] [rbp+1C8h]
  const void *v81; // [rsp+4A0h] [rbp+1D0h]
  const void *v82; // [rsp+4A8h] [rbp+1D8h]
  double (__fastcall *v83)(_QWORD); // [rsp+4B0h] [rbp+1E0h]
  __int64 v84; // [rsp+4B8h] [rbp+1E8h]
  __int64 *v85; // [rsp+4C0h] [rbp+1F0h]
  __int64 v86; // [rsp+4C8h] [rbp+1F8h]
  __int64 v87; // [rsp+4D0h] [rbp+200h]
  __int64 *v88; // [rsp+4D8h] [rbp+208h]
  __int64 v89; // [rsp+4E0h] [rbp+210h]
  __int64 v90; // [rsp+4E8h] [rbp+218h]
  __int64 *v91; // [rsp+4F0h] [rbp+220h]
  __int64 v92; // [rsp+4F8h] [rbp+228h]
  double (__fastcall *v93)(_QWORD); // [rsp+500h] [rbp+230h]
  unsigned __int64 v94; // [rsp+508h] [rbp+238h]
  _QWORD v95[2]; // [rsp+510h] [rbp+240h] BYREF
  unsigned __int8 (__fastcall *v96)(__int64, const char *, unsigned int *); // [rsp+520h] [rbp+250h]
  void (__fastcall *v97)(__int64, _QWORD, __int64, _QWORD); // [rsp+528h] [rbp+258h]
  __int64 (__fastcall *v98)(__int64, _BYTE *); // [rsp+530h] [rbp+260h]
  __int64 *v99; // [rsp+538h] [rbp+268h]
  __int64 v100; // [rsp+540h] [rbp+270h]
  __int64 v101; // [rsp+548h] [rbp+278h]
  __int64 v102; // [rsp+550h] [rbp+280h]
  __int64 *v103; // [rsp+558h] [rbp+288h]
  __int64 v104; // [rsp+560h] [rbp+290h]
  _QWORD *v105; // [rsp+568h] [rbp+298h]
  _QWORD *v106; // [rsp+570h] [rbp+2A0h]
  _QWORD *v107; // [rsp+578h] [rbp+2A8h]
  _QWORD *v108; // [rsp+580h] [rbp+2B0h]
  _QWORD *v109; // [rsp+588h] [rbp+2B8h]
  __int64 *ThreadLogContextSlot; // [rsp+590h] [rbp+2C0h]
  const void *v111; // [rsp+598h] [rbp+2C8h]
  const void *v112; // [rsp+5A0h] [rbp+2D0h]
  const void *v113; // [rsp+5A8h] [rbp+2D8h]
  double (__fastcall *v114)(_QWORD); // [rsp+5B0h] [rbp+2E0h]
  __int64 (__fastcall *v115)(__int64, __int64); // [rsp+5B8h] [rbp+2E8h]
  __int64 (__fastcall *v116)(__int64, _BYTE *); // [rsp+5C0h] [rbp+2F0h]
  __int64 *v117; // [rsp+5C8h] [rbp+2F8h]
  __int64 v118; // [rsp+5D0h] [rbp+300h]
  __int64 v119; // [rsp+5D8h] [rbp+308h]
  __int64 v120; // [rsp+5E0h] [rbp+310h]
  __int64 *v121; // [rsp+5E8h] [rbp+318h]
  __int64 v122; // [rsp+5F0h] [rbp+320h]
  _QWORD *v123; // [rsp+5F8h] [rbp+328h]
  _QWORD *v124; // [rsp+600h] [rbp+330h]
  _QWORD *v125; // [rsp+608h] [rbp+338h]
  _QWORD *v126; // [rsp+610h] [rbp+340h]
  _QWORD *v127; // [rsp+618h] [rbp+348h]
  __int64 *ThreadLogContextSlot_1; // [rsp+620h] [rbp+350h]
  const void *v129; // [rsp+628h] [rbp+358h]
  const void *v130; // [rsp+630h] [rbp+360h]
  const void *v131; // [rsp+638h] [rbp+368h]
  __int64 *v132; // [rsp+640h] [rbp+370h]
  __int64 v133; // [rsp+648h] [rbp+378h]
  __int64 *v134; // [rsp+650h] [rbp+380h]
  __int64 v135; // [rsp+658h] [rbp+388h]
  void (__fastcall *v136)(__int64, __int64); // [rsp+660h] [rbp+390h]
  __int64 v137; // [rsp+668h] [rbp+398h]
  __int64 v138; // [rsp+670h] [rbp+3A0h]
  __int64 v139; // [rsp+678h] [rbp+3A8h]
  __int64 v140; // [rsp+680h] [rbp+3B0h]
  __int64 v141; // [rsp+688h] [rbp+3B8h]
  __int64 v142; // [rsp+690h] [rbp+3C0h]
  __int64 (__fastcall *v143)(__int64, _BYTE *); // [rsp+698h] [rbp+3C8h]
  _QWORD *v144; // [rsp+6A0h] [rbp+3D0h]
  __int64 v145; // [rsp+6A8h] [rbp+3D8h]
  double (__fastcall *v146)(_QWORD); // [rsp+6B0h] [rbp+3E0h]
  double (__fastcall *v147)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+6B8h] [rbp+3E8h]
  __int64 v148; // [rsp+6C0h] [rbp+3F0h]
  __int64 *v149; // [rsp+6C8h] [rbp+3F8h]
  __int64 v150; // [rsp+6D0h] [rbp+400h]
  _QWORD *v151; // [rsp+6D8h] [rbp+408h]
  _QWORD *v152; // [rsp+6E0h] [rbp+410h]
  _QWORD dst_[10]; // [rsp+6F0h] [rbp+420h] BYREF
  _QWORD v154[2]; // [rsp+740h] [rbp+470h] BYREF
  const void *v155; // [rsp+750h] [rbp+480h]
  _QWORD v156[2]; // [rsp+758h] [rbp+488h] BYREF
  const void *v157; // [rsp+768h] [rbp+498h]
  _QWORD v158[2]; // [rsp+770h] [rbp+4A0h] BYREF
  const void *v159; // [rsp+780h] [rbp+4B0h]
  _QWORD v160[2]; // [rsp+788h] [rbp+4B8h] BYREF
  const void *v161; // [rsp+798h] [rbp+4C8h]
  _QWORD v162[2]; // [rsp+7A0h] [rbp+4D0h] BYREF
  const void *v163; // [rsp+7B0h] [rbp+4E0h]
  _QWORD v164[2]; // [rsp+7B8h] [rbp+4E8h] BYREF
  const void *v165; // [rsp+7C8h] [rbp+4F8h]
  _QWORD v166[2]; // [rsp+7D0h] [rbp+500h] BYREF
  const void *v167; // [rsp+7E0h] [rbp+510h]
  _QWORD v168[2]; // [rsp+7E8h] [rbp+518h] BYREF
  const void *v169; // [rsp+7F8h] [rbp+528h]
  _QWORD v170[2]; // [rsp+800h] [rbp+530h] BYREF
  _QWORD v171[2]; // [rsp+810h] [rbp+540h] BYREF
  _QWORD src_[2]; // [rsp+820h] [rbp+550h] BYREF
  _QWORD src__1[2]; // [rsp+830h] [rbp+560h] BYREF
  _QWORD v174[2]; // [rsp+840h] [rbp+570h] BYREF
  _QWORD src__2[2]; // [rsp+850h] [rbp+580h] BYREF
  _QWORD src__3[2]; // [rsp+860h] [rbp+590h] BYREF
  _QWORD src__4[2]; // [rsp+870h] [rbp+5A0h] BYREF
  _QWORD src__5[2]; // [rsp+880h] [rbp+5B0h] BYREF
  _QWORD v179[2]; // [rsp+890h] [rbp+5C0h] BYREF
  char v180; // [rsp+8A0h] [rbp+5D0h]
  _QWORD v181[2]; // [rsp+8A8h] [rbp+5D8h] BYREF
  char v182; // [rsp+8B8h] [rbp+5E8h]
  _QWORD v183[2]; // [rsp+8C0h] [rbp+5F0h] BYREF
  char v184; // [rsp+8D0h] [rbp+600h]
  _QWORD v185[2]; // [rsp+8D8h] [rbp+608h] BYREF
  char v186; // [rsp+8E8h] [rbp+618h]
  _QWORD v187[2]; // [rsp+8F0h] [rbp+620h] BYREF
  char v188; // [rsp+900h] [rbp+630h]
  _QWORD v189[2]; // [rsp+908h] [rbp+638h] BYREF
  _BYTE dst__5[16]; // [rsp+918h] [rbp+648h] BYREF
  __int64 dst__6[2]; // [rsp+928h] [rbp+658h] BYREF
  _BYTE dst__1[16]; // [rsp+938h] [rbp+668h] BYREF
  __int64 dst__2[2]; // [rsp+948h] [rbp+678h] BYREF
  _BYTE dst__3[16]; // [rsp+958h] [rbp+688h] BYREF
  __int64 dst__4[3]; // [rsp+968h] [rbp+698h] BYREF
  _QWORD v196[2]; // [rsp+980h] [rbp+6B0h] BYREF
  _BYTE v197[8]; // [rsp+990h] [rbp+6C0h] BYREF
  __int64 v198; // [rsp+998h] [rbp+6C8h] BYREF
  _QWORD v199[2]; // [rsp+9A0h] [rbp+6D0h] BYREF
  _BYTE v200[8]; // [rsp+9B0h] [rbp+6E0h] BYREF
  _QWORD v201[2]; // [rsp+9B8h] [rbp+6E8h] BYREF
  _BYTE v202[8]; // [rsp+9C8h] [rbp+6F8h] BYREF
  __int64 v203; // [rsp+9D0h] [rbp+700h] BYREF
  _QWORD v204[3]; // [rsp+9D8h] [rbp+708h] BYREF
  _QWORD buf_[6]; // [rsp+9F0h] [rbp+720h] BYREF
  unsigned __int64 v206[2]; // [rsp+A20h] [rbp+750h] BYREF
  unsigned __int64 v207[2]; // [rsp+A30h] [rbp+760h] BYREF
  unsigned __int64 v208[23]; // [rsp+A40h] [rbp+770h] BYREF
  int v209; // [rsp+AFCh] [rbp+82Ch]
  int v210; // [rsp+B00h] [rbp+830h]
  __int64 v211[44]; // [rsp+B80h] [rbp+8B0h] BYREF
  int v212; // [rsp+CE0h] [rbp+A10h]

  sub_1402AE3D0(&v33, "CGameRules::ClientHit", a1 + 0x6E40, 1);
  sub_1402B15B0(dst_);
  memset(buf_, 0, sizeof(buf_));
  qmemcpy(dst_, sub_1402B15B0(buf_), 0x30u);
  dst_[2] = __rdtsc();
  HIDWORD(dst_[0]) = 1;
  BYTE4(dst_[1]) = 0;
  LOWORD(dst_[0]) = 0x4600;
  v147 = qword_149B4B870;
  qword_149B4B870(
    dst_,
    &word_149E7DCA0,
    "CGameRules::ClientHit",
    "W:/p4-src/CryEngine/Code/GameSDK/GameDll/GameRulesClientServer.cpp",
    0x7C);
  WORD1(dst_[0]) = word_149E7DCA0;
  if ( sub_14030EC00((unsigned __int64 *)(a2 + 8)) )
  {
    v84 = sub_14030ECF0((_QWORD *)(a2 + 8));
    v85 = sub_14033B1A0(v84, &v203);
    v86 = *v85;
    v76 = v86;
    if ( AssetMeta::HasActorSubresource(&v76) )
      v17 = v76 & 0xFFFFFFFFFFFFLL;
    else
      v17 = 0;
    if ( v17 )
    {
      v28 = 0;
    }
    else
    {
      v87 = sub_14030ECF0((_QWORD *)(a2 + 8));
      v88 = sub_1425D62E0(v87, v204);
      v89 = *v88;
      v77 = v89;
      v28 = (_QWORD *)v204[1];
      if ( is_valid_handle_typeA(&v77) )
        v28 = (_QWORD *)(v77 & 0xFFFFFFFFFFFFLL);
      else
        v28 = 0;
    }
    v24 = v28;
    if ( v17 || v24 )
    {
      v29 = 0;
    }
    else
    {
      v90 = sub_14030ECF0((_QWORD *)(a2 + 8));
      v91 = sub_14645D130(v90, v189);
      v92 = *v91;
      v50 = v92;
      v29 = dst__4[2];
      if ( Handle::IsValid(&v50) )
        v29 = v50 & 0xFFFFFFFFFFFFLL;
      else
        v29 = 0;
    }
    v51 = v29;
    if ( v29 )
    {
      sub_144462BB0(v51, a2);
      v19 = 0;
      dst_[3] = __rdtsc();
      v93 = qword_149B4B878;
      qword_149B4B878(dst_);
      return sub_1402B1820(&v33);
    }
    else if ( v24 && sub_145C26F50((__int64)v24) )
    {
      v20 = 0;
      v21 = 1;
      _StarEngineModule__(0);
      v94 = v24[1];
      sub_141F6B8A0(v95, v94);
      v95[1] = v95[0];
      v52 = v95[0];
      if ( is_valid_handle_typeA(&v52) )
        v30 = v52 & 0xFFFFFFFFFFFFLL;
      else
        v30 = 0;
      if ( v30 )
      {
        v53 = sub_140970360(qword_149E7E438);
        v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x160LL))(v53);
        v96 = *(unsigned __int8 (__fastcall **)(__int64, const char *, unsigned int *))(*(_QWORD *)v54 + 8LL);
        if ( v96(v54, "EA_Spawn_Protection_Hit", &v34) )
        {
          v97 = *(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)v30 + 0x588LL);
          v97(v30, v34, 1, 0);
        }
      }
      if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
      {
        v44[0] = sub_142744750(0x19u);
        v44[1] = 0x44;
        src_[0] = v44;
        src_[1] = &v45;
        qmemcpy(dst__1, src_, sizeof(dst__1));
        v26 = invokeGlobalCallbackAndMaskStatusBits(
                5,
                (__int64)dst__1,
                (__int64)"Client Hit Discarded",
                "$$: Hit from '$$' [$$] discarded due to target '$$' [$$] filtering it out.");
        if ( (v26 & 0xFFFFF) != 0 )
        {
          v55 = sub_14030ECF0((_QWORD *)(a2 + 8));
          v98 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v55 + 8LL);
          v99 = (__int64 *)v98(v55, v202);
          v100 = sub_1402A24F0(*v99);
          v183[0] = 0;
          v183[1] = v100;
          v184 = 0;
          v105 = v183;
          v56 = sub_14030ECF0((_QWORD *)(a2 + 8));
          v101 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v56 + 0x70LL))(v56);
          v162[0] = 0;
          v162[1] = v101;
          v163 = 0;
          v106 = v162;
          v102 = a2;
          v103 = sub_1403B0A70((unsigned __int64 *)a2, v196);
          v104 = sub_1402A24F0(*v103);
          v179[0] = 0;
          v179[1] = v104;
          v180 = 0;
          v107 = v179;
          if ( sub_14030EC00((unsigned __int64 *)a2) )
          {
            v57 = sub_14030ECF0((_QWORD *)a2);
            p_unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v57 + 0x70LL))(v57);
          }
          else
          {
            p_unknown = "unknown";
          }
          v160[0] = 0;
          v160[1] = p_unknown;
          v161 = 0;
          v108 = v160;
          v158[0] = 0;
          v158[1] = "CGameRules::ClientHit";
          v159 = 0;
          v109 = v158;
          ThreadLogContextSlot = getThreadLogContextSlot();
          v174[0] = 0;
          v174[1] = 0;
          v46[0] = sub_142744750(0x19u);
          v46[1] = 0x44;
          src__1[0] = v46;
          src__1[1] = &v47;
          qmemcpy(dst__2, src__1, sizeof(dst__2));
          v196[1] = 6;
          v5 = alloca(0x2A0);
          v59 = v9;
          __Val_0__ = (vraudio::AudioBuffer *)v9;
          sub_143068F20((__int64)v9, (__int64)ThreadLogContextSlot, v109, v108, v107, v106, v105);
          LODWORD(v8) = v26;
          sub_1403045C0(
            5u,
            dst__2,
            "Client Hit Discarded",
            "$$: Hit from '$$' [$$] discarded due to target '$$' [$$] filtering it out.",
            __Val_0__,
            6u,
            1,
            v8,
            v174,
            0);
          v111 = v159;
          sub_1402A3D30(v159);
          v112 = v161;
          sub_1402A3D30(v161);
          v113 = v163;
          sub_1402A3D30(v163);
        }
      }
      v22 = 0;
      dst_[3] = __rdtsc();
      v114 = qword_149B4B878;
      qword_149B4B878(dst_);
      return sub_1402B1820(&v33);
    }
    else
    {
      if ( v24 )
      {
        v13 = (*(__int64 (__fastcall **)(_QWORD *))(*v24 + 0x5A0LL))(v24);
      }
      else
      {
        if ( v17 )
        {
          v115 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v17 + 0x7C0LL);
          LOBYTE(v4) = 2;
          v12 = v115(v17, v4);
        }
        else
        {
          v12 = 0;
        }
        v13 = v12;
      }
      v15 = v13;
      if ( v13 )
      {
        if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
        {
          v48[0] = sub_142744750(0x19u);
          v48[1] = 0x44;
          src__2[0] = v48;
          src__2[1] = &v49;
          qmemcpy(dst__3, src__2, sizeof(dst__3));
          v27 = invokeGlobalCallbackAndMaskStatusBits(
                  5,
                  (__int64)dst__3,
                  (__int64)"Client Hit Discarded",
                  "$$: Hit from '$$' [$$] discarded due to target '$$' [$$] being considered dead already.");
          if ( (v27 & 0xFFFFF) != 0 )
          {
            v61 = sub_14030ECF0((_QWORD *)(a2 + 8));
            v116 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v61 + 8LL);
            v117 = (__int64 *)v116(v61, v197);
            v118 = sub_1402A24F0(*v117);
            v185[0] = 0;
            v185[1] = v118;
            v186 = 0;
            v123 = v185;
            v62 = sub_14030ECF0((_QWORD *)(a2 + 8));
            v119 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v62 + 0x70LL))(v62);
            v168[0] = 0;
            v168[1] = v119;
            v169 = 0;
            v124 = v168;
            v120 = a2;
            v121 = sub_1403B0A70((unsigned __int64 *)a2, &v198);
            v122 = sub_1402A24F0(*v121);
            v187[0] = 0;
            v187[1] = v122;
            v188 = 0;
            v125 = v187;
            if ( sub_14030EC00((unsigned __int64 *)a2) )
            {
              v63 = sub_14030ECF0((_QWORD *)a2);
              p_unknown_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v63 + 0x70LL))(v63);
            }
            else
            {
              p_unknown_1 = "unknown";
            }
            v166[0] = 0;
            v166[1] = p_unknown_1;
            v167 = 0;
            v126 = v166;
            v164[0] = 0;
            v164[1] = "CGameRules::ClientHit";
            v165 = 0;
            v127 = v164;
            ThreadLogContextSlot_1 = getThreadLogContextSlot();
            v171[0] = 0;
            v171[1] = 0;
            v38[0] = sub_142744750(0x19u);
            v38[1] = 0x44;
            src__3[0] = v38;
            src__3[1] = &v39;
            qmemcpy(dst__4, src__3, 0x10u);
            v189[1] = 6;
            v6 = alloca(0x2A0);
            v65 = v9;
            __Val_0___1 = (vraudio::AudioBuffer *)v9;
            sub_143068F20((__int64)v9, (__int64)ThreadLogContextSlot_1, v127, v126, v125, v124, v123);
            LODWORD(v8) = v27;
            sub_1403045C0(
              5u,
              dst__4,
              "Client Hit Discarded",
              "$$: Hit from '$$' [$$] discarded due to target '$$' [$$] being considered dead already.",
              __Val_0___1,
              6u,
              1,
              v8,
              v171,
              0);
            v129 = v165;
            sub_1402A3D30(v165);
            v130 = v167;
            sub_1402A3D30(v167);
            v131 = v169;
            sub_1402A3D30(v169);
          }
        }
      }
      else
      {
        v14 = *(_BYTE *)(a2 + 0xE4);
        sub_1403624E0((__int64)v206, a2);
        if ( sub_14030EC00(v208) )
        {
          v67 = sub_14030ECF0(v208);
          v68 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v67 + 0x20LL))(v67);
          v209 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v68 + 0x28LL))(v68);
        }
        if ( sub_14030EC00(v207) )
        {
          v69 = sub_14030ECF0(v207);
          v70 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v69 + 0x20LL))(v69);
          v210 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v70 + 0x28LL))(v70);
        }
        if ( *(_BYTE *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x2A0) )
        {
          if ( !v14 )
            sub_14646D6C0(a1, v206);
        }
        else
        {
          sub_14646A350(a1, (__int64)v206);
          if ( !v14 )
          {
            Parameter = a1 + 0x6E18;
            v7 = sub_1402A24F0((__int64)&qword_149B4FBE0);
            v35 = sub_1403E6790(v7);
            v132 = v211;
            sub_1403624E0((__int64)v211, (__int64)v206);
            v212 = v35;
            _StarEngineModule__(Parameter);
            sub_14645F2F0((_QWORD *)Parameter, (__int64)v211);
            sub_140372D50((__int64)v211);
            if ( sub_14030EC00((unsigned __int64 *)a2) )
            {
              v133 = sub_14030ECF0((_QWORD *)a2);
              v134 = sub_1425D62E0(v133, v199);
              v135 = *v134;
              v72 = v135;
              v31 = v199[1];
              v31 = is_valid_handle_typeA(&v72) ? v72 & 0xFFFFFFFFFFFFLL : 0LL;
            }
            else
            {
              v31 = 0;
            }
            v36 = v31;
            if ( v31 )
            {
              if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x650LL))(v36) )
              {
                v37 = sub_1464830F0(a1);
                if ( v37 )
                {
                  v136 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v37 + 0x680LL);
                  v136(v37, a2);
                }
              }
            }
          }
        }
        sub_140372D50((__int64)v206);
      }
      v137 = sub_1402A24F0((__int64)&qword_149B4FBE0);
      if ( *(_BYTE *)(v137 + 0x5F5) )
      {
        sub_1464E72C0(qword_149E7E438, &v32);
        v138 = a2;
        if ( std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>((_QWORD *)a2, &v32) )
        {
          v139 = sub_14490F860();
          sub_1449473E0(v139, a2);
        }
        v140 = a2 + 8;
        if ( std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>((_QWORD *)(a2 + 8), &v32) )
        {
          v141 = sub_14490F860();
          sub_1449461C0(v141, a2);
        }
        if ( v17 )
        {
          v142 = a2;
          if ( unknown_libname_23((_QWORD *)a2, &v32) )
          {
            v143 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v17 + 0x7F0LL);
            v144 = (_QWORD *)v143(v17, v200);
            if ( std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(v144, &v32) )
            {
              v145 = sub_14490F860();
              sub_144947720(v145, a2);
            }
          }
        }
      }
      v23 = 0;
      dst_[3] = __rdtsc();
      v146 = qword_149B4B878;
      qword_149B4B878(dst_);
      return sub_1402B1820(&v33);
    }
  }
  else
  {
    if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
    {
      v40[0] = sub_142744750(0x19u);
      v40[1] = 0x44;
      src__4[0] = v40;
      src__4[1] = &v41;
      qmemcpy(dst__5, src__4, sizeof(dst__5));
      v25 = invokeGlobalCallbackAndMaskStatusBits(
              5,
              (__int64)dst__5,
              (__int64)"Client Hit Discarded",
              "$$: Hit from '$$' [$$] discarded due to invalid target.");
      if ( (v25 & 0xFFFFF) != 0 )
      {
        v148 = a2;
        v149 = sub_1403B0A70((unsigned __int64 *)a2, v201);
        v150 = sub_1402A24F0(*v149);
        v181[0] = 0;
        v181[1] = v150;
        v182 = 0;
        v151 = v181;
        if ( sub_14030EC00((unsigned __int64 *)a2) )
        {
          v64 = sub_14030ECF0((_QWORD *)a2);
          p_unknown_2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v64 + 0x70LL))(v64);
        }
        else
        {
          p_unknown_2 = "unknown";
        }
        v156[0] = 0;
        v156[1] = p_unknown_2;
        v157 = 0;
        v152 = v156;
        v154[0] = 0;
        v154[1] = "CGameRules::ClientHit";
        v155 = 0;
        v79 = v154;
        ThreadLogContextSlot_2 = getThreadLogContextSlot();
        v170[0] = 0;
        v170[1] = 0;
        v42[0] = sub_142744750(0x19u);
        v42[1] = 0x44;
        src__5[0] = v42;
        src__5[1] = &v43;
        qmemcpy(dst__6, src__5, sizeof(dst__6));
        v201[1] = 4;
        v2 = alloca(0x1C0);
        v74 = v11;
        __Val_0___2 = (vraudio::AudioBuffer *)v11;
        sub_141DA5C20((__int64)v11, (__int64)ThreadLogContextSlot_2, v79, v152, v151);
        LODWORD(v10) = v25;
        sub_1403045C0(
          5u,
          dst__6,
          "Client Hit Discarded",
          "$$: Hit from '$$' [$$] discarded due to invalid target.",
          __Val_0___2,
          4u,
          1,
          v10,
          v170,
          0);
        v81 = v155;
        sub_1402A3D30(v155);
        v82 = v157;
        sub_1402A3D30(v157);
      }
    }
    v18 = 0;
    dst_[3] = __rdtsc();
    v83 = qword_149B4B878;
    qword_149B4B878(dst_);
    return sub_1402B1820(&v33);
  }
}

// --- End Function: sub_146465830 (0x146465830) ---

// --- Function: sub_146467000 (0x146467000) ---
unsigned __int64 *__fastcall sub_146467000(__int64 a1, __int64 a2, char *a3)
{
  struct std::pmr::memory_resource **v3; // rax
  char *v4; // rax
  unsigned __int64 *v5; // rax
  unsigned __int64 *result; // rax
  char *v7; // rax
  int i; // [rsp+20h] [rbp-118h]
  unsigned __int64 *v9; // [rsp+28h] [rbp-110h]
  unsigned __int64 v10; // [rsp+30h] [rbp-108h] BYREF
  __int64 v11; // [rsp+38h] [rbp-100h] BYREF
  __int64 v12; // [rsp+40h] [rbp-F8h]
  __int64 v13; // [rsp+48h] [rbp-F0h]
  __int64 v14; // [rsp+50h] [rbp-E8h]
  __int64 v15; // [rsp+58h] [rbp-E0h]
  unsigned __int64 v16[2]; // [rsp+60h] [rbp-D8h] BYREF
  unsigned __int64 v17; // [rsp+70h] [rbp-C8h] BYREF
  __int64 v18; // [rsp+78h] [rbp-C0h]
  void *v19; // [rsp+80h] [rbp-B8h]
  struct std::pmr::memory_resource *v20; // [rsp+88h] [rbp-B0h]
  std::pmr::_Identity_equal_resource *v21; // [rsp+90h] [rbp-A8h]
  __int64 v22; // [rsp+98h] [rbp-A0h]
  void (__fastcall *v23)(__int64, unsigned __int64 *, __int64); // [rsp+A0h] [rbp-98h]
  __int64 v24; // [rsp+A8h] [rbp-90h]
  __int64 *v25; // [rsp+B0h] [rbp-88h]
  __int64 v26; // [rsp+B8h] [rbp-80h]
  __int64 v27; // [rsp+C0h] [rbp-78h]
  __int64 v28; // [rsp+C8h] [rbp-70h]
  struct __crt_locale_data *v29; // [rsp+D0h] [rbp-68h]
  void (__fastcall *v30)(__int64, unsigned __int64 *, struct __crt_locale_data *); // [rsp+D8h] [rbp-60h]
  __int64 v31; // [rsp+E0h] [rbp-58h]
  void (__fastcall *v32)(__int64, __int64 *, __int64); // [rsp+E8h] [rbp-50h]
  __int64 v33; // [rsp+F0h] [rbp-48h] BYREF
  unsigned __int64 *v34; // [rsp+F8h] [rbp-40h]
  __int64 v35; // [rsp+100h] [rbp-38h] BYREF
  __int64 v36; // [rsp+108h] [rbp-30h] BYREF
  struct __crt_locale_data *v37; // [rsp+110h] [rbp-28h] BYREF
  __int64 v38; // [rsp+118h] [rbp-20h] BYREF
  __int64 v39[3]; // [rsp+120h] [rbp-18h] BYREF

  v19 = &v35;
  sub_1402B1640(&v35);
  v20 = *v3;
  v21 = *(std::pmr::_Identity_equal_resource **)(a2 + 0x18);
  if ( std::pmr::_Identity_equal_resource::do_is_equal(v21, v20) && *(_DWORD *)(a2 + 0xC0) == 5 )
  {
    v12 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA0);
    v23 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v12 + 0x120LL);
    v22 = *(_QWORD *)(a2 + 0x10);
    v23(v12, &v10, v22);
    if ( sub_14030EC00(&v10) )
    {
      v13 = sub_14030ECF0(&v10);
      v4 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x3D0LL))(v13);
      sub_141339280(a3, v4);
      v24 = sub_14030ECF0(&v10);
      v25 = sub_1426D9DD0(v24, &v36);
      v26 = *v25;
      v11 = v26;
      if ( Handle::IsValid(&v11) )
      {
        v27 = v11 & 0xFFFFFFFFFFFFLL;
        if ( (unsigned int)sub_14337D120(v11 & 0xFFFFFFFFFFFFLL) == 1 )
        {
          v14 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA0);
          v30 = *(void (__fastcall **)(__int64, unsigned __int64 *, struct __crt_locale_data *))(*(_QWORD *)v14 + 0x120LL);
          v28 = v11 & 0xFFFFFFFFFFFFLL;
          v29 = *sub_145C82DB0(v11 & 0xFFFFFFFFFFFFLL, &v37);
          v30(v14, v16, v29);
          if ( sub_14030EC00(v16) )
          {
            for ( i = sub_1404B64E0((__int64)a3); i >= 0; --i )
            {
              v15 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA0);
              v32 = *(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v15 + 0x188LL);
              v31 = *sub_1461A1AD0((__int64)a3, &v38, i);
              v32(v15, &v33, v31);
              if ( std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(&v33, v16) )
              {
                v5 = sub_1461A1AD0((__int64)a3, v39, i);
                sub_145F44160((__int64)a3, *v5);
              }
            }
          }
        }
      }
    }
  }
  v16[1] = a2 + 0x28;
  v9 = *(unsigned __int64 **)(a2 + 0x28);
  v34 = *(unsigned __int64 **)(a2 + 0x30);
  while ( 1 )
  {
    result = v34;
    if ( v9 == v34 )
      break;
    v17 = *v9;
    if ( sub_14030EC00(&v17) )
    {
      v18 = sub_14030ECF0(&v17);
      v7 = (char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x3D0LL))(v18);
      sub_141339280(a3, v7);
    }
    ++v9;
  }
  return result;
}

// --- End Function: sub_146467000 (0x146467000) ---

// --- Function: sub_146467420 (0x146467420) ---
__int64 __fastcall sub_146467420(__int64 a1)
{
  unsigned __int64 n0x40; // [rsp+0h] [rbp-18h]

  for ( n0x40 = 0; n0x40 < 0x40; ++n0x40 )
  {
    if ( !*(_BYTE *)(n0x40 + a1 + 0x6D88) )
      return (unsigned int)n0x40;
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_146467420 (0x146467420) ---

// --- Function: sub_14646A350 (0x14646A350) ---
void *(__fastcall **__fastcall sub_14646A350(__int64 a1, __int64 a2))(FDefaultModuleImpl *__hidden this, unsigned int)
{
  void *v2; // rsp
  __int64 v4; // [rsp+18h] [rbp-2B8h]
  _BYTE v5[592]; // [rsp+30h] [rbp-2A0h] BYREF
  int v6; // [rsp+2D0h] [rbp+0h]
  BOOL v7; // [rsp+2D4h] [rbp+4h]
  __int64 *Parameter_; // [rsp+2D8h] [rbp+8h] BYREF
  __int64 v9; // [rsp+2E0h] [rbp+10h]
  _DWORD v10[2]; // [rsp+2E8h] [rbp+18h] BYREF
  char v11; // [rsp+2F0h] [rbp+20h] BYREF
  _DWORD v12[2]; // [rsp+2F8h] [rbp+28h] BYREF
  char v13; // [rsp+300h] [rbp+30h] BYREF
  __int64 v14; // [rsp+308h] [rbp+38h]
  const char *p_unknown; // [rsp+310h] [rbp+40h]
  __int64 v16; // [rsp+318h] [rbp+48h]
  const char *p_unknown_1; // [rsp+320h] [rbp+50h]
  _BYTE *v18; // [rsp+328h] [rbp+58h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+330h] [rbp+60h]
  __int64 v20; // [rsp+338h] [rbp+68h]
  __int64 v21; // [rsp+340h] [rbp+70h]
  __int64 v22; // [rsp+348h] [rbp+78h]
  __int64 v23; // [rsp+350h] [rbp+80h]
  char v24; // [rsp+358h] [rbp+88h]
  __int64 v25; // [rsp+360h] [rbp+90h]
  _QWORD *v26; // [rsp+368h] [rbp+98h]
  _QWORD *v27; // [rsp+370h] [rbp+A0h]
  _QWORD *v28; // [rsp+378h] [rbp+A8h]
  _QWORD *v29; // [rsp+380h] [rbp+B0h]
  _QWORD *v30; // [rsp+388h] [rbp+B8h]
  __int64 *ThreadLogContextSlot; // [rsp+390h] [rbp+C0h]
  const void *v32; // [rsp+398h] [rbp+C8h]
  const void *v33; // [rsp+3A0h] [rbp+D0h]
  const void *v34; // [rsp+3A8h] [rbp+D8h]
  void (__fastcall *v35)(__int64, unsigned __int64 *); // [rsp+3B0h] [rbp+E0h]
  __int64 v36; // [rsp+3B8h] [rbp+E8h]
  __int64 v37; // [rsp+3C0h] [rbp+F0h]
  __int64 v38; // [rsp+3C8h] [rbp+F8h]
  __int64 v39; // [rsp+3D0h] [rbp+100h]
  __int64 v40; // [rsp+3D8h] [rbp+108h]
  __int64 v41; // [rsp+3E0h] [rbp+110h]
  __int64 v42; // [rsp+3E8h] [rbp+118h]
  _QWORD Parameter__1[2]; // [rsp+3F0h] [rbp+120h] BYREF
  void (__fastcall *v44)(__int64, unsigned __int64 *); // [rsp+400h] [rbp+130h]
  __int64 *v45; // [rsp+408h] [rbp+138h]
  __int64 v46; // [rsp+410h] [rbp+140h]
  __int64 *v47; // [rsp+418h] [rbp+148h]
  _QWORD v48[2]; // [rsp+420h] [rbp+150h] BYREF
  const void *v49; // [rsp+430h] [rbp+160h]
  _QWORD v50[2]; // [rsp+438h] [rbp+168h] BYREF
  const void *v51; // [rsp+448h] [rbp+178h]
  _QWORD v52[2]; // [rsp+450h] [rbp+180h] BYREF
  const void *v53; // [rsp+460h] [rbp+190h]
  _QWORD src_[2]; // [rsp+468h] [rbp+198h] BYREF
  _QWORD src__1[2]; // [rsp+478h] [rbp+1A8h] BYREF
  _QWORD v56[2]; // [rsp+488h] [rbp+1B8h] BYREF
  _QWORD v57[2]; // [rsp+498h] [rbp+1C8h] BYREF
  char v58; // [rsp+4A8h] [rbp+1D8h]
  _QWORD v59[2]; // [rsp+4B0h] [rbp+1E0h] BYREF
  char v60; // [rsp+4C0h] [rbp+1F0h]
  __int64 v61; // [rsp+4C8h] [rbp+1F8h] BYREF
  _QWORD v62[2]; // [rsp+4D0h] [rbp+200h] BYREF
  _BYTE dst_[16]; // [rsp+4E0h] [rbp+210h] BYREF
  __int64 dst__1[2]; // [rsp+4F0h] [rbp+220h] BYREF
  unsigned __int64 v65; // [rsp+500h] [rbp+230h] BYREF
  unsigned __int64 v66[43]; // [rsp+508h] [rbp+238h] BYREF

  sub_1403624E0((__int64)&v65, a2);
  if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
  {
    v10[0] = sub_142744750(0x19u);
    v10[1] = 0x44;
    src_[0] = v10;
    src_[1] = &v11;
    qmemcpy(dst_, src_, sizeof(dst_));
    v6 = invokeGlobalCallbackAndMaskStatusBits(
           5,
           (__int64)dst_,
           (__int64)"Processing Hit",
           "$$: Handling hit from '$$' [$$] on target '$$' [$$].");
    if ( (v6 & 0xFFFFF) != 0 )
    {
      v45 = sub_1403B0A70(v66, &v61);
      v46 = sub_1402A24F0(*v45);
      v57[0] = 0;
      v57[1] = v46;
      v58 = 0;
      v26 = v57;
      if ( sub_14030EC00(v66) )
      {
        v14 = sub_14030ECF0(v66);
        p_unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x70LL))(v14);
      }
      else
      {
        p_unknown = "unknown";
      }
      v52[0] = 0;
      v52[1] = p_unknown;
      v53 = 0;
      v27 = v52;
      v47 = sub_1403B0A70(&v65, v62);
      v25 = sub_1402A24F0(*v47);
      v59[0] = 0;
      v59[1] = v25;
      v60 = 0;
      v28 = v59;
      if ( sub_14030EC00(&v65) )
      {
        v16 = sub_14030ECF0(&v65);
        p_unknown_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x70LL))(v16);
      }
      else
      {
        p_unknown_1 = "unknown";
      }
      v50[0] = 0;
      v50[1] = p_unknown_1;
      v51 = 0;
      v29 = v50;
      v48[0] = 0;
      v48[1] = "CGameRules::ProcessHit";
      v49 = 0;
      v30 = v48;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v56[0] = 0;
      v56[1] = 0;
      v12[0] = sub_142744750(0x19u);
      v12[1] = 0x44;
      src__1[0] = v12;
      src__1[1] = &v13;
      qmemcpy(dst__1, src__1, sizeof(dst__1));
      v62[1] = 6;
      v2 = alloca(0x2A0);
      v18 = v5;
      __Val_0__ = (vraudio::AudioBuffer *)v5;
      sub_143068F20((__int64)v5, (__int64)ThreadLogContextSlot, v30, v29, v28, v27, v26);
      LODWORD(v4) = v6;
      sub_1403045C0(
        5u,
        dst__1,
        "Processing Hit",
        "$$: Handling hit from '$$' [$$] on target '$$' [$$].",
        __Val_0__,
        6u,
        1,
        v4,
        v56,
        0);
      v32 = v49;
      sub_1402A3D30(v49);
      v33 = v51;
      sub_1402A3D30(v51);
      v34 = v53;
      sub_1402A3D30(v53);
    }
  }
  v9 = sub_146481A00(a1);
  if ( v9 )
  {
    v35 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v9 + 0x570LL);
    v35(v9, &v65);
  }
  v23 = a1 + 0x388;
  v24 = 1;
  v36 = a1 + 0x388;
  sub_1402D2710(a1 + 0x388, "CGameRules::ProcessHit", "m_hitListenerLock", 1);
  v37 = a1 + 0x370;
  v20 = a1 + 0x370;
  v38 = a1 + 0x370;
  v39 = *(_QWORD *)(a1 + 0x370);
  std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
    (Parameter *)&Parameter_,
    v39);
  while ( 1 )
  {
    v40 = a1 + 0x370;
    v21 = a1 + 0x370;
    v41 = a1 + 0x370;
    v42 = *(_QWORD *)(a1 + 0x378);
    std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
      (Parameter *)Parameter__1,
      v42);
    v7 = Parameter_ == (__int64 *)Parameter__1[0];
    if ( Parameter_ == (__int64 *)Parameter__1[0] )
      break;
    Parameter__1[1] = Parameter_;
    v22 = *Parameter_;
    v44 = *(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)v22 + 8LL);
    v44(v22, &v65);
    ++Parameter_;
  }
  if ( v24 )
    sub_1402D2790(v23);
  return sub_140372D50((__int64)&v65);
}

// --- End Function: sub_14646A350 (0x14646A350) ---

// --- Function: sub_14646AC20 (0x14646AC20) ---
void __fastcall sub_14646AC20(__int64 a1, __int64 a2)
{
  __int64 v12; // rax
  __int64 v13; // [rsp+88h] [rbp-4C0h]
  float v14; // [rsp+ACh] [rbp-49Ch]
  float v15; // [rsp+B0h] [rbp-498h]
  float v16; // [rsp+B8h] [rbp-490h]
  float v17; // [rsp+BCh] [rbp-48Ch]
  float v18; // [rsp+C0h] [rbp-488h]
  float v19; // [rsp+C4h] [rbp-484h]
  float v20; // [rsp+CCh] [rbp-47Ch]
  float v21; // [rsp+D0h] [rbp-478h]
  float v22; // [rsp+D4h] [rbp-474h]
  float v23; // [rsp+DCh] [rbp-46Ch]
  float v24; // [rsp+E8h] [rbp-460h]
  float v25; // [rsp+ECh] [rbp-45Ch]
  float v26; // [rsp+F0h] [rbp-458h]
  float v27; // [rsp+FCh] [rbp-44Ch]
  float v28; // [rsp+100h] [rbp-448h]
  float v29; // [rsp+104h] [rbp-444h]
  __int64 v30; // [rsp+108h] [rbp-440h]
  float v31; // [rsp+110h] [rbp-438h]
  float v32; // [rsp+114h] [rbp-434h]
  int v33; // [rsp+11Ch] [rbp-42Ch]
  float v34; // [rsp+120h] [rbp-428h]
  float v35; // [rsp+124h] [rbp-424h]
  __int64 v36; // [rsp+128h] [rbp-420h] BYREF
  float v37; // [rsp+130h] [rbp-418h]
  __int64 v38; // [rsp+138h] [rbp-410h]
  float v39; // [rsp+140h] [rbp-408h]
  __int64 v40; // [rsp+148h] [rbp-400h]
  __int64 v41; // [rsp+150h] [rbp-3F8h]
  __int64 v42; // [rsp+158h] [rbp-3F0h]
  __int64 v43; // [rsp+160h] [rbp-3E8h]
  __int64 v44; // [rsp+168h] [rbp-3E0h] BYREF
  __int64 v45; // [rsp+170h] [rbp-3D8h]
  __int64 v46; // [rsp+178h] [rbp-3D0h]
  float v47[3]; // [rsp+180h] [rbp-3C8h] BYREF
  float v48[3]; // [rsp+18Ch] [rbp-3BCh] BYREF
  __int64 v49; // [rsp+198h] [rbp-3B0h]
  void (__fastcall *v50)(__int64, __int64 *); // [rsp+1A0h] [rbp-3A8h]
  void (__fastcall *v51)(__int64, __int64 *, _QWORD); // [rsp+1A8h] [rbp-3A0h]
  __int64 v52; // [rsp+1B0h] [rbp-398h]
  __int64 v53; // [rsp+1B8h] [rbp-390h]
  __int64 v54; // [rsp+1C0h] [rbp-388h]
  __int64 v55; // [rsp+1C8h] [rbp-380h]
  __int64 v56; // [rsp+1D0h] [rbp-378h]
  __int64 v57; // [rsp+1D8h] [rbp-370h]
  __int64 v58; // [rsp+1E0h] [rbp-368h]
  __int64 v59; // [rsp+1E8h] [rbp-360h]
  __int64 v60; // [rsp+1F0h] [rbp-358h]
  __int64 v61; // [rsp+1F8h] [rbp-350h]
  __int64 v62; // [rsp+200h] [rbp-348h]
  __int64 v63; // [rsp+208h] [rbp-340h]
  __int64 v64; // [rsp+210h] [rbp-338h]
  __int64 v65; // [rsp+218h] [rbp-330h]
  __int64 v66; // [rsp+220h] [rbp-328h]
  __int64 v67; // [rsp+228h] [rbp-320h]
  __int64 v68; // [rsp+230h] [rbp-318h]
  __int64 v69; // [rsp+238h] [rbp-310h]
  __int64 v70; // [rsp+240h] [rbp-308h]
  __int64 v71; // [rsp+248h] [rbp-300h]
  __int64 v72; // [rsp+250h] [rbp-2F8h]
  __int64 v73; // [rsp+258h] [rbp-2F0h]
  __int64 v74; // [rsp+260h] [rbp-2E8h]
  __int64 v75; // [rsp+268h] [rbp-2E0h]
  __int64 v76; // [rsp+270h] [rbp-2D8h]
  __int64 v77; // [rsp+278h] [rbp-2D0h]
  __int64 v78; // [rsp+280h] [rbp-2C8h]
  __int64 v79; // [rsp+288h] [rbp-2C0h]
  float *v80; // [rsp+290h] [rbp-2B8h]
  double *v81; // [rsp+298h] [rbp-2B0h]
  __int64 v82; // [rsp+2A0h] [rbp-2A8h]
  __int64 v83; // [rsp+2A8h] [rbp-2A0h]
  __int64 v84; // [rsp+2B0h] [rbp-298h]
  __int64 v85; // [rsp+2B8h] [rbp-290h]
  __int64 v86; // [rsp+2C0h] [rbp-288h]
  __int64 v89; // [rsp+2D8h] [rbp-270h]
  float *v90; // [rsp+2E0h] [rbp-268h]
  __int64 v91; // [rsp+2E8h] [rbp-260h]
  __int64 v92; // [rsp+2F0h] [rbp-258h]
  __int64 v93; // [rsp+2F8h] [rbp-250h]
  __int64 *v94; // [rsp+300h] [rbp-248h]
  __int64 v95; // [rsp+308h] [rbp-240h]
  float v96; // [rsp+310h] [rbp-238h]
  __int64 (__fastcall *v97)(__int64, _QWORD); // [rsp+318h] [rbp-230h]
  __int64 v98; // [rsp+320h] [rbp-228h]
  __int64 v99; // [rsp+328h] [rbp-220h]
  __int64 v100; // [rsp+330h] [rbp-218h] BYREF
  __int64 v101; // [rsp+368h] [rbp-1E0h] BYREF
  _QWORD v102[2]; // [rsp+370h] [rbp-1D8h] BYREF
  double v103[3]; // [rsp+380h] [rbp-1C8h] BYREF
  _BYTE v104[16]; // [rsp+398h] [rbp-1B0h] BYREF
  __int64 v105; // [rsp+3A8h] [rbp-1A0h]
  _QWORD v106[4]; // [rsp+3B0h] [rbp-198h] BYREF
  int v107; // [rsp+3D0h] [rbp-178h]
  char v108; // [rsp+475h] [rbp-D3h]
  char v109; // [rsp+494h] [rbp-B4h]
  bool v110; // [rsp+495h] [rbp-B3h]
  __int16 v111; // [rsp+50Ch] [rbp-3Ch]
  unsigned __int64 v112[4]; // [rsp+510h] [rbp-38h] BYREF

  v45 = *(_QWORD *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0xA0);
  v40 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 0xC0LL))(v45);
  v97 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v40 + 0x10LL);
  v41 = v97(v40, *(unsigned int *)(a2 + 0x50));
  if ( v41 )
  {
    v98 = sub_141810760(qword_149E7E438);
    sub_1457239F0(v98, (__int64)v104, v41);
    v99 = v105;
    if ( v105 )
    {
      v49 = v105;
      v42 = sub_142CE4F70(v105);
    }
    else
    {
      v42 = 0;
    }
    v13 = v42;
    if ( v42 )
    {
      v33 = sub_143CF4820(v42);
      v30 = sub_145D1BE90((_QWORD *)a2);
      if ( v30 )
      {
        v50 = *(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v30 + 0x38LL);
        v50(v30, &v36);
        v51 = *(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v30 + 0x78LL);
        v51(v30, &v100, 0);
        v34 = *(float *)(v13 + 0x5C);
        v35 = *(float *)(v13 + 0x58);
        v37 = *(float *)(v13 + 0x1C);
        v39 = *(float *)(v13 + 0x18);
        v31 = *(float *)(v13 + 0x10);
        _XMM0 = *(unsigned int *)(v13 + 0xC);
        v32 = *(float *)(v13 + 0xC);
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_200] }
        v23 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_218] }
        v21 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_210] }
        v22 = *(float *)&_XMM0;
        __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_208] }
        v26 = (float)((float)(v22 * *(float *)(a2 + 0x40)) - (float)(*(float *)&_XMM0 * *(float *)(a2 + 0x3C)))
            + (float)(v23 * *(float *)(a2 + 0x38));
        v25 = (float)((float)(*(float *)&_XMM0 * *(float *)(a2 + 0x38)) - (float)(v21 * *(float *)(a2 + 0x40)))
            + (float)(v23 * *(float *)(a2 + 0x3C));
        v24 = (float)((float)(v21 * *(float *)(a2 + 0x3C)) - (float)(v22 * *(float *)(a2 + 0x38)))
            + (float)(v23 * *(float *)(a2 + 0x40));
        v14 = (float)((float)(v26 * *(float *)&_XMM0) - (float)(v24 * v21))
            + (float)((float)((float)(v26 * *(float *)&_XMM0) - (float)(v24 * v21)) + *(float *)(a2 + 0x3C));
        v15 = (float)((float)(v25 * v21) - (float)(v26 * v22))
            + (float)((float)((float)(v25 * v21) - (float)(v26 * v22)) + *(float *)(a2 + 0x40));
        v47[0] = (float)((float)(v24 * v22) - (float)(v25 * *(float *)&_XMM0))
               + (float)((float)((float)(v24 * v22) - (float)(v25 * *(float *)&_XMM0)) + *(float *)(a2 + 0x38));
        v47[1] = v14;
        v47[2] = v15;
        v80 = v47;
        v81 = sub_140337B60(v103, (double *)&v100, (double *)(a2 + 0x20));
        v52 = *(_QWORD *)(a2 + 0x10);
        v53 = v52;
        v54 = v52;
        v55 = v52;
        v56 = v52;
        v57 = v52;
        v58 = v52;
        v82 = v52;
        v59 = *(_QWORD *)(a2 + 8);
        v60 = v59;
        v61 = v59;
        v62 = v59;
        v63 = v59;
        v64 = v59;
        v65 = v59;
        v83 = v59;
        v66 = *(_QWORD *)a2;
        v67 = v66;
        v68 = v66;
        v69 = v66;
        v70 = v66;
        v71 = v66;
        v72 = v66;
        v84 = v66;
        v73 = v36;
        v74 = v36;
        v75 = v36;
        v76 = v36;
        v77 = v36;
        v78 = v36;
        v79 = v36;
        v85 = v36;
        _XMM0 = LODWORD(v32);
        sub_140362070(
          (__int64)v106,
          v36,
          v66,
          v59,
          v52,
          v13 + 0x198,
          (__int64)v81,
          (__int64)v80,
          v32,
          v31,
          v39,
          v37,
          0.0,
          v35,
          v34,
          v33);
        v107 = *(_DWORD *)(a2 + 0x50);
        v109 = 1;
        v86 = v105;
        v110 = sub_145733E00(v105);
        if ( *(_QWORD *)(v13 + 0x128) )
        {
          v46 = v102[1];
          v46 = *(_QWORD *)(v13 + 0x128);
          sub_143D7C7A0(v46, (__int64)v106);
        }
        if ( *(_QWORD *)(v13 + 0x190) )
        {
          if ( *(_QWORD *)(v13 + 0x190) )
            v111 = sub_1404B2D60(v13 + 0x180, 0);
        }
        if ( *(_BYTE *)(a2 + 0x54) )
        {
          v89 = *(_QWORD *)(a2 + 0x18);
          __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_200] }
          v20 = *(float *)&_XMM0;
          __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_218] }
          v18 = *(float *)&_XMM0;
          __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_210] }
          v19 = *(float *)&_XMM0;
          __asm { vcvtsd2ss xmm0, xmm0, [rsp+548h+var_208] }
          v29 = (float)((float)(v19 * *(float *)(a2 + 0x4C)) - (float)(*(float *)&_XMM0 * *(float *)(a2 + 0x48)))
              + (float)(v20 * *(float *)(a2 + 0x44));
          v28 = (float)((float)(*(float *)&_XMM0 * *(float *)(a2 + 0x44)) - (float)(v18 * *(float *)(a2 + 0x4C)))
              + (float)(v20 * *(float *)(a2 + 0x48));
          v27 = (float)((float)(v18 * *(float *)(a2 + 0x48)) - (float)(v19 * *(float *)(a2 + 0x44)))
              + (float)(v20 * *(float *)(a2 + 0x4C));
          v16 = (float)((float)(v29 * *(float *)&_XMM0) - (float)(v27 * v18))
              + (float)((float)((float)(v29 * *(float *)&_XMM0) - (float)(v27 * v18)) + *(float *)(a2 + 0x48));
          v17 = (float)((float)(v28 * v18) - (float)(v29 * v19))
              + (float)((float)((float)(v28 * v18) - (float)(v29 * v19)) + *(float *)(a2 + 0x4C));
          v48[0] = (float)((float)(v27 * v19) - (float)(v28 * *(float *)&_XMM0))
                 + (float)((float)((float)(v27 * v19) - (float)(v28 * *(float *)&_XMM0)) + *(float *)(a2 + 0x44));
          v48[1] = v16;
          v48[2] = v17;
          v90 = v48;
          sub_1403D54E0((__int64)v106, (__int64)v48, v89);
        }
        sub_1403D5240((__int64)v106, *(_DWORD *)(v13 + 8));
        v108 = 0;
        if ( !*(_BYTE *)(sub_1402A24F0((__int64)&qword_149B4FBE0) + 0x2A0) )
          sub_1403790A0(v112, (__int64 *)(a2 + 0x58));
        v96 = 1.0;
        sub_143C89900(v13, (__int64)v106, 1.0, *(_BYTE *)(a2 + 0x54) == 0);
        sub_14646C840(a1, (__int64)v106);
        v91 = sub_1402A24F0((__int64)&qword_149B4FBE0);
        if ( *(_BYTE *)(v91 + 0x5F7) )
        {
          if ( sub_14030EC00((unsigned __int64 *)&v36) )
          {
            v92 = v105;
            if ( sub_1457346C0(v105) )
            {
              v93 = *sub_1464823B0(a1, &v101, 0);
              v94 = sub_143B72180(v102, v93);
              v95 = *v94;
              v44 = v95;
              if ( is_valid_handle_typeA(&v44) )
                v38 = v44 & 0xFFFFFFFFFFFFLL;
              else
                v38 = 0;
              if ( v38 )
              {
                v43 = sub_14030ECF0(&v36);
                v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v43 + 0x668LL))(v43);
                sub_146463D30(a1, (__int64)v106, (__int64)v112, v12);
                sub_143452980(v38, v106);
              }
            }
          }
        }
        sub_140372C50(v106);
      }
      else
      {
        sub_1405C0E00(0xAu, 2u, "Projectile explosion queued without a valid projectile entity! Skipping explosion.");
      }
    }
  }
}

// --- End Function: sub_14646AC20 (0x14646AC20) ---

// --- Function: sub_14646C840 (0x14646C840) ---
void __fastcall sub_14646C840(__int64 a1, __int64 a2)
{
  AK::WriteBytesMem *v2; // rax
  const char *v3; // rax
  AK::WriteBytesMem *v4; // rax
  const char *v5; // rax
  int v6; // [rsp+20h] [rbp-4E8h]
  __int64 v7; // [rsp+70h] [rbp-498h]
  __int64 v8; // [rsp+A0h] [rbp-468h] BYREF
  __int64 v9; // [rsp+A8h] [rbp-460h] BYREF
  _BYTE v10[544]; // [rsp+B0h] [rbp-458h] BYREF
  _BYTE v11[544]; // [rsp+2D0h] [rbp-238h] BYREF

  if ( sub_14030EC00((unsigned __int64 *)a2) )
  {
    v7 = sub_14030ECF0((_QWORD *)a2);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x668LL))(v7) )
    {
      sub_1402AE3D0(&v9, "CGameRules::QueueExplosion", a1 + 0x520, 1);
      v6 = sub_146467420(a1);
      if ( v6 == 0xFFFFFFFF )
      {
        sub_1405C0E00(0xAu, 2u, "Out of explosion indices to use!");
      }
      else
      {
        if ( fpclassify(*(double *)(a2 + 0x60)) == 2
          || fpclassify(*(double *)(a2 + 0x68)) == 2
          || fpclassify(*(double *)(a2 + 0x70)) == 2
          || fpclassify(*(float *)(a2 + 0x78)) == 2
          || fpclassify(*(float *)(a2 + 0x7C)) == 2
          || fpclassify(*(float *)(a2 + 0x80)) == 2 )
        {
          LogFatalError("%s explosion position and/or direction contains NANs", "CGameRules::QueueExplosion");
        }
        sub_140332A60(COERCE_DOUBLE((unsigned __int64)COERCE_UNSIGNED_INT(
                                                        1.0
                                                      - (float)((float)((float)(*(float *)(a2 + 0x78)
                                                                              * *(float *)(a2 + 0x78))
                                                                      + (float)(*(float *)(a2 + 0x7C)
                                                                              * *(float *)(a2 + 0x7C)))
                                                              + (float)(*(float *)(a2 + 0x80) * *(float *)(a2 + 0x80))))));
        sub_14037A290(a1 + 0x1A0LL * v6 + 0x588, a2);
        *(_BYTE *)(a1 + v6 + 0x6D88) = 1;
        sub_140464CC0(a1 + 0x1A0LL * v6 + 0x708);
        v8 = a1 + 0x1A0LL * v6 + 0x588;
        _StarEngineModule__(a1 + 0x538);
        sub_14645F0E0((_QWORD *)(a1 + 0x538), &v8);
      }
      sub_1402B1820(&v9);
    }
    else
    {
      v4 = (AK::WriteBytesMem *)sub_1403ADDB0(a2, (__int64)v11);
      v5 = (const char *)AK::WriteBytesMem::Bytes(v4);
      sub_1405C0E00(0xAu, 2u, "Explosion queued with a zone host that doesn't host a zone! Skipping explosion. %s", v5);
      sub_1402A2B40((__int64)v11);
    }
  }
  else
  {
    v2 = (AK::WriteBytesMem *)sub_1403ADDB0(a2, (__int64)v10);
    v3 = (const char *)AK::WriteBytesMem::Bytes(v2);
    sub_1405C0E00(0xAu, 2u, "Explosion queued without a valid zone host! Skipping explosion. %s", v3);
    sub_1402A2B40((__int64)v10);
  }
}

// --- End Function: sub_14646C840 (0x14646C840) ---

// --- Function: sub_14646D6C0 (0x14646D6C0) ---
const ULONG_PTR *__fastcall sub_14646D6C0(__int64 a1, unsigned __int64 *a2)
{
  void *v2; // rsp
  __int64 v4; // [rsp+18h] [rbp-2B8h]
  _BYTE v5[592]; // [rsp+30h] [rbp-2A0h] BYREF
  int v6; // [rsp+2D0h] [rbp+0h]
  _DWORD v8[2]; // [rsp+2D8h] [rbp+8h] BYREF
  char v9; // [rsp+2E0h] [rbp+10h] BYREF
  _DWORD v10[2]; // [rsp+2E8h] [rbp+18h] BYREF
  char v11; // [rsp+2F0h] [rbp+20h] BYREF
  __int64 v12; // [rsp+2F8h] [rbp+28h]
  const char *p_unknown; // [rsp+300h] [rbp+30h]
  __int64 v14; // [rsp+308h] [rbp+38h]
  const char *p_unknown_1; // [rsp+310h] [rbp+40h]
  _BYTE *v16; // [rsp+318h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+320h] [rbp+50h]
  ULONG_PTR Parameter; // [rsp+328h] [rbp+58h]
  __int64 v19; // [rsp+330h] [rbp+60h] BYREF
  __int64 v20; // [rsp+338h] [rbp+68h]
  unsigned __int64 *v21; // [rsp+340h] [rbp+70h]
  __int64 *v22; // [rsp+348h] [rbp+78h]
  __int64 v23; // [rsp+350h] [rbp+80h]
  _QWORD *v24; // [rsp+358h] [rbp+88h]
  _QWORD *v25; // [rsp+360h] [rbp+90h]
  _QWORD *v26; // [rsp+368h] [rbp+98h]
  _QWORD *v27; // [rsp+370h] [rbp+A0h]
  _QWORD *v28; // [rsp+378h] [rbp+A8h]
  __int64 *ThreadLogContextSlot; // [rsp+380h] [rbp+B0h]
  const void *v30; // [rsp+388h] [rbp+B8h]
  const void *v31; // [rsp+390h] [rbp+C0h]
  const void *v32; // [rsp+398h] [rbp+C8h]
  __int64 v33; // [rsp+3A0h] [rbp+D0h]
  __int64 v34; // [rsp+3A8h] [rbp+D8h]
  unsigned __int64 *v35; // [rsp+3B0h] [rbp+E0h]
  __int64 *v36; // [rsp+3B8h] [rbp+E8h]
  _QWORD v37[2]; // [rsp+3C0h] [rbp+F0h] BYREF
  const void *v38; // [rsp+3D0h] [rbp+100h]
  _QWORD v39[2]; // [rsp+3D8h] [rbp+108h] BYREF
  const void *v40; // [rsp+3E8h] [rbp+118h]
  _QWORD v41[2]; // [rsp+3F0h] [rbp+120h] BYREF
  const void *v42; // [rsp+400h] [rbp+130h]
  _QWORD src_[2]; // [rsp+408h] [rbp+138h] BYREF
  _QWORD src__1[2]; // [rsp+418h] [rbp+148h] BYREF
  _QWORD v45[2]; // [rsp+428h] [rbp+158h] BYREF
  _QWORD v46[2]; // [rsp+438h] [rbp+168h] BYREF
  char v47; // [rsp+448h] [rbp+178h]
  _QWORD v48[2]; // [rsp+450h] [rbp+180h] BYREF
  char v49; // [rsp+460h] [rbp+190h]
  __int64 n6; // [rsp+468h] [rbp+198h]
  __int64 v51; // [rsp+470h] [rbp+1A0h] BYREF
  __int64 v52; // [rsp+478h] [rbp+1A8h] BYREF
  _BYTE dst_[16]; // [rsp+480h] [rbp+1B0h] BYREF
  __int64 dst__1[2]; // [rsp+490h] [rbp+1C0h] BYREF

  sub_1402AE3D0(&v19, "CGameRules::ServerHit", a1 + 0x6E40, 1);
  if ( *(_DWORD *)(a1 + 0x6E10) )
  {
    if ( *(int *)(qword_149E7E430 + 0x250) > 0 )
    {
      v8[0] = sub_142744750(0x19u);
      v8[1] = 0x44;
      src_[0] = v8;
      src_[1] = &v9;
      qmemcpy(dst_, src_, sizeof(dst_));
      v6 = invokeGlobalCallbackAndMaskStatusBits(
             5,
             (__int64)dst_,
             (__int64)"Processing Hit",
             "$$: Queuing hit from '$$' [$$] on target '$$' [$$].");
      if ( (v6 & 0xFFFFF) != 0 )
      {
        v35 = a2 + 1;
        v36 = sub_1403B0A70(a2 + 1, &v51);
        v20 = sub_1402A24F0(*v36);
        v48[0] = 0;
        v48[1] = v20;
        v49 = 0;
        v24 = v48;
        if ( sub_14030EC00(a2 + 1) )
        {
          v12 = sub_14030ECF0(a2 + 1);
          p_unknown = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x70LL))(v12);
        }
        else
        {
          p_unknown = "unknown";
        }
        v41[0] = 0;
        v41[1] = p_unknown;
        v42 = 0;
        v25 = v41;
        v21 = a2;
        v22 = sub_1403B0A70(a2, &v52);
        v23 = sub_1402A24F0(*v22);
        v46[0] = 0;
        v46[1] = v23;
        v47 = 0;
        v26 = v46;
        if ( sub_14030EC00(a2) )
        {
          v14 = sub_14030ECF0(a2);
          p_unknown_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x70LL))(v14);
        }
        else
        {
          p_unknown_1 = "unknown";
        }
        v39[0] = 0;
        v39[1] = p_unknown_1;
        v40 = 0;
        v27 = v39;
        v37[0] = 0;
        v37[1] = "CGameRules::ServerHit";
        v38 = 0;
        v28 = v37;
        ThreadLogContextSlot = getThreadLogContextSlot();
        v45[0] = 0;
        v45[1] = 0;
        v10[0] = sub_142744750(0x19u);
        v10[1] = 0x44;
        src__1[0] = v10;
        src__1[1] = &v11;
        qmemcpy(dst__1, src__1, sizeof(dst__1));
        n6 = 6;
        v2 = alloca(0x2A0);
        v16 = v5;
        __Val_0__ = (vraudio::AudioBuffer *)v5;
        sub_143068F20((__int64)v5, (__int64)ThreadLogContextSlot, v28, v27, v26, v25, v24);
        LODWORD(v4) = v6;
        sub_1403045C0(
          5u,
          dst__1,
          "Processing Hit",
          "$$: Queuing hit from '$$' [$$] on target '$$' [$$].",
          __Val_0__,
          6u,
          1,
          v4,
          v45,
          0);
        v30 = v38;
        sub_1402A3D30(v38);
        v31 = v40;
        sub_1402A3D30(v40);
        v32 = v42;
        sub_1402A3D30(v42);
      }
    }
    v33 = a1 + 0x6DE8;
    Parameter = a1 + 0x6DE8;
    _StarEngineModule__(a1 + 0x6DE8);
    sub_14645EEC0((_QWORD *)Parameter, (__int64)a2);
    return sub_1402B1820(&v19);
  }
  else
  {
    ++*(_DWORD *)(a1 + 0x6E10);
    sub_14646A350(a1, (__int64)a2);
    while ( *(_QWORD *)(a1 + 0x6E08) != 0 )
    {
      v34 = sub_146475950(a1 + 0x6DE8);
      sub_14646A350(a1, v34);
      sub_1464759A0((_QWORD *)(a1 + 0x6DE8));
    }
    --*(_DWORD *)(a1 + 0x6E10);
    return sub_1402B1820(&v19);
  }
}

// --- End Function: sub_14646D6C0 (0x14646D6C0) ---

// --- Function: sub_146474FB0 (0x146474FB0) ---
unsigned __int64 __fastcall sub_146474FB0(_QWORD *a1, unsigned __int64 a2)
{
  __crt_strtox *v2; // rcx
  unsigned __int64 _Bytes; // rax
  unsigned __int64 result; // rax
  unsigned __int64 n8; // [rsp+20h] [rbp-B8h]
  char *v6; // [rsp+28h] [rbp-B0h]
  char *buf_1; // [rsp+28h] [rbp-B0h]
  char *buf; // [rsp+28h] [rbp-B0h]
  unsigned __int64 v9; // [rsp+30h] [rbp-A8h]
  char *buf_2; // [rsp+38h] [rbp-A0h]
  __int64 n8_2; // [rsp+40h] [rbp-98h]
  __int64 v12; // [rsp+50h] [rbp-88h] BYREF
  __int64 v13; // [rsp+58h] [rbp-80h] BYREF
  __int64 v14; // [rsp+60h] [rbp-78h]
  unsigned __int64 n8_1; // [rsp+68h] [rbp-70h]
  __int64 v16; // [rsp+70h] [rbp-68h]
  AK::WriteBytesCount *v17; // [rsp+78h] [rbp-60h]
  __int64 v18; // [rsp+80h] [rbp-58h]
  AK::WriteBytesCount *v19; // [rsp+88h] [rbp-50h]
  __int64 v20; // [rsp+90h] [rbp-48h]
  AK::WriteBytesCount *v21; // [rsp+98h] [rbp-40h]
  __int64 v22; // [rsp+A0h] [rbp-38h]
  AK::WriteBytesCount *v23; // [rsp+A8h] [rbp-30h]
  __int64 v24; // [rsp+B0h] [rbp-28h]
  _QWORD *v25; // [rsp+B8h] [rbp-20h]
  __int64 v26; // [rsp+C0h] [rbp-18h]
  __int64 v27; // [rsp+C8h] [rbp-10h]
  unsigned __int64 v30; // [rsp+E8h] [rbp+10h]

  if ( a1[2] )
    n8_2 = a1[2];
  else
    n8_2 = 1;
  for ( n8 = n8_2; ; n8 *= 2LL )
  {
    v2 = (__crt_strtox *)(n8 - a1[2]);
    if ( (unsigned __int64)v2 >= a2 && n8 >= 8 )
      break;
    v12 = 0xB60B60B60B60B6LL;
    v13 = __crt_strtox::maximum_signed_value(v2);
    v14 = *unknown_libname_2(&v13, &v12);
    if ( v14 - n8 < n8 )
      unknown_libname_73();
  }
  v9 = a1[3];
  n8_1 = n8;
  _Bytes = sub_1402A8570(n8);
  buf_2 = (char *)std::_Allocate<16,std::_Default_allocate_traits,0>(_Bytes);
  v30 = n8 - a1[2];
  v16 = a1[1] + 8LL * a1[2];
  v17 = (AK::WriteBytesCount *)(a1[1] + 8 * v9);
  v6 = sub_1428CF930(v17, v16, &buf_2[8 * v9]);
  if ( v9 > v30 )
  {
    v20 = a1[1] + 8 * v30;
    v21 = (AK::WriteBytesCount *)a1[1];
    sub_1428CF930(v21, v20, v6);
    v22 = a1[1] + 8 * v9;
    v23 = (AK::WriteBytesCount *)(a1[1] + 8 * v30);
    buf = sub_1428CF930(v23, v22, buf_2);
    sub_1428CE330(buf, v30);
  }
  else
  {
    v18 = a1[1] + 8 * v9;
    v19 = (AK::WriteBytesCount *)a1[1];
    buf_1 = sub_1428CF930(v19, v18, v6);
    sub_1428CE330(buf_1, v30 - v9);
    sub_1428CE330(buf_2, v9);
  }
  if ( a1[1] )
  {
    v26 = a1[1] + 8LL * a1[2];
    v27 = a1[1];
    v24 = a1[2];
    v25 = (_QWORD *)a1[1];
    std::_Deallocate<16,0>(v25, 8 * v24);
  }
  a1[1] = buf_2;
  result = v30 + a1[2];
  a1[2] = result;
  return result;
}

// --- End Function: sub_146474FB0 (0x146474FB0) ---

// --- Function: sub_146475950 (0x146475950) ---
__int64 __fastcall sub_146475950(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp-20h]
  _QWORD v3[3]; // [rsp+30h] [rbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 0x18);
  v3[0] = a1;
  v3[1] = v2;
  return sub_146460E50(v3);
}

// --- End Function: sub_146475950 (0x146475950) ---

// --- Function: sub_1464759A0 (0x1464759A0) ---
_QWORD *__fastcall sub_1464759A0(_QWORD *a1)
{
  _QWORD *result; // rax

  sub_140372D50(*(_QWORD *)(a1[1] + 8 * ((a1[2] - 1LL) & a1[3])));
  if ( --a1[4] )
  {
    result = (_QWORD *)(a1[3] + 1LL);
    a1[3] = result;
  }
  else
  {
    result = a1;
    a1[3] = 0;
  }
  return result;
}

// --- End Function: sub_1464759A0 (0x1464759A0) ---

// --- Function: sub_146481A00 (0x146481A00) ---
__int64 __fastcall sub_146481A00(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x200);
  if ( v1 )
    return sub_1442DD550(v1);
  else
    return 0;
}

// --- End Function: sub_146481A00 (0x146481A00) ---

// --- Function: sub_146481FD0 (0x146481FD0) ---
__int64 __fastcall sub_146481FD0(__int64 a1, const char *String2)
{
  __int64 v2; // r8
  __int64 v3; // rbx
  __int64 i; // rdi

  v2 = *(_QWORD *)(a1 + 0x6DC8);
  v3 = 0;
  if ( !((*(_QWORD *)(a1 + 0x6DD0) - v2) >> 4) )
    return 0;
  for ( i = 0; stricmp_w_3((const char **)(i + v2), String2); i += 0x10 )
  {
    v2 = *(_QWORD *)(a1 + 0x6DC8);
    if ( ++v3 >= (unsigned __int64)((*(_QWORD *)(a1 + 0x6DD0) - v2) >> 4) )
      return 0;
  }
  return (unsigned int)v3;
}

// --- End Function: sub_146481FD0 (0x146481FD0) ---

// --- Function: sub_1464823B0 (0x1464823B0) ---
_QWORD *__fastcall sub_1464823B0(__int64 a1, _QWORD *a2, int a3)
{
  __int64 v3; // r9

  if ( a3 < 0 || (v3 = *(_QWORD *)(a1 + 0x500), a3 >= (int)((*(_QWORD *)(a1 + 0x508) - v3) >> 4)) )
  {
    *a2 = 0;
    return a2;
  }
  else
  {
    *a2 = *(_QWORD *)(v3 + 0x10LL * a3);
    return a2;
  }
}

// --- End Function: sub_1464823B0 (0x1464823B0) ---

// --- Function: sub_1464830F0 (0x1464830F0) ---
__int64 __fastcall sub_1464830F0(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x200);
  if ( v1 )
    return sub_1442E10A0(v1);
  else
    return 0;
}

// --- End Function: sub_1464830F0 (0x1464830F0) ---

// --- Function: sub_1464831B0 (0x1464831B0) ---
__int64 __fastcall sub_1464831B0(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 0x200);
  if ( v1 )
    return sub_1442E1690(v1);
  else
    return 0;
}

// --- End Function: sub_1464831B0 (0x1464831B0) ---

// --- Function: sub_146489B70 (0x146489B70) ---
char __fastcall sub_146489B70(__int64 a1, __int64 a2, unsigned __int64 **a3)
{
  __int64 n2; // rax
  unsigned __int64 *v5; // r8
  unsigned __int64 *v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 (__fastcall *v9)(__int64, char *, unsigned __int64 *); // rdi
  __int16 n0xFFFF; // cx
  __int64 v11; // rcx
  __int64 n2_1; // r14
  unsigned __int64 *v13; // rbx
  __int64 v14; // rdi
  __int64 (__fastcall *v15)(__int64, char *, __int64 *); // rbp
  __int16 n0xFFFF_1; // ax
  unsigned __int64 *v17; // rdi
  __int16 n4; // dx
  __int64 v19; // rdi
  char v21[2]; // [rsp+20h] [rbp-68h] BYREF
  char v22[6]; // [rsp+22h] [rbp-66h] BYREF
  unsigned __int64 *v23; // [rsp+28h] [rbp-60h] BYREF
  char v24[8]; // [rsp+30h] [rbp-58h] BYREF
  char v25[8]; // [rsp+38h] [rbp-50h] BYREF
  char v26[16]; // [rsp+40h] [rbp-48h] BYREF
  unsigned __int64 v27; // [rsp+98h] [rbp+10h] BYREF
  __int64 v28; // [rsp+A8h] [rbp+20h] BYREF

  LODWORD(n2) = *(_DWORD *)(a2 + 0xE0);
  if ( (_DWORD)n2 == 1 )
  {
    (*(void (__fastcall **)(_QWORD, unsigned __int64 *, _QWORD))(**(_QWORD **)(a1 + 0x4C8) + 0x120LL))(
      *(_QWORD *)(a1 + 0x4C8),
      &v27,
      *(_QWORD *)(a2 + 8));
    LOBYTE(n2) = sub_14030EC00(&v27);
    if ( (_BYTE)n2 )
    {
      v5 = *a3;
      v6 = a3[1];
      if ( *a3 != v6 )
      {
        LOBYTE(n2) = v27;
        while ( *v5 != v27 )
        {
          v5 += 8;
          if ( v5 == v6 )
            return n2;
        }
        LOBYTE(n2) = sub_14648F280(a3, &v28, v5);
      }
    }
  }
  else if ( (_DWORD)n2 == 2 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)gEnv + 0x118LL))(gEnv, *(_QWORD *)(a2 + 8));
    v8 = v7;
    if ( v7 )
    {
      v9 = *(__int64 (__fastcall **)(__int64, char *, unsigned __int64 *))(*(_QWORD *)v7 + 0x340LL);
      n0xFFFF = n0xFFFF_76;
      if ( n0xFFFF_76 == (__int16)0xFFFF )
      {
        n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                     + 0x10LL))(
                              qword_149B4FC88,
                              v21,
                              "IEntityComponentHostility");
        n0xFFFF_76 = n0xFFFF;
      }
      LOWORD(v27) = n0xFFFF;
      v11 = *(_QWORD *)v9(v8, v24, &v27);
    }
    else
    {
      v11 = 0;
    }
    v28 = v11;
    n2 = sub_140501090(&v28);
    n2_1 = n2;
    if ( n2 )
    {
      v13 = *a3;
      while ( v13 != a3[1] )
      {
        LOBYTE(n2) = sub_14030EC00(v13);
        if ( !(_BYTE)n2 )
          goto LABEL_31;
        v14 = *v13 & 0xFFFFFFFFFFFFLL;
        v15 = *(__int64 (__fastcall **)(__int64, char *, __int64 *))(*(_QWORD *)v14 + 0x340LL);
        n0xFFFF_1 = n0xFFFF_76;
        if ( n0xFFFF_76 == (__int16)0xFFFF )
        {
          n0xFFFF_1 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                         + 0x10LL))(
                                  qword_149B4FC88,
                                  v22,
                                  "IEntityComponentHostility");
          n0xFFFF_76 = n0xFFFF_1;
        }
        LOWORD(v28) = n0xFFFF_1;
        n2 = v15(v14, v25, &v28);
        v17 = *(unsigned __int64 **)n2;
        v23 = v17;
        if ( !v17 )
          goto LABEL_27;
        n2 = sub_1403B4B50((unsigned __int64)v17 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(n2 + 4);
        if ( n4 == 4 || *(_WORD *)(n2 + 2) != (HIWORD(v17) & 0xFFF) )
          goto LABEL_27;
        if ( n4 == 2 && (n2 = NtCurrentTeb_w(), !*(_QWORD *)n2) || (LOBYTE(n2) = sub_14031FE20(&v23), (_BYTE)n2) )
          v19 = (unsigned __int64)v17 & 0xFFFFFFFFFFFFLL;
        else
LABEL_27:
          v19 = 0;
        if ( v19
          && (LODWORD(n2) = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)n2_1 + 0x5C0LL))(
                              n2_1,
                              v19,
                              0),
              (_DWORD)n2 == 2) )
        {
          n2 = sub_14648F280(a3, v26, v13);
          v13 = *(unsigned __int64 **)n2;
        }
        else
        {
LABEL_31:
          v13 += 8;
        }
      }
    }
  }
  return n2;
}

// --- End Function: sub_146489B70 (0x146489B70) ---

// --- Function: sub_14648CE80 (0x14648CE80) ---
double __fastcall sub_14648CE80(__int64 a1, __int64 a2, _BYTE *dst, __int64 a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int128 v9; // xmm11
  __int128 v10; // xmm12
  __int128 v11; // xmm13
  __int128 v12; // xmm14
  __int128 v13; // xmm15
  __int64 v14; // r15
  __int64 v15; // rsi
  __int64 v17; // r12
  __int64 v18; // r14
  __int64 v19; // rbx
  __int64 v20; // rdi
  bool v21; // al
  _QWORD *v22; // rbx
  _QWORD *v23; // rax
  __int64 v24; // rcx
  __int64 v25; // rax
  char *v26; // r12
  double *v27; // rax
  double v28; // xmm1_8
  double *v29; // rax
  double v30; // xmm11_8
  double v31; // xmm9_8
  double v32; // xmm4_8
  double v33; // xmm7_8
  double *v34; // rax
  double v35; // xmm13_8
  double v36; // xmm12_8
  double v37; // xmm10_8
  double v38; // xmm8_8
  double v39; // xmm6_8
  double v40; // xmm4_8
  float v41; // xmm1_4
  double v43; // xmm15_8
  double *v44; // rax
  double v47; // xmm7_8
  double v48; // xmm6_8
  __int128 v49; // xmm5
  __int128 v50; // xmm6
  __int128 v51; // xmm4
  __int128 v52; // kr00_16
  double v60; // xmm7_8
  __int128 v61; // xmm5
  __int64 *v62; // rcx
  __int128 v63; // xmm4
  __int64 v64; // rax
  __int128 v65; // xmm3
  __int64 v72; // rdi
  __int64 (__fastcall *v73)(__int64, __int128 *, __int16 *); // r14
  __int16 n0xFFFF; // ax
  __int64 v75; // rdi
  __int64 v76; // rax
  __int16 n4; // cx
  int v78; // eax
  float Src_2; // r14d
  _DWORD *v80; // rdi
  unsigned __int64 v81; // rcx
  char *v82; // rsi
  __int64 v83; // rdi
  unsigned __int64 v84; // r12
  unsigned __int64 v85; // rcx
  unsigned __int64 v86; // rdx
  __int64 v87; // r14
  unsigned __int64 allocSize; // r14
  char *v89; // r15
  __int64 v90; // rdi
  char *v91; // rcx
  char *v92; // rdx
  size_t Size; // r8
  char *v94; // rax
  char *v95; // r12
  char *v96; // rcx
  int v97; // r14d
  char *v98; // rdx
  __int64 v99; // rdi
  _QWORD *v100; // rbx
  _QWORD *v101; // rcx
  __int64 v102; // rax
  double *v103; // rax
  double v104; // xmm1_8
  double *v105; // rax
  double v106; // xmm11_8
  double v107; // xmm9_8
  double v108; // xmm4_8
  double *v109; // r15
  double v110; // xmm13_8
  double v111; // xmm12_8
  double v112; // xmm10_8
  double v113; // xmm8_8
  double v114; // kr00_8
  double v115; // xmm4_8
  double v116; // xmm3_8
  double v117; // xmm1_8
  float v118; // xmm1_4
  __int64 v119; // rax
  double v120; // xmm11_8
  double v121; // xmm10_8
  double v122; // xmm4_8
  double v123; // xmm8_8
  double v124; // xmm14_8
  __int128 v125; // xmm15
  double v126; // xmm13_8
  double v127; // xmm6_8
  double v128; // xmm5_8
  double v129; // xmm4_8
  double v130; // xmm2_8
  double v131; // xmm0_8
  double v132; // xmm4_8
  double v133; // xmm9_8
  __int128 v134; // xmm12
  double v137; // xmm10_8
  double v138; // xmm2_8
  double v139; // xmm7_8
  double v140; // xmm6_8
  double v141; // xmm4_8
  double v142; // xmm5_8
  double v143; // xmm4_8
  double v144; // xmm6_8
  double v145; // kr00_8
  __int128 v146; // xmm14
  double v147; // xmm0_8
  double v148; // xmm5_8
  __int128 v151; // kr00_16
  double v152; // kr00_8
  double v153; // xmm10_8
  double v154; // xmm0_8
  double v155; // xmm4_8
  __int128 v156; // xmm3
  double v157; // xmm1_8
  __int128 v158; // xmm0
  double v162; // xmm11_8
  __int128 v166; // xmm2
  __int128 v167; // xmm7
  __int128 v168; // xmm6
  __int128 v169; // xmm4
  __int128 v170; // xmm5
  __int128 v171; // xmm4
  __int128 v172; // xmm3
  char *v179; // rcx
  int v181; // [rsp+28h] [rbp-E0h]
  __int64 v182; // [rsp+38h] [rbp-D0h] BYREF
  float Src; // [rsp+40h] [rbp-C8h]
  void *Src_8[2]; // [rsp+48h] [rbp-C0h] BYREF
  char *v185; // [rsp+58h] [rbp-B0h]
  __int64 v186; // [rsp+60h] [rbp-A8h]
  _QWORD v187[3]; // [rsp+68h] [rbp-A0h] BYREF
  unsigned __int64 v188; // [rsp+80h] [rbp-88h] BYREF
  __int128 v189; // [rsp+88h] [rbp-80h] BYREF
  double v190; // [rsp+98h] [rbp-70h]
  char v191[8]; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v192; // [rsp+A8h] [rbp-60h]
  __int64 v193; // [rsp+B8h] [rbp-50h] BYREF
  float Src_1; // [rsp+C0h] [rbp-48h]
  float v195; // [rsp+C4h] [rbp-44h]
  float v196; // [rsp+C8h] [rbp-40h]
  float v197; // [rsp+CCh] [rbp-3Ch]
  float v198; // [rsp+D0h] [rbp-38h]
  float v199; // [rsp+D4h] [rbp-34h]
  float v200; // [rsp+D8h] [rbp-30h]
  char *v201; // [rsp+E0h] [rbp-28h] BYREF
  __int128 v202; // [rsp+E8h] [rbp-20h]
  double v203; // [rsp+F8h] [rbp-10h] BYREF
  double v204; // [rsp+100h] [rbp-8h]
  double v205; // [rsp+108h] [rbp+0h]
  __int64 v206; // [rsp+110h] [rbp+8h]
  __int128 v207; // [rsp+118h] [rbp+10h] BYREF
  double v208; // [rsp+138h] [rbp+30h]
  int n0x4000; // [rsp+148h] [rbp+40h] BYREF
  __int64 v210; // [rsp+14Ch] [rbp+44h]
  int v211; // [rsp+154h] [rbp+4Ch]
  unsigned __int64 v212; // [rsp+158h] [rbp+50h]
  unsigned __int64 v213; // [rsp+160h] [rbp+58h]
  __int64 v214; // [rsp+168h] [rbp+60h]
  __int64 v215; // [rsp+170h] [rbp+68h]
  double v216; // [rsp+198h] [rbp+90h] BYREF
  double v217; // [rsp+1A0h] [rbp+98h]
  double v218; // [rsp+1A8h] [rbp+A0h]
  double v219; // [rsp+1B0h] [rbp+A8h]
  double v220; // [rsp+1B8h] [rbp+B0h]
  double v221; // [rsp+1C0h] [rbp+B8h]
  double v222; // [rsp+1C8h] [rbp+C0h]
  double v223; // [rsp+1D0h] [rbp+C8h]
  _DWORD v224[14]; // [rsp+1D8h] [rbp+D0h] BYREF
  unsigned __int64 v225; // [rsp+210h] [rbp+108h]
  __int64 v226; // [rsp+218h] [rbp+110h]
  unsigned __int64 v227; // [rsp+220h] [rbp+118h]
  __int64 v228; // [rsp+228h] [rbp+120h]
  unsigned __int64 v229; // [rsp+230h] [rbp+128h]
  unsigned int v230; // [rsp+238h] [rbp+130h]
  unsigned int v231; // [rsp+23Ch] [rbp+134h]
  unsigned int v232; // [rsp+240h] [rbp+138h]
  unsigned int v233; // [rsp+244h] [rbp+13Ch]
  unsigned __int64 v234; // [rsp+248h] [rbp+140h]
  unsigned int v235; // [rsp+250h] [rbp+148h]
  unsigned __int64 v236; // [rsp+258h] [rbp+150h]
  unsigned int v237; // [rsp+260h] [rbp+158h]
  unsigned __int64 v238; // [rsp+268h] [rbp+160h]
  unsigned int v239; // [rsp+274h] [rbp+16Ch]
  int v240; // [rsp+278h] [rbp+170h]
  unsigned int v241; // [rsp+27Ch] [rbp+174h]
  unsigned __int64 v242; // [rsp+280h] [rbp+178h]
  __int128 v243; // [rsp+288h] [rbp+180h]
  __int128 v244; // [rsp+298h] [rbp+190h]
  unsigned int v245; // [rsp+2A8h] [rbp+1A0h]
  unsigned int v246; // [rsp+2ACh] [rbp+1A4h]
  unsigned int v247; // [rsp+2B0h] [rbp+1A8h]
  unsigned __int64 v248; // [rsp+2B8h] [rbp+1B0h]
  unsigned int v249; // [rsp+2C0h] [rbp+1B8h]
  unsigned __int64 v250; // [rsp+2C8h] [rbp+1C0h]
  unsigned int v251; // [rsp+2D0h] [rbp+1C8h]
  __int64 v252; // [rsp+2D8h] [rbp+1D0h]
  int v253; // [rsp+2E0h] [rbp+1D8h]
  __int64 v254; // [rsp+2E8h] [rbp+1E0h]
  char v255[8]; // [rsp+2F8h] [rbp+1F0h] BYREF
  char v256[8]; // [rsp+300h] [rbp+1F8h] BYREF
  _BYTE v257[64]; // [rsp+308h] [rbp+200h] BYREF
  __int128 v258; // [rsp+348h] [rbp+240h]
  __int128 v259; // [rsp+358h] [rbp+250h]
  __int128 v260; // [rsp+368h] [rbp+260h]
  __int128 v261; // [rsp+378h] [rbp+270h]
  __int128 v262; // [rsp+388h] [rbp+280h]
  __int128 v263; // [rsp+398h] [rbp+290h]
  __int128 v264; // [rsp+3A8h] [rbp+2A0h]
  __int128 v265; // [rsp+3B8h] [rbp+2B0h]
  __int128 v266; // [rsp+3C8h] [rbp+2C0h]
  __int128 v267; // [rsp+3D8h] [rbp+2D0h]
  __int16 n0xFFFF_1; // [rsp+438h] [rbp+330h] BYREF
  __int64 v270; // [rsp+440h] [rbp+338h]

  v270 = a4;
  v267 = v4;
  v14 = 0;
  v266 = v5;
  v15 = a4;
  v265 = v6;
  v264 = v7;
  v17 = a2;
  v263 = v8;
  v262 = v9;
  v261 = v10;
  v260 = v11;
  v259 = v12;
  v258 = v13;
  n0x4000 = 0x4000;
  v210 = 1;
  v211 = 0;
  v213 = 0;
  v214 = 0;
  v215 = 0;
  v212 = __rdtsc();
  qword_149B4B870(
    &n0x4000,
    &word_149E7DF88,
    "CGameRules::UpdateAffectedEntitiesSet",
    "W:/p4-src/CryEngine/Code/GameSDK/GameDll/GameRules.cpp",
    0x812);
  *(_OWORD *)Src_8 = 0;
  HIWORD(n0x4000) = word_149E7DF88;
  v185 = 0;
  LODWORD(v187[0]) = 0;
  if ( *((int *)dst + 0x22) > 0 )
  {
    v18 = 0;
    v206 = 0;
    v192 = 0;
    while ( 1 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)gEnv + 0x180LL))(
        gEnv,
        &v182,
        *(_QWORD *)(v14 + *((_QWORD *)dst + 0xF)));
      v19 = v182;
      if ( v182 )
      {
        v20 = (v182 & 0xF000000000000000uLL) != 0 ? v182 & 0xFFFFFF000000LL : (v182 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v20 + 2) == (HIWORD(v182) & 0xFFF) )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v21 = sub_140539D80(), v19 = v182, v21) )
            v21 = 1;
          if ( *(_WORD *)(v20 + 4) == 2 && v21 )
            goto LABEL_15;
          if ( sub_140392020(&v182) )
            break;
        }
      }
LABEL_70:
      v18 += 4;
      v192 = v18;
      v14 += 8;
      ++LODWORD(v187[0]);
      v206 = v14;
      if ( SLODWORD(v187[0]) >= *((_DWORD *)dst + 0x22) )
        goto LABEL_71;
    }
    v19 = v182;
LABEL_15:
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v19 & 0xFFFFFFFFFFFFLL) + 0x318LL))(v19 & 0xFFFFFFFFFFFFLL) )
    {
      v22 = *(_QWORD **)v17;
      v23 = *(_QWORD **)(v17 + 8);
      v24 = v182;
      if ( *(_QWORD **)v17 == v23 )
        goto LABEL_20;
      do
      {
        if ( *v22 == v182 )
          break;
        v22 += 8;
      }
      while ( v22 != v23 );
      if ( v22 == v23 )
      {
LABEL_20:
        v25 = *((_QWORD *)dst + 0x10);
        v26 = 0;
        v201 = 0;
        v193 = v182;
        v202 = 0;
        Src = *(float *)(v18 + v25);
        Src_1 = Src;
        if ( v15 )
        {
          v27 = (double *)(*(__int64 (__fastcall **)(__int64, double *, _BYTE *))(*(_QWORD *)v15 + 0x170LL))(
                            v15,
                            &v203,
                            dst);
          v24 = v182;
        }
        else
        {
          v28 = *((double *)dst + 2);
          v189 = *(_OWORD *)dst;
          v190 = v28;
          v27 = (double *)&v189;
        }
        *(_OWORD *)&v187[1] = *(_OWORD *)v27;
        v208 = v27[2];
        if ( v15 )
        {
          v29 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v15 + 0x68LL))(v15, v257, 0);
          v30 = v29[1];
          v31 = v29[2];
          v32 = v29[3];
          v33 = *v29;
          v24 = v182;
          v34 = &v203;
          v35 = *((float *)dst + 0x16);
          v36 = *((float *)dst + 0x15);
          v37 = *((float *)dst + 0x14);
          v38 = v30 * v35 - v31 * v36 + v32 * v37;
          v39 = v37 * v31 - v33 * v35 + v32 * v36;
          v40 = v33 * v36 - v37 * v30 + v32 * v35;
          v203 = v40 * v30 - v39 * v31 + v37 + v40 * v30 - v39 * v31;
          v205 = v35 + v39 * v33 - v38 * v30 + v39 * v33 - v38 * v30;
          v204 = v36 + v38 * v31 - v40 * v33 + v38 * v31 - v40 * v33;
        }
        else
        {
          v41 = *((float *)dst + 0x15);
          *(double *)&v189 = *((float *)dst + 0x14);
          v190 = *((float *)dst + 0x16);
          *((double *)&v189 + 1) = v41;
          v34 = (double *)&v189;
        }
        _XMM14 = *(_OWORD *)v34;
        v43 = v34[2];
        LOBYTE(v181) = 1;
        v44 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD, int))(*(_QWORD *)(v24 & 0xFFFFFFFFFFFFLL)
                                                                                         + 0x1E8LL))(
                          v24 & 0xFFFFFFFFFFFFLL,
                          v257,
                          0,
                          0,
                          v181);
        sub_1404B6AF0(v44, &v216);
        _XMM4 = *(_OWORD *)&v187[1];
        __asm { vunpckhpd xmm8, xmm4, xmm4 }
        v47 = v217 * v208 - v218 * *(double *)&_XMM8 + v219 * *(double *)&v187[1];
        v48 = v218 * *(double *)&v187[1] - v216 * v208 + v219 * *(double *)&_XMM8;
        *(double *)&_XMM4 = v216 * *(double *)&_XMM8 - v217 * *(double *)&v187[1] + v219 * v208;
        v49 = COERCE_UNSIGNED_INT64(*(double *)&_XMM4 * v217 - v48 * v218);
        v50 = COERCE_UNSIGNED_INT64(v48 * v216 - v47 * v217);
        v51 = COERCE_UNSIGNED_INT64(v47 * v218 - *(double *)&_XMM4 * v216);
        *((_QWORD *)&v52 + 1) = *((_QWORD *)&v49 + 1);
        *(double *)&v52 = (*(double *)&v49 + *(double *)&v187[1] + *(double *)&v49) * v223 + v220;
        _XMM1 = v52;
        __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
        v195 = *(float *)&_XMM2;
        *((_QWORD *)&v52 + 1) = *((_QWORD *)&v51 + 1);
        *(double *)&v52 = (*(double *)&v51 + *(double *)&_XMM8 + *(double *)&v51) * v223 + v221;
        _XMM3 = v52;
        __asm { vcvtsd2ss xmm0, xmm3, xmm3 }
        v196 = *(float *)&_XMM0;
        *((_QWORD *)&v52 + 1) = *((_QWORD *)&v50 + 1);
        *(double *)&v52 = (*(double *)&v50 + v208 + *(double *)&v50) * v223 + v222;
        _XMM3 = v52;
        __asm { vcvtsd2ss xmm1, xmm3, xmm3 }
        v197 = *(float *)&_XMM1;
        __asm { vunpckhpd xmm8, xmm14, xmm14 }
        v60 = v217 * v43 - v218 * *(double *)&_XMM8 + *(double *)&_XMM14 * v219;
        *(double *)&v50 = v218 * *(double *)&_XMM14 - v216 * v43 + v219 * *(double *)&_XMM8;
        *(double *)&v51 = v216 * *(double *)&_XMM8 - v217 * *(double *)&_XMM14 + v219 * v43;
        v208 = v43;
        v61 = COERCE_UNSIGNED_INT64(*(double *)&v51 * v217 - *(double *)&v50 * v218);
        v62 = *(__int64 **)(v14 + *((_QWORD *)dst + 0xF));
        v63 = COERCE_UNSIGNED_INT64(v60 * v218 - *(double *)&v51 * v216);
        *((_QWORD *)&v52 + 1) = 0;
        v64 = *v62;
        *(double *)&v52 = *(double *)&v50 * v216 - v60 * v217;
        v65 = v52;
        *((_QWORD *)&v52 + 1) = *((_QWORD *)&v61 + 1);
        *(double *)&v52 = *(double *)&v61 + *(double *)&_XMM14 + *(double *)&v61;
        _XMM2 = v52;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *((_QWORD *)&v52 + 1) = *((_QWORD *)&v63 + 1);
        *(double *)&v52 = *(double *)&v63 + *(double *)&_XMM8 + *(double *)&v63;
        _XMM2 = v52;
        v198 = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *((_QWORD *)&v52 + 1) = *((_QWORD *)&v65 + 1);
        *(double *)&v52 = *(double *)&v65 + v43 + *(double *)&v65;
        _XMM2 = v52;
        v199 = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        v200 = *(float *)&_XMM1;
        if ( (*(unsigned int (__fastcall **)(__int64 *))(v64 + 8))(v62) == 2 )
        {
          v72 = v182 & 0xFFFFFFFFFFFFLL;
          v73 = *(__int64 (__fastcall **)(__int64, __int128 *, __int16 *))(*(_QWORD *)(v182 & 0xFFFFFFFFFFFFLL) + 0x340LL);
          n0xFFFF = n0xFFFF_10;
          if ( n0xFFFF_10 == (__int16)0xFFFF )
          {
            n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                         + 0x10LL))(
                                  qword_149B4FC88,
                                  v191,
                                  "EntityComponentHealth");
            n0xFFFF_10 = n0xFFFF;
          }
          n0xFFFF_1 = n0xFFFF;
          v75 = *(_QWORD *)v73(v72, &v207, &n0xFFFF_1);
        }
        else
        {
          v75 = 0;
        }
        v187[1] = v75;
        if ( Src > 0.0 )
        {
          if ( v75
            && (v76 = sub_1403B4B50(v75 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v76 + 4), n4 != 4)
            && *(_WORD *)(v76 + 2) == (HIWORD(v75) & 0xFFF)
            && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v187[1]))
            && (unsigned __int8)sub_144023B60(v75 & 0xFFFFFFFFFFFFLL)
            || (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(v14 + *((_QWORD *)dst + 0xF)) + 8LL))(*(_QWORD *)(v14 + *((_QWORD *)dst + 0xF))) == 6 )
          {
            v187[1] = 0;
            v78 = (*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD, _QWORD *))(*(_QWORD *)qword_149B4FC00 + 0x258LL))(
                    qword_149B4FC00,
                    dst,
                    *(_QWORD *)(v14 + *((_QWORD *)dst + 0xF)),
                    &v187[1]);
            sub_140342500(&v201, v187[1], v78);
            v26 = v201;
          }
        }
        Src = 0.0;
        Src_2 = 0.0;
        v186 = (__int64)(v202 - (_QWORD)v26) >> 3;
        if ( v186 )
        {
          v80 = v26 + 4;
          v81 = (__int64)(v202 - (_QWORD)v26) >> 3;
          v187[1] = v26 + 4;
          do
          {
            if ( *(float *)v80 > 0.0 )
            {
              v243 = xmmword_14819FFD0;
              v224[0xC] = 0;
              v225 = 0x8000000000000000uLL;
              v240 = 0;
              v228 = 0;
              v226 = 0;
              v252 = 0;
              v253 = 0;
              v254 = 0;
              v244 = xmmword_148BA5248;
              v224[0] = 6;
              v224[4] = 0xFFBFFFFF;
              v224[0xA] = 0xFFBFFFFF;
              v224[0xD] = 0xFFBFFFFF;
              v224[2] = 0x80000000;
              v230 = 0xFFBFFFFF;
              v231 = 0xFFBFFFFF;
              v234 = 0xFFFFFFFFFFFFFFFFuLL;
              v235 = 0x80000000;
              v236 = 0xFFFFFFFFFFFFFFFFuLL;
              v238 = 0xFFFFFFFFFFFFFFFFuLL;
              v232 = 0xFFBFFFFF;
              v233 = 0xFFBFFFFF;
              v237 = 0x80000000;
              v239 = 0xFFBFFFFF;
              v241 = 0x80000000;
              v242 = 0xFFFFFFFFFFFFFFFFuLL;
              v245 = 0xFFBFFFFF;
              v246 = 0xFFBFFFFF;
              v247 = 0xFFBFFFFF;
              v250 = 0xFFFFFFFFFFFFFFFFuLL;
              v224[0xB] = 0x80000000;
              v251 = 0xFFBFFFFF;
              v248 = 0xFFFFFFFFFFFFFFFFuLL;
              v249 = 0x80000000;
              v224[3] = 1;
              v229 = 0xFFFFFFFFFFFFFFFFuLL;
              v227 = 0xFFFFFFFFFFFFFFFFuLL;
              v224[1] = v80[0xFFFFFFFF];
              if ( (*(unsigned int (__fastcall **)(_QWORD, _DWORD *))(**(_QWORD **)(v14 + *((_QWORD *)dst + 0xF))
                                                                    + 0x20LL))(
                     *(_QWORD *)(v14 + *((_QWORD *)dst + 0xF)),
                     v224) )
              {
                if ( (v243 & 0x42) != 0 )
                {
                  v188 = v242;
                  if ( sub_14030EC00(&v188)
                    && !(*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v188 & 0xFFFFFFFFFFFFLL)
                                                                            + 0x318LL))(v188 & 0xFFFFFFFFFFFFLL)
                    && v188 != v182 )
                  {
                    v82 = (char *)Src_8[1];
                    if ( Src_8[1] == v185 )
                    {
                      v83 = ((char *)Src_8[1] - (char *)Src_8[0]) >> 4;
                      if ( v83 == 0xFFFFFFFFFFFFFFFLL )
                        unknown_libname_10();
                      v84 = v83 + 1;
                      v85 = (v185 - (char *)Src_8[0]) >> 4;
                      v86 = v85 >> 1;
                      if ( v85 <= 0xFFFFFFFFFFFFFFFLL - (v85 >> 1) )
                      {
                        v87 = v86 + v85;
                        if ( v86 + v85 < v84 )
                          v87 = v83 + 1;
                      }
                      else
                      {
                        v87 = 0xFFFFFFFFFFFFFFFLL;
                      }
                      allocSize = 0x10 * v87;
                      v89 = (char *)sub_140391AB0((__int64)Src_8, allocSize);
                      v90 = 0x10 * v83;
                      *(_QWORD *)&v89[v90] = v188;
                      *(_DWORD *)&v89[v90 + 8] = *(_DWORD *)v187[1];
                      v91 = v89;
                      v92 = (char *)Src_8[0];
                      if ( v82 == Src_8[1] )
                      {
                        Size = (char *)Src_8[1] - (char *)Src_8[0];
                      }
                      else
                      {
                        memmove(v89, Src_8[0], v82 - (char *)Src_8[0]);
                        v91 = &v89[v90 + 0x10];
                        v92 = v82;
                        Size = (char *)Src_8[1] - (char *)v82;
                      }
                      memmove(v91, v92, Size);
                      if ( Src_8[0] )
                        sub_1403A3120((__int64)Src_8, Src_8[0], (v185 - (char *)Src_8[0]) & 0xFFFFFFFFFFFFFFF0uLL);
                      v80 = (_DWORD *)v187[1];
                      v94 = &v89[allocSize];
                      Src_2 = Src;
                      v95 = &v89[0x10 * v84];
                      Src_8[0] = v89;
                      v14 = v206;
                      Src_8[1] = v95;
                      v185 = v94;
                    }
                    else
                    {
                      *(_QWORD *)Src_8[1] = v188;
                      *((_DWORD *)v82 + 2) = *v80;
                      Src_8[1] = (char *)Src_8[1] + 0x10;
                    }
                  }
                }
              }
              v81 = v186;
            }
            ++LODWORD(Src_2);
            v80 += 2;
            Src = Src_2;
            v187[1] = v80;
          }
          while ( SLODWORD(Src_2) < v81 );
          v15 = v270;
        }
        v17 = a2;
        sub_14647A930(a2, v255, v22, &v193);
        v96 = v201;
        if ( v201 )
        {
          if ( ((*((_QWORD *)&v202 + 1) - (_QWORD)v201) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
          {
            v96 = (char *)*((_QWORD *)v201 + 0xFFFFFFFF);
            if ( (unsigned __int64)(v201 - v96 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_1402A3D30(v96);
        }
        v18 = v192;
      }
    }
    goto LABEL_70;
  }
LABEL_71:
  v97 = 0;
  v98 = (char *)Src_8[0];
  if ( ((char *)Src_8[1] - (char *)Src_8[0]) >> 4 )
  {
    v99 = 0;
    do
    {
      v100 = *(_QWORD **)v17;
      v101 = *(_QWORD **)(v17 + 8);
      v102 = *(_QWORD *)&v98[v99];
      if ( *(_QWORD **)v17 == v101 )
        goto LABEL_77;
      do
      {
        if ( *v100 == v102 )
          break;
        v100 += 8;
      }
      while ( v100 != v101 );
      if ( v100 == v101 )
      {
LABEL_77:
        v201 = 0;
        v193 = v102;
        Src_1 = *(float *)&v98[v99 + 8];
        v202 = 0;
        if ( v15 )
        {
          v103 = (double *)(*(__int64 (__fastcall **)(__int64, double *, _BYTE *))(*(_QWORD *)v15 + 0x170LL))(
                             v15,
                             &v203,
                             dst);
          v98 = (char *)Src_8[0];
        }
        else
        {
          v104 = *((double *)dst + 2);
          v189 = *(_OWORD *)dst;
          v190 = v104;
          v103 = (double *)&v189;
        }
        v207 = *(_OWORD *)v103;
        v208 = v103[2];
        if ( v15 )
        {
          v105 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v15 + 0x68LL))(v15, v257, 0);
          v106 = v105[1];
          v107 = v105[2];
          v108 = v105[3];
          v98 = (char *)Src_8[0];
          v109 = (double *)&v189;
          v110 = *((float *)dst + 0x16);
          v111 = *((float *)dst + 0x15);
          v112 = *((float *)dst + 0x14);
          v113 = v106 * v110 - v107 * v111 + v108 * v112;
          v114 = v112 * v107 - *v105 * v110 + v108 * v111;
          v115 = *v105 * v111 - v112 * v106 + v108 * v110;
          v116 = v114 * *v105 - v113 * v106;
          v117 = v113 * v107 - v115 * *v105 + v111 + v113 * v107 - v115 * *v105;
          *(double *)&v189 = v115 * v106 - v114 * v107 + v112 + v115 * v106 - v114 * v107;
          v190 = v116 + v110 + v116;
          *((double *)&v189 + 1) = v117;
        }
        else
        {
          v118 = *((float *)dst + 0x15);
          v203 = *((float *)dst + 0x14);
          v205 = *((float *)dst + 0x16);
          v204 = v118;
          v109 = &v203;
        }
        LOBYTE(v181) = 1;
        v119 = (*(__int64 (__fastcall **)(__int64, double *, _QWORD, _QWORD, int))(*(_QWORD *)(*(_QWORD *)&v98[v99]
                                                                                             & 0xFFFFFFFFFFFFLL)
                                                                                 + 0x1E8LL))(
                 *(_QWORD *)&v98[v99] & 0xFFFFFFFFFFFFLL,
                 &v216,
                 0,
                 0,
                 v181);
        v120 = *(double *)(v119 + 8);
        v121 = *(double *)(v119 + 0x10);
        v122 = *(double *)(v119 + 0x30);
        v123 = *(double *)(v119 + 0x18);
        v124 = *(double *)(v119 + 0x20);
        v125 = *(unsigned __int64 *)(v119 + 0x28);
        v126 = -(1.0 / *(double *)(v119 + 0x38));
        v127 = v121 * *(double *)&v125 - v120 * v122 + v123 * v124;
        v128 = v122 * *(double *)v119 - v124 * v121 + v123 * *(double *)&v125;
        v129 = v124 * v120 - *(double *)v119 * *(double *)&v125 + v123 * v122;
        v130 = v129 * *(double *)v119;
        v131 = v129 * v120;
        v132 = v123;
        v133 = v121 * v128 - v131;
        v134 = COERCE_UNSIGNED_INT64(v127 * v120 - *(double *)v119 * v128);
        _XMM3 = v207;
        __asm { vunpckhpd xmm8, xmm3, xmm3 }
        v137 = v130 - v127 * v121;
        *(_QWORD *)&v138 = *(_QWORD *)(v119 + 0x10) ^ 0x8000000000000000uLL;
        v139 = v208 * COERCE_DOUBLE(*(_QWORD *)&v120 ^ 0x8000000000000000uLL)
             - *(double *)&_XMM8 * v138
             + v132 * *(double *)&v207;
        v140 = *(double *)&v207 * v138
             - v208 * COERCE_DOUBLE(*(_QWORD *)v119 ^ 0x8000000000000000uLL)
             + v132 * *(double *)&_XMM8;
        v141 = *(double *)&_XMM8 * COERCE_DOUBLE(*(_QWORD *)v119 ^ 0x8000000000000000uLL)
             - *(double *)&v207 * COERCE_DOUBLE(*(_QWORD *)&v120 ^ 0x8000000000000000uLL)
             + v132 * v208;
        v142 = v140 * *(double *)(v119 + 0x10) - v141 * v120;
        v143 = v141 * *(double *)v119 - v139 * *(double *)(v119 + 0x10);
        v144 = v139 * v120 - v140 * *(double *)v119;
        v145 = v124 + v133;
        v146 = *((unsigned __int64 *)v109 + 2);
        v147 = v142 + *(double *)&v207 + v142;
        v148 = 1.0 / *(double *)(v119 + 0x38);
        _XMM3 = COERCE_UNSIGNED_INT64((v145 + v133) * v126 + v147 * v148);
        __asm { vcvtsd2ss xmm2, xmm3, xmm3 }
        v195 = *(float *)&_XMM2;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v125 + 1);
        v152 = *(double *)&v125 + v137 + v137;
        v153 = *(double *)(v119 + 0x10);
        v154 = v143 + *(double *)&_XMM8 + v143;
        v155 = *(double *)(v119 + 0x18);
        *(double *)&v151 = v152 * v126;
        v156 = v151;
        v157 = v154 * v148;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v134 + 1);
        *(double *)&v151 = *(double *)&v134 + *(double *)(v119 + 0x30);
        v158 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v156 + 1);
        *(double *)&v151 = *(double *)&v156 + v157;
        _XMM3 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v158 + 1);
        *(double *)&v151 = *(double *)&v158 + *(double *)&v134;
        *(_QWORD *)&v134 = *(_QWORD *)v119;
        __asm { vcvtsd2ss xmm2, xmm3, xmm3 }
        *(double *)&v151 = *(double *)&v151 * v126;
        _XMM13 = *(_OWORD *)v109;
        v196 = *(float *)&_XMM2;
        v162 = *(double *)(v119 + 8);
        *(double *)&v151 = *(double *)&v151 + (v144 + v208 + v144) * v148;
        _XMM3 = v151;
        __asm { vcvtsd2ss xmm2, xmm3, xmm3 }
        v197 = *(float *)&_XMM2;
        __asm { vunpckhpd xmm8, xmm13, xmm13 }
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&_XMM13 + 1);
        *(double *)&v151 = *(double *)&_XMM13 * COERCE_DOUBLE(*(_QWORD *)&v153 ^ 0x8000000000000000uLL);
        v166 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v146 + 1);
        *(double *)&v151 = *(double *)&v146 * COERCE_DOUBLE(*(_QWORD *)&v162 ^ 0x8000000000000000uLL)
                         - *(double *)&_XMM8 * COERCE_DOUBLE(*(_QWORD *)&v153 ^ 0x8000000000000000uLL)
                         + v155 * *(double *)&_XMM13;
        v167 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v166 + 1);
        *(double *)&v151 = *(double *)&v166
                         - *(double *)&v146 * COERCE_DOUBLE(v134 ^ 0x8000000000000000uLL)
                         + v155 * *(double *)&_XMM8;
        v168 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&_XMM8 + 1);
        *(double *)&v151 = *(double *)&_XMM8 * COERCE_DOUBLE(v134 ^ 0x8000000000000000uLL)
                         - *(double *)&_XMM13 * COERCE_DOUBLE(*(_QWORD *)&v162 ^ 0x8000000000000000uLL)
                         + v155 * *(double *)&v146;
        v169 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v168 + 1);
        *(double *)&v151 = *(double *)&v168 * v153 - *(double *)&v151 * v162;
        v170 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v169 + 1);
        *(double *)&v151 = *(double *)&v169 * *(double *)&v134 - *(double *)&v167 * v153;
        v171 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v167 + 1);
        *(double *)&v151 = *(double *)&v167 * v162 - *(double *)&v168 * *(double *)&v134;
        v172 = v151;
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v170 + 1);
        *(double *)&v151 = *(double *)&v170 + *(double *)&_XMM13 + *(double *)&v170;
        _XMM2 = v151;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v171 + 1);
        *(double *)&v151 = *(double *)&v171 + *(double *)&_XMM8 + *(double *)&v171;
        _XMM2 = v151;
        v198 = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        *((_QWORD *)&v151 + 1) = *((_QWORD *)&v172 + 1);
        *(double *)&v151 = *(double *)&v172 + *(double *)&v146 + *(double *)&v172;
        _XMM2 = v151;
        v199 = *(float *)&_XMM1;
        __asm { vcvtsd2ss xmm1, xmm2, xmm2 }
        v200 = *(float *)&_XMM1;
        v208 = *(double *)&v146;
        sub_14647A930(v17, v256, v100, &v193);
        v179 = v201;
        if ( v201 )
        {
          if ( ((*((_QWORD *)&v202 + 1) - (_QWORD)v201) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
          {
            v179 = (char *)*((_QWORD *)v201 + 0xFFFFFFFF);
            if ( (unsigned __int64)(v201 - v179 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_1402A3D30(v179);
        }
        v98 = (char *)Src_8[0];
      }
      ++v97;
      v99 += 0x10;
    }
    while ( v97 < (unsigned __int64)(((char *)Src_8[1] - (char *)v98) >> 4) );
  }
  if ( v98 )
  {
    sub_1403A3120((__int64)Src_8, v98, (v185 - v98) & 0xFFFFFFFFFFFFFFF0uLL);
    *(_OWORD *)Src_8 = 0;
    v185 = 0;
  }
  v213 = __rdtsc();
  return qword_149B4B878(&n0x4000);
}

// --- End Function: sub_14648CE80 (0x14648CE80) ---

// --- Function: sub_1464E72C0 (0x1464E72C0) ---
_QWORD *__fastcall sub_1464E72C0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rbx
  __int64 v4; // rax
  __int16 n4; // dx
  __int64 v6; // rbx
  __int64 v7; // rax
  __int16 n4_1; // dx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 0xC08);
  v10 = v2;
  if ( v2
    && (v4 = sub_1403B4B50(v2 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v4 + 4), n4 != 4)
    && *(_WORD *)(v4 + 2) == (HIWORD(v2) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v10))
    && (v6 = *sub_14644AD00(v2 & 0xFFFFFFFFFFFFLL, &v10), (v10 = v6) != 0)
    && (v7 = sub_1403B4B50(v6 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v7 + 4), n4_1 != 4)
    && *(_WORD *)(v7 + 2) == (HIWORD(v6) & 0xFFF)
    && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v10)) )
  {
    *a2 = *(_QWORD *)((v6 & 0xFFFFFFFFFFFFLL) + 8);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1464E72C0 (0x1464E72C0) ---

// --- Function: sub_1464E73E0 (0x1464E73E0) ---
_QWORD *__fastcall sub_1464E73E0(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v5; // [rsp+40h] [rbp+18h] BYREF

  sub_1464E72C0(a1, &v5);
  if ( sub_14030EC00(&v5) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFLL) + 8LL))(
      v5 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = *(_QWORD *)(a1 + 0xC10);
  return a2;
}

// --- End Function: sub_1464E73E0 (0x1464E73E0) ---

// --- Function: sub_1464E7810 (0x1464E7810) ---
__int64 __fastcall sub_1464E7810(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xC38);
}

// --- End Function: sub_1464E7810 (0x1464E7810) ---

// --- Function: sub_1464E7930 (0x1464E7930) ---
__int64 __fastcall sub_1464E7930(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xE8) + 0x180LL))(*(_QWORD *)(a1 + 0xE8));
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x28LL))(v1);
}

// --- End Function: sub_1464E7930 (0x1464E7930) ---

// --- Function: sub_1465D09B0 (0x1465D09B0) ---
bool __fastcall sub_1465D09B0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x8A8LL))(a1);
  if ( v3 && (v1 = sub_14644BB60(v3), (unsigned __int8)sub_142E160A0(v1)) )
    return 1;
  else
    return sub_142C0F3C0(a1 + 0x768, 0);
}

// --- End Function: sub_1465D09B0 (0x1465D09B0) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE58LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_1475DF210 (0x1475DF210) ---
void __fastcall sub_1475DF210(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1475B3F30(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1475DF210 (0x1475DF210) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476030E0 (0x1476030E0) ---
unsigned __int64 __fastcall sub_1476030E0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n0x20; // eax
  unsigned int n0x20_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147603270((__int64)&qword_151700CC0, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n0x20 = 0x20;
    n0x20_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n0x20 = n0x20_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(0x20 - n0x20) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148D699B0[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 0x10 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xF00;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 0xC);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147604610(&unk_151700CD0[4 * v12]);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1476034A0((__int64)&qword_151700CC0, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_151701F50;
  if ( qword_151701F50 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_151701E50;
    if ( qword_151701E50 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1476030E0 (0x1476030E0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n0x6900 = 0x6900;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n0x6900,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    0xA7);
  HIWORD(n0x6900) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n0x6900);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: unknown_libname_247 (0x148032190) ---
// Microsoft VisualC v14 64bit runtime
const __m128i *__fastcall unknown_libname_247(const __m128i *a1, const __m128i *a2, unsigned int a3)
{
  signed __int64 v3; // r9
  const __m128i *v8; // r10
  unsigned __int64 v11; // r9
  const __m128i *v12; // r10
  __m128i v13; // xmm1
  __int64 v14; // rax

  v3 = (char *)a2 - (char *)a1;
  if ( (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL) != 0 && (dword_149B1CF54 & 0x20) != 0 )
  {
    _XMM2 = a3;
    _YMM2 = (__m256i)a3;
    __asm
    {
      vpshufd xmm2, xmm2, 0
      vinsertf128 ymm2, ymm2, xmm2, 1
    }
    v8 = (const __m128i *)((char *)a1 + (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL));
    while ( 1 )
    {
      __asm
      {
        vpcmpeqd ymm1, ymm2, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        break;
      a1 += 2;
      if ( a1 == v8 )
      {
        v3 &= 0x1Fu;
        __asm { vzeroupper }
        goto LABEL_7;
      }
    }
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
LABEL_7:
    v11 = v3 & 0xFFFFFFFFFFFFFFF0uLL;
    if ( v11 )
    {
      v12 = (const __m128i *)((char *)a1 + v11);
      v13 = _mm_shuffle_epi32(_mm_cvtsi32_si128(a3), 0);
      while ( 1 )
      {
        LODWORD(v14) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_loadu_si128(a1), v13));
        if ( (_DWORD)v14 )
          break;
        if ( ++a1 == v12 )
          goto LABEL_11;
      }
      _BitScanForward((unsigned int *)&v14, v14);
      return (const __m128i *)((char *)a1 + v14);
    }
    else
    {
LABEL_11:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i32[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 4);
      }
      return a1;
    }
  }
}

// --- End Function: unknown_libname_247 (0x148032190) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: _onexit (0x1480335BC) ---
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)(); // rdx

  if ( Table._first == (_PVFV *)0xFFFFFFFFFFFFFFFFLL )
    v2 = crt_atexit((_PVFV)Func);
  else
    v2 = register_onexit_function(&Table, Func);
  v3 = 0;
  if ( !v2 )
    return Func;
  return v3;
}

// --- End Function: _onexit (0x1480335BC) ---

// --- Function: atexit (0x1480335F8) ---
int __cdecl atexit(void (__cdecl *Func)())
{
  return (onexit((_onexit_t)Func) != 0) - 1;
}

// --- End Function: atexit (0x1480335F8) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 0x18B0);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 0x18C0);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 0x18B0) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 0x1E )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 0x18B0);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

// --- Function: sub_1480BD320 (0x1480BD320) ---
void __fastcall sub_1480BD320()
{
  qword_149B3E318 = (__int64)&off_1481A0DB8;
}

// --- End Function: sub_1480BD320 (0x1480BD320) ---

// --- Function: sub_1480BE950 (0x1480BE950) ---
__int64 sub_1480BE950()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = NtCurrentTeb_w();
  sub_1402A3D30(*(const void **)(*(_QWORD *)(v0 + 0x10) + 0x18LL));
  result = NtCurrentTeb_w();
  *(_QWORD *)(*(_QWORD *)(result + 0x10) + 0x18LL) = 0;
  return result;
}

// --- End Function: sub_1480BE950 (0x1480BE950) ---

