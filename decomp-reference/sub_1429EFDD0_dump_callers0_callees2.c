// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1429EFDD0 (sub_1429EFDD0)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 38
// ------------------------------------------------------------

// --- Function: sub_1402A2880 (0x1402A2880) ---
__int64 __fastcall sub_1402A2880(__int64 a1, size_t *a2)
{
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = a1 + 24;
  *(_QWORD *)(a1 + 8) = 511;
  sub_1402A3BE0(a1, (const void *)a2[2], *a2);
  return a1;
}

// --- End Function: sub_1402A2880 (0x1402A2880) ---

// --- Function: __StarEngineModule__ (0x1402A34C0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A34C0) ---

// --- Function: sub_1402A3B50 (0x1402A3B50) ---
_BYTE *__fastcall sub_1402A3B50(__int64 *a1, __int64 n511_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n511; // rcx

  result = a1 + 3;
  if ( n511_1 )
  {
    allocSize = n511_1 + 1;
    if ( (unsigned __int64)(n511_1 + 1) <= 0x200 )
    {
      n511 = 511;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3AB68 += allocSize;
      n511 = n511_1;
    }
    a1[1] = n511;
    *a1 = n511_1;
    a1[2] = (__int64)result;
    result[n511_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 511;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A3B50 (0x1402A3B50) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: sub_14033B5B0 (0x14033B5B0) ---
_QWORD *__fastcall sub_14033B5B0(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 *v4; // rdx
  __int64 *v5; // rcx
  __int64 *v6; // rax

  v4 = *a1;
  v5 = v4;
  v6 = (__int64 *)v4[1];
  while ( !*((_BYTE *)v6 + 25) )
  {
    if ( *((_DWORD *)v6 + 8) >= *a3 )
    {
      v5 = v6;
      v6 = (__int64 *)*v6;
    }
    else
    {
      v6 = (__int64 *)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 25) || *a3 < *((_DWORD *)v5 + 8) || v5 == v4 )
  {
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
  else
  {
    sub_14033B330(v5[7], (__int64)a2);
    return a2;
  }
}

// --- End Function: sub_14033B5B0 (0x14033B5B0) ---

// --- Function: sub_14035AED0 (0x14035AED0) ---
_QWORD *__fastcall sub_14035AED0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax
  _QWORD *result; // rax

  *a1 = a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  v5 = allocWithProfilerInfo_w(0x18u);
  if ( v5 )
  {
    *(_DWORD *)(v5 + 8) = 1;
    *(_QWORD *)v5 = off_1481B6460;
    *(_DWORD *)(v5 + 12) = 1;
    *(_QWORD *)(v5 + 16) = a3;
  }
  else
  {
    v5 = 0;
  }
  a1[4] = v5;
  result = a1;
  a1[3] = a3;
  return result;
}

// --- End Function: sub_14035AED0 (0x14035AED0) ---

// --- Function: sub_140370C50 (0x140370C50) ---
__int64 __fastcall sub_140370C50(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx

  v1 = *(volatile signed __int32 **)(a1 + 32);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v4 = *(volatile signed __int32 **)(a1 + 16);
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
  }
  return result;
}

// --- End Function: sub_140370C50 (0x140370C50) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: get_event_key_from_source_location (0x1403BB9D0) ---
// Retrieves an event key (DWORD ID) based on input parameters, likely source file
// path and line number. Dynamically resolves the address of the `__GetEventKey__`
// function using GetProcAddress/LoadLibraryA on the first call and caches the
// result. Calls the resolved function with `a2` (source path?) and `a3` (line
// number?) and stores the returned key in `*a1`.
__int64 __fastcall get_event_key_from_source_location(_DWORD *a1, __int64 a2, __int64 a3)
{
  FARPROC ProcAddress; // rbx
  HMODULE hModule; // rax
  HMODULE hModule_1; // rax
  __int64 result; // rax

  ProcAddress = (FARPROC)qword_149B3D530;
  if ( !qword_149B3D530 )
  {
    hModule = GetModuleHandleA(0);
    ProcAddress = GetProcAddress(hModule, "__GetEventKey__");
    if ( !ProcAddress )
    {
      hModule_1 = LoadLibraryA(0);
      if ( hModule_1 )
        ProcAddress = GetProcAddress(hModule_1, "__GetEventKey__");
    }
    qword_149B3D530 = (__int64)ProcAddress;
  }
  result = ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a2, a3);
  *a1 = result;
  return result;
}

// --- End Function: get_event_key_from_source_location (0x1403BB9D0) ---

// --- Function: sub_14041E9D0 (0x14041E9D0) ---
void __fastcall sub_14041E9D0(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
}

// --- End Function: sub_14041E9D0 (0x14041E9D0) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14053A870 (0x14053A870) ---
__int64 __fastcall sub_14053A870(__int64 a1, int a2, __int64 a3, int a4, size_t *a5)
{
  size_t *v9; // rcx

  sub_1402A2880(a1, a5);
  *(_DWORD *)(a1 + 536) = a4;
  *(_DWORD *)(a1 + 540) = a2;
  *(_QWORD *)(a1 + 544) = a3;
  v9 = (size_t *)a5[2];
  if ( v9 != a5 + 3 )
  {
    qword_149B3AB68 += -1LL - a5[1];
    sub_147605980(v9);
  }
  return a1;
}

// --- End Function: sub_14053A870 (0x14053A870) ---

// --- Function: sub_14053B5C0 (0x14053B5C0) ---
char __fastcall sub_14053B5C0(__int64 a1, _DWORD *a2, _QWORD *a3)
{
  _QWORD *i; // r9
  __int64 *v6; // rax
  _QWORD *v7; // r10
  __int64 *v8; // r8
  __int64 *v9; // rdx
  __int64 *v10; // rax
  __int64 v12; // rax
  volatile signed __int32 *v13; // rbx
  __int64 v14; // rcx

  for ( i = (_QWORD *)(a1 + 136); ; ++i )
  {
    v6 = (__int64 *)*i;
    v7 = i;
    if ( *i )
    {
      v8 = (__int64 *)*v6;
      v9 = (__int64 *)*v6;
      v10 = *(__int64 **)(*v6 + 8);
      while ( !*((_BYTE *)v10 + 25) )
      {
        if ( *((_DWORD *)v10 + 8) >= *a2 )
        {
          v9 = v10;
          v10 = (__int64 *)*v10;
        }
        else
        {
          v10 = (__int64 *)v10[2];
        }
      }
      if ( !*((_BYTE *)v9 + 25) && *a2 >= *((_DWORD *)v9 + 8) && v9 != v8 )
        break;
    }
    if ( v7 == (_QWORD *)(a1 + 152) )
      return 0;
  }
  v12 = v9[8];
  if ( v12 )
    _InterlockedIncrement((volatile signed __int32 *)(v12 + 8));
  v13 = (volatile signed __int32 *)a3[1];
  v14 = v9[8];
  *a3 = v9[7];
  a3[1] = v14;
  if ( v13 && _InterlockedExchangeAdd(v13 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
    if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8LL))(v13);
  }
  return 1;
}

// --- End Function: sub_14053B5C0 (0x14053B5C0) ---

// --- Function: sub_14053D5C0 (0x14053D5C0) ---
char sub_14053D5C0(__int64 a1, __int64 a2, unsigned int n2, const char *Format, ...)
{
  va_list va; // [rsp+60h] [rbp+28h] BYREF

  va_start(va, Format);
  return sub_14053D5E0(a1, a2, n2, Format, va);
}

// --- End Function: sub_14053D5C0 (0x14053D5C0) ---

// --- Function: sub_14053D5E0 (0x14053D5E0) ---
void __fastcall sub_14053D5E0(__int64 a1, __int64 a2, unsigned int n2, const char *Format_1, va_list va)
{
  __int64 v7; // rsi
  unsigned __int64 *v9; // rax
  const char **v10; // r13
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbx
  __int64 v12; // rax
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rsi
  const char *v14; // rbx
  const char *v15; // rdi
  const char *v16; // r14
  const char *v17; // rax
  int n72; // edi
  int v19; // edi
  __int64 v20; // rcx
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_2; // rax
  bool v22; // zf
  const char *v23; // rax
  size_t *v24; // rax
  _BYTE *v25; // rcx
  size_t n511_2; // rbx
  const void *v27; // r14
  _BYTE *v28; // rax
  float *v29; // r9
  float v30; // xmm2_4
  __int64 v31; // [rsp+50h] [rbp-B0h] BYREF
  float v32; // [rsp+58h] [rbp-A8h]
  float v33; // [rsp+5Ch] [rbp-A4h]
  __int128 v34; // [rsp+60h] [rbp-A0h] BYREF
  size_t n511_3; // [rsp+70h] [rbp-90h]
  __int64 n511_1; // [rsp+78h] [rbp-88h]
  void *v37; // [rsp+80h] [rbp-80h]
  _BYTE v38[520]; // [rsp+88h] [rbp-78h] BYREF
  __int64 v39; // [rsp+290h] [rbp+190h] BYREF
  __int64 n511; // [rsp+298h] [rbp+198h]
  _BYTE *v41; // [rsp+2A0h] [rbp+1A0h]
  _BYTE v42[520]; // [rsp+2A8h] [rbp+1A8h] BYREF
  char Buffer[4096]; // [rsp+4B0h] [rbp+3B0h] BYREF

  v31 = a1;
  v7 = a1;
  memset(Buffer, 0, sizeof(Buffer));
  v9 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v9, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  v10 = (const char **)(v7 + 80);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_BYTE *)(a2 + 80) )
  {
    v12 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v7 + 136) + 16LL))(*(_QWORD *)(v7 + 136));
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    v14 = *(const char **)(a2 + 64);
    v15 = *(const char **)(a2 + 56);
    v16 = (const char *)v12;
    if ( *v10 )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *v10;
    v17 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 8) + 112LL))(*(_QWORD *)(a2 + 8));
    sub_1405C0E00(
      4u,
      n2,
      "[Subsumption] %s|%s.%s.%s (%s): %s",
      v17,
      v15,
      v14,
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
      v16,
      Buffer);
    v7 = v31;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  n72 = 72;
  if ( n2 )
    n72 = 8;
  v19 = *(_DWORD *)(a2 + 48) | n72;
  if ( sub_140393530(*(_QWORD *)(a2 + 40), v19) )
  {
    v20 = *(_QWORD *)(v7 + 136);
    v41 = v42;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = *v10;
    v22 = *v10 == 0;
    v42[0] = 0;
    v39 = 0;
    if ( !v22 )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
    n511 = 511;
    v23 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 24LL))(v20);
    v24 = (size_t *)sub_1402A3190((__int64)&v39, "  %s (%s): %s", v23, p_p_p_p_p_p_p_p_p_p_p_p_Source, Buffer);
    v38[0] = 0;
    v25 = v38;
    v37 = v38;
    n511_3 = 0;
    n511_1 = 511;
    n511_2 = *v24;
    v27 = (const void *)v24[2];
    if ( *v24 > 0x1FF )
    {
      v28 = v38;
      if ( n511_2 + 1 > 0x200 )
      {
        v28 = (_BYTE *)allocWithProfilerInfo(n511_2 + 1, 0);
        qword_149B3AB68 += n511_2 + 1;
        n511_1 = n511_2;
      }
      v37 = v28;
      n511_3 = n511_2;
      v28[n511_2] = 0;
      v25 = v37;
    }
    memmove(v25, v27, n511_2);
    n511_3 = n511_2;
    *((_BYTE *)v37 + n511_2) = 0;
    if ( v41 != v42 )
    {
      qword_149B3AB68 += -1 - n511;
      sub_147605980(v41);
    }
    if ( n2 )
    {
      if ( n2 == 2 )
        v30 = 0.0;
      else
        v30 = 1.0;
      v31 = 0x3F8000003F800000LL;
      v32 = v30;
      v33 = 1.0;
      v29 = (float *)&v31;
    }
    else
    {
      v34 = xmmword_1481D9FB0;
      v29 = (float *)&v34;
    }
    sub_14038F6D0(*(__int64 **)(a2 + 40), v37, v19, v29, 0);
    if ( v37 != v38 )
    {
      qword_149B3AB68 += -1 - n511_1;
      sub_147605980(v37);
    }
  }
}

// --- End Function: sub_14053D5E0 (0x14053D5E0) ---

// --- Function: sub_141358770 (0x141358770) ---
_QWORD *__fastcall sub_141358770(__int64 a1, _QWORD *a2)
{
  char *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rbp
  __int64 *v7; // rax
  __int64 v8; // r8
  unsigned __int8 *v9; // rax
  __int64 v10; // r8
  int v11; // ecx
  int v12; // edx
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rbp
  __int64 v16; // rdi
  __int64 v17; // rbx
  __int64 v18; // rdx
  const char *v20; // [rsp+30h] [rbp-38h] BYREF
  _BYTE v21[24]; // [rsp+38h] [rbp-30h] BYREF
  BOOL fPending; // [rsp+80h] [rbp+18h] BYREF
  char *v23; // [rsp+88h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__119, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149CEFFF8 & 1) == 0 )
    {
      dword_149CEFFF8 |= 1u;
      xmmword_149CEFF60 = 0;
    }
    n120_105 = 120;
    v23 = strchr(
            "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<struct CryGUID>>(void)",
            60);
    v4 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<struct CryGUID>>(void)",
           62);
    if ( v23 != v4 )
      ++v23;
    v20 = (const char *)&unk_149CEFF78;
    sub_1403E40C0(&v20, (const char *)&unk_149CEFFF7, (const char **)&v23, v4);
    *v20 = 0;
    *((_QWORD *)&xmmword_149CEFF60 + 1) = &unk_149CEFFFC;
    *(_QWORD *)&xmmword_149CEFF60 = &xmmword_149CEFF60;
    qword_149CEFF58 = (__int64)&xmmword_149CEFF60;
    if ( !InitOnceComplete(&lpInitOnce__119, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v5 = *(_QWORD *)qword_149CEFF58;
  v6 = *(_QWORD *)(qword_149CEFF58 + 8);
  v7 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v21);
  v8 = *v7;
  if ( v5 == *v7 )
    goto LABEL_19;
  if ( !v5 || !v8 || v6 == v7[1] || *(_QWORD *)(v5 + 16) != *(_QWORD *)(v8 + 16) )
    goto LABEL_18;
  v9 = (unsigned __int8 *)(v5 + 24);
  v10 = v8 - v5;
  do
  {
    v11 = v9[v10];
    v12 = *v9 - v11;
    if ( v12 )
      break;
    ++v9;
  }
  while ( v11 );
  if ( !v12 )
  {
LABEL_19:
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 32LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1) && (v16 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1);
      *(_QWORD *)v16 = v17;
      *(_BYTE *)(v16 + 8) = 1;
      if ( *(_DWORD *)(v17 + 16) == *(_DWORD *)(NtCurrentTeb_w() + 24) )
      {
        ++*(_DWORD *)(v17 + 20);
      }
      else
      {
        v18 = _InterlockedIncrement64((volatile signed __int64 *)v17);
        if ( (v18 & 0x200000) != 0 )
          sub_1403CB300(v17, v18, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, 1);
      }
    }
    else
    {
      v16 = 0;
    }
    v13 = v16;
    v14 = v15;
  }
  else
  {
LABEL_18:
    v13 = 0;
    v14 = 0;
  }
  sub_14035AED0(a2, v14, v13);
  return a2;
}

// --- End Function: sub_141358770 (0x141358770) ---

// --- Function: sub_14135A8D0 (0x14135A8D0) ---
_QWORD *__fastcall sub_14135A8D0(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 *v4; // rdx
  __int64 *v5; // rcx
  __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 *v8; // rbx
  __int64 *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  unsigned __int8 *v12; // rax
  __int64 v13; // r8
  int v14; // ecx
  int v15; // edx
  __int64 v16; // rdx
  __int64 v17; // rbx
  __int64 v18; // rbp
  __int64 v19; // rdi
  __int64 v20; // rdx
  _BYTE v22[16]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v23[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = *a1;
  v5 = v4;
  v6 = (__int64 *)v4[1];
  while ( !*((_BYTE *)v6 + 25) )
  {
    if ( *((_DWORD *)v6 + 8) >= *a3 )
    {
      v5 = v6;
      v6 = (__int64 *)*v6;
    }
    else
    {
      v6 = (__int64 *)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 25) || *a3 < *((_DWORD *)v5 + 8) || v5 == v4 )
  {
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
  else
  {
    v7 = v5[7];
    v8 = (__int64 *)sub_14054F030(v22);
    v9 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 8LL))(v7, v23);
    v10 = *v8;
    v11 = *v9;
    if ( *v8 == *v9 )
      goto LABEL_19;
    if ( !v10 || !v11 || v8[1] == v9[1] || *(_QWORD *)(v10 + 16) != *(_QWORD *)(v11 + 16) )
      goto LABEL_18;
    v12 = (unsigned __int8 *)(v10 + 24);
    v13 = v11 - v10;
    do
    {
      v14 = v12[v13];
      v15 = *v12 - v14;
      if ( v15 )
        break;
      ++v12;
    }
    while ( v14 );
    if ( !v15 )
    {
LABEL_19:
      v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 32LL))(v7);
      if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7)
        && (v17 = allocWithProfilerInfo_w(0x10u)) != 0 )
      {
        v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        *(_QWORD *)v17 = v19;
        *(_BYTE *)(v17 + 8) = 1;
        if ( *(_DWORD *)(v19 + 16) == *(_DWORD *)(NtCurrentTeb_w() + 24) )
        {
          ++*(_DWORD *)(v19 + 20);
        }
        else
        {
          v20 = _InterlockedIncrement64((volatile signed __int64 *)v19);
          if ( (v20 & 0x200000) != 0 )
            sub_1403CB300(v19, v20, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, 1);
        }
      }
      else
      {
        v17 = 0;
      }
      v16 = v18;
    }
    else
    {
LABEL_18:
      v16 = 0;
      v17 = 0;
    }
    sub_14035AED0(a2, v16, v17);
    return a2;
  }
}

// --- End Function: sub_14135A8D0 (0x14135A8D0) ---

// --- Function: sub_14135AA80 (0x14135AA80) ---
_QWORD *__fastcall sub_14135AA80(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 **v3; // rdi
  __int64 **v6; // r12
  __int64 *v7; // rax
  __int64 *v8; // r8
  __int64 *v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rbx
  __int64 *v12; // rdi
  __int64 *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r8
  unsigned __int8 *v16; // rax
  __int64 v17; // r8
  int v18; // ecx
  int v19; // edx
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rsi
  __int64 v23; // rdi
  __int64 v24; // rbx
  __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rbx
  volatile signed __int32 *v28; // rbx
  __int64 v29; // rax
  volatile signed __int32 *v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rbx
  volatile signed __int32 *v34; // rbx
  char v35[16]; // [rsp+30h] [rbp-50h] BYREF
  char v36[16]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v37[2]; // [rsp+50h] [rbp-30h] BYREF
  volatile signed __int32 *v38; // [rsp+60h] [rbp-20h]
  __int64 v39; // [rsp+68h] [rbp-18h]
  __int64 v40; // [rsp+70h] [rbp-10h]
  __int64 **v41; // [rsp+B0h] [rbp+30h]

  v3 = a1 + 3;
  v41 = a1 + 3;
  v6 = a1;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_44:
    if ( ++v6 == v3 )
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      a2[3] = 0;
      a2[4] = 0;
      v29 = allocWithProfilerInfo_w(0x18u);
      if ( v29 )
      {
        *(_DWORD *)(v29 + 8) = 1;
        *(_DWORD *)(v29 + 12) = 1;
        *(_QWORD *)v29 = off_1481B6460;
        *(_QWORD *)(v29 + 16) = 0;
      }
      a2[3] = 0;
      a2[4] = v29;
      return a2;
    }
  }
  v8 = (__int64 *)*v7;
  v9 = (__int64 *)*v7;
  v10 = *(__int64 **)(*v7 + 8);
  while ( !*((_BYTE *)v10 + 25) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *((_BYTE *)v9 + 25) || *a3 < *((_DWORD *)v9 + 8) || v9 == v8 )
  {
    v38 = 0;
    v26 = allocWithProfilerInfo_w(0x18u);
    v21 = v26;
    if ( v26 )
    {
      *(_DWORD *)(v26 + 8) = 1;
      *(_DWORD *)(v26 + 12) = 1;
      *(_QWORD *)v26 = off_1481B6460;
      *(_QWORD *)(v26 + 16) = 0;
    }
    else
    {
      v21 = 0;
    }
    goto LABEL_35;
  }
  v11 = v9[7];
  v12 = (__int64 *)sub_14054F030(v35);
  v13 = (__int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v11 + 8LL))(v11, v36);
  v14 = *v12;
  v15 = *v13;
  if ( *v12 != *v13 )
  {
    if ( !v14 || !v15 || v12[1] == v13[1] || *(_QWORD *)(v14 + 16) != *(_QWORD *)(v15 + 16) )
      goto LABEL_20;
    v16 = (unsigned __int8 *)(v14 + 24);
    v17 = v15 - v14;
    do
    {
      v18 = v16[v17];
      v19 = *v16 - v18;
      if ( v19 )
        break;
      ++v16;
    }
    while ( v18 );
    if ( v19 )
    {
LABEL_20:
      v38 = 0;
      v20 = allocWithProfilerInfo_w(0x18u);
      v21 = v20;
      v3 = v41;
      if ( v20 )
      {
        *(_DWORD *)(v20 + 8) = 1;
        *(_DWORD *)(v20 + 12) = 1;
        *(_QWORD *)v20 = off_1481B6460;
        *(_QWORD *)(v20 + 16) = 0;
      }
      else
      {
        v21 = 0;
      }
LABEL_35:
      v40 = v21;
LABEL_36:
      if ( v21 )
      {
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v21 + 8), 0xFFFFFFFF) == 1 )
        {
          v27 = v40;
          (**(void (__fastcall ***)(__int64))v40)(v40);
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 12), 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
        }
      }
      if ( v38 )
      {
        if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
        {
          v28 = v38;
          (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
          if ( _InterlockedExchangeAdd(v28 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
        }
      }
      goto LABEL_44;
    }
  }
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 32LL))(v11);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11) && (v23 = allocWithProfilerInfo_w(0x10u)) != 0 )
  {
    v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
    *(_QWORD *)v23 = v24;
    *(_BYTE *)(v23 + 8) = 1;
    if ( *(_DWORD *)(v24 + 16) == *(_DWORD *)(NtCurrentTeb_w() + 24) )
    {
      ++*(_DWORD *)(v24 + 20);
    }
    else
    {
      v25 = _InterlockedIncrement64((volatile signed __int64 *)v24);
      if ( (v25 & 0x200000) != 0 )
        sub_1403CB300(v24, v25, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, 1);
    }
  }
  else
  {
    v23 = 0;
  }
  sub_14035AED0(v37, v22, v23);
  if ( !v37[0] )
  {
    v21 = v40;
    v3 = v41;
    goto LABEL_36;
  }
  v31 = v38;
  *a2 = v37[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v31 )
  {
    _InterlockedIncrement(v31 + 2);
    v31 = v38;
  }
  v32 = v40;
  a2[1] = v37[1];
  a2[2] = v31;
  a2[3] = 0;
  a2[4] = 0;
  if ( v32 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v32 + 8));
    v32 = v40;
    v31 = v38;
  }
  a2[3] = v39;
  a2[4] = v32;
  if ( v32 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v32 + 8), 0xFFFFFFFF) == 1 )
    {
      v33 = v40;
      (**(void (__fastcall ***)(__int64))v40)(v40);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v33 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
    }
    v31 = v38;
  }
  if ( v31 )
  {
    if ( _InterlockedExchangeAdd(v31 + 2, 0xFFFFFFFF) == 1 )
    {
      v34 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  return a2;
}

// --- End Function: sub_14135AA80 (0x14135AA80) ---

// --- Function: sub_1413608A0 (0x1413608A0) ---
_QWORD *__fastcall sub_1413608A0(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  __int64 v8; // rcx
  volatile signed __int32 *v9; // rdx
  signed __int32 v10; // eax
  volatile signed __int32 *v11; // rbx
  volatile signed __int32 *v12; // rbx
  volatile signed __int32 *v13; // rbx
  __int64 v14; // rbx
  __int64 *v15; // r8
  __int64 *v16; // rcx
  __int64 *v17; // rax
  _DWORD *v18; // r14
  __int64 v19; // rbx
  __int64 v20; // rbx
  volatile signed __int32 *v21; // rbx
  volatile signed __int32 *v22; // rbx
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rcx
  __int64 v25; // rax
  volatile signed __int32 *v26; // rbx
  volatile signed __int32 *v27; // rbx
  __int128 v29; // [rsp+20h] [rbp-59h] BYREF
  _QWORD v30[2]; // [rsp+30h] [rbp-49h] BYREF
  __int64 v31; // [rsp+40h] [rbp-39h]
  __int64 v32; // [rsp+48h] [rbp-31h]
  volatile signed __int32 *v33; // [rsp+50h] [rbp-29h]
  _DWORD *v34; // [rsp+58h] [rbp-21h] BYREF
  volatile signed __int32 *v35; // [rsp+68h] [rbp-11h]
  volatile signed __int32 *v36; // [rsp+78h] [rbp-1h]
  _DWORD *v37[2]; // [rsp+80h] [rbp+7h] BYREF
  volatile signed __int32 *v38; // [rsp+90h] [rbp+17h]
  volatile signed __int32 *v39; // [rsp+A0h] [rbp+27h]
  __int128 v40; // [rsp+B0h] [rbp+37h] BYREF

  sub_14135A8D0((__int64 **)(a1 + 16 * ((int)a3[6] + 10LL)), v30, a3);
  if ( v30[0] )
  {
    v8 = v31;
    *a2 = v30[0];
    a2[1] = 0;
    a2[2] = 0;
    if ( v8 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 8));
      v8 = v31;
    }
    v9 = v33;
    a2[1] = v30[1];
    a2[2] = v8;
    a2[3] = 0;
    a2[4] = 0;
    if ( v9 )
    {
      _InterlockedIncrement(v9 + 2);
      v9 = v33;
      v8 = v31;
    }
    a2[3] = v32;
    a2[4] = v9;
    if ( !v9 )
      goto LABEL_23;
    v10 = _InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF);
    goto LABEL_19;
  }
  sub_14033B5B0((__int64 **)(a1 + 16 * ((int)a3[6] + 10LL)), v37, a3);
  if ( !v37[0] )
  {
    v15 = *(__int64 **)(a1 + 16 * ((int)a3[6] + 10LL));
    v16 = v15;
    v17 = (__int64 *)v15[1];
    while ( !*((_BYTE *)v17 + 25) )
    {
      if ( *((_DWORD *)v17 + 8) >= *a3 )
      {
        v16 = v17;
        v17 = (__int64 *)*v17;
      }
      else
      {
        v17 = (__int64 *)v17[2];
      }
    }
    if ( *((_BYTE *)v16 + 25) || *a3 < *((_DWORD *)v16 + 8) || v16 == v15 )
    {
      v35 = 0;
      v25 = allocWithProfilerInfo_w(0x18u);
      v24 = (volatile signed __int32 *)v25;
      if ( v25 )
      {
        *(_DWORD *)(v25 + 8) = 1;
        *(_DWORD *)(v25 + 12) = 1;
        *(_QWORD *)v25 = off_1481B6460;
        *(_QWORD *)(v25 + 16) = 0;
      }
      else
      {
        v24 = 0;
      }
      v36 = v24;
    }
    else
    {
      sub_141358770(v16[7], &v34);
      v18 = v34;
      if ( v34 )
      {
        v29 = 0;
        if ( sub_14053B5C0(a4, v34, &v29) )
        {
          v19 = *((_QWORD *)&v29 + 1);
          if ( *((_QWORD *)&v29 + 1) )
          {
            _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL));
            v18 = v34;
            v19 = *((_QWORD *)&v29 + 1);
          }
          v40 = v29;
          sub_14137CC40(v18, a2, &v40, a4 + 136);
          if ( v19 )
          {
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v19 + 8), 0xFFFFFFFF) == 1 )
            {
              v20 = *((_QWORD *)&v29 + 1);
              (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
              if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v20 + 12), 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
            }
          }
          if ( v36 )
          {
            if ( _InterlockedExchangeAdd(v36 + 2, 0xFFFFFFFF) == 1 )
            {
              v21 = v36;
              (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
              if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
            }
          }
          if ( v35 )
          {
            if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
            {
              v22 = v35;
              (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
              if ( _InterlockedExchangeAdd(v22 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
            }
          }
          sub_140370C50((__int64)v37);
LABEL_70:
          sub_140370C50((__int64)v30);
          return a2;
        }
        if ( *((_QWORD *)&v29 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            v23 = *((_QWORD *)&v29 + 1);
            (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v23 + 12), 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
          }
        }
      }
      v24 = v36;
    }
    if ( v24 )
    {
      if ( _InterlockedExchangeAdd(v24 + 2, 0xFFFFFFFF) == 1 )
      {
        v26 = v36;
        (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
        if ( _InterlockedExchangeAdd(v26 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
      }
    }
    if ( v35 )
    {
      if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
      {
        v27 = v35;
        (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
        if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
      }
    }
    sub_140370C50((__int64)v37);
    sub_14035AED0(a2, 0, 0);
    goto LABEL_70;
  }
  sub_14135AA80((__int64 **)(a4 + 136), a2, v37[0]);
  if ( v39 )
  {
    if ( _InterlockedExchangeAdd(v39 + 2, 0xFFFFFFFF) == 1 )
    {
      v11 = v39;
      (**(void (__fastcall ***)(volatile signed __int32 *))v39)(v39);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v39 + 8LL))(v39);
    }
  }
  if ( v38 )
  {
    if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
    {
      v12 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  if ( !v33 )
    goto LABEL_22;
  v10 = _InterlockedExchangeAdd(v33 + 2, 0xFFFFFFFF);
LABEL_19:
  if ( v10 == 1 )
  {
    v13 = v33;
    (**(void (__fastcall ***)(volatile signed __int32 *))v33)(v33);
    if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v33 + 8LL))(v33);
  }
LABEL_22:
  v8 = v31;
LABEL_23:
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    {
      v14 = v31;
      (**(void (__fastcall ***)(__int64))v31)(v31);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v14 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 8LL))(v31);
    }
  }
  return a2;
}

// --- End Function: sub_1413608A0 (0x1413608A0) ---

// --- Function: sub_14137CC40 (0x14137CC40) ---
_QWORD *__fastcall sub_14137CC40(__int64 a1, _QWORD *a2, void *a3, __int64 a4)
{
  _QWORD *v5; // rsi
  _QWORD *v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rcx
  void (__fastcall *v12)(__int64, __int64 *, _QWORD *, __int64); // r10
  __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // r14
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  int *v23; // rcx
  int *v24; // r9
  const char *v25; // rax
  unsigned int v26; // ecx
  unsigned int v27; // r8d
  int v28; // ebx
  int v29; // edi
  int v30; // esi
  int v31; // r14d
  int v32; // ecx
  int v33; // edx
  int v34; // eax
  int v35; // r9d
  int v36; // r8d
  size_t Size; // rbx
  size_t Size_1; // r8
  _OWORD *v39; // rax
  _OWORD *v40; // rdi
  __int64 v41; // rax
  volatile signed __int32 *v42; // rbx
  _BYTE *v43; // rcx
  _DWORD *v44; // r13
  __int64 v45; // rax
  _DWORD *v46; // rsi
  __int64 v47; // rax
  __int64 v48; // rbx
  __int64 (__fastcall *v49)(__int64, char *, __int16 *); // rdi
  __int16 v50; // ax
  __int64 v51; // rbx
  __int64 v52; // rdi
  __int64 v53; // rax
  __int16 n4; // cx
  void (__fastcall *v55)(__int64, __int64 *, _DWORD *, __int64); // rbx
  __int64 v56; // rax
  __int64 v57; // rdx
  signed __int32 v58; // eax
  signed __int32 v59; // ett
  __int64 v60; // r12
  volatile signed __int32 *v61; // rsi
  __int64 v62; // rax
  __int64 v63; // rbx
  __int64 (__fastcall *v64)(__int64, char *, __int16 *); // rdi
  __int16 v65; // ax
  __int64 v66; // rbx
  __int64 v67; // rax
  __int16 n4_1; // cx
  __int64 **v69; // rax
  volatile signed __int32 *v70; // rbx
  volatile signed __int32 *v71; // rbx
  _OWORD *v72; // rax
  _OWORD *v73; // r14
  __int64 v74; // rax
  volatile signed __int32 *v75; // rbx
  unsigned __int8 (__fastcall *v76)(__int64, _OWORD *, __int64); // rdi
  __int64 v77; // rax
  __int64 v78; // rdx
  __int64 v79; // rcx
  __int64 *v80; // rcx
  __int64 v81; // rax
  __int64 v82; // rcx
  volatile signed __int32 *v83; // rbx
  _QWORD *v84; // r14
  volatile signed __int32 *v85; // rcx
  __int64 v86; // rax
  volatile signed __int32 *v87; // rcx
  __int64 v88; // rax
  __int64 v89; // rcx
  volatile signed __int32 *v90; // r14
  _QWORD *v92; // rdi
  __int64 v93; // rcx
  volatile signed __int32 *v94; // rbx
  __int64 v95; // rax
  volatile signed __int32 *v96; // rbx
  int v97; // [rsp+40h] [rbp-D0h]
  int v98; // [rsp+48h] [rbp-C8h]
  int v99; // [rsp+78h] [rbp-98h]
  int v100; // [rsp+80h] [rbp-90h]
  int v101; // [rsp+88h] [rbp-88h]
  __int16 v102; // [rsp+90h] [rbp-80h] BYREF
  __int16 v103; // [rsp+92h] [rbp-7Eh] BYREF
  __int64 v104; // [rsp+98h] [rbp-78h] BYREF
  _DWORD *v105; // [rsp+A0h] [rbp-70h]
  __int64 v106; // [rsp+A8h] [rbp-68h]
  char *v107; // [rsp+B0h] [rbp-60h] BYREF
  _QWORD *v108; // [rsp+B8h] [rbp-58h]
  void *v109; // [rsp+C0h] [rbp-50h]
  char v110[2]; // [rsp+C8h] [rbp-48h] BYREF
  char v111[2]; // [rsp+CAh] [rbp-46h] BYREF
  unsigned int v112; // [rsp+CCh] [rbp-44h]
  int *v113; // [rsp+D0h] [rbp-40h]
  volatile signed __int32 *v114; // [rsp+D8h] [rbp-38h]
  __int64 v115; // [rsp+E0h] [rbp-30h] BYREF
  __int64 v116; // [rsp+E8h] [rbp-28h]
  __int64 v117; // [rsp+F0h] [rbp-20h] BYREF
  __int64 v118; // [rsp+F8h] [rbp-18h] BYREF
  __int64 v119; // [rsp+100h] [rbp-10h]
  unsigned __int64 v120; // [rsp+108h] [rbp-8h]
  _QWORD v121[2]; // [rsp+110h] [rbp+0h] BYREF
  volatile signed __int32 *v122; // [rsp+120h] [rbp+10h]
  __int64 v123; // [rsp+128h] [rbp+18h]
  volatile signed __int32 *v124; // [rsp+130h] [rbp+20h]
  __int64 v125; // [rsp+140h] [rbp+30h]
  __int64 v126; // [rsp+148h] [rbp+38h]
  __int64 v127; // [rsp+150h] [rbp+40h]
  __int64 v128; // [rsp+158h] [rbp+48h]
  __int64 v129; // [rsp+160h] [rbp+50h]
  __int64 v130; // [rsp+168h] [rbp+58h]
  int n23040; // [rsp+170h] [rbp+60h] BYREF
  __int64 v132; // [rsp+174h] [rbp+64h]
  int v133; // [rsp+17Ch] [rbp+6Ch]
  unsigned __int64 v134; // [rsp+180h] [rbp+70h]
  unsigned __int64 v135; // [rsp+188h] [rbp+78h]
  __int64 v136; // [rsp+190h] [rbp+80h]
  __int64 v137; // [rsp+198h] [rbp+88h]
  unsigned __int64 v138; // [rsp+1C0h] [rbp+B0h]
  int *v139; // [rsp+1C8h] [rbp+B8h]
  __int128 v140; // [rsp+1D0h] [rbp+C0h] BYREF
  _QWORD v141[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  char v142[8]; // [rsp+1F0h] [rbp+E0h] BYREF
  __int64 v143; // [rsp+1F8h] [rbp+E8h] BYREF
  char v144[8]; // [rsp+200h] [rbp+F0h] BYREF
  char v145[8]; // [rsp+208h] [rbp+F8h] BYREF
  char v146[16]; // [rsp+210h] [rbp+100h] BYREF
  char v147[8]; // [rsp+220h] [rbp+110h] BYREF
  _BYTE *v148; // [rsp+228h] [rbp+118h]
  __int128 v149; // [rsp+230h] [rbp+120h]
  __int64 v150[4]; // [rsp+240h] [rbp+130h] BYREF
  char v151[16]; // [rsp+260h] [rbp+150h] BYREF
  char v152[16]; // [rsp+270h] [rbp+160h] BYREF
  char v153[16]; // [rsp+280h] [rbp+170h] BYREF
  char v154[16]; // [rsp+290h] [rbp+180h] BYREF
  size_t Size_2; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 n36; // [rsp+2A8h] [rbp+198h]
  _BYTE *v157; // [rsp+2B0h] [rbp+1A0h]
  _BYTE v158[40]; // [rsp+2B8h] [rbp+1A8h] BYREF
  unsigned __int64 v159; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 n511; // [rsp+2E8h] [rbp+1D8h]
  const char *v161; // [rsp+2F0h] [rbp+1E0h]
  _BYTE v162[520]; // [rsp+2F8h] [rbp+1E8h] BYREF

  v109 = a3;
  v126 = 0;
  v127 = 0;
  v5 = a3;
  v128 = 0;
  v6 = a2;
  v129 = 0;
  v7 = a1;
  v130 = 0;
  v133 = 0;
  v135 = 0;
  v136 = 0;
  v137 = 0;
  v108 = a2;
  v119 = a1;
  v125 = 0;
  n23040 = 23040;
  v132 = 1;
  v134 = __rdtsc();
  qword_149B4B870(
    &n23040,
    &word_149CEFAC8,
    "Subsumption::SuperGUID<struct CryGUID>::ResolveSuperGuidInputValue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\SubsumptionSuperGUID.h",
    255);
  HIWORD(n23040) = word_149CEFAC8;
  if ( !*(_QWORD *)(v7 + 112) )
    goto LABEL_149;
  v8 = (*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)*v5 + 8LL))(*v5, v151);
  v9 = *(_QWORD *)(v7 + 112);
  if ( !v9 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x14137D963LL);
  }
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v9 + 16LL))(v9, v8);
  v11 = v10;
  if ( !v10 )
    goto LABEL_149;
  v12 = *(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v10 + 24LL);
  v13 = v5[1];
  if ( v13 )
    _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
  v141[0] = *v5;
  v141[1] = v5[1];
  v12(v11, &v104, v141, a4);
  v14 = *(_QWORD *)(v7 + 48);
  v106 = 0;
  v15 = *(unsigned int *)(v14 - 4);
  LODWORD(v15) = v15 & 0x7FFFFFFF;
  v138 = v15;
  v16 = v15 - 1;
  if ( !v15 )
    v16 = 0;
  v120 = v16;
  if ( !v15 )
  {
LABEL_148:
    v5 = v109;
LABEL_149:
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v95 = allocWithProfilerInfo_w(0x18u);
    if ( v95 )
    {
      *(_DWORD *)(v95 + 8) = 1;
      *(_QWORD *)v95 = off_1481B6460;
      *(_DWORD *)(v95 + 12) = 1;
      *(_QWORD *)(v95 + 16) = 0;
    }
    else
    {
      v95 = 0;
    }
    v6[3] = 0;
    v6[4] = v95;
    v135 = __rdtsc();
    qword_149B4B878(&n23040);
    v96 = (volatile signed __int32 *)v5[1];
    if ( v96 && _InterlockedExchangeAdd(v96 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v96)(v96);
      if ( _InterlockedExchangeAdd(v96 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v96 + 8LL))(v96);
    }
    return v6;
  }
  v17 = 0;
  while ( 1 )
  {
    if ( (int)v17 >= (*(_DWORD *)(*(_QWORD *)(v7 + 48) - 4LL) & 0x7FFFFFFF) )
      __debugbreak();
    v18 = (__int64 *)(*(_QWORD *)(v7 + 48) + 16LL * (int)v17);
    v19 = v18[1];
    if ( v19 )
      _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
    v20 = *v18;
    v114 = (volatile signed __int32 *)v18[1];
    if ( *(_DWORD *)(v20 + 8) )
      break;
    if ( !v104 )
    {
      v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 160LL))(qword_149B4FC78);
      v104 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v21 + 472LL))(v21, v142);
    }
    sub_1403F6100((__int64)v147, v104, v20 + 16);
    v22 = *sub_14040B4F0((__int64)v147, &v143);
    if ( v22 )
    {
      if ( v17 == v16 )
      {
        v39 = (_OWORD *)allocWithProfilerInfo_w(0x10u);
        v40 = v39;
        if ( v39 )
          *v39 = 0;
        else
          v40 = 0;
        v41 = allocWithProfilerInfo_w(0x18u);
        v42 = (volatile signed __int32 *)v41;
        if ( v41 )
        {
          *(_DWORD *)(v41 + 8) = 1;
          *(_DWORD *)(v41 + 12) = 1;
          *(_QWORD *)v41 = off_1483F71A8;
          *(_QWORD *)(v41 + 16) = v40;
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v41 + 8), 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(__int64))v41)(v41);
            if ( _InterlockedExchangeAdd(v42 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v42 + 8LL))(v42);
          }
        }
      }
      else
      {
        v104 = v22;
      }
    }
    else
    {
      v23 = *(int **)(v20 + 24);
      v24 = *(int **)(v20 + 16);
      v162[0] = 0;
      v25 = v162;
      v161 = v162;
      v159 = 0;
      n511 = 511;
      v139 = v23;
      v113 = v24;
      if ( v24 != v23 )
      {
        do
        {
          v26 = v24[2];
          v27 = *v24;
          v28 = *((unsigned __int8 *)v24 + 12);
          v29 = *((unsigned __int8 *)v24 + 13);
          v30 = *((unsigned __int8 *)v24 + 14);
          v31 = *((unsigned __int8 *)v24 + 15);
          v157 = v158;
          v101 = (unsigned __int8)v26;
          Size_2 = 0;
          v100 = BYTE1(v26);
          v99 = BYTE2(v26);
          v112 = HIBYTE(v26);
          v32 = *((unsigned __int8 *)v24 + 5);
          v98 = (unsigned __int8)v27;
          v97 = BYTE1(v27);
          LODWORD(v105) = HIBYTE(v27);
          v33 = BYTE2(v27);
          v34 = *((unsigned __int8 *)v24 + 4);
          v35 = *((unsigned __int8 *)v24 + 6);
          v36 = *((unsigned __int8 *)v113 + 7);
          v158[0] = 0;
          n36 = 36;
          sub_1402C61F0(
            (__int64)&Size_2,
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            v36,
            v35,
            v32,
            v34,
            (_DWORD)v105,
            v33,
            v97,
            v98,
            v31,
            v30,
            v29,
            v28,
            v112,
            v99,
            v100,
            v101);
          sub_1403E0AA0(&v107);
          Size = Size_2;
          if ( Size_2 )
          {
            sub_1403DE0C0(&v107, Size_2);
            sub_1403E1FA0(v107, v157, Size);
          }
          if ( v157 != v158 )
          {
            qword_149B3AD38 += -1 - n36;
            sub_147605980(v157);
          }
          if ( v107 )
          {
            Size_1 = -1;
            do
              ++Size_1;
            while ( v107[Size_1] );
          }
          else
          {
            Size_1 = 0;
          }
          sub_1402DECA0(&v159, v107, Size_1);
          sub_1402DECA0(&v159, ", ", 2u);
          sub_140370D10(&v107);
          v24 = v113 + 4;
          v113 = v24;
        }
        while ( v24 != v139 );
        v25 = v161;
        v17 = v106;
      }
      sub_1405C0E00(
        4u,
        2u,
        "SuperGUID::ResolveSuperGuidInputValue failed to find entity in superguid query corresponding to the following super guid: %s",
        v25);
      if ( v161 != v162 )
      {
        qword_149B3AB68 += -1 - n511;
        sub_147605980(v161);
      }
    }
    sub_1402B2610(v150);
    v43 = v148;
    if ( v148 )
    {
      if ( ((*((_QWORD *)&v149 + 1) - (_QWORD)v148) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
      {
        v43 = (_BYTE *)*((_QWORD *)v148 - 1);
        if ( (unsigned __int64)(v148 - v43 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v43);
      v149 = 0;
      v148 = 0;
    }
LABEL_107:
    v83 = v114;
    if ( v114 )
    {
      if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v83)(v83);
        if ( _InterlockedExchangeAdd(v83 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v83 + 8LL))(v83);
      }
    }
    v106 = ++v17;
    if ( v17 >= v138 )
    {
      v6 = v108;
      goto LABEL_148;
    }
    v7 = v119;
    v16 = v120;
  }
  v44 = *(_DWORD **)(v20 + 16);
  v45 = (unsigned int)*(v44 - 1);
  LODWORD(v45) = v45 & 0x7FFFFFFF;
  v46 = &v44[6 * v45];
  v105 = v46;
  if ( v44 == v46 )
    goto LABEL_107;
  while ( 1 )
  {
    if ( !v104 )
      goto LABEL_106;
    v47 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 280LL))(gEnv);
    v48 = v47;
    if ( !v47 )
    {
      v118 = 0;
      goto LABEL_106;
    }
    v49 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v47 + 832LL);
    v50 = word_149926080;
    if ( word_149926080 == -1 )
    {
      v50 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 16LL))(
                        qword_149B4FC88,
                        v110,
                        "ISerializedComponent");
      word_149926080 = v50;
    }
    v102 = v50;
    v51 = *(_QWORD *)v49(v48, v144, &v102);
    v118 = v51;
    if ( !v51 )
      goto LABEL_106;
    v52 = v51 & 0xFFFFFFFFFFFFLL;
    v53 = sub_1403B4B50(v51 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v53 + 4);
    if ( n4 == 4 || *(_WORD *)(v53 + 2) != (HIWORD(v51) & 0xFFF) )
      goto LABEL_106;
    if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v118) )
      goto LABEL_106;
    v55 = *(void (__fastcall **)(__int64, __int64 *, _DWORD *, __int64))(*(_QWORD *)v52 + 1456LL);
    v56 = sub_14054F030(v152);
    v55(v52, &v115, v44, v56);
    v57 = v116;
    if ( !v116 )
      goto LABEL_106;
    v58 = *(_DWORD *)(v116 + 8);
    if ( !v58 )
      goto LABEL_102;
    while ( 1 )
    {
      v59 = v58;
      v58 = _InterlockedCompareExchange((volatile signed __int32 *)(v57 + 8), v58 + 1, v58);
      if ( v59 == v58 )
        break;
      if ( !v58 )
        goto LABEL_102;
    }
    v60 = v115;
    v61 = (volatile signed __int32 *)v116;
    if ( !v115 )
      goto LABEL_97;
    if ( v17 != v120 )
    {
      v78 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v115 + 16LL))(v115, v154);
      v79 = *(_QWORD *)(v119 + 112);
      if ( !v79 )
      {
        std::_Xbad_function_call();
        __debugbreak();
      }
      v80 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v79 + 16LL))(v79, v78);
      v140 = 0;
      v81 = *v80;
      if ( v61 )
        _InterlockedIncrement(v61 + 2);
      *(_QWORD *)&v140 = v60;
      *((_QWORD *)&v140 + 1) = v61;
      v104 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *, __int128 *))(v81 + 16))(v80, v146, &v140);
      goto LABEL_97;
    }
    v62 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 280LL))(gEnv, v104);
    v63 = v62;
    if ( v62 )
      break;
    v117 = 0;
LABEL_81:
    v72 = (_OWORD *)allocWithProfilerInfo_w(0x10u);
    v73 = v72;
    if ( v72 )
      *v72 = 0;
    else
      v73 = 0;
    v74 = allocWithProfilerInfo_w(0x18u);
    v75 = (volatile signed __int32 *)v74;
    if ( v74 )
    {
      *(_DWORD *)(v74 + 8) = 1;
      *(_DWORD *)(v74 + 12) = 1;
      *(_QWORD *)v74 = off_1483F71A8;
      *(_QWORD *)(v74 + 16) = v73;
    }
    else
    {
      v75 = 0;
    }
    v76 = *(unsigned __int8 (__fastcall **)(__int64, _OWORD *, __int64))(*(_QWORD *)v60 + 64LL);
    v77 = sub_14054F030(v153);
    if ( v76(v60, v73, v77) )
    {
      v92 = v108;
      *v108 = v73;
      v92[1] = 0;
      v92[2] = 0;
      if ( v75 )
      {
        _InterlockedIncrement(v75 + 2);
        v92[1] = v73;
        v92[2] = v75;
        v92[3] = 0;
        v92[4] = 0;
        if ( _InterlockedExchangeAdd(v75 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v75)(v75);
          if ( _InterlockedExchangeAdd(v75 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v75 + 8LL))(v75);
        }
      }
      else
      {
        v92[1] = v73;
        v92[2] = 0;
        v92[3] = 0;
        v92[4] = 0;
      }
      if ( v61 )
      {
        if ( _InterlockedExchangeAdd(v61 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v61)(v61);
          if ( _InterlockedExchangeAdd(v61 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v61 + 8LL))(v61);
        }
      }
      v93 = v116;
      if ( v116 && _InterlockedExchangeAdd((volatile signed __int32 *)(v116 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v93 + 8LL))(v93);
      v94 = v114;
      if ( v114 )
      {
        if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v94)(v94);
          if ( _InterlockedExchangeAdd(v94 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v94 + 8LL))(v94);
        }
      }
      v135 = __rdtsc();
      qword_149B4B878(&n23040);
      std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v109);
      return v92;
    }
    if ( v75 )
    {
      if ( _InterlockedExchangeAdd(v75 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v75)(v75);
        if ( _InterlockedExchangeAdd(v75 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v75 + 8LL))(v75);
      }
    }
    v17 = v106;
LABEL_97:
    if ( v61 )
    {
      if ( _InterlockedExchangeAdd(v61 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v61)(v61);
        if ( _InterlockedExchangeAdd(v61 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v61 + 8LL))(v61);
      }
    }
    v46 = v105;
LABEL_102:
    v82 = v116;
    if ( v116 && _InterlockedExchangeAdd((volatile signed __int32 *)(v116 + 12), 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v82 + 8LL))(v82);
LABEL_106:
    v44 += 6;
    if ( v44 == v46 )
      goto LABEL_107;
  }
  v64 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v62 + 832LL);
  v65 = word_14992FD18;
  if ( word_14992FD18 == -1 )
  {
    v65 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 16LL))(
                      qword_149B4FC88,
                      v111,
                      "ISubsumptionComponent");
    word_14992FD18 = v65;
  }
  v103 = v65;
  v66 = *(_QWORD *)v64(v63, v145, &v103);
  v117 = v66;
  if ( !v66 )
    goto LABEL_81;
  v67 = sub_1403B4B50(v66 & 0xFFFFFFFFFFFFLL);
  n4_1 = *(_WORD *)(v67 + 4);
  if ( n4_1 == 4 || *(_WORD *)(v67 + 2) != (HIWORD(v66) & 0xFFF) )
    goto LABEL_81;
  if ( (n4_1 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v117) )
    goto LABEL_81;
  v69 = (__int64 **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v66 & 0xFFFFFFFFFFFFLL) + 1424LL))(v66 & 0xFFFFFFFFFFFFLL);
  sub_14135A8D0(v69, v121, v44);
  if ( !v121[0] )
  {
    if ( v124 )
    {
      if ( _InterlockedExchangeAdd(v124 + 2, 0xFFFFFFFF) == 1 )
      {
        v70 = v124;
        (**(void (__fastcall ***)(volatile signed __int32 *))v124)(v124);
        if ( _InterlockedExchangeAdd(v70 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v124 + 8LL))(v124);
      }
    }
    if ( v122 )
    {
      if ( _InterlockedExchangeAdd(v122 + 2, 0xFFFFFFFF) == 1 )
      {
        v71 = v122;
        (**(void (__fastcall ***)(volatile signed __int32 *))v122)(v122);
        if ( _InterlockedExchangeAdd(v71 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v122 + 8LL))(v122);
      }
    }
    goto LABEL_81;
  }
  v84 = v108;
  v85 = v122;
  *v108 = v121[0];
  v84[1] = 0;
  v84[2] = 0;
  if ( v85 )
  {
    _InterlockedIncrement(v85 + 2);
    v85 = v122;
  }
  v86 = v121[1];
  v84[2] = v85;
  v87 = v124;
  v84[1] = v86;
  v84[3] = 0;
  v84[4] = 0;
  if ( v87 )
  {
    _InterlockedIncrement(v87 + 2);
    v87 = v124;
  }
  v88 = v123;
  v84[4] = v87;
  v84[3] = v88;
  sub_140370C50((__int64)v121);
  if ( v61 )
  {
    if ( _InterlockedExchangeAdd(v61 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v61)(v61);
      if ( _InterlockedExchangeAdd(v61 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v61 + 8LL))(v61);
    }
  }
  v89 = v116;
  if ( v116 && _InterlockedExchangeAdd((volatile signed __int32 *)(v116 + 12), 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v89 + 8LL))(v89);
  v90 = v114;
  if ( v114 )
  {
    if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v90)(v90);
      if ( _InterlockedExchangeAdd(v90 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v90 + 8LL))(v90);
    }
  }
  v135 = __rdtsc();
  qword_149B4B878(&n23040);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v109);
  return v108;
}

// --- End Function: sub_14137CC40 (0x14137CC40) ---

// --- Function: sub_1425D7290 (0x1425D7290) ---
_QWORD *__fastcall sub_1425D7290(__int64 a1, _QWORD *a2)
{
  char *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rbp
  __int64 *v7; // rax
  __int64 v8; // r8
  unsigned __int8 *v9; // rax
  __int64 v10; // r8
  int v11; // ecx
  int v12; // edx
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rbp
  __int64 v16; // rdi
  __int64 v17; // rbx
  __int64 v18; // rdx
  const char *v20; // [rsp+30h] [rbp-38h] BYREF
  _BYTE v21[24]; // [rsp+38h] [rbp-30h] BYREF
  BOOL fPending; // [rsp+80h] [rbp+18h] BYREF
  char *v23; // [rsp+88h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__120, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149DDBE08 & 1) == 0 )
    {
      dword_149DDBE08 |= 1u;
      xmmword_149DDBD70 = 0;
    }
    n120_106 = 120;
    v23 = strchr(
            "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<class Subsumption::NPCEntity>>(void)",
            60);
    v4 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<class Subsumption::NPCEntity>>(void)",
           62);
    if ( v23 != v4 )
      ++v23;
    v20 = (const char *)&unk_149DDBD88;
    sub_1403E40C0(&v20, (const char *)&unk_149DDBE07, (const char **)&v23, v4);
    *v20 = 0;
    *((_QWORD *)&xmmword_149DDBD70 + 1) = &unk_149DDBE0C;
    *(_QWORD *)&xmmword_149DDBD70 = &xmmword_149DDBD70;
    qword_149DDBD68 = (__int64)&xmmword_149DDBD70;
    if ( !InitOnceComplete(&lpInitOnce__120, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v5 = *(_QWORD *)qword_149DDBD68;
  v6 = *(_QWORD *)(qword_149DDBD68 + 8);
  v7 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v21);
  v8 = *v7;
  if ( v5 == *v7 )
    goto LABEL_19;
  if ( !v5 || !v8 || v6 == v7[1] || *(_QWORD *)(v5 + 16) != *(_QWORD *)(v8 + 16) )
    goto LABEL_18;
  v9 = (unsigned __int8 *)(v5 + 24);
  v10 = v8 - v5;
  do
  {
    v11 = v9[v10];
    v12 = *v9 - v11;
    if ( v12 )
      break;
    ++v9;
  }
  while ( v11 );
  if ( !v12 )
  {
LABEL_19:
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 32LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1) && (v16 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1);
      *(_QWORD *)v16 = v17;
      *(_BYTE *)(v16 + 8) = 1;
      if ( *(_DWORD *)(v17 + 16) == *(_DWORD *)(NtCurrentTeb_w() + 24) )
      {
        ++*(_DWORD *)(v17 + 20);
      }
      else
      {
        v18 = _InterlockedIncrement64((volatile signed __int64 *)v17);
        if ( (v18 & 0x200000) != 0 )
          sub_1403CB300(v17, v18, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, 1);
      }
    }
    else
    {
      v16 = 0;
    }
    v13 = v16;
    v14 = v15;
  }
  else
  {
LABEL_18:
    v13 = 0;
    v14 = 0;
  }
  sub_14035AED0(a2, v14, v13);
  return a2;
}

// --- End Function: sub_1425D7290 (0x1425D7290) ---

// --- Function: sub_1425D9930 (0x1425D9930) ---
_QWORD *__fastcall sub_1425D9930(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 *v4; // rdx
  __int64 *v5; // rcx
  __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 *v8; // rbx
  __int64 *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  unsigned __int8 *v12; // rax
  __int64 v13; // r8
  int v14; // ecx
  int v15; // edx
  __int64 v16; // rdx
  __int64 v17; // rbx
  __int64 v18; // rbp
  __int64 v19; // rdi
  __int64 v20; // rdx
  _BYTE v22[16]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v23[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = *a1;
  v5 = v4;
  v6 = (__int64 *)v4[1];
  while ( !*((_BYTE *)v6 + 25) )
  {
    if ( *((_DWORD *)v6 + 8) >= *a3 )
    {
      v5 = v6;
      v6 = (__int64 *)*v6;
    }
    else
    {
      v6 = (__int64 *)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 25) || *a3 < *((_DWORD *)v5 + 8) || v5 == v4 )
  {
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
  else
  {
    v7 = v5[7];
    v8 = (__int64 *)sub_1425FBBC0(v22);
    v9 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 8LL))(v7, v23);
    v10 = *v8;
    v11 = *v9;
    if ( *v8 == *v9 )
      goto LABEL_19;
    if ( !v10 || !v11 || v8[1] == v9[1] || *(_QWORD *)(v10 + 16) != *(_QWORD *)(v11 + 16) )
      goto LABEL_18;
    v12 = (unsigned __int8 *)(v10 + 24);
    v13 = v11 - v10;
    do
    {
      v14 = v12[v13];
      v15 = *v12 - v14;
      if ( v15 )
        break;
      ++v12;
    }
    while ( v14 );
    if ( !v15 )
    {
LABEL_19:
      v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 32LL))(v7);
      if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7)
        && (v17 = allocWithProfilerInfo_w(0x10u)) != 0 )
      {
        v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        *(_QWORD *)v17 = v19;
        *(_BYTE *)(v17 + 8) = 1;
        if ( *(_DWORD *)(v19 + 16) == *(_DWORD *)(NtCurrentTeb_w() + 24) )
        {
          ++*(_DWORD *)(v19 + 20);
        }
        else
        {
          v20 = _InterlockedIncrement64((volatile signed __int64 *)v19);
          if ( (v20 & 0x200000) != 0 )
            sub_1403CB300(v19, v20, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, 1);
        }
      }
      else
      {
        v17 = 0;
      }
      v16 = v18;
    }
    else
    {
LABEL_18:
      v16 = 0;
      v17 = 0;
    }
    sub_14035AED0(a2, v16, v17);
    return a2;
  }
}

// --- End Function: sub_1425D9930 (0x1425D9930) ---

// --- Function: sub_1425D9AE0 (0x1425D9AE0) ---
_QWORD *__fastcall sub_1425D9AE0(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 **v3; // rdi
  __int64 **v6; // r12
  __int64 *v7; // rax
  __int64 *v8; // r8
  __int64 *v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rbx
  __int64 *v12; // rdi
  __int64 *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r8
  unsigned __int8 *v16; // rax
  __int64 v17; // r8
  int v18; // ecx
  int v19; // edx
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rsi
  __int64 v23; // rdi
  __int64 v24; // rbx
  __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rbx
  volatile signed __int32 *v28; // rbx
  __int64 v29; // rax
  volatile signed __int32 *v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rbx
  volatile signed __int32 *v34; // rbx
  char v35[16]; // [rsp+30h] [rbp-50h] BYREF
  char v36[16]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v37[2]; // [rsp+50h] [rbp-30h] BYREF
  volatile signed __int32 *v38; // [rsp+60h] [rbp-20h]
  __int64 v39; // [rsp+68h] [rbp-18h]
  __int64 v40; // [rsp+70h] [rbp-10h]
  __int64 **v41; // [rsp+B0h] [rbp+30h]

  v3 = a1 + 3;
  v41 = a1 + 3;
  v6 = a1;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_44:
    if ( ++v6 == v3 )
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      a2[3] = 0;
      a2[4] = 0;
      v29 = allocWithProfilerInfo_w(0x18u);
      if ( v29 )
      {
        *(_DWORD *)(v29 + 8) = 1;
        *(_DWORD *)(v29 + 12) = 1;
        *(_QWORD *)v29 = off_1481B6460;
        *(_QWORD *)(v29 + 16) = 0;
      }
      a2[3] = 0;
      a2[4] = v29;
      return a2;
    }
  }
  v8 = (__int64 *)*v7;
  v9 = (__int64 *)*v7;
  v10 = *(__int64 **)(*v7 + 8);
  while ( !*((_BYTE *)v10 + 25) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *((_BYTE *)v9 + 25) || *a3 < *((_DWORD *)v9 + 8) || v9 == v8 )
  {
    v38 = 0;
    v26 = allocWithProfilerInfo_w(0x18u);
    v21 = v26;
    if ( v26 )
    {
      *(_DWORD *)(v26 + 8) = 1;
      *(_DWORD *)(v26 + 12) = 1;
      *(_QWORD *)v26 = off_1481B6460;
      *(_QWORD *)(v26 + 16) = 0;
    }
    else
    {
      v21 = 0;
    }
    goto LABEL_35;
  }
  v11 = v9[7];
  v12 = (__int64 *)sub_1425FBBC0(v35);
  v13 = (__int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v11 + 8LL))(v11, v36);
  v14 = *v12;
  v15 = *v13;
  if ( *v12 != *v13 )
  {
    if ( !v14 || !v15 || v12[1] == v13[1] || *(_QWORD *)(v14 + 16) != *(_QWORD *)(v15 + 16) )
      goto LABEL_20;
    v16 = (unsigned __int8 *)(v14 + 24);
    v17 = v15 - v14;
    do
    {
      v18 = v16[v17];
      v19 = *v16 - v18;
      if ( v19 )
        break;
      ++v16;
    }
    while ( v18 );
    if ( v19 )
    {
LABEL_20:
      v38 = 0;
      v20 = allocWithProfilerInfo_w(0x18u);
      v21 = v20;
      v3 = v41;
      if ( v20 )
      {
        *(_DWORD *)(v20 + 8) = 1;
        *(_DWORD *)(v20 + 12) = 1;
        *(_QWORD *)v20 = off_1481B6460;
        *(_QWORD *)(v20 + 16) = 0;
      }
      else
      {
        v21 = 0;
      }
LABEL_35:
      v40 = v21;
LABEL_36:
      if ( v21 )
      {
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v21 + 8), 0xFFFFFFFF) == 1 )
        {
          v27 = v40;
          (**(void (__fastcall ***)(__int64))v40)(v40);
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 12), 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
        }
      }
      if ( v38 )
      {
        if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
        {
          v28 = v38;
          (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
          if ( _InterlockedExchangeAdd(v28 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
        }
      }
      goto LABEL_44;
    }
  }
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 32LL))(v11);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11) && (v23 = allocWithProfilerInfo_w(0x10u)) != 0 )
  {
    v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
    *(_QWORD *)v23 = v24;
    *(_BYTE *)(v23 + 8) = 1;
    if ( *(_DWORD *)(v24 + 16) == *(_DWORD *)(NtCurrentTeb_w() + 24) )
    {
      ++*(_DWORD *)(v24 + 20);
    }
    else
    {
      v25 = _InterlockedIncrement64((volatile signed __int64 *)v24);
      if ( (v25 & 0x200000) != 0 )
        sub_1403CB300(v24, v25, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source, 1);
    }
  }
  else
  {
    v23 = 0;
  }
  sub_14035AED0(v37, v22, v23);
  if ( !v37[0] )
  {
    v21 = v40;
    v3 = v41;
    goto LABEL_36;
  }
  v31 = v38;
  *a2 = v37[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v31 )
  {
    _InterlockedIncrement(v31 + 2);
    v31 = v38;
  }
  v32 = v40;
  a2[1] = v37[1];
  a2[2] = v31;
  a2[3] = 0;
  a2[4] = 0;
  if ( v32 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v32 + 8));
    v32 = v40;
    v31 = v38;
  }
  a2[3] = v39;
  a2[4] = v32;
  if ( v32 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v32 + 8), 0xFFFFFFFF) == 1 )
    {
      v33 = v40;
      (**(void (__fastcall ***)(__int64))v40)(v40);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v33 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
    }
    v31 = v38;
  }
  if ( v31 )
  {
    if ( _InterlockedExchangeAdd(v31 + 2, 0xFFFFFFFF) == 1 )
    {
      v34 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  return a2;
}

// --- End Function: sub_1425D9AE0 (0x1425D9AE0) ---

// --- Function: sub_1425DEEA0 (0x1425DEEA0) ---
_QWORD *__fastcall sub_1425DEEA0(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  __int64 v8; // rcx
  volatile signed __int32 *v9; // rdx
  signed __int32 v10; // eax
  volatile signed __int32 *v11; // rbx
  volatile signed __int32 *v12; // rbx
  volatile signed __int32 *v13; // rbx
  __int64 v14; // rbx
  __int64 *v15; // r8
  __int64 *v16; // rcx
  __int64 *v17; // rax
  _DWORD *v18; // r14
  __int64 v19; // rbx
  __int64 v20; // rbx
  volatile signed __int32 *v21; // rbx
  volatile signed __int32 *v22; // rbx
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rcx
  __int64 v25; // rax
  volatile signed __int32 *v26; // rbx
  volatile signed __int32 *v27; // rbx
  __int128 v29; // [rsp+20h] [rbp-59h] BYREF
  _QWORD v30[2]; // [rsp+30h] [rbp-49h] BYREF
  __int64 v31; // [rsp+40h] [rbp-39h]
  __int64 v32; // [rsp+48h] [rbp-31h]
  volatile signed __int32 *v33; // [rsp+50h] [rbp-29h]
  _DWORD *v34; // [rsp+58h] [rbp-21h] BYREF
  volatile signed __int32 *v35; // [rsp+68h] [rbp-11h]
  volatile signed __int32 *v36; // [rsp+78h] [rbp-1h]
  _DWORD *v37[2]; // [rsp+80h] [rbp+7h] BYREF
  volatile signed __int32 *v38; // [rsp+90h] [rbp+17h]
  volatile signed __int32 *v39; // [rsp+A0h] [rbp+27h]
  __int128 v40; // [rsp+B0h] [rbp+37h] BYREF

  sub_1425D9930((__int64 **)(a1 + 16 * ((int)a3[6] + 10LL)), v30, a3);
  if ( v30[0] )
  {
    v8 = v31;
    *a2 = v30[0];
    a2[1] = 0;
    a2[2] = 0;
    if ( v8 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 8));
      v8 = v31;
    }
    v9 = v33;
    a2[1] = v30[1];
    a2[2] = v8;
    a2[3] = 0;
    a2[4] = 0;
    if ( v9 )
    {
      _InterlockedIncrement(v9 + 2);
      v9 = v33;
      v8 = v31;
    }
    a2[3] = v32;
    a2[4] = v9;
    if ( !v9 )
      goto LABEL_23;
    v10 = _InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF);
    goto LABEL_19;
  }
  sub_14033B5B0((__int64 **)(a1 + 16 * ((int)a3[6] + 10LL)), v37, a3);
  if ( !v37[0] )
  {
    v15 = *(__int64 **)(a1 + 16 * ((int)a3[6] + 10LL));
    v16 = v15;
    v17 = (__int64 *)v15[1];
    while ( !*((_BYTE *)v17 + 25) )
    {
      if ( *((_DWORD *)v17 + 8) >= *a3 )
      {
        v16 = v17;
        v17 = (__int64 *)*v17;
      }
      else
      {
        v17 = (__int64 *)v17[2];
      }
    }
    if ( *((_BYTE *)v16 + 25) || *a3 < *((_DWORD *)v16 + 8) || v16 == v15 )
    {
      v35 = 0;
      v25 = allocWithProfilerInfo_w(0x18u);
      v24 = (volatile signed __int32 *)v25;
      if ( v25 )
      {
        *(_DWORD *)(v25 + 8) = 1;
        *(_DWORD *)(v25 + 12) = 1;
        *(_QWORD *)v25 = off_1481B6460;
        *(_QWORD *)(v25 + 16) = 0;
      }
      else
      {
        v24 = 0;
      }
      v36 = v24;
    }
    else
    {
      sub_1425D7290(v16[7], &v34);
      v18 = v34;
      if ( v34 )
      {
        v29 = 0;
        if ( sub_14053B5C0(a4, v34, &v29) )
        {
          v19 = *((_QWORD *)&v29 + 1);
          if ( *((_QWORD *)&v29 + 1) )
          {
            _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL));
            v18 = v34;
            v19 = *((_QWORD *)&v29 + 1);
          }
          v40 = v29;
          sub_142648CD0(v18, a2, &v40, a4 + 136);
          if ( v19 )
          {
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v19 + 8), 0xFFFFFFFF) == 1 )
            {
              v20 = *((_QWORD *)&v29 + 1);
              (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
              if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v20 + 12), 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
            }
          }
          if ( v36 )
          {
            if ( _InterlockedExchangeAdd(v36 + 2, 0xFFFFFFFF) == 1 )
            {
              v21 = v36;
              (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
              if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
            }
          }
          if ( v35 )
          {
            if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
            {
              v22 = v35;
              (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
              if ( _InterlockedExchangeAdd(v22 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
            }
          }
          sub_140370C50((__int64)v37);
LABEL_70:
          sub_140370C50((__int64)v30);
          return a2;
        }
        if ( *((_QWORD *)&v29 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            v23 = *((_QWORD *)&v29 + 1);
            (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v23 + 12), 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
          }
        }
      }
      v24 = v36;
    }
    if ( v24 )
    {
      if ( _InterlockedExchangeAdd(v24 + 2, 0xFFFFFFFF) == 1 )
      {
        v26 = v36;
        (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
        if ( _InterlockedExchangeAdd(v26 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
      }
    }
    if ( v35 )
    {
      if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
      {
        v27 = v35;
        (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
        if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
      }
    }
    sub_140370C50((__int64)v37);
    sub_14035AED0(a2, 0, 0);
    goto LABEL_70;
  }
  sub_1425D9AE0((__int64 **)(a4 + 136), a2, v37[0]);
  if ( v39 )
  {
    if ( _InterlockedExchangeAdd(v39 + 2, 0xFFFFFFFF) == 1 )
    {
      v11 = v39;
      (**(void (__fastcall ***)(volatile signed __int32 *))v39)(v39);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v39 + 8LL))(v39);
    }
  }
  if ( v38 )
  {
    if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
    {
      v12 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  if ( !v33 )
    goto LABEL_22;
  v10 = _InterlockedExchangeAdd(v33 + 2, 0xFFFFFFFF);
LABEL_19:
  if ( v10 == 1 )
  {
    v13 = v33;
    (**(void (__fastcall ***)(volatile signed __int32 *))v33)(v33);
    if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v33 + 8LL))(v33);
  }
LABEL_22:
  v8 = v31;
LABEL_23:
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    {
      v14 = v31;
      (**(void (__fastcall ***)(__int64))v31)(v31);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v14 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 8LL))(v31);
    }
  }
  return a2;
}

// --- End Function: sub_1425DEEA0 (0x1425DEEA0) ---

// --- Function: sub_142648CD0 (0x142648CD0) ---
__int64 *__fastcall sub_142648CD0(__int64 a1, __int64 *a2, void *a3, __int64 a4)
{
  _QWORD *v5; // rsi
  __int64 *v6; // r12
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rcx
  void (__fastcall *v12)(__int64, __int64 *, _QWORD *, __int64); // r10
  __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r13
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  volatile signed __int32 *v21; // r14
  __int64 v22; // rax
  int **v23; // rdi
  __int64 *v24; // rax
  __int64 v25; // rbx
  int *v26; // rcx
  const char *v27; // rax
  int *v28; // r9
  unsigned int v29; // ecx
  unsigned int v30; // r8d
  int v31; // ebx
  int v32; // edi
  int v33; // esi
  int v34; // r14d
  int v35; // ecx
  int v36; // edx
  int v37; // eax
  int v38; // r9d
  int v39; // r8d
  size_t Size; // rbx
  size_t Size_1; // r8
  _BYTE *v42; // rcx
  _DWORD *v43; // r13
  __int64 v44; // rax
  _DWORD *v45; // rsi
  __int64 v46; // rax
  __int64 v47; // rbx
  __int64 (__fastcall *v48)(__int64, char *, __int16 *); // rdi
  __int16 v49; // ax
  __int64 v50; // rbx
  __int64 v51; // rdi
  __int64 v52; // rcx
  __int16 n4; // ax
  void (__fastcall *v54)(__int64, __int64 *, _DWORD *, __int64); // rbx
  __int64 v55; // rax
  __int64 v56; // rdx
  signed __int32 v57; // eax
  signed __int32 v58; // ett
  __int64 v59; // r12
  volatile signed __int32 *v60; // rsi
  __int64 v61; // rax
  __int64 v62; // rbx
  __int64 (__fastcall *v63)(__int64, char *, __int16 *); // rdi
  __int16 v64; // ax
  __int64 v65; // rbx
  __int64 v66; // rax
  __int16 n4_1; // cx
  __int64 **v68; // rax
  volatile signed __int32 *v69; // rbx
  volatile signed __int32 *v70; // rbx
  __int64 v71; // rax
  __int64 v72; // r14
  __int64 v73; // rax
  volatile signed __int32 *v74; // rbx
  unsigned __int8 (__fastcall *v75)(__int64, __int64, __int64); // rdi
  __int64 v76; // rax
  __int64 v77; // rdx
  __int64 v78; // rcx
  __int64 *v79; // rcx
  __int64 v80; // rax
  __int64 v81; // rcx
  volatile signed __int32 *v82; // rbx
  __int64 v83; // rax
  __int64 v84; // rsi
  __int64 v85; // rax
  volatile signed __int32 *v86; // rdi
  _BYTE *v87; // rcx
  __int64 *v88; // rdi
  volatile signed __int32 *v89; // rcx
  __int64 v90; // rax
  volatile signed __int32 *v91; // rcx
  __int64 v92; // rax
  __int64 v93; // rcx
  volatile signed __int32 *v94; // r14
  void (__fastcall **v95)(_QWORD); // rax
  volatile signed __int32 *v96; // rcx
  __int64 v98; // rcx
  volatile signed __int32 *v99; // rbx
  __int64 v100; // rax
  volatile signed __int32 *v101; // rbx
  int v102; // [rsp+40h] [rbp-D0h]
  int v103; // [rsp+48h] [rbp-C8h]
  int v104; // [rsp+78h] [rbp-98h]
  int v105; // [rsp+80h] [rbp-90h]
  int v106; // [rsp+88h] [rbp-88h]
  __int16 v107; // [rsp+90h] [rbp-80h] BYREF
  __int16 v108; // [rsp+92h] [rbp-7Eh] BYREF
  __int64 v109; // [rsp+98h] [rbp-78h] BYREF
  _DWORD *v110; // [rsp+A0h] [rbp-70h]
  void *v111; // [rsp+A8h] [rbp-68h]
  char *v112; // [rsp+B0h] [rbp-60h] BYREF
  __int64 *v113; // [rsp+B8h] [rbp-58h]
  char v114[2]; // [rsp+C0h] [rbp-50h] BYREF
  char v115[2]; // [rsp+C2h] [rbp-4Eh] BYREF
  unsigned int v116; // [rsp+C4h] [rbp-4Ch]
  int *v117; // [rsp+C8h] [rbp-48h]
  unsigned __int64 v118; // [rsp+D0h] [rbp-40h]
  volatile signed __int32 *v119; // [rsp+D8h] [rbp-38h]
  __int64 v120; // [rsp+E0h] [rbp-30h] BYREF
  __int64 v121; // [rsp+E8h] [rbp-28h]
  __int64 v122; // [rsp+F0h] [rbp-20h] BYREF
  __int64 v123; // [rsp+F8h] [rbp-18h] BYREF
  __int64 v124; // [rsp+100h] [rbp-10h]
  unsigned __int64 v125; // [rsp+108h] [rbp-8h]
  _QWORD v126[2]; // [rsp+110h] [rbp+0h] BYREF
  volatile signed __int32 *v127; // [rsp+120h] [rbp+10h]
  __int64 v128; // [rsp+128h] [rbp+18h]
  volatile signed __int32 *v129; // [rsp+130h] [rbp+20h]
  int n23040; // [rsp+140h] [rbp+30h] BYREF
  __int64 v131; // [rsp+144h] [rbp+34h]
  int v132; // [rsp+14Ch] [rbp+3Ch]
  unsigned __int64 v133; // [rsp+150h] [rbp+40h]
  unsigned __int64 v134; // [rsp+158h] [rbp+48h]
  __int64 v135; // [rsp+160h] [rbp+50h]
  __int64 v136; // [rsp+168h] [rbp+58h]
  __int64 v137; // [rsp+190h] [rbp+80h]
  __int64 v138; // [rsp+198h] [rbp+88h]
  __int64 v139; // [rsp+1A0h] [rbp+90h]
  __int64 v140; // [rsp+1A8h] [rbp+98h]
  __int64 v141; // [rsp+1B0h] [rbp+A0h]
  __int64 v142; // [rsp+1B8h] [rbp+A8h]
  unsigned __int64 v143; // [rsp+1C0h] [rbp+B0h]
  int *v144; // [rsp+1C8h] [rbp+B8h]
  __int128 v145; // [rsp+1D0h] [rbp+C0h] BYREF
  _QWORD v146[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  char v147[8]; // [rsp+1F0h] [rbp+E0h] BYREF
  _BYTE *v148; // [rsp+1F8h] [rbp+E8h]
  __int128 v149; // [rsp+200h] [rbp+F0h]
  __int64 v150[4]; // [rsp+210h] [rbp+100h] BYREF
  char v151[8]; // [rsp+230h] [rbp+120h] BYREF
  __int64 v152; // [rsp+238h] [rbp+128h] BYREF
  char v153[8]; // [rsp+240h] [rbp+130h] BYREF
  char v154[8]; // [rsp+248h] [rbp+138h] BYREF
  char v155[8]; // [rsp+250h] [rbp+140h] BYREF
  char v156[16]; // [rsp+258h] [rbp+148h] BYREF
  char v157[16]; // [rsp+268h] [rbp+158h] BYREF
  char v158[16]; // [rsp+278h] [rbp+168h] BYREF
  char v159[24]; // [rsp+288h] [rbp+178h] BYREF
  size_t Size_2; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 n36; // [rsp+2A8h] [rbp+198h]
  _BYTE *v162; // [rsp+2B0h] [rbp+1A0h]
  _BYTE v163[40]; // [rsp+2B8h] [rbp+1A8h] BYREF
  unsigned __int64 v164; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 n511; // [rsp+2E8h] [rbp+1D8h]
  const char *v166; // [rsp+2F0h] [rbp+1E0h]
  _BYTE v167[520]; // [rsp+2F8h] [rbp+1E8h] BYREF

  v111 = a3;
  v138 = 0;
  v139 = 0;
  v5 = a3;
  v140 = 0;
  v6 = a2;
  v141 = 0;
  v7 = a1;
  v142 = 0;
  v132 = 0;
  v134 = 0;
  v135 = 0;
  v136 = 0;
  v113 = a2;
  v124 = a1;
  v137 = 0;
  n23040 = 23040;
  v131 = 1;
  v133 = __rdtsc();
  qword_149B4B870(
    &n23040,
    &word_149DDB7AC,
    "Subsumption::SuperGUID<class Subsumption::NPCEntity>::ResolveSuperGuidInputValue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\SubsumptionSuperGUID.h",
    255);
  HIWORD(n23040) = word_149DDB7AC;
  if ( !*(_QWORD *)(v7 + 112) )
    goto LABEL_161;
  v8 = (*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)*v5 + 8LL))(*v5, v156);
  v9 = *(_QWORD *)(v7 + 112);
  if ( !v9 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x142649B66LL);
  }
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v9 + 16LL))(v9, v8);
  v11 = v10;
  if ( !v10 )
    goto LABEL_161;
  v12 = *(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v10 + 24LL);
  v13 = v5[1];
  if ( v13 )
    _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
  v146[0] = *v5;
  v146[1] = v5[1];
  v12(v11, &v109, v146, a4);
  v14 = *(_QWORD *)(v7 + 48);
  v15 = 0;
  v118 = 0;
  v16 = *(unsigned int *)(v14 - 4);
  LODWORD(v16) = v16 & 0x7FFFFFFF;
  v143 = v16;
  v17 = v16 - 1;
  if ( !v16 )
    v17 = 0;
  v125 = v17;
  if ( !v16 )
  {
LABEL_160:
    v5 = v111;
LABEL_161:
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v100 = allocWithProfilerInfo_w(0x18u);
    if ( v100 )
    {
      *(_DWORD *)(v100 + 8) = 1;
      *(_QWORD *)v100 = off_1481B6460;
      *(_DWORD *)(v100 + 12) = 1;
      *(_QWORD *)(v100 + 16) = 0;
    }
    else
    {
      v100 = 0;
    }
    v6[3] = 0;
    v6[4] = v100;
    v134 = __rdtsc();
    qword_149B4B878(&n23040);
    v101 = (volatile signed __int32 *)v5[1];
    if ( v101 && _InterlockedExchangeAdd(v101 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v101)(v101);
      if ( _InterlockedExchangeAdd(v101 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v101 + 8LL))(v101);
    }
    return v6;
  }
  while ( 1 )
  {
    if ( (int)v15 >= (*(_DWORD *)(*(_QWORD *)(v7 + 48) - 4LL) & 0x7FFFFFFF) )
      __debugbreak();
    v18 = (__int64 *)(*(_QWORD *)(v7 + 48) + 16LL * (int)v15);
    v19 = v18[1];
    if ( v19 )
      _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
    v20 = *v18;
    v21 = (volatile signed __int32 *)v18[1];
    v119 = v21;
    if ( *(_DWORD *)(v20 + 8) )
      break;
    if ( !v109 )
    {
      v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 160LL))(qword_149B4FC78);
      v109 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v22 + 472LL))(v22, v151);
    }
    v23 = (int **)(v20 + 16);
    sub_1403F6100((__int64)v147, v109, v20 + 16);
    v24 = sub_14040B4F0((__int64)v147, &v152);
    v25 = *v24;
    if ( *v24 )
    {
      if ( v15 == v17 )
      {
        v83 = allocWithProfilerInfo_w(0x1A0u);
        if ( v83 )
          v84 = sub_142601EE0(v83);
        else
          v84 = 0;
        v85 = allocWithProfilerInfo_w(0x18u);
        v86 = (volatile signed __int32 *)v85;
        if ( v85 )
        {
          *(_DWORD *)(v85 + 8) = 1;
          *(_DWORD *)(v85 + 12) = 1;
          *(_QWORD *)v85 = off_14861A3D0;
          *(_QWORD *)(v85 + 16) = v84;
        }
        else
        {
          v86 = 0;
        }
        sub_14264F010(v84, v25);
        v6 = v113;
        *v113 = v84;
        v6[1] = 0;
        v6[2] = 0;
        if ( v86 )
        {
          _InterlockedIncrement(v86 + 2);
          v6[1] = v84;
          v6[2] = (__int64)v86;
          v6[3] = 0;
          v6[4] = 0;
          if ( _InterlockedExchangeAdd(v86 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v86)(v86);
            if ( _InterlockedExchangeAdd(v86 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v86 + 8LL))(v86);
          }
        }
        else
        {
          v6[1] = v84;
          v6[2] = 0;
          v6[3] = 0;
          v6[4] = 0;
        }
        sub_1402B2610(v150);
        v87 = v148;
        if ( v148 )
        {
          if ( ((*((_QWORD *)&v149 + 1) - (_QWORD)v148) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
          {
            v87 = (_BYTE *)*((_QWORD *)v148 - 1);
            if ( (unsigned __int64)(v148 - v87 - 8) > 0x1F )
LABEL_119:
              invalid_parameter_noinfo_noreturn();
          }
          sub_1402A3D30(v87);
          v149 = 0;
          v148 = 0;
        }
        if ( v21 )
        {
          if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
            if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v21 + 8LL))(v21);
          }
        }
        v134 = __rdtsc();
        qword_149B4B878(&n23040);
        std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v111);
        return v6;
      }
      v109 = *v24;
    }
    else
    {
      v26 = v23[1];
      v27 = v167;
      v28 = *v23;
      v167[0] = 0;
      v166 = v167;
      v164 = 0;
      n511 = 511;
      v144 = v26;
      v117 = v28;
      if ( v28 != v26 )
      {
        do
        {
          v29 = v28[2];
          v30 = *v28;
          v31 = *((unsigned __int8 *)v28 + 12);
          v32 = *((unsigned __int8 *)v28 + 13);
          v33 = *((unsigned __int8 *)v28 + 14);
          v34 = *((unsigned __int8 *)v28 + 15);
          v162 = v163;
          v106 = (unsigned __int8)v29;
          v105 = BYTE1(v29);
          v104 = BYTE2(v29);
          v116 = HIBYTE(v29);
          v35 = *((unsigned __int8 *)v28 + 5);
          v103 = (unsigned __int8)v30;
          v102 = BYTE1(v30);
          LODWORD(v110) = HIBYTE(v30);
          v36 = BYTE2(v30);
          v37 = *((unsigned __int8 *)v28 + 4);
          v38 = *((unsigned __int8 *)v28 + 6);
          v39 = *((unsigned __int8 *)v117 + 7);
          v163[0] = 0;
          Size_2 = 0;
          n36 = 36;
          sub_1402C61F0(
            (__int64)&Size_2,
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            v39,
            v38,
            v35,
            v37,
            (_DWORD)v110,
            v36,
            v102,
            v103,
            v34,
            v33,
            v32,
            v31,
            v116,
            v104,
            v105,
            v106);
          sub_1403E0AA0(&v112);
          Size = Size_2;
          if ( Size_2 )
          {
            sub_1403DE0C0(&v112, Size_2);
            sub_1403E1FA0(v112, v162, Size);
          }
          if ( v162 != v163 )
          {
            qword_149B3AD38 += -1 - n36;
            sub_147605980(v162);
          }
          if ( v112 )
          {
            Size_1 = -1;
            do
              ++Size_1;
            while ( v112[Size_1] );
          }
          else
          {
            Size_1 = 0;
          }
          sub_1402DECA0(&v164, v112, Size_1);
          sub_1402DECA0(&v164, ", ", 2u);
          sub_140370D10(&v112);
          v28 = v117 + 4;
          v117 = v28;
        }
        while ( v28 != v144 );
        v27 = v166;
      }
      sub_1405C0E00(
        4u,
        2u,
        "SuperGUID::ResolveSuperGuidInputValue failed to find entity in superguid query corresponding to the following super guid: %s",
        v27);
      if ( v166 != v167 )
      {
        qword_149B3AB68 += -1 - n511;
        sub_147605980(v166);
      }
    }
    sub_1402B2610(v150);
    v42 = v148;
    if ( v148 )
    {
      if ( ((*((_QWORD *)&v149 + 1) - (_QWORD)v148) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
      {
        v42 = (_BYTE *)*((_QWORD *)v148 - 1);
        if ( (unsigned __int64)(v148 - v42 - 8) > 0x1F )
          goto LABEL_119;
      }
      sub_1402A3D30(v42);
      v148 = 0;
      v149 = 0;
    }
LABEL_99:
    v82 = v119;
    if ( v119 )
    {
      if ( _InterlockedExchangeAdd(v119 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v82)(v82);
        if ( _InterlockedExchangeAdd(v82 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v82 + 8LL))(v82);
      }
    }
    v15 = v118 + 1;
    v118 = v15;
    if ( v15 >= v143 )
    {
      v6 = v113;
      goto LABEL_160;
    }
    v7 = v124;
    v17 = v125;
  }
  v43 = *(_DWORD **)(v20 + 16);
  v44 = (unsigned int)*(v43 - 1);
  LODWORD(v44) = v44 & 0x7FFFFFFF;
  v45 = &v43[6 * v44];
  v110 = v45;
  if ( v43 == v45 )
    goto LABEL_99;
  while ( !v109 )
  {
LABEL_96:
    v43 += 6;
    if ( v43 == v45 )
      goto LABEL_99;
  }
  v46 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 280LL))(gEnv);
  v47 = v46;
  if ( !v46 )
  {
    v123 = 0;
    goto LABEL_96;
  }
  v48 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v46 + 832LL);
  v49 = word_149926080;
  if ( word_149926080 == -1 )
  {
    v49 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 16LL))(
                      qword_149B4FC88,
                      v114,
                      "ISerializedComponent");
    word_149926080 = v49;
  }
  v107 = v49;
  v50 = *(_QWORD *)v48(v47, v153, &v107);
  v123 = v50;
  if ( !v50 )
    goto LABEL_96;
  v51 = v50 & 0xFFFFFFFFFFFFLL;
  v52 = sub_1403B4B50(v50 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v52 + 4);
  if ( n4 == 4 || *(_WORD *)(v52 + 2) != (HIWORD(v50) & 0xFFF) )
    goto LABEL_96;
  if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v123) )
    goto LABEL_96;
  v54 = *(void (__fastcall **)(__int64, __int64 *, _DWORD *, __int64))(*(_QWORD *)v51 + 1456LL);
  v55 = sub_1425FBBC0(v157);
  v54(v51, &v120, v43, v55);
  v56 = v121;
  if ( !v121 )
    goto LABEL_96;
  v57 = *(_DWORD *)(v121 + 8);
  if ( !v57 )
    goto LABEL_93;
  while ( 1 )
  {
    v58 = v57;
    v57 = _InterlockedCompareExchange((volatile signed __int32 *)(v56 + 8), v57 + 1, v57);
    if ( v58 == v57 )
      break;
    if ( !v57 )
      goto LABEL_93;
  }
  v59 = v120;
  v60 = (volatile signed __int32 *)v121;
  if ( !v120 )
  {
LABEL_88:
    if ( v60 )
    {
      if ( _InterlockedExchangeAdd(v60 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v60)(v60);
        if ( _InterlockedExchangeAdd(v60 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v60 + 8LL))(v60);
      }
    }
    v45 = v110;
LABEL_93:
    v81 = v121;
    if ( v121 && _InterlockedExchangeAdd((volatile signed __int32 *)(v121 + 12), 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v81 + 8LL))(v81);
    goto LABEL_96;
  }
  if ( v118 != v125 )
  {
    v77 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v120 + 16LL))(v120, v159);
    v78 = *(_QWORD *)(v124 + 112);
    if ( !v78 )
    {
      std::_Xbad_function_call();
      __debugbreak();
    }
    v79 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v78 + 16LL))(v78, v77);
    v145 = 0;
    v80 = *v79;
    if ( v60 )
      _InterlockedIncrement(v60 + 2);
    *(_QWORD *)&v145 = v59;
    *((_QWORD *)&v145 + 1) = v60;
    v109 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *, __int128 *))(v80 + 16))(v79, v155, &v145);
    goto LABEL_88;
  }
  v61 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 280LL))(gEnv, v109);
  v62 = v61;
  if ( !v61 )
  {
    v122 = 0;
    goto LABEL_72;
  }
  v63 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v61 + 832LL);
  v64 = word_14992FD18;
  if ( word_14992FD18 == -1 )
  {
    v64 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 16LL))(
                      qword_149B4FC88,
                      v115,
                      "ISubsumptionComponent");
    word_14992FD18 = v64;
  }
  v108 = v64;
  v65 = *(_QWORD *)v63(v62, v154, &v108);
  v122 = v65;
  if ( !v65
    || (v66 = sub_1403B4B50(v65 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v66 + 4), n4_1 == 4)
    || *(_WORD *)(v66 + 2) != (HIWORD(v65) & 0xFFF)
    || (n4_1 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v122) )
  {
LABEL_72:
    v71 = allocWithProfilerInfo_w(0x1A0u);
    if ( v71 )
      v72 = sub_142601EE0(v71);
    else
      v72 = 0;
    v73 = allocWithProfilerInfo_w(0x18u);
    v74 = (volatile signed __int32 *)v73;
    if ( v73 )
    {
      *(_DWORD *)(v73 + 8) = 1;
      *(_DWORD *)(v73 + 12) = 1;
      *(_QWORD *)v73 = off_14861A3D0;
      *(_QWORD *)(v73 + 16) = v72;
    }
    else
    {
      v74 = 0;
    }
    v75 = *(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v59 + 64LL);
    v76 = sub_1425FBBC0(v158);
    if ( v75(v59, v72, v76) )
    {
      v88 = v113;
      *v113 = v72;
      v88[1] = 0;
      v88[2] = 0;
      if ( v74 )
      {
        _InterlockedIncrement(v74 + 2);
        v88[1] = v72;
        v88[2] = (__int64)v74;
        v88[3] = 0;
        v88[4] = 0;
        if ( _InterlockedExchangeAdd(v74 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v74)(v74);
          if ( _InterlockedExchangeAdd(v74 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v74 + 8LL))(v74);
        }
      }
      else
      {
        v88[1] = v72;
        v88[2] = 0;
        v88[3] = 0;
        v88[4] = 0;
      }
      if ( v60 )
      {
        if ( _InterlockedExchangeAdd(v60 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v60)(v60);
          if ( _InterlockedExchangeAdd(v60 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v60 + 8LL))(v60);
        }
      }
      v98 = v121;
      if ( v121 && _InterlockedExchangeAdd((volatile signed __int32 *)(v121 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v98 + 8LL))(v98);
      v99 = v119;
      if ( v119 )
      {
        if ( _InterlockedExchangeAdd(v119 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v99)(v99);
          if ( _InterlockedExchangeAdd(v99 + 3, 0xFFFFFFFF) == 1 )
          {
            v95 = *(void (__fastcall ***)(_QWORD))v99;
            v96 = v99;
            goto LABEL_141;
          }
        }
      }
      goto LABEL_142;
    }
    if ( v74 )
    {
      if ( _InterlockedExchangeAdd(v74 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v74)(v74);
        if ( _InterlockedExchangeAdd(v74 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v74 + 8LL))(v74);
      }
    }
    goto LABEL_88;
  }
  v68 = (__int64 **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 1424LL))(v65 & 0xFFFFFFFFFFFFLL);
  sub_1425D9930(v68, v126, v43);
  if ( !v126[0] )
  {
    if ( v129 )
    {
      if ( _InterlockedExchangeAdd(v129 + 2, 0xFFFFFFFF) == 1 )
      {
        v69 = v129;
        (**(void (__fastcall ***)(volatile signed __int32 *))v129)(v129);
        if ( _InterlockedExchangeAdd(v69 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v129 + 8LL))(v129);
      }
    }
    if ( v127 )
    {
      if ( _InterlockedExchangeAdd(v127 + 2, 0xFFFFFFFF) == 1 )
      {
        v70 = v127;
        (**(void (__fastcall ***)(volatile signed __int32 *))v127)(v127);
        if ( _InterlockedExchangeAdd(v70 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v127 + 8LL))(v127);
      }
    }
    goto LABEL_72;
  }
  v88 = v113;
  v89 = v127;
  *v113 = v126[0];
  v88[1] = 0;
  v88[2] = 0;
  if ( v89 )
  {
    _InterlockedIncrement(v89 + 2);
    v89 = v127;
  }
  v90 = v126[1];
  v88[2] = (__int64)v89;
  v91 = v129;
  v88[1] = v90;
  v88[3] = 0;
  v88[4] = 0;
  if ( v91 )
  {
    _InterlockedIncrement(v91 + 2);
    v91 = v129;
  }
  v92 = v128;
  v88[4] = (__int64)v91;
  v88[3] = v92;
  sub_140370C50((__int64)v126);
  if ( v60 )
  {
    if ( _InterlockedExchangeAdd(v60 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v60)(v60);
      if ( _InterlockedExchangeAdd(v60 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v60 + 8LL))(v60);
    }
  }
  v93 = v121;
  if ( v121 && _InterlockedExchangeAdd((volatile signed __int32 *)(v121 + 12), 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v93 + 8LL))(v93);
  v94 = v119;
  if ( v119 )
  {
    if ( _InterlockedExchangeAdd(v119 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v94)(v94);
      if ( _InterlockedExchangeAdd(v94 + 3, 0xFFFFFFFF) == 1 )
      {
        v95 = *(void (__fastcall ***)(_QWORD))v94;
        v96 = v94;
LABEL_141:
        ((void (__fastcall **)(volatile signed __int32 *))v95)[1](v96);
      }
    }
  }
LABEL_142:
  v134 = __rdtsc();
  qword_149B4B878(&n23040);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v111);
  return v88;
}

// --- End Function: sub_142648CD0 (0x142648CD0) ---

// --- Function: sub_1429EFDD0 (0x1429EFDD0) ---
__int64 __fastcall sub_1429EFDD0(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm6
  __int128 v7; // xmm6
  unsigned __int64 v8; // rcx
  __int64 v9; // rbx
  unsigned __int64 v10; // rcx
  __int64 v11; // rbx
  bool v12; // al
  __int64 v13; // rbx
  __int64 (__fastcall *v14)(__int64, __int128 *, __int16 *); // rsi
  __int16 v15; // ax
  __int64 v16; // rbx
  __int64 v17; // rax
  __int16 n4_1; // dx
  __int64 gEnv; // rsi
  __int64 v20; // rdi
  __int64 v21; // rax
  __int16 n4; // cx
  int event_key_from_source_location; // eax
  size_t n511_1; // rdi
  __int64 v25; // r8
  int n2; // edx
  size_t n511_2; // rdi
  size_t n511_3; // rsi
  __int64 *v29; // rax
  size_t n511_4; // rsi
  volatile signed __int32 *v31; // rbx
  volatile signed __int32 *v32; // rbx
  volatile signed __int32 *v33; // rbx
  volatile signed __int32 *v34; // rbx
  __int16 v36; // [rsp+30h] [rbp-D0h] BYREF
  _BYTE v37[14]; // [rsp+32h] [rbp-CEh] BYREF
  __int128 v38; // [rsp+40h] [rbp-C0h] BYREF
  _QWORD v39[2]; // [rsp+50h] [rbp-B0h] BYREF
  volatile signed __int32 *v40; // [rsp+60h] [rbp-A0h]
  volatile signed __int32 *v41; // [rsp+70h] [rbp-90h]
  _QWORD v42[2]; // [rsp+78h] [rbp-88h] BYREF
  volatile signed __int32 *v43; // [rsp+88h] [rbp-78h]
  volatile signed __int32 *v44; // [rsp+98h] [rbp-68h]
  unsigned __int64 v45; // [rsp+A0h] [rbp-60h] BYREF
  _OWORD *v46; // [rsp+A8h] [rbp-58h] BYREF
  int event_key_from_source_location_1; // [rsp+B0h] [rbp-50h]
  __int64 n16; // [rsp+B8h] [rbp-48h]
  const char *p_struct_SCEvtControl_RequestFullScreenTutorial; // [rsp+C0h] [rbp-40h]
  char v50; // [rsp+C8h] [rbp-38h]
  void (__stdcall *__StarEngineModule_)(ULONG_PTR); // [rsp+D0h] [rbp-30h]
  void (__fastcall *p_sub_14041E9D0)(_OWORD *, _OWORD *); // [rsp+D8h] [rbp-28h]
  __int64 v53; // [rsp+E0h] [rbp-20h] BYREF
  __int64 n511; // [rsp+E8h] [rbp-18h]
  void *v55; // [rsp+F0h] [rbp-10h]
  _BYTE v56[512]; // [rsp+F8h] [rbp-8h] BYREF
  __int64 v57[2]; // [rsp+2F8h] [rbp+1F8h] BYREF
  void *v58; // [rsp+308h] [rbp+208h]
  char v59; // [rsp+310h] [rbp+210h] BYREF
  __int64 v60[2]; // [rsp+510h] [rbp+410h] BYREF
  void *v61; // [rsp+520h] [rbp+420h]
  char v62; // [rsp+528h] [rbp+428h] BYREF
  _OWORD v63[3]; // [rsp+730h] [rbp+630h] BYREF

  v63[2] = v3;
  v38 = 0u;
  sub_1413608A0(a1, v42, a1 + 304, a3);
  if ( v42[0] )
    v7 = *(_OWORD *)v42[0];
  else
    v7 = v38;
  sub_1425DEEA0(a1, v39, a1 + 264, a3);
  if ( v39[0] )
  {
    v8 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int128 *, _QWORD))(*(_QWORD *)::gEnv + 288LL))(
                      ::gEnv,
                      &v38,
                      *(_QWORD *)(v39[0] + 176LL));
    v45 = v8;
    if ( v8 )
    {
      v9 = v8 & 0xFFFFFFFFFFFFLL;
      v10 = HIWORD(v8);
      v11 = (v10 & 0xF000) != 0 ? v9 & 0xFFFFFF000000LL : v9 - 6;
      if ( *(_WORD *)(v11 + 2) == (v10 & 0xFFF) )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || (v12 = sub_140539D80()) )
          v12 = 1;
        if ( *(_WORD *)(v11 + 4) == 2 && v12 || sub_140392020(&v45) )
        {
          v13 = v45 & 0xFFFFFFFFFFFFLL;
          v14 = *(__int64 (__fastcall **)(__int64, __int128 *, __int16 *))(*(_QWORD *)(v45 & 0xFFFFFFFFFFFFLL) + 832LL);
          v15 = word_1499C0BD0;
          if ( word_1499C0BD0 == -1 )
          {
            v15 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149B4FC88 + 16LL))(
                              qword_149B4FC88,
                              v37,
                              "SCLocalPlayerComponent");
            word_1499C0BD0 = v15;
          }
          v36 = v15;
          v16 = *(_QWORD *)v14(v13, &v38, &v36);
          *(_QWORD *)&v38 = v16;
          if ( v16
            && (v17 = sub_1403B4B50(v16 & 0xFFFFFFFFFFFFLL), n4_1 = *(_WORD *)(v17 + 4), n4_1 != 4)
            && *(_WORD *)(v17 + 2) == (HIWORD(v16) & 0xFFF)
            && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v38)) )
          {
            gEnv = ::gEnv;
            v63[0] = v7;
            v20 = v16 & 0xFFFFFFFFFFFFLL;
            v21 = sub_1403B4B50(v16 & 0xFFFFFFFFFFFFLL);
            n4 = *(_WORD *)(v21 + 4);
            if ( n4 == 4
              || *(_WORD *)(v21 + 2) != (HIWORD(v16) & 0xFFF)
              || (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v38) )
            {
              v20 = 0;
            }
            v46 = v63;
            event_key_from_source_location = ::event_key_from_source_location;
            if ( !::event_key_from_source_location )
              event_key_from_source_location = get_event_key_from_source_location(
                                                 &::event_key_from_source_location,
                                                 (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/Tutorial/Events.h",
                                                 9);
            event_key_from_source_location_1 = event_key_from_source_location;
            n16 = 16;
            p_struct_SCEvtControl_RequestFullScreenTutorial = "struct SCEvtControl_RequestFullScreenTutorial";
            v50 = byte_149E067B4;
            __StarEngineModule_ = _StarEngineModule__;
            p_sub_14041E9D0 = sub_14041E9D0;
            (*(void (__fastcall **)(__int64, __int64, _OWORD **))(*(_QWORD *)gEnv + 856LL))(gEnv, v20, &v46);
            v56[0] = 0;
            v55 = v56;
            v53 = 0;
            n511_1 = -1;
            n511 = 511;
            do
              ++n511_1;
            while ( *((_BYTE *)&p_p_p_p_p_p_p_p_p_p_p_Source + n511_1) );
            if ( n511_1 )
            {
              sub_1402A3B50(&v53, n511_1);
              memcpy(v55, &p_p_p_p_p_p_p_p_p_p_p_Source, n511_1);
            }
            v25 = *(_QWORD *)(a1 + 144);
            n2 = 1;
          }
          else
          {
            sub_14053D5C0(a1, a3, 0, (int)"Player is not the local player");
            v56[0] = 0;
            v55 = v56;
            v53 = 0;
            n511_2 = -1;
            n511 = 511;
            do
              ++n511_2;
            while ( *((_BYTE *)&p_p_p_p_p_p_p_p_p_p_p_Source + n511_2) );
            if ( n511_2 )
            {
              sub_1402A3B50(&v53, n511_2);
              memcpy(v55, &p_p_p_p_p_p_p_p_p_p_p_Source, n511_2);
            }
            v25 = *(_QWORD *)(a1 + 152);
            n2 = 2;
          }
          sub_14053A870(a2, n2, v25, 2, &v53);
          sub_140370C50((__int64)v39);
          sub_140370C50((__int64)v42);
          return a2;
        }
      }
    }
    sub_14053D5C0(a1, a3, 0, (int)"Player entity not found");
    v59 = 0;
    v58 = &v59;
    v57[0] = 0;
    v57[1] = 511;
    n511_3 = -1;
    do
      ++n511_3;
    while ( *((_BYTE *)&p_p_p_p_p_p_p_p_p_p_p_Source + n511_3) );
    if ( n511_3 )
    {
      sub_1402A3B50(v57, n511_3);
      memcpy(v58, &p_p_p_p_p_p_p_p_p_p_p_Source, n511_3);
    }
    v29 = v57;
  }
  else
  {
    sub_14053D5C0(a1, a3, 0, (int)"The Player variable is invalid");
    v62 = 0;
    v61 = &v62;
    v60[0] = 0;
    v60[1] = 511;
    n511_4 = -1;
    do
      ++n511_4;
    while ( *((_BYTE *)&p_p_p_p_p_p_p_p_p_p_p_Source + n511_4) );
    if ( n511_4 )
    {
      sub_1402A3B50(v60, n511_4);
      memcpy(v61, &p_p_p_p_p_p_p_p_p_p_p_Source, n511_4);
    }
    v29 = v60;
  }
  sub_14053A870(a2, 2, *(_QWORD *)(a1 + 152), 2, v29);
  if ( v41 )
  {
    if ( _InterlockedExchangeAdd(v41 + 2, 0xFFFFFFFF) == 1 )
    {
      v31 = v41;
      (**(void (__fastcall ***)(volatile signed __int32 *))v41)(v41);
      if ( _InterlockedExchangeAdd(v31 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 8LL))(v41);
    }
  }
  if ( v40 )
  {
    if ( _InterlockedExchangeAdd(v40 + 2, 0xFFFFFFFF) == 1 )
    {
      v32 = v40;
      (**(void (__fastcall ***)(volatile signed __int32 *))v40)(v40);
      if ( _InterlockedExchangeAdd(v32 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v40 + 8LL))(v40);
    }
  }
  if ( v44 )
  {
    if ( _InterlockedExchangeAdd(v44 + 2, 0xFFFFFFFF) == 1 )
    {
      v33 = v44;
      (**(void (__fastcall ***)(volatile signed __int32 *))v44)(v44);
      if ( _InterlockedExchangeAdd(v33 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v44 + 8LL))(v44);
    }
  }
  if ( v43 )
  {
    if ( _InterlockedExchangeAdd(v43 + 2, 0xFFFFFFFF) == 1 )
    {
      v34 = v43;
      (**(void (__fastcall ***)(volatile signed __int32 *))v43)(v43);
      if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v43 + 8LL))(v43);
    }
  }
  return a2;
}

// --- End Function: sub_1429EFDD0 (0x1429EFDD0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

