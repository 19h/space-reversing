// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1468CF2E0 (CEntitySystem::DumpDebugInfo)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 8
// ------------------------------------------------------------

// --- Function: LogTraceConditional (0x1402BED30) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list varargs; // [rsp+38h] [rbp+10h] BYREF

  va_start(varargs, format_string);
  if ( qword_14981D3D8 && CSystem )
  {
    if ( qword_14981D2D0 )
    {
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_14981D2D0 + 8LL))(
        qword_14981D2D0,
        3,
        format_string,
        (__int64 *)varargs);
    }
  }
}

// --- End Function: LogTraceConditional (0x1402BED30) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1403BF290 (0x1403BF290) ---
__int64 __fastcall sub_1403BF290(volatile signed __int32 *a1, unsigned __int32 a2, __int64 a3, char a4)
{
  __int64 result; // rax
  char v7; // r14
  signed __int32 v8; // ecx
  bool v9; // zf
  unsigned __int32 v10; // esi
  signed __int32 v11; // eax
  unsigned __int32 v12; // [rsp+30h] [rbp-69h] BYREF
  unsigned __int32 v13[3]; // [rsp+34h] [rbp-65h] BYREF
  int n0x1600; // [rsp+40h] [rbp-59h] BYREF
  __int64 v15; // [rsp+44h] [rbp-55h]
  int v16; // [rsp+4Ch] [rbp-4Dh]
  __int64 v17; // [rsp+50h] [rbp-49h]
  unsigned __int64 v18; // [rsp+58h] [rbp-41h]
  __int64 v19; // [rsp+60h] [rbp-39h]
  __int64 v20; // [rsp+68h] [rbp-31h]
  int n0x1600_1; // [rsp+90h] [rbp-9h] BYREF
  __int64 v22; // [rsp+94h] [rbp-5h]
  int v23; // [rsp+9Ch] [rbp+3h]
  __int64 v24; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v25; // [rsp+A8h] [rbp+Fh]
  __int64 v26; // [rsp+B0h] [rbp+17h]
  __int64 v27; // [rsp+B8h] [rbp+1Fh]

  if ( a4 && *(_BYTE *)(get_tls_data_offset_784() + 0x1C) && qword_14981D3D8 )
  {
    return sub_1403BF450(a1, a2);
  }
  v7 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v7 )
      {
        n0x1600 = 0x1600;
        v15 = 0;
        v16 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v17 = 1;
        psub_7FF6AAB938D0(
          &n0x1600,
          0,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          0);
        v12 = a2;
        off_149808B88(a1, &v12, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        v18 = __rdtsc();
        psub_7FF6AAB93930(&n0x1600);
      }
      else
      {
        v10 = a2 + 2;
        v11 = _InterlockedCompareExchange(a1, a2 + 2, a2);
        v9 = a2 == v11;
        a2 = v11;
        if ( v9 )
        {
          n0x1600_1 = 0x1600;
          v22 = 0;
          v23 = 0;
          v25 = 0;
          v7 = 1;
          v26 = 0;
          v27 = 0;
          v24 = 1;
          psub_7FF6AAB938D0(
            &n0x1600_1,
            0,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          v13[0] = v10;
          off_149808B88(a1, v13, 4, 0xFFFFFFFFLL);
          a2 = *a1;
          v25 = __rdtsc();
          psub_7FF6AAB93930(&n0x1600_1);
        }
      }
    }
    v8 = (a2 | 1) - 2;
    if ( !v7 )
    {
      v8 = a2 | 1;
    }
    result = (unsigned int)_InterlockedCompareExchange(a1, v8, a2);
    v9 = a2 == (_DWORD)result;
    a2 = result;
  }
  while ( !v9 );
  return result;
}

// --- End Function: sub_1403BF290 (0x1403BF290) ---

// --- Function: sub_1403BF450 (0x1403BF450) ---
__int64 __fastcall sub_1403BF450(volatile signed __int32 *a1, unsigned __int32 a2)
{
  __int64 v2; // r15
  __int64 tls_data_offset_784; // rax
  __int64 v6; // rsi
  unsigned int v7; // r14d
  __int64 result; // rax
  unsigned __int32 v9; // ett
  int v10; // edx
  bool v11; // zf
  signed __int32 v12; // eax
  unsigned __int32 v13; // ett
  int n0x1600; // [rsp+30h] [rbp-69h] BYREF
  __int64 v15; // [rsp+34h] [rbp-65h]
  int v16; // [rsp+3Ch] [rbp-5Dh]
  __int64 v17; // [rsp+40h] [rbp-59h]
  unsigned __int64 v18; // [rsp+48h] [rbp-51h]
  __int64 v19; // [rsp+50h] [rbp-49h]
  __int64 v20; // [rsp+58h] [rbp-41h]
  int n0x1600_1; // [rsp+80h] [rbp-19h] BYREF
  __int64 v22; // [rsp+84h] [rbp-15h]
  int v23; // [rsp+8Ch] [rbp-Dh]
  __int64 v24; // [rsp+90h] [rbp-9h]
  unsigned __int64 v25; // [rsp+98h] [rbp-1h]
  __int64 v26; // [rsp+A0h] [rbp+7h]
  __int64 v27; // [rsp+A8h] [rbp+Fh]
  char v28; // [rsp+100h] [rbp+67h] BYREF
  char v29; // [rsp+108h] [rbp+6Fh] BYREF

  v2 = qword_14981D318;
  tls_data_offset_784 = get_tls_data_offset_784();
  v6 = *(_QWORD *)tls_data_offset_784;
  v7 = *(_DWORD *)(*(_QWORD *)tls_data_offset_784 + 0x1CLL);
  (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v2 + 0xF8LL))(v2, &v28, &v29);
  do
  {
    while ( (a2 & 1) != 0 )
    {
      v10 = v7 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v6 + 0x24) = HIWORD(a2);
        v12 = _InterlockedCompareExchange(a1, v10 | (unsigned __int16)a2, a2);
        v11 = a2 == v12;
        a2 = v12;
        if ( v11 )
        {
          n0x1600 = 0x1600;
          v15 = 0;
          v16 = 0;
          v18 = 0;
          v19 = 0;
          v20 = 0;
          v17 = 1;
          psub_7FF6AAB938D0(
            &n0x1600,
            0,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0xE8LL))(v2, v7);
          a2 = *a1;
          v7 = *(_DWORD *)(v6 + 0x1C);
          v18 = __rdtsc();
          psub_7FF6AAB93930(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v6 + 0x24) = 0xFFFFFFFF;
        v13 = a2;
        a2 = _InterlockedCompareExchange(a1, a2 | v10, a2);
        if ( v13 == a2 )
        {
          n0x1600_1 = 0x1600;
          v22 = 0;
          v23 = 0;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v24 = 1;
          psub_7FF6AAB938D0(
            &n0x1600_1,
            0,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0xE8LL))(v2, v7);
          a2 = *a1;
          v7 = *(_DWORD *)(v6 + 0x1C);
          v25 = __rdtsc();
          psub_7FF6AAB93930(&n0x1600_1);
        }
      }
    }
    v9 = a2;
    result = (unsigned int)_InterlockedCompareExchange(a1, a2 | 1, a2);
    a2 = result;
  }
  while ( v9 != (_DWORD)result );
  return result;
}

// --- End Function: sub_1403BF450 (0x1403BF450) ---

// --- Function: sub_1403D6A80 (0x1403D6A80) ---
__int64 __fastcall sub_1403D6A80(volatile signed __int32 *a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  __int64 result; // rax
  int v7; // [rsp+50h] [rbp+8h] BYREF
  int v8; // [rsp+58h] [rbp+10h] BYREF
  __int64 v9; // [rsp+60h] [rbp+18h] BYREF
  __int64 v10; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v9,
        &v8);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(0xC0 * (((unsigned __int64)a2 >> 0x10) & (unsigned int)(v8 - 1)) + v9 + 0x24);
      if ( v5 != 0xFFFFFFFF )
      {
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
      }
    }
    result = (unsigned int)_InterlockedCompareExchange(a1, v4, a2);
    if ( a2 == (_DWORD)result )
    {
      break;
    }
    a2 = result;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    return off_149808B90(a1);
  }
  if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
      qword_14981D318,
      &v10,
      &v7);
    *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned __int64)(unsigned int)(v7 - 1)) + v10 + 0x1C) = (unsigned __int16)(HIWORD(a2) + v7);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D318 + 0xD8LL))(qword_14981D318);
  }
  return result;
}

// --- End Function: sub_1403D6A80 (0x1403D6A80) ---

// --- Function: sub_146839340 (0x146839340) ---
void __fastcall sub_146839340(__int64 a1, char a2)
{
  double _XMM0; // xmm0_8
  const char *p_true_1; // rcx
  const char *p_true; // rax
  unsigned __int64 i; // rbx
  _QWORD *v8; // rdx
  __int64 v9; // rdi
  _QWORD *j; // rax
  char *v11; // r8
  __m128 v12; // xmm0
  __int128 v14; // kr00_16
  __m128 v16; // xmm0
  __m128 v19; // xmm0
  int v20; // ebx
  int v21; // edi
  int v22; // esi
  int v23; // ebp
  _QWORD *v26; // rax
  __int64 v27; // [rsp+28h] [rbp-70h]
  __int64 v28; // [rsp+30h] [rbp-68h]
  __int64 v29; // [rsp+38h] [rbp-60h]
  __int64 v30; // [rsp+40h] [rbp-58h]
  const char *ppStringObjectData_; // [rsp+A0h] [rbp+8h] BYREF
  __int64 v32; // [rsp+B0h] [rbp+18h] BYREF

  sub_146842340(a1, &ppStringObjectData_);
  p_true_1 = "false";
  p_true = "false";
  if ( *(_BYTE *)(a1 + 0x310) )
  {
    p_true = "true";
  }
  if ( *(_BYTE *)(a1 + 0x19C) )
  {
    p_true_1 = "true";
  }
  LogTraceConditional(
    "-- Spawn Batch [%u][%s] -- \n"
    " State=[%s], Closed=[%s], ForceBlock=[%s], PendingSpawns=[%zu], PendingRemovals=[%zu], Children=[%zu], Dependencies=[%zu]",
    *(_DWORD *)(a1 + 0x544),
    *(const char **)(a1 + 0x30),
    ppStringObjectData_,
    p_true_1,
    p_true,
    (__int64)(*(_QWORD *)(a1 + 0x2C0) - *(_QWORD *)(a1 + 0x2B8)) >> 3,
    (__int64)(*(_QWORD *)(a1 + 0x2F0) - *(_QWORD *)(a1 + 0x2E8)) >> 3,
    (__int64)(*(_QWORD *)(a1 + 0x360) - *(_QWORD *)(a1 + 0x358)) >> 4,
    (__int64)(*(_QWORD *)(a1 + 0x3E8) - *(_QWORD *)(a1 + 0x3E0)) >> 4);
  if ( a2 )
  {
    LogTraceConditional("-- Entities Begin --");
    for ( i = 0; i < *(_QWORD *)(a1 + 0x108); ++i )
    {
      v8 = *(_QWORD **)(a1 + 0x2F0);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 0xF0) + 8 * ((*(_QWORD *)(a1 + 0xF8) - 1LL) & (i + *(_QWORD *)(a1 + 0x100))));
      for ( j = *(_QWORD **)(a1 + 0x2E8); j != v8; ++j )
      {
        if ( *j == *(_QWORD *)(v9 + 0x40) )
        {
          break;
        }
      }
      v11 = (char *)&stru_147F36DC8.HistoryTable + 4;
      if ( j != v8 )
      {
        v11 = (char *)&stru_147F36DC8.EstablisherFrame + 4;
      }
      LogTraceConditional("Batch Entity Index [%zu]  - IsPendingRemoval:[%s]", i, v11);
      sub_1403A0F70(v9);
    }
    LogTraceConditional("-- Entities End --");
  }
  sub_140593A60((_QWORD *)(a1 + 0x518), &v32, (_QWORD *)(a1 + 0x510));
  v12 = sub_140593C00(_XMM0);
  *((_QWORD *)&v14 + 1) = v12.m128_u64[1];
  *(double *)&v14 = *(double *)v12.m128_u64 * 1000.0;
  _XMM0 = v14;
  __asm { vcvtsd2ss xmm8, xmm0, xmm0 }
  sub_140593A60((_QWORD *)(a1 + 0x4D0), &v32, (_QWORD *)(a1 + 0x518));
  v16 = sub_140593C00(*(double *)&v14);
  *((_QWORD *)&v14 + 1) = v16.m128_u64[1];
  *(double *)&v14 = *(double *)v16.m128_u64 * 1000.0;
  _XMM1 = v14;
  __asm { vcvtsd2ss xmm7, xmm1, xmm1 }
  sub_140593A60((_QWORD *)(a1 + 0x4D8), &v32, (_QWORD *)(a1 + 0x4D0));
  v19 = sub_140593C00(*(double *)v16.m128_u64);
  v20 = *(_DWORD *)(a1 + 0x500);
  v21 = *(_DWORD *)(a1 + 0x4FC);
  v22 = *(_DWORD *)(a1 + 0x4F4);
  v23 = *(_DWORD *)(a1 + 0x4F0);
  *((_QWORD *)&v14 + 1) = v19.m128_u64[1];
  *(double *)&v14 = *(double *)v19.m128_u64 * 1000.0;
  _XMM1 = v14;
  __asm { vcvtsd2ss xmm6, xmm1, xmm1 }
  v26 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_14981D298 + 0x78LL))(
                    qword_14981D298,
                    &v32);
  LODWORD(v30) = v20;
  LODWORD(v29) = v21;
  LODWORD(v28) = v22;
  LODWORD(v27) = v23;
  LogTraceConditional(
    "Analytics - PlayerId=%llu, msTimeSpawning=%f, msTimeComplete=%f, msTimeFinalize=%f, numEntitiesSubmitted=%u, numEnti"
    "tiesRemoved=%u, numEntitiesNetBound=%u, numEntitiesSpawned=%u",
    *v26,
    *(float *)&_XMM8,
    *(float *)&_XMM7,
    *(float *)&_XMM6,
    v27,
    v28,
    v29,
    v30);
  LogTraceConditional("-- ~Spawn Batch [%u][%s] --", *(_DWORD *)(a1 + 0x544), *(const char **)(a1 + 0x30));
  DestroyStringObject(&ppStringObjectData_);
}

// --- End Function: sub_146839340 (0x146839340) ---

// --- Function: CEntitySystem::DumpDebugInfo (0x1468CF2E0) ---
__int64 __fastcall CEntitySystem::DumpDebugInfo(__int64 a1, char a2)
{
  __int64 v2; // rax
  int v5; // edi
  const char *p_true; // rbx
  char v7; // al
  const char *p_false_1; // rdx
  __int64 result; // rax
  volatile signed __int32 *v10; // rdi
  int v11; // ebx
  unsigned __int32 v12; // eax
  unsigned int v13; // ebp
  __int64 v14; // rax
  volatile signed __int32 *v15; // rbx
  __int64 v16; // r8
  __int64 v17; // rdx
  signed __int32 v18; // eax
  signed __int32 v19; // ett
  const char *p_No_active_Spawn_Batch_in_job_%u; // rcx
  unsigned int v21; // r12d
  unsigned __int64 v22; // r14
  __int64 v23; // rbp
  __int64 v24; // rbx
  int v25; // r15d
  unsigned __int32 v26; // eax
  int v27; // eax
  unsigned __int32 v28; // eax
  int v29; // eax

  v2 = *(_QWORD *)(a1 + 0xDB8);
  v5 = 0;
  if ( v2 )
  {
    v5 = *(_DWORD *)(v2 + 0x10);
  }
  p_true = "false";
  if ( !qword_14981D238
    || (v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D238 + 0x320LL))(qword_14981D238),
        p_false_1 = "false",
        v7) )
  {
    p_false_1 = "true";
  }
  LogTraceConditional("SeekPenalty=%s", p_false_1);
  LogTraceConditional("Entity Count=%d", v5);
  if ( *(_DWORD *)(a1 + 0xE8) )
  {
    p_true = "true";
  }
  LogTraceConditional("DeleteJobRunning=%s, Deleted=%d", p_true, *(unsigned int *)(a1 + 0xF0));
  if ( a2 )
  {
    return sub_1468D1D00(a1, 0);
  }
  v10 = (volatile signed __int32 *)(a1 + 0xB24);
  v11 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( *(_DWORD *)(a1 + 0xB28) == v11 )
  {
    ++*(_DWORD *)(a1 + 0xB2C);
  }
  else
  {
    v12 = _InterlockedCompareExchange(v10, 1, 0);
    if ( v12 )
    {
      sub_1403BF290((volatile signed __int32 *)(a1 + 0xB24), v12, (__int64)"CEntitySystem::DumpDebugInfo", 1);
    }
    *(_DWORD *)(a1 + 0xB28) = v11;
  }
  LogTraceConditional(
    "Spawn queues: %zu queues, %zu jobs (%u active). %zu blocked batches.",
    *(_QWORD *)(a1 + 0xB68),
    *(_QWORD *)(a1 + 0xC08),
    *(_DWORD *)(a1 + 0xC10),
    *(_QWORD *)(a1 + 0xB50));
  v13 = 0;
  if ( *(_QWORD *)(a1 + 0xC08) )
  {
    v14 = 0;
    do
    {
      v15 = 0;
      v16 = *(_QWORD *)(a1 + 0xC00) + 0x30 * v14;
      v17 = *(_QWORD *)(v16 + 0x20);
      if ( !v17 )
      {
        goto LABEL_23;
      }
      v18 = *(_DWORD *)(v17 + 8);
      if ( !v18 )
      {
        goto LABEL_23;
      }
      while ( 1 )
      {
        v19 = v18;
        v18 = _InterlockedCompareExchange((volatile signed __int32 *)(v17 + 8), v18 + 1, v18);
        if ( v19 == v18 )
        {
          break;
        }
        if ( !v18 )
        {
          goto LABEL_23;
        }
      }
      p_No_active_Spawn_Batch_in_job_%u = "A Spawn Batch is active in job %u";
      v15 = *(volatile signed __int32 **)(v16 + 0x20);
      if ( !*(_QWORD *)(v16 + 0x18) )
      {
LABEL_23:
        p_No_active_Spawn_Batch_in_job_%u = "No active Spawn Batch in job %u";
      }
      LogTraceConditional(p_No_active_Spawn_Batch_in_job_%u, v13);
      if ( v15 )
      {
        if ( _InterlockedExchangeAdd(v15 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
          if ( _InterlockedExchangeAdd(v15 + 3, 0xFFFFFFFF) == 1 )
          {
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8LL))(v15);
          }
        }
      }
      v14 = ++v13;
    }
    while ( (unsigned __int64)v13 < *(_QWORD *)(a1 + 0xC08) );
  }
  v21 = 0;
  v22 = 0;
  if ( *(_QWORD *)(a1 + 0xB68) )
  {
    v23 = 0;
    do
    {
      v24 = v23 + *(_QWORD *)(a1 + 0xB60);
      v25 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
      if ( *(_DWORD *)(v24 + 0x3C) == v25 )
      {
        ++*(_DWORD *)(v24 + 0x40);
      }
      else
      {
        v26 = _InterlockedCompareExchange((volatile signed __int32 *)(v24 + 0x38), 1, 0);
        if ( v26 )
        {
          sub_1403BF290(
            (volatile signed __int32 *)(v24 + 0x38),
            v26,
            (__int64)"CEntitySystem::GetPendingFinalizeCount",
            1);
        }
        *(_DWORD *)(v24 + 0x3C) = v25;
      }
      v21 += *(_DWORD *)(*(_QWORD *)(a1 + 0xB60) + v23 + 0x68);
      v27 = *(_DWORD *)(v24 + 0x40);
      if ( v27 )
      {
        *(_DWORD *)(v24 + 0x40) = v27 - 1;
      }
      else
      {
        *(_DWORD *)(v24 + 0x3C) = 0xFFFFFFFF;
        v28 = _InterlockedCompareExchange((volatile signed __int32 *)(v24 + 0x38), 0, 1);
        if ( v28 != 1 )
        {
          sub_1403D6A80((volatile signed __int32 *)(v24 + 0x38), v28);
        }
      }
      ++v22;
      v23 += 0x108;
    }
    while ( v22 < *(_QWORD *)(a1 + 0xB68) );
    v10 = (volatile signed __int32 *)(a1 + 0xB24);
  }
  LogTraceConditional("Spawn Batches Finalizing:[%zu]", v21);
  v29 = *(_DWORD *)(a1 + 0xB2C);
  if ( v29 )
  {
    result = (unsigned int)(v29 - 1);
    *(_DWORD *)(a1 + 0xB2C) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 0xB28) = 0xFFFFFFFF;
    result = (unsigned int)_InterlockedCompareExchange(v10, 0, 1);
    if ( (_DWORD)result != 1 )
    {
      return sub_1403D6A80(v10, result);
    }
  }
  return result;
}

// --- End Function: CEntitySystem::DumpDebugInfo (0x1468CF2E0) ---

// --- Function: sub_1468D1D00 (0x1468D1D00) ---
void __fastcall sub_1468D1D00(__int64 a1, char a2)
{
  __int64 v2; // r13
  __int64 v4; // rbx
  unsigned __int64 i; // r12
  __int64 v6; // rbp
  int v7; // ebx
  unsigned __int32 v8; // eax
  __int64 v9; // rdi
  __int64 j; // rsi
  __int64 *v11; // rcx
  __int64 v12; // rax
  volatile signed __int32 *v13; // rbx
  int v14; // eax
  unsigned __int32 v15; // eax
  int v16; // edi
  unsigned __int32 v17; // eax
  __int64 v18; // rsi
  __int64 k; // r14
  __int64 *v20; // rcx
  __int64 v21; // rax
  volatile signed __int32 *v22; // rdi
  int v23; // eax
  unsigned __int32 v24; // eax
  unsigned __int64 v25; // rbp
  __int64 v26; // r15
  __int64 v27; // r14
  int v28; // edi
  unsigned __int32 v29; // eax
  __int64 v30; // rdx
  volatile signed __int32 *v31; // rdi
  signed __int32 v32; // eax
  signed __int32 v33; // ett
  int v34; // eax
  __int64 v35; // rsi
  unsigned __int32 v36; // eax

  v2 = 0;
  v4 = a1;
  for ( i = 0; i < *(_QWORD *)(a1 + 0xB68); v2 += 0x108 )
  {
    LogTraceConditional("Spawn queue %zu:", i);
    v6 = v2 + *(_QWORD *)(v4 + 0xB60);
    v7 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
    if ( *(_DWORD *)(v6 + 4) == v7 )
    {
      ++*(_DWORD *)(v6 + 8);
    }
    else
    {
      v8 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 1, 0);
      if ( v8 )
      {
        sub_1403BF290((volatile signed __int32 *)v6, v8, (__int64)"CEntitySystem::DumpSpawnQueues", 1);
      }
      *(_DWORD *)(v6 + 4) = v7;
    }
    LogTraceConditional("Pending Spawn Batches:[%zu]", *(_QWORD *)(v6 + 0x30));
    v9 = *(_QWORD *)(v6 + 0x28);
    for ( j = v9 + *(_QWORD *)(v6 + 0x30); v9 != j; ++v9 )
    {
      v11 = *(__int64 **)(*(_QWORD *)(v6 + 0x18) + 8 * (v9 & (*(_QWORD *)(v6 + 0x20) - 1LL)));
      v12 = v11[1];
      if ( v12 )
      {
        _InterlockedIncrement((volatile signed __int32 *)(v12 + 8));
      }
      v13 = (volatile signed __int32 *)v11[1];
      sub_146839340(*v11, a2);
      if ( v13 )
      {
        if ( _InterlockedExchangeAdd(v13 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
          if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
          {
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8LL))(v13);
          }
        }
      }
    }
    v14 = *(_DWORD *)(v6 + 8);
    if ( v14 )
    {
      *(_DWORD *)(v6 + 8) = v14 - 1;
    }
    else
    {
      *(_DWORD *)(v6 + 4) = 0xFFFFFFFF;
      v15 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 0, 1);
      if ( v15 != 1 )
      {
        sub_1403D6A80((volatile signed __int32 *)v6, v15);
      }
    }
    v16 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
    if ( *(_DWORD *)(v6 + 0x3C) == v16 )
    {
      ++*(_DWORD *)(v6 + 0x40);
    }
    else
    {
      v17 = _InterlockedCompareExchange((volatile signed __int32 *)(v6 + 0x38), 1, 0);
      if ( v17 )
      {
        sub_1403BF290((volatile signed __int32 *)(v6 + 0x38), v17, (__int64)"CEntitySystem::DumpSpawnQueues", 1);
      }
      *(_DWORD *)(v6 + 0x3C) = v16;
    }
    LogTraceConditional("Finalizing Spawn Batches:[%zu]", *(_QWORD *)(v6 + 0x68));
    v18 = *(_QWORD *)(v6 + 0x60);
    for ( k = v18 + *(_QWORD *)(v6 + 0x68); v18 != k; ++v18 )
    {
      v20 = *(__int64 **)(*(_QWORD *)(v6 + 0x50) + 8 * (v18 & (*(_QWORD *)(v6 + 0x58) - 1LL)));
      v21 = v20[1];
      if ( v21 )
      {
        _InterlockedIncrement((volatile signed __int32 *)(v21 + 8));
      }
      v22 = (volatile signed __int32 *)v20[1];
      sub_146839340(*v20, a2);
      if ( v22 )
      {
        if ( _InterlockedExchangeAdd(v22 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v22)(v22);
          if ( _InterlockedExchangeAdd(v22 + 3, 0xFFFFFFFF) == 1 )
          {
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v22 + 8LL))(v22);
          }
        }
      }
    }
    v23 = *(_DWORD *)(v6 + 0x40);
    if ( v23 )
    {
      *(_DWORD *)(v6 + 0x40) = v23 - 1;
    }
    else
    {
      *(_DWORD *)(v6 + 0x3C) = 0xFFFFFFFF;
      v24 = _InterlockedCompareExchange((volatile signed __int32 *)(v6 + 0x38), 0, 1);
      if ( v24 != 1 )
      {
        sub_1403D6A80((volatile signed __int32 *)(v6 + 0x38), v24);
      }
    }
    v4 = a1;
    ++i;
  }
  LogTraceConditional("Active Spawn Jobs:[%u of %zu]", *(_DWORD *)(v4 + 0xC10), *(_QWORD *)(v4 + 0xC08));
  v25 = 0;
  if ( *(_QWORD *)(v4 + 0xC08) )
  {
    v26 = 0;
    do
    {
      v27 = v26 + *(_QWORD *)(v4 + 0xC00);
      v28 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
      if ( *(_DWORD *)(v27 + 0xC) == v28 )
      {
        ++*(_DWORD *)(v27 + 0x10);
      }
      else
      {
        v29 = _InterlockedCompareExchange((volatile signed __int32 *)(v27 + 8), 1, 0);
        if ( v29 )
        {
          sub_1403BF290((volatile signed __int32 *)(v27 + 8), v29, (__int64)"CEntitySystem::DumpSpawnQueues", 1);
        }
        *(_DWORD *)(v27 + 0xC) = v28;
      }
      v30 = *(_QWORD *)(v27 + 0x20);
      v31 = 0;
      if ( !v30 )
      {
        goto LABEL_48;
      }
      v32 = *(_DWORD *)(v30 + 8);
      if ( !v32 )
      {
        goto LABEL_48;
      }
      while ( 1 )
      {
        v33 = v32;
        v32 = _InterlockedCompareExchange((volatile signed __int32 *)(v30 + 8), v32 + 1, v32);
        if ( v33 == v32 )
        {
          break;
        }
        if ( !v32 )
        {
          goto LABEL_48;
        }
      }
      v35 = *(_QWORD *)(v27 + 0x18);
      v31 = *(volatile signed __int32 **)(v27 + 0x20);
      if ( v35 )
      {
        LogTraceConditional("Active Spawn Batch for job:[%zu]", v25);
        sub_146839340(v35, 0);
      }
      else
      {
LABEL_48:
        LogTraceConditional("No active Spawn Batch in job:[%zu]", v25);
      }
      if ( v31 )
      {
        if ( _InterlockedExchangeAdd(v31 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v31)(v31);
          if ( _InterlockedExchangeAdd(v31 + 3, 0xFFFFFFFF) == 1 )
          {
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v31 + 8LL))(v31);
          }
        }
      }
      v34 = *(_DWORD *)(v27 + 0x10);
      if ( v34 )
      {
        *(_DWORD *)(v27 + 0x10) = v34 - 1;
      }
      else
      {
        *(_DWORD *)(v27 + 0xC) = 0xFFFFFFFF;
        v36 = _InterlockedCompareExchange((volatile signed __int32 *)(v27 + 8), 0, 1);
        if ( v36 != 1 )
        {
          sub_1403D6A80((volatile signed __int32 *)(v27 + 8), v36);
        }
      }
      v4 = a1;
      ++v25;
      v26 += 0x30;
    }
    while ( v25 < *(_QWORD *)(a1 + 0xC08) );
  }
}

// --- End Function: sub_1468D1D00 (0x1468D1D00) ---

