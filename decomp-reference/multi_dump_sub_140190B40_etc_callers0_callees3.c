// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x140190B40 (sub_140190B40)
//   - 0x1403B1000 (sub_1403B1000)
//   - 0x140475DE0 (sub_140475DE0)
//   - 0x1425638B0 (sub_1425638B0)
//   - 0x14258B610 (sub_14258B610)
//   - 0x14259AAD0 (sub_14259AAD0)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 35
// ------------------------------------------------------------

// --- Function: sub_140190B40 (0x140190B40) ---
int sub_140190B40()
{
  _BYTE *v0; // rax
  void *v2; // [rsp+20h] [rbp-18h] BYREF
  void *v3; // [rsp+28h] [rbp-10h]

  CreateStringObjectFromString(&v2, "fallbackShipInsurance");
  sub_140362CA0(qword_149E376F8);
  qword_149E376F8[0] = (__int64)off_148603448;
  v3 = &unk_149E37700;
  v0 = (_BYTE *)sub_1402A2660((__int64)&v2);
  sub_140361D60((__int64)v3, v0);
  unk_149E37710 = 666.0;
  *(float *)&dword_149E37714 = 0.0;
  *(_DWORD *)algn_149E37718 = 0xA2C2A;
  sub_140370D10(&v2);
  return atexit(sub_148144760);
}

// --- End Function: sub_140190B40 (0x140190B40) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402B4590 (0x1402B4590) ---
void *(__fastcall **__fastcall sub_1402B4590(_QWORD *a1))(FDefaultModuleImpl *__hidden this, unsigned int)
{
  void *(__fastcall **result)(FDefaultModuleImpl *__hidden, unsigned int); // rax

  result = &off_1481A0DB8;
  *a1 = &off_1481A0DB8;
  return result;
}

// --- End Function: sub_1402B4590 (0x1402B4590) ---

// --- Function: sub_1402CA4C0 (0x1402CA4C0) ---
__int64 __fastcall sub_1402CA4C0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
      break;
    v4 = 0;
    if ( (int)result < 0 )
      v4 = a1;
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402CA4C0 (0x1402CA4C0) ---

// --- Function: sub_1402D2830 (0x1402D2830) ---
__int64 __fastcall sub_1402D2830(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
      break;
    ++a4;
    if ( (a1 & 1) != 0 )
      a3 |= 1 << (a2 - v4);
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D2830 (0x1402D2830) ---

// --- Function: sub_1402E1FE0 (0x1402E1FE0) ---
__int64 __fastcall sub_1402E1FE0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
      break;
    v5 = v4 + 0x20;
    if ( (unsigned __int8)(v4 - 0x41) > 0x19u )
      v5 = v4;
    v6 = sub_1402D2830(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402CA4C0(0x4C11DB7, 1, (v6 << 0x19) ^ (unsigned int)((unsigned __int64)(v6 << 0x18) >> 0x1F) & 0x4C11DB7);
    v8 = sub_1402D2830(v7 >> 1, 0x20, v7 << 0x1F, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402E1FE0 (0x1402E1FE0) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_140361D60 (0x140361D60) ---
__int64 __fastcall sub_140361D60(__int64 a1, _BYTE *a2)
{
  size_t Size; // rbx
  void *v5; // rax

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( Size )
  {
    v5 = (void *)allocWithProfilerInfo_w(Size + 1);
    *(_QWORD *)a1 = v5;
    memcpy(v5, a2, Size);
    *(_BYTE *)(Size + *(_QWORD *)a1) = 0;
  }
  return a1;
}

// --- End Function: sub_140361D60 (0x140361D60) ---

// --- Function: sub_140361E00 (0x140361E00) ---
_QWORD *__fastcall sub_140361E00(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

// --- End Function: sub_140361E00 (0x140361E00) ---

// --- Function: sub_140362CA0 (0x140362CA0) ---
_QWORD *__fastcall sub_140362CA0(_QWORD *a1)
{
  *a1 = &off_1481A0DB8;
  return a1;
}

// --- End Function: sub_140362CA0 (0x140362CA0) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140372C00 (0x140372C00) ---
__int64 __fastcall sub_140372C00(__int64 a1)
{
  const void *v2; // rcx
  __int64 result; // rax

  v2 = *(const void **)a1;
  if ( v2 )
  {
    if ( !*(_BYTE *)(a1 + 8) )
      result = sub_1402A3D30(v2);
    *(_QWORD *)a1 = 0;
  }
  return result;
}

// --- End Function: sub_140372C00 (0x140372C00) ---

// --- Function: sub_1403B1000 (0x1403B1000) ---
__int64 __fastcall sub_1403B1000(__int64 a1, __int64 a2)
{
  *(_DWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 0x10) = 0;
  return a2;
}

// --- End Function: sub_1403B1000 (0x1403B1000) ---

// --- Function: sub_140475DE0 (0x140475DE0) ---
_QWORD *__fastcall sub_140475DE0(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  _QWORD *v5; // r14
  _QWORD *i; // rbx

  if ( (a2 & 2) != 0 )
  {
    v4 = a1[0xFFFFFFFF];
    v5 = a1 + 0xFFFFFFFF;
    for ( i = &a1[5 * v4]; v4; --v4 )
    {
      i += 0xFFFFFFFB;
      sub_140372C00((__int64)(i + 1));
      *i = &off_1481A0DB8;
    }
    if ( (a2 & 1) != 0 )
      sub_1402A3D30(v5);
    return v5;
  }
  else
  {
    sub_140372C00((__int64)(a1 + 1));
    *a1 = &off_1481A0DB8;
    if ( (a2 & 1) != 0 )
      sub_1402A3D30(a1);
    return a1;
  }
}

// --- End Function: sub_140475DE0 (0x140475DE0) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1425638B0 (0x1425638B0) ---
__int64 __fastcall sub_1425638B0(__int64 a1)
{
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)a1 = off_148603588;
  *(_BYTE *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x10) = off_148603448;
  *(_QWORD *)(a1 + 0x38) = off_148603510;
  sub_14035B3E0((_QWORD *)(a1 + 0x40));
  sub_14035B3E0((_QWORD *)(a1 + 0x48));
  sub_14035B3E0((_QWORD *)(a1 + 0x58));
  sub_140361E00((_QWORD *)(a1 + 0x60));
  return a1;
}

// --- End Function: sub_1425638B0 (0x1425638B0) ---

// --- Function: sub_14258B610 (0x14258B610) ---
const char *sub_14258B610()
{
  return "ShipInsuranceParams";
}

// --- End Function: sub_14258B610 (0x14258B610) ---

// --- Function: sub_14259AAD0 (0x14259AAD0) ---
__int64 __fastcall sub_14259AAD0(__int64 a1, __int64 a2)
{
  int v2; // edi
  int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  char *ShipInsuranceParams; // rax

  v2 = dword_149DD452C;
  if ( !dword_149DD452C )
  {
    v4 = sub_1402D2830(0x46u, 8, 0, 2);
    v5 = sub_1402CA4C0(0x4C11DB7, 1, (v4 << 0x19) ^ (unsigned int)((unsigned __int64)(v4 << 0x18) >> 0x1F) & 0x4C11DB7);
    v6 = sub_1402D2830(v5 >> 1, 0x20, v5 << 0x1F, 2);
    v2 = sub_1402E1FE0((unsigned __int8 *)"hipInsuranceParams", v6 ^ 0xFFFFFFu);
    ShipInsuranceParams = (char *)allocWithProfilerInfo(0x14u, 0);
    strcpy(ShipInsuranceParams, "ShipInsuranceParams");
    dword_149DD452C = v2;
    if ( ShipInsuranceParams )
    {
      sub_147605980(ShipInsuranceParams);
      v2 = dword_149DD452C;
    }
  }
  *(_DWORD *)a2 = v2;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 0x10) = 0;
  return a2;
}

// --- End Function: sub_14259AAD0 (0x14259AAD0) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: _onexit (0x1480335BC) ---
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)(); // rdx

  if ( Table._first == (_PVFV *)0xFFFFFFFFFFFFFFFFLL )
    v2 = crt_atexit((_PVFV)Func);
  else
    v2 = register_onexit_function(&Table, Func);
  v3 = 0;
  if ( !v2 )
    return Func;
  return v3;
}

// --- End Function: _onexit (0x1480335BC) ---

// --- Function: atexit (0x1480335F8) ---
int __cdecl atexit(void (__cdecl *Func)())
{
  return (onexit((_onexit_t)Func) != 0) - 1;
}

// --- End Function: atexit (0x1480335F8) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: _register_onexit_function (0x148082329) ---
// attributes: thunk
int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function)
{
  return _register_onexit_function(Table, Function);
}

// --- End Function: _register_onexit_function (0x148082329) ---

// --- Function: _crt_atexit (0x14808232F) ---
// attributes: thunk
int __cdecl crt_atexit(_PVFV Function)
{
  return _crt_atexit(Function);
}

// --- End Function: _crt_atexit (0x14808232F) ---

// --- Function: sub_148144760 (0x148144760) ---
void __fastcall sub_148144760()
{
  sub_140372C00((__int64)&unk_149E37700);
  sub_1402B4590(qword_149E376F8);
}

// --- End Function: sub_148144760 (0x148144760) ---

