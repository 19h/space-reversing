// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x14053AEE0 (sub_14053AEE0)
//   - 0x14053B050 (sub_14053B050)
//   - 0x14053B1B0 (sub_14053B1B0)
//   - 0x14053B580 (sub_14053B580)
//   - 0x14053B590 (sub_14053B590)
//   - 0x14053B5A0 (sub_14053B5A0)
//   - 0x14053BF90 (sub_14053BF90)
//   - 0x14053C290 (sub_14053C290)
//   - 0x14053D1C0 (sub_14053D1C0)
//   - 0x14053D8F0 (sub_14053D8F0)
//   - 0x14053DA80 (sub_14053DA80)
//   - 0x142708D10 (sub_142708D10)
//   - 0x142988630 (sub_142988630)
//   - 0x14299CEA0 (sub_14299CEA0)
//   - 0x1429AA610 (sub_1429AA610)
// Caller Depth: 1
// Callee/Ref Depth: 6
// Total Functions Found: 542
// ------------------------------------------------------------

// --- Function: identity_int64 (0x1402A24F0) ---
// This function is a simple identity function that returns its single __int64
// argument unchanged. It effectively acts as a pass-through.
__int64 __fastcall identity_int64(__int64 a1)
{
  return a1;
}

// --- End Function: identity_int64 (0x1402A24F0) ---

// --- Function: sub_1402A2880 (0x1402A2880) ---
__int64 __fastcall sub_1402A2880(__int64 a1, size_t *a2)
{
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = a1 + 24;
  *(_QWORD *)(a1 + 8) = 511;
  sub_1402A3BE0(a1, (const void *)a2[2], *a2);
  return a1;
}

// --- End Function: sub_1402A2880 (0x1402A2880) ---

// --- Function: sub_1402A28C0 (0x1402A28C0) ---
__int64 __fastcall sub_1402A28C0(__int64 a1, _BYTE *a2)
{
  size_t n511; // rbx

  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0x1FF;
  if ( !a2 )
    return a1;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n511;
  while ( a2[n511] );
  if ( n511 )
  {
    sub_1402A3B50((__int64 *)a1, n511);
    memcpy(*(void **)(a1 + 0x10), a2, n511);
  }
  return a1;
}

// --- End Function: sub_1402A28C0 (0x1402A28C0) ---

// --- Function: sub_1402A2950 (0x1402A2950) ---
__int64 __fastcall sub_1402A2950(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  result = a1;
  *(_QWORD *)(a1 + 8) = 0x1FF;
  return result;
}

// --- End Function: sub_1402A2950 (0x1402A2950) ---

// --- Function: sub_1402A2AD0 (0x1402A2AD0) ---
__int64 __fastcall sub_1402A2AD0(_QWORD *a1)
{
  void (__fastcall *n2)(__int64, _QWORD *); // rax
  __int64 result; // rax

  n2 = (void (__fastcall *)(__int64, _QWORD *))a1[1];
  if ( (unsigned __int64)n2 < 2 )
  {
    result = 0;
    *a1 = 0;
  }
  else
  {
    n2(2, a1);
    result = 0;
    a1[1] = 0;
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_1402A2AD0 (0x1402A2AD0) ---

// --- Function: sub_1402A2B40 (0x1402A2B40) ---
void __fastcall sub_1402A2B40(__int64 a1)
{
  unsigned __int64 v1; // rax
  const void *v2; // rcx

  if ( *(_QWORD *)(a1 + 0x10) != a1 + 0x18 )
  {
    v1 = 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
    v2 = *(const void **)(a1 + 0x10);
    qword_149B3AB68 += v1;
    sub_147605980(v2);
  }
}

// --- End Function: sub_1402A2B40 (0x1402A2B40) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3190 (0x1402A3190) ---
__int64 sub_1402A3190(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n511;
  while ( Buffer[n511] );
  sub_1402A3BE0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A3190 (0x1402A3190) ---

// --- Function: sub_1402A3B50 (0x1402A3B50) ---
_BYTE *__fastcall sub_1402A3B50(__int64 *a1, __int64 n511_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n511; // rcx

  result = a1 + 3;
  if ( n511_1 )
  {
    allocSize = n511_1 + 1;
    if ( (unsigned __int64)(n511_1 + 1) <= 0x200 )
    {
      n511 = 511;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3AB68 += allocSize;
      n511 = n511_1;
    }
    a1[1] = n511;
    *a1 = n511_1;
    a1[2] = (__int64)result;
    result[n511_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 511;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A3B50 (0x1402A3B50) ---

// --- Function: sub_1402A3BE0 (0x1402A3BE0) ---
__int64 __fastcall sub_1402A3BE0(__int64 a1, const void *a2, size_t n511)
{
  size_t n511_1; // r8
  const void *v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  n511_1 = *(_QWORD *)(a1 + 8);
  if ( n511 > n511_1 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n511_1;
      sub_147605980(v7);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x1FF;
    sub_1402A3B50((__int64 *)a1, n511);
  }
  memmove(*(void **)(a1 + 0x10), a2, n511);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n511;
  *(_BYTE *)(n511 + result) = 0;
  return result;
}

// --- End Function: sub_1402A3BE0 (0x1402A3BE0) ---

// --- Function: sub_1402A3C90 (0x1402A3C90) ---
void __fastcall sub_1402A3C90(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _BYTE *v3; // rsi

  v2 = (_QWORD *)a1[2];
  v3 = a1 + 3;
  if ( v2 != a1 + 3 )
  {
    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - a1[1];
    sub_147605980(v2);
  }
  a1[2] = v3;
  *v3 = 0;
  *a1 = 0;
  a1[1] = 0x1FF;
}

// --- End Function: sub_1402A3C90 (0x1402A3C90) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A3D90) ---
unsigned __int8 *__fastcall AK::WriteBytesMem::Bytes(AK::WriteBytesMem *this)
{
  return (unsigned __int8 *)*((_QWORD *)this + 2);
}

// --- End Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A3D90) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 39 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 39);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 - 1) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: ??$_Emplace_reallocate@PEBVAudioBuffer@vraudio@@@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@QEAAPEAPEBVAudioBuffer@vraudio@@QEAPEBV23@$$QEAPEBV23@@Z (0x1402A6760) ---

// --- Function: sub_1402A6B30 (0x1402A6B30) ---
char *__fastcall sub_1402A6B30(__int64 a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  std::array<int,2> *v12; // rsi
  std::array<int,2> *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  char *v16; // rbp
  size_t Size; // r8
  _QWORD *v18; // rcx
  char *result; // rax

  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 3;
  _Count = 0x1FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<std::array<int,2>>::allocate((std::allocator<std::array<int,2> > *)a1, _Count);
  *((_QWORD *)v12 + v4) = *a3;
  v13 = v12;
  v14 = *(_BYTE **)(a1 + 8);
  v15 = *(_BYTE **)a1;
  v16 = (char *)v12 + 8 * v4;
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = (std::array<int,2> *)(v16 + 8);
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  v18 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v18) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v18 - v18[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v18 = (_QWORD *)v18[0xFFFFFFFF];
    }
    sub_1402A3D30(v18);
  }
  *(_QWORD *)a1 = v12;
  result = v16;
  *(_QWORD *)(a1 + 8) = (char *)v12 + 8 * v10;
  *(_QWORD *)(a1 + 0x10) = (char *)v12 + 8 * _Count;
  return result;
}

// --- End Function: sub_1402A6B30 (0x1402A6B30) ---

// --- Function: sub_1402A7670 (0x1402A7670) ---
char *__fastcall sub_1402A7670(__int64 *a1, _BYTE *a2, __int64 a3)
{
  __int64 v6; // r12
  __int64 v7; // rdx
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  _QWORD *v13; // rbx
  void *v14; // rcx
  double *v15; // rbp
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  size_t Size; // r8
  _BYTE *v19; // r8
  char *result; // rax

  v6 = (__int64)&a2[-*a1] / 0x18;
  v7 = (a1[1] - *a1) / 0x18;
  if ( v7 == 0xAAAAAAAAAAAAAAALL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x18;
  if ( v9 > 0xAAAAAAAAAAAAAAALL - (v9 >> 1) )
    goto LABEL_24;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0xAAAAAAAAAAAAAAALL )
    goto LABEL_24;
  v11 = 0x18 * v10;
  if ( 0x18 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = (_QWORD *)allocWithProfilerInfo_w(0x18 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_24:
    sub_1402E1170();
  v12 = allocWithProfilerInfo_w(v11 + 0x27);
  if ( !v12 )
    goto LABEL_22;
  v13 = (_QWORD *)((v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v13[0xFFFFFFFF] = v12;
LABEL_13:
  v14 = v13;
  *(_OWORD *)&v13[3 * v6] = *(_OWORD *)a3;
  v15 = (double *)&v13[3 * v6];
  v15[2] = *(double *)(a3 + 0x10);
  v16 = (_BYTE *)a1[1];
  v17 = (_BYTE *)*a1;
  if ( a2 == v16 )
  {
    Size = v16 - v17;
  }
  else
  {
    memmove(v13, v17, a2 - v17);
    v14 = v15 + 3;
    Size = a1[1] - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v14, v17, Size);
  v19 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(0x18 * ((a1[2] - (__int64)v19) / 0x18)) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v19);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v19[-*((_QWORD *)v19 + 0xFFFFFFFF) - 8] <= 0x1F )
    {
      v19 = (_BYTE *)*((_QWORD *)v19 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v13;
  a1[1] = (__int64)&v13[3 * v8];
  result = (char *)&v13[3 * v6];
  a1[2] = (__int64)&v13[v11 / 8];
  return result;
}

// --- End Function: sub_1402A7670 (0x1402A7670) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: sub_1402AE3D0 (0x1402AE3D0) ---
__int64 *__fastcall sub_1402AE3D0(__int64 *a1, const char *a2, __int64 a3, char a4)
{
  *a1 = a3;
  sub_1402CD240(a3, a2, a4);
  return a1;
}

// --- End Function: sub_1402AE3D0 (0x1402AE3D0) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: sub_1402B1820 (0x1402B1820) ---
const ULONG_PTR *__fastcall sub_1402B1820(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v4; // eax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 0x14);
  if ( v2 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v1 + 0x10) = 0xFFFFFFFF;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( v4 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &byte_14819E9C2;
      *(_QWORD *)(v1 + 8) = &byte_14819E9C2;
    }
    else
    {
      return sub_1403DB1F0(v1, v4);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402B1820 (0x1402B1820) ---

// --- Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B2210) ---
void __fastcall std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>(
        std::shared_ptr<std::vector<char> > *this)
{
  volatile signed __int32 *v1; // rbx

  v1 = (volatile signed __int32 *)*((_QWORD *)this + 1);
  if ( v1 && _InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
    if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
  }
}

// --- End Function: ??1?$shared_ptr@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ (0x1402B2210) ---

// --- Function: ?_Tidy@?$vector@V?$Vector@$02N@gte@@V?$allocator@V?$Vector@$02N@gte@@@std@@@std@@AEAAXXZ (0x1402B2380) ---
void __fastcall std::vector<gte::Vector<3,double>>::_Tidy(std::vector<gte::Vector<3,double>> *this)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)this;
  if ( v2 )
  {
    if ( (unsigned __int64)(24 * ((*((_QWORD *)this + 2) - (_QWORD)v2) / 24LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)*(v2 - 1);
    }
    sub_1402A3D30(v2);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
  }
}

// --- End Function: ?_Tidy@?$vector@V?$Vector@$02N@gte@@V?$allocator@V?$Vector@$02N@gte@@@std@@@std@@AEAAXXZ (0x1402B2380) ---

// --- Function: sub_1402B2610 (0x1402B2610) ---
__int64 __fastcall sub_1402B2610(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rdi
  _QWORD *v4; // rcx
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; ++v1 )
      sub_140370D10(v1);
    v4 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1402B2610 (0x1402B2610) ---

// --- Function: sub_1402BC380 (0x1402BC380) ---
__int64 *__fastcall sub_1402BC380(__int64 *a1, char *a2)
{
  __int64 n0x7B; // r8
  __int64 n0x5A; // r8
  __int64 v6; // r8
  __int64 n0x5A_1; // rcx
  __int64 v8; // r8
  __int64 v9; // rcx
  __int64 n0x5A_2; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r8
  __int64 n0x5A_3; // rcx
  __int64 v15; // rdx
  __int64 n0x5A_4; // rcx
  __int64 v17; // rdx
  __int64 v18; // rax
  __int64 n0x5A_5; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  __int64 n0x5A_6; // rcx
  __int64 v23; // rdx
  __int64 v24; // rax
  __int64 n0x5A_7; // rcx
  __int64 v26; // rdx
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 n0x7A; // rcx
  __int64 v30; // rax
  __int64 n0x5A_8; // rcx
  __int64 v32; // rdx
  __int64 v33; // rax
  __int64 n0x5A_9; // rcx
  __int64 v35; // rdx
  __int64 v36; // rax
  __int64 n0x5A_10; // rcx
  __int64 v38; // rdx
  __int64 v39; // rax
  __int64 v40; // rdx
  __int64 n0x7A_1; // rcx
  __int64 v42; // rax
  __int64 n0x5A_11; // rcx
  __int64 v44; // rdx
  __int64 v45; // rax
  __int64 n0x5A_12; // rcx
  __int64 v47; // rdx
  __int64 v48; // rax
  __int64 n0x5A_13; // rcx
  __int64 v50; // rdx
  __int64 v51; // rax
  __int64 v52; // rdx
  __int64 n0x7A_2; // rcx
  __int64 v54; // rcx
  __int64 n0x5A_14; // r8
  __int64 v56; // rcx
  __int64 v57; // rax
  __int64 n0x5A_15; // r8
  __int64 v59; // rcx
  __int64 v60; // r8
  __int64 v61; // r8
  __int64 n0x5A_16; // rcx
  __int64 v63; // rcx
  __int64 v64; // rcx
  __int64 n0x7A_3; // r8
  __int64 v66; // r8
  __int64 v67; // r8
  __int64 n0x5A_17; // rcx
  __int64 v69; // rcx
  __int64 v70; // rcx
  __int64 n0x5A_18; // r8
  __int64 v72; // r8
  __int64 v73; // r8
  __int64 n0x5A_19; // rcx
  __int64 v75; // rcx
  __int64 v76; // rcx
  __int64 n0x5A_20; // r8
  __int64 v78; // r8
  __int64 v79; // r8
  __int64 n0x5A_21; // rcx
  __int64 v81; // rcx
  __int64 v82; // rcx
  __int64 n0x5A_22; // r8
  __int64 v84; // r8
  __int64 v85; // r8
  __int64 n0x5A_23; // rcx
  __int64 v87; // rcx
  __int64 v88; // rcx
  __int64 n0x5A_24; // r8
  __int64 v90; // rax
  __int64 n0x5A_25; // r8
  __int64 v92; // rcx
  __int64 v93; // rax
  __int64 n0x5A_26; // r8
  __int64 v95; // rcx
  __int64 v96; // rax
  __int64 n0x61; // r8
  __int64 v98; // rcx
  __int64 v99; // rax
  __int64 v100; // rcx
  __int64 *result; // rax
  __int64 v102; // rdx
  __int64 n0x7A_4; // rcx
  __int64 v104; // rdx
  __int64 v105; // rax
  __int64 n0x7A_5; // rcx
  __int64 v107; // rdx
  __int64 v108; // rax
  __int64 n0x7A_6; // rcx
  __int64 v110; // rdx
  __int64 v111; // rax
  __int64 n0x7A_7; // rcx
  __int64 v113; // rdx
  __int64 v114; // rax
  __int64 n0x7A_8; // rcx
  __int64 v116; // rdx
  __int64 v117; // rax
  __int64 n0x7A_9; // rcx
  __int64 v119; // rdx
  __int64 v120; // rax
  __int64 n0x7A_10; // rcx
  __int64 v122; // rdx
  __int64 v123; // rax
  __int64 v124; // rdx
  __int64 n0x7A_11; // rcx
  __int64 v126; // rax
  __int64 n0x7A_12; // rcx
  __int64 v128; // rdx
  __int64 v129; // rax
  __int64 n0x7A_13; // rcx
  __int64 v131; // rdx
  __int64 v132; // rax
  __int64 n0x7A_14; // rcx
  __int64 v134; // rdx
  __int64 v135; // rax
  __int64 v136; // rdx
  __int64 n0x7A_15; // rcx
  __int64 v138; // rax
  __int64 n0x7A_16; // rcx
  __int64 v140; // rdx
  __int64 v141; // rax
  __int64 n0x7A_17; // rcx
  __int64 v143; // rdx
  __int64 v144; // rax
  __int64 n0x7A_18; // rcx
  __int64 v146; // rdx
  __int64 v147; // rax
  __int64 n0x7A_19; // rcx
  __int64 v149; // r8
  __int64 n0x7A_20; // rcx
  __int64 v151; // r8
  __int64 v152; // rax
  __int64 n0x7A_21; // rcx
  __int64 v154; // r8
  __int64 v155; // rax
  __int64 n0x7A_22; // rcx
  __int64 v157; // r8
  __int64 v158; // rax
  __int64 v159; // r8
  __int64 n0x7A_23; // rcx
  __int64 v161; // rax
  __int64 n0x7A_24; // rcx
  __int64 v163; // r8
  __int64 v164; // rax
  __int64 n0x7A_25; // rcx
  __int64 v166; // r8
  __int64 v167; // rax
  __int64 n0x7A_26; // rcx
  __int64 v169; // r8
  __int64 v170; // rax
  __int64 n0x7A_27; // rcx
  __int64 v172; // r8
  __int64 v173; // rax
  __int64 n0x7A_28; // rcx
  __int64 v175; // r8
  __int64 v176; // rax
  __int64 n0x7A_29; // rcx
  __int64 v178; // r8
  __int64 v179; // rax
  __int64 n0x7A_30; // rcx
  __int64 v181; // r8
  __int64 v182; // rax
  __int64 n0x7A_31; // rcx
  __int64 v184; // r8
  __int64 v185; // rax
  __int64 n0x7A_32; // rcx
  __int64 v187; // r8
  __int64 v188; // rax
  __int64 n0x7A_33; // rcx
  __int64 v190; // r8
  __int64 v191; // rax
  __int64 n0x7A_34; // rcx
  __int64 v193; // r8

  n0x7B = *a2;
  if ( (_BYTE)n0x7B == 0x7B )
  {
    n0x5A = a2[1];
    if ( (char)n0x5A <= 0x7A )
    {
      if ( (char)n0x5A < 0x61 )
      {
        if ( (char)n0x5A > 0x5A )
          goto LABEL_263;
        if ( (char)n0x5A < 0x41 )
        {
          if ( (unsigned __int8)(n0x5A - 0x30) > 9u )
            goto LABEL_263;
          v6 = n0x5A - 0x30;
        }
        else
        {
          v6 = n0x5A - 0x37;
        }
      }
      else
      {
        v6 = n0x5A - 0x57;
      }
      n0x5A_1 = a2[2];
      v8 = v6 << 0x1C;
      if ( (char)n0x5A_1 <= 0x7A )
      {
        if ( (char)n0x5A_1 < 0x61 )
        {
          if ( (char)n0x5A_1 > 0x5A )
            goto LABEL_263;
          if ( (char)n0x5A_1 < 0x41 )
          {
            if ( (unsigned __int8)(n0x5A_1 - 0x30) > 9u )
              goto LABEL_263;
            v9 = n0x5A_1 - 0x30;
          }
          else
          {
            v9 = n0x5A_1 - 0x37;
          }
        }
        else
        {
          v9 = n0x5A_1 - 0x57;
        }
        n0x5A_2 = a2[3];
        v11 = v8 | (v9 << 0x18);
        if ( (char)n0x5A_2 <= 0x7A )
        {
          if ( (char)n0x5A_2 < 0x61 )
          {
            if ( (char)n0x5A_2 > 0x5A )
              goto LABEL_263;
            if ( (char)n0x5A_2 < 0x41 )
            {
              if ( (unsigned __int8)(n0x5A_2 - 0x30) > 9u )
                goto LABEL_263;
              v12 = n0x5A_2 - 0x30;
            }
            else
            {
              v12 = n0x5A_2 - 0x37;
            }
          }
          else
          {
            v12 = n0x5A_2 - 0x57;
          }
          v13 = v11 | (v12 << 0x14);
          n0x5A_3 = a2[4];
          if ( (char)n0x5A_3 <= 0x7A )
          {
            if ( (char)n0x5A_3 < 0x61 )
            {
              if ( (char)n0x5A_3 > 0x5A )
                goto LABEL_263;
              if ( (char)n0x5A_3 < 0x41 )
              {
                if ( (unsigned __int8)(n0x5A_3 - 0x30) > 9u )
                  goto LABEL_263;
                v15 = n0x5A_3 - 0x30;
              }
              else
              {
                v15 = n0x5A_3 - 0x37;
              }
            }
            else
            {
              v15 = n0x5A_3 - 0x57;
            }
            n0x5A_4 = a2[5];
            v17 = v13 | (v15 << 0x10);
            if ( (char)n0x5A_4 <= 0x7A )
            {
              if ( (char)n0x5A_4 < 0x61 )
              {
                if ( (char)n0x5A_4 > 0x5A )
                  goto LABEL_263;
                if ( (char)n0x5A_4 < 0x41 )
                {
                  if ( (unsigned __int8)(n0x5A_4 - 0x30) > 9u )
                    goto LABEL_263;
                  v18 = n0x5A_4 - 0x30;
                }
                else
                {
                  v18 = n0x5A_4 - 0x37;
                }
              }
              else
              {
                v18 = n0x5A_4 - 0x57;
              }
              n0x5A_5 = a2[6];
              v20 = (v18 << 0xC) | v17;
              if ( (char)n0x5A_5 <= 0x7A )
              {
                if ( (char)n0x5A_5 < 0x61 )
                {
                  if ( (char)n0x5A_5 > 0x5A )
                    goto LABEL_263;
                  if ( (char)n0x5A_5 < 0x41 )
                  {
                    if ( (unsigned __int8)(n0x5A_5 - 0x30) > 9u )
                      goto LABEL_263;
                    v21 = n0x5A_5 - 0x30;
                  }
                  else
                  {
                    v21 = n0x5A_5 - 0x37;
                  }
                }
                else
                {
                  v21 = n0x5A_5 - 0x57;
                }
                n0x5A_6 = a2[7];
                v23 = (v21 << 8) | v20;
                if ( (char)n0x5A_6 <= 0x7A )
                {
                  if ( (char)n0x5A_6 < 0x61 )
                  {
                    if ( (char)n0x5A_6 > 0x5A )
                      goto LABEL_263;
                    if ( (char)n0x5A_6 < 0x41 )
                    {
                      if ( (unsigned __int8)(n0x5A_6 - 0x30) > 9u )
                        goto LABEL_263;
                      v24 = n0x5A_6 - 0x30;
                    }
                    else
                    {
                      v24 = n0x5A_6 - 0x37;
                    }
                  }
                  else
                  {
                    v24 = n0x5A_6 - 0x57;
                  }
                  n0x5A_7 = a2[8];
                  v26 = (0x10 * v24) | v23;
                  if ( (char)n0x5A_7 <= 0x7A )
                  {
                    if ( (char)n0x5A_7 < 0x61 )
                    {
                      if ( (char)n0x5A_7 > 0x5A )
                        goto LABEL_263;
                      if ( (char)n0x5A_7 < 0x41 )
                      {
                        if ( (unsigned __int8)(n0x5A_7 - 0x30) > 9u )
                          goto LABEL_263;
                        v27 = n0x5A_7 - 0x30;
                      }
                      else
                      {
                        v27 = n0x5A_7 - 0x37;
                      }
                    }
                    else
                    {
                      v27 = n0x5A_7 - 0x57;
                    }
                    v28 = v27 | v26;
                    if ( a2[9] != 0x2D )
                      goto LABEL_263;
                    n0x7A = a2[0xA];
                    if ( (char)n0x7A > 0x7A )
                      goto LABEL_263;
                    if ( (char)n0x7A < 0x61 )
                    {
                      if ( (char)n0x7A > 0x5A )
                        goto LABEL_263;
                      if ( (char)n0x7A < 0x41 )
                      {
                        if ( (unsigned __int8)(n0x7A - 0x30) > 9u )
                          goto LABEL_263;
                        v30 = n0x7A - 0x30;
                      }
                      else
                      {
                        v30 = n0x7A - 0x37;
                      }
                    }
                    else
                    {
                      v30 = n0x7A - 0x57;
                    }
                    n0x5A_8 = a2[0xB];
                    v32 = (v30 << 0x2C) | v28;
                    if ( (char)n0x5A_8 <= 0x7A )
                    {
                      if ( (char)n0x5A_8 < 0x61 )
                      {
                        if ( (char)n0x5A_8 > 0x5A )
                          goto LABEL_263;
                        if ( (char)n0x5A_8 < 0x41 )
                        {
                          if ( (unsigned __int8)(n0x5A_8 - 0x30) > 9u )
                            goto LABEL_263;
                          v33 = n0x5A_8 - 0x30;
                        }
                        else
                        {
                          v33 = n0x5A_8 - 0x37;
                        }
                      }
                      else
                      {
                        v33 = n0x5A_8 - 0x57;
                      }
                      n0x5A_9 = a2[0xC];
                      v35 = (v33 << 0x28) | v32;
                      if ( (char)n0x5A_9 <= 0x7A )
                      {
                        if ( (char)n0x5A_9 < 0x61 )
                        {
                          if ( (char)n0x5A_9 > 0x5A )
                            goto LABEL_263;
                          if ( (char)n0x5A_9 < 0x41 )
                          {
                            if ( (unsigned __int8)(n0x5A_9 - 0x30) > 9u )
                              goto LABEL_263;
                            v36 = n0x5A_9 - 0x30;
                          }
                          else
                          {
                            v36 = n0x5A_9 - 0x37;
                          }
                        }
                        else
                        {
                          v36 = n0x5A_9 - 0x57;
                        }
                        n0x5A_10 = a2[0xD];
                        v38 = (v36 << 0x24) | v35;
                        if ( (char)n0x5A_10 <= 0x7A )
                        {
                          if ( (char)n0x5A_10 < 0x61 )
                          {
                            if ( (char)n0x5A_10 > 0x5A )
                              goto LABEL_263;
                            if ( (char)n0x5A_10 < 0x41 )
                            {
                              if ( (unsigned __int8)(n0x5A_10 - 0x30) > 9u )
                                goto LABEL_263;
                              v39 = n0x5A_10 - 0x30;
                            }
                            else
                            {
                              v39 = n0x5A_10 - 0x37;
                            }
                          }
                          else
                          {
                            v39 = n0x5A_10 - 0x57;
                          }
                          v40 = (v39 << 0x20) | v38;
                          if ( a2[0xE] != 0x2D )
                            goto LABEL_263;
                          n0x7A_1 = a2[0xF];
                          if ( (char)n0x7A_1 > 0x7A )
                            goto LABEL_263;
                          if ( (char)n0x7A_1 < 0x61 )
                          {
                            if ( (char)n0x7A_1 > 0x5A )
                              goto LABEL_263;
                            if ( (char)n0x7A_1 < 0x41 )
                            {
                              if ( (unsigned __int8)(n0x7A_1 - 0x30) > 9u )
                                goto LABEL_263;
                              v42 = a2[0xF];
                            }
                            else
                            {
                              v42 = n0x7A_1 - 7;
                            }
                          }
                          else
                          {
                            v42 = n0x7A_1 - 7;
                          }
                          n0x5A_11 = a2[0x10];
                          v44 = (v42 << 0x3C) | v40;
                          if ( (char)n0x5A_11 <= 0x7A )
                          {
                            if ( (char)n0x5A_11 < 0x61 )
                            {
                              if ( (char)n0x5A_11 > 0x5A )
                                goto LABEL_263;
                              if ( (char)n0x5A_11 < 0x41 )
                              {
                                if ( (unsigned __int8)(n0x5A_11 - 0x30) > 9u )
                                  goto LABEL_263;
                                v45 = n0x5A_11 - 0x30;
                              }
                              else
                              {
                                v45 = n0x5A_11 - 0x37;
                              }
                            }
                            else
                            {
                              v45 = n0x5A_11 - 0x57;
                            }
                            n0x5A_12 = a2[0x11];
                            v47 = (v45 << 0x38) | v44;
                            if ( (char)n0x5A_12 <= 0x7A )
                            {
                              if ( (char)n0x5A_12 < 0x61 )
                              {
                                if ( (char)n0x5A_12 > 0x5A )
                                  goto LABEL_263;
                                if ( (char)n0x5A_12 < 0x41 )
                                {
                                  if ( (unsigned __int8)(n0x5A_12 - 0x30) > 9u )
                                    goto LABEL_263;
                                  v48 = n0x5A_12 - 0x30;
                                }
                                else
                                {
                                  v48 = n0x5A_12 - 0x37;
                                }
                              }
                              else
                              {
                                v48 = n0x5A_12 - 0x57;
                              }
                              n0x5A_13 = a2[0x12];
                              v50 = (v48 << 0x34) | v47;
                              if ( (char)n0x5A_13 <= 0x7A )
                              {
                                if ( (char)n0x5A_13 < 0x61 )
                                {
                                  if ( (char)n0x5A_13 > 0x5A )
                                    goto LABEL_263;
                                  if ( (char)n0x5A_13 < 0x41 )
                                  {
                                    if ( (unsigned __int8)(n0x5A_13 - 0x30) > 9u )
                                      goto LABEL_263;
                                    v51 = n0x5A_13 - 0x30;
                                  }
                                  else
                                  {
                                    v51 = n0x5A_13 - 0x37;
                                  }
                                }
                                else
                                {
                                  v51 = n0x5A_13 - 0x57;
                                }
                                v52 = (v51 << 0x30) | v50;
                                if ( a2[0x13] != 0x2D )
                                  goto LABEL_263;
                                n0x7A_2 = a2[0x14];
                                if ( (char)n0x7A_2 > 0x7A )
                                  goto LABEL_263;
                                if ( (char)n0x7A_2 < 0x61 )
                                {
                                  if ( (char)n0x7A_2 > 0x5A )
                                    goto LABEL_263;
                                  if ( (char)n0x7A_2 < 0x41 )
                                  {
                                    if ( (unsigned __int8)(n0x7A_2 - 0x30) > 9u )
                                      goto LABEL_263;
                                    v54 = n0x7A_2 - 0x30;
                                  }
                                  else
                                  {
                                    v54 = n0x7A_2 - 0x37;
                                  }
                                }
                                else
                                {
                                  v54 = n0x7A_2 - 0x57;
                                }
                                n0x5A_14 = a2[0x15];
                                v56 = 0x10 * v54;
                                if ( (char)n0x5A_14 <= 0x7A )
                                {
                                  if ( (char)n0x5A_14 < 0x61 )
                                  {
                                    if ( (char)n0x5A_14 > 0x5A )
                                      goto LABEL_263;
                                    if ( (char)n0x5A_14 < 0x41 )
                                    {
                                      if ( (unsigned __int8)(n0x5A_14 - 0x30) > 9u )
                                        goto LABEL_263;
                                      v57 = n0x5A_14 - 0x30;
                                    }
                                    else
                                    {
                                      v57 = n0x5A_14 - 0x37;
                                    }
                                  }
                                  else
                                  {
                                    v57 = n0x5A_14 - 0x57;
                                  }
                                  n0x5A_15 = a2[0x16];
                                  v59 = v57 | v56;
                                  if ( (char)n0x5A_15 <= 0x7A )
                                  {
                                    if ( (char)n0x5A_15 < 0x61 )
                                    {
                                      if ( (char)n0x5A_15 > 0x5A )
                                        goto LABEL_263;
                                      if ( (char)n0x5A_15 < 0x41 )
                                      {
                                        if ( (unsigned __int8)(n0x5A_15 - 0x30) > 9u )
                                          goto LABEL_263;
                                        v60 = n0x5A_15 - 0x30;
                                      }
                                      else
                                      {
                                        v60 = n0x5A_15 - 0x37;
                                      }
                                    }
                                    else
                                    {
                                      v60 = n0x5A_15 - 0x57;
                                    }
                                    v61 = v59 | (v60 << 0xC);
                                    n0x5A_16 = a2[0x17];
                                    if ( (char)n0x5A_16 <= 0x7A )
                                    {
                                      if ( (char)n0x5A_16 < 0x61 )
                                      {
                                        if ( (char)n0x5A_16 > 0x5A )
                                          goto LABEL_263;
                                        if ( (char)n0x5A_16 < 0x41 )
                                        {
                                          if ( (unsigned __int8)(n0x5A_16 - 0x30) > 9u )
                                            goto LABEL_263;
                                          v63 = n0x5A_16 - 0x30;
                                        }
                                        else
                                        {
                                          v63 = n0x5A_16 - 0x37;
                                        }
                                      }
                                      else
                                      {
                                        v63 = n0x5A_16 - 0x57;
                                      }
                                      v64 = v61 | (v63 << 8);
                                      if ( a2[0x18] != 0x2D )
                                        goto LABEL_263;
                                      n0x7A_3 = a2[0x19];
                                      if ( (char)n0x7A_3 > 0x7A )
                                        goto LABEL_263;
                                      if ( (char)n0x7A_3 < 0x61 )
                                      {
                                        if ( (char)n0x7A_3 > 0x5A )
                                          goto LABEL_263;
                                        if ( (char)n0x7A_3 < 0x41 )
                                        {
                                          if ( (unsigned __int8)(n0x7A_3 - 0x30) > 9u )
                                            goto LABEL_263;
                                          v66 = n0x7A_3 - 0x30;
                                        }
                                        else
                                        {
                                          v66 = n0x7A_3 - 0x37;
                                        }
                                      }
                                      else
                                      {
                                        v66 = n0x7A_3 - 0x57;
                                      }
                                      v67 = v64 | (v66 << 0x14);
                                      n0x5A_17 = a2[0x1A];
                                      if ( (char)n0x5A_17 <= 0x7A )
                                      {
                                        if ( (char)n0x5A_17 < 0x61 )
                                        {
                                          if ( (char)n0x5A_17 > 0x5A )
                                            goto LABEL_263;
                                          if ( (char)n0x5A_17 < 0x41 )
                                          {
                                            if ( (unsigned __int8)(n0x5A_17 - 0x30) > 9u )
                                              goto LABEL_263;
                                            v69 = n0x5A_17 - 0x30;
                                          }
                                          else
                                          {
                                            v69 = n0x5A_17 - 0x37;
                                          }
                                        }
                                        else
                                        {
                                          v69 = n0x5A_17 - 0x57;
                                        }
                                        v70 = v67 | (v69 << 0x10);
                                        n0x5A_18 = a2[0x1B];
                                        if ( (char)n0x5A_18 <= 0x7A )
                                        {
                                          if ( (char)n0x5A_18 < 0x61 )
                                          {
                                            if ( (char)n0x5A_18 > 0x5A )
                                              goto LABEL_263;
                                            if ( (char)n0x5A_18 < 0x41 )
                                            {
                                              if ( (unsigned __int8)(n0x5A_18 - 0x30) > 9u )
                                                goto LABEL_263;
                                              v72 = n0x5A_18 - 0x30;
                                            }
                                            else
                                            {
                                              v72 = n0x5A_18 - 0x37;
                                            }
                                          }
                                          else
                                          {
                                            v72 = n0x5A_18 - 0x57;
                                          }
                                          v73 = v70 | (v72 << 0x1C);
                                          n0x5A_19 = a2[0x1C];
                                          if ( (char)n0x5A_19 <= 0x7A )
                                          {
                                            if ( (char)n0x5A_19 < 0x61 )
                                            {
                                              if ( (char)n0x5A_19 > 0x5A )
                                                goto LABEL_263;
                                              if ( (char)n0x5A_19 < 0x41 )
                                              {
                                                if ( (unsigned __int8)(n0x5A_19 - 0x30) > 9u )
                                                  goto LABEL_263;
                                                v75 = n0x5A_19 - 0x30;
                                              }
                                              else
                                              {
                                                v75 = n0x5A_19 - 0x37;
                                              }
                                            }
                                            else
                                            {
                                              v75 = n0x5A_19 - 0x57;
                                            }
                                            v76 = v73 | (v75 << 0x18);
                                            n0x5A_20 = a2[0x1D];
                                            if ( (char)n0x5A_20 <= 0x7A )
                                            {
                                              if ( (char)n0x5A_20 < 0x61 )
                                              {
                                                if ( (char)n0x5A_20 > 0x5A )
                                                  goto LABEL_263;
                                                if ( (char)n0x5A_20 < 0x41 )
                                                {
                                                  if ( (unsigned __int8)(n0x5A_20 - 0x30) > 9u )
                                                    goto LABEL_263;
                                                  v78 = n0x5A_20 - 0x30;
                                                }
                                                else
                                                {
                                                  v78 = n0x5A_20 - 0x37;
                                                }
                                              }
                                              else
                                              {
                                                v78 = n0x5A_20 - 0x57;
                                              }
                                              v79 = v76 | (v78 << 0x24);
                                              n0x5A_21 = a2[0x1E];
                                              if ( (char)n0x5A_21 <= 0x7A )
                                              {
                                                if ( (char)n0x5A_21 < 0x61 )
                                                {
                                                  if ( (char)n0x5A_21 > 0x5A )
                                                    goto LABEL_263;
                                                  if ( (char)n0x5A_21 < 0x41 )
                                                  {
                                                    if ( (unsigned __int8)(n0x5A_21 - 0x30) > 9u )
                                                      goto LABEL_263;
                                                    v81 = n0x5A_21 - 0x30;
                                                  }
                                                  else
                                                  {
                                                    v81 = n0x5A_21 - 0x37;
                                                  }
                                                }
                                                else
                                                {
                                                  v81 = n0x5A_21 - 0x57;
                                                }
                                                v82 = v79 | (v81 << 0x20);
                                                n0x5A_22 = a2[0x1F];
                                                if ( (char)n0x5A_22 <= 0x7A )
                                                {
                                                  if ( (char)n0x5A_22 < 0x61 )
                                                  {
                                                    if ( (char)n0x5A_22 > 0x5A )
                                                      goto LABEL_263;
                                                    if ( (char)n0x5A_22 < 0x41 )
                                                    {
                                                      if ( (unsigned __int8)(n0x5A_22 - 0x30) > 9u )
                                                        goto LABEL_263;
                                                      v84 = n0x5A_22 - 0x30;
                                                    }
                                                    else
                                                    {
                                                      v84 = n0x5A_22 - 0x37;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v84 = n0x5A_22 - 0x57;
                                                  }
                                                  v85 = v82 | (v84 << 0x2C);
                                                  n0x5A_23 = a2[0x20];
                                                  if ( (char)n0x5A_23 <= 0x7A )
                                                  {
                                                    if ( (char)n0x5A_23 < 0x61 )
                                                    {
                                                      if ( (char)n0x5A_23 > 0x5A )
                                                        goto LABEL_263;
                                                      if ( (char)n0x5A_23 < 0x41 )
                                                      {
                                                        if ( (unsigned __int8)(n0x5A_23 - 0x30) > 9u )
                                                          goto LABEL_263;
                                                        v87 = n0x5A_23 - 0x30;
                                                      }
                                                      else
                                                      {
                                                        v87 = n0x5A_23 - 0x37;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v87 = n0x5A_23 - 0x57;
                                                    }
                                                    v88 = v85 | (v87 << 0x28);
                                                    n0x5A_24 = a2[0x21];
                                                    if ( (char)n0x5A_24 <= 0x7A )
                                                    {
                                                      if ( (char)n0x5A_24 < 0x61 )
                                                      {
                                                        if ( (char)n0x5A_24 > 0x5A )
                                                          goto LABEL_263;
                                                        if ( (char)n0x5A_24 < 0x41 )
                                                        {
                                                          if ( (unsigned __int8)(n0x5A_24 - 0x30) > 9u )
                                                            goto LABEL_263;
                                                          v90 = n0x5A_24 - 0x30;
                                                        }
                                                        else
                                                        {
                                                          v90 = n0x5A_24 - 0x37;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v90 = n0x5A_24 - 0x57;
                                                      }
                                                      n0x5A_25 = a2[0x22];
                                                      v92 = (v90 << 0x34) | v88;
                                                      if ( (char)n0x5A_25 <= 0x7A )
                                                      {
                                                        if ( (char)n0x5A_25 < 0x61 )
                                                        {
                                                          if ( (char)n0x5A_25 > 0x5A )
                                                            goto LABEL_263;
                                                          if ( (char)n0x5A_25 < 0x41 )
                                                          {
                                                            if ( (unsigned __int8)(n0x5A_25 - 0x30) > 9u )
                                                              goto LABEL_263;
                                                            v93 = n0x5A_25 - 0x30;
                                                          }
                                                          else
                                                          {
                                                            v93 = n0x5A_25 - 0x37;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          v93 = n0x5A_25 - 0x57;
                                                        }
                                                        n0x5A_26 = a2[0x23];
                                                        v95 = (v93 << 0x30) | v92;
                                                        if ( (char)n0x5A_26 <= 0x7A )
                                                        {
                                                          if ( (char)n0x5A_26 < 0x61 )
                                                          {
                                                            if ( (char)n0x5A_26 > 0x5A )
                                                              goto LABEL_263;
                                                            if ( (char)n0x5A_26 < 0x41 )
                                                            {
                                                              if ( (unsigned __int8)(n0x5A_26 - 0x30) > 9u )
                                                                goto LABEL_263;
                                                              v96 = a2[0x23];
                                                            }
                                                            else
                                                            {
                                                              v96 = n0x5A_26 - 7;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            v96 = n0x5A_26 - 7;
                                                          }
                                                          n0x61 = a2[0x24];
                                                          v98 = (v96 << 0x3C) | v95;
                                                          if ( (char)n0x61 <= 0x7A )
                                                          {
                                                            if ( (char)n0x61 >= 0x61 )
                                                            {
                                                              v99 = n0x61 - 0x57;
                                                              goto LABEL_262;
                                                            }
                                                            if ( (char)n0x61 <= 0x5A )
                                                            {
                                                              if ( (char)n0x61 >= 0x41 )
                                                              {
                                                                v99 = n0x61 - 0x37;
                                                                goto LABEL_262;
                                                              }
                                                              if ( (unsigned __int8)(n0x61 - 0x30) <= 9u )
                                                              {
                                                                v99 = n0x61 - 0x30;
LABEL_262:
                                                                v100 = (v99 << 0x38) | v98;
                                                                if ( a2[0x25] != 0x7D )
                                                                  goto LABEL_263;
                                                                goto LABEL_524;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_263:
    *a1 = 0;
    a1[1] = 0;
    return a1;
  }
  if ( (char)n0x7B > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7B < 0x61 )
  {
    if ( (char)n0x7B > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7B < 0x41 )
    {
      if ( (unsigned __int8)(n0x7B - 0x30) > 9u )
        goto LABEL_263;
      v102 = *a2;
    }
    else
    {
      v102 = n0x7B - 7;
    }
  }
  else
  {
    v102 = n0x7B - 7;
  }
  n0x7A_4 = a2[1];
  v104 = v102 << 0x3C;
  if ( (char)n0x7A_4 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_4 < 0x61 )
  {
    if ( (char)n0x7A_4 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_4 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_4 - 0x30) > 9u )
        goto LABEL_263;
      v105 = n0x7A_4 - 0x30;
    }
    else
    {
      v105 = n0x7A_4 - 0x37;
    }
  }
  else
  {
    v105 = n0x7A_4 - 0x57;
  }
  n0x7A_5 = a2[2];
  v107 = (v105 << 0x38) | v104;
  if ( (char)n0x7A_5 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_5 < 0x61 )
  {
    if ( (char)n0x7A_5 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_5 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_5 - 0x30) > 9u )
        goto LABEL_263;
      v108 = n0x7A_5 - 0x30;
    }
    else
    {
      v108 = n0x7A_5 - 0x37;
    }
  }
  else
  {
    v108 = n0x7A_5 - 0x57;
  }
  n0x7A_6 = a2[3];
  v110 = (v108 << 0x34) | v107;
  if ( (char)n0x7A_6 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_6 < 0x61 )
  {
    if ( (char)n0x7A_6 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_6 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_6 - 0x30) > 9u )
        goto LABEL_263;
      v111 = n0x7A_6 - 0x30;
    }
    else
    {
      v111 = n0x7A_6 - 0x37;
    }
  }
  else
  {
    v111 = n0x7A_6 - 0x57;
  }
  n0x7A_7 = a2[4];
  v113 = (v111 << 0x30) | v110;
  if ( (char)n0x7A_7 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_7 < 0x61 )
  {
    if ( (char)n0x7A_7 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_7 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_7 - 0x30) > 9u )
        goto LABEL_263;
      v114 = n0x7A_7 - 0x30;
    }
    else
    {
      v114 = n0x7A_7 - 0x37;
    }
  }
  else
  {
    v114 = n0x7A_7 - 0x57;
  }
  n0x7A_8 = a2[5];
  v116 = (v114 << 0x2C) | v113;
  if ( (char)n0x7A_8 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_8 < 0x61 )
  {
    if ( (char)n0x7A_8 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_8 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_8 - 0x30) > 9u )
        goto LABEL_263;
      v117 = n0x7A_8 - 0x30;
    }
    else
    {
      v117 = n0x7A_8 - 0x37;
    }
  }
  else
  {
    v117 = n0x7A_8 - 0x57;
  }
  n0x7A_9 = a2[6];
  v119 = (v117 << 0x28) | v116;
  if ( (char)n0x7A_9 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_9 < 0x61 )
  {
    if ( (char)n0x7A_9 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_9 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_9 - 0x30) > 9u )
        goto LABEL_263;
      v120 = n0x7A_9 - 0x30;
    }
    else
    {
      v120 = n0x7A_9 - 0x37;
    }
  }
  else
  {
    v120 = n0x7A_9 - 0x57;
  }
  n0x7A_10 = a2[7];
  v122 = (v120 << 0x24) | v119;
  if ( (char)n0x7A_10 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_10 < 0x61 )
  {
    if ( (char)n0x7A_10 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_10 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_10 - 0x30) > 9u )
        goto LABEL_263;
      v123 = n0x7A_10 - 0x30;
    }
    else
    {
      v123 = n0x7A_10 - 0x37;
    }
  }
  else
  {
    v123 = n0x7A_10 - 0x57;
  }
  v124 = (v123 << 0x20) | v122;
  if ( a2[8] != 0x2D )
    goto LABEL_263;
  n0x7A_11 = a2[9];
  if ( (char)n0x7A_11 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_11 < 0x61 )
  {
    if ( (char)n0x7A_11 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_11 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_11 - 0x30) > 9u )
        goto LABEL_263;
      v126 = n0x7A_11 - 0x30;
    }
    else
    {
      v126 = n0x7A_11 - 0x37;
    }
  }
  else
  {
    v126 = n0x7A_11 - 0x57;
  }
  n0x7A_12 = a2[0xA];
  v128 = (v126 << 0x1C) | v124;
  if ( (char)n0x7A_12 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_12 < 0x61 )
  {
    if ( (char)n0x7A_12 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_12 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_12 - 0x30) > 9u )
        goto LABEL_263;
      v129 = n0x7A_12 - 0x30;
    }
    else
    {
      v129 = n0x7A_12 - 0x37;
    }
  }
  else
  {
    v129 = n0x7A_12 - 0x57;
  }
  n0x7A_13 = a2[0xB];
  v131 = (v129 << 0x18) | v128;
  if ( (char)n0x7A_13 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_13 < 0x61 )
  {
    if ( (char)n0x7A_13 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_13 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_13 - 0x30) > 9u )
        goto LABEL_263;
      v132 = n0x7A_13 - 0x30;
    }
    else
    {
      v132 = n0x7A_13 - 0x37;
    }
  }
  else
  {
    v132 = n0x7A_13 - 0x57;
  }
  n0x7A_14 = a2[0xC];
  v134 = (v132 << 0x14) | v131;
  if ( (char)n0x7A_14 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_14 < 0x61 )
  {
    if ( (char)n0x7A_14 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_14 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_14 - 0x30) > 9u )
        goto LABEL_263;
      v135 = n0x7A_14 - 0x30;
    }
    else
    {
      v135 = n0x7A_14 - 0x37;
    }
  }
  else
  {
    v135 = n0x7A_14 - 0x57;
  }
  v136 = (v135 << 0x10) | v134;
  if ( a2[0xD] != 0x2D )
    goto LABEL_263;
  n0x7A_15 = a2[0xE];
  if ( (char)n0x7A_15 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_15 < 0x61 )
  {
    if ( (char)n0x7A_15 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_15 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_15 - 0x30) > 9u )
        goto LABEL_263;
      v138 = n0x7A_15 - 0x30;
    }
    else
    {
      v138 = n0x7A_15 - 0x37;
    }
  }
  else
  {
    v138 = n0x7A_15 - 0x57;
  }
  n0x7A_16 = a2[0xF];
  v140 = (v138 << 0xC) | v136;
  if ( (char)n0x7A_16 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_16 < 0x61 )
  {
    if ( (char)n0x7A_16 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_16 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_16 - 0x30) > 9u )
        goto LABEL_263;
      v141 = n0x7A_16 - 0x30;
    }
    else
    {
      v141 = n0x7A_16 - 0x37;
    }
  }
  else
  {
    v141 = n0x7A_16 - 0x57;
  }
  n0x7A_17 = a2[0x10];
  v143 = (v141 << 8) | v140;
  if ( (char)n0x7A_17 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_17 < 0x61 )
  {
    if ( (char)n0x7A_17 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_17 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_17 - 0x30) > 9u )
        goto LABEL_263;
      v144 = n0x7A_17 - 0x30;
    }
    else
    {
      v144 = n0x7A_17 - 0x37;
    }
  }
  else
  {
    v144 = n0x7A_17 - 0x57;
  }
  n0x7A_18 = a2[0x11];
  v146 = (0x10 * v144) | v143;
  if ( (char)n0x7A_18 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_18 < 0x61 )
  {
    if ( (char)n0x7A_18 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_18 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_18 - 0x30) > 9u )
        goto LABEL_263;
      v147 = n0x7A_18 - 0x30;
    }
    else
    {
      v147 = n0x7A_18 - 0x37;
    }
  }
  else
  {
    v147 = n0x7A_18 - 0x57;
  }
  v52 = v147 | v146;
  if ( a2[0x12] != 0x2D )
    goto LABEL_263;
  n0x7A_19 = a2[0x13];
  if ( (char)n0x7A_19 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_19 < 0x61 )
  {
    if ( (char)n0x7A_19 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_19 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_19 - 0x30) > 9u )
        goto LABEL_263;
      v149 = a2[0x13];
    }
    else
    {
      v149 = n0x7A_19 - 7;
    }
  }
  else
  {
    v149 = n0x7A_19 - 7;
  }
  n0x7A_20 = a2[0x14];
  v151 = v149 << 0x3C;
  if ( (char)n0x7A_20 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_20 < 0x61 )
  {
    if ( (char)n0x7A_20 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_20 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_20 - 0x30) > 9u )
        goto LABEL_263;
      v152 = n0x7A_20 - 0x30;
    }
    else
    {
      v152 = n0x7A_20 - 0x37;
    }
  }
  else
  {
    v152 = n0x7A_20 - 0x57;
  }
  n0x7A_21 = a2[0x15];
  v154 = (v152 << 0x38) | v151;
  if ( (char)n0x7A_21 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_21 < 0x61 )
  {
    if ( (char)n0x7A_21 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_21 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_21 - 0x30) > 9u )
        goto LABEL_263;
      v155 = n0x7A_21 - 0x30;
    }
    else
    {
      v155 = n0x7A_21 - 0x37;
    }
  }
  else
  {
    v155 = n0x7A_21 - 0x57;
  }
  n0x7A_22 = a2[0x16];
  v157 = (v155 << 0x34) | v154;
  if ( (char)n0x7A_22 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_22 < 0x61 )
  {
    if ( (char)n0x7A_22 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_22 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_22 - 0x30) > 9u )
        goto LABEL_263;
      v158 = n0x7A_22 - 0x30;
    }
    else
    {
      v158 = n0x7A_22 - 0x37;
    }
  }
  else
  {
    v158 = n0x7A_22 - 0x57;
  }
  v159 = (v158 << 0x30) | v157;
  if ( a2[0x17] != 0x2D )
    goto LABEL_263;
  n0x7A_23 = a2[0x18];
  if ( (char)n0x7A_23 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_23 < 0x61 )
  {
    if ( (char)n0x7A_23 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_23 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_23 - 0x30) > 9u )
        goto LABEL_263;
      v161 = n0x7A_23 - 0x30;
    }
    else
    {
      v161 = n0x7A_23 - 0x37;
    }
  }
  else
  {
    v161 = n0x7A_23 - 0x57;
  }
  n0x7A_24 = a2[0x19];
  v163 = (v161 << 0x2C) | v159;
  if ( (char)n0x7A_24 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_24 < 0x61 )
  {
    if ( (char)n0x7A_24 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_24 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_24 - 0x30) > 9u )
        goto LABEL_263;
      v164 = n0x7A_24 - 0x30;
    }
    else
    {
      v164 = n0x7A_24 - 0x37;
    }
  }
  else
  {
    v164 = n0x7A_24 - 0x57;
  }
  n0x7A_25 = a2[0x1A];
  v166 = (v164 << 0x28) | v163;
  if ( (char)n0x7A_25 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_25 < 0x61 )
  {
    if ( (char)n0x7A_25 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_25 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_25 - 0x30) > 9u )
        goto LABEL_263;
      v167 = n0x7A_25 - 0x30;
    }
    else
    {
      v167 = n0x7A_25 - 0x37;
    }
  }
  else
  {
    v167 = n0x7A_25 - 0x57;
  }
  n0x7A_26 = a2[0x1B];
  v169 = (v167 << 0x24) | v166;
  if ( (char)n0x7A_26 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_26 < 0x61 )
  {
    if ( (char)n0x7A_26 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_26 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_26 - 0x30) > 9u )
        goto LABEL_263;
      v170 = n0x7A_26 - 0x30;
    }
    else
    {
      v170 = n0x7A_26 - 0x37;
    }
  }
  else
  {
    v170 = n0x7A_26 - 0x57;
  }
  n0x7A_27 = a2[0x1C];
  v172 = (v170 << 0x20) | v169;
  if ( (char)n0x7A_27 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_27 < 0x61 )
  {
    if ( (char)n0x7A_27 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_27 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_27 - 0x30) > 9u )
        goto LABEL_263;
      v173 = n0x7A_27 - 0x30;
    }
    else
    {
      v173 = n0x7A_27 - 0x37;
    }
  }
  else
  {
    v173 = n0x7A_27 - 0x57;
  }
  n0x7A_28 = a2[0x1D];
  v175 = (v173 << 0x1C) | v172;
  if ( (char)n0x7A_28 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_28 < 0x61 )
  {
    if ( (char)n0x7A_28 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_28 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_28 - 0x30) > 9u )
        goto LABEL_263;
      v176 = n0x7A_28 - 0x30;
    }
    else
    {
      v176 = n0x7A_28 - 0x37;
    }
  }
  else
  {
    v176 = n0x7A_28 - 0x57;
  }
  n0x7A_29 = a2[0x1E];
  v178 = (v176 << 0x18) | v175;
  if ( (char)n0x7A_29 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_29 < 0x61 )
  {
    if ( (char)n0x7A_29 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_29 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_29 - 0x30) > 9u )
        goto LABEL_263;
      v179 = n0x7A_29 - 0x30;
    }
    else
    {
      v179 = n0x7A_29 - 0x37;
    }
  }
  else
  {
    v179 = n0x7A_29 - 0x57;
  }
  n0x7A_30 = a2[0x1F];
  v181 = (v179 << 0x14) | v178;
  if ( (char)n0x7A_30 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_30 < 0x61 )
  {
    if ( (char)n0x7A_30 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_30 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_30 - 0x30) > 9u )
        goto LABEL_263;
      v182 = n0x7A_30 - 0x30;
    }
    else
    {
      v182 = n0x7A_30 - 0x37;
    }
  }
  else
  {
    v182 = n0x7A_30 - 0x57;
  }
  n0x7A_31 = a2[0x20];
  v184 = (v182 << 0x10) | v181;
  if ( (char)n0x7A_31 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_31 < 0x61 )
  {
    if ( (char)n0x7A_31 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_31 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_31 - 0x30) > 9u )
        goto LABEL_263;
      v185 = n0x7A_31 - 0x30;
    }
    else
    {
      v185 = n0x7A_31 - 0x37;
    }
  }
  else
  {
    v185 = n0x7A_31 - 0x57;
  }
  n0x7A_32 = a2[0x21];
  v187 = (v185 << 0xC) | v184;
  if ( (char)n0x7A_32 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_32 < 0x61 )
  {
    if ( (char)n0x7A_32 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_32 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_32 - 0x30) > 9u )
        goto LABEL_263;
      v188 = n0x7A_32 - 0x30;
    }
    else
    {
      v188 = n0x7A_32 - 0x37;
    }
  }
  else
  {
    v188 = n0x7A_32 - 0x57;
  }
  n0x7A_33 = a2[0x22];
  v190 = (v188 << 8) | v187;
  if ( (char)n0x7A_33 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_33 < 0x61 )
  {
    if ( (char)n0x7A_33 > 0x5A )
      goto LABEL_263;
    if ( (char)n0x7A_33 < 0x41 )
    {
      if ( (unsigned __int8)(n0x7A_33 - 0x30) > 9u )
        goto LABEL_263;
      v191 = n0x7A_33 - 0x30;
    }
    else
    {
      v191 = n0x7A_33 - 0x37;
    }
  }
  else
  {
    v191 = n0x7A_33 - 0x57;
  }
  n0x7A_34 = a2[0x23];
  v193 = (0x10 * v191) | v190;
  if ( (char)n0x7A_34 > 0x7A )
    goto LABEL_263;
  if ( (char)n0x7A_34 >= 0x61 )
  {
    *a1 = v52;
    result = a1;
    a1[1] = v193 | (n0x7A_34 - 0x57);
    return result;
  }
  if ( (char)n0x7A_34 > 0x5A )
    goto LABEL_263;
  if ( (char)n0x7A_34 >= 0x41 )
  {
    *a1 = v52;
    result = a1;
    a1[1] = v193 | (n0x7A_34 - 0x37);
    return result;
  }
  if ( (unsigned __int8)(n0x7A_34 - 0x30) > 9u )
    goto LABEL_263;
  v100 = v193 | (n0x7A_34 - 0x30);
LABEL_524:
  *a1 = v52;
  result = a1;
  a1[1] = v100;
  return result;
}

// --- End Function: sub_1402BC380 (0x1402BC380) ---

// --- Function: sub_1402C61F0 (0x1402C61F0) ---
__int64 sub_1402C61F0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n36; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n36 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n36;
  while ( Buffer[n36] );
  sub_1402DE5F0(a1, Buffer, n36);
  return a1;
}

// --- End Function: sub_1402C61F0 (0x1402C61F0) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402CA4C0 (0x1402CA4C0) ---
__int64 __fastcall sub_1402CA4C0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
      break;
    v4 = 0;
    if ( (int)result < 0 )
      v4 = a1;
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402CA4C0 (0x1402CA4C0) ---

// --- Function: sscanf_s_w (0x1402CC900) ---
bool __fastcall sscanf_s_w(const char *a1)
{
  char v2; // [rsp+90h] [rbp-58h] BYREF
  char v3; // [rsp+94h] [rbp-54h] BYREF
  char v4; // [rsp+98h] [rbp-50h] BYREF
  char v5; // [rsp+9Ch] [rbp-4Ch] BYREF
  char v6; // [rsp+A0h] [rbp-48h] BYREF
  char v7; // [rsp+A4h] [rbp-44h] BYREF
  char v8; // [rsp+A8h] [rbp-40h] BYREF
  char v9; // [rsp+ACh] [rbp-3Ch] BYREF
  char v10; // [rsp+B0h] [rbp-38h] BYREF
  char v11; // [rsp+B4h] [rbp-34h] BYREF
  char v12; // [rsp+B8h] [rbp-30h] BYREF
  char v13; // [rsp+BCh] [rbp-2Ch] BYREF
  char v14; // [rsp+C0h] [rbp-28h] BYREF
  char v15; // [rsp+C4h] [rbp-24h] BYREF
  char v16; // [rsp+C8h] [rbp-20h] BYREF
  char v17; // [rsp+CCh] [rbp-1Ch] BYREF

  return sscanf_s(
           a1,
           "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
           &v2,
           &v3,
           &v4,
           &v5,
           &v6,
           &v7,
           &v8,
           &v9,
           &v10,
           &v11,
           &v12,
           &v13,
           &v14,
           &v15,
           &v16,
           &v17) == 0x10;
}

// --- End Function: sscanf_s_w (0x1402CC900) ---

// --- Function: sub_1402CD240 (0x1402CD240) ---
__int64 __fastcall sub_1402CD240(__int64 a1, const char *a2, char a3)
{
  __int64 result; // rax
  int v7; // edi
  unsigned __int32 v8; // eax

  result = NtCurrentTeb_w();
  v7 = *(_DWORD *)(result + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v7 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v8 )
    {
      result = sub_1403C33A0(a1, v8, a2, a3);
    }
    else
    {
      result = NtCurrentTeb_w();
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v7;
  }
  return result;
}

// --- End Function: sub_1402CD240 (0x1402CD240) ---

// --- Function: sub_1402D2790 (0x1402D2790) ---
unsigned __int64 __fastcall sub_1402D2790(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(result + 24) && (result = *(unsigned int *)(a1 + 20), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 20) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CB820((volatile signed __int64 *)a1, v3);
    }
  }
  return result;
}

// --- End Function: sub_1402D2790 (0x1402D2790) ---

// --- Function: sub_1402D2830 (0x1402D2830) ---
__int64 __fastcall sub_1402D2830(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
      break;
    ++a4;
    if ( (a1 & 1) != 0 )
      a3 |= 1 << (a2 - v4);
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D2830 (0x1402D2830) ---

// --- Function: sub_1402DB100 (0x1402DB100) ---
const ULONG_PTR *__fastcall sub_1402DB100(__int64 a1)
{
  unsigned __int32 v1; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  v1 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
  if ( v1 != 1 )
    return sub_1403DB1F0(a1, v1);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &byte_14819E9C2;
  *(_QWORD *)(a1 + 8) = &byte_14819E9C2;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402DB100 (0x1402DB100) ---

// --- Function: sub_1402DE5F0 (0x1402DE5F0) ---
__int64 __fastcall sub_1402DE5F0(__int64 a1, const void *a2, size_t n36_1)
{
  size_t n36; // r8
  const void *v7; // rcx
  _BYTE *v8; // rsi
  size_t n0x24; // rax
  __int64 v10; // rax
  __int64 result; // rax

  n36 = *(_QWORD *)(a1 + 8);
  if ( n36_1 > n36 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - n36;
      sub_147605980(v7);
    }
    *v8 = 0;
    n0x24 = 0x24;
    *(_QWORD *)(a1 + 8) = 0x24;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    if ( n36_1 )
    {
      if ( n36_1 + 1 > 0x25 )
      {
        v10 = allocWithProfilerInfo(n36_1 + 1, 0);
        qword_149B3AD38 += n36_1 + 1;
        v8 = (_BYTE *)v10;
        n0x24 = n36_1;
      }
      *(_QWORD *)(a1 + 8) = n0x24;
      *(_QWORD *)a1 = n36_1;
      *(_QWORD *)(a1 + 0x10) = v8;
      v8[n36_1] = 0;
    }
  }
  memmove(*(void **)(a1 + 0x10), a2, n36_1);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n36_1;
  *(_BYTE *)(n36_1 + result) = 0;
  return result;
}

// --- End Function: sub_1402DE5F0 (0x1402DE5F0) ---

// --- Function: sub_1402DECA0 (0x1402DECA0) ---
void __fastcall sub_1402DECA0(unsigned __int64 *a1, const void *a2, size_t Size)
{
  unsigned __int64 *v5; // rsi
  size_t Size_1; // r14
  unsigned __int64 v8; // rbp
  unsigned __int64 n8; // rdx
  unsigned __int64 v10; // rax

  if ( Size )
  {
    v5 = (unsigned __int64 *)a1[2];
    Size_1 = *a1;
    v8 = *a1 + Size;
    if ( v8 <= a1[1] )
    {
      memcpy((char *)v5 + Size_1, a2, Size);
      *a1 += Size;
      *(_BYTE *)(*a1 + a1[2]) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= v8 )
        n8 = *a1 + Size;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        sub_1402A3B50((__int64 *)a1, n8);
        memcpy((void *)a1[2], v5, Size_1);
        memcpy((void *)(Size_1 + a1[2]), a2, Size);
        v10 = a1[2];
        *a1 = v8;
        *(_BYTE *)(Size_1 + Size + v10) = 0;
      }
      if ( v5 != a1 + 3 )
      {
        qword_149B3AB68 += -1LL - a1[1];
        sub_147605980(v5);
      }
    }
  }
}

// --- End Function: sub_1402DECA0 (0x1402DECA0) ---

// --- Function: GetEventDispatcherContext (0x1402E07B0) ---
// Returns a pointer to the event dispatcher context, which is located at an offset
// of 8 bytes from the provided object.
__int64 __fastcall GetEventDispatcherContext(__int64 radar_state_updater_base)
{
  return radar_state_updater_base + 8;
}

// --- End Function: GetEventDispatcherContext (0x1402E07B0) ---

// --- Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
        __int64 **a1,
        __int64 a2,
        __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 0x18) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 0x18LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 0x18) )
      {
        v13 = *(_QWORD **)(v9 + 0x10);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 0x10) = *v13;
          if ( !*(_BYTE *)(*v13 + 0x19LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 0x10LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 0x19) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v12 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 0x18) )
      {
        v19 = *(_QWORD *)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = *(_QWORD *)(v19 + 0x10);
          v20 = *(_QWORD *)(v19 + 0x10);
          if ( !*(_BYTE *)(v20 + 0x19) )
            *(_QWORD *)(v20 + 8) = v9;
          *(_QWORD *)(v19 + 8) = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(__int64 **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          *(_QWORD *)(v19 + 0x10) = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 0x19LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v11 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 0x18) = 1;
  return a3;
}

// --- End Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: __std_init_once_link_alternate_names_and_abort (0x1402E1150) ---
void __noreturn _std_init_once_link_alternate_names_and_abort()
{
  abort();
}

// --- End Function: __std_init_once_link_alternate_names_and_abort (0x1402E1150) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_7 (0x1402E11B0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402E11B0) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: sub_1402E1FE0 (0x1402E1FE0) ---
__int64 __fastcall sub_1402E1FE0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
      break;
    v5 = v4 + 0x20;
    if ( (unsigned __int8)(v4 - 0x41) > 0x19u )
      v5 = v4;
    v6 = sub_1402D2830(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402CA4C0(0x4C11DB7, 1, (v6 << 0x19) ^ (unsigned int)((unsigned __int64)(v6 << 0x18) >> 0x1F) & 0x4C11DB7);
    v8 = sub_1402D2830(v7 >> 1, 0x20, v7 << 0x1F, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402E1FE0 (0x1402E1FE0) ---

// --- Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---
std::array<int,2> *__fastcall std::allocator<std::array<int,2>>::allocate(
        std::allocator<std::array<int,2> > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  std::array<int,2> *result; // rax

  if ( _Count > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  allocSize = 8 * _Count;
  if ( 8 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (std::array<int,2> *)allocWithProfilerInfo_w(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E1170();
  v3 = allocWithProfilerInfo_w(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (std::array<int,2> *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---

// --- Function: sub_1402E4190 (0x1402E4190) ---
void *sub_1402E4190()
{
  return &unk_149B3AD30;
}

// --- End Function: sub_1402E4190 (0x1402E4190) ---

// --- Function: sscanf_s (0x1402E41A0) ---
int sscanf_s(const char *Src, const char *Format, ...)
{
  _QWORD *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_1402E4190();
  return _stdio_common_vsscanf(*v4 | 1LL, Src, 0xFFFFFFFFFFFFFFFFuLL, Format, 0, va);
}

// --- End Function: sscanf_s (0x1402E41A0) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n22 = 22;
  if ( n22 + 1 >= 0x1000 )
  {
    allocSize = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n22 == -1 )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FBEC0 (0x1402FBEC0) ---
__int64 __fastcall sub_1402FBEC0(unsigned __int8 *a1)
{
  return *a1;
}

// --- End Function: sub_1402FBEC0 (0x1402FBEC0) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)v8 + 80LL) )
          {
            n256 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i - 1);
              i -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                  break;
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30-- - v8) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(
        __int64 timestampMs,
        _QWORD *unknownContext2,
        __int64 callbackContext,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  unsigned __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  unsigned __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(callbackContext + 0x24));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(callbackContext + 0x20);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(callbackContext + 8);
  v18 = *(_QWORD *)callbackContext;
  v31 = v16;
  if ( (v17 - *(_QWORD *)callbackContext) / 0x70 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 0x58) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 0x40))();
        v18 += 0x70;
      }
      while ( v18 != v17 );
      *(_QWORD *)(callbackContext + 8) = *(_QWORD *)callbackContext;
    }
    sub_1402FDB90((__int64 *)callbackContext, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = unknownContext2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 0x30;
    v23 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v29 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v16 )
    {
      v20 = unknownContext2 + 1;
      if ( _Newcapacity_1 < (__int64)(unknownContext2[1] - *unknownContext2) >> 2
        && !*(_DWORD *)(*unknownContext2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 0x18)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(callbackContext + 8) - *(_QWORD *)callbackContext) / 0x70LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 0x30),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)callbackContext));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v26 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *unknownContext2) >> 2
          && !*(_DWORD *)(*unknownContext2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 0x38)
          && *(_QWORD *)(v26 + 0x20) )
        {
          if ( (*(_QWORD *)(callbackContext + 8) - *(_QWORD *)callbackContext) / 0x70LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)callbackContext;
          if ( *(_BYTE *)(v27 + 0x58) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 0x40))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 0x38))(*(_QWORD *)(v26 - 0x10));
          v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 0x10) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 0x18) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 0x20) = *(_QWORD *)(v26 + 0x10);
          *(_QWORD *)(v27 + 0x30) = *(_QWORD *)(v26 + 0x20);
          *(_QWORD *)(v27 + 0x28) = *(_QWORD *)(v26 + 0x18);
          *(_QWORD *)(v27 + 0x38) = *(_QWORD *)(v26 + 0x28);
          *(_QWORD *)(v27 + 0x40) = *(_QWORD *)(v26 + 0x30);
          *(_QWORD *)(v27 + 0x48) = *(_QWORD *)(v26 + 0x38);
          *(_QWORD *)(v27 + 0x50) = *(_QWORD *)(v26 + 0x40);
          *(_QWORD *)(v27 + 0x60) = *(_QWORD *)(v26 + 0x50);
          *(_QWORD *)(v27 + 0x68) = *(_QWORD *)(v26 + 0x58);
          *(_BYTE *)(v27 + 0x58) = 1;
          *(_BYTE *)(v27 + 0x59) = *(_BYTE *)(v26 + 0x49);
        }
        ++_Newcapacity_2;
        v26 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(callbackContext + 0x18) = timestampMs;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 timestampMs)
{
  int timestampMs_1; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  timestampMs_1 = timestampMs;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = timestampMs / 0x3E8;
  Time = timestampMs / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", timestampMs_1 - 0x3E8 * v7)
                      + 0x13);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes a global callback function if it is registered, passing the provided
// arguments. If no callback is registered, it defaults to returning a status of 1.
// The resulting status bits are then masked: bit 2 is cleared if qword_149B3B208
// is zero, and bit 3 is cleared if qword_149B3B210 is zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 statusBits; // rax

  if ( qword_149B3B1F0 )
    statusBits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    statusBits = 1;
  if ( !qword_149B3B208 )
    statusBits = (unsigned int)statusBits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)statusBits & 0xFFFFFFF7;
  return statusBits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140300D10 (0x140300D10) ---
__int64 __fastcall sub_140300D10(_BYTE *a1, int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // r10
  int v8; // edx
  int v9; // ebp
  unsigned __int64 i; // rbx
  int v11; // r11d
  int v12; // r9d
  _WORD *v13; // r8
  __int64 v14; // rax
  unsigned int v15; // edx

  v4 = -1;
  do
    ++v4;
  while ( *(_BYTE *)(a3 + v4) );
  v8 = 0;
  v9 = 0;
  if ( a4 )
  {
    if ( a2 <= 0 )
    {
      v9 = 1;
    }
    else
    {
      *a1 = 34;
      v8 = 1;
    }
  }
  for ( i = 0; i < v4; ++i )
  {
    if ( v8 >= a2 )
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = a2 - v8;
      v13 = &a1[v8];
      switch ( *(_BYTE *)(i + a3) )
      {
        case 8:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 25180;
          v8 += 2;
          break;
        case 9:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 29788;
          v8 += 2;
          break;
        case 0xA:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 28252;
          v8 += 2;
          break;
        case 0xC:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 26204;
          v8 += 2;
          break;
        case 0xD:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 29276;
          v8 += 2;
          break;
        case 0x22:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 8796;
          v8 += 2;
          break;
        case 0x5C:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 23644;
          v8 += 2;
          break;
        default:
          if ( v12 > 0 )
          {
            *(_BYTE *)v13 = *(_BYTE *)(i + a3);
            v11 = 1;
          }
LABEL_26:
          v8 += v11;
          break;
      }
    }
  }
  if ( a4 )
  {
    if ( v8 < a2 )
    {
      v14 = v8;
      v15 = v8 + 1;
      if ( v9 )
        v15 = -1;
      a1[v14] = 34;
      return v15;
    }
    v9 = 1;
  }
  if ( v9 )
    return (unsigned int)-1;
  return (unsigned int)v8;
}

// --- End Function: sub_140300D10 (0x140300D10) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 timestampMs,
        wchar_t *p_uuidString,
        unsigned int n4,
        __int64 *playerId,
        _BYTE *Src,
        char *sourceLocation,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 unknownContext1,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *p_outputFlags)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          sourceLocation,
          (__int64)__Val_0__,
          _Newcapacity,
          unknownContext1,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *playerId;
  if ( !((playerId[1] - *playerId) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *playerId;
  }
  while ( v62 < (playerId[1] - *playerId) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*p_outputFlags & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*p_outputFlags & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(timestampMs, p_uuidString, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 timestampMs,
        _BYTE *p_Buffer,
        _BYTE *p_uuidString,
        unsigned int n4,
        _QWORD *playerId,
        char *messageString,
        char *sourceLocation,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 unknownContext1,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int outputFlags,
        int eventKeyVectorPtr)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *playerId_1; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *playerId_3; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *messageString_2; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 timestampMs_2; // r14
  _BYTE *p_uuidString_2; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *playerId_2; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *p_uuidString_1; // [rsp+C0h] [rbp-A8h]
  __int64 timestampMs_1; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *sourceLocation_1; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *messageString_1; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  playerId_1 = playerId;
  messageString_1 = messageString;
  sourceLocation_1 = sourceLocation;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  p_uuidString_1 = p_uuidString;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  timestampMs_1 = timestampMs;
  n0xF_3 = n0xF + 0x80;
  n0xF_5[0] = n4;
  playerId_2 = playerId;
  n0xF_17 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    playerId_1 = playerId_2;
LABEL_57:
    n0xF_25 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( p_uuidString[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( p_uuidString && Size_4 >= Size_3 )
    {
      memcpy(v36, p_uuidString, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !p_uuidString )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  playerId_1 = playerId_2;
  n0xF_25 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (outputFlags & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              timestampMs_1,
              p_uuidString_1,
              n4_1,
              messageString_1,
              playerId_1,
              v165,
              a17,
              sourceLocation_1,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &outputFlags);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (outputFlags & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (outputFlags & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (outputFlags & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_26 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_95;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_18 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  playerId_3 = playerId_2;
  v59 = playerId_2[1];
  v60 = *playerId_2;
  v61 = (v59 - *playerId_2) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_129:
      n0xF_3 = n0xF + 0x80;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      playerId_3 = playerId_2;
      goto LABEL_131;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 0x22;
      }
      else
      {
LABEL_111:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_130;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    playerId_3 = playerId_2;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = playerId_3[1];
    ++v62;
    v60 = *playerId_3;
    v75 = v59 - *playerId_3;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_145:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 0xB;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *messageString_1 )
  {
    messageString_2 = messageString_1;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *messageString_2);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++messageString_2;
    }
    while ( *messageString_2 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_209:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            sourceLocation_1,
            __Val_0___1,
            _Newcapacity,
            unknownContext1,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_16 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_248:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_255;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 0x16;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_292;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_16 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_315:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( eventKeyVectorPtr <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &eventKeyVectorPtr);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (outputFlags & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 outputFlags,
                 timestampMs_1,
                 p_uuidString_1,
                 n4,
                 messageString_1,
                 playerId_2,
                 v165,
                 v48,
                 sourceLocation_1,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  timestampMs_2 = timestampMs_1;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    p_uuidString_2 = p_uuidString_1;
    qword_149B3B210(timestampMs_1, p_uuidString_1, n4, Buffer_1, p_n0xFa, eventKeyVectorPtr);
  }
  else
  {
    p_uuidString_2 = p_uuidString_1;
  }
  if ( v167 )
    v167(
      outputFlags,
      timestampMs_2,
      p_uuidString_2,
      n4,
      messageString_1,
      playerId_2,
      v165,
      a17,
      sourceLocation_1,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 39 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 39);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(_Newvec - 1) = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: ReportTelemetryEvent (0x1403045C0) ---
// This function serves as a comprehensive structured logging or telemetry event
// reporting mechanism. It captures various contextual data points such as
// timestamps, unique IDs (UUID-like), player information, source location, and
// custom event-specific data. The collected data is formatted into a human-
// readable string and/or a JSON-like structure. Depending on global configuration
// flags, the formatted output can be directed to standard output, standard error,
// or custom logging callbacks. It also handles dynamic memory allocation and
// deallocation for internal buffers and data structures.
void __fastcall ReportTelemetryEvent(
        unsigned int logLevel,
        __int64 *playerId,
        char *messageString,
        char *sourceLocation,
        vraudio::AudioBuffer *audioBufferContext,
        unsigned __int64 audioBufferCount,
        __int64 unknownContext1,
        __int64 outputFlags,
        _QWORD *unknownContext2,
        __int64 callbackContext)
{
  _QWORD *unknownContext2_1; // rdi
  __int64 callbackContext_1; // rbx
  __int64 timestampMs_1; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 eventKeyCount; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *audioBufferContext_2; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *audioBufferContext_4; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *audioBufferContext_8; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_1; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 audioBufferCount_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 eventKeyCount_1; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 logMessageBuffer; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char outputFlags_1; // cl
  int v90; // eax
  FILE *File; // rax
  int g_logToStderrEnabled; // r8d
  FILE *File_1; // rax
  char outputFlags_2; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_1; // rax
  const void *Buffer_2; // rsi
  double *Buffer; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *eventKeyListPtr; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *eventKeyListPtr_1; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int eventKeyVectorPtr; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME uuid; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *audioBufferContext_1; // [rsp+F0h] [rbp+50h]
  __int64 timestampMs; // [rsp+F8h] [rbp+58h]
  unsigned __int64 audioBufferContext_5; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *audioBufferContext_3; // [rsp+110h] [rbp+70h]
  char *sourceLocation_1; // [rsp+118h] [rbp+78h]
  char *messageStringa; // [rsp+120h] [rbp+80h]
  __int64 *playerIda; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *audioBufferContext_6; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *audioBufferContext_7; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 audioBufferCount_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char timestampBuffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t uuidString[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  unknownContext2_1 = unknownContext2;
  callbackContext_1 = callbackContext;
  sourceLocation_1 = sourceLocation;
  messageStringa = messageString;
  playerIda = playerId;
  n4 = logLevel;
  audioBufferContext_1 = audioBufferContext;
  if ( qword_149B3B188 )
  {
    timestampMs_1 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &uuid);
    timestampMs_1 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&uuid - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  timestampMs = timestampMs_1;
  if ( callbackContext_1
    && !sub_1402FFCB0(
          timestampMs_1,
          unknownContext2_1,
          callbackContext_1,
          (__int64)audioBufferContext,
          audioBufferCount) )
  {
    return;
  }
  if ( qword_149B3B1E0 )
  {
    uuid = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(uuidString, 0x25);
  }
  else
  {
    uuid = (struct _FILETIME)qword_149B3B250++;
    swprintf(uuidString, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(timestampBuffer, 0x20u, timestampMs_1);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  eventKeyCount = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  audioBufferCount_2 = 0;
  if ( !audioBufferCount )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  audioBufferContext_2 = audioBufferContext_1;
  v20 = v117;
  audioBufferContext_3 = audioBufferContext_1;
  while ( 2 )
  {
    audioBufferContext_4 = audioBufferContext_2;
    if ( *((_BYTE *)audioBufferContext_2 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = audioBufferContext_2;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    audioBufferContext_5 = (unsigned __int64)audioBufferContext_2;
    if ( eventKeyCount < 0x400 )
    {
      v147[eventKeyCount] = audioBufferContext_2;
LABEL_30:
      n0xF_29 = ++eventKeyCount;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, audioBufferCount);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              v14,
              _Whereptr,
              __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400;
          ++__Val_0_;
        }
        while ( n0x400 < 0x400 );
        eventKeyCount = n0xF_29;
        audioBufferContext_2 = audioBufferContext_3;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          v14,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&audioBufferContext_5);
      }
      else
      {
        *_Whereptr_1 = audioBufferContext_2;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)audioBufferContext_2 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)audioBufferContext_2 + 1) = sub_1402FF3C0(&v142, audioBufferContext_2);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)audioBufferContext_2 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    audioBufferContext_5 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)audioBufferContext_2, &v130, &audioBufferContext_5);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      audioBufferContext_4 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      audioBufferContext_6 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        audioBufferContext_8 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        audioBufferContext_7 = audioBufferContext_8;
        v48 = *(_QWORD **)audioBufferContext_8;
        v49 = **(_QWORD ***)audioBufferContext_8;
        if ( v49 == *(_QWORD **)audioBufferContext_8 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        audioBufferContext_8 = audioBufferContext_7;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)audioBufferContext_8 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)audioBufferContext_8 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          audioBufferContext_4 = audioBufferContext_6;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        audioBufferContext_4 = audioBufferContext_6;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)audioBufferContext_4 + 1) = v57;
      eventKeyCount = n0xF_29;
      audioBufferContext_7 = audioBufferContext_4;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_1 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, audioBufferCount);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                v14,
                _Whereptr_2,
                __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_1;
            ++__Val_0__1;
          }
          while ( n0x400_1 < 0x400 );
          eventKeyCount = n0xF_29;
          audioBufferContext_4 = audioBufferContext_6;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            v14,
            _Whereptr_3,
            &audioBufferContext_7);
        }
        else
        {
          *_Whereptr_3 = audioBufferContext_4;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = audioBufferContext_4;
      }
      n0xF_29 = ++eventKeyCount;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    audioBufferContext_2 = audioBufferContext_3;
    v29 = v143;
LABEL_94:
    if ( audioBufferContext_5 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[audioBufferContext_5];
    v124 += audioBufferContext_5;
LABEL_98:
    audioBufferContext_2 = (vraudio::AudioBuffer *)((char *)audioBufferContext_2 + 0x70);
    v69 = v120;
    audioBufferCount_1 = audioBufferCount_2 + 1;
    *((_QWORD *)audioBufferContext_4 + 0xA) = v29;
    audioBufferCount_2 = audioBufferCount_1;
    audioBufferContext_3 = audioBufferContext_2;
    if ( audioBufferCount_1 < audioBufferCount )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = eventKeyCount;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = eventKeyCount;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * eventKeyCount], (__int64)(8 * eventKeyCount) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( eventKeyCount_1 = 0; eventKeyCount_1 < eventKeyCount; ++eventKeyCount_1 )
  {
    v76 = *(_QWORD *)&v71[8 * eventKeyCount_1];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * eventKeyCount_1] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_131;
    }
  }
  logMessageBuffer = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    logMessageBuffer = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(logMessageBuffer & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_131:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(
            timestampMs,
            n4,
            messageStringa,
            playerIda,
            sourceLocation_1,
            audioBufferContext_1,
            audioBufferCount,
            v146,
            n0x10_1,
            &outputFlags);
    v123[0] = v87;
  }
  outputFlags_1 = outputFlags;
  if ( (outputFlags & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&uuid,
            timestampMs,
            uuidString,
            n4,
            playerIda,
            messageStringa,
            sourceLocation_1,
            audioBufferContext_1,
            audioBufferCount,
            unknownContext1,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &outputFlags);
    outputFlags_1 = outputFlags;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (outputFlags_1 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", timestampBuffer, v83);
    outputFlags_1 = outputFlags;
  }
  g_logToStderrEnabled = n2_126;
  if ( n2_126 == 1 && (outputFlags_1 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(n2_126 + 1);
    fprintf(File_1, "%s %s\n", timestampBuffer, v83);
    g_logToStderrEnabled = n2_126;
  }
  v83[v88] = 0;
  outputFlags_2 = outputFlags;
  v95 = (outputFlags & 1) != 0 && n2_125 == 2;
  v96 = (outputFlags & 2) != 0 && g_logToStderrEnabled == 2;
  if ( (outputFlags & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_2 = 0;
    }
    else
    {
      Buffer_1 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_2 = (const void *)Buffer_1;
      if ( Buffer_1 )
      {
        Buffer = (double *)Buffer_1;
        goto LABEL_167;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer = (double *)&v117;
LABEL_167:
    eventKeyVectorPtr = v123[0];
    *(_BYTE *)Buffer = 0;
    sub_140302E40(
      *(_QWORD *)&uuid,
      timestampMs,
      timestampBuffer,
      uuidString,
      n4,
      playerIda,
      messageStringa,
      sourceLocation_1,
      (__int64)audioBufferContext_1,
      audioBufferCount,
      unknownContext1,
      (__int64)v71,
      n0xF_29,
      Buffer,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      outputFlags,
      eventKeyVectorPtr);
    sub_1402A3D30(Buffer_2);
    outputFlags_2 = outputFlags;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (outputFlags_2 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      outputFlags_2 = outputFlags;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (outputFlags_2 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    eventKeyListPtr = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = eventKeyListPtr[5];
        eventKeyListPtr_1 = (_QWORD *)*eventKeyListPtr;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)eventKeyListPtr[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_191;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        eventKeyListPtr[4] = 0;
        eventKeyListPtr[5] = 0xF;
        *((_BYTE *)eventKeyListPtr + 0x10) = 0;
        sub_1402A3D30(eventKeyListPtr);
        eventKeyListPtr = eventKeyListPtr_1;
      }
      while ( eventKeyListPtr_1 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_191:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: ReportTelemetryEvent (0x1403045C0) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: sub_140306B60 (0x140306B60) ---
char *__fastcall sub_140306B60(void **a1, char *a2, unsigned __int64 a3)
{
  _BYTE *v5; // rcx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rbx
  size_t Size_2; // rdi
  char *result; // rax
  unsigned __int64 v13; // rbp
  char *v14; // rbx
  size_t Size_1; // rdi
  size_t Size; // r8
  char *v17; // rbx

  v5 = *a1;
  v7 = ((_BYTE *)a1[2] - v5) >> 4;
  if ( a3 <= v7 )
  {
    v13 = ((_BYTE *)a1[1] - v5) >> 4;
    if ( a3 <= v13 )
    {
      Size = 0x10 * a3;
      v17 = &v5[Size];
      result = (char *)memmove(v5, a2, Size);
      a1[1] = v17;
    }
    else
    {
      memmove(v5, a2, 0x10 * v13);
      v14 = (char *)a1[1];
      Size_1 = 0x10 * (a3 - v13);
      memmove(v14, &a2[0x10 * v13], Size_1);
      result = &v14[Size_1];
      a1[1] = &v14[Size_1];
    }
  }
  else
  {
    v8 = 0xFFFFFFFFFFFFFFFLL;
    if ( a3 > 0xFFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = v7 >> 1;
    if ( v7 <= 0xFFFFFFFFFFFFFFFLL - (v7 >> 1) )
    {
      v8 = v9 + v7;
      if ( v9 + v7 < a3 )
        v8 = a3;
    }
    if ( v5 )
    {
      if ( 0x10 * v7 >= 0x1000 )
      {
        if ( (unsigned __int64)&v5[-*((_QWORD *)v5 + 0xFFFFFFFF) - 8] > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v5 = (_BYTE *)*((_QWORD *)v5 + 0xFFFFFFFF);
      }
      sub_1402A3D30(v5);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    sub_140332420((unsigned __int64 *)a1, v8);
    v10 = (unsigned __int64)*a1;
    Size_2 = 0x10 * a3;
    memmove(*a1, a2, Size_2);
    result = (char *)(Size_2 + v10);
    a1[1] = (void *)(Size_2 + v10);
  }
  return result;
}

// --- End Function: sub_140306B60 (0x140306B60) ---

// --- Function: sub_1403090C0 (0x1403090C0) ---
void __fastcall sub_1403090C0(__int64 a1)
{
  const void *v1; // rcx

  v1 = *(const void **)(a1 + 8);
  if ( v1 )
    sub_147605980(v1);
}

// --- End Function: sub_1403090C0 (0x1403090C0) ---

// --- Function: sub_14030A540 (0x14030A540) ---
__int64 __fastcall sub_14030A540(__int64 a1, __int64 a2)
{
  void *v3; // rcx
  _BYTE *v4; // rsi
  unsigned __int64 v5; // rbx
  unsigned __int64 allocSize; // rbx

  v3 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  v4 = *(_BYTE **)(a2 + 8);
  if ( v4 )
  {
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v5;
    while ( v4[v5] );
    allocSize = v5 + 1;
    if ( allocSize )
    {
      v3 = (void *)allocWithProfilerInfo(allocSize, 0);
      *(_QWORD *)(a1 + 8) = v3;
      *(_QWORD *)(a1 + 0x10) = allocSize;
    }
    memcpy(v3, v4, allocSize);
  }
  return a1;
}

// --- End Function: sub_14030A540 (0x14030A540) ---

// --- Function: sub_14030DE50 (0x14030DE50) ---
__int64 __fastcall sub_14030DE50(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 0x10) = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a1 + 0x18) = *(_QWORD *)(a2 + 0x18);
  result = a1;
  *(_OWORD *)(a1 + 0x20) = *(_OWORD *)(a2 + 0x20);
  *(double *)(a1 + 0x30) = *(double *)(a2 + 0x30);
  return result;
}

// --- End Function: sub_14030DE50 (0x14030DE50) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: validateHandleAccess (0x14030EC00) ---
// Validates a given handle by checking its internal type, flags, and thread-
// specific access permissions. It extracts the raw pointer and flags from the
// handle, then performs checks against metadata associated with the handle. It
// also verifies if the current thread's context or global settings permit access
// to the handle based on its type.
bool __fastcall validateHandleAccess(unsigned __int64 *a1)
{
  unsigned __int64 handleValue; // r9
  __int64 rawPointer; // r10
  unsigned __int64 handleFlags; // r9
  __int64 flagMask; // rax
  __int64 metadataBase; // r10
  __int64 metadataPtr; // rbx
  bool isThreadAccessPermitted; // al

  handleValue = *a1;
  if ( !*a1 )
    return 0;
  rawPointer = handleValue & 0xFFFFFFFFFFFFLL;
  handleFlags = HIWORD(handleValue);
  if ( (handleFlags & 0xF000) != 0 )
  {
    flagMask = map_flag_to_mask(0x2000u);
    metadataPtr = metadataBase & ~(flagMask - 1);
  }
  else
  {
    metadataPtr = rawPointer - 6;
  }
  if ( *(_WORD *)(metadataPtr + 2) != (handleFlags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (isThreadAccessPermitted = sub_140539D80()) )
    isThreadAccessPermitted = 1;
  return *(_WORD *)(metadataPtr + 4) == 2 && isThreadAccessPermitted || sub_140392020(a1) != 0;
}

// --- End Function: validateHandleAccess (0x14030EC00) ---

// --- Function: sub_14030ECF0 (0x14030ECF0) ---
__int64 __fastcall sub_14030ECF0(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_14030ECF0 (0x14030ECF0) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 24576 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_140332420 (0x140332420) ---
unsigned __int64 __fastcall sub_140332420(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 allocSize; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  unsigned __int64 result; // rax

  if ( a2 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_11;
  allocSize = 0x10 * a2;
  if ( 0x10 * a2 < 0x1000 )
  {
    if ( allocSize )
      v6 = allocWithProfilerInfo_w(allocSize);
    else
      v6 = 0;
    goto LABEL_10;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_11:
    sub_1402E1170();
  v4 = allocWithProfilerInfo_w(allocSize + 0x27);
  v5 = v4;
  if ( !v4 )
    invalid_parameter_noinfo_noreturn();
  v6 = (v4 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v6 - 8) = v5;
LABEL_10:
  *a1 = v6;
  a1[1] = v6;
  result = allocSize + v6;
  a1[2] = result;
  return result;
}

// --- End Function: sub_140332420 (0x140332420) ---

// --- Function: sub_1403328D0 (0x1403328D0) ---
__int64 __fastcall sub_1403328D0(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rdi
  const void *v4; // rcx
  _QWORD *v5; // rcx
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; v1 += 4 )
    {
      v4 = (const void *)v1[1];
      if ( v4 )
        sub_147605980(v4);
    }
    v5 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v5 - v5[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v5 = (_QWORD *)v5[0xFFFFFFFF];
    }
    sub_1402A3D30(v5);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1403328D0 (0x1403328D0) ---

// --- Function: sub_14033B330 (0x14033B330) ---
_QWORD *__fastcall sub_14033B330(__int64 a1, _QWORD *a2)
{
  char *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 *v7; // rax
  __int64 v8; // r8
  unsigned __int8 *v9; // rax
  __int64 v10; // r8
  int v11; // ecx
  int v12; // edx
  __int64 v13; // r14
  __int64 v14; // rsi
  __int64 v15; // rbx
  signed __int64 v16; // rdi
  const char *v18; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v19[24]; // [rsp+28h] [rbp-30h] BYREF
  BOOL fPending; // [rsp+70h] [rbp+18h] BYREF
  char *v21; // [rsp+78h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&InitOnce, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149B3E728 & 1) == 0 )
    {
      dword_149B3E728 |= 1u;
      xmmword_149B3E690 = 0;
    }
    n0x18_24 = 0x18;
    v21 = strchr("class yasli::TypeID __cdecl yasli::TypeID::get<class CStringHash>(void)", 0x3C);
    v4 = strrchr("class yasli::TypeID __cdecl yasli::TypeID::get<class CStringHash>(void)", 0x3E);
    if ( v21 != v4 )
      ++v21;
    v18 = (const char *)&unk_149B3E6A8;
    sub_1403E40C0(&v18, (const char *)&unk_149B3E727, (const char **)&v21, v4);
    *v18 = 0;
    *((_QWORD *)&xmmword_149B3E690 + 1) = &unk_149B3E72C;
    *(_QWORD *)&xmmword_149B3E690 = &xmmword_149B3E690;
    qword_149B3E680 = (__int64)&xmmword_149B3E690;
    if ( !InitOnceComplete(&InitOnce, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v5 = *(_QWORD *)qword_149B3E680;
  v6 = *(_QWORD *)(qword_149B3E680 + 8);
  v7 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v19);
  v8 = *v7;
  if ( v5 == *v7 )
    goto LABEL_19;
  if ( !v5 || !v8 || v6 == v7[1] || *(_QWORD *)(v5 + 0x10) != *(_QWORD *)(v8 + 0x10) )
    goto LABEL_18;
  v9 = (unsigned __int8 *)(v5 + 0x18);
  v10 = v8 - v5;
  do
  {
    v11 = v9[v10];
    v12 = *v9 - v11;
    if ( v12 )
      break;
    ++v9;
  }
  while ( v11 );
  if ( !v12 )
  {
LABEL_19:
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x20LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1)
      && (v14 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
      *(_QWORD *)v14 = v15;
      *(_BYTE *)(v14 + 8) = 1;
      if ( *(_DWORD *)(v15 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v15 + 0x14);
      }
      else
      {
        v16 = _InterlockedIncrement64((volatile signed __int64 *)v15);
        if ( (v16 & 0x200000) != 0 )
        {
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
            sub_1403CB380(v15, v16, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2);
          else
            sub_1403CB5B0(v15, v16, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2);
        }
      }
    }
    else
    {
      v14 = 0;
    }
    sub_14035AED0(a2, v13, v14);
  }
  else
  {
LABEL_18:
    sub_14035AED0(a2, 0, 0);
  }
  return a2;
}

// --- End Function: sub_14033B330 (0x14033B330) ---

// --- Function: sub_14033B5B0 (0x14033B5B0) ---
_QWORD *__fastcall sub_14033B5B0(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 *v4; // rdx
  __int64 *v5; // rcx
  __int64 *v6; // rax

  v4 = *a1;
  v5 = v4;
  v6 = (__int64 *)v4[1];
  while ( !*((_BYTE *)v6 + 25) )
  {
    if ( *((_DWORD *)v6 + 8) >= *a3 )
    {
      v5 = v6;
      v6 = (__int64 *)*v6;
    }
    else
    {
      v6 = (__int64 *)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 25) || *a3 < *((_DWORD *)v5 + 8) || v5 == v4 )
  {
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
  else
  {
    sub_14033B330(v5[7], (__int64)a2);
    return a2;
  }
}

// --- End Function: sub_14033B5B0 (0x14033B5B0) ---

// --- Function: sub_1403487D0 (0x1403487D0) ---
void __fastcall sub_1403487D0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  const void *v6; // rdi

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 0x19) )
  {
    do
    {
      sub_1403487D0(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      sub_140357E60(a2, (__int64)v6 + 0x20);
      sub_1402A3D30(v6);
    }
    while ( !*((_BYTE *)v3 + 0x19) );
  }
}

// --- End Function: sub_1403487D0 (0x1403487D0) ---

// --- Function: sub_140357E60 (0x140357E60) ---
void __fastcall sub_140357E60(__int64 a1, __int64 a2)
{
  volatile signed __int32 *v2; // rbx
  const void *v4; // rcx

  v2 = *(volatile signed __int32 **)(a2 + 0x20);
  if ( v2 )
  {
    if ( _InterlockedExchangeAdd(v2 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v2)(v2);
      if ( _InterlockedExchangeAdd(v2 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8LL))(v2);
    }
  }
  v4 = *(const void **)(a2 + 8);
  if ( v4 )
    sub_147605980(v4);
}

// --- End Function: sub_140357E60 (0x140357E60) ---

// --- Function: sub_14035AED0 (0x14035AED0) ---
_QWORD *__fastcall sub_14035AED0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax
  _QWORD *result; // rax

  *a1 = a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  v5 = allocWithProfilerInfo_w(0x18u);
  if ( v5 )
  {
    *(_DWORD *)(v5 + 8) = 1;
    *(_QWORD *)v5 = off_1481B6460;
    *(_DWORD *)(v5 + 12) = 1;
    *(_QWORD *)(v5 + 16) = a3;
  }
  else
  {
    v5 = 0;
  }
  a1[4] = v5;
  result = a1;
  a1[3] = a3;
  return result;
}

// --- End Function: sub_14035AED0 (0x14035AED0) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 - 2);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_14036F3B0 (0x14036F3B0) ---
_QWORD *__fastcall sub_14036F3B0(_QWORD *a1, __int64 a2)
{
  a1[3] = 0x3FF0000000000000LL;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  *((_OWORD *)a1 + 2) = *(_OWORD *)a2;
  *((double *)a1 + 6) = *(double *)(a2 + 0x10);
  a1[7] = *(_QWORD *)(a2 + 0x20);
  return a1;
}

// --- End Function: sub_14036F3B0 (0x14036F3B0) ---

// --- Function: sub_1403701E0 (0x1403701E0) ---
__int64 __fastcall sub_1403701E0(__int64 a1, unsigned __int8 *a2, int a3)
{
  void *v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 allocSize; // rbx
  __int64 result; // rax

  *(_DWORD *)a1 = sub_1402E1FE0(a2, 0xFFFFFFFF);
  v6 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  if ( a2 )
  {
    v7 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v7;
    while ( a2[v7] );
    allocSize = v7 + 1;
    if ( allocSize )
    {
      v6 = (void *)allocWithProfilerInfo(allocSize, 0);
      *(_QWORD *)(a1 + 8) = v6;
      *(_QWORD *)(a1 + 0x10) = allocSize;
    }
    memcpy(v6, a2, allocSize);
  }
  result = a1;
  *(_DWORD *)(a1 + 0x18) = a3;
  return result;
}

// --- End Function: sub_1403701E0 (0x1403701E0) ---

// --- Function: sub_140370C50 (0x140370C50) ---
__int64 __fastcall sub_140370C50(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax
  volatile signed __int32 *v4; // rbx

  v1 = *(volatile signed __int32 **)(a1 + 32);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v4 = *(volatile signed __int32 **)(a1 + 16);
  if ( v4 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
  }
  return result;
}

// --- End Function: sub_140370C50 (0x140370C50) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: assignCStringToStringStructure (0x140377FA0) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **a1, _BYTE *a2)
{
  __int64 Size; // rax

  if ( a2 )
  {
    Size = -1;
    do
      ++Size;
    while ( a2[Size] );
    sub_1403DE230(a1, a2, (int)Size);
    return a1;
  }
  else
  {
    sub_1403DE230(a1, 0, 0);
    return a1;
  }
}

// --- End Function: assignCStringToStringStructure (0x140377FA0) ---

// --- Function: sub_14038F6D0 (0x14038F6D0) ---
double __fastcall sub_14038F6D0(__int64 *a1, _BYTE *a2, int a3, float *a4, char a5)
{
  size_t n1023; // rsi
  __int64 v9; // rcx
  char *Src_2; // rbx
  unsigned int v11; // r13d
  unsigned __int64 Size; // rbx
  _DWORD *v13; // rax
  void (__fastcall *v14)(void **, _QWORD); // rax
  __int64 v15; // rax
  const char *v16; // rax
  void *Src_1; // rax
  unsigned __int64 Size_1; // rdi
  _DWORD *v19; // rax
  char **v20; // rbx
  void *v21; // rcx
  __int64 v22; // rcx
  unsigned __int64 Size_2; // rax
  char *v24; // rdx
  void *hFile; // rcx
  unsigned __int64 nNumberOfBytesToWrite; // r8
  float v27; // xmm6_4
  float v28; // xmm7_4
  float v29; // xmm8_4
  float v30; // xmm9_4
  size_t n0x3FF_1; // rdi
  __int16 v32; // ax
  int v33; // r15d
  char *Src_3; // rbx
  _BYTE *v35; // rdx
  __int64 v36; // rdi
  __int64 v37; // rax
  __int64 v38; // rdx
  __int64 v39; // rcx
  void *Src_4; // [rsp+30h] [rbp-D0h] BYREF
  void *v42[7]; // [rsp+38h] [rbp-C8h] BYREF
  int n0x5A00_1; // [rsp+70h] [rbp-90h] BYREF
  __int64 v44; // [rsp+74h] [rbp-8Ch]
  int v45; // [rsp+7Ch] [rbp-84h]
  unsigned __int64 v46; // [rsp+80h] [rbp-80h]
  unsigned __int64 v47; // [rsp+88h] [rbp-78h]
  __int64 v48; // [rsp+90h] [rbp-70h]
  __int64 v49; // [rsp+98h] [rbp-68h]
  int v50; // [rsp+C0h] [rbp-40h]
  void *Src; // [rsp+C8h] [rbp-38h] BYREF
  char *v52; // [rsp+D0h] [rbp-30h] BYREF
  float *v53; // [rsp+D8h] [rbp-28h]
  int n0x5A00; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v55; // [rsp+E4h] [rbp-1Ch]
  int v56; // [rsp+ECh] [rbp-14h]
  unsigned __int64 v57; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v58; // [rsp+F8h] [rbp-8h]
  __int64 v59; // [rsp+100h] [rbp+0h]
  __int64 v60; // [rsp+108h] [rbp+8h]
  size_t n1023_1; // [rsp+130h] [rbp+30h] BYREF
  __int64 n0x3FF; // [rsp+138h] [rbp+38h]
  void *v63; // [rsp+140h] [rbp+40h]
  _BYTE v64[1024]; // [rsp+148h] [rbp+48h] BYREF
  float v65; // [rsp+548h] [rbp+448h]
  float v66; // [rsp+54Ch] [rbp+44Ch]
  float v67; // [rsp+550h] [rbp+450h]
  float v68; // [rsp+554h] [rbp+454h]
  int v69; // [rsp+558h] [rbp+458h]

  n1023 = 0;
  v53 = a4;
  v56 = 0;
  v50 = a3;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  n0x5A00 = 0x5A00;
  v55 = 1;
  v57 = __rdtsc();
  qword_149B4B870(
    &n0x5A00,
    &word_149B3E358,
    "Subsumption::PersonalLogger::AddLine",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption/PersonalLogger.cpp",
    0x67);
  v9 = a1[1] - *a1;
  HIWORD(n0x5A00) = word_149B3E358;
  if ( !(((__int64)((unsigned __int128)(v9 * (__int128)0x7A44C6AFC2DD9CA9LL) >> 0x40) >> 9)
       + ((unsigned __int64)((unsigned __int128)(v9 * (__int128)0x7A44C6AFC2DD9CA9LL) >> 0x40) >> 0x3F)
       - 1)
    || (a3 & (_DWORD)a1[9]) != a3 )
  {
    goto LABEL_73;
  }
  Src_2 = (char *)&qword_149B3B33C + 4;
  if ( a1[0xD] )
  {
    n0x5A00_1 = 0x5A00;
    v44 = 1;
    v45 = 0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v46 = __rdtsc();
    qword_149B4B870(
      &n0x5A00_1,
      &word_149B3E35C,
      "PersonalLogger::AddLine Custom Function",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption/PersonalLogger.cpp",
      0x70);
    v11 = *((_DWORD *)a1 + 0x13);
    HIWORD(n0x5A00_1) = word_149B3E35C;
    v42[0] = (char *)&qword_149B3B33C + 4;
    if ( a2 )
    {
      Size = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++Size;
      while ( a2[Size] );
      if ( (_DWORD)Size )
      {
        v13 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
        v42[0] = v13 + 2;
        *v13 = Size;
        v13[1] = Size;
        *((_BYTE *)v42[0] + (int)Size) = 0;
        if ( v42[0] != a2 )
          memcpy(v42[0], a2, (int)Size);
      }
      Src_2 = (char *)&qword_149B3B33C + 4;
    }
    v14 = (void (__fastcall *)(void **, _QWORD))a1[0xD];
    if ( a1[0xE] == 1 )
      v14(v42, v11);
    else
      ((void (__fastcall *)(__int64 *, void **, _QWORD))v14)(a1 + 0xD, v42, v11);
    if ( *((int *)v42[0] + 0xFFFFFFFF) > 0 )
      sub_147605980((char *)v42[0] + 0xFFFFFFF8);
    v47 = __rdtsc();
    qword_149B4B878(&n0x5A00_1);
  }
  if ( *((_BYTE *)a1 + 0x50) )
  {
    Src_4 = (char *)&qword_149B3B33C + 4;
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC70 + 0x90LL))(qword_149B4FC70);
    v16 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0xF8LL))(v15);
    sub_1403A9130((char **)&Src_4, "%s %s", v16, a2);
    Src_1 = Src_4;
    Src_4 = (char *)&qword_149B3B33C + 4;
    Src = Src_1;
  }
  else
  {
    if ( a2 )
    {
      Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++Size_1;
      while ( a2[Size_1] );
      if ( (_DWORD)Size_1 )
      {
        v19 = (_DWORD *)allocWithProfilerInfo((int)Size_1 + 9LL, 0);
        Src_2 = (char *)(v19 + 2);
        *v19 = Size_1;
        v19[1] = Size_1;
        *((_BYTE *)v19 + (int)Size_1 + 8) = 0;
        if ( v19 + 2 != (_DWORD *)a2 )
          memcpy(v19 + 2, a2, (int)Size_1);
      }
    }
    Src = Src_2;
    v52 = (char *)&qword_149B3B33C + 4;
  }
  if ( SLODWORD(qword_149B3B33C) > 0 )
    sub_147605980((char *)&qword_149B3B33C + 0xFFFFFFFC);
  if ( *((_BYTE *)a1 + 0x51) )
  {
    v20 = (char **)sub_14035B160(&Src_4, (const void **)&Src);
    n0x5A00_1 = 0x5A00;
    v44 = 1;
    v45 = 0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v46 = __rdtsc();
    qword_149B4B870(
      &n0x5A00_1,
      &word_149B3E364,
      "Subsumption::PersonalLogger::LogToFile",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption/PersonalLogger.cpp",
      0xB3);
    v21 = (void *)a1[0xB];
    HIWORD(n0x5A00_1) = word_149B3E364;
    if ( __scrt_is_event_api_used(v21) )
    {
      v22 = *((int *)*v20 + 0xFFFFFFFE);
      if ( (_DWORD)v22 )
      {
        if ( (*v20)[v22 - 1] == 0xA )
          sub_1403E9810(v20, v22 - 1, 0x20);
        Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_2;
        while ( asc_1481A7AE4[Size_2] );
      }
      else
      {
        Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_2;
        while ( asc_1481A7AE4[Size_2] );
      }
      sub_1403DFF30((void **)v20, "\r\n", (int)Size_2);
      v24 = *v20;
      hFile = (void *)a1[0xB];
      nNumberOfBytesToWrite = *((int *)*v20 + 0xFFFFFFFE);
      v52 = 0;
      if ( (unsigned int)sub_140539860(hFile, (__int64)v24, nNumberOfBytesToWrite, &v52) )
        __debugbreak();
    }
    v47 = __rdtsc();
    qword_149B4B878(&n0x5A00_1);
    if ( *((int *)*v20 + 0xFFFFFFFF) > 0 )
      sub_147605980(*v20 + 0xFFFFFFF8);
  }
  v27 = *v53;
  v28 = v53[1];
  v29 = v53[2];
  v30 = v53[3];
  if ( (v50 & 8) != 0 && ((a1[7] - a1[6]) & 0xFFFFFFFFFFFFFFFCuLL) != 0 )
  {
    switch ( *(_DWORD *)(a1[7] - 4) )
    {
      case 1:
        v30 = 1.0;
        if ( a5 )
        {
          v28 = 0.50199997;
          v27 = 0.0;
          v29 = 0.0;
          break;
        }
        v27 = 0.80400002;
        v28 = 0.361;
        goto LABEL_56;
      case 2:
        if ( a5 )
        {
          v27 = 0.60399997;
          v28 = 0.80400002;
          v29 = 0.19599999;
          v30 = 1.0;
        }
        else
        {
          v27 = 1.0;
          v28 = 0.271;
          v30 = 1.0;
          v29 = 0.0;
        }
        break;
      case 4:
        v30 = 1.0;
        if ( a5 )
        {
          v27 = 0.333;
          v28 = 0.41999999;
          v29 = 0.184;
          break;
        }
        v27 = 0.69800001;
        v28 = 0.133;
LABEL_56:
        v29 = v28;
        break;
    }
  }
  n0x5A00_1 = 0x5A00;
  v44 = 1;
  v45 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v46 = __rdtsc();
  qword_149B4B870(
    &n0x5A00_1,
    &word_149B3E360,
    "PersonalLogger::AddLine Insertion operation",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption/PersonalLogger.cpp",
    0x8F);
  n0x3FF_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v32 = word_149B3E360;
  v33 = *((_DWORD *)a1 + 0x13) + 1;
  Src_3 = (char *)Src;
  *((_DWORD *)a1 + 0x13) = v33;
  HIWORD(n0x5A00_1) = v32;
  do
    ++n0x3FF_1;
  while ( Src_3[n0x3FF_1] );
  v64[0] = 0;
  n1023_1 = 0;
  v35 = v64;
  n0x3FF = 0x3FF;
  if ( n0x3FF_1 > 0x3FF )
    n0x3FF_1 = 0x3FF;
  v63 = v64;
  if ( n0x3FF_1 )
  {
    sub_1403DE030((__int64 *)&n1023_1, n0x3FF_1);
    memcpy(v63, Src_3, n0x3FF_1);
    v35 = v63;
    n1023 = n1023_1;
  }
  v36 = a1[4];
  v69 = v33;
  v65 = v27;
  v66 = v28;
  v67 = v29;
  v68 = v30;
  sub_1403DE180(v36, v35, n1023);
  *(float *)(v36 + 0x418) = v65;
  *(float *)(v36 + 0x41C) = v66;
  *(float *)(v36 + 0x420) = v67;
  *(float *)(v36 + 0x424) = v68;
  *(_DWORD *)(v36 + 0x428) = v69;
  a1[4] += 0x430;
  v37 = a1[4];
  v38 = a1[1];
  if ( v37 == v38 )
  {
    v37 = *a1;
    a1[4] = *a1;
  }
  v39 = a1[3];
  if ( v37 == v39 )
  {
    a1[3] = v39 + 0x430;
    if ( v39 + 0x430 == v38 )
      a1[3] = *a1;
  }
  else
  {
    ++a1[5];
  }
  if ( v63 != v64 )
  {
    qword_149B3E668 += 0xFFFFFFFFFFFFFFFFuLL - n0x3FF;
    sub_147605980(v63);
  }
  v47 = __rdtsc();
  qword_149B4B878(&n0x5A00_1);
  if ( *((int *)Src_3 + 0xFFFFFFFF) > 0 )
    sub_147605980(Src_3 + 0xFFFFFFF8);
LABEL_73:
  v58 = __rdtsc();
  return qword_149B4B878(&n0x5A00);
}

// --- End Function: sub_14038F6D0 (0x14038F6D0) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140391F30 (0x140391F30) ---
char __fastcall sub_140391F30(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, v1, 0);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *(_QWORD *)(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls(*(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFLL);
}

// --- End Function: sub_140391F30 (0x140391F30) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_140393530 (0x140393530) ---
bool __fastcall sub_140393530(__int64 a1, int a2)
{
  return (a2 & *(_DWORD *)(a1 + 0x48)) == a2;
}

// --- End Function: sub_140393530 (0x140393530) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403A2CE0 (0x1403A2CE0) ---
__int64 sub_1403A2CE0(__int64 a1, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, a1);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
               qword_149B4FCB0,
               0,
               a1,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1403A2CE0 (0x1403A2CE0) ---

// --- Function: sub_1403A9130 (0x1403A9130) ---
char **sub_1403A9130(char **a1, const char *Format_1, ...)
{
  _QWORD *v4; // rdi
  int BufferCount_2; // eax
  int BufferCount_1; // ecx
  size_t BufferCount; // rbx
  va_list va; // [rsp+70h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = sub_1402A4380();
  BufferCount_2 = _stdio_common_vsprintf(*v4 | 2LL, 0, 0, Format_1, 0, va);
  if ( BufferCount_2 < 0 )
    BufferCount_2 = -1;
  BufferCount_1 = 0;
  if ( BufferCount_2 >= 0 )
    BufferCount_1 = BufferCount_2;
  BufferCount = BufferCount_1;
  sub_1403E9810(a1, BufferCount_1, 32);
  _stdio_common_vsprintf(*v4 | 1LL, *a1, BufferCount, Format_1, 0, va);
  return a1;
}

// --- End Function: sub_1403A9130 (0x1403A9130) ---

// --- Function: sub_1403AC6A0 (0x1403AC6A0) ---
unsigned __int64 *__fastcall sub_1403AC6A0(__int64 a1, unsigned __int64 *a2)
{
  __int64 v4; // rax
  unsigned __int64 v5; // r9
  unsigned __int64 *result; // rax
  char v7; // [rsp+30h] [rbp+8h] BYREF

  v7 = 0;
  v4 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)gEnv + 0x128LL))(gEnv, a1, &v7);
  v5 = *(unsigned __int16 *)(v4 + 2) | (unsigned __int64)(v7 != 0 ? 0x2000 : 0);
  result = a2;
  *a2 = a1 | (v5 << 0x30);
  return result;
}

// --- End Function: sub_1403AC6A0 (0x1403AC6A0) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403B9CB0 (0x1403B9CB0) ---
char __fastcall sub_1403B9CB0(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  _BYTE v8[72]; // [rsp+20h] [rbp-48h] BYREF

  v4 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)gEnv + 0x118LL))(gEnv, *(_QWORD *)(a1 + 0x38));
  if ( !v4 )
    return 0;
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 0x668LL))(v4);
  if ( !v5 )
    return 0;
  v6 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v5 + 0x150LL))(v5, v8, a1);
  *(_QWORD *)a2 = *(_QWORD *)v6;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(v6 + 8);
  *(_QWORD *)(a2 + 0x10) = *(_QWORD *)(v6 + 0x10);
  *(_QWORD *)(a2 + 0x18) = *(_QWORD *)(v6 + 0x18);
  *(_OWORD *)(a2 + 0x20) = *(_OWORD *)(v6 + 0x20);
  *(double *)(a2 + 0x30) = *(double *)(v6 + 0x30);
  return 1;
}

// --- End Function: sub_1403B9CB0 (0x1403B9CB0) ---

// --- Function: sub_1403BFA30 (0x1403BFA30) ---
bool __fastcall sub_1403BFA30(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BFA30 (0x1403BFA30) ---

// --- Function: sub_1403BFC90 (0x1403BFC90) ---
bool __fastcall sub_1403BFC90(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
  return v1 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v1 + 0x20LL))(v1);
}

// --- End Function: sub_1403BFC90 (0x1403BFC90) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149B4FCF8;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &byte_14819E9C2;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &byte_14819E9C2;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &byte_14819E9C2;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &byte_14819E9C2;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403CA4D0 (0x1403CA4D0) ---
unsigned __int64 __fastcall sub_1403CA4D0(__int64 a1, unsigned __int64 a2, signed __int64 *a3)
{
  signed __int64 v6; // rdi
  unsigned __int64 v7; // r15
  int v8; // ebp
  signed __int32 v9; // r12d
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  __int64 v12; // rbp
  unsigned __int64 v13; // r9
  int v14; // eax

  v6 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 0x20), a2);
  v7 = v6 + a2;
  if ( v6 + a2 > *(_QWORD *)(a1 + 0x28) )
  {
    v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x48) == v8 )
    {
      ++*(_DWORD *)(a1 + 0x4C);
    }
    else
    {
      v9 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x38), 1, 0);
      if ( v9 )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
          sub_1403C3410(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
        else
          sub_1403C3680(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
      }
      else
      {
        *(_QWORD *)(a1 + 0x40) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      }
      *(_DWORD *)(a1 + 0x48) = v8;
    }
    v10 = *(_QWORD *)(a1 + 0x28);
    if ( v7 > v10 )
    {
      v11 = (v7 - v10) % *(_QWORD *)(a1 + 0x30);
      v12 = *(_QWORD *)(a1 + 0x30) + v7 - v10 - v11;
      v13 = *(_QWORD *)(a1 + 0x30) + v7 - v11;
      if ( v13 > *(_QWORD *)(a1 + 8) )
        LogFatalError(
          "Not enough storage reserved for thread safe container. Allocating %zu, Page size %u, Required %zu, Reserved %zu",
          a2,
          *(_DWORD *)(a1 + 0x14),
          v13,
          *(_QWORD *)(a1 + 8));
      sub_14056DA40(a1, *(_QWORD *)a1 + *(_QWORD *)(a1 + 0x28), v12);
      *(_QWORD *)(a1 + 0x28) += v12;
    }
    v14 = *(_DWORD *)(a1 + 0x4C);
    if ( v14 )
    {
      *(_DWORD *)(a1 + 0x4C) = v14 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x48) = 0xFFFFFFFF;
      sub_1402DB100(a1 + 0x38);
    }
  }
  if ( a3 )
    *a3 = v6;
  return v7 + *(_QWORD *)a1 - a2;
}

// --- End Function: sub_1403CA4D0 (0x1403CA4D0) ---

// --- Function: sub_1403CB300 (0x1403CB300) ---
double __fastcall sub_1403CB300(__int64 a1, signed __int64 a2, const char *a3, const char *a4, char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403CB380(a1, a2, a3, a4);
  else
    return sub_1403CB5B0(a1, a2, a3, a4);
}

// --- End Function: sub_1403CB300 (0x1403CB300) ---

// --- Function: sub_1403CB380 (0x1403CB380) ---
double __fastcall sub_1403CB380(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  _BYTE v19[16]; // [rsp+30h] [rbp-29h] BYREF
  int n5632; // [rsp+40h] [rbp-19h] BYREF
  __int64 v21; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v23; // [rsp+50h] [rbp-9h]
  unsigned __int64 v24; // [rsp+58h] [rbp-1h]
  __int64 v25; // [rsp+60h] [rbp+7h]
  __int64 v26; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 284LL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 248LL))(v4, v19, &v27);
  if ( (a2 & 0x200000) == 0 )
    return result;
  v12 = (unsigned __int64)v11 << 32;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 292) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n5632 = 5632;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v21 = 1;
      n2 = 2;
      v23 = __rdtsc();
      qword_149B4B870(
        &n5632,
        &word_149B3E384,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        146);
      v15 = word_149B3E384;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(v10 + 292) = -1;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n5632 = 5632;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  n2 = 2;
  v23 = __rdtsc();
  qword_149B4B870(
    &n5632,
    &word_149B3E388,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    177);
  v15 = word_149B3E388;
LABEL_10:
  HIWORD(n5632) = v15;
  qword_149B4B8B0("Lock: %s", a4);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &byte_14819E9C2;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
  qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
  qword_149B4B8B0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 232LL))(v4, v11);
  v24 = __rdtsc();
  return qword_149B4B878(&n5632);
}

// --- End Function: sub_1403CB380 (0x1403CB380) ---

// --- Function: sub_1403CB5B0 (0x1403CB5B0) ---
double __fastcall sub_1403CB5B0(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int *p_n5632; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  int v15; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v16[3]; // [rsp+34h] [rbp-65h] BYREF
  int n5632_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v18; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+50h] [rbp-49h]
  unsigned __int64 v21; // [rsp+58h] [rbp-41h]
  __int64 v22; // [rsp+60h] [rbp-39h]
  __int64 v23; // [rsp+68h] [rbp-31h]
  int n5632; // [rsp+90h] [rbp-9h] BYREF
  __int64 v25; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v27; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v28; // [rsp+A8h] [rbp+Fh]
  __int64 v29; // [rsp+B0h] [rbp+17h]
  __int64 v30; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 296LL))(qword_149B4FCF8, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n5632 = 5632;
        v25 = 1;
        n2 = 2;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v27 = __rdtsc();
        qword_149B4B870(
          &n5632,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          98);
        HIWORD(n5632) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", a4);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &byte_14819E9C2;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v16[0] = v10;
        qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n5632 = &n5632;
        v28 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return result;
    }
    n5632_1 = 5632;
    v18 = 1;
    n2_1 = 2;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v20 = __rdtsc();
    qword_149B4B870(
      &n5632_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      74);
    HIWORD(n5632_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", a4);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &byte_14819E9C2;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
    qword_149B4B8B0("Caller: %s", a3);
    v15 = v6;
    qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n5632 = &n5632_1;
    v21 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_n5632);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: sub_1403CB5B0 (0x1403CB5B0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 192LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 16) & (unsigned int)(v9 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 = (v5 << 16) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 284) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCF8 + 216LL))(qword_149B4FCF8);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &byte_14819E9C2;
  *(_QWORD *)(a1 + 8) = &byte_14819E9C2;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403DE030 (0x1403DE030) ---
_BYTE *__fastcall sub_1403DE030(__int64 *a1, __int64 n1023_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0x3FF; // rcx

  result = a1 + 3;
  if ( n1023_1 )
  {
    allocSize = n1023_1 + 1;
    if ( (unsigned __int64)(n1023_1 + 1) <= 0x400 )
    {
      n0x3FF = 0x3FF;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3E668 += allocSize;
      n0x3FF = n1023_1;
    }
    a1[1] = n0x3FF;
    *a1 = n1023_1;
    a1[2] = (__int64)result;
    result[n1023_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0x3FF;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1403DE030 (0x1403DE030) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403DE180 (0x1403DE180) ---
__int64 __fastcall sub_1403DE180(__int64 a1, const void *a2, size_t n1023)
{
  size_t n1023_1; // r8
  const void *v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  n1023_1 = *(_QWORD *)(a1 + 8);
  if ( n1023 > n1023_1 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3E668 += 0xFFFFFFFFFFFFFFFFuLL - n1023_1;
      sub_147605980(v7);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x3FF;
    sub_1403DE030((__int64 *)a1, n1023);
  }
  memmove(*(void **)(a1 + 0x10), a2, n1023);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n1023;
  *(_BYTE *)(n1023 + result) = 0;
  return result;
}

// --- End Function: sub_1403DE180 (0x1403DE180) ---

// --- Function: sub_1403DE230 (0x1403DE230) ---
void *__fastcall sub_1403DE230(void **a1, void *a2, size_t Size)
{
  _BYTE *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = *a1;
  if ( Size > *((int *)v5 - 1) )
  {
    v7 = (int *)(v5 - 8);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = (char *)&qword_149B3B33C + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, Size);
  *((_DWORD *)*a1 - 2) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403DE230 (0x1403DE230) ---

// --- Function: sub_1403DFF30 (0x1403DFF30) ---
void __fastcall sub_1403DFF30(void **a1, char *a2, size_t Size)
{
  _BYTE *v4; // rbp
  size_t Size_1; // r13
  unsigned __int64 n8; // r15
  _DWORD *v9; // rax
  char *v10; // rcx

  if ( Size )
  {
    v4 = *a1;
    Size_1 = *((int *)*a1 + 0xFFFFFFFE);
    if ( Size + Size_1 <= *((int *)*a1 + 0xFFFFFFFF) )
    {
      if ( &v4[Size_1] != a2 )
        memcpy(&v4[Size_1], a2, Size);
      *((_DWORD *)*a1 + 0xFFFFFFFE) += Size;
      *((_BYTE *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= Size + Size_1 )
        n8 = Size + Size_1;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        v9 = (_DWORD *)allocWithProfilerInfo(n8 + 9, 0);
        *a1 = v9 + 2;
        *v9 = n8;
        v9[1] = n8;
        *((_BYTE *)*a1 + n8) = 0;
        if ( *a1 != v4 )
          memcpy(*a1, v4, Size_1);
        v10 = (char *)*a1 + Size_1;
        if ( v10 != a2 )
          memcpy(v10, a2, Size);
        *((_DWORD *)*a1 + 0xFFFFFFFE) = Size + Size_1;
        *((_BYTE *)*a1 + Size_1 + Size) = 0;
      }
      if ( *((int *)v4 + 0xFFFFFFFF) > 0 )
        sub_147605980(v4 + 0xFFFFFFF8);
    }
  }
}

// --- End Function: sub_1403DFF30 (0x1403DFF30) ---

// --- Function: sub_1403E0AA0 (0x1403E0AA0) ---
char *__fastcall sub_1403E0AA0(_QWORD *a1)
{
  char *result; // rax

  result = (char *)&qword_149B3B33C + 4;
  *a1 = (char *)&qword_149B3B33C + 4;
  return result;
}

// --- End Function: sub_1403E0AA0 (0x1403E0AA0) ---

// --- Function: sub_1403E1FA0 (0x1403E1FA0) ---
void *__fastcall sub_1403E1FA0(void *a1, const void *a2, size_t Size)
{
  void *result; // rax

  if ( a1 != a2 )
    return memcpy(a1, a2, Size);
  return result;
}

// --- End Function: sub_1403E1FA0 (0x1403E1FA0) ---

// --- Function: sub_1403E2E40 (0x1403E2E40) ---
__int64 __fastcall sub_1403E2E40(__int64 a1, __int64 a2)
{
  HMODULE hModule; // rax
  FARPROC ProcAddress; // rbx
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  ProcAddress = GetProcAddress(hModule, "___cigFetchNonWrapFunction___");
  if ( !ProcAddress )
  {
    hModule_1 = LoadLibraryA(0);
    if ( hModule_1 )
      ProcAddress = GetProcAddress(hModule_1, "___cigFetchNonWrapFunction___");
  }
  return ((__int64 (__fastcall *)(__int64, __int64))ProcAddress)(a1, a2);
}

// --- End Function: sub_1403E2E40 (0x1403E2E40) ---

// --- Function: sub_1403E3510 (0x1403E3510) ---
__int64 __fastcall sub_1403E3510(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __m128i v5; // rt0
  __m128i v7; // [rsp+10h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    v5.m128i_i64[0] = v2.m128i_i64[0];
    v5.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, epi64 + 1, *(_QWORD *)v2.m128i_i64[0], v5.m128i_i64);
    v4 = v5.m128i_i64[0];
    v7 = v5;
    if ( *(_OWORD *)&v5 == __PAIR128__(epi64, v2.m128i_u64[0]) )
      break;
    v2 = v7;
    if ( !v4 )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_1403E3510 (0x1403E3510) ---

// --- Function: sub_1403E35D0 (0x1403E35D0) ---
__int64 __fastcall sub_1403E35D0(volatile signed __int64 *a1, _QWORD *a2)
{
  __m128i v2; // rt0
  __m128i i; // xmm0
  signed __int64 epi64; // r9
  __int64 result; // rax
  __m128i v6; // rt0
  __m128i v7; // [rsp+10h] [rbp-28h]

  v2 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v2.m128i_i64);
  for ( i = v2; ; i = v7 )
  {
    if ( a2 == (_QWORD *)i.m128i_i64[0] )
      __debugbreak();
    epi64 = _mm_extract_epi64(i, 1);
    *a2 = i.m128i_i64[0];
    v6.m128i_i64[0] = i.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, epi64 + 1, (signed __int64)a2, v6.m128i_i64);
    result = v6.m128i_i64[0];
    v7 = v6;
    if ( *(_OWORD *)&v6 == __PAIR128__(epi64, i.m128i_u64[0]) )
      break;
  }
  return result;
}

// --- End Function: sub_1403E35D0 (0x1403E35D0) ---

// --- Function: EnterCriticalSection (0x1403E3690) ---
// attributes: thunk
void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_EnterCriticalSection(lpCriticalSection);
}

// --- End Function: EnterCriticalSection (0x1403E3690) ---

// --- Function: LeaveCriticalSection (0x1403E3CD0) ---
// attributes: thunk
void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
  __imp_LeaveCriticalSection(lpCriticalSection);
}

// --- End Function: LeaveCriticalSection (0x1403E3CD0) ---

// --- Function: sub_1403E40C0 (0x1403E40C0) ---
const char *__fastcall sub_1403E40C0(const char **a1, const char *a2, const char **a3, const char *a4)
{
  int v8; // eax
  const char *Str1; // rcx
  const char *v10; // rcx
  const char *v11; // rax
  int n0x10041; // r15d
  const char *result; // rax
  char n0x41; // r8
  const char *i; // r14
  const char *v16; // rcx
  const char *v17; // rcx
  const char *v18; // rdx
  int n0x45; // r8d
  char n0x41_1; // r8

  v8 = strncmp(*a3, "class ", 6u);
  Str1 = *a3;
  if ( v8 )
  {
    if ( !strncmp(Str1, "struct ", 7u) )
      *a3 += 7;
  }
  else
  {
    *a3 = Str1 + 6;
  }
  v10 = *a3;
  if ( **a3 == 0x20 )
  {
    v11 = *a3;
    do
    {
      if ( v11 == a4 )
        break;
      v10 = v11 + 1;
      *a3 = v11 + 1;
      v11 = v10;
    }
    while ( *v10 == 0x20 );
  }
  n0x10041 = 0x10041;
  if ( (unsigned __int8)(*v10 - 0x43) <= 0x10u && _bittest(&n0x10041, (char)(*v10 - 0x43))
    || (result = v10, *v10 == 0x45) )
  {
    n0x41 = v10[1];
    result = v10;
    if ( n0x41 >= 0x41 && n0x41 <= 0x5A )
    {
      *a3 = v10 + 1;
      result = v10 + 1;
    }
  }
  if ( result < a4 )
  {
    for ( i = *a1; *a1 != a2; ++*a1 )
    {
      result = *a3;
      if ( *a3 == a4 )
        break;
      if ( *result == 0x20 )
      {
        v16 = *a3;
        do
        {
          if ( v16 == a4 )
            break;
          result = v16 + 1;
          *a3 = v16 + 1;
          v16 = result;
        }
        while ( *result == 0x20 );
      }
      if ( result == a4 )
        break;
      v17 = result;
      if ( *result == 0x3A && result[1] == 0x3A )
      {
        if ( (*a3 = result + 2,
              *a1 = i,
              v18 = *a3,
              n0x45 = *(unsigned __int8 *)*a3,
              result = (const char *)(unsigned int)(n0x45 - 0x43),
              (unsigned __int8)(n0x45 - 0x43) <= 0x10u)
          && (result = (const char *)(unsigned int)(char)(n0x45 - 0x43), _bittest(&n0x10041, (unsigned int)result))
          || (v17 = *a3, (_BYTE)n0x45 == 0x45) )
        {
          n0x41_1 = v18[1];
          result = v18 + 1;
          v17 = *a3;
          if ( n0x41_1 >= 0x41 && n0x41_1 <= 0x5A )
          {
            *a3 = result;
            v17 = v18 + 1;
          }
        }
      }
      if ( v17 >= a4 )
        break;
      if ( *v17 == 0x3C )
      {
        *(*a1)++ = 0x3C;
        ++*a3;
        sub_1403E40C0(a1, a2, a3, a4);
      }
      else if ( *v17 == 0x3E )
      {
        result = *a1;
        **a1 = 0;
        return result;
      }
      result = (const char *)*(unsigned __int8 *)*a3;
      **a1 = (char)result;
      ++*a3;
    }
  }
  return result;
}

// --- End Function: sub_1403E40C0 (0x1403E40C0) ---

// --- Function: sub_1403E4370 (0x1403E4370) ---
_QWORD *__fastcall sub_1403E4370(__int64 a1)
{
  _QWORD *v1; // rbx
  _QWORD *v3; // rdi
  _QWORD *result; // rax

  v1 = *(_QWORD **)a1;
  v3 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v3 )
  {
    do
    {
      if ( *(int *)(*v1 - 4LL) > 0 )
        sub_147605980((const void *)(*v1 - 8LL));
      ++v1;
    }
    while ( v1 != v3 );
    result = *(_QWORD **)a1;
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  }
  return result;
}

// --- End Function: sub_1403E4370 (0x1403E4370) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 sub_1403E4B50()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4B60 (0x1403E4B60) ---
_OWORD *__fastcall sub_1403E4B60(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)allocWithProfilerInfo_w(0x10u);
  if ( result )
    *result = *a1;
  return result;
}

// --- End Function: sub_1403E4B60 (0x1403E4B60) ---

// --- Function: sub_1403E4B90 (0x1403E4B90) ---
_QWORD *__fastcall sub_1403E4B90(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A3D30(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)allocWithProfilerInfo_w(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E4B90 (0x1403E4B90) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
__int64 __fastcall sub_1403E4E60(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4E70 (0x1403E4E70) ---
void __fastcall sub_1403E4E70(const void *a1)
{
  sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E70 (0x1403E4E70) ---

// --- Function: sub_1403E4E80 (0x1403E4E80) ---
__int64 __fastcall sub_1403E4E80(const void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_1402A3D30(a1[2]);
    return sub_1402A3D30(a1);
  }
  return result;
}

// --- End Function: sub_1403E4E80 (0x1403E4E80) ---

// --- Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403E7630) ---
bool __fastcall FH4::HandlerMap4::iterator::operator==(__int64 a1, __int64 a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

// --- End Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403E7630) ---

// --- Function: sub_1403E7650 (0x1403E7650) ---
bool __fastcall sub_1403E7650(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E7650 (0x1403E7650) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 - 1) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 - 2)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 - 2));
  memset(&(*a1)[*((int *)v3 - 2)], Val_1, Size);
  if ( *((int *)v3 - 1) > 0 )
    sub_147605980(v3 - 8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1403EB0E0 (0x1403EB0E0) ---
__int64 __fastcall sub_1403EB0E0(__int64 a1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EB0E0 (0x1403EB0E0) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n12; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12 = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 = 12;
      if ( (int)n12_1 <= 12 )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n12 + a2), n12_1 - (unsigned int)n12);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v8;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 19;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v10;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 18;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12 += v14;
    if ( n12 < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n12 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return (unsigned int)-1;
  return (unsigned int)n12;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB580 (0x1403EB580) ---
__int64 __fastcall sub_1403EB580(__int64 a1, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB580 (0x1403EB580) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: _snprintf_s (0x1403ECF60) ---
int snprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = (unsigned __int64 *)sub_1402A4380();
  result = _stdio_common_vsnprintf_s(*v8, DstBuf, SizeInBytes, MaxCount, Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: _snprintf_s (0x1403ECF60) ---

// --- Function: sub_1403F6100 (0x1403F6100) ---
__int64 __fastcall sub_1403F6100(__int64 a1, __int64 a2, __int64 a3)
{
  void **v3; // rsi
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  v3 = (void **)(a1 + 8);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_WORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0x3A) = 0;
  if ( *(_QWORD *)a3 != *(_QWORD *)(a3 + 8) )
  {
    *(_QWORD *)a1 = *sub_1404046E0(a1, &v7, a2);
    if ( v3 != (void **)a3 )
      sub_140306B60(v3, *(char **)a3, (__int64)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 4);
  }
  return a1;
}

// --- End Function: sub_1403F6100 (0x1403F6100) ---

// --- Function: sub_1404046E0 (0x1404046E0) ---
__int64 *__fastcall sub_1404046E0(__int64 a1, __int64 *a2, __int64 a3)
{
  char v3; // bp
  __int64 v5; // rbx
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 (__fastcall *v10)(__int64, _BYTE *, __int64 *); // r14
  __int16 n0xFFFF; // cx
  __int64 v12; // rdi
  __int64 v13; // rax
  __int16 n4; // cx
  __int64 v15; // rax
  __int64 v16; // rax
  unsigned __int64 *v17; // rax
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 (__fastcall *v20)(__int64, _BYTE *, __int64 *); // rbp
  __int16 n0xFFFF_1; // cx
  char v22; // di
  _BYTE v23[8]; // [rsp+20h] [rbp-48h] BYREF
  _BYTE v24[8]; // [rsp+28h] [rbp-40h] BYREF
  _BYTE v25[8]; // [rsp+30h] [rbp-38h] BYREF
  _BYTE v26[8]; // [rsp+38h] [rbp-30h] BYREF
  __int64 v27; // [rsp+88h] [rbp+20h] BYREF

  v3 = 0;
  LODWORD(v27) = 0;
  v5 = a3;
  if ( gEnv )
  {
    v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv, a3);
    v9 = v8;
    if ( v8 )
    {
      v10 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v8 + 0x340LL);
      n0xFFFF = n0xFFFF_21;
      if ( n0xFFFF_21 == (__int16)0xFFFF )
      {
        n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                      + 0x10LL))(
                              qword_149B4FC88,
                              v23,
                              "IEntityComponentObjectContainer");
        n0xFFFF_21 = n0xFFFF;
      }
      LOWORD(v27) = n0xFFFF;
      v12 = *(_QWORD *)v10(v9, v24, &v27);
      v27 = v12;
      if ( v12 )
      {
        v13 = sub_1403B4B50(v12 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(v13 + 4);
        if ( n4 != 4
          && *(_WORD *)(v13 + 2) == (HIWORD(v12) & 0xFFF)
          && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v27)) )
        {
          (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(v12 & 0xFFFFFFFFFFFFLL) + 0x5D8LL))(
            v12 & 0xFFFFFFFFFFFFLL,
            &v27);
          if ( v27 )
            v5 = v27;
        }
      }
    }
    if ( *(_BYTE *)(a1 + 0x39) )
      goto LABEL_24;
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
    v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x1D0LL))(v15);
    v3 = 1;
    if ( *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64, _QWORD))(*(_QWORD *)v16 + 0x118LL))(
                      v16,
                      v24,
                      v5,
                      0) )
      goto LABEL_24;
    v17 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)gEnv + 0x120LL))(
                                gEnv,
                                v25,
                                v5);
    if ( !validateHandleAccess(v17) )
      goto LABEL_24;
    v18 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv, v5);
    v19 = v18;
    if ( v18 )
    {
      v20 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v18 + 0x340LL);
      n0xFFFF_1 = n0xFFFF_22;
      if ( n0xFFFF_22 == (__int16)0xFFFF )
      {
        n0xFFFF_1 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                        + 0x10LL))(
                                qword_149B4FC88,
                                v23,
                                "IEntityComponentSuperGUID");
        n0xFFFF_22 = n0xFFFF_1;
      }
      LOWORD(v27) = n0xFFFF_1;
      v18 = *(_QWORD *)v20(v19, v26, &v27);
    }
    v27 = v18;
    v3 = 1;
    if ( is_valid_handle_typeA(&v27) || !byte_149B4FE80 )
LABEL_24:
      v22 = 1;
    else
      v22 = 0;
    if ( (v3 & 1) != 0 )
      sub_1404EAD00(v24);
    if ( v22 )
      *a2 = v5;
    else
      *a2 = 0;
    return a2;
  }
  else
  {
    *a2 = a3;
    return a2;
  }
}

// --- End Function: sub_1404046E0 (0x1404046E0) ---

// --- Function: sub_14040B4F0 (0x14040B4F0) ---
_QWORD *__fastcall sub_14040B4F0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r12
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 (__fastcall *v5)(__int64, unsigned __int64 *, __int128 *); // r9
  __int64 v6; // rax
  __int64 v7; // rax
  _QWORD *v8; // rsi
  _QWORD *v9; // r15
  char v10; // bp
  unsigned __int64 v11; // rbx
  __int64 (__fastcall *v12)(unsigned __int64, __int128 *, unsigned __int64 *); // r14
  __int16 n0xFFFF; // ax
  __int64 v14; // rbx
  __int64 v15; // rax
  __int16 n4; // dx
  __int64 v17; // rax
  __int64 v18; // rax
  unsigned __int64 v20; // [rsp+20h] [rbp-68h] BYREF
  __int64 v21; // [rsp+28h] [rbp-60h] BYREF
  __int128 v22; // [rsp+30h] [rbp-58h] BYREF
  __int64 v23; // [rsp+90h] [rbp+8h] BYREF
  _QWORD *v24; // [rsp+98h] [rbp+10h]
  unsigned __int64 v25; // [rsp+A0h] [rbp+18h] BYREF
  char v26; // [rsp+A8h] [rbp+20h] BYREF

  v24 = a2;
  v23 = a1;
  v2 = a2;
  v3 = a1;
  if ( !*(_QWORD *)a1 )
    goto LABEL_33;
  if ( *(_BYTE *)(a1 + 0x38) )
  {
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0xC0LL))(gEnv);
    v5 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *, __int128 *))(*(_QWORD *)v4 + 0x48LL);
    v22 = *(_OWORD *)*(_QWORD *)(v3 + 8);
    *(_QWORD *)v3 = *(_QWORD *)v5(v4, &v25, &v22);
    memmove(
      *(void **)(v3 + 8),
      (const void *)(*(_QWORD *)(v3 + 8) + 0x10LL),
      *(_QWORD *)(v3 + 0x10) - (*(_QWORD *)(v3 + 8) + 0x10LL));
    *(_QWORD *)(v3 + 0x10) -= 0x10LL;
  }
  else if ( *(_BYTE *)(a1 + 0x39) )
  {
    (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)gEnv + 0x120LL))(gEnv, &v25);
    if ( !validateHandleAccess(&v25) )
      goto LABEL_33;
    *(_QWORD *)v3 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(v25 & 0xFFFFFFFFFFFFLL)
                                                                                   + 0x660LL))(
                                 v25 & 0xFFFFFFFFFFFFLL,
                                 &v26);
    *(_BYTE *)(v3 + 0x39) = 0;
  }
  if ( *(_QWORD *)(v3 + 8) != *(_QWORD *)(v3 + 0x10) )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x1D0LL))(v6);
    *(_QWORD *)v3 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, unsigned __int64 *, _QWORD, __int64))(*(_QWORD *)v7 + 0x158LL))(
                                 v7,
                                 &v25,
                                 *(_QWORD *)v3,
                                 v3 + 8);
  }
  if ( *(_QWORD *)(v3 + 8) == *(_QWORD *)(v3 + 0x10) && *(_QWORD *)(v3 + 0x20) != *(_QWORD *)(v3 + 0x28) )
  {
    if ( *(_QWORD *)v3 )
    {
      (*(void (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)gEnv + 0x120LL))(gEnv, &v20);
      if ( validateHandleAccess(&v20) )
      {
        if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v20 & 0xFFFFFFFFFFFFLL) + 0x50LL))(v20 & 0xFFFFFFFFFFFFLL) )
        {
          v8 = *(_QWORD **)(v3 + 0x20);
          v9 = *(_QWORD **)(v3 + 0x28);
          if ( v8 != v9 )
          {
            do
            {
              v10 = 0;
              if ( validateHandleAccess(&v20) )
              {
                v11 = v20 & 0xFFFFFFFFFFFFLL;
                v12 = *(__int64 (__fastcall **)(unsigned __int64, __int128 *, unsigned __int64 *))(*(_QWORD *)(v20 & 0xFFFFFFFFFFFFLL)
                                                                                                 + 0x340LL);
                n0xFFFF = n0xFFFF_23;
                if ( n0xFFFF_23 == (__int16)0xFFFF )
                {
                  n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                               + 0x10LL))(
                                        qword_149B4FC88,
                                        &v26,
                                        "IItemPortContainer");
                  n0xFFFF_23 = n0xFFFF;
                }
                LOWORD(v25) = n0xFFFF;
                v14 = *(_QWORD *)v12(v11, &v22, &v25);
                v21 = v14;
                if ( v14 )
                {
                  v15 = sub_1403B4B50(v14 & 0xFFFFFFFFFFFFLL);
                  n4 = *(_WORD *)(v15 + 4);
                  if ( n4 != 4
                    && *(_WORD *)(v15 + 2) == (HIWORD(v14) & 0xFFF)
                    && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v21)) )
                  {
                    v17 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(v14 & 0xFFFFFFFFFFFFLL) + 0x580LL))(
                            v14 & 0xFFFFFFFFFFFFLL,
                            *v8);
                    if ( v17 )
                    {
                      v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x40LL))(v17);
                      if ( v18 )
                      {
                        v10 = 1;
                        v20 = *(_QWORD *)(v18 + 8);
                      }
                    }
                  }
                }
              }
              ++v8;
            }
            while ( v8 != v9 );
            v3 = v23;
            v2 = v24;
            if ( v10 )
            {
              sub_1403E4370(v23 + 0x20);
              *(_QWORD *)v3 = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)(v20 & 0xFFFFFFFFFFFFLL)
                                                                                                + 8LL))(
                                           v20 & 0xFFFFFFFFFFFFLL,
                                           &v23);
            }
          }
        }
      }
    }
  }
  if ( *(_QWORD *)(v3 + 8) == *(_QWORD *)(v3 + 0x10) && *(_QWORD *)(v3 + 0x20) == *(_QWORD *)(v3 + 0x28) )
  {
    *v2 = *(_QWORD *)v3;
    return v2;
  }
LABEL_33:
  *v2 = 0;
  return v2;
}

// --- End Function: sub_14040B4F0 (0x14040B4F0) ---

// --- Function: sub_14042B510 (0x14042B510) ---
void __fastcall sub_14042B510(__int64 *a1, __int64 a2, int a3, char a4)
{
  __int64 v4; // rdi
  unsigned __int8 *v7; // r8
  __int64 v8; // rdx
  __int64 v9; // rax
  int v10; // ecx
  __int64 v11; // rax
  _DWORD *v12; // rcx
  int v13; // eax
  int v14; // esi
  __int64 v15; // rcx
  unsigned __int64 *v16; // rax
  unsigned __int64 *v17; // rcx
  __int64 *v18; // rax
  unsigned __int64 n0xF; // rax
  int *p_n0xF2; // [rsp+60h] [rbp-29h] BYREF
  _BYTE *v21; // [rsp+68h] [rbp-21h]
  _QWORD v22[2]; // [rsp+70h] [rbp-19h] BYREF
  const void *v23; // [rsp+80h] [rbp-9h]
  _QWORD v24[2]; // [rsp+88h] [rbp-1h] BYREF
  __int128 v25; // [rsp+98h] [rbp+Fh] BYREF
  int n0xF2; // [rsp+A8h] [rbp+1Fh] BYREF
  int n0x1C; // [rsp+ACh] [rbp+23h]
  int n0x60; // [rsp+B0h] [rbp+27h]
  _BYTE v29[4]; // [rsp+B4h] [rbp+2Bh] BYREF

  v4 = (unsigned int)a3;
  if ( a3 < 0 || a3 >= (int)((a1[3] - a1[2]) / 0x38) )
  {
    p_n0xF2 = &n0xF2;
    n0xF2 = 0xF2;
    v21 = v29;
    n0x1C = 0x1C;
    n0x60 = 0x60;
    v14 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)&p_n0xF2,
            (__int64)"Invalid Mannequin Tag",
            "Invalid Tag id: $$");
    if ( (v14 & 0xFFFFF) != 0 )
    {
      v15 = *a1;
      p_n0xF2 = 0;
      v22[0] = 0;
      v23 = 0;
      LODWORD(v21) = v4;
      v22[1] = v15;
      v16 = sub_1404B3EA0();
      v17 = v16;
      if ( v16 )
      {
        n0xF = *v16;
        if ( n0xF > 0xF )
          n0xF = 0xF;
        v18 = (__int64 *)&v17[0x16 * n0xF + 1];
      }
      else
      {
        v18 = &dword_149B45F40;
      }
      n0xF2 = 0xF2;
      v24[0] = &n0xF2;
      v24[1] = v29;
      n0x1C = 0x1C;
      n0x60 = 0x60;
      v25 = 0;
      sub_1404424A0(
        3,
        (__int64)v24,
        "Invalid Mannequin Tag",
        (__int64)"Invalid Tag id: $$",
        2,
        v14,
        &v25,
        0,
        (__int64)v18,
        v22,
        &p_n0xF2);
      sub_1402A3D30(v23);
    }
  }
  else
  {
    v7 = (unsigned __int8 *)(a1[0x23] + 8LL * (unsigned int)a3);
    v8 = *(int *)(0x38 * v4 + a1[2] + 0x2C);
    if ( (_DWORD)v8 == 0xFFFFFFFF )
    {
      v12 = (_DWORD *)(a2 + 4LL * *v7);
      v13 = *((_DWORD *)v7 + 1);
      if ( a4 )
        goto LABEL_7;
      *v12 &= ~v13;
    }
    else
    {
      v9 = a1[0x26];
      v10 = *(_DWORD *)(v9 + 8 * v8 + 4);
      v11 = *(unsigned __int8 *)(v9 + 8 * v8);
      if ( ((v10 & *(_DWORD *)(a2 + 4 * v11)) == *((_DWORD *)v7 + 1)) != a4 )
      {
        *(_DWORD *)(a2 + 4 * v11) &= ~v10;
        if ( a4 )
        {
          v12 = (_DWORD *)(a2 + 4LL * *v7);
          v13 = *((_DWORD *)v7 + 1);
LABEL_7:
          *v12 |= v13;
        }
      }
    }
  }
}

// --- End Function: sub_14042B510 (0x14042B510) ---

// --- Function: sub_1404424A0 (0x1404424A0) ---
void __fastcall sub_1404424A0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v12; // rsp
  const char *p_null; // rcx
  unsigned __int64 v14; // rax
  __int64 v15; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  _QWORD *v20; // [rsp+A0h] [rbp-E0h]
  const char *p_Asset; // [rsp+A8h] [rbp-D8h]
  __int64 v22; // [rsp+B0h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+B8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+C0h] [rbp-C0h]
  __int64 v25; // [rsp+C8h] [rbp-B8h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+D0h] [rbp-B0h]
  __int64 v27; // [rsp+D8h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E4E80)(const void **); // [rsp+E0h] [rbp-A0h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+E8h] [rbp-98h]
  unsigned __int64 v30; // [rsp+F0h] [rbp-90h]
  char v31; // [rsp+F8h] [rbp-88h]
  char v32; // [rsp+F9h] [rbp-87h]
  __int64 n0x18; // [rsp+100h] [rbp-80h]
  unsigned __int64 v34; // [rsp+108h] [rbp-78h]
  _QWORD *v35; // [rsp+110h] [rbp-70h]
  const char *p_Int; // [rsp+118h] [rbp-68h]
  __int64 v37; // [rsp+120h] [rbp-60h]
  __int64 (__fastcall *p_sub_1405048A0)(__int64, __int64, __int64); // [rsp+128h] [rbp-58h]
  __int64 (__fastcall *p_sub_1405048A0_1)(__int64, __int64, __int64); // [rsp+130h] [rbp-50h]
  __int64 v40; // [rsp+138h] [rbp-48h]
  bool (__fastcall *p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z)(__int64, __int64); // [rsp+140h] [rbp-40h]
  __int64 v42; // [rsp+148h] [rbp-38h]
  void (__fastcall *p_sub_1403E4E70)(const void *); // [rsp+150h] [rbp-30h]
  _OWORD *(__fastcall *p_sub_1403E4B60)(_OWORD *); // [rsp+158h] [rbp-28h]
  unsigned __int64 v45; // [rsp+160h] [rbp-20h]
  char v46; // [rsp+168h] [rbp-18h]
  char v47; // [rsp+169h] [rbp-17h]
  __int64 n0x10; // [rsp+170h] [rbp-10h]
  __int64 n0x15; // [rsp+178h] [rbp-8h]

  v12 = alloca(0x150);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  p_Asset = "Asset";
  v20 = a10;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v32 = 1;
  v22 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v25 = 0;
  v27 = 0;
  v30 = 0xFFFFFFFFFFFFFFFFuLL;
  v31 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  v14 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v14;
  while ( p_null[v14] );
  v34 = v14;
  v35 = a11;
  p_Int = "Int";
  v47 = 0;
  v37 = *a11;
  p_sub_1405048A0 = sub_1405048A0;
  p_sub_1405048A0_1 = sub_1405048A0;
  p_??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z = FH4::HandlerMap4::iterator::operator==;
  p_sub_1403E4E70 = sub_1403E4E70;
  p_sub_1403E4B60 = sub_1403E4B60;
  LODWORD(v15) = a6;
  v40 = 0;
  v42 = 0;
  v45 = 0xFFFFFFFFFFFFFFFFuLL;
  v46 = 0;
  n0x10 = 0x10;
  n0x15 = 0x15;
  ReportTelemetryEvent(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 3u, a5, v15, a7, a8);
}

// --- End Function: sub_1404424A0 (0x1404424A0) ---

// --- Function: sub_140450060 (0x140450060) ---
__int64 __fastcall sub_140450060(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  int v10; // eax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 0x2D;
    a4 = -a4 & 0x7FFFFFFF;
    v6 = 1;
  }
  else
  {
    v6 = 0xFFFFFFFF;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
      return 0xFFFFFFFFLL;
    ++v6;
    v10 = a4 % 0xA;
    a4 /= 0xA;
    *(_BYTE *)(v8 + v4) = v10 + 0x30;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_140450060 (0x140450060) ---

// --- Function: sub_140453020 (0x140453020) ---
__int64 __fastcall sub_140453020(__int64 a1, __int64 a2, int a3)
{
  unsigned __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  *(_QWORD *)a1 = *sub_1403AC6A0(a2, &v6);
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 0xC) = 9;
  sub_140486F20((__int64 *)a1);
  return a1;
}

// --- End Function: sub_140453020 (0x140453020) ---

// --- Function: sub_140459070 (0x140459070) ---
__int64 __fastcall sub_140459070(__int64 a1, int a2, __m256i *a3, int a4, __int64 a5, __int64 a6)
{
  __m256i v6; // ymm0
  __int64 result; // rax

  v6 = *a3;
  *(_QWORD *)a1 = a5;
  *(_QWORD *)(a1 + 8) = a6;
  result = a1;
  *(__m256i *)(a1 + 0x14) = v6;
  *(_DWORD *)(a1 + 0x10) = a2;
  *(_OWORD *)(a1 + 0x34) = 0;
  *(_DWORD *)(a1 + 0x44) = a4;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140459070 (0x140459070) ---

// --- Function: sub_1404590B0 (0x1404590B0) ---
__m256i *__fastcall sub_1404590B0(__m256i *a1, __m256i *a2, __int32 a3)
{
  __m256i *result; // rax

  *a1 = *a2;
  a1[1].m256i_i32[0] = 0xFFFFFFFF;
  result = a1;
  a1[1].m256i_i32[1] = a3;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404590B0 (0x1404590B0) ---

// --- Function: sub_140463990 (0x140463990) ---
// attributes: thunk
void __fastcall sub_140463990(__int64 *a1)
{
  sub_1404EAF80(a1);
}

// --- End Function: sub_140463990 (0x140463990) ---

// --- Function: sub_140469400 (0x140469400) ---
__int64 __fastcall sub_140469400(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 result; // rax

  sub_1404EAF80((__int64 *)a1);
  v4 = *(_QWORD *)a1;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 0xC) = *(_DWORD *)(a2 + 0xC);
  result = a1;
  *(_DWORD *)(a2 + 8) = 0x18;
  *(_DWORD *)(a2 + 0xC) = 9;
  return result;
}

// --- End Function: sub_140469400 (0x140469400) ---

// --- Function: sub_14046B610 (0x14046B610) ---
bool __fastcall sub_14046B610(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) != 0x18;
}

// --- End Function: sub_14046B610 (0x14046B610) ---

// --- Function: sub_140486F20 (0x140486F20) ---
void __fastcall sub_140486F20(__int64 *a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int16 n4; // dx
  void (__fastcall ***v5)(_QWORD, _QWORD); // rax
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // [rsp+30h] [rbp+8h] BYREF

  v2 = *a1;
  v8 = v2;
  if ( v2 )
  {
    v3 = sub_1403B4B50(v2 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v3 + 4);
    if ( n4 != 4
      && *(_WORD *)(v3 + 2) == (HIWORD(v2) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v8)) )
    {
      v5 = (void (__fastcall ***)(_QWORD, _QWORD))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v2 & 0xFFFFFFFFFFFFLL)
                                                                                     + 0x870LL))(v2 & 0xFFFFFFFFFFFFLL);
      (**v5)(v5, *((unsigned int *)a1 + 2));
    }
  }
  if ( *((_DWORD *)a1 + 3) != 9 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0x1D8LL))(qword_149B4FC78);
    LOBYTE(v7) = 1;
    (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v6 + 8LL))(v6, *((unsigned int *)a1 + 3), v7);
  }
}

// --- End Function: sub_140486F20 (0x140486F20) ---

// --- Function: sub_140496870 (0x140496870) ---
double __fastcall sub_140496870(int **a1, __int64 *a2, __int64 a3)
{
  int *v6; // rbx
  int *i; // rdi
  int v8; // eax
  int n0x4400; // [rsp+30h] [rbp-58h] BYREF
  __int64 v11; // [rsp+34h] [rbp-54h]
  int v12; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v13; // [rsp+40h] [rbp-48h]
  unsigned __int64 v14; // [rsp+48h] [rbp-40h]
  __int64 v15; // [rsp+50h] [rbp-38h]
  __int64 v16; // [rsp+58h] [rbp-30h]

  n0x4400 = 0x4400;
  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v13 = __rdtsc();
  qword_149B4B870(
    &n0x4400,
    &word_149B46BD0,
    "CTagDefinition::CRCsToTagState",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\ICryAction/ICryMannequinTagDefs.cpp",
    0x716);
  HIWORD(n0x4400) = word_149B46BD0;
  if ( a2 )
  {
    v6 = *a1;
    for ( i = a1[1]; v6 != i; ++v6 )
    {
      v8 = sub_1404A9260(a2, *v6, 0, 0);
      if ( v8 != 0xFFFFFFFF )
        sub_14042B510(a2, a3, v8, 1);
    }
  }
  v14 = __rdtsc();
  return qword_149B4B878(&n0x4400);
}

// --- End Function: sub_140496870 (0x140496870) ---

// --- Function: sub_14049F340 (0x14049F340) ---
char __fastcall sub_14049F340(__int64 a1, _DWORD **a2, __int64 a3)
{
  _DWORD *v4; // r9
  _BYTE *v6; // r10
  __int64 v8; // r11
  _DWORD *v9; // r8
  signed __int64 v10; // rdx
  unsigned __int8 *v11; // r9
  unsigned __int8 *i; // rdx
  int v13; // eax
  _DWORD *v14; // rcx
  _DWORD *v15; // r9
  __int128 *j; // rdx
  __int128 v18; // [rsp+20h] [rbp-28h] BYREF

  v4 = *a2;
  v6 = *(_BYTE **)a3;
  v8 = *(unsigned int *)(a3 + 8);
  v9 = &(*a2)[v8];
  if ( *a2 != v9 )
  {
    v10 = v6 - (_BYTE *)v4;
    while ( (*v4 & *(_DWORD *)((char *)v4 + v10)) == *(_DWORD *)((char *)v4 + v10) )
    {
      if ( ++v4 == v9 )
        goto LABEL_5;
    }
    return 0;
  }
LABEL_5:
  v18 = 0;
  memcpy(&v18, v6, v8 * 4);
  v11 = *(unsigned __int8 **)(a1 + 0x138);
  for ( i = *(unsigned __int8 **)(a1 + 0x130); i != v11; i += 8 )
  {
    v13 = *((_DWORD *)i + 1);
    if ( v13 )
    {
      if ( (v13 & *(_DWORD *)(4LL * *i + *(_QWORD *)a3)) != 0 )
        *((_DWORD *)&v18 + *i) |= v13;
      else
        *((_DWORD *)&v18 + *i) &= ~v13;
    }
  }
  v14 = *a2;
  v15 = &(*a2)[*(unsigned int *)(a3 + 8)];
  if ( *a2 != v15 )
  {
    for ( j = &v18;
          (*(_DWORD *)j & *v14) == *(_DWORD *)((char *)j + *(_QWORD *)a3 - (_QWORD)&v18);
          j = (__int128 *)((char *)j + 4) )
    {
      if ( ++v14 == v15 )
        return 1;
    }
    return 0;
  }
  return 1;
}

// --- End Function: sub_14049F340 (0x14049F340) ---

// --- Function: sub_1404A9260 (0x1404A9260) ---
__int64 __fastcall sub_1404A9260(_QWORD *a1, int a2, char a3, _BYTE *a4)
{
  __int64 v4; // rbx
  __int64 v9; // r8
  unsigned __int64 v10; // rdx
  __int64 *v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rdi
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 *v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rax
  __int64 v21; // rcx
  int n0x4400; // [rsp+30h] [rbp-68h] BYREF
  __int64 v24; // [rsp+34h] [rbp-64h]
  int v25; // [rsp+3Ch] [rbp-5Ch]
  unsigned __int64 v26; // [rsp+40h] [rbp-58h]
  unsigned __int64 v27; // [rsp+48h] [rbp-50h]
  __int64 v28; // [rsp+50h] [rbp-48h]
  __int64 v29; // [rsp+58h] [rbp-40h]

  v4 = 0;
  v24 = 0;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  n0x4400 = 0x4400;
  v26 = __rdtsc();
  qword_149B4B870(
    &n0x4400,
    &word_149B46BC0,
    "CTagDefinition::Find",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\ICryAction/ICryMannequinTagDefs.cpp",
    0x407);
  HIWORD(n0x4400) = word_149B46BC0;
  if ( a4 )
    *a4 = 0;
  v9 = a1[0x14];
  v10 = 0x100000001B3LL
      * (HIBYTE(a2)
       ^ (0x100000001B3LL
        * (BYTE2(a2)
         ^ (0x100000001B3LL * (BYTE1(a2) ^ (0x100000001B3LL * ((unsigned __int8)a2 ^ 0xCBF29CE484222325uLL)))))));
  v11 = (__int64 *)(a1[0x16] + 0x10 * (v10 & a1[0x19]));
  v12 = v11[1];
  if ( v12 == v9 )
  {
LABEL_8:
    v12 = 0;
    goto LABEL_9;
  }
  v13 = *v11;
  if ( a2 != *(_DWORD *)(v12 + 0x10) )
  {
    while ( v12 != v13 )
    {
      v12 = *(_QWORD *)(v12 + 8);
      if ( a2 == *(_DWORD *)(v12 + 0x10) )
        goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_9:
  if ( !v12 )
    v12 = a1[0x14];
  if ( v12 != v9 )
  {
    LODWORD(v14) = *(_DWORD *)(v12 + 0x14);
    goto LABEL_29;
  }
  v15 = v10 & a1[0x11];
  v16 = a1[0xC];
  v17 = (__int64 *)(a1[0xE] + 0x10 * v15);
  v18 = v17[1];
  if ( v18 != v16 )
  {
    v19 = *v17;
    if ( a2 == *(_DWORD *)(v18 + 0x10) )
    {
LABEL_17:
      v4 = v18;
    }
    else
    {
      while ( v18 != v19 )
      {
        v18 = *(_QWORD *)(v18 + 8);
        if ( a2 == *(_DWORD *)(v18 + 0x10) )
          goto LABEL_17;
      }
    }
  }
  if ( !v4 )
    v4 = a1[0xC];
  if ( v4 == v16 )
    goto LABEL_28;
  v14 = *(int *)(v4 + 0x14);
  v20 = a1[2];
  v21 = 0x38 * v14;
  if ( !*(_BYTE *)(0x38 * v14 + v20 + 0x36)
    || *(_WORD *)(v21 + v20 + 0x32) == 0xFFFF && *(_WORD *)(v21 + v20 + 0x30) == 0xFFFF )
  {
    goto LABEL_29;
  }
  if ( !a3 )
  {
LABEL_28:
    LODWORD(v14) = 0xFFFFFFFF;
    goto LABEL_29;
  }
  if ( a4 )
    *a4 = 1;
  LODWORD(v14) = *(_DWORD *)(v4 + 0x14);
LABEL_29:
  v27 = __rdtsc();
  qword_149B4B878(&n0x4400);
  return (unsigned int)v14;
}

// --- End Function: sub_1404A9260 (0x1404A9260) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1480BE950, v3);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: sub_1404B5BF0 (0x1404B5BF0) ---
__int64 __fastcall sub_1404B5BF0(__int64 a1, int a2)
{
  __int64 v2; // rcx
  __int64 v3; // r9

  v2 = *(_QWORD *)(a1 + 0x18);
  if ( a2 < 0 )
    return 0;
  v3 = *(_QWORD *)(v2 + 0x10);
  if ( a2 >= (int)((*(_QWORD *)(v2 + 0x18) - v3) / 0x38) )
    return 0;
  else
    return *(_QWORD *)(0x38LL * a2 + v3);
}

// --- End Function: sub_1404B5BF0 (0x1404B5BF0) ---

// --- Function: sub_1404BB5C0 (0x1404BB5C0) ---
__int64 __fastcall sub_1404BB5C0(_QWORD *a1, int a2, _DWORD *a3, int a4, __m256i *a5)
{
  __int64 *v5; // r14
  __int64 v8; // rcx
  __int64 v9; // rbp
  __int64 v10; // rbp
  __int64 v11; // rax
  unsigned int v12; // ebx
  _QWORD *v13; // r15
  __int64 v14; // rsi
  __m256i *v15; // rdi
  __int64 result; // rax
  __int64 v17; // [rsp+20h] [rbp-88h]
  __m256i *v18; // [rsp+28h] [rbp-80h] BYREF
  int n4; // [rsp+30h] [rbp-78h]
  _DWORD *v20; // [rsp+38h] [rbp-70h] BYREF
  int n4_1; // [rsp+40h] [rbp-68h]
  __int64 *v22; // [rsp+48h] [rbp-60h] BYREF
  int n4_2; // [rsp+50h] [rbp-58h]
  _DWORD *v24; // [rsp+58h] [rbp-50h] BYREF
  int n4_3; // [rsp+60h] [rbp-48h]

  v5 = 0;
  if ( a2 < 0 || a2 >= (int)((*(_QWORD *)(a1[3] + 0x18LL) - *(_QWORD *)(a1[3] + 0x10LL)) / 0x38LL) )
  {
    result = 0;
  }
  else
  {
    v8 = a1[3];
    v9 = *(_QWORD *)(v8 + 0x10);
    if ( a2 >= (*(_DWORD *)(v8 + 0x18) - (int)v9) / 0x38 )
      v10 = 0;
    else
      v10 = *(_QWORD *)(0x38LL * a2 + v9);
    v11 = a1[2];
    v12 = 0;
    v17 = v11;
    v13 = (_QWORD *)(a1[0x8E] + 0x38LL * a2);
    v14 = (__int64)(v13[1] - *v13) >> 5;
    if ( (_DWORD)v14 )
    {
      while ( 1 )
      {
        v15 = (__m256i *)(*v13 + 0x20LL * v12);
        v18 = v15;
        n4 = 4;
        v20 = a3;
        n4_1 = 4;
        if ( sub_14049F340(v11, &v20, (__int64)&v18) )
        {
          if ( !v10 )
            break;
          n4_2 = 4;
          v22 = &v15->m256i_i64[2];
          n4_3 = 4;
          v24 = a3 + 4;
          if ( sub_14049F340(v10, &v24, (__int64)&v22) )
            break;
        }
        if ( ++v12 >= (unsigned int)v14 )
          goto LABEL_15;
        v11 = v17;
      }
      if ( a5 )
        *a5 = *v15;
      v5 = (__int64 *)(v13[3] + 8LL * v12);
    }
LABEL_15:
    result = *v5;
    if ( a4 != 0xFFFFFFFF )
    {
      result |= *(_QWORD *)(a1[0x97] + 0x18LL * a4);
      __asm { vzeroupper }
      return result;
    }
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404BB5C0 (0x1404BB5C0) ---

// --- Function: sub_1404EAD00 (0x1404EAD00) ---
unsigned __int64 __fastcall sub_1404EAD00(__int64 *a1)
{
  __int64 v1; // rcx
  __int64 v2; // rcx
  unsigned __int64 result; // rax

  v1 = *a1;
  if ( v1 )
  {
    v2 = *(_QWORD *)(v1 + 0x98);
    if ( v2 )
      return sub_1402D2790(v2);
  }
  return result;
}

// --- End Function: sub_1404EAD00 (0x1404EAD00) ---

// --- Function: sub_1404EAF80 (0x1404EAF80) ---
void __fastcall sub_1404EAF80(__int64 *a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int16 n4; // dx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  v2 = *a1;
  v7 = v2;
  if ( v2 )
  {
    v3 = sub_1403B4B50(v2 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v3 + 4);
    if ( n4 != 4
      && *(_WORD *)(v3 + 2) == (HIWORD(v2) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v7)) )
    {
      v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v2 & 0xFFFFFFFFFFFFLL) + 0x870LL))(v2 & 0xFFFFFFFFFFFFLL);
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 8LL))(v5, *((unsigned int *)a1 + 2));
    }
  }
  if ( *((_DWORD *)a1 + 3) != 9 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0x1D8LL))(qword_149B4FC78);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v6 + 8LL))(v6, *((unsigned int *)a1 + 3), 0);
  }
  *a1 = 0;
  *((_DWORD *)a1 + 2) = 0x18;
  *((_DWORD *)a1 + 3) = 9;
}

// --- End Function: sub_1404EAF80 (0x1404EAF80) ---

// --- Function: sub_1404F3FB0 (0x1404F3FB0) ---
__int64 __fastcall sub_1404F3FB0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[40] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[40] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[41] >> 4];
  a2[3] = _0123456789abcdef_[a1[41] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[42] >> 4];
  a2[5] = _0123456789abcdef_[a1[42] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[43] >> 4];
  a2[7] = _0123456789abcdef_[a1[43] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[44] >> 4];
  a2[9] = _0123456789abcdef_[a1[44] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[45] >> 4];
  a2[11] = _0123456789abcdef_[a1[45] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[46] >> 4];
  a2[13] = _0123456789abcdef_[a1[46] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[47] >> 4];
  a2[15] = _0123456789abcdef_[a1[47] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F3FB0 (0x1404F3FB0) ---

// --- Function: sub_1404F4100 (0x1404F4100) ---
__int64 __fastcall sub_1404F4100(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[16] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[16] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[17] >> 4];
  a2[3] = _0123456789abcdef_[a1[17] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[18] >> 4];
  a2[5] = _0123456789abcdef_[a1[18] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[19] >> 4];
  a2[7] = _0123456789abcdef_[a1[19] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[20] >> 4];
  a2[9] = _0123456789abcdef_[a1[20] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[21] >> 4];
  a2[11] = _0123456789abcdef_[a1[21] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[22] >> 4];
  a2[13] = _0123456789abcdef_[a1[22] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[23] >> 4];
  a2[15] = _0123456789abcdef_[a1[23] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[24] >> 4];
  a2[17] = _0123456789abcdef_[a1[24] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[25] >> 4];
  a2[19] = _0123456789abcdef_[a1[25] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[26] >> 4];
  a2[21] = _0123456789abcdef_[a1[26] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[27] >> 4];
  a2[23] = _0123456789abcdef_[a1[27] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[28] >> 4];
  a2[25] = _0123456789abcdef_[a1[28] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[29] >> 4];
  a2[27] = _0123456789abcdef_[a1[29] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[30] >> 4];
  a2[29] = _0123456789abcdef_[a1[30] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[31] >> 4];
  a2[31] = _0123456789abcdef_[a1[31] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4100 (0x1404F4100) ---

// --- Function: sub_1404F4350 (0x1404F4350) ---
__int64 __fastcall sub_1404F4350(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[32] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[32] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[33] >> 4];
  a2[3] = _0123456789abcdef_[a1[33] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[34] >> 4];
  a2[5] = _0123456789abcdef_[a1[34] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[35] >> 4];
  a2[7] = _0123456789abcdef_[a1[35] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[36] >> 4];
  a2[9] = _0123456789abcdef_[a1[36] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[37] >> 4];
  a2[11] = _0123456789abcdef_[a1[37] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[38] >> 4];
  a2[13] = _0123456789abcdef_[a1[38] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[39] >> 4];
  a2[15] = _0123456789abcdef_[a1[39] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F4350 (0x1404F4350) ---

// --- Function: sub_1404F4760 (0x1404F4760) ---
__int64 __fastcall sub_1404F4760(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[11] = _0123456789abcdef_[a1[5] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[13] = _0123456789abcdef_[a1[6] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[15] = _0123456789abcdef_[a1[7] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[17] = _0123456789abcdef_[a1[8] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[19] = _0123456789abcdef_[a1[9] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[10] >> 4];
  a2[21] = _0123456789abcdef_[a1[10] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[11] >> 4];
  a2[23] = _0123456789abcdef_[a1[11] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[12] >> 4];
  a2[25] = _0123456789abcdef_[a1[12] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[13] >> 4];
  a2[27] = _0123456789abcdef_[a1[13] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[14] >> 4];
  a2[29] = _0123456789abcdef_[a1[14] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[15] >> 4];
  a2[31] = _0123456789abcdef_[a1[15] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4760 (0x1404F4760) ---

// --- Function: sub_1405048A0 (0x1405048A0) ---
__int64 __fastcall sub_1405048A0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_140450060(a2, a3, 0, *(_DWORD *)(a1 + 8));
}

// --- End Function: sub_1405048A0 (0x1405048A0) ---

// --- Function: _InterlockedIncrement16_w (0x140508E80) ---
signed __int16 __fastcall InterlockedIncrement16_w(volatile signed __int16 *a1)
{
  return _InterlockedIncrement16(a1);
}

// --- End Function: _InterlockedIncrement16_w (0x140508E80) ---

// --- Function: ?__scrt_is_event_api_used@@YA_NQEAX@Z (0x140538EE0) ---
bool __fastcall __scrt_is_event_api_used(void *const a1)
{
  return a1 != 0;
}

// --- End Function: ?__scrt_is_event_api_used@@YA_NQEAX@Z (0x140538EE0) ---

// --- Function: sub_1405396A0 (0x1405396A0) ---
__int64 __fastcall sub_1405396A0(unsigned __int64 n1224)
{
  __int64 n2; // rax

  if ( n1224 > 0x22A )
  {
    n2 = 2;
    if ( n1224 != 0x4C8 )
      return 0x11;
  }
  else if ( n1224 == 0x22A )
  {
    return 0xA;
  }
  else
  {
    switch ( n1224 )
    {
      case 0uLL:
        n2 = 0;
        break;
      case 1uLL:
        n2 = 0x10;
        break;
      case 2uLL:
      case 3uLL:
        n2 = 1;
        break;
      case 4uLL:
        n2 = 0xD;
        break;
      case 5uLL:
        n2 = 8;
        break;
      case 6uLL:
        n2 = 6;
        break;
      case 0x17uLL:
        n2 = 0xE;
        break;
      case 0x20uLL:
        n2 = 2;
        break;
      case 0x26uLL:
        n2 = 0xF;
        break;
      case 0x50uLL:
      case 0xB7uLL:
        n2 = 9;
        break;
      case 0x70uLL:
        n2 = 0xC;
        break;
      default:
        n2 = 0x11;
        break;
    }
  }
  return n2;
}

// --- End Function: sub_1405396A0 (0x1405396A0) ---

// --- Function: sub_140539860 (0x140539860) ---
__int64 __fastcall sub_140539860(HANDLE hFile, __int64 a2, unsigned __int64 nNumberOfBytesToWrite_2, _QWORD *a4)
{
  __int64 nNumberOfBytesToWrite_3; // rdi
  unsigned __int64 nNumberOfBytesToWrite; // rsi
  DWORD nNumberOfBytesToWrite_1; // ebp
  unsigned __int32 err; // eax
  DWORD NumberOfBytesWritten; // [rsp+68h] [rbp+10h] BYREF

  nNumberOfBytesToWrite_3 = 0;
  nNumberOfBytesToWrite = nNumberOfBytesToWrite_2;
  do
  {
    NumberOfBytesWritten = 0;
    nNumberOfBytesToWrite_1 = nNumberOfBytesToWrite;
    if ( nNumberOfBytesToWrite > 0xFFFFFFFF )
      nNumberOfBytesToWrite_1 = 0xFFFFFFFF;
    if ( !WriteFile(hFile, (LPCVOID)(nNumberOfBytesToWrite_3 + a2), nNumberOfBytesToWrite_1, &NumberOfBytesWritten, 0) )
    {
      err = GetLastError();
      return sub_1405396A0(err);
    }
    nNumberOfBytesToWrite_3 += nNumberOfBytesToWrite_1;
    nNumberOfBytesToWrite -= nNumberOfBytesToWrite_1;
  }
  while ( nNumberOfBytesToWrite_3 != nNumberOfBytesToWrite_2 );
  if ( a4 )
    *a4 = nNumberOfBytesToWrite_3;
  return 0;
}

// --- End Function: sub_140539860 (0x140539860) ---

// --- Function: sub_140539D30 (0x140539D30) ---
__int64 (__fastcall *__fastcall sub_140539D30(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_14039B170(0, "__InitializeThreadInfoBlock__", 0);
  if ( result )
    return (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}

// --- End Function: sub_140539D30 (0x140539D30) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14053A5C0 (0x14053A5C0) ---
char *__fastcall sub_14053A5C0(__int64 _Newvec, _BYTE *a2, void **p_Src, __int64 *a4, int *a5, _OWORD *a6, __int64 *a7)
{
  __int64 v11; // rsi
  __int64 v12; // rdx
  unsigned __int64 _Newcapacity; // rbp
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  unsigned __int64 _Newcapacity_1; // rbx
  unsigned __int64 allocSize; // rcx
  __int64 v18; // rax
  _QWORD *_Newsize; // rdi
  __int64 v20; // rcx
  char *v21; // rsi
  __int64 v22; // r8
  int v23; // edx
  void *_Newsize_1; // rcx
  _BYTE *v25; // r8
  _BYTE *v26; // rdx
  size_t Size; // r8

  v11 = (__int64)&a2[-*(_QWORD *)_Newvec] / 0x30;
  v12 = (*(_QWORD *)(_Newvec + 8) - *(_QWORD *)_Newvec) / 0x30LL;
  if ( v12 == 0x555555555555555LL )
    unknown_libname_10();
  _Newcapacity = v12 + 1;
  v14 = (*(_QWORD *)(_Newvec + 0x10) - *(_QWORD *)_Newvec) / 0x30LL;
  v15 = v14 >> 1;
  if ( v14 > 0x555555555555555LL - (v14 >> 1) )
    goto LABEL_19;
  _Newcapacity_1 = _Newcapacity;
  if ( v15 + v14 >= _Newcapacity )
    _Newcapacity_1 = v15 + v14;
  if ( _Newcapacity_1 > 0x555555555555555LL )
    goto LABEL_19;
  allocSize = 0x30 * _Newcapacity_1;
  if ( 0x30 * _Newcapacity_1 < 0x1000 )
  {
    if ( allocSize )
      _Newsize = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      _Newsize = 0;
    goto LABEL_14;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_19:
    sub_1402E1170();
  v18 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v18 )
    invalid_parameter_noinfo_noreturn();
  _Newsize = (_QWORD *)((v18 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  _Newsize[0xFFFFFFFF] = v18;
LABEL_14:
  v20 = *a4;
  v21 = (char *)&_Newsize[6 * v11];
  v22 = *a7;
  v23 = *a5;
  *(_QWORD *)v21 = *p_Src;
  *((_QWORD *)v21 + 1) = v20;
  _Newsize_1 = _Newsize;
  *((_DWORD *)v21 + 4) = v23;
  *(_OWORD *)(v21 + 0x18) = *a6;
  *((_QWORD *)v21 + 5) = v22;
  v25 = *(_BYTE **)(_Newvec + 8);
  v26 = *(_BYTE **)_Newvec;
  if ( a2 == v25 )
  {
    Size = v25 - v26;
  }
  else
  {
    memmove(_Newsize, v26, a2 - v26);
    _Newsize_1 = v21 + 0x30;
    Size = *(_QWORD *)(_Newvec + 8) - (_QWORD)a2;
    v26 = a2;
  }
  memmove(_Newsize_1, v26, Size);
  std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_Change_array(
    (GSC::AI::GameGraph::generate_game_graph::__l246::search_node *const)_Newvec,
    (const unsigned __int64)_Newsize,
    _Newcapacity,
    _Newcapacity_1);
  return v21;
}

// --- End Function: sub_14053A5C0 (0x14053A5C0) ---

// --- Function: sub_14053A790 (0x14053A790) ---
void __fastcall sub_14053A790(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  _QWORD *v6; // rdi
  const void *v7; // rcx

  v3 = a3;
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    sub_14053A790(a1, a2, v3[2]);
    v6 = v3;
    v3 = (__int64 *)*v3;
    v7 = (const void *)v6[5];
    if ( v7 )
      sub_147605980(v7);
    sub_1402A3D30(v6);
  }
}

// --- End Function: sub_14053A790 (0x14053A790) ---

// --- Function: sub_14053A870 (0x14053A870) ---
__int64 __fastcall sub_14053A870(__int64 a1, int a2, __int64 a3, int a4, size_t *a5)
{
  size_t *v9; // rcx

  sub_1402A2880(a1, a5);
  *(_DWORD *)(a1 + 536) = a4;
  *(_DWORD *)(a1 + 540) = a2;
  *(_QWORD *)(a1 + 544) = a3;
  v9 = (size_t *)a5[2];
  if ( v9 != a5 + 3 )
  {
    qword_149B3AB68 += -1LL - a5[1];
    sub_147605980(v9);
  }
  return a1;
}

// --- End Function: sub_14053A870 (0x14053A870) ---

// --- Function: sub_14053A900 (0x14053A900) ---
__int64 __fastcall sub_14053A900(__int64 a1)
{
  int v2; // eax
  unsigned int v3; // eax
  int v4; // eax
  char *Success; // rax
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax
  char *Failure; // rax
  int v10; // eax
  unsigned int v11; // eax
  int v12; // eax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 n3; // rdi
  _QWORD *v16; // rbx
  __int64 v17; // rax

  *(_QWORD *)a1 = off_1481D99A8;
  v2 = sub_1402D2830(0x46u, 8, 0, 2);
  v3 = sub_1402CA4C0(0x4C11DB7, 1, (v2 << 0x19) ^ (unsigned int)((unsigned __int64)(v2 << 0x18) >> 0x1F) & 0x4C11DB7);
  v4 = sub_1402D2830(v3 >> 1, 0x20, v3 << 0x1F, 2);
  *(_DWORD *)(a1 + 8) = sub_1402E1FE0((unsigned __int8 *)"uccess", v4 ^ 0xFFFFFFu);
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  Success = (char *)allocWithProfilerInfo(8u, 0);
  *(_QWORD *)(a1 + 0x10) = Success;
  *(_QWORD *)(a1 + 0x18) = 8;
  strcpy(Success, "Success");
  v6 = sub_1402D2830(0x4Cu, 8, 0x80u, 2);
  v7 = sub_1402CA4C0(0x4C11DB7, 1, (v6 << 0x19) ^ (unsigned int)((unsigned __int64)(v6 << 0x18) >> 0x1F) & 0x4C11DB7);
  v8 = sub_1402D2830(v7 >> 1, 0x20, v7 << 0x1F, 2);
  *(_DWORD *)(a1 + 0x20) = sub_1402E1FE0((unsigned __int8 *)"ailure", v8 ^ 0xFFFFFFu);
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  Failure = (char *)allocWithProfilerInfo(8u, 0);
  *(_QWORD *)(a1 + 0x28) = Failure;
  *(_QWORD *)(a1 + 0x30) = 8;
  strcpy(Failure, "Failure");
  *(_OWORD *)(a1 + 0x38) = 0;
  v10 = sub_1402D2830(0x45u, 8, 0, 2);
  v11 = sub_1402CA4C0(0x4C11DB7, 1, (v10 << 0x19) ^ (unsigned int)((unsigned __int64)(v10 << 0x18) >> 0x1F) & 0x4C11DB7);
  v12 = sub_1402D2830(v11 >> 1, 0x20, v11 << 0x1F, 2);
  *(_DWORD *)(a1 + 0x48) = sub_1402E1FE0((unsigned __int8 *)"ninitialized", v12 ^ 0xFFFFFFu);
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  v13 = allocWithProfilerInfo(0xEu, 0);
  *(_QWORD *)(a1 + 0x50) = v13;
  *(_QWORD *)(a1 + 0x58) = 0xE;
  *(double *)v13 = *(double *)"Uninitialized";
  strcpy((char *)(v13 + 8), "lized");
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  v14 = allocWithProfilerInfo_w(0x50u);
  n3 = 3;
  v16 = (_QWORD *)(a1 + 0xA0);
  *(_QWORD *)v14 = v14;
  *(_QWORD *)(v14 + 8) = v14;
  *(_QWORD *)(v14 + 0x10) = v14;
  *(_WORD *)(v14 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x60) = v14;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0x98) = 0;
  do
  {
    *v16 = 0;
    v16[1] = 0;
    v17 = allocWithProfilerInfo_w(0x48u);
    v16 += 2;
    *(_QWORD *)v17 = v17;
    *(_QWORD *)(v17 + 8) = v17;
    *(_QWORD *)(v17 + 0x10) = v17;
    *(_WORD *)(v17 + 0x18) = 0x101;
    v16[0xFFFFFFFE] = v17;
    --n3;
  }
  while ( n3 );
  *(_WORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = 0;
  *(_QWORD *)(a1 + 0xE8) = 0;
  *(_BYTE *)(a1 + 0xD2) = 0x5A;
  sub_14035B3E0((_QWORD *)(a1 + 0xF0));
  sub_14035B3E0((_QWORD *)(a1 + 0xF8));
  sub_14035B3E0((_QWORD *)(a1 + 0x100));
  return a1;
}

// --- End Function: sub_14053A900 (0x14053A900) ---

// --- Function: sub_14053ABD0 (0x14053ABD0) ---
void __fastcall sub_14053ABD0(__int64 a1)
{
  __int64 n3; // rsi
  const void **v3; // rbx
  _QWORD *v4; // r8
  const void *v5; // rcx
  const void *v6; // rcx
  const void *v7; // rcx

  sub_140370D10((_QWORD *)(a1 + 0x100));
  sub_140370D10((_QWORD *)(a1 + 0xF8));
  sub_140370D10((_QWORD *)(a1 + 0xF0));
  sub_1403328D0((__int64 *)(a1 + 0xD8));
  n3 = 3;
  v3 = (const void **)(a1 + 0xD0);
  do
  {
    v4 = v3[0xFFFFFFFE];
    v3 += 0xFFFFFFFE;
    sub_1403487D0((__int64)v3, (__int64)v3, v4[1]);
    sub_1402A3D30(*v3);
    --n3;
  }
  while ( n3 );
  std::vector<gte::Vector<3,double>>::_Tidy((std::vector<gte::Vector<3,double>> *)(a1 + 0x70));
  sub_14053A790(a1 + 0x60, a1 + 0x60, *(__int64 **)(*(_QWORD *)(a1 + 0x60) + 8LL));
  sub_1402A3D30(*(const void **)(a1 + 0x60));
  v5 = *(const void **)(a1 + 0x50);
  if ( v5 )
    sub_147605980(v5);
  v6 = *(const void **)(a1 + 0x28);
  if ( v6 )
    sub_147605980(v6);
  v7 = *(const void **)(a1 + 0x10);
  if ( v7 )
    sub_147605980(v7);
}

// --- End Function: sub_14053ABD0 (0x14053ABD0) ---

// --- Function: sub_14053ACC0 (0x14053ACC0) ---
__int64 __fastcall sub_14053ACC0(__int64 a1, unsigned int *a2)
{
  __int64 *v2; // rsi
  __int64 inserted; // r8
  __int64 v6; // rax
  unsigned int v7; // r9d
  __int64 v8; // rdi
  __int128 v9; // xmm0
  __int128 v11; // [rsp+20h] [rbp-38h] BYREF

  v2 = *(__int64 **)a1;
  DWORD2(v11) = 0;
  inserted = (__int64)v2;
  v6 = v2[1];
  *(_QWORD *)&v11 = v6;
  if ( !*(_BYTE *)(v6 + 0x19) )
  {
    v7 = *a2;
    do
    {
      *(_QWORD *)&v11 = v6;
      if ( *(_DWORD *)(v6 + 0x20) >= v7 )
      {
        inserted = v6;
        DWORD2(v11) = 1;
        v6 = *(_QWORD *)v6;
      }
      else
      {
        v6 = *(_QWORD *)(v6 + 0x10);
        DWORD2(v11) = 0;
      }
    }
    while ( !*(_BYTE *)(v6 + 0x19) );
  }
  if ( *(_BYTE *)(inserted + 0x19) || *a2 < *(_DWORD *)(inserted + 0x20) )
  {
    if ( *(_QWORD *)(a1 + 8) == 0x333333333333333LL )
      unknown_libname_7();
    v8 = allocWithProfilerInfo_w(0x50u);
    sub_14030A540(v8 + 0x20, (__int64)a2);
    *(_OWORD *)(v8 + 0x38) = 0;
    v9 = v11;
    *(_QWORD *)(v8 + 0x48) = 0;
    *(_QWORD *)v8 = v2;
    *(_QWORD *)(v8 + 8) = v2;
    *(_QWORD *)(v8 + 0x10) = v2;
    *(_WORD *)(v8 + 0x18) = 0;
    v11 = v9;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 (__int64 **)a1,
                 (__int64)&v11,
                 v8);
  }
  return inserted + 0x38;
}

// --- End Function: sub_14053ACC0 (0x14053ACC0) ---

// --- Function: sub_14053AEE0 (0x14053AEE0) ---
__int64 __fastcall sub_14053AEE0(__int64 a1, __int64 a2, __int64 a3)
{
  __m256i v3; // ymm1
  __int128 v6; // xmm1
  signed __int64 v7; // rdx
  __int64 *v8; // rcx
  __int64 v9; // rax
  __int64 result; // rax
  __m256 v11; // [rsp+20h] [rbp-168h] BYREF
  __int128 v12; // [rsp+40h] [rbp-148h]
  __int64 v13; // [rsp+50h] [rbp-138h]
  __m256i v14; // [rsp+60h] [rbp-128h] BYREF
  __m256i v15; // [rsp+80h] [rbp-108h]
  __m256i v16; // [rsp+A0h] [rbp-E8h]
  __m256i v17; // [rsp+C0h] [rbp-C8h]
  _BYTE v18[96]; // [rsp+E0h] [rbp-A8h]
  _BYTE v19[48]; // [rsp+140h] [rbp-48h]
  __int64 v20; // [rsp+170h] [rbp-18h]

  v3 = *(__m256i *)(a2 + 0x80);
  v14 = *(__m256i *)a2;
  v15 = *(__m256i *)(a2 + 0x20);
  v16 = *(__m256i *)(a2 + 0x40);
  v17 = *(__m256i *)(a2 + 0x60);
  *(__m256i *)v18 = v3;
  *(__m256i *)&v18[0x20] = *(__m256i *)(a2 + 0xA0);
  *(__m256i *)&v18[0x40] = *(__m256i *)(a2 + 0xC0);
  v6 = *(_OWORD *)(a1 + 0x38);
  *(_DWORD *)&v19[0x28] = v17.m256i_i32[6];
  *(_QWORD *)v19 = v14.m256i_i64[0];
  v7 = v6
     ^ *(_QWORD *)(a1 + 0x40)
     ^ _mm_extract_epi64(*(__m128i *)&v17.m256i_u64[1], 1)
     ^ v17.m256i_i64[1]
     ^ v17.m256i_u32[6];
  v8 = *(__int64 **)(a1 + 0x88);
  *(_OWORD *)&v19[0x18] = *(_OWORD *)&v17.m256i_u64[1];
  *(_OWORD *)&v19[8] = v6;
  v9 = *v8;
  v20 = v14.m256i_i64[0] ^ v7 ^ 0x1234567898765432LL;
  v11 = *(__m256 *)v19;
  v13 = v20;
  v12 = *(_OWORD *)&v19[0x20];
  __asm { vzeroupper }
  result = (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v9 + 0x40))(v8, &v11, v15.m256i_i64[0]);
  v16.m256i_i64[3] = result;
  if ( result )
    return (*(__int64 (__fastcall **)(__int64, __m256i *, __int64))(*(_QWORD *)a1 + 0x90LL))(a1, &v14, a3);
  return result;
}

// --- End Function: sub_14053AEE0 (0x14053AEE0) ---

// --- Function: sub_14053B050 (0x14053B050) ---
__int64 __fastcall sub_14053B050(__int64 a1, __int64 a2)
{
  __m256i v2; // ymm1
  __int128 v4; // xmm1
  signed __int64 v5; // rdx
  __int64 *v6; // rcx
  __int64 v7; // rax
  __int64 result; // rax
  __m256 v9; // [rsp+20h] [rbp-168h] BYREF
  __int128 v10; // [rsp+40h] [rbp-148h]
  __int64 v11; // [rsp+50h] [rbp-138h]
  __m256i v12; // [rsp+60h] [rbp-128h] BYREF
  __m256i v13; // [rsp+80h] [rbp-108h]
  __m256i v14; // [rsp+A0h] [rbp-E8h]
  __m256i v15; // [rsp+C0h] [rbp-C8h]
  _BYTE v16[96]; // [rsp+E0h] [rbp-A8h]
  _BYTE v17[48]; // [rsp+140h] [rbp-48h]
  __int64 v18; // [rsp+170h] [rbp-18h]

  v2 = *(__m256i *)(a2 + 0x80);
  v12 = *(__m256i *)a2;
  v13 = *(__m256i *)(a2 + 0x20);
  v14 = *(__m256i *)(a2 + 0x40);
  v15 = *(__m256i *)(a2 + 0x60);
  *(__m256i *)v16 = v2;
  *(__m256i *)&v16[0x20] = *(__m256i *)(a2 + 0xA0);
  *(__m256i *)&v16[0x40] = *(__m256i *)(a2 + 0xC0);
  v4 = *(_OWORD *)(a1 + 0x38);
  *(_DWORD *)&v17[0x28] = v15.m256i_i32[6];
  *(_QWORD *)v17 = v12.m256i_i64[0];
  v5 = v4
     ^ *(_QWORD *)(a1 + 0x40)
     ^ _mm_extract_epi64(*(__m128i *)&v15.m256i_u64[1], 1)
     ^ v15.m256i_i64[1]
     ^ v15.m256i_u32[6];
  v6 = *(__int64 **)(a1 + 0x88);
  *(_OWORD *)&v17[0x18] = *(_OWORD *)&v15.m256i_u64[1];
  *(_OWORD *)&v17[8] = v4;
  v7 = *v6;
  v18 = v12.m256i_i64[0] ^ v5 ^ 0x1234567898765432LL;
  v9 = *(__m256 *)v17;
  v11 = v18;
  v10 = *(_OWORD *)&v17[0x20];
  __asm { vzeroupper }
  result = (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v7 + 0x40))(v6, &v9, v13.m256i_i64[0]);
  v14.m256i_i64[3] = result;
  if ( result )
    return (*(__int64 (__fastcall **)(__int64, __m256i *))(*(_QWORD *)a1 + 0xA0LL))(a1, &v12);
  return result;
}

// --- End Function: sub_14053B050 (0x14053B050) ---

// --- Function: sub_14053B1B0 (0x14053B1B0) ---
void __fastcall sub_14053B1B0(__int64 a1, __int64 a2, __int64 a3)
{
  __m256i v3; // ymm1
  __int128 v6; // xmm1
  signed __int64 v7; // rdx
  __int64 *v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rcx
  const char *v11; // rax
  const char *v12; // rbx
  const char *v13; // rax
  size_t *v14; // rax
  size_t n511; // rbx
  const void *v16; // rsi
  __int64 v17; // rax
  __m256 v18; // [rsp+20h] [rbp-E0h] BYREF
  __int128 v19; // [rsp+40h] [rbp-C0h]
  __int64 v20; // [rsp+50h] [rbp-B0h]
  __m256i v21; // [rsp+60h] [rbp-A0h] BYREF
  __m256i v22; // [rsp+80h] [rbp-80h]
  __m256i v23; // [rsp+A0h] [rbp-60h]
  __m256i v24; // [rsp+C0h] [rbp-40h]
  _BYTE v25[96]; // [rsp+E0h] [rbp-20h]
  _BYTE v26[48]; // [rsp+140h] [rbp+40h]
  __int64 v27; // [rsp+170h] [rbp+70h]
  __int64 v28; // [rsp+180h] [rbp+80h] BYREF
  __int64 n0x1FF; // [rsp+188h] [rbp+88h]
  _BYTE *v30; // [rsp+190h] [rbp+90h]
  _BYTE v31[520]; // [rsp+198h] [rbp+98h] BYREF

  v3 = *(__m256i *)(a2 + 0x80);
  v21 = *(__m256i *)a2;
  v22 = *(__m256i *)(a2 + 0x20);
  v23 = *(__m256i *)(a2 + 0x40);
  v24 = *(__m256i *)(a2 + 0x60);
  *(__m256i *)v25 = v3;
  *(__m256i *)&v25[0x20] = *(__m256i *)(a2 + 0xA0);
  *(__m256i *)&v25[0x40] = *(__m256i *)(a2 + 0xC0);
  v6 = *(_OWORD *)(a1 + 0x38);
  *(_DWORD *)&v26[0x28] = v24.m256i_i32[6];
  *(_QWORD *)v26 = v21.m256i_i64[0];
  v7 = v6
     ^ *(_QWORD *)(a1 + 0x40)
     ^ _mm_extract_epi64(*(__m128i *)&v24.m256i_u64[1], 1)
     ^ v24.m256i_i64[1]
     ^ v24.m256i_u32[6];
  v8 = *(__int64 **)(a1 + 0x88);
  *(_OWORD *)&v26[0x18] = *(_OWORD *)&v24.m256i_u64[1];
  *(_OWORD *)&v26[8] = v6;
  v9 = *v8;
  v27 = v21.m256i_i64[0] ^ v7 ^ 0x1234567898765432LL;
  v18 = *(__m256 *)v26;
  v20 = v27;
  v19 = *(_OWORD *)&v26[0x20];
  __asm { vzeroupper }
  v23.m256i_i64[3] = (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v9 + 0x40))(v8, &v18, v22.m256i_i64[0]);
  if ( !v23.m256i_i64[3]
    || !(*(unsigned __int8 (__fastcall **)(__int64, __m256i *, __int64))(*(_QWORD *)a1 + 0x98LL))(a1, &v21, a3) )
  {
    v10 = *(_QWORD *)(a1 + 0x88);
    v30 = v31;
    v11 = *(const char **)(a1 + 0x50);
    v31[0] = 0;
    v12 = (const char *)&byte_14819E9C2;
    if ( v11 )
      v12 = v11;
    v28 = 0;
    n0x1FF = 0x1FF;
    v13 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x10LL))(v10);
    v14 = (size_t *)sub_1402A3190((__int64)&v28, "%s (%s)", v13, v12);
    n511 = *v14;
    v16 = (const void *)v14[2];
    if ( *v14 > *(_QWORD *)(a3 + 8) )
    {
      sub_1402A3C90((_QWORD *)a3);
      sub_1402A3B50((__int64 *)a3, n511);
    }
    memmove(*(void **)(a3 + 0x10), v16, n511);
    v17 = *(_QWORD *)(a3 + 0x10);
    *(_QWORD *)a3 = n511;
    *(_BYTE *)(n511 + v17) = 0;
    if ( v30 != v31 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v30);
    }
  }
}

// --- End Function: sub_14053B1B0 (0x14053B1B0) ---

// --- Function: sub_14053B580 (0x14053B580) ---
__int64 __fastcall sub_14053B580(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x88) + 0x18LL))(*(_QWORD *)(a1 + 0x88));
}

// --- End Function: sub_14053B580 (0x14053B580) ---

// --- Function: sub_14053B590 (0x14053B590) ---
_OWORD *__fastcall sub_14053B590(__int64 a1, _OWORD *a2)
{
  *a2 = *(_OWORD *)(a1 + 0x38);
  return a2;
}

// --- End Function: sub_14053B590 (0x14053B590) ---

// --- Function: sub_14053B5A0 (0x14053B5A0) ---
__int64 __fastcall sub_14053B5A0(__int64 a1, __int64 a2)
{
  sub_14030A540(a2, a1 + 0x48);
  return a2;
}

// --- End Function: sub_14053B5A0 (0x14053B5A0) ---

// --- Function: sub_14053B5C0 (0x14053B5C0) ---
char __fastcall sub_14053B5C0(__int64 a1, _DWORD *a2, _QWORD *a3)
{
  _QWORD *i; // r9
  __int64 *v6; // rax
  _QWORD *v7; // r10
  __int64 *v8; // r8
  __int64 *v9; // rdx
  __int64 *v10; // rax
  __int64 v12; // rax
  volatile signed __int32 *v13; // rbx
  __int64 v14; // rcx

  for ( i = (_QWORD *)(a1 + 136); ; ++i )
  {
    v6 = (__int64 *)*i;
    v7 = i;
    if ( *i )
    {
      v8 = (__int64 *)*v6;
      v9 = (__int64 *)*v6;
      v10 = *(__int64 **)(*v6 + 8);
      while ( !*((_BYTE *)v10 + 25) )
      {
        if ( *((_DWORD *)v10 + 8) >= *a2 )
        {
          v9 = v10;
          v10 = (__int64 *)*v10;
        }
        else
        {
          v10 = (__int64 *)v10[2];
        }
      }
      if ( !*((_BYTE *)v9 + 25) && *a2 >= *((_DWORD *)v9 + 8) && v9 != v8 )
        break;
    }
    if ( v7 == (_QWORD *)(a1 + 152) )
      return 0;
  }
  v12 = v9[8];
  if ( v12 )
    _InterlockedIncrement((volatile signed __int32 *)(v12 + 8));
  v13 = (volatile signed __int32 *)a3[1];
  v14 = v9[8];
  *a3 = v9[7];
  a3[1] = v14;
  if ( v13 && _InterlockedExchangeAdd(v13 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
    if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8LL))(v13);
  }
  return 1;
}

// --- End Function: sub_14053B5C0 (0x14053B5C0) ---

// --- Function: sub_14053BF90 (0x14053BF90) ---
__int64 __fastcall sub_14053BF90(__int64 a1, __int64 a2, __int64 a3)
{
  __m256i v3; // ymm1
  __int128 v6; // xmm1
  signed __int64 v7; // rdx
  __int64 *v8; // rcx
  __int64 v9; // rax
  __m256 v11; // [rsp+20h] [rbp-168h] BYREF
  __int128 v12; // [rsp+40h] [rbp-148h]
  __int64 v13; // [rsp+50h] [rbp-138h]
  __m256i v14; // [rsp+60h] [rbp-128h] BYREF
  __m256i v15; // [rsp+80h] [rbp-108h]
  __m256i v16; // [rsp+A0h] [rbp-E8h]
  __m256i v17; // [rsp+C0h] [rbp-C8h]
  _BYTE v18[96]; // [rsp+E0h] [rbp-A8h]
  _BYTE v19[48]; // [rsp+140h] [rbp-48h] BYREF
  __int64 v20; // [rsp+170h] [rbp-18h]

  v3 = *(__m256i *)(a2 + 0x80);
  v14 = *(__m256i *)a2;
  v15 = *(__m256i *)(a2 + 0x20);
  v16 = *(__m256i *)(a2 + 0x40);
  v17 = *(__m256i *)(a2 + 0x60);
  *(__m256i *)v18 = v3;
  *(__m256i *)&v18[0x20] = *(__m256i *)(a2 + 0xA0);
  *(__m256i *)&v18[0x40] = *(__m256i *)(a2 + 0xC0);
  v6 = *(_OWORD *)(a1 + 0x38);
  *(_DWORD *)&v19[0x28] = v17.m256i_i32[6];
  *(_QWORD *)v19 = v14.m256i_i64[0];
  v7 = v6
     ^ *(_QWORD *)(a1 + 0x40)
     ^ _mm_extract_epi64(*(__m128i *)&v17.m256i_u64[1], 1)
     ^ v17.m256i_i64[1]
     ^ v17.m256i_u32[6];
  v8 = *(__int64 **)(a1 + 0x88);
  *(_OWORD *)&v19[0x18] = *(_OWORD *)&v17.m256i_u64[1];
  *(_OWORD *)&v19[8] = v6;
  v9 = *v8;
  v20 = v14.m256i_i64[0] ^ v7 ^ 0x1234567898765432LL;
  v11 = *(__m256 *)v19;
  v13 = v20;
  v12 = *(_OWORD *)&v19[0x20];
  __asm { vzeroupper }
  v16.m256i_i64[3] = (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v9 + 0x40))(v8, &v11, v15.m256i_i64[0]);
  if ( !v16.m256i_i64[3] )
    sub_14053C120(a1, (__int64)v19, (__int64)&v14);
  return (*(__int64 (__fastcall **)(__int64, __m256i *, __int64))(*(_QWORD *)a1 + 0x88LL))(a1, &v14, a3);
}

// --- End Function: sub_14053BF90 (0x14053BF90) ---

// --- Function: sub_14053C120 (0x14053C120) ---
double __fastcall sub_14053C120(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 v6; // xmm1
  __int64 *v7; // rcx
  __int64 v8; // r8
  double v9; // xmm0_8
  __int64 v10; // rax
  _BYTE v12[2]; // [rsp+30h] [rbp-98h] BYREF
  __int16 v13; // [rsp+32h] [rbp-96h]
  __int64 v14; // [rsp+34h] [rbp-94h]
  int v15; // [rsp+3Ch] [rbp-8Ch]
  unsigned __int64 v16; // [rsp+40h] [rbp-88h]
  unsigned __int64 v17; // [rsp+48h] [rbp-80h]
  __int64 v18; // [rsp+50h] [rbp-78h]
  __int64 v19; // [rsp+58h] [rbp-70h]
  __m256 v20; // [rsp+80h] [rbp-48h] BYREF
  __int128 v21; // [rsp+A0h] [rbp-28h]
  double v22; // [rsp+B0h] [rbp-18h]

  v14 = 1;
  v13 = 0;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v12[0] = 0;
  v16 = __rdtsc();
  v12[1] = *(_BYTE *)(a1 + 0xD2);
  qword_149B4B870(
    v12,
    &word_149B47AD0,
    "Subsumption::Task::InitializeTask",
    "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
    0x1F9);
  v6 = *(_OWORD *)(a2 + 0x20);
  v7 = *(__int64 **)(a1 + 0x88);
  v8 = *(_QWORD *)(a3 + 0x20);
  v20 = *(__m256 *)a2;
  v9 = *(double *)(a2 + 0x30);
  v13 = word_149B47AD0;
  v10 = *v7;
  v22 = v9;
  v21 = v6;
  __asm { vzeroupper }
  *(_QWORD *)(a3 + 0x58) = (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v10 + 0x38))(v7, &v20, v8);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x70LL))(a1, a3);
  v17 = __rdtsc();
  return qword_149B4B878(v12);
}

// --- End Function: sub_14053C120 (0x14053C120) ---

// --- Function: sub_14053C290 (0x14053C290) ---
__int64 __fastcall sub_14053C290(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int128 v3; // xmm6
  __int64 v4; // r13
  __int64 v6; // rcx
  __int64 v7; // rax
  const void *v8; // rdi
  size_t n0x1FF_1; // rbx
  _BYTE *v10; // rax
  const char *v11; // rax
  __int64 v12; // rcx
  unsigned __int8 *v13; // r15
  _BYTE *v14; // rax
  _BYTE *v15; // rax
  _BYTE *v16; // rax
  int v17; // r14d
  void *v18; // rdi
  unsigned __int64 v19; // rbx
  unsigned __int64 allocSize_1; // rsi
  unsigned __int64 allocSize; // rbx
  const void *v22; // rcx
  __int64 v23; // rax
  unsigned int v24; // esi
  int v25; // r15d
  unsigned int i; // r14d
  _BYTE *v27; // rdi
  size_t n0x1FF_4; // rbx
  _BYTE *v29; // rax
  __int64 *v30; // rax
  __m128i v31; // xmm6
  __int64 v32; // rax
  signed __int64 epi64; // rax
  _BYTE *Src_1; // rdi
  unsigned __int64 v35; // rbx
  void *v36; // rax
  unsigned __int64 allocSize_2; // rbx
  __int64 v38; // rax
  int v39; // r14d
  __int64 v40; // rbx
  const char *v41; // rax
  char *v42; // rdi
  __m128i v43; // xmm0
  char *v44; // rbx
  __int64 *v45; // rax
  __m128i v46; // xmm6
  __int64 v47; // rax
  signed __int64 v48; // rax
  unsigned __int64 v49; // rbx
  void *v50; // rax
  unsigned __int64 allocSize_4; // rbx
  __int64 v52; // rax
  int v53; // r14d
  int v54; // r15d
  _BYTE *v55; // rdi
  size_t n0x1FF_7; // rbx
  _BYTE *v57; // rax
  __int64 *v58; // rax
  __int64 v59; // rdx
  __int128 v60; // xmm0
  int v61; // eax
  __int64 v62; // r15
  _QWORD *v63; // rbx
  unsigned int v64; // r13d
  _BYTE *v65; // rsi
  size_t n0x1FF_10; // rdi
  _BYTE *v67; // rax
  _BYTE *v68; // rsi
  __int64 *v69; // rax
  _QWORD *v70; // r14
  _QWORD *v71; // rcx
  __m128i v72; // xmm0
  __int64 v73; // rdx
  unsigned __int64 v74; // rdi
  unsigned __int64 v75; // r8
  __int64 v76; // rax
  unsigned __int64 v77; // r10
  bool v78; // cf
  bool v79; // cf
  __int64 *v80; // rsi
  _QWORD *v81; // rdi
  __int64 v82; // r15
  __int64 v83; // rax
  unsigned __int8 (__fastcall *v84)(__int64 *, _QWORD *, __int64, __int64, __int64 *, __int64); // r14
  __int64 v85; // r15
  int v86; // eax
  const ULONG_PTR *v87; // r9
  void *v88; // rcx
  int v89; // eax
  _QWORD *v90; // rdi
  _QWORD *v91; // rbx
  _QWORD *v92; // rsi
  __int64 *v93; // r8
  __int64 *v94; // rcx
  __int64 *v95; // rax
  __int64 *v96; // rcx
  __int64 v97; // rax
  void (__fastcall *v98)(__int64 *, _QWORD *, __int64, __int128 *); // r10
  __int64 v99; // r8
  unsigned int v100; // ebx
  const char *p_Failed_to_create_Subsumption_task_at_line_%d_because_it_doesn; // rbx
  unsigned int v102; // eax
  __int64 v104; // [rsp+30h] [rbp-D8h]
  __int64 v105; // [rsp+38h] [rbp-D0h]
  __int64 *v106; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v107; // [rsp+50h] [rbp-B8h] BYREF
  _QWORD *v108; // [rsp+58h] [rbp-B0h]
  __int64 v109; // [rsp+60h] [rbp-A8h]
  __int64 v110; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v111; // [rsp+70h] [rbp-98h]
  void *Src; // [rsp+78h] [rbp-90h] BYREF
  __int64 v113; // [rsp+80h] [rbp-88h] BYREF
  const char *v114; // [rsp+88h] [rbp-80h]
  __int64 v115; // [rsp+90h] [rbp-78h] BYREF
  __int64 v116; // [rsp+98h] [rbp-70h]
  __int128 v117; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v118; // [rsp+B0h] [rbp-58h] BYREF
  unsigned int v119; // [rsp+B8h] [rbp-50h] BYREF
  const void *v120; // [rsp+C0h] [rbp-48h]
  unsigned __int64 allocSize_3; // [rsp+C8h] [rbp-40h]
  unsigned int v122; // [rsp+D0h] [rbp-38h] BYREF
  const void *v123; // [rsp+D8h] [rbp-30h]
  unsigned __int64 allocSize_5; // [rsp+E0h] [rbp-28h]
  __int64 v125; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v126; // [rsp+F0h] [rbp-18h] BYREF
  _BYTE v127[2]; // [rsp+F8h] [rbp-10h] BYREF
  __int16 v128; // [rsp+FAh] [rbp-Eh]
  __int64 v129; // [rsp+FCh] [rbp-Ch]
  int v130; // [rsp+104h] [rbp-4h]
  unsigned __int64 v131; // [rsp+108h] [rbp+0h]
  unsigned __int64 v132; // [rsp+110h] [rbp+8h]
  __int64 v133; // [rsp+118h] [rbp+10h]
  __int64 v134; // [rsp+120h] [rbp+18h]
  __int128 v135; // [rsp+148h] [rbp+40h] BYREF
  double v136; // [rsp+158h] [rbp+50h]
  char v137[16]; // [rsp+160h] [rbp+58h] BYREF
  char v138[16]; // [rsp+170h] [rbp+68h] BYREF
  __m128i v139; // [rsp+180h] [rbp+78h]
  char v140[16]; // [rsp+190h] [rbp+88h] BYREF
  char v141[16]; // [rsp+1A0h] [rbp+98h] BYREF
  __m128i v142; // [rsp+1B0h] [rbp+A8h]
  char v143[16]; // [rsp+1C0h] [rbp+B8h] BYREF
  char v144[16]; // [rsp+1D0h] [rbp+C8h] BYREF
  __m128i v145; // [rsp+1E0h] [rbp+D8h]
  size_t n0x1FF_11; // [rsp+1F8h] [rbp+F0h]
  __int64 n0x1FF_9; // [rsp+200h] [rbp+F8h]
  void *v148; // [rsp+208h] [rbp+100h]
  _BYTE v149[520]; // [rsp+210h] [rbp+108h] BYREF
  size_t n0x1FF_5; // [rsp+418h] [rbp+310h]
  __int64 n0x1FF_3; // [rsp+420h] [rbp+318h]
  void *v152; // [rsp+428h] [rbp+320h]
  _BYTE v153[520]; // [rsp+430h] [rbp+328h] BYREF
  size_t n0x1FF_8; // [rsp+638h] [rbp+530h]
  __int64 n0x1FF_6; // [rsp+640h] [rbp+538h]
  void *v156; // [rsp+648h] [rbp+540h]
  _BYTE v157[520]; // [rsp+650h] [rbp+548h] BYREF
  size_t n0x1FF_2; // [rsp+858h] [rbp+750h]
  __int64 n0x1FF; // [rsp+860h] [rbp+758h]
  void *v160; // [rsp+868h] [rbp+760h]
  _BYTE v161[520]; // [rsp+870h] [rbp+768h] BYREF
  __int128 v162; // [rsp+A88h] [rbp+980h]

  v4 = a1;
  v109 = a3;
  v108 = a2;
  v116 = a1;
  v128 = 0;
  v129 = 1;
  v130 = 0;
  v132 = 0;
  v133 = 0;
  v134 = 0;
  v127[0] = 0;
  v131 = __rdtsc();
  v127[1] = *(_BYTE *)(a1 + 0xD2);
  qword_149B4B870(
    v127,
    &word_149B47AB4,
    "Subsumption::Task::LoadFromXml",
    "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
    0x18);
  v6 = *a2;
  v128 = word_149B47AB4;
  v7 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v6 + 0x110LL))(v6, "ID");
  v161[0] = 0;
  v8 = (const void *)v7;
  n0x1FF_2 = 0;
  n0x1FF = 0x1FF;
  v160 = v161;
  if ( !v7 )
    goto LABEL_152;
  n0x1FF_1 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0x1FF_1;
  while ( *(_BYTE *)(v7 + n0x1FF_1) );
  if ( !n0x1FF_1 )
    goto LABEL_152;
  v10 = v161;
  if ( n0x1FF_1 + 1 > 0x200 )
  {
    v10 = (_BYTE *)allocWithProfilerInfo(n0x1FF_1 + 1, 0);
    qword_149B3AB68 += n0x1FF_1 + 1;
    n0x1FF = n0x1FF_1;
  }
  v160 = v10;
  n0x1FF_2 = n0x1FF_1;
  v10[n0x1FF_1] = 0;
  memcpy(v160, v8, n0x1FF_1);
  if ( !n0x1FF_2 )
  {
LABEL_152:
    p_Failed_to_create_Subsumption_task_at_line_%d_because_it_doesn = "Failed to create Subsumption task at line %d becau"
                                                                      "se it doesn't contain a valid 'ID'";
    goto LABEL_153;
  }
  *(_OWORD *)(v4 + 0x38) = *(_OWORD *)sub_1402BC380((__int64 *)v137, (char *)v160);
  v11 = (const char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a2 + 0x110LL))(*a2, "Name");
  v12 = *a2;
  v13 = (unsigned __int8 *)v11;
  v114 = v11;
  v14 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v12 + 0x110LL))(v12, "DebugStart");
  assignCStringToStringStructure((void **)(v4 + 0xF0), v14);
  v15 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a2 + 0x110LL))(*a2, "DebugSuccess");
  assignCStringToStringStructure((void **)(v4 + 0xF8), v15);
  v16 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*a2 + 0x110LL))(*a2, "DebugFailure");
  assignCStringToStringStructure((void **)(v4 + 0x100), v16);
  if ( !v13 || !*v13 )
  {
    p_Failed_to_create_Subsumption_task_at_line_%d_because_it_doesn = "Failed to create Subsumption task at line %d becau"
                                                                      "se it doesn't contain the 'Name'";
LABEL_153:
    v102 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    sub_1405C0E00(4u, 0, p_Failed_to_create_Subsumption_task_at_line_%d_because_it_doesn, v102);
    v100 = 0;
    goto LABEL_154;
  }
  v17 = sub_1402E1FE0(v13, 0xFFFFFFFF);
  v18 = 0;
  v19 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v19;
  while ( v13[v19] );
  allocSize_1 = 0;
  allocSize = v19 + 1;
  if ( allocSize )
  {
    v18 = (void *)allocWithProfilerInfo(allocSize, 0);
    allocSize_1 = allocSize;
  }
  memcpy(v18, v13, allocSize);
  v22 = *(const void **)(v4 + 0x50);
  *(_DWORD *)(v4 + 0x48) = v17;
  *(_QWORD *)(v4 + 0x50) = v18;
  *(_QWORD *)(v4 + 0x58) = allocSize_1;
  if ( v22 )
    sub_147605980(v22);
  (*(void (__fastcall **)(_QWORD, __int64 **, const char *))(*(_QWORD *)*v108 + 0x168LL))(*v108, &v106, "Links");
  if ( v106 )
  {
    v23 = *v106;
    v162 = v3;
    v24 = 0;
    v25 = (*(__int64 (**)(void))(v23 + 0x50))();
    for ( i = 0; (int)i < v25; ++i )
    {
      Src = 0;
      v125 = 0;
      if ( (*(unsigned __int8 (__fastcall **)(__int64 *, _QWORD, void **, __int64 *))(*v106 + 0x58))(
             v106,
             i,
             &Src,
             &v125)
        && Src
        && *(_BYTE *)Src )
      {
        v27 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *))(*v106 + 0x110))(v106);
        v153[0] = 0;
        n0x1FF_5 = 0;
        v152 = v153;
        n0x1FF_3 = 0x1FF;
        if ( v27 )
        {
          n0x1FF_4 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++n0x1FF_4;
          while ( v27[n0x1FF_4] );
          if ( n0x1FF_4 )
          {
            v29 = v153;
            if ( n0x1FF_4 + 1 > 0x200 )
            {
              v29 = (_BYTE *)allocWithProfilerInfo(n0x1FF_4 + 1, 0);
              qword_149B3AB68 += n0x1FF_4 + 1;
              n0x1FF_3 = n0x1FF_4;
            }
            v152 = v29;
            n0x1FF_5 = n0x1FF_4;
            v29[n0x1FF_4] = 0;
            memcpy(v152, v27, n0x1FF_4);
            if ( !n0x1FF_5 )
              goto LABEL_40;
            v30 = sub_1402BC380((__int64 *)v138, (char *)v152);
            v31 = *(__m128i *)v30;
            v32 = *v30;
            v139 = v31;
            if ( v32 || (epi64 = _mm_extract_epi64(v31, 1)) != 0 )
              LOBYTE(epi64) = 1;
            if ( (_BYTE)epi64 )
            {
              Src_1 = Src;
              v24 = 0;
              v119 = sub_1402E1FE0((unsigned __int8 *)Src, 0xFFFFFFFF);
              v120 = 0;
              allocSize_3 = 0;
              if ( Src_1 )
              {
                v35 = 0xFFFFFFFFFFFFFFFFuLL;
                do
                  ++v35;
                while ( Src_1[v35] );
                v36 = 0;
                allocSize_2 = v35 + 1;
                if ( allocSize_2 )
                {
                  v36 = (void *)allocWithProfilerInfo(allocSize_2, 0);
                  v120 = v36;
                  allocSize_3 = allocSize_2;
                }
                memcpy(v36, Src_1, allocSize_2);
              }
              v38 = sub_14053ACC0(v4 + 0x60, &v119);
              *(__m128i *)v38 = v31;
              *(_QWORD *)(v38 + 0x10) = 0;
              if ( v120 )
                sub_147605980(v120);
            }
            else
            {
LABEL_40:
              v24 = 0;
            }
          }
        }
        if ( v152 != v153 )
        {
          qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_3;
          sub_147605980(v152);
        }
      }
    }
    v39 = (*(__int64 (__fastcall **)(__int64 *))(*v106 + 0x158))(v106);
    if ( v39 > 0 )
    {
      v40 = v109;
      while ( 1 )
      {
        (*(void (__fastcall **)(__int64 *, __int64 *, _QWORD))(*v106 + 0x160))(v106, &v107, v24);
        v41 = (const char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v107 + 0x110LL))(v107, "ID");
        v42 = (char *)v41;
        if ( !*(_BYTE *)(v40 + 0x58) || !v41 || !*v41 || !sscanf_s_w(v41) )
          break;
        v43 = *(__m128i *)sub_1402BC380((__int64 *)v140, v42);
        if ( !*(_BYTE *)(v40 + 0x58)
          || *(_QWORD *)(v40 + 0x48) == v43.m128i_i64[0] && *(_QWORD *)(v40 + 0x50) == _mm_extract_epi64(v43, 1) )
        {
          v44 = (char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v107 + 0x110LL))(v107, "TaskID");
          goto LABEL_57;
        }
        if ( v107 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v107 + 0x28LL))(v107);
LABEL_74:
        if ( (int)++v24 >= v39 )
          goto LABEL_75;
      }
      v44 = (char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v107 + 0x110LL))(v107, "TaskID");
      if ( v42 )
      {
LABEL_57:
        if ( v44 && *v42 && *v44 && sscanf_s_w(v44) )
        {
          v45 = sub_1402BC380((__int64 *)v141, v44);
          v46 = *(__m128i *)v45;
          v47 = *v45;
          v142 = v46;
          if ( v47 || (v48 = _mm_extract_epi64(v46, 1)) != 0 )
            LOBYTE(v48) = 1;
          if ( (_BYTE)v48 )
          {
            v122 = sub_1402E1FE0((unsigned __int8 *)v42, 0xFFFFFFFF);
            v123 = 0;
            v49 = 0xFFFFFFFFFFFFFFFFuLL;
            allocSize_5 = 0;
            do
              ++v49;
            while ( v42[v49] );
            v50 = 0;
            allocSize_4 = v49 + 1;
            if ( allocSize_4 )
            {
              v50 = (void *)allocWithProfilerInfo(allocSize_4, 0);
              v123 = v50;
              allocSize_5 = allocSize_4;
            }
            memcpy(v50, v42, allocSize_4);
            v52 = sub_14053ACC0(v4 + 0x60, &v122);
            *(__m128i *)v52 = v46;
            *(_QWORD *)(v52 + 0x10) = 0;
            if ( v123 )
              sub_147605980(v123);
          }
        }
      }
      if ( v107 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v107 + 0x28LL))(v107);
      v40 = v109;
      goto LABEL_74;
    }
LABEL_75:
    (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(*v106 + 0x168))(v106, &v113, "ParallelTasks");
    if ( v113 )
    {
      v53 = 0;
      v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v113 + 0x158LL))(v113);
      if ( v54 > 0 )
      {
        do
        {
          (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v113 + 0x160LL))(
            v113,
            &v118,
            (unsigned int)v53);
          v55 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v118 + 0x110LL))(v118, "ID");
          v157[0] = 0;
          n0x1FF_8 = 0;
          v156 = v157;
          n0x1FF_6 = 0x1FF;
          if ( !v55 )
            goto LABEL_87;
          n0x1FF_7 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++n0x1FF_7;
          while ( v55[n0x1FF_7] );
          if ( !n0x1FF_7 )
            goto LABEL_87;
          v57 = v157;
          if ( n0x1FF_7 + 1 > 0x200 )
          {
            v57 = (_BYTE *)allocWithProfilerInfo(n0x1FF_7 + 1, 0);
            qword_149B3AB68 += n0x1FF_7 + 1;
            n0x1FF_6 = n0x1FF_7;
          }
          v156 = v57;
          n0x1FF_8 = n0x1FF_7;
          v57[n0x1FF_7] = 0;
          memcpy(v156, v55, n0x1FF_7);
          if ( n0x1FF_8 )
          {
            v58 = sub_1402BC380((__int64 *)v143, (char *)v156);
            v59 = *(_QWORD *)(v4 + 0x78);
            v136 = 0.0;
            v60 = *(_OWORD *)v58;
            v135 = *(_OWORD *)v58;
            if ( v59 == *(_QWORD *)(v4 + 0x80) )
            {
              sub_1402A7670((__int64 *)(v4 + 0x70), (_BYTE *)v59, (__int64)&v135);
            }
            else
            {
              *(_OWORD *)v59 = v60;
              *(double *)(v59 + 0x10) = v136;
              *(_QWORD *)(v4 + 0x78) += 0x18LL;
            }
          }
          else
          {
LABEL_87:
            v61 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v108 + 0x1B0LL))(*v108);
            sub_1405C0E00(
              4u,
              0,
              "Failed to load Subsumption parallel task for '%s' task at line %d because it doesn't contain the 'ID'",
              v114,
              v61);
          }
          if ( v156 != v157 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_6;
            sub_147605980(v156);
          }
          if ( v118 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v118 + 0x28LL))(v118);
          ++v53;
        }
        while ( v53 < v54 );
      }
      if ( v113 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v113 + 0x28LL))(v113);
    }
    if ( v106 )
      (*(void (__fastcall **)(__int64 *))(*v106 + 0x28))(v106);
  }
  v62 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v4 + 0x88) + 0x58LL))(*(_QWORD *)(v4 + 0x88));
  *(_QWORD *)&v117 = v62;
  v63 = *(_QWORD **)(v62 + 8);
  (*(void (__fastcall **)(_QWORD, __int64 *, const char *))(*(_QWORD *)*v108 + 0x168LL))(*v108, &v115, "Variables");
  if ( v115 )
  {
    v64 = 0;
    LODWORD(v111) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v115 + 0x158LL))(v115);
    if ( (int)v111 > 0 )
    {
      while ( 1 )
      {
        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v115 + 0x160LL))(v115, &v110, v64);
        v65 = (_BYTE *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v110 + 0x110LL))(v110, "ID");
        v149[0] = 0;
        n0x1FF_11 = 0;
        v148 = v149;
        n0x1FF_9 = 0x1FF;
        if ( v65 )
        {
          n0x1FF_10 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++n0x1FF_10;
          while ( v65[n0x1FF_10] );
          if ( n0x1FF_10 )
          {
            v67 = v149;
            if ( n0x1FF_10 + 1 > 0x200 )
            {
              v67 = (_BYTE *)allocWithProfilerInfo(n0x1FF_10 + 1, 0);
              qword_149B3AB68 += n0x1FF_10 + 1;
              n0x1FF_9 = n0x1FF_10;
            }
            v148 = v67;
            n0x1FF_11 = n0x1FF_10;
            v67[n0x1FF_10] = 0;
            memcpy(v148, v65, n0x1FF_10);
            if ( n0x1FF_11 )
              break;
          }
        }
        v89 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v108 + 0x1B0LL))(*v108);
        sub_1405C0E00(
          4u,
          0,
          "[Task::LoadFromXml] Failed to create Subsumption variable for '%s' task at line %d because it doesn't contain the 'ID'",
          v114,
          v89);
        v88 = v148;
        if ( v148 != v149 )
          goto LABEL_129;
LABEL_130:
        if ( v110 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v110 + 0x28LL))(v110);
        if ( (int)++v64 >= (int)v111 )
          goto LABEL_133;
      }
      v68 = v148;
      v69 = sub_1402BC380((__int64 *)v144, (char *)v148);
      v70 = *(_QWORD **)(v62 + 8);
      v71 = *(_QWORD **)v62;
      v72 = *(__m128i *)v69;
      v73 = (unsigned __int128)(((__int64)v70 - *(_QWORD *)v62) * (__int128)0x4EC4EC4EC4EC4EC5LL) >> 0x40;
      v145 = v72;
      v74 = _mm_extract_epi64(v72, 1);
      v75 = ((unsigned __int64)v73 >> 0x3F) + (v73 >> 5);
      while ( v75 )
      {
        v76 = 0xD * (v75 >> 1);
        v77 = v71[v76];
        v78 = v77 < v72.m128i_i64[0];
        if ( v77 == v72.m128i_i64[0] )
          v78 = v71[v76 + 1] < v74;
        if ( v78 )
        {
          v71 = (_QWORD *)((char *)v71 + v76 * 8 + 0x68);
          v75 += 0xFFFFFFFFFFFFFFFFuLL - (v75 >> 1);
        }
        else
        {
          v75 >>= 1;
        }
      }
      if ( v71 != v70 )
      {
        v79 = v72.m128i_i64[0] < *v71;
        if ( v72.m128i_i64[0] == *v71 )
          v79 = v74 < v71[1];
        if ( v79 )
          v71 = v70;
      }
      if ( v71 != v63 )
      {
        v80 = (__int64 *)v71[8];
        v81 = v71 + 2;
        v82 = v71[0xB];
        v83 = *v80;
        v126 = v110;
        v84 = *(unsigned __int8 (__fastcall **)(__int64 *, _QWORD *, __int64, __int64, __int64 *, __int64))(v83 + 0x40);
        if ( v110 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v110 + 0x20LL))(v110);
        v104 = v82;
        v85 = v109;
        if ( !v84(v80, v81, v109, v116 + 0x10 * (*((int *)v81 + 9) + 0xALL), &v126, v104) )
        {
          v86 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v108 + 0x1B0LL))(*v108);
          v87 = &byte_14819E9C2;
          LODWORD(v105) = v86;
          if ( v81[1] )
            v87 = (const ULONG_PTR *)v81[1];
          sub_1405C0E00(
            4u,
            0,
            "[Task::LoadFromXml] Failed to create Subsumption variable '%s' for '%s' task in file '%s' at line %d",
            v87,
            v114,
            *(_QWORD *)(v85 + 0x18),
            v105);
        }
        v62 = v117;
        v68 = v148;
      }
      if ( v68 == v149 )
        goto LABEL_130;
      v88 = v68;
LABEL_129:
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_9;
      sub_147605980(v88);
      goto LABEL_130;
    }
LABEL_133:
    if ( v115 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v115 + 0x28LL))(v115);
    v4 = v116;
  }
  v90 = *(_QWORD **)(v62 + 8);
  v91 = *(_QWORD **)v62;
  if ( *(_QWORD **)v62 != v90 )
  {
    v92 = v91 + 0xA;
    do
    {
      v93 = *(__int64 **)(v4 + 0x10 * (*((int *)v92 + 0xFFFFFFF9) + 0xALL));
      v94 = v93;
      v95 = (__int64 *)v93[1];
      while ( !*((_BYTE *)v95 + 0x19) )
      {
        if ( *((_DWORD *)v95 + 8) >= *((_DWORD *)v92 + 0xFFFFFFF0) )
        {
          v94 = v95;
          v95 = (__int64 *)*v95;
        }
        else
        {
          v95 = (__int64 *)v95[2];
        }
      }
      if ( *((_BYTE *)v94 + 0x19) || *((_DWORD *)v92 + 0xFFFFFFF0) < *((_DWORD *)v94 + 8) || v94 == v93 )
      {
        v96 = (__int64 *)v92[0xFFFFFFFE];
        v97 = *v96;
        v117 = 0;
        v98 = *(void (__fastcall **)(__int64 *, _QWORD *, __int64, __int128 *))(v97 + 0x48);
        if ( *v92 )
          _InterlockedIncrement((volatile signed __int32 *)(*v92 + 8LL));
        v99 = *((int *)v92 + 0xFFFFFFF9) + 0xALL;
        v117 = *(_OWORD *)(v92 + 0xFFFFFFFF);
        v98(v96, v92 + 0xFFFFFFF8, v4 + 0x10 * v99, &v117);
      }
      v91 += 0xD;
      v92 += 0xD;
    }
    while ( v91 != v90 );
  }
  v100 = 1;
LABEL_154:
  if ( v160 != v161 )
  {
    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
    sub_147605980(v160);
  }
  v132 = __rdtsc();
  qword_149B4B878(v127);
  return v100;
}

// --- End Function: sub_14053C290 (0x14053C290) ---

// --- Function: sub_14053D1C0 (0x14053D1C0) ---
void __fastcall sub_14053D1C0(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 0xD2) = a2;
}

// --- End Function: sub_14053D1C0 (0x14053D1C0) ---

// --- Function: sub_14053D5C0 (0x14053D5C0) ---
char sub_14053D5C0(__int64 a1, __int64 a2, unsigned int n2, const char *Format, ...)
{
  va_list va; // [rsp+60h] [rbp+28h] BYREF

  va_start(va, Format);
  return sub_14053D5E0(a1, a2, n2, Format, va);
}

// --- End Function: sub_14053D5C0 (0x14053D5C0) ---

// --- Function: sub_14053D5E0 (0x14053D5E0) ---
void __fastcall sub_14053D5E0(__int64 a1, __int64 a2, unsigned int n2, const char *Format_1, va_list va)
{
  __int64 v7; // rsi
  unsigned __int64 *v9; // rax
  const char **v10; // r13
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbx
  __int64 v12; // rax
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rsi
  const char *v14; // rbx
  const char *v15; // rdi
  const char *v16; // r14
  const char *v17; // rax
  int n72; // edi
  int v19; // edi
  __int64 v20; // rcx
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_2; // rax
  bool v22; // zf
  const char *v23; // rax
  size_t *v24; // rax
  _BYTE *v25; // rcx
  size_t n511_2; // rbx
  const void *v27; // r14
  _BYTE *v28; // rax
  float *v29; // r9
  float v30; // xmm2_4
  __int64 v31; // [rsp+50h] [rbp-B0h] BYREF
  float v32; // [rsp+58h] [rbp-A8h]
  float v33; // [rsp+5Ch] [rbp-A4h]
  __int128 v34; // [rsp+60h] [rbp-A0h] BYREF
  size_t n511_3; // [rsp+70h] [rbp-90h]
  __int64 n511_1; // [rsp+78h] [rbp-88h]
  void *v37; // [rsp+80h] [rbp-80h]
  _BYTE v38[520]; // [rsp+88h] [rbp-78h] BYREF
  __int64 v39; // [rsp+290h] [rbp+190h] BYREF
  __int64 n511; // [rsp+298h] [rbp+198h]
  _BYTE *v41; // [rsp+2A0h] [rbp+1A0h]
  _BYTE v42[520]; // [rsp+2A8h] [rbp+1A8h] BYREF
  char Buffer[4096]; // [rsp+4B0h] [rbp+3B0h] BYREF

  v31 = a1;
  v7 = a1;
  memset(Buffer, 0, sizeof(Buffer));
  v9 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v9, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  v10 = (const char **)(v7 + 80);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&byte_14819E9C2;
  if ( *(_BYTE *)(a2 + 80) )
  {
    v12 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v7 + 136) + 16LL))(*(_QWORD *)(v7 + 136));
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const char *)&byte_14819E9C2;
    v14 = *(const char **)(a2 + 64);
    v15 = *(const char **)(a2 + 56);
    v16 = (const char *)v12;
    if ( *v10 )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *v10;
    v17 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 8) + 112LL))(*(_QWORD *)(a2 + 8));
    sub_1405C0E00(
      4u,
      n2,
      "[Subsumption] %s|%s.%s.%s (%s): %s",
      v17,
      v15,
      v14,
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
      v16,
      Buffer);
    v7 = v31;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&byte_14819E9C2;
  }
  n72 = 72;
  if ( n2 )
    n72 = 8;
  v19 = *(_DWORD *)(a2 + 48) | n72;
  if ( sub_140393530(*(_QWORD *)(a2 + 40), v19) )
  {
    v20 = *(_QWORD *)(v7 + 136);
    v41 = v42;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = *v10;
    v22 = *v10 == 0;
    v42[0] = 0;
    v39 = 0;
    if ( !v22 )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
    n511 = 511;
    v23 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 24LL))(v20);
    v24 = (size_t *)sub_1402A3190((__int64)&v39, "  %s (%s): %s", v23, p_p_p_p_p_p_p_p_p_p_p_p_Source, Buffer);
    v38[0] = 0;
    v25 = v38;
    v37 = v38;
    n511_3 = 0;
    n511_1 = 511;
    n511_2 = *v24;
    v27 = (const void *)v24[2];
    if ( *v24 > 0x1FF )
    {
      v28 = v38;
      if ( n511_2 + 1 > 0x200 )
      {
        v28 = (_BYTE *)allocWithProfilerInfo(n511_2 + 1, 0);
        qword_149B3AB68 += n511_2 + 1;
        n511_1 = n511_2;
      }
      v37 = v28;
      n511_3 = n511_2;
      v28[n511_2] = 0;
      v25 = v37;
    }
    memmove(v25, v27, n511_2);
    n511_3 = n511_2;
    *((_BYTE *)v37 + n511_2) = 0;
    if ( v41 != v42 )
    {
      qword_149B3AB68 += -1 - n511;
      sub_147605980(v41);
    }
    if ( n2 )
    {
      if ( n2 == 2 )
        v30 = 0.0;
      else
        v30 = 1.0;
      v31 = 0x3F8000003F800000LL;
      v32 = v30;
      v33 = 1.0;
      v29 = (float *)&v31;
    }
    else
    {
      v34 = xmmword_1481D9FB0;
      v29 = (float *)&v34;
    }
    sub_14038F6D0(*(__int64 **)(a2 + 40), v37, v19, v29, 0);
    if ( v37 != v38 )
    {
      qword_149B3AB68 += -1 - n511_1;
      sub_147605980(v37);
    }
  }
}

// --- End Function: sub_14053D5E0 (0x14053D5E0) ---

// --- Function: sub_14053D8F0 (0x14053D8F0) ---
__int64 __fastcall sub_14053D8F0(__int64 a1, __int64 a2)
{
  __m256i v2; // ymm1
  __int128 v4; // xmm1
  signed __int64 v5; // rdx
  __int64 *v6; // rcx
  __int64 v7; // rax
  __int64 result; // rax
  __int64 *v9; // rcx
  __int64 v10; // rax
  __m256 v11; // [rsp+20h] [rbp-E0h] BYREF
  __int128 v12; // [rsp+40h] [rbp-C0h]
  __int64 v13; // [rsp+50h] [rbp-B0h]
  __m256i v14; // [rsp+60h] [rbp-A0h] BYREF
  __m256i v15; // [rsp+80h] [rbp-80h]
  __m256i v16; // [rsp+A0h] [rbp-60h]
  __m256i v17; // [rsp+C0h] [rbp-40h]
  _BYTE v18[96]; // [rsp+E0h] [rbp-20h]
  _BYTE v19[48]; // [rsp+140h] [rbp+40h]
  __int64 v20; // [rsp+170h] [rbp+70h]

  v2 = *(__m256i *)(a2 + 0x80);
  v14 = *(__m256i *)a2;
  v15 = *(__m256i *)(a2 + 0x20);
  v16 = *(__m256i *)(a2 + 0x40);
  v17 = *(__m256i *)(a2 + 0x60);
  *(__m256i *)v18 = v2;
  *(__m256i *)&v18[0x20] = *(__m256i *)(a2 + 0xA0);
  *(__m256i *)&v18[0x40] = *(__m256i *)(a2 + 0xC0);
  v4 = *(_OWORD *)(a1 + 0x38);
  *(_DWORD *)&v19[0x28] = v17.m256i_i32[6];
  *(_QWORD *)v19 = v14.m256i_i64[0];
  v5 = v4
     ^ *(_QWORD *)(a1 + 0x40)
     ^ _mm_extract_epi64(*(__m128i *)&v17.m256i_u64[1], 1)
     ^ v17.m256i_i64[1]
     ^ v17.m256i_u32[6];
  v6 = *(__int64 **)(a1 + 0x88);
  *(_OWORD *)&v19[8] = v4;
  *(_OWORD *)&v19[0x18] = *(_OWORD *)&v17.m256i_u64[1];
  v7 = *v6;
  v20 = v14.m256i_i64[0] ^ v5 ^ 0x1234567898765432LL;
  v11 = *(__m256 *)v19;
  v13 = v20;
  v12 = *(_OWORD *)&v19[0x20];
  __asm { vzeroupper }
  result = (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v7 + 0x40))(v6, &v11, v15.m256i_i64[0]);
  v16.m256i_i64[3] = result;
  if ( result )
  {
    (*(void (__fastcall **)(__int64, __m256i *))(*(_QWORD *)a1 + 0x80LL))(a1, &v14);
    v9 = *(__int64 **)(a1 + 0x88);
    v11 = *(__m256 *)v19;
    v10 = *v9;
    v12 = *(_OWORD *)&v19[0x20];
    v13 = v20;
    __asm { vzeroupper }
    return (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v10 + 0x48))(v9, &v11, v15.m256i_i64[0]);
  }
  return result;
}

// --- End Function: sub_14053D8F0 (0x14053D8F0) ---

// --- Function: sub_14053DA80 (0x14053DA80) ---
__int64 __fastcall sub_14053DA80(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int64 v5; // rsi
  const ULONG_PTR *v8; // rdx
  __m256i v9; // ymm1
  _QWORD *_Newvec; // r15
  __int128 v11; // xmm6
  int v12; // edi
  __int64 v13; // rdx
  _QWORD *v14; // rbx
  __int128 v15; // xmm0
  __int64 v16; // rdx
  int v17; // r12d
  __int64 *v18; // rcx
  __int128 v19; // xmm6
  __int64 v20; // rax
  __int64 v21; // xmm7_8
  _BYTE *v22; // rdx
  int v23; // edi
  const char *v24; // rsi
  const char *v25; // rbx
  const char *v26; // rdi
  const char *v27; // rax
  const ULONG_PTR *v28; // rsi
  __int64 v29; // rcx
  const ULONG_PTR *v30; // rax
  __int64 v31; // rbx
  __int64 v32; // rax
  const char *p__%s:_%s___%s___%s%s; // rdx
  const char *p_Success; // rcx
  size_t *v35; // rax
  _BYTE *v36; // rcx
  size_t n0x1FF_2; // rbx
  void *v38; // rdx
  _BYTE *v39; // rax
  int v40; // ebx
  int v41; // ebx
  _BYTE *v42; // rdx
  __int64 *v43; // rcx
  __int64 v44; // rax
  __int64 v45; // rax
  int v46; // ebx
  __int64 v47; // rdi
  __int64 v48; // rax
  __int64 i; // rcx
  __int64 v51; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v52; // [rsp+64h] [rbp-A4h] BYREF
  __int64 v53; // [rsp+6Ch] [rbp-9Ch]
  int v54; // [rsp+74h] [rbp-94h]
  unsigned __int64 v55; // [rsp+78h] [rbp-90h]
  unsigned __int64 v56; // [rsp+80h] [rbp-88h]
  __int64 v57; // [rsp+88h] [rbp-80h]
  __int64 v58; // [rsp+90h] [rbp-78h]
  void *Src[2]; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v60; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v61; // [rsp+D0h] [rbp-38h]
  _BYTE v62[2]; // [rsp+D8h] [rbp-30h] BYREF
  __int16 v63; // [rsp+DAh] [rbp-2Eh]
  __int64 v64; // [rsp+DCh] [rbp-2Ch]
  int v65; // [rsp+E4h] [rbp-24h]
  unsigned __int64 v66; // [rsp+E8h] [rbp-20h]
  unsigned __int64 v67; // [rsp+F0h] [rbp-18h]
  __int64 v68; // [rsp+F8h] [rbp-10h]
  __int64 v69; // [rsp+100h] [rbp-8h]
  _BYTE v70[2]; // [rsp+128h] [rbp+20h] BYREF
  __int16 v71; // [rsp+12Ah] [rbp+22h]
  __int64 v72; // [rsp+12Ch] [rbp+24h]
  int v73; // [rsp+134h] [rbp+2Ch]
  unsigned __int64 v74; // [rsp+138h] [rbp+30h]
  unsigned __int64 v75; // [rsp+140h] [rbp+38h]
  __int64 v76; // [rsp+148h] [rbp+40h]
  __int64 v77; // [rsp+150h] [rbp+48h]
  __m256 v78; // [rsp+178h] [rbp+70h] BYREF
  __int128 v79; // [rsp+198h] [rbp+90h]
  __int64 v80; // [rsp+1A8h] [rbp+A0h]
  __m256 v81; // [rsp+1B8h] [rbp+B0h] BYREF
  __int128 v82; // [rsp+1D8h] [rbp+D0h]
  __int64 v83; // [rsp+1E8h] [rbp+E0h]
  __m256i v84; // [rsp+1F8h] [rbp+F0h] BYREF
  __m256i v85; // [rsp+218h] [rbp+110h]
  __m256i v86; // [rsp+238h] [rbp+130h]
  __m256i v87; // [rsp+258h] [rbp+150h]
  _BYTE v88[96]; // [rsp+278h] [rbp+170h]
  __int128 v89; // [rsp+2D8h] [rbp+1D0h] BYREF
  _BYTE v90[48]; // [rsp+2E8h] [rbp+1E0h] BYREF
  __int64 v91; // [rsp+318h] [rbp+210h]
  size_t n0x1FF_3; // [rsp+328h] [rbp+220h]
  __int64 n0x1FF_1; // [rsp+330h] [rbp+228h]
  void *v94; // [rsp+338h] [rbp+230h]
  _BYTE v95[520]; // [rsp+340h] [rbp+238h] BYREF
  __int64 v96; // [rsp+548h] [rbp+440h] BYREF
  __int64 n0x1FF; // [rsp+550h] [rbp+448h]
  _BYTE *v98; // [rsp+558h] [rbp+450h]
  _BYTE v99[520]; // [rsp+560h] [rbp+458h] BYREF
  __int128 v100; // [rsp+778h] [rbp+670h]
  __int128 v101; // [rsp+788h] [rbp+680h]

  v101 = v3;
  v100 = v4;
  LOWORD(v51) = *(_WORD *)(a1 + 0xD0);
  v5 = a3;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v61 = a3;
  v70[0] = 0;
  v74 = __rdtsc();
  v70[1] = *(_BYTE *)(a1 + 0xD2);
  qword_149B4B870(v70, &v51, &byte_14819E9C2, &byte_14819E9C2, 0);
  v8 = &byte_14819E9C2;
  v71 = v51;
  if ( *(_QWORD *)(a1 + 0x50) )
    v8 = *(const ULONG_PTR **)(a1 + 0x50);
  qword_149B4B8B0("TaskName: %s", v8);
  v9 = *(__m256i *)(v5 + 0x80);
  _Newvec = *(_QWORD **)(v5 + 0x48);
  v84 = *(__m256i *)v5;
  v85 = *(__m256i *)(v5 + 0x20);
  v86 = *(__m256i *)(v5 + 0x40);
  v87 = *(__m256i *)(v5 + 0x60);
  *(__m256i *)v88 = v9;
  *(__m256i *)&v88[0x20] = *(__m256i *)(v5 + 0xA0);
  *(__m256i *)&v88[0x40] = *(__m256i *)(v5 + 0xC0);
  if ( _Newvec )
  {
    v11 = *(_OWORD *)(v5 + 0x68);
    v12 = *(_DWORD *)(v5 + 0x78);
    v89 = v11;
    LODWORD(v51) = v12;
    Src[0] = (void *)a1;
    HIDWORD(v52) = 0x5A00;
    v53 = 1;
    v54 = 0;
    v56 = 0;
    v57 = 0;
    v58 = 0;
    v55 = __rdtsc();
    __asm { vzeroupper }
    qword_149B4B870(
      (char *)&v52 + 4,
      &word_149B47AAC,
      "Subsumption::DebugTaskTree::Push",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\ISubsumptionTask.h",
      0x169);
    v13 = _Newvec[1];
    v14 = _Newvec + 3;
    HIWORD(v52) = word_149B47AAC;
    v60 = 0;
    if ( v13 == _Newvec[2] )
    {
      sub_14053A5C0((__int64)_Newvec, (_BYTE *)v13, Src, &v60, (int *)&v51, &v89, _Newvec + 3);
    }
    else
    {
      *(_QWORD *)(v13 + 0x28) = *v14;
      *(_QWORD *)v13 = a1;
      *(_QWORD *)(v13 + 8) = 0;
      *(_DWORD *)(v13 + 0x10) = v12;
      *(_OWORD *)(v13 + 0x18) = v11;
      _Newvec[1] += 0x30LL;
    }
    *v14 = ((__int64)((unsigned __int128)((__int64)(_Newvec[1] - *_Newvec) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 3)
         + ((unsigned __int64)((unsigned __int128)((__int64)(_Newvec[1] - *_Newvec) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F)
         - 1;
    v56 = __rdtsc();
    qword_149B4B878((char *)&v52 + 4);
  }
  v15 = *(_OWORD *)(a1 + 0x38);
  v16 = *(_QWORD *)(a1 + 0x40) ^ v87.m256i_u32[6];
  v17 = v85.m256i_i32[4] | 8;
  *(_DWORD *)&v90[0x28] = v87.m256i_i32[6];
  *(_QWORD *)v90 = v84.m256i_i64[0];
  v18 = *(__int64 **)(a1 + 0x88);
  *(_OWORD *)&v90[0x18] = *(_OWORD *)&v87.m256i_u64[1];
  v19 = *(_OWORD *)&v90[0x20];
  v20 = *v18;
  v91 = v84.m256i_i64[0]
      ^ _mm_extract_epi64(*(__m128i *)&v87.m256i_u64[1], 1)
      ^ v87.m256i_i64[1]
      ^ v15
      ^ v16
      ^ 0x1234567898765432LL;
  v21 = v91;
  *(_OWORD *)&v90[8] = v15;
  v80 = v91;
  v78 = *(__m256 *)v90;
  v79 = *(_OWORD *)&v90[0x20];
  __asm { vzeroupper }
  v86.m256i_i64[3] = (*(__int64 (__fastcall **)(__int64 *, __m256 *, __int64))(v20 + 0x40))(v18, &v78, v85.m256i_i64[0]);
  if ( !v86.m256i_i64[3] )
  {
    sub_14053C120(a1, (__int64)v90, (__int64)&v84);
    v53 = 1;
    HIWORD(v52) = 0;
    v54 = 0;
    v56 = 0;
    v57 = 0;
    v58 = 0;
    BYTE4(v52) = 0;
    v55 = __rdtsc();
    BYTE5(v52) = *(_BYTE *)(a1 + 0xD2);
    qword_149B4B870(
      (char *)&v52 + 4,
      &word_149B47AB8,
      "Subsumption::Tick - Personal Log - Start Log",
      "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
      0xDE);
    HIWORD(v52) = word_149B47AB8;
    if ( !sub_1403BFA30((_QWORD *)(a1 + 0xF0)) )
    {
      v22 = *(_BYTE **)(a1 + 0xF0);
      v89 = xmmword_1481A4C90;
      sub_14038F6D0((__int64 *)v85.m256i_i64[1], v22, v17 | 0x10, (float *)&v89, 0);
    }
    v56 = __rdtsc();
    qword_149B4B878((char *)&v52 + 4);
  }
  v64 = 1;
  v63 = 0;
  v65 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v62[0] = 0;
  v66 = __rdtsc();
  v62[1] = *(_BYTE *)(a1 + 0xD2);
  qword_149B4B870(
    v62,
    &word_149B47ABC,
    "SubactivityTemplate::Tick - Task Update",
    "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
    0xE9);
  v63 = word_149B47ABC;
  (*(void (__fastcall **)(__int64, __int64, __m256i *))(*(_QWORD *)a1 + 0x78LL))(a1, a2, &v84);
  v23 = *(_DWORD *)(a2 + 0x21C);
  LODWORD(v60) = v23;
  if ( v23 )
  {
    HIWORD(v52) = 0;
    v53 = 1;
    LOBYTE(v51) = v23 == 1;
    v54 = 0;
    v56 = 0;
    v57 = 0;
    v58 = 0;
    BYTE4(v52) = 0;
    v55 = __rdtsc();
    BYTE5(v52) = *(_BYTE *)(a1 + 0xD2);
    qword_149B4B870(
      (char *)&v52 + 4,
      &word_149B47AC0,
      "Subsumption::Tick - Warning",
      "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
      0xF1);
    HIWORD(v52) = word_149B47AC0;
    if ( *(_QWORD *)a2 && !*(_QWORD *)(a2 + 0x220) && v86.m256i_i8[0x10] )
    {
      v24 = *(const char **)(a2 + 0x10);
      v25 = (const char *)&byte_14819E9C2;
      v26 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x88) + 0x10LL))(*(_QWORD *)(a1 + 0x88));
      if ( *(_QWORD *)(a1 + 0x50) )
        v25 = *(const char **)(a1 + 0x50);
      v27 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v84.m256i_i64[1] + 0x70LL))(v84.m256i_i64[1]);
      sub_1405C0E00(
        4u,
        *(_DWORD *)(a2 + 0x218),
        "[Subsumption] %s|%s.%s.%s (%s): %s",
        v27,
        (const char *)v85.m256i_i64[3],
        (const char *)v86.m256i_i64[0],
        v25,
        v26,
        v24);
      v23 = v60;
    }
    v56 = __rdtsc();
    qword_149B4B878((char *)&v52 + 4);
    HIWORD(v52) = 0;
    v53 = 1;
    v54 = 0;
    v56 = 0;
    v57 = 0;
    v58 = 0;
    BYTE4(v52) = 0;
    v55 = __rdtsc();
    BYTE5(v52) = *(_BYTE *)(a1 + 0xD2);
    qword_149B4B870(
      (char *)&v52 + 4,
      &word_149B47AC4,
      "Subsumption::Tick - Personal Log Post Tick",
      "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
      0xFA);
    v28 = &byte_14819E9C2;
    v29 = *(_QWORD *)(a1 + 0x88);
    HIWORD(v52) = word_149B47AC4;
    v98 = v99;
    v30 = *(const ULONG_PTR **)(a1 + 0x50);
    v96 = 0;
    v31 = *(_QWORD *)(a2 + 0x10);
    if ( v30 )
      v28 = v30;
    v99[0] = 0;
    n0x1FF = 0x1FF;
    v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x18LL))(v29);
    p__%s:_%s___%s___%s%s = " %s: %s - %s - %s - %s";
    if ( !*(_QWORD *)a2 )
      p__%s:_%s___%s___%s%s = " %s: %s - %s - %s%s";
    p_Success = "Failure";
    if ( v23 == 1 )
      p_Success = "Success";
    v35 = (size_t *)sub_1402A3190((__int64)&v96, p__%s:_%s___%s___%s%s, v86.m256i_i64[0], v32, v28, p_Success, v31);
    v95[0] = 0;
    n0x1FF_3 = 0;
    v36 = v95;
    v94 = v95;
    n0x1FF_1 = 0x1FF;
    n0x1FF_2 = *v35;
    v38 = (void *)v35[2];
    Src[0] = v38;
    if ( n0x1FF_2 > 0x1FF )
    {
      v39 = v95;
      if ( n0x1FF_2 + 1 > 0x200 )
      {
        v39 = (_BYTE *)allocWithProfilerInfo(n0x1FF_2 + 1, 0);
        qword_149B3AB68 += n0x1FF_2 + 1;
        v38 = Src[0];
        n0x1FF_1 = n0x1FF_2;
      }
      v94 = v39;
      n0x1FF_3 = n0x1FF_2;
      v39[n0x1FF_2] = 0;
      v36 = v94;
    }
    memmove(v36, v38, n0x1FF_2);
    n0x1FF_3 = n0x1FF_2;
    *((_BYTE *)v94 + n0x1FF_2) = 0;
    if ( v98 != v99 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v98);
    }
    if ( v23 == 1 || *(_QWORD *)(a2 + 0x220) )
    {
      v40 = v17;
      if ( v23 == 1 )
      {
        v89 = xmmword_1481D9FC0;
        sub_14038F6D0((__int64 *)v85.m256i_i64[1], v94, v17, (float *)&v89, v51);
        if ( !sub_1403BFA30((_QWORD *)(a1 + 0xF8)) )
        {
          v42 = *(_BYTE **)(a1 + 0xF8);
          v41 = v17 | 0x10;
          *(_OWORD *)Src = Al__204;
          goto LABEL_39;
        }
LABEL_40:
        if ( v94 != v95 )
        {
          qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
          sub_147605980(v94);
        }
        v56 = __rdtsc();
        qword_149B4B878((char *)&v52 + 4);
        v53 = 1;
        HIWORD(v52) = 0;
        v54 = 0;
        v56 = 0;
        v57 = 0;
        v58 = 0;
        BYTE4(v52) = 0;
        v55 = __rdtsc();
        BYTE5(v52) = *(_BYTE *)(a1 + 0xD2);
        qword_149B4B870(
          (char *)&v52 + 4,
          &word_149B47AC8,
          "SubactivityTemplate::Tick - Task termination",
          "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
          0x112);
        HIWORD(v52) = word_149B47AC8;
        (*(void (__fastcall **)(__int64, __m256i *))(*(_QWORD *)a1 + 0x80LL))(a1, &v84);
        v56 = __rdtsc();
        qword_149B4B878((char *)&v52 + 4);
        HIWORD(v52) = 0;
        v53 = 1;
        v54 = 0;
        v56 = 0;
        v57 = 0;
        v58 = 0;
        BYTE4(v52) = 0;
        v55 = __rdtsc();
        BYTE5(v52) = *(_BYTE *)(a1 + 0xD2);
        qword_149B4B870(
          (char *)&v52 + 4,
          &word_149B47ACC,
          "SubactivityTemplate::Tick - Freeing runtime data",
          "W:/p4-src/CryEngine/Code/CryEngine/CryCommon/Subsumption/SubsumptionTask.cpp",
          0x117);
        v43 = *(__int64 **)(a1 + 0x88);
        HIWORD(v52) = word_149B47ACC;
        v81 = *(__m256 *)v90;
        v44 = *v43;
        v82 = v19;
        v83 = v21;
        __asm { vzeroupper }
        (*(void (__fastcall **)(__int64 *, __m256 *, __int64))(v44 + 0x48))(v43, &v81, v85.m256i_i64[0]);
        v86.m256i_i64[3] = 0;
        v56 = __rdtsc();
        qword_149B4B878((char *)&v52 + 4);
        v5 = v61;
        goto LABEL_43;
      }
    }
    else
    {
      v17 |= 0x40u;
      v40 = v17;
    }
    *(_OWORD *)Src = xmmword_1481D9FD0;
    sub_14038F6D0((__int64 *)v85.m256i_i64[1], v94, v40, (float *)Src, v51);
    if ( !sub_1403BFA30((_QWORD *)(a1 + 0x100)) )
    {
      v41 = v17 | 0x10;
      *(_OWORD *)Src = Al__204;
      v42 = *(_BYTE **)(a1 + 0x100);
LABEL_39:
      sub_14038F6D0((__int64 *)v85.m256i_i64[1], v42, v41, (float *)Src, v51);
      goto LABEL_40;
    }
    goto LABEL_40;
  }
LABEL_43:
  if ( _Newvec )
  {
    v45 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 0x68LL))(a1, v5);
    v46 = *(_DWORD *)(a2 + 0x21C);
    v54 = 0;
    v47 = v45;
    v56 = 0;
    v57 = 0;
    v58 = 0;
    HIDWORD(v52) = 0x5A00;
    v53 = 1;
    v55 = __rdtsc();
    qword_149B4B870(
      (char *)&v52 + 4,
      &word_149B47AB0,
      "Subsumption::DebugTaskTree::Pop",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\ISubsumptionTask.h",
      0x171);
    HIWORD(v52) = word_149B47AB0;
    if ( (unsigned int)(v46 - 1) <= 1 )
    {
      for ( i = _Newvec[1]; *(_QWORD *)(i - 0x30) != a1; _Newvec[1] = i )
        i -= 0x30;
      _Newvec[3] = *(_QWORD *)(i - 8);
      _Newvec[1] = i - 0x30;
    }
    else
    {
      v48 = *_Newvec + 0x30LL * _Newvec[3];
      *(_QWORD *)(v48 + 8) = v47;
      _Newvec[3] = *(_QWORD *)(v48 + 0x28);
    }
    v56 = __rdtsc();
    qword_149B4B878((char *)&v52 + 4);
  }
  v67 = __rdtsc();
  qword_149B4B878(v62);
  v75 = __rdtsc();
  qword_149B4B878(v70);
  return a2;
}

// --- End Function: sub_14053DA80 (0x14053DA80) ---

// --- Function: std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_Change_array (0x14053E7F0) ---
void __fastcall std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_Change_array(
        GSC::AI::GameGraph::generate_game_graph::__l246::search_node *const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity,
        __int64 a4)
{
  _QWORD *v6; // rcx

  v6 = *(_QWORD **)_Newvec;
  if ( v6 )
  {
    if ( (unsigned __int64)(0x30 * ((*((_QWORD *)_Newvec + 2) - (_QWORD)v6) / 0x30LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - v6[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)v6[0xFFFFFFFF];
    }
    sub_1402A3D30(v6);
  }
  *(_QWORD *)_Newvec = _Newsize;
  *((_QWORD *)_Newvec + 1) = _Newsize + 0x30 * _Newcapacity;
  *((_QWORD *)_Newvec + 2) = _Newsize + 0x30 * a4;
}

// --- End Function: std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_Change_array (0x14053E7F0) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10(a3);
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DBC0 (0x14056DBC0) ---
__int64 __fastcall sub_14056DBC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E2E40(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056DBC0 (0x14056DBC0) ---

// --- Function: sub_14056DD10 (0x14056DD10) ---
// attributes: thunk
__int64 sub_14056DD10()
{
  return qword_149B4F990();
}

// --- End Function: sub_14056DD10 (0x14056DD10) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Logs a fatal error message. If the fatal error system is not properly
// initialized (missing necessary function pointers), it triggers a debug break.
// Otherwise, it formats the provided message into a buffer and dispatches it to an
// external logging function. Execution typically halts after this function.
_BYTE *LogFatalError(const char *formatString, ...)
{
  __int64 (*pfnInitFatalFunctions)(void); // rax
  FARPROC pfnInitFatalFunctionsAddr; // rax
  _BYTE *result; // rax
  _QWORD *pStdioCommonVsnprintf; // rax
  int formattedMessageLength; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, formatString);
  pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  if ( !::pfnInitFatalFunctions )
  {
    pfnInitFatalFunctionsAddr = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))pfnInitFatalFunctionsAddr)(&::pfnInitFatalFunctions);
    pfnInitFatalFunctions = (__int64 (*)(void))::pfnInitFatalFunctions;
  }
  result = (_BYTE *)pfnInitFatalFunctions();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    pStdioCommonVsnprintf = sub_1402A4380();
    formattedMessageLength = _stdio_common_vsprintf(
                               *pStdioCommonVsnprintf | 2LL,
                               formattedMessageBuffer,
                               0x1000u,
                               formatString,
                               0,
                               args);
    if ( formattedMessageLength < 0 )
      formattedMessageLength = 0xFFFFFFFF;
    if ( (unsigned int)formattedMessageLength >= 0x1000 )
      formattedMessageBuffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_1412A8110 (0x1412A8110) ---
__int64 *__fastcall sub_1412A8110(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        _DWORD *a4,
        __int64 a5,
        char a6,
        int a7,
        int a8,
        char a9)
{
  __int64 v10; // xmm1_8
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  _BYTE v16[40]; // [rsp+20h] [rbp-28h] BYREF

  *a1 = a2;
  a1[4] = *(_QWORD *)(a3 + 0x18);
  a1[1] = *(_QWORD *)a3;
  a1[2] = *(_QWORD *)(a3 + 8);
  a1[3] = *(_QWORD *)(a3 + 0x10);
  *(_OWORD *)(a1 + 5) = *(_OWORD *)(a3 + 0x20);
  v10 = *(__int64 *)(a3 + 0x30);
  a1[7] = v10;
  a1[8] = *(_QWORD *)(a3 + 0x38);
  a1[9] = 0;
  a1[0xA] = 0;
  a1[0xB] = 0;
  *((_DWORD *)a1 + 0x1B) = a4[3];
  *((_DWORD *)a1 + 0x18) = *a4;
  *((_DWORD *)a1 + 0x19) = a4[1];
  *((_DWORD *)a1 + 0x1A) = a4[2];
  v11 = *a1;
  a1[0xE] = *(__int64 *)a5;
  *((_DWORD *)a1 + 0x1E) = *(_DWORD *)(a5 + 8);
  *((_BYTE *)a1 + 0x7C) = a6;
  *((_BYTE *)a1 + 0x7F) = a9;
  *(_WORD *)((char *)a1 + 0x7D) = 0;
  if ( v11 )
  {
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
    if ( v12 )
    {
      v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x668LL))(v12);
      if ( v13 )
      {
        v14 = (*(__int64 (__fastcall **)(__int64, _BYTE *, __int64 *))(*(_QWORD *)v13 + 0x170LL))(v13, v16, a1 + 5);
        *(_OWORD *)(a1 + 9) = *(_OWORD *)v14;
        a1[0xB] = *(__int64 *)(v14 + 0x10);
      }
      else
      {
        sub_1403A2CE0((__int64)"Constructing SActorTeleportParams with a zone entity id that does not host a zone.");
      }
      return a1;
    }
    else
    {
      sub_1403A2CE0((__int64)"Constructing SActorTeleportParams with invalid zone entity id.");
      return a1;
    }
  }
  else
  {
    *(_OWORD *)(a1 + 9) = *(_OWORD *)(a1 + 5);
    a1[0xB] = v10;
    return a1;
  }
}

// --- End Function: sub_1412A8110 (0x1412A8110) ---

// --- Function: sub_1412A83D0 (0x1412A83D0) ---
__int64 __fastcall sub_1412A83D0(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FBE8 + 0xF0LL))(qword_149B4FBE8);
  return a1;
}

// --- End Function: sub_1412A83D0 (0x1412A83D0) ---

// --- Function: sub_1412A9390 (0x1412A9390) ---
__int64 sub_1412A9390()
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FBE8 + 0xF8LL))(qword_149B4FBE8);
}

// --- End Function: sub_1412A9390 (0x1412A9390) ---

// --- Function: sub_1413594F0 (0x1413594F0) ---
_QWORD *__fastcall sub_1413594F0(__int64 a1, _QWORD *a2)
{
  char *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rbp
  __int64 *v7; // rax
  __int64 v8; // r8
  unsigned __int8 *v9; // rax
  __int64 v10; // r8
  int v11; // ecx
  int v12; // edx
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rbp
  __int64 v16; // rdi
  __int64 v17; // rbx
  signed __int64 v18; // rdx
  const char *v20; // [rsp+30h] [rbp-38h] BYREF
  _BYTE v21[24]; // [rsp+38h] [rbp-30h] BYREF
  BOOL fPending; // [rsp+80h] [rbp+18h] BYREF
  char *v23; // [rsp+88h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&stru_149CEFEA0, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149CEFF48 & 1) == 0 )
    {
      dword_149CEFF48 |= 1u;
      xmmword_149CEFEB0 = 0;
    }
    n0x78 = 0x78;
    v23 = strchr(
            "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<class std::vector<class EntityId"
            ",class std::allocator<class EntityId> > >>(void)",
            0x3C);
    v4 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<class std::vector<class EntityId,"
           "class std::allocator<class EntityId> > >>(void)",
           0x3E);
    if ( v23 != v4 )
      ++v23;
    v20 = (const char *)&unk_149CEFEC8;
    sub_1403E40C0(&v20, (const char *)&unk_149CEFF47, (const char **)&v23, v4);
    *v20 = 0;
    *((_QWORD *)&xmmword_149CEFEB0 + 1) = &unk_149CEFF4C;
    *(_QWORD *)&xmmword_149CEFEB0 = &xmmword_149CEFEB0;
    qword_149CEFEA8 = (__int64)&xmmword_149CEFEB0;
    if ( !InitOnceComplete(&stru_149CEFEA0, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v5 = *(_QWORD *)qword_149CEFEA8;
  v6 = *(_QWORD *)(qword_149CEFEA8 + 8);
  v7 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v21);
  v8 = *v7;
  if ( v5 == *v7 )
    goto LABEL_19;
  if ( !v5 || !v8 || v6 == v7[1] || *(_QWORD *)(v5 + 0x10) != *(_QWORD *)(v8 + 0x10) )
    goto LABEL_18;
  v9 = (unsigned __int8 *)(v5 + 0x18);
  v10 = v8 - v5;
  do
  {
    v11 = v9[v10];
    v12 = *v9 - v11;
    if ( v12 )
      break;
    ++v9;
  }
  while ( v11 );
  if ( !v12 )
  {
LABEL_19:
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x20LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1)
      && (v16 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
      *(_QWORD *)v16 = v17;
      *(_BYTE *)(v16 + 8) = 1;
      if ( *(_DWORD *)(v17 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v17 + 0x14);
      }
      else
      {
        v18 = _InterlockedIncrement64((volatile signed __int64 *)v17);
        if ( (v18 & 0x200000) != 0 )
          sub_1403CB300(v17, v18, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
      }
    }
    else
    {
      v16 = 0;
    }
    v13 = v16;
    v14 = v15;
  }
  else
  {
LABEL_18:
    v13 = 0;
    v14 = 0;
  }
  sub_14035AED0(a2, v14, v13);
  return a2;
}

// --- End Function: sub_1413594F0 (0x1413594F0) ---

// --- Function: sub_14135C730 (0x14135C730) ---
_QWORD *__fastcall sub_14135C730(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 *v4; // rdx
  __int64 *v5; // rcx
  __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 *v8; // rbx
  __int64 *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  unsigned __int8 *v12; // rax
  __int64 v13; // r8
  int v14; // ecx
  int v15; // edx
  __int64 v16; // rdx
  __int64 v17; // rbx
  __int64 v18; // rbp
  __int64 v19; // rdi
  signed __int64 v20; // rdx
  _QWORD v22[2]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v23[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = *a1;
  v5 = v4;
  v6 = (__int64 *)v4[1];
  while ( !*((_BYTE *)v6 + 0x19) )
  {
    if ( *((_DWORD *)v6 + 8) >= *a3 )
    {
      v5 = v6;
      v6 = (__int64 *)*v6;
    }
    else
    {
      v6 = (__int64 *)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 0x19) || *a3 < *((_DWORD *)v5 + 8) || v5 == v4 )
  {
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
  else
  {
    v7 = v5[7];
    v8 = sub_1413674D0(v22);
    v9 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 8LL))(v7, v23);
    v10 = *v8;
    v11 = *v9;
    if ( *v8 == *v9 )
      goto LABEL_19;
    if ( !v10 || !v11 || v8[1] == v9[1] || *(_QWORD *)(v10 + 0x10) != *(_QWORD *)(v11 + 0x10) )
      goto LABEL_18;
    v12 = (unsigned __int8 *)(v10 + 0x18);
    v13 = v11 - v10;
    do
    {
      v14 = v12[v13];
      v15 = *v12 - v14;
      if ( v15 )
        break;
      ++v12;
    }
    while ( v14 );
    if ( !v15 )
    {
LABEL_19:
      v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x20LL))(v7);
      if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x10LL))(v7)
        && (v17 = allocWithProfilerInfo_w(0x10u)) != 0 )
      {
        v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x10LL))(v7);
        *(_QWORD *)v17 = v19;
        *(_BYTE *)(v17 + 8) = 1;
        if ( *(_DWORD *)(v19 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
        {
          ++*(_DWORD *)(v19 + 0x14);
        }
        else
        {
          v20 = _InterlockedIncrement64((volatile signed __int64 *)v19);
          if ( (v20 & 0x200000) != 0 )
            sub_1403CB300(v19, v20, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
        }
      }
      else
      {
        v17 = 0;
      }
      v16 = v18;
    }
    else
    {
LABEL_18:
      v16 = 0;
      v17 = 0;
    }
    sub_14035AED0(a2, v16, v17);
    return a2;
  }
}

// --- End Function: sub_14135C730 (0x14135C730) ---

// --- Function: sub_14135C8E0 (0x14135C8E0) ---
_QWORD *__fastcall sub_14135C8E0(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 **v3; // rdi
  __int64 **v6; // r12
  __int64 *v7; // rax
  __int64 v8; // r8
  __int64 v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rbx
  __int64 *v12; // rdi
  __int64 *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r8
  unsigned __int8 *v16; // rax
  __int64 v17; // r8
  int v18; // ecx
  int v19; // edx
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rsi
  __int64 v23; // rdi
  __int64 v24; // rbx
  signed __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rbx
  volatile signed __int32 *v28; // rbx
  __int64 v29; // rax
  volatile signed __int32 *v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rbx
  volatile signed __int32 *v34; // rbx
  char v35[16]; // [rsp+30h] [rbp-50h] BYREF
  char v36[16]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v37[2]; // [rsp+50h] [rbp-30h] BYREF
  volatile signed __int32 *v38; // [rsp+60h] [rbp-20h]
  __int64 v39; // [rsp+68h] [rbp-18h]
  __int64 v40; // [rsp+70h] [rbp-10h]
  __int64 **v41; // [rsp+B0h] [rbp+30h]

  v3 = a1 + 3;
  v41 = a1 + 3;
  v6 = a1;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_44:
    if ( ++v6 == v3 )
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      a2[3] = 0;
      a2[4] = 0;
      v29 = allocWithProfilerInfo_w(0x18u);
      if ( v29 )
      {
        *(_DWORD *)(v29 + 8) = 1;
        *(_DWORD *)(v29 + 0xC) = 1;
        *(_QWORD *)v29 = off_1481B6460;
        *(_QWORD *)(v29 + 0x10) = 0;
      }
      a2[3] = 0;
      a2[4] = v29;
      return a2;
    }
  }
  v8 = *v7;
  v9 = *v7;
  v10 = *(__int64 **)(*v7 + 8);
  while ( !*((_BYTE *)v10 + 0x19) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = (__int64)v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *(_BYTE *)(v9 + 0x19) || *a3 < *(_DWORD *)(v9 + 0x20) || v9 == v8 )
  {
    v38 = 0;
    v26 = allocWithProfilerInfo_w(0x18u);
    v21 = v26;
    if ( v26 )
    {
      *(_DWORD *)(v26 + 8) = 1;
      *(_DWORD *)(v26 + 0xC) = 1;
      *(_QWORD *)v26 = off_1481B6460;
      *(_QWORD *)(v26 + 0x10) = 0;
    }
    else
    {
      v21 = 0;
    }
    goto LABEL_35;
  }
  v11 = *(_QWORD *)(v9 + 0x38);
  v12 = sub_1413674D0(v35);
  v13 = (__int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v11 + 8LL))(v11, v36);
  v14 = *v12;
  v15 = *v13;
  if ( *v12 != *v13 )
  {
    if ( !v14 || !v15 || v12[1] == v13[1] || *(_QWORD *)(v14 + 0x10) != *(_QWORD *)(v15 + 0x10) )
      goto LABEL_20;
    v16 = (unsigned __int8 *)(v14 + 0x18);
    v17 = v15 - v14;
    do
    {
      v18 = v16[v17];
      v19 = *v16 - v18;
      if ( v19 )
        break;
      ++v16;
    }
    while ( v18 );
    if ( v19 )
    {
LABEL_20:
      v38 = 0;
      v20 = allocWithProfilerInfo_w(0x18u);
      v21 = v20;
      v3 = v41;
      if ( v20 )
      {
        *(_DWORD *)(v20 + 8) = 1;
        *(_DWORD *)(v20 + 0xC) = 1;
        *(_QWORD *)v20 = off_1481B6460;
        *(_QWORD *)(v20 + 0x10) = 0;
      }
      else
      {
        v21 = 0;
      }
LABEL_35:
      v40 = v21;
LABEL_36:
      if ( v21 )
      {
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v21 + 8), 0xFFFFFFFF) == 1 )
        {
          v27 = v40;
          (**(void (__fastcall ***)(__int64))v40)(v40);
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 0xC), 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
        }
      }
      if ( v38 )
      {
        if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
        {
          v28 = v38;
          (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
          if ( _InterlockedExchangeAdd(v28 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
        }
      }
      goto LABEL_44;
    }
  }
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x20LL))(v11);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x10LL))(v11)
    && (v23 = allocWithProfilerInfo_w(0x10u)) != 0 )
  {
    v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x10LL))(v11);
    *(_QWORD *)v23 = v24;
    *(_BYTE *)(v23 + 8) = 1;
    if ( *(_DWORD *)(v24 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(v24 + 0x14);
    }
    else
    {
      v25 = _InterlockedIncrement64((volatile signed __int64 *)v24);
      if ( (v25 & 0x200000) != 0 )
        sub_1403CB300(v24, v25, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
    }
  }
  else
  {
    v23 = 0;
  }
  sub_14035AED0(v37, v22, v23);
  if ( !v37[0] )
  {
    v21 = v40;
    v3 = v41;
    goto LABEL_36;
  }
  v31 = v38;
  *a2 = v37[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v31 )
  {
    _InterlockedIncrement(v31 + 2);
    v31 = v38;
  }
  v32 = v40;
  a2[1] = v37[1];
  a2[2] = v31;
  a2[3] = 0;
  a2[4] = 0;
  if ( v32 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v32 + 8));
    v32 = v40;
    v31 = v38;
  }
  a2[3] = v39;
  a2[4] = v32;
  if ( v32 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v32 + 8), 0xFFFFFFFF) == 1 )
    {
      v33 = v40;
      (**(void (__fastcall ***)(__int64))v40)(v40);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v33 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
    }
    v31 = v38;
  }
  if ( v31 )
  {
    if ( _InterlockedExchangeAdd(v31 + 2, 0xFFFFFFFF) == 1 )
    {
      v34 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  return a2;
}

// --- End Function: sub_14135C8E0 (0x14135C8E0) ---

// --- Function: sub_141361F20 (0x141361F20) ---
_QWORD *__fastcall sub_141361F20(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  __int64 v8; // rcx
  volatile signed __int32 *v9; // rdx
  signed __int32 v10; // eax
  volatile signed __int32 *v11; // rbx
  volatile signed __int32 *v12; // rbx
  volatile signed __int32 *v13; // rbx
  __int64 v14; // rbx
  __int64 *v15; // r8
  __int64 *v16; // rcx
  __int64 *v17; // rax
  _DWORD *v18; // r14
  __int64 v19; // rbx
  __int64 v20; // rbx
  volatile signed __int32 *v21; // rbx
  volatile signed __int32 *v22; // rbx
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rcx
  __int64 v25; // rax
  volatile signed __int32 *v26; // rbx
  volatile signed __int32 *v27; // rbx
  __int128 v29; // [rsp+20h] [rbp-59h] BYREF
  _QWORD v30[2]; // [rsp+30h] [rbp-49h] BYREF
  __int64 v31; // [rsp+40h] [rbp-39h]
  __int64 v32; // [rsp+48h] [rbp-31h]
  volatile signed __int32 *v33; // [rsp+50h] [rbp-29h]
  _DWORD *v34; // [rsp+58h] [rbp-21h] BYREF
  volatile signed __int32 *v35; // [rsp+68h] [rbp-11h]
  volatile signed __int32 *v36; // [rsp+78h] [rbp-1h]
  _DWORD *v37[2]; // [rsp+80h] [rbp+7h] BYREF
  volatile signed __int32 *v38; // [rsp+90h] [rbp+17h]
  volatile signed __int32 *v39; // [rsp+A0h] [rbp+27h]
  __int128 v40; // [rsp+B0h] [rbp+37h] BYREF

  sub_14135C730((__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)), v30, a3);
  if ( v30[0] )
  {
    v8 = v31;
    *a2 = v30[0];
    a2[1] = 0;
    a2[2] = 0;
    if ( v8 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 8));
      v8 = v31;
    }
    v9 = v33;
    a2[1] = v30[1];
    a2[2] = v8;
    a2[3] = 0;
    a2[4] = 0;
    if ( v9 )
    {
      _InterlockedIncrement(v9 + 2);
      v9 = v33;
      v8 = v31;
    }
    a2[3] = v32;
    a2[4] = v9;
    if ( !v9 )
      goto LABEL_23;
    v10 = _InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF);
    goto LABEL_19;
  }
  sub_14033B5B0((__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)), v37, a3);
  if ( !v37[0] )
  {
    v15 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
    v16 = v15;
    v17 = (__int64 *)v15[1];
    while ( !*((_BYTE *)v17 + 0x19) )
    {
      if ( *((_DWORD *)v17 + 8) >= *a3 )
      {
        v16 = v17;
        v17 = (__int64 *)*v17;
      }
      else
      {
        v17 = (__int64 *)v17[2];
      }
    }
    if ( *((_BYTE *)v16 + 0x19) || *a3 < *((_DWORD *)v16 + 8) || v16 == v15 )
    {
      v35 = 0;
      v25 = allocWithProfilerInfo_w(0x18u);
      v24 = (volatile signed __int32 *)v25;
      if ( v25 )
      {
        *(_DWORD *)(v25 + 8) = 1;
        *(_DWORD *)(v25 + 0xC) = 1;
        *(_QWORD *)v25 = off_1481B6460;
        *(_QWORD *)(v25 + 0x10) = 0;
      }
      else
      {
        v24 = 0;
      }
      v36 = v24;
    }
    else
    {
      sub_1413594F0(v16[7], &v34);
      v18 = v34;
      if ( v34 )
      {
        v29 = 0;
        if ( sub_14053B5C0(a4, v34, &v29) )
        {
          v19 = *((_QWORD *)&v29 + 1);
          if ( *((_QWORD *)&v29 + 1) )
          {
            _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL));
            v18 = v34;
            v19 = *((_QWORD *)&v29 + 1);
          }
          v40 = v29;
          sub_141380EA0((__int64)v18, a2, &v40, a4 + 0x88);
          if ( v19 )
          {
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v19 + 8), 0xFFFFFFFF) == 1 )
            {
              v20 = *((_QWORD *)&v29 + 1);
              (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
              if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v20 + 0xC), 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
            }
          }
          if ( v36 )
          {
            if ( _InterlockedExchangeAdd(v36 + 2, 0xFFFFFFFF) == 1 )
            {
              v21 = v36;
              (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
              if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
            }
          }
          if ( v35 )
          {
            if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
            {
              v22 = v35;
              (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
              if ( _InterlockedExchangeAdd(v22 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
            }
          }
          sub_140370C50((__int64)v37);
LABEL_70:
          sub_140370C50((__int64)v30);
          return a2;
        }
        if ( *((_QWORD *)&v29 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            v23 = *((_QWORD *)&v29 + 1);
            (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v23 + 0xC), 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
          }
        }
      }
      v24 = v36;
    }
    if ( v24 )
    {
      if ( _InterlockedExchangeAdd(v24 + 2, 0xFFFFFFFF) == 1 )
      {
        v26 = v36;
        (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
        if ( _InterlockedExchangeAdd(v26 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
      }
    }
    if ( v35 )
    {
      if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
      {
        v27 = v35;
        (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
        if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
      }
    }
    sub_140370C50((__int64)v37);
    sub_14035AED0(a2, 0, 0);
    goto LABEL_70;
  }
  sub_14135C8E0((__int64 **)(a4 + 0x88), a2, v37[0]);
  if ( v39 )
  {
    if ( _InterlockedExchangeAdd(v39 + 2, 0xFFFFFFFF) == 1 )
    {
      v11 = v39;
      (**(void (__fastcall ***)(volatile signed __int32 *))v39)(v39);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v39 + 8LL))(v39);
    }
  }
  if ( v38 )
  {
    if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
    {
      v12 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  if ( !v33 )
    goto LABEL_22;
  v10 = _InterlockedExchangeAdd(v33 + 2, 0xFFFFFFFF);
LABEL_19:
  if ( v10 == 1 )
  {
    v13 = v33;
    (**(void (__fastcall ***)(volatile signed __int32 *))v33)(v33);
    if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v33 + 8LL))(v33);
  }
LABEL_22:
  v8 = v31;
LABEL_23:
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    {
      v14 = v31;
      (**(void (__fastcall ***)(__int64))v31)(v31);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v14 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 8LL))(v31);
    }
  }
  return a2;
}

// --- End Function: sub_141361F20 (0x141361F20) ---

// --- Function: sub_141365900 (0x141365900) ---
__int64 __fastcall sub_141365900(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // r14
  unsigned __int64 allocSize; // r14
  __int64 v13; // rax
  _DWORD *v14; // rsi
  __int64 v15; // r13
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // rbx
  __int64 i; // rbp
  const void *v20; // rcx
  _QWORD *v21; // rcx
  __int64 result; // rax

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 5;
  if ( v5 == 0x7FFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (a1[2] - *a1) >> 5;
  v9 = v8 >> 1;
  v10 = v5 + 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_28;
  v11 = v5 + 1;
  if ( v9 + v8 >= v10 )
    v11 = v9 + v8;
  if ( v11 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_28;
  allocSize = 0x20 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_DWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_28:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_26;
  v14 = (_DWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)v14 + 0xFFFFFFFF) = v13;
LABEL_13:
  v15 = (__int64)v14 + (v4 & 0xFFFFFFFFFFFFFFE0uLL);
  sub_14030A540(v15, a3);
  *(_DWORD *)(v15 + 0x18) = *(_DWORD *)(a3 + 0x18);
  v16 = a1[1];
  v17 = *a1;
  if ( a2 == v16 )
  {
    sub_141366060(v17, v16, (__int64)v14);
  }
  else
  {
    sub_1413660E0(v17, a2, v14);
    sub_1413660E0(a2, a1[1], (_DWORD *)(v15 + 0x20));
  }
  v18 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v18 != i; v18 += 0x20 )
    {
      v20 = *(const void **)(v18 + 8);
      if ( v20 )
        sub_147605980(v20);
    }
    v21 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
      goto LABEL_24;
    if ( (unsigned __int64)v21 - v21[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v21 = (_QWORD *)v21[0xFFFFFFFF];
LABEL_24:
      sub_1402A3D30(v21);
      goto LABEL_25;
    }
LABEL_26:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  *a1 = (__int64)v14;
  result = v15;
  a1[1] = (__int64)&v14[8 * v10];
  a1[2] = (__int64)&v14[allocSize / 4];
  return result;
}

// --- End Function: sub_141365900 (0x141365900) ---

// --- Function: sub_141366060 (0x141366060) ---
__int64 __fastcall sub_141366060(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // r14
  _DWORD *v8; // rdx
  int v9; // ecx

  v3 = a3;
  v5 = a1;
  if ( a1 != a2 )
  {
    v6 = a1 - a3;
    v7 = a3 - a1 + 0x18;
    do
    {
      sub_14030A540(v3, v5);
      v8 = (_DWORD *)(v7 + v5);
      v3 += 0x20;
      v9 = *(_DWORD *)(v7 + v5 + v6);
      v5 += 0x20;
      *v8 = v9;
    }
    while ( v5 != a2 );
  }
  return v3;
}

// --- End Function: sub_141366060 (0x141366060) ---

// --- Function: sub_1413660E0 (0x1413660E0) ---
_DWORD *__fastcall sub_1413660E0(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // r9
  char *v5; // r10
  __int64 v6; // r8
  int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // rdx

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = (char *)a3 - a1;
    v6 = a1 + 0x10;
    do
    {
      *(_QWORD *)&v5[v6] = 0;
      *(_QWORD *)&v5[v6 - 8] = 0;
      v7 = *(_DWORD *)(v6 - 0x10);
      v6 += 0x20;
      *v3 = v7;
      v3 += 8;
      *(_QWORD *)&v5[v6 - 0x28] = *(_QWORD *)(v6 - 0x28);
      v8 = *(_QWORD *)(v6 - 0x20);
      *(_QWORD *)(v6 - 0x28) = 0;
      v9 = *(_QWORD *)&v5[v6 - 0x20];
      *(_QWORD *)&v5[v6 - 0x20] = v8;
      *(_QWORD *)(v6 - 0x20) = v9;
      *(_DWORD *)&v5[v6 - 0x18] = *(_DWORD *)(v6 - 0x18);
    }
    while ( v6 - 0x10 != a2 );
  }
  return v3;
}

// --- End Function: sub_1413660E0 (0x1413660E0) ---

// --- Function: sub_1413674D0 (0x1413674D0) ---
_QWORD *__fastcall sub_1413674D0(_QWORD *a1)
{
  char *v2; // rax
  __int64 v3; // rcx
  BOOL fPending; // [rsp+38h] [rbp+10h] BYREF
  char *v6; // [rsp+40h] [rbp+18h] BYREF
  const char *v7; // [rsp+48h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&stru_149CEFD40, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149CEFDE8 & 1) == 0 )
    {
      dword_149CEFDE8 |= 1u;
      xmmword_149CEFD50 = 0;
    }
    n0x18_25 = 0x18;
    v6 = strchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class std::vector<class EntityId,class std::allocator<class En"
           "tityId> >>(void)",
           0x3C);
    v2 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class std::vector<class EntityId,class std::allocator<class En"
           "tityId> >>(void)",
           0x3E);
    if ( v6 != v2 )
      ++v6;
    v7 = (const char *)&unk_149CEFD68;
    sub_1403E40C0(&v7, (const char *)&unk_149CEFDE7, (const char **)&v6, v2);
    *v7 = 0;
    *((_QWORD *)&xmmword_149CEFD50 + 1) = &unk_149CEFDEC;
    *(_QWORD *)&xmmword_149CEFD50 = &xmmword_149CEFD50;
    qword_149CEFD48 = (__int64)&xmmword_149CEFD50;
    if ( !InitOnceComplete(&stru_149CEFD40, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v3 = qword_149CEFD48;
  *a1 = *(_QWORD *)qword_149CEFD48;
  a1[1] = *(_QWORD *)(v3 + 8);
  return a1;
}

// --- End Function: sub_1413674D0 (0x1413674D0) ---

// --- Function: sub_141369EA0 (0x141369EA0) ---
__int64 __fastcall sub_141369EA0(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // rdi

  v3 = a2[1];
  if ( v3 == a2[2] )
  {
    sub_141365900(a2, v3, a3);
  }
  else
  {
    sub_14030A540(v3, a3);
    *(_DWORD *)(v3 + 0x18) = *(_DWORD *)(a3 + 0x18);
    a2[1] += 0x20;
  }
  return a1;
}

// --- End Function: sub_141369EA0 (0x141369EA0) ---

// --- Function: sub_141377720 (0x141377720) ---
__int64 __fastcall sub_141377720(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned int v6; // r14d
  __int64 v7; // rax
  __int64 v8; // rcx
  const char *v9; // rdi
  const char *v10; // rsi
  const char *v11; // r15
  int v12; // ebx
  const char *v13; // rax
  const char *v15; // rdi
  const char *v16; // rsi
  const char *v17; // r15
  int v18; // ebx
  const char *v19; // rax
  int n0x5A00; // [rsp+40h] [rbp-68h] BYREF
  __int64 v21; // [rsp+44h] [rbp-64h]
  int v22; // [rsp+4Ch] [rbp-5Ch]
  unsigned __int64 v23; // [rsp+50h] [rbp-58h]
  unsigned __int64 v24; // [rsp+58h] [rbp-50h]
  __int64 v25; // [rsp+60h] [rbp-48h]
  __int64 v26; // [rsp+68h] [rbp-40h]

  n0x5A00 = 0x5A00;
  v22 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  v23 = __rdtsc();
  v6 = 1;
  qword_149B4B870(
    &n0x5A00,
    &word_149CEF124,
    "Subsumption::Decorator::LoadFromXml",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption/SubsumptionDecoratorTask.h",
    0x11);
  HIWORD(n0x5A00) = word_149CEF124;
  if ( (unsigned int)sub_14053C290(a1, a2, a3) != 1 )
  {
LABEL_6:
    v6 = 0;
    goto LABEL_7;
  }
  v7 = *(_QWORD *)(a1 + 0x70);
  v8 = *(_QWORD *)(a1 + 0x78);
  if ( v7 == v8 )
  {
    v9 = *(const char **)(a3 + 0x20);
    v10 = *(const char **)(a3 + 0x18);
    v11 = (const char *)&byte_14819E9C2;
    v12 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    if ( *(_QWORD *)(a1 + 0x50) )
      v11 = *(const char **)(a1 + 0x50);
    v13 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x88) + 0x10LL))(*(_QWORD *)(a1 + 0x88));
    sub_1405C0E00(
      4u,
      0,
      "Subsumption task type '%s' (Task name '%s') is a Decorator and at line %d in file '%s' inside the parent subactivi"
      "ty '%s' has no parallel tasks attached.",
      v13,
      v11,
      v12,
      v10,
      v9);
    goto LABEL_6;
  }
  if ( (unsigned __int64)((v8 - v7) / 0x18) > 1 )
  {
    v15 = *(const char **)(a3 + 0x20);
    v16 = *(const char **)(a3 + 0x18);
    v17 = (const char *)&byte_14819E9C2;
    v18 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    if ( *(_QWORD *)(a1 + 0x50) )
      v17 = *(const char **)(a1 + 0x50);
    v19 = (const char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x88) + 0x10LL))(*(_QWORD *)(a1 + 0x88));
    sub_1405C0E00(
      4u,
      0,
      "Subsumption task '%s' (Task name '%s') is a Decorator and at line %d in file '%s' inside the parent subactivity '%"
      "s' has more than 1 supported parallel tasks attached. Only 1 tasks will be executed.",
      v19,
      v17,
      v18,
      v16,
      v15);
  }
LABEL_7:
  v24 = __rdtsc();
  qword_149B4B878(&n0x5A00);
  return v6;
}

// --- End Function: sub_141377720 (0x141377720) ---

// --- Function: sub_141380EA0 (0x141380EA0) ---
_QWORD *__fastcall sub_141380EA0(__int64 a1, _QWORD *a2, void *a3, __int64 a4)
{
  unsigned __int64 v4; // r12
  _QWORD *v6; // r14
  _QWORD *v7; // rdi
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rcx
  void (__fastcall *v13)(__int64, __int64 *, _QWORD *, __int64); // r10
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r13
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  volatile signed __int32 *v21; // r14
  __int64 v22; // rax
  int **v23; // rdi
  __int64 v24; // rbx
  int *v25; // rcx
  const char *v26; // rax
  int *v27; // r9
  unsigned int v28; // ecx
  unsigned int v29; // r8d
  int v30; // edi
  int v31; // esi
  int v32; // r14d
  int v33; // r15d
  int v34; // ecx
  int v35; // edx
  int v36; // eax
  int v37; // r9d
  int v38; // r8d
  size_t Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // rcx
  _DWORD *v42; // r13
  __int64 v43; // rax
  _DWORD *v44; // rsi
  __int64 v45; // rax
  __int64 v46; // rbx
  __int64 (__fastcall *v47)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v49; // rbx
  __int64 v50; // rdi
  __int64 v51; // rcx
  __int16 n4; // ax
  void (__fastcall *v53)(__int64, __int64 *, _DWORD *, _QWORD *); // rbx
  _QWORD *v54; // rax
  __int64 v55; // rdx
  signed __int32 v56; // eax
  signed __int32 v57; // ett
  __int64 v58; // r12
  volatile signed __int32 *v59; // rsi
  __int64 v60; // rax
  __int64 v61; // rbx
  __int64 (__fastcall *v62)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF_2; // ax
  __int64 v64; // rbx
  __int64 v65; // rax
  __int16 n4_1; // cx
  __int64 **v67; // rax
  volatile signed __int32 *v68; // rbx
  volatile signed __int32 *v69; // rbx
  _QWORD *v70; // rax
  _QWORD *v71; // r14
  __int64 v72; // rax
  volatile signed __int32 *v73; // rbx
  unsigned __int8 (__fastcall *v74)(__int64, _QWORD *, _QWORD *); // rdi
  _QWORD *v75; // rax
  __int64 v76; // rdx
  __int64 v77; // rcx
  __int64 *v78; // rcx
  __int64 v79; // rax
  __int64 v80; // rcx
  volatile signed __int32 *v81; // rbx
  _QWORD *v82; // rax
  _QWORD *v83; // rsi
  __int64 v84; // rax
  volatile signed __int32 *v85; // rdi
  _BYTE *v86; // rax
  _BYTE *v87; // rdx
  _QWORD *v88; // rbx
  _BYTE *v89; // rcx
  volatile signed __int32 *v91; // rcx
  __int64 v92; // rax
  volatile signed __int32 *v93; // rcx
  __int64 v94; // rax
  __int64 v95; // rcx
  __int64 v96; // rcx
  volatile signed __int32 *v97; // rbx
  __int64 v98; // rax
  volatile signed __int32 *v99; // rbx
  int v100; // [rsp+40h] [rbp-D0h]
  int v101; // [rsp+48h] [rbp-C8h]
  int v102; // [rsp+78h] [rbp-98h]
  int v103; // [rsp+80h] [rbp-90h]
  int v104; // [rsp+88h] [rbp-88h]
  __int16 n0xFFFF_1; // [rsp+90h] [rbp-80h] BYREF
  __int16 n0xFFFF_3; // [rsp+92h] [rbp-7Eh] BYREF
  __int64 v107; // [rsp+98h] [rbp-78h] BYREF
  _DWORD *v108; // [rsp+A0h] [rbp-70h]
  char *v109; // [rsp+A8h] [rbp-68h] BYREF
  __int64 v110; // [rsp+B0h] [rbp-60h]
  volatile signed __int32 *v111; // [rsp+B8h] [rbp-58h]
  _QWORD *v112; // [rsp+C0h] [rbp-50h]
  void *v113; // [rsp+C8h] [rbp-48h]
  char v114[2]; // [rsp+D0h] [rbp-40h] BYREF
  char v115[2]; // [rsp+D2h] [rbp-3Eh] BYREF
  int v116; // [rsp+D4h] [rbp-3Ch]
  unsigned int v117; // [rsp+D8h] [rbp-38h]
  int *v118; // [rsp+E0h] [rbp-30h]
  unsigned __int64 v119; // [rsp+E8h] [rbp-28h]
  __int64 v120; // [rsp+F0h] [rbp-20h] BYREF
  __int64 v121; // [rsp+F8h] [rbp-18h]
  __int64 v122; // [rsp+100h] [rbp-10h] BYREF
  __int64 v123; // [rsp+108h] [rbp-8h] BYREF
  __int64 v124; // [rsp+110h] [rbp+0h]
  _QWORD v125[2]; // [rsp+118h] [rbp+8h] BYREF
  volatile signed __int32 *v126; // [rsp+128h] [rbp+18h]
  __int64 v127; // [rsp+130h] [rbp+20h]
  volatile signed __int32 *v128; // [rsp+138h] [rbp+28h]
  int n0x5A00; // [rsp+140h] [rbp+30h] BYREF
  __int64 v130; // [rsp+144h] [rbp+34h]
  int v131; // [rsp+14Ch] [rbp+3Ch]
  unsigned __int64 v132; // [rsp+150h] [rbp+40h]
  unsigned __int64 v133; // [rsp+158h] [rbp+48h]
  __int64 v134; // [rsp+160h] [rbp+50h]
  __int64 v135; // [rsp+168h] [rbp+58h]
  __int64 v136; // [rsp+190h] [rbp+80h]
  __int64 v137; // [rsp+198h] [rbp+88h]
  __int64 v138; // [rsp+1A0h] [rbp+90h]
  __int64 v139; // [rsp+1A8h] [rbp+98h]
  __int64 v140; // [rsp+1B0h] [rbp+A0h]
  __int64 v141; // [rsp+1B8h] [rbp+A8h]
  int *v142; // [rsp+1C0h] [rbp+B0h]
  __int128 v143; // [rsp+1C8h] [rbp+B8h] BYREF
  __int64 v144; // [rsp+1D8h] [rbp+C8h]
  unsigned __int64 v145; // [rsp+1E0h] [rbp+D0h]
  __int64 v146; // [rsp+1E8h] [rbp+D8h] BYREF
  _QWORD v147[2]; // [rsp+1F0h] [rbp+E0h] BYREF
  char v148[8]; // [rsp+200h] [rbp+F0h] BYREF
  _BYTE *v149; // [rsp+208h] [rbp+F8h]
  __int128 v150; // [rsp+210h] [rbp+100h]
  __int64 v151[4]; // [rsp+220h] [rbp+110h] BYREF
  char v152[8]; // [rsp+240h] [rbp+130h] BYREF
  __int64 v153; // [rsp+248h] [rbp+138h] BYREF
  char v154[8]; // [rsp+250h] [rbp+140h] BYREF
  char v155[8]; // [rsp+258h] [rbp+148h] BYREF
  char v156[8]; // [rsp+260h] [rbp+150h] BYREF
  char v157[16]; // [rsp+268h] [rbp+158h] BYREF
  __int64 v158; // [rsp+278h] [rbp+168h] BYREF
  __int64 v159; // [rsp+288h] [rbp+178h] BYREF
  char v160[24]; // [rsp+298h] [rbp+188h] BYREF
  size_t Size_2; // [rsp+2B0h] [rbp+1A0h] BYREF
  __int64 n0x24; // [rsp+2B8h] [rbp+1A8h]
  _BYTE *v163; // [rsp+2C0h] [rbp+1B0h]
  _BYTE v164[40]; // [rsp+2C8h] [rbp+1B8h] BYREF
  unsigned __int64 v165; // [rsp+2F0h] [rbp+1E0h] BYREF
  __int64 n0x1FF; // [rsp+2F8h] [rbp+1E8h]
  const char *v167; // [rsp+300h] [rbp+1F0h]
  _BYTE v168[520]; // [rsp+308h] [rbp+1F8h] BYREF

  v4 = 0;
  v113 = a3;
  v137 = 0;
  v138 = 0;
  v6 = a3;
  v139 = 0;
  v7 = a2;
  v140 = 0;
  v8 = a1;
  v141 = 0;
  v131 = 0;
  v133 = 0;
  v134 = 0;
  v135 = 0;
  v112 = a2;
  v124 = a1;
  v136 = 0;
  n0x5A00 = 0x5A00;
  v130 = 1;
  v132 = __rdtsc();
  qword_149B4B870(
    &n0x5A00,
    &word_149CEFACC,
    "Subsumption::SuperGUID<class std::vector<class EntityId,class std::allocator<class EntityId> > >::ResolveSuperGuidInputValue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\SubsumptionSuperGUID.h",
    0xFF);
  HIWORD(n0x5A00) = word_149CEFACC;
  if ( !*(_QWORD *)(v8 + 0x70) )
    goto LABEL_165;
  v9 = (*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)*v6 + 8LL))(*v6, v157);
  v10 = *(_QWORD *)(v8 + 0x70);
  if ( !v10 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x141381D29LL);
  }
  v11 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 0x10LL))(v10, v9);
  v12 = v11;
  if ( !v11 )
    goto LABEL_165;
  v13 = *(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v11 + 0x18LL);
  v14 = v6[1];
  if ( v14 )
    _InterlockedIncrement((volatile signed __int32 *)(v14 + 8));
  v147[0] = *v6;
  v147[1] = v6[1];
  v13(v12, &v107, v147, a4);
  v15 = *(_QWORD *)(v8 + 0x30);
  v110 = 0;
  v16 = *(unsigned int *)(v15 - 4);
  LODWORD(v16) = v16 & 0x7FFFFFFF;
  v145 = v16;
  v17 = v16 - 1;
  if ( !v16 )
    v17 = 0;
  v119 = v17;
  if ( !v16 )
    goto LABEL_165;
  while ( 1 )
  {
    if ( (int)v4 >= (*(_DWORD *)(*(_QWORD *)(v8 + 0x30) - 4LL) & 0x7FFFFFFF) )
      __debugbreak();
    v18 = (__int64 *)(*(_QWORD *)(v8 + 0x30) + 0x10LL * (int)v4);
    v19 = v18[1];
    if ( v19 )
      _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
    v20 = *v18;
    v21 = (volatile signed __int32 *)v18[1];
    v111 = v21;
    if ( *(_DWORD *)(v20 + 8) )
      break;
    if ( !v107 )
    {
      v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
      v107 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v22 + 0x1D8LL))(v22, v152);
    }
    v23 = (int **)(v20 + 0x10);
    sub_1403F6100((__int64)v148, v107, v20 + 0x10);
    v24 = *sub_14040B4F0((__int64)v148, &v153);
    v144 = v24;
    v146 = v24;
    if ( v24 )
      goto LABEL_31;
    v25 = v23[1];
    v26 = v168;
    v27 = *v23;
    v168[0] = 0;
    v167 = v168;
    v165 = 0;
    n0x1FF = 0x1FF;
    v142 = v25;
    v118 = v27;
    if ( v27 != v25 )
    {
      do
      {
        v28 = v27[2];
        v29 = *v27;
        v30 = *((unsigned __int8 *)v27 + 0xC);
        v31 = *((unsigned __int8 *)v27 + 0xD);
        v32 = *((unsigned __int8 *)v27 + 0xE);
        v33 = *((unsigned __int8 *)v27 + 0xF);
        v163 = v164;
        v116 = (unsigned __int8)v28;
        v104 = (unsigned __int8)v28;
        v103 = BYTE1(v28);
        v102 = BYTE2(v28);
        v117 = HIBYTE(v28);
        v34 = *((unsigned __int8 *)v27 + 5);
        v101 = (unsigned __int8)v29;
        v100 = BYTE1(v29);
        LODWORD(v108) = HIBYTE(v29);
        v35 = BYTE2(v29);
        v36 = *((unsigned __int8 *)v27 + 4);
        v37 = *((unsigned __int8 *)v27 + 6);
        v38 = *((unsigned __int8 *)v118 + 7);
        v164[0] = 0;
        Size_2 = 0;
        n0x24 = 0x24;
        sub_1402C61F0(
          (__int64)&Size_2,
          "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
          v38,
          v37,
          v34,
          v36,
          (_DWORD)v108,
          v35,
          v100,
          v101,
          v33,
          v32,
          v31,
          v30,
          v117,
          v102,
          v103,
          v104);
        sub_1403E0AA0(&v109);
        Size = Size_2;
        if ( Size_2 )
        {
          sub_1403DE0C0(&v109, Size_2);
          sub_1403E1FA0(v109, v163, Size);
        }
        if ( v163 != v164 )
        {
          qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - n0x24;
          sub_147605980(v163);
        }
        if ( v109 )
        {
          Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
          do
            ++Size_1;
          while ( v109[Size_1] );
        }
        else
        {
          Size_1 = 0;
        }
        sub_1402DECA0(&v165, v109, Size_1);
        sub_1402DECA0(&v165, ", ", 2u);
        sub_140370D10(&v109);
        v27 = v118 + 4;
        v118 = v27;
      }
      while ( v27 != v142 );
      v24 = v144;
      v26 = v167;
      v21 = v111;
      v4 = v110;
      v17 = v119;
    }
    sub_1405C0E00(
      4u,
      2u,
      "SuperGUID::ResolveSuperGuidInputValue failed to find entity in superguid query corresponding to the following super guid: %s",
      v26);
    if ( v167 != v168 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v167);
    }
    if ( v24 )
    {
LABEL_31:
      if ( v4 == v17 )
      {
        v82 = (_QWORD *)allocWithProfilerInfo_w(0x18u);
        v83 = v82;
        if ( v82 )
        {
          *v82 = 0;
          v82[1] = 0;
          v82[2] = 0;
        }
        else
        {
          v83 = 0;
        }
        v84 = allocWithProfilerInfo_w(0x18u);
        v85 = (volatile signed __int32 *)v84;
        if ( v84 )
        {
          *(_DWORD *)(v84 + 8) = 1;
          *(_DWORD *)(v84 + 0xC) = 1;
          *(_QWORD *)v84 = off_1483F71C8;
          *(_QWORD *)(v84 + 0x10) = v83;
        }
        else
        {
          v85 = 0;
        }
        v86 = (_BYTE *)*v83;
        v87 = (_BYTE *)v83[1];
        if ( (_BYTE *)*v83 != v87 )
        {
          v83[1] = v86;
          v87 = v86;
        }
        if ( v87 == (_BYTE *)v83[2] )
        {
          sub_1402A6B30((__int64)v83, v87, &v146);
        }
        else
        {
          *(_QWORD *)v87 = v24;
          v83[1] += 8LL;
        }
        v88 = v112;
        *v112 = v83;
        v88[1] = 0;
        v88[2] = 0;
        if ( v85 )
        {
          _InterlockedIncrement(v85 + 2);
          v88[1] = v83;
          v88[2] = v85;
          v88[3] = 0;
          v88[4] = 0;
          if ( _InterlockedExchangeAdd(v85 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v85)(v85);
            if ( _InterlockedExchangeAdd(v85 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v85 + 8LL))(v85);
          }
        }
        else
        {
          v88[1] = v83;
          v88[2] = 0;
          v88[3] = 0;
          v88[4] = 0;
        }
        sub_1402B2610(v151);
        v89 = v149;
        if ( v149 )
        {
          if ( ((*((_QWORD *)&v150 + 1) - (_QWORD)v149) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
          {
            v89 = (_BYTE *)*((_QWORD *)v149 + 0xFFFFFFFF);
            if ( (unsigned __int64)(v149 - v89 - 8) > 0x1F )
LABEL_131:
              invalid_parameter_noinfo_noreturn();
          }
          sub_1402A3D30(v89);
          v150 = 0;
          v149 = 0;
        }
        if ( v21 )
        {
          if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
            if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
LABEL_129:
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v21 + 8LL))(v21);
          }
        }
LABEL_130:
        v133 = __rdtsc();
        qword_149B4B878(&n0x5A00);
        std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v113);
        return v88;
      }
      v107 = v24;
    }
    sub_1402B2610(v151);
    v41 = v149;
    if ( v149 )
    {
      if ( ((*((_QWORD *)&v150 + 1) - (_QWORD)v149) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
      {
        v41 = (_BYTE *)*((_QWORD *)v149 + 0xFFFFFFFF);
        if ( (unsigned __int64)(v149 - v41 - 8) > 0x1F )
          goto LABEL_131;
      }
      sub_1402A3D30(v41);
      v150 = 0;
      v149 = 0;
    }
LABEL_100:
    v81 = v111;
    if ( v111 )
    {
      if ( _InterlockedExchangeAdd(v111 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v81)(v81);
        if ( _InterlockedExchangeAdd(v81 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v81 + 8LL))(v81);
      }
    }
    v110 = ++v4;
    if ( v4 >= v145 )
    {
      v7 = v112;
      v6 = v113;
LABEL_165:
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = 0;
      v7[4] = 0;
      v98 = allocWithProfilerInfo_w(0x18u);
      if ( v98 )
      {
        *(_DWORD *)(v98 + 8) = 1;
        *(_QWORD *)v98 = off_1481B6460;
        *(_DWORD *)(v98 + 0xC) = 1;
        *(_QWORD *)(v98 + 0x10) = 0;
      }
      else
      {
        v98 = 0;
      }
      v7[3] = 0;
      v7[4] = v98;
      v133 = __rdtsc();
      qword_149B4B878(&n0x5A00);
      v99 = (volatile signed __int32 *)v6[1];
      if ( v99 && _InterlockedExchangeAdd(v99 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v99)(v99);
        if ( _InterlockedExchangeAdd(v99 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v99 + 8LL))(v99);
      }
      return v7;
    }
    v8 = v124;
    v17 = v119;
  }
  v42 = *(_DWORD **)(v20 + 0x10);
  v43 = (unsigned int)v42[0xFFFFFFFF];
  LODWORD(v43) = v43 & 0x7FFFFFFF;
  v44 = &v42[6 * v43];
  v108 = v44;
  if ( v42 == v44 )
    goto LABEL_100;
  while ( !v107 )
  {
LABEL_98:
    v42 += 6;
    if ( v42 == v44 )
    {
      v4 = v110;
      goto LABEL_100;
    }
  }
  v45 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
  v46 = v45;
  if ( !v45 )
  {
    v123 = 0;
    goto LABEL_98;
  }
  v47 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v45 + 0x340LL);
  n0xFFFF = n0xFFFF_16;
  if ( n0xFFFF_16 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          v114,
                          "ISerializedComponent");
    n0xFFFF_16 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v49 = *(_QWORD *)v47(v46, v154, &n0xFFFF_1);
  v123 = v49;
  if ( !v49 )
    goto LABEL_98;
  v50 = v49 & 0xFFFFFFFFFFFFLL;
  v51 = sub_1403B4B50(v49 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v51 + 4);
  if ( n4 == 4 || *(_WORD *)(v51 + 2) != (HIWORD(v49) & 0xFFF) )
    goto LABEL_98;
  if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v123) )
    goto LABEL_98;
  v53 = *(void (__fastcall **)(__int64, __int64 *, _DWORD *, _QWORD *))(*(_QWORD *)v50 + 0x5B0LL);
  v54 = sub_1413674D0(&v158);
  v53(v50, &v120, v42, v54);
  v55 = v121;
  if ( !v121 )
    goto LABEL_98;
  v56 = *(_DWORD *)(v121 + 8);
  if ( !v56 )
    goto LABEL_94;
  while ( 1 )
  {
    v57 = v56;
    v56 = _InterlockedCompareExchange((volatile signed __int32 *)(v55 + 8), v56 + 1, v56);
    if ( v57 == v56 )
      break;
    if ( !v56 )
      goto LABEL_94;
  }
  v58 = v120;
  v59 = (volatile signed __int32 *)v121;
  if ( !v120 )
  {
LABEL_89:
    if ( v59 )
    {
      if ( _InterlockedExchangeAdd(v59 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v59)(v59);
        if ( _InterlockedExchangeAdd(v59 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v59 + 8LL))(v59);
      }
    }
    v44 = v108;
LABEL_94:
    v80 = v121;
    if ( v121 && _InterlockedExchangeAdd((volatile signed __int32 *)(v121 + 0xC), 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v80 + 8LL))(v80);
    goto LABEL_98;
  }
  if ( v110 != v119 )
  {
    v76 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v120 + 0x10LL))(v120, v160);
    v77 = *(_QWORD *)(v124 + 0x70);
    if ( !v77 )
    {
      std::_Xbad_function_call();
      __debugbreak();
    }
    v78 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v77 + 0x10LL))(v77, v76);
    v143 = 0;
    v79 = *v78;
    if ( v59 )
      _InterlockedIncrement(v59 + 2);
    *(_QWORD *)&v143 = v58;
    *((_QWORD *)&v143 + 1) = v59;
    v107 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *, __int128 *))(v79 + 0x10))(v78, v156, &v143);
    goto LABEL_89;
  }
  v60 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv, v107);
  v61 = v60;
  if ( v60 )
  {
    v62 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v60 + 0x340LL);
    n0xFFFF_2 = n0xFFFF_24;
    if ( n0xFFFF_24 == (__int16)0xFFFF )
    {
      n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                     + 0x10LL))(
                              qword_149B4FC88,
                              v115,
                              "ISubsumptionComponent");
      n0xFFFF_24 = n0xFFFF_2;
    }
    n0xFFFF_3 = n0xFFFF_2;
    v64 = *(_QWORD *)v62(v61, v155, &n0xFFFF_3);
    v122 = v64;
    if ( v64 )
    {
      v65 = sub_1403B4B50(v64 & 0xFFFFFFFFFFFFLL);
      n4_1 = *(_WORD *)(v65 + 4);
      if ( n4_1 != 4
        && *(_WORD *)(v65 + 2) == (HIWORD(v64) & 0xFFF)
        && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v122)) )
      {
        v67 = (__int64 **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v64 & 0xFFFFFFFFFFFFLL) + 0x590LL))(v64 & 0xFFFFFFFFFFFFLL);
        sub_14135C730(v67, v125, v42);
        if ( v125[0] )
        {
          v88 = v112;
          v91 = v126;
          *v112 = v125[0];
          v88[1] = 0;
          v88[2] = 0;
          if ( v91 )
          {
            _InterlockedIncrement(v91 + 2);
            v91 = v126;
          }
          v92 = v125[1];
          v88[2] = v91;
          v93 = v128;
          v88[1] = v92;
          v88[3] = 0;
          v88[4] = 0;
          if ( v93 )
          {
            _InterlockedIncrement(v93 + 2);
            v93 = v128;
          }
          v94 = v127;
          v88[4] = v93;
          v88[3] = v94;
          sub_140370C50((__int64)v125);
          if ( v59 )
          {
            if ( _InterlockedExchangeAdd(v59 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v59)(v59);
              if ( _InterlockedExchangeAdd(v59 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v59 + 8LL))(v59);
            }
          }
          v95 = v121;
          if ( v121 && _InterlockedExchangeAdd((volatile signed __int32 *)(v121 + 0xC), 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v95 + 8LL))(v95);
          v21 = v111;
          if ( v111 )
          {
            if ( _InterlockedExchangeAdd(v111 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
              if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
                goto LABEL_129;
            }
          }
          goto LABEL_130;
        }
        if ( v128 )
        {
          if ( _InterlockedExchangeAdd(v128 + 2, 0xFFFFFFFF) == 1 )
          {
            v68 = v128;
            (**(void (__fastcall ***)(volatile signed __int32 *))v128)(v128);
            if ( _InterlockedExchangeAdd(v68 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v128 + 8LL))(v128);
          }
        }
        if ( v126 )
        {
          if ( _InterlockedExchangeAdd(v126 + 2, 0xFFFFFFFF) == 1 )
          {
            v69 = v126;
            (**(void (__fastcall ***)(volatile signed __int32 *))v126)(v126);
            if ( _InterlockedExchangeAdd(v69 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v126 + 8LL))(v126);
          }
        }
      }
    }
  }
  else
  {
    v122 = 0;
  }
  v70 = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v71 = v70;
  if ( v70 )
  {
    *v70 = 0;
    v70[1] = 0;
    v70[2] = 0;
  }
  else
  {
    v71 = 0;
  }
  v72 = allocWithProfilerInfo_w(0x18u);
  v73 = (volatile signed __int32 *)v72;
  if ( v72 )
  {
    *(_DWORD *)(v72 + 8) = 1;
    *(_DWORD *)(v72 + 0xC) = 1;
    *(_QWORD *)v72 = off_1483F71C8;
    *(_QWORD *)(v72 + 0x10) = v71;
  }
  else
  {
    v73 = 0;
  }
  v74 = *(unsigned __int8 (__fastcall **)(__int64, _QWORD *, _QWORD *))(*(_QWORD *)v58 + 0x40LL);
  v75 = sub_1413674D0(&v159);
  if ( !v74(v58, v71, v75) )
  {
    if ( v73 )
    {
      if ( _InterlockedExchangeAdd(v73 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v73)(v73);
        if ( _InterlockedExchangeAdd(v73 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v73 + 8LL))(v73);
      }
    }
    goto LABEL_89;
  }
  v7 = v112;
  *v112 = v71;
  v7[1] = 0;
  v7[2] = 0;
  if ( v73 )
  {
    _InterlockedIncrement(v73 + 2);
    v7[1] = v71;
    v7[2] = v73;
    v7[3] = 0;
    v7[4] = 0;
    if ( _InterlockedExchangeAdd(v73 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v73)(v73);
      if ( _InterlockedExchangeAdd(v73 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v73 + 8LL))(v73);
    }
  }
  else
  {
    v7[1] = v71;
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
  }
  if ( v59 )
  {
    if ( _InterlockedExchangeAdd(v59 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v59)(v59);
      if ( _InterlockedExchangeAdd(v59 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v59 + 8LL))(v59);
    }
  }
  v96 = v121;
  if ( v121 && _InterlockedExchangeAdd((volatile signed __int32 *)(v121 + 0xC), 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v96 + 8LL))(v96);
  v97 = v111;
  if ( v111 )
  {
    if ( _InterlockedExchangeAdd(v111 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v97)(v97);
      if ( _InterlockedExchangeAdd(v97 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v97 + 8LL))(v97);
    }
  }
  v133 = __rdtsc();
  qword_149B4B878(&n0x5A00);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v113);
  return v7;
}

// --- End Function: sub_141380EA0 (0x141380EA0) ---

// --- Function: sub_14138FC80 (0x14138FC80) ---
_QWORD *__fastcall sub_14138FC80(__int64 a1, _QWORD *a2)
{
  char *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rbp
  __int64 *v7; // rax
  __int64 v8; // r8
  unsigned __int8 *v9; // rax
  __int64 v10; // r8
  int v11; // ecx
  int v12; // edx
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rbp
  __int64 v16; // rdi
  __int64 v17; // rbx
  signed __int64 v18; // rdx
  const char *v20; // [rsp+30h] [rbp-38h] BYREF
  _BYTE v21[24]; // [rsp+38h] [rbp-30h] BYREF
  BOOL fPending; // [rsp+80h] [rbp+18h] BYREF
  char *v23; // [rsp+88h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__121, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149CF3418 & 1) == 0 )
    {
      dword_149CF3418 |= 1u;
      xmmword_149CF3380 = 0;
    }
    n0x78_0 = 0x78;
    v23 = strchr(
            "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<struct SZoneTransform<struct Vec"
            "3_tpl<double> > >>(void)",
            0x3C);
    v4 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<struct SZoneTransform<struct Vec3"
           "_tpl<double> > >>(void)",
           0x3E);
    if ( v23 != v4 )
      ++v23;
    v20 = (const char *)&unk_149CF3398;
    sub_1403E40C0(&v20, (const char *)&unk_149CF3417, (const char **)&v23, v4);
    *v20 = 0;
    *((_QWORD *)&xmmword_149CF3380 + 1) = &unk_149CF341C;
    *(_QWORD *)&xmmword_149CF3380 = &xmmword_149CF3380;
    qword_149CF3378 = (__int64)&xmmword_149CF3380;
    if ( !InitOnceComplete(&lpInitOnce__121, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v5 = *(_QWORD *)qword_149CF3378;
  v6 = *(_QWORD *)(qword_149CF3378 + 8);
  v7 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v21);
  v8 = *v7;
  if ( v5 == *v7 )
    goto LABEL_19;
  if ( !v5 || !v8 || v6 == v7[1] || *(_QWORD *)(v5 + 0x10) != *(_QWORD *)(v8 + 0x10) )
    goto LABEL_18;
  v9 = (unsigned __int8 *)(v5 + 0x18);
  v10 = v8 - v5;
  do
  {
    v11 = v9[v10];
    v12 = *v9 - v11;
    if ( v12 )
      break;
    ++v9;
  }
  while ( v11 );
  if ( !v12 )
  {
LABEL_19:
    v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x20LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1)
      && (v16 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
      *(_QWORD *)v16 = v17;
      *(_BYTE *)(v16 + 8) = 1;
      if ( *(_DWORD *)(v17 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v17 + 0x14);
      }
      else
      {
        v18 = _InterlockedIncrement64((volatile signed __int64 *)v17);
        if ( (v18 & 0x200000) != 0 )
          sub_1403CB300(v17, v18, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
      }
    }
    else
    {
      v16 = 0;
    }
    v13 = v16;
    v14 = v15;
  }
  else
  {
LABEL_18:
    v13 = 0;
    v14 = 0;
  }
  sub_14035AED0(a2, v14, v13);
  return a2;
}

// --- End Function: sub_14138FC80 (0x14138FC80) ---

// --- Function: sub_141390D40 (0x141390D40) ---
_QWORD *__fastcall sub_141390D40(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 *v4; // rdx
  __int64 *v5; // rcx
  __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 *v8; // rbx
  __int64 *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // r8
  unsigned __int8 *v12; // rax
  __int64 v13; // r8
  int v14; // ecx
  int v15; // edx
  __int64 v16; // rdx
  __int64 v17; // rbx
  __int64 v18; // rbp
  __int64 v19; // rdi
  signed __int64 v20; // rdx
  _BYTE v22[16]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v23[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = *a1;
  v5 = v4;
  v6 = (__int64 *)v4[1];
  while ( !*((_BYTE *)v6 + 0x19) )
  {
    if ( *((_DWORD *)v6 + 8) >= *a3 )
    {
      v5 = v6;
      v6 = (__int64 *)*v6;
    }
    else
    {
      v6 = (__int64 *)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 0x19) || *a3 < *((_DWORD *)v5 + 8) || v5 == v4 )
  {
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
  else
  {
    v7 = v5[7];
    v8 = (__int64 *)sub_1413A77C0(v22);
    v9 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 8LL))(v7, v23);
    v10 = *v8;
    v11 = *v9;
    if ( *v8 == *v9 )
      goto LABEL_19;
    if ( !v10 || !v11 || v8[1] == v9[1] || *(_QWORD *)(v10 + 0x10) != *(_QWORD *)(v11 + 0x10) )
      goto LABEL_18;
    v12 = (unsigned __int8 *)(v10 + 0x18);
    v13 = v11 - v10;
    do
    {
      v14 = v12[v13];
      v15 = *v12 - v14;
      if ( v15 )
        break;
      ++v12;
    }
    while ( v14 );
    if ( !v15 )
    {
LABEL_19:
      v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x20LL))(v7);
      if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x10LL))(v7)
        && (v17 = allocWithProfilerInfo_w(0x10u)) != 0 )
      {
        v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x10LL))(v7);
        *(_QWORD *)v17 = v19;
        *(_BYTE *)(v17 + 8) = 1;
        if ( *(_DWORD *)(v19 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
        {
          ++*(_DWORD *)(v19 + 0x14);
        }
        else
        {
          v20 = _InterlockedIncrement64((volatile signed __int64 *)v19);
          if ( (v20 & 0x200000) != 0 )
            sub_1403CB300(v19, v20, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
        }
      }
      else
      {
        v17 = 0;
      }
      v16 = v18;
    }
    else
    {
LABEL_18:
      v16 = 0;
      v17 = 0;
    }
    sub_14035AED0(a2, v16, v17);
    return a2;
  }
}

// --- End Function: sub_141390D40 (0x141390D40) ---

// --- Function: sub_141390EF0 (0x141390EF0) ---
_QWORD *__fastcall sub_141390EF0(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 **v3; // rdi
  __int64 **v6; // r12
  __int64 *v7; // rax
  __int64 *v8; // r8
  __int64 *v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rbx
  __int64 *v12; // rdi
  __int64 *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r8
  unsigned __int8 *v16; // rax
  __int64 v17; // r8
  int v18; // ecx
  int v19; // edx
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rsi
  __int64 v23; // rdi
  __int64 v24; // rbx
  signed __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rbx
  volatile signed __int32 *v28; // rbx
  __int64 v29; // rax
  volatile signed __int32 *v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rbx
  volatile signed __int32 *v34; // rbx
  char v35[16]; // [rsp+30h] [rbp-50h] BYREF
  char v36[16]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v37[2]; // [rsp+50h] [rbp-30h] BYREF
  volatile signed __int32 *v38; // [rsp+60h] [rbp-20h]
  __int64 v39; // [rsp+68h] [rbp-18h]
  __int64 v40; // [rsp+70h] [rbp-10h]
  __int64 **v41; // [rsp+B0h] [rbp+30h]

  v3 = a1 + 3;
  v41 = a1 + 3;
  v6 = a1;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_44:
    if ( ++v6 == v3 )
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      a2[3] = 0;
      a2[4] = 0;
      v29 = allocWithProfilerInfo_w(0x18u);
      if ( v29 )
      {
        *(_DWORD *)(v29 + 8) = 1;
        *(_DWORD *)(v29 + 0xC) = 1;
        *(_QWORD *)v29 = off_1481B6460;
        *(_QWORD *)(v29 + 0x10) = 0;
      }
      a2[3] = 0;
      a2[4] = v29;
      return a2;
    }
  }
  v8 = (__int64 *)*v7;
  v9 = (__int64 *)*v7;
  v10 = *(__int64 **)(*v7 + 8);
  while ( !*((_BYTE *)v10 + 0x19) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *((_BYTE *)v9 + 0x19) || *a3 < *((_DWORD *)v9 + 8) || v9 == v8 )
  {
    v38 = 0;
    v26 = allocWithProfilerInfo_w(0x18u);
    v21 = v26;
    if ( v26 )
    {
      *(_DWORD *)(v26 + 8) = 1;
      *(_DWORD *)(v26 + 0xC) = 1;
      *(_QWORD *)v26 = off_1481B6460;
      *(_QWORD *)(v26 + 0x10) = 0;
    }
    else
    {
      v21 = 0;
    }
    goto LABEL_35;
  }
  v11 = v9[7];
  v12 = (__int64 *)sub_1413A77C0(v35);
  v13 = (__int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v11 + 8LL))(v11, v36);
  v14 = *v12;
  v15 = *v13;
  if ( *v12 != *v13 )
  {
    if ( !v14 || !v15 || v12[1] == v13[1] || *(_QWORD *)(v14 + 0x10) != *(_QWORD *)(v15 + 0x10) )
      goto LABEL_20;
    v16 = (unsigned __int8 *)(v14 + 0x18);
    v17 = v15 - v14;
    do
    {
      v18 = v16[v17];
      v19 = *v16 - v18;
      if ( v19 )
        break;
      ++v16;
    }
    while ( v18 );
    if ( v19 )
    {
LABEL_20:
      v38 = 0;
      v20 = allocWithProfilerInfo_w(0x18u);
      v21 = v20;
      v3 = v41;
      if ( v20 )
      {
        *(_DWORD *)(v20 + 8) = 1;
        *(_DWORD *)(v20 + 0xC) = 1;
        *(_QWORD *)v20 = off_1481B6460;
        *(_QWORD *)(v20 + 0x10) = 0;
      }
      else
      {
        v21 = 0;
      }
LABEL_35:
      v40 = v21;
LABEL_36:
      if ( v21 )
      {
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v21 + 8), 0xFFFFFFFF) == 1 )
        {
          v27 = v40;
          (**(void (__fastcall ***)(__int64))v40)(v40);
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v27 + 0xC), 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
        }
      }
      if ( v38 )
      {
        if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
        {
          v28 = v38;
          (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
          if ( _InterlockedExchangeAdd(v28 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
        }
      }
      goto LABEL_44;
    }
  }
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x20LL))(v11);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x10LL))(v11)
    && (v23 = allocWithProfilerInfo_w(0x10u)) != 0 )
  {
    v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x10LL))(v11);
    *(_QWORD *)v23 = v24;
    *(_BYTE *)(v23 + 8) = 1;
    if ( *(_DWORD *)(v24 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++*(_DWORD *)(v24 + 0x14);
    }
    else
    {
      v25 = _InterlockedIncrement64((volatile signed __int64 *)v24);
      if ( (v25 & 0x200000) != 0 )
        sub_1403CB300(v24, v25, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
    }
  }
  else
  {
    v23 = 0;
  }
  sub_14035AED0(v37, v22, v23);
  if ( !v37[0] )
  {
    v21 = v40;
    v3 = v41;
    goto LABEL_36;
  }
  v31 = v38;
  *a2 = v37[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v31 )
  {
    _InterlockedIncrement(v31 + 2);
    v31 = v38;
  }
  v32 = v40;
  a2[1] = v37[1];
  a2[2] = v31;
  a2[3] = 0;
  a2[4] = 0;
  if ( v32 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v32 + 8));
    v32 = v40;
    v31 = v38;
  }
  a2[3] = v39;
  a2[4] = v32;
  if ( v32 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v32 + 8), 0xFFFFFFFF) == 1 )
    {
      v33 = v40;
      (**(void (__fastcall ***)(__int64))v40)(v40);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v33 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 8LL))(v40);
    }
    v31 = v38;
  }
  if ( v31 )
  {
    if ( _InterlockedExchangeAdd(v31 + 2, 0xFFFFFFFF) == 1 )
    {
      v34 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  return a2;
}

// --- End Function: sub_141390EF0 (0x141390EF0) ---

// --- Function: sub_141394B60 (0x141394B60) ---
_QWORD *__fastcall sub_141394B60(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  __int64 v8; // rcx
  volatile signed __int32 *v9; // rdx
  signed __int32 v10; // eax
  volatile signed __int32 *v11; // rbx
  volatile signed __int32 *v12; // rbx
  volatile signed __int32 *v13; // rbx
  __int64 v14; // rbx
  __int64 *v15; // r8
  __int64 *v16; // rcx
  __int64 *v17; // rax
  _DWORD *v18; // r14
  __int64 v19; // rbx
  __int64 v20; // rbx
  volatile signed __int32 *v21; // rbx
  volatile signed __int32 *v22; // rbx
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rcx
  __int64 v25; // rax
  volatile signed __int32 *v26; // rbx
  volatile signed __int32 *v27; // rbx
  __int128 v29; // [rsp+20h] [rbp-59h] BYREF
  _QWORD v30[2]; // [rsp+30h] [rbp-49h] BYREF
  __int64 v31; // [rsp+40h] [rbp-39h]
  __int64 v32; // [rsp+48h] [rbp-31h]
  volatile signed __int32 *v33; // [rsp+50h] [rbp-29h]
  _DWORD *v34; // [rsp+58h] [rbp-21h] BYREF
  volatile signed __int32 *v35; // [rsp+68h] [rbp-11h]
  volatile signed __int32 *v36; // [rsp+78h] [rbp-1h]
  _DWORD *v37[2]; // [rsp+80h] [rbp+7h] BYREF
  volatile signed __int32 *v38; // [rsp+90h] [rbp+17h]
  volatile signed __int32 *v39; // [rsp+A0h] [rbp+27h]
  __int128 v40; // [rsp+B0h] [rbp+37h] BYREF

  sub_141390D40((__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)), v30, a3);
  if ( v30[0] )
  {
    v8 = v31;
    *a2 = v30[0];
    a2[1] = 0;
    a2[2] = 0;
    if ( v8 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 8));
      v8 = v31;
    }
    v9 = v33;
    a2[1] = v30[1];
    a2[2] = v8;
    a2[3] = 0;
    a2[4] = 0;
    if ( v9 )
    {
      _InterlockedIncrement(v9 + 2);
      v9 = v33;
      v8 = v31;
    }
    a2[3] = v32;
    a2[4] = v9;
    if ( !v9 )
      goto LABEL_23;
    v10 = _InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF);
    goto LABEL_19;
  }
  sub_14033B5B0((__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)), v37, a3);
  if ( !v37[0] )
  {
    v15 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
    v16 = v15;
    v17 = (__int64 *)v15[1];
    while ( !*((_BYTE *)v17 + 0x19) )
    {
      if ( *((_DWORD *)v17 + 8) >= *a3 )
      {
        v16 = v17;
        v17 = (__int64 *)*v17;
      }
      else
      {
        v17 = (__int64 *)v17[2];
      }
    }
    if ( *((_BYTE *)v16 + 0x19) || *a3 < *((_DWORD *)v16 + 8) || v16 == v15 )
    {
      v35 = 0;
      v25 = allocWithProfilerInfo_w(0x18u);
      v24 = (volatile signed __int32 *)v25;
      if ( v25 )
      {
        *(_DWORD *)(v25 + 8) = 1;
        *(_DWORD *)(v25 + 0xC) = 1;
        *(_QWORD *)v25 = off_1481B6460;
        *(_QWORD *)(v25 + 0x10) = 0;
      }
      else
      {
        v24 = 0;
      }
      v36 = v24;
    }
    else
    {
      sub_14138FC80(v16[7], &v34);
      v18 = v34;
      if ( v34 )
      {
        v29 = 0;
        if ( sub_14053B5C0(a4, v34, &v29) )
        {
          v19 = *((_QWORD *)&v29 + 1);
          if ( *((_QWORD *)&v29 + 1) )
          {
            _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL));
            v18 = v34;
            v19 = *((_QWORD *)&v29 + 1);
          }
          v40 = v29;
          sub_1413BB770(v18, a2, &v40, a4 + 0x88);
          if ( v19 )
          {
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v19 + 8), 0xFFFFFFFF) == 1 )
            {
              v20 = *((_QWORD *)&v29 + 1);
              (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
              if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v20 + 0xC), 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
            }
          }
          if ( v36 )
          {
            if ( _InterlockedExchangeAdd(v36 + 2, 0xFFFFFFFF) == 1 )
            {
              v21 = v36;
              (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
              if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
            }
          }
          if ( v35 )
          {
            if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
            {
              v22 = v35;
              (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
              if ( _InterlockedExchangeAdd(v22 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
            }
          }
          sub_140370C50((__int64)v37);
LABEL_70:
          sub_140370C50((__int64)v30);
          return a2;
        }
        if ( *((_QWORD *)&v29 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v29 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            v23 = *((_QWORD *)&v29 + 1);
            (***((void (__fastcall ****)(_QWORD))&v29 + 1))(*((_QWORD *)&v29 + 1));
            if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v23 + 0xC), 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v29 + 1) + 8LL))(*((_QWORD *)&v29 + 1));
          }
        }
      }
      v24 = v36;
    }
    if ( v24 )
    {
      if ( _InterlockedExchangeAdd(v24 + 2, 0xFFFFFFFF) == 1 )
      {
        v26 = v36;
        (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
        if ( _InterlockedExchangeAdd(v26 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
      }
    }
    if ( v35 )
    {
      if ( _InterlockedExchangeAdd(v35 + 2, 0xFFFFFFFF) == 1 )
      {
        v27 = v35;
        (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
        if ( _InterlockedExchangeAdd(v27 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
      }
    }
    sub_140370C50((__int64)v37);
    sub_14035AED0(a2, 0, 0);
    goto LABEL_70;
  }
  sub_141390EF0((__int64 **)(a4 + 0x88), a2, v37[0]);
  if ( v39 )
  {
    if ( _InterlockedExchangeAdd(v39 + 2, 0xFFFFFFFF) == 1 )
    {
      v11 = v39;
      (**(void (__fastcall ***)(volatile signed __int32 *))v39)(v39);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v39 + 8LL))(v39);
    }
  }
  if ( v38 )
  {
    if ( _InterlockedExchangeAdd(v38 + 2, 0xFFFFFFFF) == 1 )
    {
      v12 = v38;
      (**(void (__fastcall ***)(volatile signed __int32 *))v38)(v38);
      if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v38 + 8LL))(v38);
    }
  }
  if ( !v33 )
    goto LABEL_22;
  v10 = _InterlockedExchangeAdd(v33 + 2, 0xFFFFFFFF);
LABEL_19:
  if ( v10 == 1 )
  {
    v13 = v33;
    (**(void (__fastcall ***)(volatile signed __int32 *))v33)(v33);
    if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v33 + 8LL))(v33);
  }
LABEL_22:
  v8 = v31;
LABEL_23:
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    {
      v14 = v31;
      (**(void (__fastcall ***)(__int64))v31)(v31);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v14 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 8LL))(v31);
    }
  }
  return a2;
}

// --- End Function: sub_141394B60 (0x141394B60) ---

// --- Function: sub_1413A77C0 (0x1413A77C0) ---
_QWORD *__fastcall sub_1413A77C0(_QWORD *a1)
{
  char *v2; // rax
  __int64 v3; // rcx
  BOOL fPending; // [rsp+38h] [rbp+10h] BYREF
  char *v6; // [rsp+40h] [rbp+18h] BYREF
  const char *v7; // [rsp+48h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__122, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149CF2E98 & 1) == 0 )
    {
      dword_149CF2E98 |= 1u;
      xmmword_149CF2E00 = 0;
    }
    n0x28_5 = 0x28;
    v6 = strchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<struct SZoneTransform<struct Vec3_tpl<double> >>(void)",
           0x3C);
    v2 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<struct SZoneTransform<struct Vec3_tpl<double> >>(void)",
           0x3E);
    if ( v6 != v2 )
      ++v6;
    v7 = (const char *)&unk_149CF2E18;
    sub_1403E40C0(&v7, (const char *)&unk_149CF2E97, (const char **)&v6, v2);
    *v7 = 0;
    *((_QWORD *)&xmmword_149CF2E00 + 1) = &unk_149CF2E9C;
    *(_QWORD *)&xmmword_149CF2E00 = &xmmword_149CF2E00;
    qword_149CF2DF0 = (__int64)&xmmword_149CF2E00;
    if ( !InitOnceComplete(&lpInitOnce__122, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v3 = qword_149CF2DF0;
  *a1 = *(_QWORD *)qword_149CF2DF0;
  a1[1] = *(_QWORD *)(v3 + 8);
  return a1;
}

// --- End Function: sub_1413A77C0 (0x1413A77C0) ---

// --- Function: sub_1413BB770 (0x1413BB770) ---
_QWORD *__fastcall sub_1413BB770(__int64 a1, _QWORD *a2, void *a3, __int64 a4)
{
  _QWORD *v5; // rsi
  _QWORD *v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rcx
  void (__fastcall *v12)(__int64, __int64 *, _QWORD *, __int64); // r10
  __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // r14
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  int *v23; // rcx
  int *v24; // r9
  const char *v25; // rax
  unsigned int v26; // ecx
  unsigned int v27; // r8d
  int v28; // ebx
  int v29; // edi
  int v30; // esi
  int v31; // r14d
  int v32; // ecx
  int v33; // edx
  int v34; // eax
  int v35; // r9d
  int v36; // r8d
  size_t Size; // rbx
  size_t Size_1; // r8
  _QWORD *v39; // rax
  _QWORD *v40; // rdi
  __int64 v41; // rax
  volatile signed __int32 *v42; // rbx
  _BYTE *v43; // rcx
  _DWORD *v44; // r13
  __int64 v45; // rax
  _DWORD *v46; // rsi
  __int64 v47; // rax
  __int64 v48; // rbx
  __int64 (__fastcall *v49)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v51; // rbx
  __int64 v52; // rdi
  __int64 v53; // rax
  __int16 n4; // cx
  void (__fastcall *v55)(__int64, __int64 *, _DWORD *, _QWORD *); // rbx
  _QWORD *v56; // rax
  __int64 v57; // rdx
  signed __int32 v58; // eax
  signed __int32 v59; // ett
  __int64 v60; // r12
  volatile signed __int32 *v61; // rsi
  __int64 v62; // rax
  __int64 v63; // rbx
  __int64 (__fastcall *v64)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF_2; // ax
  __int64 v66; // rbx
  __int64 v67; // rax
  __int16 n4_1; // cx
  __int64 **v69; // rax
  volatile signed __int32 *v70; // rbx
  volatile signed __int32 *v71; // rbx
  _QWORD *v72; // rax
  _QWORD *v73; // r14
  __int64 v74; // rax
  volatile signed __int32 *v75; // rdi
  unsigned __int8 (__fastcall *v76)(__int64, _QWORD *, _QWORD *); // rbx
  _QWORD *v77; // rax
  __int64 v78; // rdx
  __int64 v79; // rcx
  __int64 *v80; // rcx
  __int64 v81; // rax
  __int64 v82; // rcx
  volatile signed __int32 *v83; // rbx
  _QWORD *v84; // r14
  volatile signed __int32 *v85; // rcx
  __int64 v86; // rax
  volatile signed __int32 *v87; // rcx
  __int64 v88; // rax
  __int64 v89; // rcx
  volatile signed __int32 *v90; // r14
  _QWORD *v92; // r12
  __int64 v93; // rcx
  volatile signed __int32 *v94; // rbx
  __int64 v95; // rax
  volatile signed __int32 *v96; // rbx
  int v97; // [rsp+40h] [rbp-D0h]
  int v98; // [rsp+48h] [rbp-C8h]
  int v99; // [rsp+78h] [rbp-98h]
  int v100; // [rsp+80h] [rbp-90h]
  int v101; // [rsp+88h] [rbp-88h]
  __int16 n0xFFFF_1; // [rsp+90h] [rbp-80h] BYREF
  __int16 n0xFFFF_3; // [rsp+92h] [rbp-7Eh] BYREF
  __int64 v104; // [rsp+98h] [rbp-78h] BYREF
  _DWORD *v105; // [rsp+A0h] [rbp-70h]
  __int64 v106; // [rsp+A8h] [rbp-68h]
  char *v107; // [rsp+B0h] [rbp-60h] BYREF
  _QWORD *v108; // [rsp+B8h] [rbp-58h]
  void *v109; // [rsp+C0h] [rbp-50h]
  char v110[2]; // [rsp+C8h] [rbp-48h] BYREF
  char v111[2]; // [rsp+CAh] [rbp-46h] BYREF
  unsigned int v112; // [rsp+CCh] [rbp-44h]
  int *v113; // [rsp+D0h] [rbp-40h]
  volatile signed __int32 *v114; // [rsp+D8h] [rbp-38h]
  __int64 v115; // [rsp+E0h] [rbp-30h] BYREF
  __int64 v116; // [rsp+E8h] [rbp-28h]
  __int64 v117; // [rsp+F0h] [rbp-20h] BYREF
  __int64 v118; // [rsp+F8h] [rbp-18h] BYREF
  __int64 v119; // [rsp+100h] [rbp-10h]
  unsigned __int64 v120; // [rsp+108h] [rbp-8h]
  _QWORD v121[2]; // [rsp+110h] [rbp+0h] BYREF
  volatile signed __int32 *v122; // [rsp+120h] [rbp+10h]
  __int64 v123; // [rsp+128h] [rbp+18h]
  volatile signed __int32 *v124; // [rsp+130h] [rbp+20h]
  __int64 v125; // [rsp+140h] [rbp+30h]
  __int64 v126; // [rsp+148h] [rbp+38h]
  __int64 v127; // [rsp+150h] [rbp+40h]
  __int64 v128; // [rsp+158h] [rbp+48h]
  __int64 v129; // [rsp+160h] [rbp+50h]
  __int64 v130; // [rsp+168h] [rbp+58h]
  int n0x5A00; // [rsp+170h] [rbp+60h] BYREF
  __int64 v132; // [rsp+174h] [rbp+64h]
  int v133; // [rsp+17Ch] [rbp+6Ch]
  unsigned __int64 v134; // [rsp+180h] [rbp+70h]
  unsigned __int64 v135; // [rsp+188h] [rbp+78h]
  __int64 v136; // [rsp+190h] [rbp+80h]
  __int64 v137; // [rsp+198h] [rbp+88h]
  unsigned __int64 v138; // [rsp+1C0h] [rbp+B0h]
  int *v139; // [rsp+1C8h] [rbp+B8h]
  __int128 v140; // [rsp+1D0h] [rbp+C0h] BYREF
  _QWORD v141[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  char v142[8]; // [rsp+1F0h] [rbp+E0h] BYREF
  __int64 v143; // [rsp+1F8h] [rbp+E8h] BYREF
  char v144[8]; // [rsp+200h] [rbp+F0h] BYREF
  char v145[8]; // [rsp+208h] [rbp+F8h] BYREF
  char v146[16]; // [rsp+210h] [rbp+100h] BYREF
  char v147[8]; // [rsp+220h] [rbp+110h] BYREF
  _BYTE *v148; // [rsp+228h] [rbp+118h]
  __int128 v149; // [rsp+230h] [rbp+120h]
  __int64 v150[4]; // [rsp+240h] [rbp+130h] BYREF
  char v151[16]; // [rsp+260h] [rbp+150h] BYREF
  __int64 v152; // [rsp+270h] [rbp+160h] BYREF
  __int64 v153; // [rsp+280h] [rbp+170h] BYREF
  char v154[16]; // [rsp+290h] [rbp+180h] BYREF
  size_t Size_2; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 n0x24; // [rsp+2A8h] [rbp+198h]
  _BYTE *v157; // [rsp+2B0h] [rbp+1A0h]
  _BYTE v158[40]; // [rsp+2B8h] [rbp+1A8h] BYREF
  unsigned __int64 v159; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 n0x1FF; // [rsp+2E8h] [rbp+1D8h]
  const char *v161; // [rsp+2F0h] [rbp+1E0h]
  _BYTE v162[520]; // [rsp+2F8h] [rbp+1E8h] BYREF

  v109 = a3;
  v126 = 0;
  v127 = 0;
  v5 = a3;
  v128 = 0;
  v6 = a2;
  v129 = 0;
  v7 = a1;
  v130 = 0;
  v133 = 0;
  v135 = 0;
  v136 = 0;
  v137 = 0;
  v108 = a2;
  v119 = a1;
  v125 = 0;
  n0x5A00 = 0x5A00;
  v132 = 1;
  v134 = __rdtsc();
  qword_149B4B870(
    &n0x5A00,
    &word_149CF2D50,
    "Subsumption::SuperGUID<struct SZoneTransform<struct Vec3_tpl<double> > >::ResolveSuperGuidInputValue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\SubsumptionSuperGUID.h",
    0xFF);
  HIWORD(n0x5A00) = word_149CF2D50;
  if ( !*(_QWORD *)(v7 + 0x70) )
    goto LABEL_149;
  v8 = (*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)*v5 + 8LL))(*v5, v151);
  v9 = *(_QWORD *)(v7 + 0x70);
  if ( !v9 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x1413BC4BALL);
  }
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v9 + 0x10LL))(v9, v8);
  v11 = v10;
  if ( !v10 )
    goto LABEL_149;
  v12 = *(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v10 + 0x18LL);
  v13 = v5[1];
  if ( v13 )
    _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
  v141[0] = *v5;
  v141[1] = v5[1];
  v12(v11, &v104, v141, a4);
  v14 = *(_QWORD *)(v7 + 0x30);
  v106 = 0;
  v15 = *(unsigned int *)(v14 - 4);
  LODWORD(v15) = v15 & 0x7FFFFFFF;
  v138 = v15;
  v16 = v15 - 1;
  if ( !v15 )
    v16 = 0;
  v120 = v16;
  if ( !v15 )
  {
LABEL_148:
    v5 = v109;
LABEL_149:
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v95 = allocWithProfilerInfo_w(0x18u);
    if ( v95 )
    {
      *(_DWORD *)(v95 + 8) = 1;
      *(_QWORD *)v95 = off_1481B6460;
      *(_DWORD *)(v95 + 0xC) = 1;
      *(_QWORD *)(v95 + 0x10) = 0;
    }
    else
    {
      v95 = 0;
    }
    v6[3] = 0;
    v6[4] = v95;
    v135 = __rdtsc();
    qword_149B4B878(&n0x5A00);
    v96 = (volatile signed __int32 *)v5[1];
    if ( v96 && _InterlockedExchangeAdd(v96 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v96)(v96);
      if ( _InterlockedExchangeAdd(v96 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v96 + 8LL))(v96);
    }
    return v6;
  }
  v17 = 0;
  while ( 1 )
  {
    if ( (int)v17 >= (*(_DWORD *)(*(_QWORD *)(v7 + 0x30) - 4LL) & 0x7FFFFFFF) )
      __debugbreak();
    v18 = (__int64 *)(*(_QWORD *)(v7 + 0x30) + 0x10LL * (int)v17);
    v19 = v18[1];
    if ( v19 )
      _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
    v20 = *v18;
    v114 = (volatile signed __int32 *)v18[1];
    if ( *(_DWORD *)(v20 + 8) )
      break;
    if ( !v104 )
    {
      v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
      v104 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v21 + 0x1D8LL))(v21, v142);
    }
    sub_1403F6100((__int64)v147, v104, v20 + 0x10);
    v22 = *sub_14040B4F0((__int64)v147, &v143);
    if ( v22 )
    {
      if ( v17 == v16 )
      {
        v39 = (_QWORD *)allocWithProfilerInfo_w(0x28u);
        v40 = v39;
        if ( v39 )
        {
          *v39 = 0;
          v39[1] = 0;
          v39[2] = 0;
          v39[3] = 0;
          v39[4] = 0;
        }
        else
        {
          v40 = 0;
        }
        v41 = allocWithProfilerInfo_w(0x18u);
        v42 = (volatile signed __int32 *)v41;
        if ( v41 )
        {
          *(_DWORD *)(v41 + 8) = 1;
          *(_DWORD *)(v41 + 0xC) = 1;
          *(_QWORD *)v41 = off_1483FF6F8;
          *(_QWORD *)(v41 + 0x10) = v40;
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v41 + 8), 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(__int64))v41)(v41);
            if ( _InterlockedExchangeAdd(v42 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v42 + 8LL))(v42);
          }
        }
      }
      else
      {
        v104 = v22;
      }
    }
    else
    {
      v23 = *(int **)(v20 + 0x18);
      v24 = *(int **)(v20 + 0x10);
      v162[0] = 0;
      v25 = v162;
      v161 = v162;
      v159 = 0;
      n0x1FF = 0x1FF;
      v139 = v23;
      v113 = v24;
      if ( v24 != v23 )
      {
        do
        {
          v26 = v24[2];
          v27 = *v24;
          v28 = *((unsigned __int8 *)v24 + 0xC);
          v29 = *((unsigned __int8 *)v24 + 0xD);
          v30 = *((unsigned __int8 *)v24 + 0xE);
          v31 = *((unsigned __int8 *)v24 + 0xF);
          v157 = v158;
          v101 = (unsigned __int8)v26;
          Size_2 = 0;
          v100 = BYTE1(v26);
          v99 = BYTE2(v26);
          v112 = HIBYTE(v26);
          v32 = *((unsigned __int8 *)v24 + 5);
          v98 = (unsigned __int8)v27;
          v97 = BYTE1(v27);
          LODWORD(v105) = HIBYTE(v27);
          v33 = BYTE2(v27);
          v34 = *((unsigned __int8 *)v24 + 4);
          v35 = *((unsigned __int8 *)v24 + 6);
          v36 = *((unsigned __int8 *)v113 + 7);
          v158[0] = 0;
          n0x24 = 0x24;
          sub_1402C61F0(
            (__int64)&Size_2,
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            v36,
            v35,
            v32,
            v34,
            (_DWORD)v105,
            v33,
            v97,
            v98,
            v31,
            v30,
            v29,
            v28,
            v112,
            v99,
            v100,
            v101);
          sub_1403E0AA0(&v107);
          Size = Size_2;
          if ( Size_2 )
          {
            sub_1403DE0C0(&v107, Size_2);
            sub_1403E1FA0(v107, v157, Size);
          }
          if ( v157 != v158 )
          {
            qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - n0x24;
            sub_147605980(v157);
          }
          if ( v107 )
          {
            Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++Size_1;
            while ( v107[Size_1] );
          }
          else
          {
            Size_1 = 0;
          }
          sub_1402DECA0(&v159, v107, Size_1);
          sub_1402DECA0(&v159, ", ", 2u);
          sub_140370D10(&v107);
          v24 = v113 + 4;
          v113 = v24;
        }
        while ( v24 != v139 );
        v25 = v161;
        v17 = v106;
      }
      sub_1405C0E00(
        4u,
        2u,
        "SuperGUID::ResolveSuperGuidInputValue failed to find entity in superguid query corresponding to the following super guid: %s",
        v25);
      if ( v161 != v162 )
      {
        qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
        sub_147605980(v161);
      }
    }
    sub_1402B2610(v150);
    v43 = v148;
    if ( v148 )
    {
      if ( ((*((_QWORD *)&v149 + 1) - (_QWORD)v148) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
      {
        v43 = (_BYTE *)*((_QWORD *)v148 + 0xFFFFFFFF);
        if ( (unsigned __int64)(v148 - v43 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v43);
      v149 = 0;
      v148 = 0;
    }
LABEL_107:
    v83 = v114;
    if ( v114 )
    {
      if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v83)(v83);
        if ( _InterlockedExchangeAdd(v83 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v83 + 8LL))(v83);
      }
    }
    v106 = ++v17;
    if ( v17 >= v138 )
    {
      v6 = v108;
      goto LABEL_148;
    }
    v7 = v119;
    v16 = v120;
  }
  v44 = *(_DWORD **)(v20 + 0x10);
  v45 = (unsigned int)v44[0xFFFFFFFF];
  LODWORD(v45) = v45 & 0x7FFFFFFF;
  v46 = &v44[6 * v45];
  v105 = v46;
  if ( v44 == v46 )
    goto LABEL_107;
  while ( 1 )
  {
    if ( !v104 )
      goto LABEL_106;
    v47 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
    v48 = v47;
    if ( !v47 )
    {
      v118 = 0;
      goto LABEL_106;
    }
    v49 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v47 + 0x340LL);
    n0xFFFF = n0xFFFF_16;
    if ( n0xFFFF_16 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            v110,
                            "ISerializedComponent");
      n0xFFFF_16 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    v51 = *(_QWORD *)v49(v48, v144, &n0xFFFF_1);
    v118 = v51;
    if ( !v51 )
      goto LABEL_106;
    v52 = v51 & 0xFFFFFFFFFFFFLL;
    v53 = sub_1403B4B50(v51 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v53 + 4);
    if ( n4 == 4 || *(_WORD *)(v53 + 2) != (HIWORD(v51) & 0xFFF) )
      goto LABEL_106;
    if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v118) )
      goto LABEL_106;
    v55 = *(void (__fastcall **)(__int64, __int64 *, _DWORD *, _QWORD *))(*(_QWORD *)v52 + 0x5B0LL);
    v56 = sub_1413A77C0(&v152);
    v55(v52, &v115, v44, v56);
    v57 = v116;
    if ( !v116 )
      goto LABEL_106;
    v58 = *(_DWORD *)(v116 + 8);
    if ( !v58 )
      goto LABEL_102;
    while ( 1 )
    {
      v59 = v58;
      v58 = _InterlockedCompareExchange((volatile signed __int32 *)(v57 + 8), v58 + 1, v58);
      if ( v59 == v58 )
        break;
      if ( !v58 )
        goto LABEL_102;
    }
    v60 = v115;
    v61 = (volatile signed __int32 *)v116;
    if ( !v115 )
      goto LABEL_97;
    if ( v17 != v120 )
    {
      v78 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v115 + 0x10LL))(v115, v154);
      v79 = *(_QWORD *)(v119 + 0x70);
      if ( !v79 )
      {
        std::_Xbad_function_call();
        __debugbreak();
      }
      v80 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v79 + 0x10LL))(v79, v78);
      v140 = 0;
      v81 = *v80;
      if ( v61 )
        _InterlockedIncrement(v61 + 2);
      *(_QWORD *)&v140 = v60;
      *((_QWORD *)&v140 + 1) = v61;
      v104 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *, __int128 *))(v81 + 0x10))(v80, v146, &v140);
      goto LABEL_97;
    }
    v62 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv, v104);
    v63 = v62;
    if ( v62 )
      break;
    v117 = 0;
LABEL_80:
    v72 = (_QWORD *)allocWithProfilerInfo_w(0x28u);
    v73 = v72;
    if ( v72 )
    {
      *v72 = 0;
      v72[1] = 0;
      v72[2] = 0;
      v72[3] = 0;
      v72[4] = 0;
    }
    else
    {
      v73 = 0;
    }
    v74 = allocWithProfilerInfo_w(0x18u);
    v75 = (volatile signed __int32 *)v74;
    if ( v74 )
    {
      *(_DWORD *)(v74 + 8) = 1;
      *(_DWORD *)(v74 + 0xC) = 1;
      *(_QWORD *)v74 = off_1483FF6F8;
      *(_QWORD *)(v74 + 0x10) = v73;
    }
    else
    {
      v75 = 0;
    }
    v76 = *(unsigned __int8 (__fastcall **)(__int64, _QWORD *, _QWORD *))(*(_QWORD *)v60 + 0x40LL);
    v77 = sub_1413A77C0(&v153);
    if ( v76(v60, v73, v77) )
    {
      v92 = v108;
      *v108 = v73;
      v92[1] = 0;
      v92[2] = 0;
      if ( v75 )
      {
        _InterlockedIncrement(v75 + 2);
        v92[1] = v73;
        v92[2] = v75;
        v92[3] = 0;
        v92[4] = 0;
        if ( _InterlockedExchangeAdd(v75 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v75)(v75);
          if ( _InterlockedExchangeAdd(v75 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v75 + 8LL))(v75);
        }
      }
      else
      {
        v92[1] = v73;
        v92[2] = 0;
        v92[3] = 0;
        v92[4] = 0;
      }
      if ( v61 )
      {
        if ( _InterlockedExchangeAdd(v61 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v61)(v61);
          if ( _InterlockedExchangeAdd(v61 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v61 + 8LL))(v61);
        }
      }
      v93 = v116;
      if ( v116 && _InterlockedExchangeAdd((volatile signed __int32 *)(v116 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v93 + 8LL))(v93);
      v94 = v114;
      if ( v114 )
      {
        if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v94)(v94);
          if ( _InterlockedExchangeAdd(v94 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v94 + 8LL))(v94);
        }
      }
      v135 = __rdtsc();
      qword_149B4B878(&n0x5A00);
      std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v109);
      return v92;
    }
    if ( v75 )
    {
      if ( _InterlockedExchangeAdd(v75 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v75)(v75);
        if ( _InterlockedExchangeAdd(v75 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v75 + 8LL))(v75);
      }
    }
    v17 = v106;
LABEL_97:
    if ( v61 )
    {
      if ( _InterlockedExchangeAdd(v61 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v61)(v61);
        if ( _InterlockedExchangeAdd(v61 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v61 + 8LL))(v61);
      }
    }
    v46 = v105;
LABEL_102:
    v82 = v116;
    if ( v116 && _InterlockedExchangeAdd((volatile signed __int32 *)(v116 + 0xC), 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v82 + 8LL))(v82);
LABEL_106:
    v44 += 6;
    if ( v44 == v46 )
      goto LABEL_107;
  }
  v64 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v62 + 0x340LL);
  n0xFFFF_2 = n0xFFFF_24;
  if ( n0xFFFF_24 == (__int16)0xFFFF )
  {
    n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            v111,
                            "ISubsumptionComponent");
    n0xFFFF_24 = n0xFFFF_2;
  }
  n0xFFFF_3 = n0xFFFF_2;
  v66 = *(_QWORD *)v64(v63, v145, &n0xFFFF_3);
  v117 = v66;
  if ( !v66 )
    goto LABEL_80;
  v67 = sub_1403B4B50(v66 & 0xFFFFFFFFFFFFLL);
  n4_1 = *(_WORD *)(v67 + 4);
  if ( n4_1 == 4 || *(_WORD *)(v67 + 2) != (HIWORD(v66) & 0xFFF) )
    goto LABEL_80;
  if ( (n4_1 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v117) )
    goto LABEL_80;
  v69 = (__int64 **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v66 & 0xFFFFFFFFFFFFLL) + 0x590LL))(v66 & 0xFFFFFFFFFFFFLL);
  sub_141390D40(v69, v121, v44);
  if ( !v121[0] )
  {
    if ( v124 )
    {
      if ( _InterlockedExchangeAdd(v124 + 2, 0xFFFFFFFF) == 1 )
      {
        v70 = v124;
        (**(void (__fastcall ***)(volatile signed __int32 *))v124)(v124);
        if ( _InterlockedExchangeAdd(v70 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v124 + 8LL))(v124);
      }
    }
    if ( v122 )
    {
      if ( _InterlockedExchangeAdd(v122 + 2, 0xFFFFFFFF) == 1 )
      {
        v71 = v122;
        (**(void (__fastcall ***)(volatile signed __int32 *))v122)(v122);
        if ( _InterlockedExchangeAdd(v71 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v122 + 8LL))(v122);
      }
    }
    goto LABEL_80;
  }
  v84 = v108;
  v85 = v122;
  *v108 = v121[0];
  v84[1] = 0;
  v84[2] = 0;
  if ( v85 )
  {
    _InterlockedIncrement(v85 + 2);
    v85 = v122;
  }
  v86 = v121[1];
  v84[2] = v85;
  v87 = v124;
  v84[1] = v86;
  v84[3] = 0;
  v84[4] = 0;
  if ( v87 )
  {
    _InterlockedIncrement(v87 + 2);
    v87 = v124;
  }
  v88 = v123;
  v84[4] = v87;
  v84[3] = v88;
  sub_140370C50((__int64)v121);
  if ( v61 )
  {
    if ( _InterlockedExchangeAdd(v61 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v61)(v61);
      if ( _InterlockedExchangeAdd(v61 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v61 + 8LL))(v61);
    }
  }
  v89 = v116;
  if ( v116 && _InterlockedExchangeAdd((volatile signed __int32 *)(v116 + 0xC), 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v89 + 8LL))(v89);
  v90 = v114;
  if ( v114 )
  {
    if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v90)(v90);
      if ( _InterlockedExchangeAdd(v90 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v90 + 8LL))(v90);
    }
  }
  v135 = __rdtsc();
  qword_149B4B878(&n0x5A00);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v109);
  return v108;
}

// --- End Function: sub_1413BB770 (0x1413BB770) ---

// --- Function: sub_141848E00 (0x141848E00) ---
_QWORD *__fastcall sub_141848E00(_QWORD *p_pExceptionObject)
{
  p_pExceptionObject[1] = "bad allocation";
  *p_pExceptionObject = off_1481A05A8;
  return p_pExceptionObject;
}

// --- End Function: sub_141848E00 (0x141848E00) ---

// --- Function: sub_141872140 (0x141872140) ---
_QWORD *__fastcall sub_141872140(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_25;
  if ( n0xFFFF_25 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "IEntityPhysicsController");
    n0xFFFF_25 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_141872140 (0x141872140) ---

// --- Function: sub_141976650 (0x141976650) ---
void __fastcall sub_141976650(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx

  v2 = (_QWORD *)a1[0xB];
  if ( v2 )
  {
    if ( ((a1[0xD] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        goto LABEL_12;
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[0xB] = 0;
    a1[0xC] = 0;
    a1[0xD] = 0;
  }
  v3 = (_QWORD *)a1[7];
  if ( !v3 )
    return;
  if ( ((a1[9] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFC0uLL) >= 0x1000 )
  {
    if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v3 = (_QWORD *)v3[0xFFFFFFFF];
      goto LABEL_10;
    }
LABEL_12:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_1402A3D30(v3);
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
}

// --- End Function: sub_141976650 (0x141976650) ---

// --- Function: sub_1419EA6D0 (0x1419EA6D0) ---
_QWORD *__fastcall sub_1419EA6D0(__int64 a1, _QWORD *a2)
{
  __int64 *v4; // rbx
  __int64 *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  unsigned __int8 *v8; // rax
  __int64 v9; // r8
  int v10; // ecx
  int v11; // edx
  __int64 v13; // rbp
  __int64 v14; // rbx
  __int64 v15; // rdi
  signed __int64 v16; // rdx
  _BYTE v17[16]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v18[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = (__int64 *)sub_141A38380(v17);
  v5 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v18);
  v6 = *v4;
  v7 = *v5;
  if ( *v4 == *v5 )
    goto LABEL_11;
  if ( !v6 || !v7 || v4[1] == v5[1] || *(_QWORD *)(v6 + 0x10) != *(_QWORD *)(v7 + 0x10) )
    goto LABEL_10;
  v8 = (unsigned __int8 *)(v6 + 0x18);
  v9 = v7 - v6;
  do
  {
    v10 = v8[v9];
    v11 = *v8 - v10;
    if ( v11 )
      break;
    ++v8;
  }
  while ( v10 );
  if ( !v11 )
  {
LABEL_11:
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x20LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1)
      && (v14 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
      *(_QWORD *)v14 = v15;
      *(_BYTE *)(v14 + 8) = 1;
      if ( *(_DWORD *)(v15 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v15 + 0x14);
      }
      else
      {
        v16 = _InterlockedIncrement64((volatile signed __int64 *)v15);
        if ( (v16 & 0x200000) != 0 )
          sub_1403CB300(v15, v16, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
      }
    }
    else
    {
      v14 = 0;
    }
    sub_14035AED0(a2, v13, v14);
    return a2;
  }
  else
  {
LABEL_10:
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
}

// --- End Function: sub_1419EA6D0 (0x1419EA6D0) ---

// --- Function: sub_1419EBCD0 (0x1419EBCD0) ---
_QWORD *__fastcall sub_1419EBCD0(__int64 a1, _QWORD *a2)
{
  __int64 *v4; // rbx
  __int64 *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  unsigned __int8 *v8; // rax
  __int64 v9; // r8
  int v10; // ecx
  int v11; // edx
  __int64 v13; // rbp
  __int64 v14; // rbx
  __int64 v15; // rdi
  signed __int64 v16; // rdx
  _BYTE v17[16]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v18[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = (__int64 *)sub_141A39550(v17);
  v5 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v18);
  v6 = *v4;
  v7 = *v5;
  if ( *v4 == *v5 )
    goto LABEL_11;
  if ( !v6 || !v7 || v4[1] == v5[1] || *(_QWORD *)(v6 + 0x10) != *(_QWORD *)(v7 + 0x10) )
    goto LABEL_10;
  v8 = (unsigned __int8 *)(v6 + 0x18);
  v9 = v7 - v6;
  do
  {
    v10 = v8[v9];
    v11 = *v8 - v10;
    if ( v11 )
      break;
    ++v8;
  }
  while ( v10 );
  if ( !v11 )
  {
LABEL_11:
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x20LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1)
      && (v14 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
      *(_QWORD *)v14 = v15;
      *(_BYTE *)(v14 + 8) = 1;
      if ( *(_DWORD *)(v15 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v15 + 0x14);
      }
      else
      {
        v16 = _InterlockedIncrement64((volatile signed __int64 *)v15);
        if ( (v16 & 0x200000) != 0 )
          sub_1403CB300(v15, v16, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
      }
    }
    else
    {
      v14 = 0;
    }
    sub_14035AED0(a2, v13, v14);
    return a2;
  }
  else
  {
LABEL_10:
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
}

// --- End Function: sub_1419EBCD0 (0x1419EBCD0) ---

// --- Function: sub_1419EC490 (0x1419EC490) ---
_QWORD *__fastcall sub_1419EC490(__int64 a1, _QWORD *a2)
{
  __int64 *v4; // rbx
  __int64 *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  unsigned __int8 *v8; // rax
  __int64 v9; // r8
  int v10; // ecx
  int v11; // edx
  __int64 v13; // rbp
  __int64 v14; // rbx
  __int64 v15; // rdi
  signed __int64 v16; // rdx
  _BYTE v17[16]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v18[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = (__int64 *)sub_141A39A10(v17);
  v5 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v18);
  v6 = *v4;
  v7 = *v5;
  if ( *v4 == *v5 )
    goto LABEL_11;
  if ( !v6 || !v7 || v4[1] == v5[1] || *(_QWORD *)(v6 + 0x10) != *(_QWORD *)(v7 + 0x10) )
    goto LABEL_10;
  v8 = (unsigned __int8 *)(v6 + 0x18);
  v9 = v7 - v6;
  do
  {
    v10 = v8[v9];
    v11 = *v8 - v10;
    if ( v11 )
      break;
    ++v8;
  }
  while ( v10 );
  if ( !v11 )
  {
LABEL_11:
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x20LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1)
      && (v14 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
      *(_QWORD *)v14 = v15;
      *(_BYTE *)(v14 + 8) = 1;
      if ( *(_DWORD *)(v15 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v15 + 0x14);
      }
      else
      {
        v16 = _InterlockedIncrement64((volatile signed __int64 *)v15);
        if ( (v16 & 0x200000) != 0 )
          sub_1403CB300(v15, v16, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
      }
    }
    else
    {
      v14 = 0;
    }
    sub_14035AED0(a2, v13, v14);
    return a2;
  }
  else
  {
LABEL_10:
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
}

// --- End Function: sub_1419EC490 (0x1419EC490) ---

// --- Function: sub_1419ECFF0 (0x1419ECFF0) ---
_QWORD *__fastcall sub_1419ECFF0(__int64 a1, _QWORD *a2)
{
  __int64 *v4; // rbx
  __int64 *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  unsigned __int8 *v8; // rax
  __int64 v9; // r8
  int v10; // ecx
  int v11; // edx
  __int64 v13; // rbp
  __int64 v14; // rbx
  __int64 v15; // rdi
  signed __int64 v16; // rdx
  _BYTE v17[16]; // [rsp+30h] [rbp-28h] BYREF
  _BYTE v18[24]; // [rsp+40h] [rbp-18h] BYREF

  v4 = (__int64 *)sub_141A3A260(v17);
  v5 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 8LL))(a1, v18);
  v6 = *v4;
  v7 = *v5;
  if ( *v4 == *v5 )
    goto LABEL_11;
  if ( !v6 || !v7 || v4[1] == v5[1] || *(_QWORD *)(v6 + 0x10) != *(_QWORD *)(v7 + 0x10) )
    goto LABEL_10;
  v8 = (unsigned __int8 *)(v6 + 0x18);
  v9 = v7 - v6;
  do
  {
    v10 = v8[v9];
    v11 = *v8 - v10;
    if ( v11 )
      break;
    ++v8;
  }
  while ( v10 );
  if ( !v11 )
  {
LABEL_11:
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x20LL))(a1);
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1)
      && (v14 = allocWithProfilerInfo_w(0x10u)) != 0 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x10LL))(a1);
      *(_QWORD *)v14 = v15;
      *(_BYTE *)(v14 + 8) = 1;
      if ( *(_DWORD *)(v15 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v15 + 0x14);
      }
      else
      {
        v16 = _InterlockedIncrement64((volatile signed __int64 *)v15);
        if ( (v16 & 0x200000) != 0 )
          sub_1403CB300(v15, v16, (const char *)&byte_14819E9C2, (const char *)&byte_14819E9C2, 1);
      }
    }
    else
    {
      v14 = 0;
    }
    sub_14035AED0(a2, v13, v14);
    return a2;
  }
  else
  {
LABEL_10:
    sub_14035AED0(a2, 0, 0);
    return a2;
  }
}

// --- End Function: sub_1419ECFF0 (0x1419ECFF0) ---

// --- Function: sub_1419EEAB0 (0x1419EEAB0) ---
_QWORD *__fastcall sub_1419EEAB0(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 **v3; // rbp
  __int64 **v6; // rsi
  __int64 *v7; // rax
  __int64 *v8; // r8
  __int64 *v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rbx
  volatile signed __int32 *v14; // rbx
  __int64 v15; // rax
  volatile signed __int32 *v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rbx
  volatile signed __int32 *v19; // rbx
  _QWORD v21[2]; // [rsp+20h] [rbp-58h] BYREF
  volatile signed __int32 *v22; // [rsp+30h] [rbp-48h]
  __int64 v23; // [rsp+38h] [rbp-40h]
  __int64 v24; // [rsp+40h] [rbp-38h]

  v3 = a1 + 3;
  v6 = a1;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_25:
    if ( ++v6 == v3 )
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      a2[3] = 0;
      a2[4] = 0;
      v15 = allocWithProfilerInfo_w(0x18u);
      if ( v15 )
      {
        *(_DWORD *)(v15 + 8) = 1;
        *(_DWORD *)(v15 + 0xC) = 1;
        *(_QWORD *)v15 = off_1481B6460;
        *(_QWORD *)(v15 + 0x10) = 0;
      }
      else
      {
        v15 = 0;
      }
      a2[3] = 0;
      a2[4] = v15;
      return a2;
    }
  }
  v8 = (__int64 *)*v7;
  v9 = (__int64 *)*v7;
  v10 = *(__int64 **)(*v7 + 8);
  while ( !*((_BYTE *)v10 + 0x19) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *((_BYTE *)v9 + 0x19) || *a3 < *((_DWORD *)v9 + 8) || v9 == v8 )
  {
    v22 = 0;
    v12 = allocWithProfilerInfo_w(0x18u);
    v11 = v12;
    if ( v12 )
    {
      *(_DWORD *)(v12 + 8) = 1;
      *(_DWORD *)(v12 + 0xC) = 1;
      *(_QWORD *)v12 = off_1481B6460;
      *(_QWORD *)(v12 + 0x10) = 0;
    }
    else
    {
      v11 = 0;
    }
    v24 = v11;
    goto LABEL_17;
  }
  sub_1419EA6D0(v9[7], v21);
  if ( !v21[0] )
  {
    v11 = v24;
LABEL_17:
    if ( v11 )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 0xFFFFFFFF) == 1 )
      {
        v13 = v24;
        (**(void (__fastcall ***)(__int64))v24)(v24);
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v13 + 0xC), 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 8LL))(v24);
      }
    }
    if ( v22 )
    {
      if ( _InterlockedExchangeAdd(v22 + 2, 0xFFFFFFFF) == 1 )
      {
        v14 = v22;
        (**(void (__fastcall ***)(volatile signed __int32 *))v22)(v22);
        if ( _InterlockedExchangeAdd(v14 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v22 + 8LL))(v22);
      }
    }
    goto LABEL_25;
  }
  v16 = v22;
  *a2 = v21[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v16 )
  {
    _InterlockedIncrement(v16 + 2);
    v16 = v22;
  }
  v17 = v24;
  a2[1] = v21[1];
  a2[2] = v16;
  a2[3] = 0;
  a2[4] = 0;
  if ( v17 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v17 + 8));
    v17 = v24;
    v16 = v22;
  }
  a2[3] = v23;
  a2[4] = v17;
  if ( v17 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v17 + 8), 0xFFFFFFFF) == 1 )
    {
      v18 = v24;
      (**(void (__fastcall ***)(__int64))v24)(v24);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v18 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 8LL))(v24);
    }
    v16 = v22;
  }
  if ( v16 )
  {
    if ( _InterlockedExchangeAdd(v16 + 2, 0xFFFFFFFF) == 1 )
    {
      v19 = v22;
      (**(void (__fastcall ***)(volatile signed __int32 *))v22)(v22);
      if ( _InterlockedExchangeAdd(v19 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v22 + 8LL))(v22);
    }
  }
  return a2;
}

// --- End Function: sub_1419EEAB0 (0x1419EEAB0) ---

// --- Function: sub_1419EFC90 (0x1419EFC90) ---
_QWORD *__fastcall sub_1419EFC90(__int64 **a1, _QWORD *a2, _DWORD *a3)
{
  __int64 **v3; // rbp
  __int64 **v6; // rsi
  __int64 *v7; // rax
  __int64 *v8; // r8
  __int64 *v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rbx
  volatile signed __int32 *v14; // rbx
  __int64 v15; // rax
  volatile signed __int32 *v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rbx
  volatile signed __int32 *v19; // rbx
  _QWORD v21[2]; // [rsp+20h] [rbp-58h] BYREF
  volatile signed __int32 *v22; // [rsp+30h] [rbp-48h]
  __int64 v23; // [rsp+38h] [rbp-40h]
  __int64 v24; // [rsp+40h] [rbp-38h]

  v3 = a1 + 3;
  v6 = a1;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_25:
    if ( ++v6 == v3 )
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      a2[3] = 0;
      a2[4] = 0;
      v15 = allocWithProfilerInfo_w(0x18u);
      if ( v15 )
      {
        *(_DWORD *)(v15 + 8) = 1;
        *(_DWORD *)(v15 + 0xC) = 1;
        *(_QWORD *)v15 = off_1481B6460;
        *(_QWORD *)(v15 + 0x10) = 0;
      }
      else
      {
        v15 = 0;
      }
      a2[3] = 0;
      a2[4] = v15;
      return a2;
    }
  }
  v8 = (__int64 *)*v7;
  v9 = (__int64 *)*v7;
  v10 = *(__int64 **)(*v7 + 8);
  while ( !*((_BYTE *)v10 + 0x19) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *((_BYTE *)v9 + 0x19) || *a3 < *((_DWORD *)v9 + 8) || v9 == v8 )
  {
    v22 = 0;
    v12 = allocWithProfilerInfo_w(0x18u);
    v11 = v12;
    if ( v12 )
    {
      *(_DWORD *)(v12 + 8) = 1;
      *(_DWORD *)(v12 + 0xC) = 1;
      *(_QWORD *)v12 = off_1481B6460;
      *(_QWORD *)(v12 + 0x10) = 0;
    }
    else
    {
      v11 = 0;
    }
    v24 = v11;
    goto LABEL_17;
  }
  sub_1419ECFF0(v9[7], v21);
  if ( !v21[0] )
  {
    v11 = v24;
LABEL_17:
    if ( v11 )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 0xFFFFFFFF) == 1 )
      {
        v13 = v24;
        (**(void (__fastcall ***)(__int64))v24)(v24);
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v13 + 0xC), 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 8LL))(v24);
      }
    }
    if ( v22 )
    {
      if ( _InterlockedExchangeAdd(v22 + 2, 0xFFFFFFFF) == 1 )
      {
        v14 = v22;
        (**(void (__fastcall ***)(volatile signed __int32 *))v22)(v22);
        if ( _InterlockedExchangeAdd(v14 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v22 + 8LL))(v22);
      }
    }
    goto LABEL_25;
  }
  v16 = v22;
  *a2 = v21[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v16 )
  {
    _InterlockedIncrement(v16 + 2);
    v16 = v22;
  }
  v17 = v24;
  a2[1] = v21[1];
  a2[2] = v16;
  a2[3] = 0;
  a2[4] = 0;
  if ( v17 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v17 + 8));
    v17 = v24;
    v16 = v22;
  }
  a2[3] = v23;
  a2[4] = v17;
  if ( v17 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v17 + 8), 0xFFFFFFFF) == 1 )
    {
      v18 = v24;
      (**(void (__fastcall ***)(__int64))v24)(v24);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v18 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 8LL))(v24);
    }
    v16 = v22;
  }
  if ( v16 )
  {
    if ( _InterlockedExchangeAdd(v16 + 2, 0xFFFFFFFF) == 1 )
    {
      v19 = v22;
      (**(void (__fastcall ***)(volatile signed __int32 *))v22)(v22);
      if ( _InterlockedExchangeAdd(v19 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v22 + 8LL))(v22);
    }
  }
  return a2;
}

// --- End Function: sub_1419EFC90 (0x1419EFC90) ---

// --- Function: sub_1419FAC20 (0x1419FAC20) ---
_QWORD *__fastcall sub_1419FAC20(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  __int64 *v8; // r10
  __int64 *v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rcx
  volatile signed __int32 *v12; // rdx
  signed __int32 v13; // eax
  __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 *v16; // rax
  volatile signed __int32 *v17; // rbx
  volatile signed __int32 *v18; // rbx
  __int64 v19; // rax
  __int64 *v20; // rcx
  __int64 *v21; // rax
  _DWORD *v22; // r10
  __int64 ***v23; // rdx
  __int64 **v24; // r9
  __int64 *v25; // rcx
  __int64 *v26; // rax
  volatile signed __int32 *v27; // rcx
  __int64 v28; // rax
  volatile signed __int32 *v29; // rbx
  __int64 v30; // r9
  __int64 v31; // rax
  volatile signed __int32 *v32; // rbx
  volatile signed __int32 *v33; // rbx
  __int64 v34; // rax
  volatile signed __int32 *v35; // rbx
  volatile signed __int32 *v36; // rbx
  volatile signed __int32 *v37; // rbx
  volatile signed __int32 *v38; // rbx
  volatile signed __int32 *v39; // rbx
  __int64 v40; // rbx
  _QWORD v42[2]; // [rsp+20h] [rbp-49h] BYREF
  __int64 v43; // [rsp+30h] [rbp-39h]
  __int64 v44; // [rsp+38h] [rbp-31h]
  volatile signed __int32 *v45; // [rsp+40h] [rbp-29h]
  _DWORD *v46; // [rsp+48h] [rbp-21h] BYREF
  volatile signed __int32 *v47; // [rsp+58h] [rbp-11h]
  volatile signed __int32 *v48; // [rsp+68h] [rbp-1h]
  _DWORD *v49; // [rsp+70h] [rbp+7h] BYREF
  volatile signed __int32 *v50; // [rsp+80h] [rbp+17h]
  volatile signed __int32 *v51; // [rsp+90h] [rbp+27h]
  __int64 v52; // [rsp+98h] [rbp+2Fh] BYREF
  volatile signed __int32 *v53; // [rsp+A0h] [rbp+37h]

  v8 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
  v9 = v8;
  v10 = (__int64 *)v8[1];
  while ( !*((_BYTE *)v10 + 0x19) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *((_BYTE *)v9 + 0x19) || *a3 < *((_DWORD *)v9 + 8) || v9 == v8 )
  {
    v43 = 0;
    v14 = allocWithProfilerInfo_w(0x18u);
    if ( v14 )
    {
      *(_DWORD *)(v14 + 8) = 1;
      *(_DWORD *)(v14 + 0xC) = 1;
      *(_QWORD *)v14 = off_1481B6460;
      *(_QWORD *)(v14 + 0x10) = 0;
    }
    else
    {
      v14 = 0;
    }
    v45 = (volatile signed __int32 *)v14;
LABEL_20:
    v15 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
    v16 = (__int64 *)v15[1];
    while ( !*((_BYTE *)v16 + 0x19) )
    {
      if ( *((_DWORD *)v16 + 8) >= *a3 )
      {
        v15 = v16;
        v16 = (__int64 *)*v16;
      }
      else
      {
        v16 = (__int64 *)v16[2];
      }
    }
    if ( *((_BYTE *)v15 + 0x19) || *a3 < *((_DWORD *)v15 + 8) || v15 == *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)) )
    {
      v47 = 0;
      v19 = allocWithProfilerInfo_w(0x18u);
      if ( v19 )
      {
        *(_DWORD *)(v19 + 8) = 1;
        *(_DWORD *)(v19 + 0xC) = 1;
        *(_QWORD *)v19 = off_1481B6460;
        *(_QWORD *)(v19 + 0x10) = 0;
      }
      else
      {
        v19 = 0;
      }
      v48 = (volatile signed __int32 *)v19;
    }
    else
    {
      sub_14033B330(v15[7], &v46);
      if ( v46 )
      {
        sub_1419EEAB0((__int64 **)(a4 + 0x88), a2, v46);
LABEL_30:
        if ( v48 )
        {
          if ( _InterlockedExchangeAdd(v48 + 2, 0xFFFFFFFF) == 1 )
          {
            v17 = v48;
            (**(void (__fastcall ***)(volatile signed __int32 *))v48)(v48);
            if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v48 + 8LL))(v48);
          }
        }
        if ( v47 )
        {
          if ( _InterlockedExchangeAdd(v47 + 2, 0xFFFFFFFF) == 1 )
          {
            v18 = v47;
            (**(void (__fastcall ***)(volatile signed __int32 *))v47)(v47);
            if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v47 + 8LL))(v47);
          }
        }
LABEL_99:
        if ( !v45 )
        {
LABEL_104:
          v11 = v43;
          goto LABEL_105;
        }
        v13 = _InterlockedExchangeAdd(v45 + 2, 0xFFFFFFFF);
LABEL_101:
        if ( v13 == 1 )
        {
          v39 = v45;
          (**(void (__fastcall ***)(volatile signed __int32 *))v45)(v45);
          if ( _InterlockedExchangeAdd(v39 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v45 + 8LL))(v45);
        }
        goto LABEL_104;
      }
    }
    v20 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
    v21 = (__int64 *)v20[1];
    while ( !*((_BYTE *)v21 + 0x19) )
    {
      if ( *((_DWORD *)v21 + 8) >= *a3 )
      {
        v20 = v21;
        v21 = (__int64 *)*v21;
      }
      else
      {
        v21 = (__int64 *)v21[2];
      }
    }
    if ( *((_BYTE *)v20 + 0x19) || *a3 < *((_DWORD *)v20 + 8) || v20 == *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)) )
    {
      v50 = 0;
      v34 = allocWithProfilerInfo_w(0x18u);
      v27 = (volatile signed __int32 *)v34;
      if ( v34 )
      {
        *(_DWORD *)(v34 + 8) = 1;
        *(_DWORD *)(v34 + 0xC) = 1;
        *(_QWORD *)v34 = off_1481B6460;
        *(_QWORD *)(v34 + 0x10) = 0;
      }
      else
      {
        v27 = 0;
      }
      v51 = v27;
    }
    else
    {
      sub_1419EBCD0(v20[7], &v49);
      v22 = v49;
      if ( v49 )
      {
        v23 = (__int64 ***)(a4 + 0x88);
        if ( a4 + 0x88 != a4 + 0xA0 )
        {
          while ( 1 )
          {
            v24 = *v23;
            if ( *v23 )
            {
              v25 = *v24;
              v26 = (__int64 *)(*v24)[1];
              while ( !*((_BYTE *)v26 + 0x19) )
              {
                if ( *((_DWORD *)v26 + 8) >= *v49 )
                {
                  v25 = v26;
                  v26 = (__int64 *)*v26;
                }
                else
                {
                  v26 = (__int64 *)v26[2];
                }
              }
              if ( !*((_BYTE *)v25 + 0x19) && *v49 >= *((_DWORD *)v25 + 8) && v25 != *v24 )
                break;
            }
            if ( ++v23 == (__int64 ***)(a4 + 0xA0) )
              goto LABEL_62;
          }
          v28 = v25[8];
          if ( v28 )
          {
            _InterlockedIncrement((volatile signed __int32 *)(v28 + 8));
            v22 = v49;
          }
          v29 = (volatile signed __int32 *)v25[8];
          v30 = a4 + 0x88;
          v31 = v25[7];
          if ( v29 )
          {
            _InterlockedIncrement(v29 + 2);
            v52 = v31;
            v53 = v29;
            sub_141B71AA0(v49, a2, &v52, v30);
            if ( _InterlockedExchangeAdd(v29 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v29)(v29);
              if ( _InterlockedExchangeAdd(v29 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v29 + 8LL))(v29);
            }
          }
          else
          {
            v52 = v25[7];
            v53 = 0;
            sub_141B71AA0(v22, a2, &v52, v30);
          }
          if ( v51 )
          {
            if ( _InterlockedExchangeAdd(v51 + 2, 0xFFFFFFFF) == 1 )
            {
              v32 = v51;
              (**(void (__fastcall ***)(volatile signed __int32 *))v51)(v51);
              if ( _InterlockedExchangeAdd(v32 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v51 + 8LL))(v51);
            }
          }
          if ( v50 )
          {
            if ( _InterlockedExchangeAdd(v50 + 2, 0xFFFFFFFF) == 1 )
            {
              v33 = v50;
              (**(void (__fastcall ***)(volatile signed __int32 *))v50)(v50);
              if ( _InterlockedExchangeAdd(v33 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v50 + 8LL))(v50);
            }
          }
          goto LABEL_30;
        }
      }
LABEL_62:
      v27 = v51;
    }
    if ( v27 )
    {
      if ( _InterlockedExchangeAdd(v27 + 2, 0xFFFFFFFF) == 1 )
      {
        v35 = v51;
        (**(void (__fastcall ***)(volatile signed __int32 *))v51)(v51);
        if ( _InterlockedExchangeAdd(v35 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v51 + 8LL))(v51);
      }
    }
    if ( v50 )
    {
      if ( _InterlockedExchangeAdd(v50 + 2, 0xFFFFFFFF) == 1 )
      {
        v36 = v50;
        (**(void (__fastcall ***)(volatile signed __int32 *))v50)(v50);
        if ( _InterlockedExchangeAdd(v36 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v50 + 8LL))(v50);
      }
    }
    if ( v48 )
    {
      if ( _InterlockedExchangeAdd(v48 + 2, 0xFFFFFFFF) == 1 )
      {
        v37 = v48;
        (**(void (__fastcall ***)(volatile signed __int32 *))v48)(v48);
        if ( _InterlockedExchangeAdd(v37 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v48 + 8LL))(v48);
      }
    }
    if ( v47 )
    {
      if ( _InterlockedExchangeAdd(v47 + 2, 0xFFFFFFFF) == 1 )
      {
        v38 = v47;
        (**(void (__fastcall ***)(volatile signed __int32 *))v47)(v47);
        if ( _InterlockedExchangeAdd(v38 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v47 + 8LL))(v47);
      }
    }
    sub_14035AED0(a2, 0, 0);
    goto LABEL_99;
  }
  sub_1419EA6D0(v9[7], v42);
  if ( !v42[0] )
    goto LABEL_20;
  v11 = v43;
  *a2 = v42[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v11 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
    v11 = v43;
  }
  v12 = v45;
  a2[1] = v42[1];
  a2[2] = v11;
  a2[3] = 0;
  a2[4] = 0;
  if ( v12 )
  {
    _InterlockedIncrement(v12 + 2);
    v12 = v45;
    v11 = v43;
  }
  a2[3] = v44;
  a2[4] = v12;
  if ( v12 )
  {
    v13 = _InterlockedExchangeAdd(v12 + 2, 0xFFFFFFFF);
    goto LABEL_101;
  }
LABEL_105:
  if ( v11 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 0xFFFFFFFF) == 1 )
    {
      v40 = v43;
      (**(void (__fastcall ***)(__int64))v43)(v43);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v40 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v43 + 8LL))(v43);
    }
  }
  return a2;
}

// --- End Function: sub_1419FAC20 (0x1419FAC20) ---

// --- Function: sub_1419FCA10 (0x1419FCA10) ---
_QWORD *__fastcall sub_1419FCA10(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  __int64 *v8; // r10
  __int64 *v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // rcx
  volatile signed __int32 *v12; // rdx
  signed __int32 v13; // eax
  __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 *v16; // rax
  volatile signed __int32 *v17; // rbx
  volatile signed __int32 *v18; // rbx
  __int64 v19; // rax
  __int64 *v20; // rcx
  __int64 *v21; // rax
  _DWORD *v22; // r10
  __int64 ***v23; // rdx
  __int64 **v24; // r9
  __int64 *v25; // rcx
  __int64 *v26; // rax
  volatile signed __int32 *v27; // rcx
  __int64 v28; // rax
  volatile signed __int32 *v29; // rbx
  __int64 v30; // r9
  __int64 v31; // rax
  volatile signed __int32 *v32; // rbx
  volatile signed __int32 *v33; // rbx
  __int64 v34; // rax
  volatile signed __int32 *v35; // rbx
  volatile signed __int32 *v36; // rbx
  volatile signed __int32 *v37; // rbx
  volatile signed __int32 *v38; // rbx
  volatile signed __int32 *v39; // rbx
  __int64 v40; // rbx
  _QWORD v42[2]; // [rsp+20h] [rbp-49h] BYREF
  __int64 v43; // [rsp+30h] [rbp-39h]
  __int64 v44; // [rsp+38h] [rbp-31h]
  volatile signed __int32 *v45; // [rsp+40h] [rbp-29h]
  _DWORD *v46; // [rsp+48h] [rbp-21h] BYREF
  volatile signed __int32 *v47; // [rsp+58h] [rbp-11h]
  volatile signed __int32 *v48; // [rsp+68h] [rbp-1h]
  _DWORD *v49; // [rsp+70h] [rbp+7h] BYREF
  volatile signed __int32 *v50; // [rsp+80h] [rbp+17h]
  volatile signed __int32 *v51; // [rsp+90h] [rbp+27h]
  __int64 v52; // [rsp+98h] [rbp+2Fh] BYREF
  volatile signed __int32 *v53; // [rsp+A0h] [rbp+37h]

  v8 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
  v9 = v8;
  v10 = (__int64 *)v8[1];
  while ( !*((_BYTE *)v10 + 0x19) )
  {
    if ( *((_DWORD *)v10 + 8) >= *a3 )
    {
      v9 = v10;
      v10 = (__int64 *)*v10;
    }
    else
    {
      v10 = (__int64 *)v10[2];
    }
  }
  if ( *((_BYTE *)v9 + 0x19) || *a3 < *((_DWORD *)v9 + 8) || v9 == v8 )
  {
    v43 = 0;
    v14 = allocWithProfilerInfo_w(0x18u);
    if ( v14 )
    {
      *(_DWORD *)(v14 + 8) = 1;
      *(_DWORD *)(v14 + 0xC) = 1;
      *(_QWORD *)v14 = off_1481B6460;
      *(_QWORD *)(v14 + 0x10) = 0;
    }
    else
    {
      v14 = 0;
    }
    v45 = (volatile signed __int32 *)v14;
LABEL_20:
    v15 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
    v16 = (__int64 *)v15[1];
    while ( !*((_BYTE *)v16 + 0x19) )
    {
      if ( *((_DWORD *)v16 + 8) >= *a3 )
      {
        v15 = v16;
        v16 = (__int64 *)*v16;
      }
      else
      {
        v16 = (__int64 *)v16[2];
      }
    }
    if ( *((_BYTE *)v15 + 0x19) || *a3 < *((_DWORD *)v15 + 8) || v15 == *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)) )
    {
      v47 = 0;
      v19 = allocWithProfilerInfo_w(0x18u);
      if ( v19 )
      {
        *(_DWORD *)(v19 + 8) = 1;
        *(_DWORD *)(v19 + 0xC) = 1;
        *(_QWORD *)v19 = off_1481B6460;
        *(_QWORD *)(v19 + 0x10) = 0;
      }
      else
      {
        v19 = 0;
      }
      v48 = (volatile signed __int32 *)v19;
    }
    else
    {
      sub_14033B330(v15[7], &v46);
      if ( v46 )
      {
        sub_1419EFC90((__int64 **)(a4 + 0x88), a2, v46);
LABEL_30:
        if ( v48 )
        {
          if ( _InterlockedExchangeAdd(v48 + 2, 0xFFFFFFFF) == 1 )
          {
            v17 = v48;
            (**(void (__fastcall ***)(volatile signed __int32 *))v48)(v48);
            if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v48 + 8LL))(v48);
          }
        }
        if ( v47 )
        {
          if ( _InterlockedExchangeAdd(v47 + 2, 0xFFFFFFFF) == 1 )
          {
            v18 = v47;
            (**(void (__fastcall ***)(volatile signed __int32 *))v47)(v47);
            if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v47 + 8LL))(v47);
          }
        }
LABEL_99:
        if ( !v45 )
        {
LABEL_104:
          v11 = v43;
          goto LABEL_105;
        }
        v13 = _InterlockedExchangeAdd(v45 + 2, 0xFFFFFFFF);
LABEL_101:
        if ( v13 == 1 )
        {
          v39 = v45;
          (**(void (__fastcall ***)(volatile signed __int32 *))v45)(v45);
          if ( _InterlockedExchangeAdd(v39 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v45 + 8LL))(v45);
        }
        goto LABEL_104;
      }
    }
    v20 = *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL));
    v21 = (__int64 *)v20[1];
    while ( !*((_BYTE *)v21 + 0x19) )
    {
      if ( *((_DWORD *)v21 + 8) >= *a3 )
      {
        v20 = v21;
        v21 = (__int64 *)*v21;
      }
      else
      {
        v21 = (__int64 *)v21[2];
      }
    }
    if ( *((_BYTE *)v20 + 0x19) || *a3 < *((_DWORD *)v20 + 8) || v20 == *(__int64 **)(a1 + 0x10 * ((int)a3[6] + 0xALL)) )
    {
      v50 = 0;
      v34 = allocWithProfilerInfo_w(0x18u);
      v27 = (volatile signed __int32 *)v34;
      if ( v34 )
      {
        *(_DWORD *)(v34 + 8) = 1;
        *(_DWORD *)(v34 + 0xC) = 1;
        *(_QWORD *)v34 = off_1481B6460;
        *(_QWORD *)(v34 + 0x10) = 0;
      }
      else
      {
        v27 = 0;
      }
      v51 = v27;
    }
    else
    {
      sub_1419EC490(v20[7], &v49);
      v22 = v49;
      if ( v49 )
      {
        v23 = (__int64 ***)(a4 + 0x88);
        if ( a4 + 0x88 != a4 + 0xA0 )
        {
          while ( 1 )
          {
            v24 = *v23;
            if ( *v23 )
            {
              v25 = *v24;
              v26 = (__int64 *)(*v24)[1];
              while ( !*((_BYTE *)v26 + 0x19) )
              {
                if ( *((_DWORD *)v26 + 8) >= *v49 )
                {
                  v25 = v26;
                  v26 = (__int64 *)*v26;
                }
                else
                {
                  v26 = (__int64 *)v26[2];
                }
              }
              if ( !*((_BYTE *)v25 + 0x19) && *v49 >= *((_DWORD *)v25 + 8) && v25 != *v24 )
                break;
            }
            if ( ++v23 == (__int64 ***)(a4 + 0xA0) )
              goto LABEL_62;
          }
          v28 = v25[8];
          if ( v28 )
          {
            _InterlockedIncrement((volatile signed __int32 *)(v28 + 8));
            v22 = v49;
          }
          v29 = (volatile signed __int32 *)v25[8];
          v30 = a4 + 0x88;
          v31 = v25[7];
          if ( v29 )
          {
            _InterlockedIncrement(v29 + 2);
            v52 = v31;
            v53 = v29;
            sub_141B76140(v49, a2, &v52, v30);
            if ( _InterlockedExchangeAdd(v29 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v29)(v29);
              if ( _InterlockedExchangeAdd(v29 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v29 + 8LL))(v29);
            }
          }
          else
          {
            v52 = v25[7];
            v53 = 0;
            sub_141B76140(v22, a2, &v52, v30);
          }
          if ( v51 )
          {
            if ( _InterlockedExchangeAdd(v51 + 2, 0xFFFFFFFF) == 1 )
            {
              v32 = v51;
              (**(void (__fastcall ***)(volatile signed __int32 *))v51)(v51);
              if ( _InterlockedExchangeAdd(v32 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v51 + 8LL))(v51);
            }
          }
          if ( v50 )
          {
            if ( _InterlockedExchangeAdd(v50 + 2, 0xFFFFFFFF) == 1 )
            {
              v33 = v50;
              (**(void (__fastcall ***)(volatile signed __int32 *))v50)(v50);
              if ( _InterlockedExchangeAdd(v33 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v50 + 8LL))(v50);
            }
          }
          goto LABEL_30;
        }
      }
LABEL_62:
      v27 = v51;
    }
    if ( v27 )
    {
      if ( _InterlockedExchangeAdd(v27 + 2, 0xFFFFFFFF) == 1 )
      {
        v35 = v51;
        (**(void (__fastcall ***)(volatile signed __int32 *))v51)(v51);
        if ( _InterlockedExchangeAdd(v35 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v51 + 8LL))(v51);
      }
    }
    if ( v50 )
    {
      if ( _InterlockedExchangeAdd(v50 + 2, 0xFFFFFFFF) == 1 )
      {
        v36 = v50;
        (**(void (__fastcall ***)(volatile signed __int32 *))v50)(v50);
        if ( _InterlockedExchangeAdd(v36 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v50 + 8LL))(v50);
      }
    }
    if ( v48 )
    {
      if ( _InterlockedExchangeAdd(v48 + 2, 0xFFFFFFFF) == 1 )
      {
        v37 = v48;
        (**(void (__fastcall ***)(volatile signed __int32 *))v48)(v48);
        if ( _InterlockedExchangeAdd(v37 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v48 + 8LL))(v48);
      }
    }
    if ( v47 )
    {
      if ( _InterlockedExchangeAdd(v47 + 2, 0xFFFFFFFF) == 1 )
      {
        v38 = v47;
        (**(void (__fastcall ***)(volatile signed __int32 *))v47)(v47);
        if ( _InterlockedExchangeAdd(v38 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v47 + 8LL))(v47);
      }
    }
    sub_14035AED0(a2, 0, 0);
    goto LABEL_99;
  }
  sub_1419ECFF0(v9[7], v42);
  if ( !v42[0] )
    goto LABEL_20;
  v11 = v43;
  *a2 = v42[0];
  a2[1] = 0;
  a2[2] = 0;
  if ( v11 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
    v11 = v43;
  }
  v12 = v45;
  a2[1] = v42[1];
  a2[2] = v11;
  a2[3] = 0;
  a2[4] = 0;
  if ( v12 )
  {
    _InterlockedIncrement(v12 + 2);
    v12 = v45;
    v11 = v43;
  }
  a2[3] = v44;
  a2[4] = v12;
  if ( v12 )
  {
    v13 = _InterlockedExchangeAdd(v12 + 2, 0xFFFFFFFF);
    goto LABEL_101;
  }
LABEL_105:
  if ( v11 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 0xFFFFFFFF) == 1 )
    {
      v40 = v43;
      (**(void (__fastcall ***)(__int64))v43)(v43);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v40 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v43 + 8LL))(v43);
    }
  }
  return a2;
}

// --- End Function: sub_1419FCA10 (0x1419FCA10) ---

// --- Function: sub_141A38380 (0x141A38380) ---
_QWORD *__fastcall sub_141A38380(_QWORD *a1)
{
  char *v2; // rax
  __int64 v3; // rcx
  BOOL fPending; // [rsp+38h] [rbp+10h] BYREF
  char *v6; // [rsp+40h] [rbp+18h] BYREF
  const char *v7; // [rsp+48h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__123, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149D17AA8 & 1) == 0 )
    {
      dword_149D17AA8 |= 1u;
      xmmword_149D17A10 = 0;
    }
    n4_905 = 4;
    v6 = strchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<struct Subsumption::MannequinFragmentIDCrc>(void)",
           0x3C);
    v2 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<struct Subsumption::MannequinFragmentIDCrc>(void)",
           0x3E);
    if ( v6 != v2 )
      ++v6;
    v7 = (const char *)&unk_149D17A28;
    sub_1403E40C0(&v7, (const char *)&unk_149D17AA7, (const char **)&v6, v2);
    *v7 = 0;
    *((_QWORD *)&xmmword_149D17A10 + 1) = &unk_149D17AAC;
    *(_QWORD *)&xmmword_149D17A10 = &xmmword_149D17A10;
    qword_149D17A08 = (__int64)&xmmword_149D17A10;
    if ( !InitOnceComplete(&lpInitOnce__123, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v3 = qword_149D17A08;
  *a1 = *(_QWORD *)qword_149D17A08;
  a1[1] = *(_QWORD *)(v3 + 8);
  return a1;
}

// --- End Function: sub_141A38380 (0x141A38380) ---

// --- Function: sub_141A39550 (0x141A39550) ---
_QWORD *__fastcall sub_141A39550(_QWORD *a1)
{
  char *v2; // rax
  __int64 v3; // rcx
  BOOL fPending; // [rsp+38h] [rbp+10h] BYREF
  char *v6; // [rsp+40h] [rbp+18h] BYREF
  const char *v7; // [rsp+48h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__124, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149D18408 & 1) == 0 )
    {
      dword_149D18408 |= 1u;
      xmmword_149D18370 = 0;
    }
    n0x78_1 = 0x78;
    v6 = strchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<struct Subsumption::MannequinFrag"
           "mentIDCrc>>(void)",
           0x3C);
    v2 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<struct Subsumption::MannequinFrag"
           "mentIDCrc>>(void)",
           0x3E);
    if ( v6 != v2 )
      ++v6;
    v7 = (const char *)&unk_149D18388;
    sub_1403E40C0(&v7, (const char *)&unk_149D18407, (const char **)&v6, v2);
    *v7 = 0;
    *((_QWORD *)&xmmword_149D18370 + 1) = &unk_149D1840C;
    *(_QWORD *)&xmmword_149D18370 = &xmmword_149D18370;
    qword_149D18368 = (__int64)&xmmword_149D18370;
    if ( !InitOnceComplete(&lpInitOnce__124, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v3 = qword_149D18368;
  *a1 = *(_QWORD *)qword_149D18368;
  a1[1] = *(_QWORD *)(v3 + 8);
  return a1;
}

// --- End Function: sub_141A39550 (0x141A39550) ---

// --- Function: sub_141A39A10 (0x141A39A10) ---
_QWORD *__fastcall sub_141A39A10(_QWORD *a1)
{
  char *v2; // rax
  __int64 v3; // rcx
  BOOL fPending; // [rsp+38h] [rbp+10h] BYREF
  char *v6; // [rsp+40h] [rbp+18h] BYREF
  const char *v7; // [rsp+48h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__125, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149D18358 & 1) == 0 )
    {
      dword_149D18358 |= 1u;
      xmmword_149D182C0 = 0;
    }
    n0x78_2 = 0x78;
    v6 = strchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<class std::vector<struct SCRCRef<"
           "0,struct SCRCRefHash_CRC32Lowercase>,class std::allocator<struct SCRCRef<0,struct SCRCRefHash_CRC32Lowercase> > > >>(void)",
           0x3C);
    v2 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class Subsumption::SuperGUID<class std::vector<struct SCRCRef<"
           "0,struct SCRCRefHash_CRC32Lowercase>,class std::allocator<struct SCRCRef<0,struct SCRCRefHash_CRC32Lowercase> > > >>(void)",
           0x3E);
    if ( v6 != v2 )
      ++v6;
    v7 = (const char *)&unk_149D182D8;
    sub_1403E40C0(&v7, (const char *)&unk_149D18357, (const char **)&v6, v2);
    *v7 = 0;
    *((_QWORD *)&xmmword_149D182C0 + 1) = &unk_149D1835C;
    *(_QWORD *)&xmmword_149D182C0 = &xmmword_149D182C0;
    qword_149D182B8 = (__int64)&xmmword_149D182C0;
    if ( !InitOnceComplete(&lpInitOnce__125, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v3 = qword_149D182B8;
  *a1 = *(_QWORD *)qword_149D182B8;
  a1[1] = *(_QWORD *)(v3 + 8);
  return a1;
}

// --- End Function: sub_141A39A10 (0x141A39A10) ---

// --- Function: sub_141A3A260 (0x141A3A260) ---
_QWORD *__fastcall sub_141A3A260(_QWORD *a1)
{
  char *v2; // rax
  __int64 v3; // rcx
  BOOL fPending; // [rsp+38h] [rbp+10h] BYREF
  char *v6; // [rsp+40h] [rbp+18h] BYREF
  const char *v7; // [rsp+48h] [rbp+20h] BYREF

  if ( !InitOnceBeginInitialize(&lpInitOnce__126, 0, &fPending, 0) )
    abort();
  if ( fPending )
  {
    if ( (dword_149D179E8 & 1) == 0 )
    {
      dword_149D179E8 |= 1u;
      xmmword_149D17950 = 0;
    }
    n0x18_26 = 0x18;
    v6 = strchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class std::vector<struct SCRCRef<0,struct SCRCRefHash_CRC32Low"
           "ercase>,class std::allocator<struct SCRCRef<0,struct SCRCRefHash_CRC32Lowercase> > >>(void)",
           0x3C);
    v2 = strrchr(
           "class yasli::TypeID __cdecl yasli::TypeID::get<class std::vector<struct SCRCRef<0,struct SCRCRefHash_CRC32Low"
           "ercase>,class std::allocator<struct SCRCRef<0,struct SCRCRefHash_CRC32Lowercase> > >>(void)",
           0x3E);
    if ( v6 != v2 )
      ++v6;
    v7 = (const char *)&unk_149D17968;
    sub_1403E40C0(&v7, (const char *)&unk_149D179E7, (const char **)&v6, v2);
    *v7 = 0;
    *((_QWORD *)&xmmword_149D17950 + 1) = &unk_149D179EC;
    *(_QWORD *)&xmmword_149D17950 = &xmmword_149D17950;
    qword_149D17948 = (__int64)&xmmword_149D17950;
    if ( !InitOnceComplete(&lpInitOnce__126, 0, 0) )
      _std_init_once_link_alternate_names_and_abort();
  }
  v3 = qword_149D17948;
  *a1 = *(_QWORD *)qword_149D17948;
  a1[1] = *(_QWORD *)(v3 + 8);
  return a1;
}

// --- End Function: sub_141A3A260 (0x141A3A260) ---

// --- Function: sub_141B0C6E0 (0x141B0C6E0) ---
__int64 __fastcall sub_141B0C6E0(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 *v5; // r8
  __int64 *v6; // rcx
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rbx
  volatile signed __int32 *v11; // rbx
  __int64 v12; // [rsp+20h] [rbp-38h] BYREF
  volatile signed __int32 *v13; // [rsp+30h] [rbp-28h]
  __int64 v14; // [rsp+40h] [rbp-18h]

  if ( (unsigned int)sub_14053C290(a1, a2, a3) != 1 )
    return 0;
  v5 = *(__int64 **)(a1 + 0x10 * (*(int *)(a1 + 0x130) + 0xALL));
  v6 = v5;
  v7 = (__int64 *)v5[1];
  while ( !*((_BYTE *)v7 + 0x19) )
  {
    if ( *((_DWORD *)v7 + 8) >= *(_DWORD *)(a1 + 0x118) )
    {
      v6 = v7;
      v7 = (__int64 *)*v7;
    }
    else
    {
      v7 = (__int64 *)v7[2];
    }
  }
  if ( *((_BYTE *)v6 + 0x19) || *(_DWORD *)(a1 + 0x118) < *((_DWORD *)v6 + 8) || v6 == v5 )
  {
    v13 = 0;
    v9 = allocWithProfilerInfo_w(0x18u);
    v8 = v9;
    if ( v9 )
    {
      *(_DWORD *)(v9 + 8) = 1;
      *(_DWORD *)(v9 + 0xC) = 1;
      *(_QWORD *)v9 = off_1481B6460;
      *(_QWORD *)(v9 + 0x10) = 0;
    }
    else
    {
      v8 = 0;
    }
    v14 = v8;
  }
  else
  {
    sub_141358190(v6[7], &v12);
    if ( v12 )
      sub_141B4E260(a1 + 0x108);
    v8 = v14;
  }
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    {
      v10 = v14;
      (**(void (__fastcall ***)(__int64))v14)(v14);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v10 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 8LL))(v14);
    }
  }
  if ( v13 && _InterlockedExchangeAdd(v13 + 2, 0xFFFFFFFF) == 1 )
  {
    v11 = v13;
    (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
    if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8LL))(v13);
  }
  return 1;
}

// --- End Function: sub_141B0C6E0 (0x141B0C6E0) ---

// --- Function: sub_141B0C9A0 (0x141B0C9A0) ---
__int64 __fastcall sub_141B0C9A0(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax
  int v6; // eax
  unsigned __int64 n0x20; // rdx

  if ( (unsigned int)sub_14053C290((__int64)a1, a2, a3) != 1 )
    return 0;
  if ( (unsigned __int64)((a1[0xF] - a1[0xE]) / 0x18LL) > 0x20 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    sub_1405C0E00(
      4u,
      0,
      "Subsumption task Parallel at line %d has more than %d supported parallel tasks attached. Only %d tasks will be executed.",
      v6,
      0x20,
      0x20);
  }
  n0x20 = (a1[0xF] - a1[0xE]) / 0x18LL;
  result = 1;
  if ( n0x20 > 0x20 )
    n0x20 = 0x20;
  a1[0x2B] = n0x20;
  return result;
}

// --- End Function: sub_141B0C9A0 (0x141B0C9A0) ---

// --- Function: sub_141B0CA70 (0x141B0CA70) ---
__int64 __fastcall sub_141B0CA70(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax
  int v6; // eax
  unsigned __int64 n0x20; // rdx

  if ( (unsigned int)sub_14053C290((__int64)a1, a2, a3) != 1 )
    return 0;
  if ( (unsigned __int64)((a1[0xF] - a1[0xE]) / 0x18LL) > 0x20 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    sub_1405C0E00(
      4u,
      0,
      "Subsumption task 'SelectChildByIndex' at line %d has more than %d supported child tasks attached. Only %d tasks wi"
      "ll be considered.",
      v6,
      0x20,
      0x20);
  }
  n0x20 = (a1[0xF] - a1[0xE]) / 0x18LL;
  result = 1;
  if ( n0x20 > 0x20 )
    n0x20 = 0x20;
  a1[0x21] = n0x20;
  return result;
}

// --- End Function: sub_141B0CA70 (0x141B0CA70) ---

// --- Function: sub_141B0CB40 (0x141B0CB40) ---
__int64 __fastcall sub_141B0CB40(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v6; // rdx
  int v7; // r15d
  int v8; // r12d
  char *v9; // rax
  __int64 *v10; // rax
  _OWORD *v11; // r8
  __int64 v12; // r9
  __int64 v13; // rsi
  __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  char *v16; // rax
  __int128 v17; // xmm6
  __int64 v18; // rcx
  const void **v19; // rax
  const void **v20; // rbx
  unsigned __int64 v21; // rdx
  const void *v22; // rcx
  __int64 v23; // rdi
  __int64 v24; // rbx
  const void *v25; // rcx
  char *v26; // rax
  char *v27; // r8
  __int64 v28; // rdi
  __int64 v29; // rbx
  const void *v30; // rcx
  char *v31; // rax
  const char *v32; // rdi
  const char *v33; // rbx
  const char *v34; // rax
  __int64 v35; // rax
  volatile signed __int32 *v36; // rcx
  __int64 v37; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v38; // [rsp+38h] [rbp-C8h] BYREF
  __int128 v39; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v40; // [rsp+50h] [rbp-B0h]
  const void *v41; // [rsp+58h] [rbp-A8h]
  const void *v42; // [rsp+60h] [rbp-A0h]
  void *v43; // [rsp+68h] [rbp-98h] BYREF
  const void *v44; // [rsp+70h] [rbp-90h]
  char v45; // [rsp+78h] [rbp-88h]
  __int64 v46; // [rsp+80h] [rbp-80h]
  _QWORD *v47; // [rsp+88h] [rbp-78h]
  __int128 v48; // [rsp+90h] [rbp-70h]
  _OWORD v49[2]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v50; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v51; // [rsp+D0h] [rbp-30h] BYREF
  __int128 v52; // [rsp+E0h] [rbp-20h] BYREF
  __int128 v53; // [rsp+F0h] [rbp-10h]

  v46 = a3;
  v47 = a2;
  if ( (unsigned int)sub_14053C290((__int64)a1, a2, a3) != 1 )
    return 0;
  v6 = (__int64)((unsigned __int128)((__int64)(a1[0xF] - a1[0xE]) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 2;
  v49[1] = 0;
  v52 = 0;
  v53 = 0;
  sub_141A31080(a1 + 0x21, (v6 >> 0x3F) + v6, &v52);
  if ( *((_QWORD *)&v53 + 1)
    && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v53 + 1) + 0xCLL), 0xFFFFFFFF) == 1 )
  {
    (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v53 + 1) + 8LL))(*((_QWORD *)&v53 + 1));
  }
  (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*a2 + 0x188LL))(*a2, &v38);
  v7 = 0;
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 0x158LL))(v38);
  if ( v8 > 0 )
  {
    do
    {
      (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v38 + 0x160LL))(v38, &v37, (unsigned int)v7);
      v9 = (char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v37 + 0x110LL))(v37, "ID");
      v10 = sub_1402BC380(&v50, v9);
      v11 = (_OWORD *)a1[0xE];
      v12 = 0;
      v13 = 0;
      v14 = a1[0xF] - (_QWORD)v11;
      v48 = *(_OWORD *)v10;
      v15 = v14 / 0x18;
      if ( v14 / 0x18 )
      {
        while ( *v11 != v48 )
        {
          v12 = (unsigned int)(v12 + 1);
          ++v13;
          v11 = (_OWORD *)((char *)v11 + 0x18);
          if ( (int)v12 >= v15 )
            goto LABEL_54;
        }
        v16 = (char *)(*(__int64 (__fastcall **)(__int64, const char *, _OWORD *, __int64))(*(_QWORD *)v37 + 0x110LL))(
                        v37,
                        "FunctionArchetype",
                        v11,
                        v12);
        if ( !v16 || !*v16 )
          goto LABEL_50;
        v17 = *(_OWORD *)sub_1402BC380(&v51, v16);
        v18 = *(_QWORD *)(qword_149D07130 + 0xC8) + 0xE0LL;
        v49[0] = v17;
        v19 = (const void **)(*(__int64 (__fastcall **)(__int64, _OWORD *, __int64))(*(_QWORD *)v18 + 0x30LL))(
                               v18,
                               v49,
                               1);
        v40 = 0;
        v20 = v19;
        v39 = 0;
        v21 = ((_BYTE *)v19[1] - (_BYTE *)*v19) / 0x58;
        if ( v21 )
        {
          if ( v21 > 0x2E8BA2E8BA2E8BALL )
            unknown_libname_10();
          sub_1403DE790(&v39);
          *((_QWORD *)&v39 + 1) = sub_14034ECE0(*v20, v20[1], v39, &v39);
        }
        v22 = v20[3];
        v41 = v22;
        if ( v22 )
          (*(void (__fastcall **)(const void *))(*(_QWORD *)v22 + 0x20LL))(v22);
        v42 = v20[4];
        sub_14035B160(&v43, v20 + 5);
        v44 = v20[6];
        v45 = *((_BYTE *)v20 + 0x38);
        if ( ((unsigned __int8)v44 & 1) == 0 )
        {
          sub_140370D10(&v43);
          if ( v41 )
            (*(void (__fastcall **)(const void *))(*(_QWORD *)v41 + 0x28LL))(v41);
          v27 = (char *)v39;
          if ( (_QWORD)v39 )
          {
            v28 = *((_QWORD *)&v39 + 1);
            if ( (_QWORD)v39 != *((_QWORD *)&v39 + 1) )
            {
              v29 = v39 + 0x30;
              do
              {
                if ( *(_BYTE *)(v29 + 0x20) && *(_QWORD *)v29 )
                  sub_1402A3D30(*(const void **)v29);
                sub_1403729F0((_DWORD *)(v29 - 8));
                v30 = *(const void **)(v29 - 0x28);
                if ( v30 )
                  sub_147605980(v30);
                v29 += 0x58;
              }
              while ( v29 - 0x30 != v28 );
              v27 = (char *)v39;
            }
            v31 = v27;
            if ( (unsigned __int64)(0x58 * ((v40 - (__int64)v27) / 0x58)) >= 0x1000 )
            {
              v27 = (char *)*((_QWORD *)v27 + 0xFFFFFFFF);
              if ( (unsigned __int64)(v31 - v27 - 8) > 0x1F )
LABEL_61:
                invalid_parameter_noinfo_noreturn();
            }
            sub_1402A3D30(v27);
          }
LABEL_50:
          v32 = *(const char **)(v46 + 0x18);
          v33 = (const char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v37 + 0x110LL))(v37, "Name");
          v34 = (const char *)(*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)*v47 + 0x110LL))(
                                *v47,
                                "Name");
          sub_1405C0E00(
            4u,
            0,
            "Subsumption task 'SelectFunction' [%s] has a parallel task [%s] that is not ExecuteFunction. File: %s",
            v34,
            v33,
            v32);
          v11 = (_OWORD *)a1[0xF];
          v35 = a1[0xE];
          *(_OWORD *)(v35 + 0x18 * v13) = *(_OWORD *)((char *)v11 + 0xFFFFFFE8);
          v15 = v35 + 0x18 * v13;
          *(_QWORD *)(v15 + 0x10) = *((_QWORD *)v11 + 0xFFFFFFFF);
          a1[0xF] -= 0x18LL;
          *(_OWORD *)(0x20 * v13 + a1[0x21]) = *(_OWORD *)(a1[0x22] - 0x20LL);
          v36 = *(volatile signed __int32 **)(a1[0x22] - 8LL);
          if ( v36 && _InterlockedExchangeAdd(v36 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
          a1[0x22] -= 0x20LL;
          goto LABEL_54;
        }
        *(_OWORD *)(0x20 * v13 + a1[0x21]) = v17;
        sub_140370D10(&v43);
        if ( v41 )
          (*(void (__fastcall **)(const void *))(*(_QWORD *)v41 + 0x28LL))(v41);
        v11 = (_OWORD *)v39;
        if ( (_QWORD)v39 )
        {
          v23 = *((_QWORD *)&v39 + 1);
          if ( (_QWORD)v39 != *((_QWORD *)&v39 + 1) )
          {
            v24 = v39 + 0x30;
            do
            {
              if ( *(_BYTE *)(v24 + 0x20) && *(_QWORD *)v24 )
                sub_1402A3D30(*(const void **)v24);
              sub_1403729F0((_DWORD *)(v24 - 8));
              v25 = *(const void **)(v24 - 0x28);
              if ( v25 )
                sub_147605980(v25);
              v24 += 0x58;
            }
            while ( v24 - 0x30 != v23 );
            v11 = (_OWORD *)v39;
          }
          v26 = (char *)v11;
          if ( (unsigned __int64)(0x58 * ((v40 - (__int64)v11) / 0x58)) >= 0x1000 )
          {
            v11 = (_OWORD *)*((_QWORD *)v11 + 0xFFFFFFFF);
            if ( (unsigned __int64)(v26 - (char *)v11 - 8) > 0x1F )
              goto LABEL_61;
          }
          sub_1402A3D30(v11);
        }
      }
LABEL_54:
      if ( v37 )
        (*(void (__fastcall **)(__int64, unsigned __int64, _OWORD *, __int64))(*(_QWORD *)v37 + 0x28LL))(
          v37,
          v15,
          v11,
          v12);
      ++v7;
    }
    while ( v7 < v8 );
  }
  if ( v38 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v38 + 0x28LL))(v38);
  return 1;
}

// --- End Function: sub_141B0CB40 (0x141B0CB40) ---

// --- Function: sub_141B0D120 (0x141B0D120) ---
__int64 __fastcall sub_141B0D120(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax
  int v6; // eax
  unsigned __int64 n0x20; // rdx

  if ( (unsigned int)sub_14053C290((__int64)a1, a2, a3) != 1 )
    return 0;
  if ( (unsigned __int64)((a1[0xF] - a1[0xE]) / 0x18LL) > 0x20 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    sub_1405C0E00(
      4u,
      0,
      "Subsumption task 'SelectRandomChild' at line %d has more than %d supported child tasks attached. Only %d tasks wil"
      "l be considered.",
      v6,
      0x20,
      0x20);
  }
  n0x20 = (a1[0xF] - a1[0xE]) / 0x18LL;
  result = 1;
  if ( n0x20 > 0x20 )
    n0x20 = 0x20;
  a1[0x21] = n0x20;
  return result;
}

// --- End Function: sub_141B0D120 (0x141B0D120) ---

// --- Function: sub_141B0D1F0 (0x141B0D1F0) ---
__int64 __fastcall sub_141B0D1F0(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax
  int v6; // eax
  unsigned __int64 n0x20; // rdx

  if ( (unsigned int)sub_14053C290((__int64)a1, a2, a3) != 1 )
    return 0;
  if ( (unsigned __int64)((a1[0xF] - a1[0xE]) / 0x18LL) > 0x20 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    sub_1405C0E00(
      4u,
      0,
      "Subsumption task 'Selector' at line %d has more than %d supported parallel tasks attached. Only %d tasks will be executed.",
      v6,
      0x20,
      0x20);
  }
  n0x20 = (a1[0xF] - a1[0xE]) / 0x18LL;
  result = 1;
  if ( n0x20 > 0x20 )
    n0x20 = 0x20;
  a1[0x21] = n0x20;
  return result;
}

// --- End Function: sub_141B0D1F0 (0x141B0D1F0) ---

// --- Function: sub_141B0D2C0 (0x141B0D2C0) ---
__int64 __fastcall sub_141B0D2C0(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 result; // rax
  int v6; // eax
  unsigned __int64 n0x20; // rdx

  if ( (unsigned int)sub_14053C290((__int64)a1, a2, a3) != 1 )
    return 0;
  if ( (unsigned __int64)((a1[0xF] - a1[0xE]) / 0x18LL) > 0x20 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x1B0LL))(*a2);
    sub_1405C0E00(
      4u,
      0,
      "Subsumption task 'Sequence' at line %d has more than %d supported parallel tasks attached. Only %d tasks will be executed.",
      v6,
      0x20,
      0x20);
  }
  n0x20 = (a1[0xF] - a1[0xE]) / 0x18LL;
  result = 1;
  if ( n0x20 > 0x20 )
    n0x20 = 0x20;
  a1[0x21] = n0x20;
  return result;
}

// --- End Function: sub_141B0D2C0 (0x141B0D2C0) ---

// --- Function: sub_141B71AA0 (0x141B71AA0) ---
_QWORD *__fastcall sub_141B71AA0(__int64 a1, _QWORD *a2, void *a3, __int64 a4)
{
  _QWORD *v5; // rsi
  _QWORD *v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rcx
  void (__fastcall *v12)(__int64, __int64 *, _QWORD *, __int64); // r10
  __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // r14
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  int *v23; // rcx
  int *v24; // r9
  const char *v25; // rax
  unsigned int v26; // ecx
  unsigned int v27; // r8d
  int v28; // ebx
  int v29; // edi
  int v30; // esi
  int v31; // r14d
  int v32; // ecx
  int v33; // edx
  int v34; // eax
  int v35; // r9d
  int v36; // r8d
  size_t Size; // rbx
  size_t Size_1; // r8
  _DWORD *v39; // rdi
  __int64 v40; // rax
  volatile signed __int32 *v41; // rbx
  _BYTE *v42; // rcx
  _DWORD *v43; // r13
  __int64 v44; // rax
  _DWORD *v45; // rsi
  __int64 v46; // rax
  __int64 v47; // rbx
  __int64 (__fastcall *v48)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v50; // rbx
  __int64 v51; // rdi
  __int64 v52; // rax
  __int16 n4; // cx
  void (__fastcall *v54)(__int64, __int64 *, _DWORD *, _QWORD *); // rbx
  _QWORD *v55; // rax
  __int64 v56; // rdx
  signed __int32 v57; // eax
  signed __int32 v58; // ett
  __int64 v59; // r12
  volatile signed __int32 *v60; // rsi
  __int64 v61; // rax
  __int64 v62; // rbx
  __int64 (__fastcall *v63)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF_2; // ax
  __int64 v65; // rbx
  __int64 v66; // rax
  __int16 n4_1; // cx
  __int64 v68; // rax
  __int64 *v69; // r8
  __int64 *v70; // rcx
  __int64 *v71; // rax
  volatile signed __int32 *v72; // rcx
  __int64 v73; // rax
  volatile signed __int32 *v74; // rbx
  volatile signed __int32 *v75; // rbx
  _DWORD *v76; // r14
  __int64 v77; // rax
  volatile signed __int32 *v78; // rdi
  unsigned __int8 (__fastcall *v79)(__int64, _DWORD *, _QWORD *); // rbx
  _QWORD *v80; // rax
  __int64 v81; // rdx
  __int64 v82; // rcx
  __int64 *v83; // rcx
  __int64 v84; // rax
  __int64 v85; // rcx
  volatile signed __int32 *v86; // rbx
  _QWORD *v87; // r14
  volatile signed __int32 *v88; // rcx
  volatile signed __int32 *v89; // rdx
  volatile signed __int32 *v90; // rbx
  volatile signed __int32 *v91; // rbx
  __int64 v92; // rcx
  volatile signed __int32 *v93; // r14
  _QWORD *v95; // r12
  __int64 v96; // rcx
  volatile signed __int32 *v97; // rbx
  __int64 v98; // rax
  volatile signed __int32 *v99; // rbx
  int v100; // [rsp+40h] [rbp-D0h]
  int v101; // [rsp+48h] [rbp-C8h]
  int v102; // [rsp+78h] [rbp-98h]
  int v103; // [rsp+80h] [rbp-90h]
  int v104; // [rsp+88h] [rbp-88h]
  __int16 n0xFFFF_1; // [rsp+90h] [rbp-80h] BYREF
  __int16 n0xFFFF_3; // [rsp+92h] [rbp-7Eh] BYREF
  __int64 v107; // [rsp+98h] [rbp-78h] BYREF
  _DWORD *v108; // [rsp+A0h] [rbp-70h]
  __int64 v109; // [rsp+A8h] [rbp-68h]
  char *v110; // [rsp+B0h] [rbp-60h] BYREF
  _QWORD *v111; // [rsp+B8h] [rbp-58h]
  void *v112; // [rsp+C0h] [rbp-50h]
  __int128 v113; // [rsp+C8h] [rbp-48h] BYREF
  volatile signed __int32 *v114; // [rsp+D8h] [rbp-38h]
  __int64 v115; // [rsp+E0h] [rbp-30h]
  volatile signed __int32 *v116; // [rsp+E8h] [rbp-28h]
  char v117[2]; // [rsp+F0h] [rbp-20h] BYREF
  char v118[2]; // [rsp+F2h] [rbp-1Eh] BYREF
  unsigned int v119; // [rsp+F4h] [rbp-1Ch]
  int *v120; // [rsp+F8h] [rbp-18h]
  volatile signed __int32 *v121; // [rsp+100h] [rbp-10h]
  __int64 v122; // [rsp+108h] [rbp-8h] BYREF
  __int64 v123; // [rsp+110h] [rbp+0h]
  __int64 v124; // [rsp+118h] [rbp+8h] BYREF
  __int64 v125; // [rsp+120h] [rbp+10h] BYREF
  __int64 v126; // [rsp+128h] [rbp+18h]
  unsigned __int64 v127; // [rsp+130h] [rbp+20h]
  __int64 v128; // [rsp+140h] [rbp+30h]
  __int64 v129; // [rsp+148h] [rbp+38h]
  __int64 v130; // [rsp+150h] [rbp+40h]
  __int64 v131; // [rsp+158h] [rbp+48h]
  __int64 v132; // [rsp+160h] [rbp+50h]
  __int64 v133; // [rsp+168h] [rbp+58h]
  int n0x5A00; // [rsp+170h] [rbp+60h] BYREF
  __int64 v135; // [rsp+174h] [rbp+64h]
  int v136; // [rsp+17Ch] [rbp+6Ch]
  unsigned __int64 v137; // [rsp+180h] [rbp+70h]
  unsigned __int64 v138; // [rsp+188h] [rbp+78h]
  __int64 v139; // [rsp+190h] [rbp+80h]
  __int64 v140; // [rsp+198h] [rbp+88h]
  unsigned __int64 v141; // [rsp+1C0h] [rbp+B0h]
  int *v142; // [rsp+1C8h] [rbp+B8h]
  __int128 v143; // [rsp+1D0h] [rbp+C0h] BYREF
  _QWORD v144[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  char v145[8]; // [rsp+1F0h] [rbp+E0h] BYREF
  __int64 v146; // [rsp+1F8h] [rbp+E8h] BYREF
  char v147[8]; // [rsp+200h] [rbp+F0h] BYREF
  char v148[8]; // [rsp+208h] [rbp+F8h] BYREF
  char v149[16]; // [rsp+210h] [rbp+100h] BYREF
  char v150[8]; // [rsp+220h] [rbp+110h] BYREF
  _BYTE *v151; // [rsp+228h] [rbp+118h]
  __int128 v152; // [rsp+230h] [rbp+120h]
  __int64 v153[4]; // [rsp+240h] [rbp+130h] BYREF
  char v154[16]; // [rsp+260h] [rbp+150h] BYREF
  __int64 v155; // [rsp+270h] [rbp+160h] BYREF
  __int64 v156; // [rsp+280h] [rbp+170h] BYREF
  char v157[16]; // [rsp+290h] [rbp+180h] BYREF
  size_t Size_2; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 n0x24; // [rsp+2A8h] [rbp+198h]
  _BYTE *v160; // [rsp+2B0h] [rbp+1A0h]
  _BYTE v161[40]; // [rsp+2B8h] [rbp+1A8h] BYREF
  unsigned __int64 v162; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 n0x1FF; // [rsp+2E8h] [rbp+1D8h]
  const char *v164; // [rsp+2F0h] [rbp+1E0h]
  _BYTE v165[520]; // [rsp+2F8h] [rbp+1E8h] BYREF

  v112 = a3;
  v129 = 0;
  v130 = 0;
  v5 = a3;
  v131 = 0;
  v6 = a2;
  v132 = 0;
  v7 = a1;
  v133 = 0;
  v136 = 0;
  v138 = 0;
  v139 = 0;
  v140 = 0;
  v111 = a2;
  v126 = a1;
  v128 = 0;
  n0x5A00 = 0x5A00;
  v135 = 1;
  v137 = __rdtsc();
  qword_149B4B870(
    &n0x5A00,
    &word_149D16990,
    "Subsumption::SuperGUID<struct Subsumption::MannequinFragmentIDCrc>::ResolveSuperGuidInputValue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\SubsumptionSuperGUID.h",
    0xFF);
  HIWORD(n0x5A00) = word_149D16990;
  if ( !*(_QWORD *)(v7 + 0x70) )
    goto LABEL_171;
  v8 = (*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)*v5 + 8LL))(*v5, v154);
  v9 = *(_QWORD *)(v7 + 0x70);
  if ( !v9 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x141B728CBLL);
  }
  v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v9 + 0x10LL))(v9, v8);
  v11 = v10;
  if ( !v10 )
    goto LABEL_171;
  v12 = *(void (__fastcall **)(__int64, __int64 *, _QWORD *, __int64))(*(_QWORD *)v10 + 0x18LL);
  v13 = v5[1];
  if ( v13 )
    _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
  v144[0] = *v5;
  v144[1] = v5[1];
  v12(v11, &v107, v144, a4);
  v14 = *(_QWORD *)(v7 + 0x30);
  v109 = 0;
  v15 = *(unsigned int *)(v14 - 4);
  LODWORD(v15) = v15 & 0x7FFFFFFF;
  v141 = v15;
  v16 = v15 - 1;
  if ( !v15 )
    v16 = 0;
  v127 = v16;
  if ( !v15 )
  {
LABEL_170:
    v5 = v112;
LABEL_171:
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v98 = allocWithProfilerInfo_w(0x18u);
    if ( v98 )
    {
      *(_DWORD *)(v98 + 8) = 1;
      *(_DWORD *)(v98 + 0xC) = 1;
      *(_QWORD *)v98 = off_1481B6460;
      *(_QWORD *)(v98 + 0x10) = 0;
    }
    else
    {
      v98 = 0;
    }
    v6[3] = 0;
    v6[4] = v98;
    v138 = __rdtsc();
    qword_149B4B878(&n0x5A00);
    v99 = (volatile signed __int32 *)v5[1];
    if ( v99 && _InterlockedExchangeAdd(v99 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v99)(v99);
      if ( _InterlockedExchangeAdd(v99 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v99 + 8LL))(v99);
    }
    return v6;
  }
  v17 = 0;
  while ( 1 )
  {
    if ( (int)v17 >= (*(_DWORD *)(*(_QWORD *)(v7 + 0x30) - 4LL) & 0x7FFFFFFF) )
      __debugbreak();
    v18 = (__int64 *)(*(_QWORD *)(v7 + 0x30) + 0x10LL * (int)v17);
    v19 = v18[1];
    if ( v19 )
      _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
    v20 = *v18;
    v121 = (volatile signed __int32 *)v18[1];
    if ( *(_DWORD *)(v20 + 8) )
      break;
    if ( !v107 )
    {
      v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
      v107 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v21 + 0x1D8LL))(v21, v145);
    }
    sub_1403F6100((__int64)v150, v107, v20 + 0x10);
    v22 = *sub_14040B4F0((__int64)v150, &v146);
    if ( v22 )
    {
      if ( v17 == v16 )
      {
        v39 = (_DWORD *)allocWithProfilerInfo_w(4u);
        if ( v39 )
          *v39 = 0;
        else
          v39 = 0;
        v40 = allocWithProfilerInfo_w(0x18u);
        v41 = (volatile signed __int32 *)v40;
        if ( v40 )
        {
          *(_DWORD *)(v40 + 8) = 1;
          *(_DWORD *)(v40 + 0xC) = 1;
          *(_QWORD *)v40 = off_1483F7270;
          *(_QWORD *)(v40 + 0x10) = v39;
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v40 + 8), 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(__int64))v40)(v40);
            if ( _InterlockedExchangeAdd(v41 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 8LL))(v41);
          }
        }
      }
      else
      {
        v107 = v22;
      }
    }
    else
    {
      v23 = *(int **)(v20 + 0x18);
      v24 = *(int **)(v20 + 0x10);
      v165[0] = 0;
      v25 = v165;
      v164 = v165;
      v162 = 0;
      n0x1FF = 0x1FF;
      v142 = v23;
      v120 = v24;
      if ( v24 != v23 )
      {
        do
        {
          v26 = v24[2];
          v27 = *v24;
          v28 = *((unsigned __int8 *)v24 + 0xC);
          v29 = *((unsigned __int8 *)v24 + 0xD);
          v30 = *((unsigned __int8 *)v24 + 0xE);
          v31 = *((unsigned __int8 *)v24 + 0xF);
          v160 = v161;
          v104 = (unsigned __int8)v26;
          Size_2 = 0;
          v103 = BYTE1(v26);
          v102 = BYTE2(v26);
          v119 = HIBYTE(v26);
          v32 = *((unsigned __int8 *)v24 + 5);
          v101 = (unsigned __int8)v27;
          v100 = BYTE1(v27);
          LODWORD(v108) = HIBYTE(v27);
          v33 = BYTE2(v27);
          v34 = *((unsigned __int8 *)v24 + 4);
          v35 = *((unsigned __int8 *)v24 + 6);
          v36 = *((unsigned __int8 *)v120 + 7);
          v161[0] = 0;
          n0x24 = 0x24;
          sub_1402C61F0(
            (__int64)&Size_2,
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            v36,
            v35,
            v32,
            v34,
            (_DWORD)v108,
            v33,
            v100,
            v101,
            v31,
            v30,
            v29,
            v28,
            v119,
            v102,
            v103,
            v104);
          sub_1403E0AA0(&v110);
          Size = Size_2;
          if ( Size_2 )
          {
            sub_1403DE0C0(&v110, Size_2);
            sub_1403E1FA0(v110, v160, Size);
          }
          if ( v160 != v161 )
          {
            qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - n0x24;
            sub_147605980(v160);
          }
          if ( v110 )
          {
            Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++Size_1;
            while ( v110[Size_1] );
          }
          else
          {
            Size_1 = 0;
          }
          sub_1402DECA0(&v162, v110, Size_1);
          sub_1402DECA0(&v162, ", ", 2u);
          sub_140370D10(&v110);
          v24 = v120 + 4;
          v120 = v24;
        }
        while ( v24 != v142 );
        v25 = v164;
        v17 = v109;
      }
      sub_1405C0E00(
        4u,
        2u,
        "SuperGUID::ResolveSuperGuidInputValue failed to find entity in superguid query corresponding to the following super guid: %s",
        v25);
      if ( v164 != v165 )
      {
        qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
        sub_147605980(v164);
      }
    }
    sub_1402B2610(v153);
    v42 = v151;
    if ( v151 )
    {
      if ( ((*((_QWORD *)&v152 + 1) - (_QWORD)v151) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
      {
        v42 = (_BYTE *)*((_QWORD *)v151 + 0xFFFFFFFF);
        if ( (unsigned __int64)(v151 - v42 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v42);
      v152 = 0;
      v151 = 0;
    }
LABEL_120:
    v86 = v121;
    if ( v121 )
    {
      if ( _InterlockedExchangeAdd(v121 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v86)(v86);
        if ( _InterlockedExchangeAdd(v86 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v86 + 8LL))(v86);
      }
    }
    v109 = ++v17;
    if ( v17 >= v141 )
    {
      v6 = v111;
      goto LABEL_170;
    }
    v7 = v126;
    v16 = v127;
  }
  v43 = *(_DWORD **)(v20 + 0x10);
  v44 = (unsigned int)v43[0xFFFFFFFF];
  LODWORD(v44) = v44 & 0x7FFFFFFF;
  v45 = &v43[6 * v44];
  v108 = v45;
  if ( v43 == v45 )
    goto LABEL_120;
  while ( 1 )
  {
    if ( !v107 )
      goto LABEL_119;
    v46 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
    v47 = v46;
    if ( !v46 )
    {
      v125 = 0;
      goto LABEL_119;
    }
    v48 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v46 + 0x340LL);
    n0xFFFF = n0xFFFF_16;
    if ( n0xFFFF_16 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            v117,
                            "ISerializedComponent");
      n0xFFFF_16 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    v50 = *(_QWORD *)v48(v47, v147, &n0xFFFF_1);
    v125 = v50;
    if ( !v50 )
      goto LABEL_119;
    v51 = v50 & 0xFFFFFFFFFFFFLL;
    v52 = sub_1403B4B50(v50 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v52 + 4);
    if ( n4 == 4 || *(_WORD *)(v52 + 2) != (HIWORD(v50) & 0xFFF) )
      goto LABEL_119;
    if ( (n4 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v125) )
      goto LABEL_119;
    v54 = *(void (__fastcall **)(__int64, __int64 *, _DWORD *, _QWORD *))(*(_QWORD *)v51 + 0x5B0LL);
    v55 = sub_141A38380(&v155);
    v54(v51, &v122, v43, v55);
    v56 = v123;
    if ( !v123 )
      goto LABEL_119;
    v57 = *(_DWORD *)(v123 + 8);
    if ( !v57 )
      goto LABEL_115;
    while ( 1 )
    {
      v58 = v57;
      v57 = _InterlockedCompareExchange((volatile signed __int32 *)(v56 + 8), v57 + 1, v57);
      if ( v58 == v57 )
        break;
      if ( !v57 )
        goto LABEL_115;
    }
    v59 = v122;
    v60 = (volatile signed __int32 *)v123;
    if ( !v122 )
      goto LABEL_110;
    if ( v17 != v127 )
    {
      v81 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v122 + 0x10LL))(v122, v157);
      v82 = *(_QWORD *)(v126 + 0x70);
      if ( !v82 )
      {
        std::_Xbad_function_call();
        __debugbreak();
      }
      v83 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v82 + 0x10LL))(v82, v81);
      v143 = 0;
      v84 = *v83;
      if ( v60 )
        _InterlockedIncrement(v60 + 2);
      *(_QWORD *)&v143 = v59;
      *((_QWORD *)&v143 + 1) = v60;
      v107 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *, __int128 *))(v84 + 0x10))(v83, v149, &v143);
      goto LABEL_110;
    }
    v61 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv, v107);
    v62 = v61;
    if ( v61 )
      break;
    v124 = 0;
LABEL_94:
    v76 = (_DWORD *)allocWithProfilerInfo_w(4u);
    if ( v76 )
      *v76 = 0;
    else
      v76 = 0;
    v77 = allocWithProfilerInfo_w(0x18u);
    v78 = (volatile signed __int32 *)v77;
    if ( v77 )
    {
      *(_DWORD *)(v77 + 8) = 1;
      *(_DWORD *)(v77 + 0xC) = 1;
      *(_QWORD *)v77 = off_1483F7270;
      *(_QWORD *)(v77 + 0x10) = v76;
    }
    else
    {
      v78 = 0;
    }
    v79 = *(unsigned __int8 (__fastcall **)(__int64, _DWORD *, _QWORD *))(*(_QWORD *)v59 + 0x40LL);
    v80 = sub_141A38380(&v156);
    if ( v79(v59, v76, v80) )
    {
      v95 = v111;
      *v111 = v76;
      v95[1] = 0;
      v95[2] = 0;
      if ( v78 )
      {
        _InterlockedIncrement(v78 + 2);
        v95[1] = v76;
        v95[2] = v78;
        v95[3] = 0;
        v95[4] = 0;
        if ( _InterlockedExchangeAdd(v78 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v78)(v78);
          if ( _InterlockedExchangeAdd(v78 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v78 + 8LL))(v78);
        }
      }
      else
      {
        v95[1] = v76;
        v95[2] = 0;
        v95[3] = 0;
        v95[4] = 0;
      }
      if ( v60 )
      {
        if ( _InterlockedExchangeAdd(v60 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v60)(v60);
          if ( _InterlockedExchangeAdd(v60 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v60 + 8LL))(v60);
        }
      }
      v96 = v123;
      if ( v123 && _InterlockedExchangeAdd((volatile signed __int32 *)(v123 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v96 + 8LL))(v96);
      v97 = v121;
      if ( v121 )
      {
        if ( _InterlockedExchangeAdd(v121 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v97)(v97);
          if ( _InterlockedExchangeAdd(v97 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v97 + 8LL))(v97);
        }
      }
      v138 = __rdtsc();
      qword_149B4B878(&n0x5A00);
      std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v112);
      return v95;
    }
    if ( v78 )
    {
      if ( _InterlockedExchangeAdd(v78 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v78)(v78);
        if ( _InterlockedExchangeAdd(v78 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v78 + 8LL))(v78);
      }
    }
    v17 = v109;
LABEL_110:
    if ( v60 )
    {
      if ( _InterlockedExchangeAdd(v60 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v60)(v60);
        if ( _InterlockedExchangeAdd(v60 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v60 + 8LL))(v60);
      }
    }
    v45 = v108;
LABEL_115:
    v85 = v123;
    if ( v123 && _InterlockedExchangeAdd((volatile signed __int32 *)(v123 + 0xC), 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v85 + 8LL))(v85);
LABEL_119:
    v43 += 6;
    if ( v43 == v45 )
      goto LABEL_120;
  }
  v63 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v61 + 0x340LL);
  n0xFFFF_2 = n0xFFFF_24;
  if ( n0xFFFF_24 == (__int16)0xFFFF )
  {
    n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                            qword_149B4FC88,
                            v118,
                            "ISubsumptionComponent");
    n0xFFFF_24 = n0xFFFF_2;
  }
  n0xFFFF_3 = n0xFFFF_2;
  v65 = *(_QWORD *)v63(v62, v148, &n0xFFFF_3);
  v124 = v65;
  if ( !v65 )
    goto LABEL_94;
  v66 = sub_1403B4B50(v65 & 0xFFFFFFFFFFFFLL);
  n4_1 = *(_WORD *)(v66 + 4);
  if ( n4_1 == 4 || *(_WORD *)(v66 + 2) != (HIWORD(v65) & 0xFFF) )
    goto LABEL_94;
  if ( (n4_1 != 2 || *(_QWORD *)NtCurrentTeb_w()) && !sub_14031FE20(&v124) )
    goto LABEL_94;
  v68 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 0x590LL))(v65 & 0xFFFFFFFFFFFFLL);
  v69 = *(__int64 **)v68;
  v70 = *(__int64 **)v68;
  v71 = *(__int64 **)(*(_QWORD *)v68 + 8LL);
  while ( !*((_BYTE *)v71 + 0x19) )
  {
    if ( *((_DWORD *)v71 + 8) >= *v43 )
    {
      v70 = v71;
      v71 = (__int64 *)*v71;
    }
    else
    {
      v71 = (__int64 *)v71[2];
    }
  }
  if ( *((_BYTE *)v70 + 0x19) || *v43 < *((_DWORD *)v70 + 8) || v70 == v69 )
  {
    v113 = 0;
    v114 = 0;
    v73 = allocWithProfilerInfo_w(0x18u);
    v72 = (volatile signed __int32 *)v73;
    if ( v73 )
    {
      *(_DWORD *)(v73 + 8) = 1;
      *(_DWORD *)(v73 + 0xC) = 1;
      *(_QWORD *)v73 = off_1481B6460;
      *(_QWORD *)(v73 + 0x10) = 0;
    }
    else
    {
      v72 = 0;
    }
    v115 = 0;
    v116 = v72;
    goto LABEL_85;
  }
  sub_1419EA6D0(v70[7], &v113);
  if ( !(_QWORD)v113 )
  {
    v72 = v116;
LABEL_85:
    if ( v72 )
    {
      if ( _InterlockedExchangeAdd(v72 + 2, 0xFFFFFFFF) == 1 )
      {
        v74 = v116;
        (**(void (__fastcall ***)(volatile signed __int32 *))v116)(v116);
        if ( _InterlockedExchangeAdd(v74 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v116 + 8LL))(v116);
      }
    }
    if ( v114 )
    {
      if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
      {
        v75 = v114;
        (**(void (__fastcall ***)(volatile signed __int32 *))v114)(v114);
        if ( _InterlockedExchangeAdd(v75 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v114 + 8LL))(v114);
      }
    }
    goto LABEL_94;
  }
  v87 = v111;
  v88 = v114;
  *v111 = v113;
  v87[1] = 0;
  v87[2] = 0;
  if ( v88 )
  {
    _InterlockedIncrement(v88 + 2);
    v88 = v114;
  }
  v87[1] = *((_QWORD *)&v113 + 1);
  v87[2] = v88;
  v87[3] = 0;
  v87[4] = 0;
  v89 = v116;
  if ( v116 )
  {
    _InterlockedIncrement(v116 + 2);
    v89 = v116;
    v88 = v114;
  }
  v87[3] = v115;
  v87[4] = v89;
  if ( v89 )
  {
    if ( _InterlockedExchangeAdd(v89 + 2, 0xFFFFFFFF) == 1 )
    {
      v90 = v116;
      (**(void (__fastcall ***)(volatile signed __int32 *))v116)(v116);
      if ( _InterlockedExchangeAdd(v90 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v116 + 8LL))(v116);
    }
    v88 = v114;
  }
  if ( v88 )
  {
    if ( _InterlockedExchangeAdd(v88 + 2, 0xFFFFFFFF) == 1 )
    {
      v91 = v114;
      (**(void (__fastcall ***)(volatile signed __int32 *))v114)(v114);
      if ( _InterlockedExchangeAdd(v91 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v114 + 8LL))(v114);
    }
  }
  if ( v60 )
  {
    if ( _InterlockedExchangeAdd(v60 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v60)(v60);
      if ( _InterlockedExchangeAdd(v60 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v60 + 8LL))(v60);
    }
  }
  v92 = v123;
  if ( v123 && _InterlockedExchangeAdd((volatile signed __int32 *)(v123 + 0xC), 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v92 + 8LL))(v92);
  v93 = v121;
  if ( v121 )
  {
    if ( _InterlockedExchangeAdd(v121 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v93)(v93);
      if ( _InterlockedExchangeAdd(v93 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v93 + 8LL))(v93);
    }
  }
  v138 = __rdtsc();
  qword_149B4B878(&n0x5A00);
  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v112);
  return v111;
}

// --- End Function: sub_141B71AA0 (0x141B71AA0) ---

// --- Function: sub_141B76140 (0x141B76140) ---
_QWORD *__fastcall sub_141B76140(__int64 a1, _QWORD *a2, void *a3, __int64 a4)
{
  _QWORD *v5; // r14
  _QWORD *v6; // rdi
  __int64 v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rcx
  void (__fastcall *v12)(__int64, __int64 *, _QWORD *, __int64); // r10
  __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // r14
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r12
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  int *v23; // rcx
  int *v24; // r9
  const char *v25; // rax
  unsigned int v26; // ecx
  unsigned int v27; // r8d
  int v28; // ebx
  int v29; // edi
  int v30; // esi
  int v31; // r14d
  int v32; // r10d
  int v33; // r11d
  int v34; // edx
  int v35; // eax
  int v36; // r8d
  int v37; // ecx
  int v38; // r9d
  size_t Size; // rbx
  size_t Size_1; // r8
  _QWORD *v41; // rax
  _QWORD *v42; // rdi
  __int64 v43; // rax
  volatile signed __int32 *v44; // rbx
  _BYTE *v45; // rcx
  int *v46; // r13
  __int64 v47; // rax
  int *v48; // rsi
  __int64 v49; // rax
  __int64 v50; // rbx
  __int64 (__fastcall *v51)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF; // ax
  __int64 v53; // rbx
  __int64 v54; // rdi
  __int64 v55; // rax
  __int16 n4_1; // cx
  void (__fastcall *v57)(__int64, __int64 *, int *, _QWORD *); // rbx
  _QWORD *v58; // rax
  __int64 v59; // rdx
  signed __int32 v60; // eax
  signed __int32 v61; // ett
  __int64 v62; // r12
  volatile signed __int32 *v63; // r14
  __int64 v64; // rax
  __int64 v65; // rbx
  __int64 (__fastcall *v66)(__int64, char *, __int16 *); // rdi
  __int16 n0xFFFF_2; // ax
  __int64 v68; // rbx
  __int64 v69; // rax
  __int16 n4; // cx
  __int64 v71; // rax
  __int64 *v72; // r8
  __int64 *v73; // rcx
  __int64 *v74; // rax
  volatile signed __int32 *v75; // rcx
  __int64 v76; // rax
  volatile signed __int32 *v77; // rbx
  volatile signed __int32 *v78; // rbx
  _QWORD *v79; // rax
  _QWORD *v80; // rsi
  __int64 v81; // rax
  volatile signed __int32 *v82; // rdi
  unsigned __int8 (__fastcall *v83)(__int64, _QWORD *, _QWORD *); // rbx
  _QWORD *v84; // rax
  __int64 v85; // rdx
  __int64 v86; // rcx
  __int64 *v87; // rcx
  __int64 v88; // rax
  __int64 v89; // rcx
  volatile signed __int32 *v90; // rbx
  volatile signed __int32 *v91; // rcx
  volatile signed __int32 *v92; // rdx
  volatile signed __int32 *v93; // rbx
  volatile signed __int32 *v94; // rbx
  __int64 v95; // rcx
  volatile signed __int32 *v96; // rbx
  _QWORD *v97; // r12
  __int64 v98; // rcx
  volatile signed __int32 *v99; // rbx
  __int64 v101; // rax
  volatile signed __int32 *v102; // rbx
  int v103; // [rsp+78h] [rbp-98h]
  int v104; // [rsp+80h] [rbp-90h]
  int v105; // [rsp+88h] [rbp-88h]
  __int16 n0xFFFF_1; // [rsp+90h] [rbp-80h] BYREF
  __int16 n0xFFFF_3; // [rsp+92h] [rbp-7Eh] BYREF
  __int64 v108; // [rsp+98h] [rbp-78h] BYREF
  int *v109; // [rsp+A0h] [rbp-70h]
  char *v110; // [rsp+A8h] [rbp-68h] BYREF
  __int64 v111; // [rsp+B0h] [rbp-60h]
  void *v112; // [rsp+B8h] [rbp-58h]
  __int128 v113; // [rsp+C0h] [rbp-50h] BYREF
  volatile signed __int32 *v114; // [rsp+D0h] [rbp-40h]
  __int64 v115; // [rsp+D8h] [rbp-38h]
  volatile signed __int32 *v116; // [rsp+E0h] [rbp-30h]
  char v117[2]; // [rsp+E8h] [rbp-28h] BYREF
  char v118[2]; // [rsp+EAh] [rbp-26h] BYREF
  unsigned int v119; // [rsp+ECh] [rbp-24h]
  unsigned int v120; // [rsp+F0h] [rbp-20h]
  unsigned __int64 v121; // [rsp+F8h] [rbp-18h]
  volatile signed __int32 *v122; // [rsp+100h] [rbp-10h]
  _QWORD *v123; // [rsp+108h] [rbp-8h]
  __int64 v124; // [rsp+110h] [rbp+0h] BYREF
  __int64 v125; // [rsp+118h] [rbp+8h]
  __int64 v126; // [rsp+120h] [rbp+10h] BYREF
  __int64 v127; // [rsp+128h] [rbp+18h] BYREF
  __int64 v128; // [rsp+130h] [rbp+20h]
  __int64 v129; // [rsp+140h] [rbp+30h]
  __int64 v130; // [rsp+148h] [rbp+38h]
  __int64 v131; // [rsp+150h] [rbp+40h]
  __int64 v132; // [rsp+158h] [rbp+48h]
  __int64 v133; // [rsp+160h] [rbp+50h]
  __int64 v134; // [rsp+168h] [rbp+58h]
  int n0x5A00; // [rsp+170h] [rbp+60h] BYREF
  __int64 v136; // [rsp+174h] [rbp+64h]
  int v137; // [rsp+17Ch] [rbp+6Ch]
  unsigned __int64 v138; // [rsp+180h] [rbp+70h]
  unsigned __int64 v139; // [rsp+188h] [rbp+78h]
  __int64 v140; // [rsp+190h] [rbp+80h]
  __int64 v141; // [rsp+198h] [rbp+88h]
  unsigned __int64 v142; // [rsp+1C0h] [rbp+B0h]
  int *v143; // [rsp+1C8h] [rbp+B8h]
  __int128 v144; // [rsp+1D0h] [rbp+C0h] BYREF
  _QWORD v145[2]; // [rsp+1E0h] [rbp+D0h] BYREF
  char v146[8]; // [rsp+1F0h] [rbp+E0h] BYREF
  __int64 v147; // [rsp+1F8h] [rbp+E8h] BYREF
  char v148[8]; // [rsp+200h] [rbp+F0h] BYREF
  char v149[8]; // [rsp+208h] [rbp+F8h] BYREF
  char v150[16]; // [rsp+210h] [rbp+100h] BYREF
  char v151[8]; // [rsp+220h] [rbp+110h] BYREF
  _BYTE *v152; // [rsp+228h] [rbp+118h]
  __int128 v153; // [rsp+230h] [rbp+120h]
  __int64 v154[4]; // [rsp+240h] [rbp+130h] BYREF
  char v155[16]; // [rsp+260h] [rbp+150h] BYREF
  __int64 v156; // [rsp+270h] [rbp+160h] BYREF
  __int64 v157; // [rsp+280h] [rbp+170h] BYREF
  char v158[16]; // [rsp+290h] [rbp+180h] BYREF
  size_t Size_2; // [rsp+2A0h] [rbp+190h] BYREF
  __int64 n0x24; // [rsp+2A8h] [rbp+198h]
  _BYTE *v161; // [rsp+2B0h] [rbp+1A0h]
  _BYTE v162[40]; // [rsp+2B8h] [rbp+1A8h] BYREF
  unsigned __int64 v163; // [rsp+2E0h] [rbp+1D0h] BYREF
  __int64 n0x1FF; // [rsp+2E8h] [rbp+1D8h]
  const char *v165; // [rsp+2F0h] [rbp+1E0h]
  _BYTE v166[520]; // [rsp+2F8h] [rbp+1E8h] BYREF

  v112 = a3;
  v130 = 0;
  v131 = 0;
  v5 = a3;
  v132 = 0;
  v6 = a2;
  v133 = 0;
  v7 = a1;
  v134 = 0;
  v137 = 0;
  v139 = 0;
  v140 = 0;
  v141 = 0;
  v123 = a2;
  v128 = a1;
  v129 = 0;
  n0x5A00 = 0x5A00;
  v136 = 1;
  v138 = __rdtsc();
  qword_149B4B870(
    &n0x5A00,
    &word_149D169A8,
    "Subsumption::SuperGUID<class std::vector<struct SCRCRef<0,struct SCRCRefHash_CRC32Lowercase>,class std::allocator<st"
    "ruct SCRCRef<0,struct SCRCRefHash_CRC32Lowercase> > > >::ResolveSuperGuidInputValue",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Subsumption\\SubsumptionSuperGUID.h",
    0xFF);
  HIWORD(n0x5A00) = word_149D169A8;
  if ( *(_QWORD *)(v7 + 0x70) )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, char *))(*(_QWORD *)*v5 + 8LL))(*v5, v155);
    v9 = *(_QWORD *)(v7 + 0x70);
    if ( !v9 )
    {
      std::_Xbad_function_call();
      JUMPOUT(0x141B76F8CLL);
    }
    v10 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v9 + 0x10LL))(v9, v8);
    v11 = v10;
    if ( v10 )
    {
      v12 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v10 + 0x18LL);
      v13 = v5[1];
      if ( v13 )
        _InterlockedIncrement((volatile signed __int32 *)(v13 + 8));
      v145[0] = *v5;
      v145[1] = v5[1];
      v12(v11, &v108, v145, a4);
      v14 = *(_QWORD *)(v7 + 0x30);
      v15 = 0;
      v111 = 0;
      v16 = *(unsigned int *)(v14 - 4);
      LODWORD(v16) = v16 & 0x7FFFFFFF;
      v142 = v16;
      v17 = v16 - 1;
      if ( !v16 )
        v17 = 0;
      v121 = v17;
      if ( v16 )
      {
        while ( 1 )
        {
          if ( (int)v15 >= (*(_DWORD *)(*(_QWORD *)(v7 + 0x30) - 4LL) & 0x7FFFFFFF) )
            __debugbreak();
          v18 = (__int64 *)(*(_QWORD *)(v7 + 0x30) + 0x10LL * (int)v15);
          v19 = v18[1];
          if ( v19 )
            _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
          v20 = *v18;
          v122 = (volatile signed __int32 *)v18[1];
          if ( *(_DWORD *)(v20 + 8) )
          {
            v46 = *(int **)(v20 + 0x10);
            v47 = (unsigned int)v46[0xFFFFFFFF];
            LODWORD(v47) = v47 & 0x7FFFFFFF;
            v48 = &v46[6 * v47];
            v109 = v48;
            if ( v46 != v48 )
            {
              while ( 1 )
              {
                if ( v108 )
                {
                  v49 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0x118LL))(gEnv);
                  v50 = v49;
                  if ( v49 )
                  {
                    v51 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)v49 + 0x340LL);
                    n0xFFFF = n0xFFFF_16;
                    if ( n0xFFFF_16 == (__int16)0xFFFF )
                    {
                      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                                            qword_149B4FC88,
                                            v117,
                                            "ISerializedComponent");
                      n0xFFFF_16 = n0xFFFF;
                    }
                    n0xFFFF_1 = n0xFFFF;
                    v53 = *(_QWORD *)v51(v50, v148, &n0xFFFF_1);
                    v127 = v53;
                    if ( v53 )
                    {
                      v54 = v53 & 0xFFFFFFFFFFFFLL;
                      v55 = sub_1403B4B50(v53 & 0xFFFFFFFFFFFFLL);
                      n4_1 = *(_WORD *)(v55 + 4);
                      if ( n4_1 != 4
                        && *(_WORD *)(v55 + 2) == (HIWORD(v53) & 0xFFF)
                        && (n4_1 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v127)) )
                      {
                        v57 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v54 + 0x5B0LL);
                        v58 = sub_141A3A260(&v156);
                        v57(v54, &v124, v46, v58);
                        v59 = v125;
                        if ( v125 )
                        {
                          v60 = *(_DWORD *)(v125 + 8);
                          if ( v60 )
                          {
                            while ( 1 )
                            {
                              v61 = v60;
                              v60 = _InterlockedCompareExchange((volatile signed __int32 *)(v59 + 8), v60 + 1, v60);
                              if ( v61 == v60 )
                                break;
                              if ( !v60 )
                                goto LABEL_113;
                            }
                            v62 = v124;
                            v63 = (volatile signed __int32 *)v125;
                            if ( v124 )
                            {
                              if ( v111 == v121 )
                              {
                                v64 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)gEnv + 0x118LL))(
                                        gEnv,
                                        v108);
                                v65 = v64;
                                if ( v64 )
                                {
                                  v66 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)v64 + 0x340LL);
                                  n0xFFFF_2 = n0xFFFF_24;
                                  if ( n0xFFFF_24 == (__int16)0xFFFF )
                                  {
                                    n0xFFFF_2 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                                                            qword_149B4FC88,
                                                            v118,
                                                            "ISubsumptionComponent");
                                    n0xFFFF_24 = n0xFFFF_2;
                                  }
                                  n0xFFFF_3 = n0xFFFF_2;
                                  v68 = *(_QWORD *)v66(v65, v149, &n0xFFFF_3);
                                  v126 = v68;
                                  if ( v68 )
                                  {
                                    v69 = sub_1403B4B50(v68 & 0xFFFFFFFFFFFFLL);
                                    n4 = *(_WORD *)(v69 + 4);
                                    if ( n4 != 4
                                      && *(_WORD *)(v69 + 2) == (HIWORD(v68) & 0xFFF)
                                      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_14031FE20(&v126)) )
                                    {
                                      v71 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v68 & 0xFFFFFFFFFFFFLL)
                                                                               + 0x590LL))(v68 & 0xFFFFFFFFFFFFLL);
                                      v72 = *(__int64 **)v71;
                                      v73 = *(__int64 **)v71;
                                      v74 = *(__int64 **)(*(_QWORD *)v71 + 8LL);
                                      while ( !*((_BYTE *)v74 + 0x19) )
                                      {
                                        if ( *((_DWORD *)v74 + 8) >= (unsigned int)*v46 )
                                        {
                                          v73 = v74;
                                          v74 = (__int64 *)*v74;
                                        }
                                        else
                                        {
                                          v74 = (__int64 *)v74[2];
                                        }
                                      }
                                      if ( *((_BYTE *)v73 + 0x19)
                                        || (unsigned int)*v46 < *((_DWORD *)v73 + 8)
                                        || v73 == v72 )
                                      {
                                        v113 = 0;
                                        v114 = 0;
                                        v76 = allocWithProfilerInfo_w(0x18u);
                                        v75 = (volatile signed __int32 *)v76;
                                        if ( v76 )
                                        {
                                          *(_DWORD *)(v76 + 8) = 1;
                                          *(_DWORD *)(v76 + 0xC) = 1;
                                          *(_QWORD *)v76 = off_1481B6460;
                                          *(_QWORD *)(v76 + 0x10) = 0;
                                        }
                                        else
                                        {
                                          v75 = 0;
                                        }
                                        v115 = 0;
                                        v116 = v75;
                                      }
                                      else
                                      {
                                        sub_1419ECFF0(v73[7], &v113);
                                        if ( (_QWORD)v113 )
                                        {
                                          v6 = v123;
                                          v91 = v114;
                                          *v123 = v113;
                                          v6[1] = 0;
                                          v6[2] = 0;
                                          if ( v91 )
                                          {
                                            _InterlockedIncrement(v91 + 2);
                                            v91 = v114;
                                          }
                                          v6[1] = *((_QWORD *)&v113 + 1);
                                          v6[2] = v91;
                                          v6[3] = 0;
                                          v6[4] = 0;
                                          v92 = v116;
                                          if ( v116 )
                                          {
                                            _InterlockedIncrement(v116 + 2);
                                            v92 = v116;
                                            v91 = v114;
                                          }
                                          v6[3] = v115;
                                          v6[4] = v92;
                                          if ( v92 )
                                          {
                                            if ( _InterlockedExchangeAdd(v92 + 2, 0xFFFFFFFF) == 1 )
                                            {
                                              v93 = v116;
                                              (**(void (__fastcall ***)(volatile signed __int32 *))v116)(v116);
                                              if ( _InterlockedExchangeAdd(v93 + 3, 0xFFFFFFFF) == 1 )
                                                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v116 + 8LL))(v116);
                                            }
                                            v91 = v114;
                                          }
                                          if ( v91 )
                                          {
                                            if ( _InterlockedExchangeAdd(v91 + 2, 0xFFFFFFFF) == 1 )
                                            {
                                              v94 = v114;
                                              (**(void (__fastcall ***)(volatile signed __int32 *))v114)(v114);
                                              if ( _InterlockedExchangeAdd(v94 + 3, 0xFFFFFFFF) == 1 )
                                                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v114 + 8LL))(v114);
                                            }
                                          }
                                          if ( v63 )
                                          {
                                            if ( _InterlockedExchangeAdd(v63 + 2, 0xFFFFFFFF) == 1 )
                                            {
                                              (**(void (__fastcall ***)(volatile signed __int32 *))v63)(v63);
                                              if ( _InterlockedExchangeAdd(v63 + 3, 0xFFFFFFFF) == 1 )
                                                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v63 + 8LL))(v63);
                                            }
                                          }
                                          v95 = v125;
                                          if ( v125
                                            && _InterlockedExchangeAdd(
                                                 (volatile signed __int32 *)(v125 + 0xC),
                                                 0xFFFFFFFF) == 1 )
                                          {
                                            (*(void (__fastcall **)(__int64))(*(_QWORD *)v95 + 8LL))(v95);
                                          }
                                          v96 = v122;
                                          if ( v122 )
                                          {
                                            if ( _InterlockedExchangeAdd(v122 + 2, 0xFFFFFFFF) == 1 )
                                            {
                                              (**(void (__fastcall ***)(volatile signed __int32 *))v96)(v96);
                                              if ( _InterlockedExchangeAdd(v96 + 3, 0xFFFFFFFF) == 1 )
                                                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v96 + 8LL))(v96);
                                            }
                                          }
                                          v139 = __rdtsc();
                                          qword_149B4B878(&n0x5A00);
                                          std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v112);
                                          return v6;
                                        }
                                        v75 = v116;
                                      }
                                      if ( v75 )
                                      {
                                        if ( _InterlockedExchangeAdd(v75 + 2, 0xFFFFFFFF) == 1 )
                                        {
                                          v77 = v116;
                                          (**(void (__fastcall ***)(volatile signed __int32 *))v116)(v116);
                                          if ( _InterlockedExchangeAdd(v77 + 3, 0xFFFFFFFF) == 1 )
                                            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v116 + 8LL))(v116);
                                        }
                                      }
                                      if ( v114 )
                                      {
                                        if ( _InterlockedExchangeAdd(v114 + 2, 0xFFFFFFFF) == 1 )
                                        {
                                          v78 = v114;
                                          (**(void (__fastcall ***)(volatile signed __int32 *))v114)(v114);
                                          if ( _InterlockedExchangeAdd(v78 + 3, 0xFFFFFFFF) == 1 )
                                            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v114 + 8LL))(v114);
                                        }
                                      }
                                    }
                                  }
                                }
                                else
                                {
                                  v126 = 0;
                                }
                                v79 = (_QWORD *)allocWithProfilerInfo_w(0x18u);
                                v80 = v79;
                                if ( v79 )
                                {
                                  *v79 = 0;
                                  v79[1] = 0;
                                  v79[2] = 0;
                                }
                                else
                                {
                                  v80 = 0;
                                }
                                v81 = allocWithProfilerInfo_w(0x18u);
                                v82 = (volatile signed __int32 *)v81;
                                if ( v81 )
                                {
                                  *(_DWORD *)(v81 + 8) = 1;
                                  *(_DWORD *)(v81 + 0xC) = 1;
                                  *(_QWORD *)v81 = off_1484E4E80;
                                  *(_QWORD *)(v81 + 0x10) = v80;
                                }
                                else
                                {
                                  v82 = 0;
                                }
                                v83 = *(unsigned __int8 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)v62 + 0x40LL);
                                v84 = sub_141A3A260(&v157);
                                if ( v83(v62, v80, v84) )
                                {
                                  v97 = v123;
                                  *v123 = v80;
                                  v97[1] = 0;
                                  v97[2] = 0;
                                  if ( v82 )
                                  {
                                    _InterlockedIncrement(v82 + 2);
                                    v97[1] = v80;
                                    v97[2] = v82;
                                    v97[3] = 0;
                                    v97[4] = 0;
                                    if ( _InterlockedExchangeAdd(v82 + 2, 0xFFFFFFFF) == 1 )
                                    {
                                      (**(void (__fastcall ***)(volatile signed __int32 *))v82)(v82);
                                      if ( _InterlockedExchangeAdd(v82 + 3, 0xFFFFFFFF) == 1 )
                                        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v82 + 8LL))(v82);
                                    }
                                  }
                                  else
                                  {
                                    v97[1] = v80;
                                    v97[2] = 0;
                                    v97[3] = 0;
                                    v97[4] = 0;
                                  }
                                  if ( v63 )
                                  {
                                    if ( _InterlockedExchangeAdd(v63 + 2, 0xFFFFFFFF) == 1 )
                                    {
                                      (**(void (__fastcall ***)(volatile signed __int32 *))v63)(v63);
                                      if ( _InterlockedExchangeAdd(v63 + 3, 0xFFFFFFFF) == 1 )
                                        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v63 + 8LL))(v63);
                                    }
                                  }
                                  v98 = v125;
                                  if ( v125
                                    && _InterlockedExchangeAdd((volatile signed __int32 *)(v125 + 0xC), 0xFFFFFFFF) == 1 )
                                  {
                                    (*(void (__fastcall **)(__int64))(*(_QWORD *)v98 + 8LL))(v98);
                                  }
                                  v99 = v122;
                                  if ( v122 )
                                  {
                                    if ( _InterlockedExchangeAdd(v122 + 2, 0xFFFFFFFF) == 1 )
                                    {
                                      (**(void (__fastcall ***)(volatile signed __int32 *))v99)(v99);
                                      if ( _InterlockedExchangeAdd(v99 + 3, 0xFFFFFFFF) == 1 )
                                        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v99 + 8LL))(v99);
                                    }
                                  }
                                  v139 = __rdtsc();
                                  qword_149B4B878(&n0x5A00);
                                  std::shared_ptr<std::vector<char>>::~shared_ptr<std::vector<char>>((std::shared_ptr<std::vector<char> > *)v112);
                                  return v97;
                                }
                                if ( v82 )
                                {
                                  if ( _InterlockedExchangeAdd(v82 + 2, 0xFFFFFFFF) == 1 )
                                  {
                                    (**(void (__fastcall ***)(volatile signed __int32 *))v82)(v82);
                                    if ( _InterlockedExchangeAdd(v82 + 3, 0xFFFFFFFF) == 1 )
                                      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v82 + 8LL))(v82);
                                  }
                                }
                                v48 = v109;
                              }
                              else
                              {
                                v85 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v124 + 0x10LL))(
                                        v124,
                                        v158);
                                v86 = *(_QWORD *)(v128 + 0x70);
                                if ( !v86 )
                                {
                                  std::_Xbad_function_call();
                                  __debugbreak();
                                }
                                v87 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v86 + 0x10LL))(
                                                   v86,
                                                   v85);
                                v144 = 0;
                                v88 = *v87;
                                if ( v63 )
                                  _InterlockedIncrement(v63 + 2);
                                *(_QWORD *)&v144 = v62;
                                *((_QWORD *)&v144 + 1) = v63;
                                v108 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *, __int128 *))(v88 + 0x10))(
                                                    v87,
                                                    v150,
                                                    &v144);
                              }
                            }
                            if ( v63 )
                            {
                              if ( _InterlockedExchangeAdd(v63 + 2, 0xFFFFFFFF) == 1 )
                              {
                                (**(void (__fastcall ***)(volatile signed __int32 *))v63)(v63);
                                if ( _InterlockedExchangeAdd(v63 + 3, 0xFFFFFFFF) == 1 )
                                  (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v63 + 8LL))(v63);
                              }
                            }
                          }
LABEL_113:
                          v89 = v125;
                          if ( v125 && _InterlockedExchangeAdd((volatile signed __int32 *)(v125 + 0xC), 0xFFFFFFFF) == 1 )
                            (*(void (__fastcall **)(__int64))(*(_QWORD *)v89 + 8LL))(v89);
                        }
                      }
                    }
                  }
                  else
                  {
                    v127 = 0;
                  }
                }
                v46 += 6;
                if ( v46 == v48 )
                {
                  v15 = v111;
                  v17 = v121;
                  break;
                }
              }
            }
          }
          else
          {
            if ( !v108 )
            {
              v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
              v108 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v21 + 0x1D8LL))(v21, v146);
            }
            sub_1403F6100((__int64)v151, v108, v20 + 0x10);
            v22 = *sub_14040B4F0((__int64)v151, &v147);
            if ( v22 )
            {
              if ( v15 == v17 )
              {
                v41 = (_QWORD *)allocWithProfilerInfo_w(0x18u);
                v42 = v41;
                if ( v41 )
                {
                  *v41 = 0;
                  v41[1] = 0;
                  v41[2] = 0;
                }
                else
                {
                  v42 = 0;
                }
                v43 = allocWithProfilerInfo_w(0x18u);
                v44 = (volatile signed __int32 *)v43;
                if ( v43 )
                {
                  *(_DWORD *)(v43 + 8) = 1;
                  *(_DWORD *)(v43 + 0xC) = 1;
                  *(_QWORD *)v43 = off_1484E4E80;
                  *(_QWORD *)(v43 + 0x10) = v42;
                  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v43 + 8), 0xFFFFFFFF) == 1 )
                  {
                    (**(void (__fastcall ***)(__int64))v43)(v43);
                    if ( _InterlockedExchangeAdd(v44 + 3, 0xFFFFFFFF) == 1 )
                      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v44 + 8LL))(v44);
                  }
                }
              }
              else
              {
                v108 = v22;
              }
            }
            else
            {
              v23 = *(int **)(v20 + 0x18);
              v24 = *(int **)(v20 + 0x10);
              v166[0] = 0;
              v25 = v166;
              v165 = v166;
              v163 = 0;
              n0x1FF = 0x1FF;
              v143 = v23;
              v109 = v24;
              if ( v24 != v23 )
              {
                do
                {
                  v26 = v24[2];
                  v27 = *v24;
                  v28 = *((unsigned __int8 *)v24 + 0xC);
                  v29 = *((unsigned __int8 *)v24 + 0xD);
                  v30 = *((unsigned __int8 *)v24 + 0xE);
                  v31 = *((unsigned __int8 *)v24 + 0xF);
                  v161 = v162;
                  v32 = BYTE1(v27);
                  v33 = (unsigned __int8)v27;
                  v120 = HIBYTE(v27);
                  v34 = BYTE2(v27);
                  v35 = *((unsigned __int8 *)v24 + 4);
                  v36 = *((unsigned __int8 *)v109 + 7);
                  Size_2 = 0;
                  v105 = (unsigned __int8)v26;
                  v104 = BYTE1(v26);
                  v103 = BYTE2(v26);
                  v119 = HIBYTE(v26);
                  v37 = *((unsigned __int8 *)v24 + 5);
                  v38 = *((unsigned __int8 *)v24 + 6);
                  v162[0] = 0;
                  n0x24 = 0x24;
                  sub_1402C61F0(
                    (__int64)&Size_2,
                    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                    v36,
                    v38,
                    v37,
                    v35,
                    v120,
                    v34,
                    v32,
                    v33,
                    v31,
                    v30,
                    v29,
                    v28,
                    v119,
                    v103,
                    v104,
                    v105);
                  sub_1403E0AA0(&v110);
                  Size = Size_2;
                  if ( Size_2 )
                  {
                    sub_1403DE0C0(&v110, Size_2);
                    sub_1403E1FA0(v110, v161, Size);
                  }
                  if ( v161 != v162 )
                  {
                    qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - n0x24;
                    sub_147605980(v161);
                  }
                  if ( v110 )
                  {
                    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
                    do
                      ++Size_1;
                    while ( v110[Size_1] );
                  }
                  else
                  {
                    Size_1 = 0;
                  }
                  sub_1402DECA0(&v163, v110, Size_1);
                  sub_1402DECA0(&v163, ", ", 2u);
                  sub_140370D10(&v110);
                  v24 = v109 + 4;
                  v109 = v24;
                }
                while ( v24 != v143 );
                v25 = v165;
                v15 = v111;
                v17 = v121;
              }
              sub_1405C0E00(
                4u,
                2u,
                "SuperGUID::ResolveSuperGuidInputValue failed to find entity in superguid query corresponding to the foll"
                "owing super guid: %s",
                v25);
              if ( v165 != v166 )
              {
                qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
                sub_147605980(v165);
              }
            }
            sub_1402B2610(v154);
            v45 = v152;
            if ( v152 )
            {
              if ( ((*((_QWORD *)&v153 + 1) - (_QWORD)v152) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
              {
                v45 = (_BYTE *)*((_QWORD *)v152 + 0xFFFFFFFF);
                if ( (unsigned __int64)(v152 - v45 - 8) > 0x1F )
                  invalid_parameter_noinfo_noreturn();
              }
              sub_1402A3D30(v45);
              v153 = 0;
              v152 = 0;
            }
          }
          v90 = v122;
          if ( v122 )
          {
            if ( _InterlockedExchangeAdd(v122 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v90)(v90);
              if ( _InterlockedExchangeAdd(v90 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v90 + 8LL))(v90);
            }
          }
          v111 = ++v15;
          if ( v15 >= v142 )
            break;
          v7 = v128;
        }
        v6 = v123;
      }
      v5 = v112;
    }
  }
  *v6 = 0;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = 0;
  v6[4] = 0;
  v101 = allocWithProfilerInfo_w(0x18u);
  if ( v101 )
  {
    *(_DWORD *)(v101 + 8) = 1;
    *(_DWORD *)(v101 + 0xC) = 1;
    *(_QWORD *)v101 = off_1481B6460;
    *(_QWORD *)(v101 + 0x10) = 0;
  }
  else
  {
    v101 = 0;
  }
  v6[3] = 0;
  v6[4] = v101;
  v139 = __rdtsc();
  qword_149B4B878(&n0x5A00);
  v102 = (volatile signed __int32 *)v5[1];
  if ( v102 && _InterlockedExchangeAdd(v102 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v102)(v102);
    if ( _InterlockedExchangeAdd(v102 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v102 + 8LL))(v102);
  }
  return v6;
}

// --- End Function: sub_141B76140 (0x141B76140) ---

// --- Function: sub_1425D62E0 (0x1425D62E0) ---
_QWORD *__fastcall sub_1425D62E0(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_6;
  if ( n0xFFFF_6 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          &v9,
                          "Actor");
    n0xFFFF_6 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_1425D62E0 (0x1425D62E0) ---

// --- Function: sub_142703060 (0x142703060) ---
void __fastcall sub_142703060(__int64 a1)
{
  sub_1403090C0(a1 + 0x1A8);
  sub_1403090C0(a1 + 0x180);
  sub_1403090C0(a1 + 0x158);
  sub_1403090C0(a1 + 0x130);
  sub_1403090C0(a1 + 0x108);
  sub_14053ABD0(a1);
}

// --- End Function: sub_142703060 (0x142703060) ---

// --- Function: sub_142708D10 (0x142708D10) ---
const void *__fastcall sub_142708D10(const void *a1, char a2)
{
  sub_142703060((__int64)a1);
  if ( (a2 & 1) != 0 )
    sub_1402A3D30(a1);
  return a1;
}

// --- End Function: sub_142708D10 (0x142708D10) ---

// --- Function: sub_142723320 (0x142723320) ---
_QWORD *sub_142723320(__int64 a1, _QWORD *a2, __int64 a3, ...)
{
  __int64 v3; // rax
  __int64 *v4; // rax
  unsigned int v5; // eax
  __int64 v7; // [rsp+38h] [rbp-580h] BYREF
  __int64 v8; // [rsp+40h] [rbp-578h]
  double v9; // [rsp+48h] [rbp-570h]
  double v10; // [rsp+50h] [rbp-568h]
  double v11; // [rsp+58h] [rbp-560h]
  float v12; // [rsp+60h] [rbp-558h] BYREF
  float v13; // [rsp+64h] [rbp-554h]
  float v14; // [rsp+68h] [rbp-550h]
  float v15; // [rsp+6Ch] [rbp-54Ch]
  float v16; // [rsp+70h] [rbp-548h]
  float v17; // [rsp+74h] [rbp-544h]
  float v18; // [rsp+78h] [rbp-540h]
  float v19; // [rsp+80h] [rbp-538h]
  int v20; // [rsp+84h] [rbp-534h]
  double v21; // [rsp+90h] [rbp-528h] BYREF
  double v22; // [rsp+98h] [rbp-520h]
  double v23; // [rsp+A0h] [rbp-518h]
  double v24; // [rsp+A8h] [rbp-510h]
  double v25; // [rsp+B0h] [rbp-508h]
  double v26; // [rsp+B8h] [rbp-500h]
  double v27; // [rsp+C0h] [rbp-4F8h]
  double v28; // [rsp+C8h] [rbp-4F0h]
  __int64 v29; // [rsp+D0h] [rbp-4E8h]
  double *v30; // [rsp+D8h] [rbp-4E0h]
  double *v31; // [rsp+E0h] [rbp-4D8h]
  int v32; // [rsp+E8h] [rbp-4D0h]
  int v33; // [rsp+ECh] [rbp-4CCh]
  __int64 v34; // [rsp+F8h] [rbp-4C0h]
  __int64 v35; // [rsp+100h] [rbp-4B8h] BYREF
  unsigned __int64 v36; // [rsp+108h] [rbp-4B0h] BYREF
  __int64 v37; // [rsp+110h] [rbp-4A8h]
  __int64 v38; // [rsp+118h] [rbp-4A0h] BYREF
  __int64 v39; // [rsp+120h] [rbp-498h]
  __int64 v40; // [rsp+128h] [rbp-490h]
  __int64 v41; // [rsp+130h] [rbp-488h]
  __int64 v42; // [rsp+138h] [rbp-480h]
  __int64 v43; // [rsp+140h] [rbp-478h]
  double v44; // [rsp+148h] [rbp-470h]
  double v45; // [rsp+150h] [rbp-468h]
  double v46; // [rsp+158h] [rbp-460h]
  __int64 v47; // [rsp+160h] [rbp-458h]
  __int64 v48; // [rsp+168h] [rbp-450h]
  __int64 v49; // [rsp+170h] [rbp-448h]
  __int64 (__fastcall *v50)(__int64, _BYTE *); // [rsp+178h] [rbp-440h]
  __int64 v51; // [rsp+180h] [rbp-438h]
  __int64 v52; // [rsp+188h] [rbp-430h]
  __int64 v53; // [rsp+190h] [rbp-428h]
  _QWORD Parameter_[2]; // [rsp+198h] [rbp-420h] BYREF
  _QWORD Parameter__1[2]; // [rsp+1A8h] [rbp-410h] BYREF
  __int64 v56; // [rsp+1B8h] [rbp-400h]
  __int64 v57; // [rsp+1C0h] [rbp-3F8h]
  __int64 v58; // [rsp+1C8h] [rbp-3F0h]
  __int64 v59; // [rsp+1D0h] [rbp-3E8h]
  __int64 v60; // [rsp+1D8h] [rbp-3E0h]
  __int64 v61; // [rsp+1E0h] [rbp-3D8h]
  __int64 v62; // [rsp+1E8h] [rbp-3D0h]
  __int64 v63; // [rsp+1F0h] [rbp-3C8h]
  __int64 *v64; // [rsp+1F8h] [rbp-3C0h]
  __int64 v65; // [rsp+200h] [rbp-3B8h]
  __int64 v66; // [rsp+208h] [rbp-3B0h]
  __int64 v67; // [rsp+210h] [rbp-3A8h]
  __int64 v68; // [rsp+218h] [rbp-3A0h]
  __int64 v69; // [rsp+220h] [rbp-398h]
  __int64 v70; // [rsp+228h] [rbp-390h]
  __int64 v71; // [rsp+230h] [rbp-388h]
  unsigned __int64 v72; // [rsp+238h] [rbp-380h]
  __int64 v73; // [rsp+240h] [rbp-378h]
  __int64 v74; // [rsp+248h] [rbp-370h]
  __int64 v75; // [rsp+250h] [rbp-368h]
  void (__fastcall *v76)(__int64, double *, __int64, _QWORD, _BYTE); // [rsp+258h] [rbp-360h]
  __int64 v77; // [rsp+260h] [rbp-358h]
  __int64 v78; // [rsp+268h] [rbp-350h]
  void (__fastcall *v79)(__int64, float *, __int64, _QWORD); // [rsp+270h] [rbp-348h]
  double v80; // [rsp+278h] [rbp-340h]
  double v81; // [rsp+280h] [rbp-338h]
  double v82; // [rsp+288h] [rbp-330h]
  double v83; // [rsp+290h] [rbp-328h]
  double v84; // [rsp+298h] [rbp-320h]
  __int64 v85; // [rsp+2A0h] [rbp-318h]
  __int64 v86; // [rsp+2A8h] [rbp-310h]
  __int64 v87; // [rsp+2B0h] [rbp-308h]
  __int64 v88; // [rsp+2B8h] [rbp-300h]
  __int64 v89; // [rsp+2C0h] [rbp-2F8h]
  __int64 v90; // [rsp+2C8h] [rbp-2F0h]
  __int64 v91; // [rsp+348h] [rbp-270h]
  __int64 v92; // [rsp+350h] [rbp-268h]
  __int64 v93; // [rsp+358h] [rbp-260h]
  double v94; // [rsp+360h] [rbp-258h]
  double v95; // [rsp+368h] [rbp-250h]
  double v96; // [rsp+370h] [rbp-248h]
  double v97; // [rsp+378h] [rbp-240h]
  double src_[4]; // [rsp+380h] [rbp-238h] BYREF
  _BYTE v99[8]; // [rsp+3A0h] [rbp-218h] BYREF
  std::_Ref_count_base *v100; // [rsp+3A8h] [rbp-210h]
  __int64 v101; // [rsp+3B0h] [rbp-208h]
  _BYTE v102[8]; // [rsp+3B8h] [rbp-200h] BYREF
  __int64 v103; // [rsp+3C0h] [rbp-1F8h]
  _BYTE v104[8]; // [rsp+3C8h] [rbp-1F0h] BYREF
  double v105[4]; // [rsp+420h] [rbp-198h] BYREF
  _BYTE dst_[24]; // [rsp+440h] [rbp-178h] BYREF
  double v107[4]; // [rsp+458h] [rbp-160h] BYREF
  _BYTE v108[72]; // [rsp+478h] [rbp-140h] BYREF
  _BYTE v109[56]; // [rsp+4C0h] [rbp-F8h] BYREF
  __int64 v110; // [rsp+4F8h] [rbp-C0h]
  int v111; // [rsp+57Ch] [rbp-3Ch]
  __int64 v114; // [rsp+5D8h] [rbp+20h] BYREF
  va_list va; // [rsp+5D8h] [rbp+20h]
  _QWORD *v116; // [rsp+5E0h] [rbp+28h]
  va_list va1; // [rsp+5E8h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v114 = va_arg(va1, _QWORD);
  v116 = va_arg(va1, _QWORD *);
  v7 = 0;
  v8 = 0;
  v91 = a3 + 0x1B0;
  if ( Handle::IsValid((_QWORD *)(a3 + 0x1B0)) )
  {
    v92 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
    v36 = *(_QWORD *)(v92 + 8);
    if ( j_validateHandleAccess(&v36) )
    {
      v39 = sub_14030ECF0(&v36);
      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x58LL))(v39) )
      {
        v93 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
        v29 = sub_1462D3180(v93, (unsigned int *)(a3 + 0x1B8));
        if ( v29 )
        {
          v40 = sub_14030ECF0((__int64 *)va);
          v50 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v40 + 8LL);
          v3 = v50(v40, v102);
          v4 = (__int64 *)sub_1426D9260(v99, v3);
          sub_142704CD0(&v7, v4);
          if ( v100 )
            std::_Ref_count_base::_Decref(v100);
          v51 = v7;
          v52 = v7 + 0x150;
          v53 = v7 + 0x150;
          v56 = v7 + 0x150;
          sub_14277D0F0((__int64)v116, (Parameter *)Parameter_);
          Parameter_[1] = Parameter_[0];
          v57 = Parameter_[0];
          sub_14277D090(v116, (Parameter *)Parameter__1);
          Parameter__1[1] = Parameter__1[0];
          v58 = Parameter__1[0];
          v37 = v56;
          v61 = v57;
          v59 = Parameter__1[0];
          v60 = Parameter__1[0];
          v42 = Parameter__1[0];
          v62 = v57;
          v41 = v57;
          v103 = (v57 - Parameter__1[0]) >> 6;
          v63 = v56;
          v64 = (__int64 *)sub_1426F02C0(v104, Parameter__1[0], v57, v56);
          v37 = *v64;
          v101 = v37;
          v65 = v7;
          v66 = v7 + 0x30;
          sub_141B8B360(v7 + 0x30, *(_BYTE *)(a3 + 0x1F4));
          v67 = v7;
          v68 = v7 + 0x30;
          sub_141B89FE0(v7 + 0x30, *(_BYTE *)(a3 + 0x200));
          v69 = v7;
          v70 = v7 + 0x30;
          sub_14053D1C0(v7 + 0x30, 1);
          v72 = v36;
          v71 = v7;
          *(_QWORD *)(v7 + 0x198) = v36;
          v32 = *(_DWORD *)(v29 + 0x1C);
          v73 = v7;
          *(_DWORD *)(v7 + 0x1B8) = v32;
          v33 = *(_DWORD *)(a3 + 0x1C0);
          v74 = v7;
          *(_DWORD *)(v7 + 0x1BC) = v33;
          v34 = sub_1462D0420(*(_QWORD *)(v29 + 0x20));
          v38 = *(_QWORD *)(v34 + 0x20);
          if ( Handle::IsValid(&v38) )
          {
            v75 = v38 & 0xFFFFFFFFFFFFLL;
            v35 = *(_QWORD *)((v38 & 0xFFFFFFFFFFFFLL) + 8);
            v43 = sub_14030ECF0(&v35);
            v76 = *(void (__fastcall **)(__int64, double *, __int64, _QWORD, _BYTE))(*(_QWORD *)v43 + 0x1E8LL);
            v76(v43, &v21, 2, 0, 0);
            if ( *(_BYTE *)(*(_QWORD *)(v29 + 0x30) + 0x151LL) )
            {
              v77 = v38 & 0xFFFFFFFFFFFFLL;
              v30 = sub_14627FDE0(v38 & 0xFFFFFFFFFFFFLL, v107, &v21);
              v21 = *v30;
              v22 = v30[1];
              v23 = v30[2];
              v24 = v30[3];
            }
            v78 = *(_QWORD *)(v34 + 0x18);
            v79 = *(void (__fastcall **)(__int64, float *, __int64, _QWORD))(**(_QWORD **)(v34 + 0x18) + 0x50LL);
            v79(v78, &v12, v35, 0);
            v80 = v22 * v14 - v23 * v13 + v24 * v12 + v21 * v15;
            v81 = v23 * v12 - v21 * v14 + v24 * v13 + v22 * v15;
            v82 = v21 * v13 - v22 * v12 + v24 * v14 + v23 * v15;
            v83 = v24 * v15 - v21 * v12 - v22 * v13 - v23 * v14;
            v46 = v22 * v18 - v23 * v17 + v24 * v16;
            v45 = v23 * v16 - v21 * v18 + v24 * v17;
            v44 = v21 * v17 - v22 * v16 + v24 * v18;
            v11 = (v44 * v22 - v45 * v23 + v44 * v22 - v45 * v23 + v16) * v28 + v25;
            v9 = (v46 * v23 - v44 * v21 + v46 * v23 - v44 * v21 + v17) * v28 + v26;
            v10 = v45 * v21 - v46 * v22;
            v10 = v10 + v10 + v18;
            v10 = v10 * v28;
            v10 = v10 + v27;
            v84 = v28;
            v94 = v80;
            v95 = v81;
            v96 = v82;
            v97 = v83;
            src_[0] = v11;
            src_[1] = v9;
            src_[2] = v10;
            src_[3] = v28;
            v31 = v105;
            v105[0] = v80;
            v105[1] = v81;
            v105[2] = v82;
            v105[3] = v83;
            qmemcpy(dst_, src_, sizeof(dst_));
            v47 = sub_14030ECF0(&v35);
            v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v47 + 0x648LL))(v47);
            sub_141A556E0((__int64)v109);
            v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v48 + 0x1F8LL))(v48);
            v49 = sub_14036F2B0((__int64)v108, (__int64)v105, v5);
            sub_14030DE50((__int64)v109, v49);
            v110 = *(_QWORD *)(v49 + 0x38);
            v19 = 0.050000001;
            if ( *(float *)&dword_149A63C58 >= 0.050000001 )
              v20 = dword_149A63C58;
            else
              *(float *)&v20 = v19;
            v111 = v20;
            v85 = v7;
            v86 = v7 + 0x30;
            sub_141B82BC0(v7 + 0x30, v109);
            sub_141A617B0((__int64)v109);
          }
          v87 = v7;
          v88 = v7 + 0x30;
          sub_141B8B3E0(v7 + 0x30, 0);
          v89 = v7;
          v90 = v7 + 0x30;
          sub_14264F120(v7 + 0x30, 1);
        }
      }
    }
  }
  *a2 = 0;
  a2[1] = 0;
  *a2 = v7;
  a2[1] = v8;
  return a2;
}

// --- End Function: sub_142723320 (0x142723320) ---

// --- Function: sub_1427242E0 (0x1427242E0) ---
_QWORD *sub_1427242E0(__int64 a1, _QWORD *a2, __int64 a3, ...)
{
  __int64 v3; // rax
  __int64 *v4; // rax
  __int64 v6; // [rsp+38h] [rbp-580h] BYREF
  __int64 v7; // [rsp+40h] [rbp-578h]
  __int64 v8; // [rsp+D0h] [rbp-4E8h]
  int v9; // [rsp+E8h] [rbp-4D0h]
  int v10; // [rsp+ECh] [rbp-4CCh]
  int v11; // [rsp+F0h] [rbp-4C8h]
  int v12; // [rsp+F4h] [rbp-4C4h]
  unsigned __int64 v13; // [rsp+108h] [rbp-4B0h] BYREF
  __int64 v14; // [rsp+110h] [rbp-4A8h]
  __int64 v15; // [rsp+120h] [rbp-498h]
  __int64 v16; // [rsp+128h] [rbp-490h]
  __int64 v17; // [rsp+130h] [rbp-488h]
  __int64 v18; // [rsp+138h] [rbp-480h]
  __int64 (__fastcall *v19)(__int64, _BYTE *); // [rsp+178h] [rbp-440h]
  __int64 v20; // [rsp+180h] [rbp-438h]
  __int64 v21; // [rsp+188h] [rbp-430h]
  __int64 v22; // [rsp+190h] [rbp-428h]
  _QWORD Parameter_[2]; // [rsp+198h] [rbp-420h] BYREF
  _QWORD Parameter__1[2]; // [rsp+1A8h] [rbp-410h] BYREF
  __int64 v25; // [rsp+1B8h] [rbp-400h]
  __int64 v26; // [rsp+1C0h] [rbp-3F8h]
  __int64 v27; // [rsp+1C8h] [rbp-3F0h]
  __int64 v28; // [rsp+1D0h] [rbp-3E8h]
  __int64 v29; // [rsp+1D8h] [rbp-3E0h]
  __int64 v30; // [rsp+1E0h] [rbp-3D8h]
  __int64 v31; // [rsp+1E8h] [rbp-3D0h]
  __int64 v32; // [rsp+1F0h] [rbp-3C8h]
  __int64 *v33; // [rsp+1F8h] [rbp-3C0h]
  __int64 v34; // [rsp+200h] [rbp-3B8h]
  __int64 v35; // [rsp+208h] [rbp-3B0h]
  __int64 v36; // [rsp+210h] [rbp-3A8h]
  __int64 v37; // [rsp+218h] [rbp-3A0h]
  __int64 v38; // [rsp+220h] [rbp-398h]
  __int64 v39; // [rsp+228h] [rbp-390h]
  __int64 v40; // [rsp+230h] [rbp-388h]
  unsigned __int64 v41; // [rsp+238h] [rbp-380h]
  __int64 v42; // [rsp+240h] [rbp-378h]
  __int64 v43; // [rsp+248h] [rbp-370h]
  __int64 v44; // [rsp+2B0h] [rbp-308h]
  __int64 v45; // [rsp+2B8h] [rbp-300h]
  __int64 v46; // [rsp+2C0h] [rbp-2F8h]
  __int64 v47; // [rsp+2C8h] [rbp-2F0h]
  __int64 v48; // [rsp+2D0h] [rbp-2E8h]
  _QWORD *v49; // [rsp+2D8h] [rbp-2E0h]
  _QWORD *v50; // [rsp+2E0h] [rbp-2D8h]
  __int64 v51; // [rsp+2E8h] [rbp-2D0h]
  __int64 v52; // [rsp+2F0h] [rbp-2C8h]
  __int64 v53; // [rsp+2F8h] [rbp-2C0h]
  __int64 v54; // [rsp+300h] [rbp-2B8h]
  __int64 v55; // [rsp+308h] [rbp-2B0h]
  _QWORD *v56; // [rsp+310h] [rbp-2A8h]
  _QWORD *v57; // [rsp+318h] [rbp-2A0h]
  __int64 v58; // [rsp+320h] [rbp-298h]
  __int64 v59; // [rsp+328h] [rbp-290h]
  __int64 v60; // [rsp+330h] [rbp-288h]
  _QWORD *v61; // [rsp+338h] [rbp-280h]
  __int64 v62; // [rsp+340h] [rbp-278h]
  __int64 v63; // [rsp+348h] [rbp-270h]
  __int64 v64; // [rsp+350h] [rbp-268h]
  __int64 v65; // [rsp+358h] [rbp-260h]
  _BYTE v66[8]; // [rsp+3A0h] [rbp-218h] BYREF
  std::_Ref_count_base *v67; // [rsp+3A8h] [rbp-210h]
  __int64 v68; // [rsp+3B0h] [rbp-208h]
  _BYTE v69[8]; // [rsp+3B8h] [rbp-200h] BYREF
  __int64 v70; // [rsp+3C0h] [rbp-1F8h]
  _BYTE v71[8]; // [rsp+3C8h] [rbp-1F0h] BYREF
  _QWORD v72[3]; // [rsp+3D0h] [rbp-1E8h] BYREF
  _QWORD v73[3]; // [rsp+3E8h] [rbp-1D0h] BYREF
  _QWORD v74[2]; // [rsp+400h] [rbp-1B8h] BYREF
  _QWORD v75[2]; // [rsp+410h] [rbp-1A8h] BYREF
  __int64 v78; // [rsp+5D8h] [rbp+20h] BYREF
  va_list va; // [rsp+5D8h] [rbp+20h]
  _QWORD *v80; // [rsp+5E0h] [rbp+28h]
  va_list va1; // [rsp+5E8h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v78 = va_arg(va1, _QWORD);
  v80 = va_arg(va1, _QWORD *);
  v6 = 0;
  v7 = 0;
  v63 = a3 + 0x1B0;
  if ( Handle::IsValid((_QWORD *)(a3 + 0x1B0)) )
  {
    v64 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
    v13 = *(_QWORD *)(v64 + 8);
    if ( j_validateHandleAccess(&v13) )
    {
      v15 = sub_14030ECF0(&v13);
      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x58LL))(v15) )
      {
        v65 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
        v8 = sub_1462D3180(v65, (unsigned int *)(a3 + 0x1B8));
        if ( v8 )
        {
          v16 = sub_14030ECF0((__int64 *)va);
          v19 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v16 + 8LL);
          v3 = v19(v16, v69);
          v4 = (__int64 *)sub_1426D9260(v66, v3);
          sub_142704CD0(&v6, v4);
          if ( v67 )
            std::_Ref_count_base::_Decref(v67);
          v20 = v6;
          v21 = v6 + 0x150;
          v22 = v6 + 0x150;
          v25 = v6 + 0x150;
          sub_14277D0F0((__int64)v80, (Parameter *)Parameter_);
          Parameter_[1] = Parameter_[0];
          v26 = Parameter_[0];
          sub_14277D090(v80, (Parameter *)Parameter__1);
          Parameter__1[1] = Parameter__1[0];
          v27 = Parameter__1[0];
          v14 = v25;
          v30 = v26;
          v28 = Parameter__1[0];
          v29 = Parameter__1[0];
          v18 = Parameter__1[0];
          v31 = v26;
          v17 = v26;
          v70 = (v26 - Parameter__1[0]) >> 6;
          v32 = v25;
          v33 = (__int64 *)sub_1426F02C0(v71, Parameter__1[0], v26, v25);
          v14 = *v33;
          v68 = v14;
          v34 = v6;
          v35 = v6 + 0x30;
          sub_141B8B360(v6 + 0x30, *(_BYTE *)(a3 + 0x1F4));
          v36 = v6;
          v37 = v6 + 0x30;
          sub_141B89FE0(v6 + 0x30, *(_BYTE *)(a3 + 0x200));
          v38 = v6;
          v39 = v6 + 0x30;
          sub_14053D1C0(v6 + 0x30, 1);
          v41 = v13;
          v40 = v6;
          *(_QWORD *)(v6 + 0x198) = v13;
          v9 = *(_DWORD *)(v8 + 0x1C);
          v42 = v6;
          *(_DWORD *)(v6 + 0x1B8) = v9;
          v10 = *(_DWORD *)(a3 + 0x1C0);
          v43 = v6;
          *(_DWORD *)(v6 + 0x1BC) = v10;
          v44 = v6;
          v45 = v6 + 0x30;
          sub_141B8B3E0(v6 + 0x30, 0);
          v46 = v6;
          v47 = v6 + 0x30;
          sub_14264F120(v6 + 0x30, 0);
          v48 = v6;
          sub_142704DF0(v6 + 0x168, a3 + 0x1D8);
          v49 = v74;
          v50 = sub_1426FC490(v74, &v6);
          v11 = *(_DWORD *)(a3 + 0x1B8);
          v51 = *(_QWORD *)(a3 + 0x1B0);
          v52 = v78;
          v54 = sub_1456247F0((unsigned int)v72, v78, v51, v11, (__int64)v50);
          v53 = v6;
          v55 = v6 + 0x1D0;
          sub_1427049D0(v6 + 0x1D0, v54);
          sub_142702430(v72);
          v56 = v75;
          v57 = sub_1426FC490(v75, &v6);
          v12 = *(_DWORD *)(a3 + 0x1B8);
          v58 = *(_QWORD *)(a3 + 0x1B0);
          v59 = v78;
          v61 = (_QWORD *)sub_145625B80((unsigned int)v73, v78, v58, v12, (__int64)v57);
          v60 = v6;
          v62 = v6 + 0x1E8;
          sub_142704910((_QWORD *)(v6 + 0x1E8), v61);
          sub_1402A2AD0(v73);
        }
      }
    }
  }
  *a2 = 0;
  a2[1] = 0;
  *a2 = v6;
  a2[1] = v7;
  return a2;
}

// --- End Function: sub_1427242E0 (0x1427242E0) ---

// --- Function: sub_1427252A0 (0x1427252A0) ---
_QWORD *sub_1427252A0(__int64 a1, _QWORD *a2, __int64 a3, ...)
{
  __int64 v3; // rax
  __int64 *v4; // rax
  unsigned int v5; // eax
  double *v7; // [rsp+30h] [rbp-2C8h]
  double v8; // [rsp+38h] [rbp-2C0h]
  double v9; // [rsp+38h] [rbp-2C0h]
  double v10; // [rsp+40h] [rbp-2B8h]
  double v11; // [rsp+40h] [rbp-2B8h]
  double v12; // [rsp+48h] [rbp-2B0h]
  double v13; // [rsp+48h] [rbp-2B0h]
  float v14; // [rsp+50h] [rbp-2A8h] BYREF
  float v15; // [rsp+54h] [rbp-2A4h]
  float v16; // [rsp+58h] [rbp-2A0h]
  float v17; // [rsp+5Ch] [rbp-29Ch]
  float v18; // [rsp+60h] [rbp-298h]
  float v19; // [rsp+64h] [rbp-294h]
  float v20; // [rsp+68h] [rbp-290h]
  __int64 v21; // [rsp+70h] [rbp-288h] BYREF
  __int64 v22; // [rsp+78h] [rbp-280h]
  unsigned __int64 v23; // [rsp+80h] [rbp-278h] BYREF
  __int64 v24; // [rsp+88h] [rbp-270h]
  double *v25; // [rsp+90h] [rbp-268h]
  __int64 v26; // [rsp+98h] [rbp-260h]
  __int64 v27; // [rsp+A0h] [rbp-258h]
  __int64 v28; // [rsp+A8h] [rbp-250h]
  __int64 v29; // [rsp+B0h] [rbp-248h]
  double v30; // [rsp+B8h] [rbp-240h]
  double v31; // [rsp+C0h] [rbp-238h]
  double v32; // [rsp+C8h] [rbp-230h]
  __int64 v33; // [rsp+D0h] [rbp-228h]
  __int64 v34; // [rsp+D8h] [rbp-220h]
  __int64 v35; // [rsp+E0h] [rbp-218h]
  __int64 v36; // [rsp+E8h] [rbp-210h]
  __int64 v37; // [rsp+F0h] [rbp-208h]
  __int64 (__fastcall *v38)(__int64, _BYTE *); // [rsp+F8h] [rbp-200h]
  __int64 v39; // [rsp+100h] [rbp-1F8h]
  __int64 v40; // [rsp+108h] [rbp-1F0h]
  __int64 v41; // [rsp+110h] [rbp-1E8h]
  __int64 v42; // [rsp+118h] [rbp-1E0h]
  __int64 v43; // [rsp+120h] [rbp-1D8h]
  unsigned __int64 v44; // [rsp+128h] [rbp-1D0h]
  __int64 v45; // [rsp+130h] [rbp-1C8h]
  __int64 v46; // [rsp+138h] [rbp-1C0h]
  __int64 v47; // [rsp+140h] [rbp-1B8h]
  __int64 v48; // [rsp+148h] [rbp-1B0h]
  __int64 v49; // [rsp+150h] [rbp-1A8h]
  __int64 v50; // [rsp+158h] [rbp-1A0h]
  __int64 v51; // [rsp+160h] [rbp-198h]
  __int64 v52; // [rsp+168h] [rbp-190h]
  void (__fastcall *v53)(__int64, float *, unsigned __int64, _QWORD); // [rsp+170h] [rbp-188h]
  __int64 (__fastcall *v54)(__int64, _BYTE *, __int64, _QWORD, _BYTE); // [rsp+178h] [rbp-180h]
  double v55; // [rsp+180h] [rbp-178h]
  double v56; // [rsp+188h] [rbp-170h]
  __int64 v57; // [rsp+190h] [rbp-168h]
  double v58; // [rsp+198h] [rbp-160h]
  double v59; // [rsp+1A0h] [rbp-158h]
  __int64 v60; // [rsp+1A8h] [rbp-150h]
  __int64 v61; // [rsp+1B0h] [rbp-148h]
  double v62; // [rsp+1B8h] [rbp-140h]
  __int64 v63; // [rsp+1C0h] [rbp-138h]
  double v64; // [rsp+1D0h] [rbp-128h]
  double v65; // [rsp+1D8h] [rbp-120h]
  double v66; // [rsp+1E0h] [rbp-118h]
  double v67; // [rsp+1E8h] [rbp-110h]
  double src_[4]; // [rsp+1F0h] [rbp-108h] BYREF
  _BYTE v69[8]; // [rsp+210h] [rbp-E8h] BYREF
  std::_Ref_count_base *v70; // [rsp+218h] [rbp-E0h]
  _BYTE v71[8]; // [rsp+220h] [rbp-D8h] BYREF
  double v72[4]; // [rsp+228h] [rbp-D0h] BYREF
  _BYTE dst_[24]; // [rsp+248h] [rbp-B0h] BYREF
  _BYTE v74[64]; // [rsp+260h] [rbp-98h] BYREF
  _BYTE v75[88]; // [rsp+2A0h] [rbp-58h] BYREF
  va_list va; // [rsp+318h] [rbp+20h] BYREF

  va_start(va, a3);
  v21 = 0;
  v22 = 0;
  v57 = a3 + 0x1B0;
  if ( Handle::IsValid((_QWORD *)(a3 + 0x1B0)) )
  {
    v63 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
    v23 = *(_QWORD *)(v63 + 8);
    if ( j_validateHandleAccess(&v23) )
    {
      v26 = sub_14030ECF0(&v23);
      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x58LL))(v26) )
      {
        v37 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
        v28 = sub_1462D3180(v37, (unsigned int *)(a3 + 0x1B8));
        if ( v28 )
        {
          v27 = sub_14030ECF0((__int64 *)va);
          v38 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v27 + 8LL);
          v3 = v38(v27, v71);
          v4 = (__int64 *)sub_1419E4BC0(v69, v3);
          sub_142704CD0(&v21, v4);
          if ( v70 )
            std::_Ref_count_base::_Decref(v70);
          v39 = v21;
          v40 = v21 + 0x30;
          sub_14053D1C0(v21 + 0x30, 1);
          v41 = v21;
          v42 = v21 + 0x30;
          sub_141B89FE0(v21 + 0x30, 1);
          v44 = v23;
          v43 = v21;
          *(_QWORD *)(v21 + 0x1A8) = v23;
          v45 = a3 + 0x1D8;
          v46 = a3 + 0x1D8;
          v48 = *(_QWORD *)(a3 + 0x1D8) + 0x30LL;
          v47 = v21;
          sub_14030E030(v21 + 0x1B8, v48);
          v49 = v21;
          v50 = v21 + 0x30;
          sub_14264F120(v21 + 0x30, 1);
          v24 = sub_1462D0420(*(_QWORD *)(v28 + 0x20));
          if ( !(*(unsigned __int8 (__fastcall **)(_QWORD))(**(_QWORD **)(v24 + 0x18) + 0x40LL))(*(_QWORD *)(v24 + 0x18)) )
          {
            v51 = *(_QWORD *)(v24 + 0x18);
            if ( !*(_DWORD *)(v51 + 0x124) )
            {
              v52 = *(_QWORD *)(v24 + 0x18);
              v53 = *(void (__fastcall **)(__int64, float *, unsigned __int64, _QWORD))(**(_QWORD **)(v24 + 0x18)
                                                                                      + 0x50LL);
              v53(v52, &v14, v23, 0);
              v29 = sub_14030ECF0(&v23);
              v54 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64, _QWORD, _BYTE))(*(_QWORD *)v29 + 0x1E8LL);
              v7 = (double *)v54(v29, v74, 2, 0, 0);
              v55 = v7[1] * v16 - v7[2] * v15 + v7[3] * v14 + *v7 * v17;
              v56 = v7[2] * v14 - *v7 * v16 + v7[3] * v15 + v7[1] * v17;
              v62 = *v7 * v15 - v7[1] * v14 + v7[3] * v16 + v7[2] * v17;
              v58 = v7[3] * v17 - *v7 * v14 - v7[1] * v15 - v7[2] * v16;
              v32 = v7[1] * v20 - v7[2] * v19 + v7[3] * v18;
              v31 = v7[2] * v18 - *v7 * v20 + v7[3] * v19;
              v30 = *v7 * v19 - v7[1] * v18 + v7[3] * v20;
              v8 = v30 * v7[1] - v31 * v7[2];
              v9 = (v8 + v8 + v18) * v7[7] + v7[4];
              v10 = v32 * v7[2] - v30 * *v7;
              v11 = (v10 + v10 + v19) * v7[7] + v7[5];
              v12 = v31 * *v7 - v32 * v7[1];
              v13 = (v12 + v12 + v20) * v7[7] + v7[6];
              v59 = v7[7];
              v64 = v55;
              v65 = v56;
              v66 = v62;
              v67 = v58;
              src_[0] = v9;
              src_[1] = v11;
              src_[2] = v13;
              src_[3] = v59;
              v25 = v72;
              v72[0] = v55;
              v72[1] = v56;
              v72[2] = v62;
              v72[3] = v58;
              qmemcpy(dst_, src_, sizeof(dst_));
              v33 = sub_14030ECF0(&v23);
              v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v33 + 0x648LL))(v33);
              v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x1F8LL))(v34);
              v35 = sub_14036F2B0((__int64)v75, (__int64)v72, v5);
              v60 = v21;
              v36 = v21 + 0x150;
              sub_14030DE50(v21 + 0x150, v35);
              *(_QWORD *)(v36 + 0x38) = *(_QWORD *)(v35 + 0x38);
              v61 = v21;
              *(_BYTE *)(v21 + 0x1B0) = 1;
            }
          }
        }
      }
    }
  }
  *a2 = 0;
  a2[1] = 0;
  *a2 = v21;
  a2[1] = v22;
  return a2;
}

// --- End Function: sub_1427252A0 (0x1427252A0) ---

// --- Function: sub_142725D00 (0x142725D00) ---
_QWORD *sub_142725D00(__int64 a1, _QWORD *a2, __int64 a3, ...)
{
  __int64 v3; // rax
  __int64 *v4; // rax
  unsigned int v5; // eax
  double *v7; // [rsp+30h] [rbp-2C8h]
  double v8; // [rsp+38h] [rbp-2C0h]
  double v9; // [rsp+38h] [rbp-2C0h]
  double v10; // [rsp+40h] [rbp-2B8h]
  double v11; // [rsp+40h] [rbp-2B8h]
  double v12; // [rsp+48h] [rbp-2B0h]
  double v13; // [rsp+48h] [rbp-2B0h]
  float v14; // [rsp+50h] [rbp-2A8h] BYREF
  float v15; // [rsp+54h] [rbp-2A4h]
  float v16; // [rsp+58h] [rbp-2A0h]
  float v17; // [rsp+5Ch] [rbp-29Ch]
  float v18; // [rsp+60h] [rbp-298h]
  float v19; // [rsp+64h] [rbp-294h]
  float v20; // [rsp+68h] [rbp-290h]
  __int64 v21; // [rsp+70h] [rbp-288h] BYREF
  __int64 v22; // [rsp+78h] [rbp-280h]
  unsigned __int64 v23; // [rsp+80h] [rbp-278h] BYREF
  __int64 v24; // [rsp+88h] [rbp-270h]
  double *v25; // [rsp+90h] [rbp-268h]
  __int64 v26; // [rsp+98h] [rbp-260h]
  __int64 v27; // [rsp+A0h] [rbp-258h]
  __int64 v28; // [rsp+A8h] [rbp-250h]
  __int64 v29; // [rsp+B0h] [rbp-248h]
  double v30; // [rsp+B8h] [rbp-240h]
  double v31; // [rsp+C0h] [rbp-238h]
  double v32; // [rsp+C8h] [rbp-230h]
  __int64 v33; // [rsp+D0h] [rbp-228h]
  __int64 v34; // [rsp+D8h] [rbp-220h]
  __int64 v35; // [rsp+E0h] [rbp-218h]
  __int64 v36; // [rsp+E8h] [rbp-210h]
  __int64 v37; // [rsp+F0h] [rbp-208h]
  __int64 (__fastcall *v38)(__int64, _BYTE *); // [rsp+F8h] [rbp-200h]
  __int64 v39; // [rsp+100h] [rbp-1F8h]
  __int64 v40; // [rsp+108h] [rbp-1F0h]
  __int64 v41; // [rsp+110h] [rbp-1E8h]
  __int64 v42; // [rsp+118h] [rbp-1E0h]
  __int64 v43; // [rsp+120h] [rbp-1D8h]
  unsigned __int64 v44; // [rsp+128h] [rbp-1D0h]
  __int64 v45; // [rsp+130h] [rbp-1C8h]
  __int64 v46; // [rsp+138h] [rbp-1C0h]
  __int64 v47; // [rsp+140h] [rbp-1B8h]
  __int64 v48; // [rsp+148h] [rbp-1B0h]
  __int64 v49; // [rsp+150h] [rbp-1A8h]
  __int64 v50; // [rsp+158h] [rbp-1A0h]
  __int64 v51; // [rsp+160h] [rbp-198h]
  __int64 v52; // [rsp+168h] [rbp-190h]
  void (__fastcall *v53)(__int64, float *, unsigned __int64, _QWORD); // [rsp+170h] [rbp-188h]
  __int64 (__fastcall *v54)(__int64, _BYTE *, __int64, _QWORD, _BYTE); // [rsp+178h] [rbp-180h]
  double v55; // [rsp+180h] [rbp-178h]
  double v56; // [rsp+188h] [rbp-170h]
  __int64 v57; // [rsp+190h] [rbp-168h]
  double v58; // [rsp+198h] [rbp-160h]
  double v59; // [rsp+1A0h] [rbp-158h]
  __int64 v60; // [rsp+1A8h] [rbp-150h]
  __int64 v61; // [rsp+1B0h] [rbp-148h]
  double v62; // [rsp+1B8h] [rbp-140h]
  __int64 v63; // [rsp+1C0h] [rbp-138h]
  double v64; // [rsp+1D0h] [rbp-128h]
  double v65; // [rsp+1D8h] [rbp-120h]
  double v66; // [rsp+1E0h] [rbp-118h]
  double v67; // [rsp+1E8h] [rbp-110h]
  double src_[4]; // [rsp+1F0h] [rbp-108h] BYREF
  _BYTE v69[8]; // [rsp+210h] [rbp-E8h] BYREF
  std::_Ref_count_base *v70; // [rsp+218h] [rbp-E0h]
  _BYTE v71[8]; // [rsp+220h] [rbp-D8h] BYREF
  double v72[4]; // [rsp+228h] [rbp-D0h] BYREF
  _BYTE dst_[24]; // [rsp+248h] [rbp-B0h] BYREF
  _BYTE v74[64]; // [rsp+260h] [rbp-98h] BYREF
  _BYTE v75[88]; // [rsp+2A0h] [rbp-58h] BYREF
  va_list va; // [rsp+318h] [rbp+20h] BYREF

  va_start(va, a3);
  v21 = 0;
  v22 = 0;
  v57 = a3 + 0x1B0;
  if ( Handle::IsValid((_QWORD *)(a3 + 0x1B0)) )
  {
    v63 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
    v23 = *(_QWORD *)(v63 + 8);
    if ( j_validateHandleAccess(&v23) )
    {
      v26 = sub_14030ECF0(&v23);
      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x58LL))(v26) )
      {
        v37 = *(_QWORD *)(a3 + 0x1B0) & 0xFFFFFFFFFFFFLL;
        v28 = sub_1462D3180(v37, (unsigned int *)(a3 + 0x1B8));
        if ( v28 )
        {
          v27 = sub_14030ECF0((__int64 *)va);
          v38 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v27 + 8LL);
          v3 = v38(v27, v71);
          v4 = (__int64 *)sub_1419E4BC0(v69, v3);
          sub_142704CD0(&v21, v4);
          if ( v70 )
            std::_Ref_count_base::_Decref(v70);
          v39 = v21;
          v40 = v21 + 0x30;
          sub_14053D1C0(v21 + 0x30, 1);
          v41 = v21;
          v42 = v21 + 0x30;
          sub_141B89FE0(v21 + 0x30, 1);
          v44 = v23;
          v43 = v21;
          *(_QWORD *)(v21 + 0x1A8) = v23;
          v45 = a3 + 0x1D8;
          v46 = a3 + 0x1D8;
          v48 = *(_QWORD *)(a3 + 0x1D8) + 0x30LL;
          v47 = v21;
          sub_14030E030(v21 + 0x1B8, v48);
          v49 = v21;
          v50 = v21 + 0x30;
          sub_14264F120(v21 + 0x30, 0);
          v24 = sub_1462D0420(*(_QWORD *)(v28 + 0x20));
          if ( !(*(unsigned __int8 (__fastcall **)(_QWORD))(**(_QWORD **)(v24 + 0x18) + 0x40LL))(*(_QWORD *)(v24 + 0x18)) )
          {
            v51 = *(_QWORD *)(v24 + 0x18);
            if ( !*(_DWORD *)(v51 + 0x124) )
            {
              v52 = *(_QWORD *)(v24 + 0x18);
              v53 = *(void (__fastcall **)(__int64, float *, unsigned __int64, _QWORD))(**(_QWORD **)(v24 + 0x18)
                                                                                      + 0x50LL);
              v53(v52, &v14, v23, 0);
              v29 = sub_14030ECF0(&v23);
              v54 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64, _QWORD, _BYTE))(*(_QWORD *)v29 + 0x1E8LL);
              v7 = (double *)v54(v29, v74, 2, 0, 0);
              v55 = v7[1] * v16 - v7[2] * v15 + v7[3] * v14 + *v7 * v17;
              v56 = v7[2] * v14 - *v7 * v16 + v7[3] * v15 + v7[1] * v17;
              v62 = *v7 * v15 - v7[1] * v14 + v7[3] * v16 + v7[2] * v17;
              v58 = v7[3] * v17 - *v7 * v14 - v7[1] * v15 - v7[2] * v16;
              v32 = v7[1] * v20 - v7[2] * v19 + v7[3] * v18;
              v31 = v7[2] * v18 - *v7 * v20 + v7[3] * v19;
              v30 = *v7 * v19 - v7[1] * v18 + v7[3] * v20;
              v8 = v30 * v7[1] - v31 * v7[2];
              v9 = (v8 + v8 + v18) * v7[7] + v7[4];
              v10 = v32 * v7[2] - v30 * *v7;
              v11 = (v10 + v10 + v19) * v7[7] + v7[5];
              v12 = v31 * *v7 - v32 * v7[1];
              v13 = (v12 + v12 + v20) * v7[7] + v7[6];
              v59 = v7[7];
              v64 = v55;
              v65 = v56;
              v66 = v62;
              v67 = v58;
              src_[0] = v9;
              src_[1] = v11;
              src_[2] = v13;
              src_[3] = v59;
              v25 = v72;
              v72[0] = v55;
              v72[1] = v56;
              v72[2] = v62;
              v72[3] = v58;
              qmemcpy(dst_, src_, sizeof(dst_));
              v33 = sub_14030ECF0(&v23);
              v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v33 + 0x648LL))(v33);
              v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x1F8LL))(v34);
              v35 = sub_14036F2B0((__int64)v75, (__int64)v72, v5);
              v60 = v21;
              v36 = v21 + 0x150;
              sub_14030DE50(v21 + 0x150, v35);
              *(_QWORD *)(v36 + 0x38) = *(_QWORD *)(v35 + 0x38);
              v61 = v21;
              *(_BYTE *)(v21 + 0x1B0) = 1;
            }
          }
        }
      }
    }
  }
  *a2 = 0;
  a2[1] = 0;
  *a2 = v21;
  a2[1] = v22;
  return a2;
}

// --- End Function: sub_142725D00 (0x142725D00) ---

// --- Function: sub_142749500 (0x142749500) ---
__int64 __fastcall sub_142749500(__int64 a1, _QWORD *a2, __int64 a3)
{
  size_t *v3; // rax
  std::shared_ptr<vraudio::MixerNode> *_Right; // rax
  unsigned int v6; // [rsp+24h] [rbp-544h]
  _QWORD *v7; // [rsp+30h] [rbp-538h]
  __int64 v8; // [rsp+38h] [rbp-530h]
  __int64 v9; // [rsp+40h] [rbp-528h]
  __int64 v10; // [rsp+48h] [rbp-520h]
  __int64 v11; // [rsp+50h] [rbp-518h]
  __int64 v12; // [rsp+80h] [rbp-4E8h]
  __int64 v13; // [rsp+88h] [rbp-4E0h]
  _QWORD *v14; // [rsp+90h] [rbp-4D8h]
  __int64 v15; // [rsp+98h] [rbp-4D0h] BYREF
  __int64 v16; // [rsp+A0h] [rbp-4C8h]
  unsigned __int8 *v17; // [rsp+A8h] [rbp-4C0h]
  __int64 (__fastcall *v18)(__int64, _BYTE *, _BYTE *, unsigned __int8 *); // [rsp+B0h] [rbp-4B8h]
  _BYTE v19[8]; // [rsp+B8h] [rbp-4B0h] BYREF
  std::_Ref_count_base *v20; // [rsp+C0h] [rbp-4A8h]
  _BYTE v21[24]; // [rsp+C8h] [rbp-4A0h] BYREF
  __int64 v22; // [rsp+E0h] [rbp-488h] BYREF
  _BYTE Parameter_[8]; // [rsp+E8h] [rbp-480h] BYREF
  __int64 v24; // [rsp+F0h] [rbp-478h] BYREF
  _BYTE v25[24]; // [rsp+F8h] [rbp-470h] BYREF
  _BYTE v26[544]; // [rsp+110h] [rbp-458h] BYREF
  _BYTE v27[544]; // [rsp+330h] [rbp-238h] BYREF

  v6 = sub_14053C290(a1, a2, a3);
  if ( v6 )
  {
    sub_14030A5D0((__int64)v21, "InPlaceConversationHandler");
    v8 = __crt_win32_buffer<char,__crt_win32_buffer_public_dynamic_resizing>::capacity(a3);
    v7 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0x18LL))(v8);
    v12 = *sub_1402E2EC0((__int64)v7, &v22);
    v13 = *sub_14277CFE0(v7, (Parameter *)Parameter_);
    sub_1426F50A0(&v15, v13, v12, (__int64)v21);
    v14 = sub_1402E2EC0((__int64)v7, &v24);
    if ( v15 == *v14 )
    {
      sub_1403090C0((__int64)v21);
      return 0;
    }
    v16 = sub_1402A2950((__int64)v27);
    v3 = (size_t *)sub_1402A3190(v16, "OpenForConversation Created Task 001");
    sub_1402A2880((__int64)v26, v3);
    sub_1402A2B40((__int64)v27);
    v9 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0x90);
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x90LL))(v9);
    v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
    v18 = *(__int64 (__fastcall **)(__int64, _BYTE *, _BYTE *, unsigned __int8 *))(*(_QWORD *)v11 + 0x10LL);
    v17 = AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)v26);
    sub_14030A5D0((__int64)v25, "InPlaceConversationHandler");
    _Right = (std::shared_ptr<vraudio::MixerNode> *)v18(v11, v19, v25, v17);
    std::shared_ptr<vraudio::MixerNode>::operator=((std::shared_ptr<vraudio::MixerNode> *)(a1 + 0x158), _Right);
    if ( v20 )
      std::_Ref_count_base::_Decref(v20);
    sub_1403090C0((__int64)v25);
    sub_1402A2B40((__int64)v26);
    sub_1403090C0((__int64)v21);
  }
  return v6;
}

// --- End Function: sub_142749500 (0x142749500) ---

// --- Function: sub_14275B670 (0x14275B670) ---
__int64 __fastcall sub_14275B670(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  char v6; // [rsp+20h] [rbp-238h]
  __int64 v7; // [rsp+28h] [rbp-230h]
  __int64 v8; // [rsp+30h] [rbp-228h] BYREF
  std::_Ref_count_base *v9; // [rsp+38h] [rbp-220h]
  BOOL v10; // [rsp+40h] [rbp-218h]
  int v11; // [rsp+44h] [rbp-214h]
  int v12; // [rsp+48h] [rbp-210h]
  __int64 v13; // [rsp+50h] [rbp-208h]
  __int64 v14; // [rsp+58h] [rbp-200h]
  __int64 v15; // [rsp+60h] [rbp-1F8h]
  __int64 v16; // [rsp+68h] [rbp-1F0h]
  __int64 v17; // [rsp+70h] [rbp-1E8h]
  __int64 v18; // [rsp+78h] [rbp-1E0h]
  __int64 v19; // [rsp+80h] [rbp-1D8h]
  __int64 v20; // [rsp+88h] [rbp-1D0h]
  __int64 v21; // [rsp+90h] [rbp-1C8h]
  __int64 v22; // [rsp+98h] [rbp-1C0h]
  __int64 v23; // [rsp+A0h] [rbp-1B8h]
  __int64 v24; // [rsp+A8h] [rbp-1B0h]
  __int64 v25; // [rsp+B0h] [rbp-1A8h]
  __int64 v26; // [rsp+B8h] [rbp-1A0h]
  __int64 v27; // [rsp+C0h] [rbp-198h]
  __int64 v28; // [rsp+C8h] [rbp-190h]
  __int64 v29; // [rsp+D0h] [rbp-188h]
  __int64 v30; // [rsp+D8h] [rbp-180h]
  __int64 v31; // [rsp+E0h] [rbp-178h]
  __int64 v32; // [rsp+E8h] [rbp-170h]
  _QWORD *v33; // [rsp+F0h] [rbp-168h]
  _QWORD *v34; // [rsp+F8h] [rbp-160h]
  __int64 (__fastcall *v35)(__int64, _BYTE *, _QWORD *, __int64); // [rsp+100h] [rbp-158h]
  _BYTE v36[8]; // [rsp+108h] [rbp-150h] BYREF
  _QWORD v37[5]; // [rsp+110h] [rbp-148h] BYREF
  _BYTE dst_[24]; // [rsp+138h] [rbp-120h] BYREF
  _QWORD v39[2]; // [rsp+150h] [rbp-108h] BYREF
  _BYTE v40[184]; // [rsp+160h] [rbp-F8h] BYREF
  int v41; // [rsp+218h] [rbp-40h]

  v7 = *(_QWORD *)(a2 + 0x58);
  v6 = 0;
  sub_1419FDAD0(a1, v37, a1 + 0x1D0, a2);
  v10 = v37[0] != 0;
  if ( v37[0] )
  {
    v15 = v37[0];
    v6 = *(_BYTE *)v37[0];
  }
  sub_1419E4BC0(&v8, a2);
  v16 = v8;
  sub_1402B4740(v8 + 0x150, a3);
  v17 = v8;
  v18 = v8 + 0x30;
  sub_141B8B360(v8 + 0x30, v6);
  v19 = v8;
  *(_BYTE *)(v8 + 0x1E1) = 0;
  v20 = v8;
  v21 = v8 + 0x30;
  sub_14053D1C0(v8 + 0x30, 1);
  v22 = v8;
  v23 = v8 + 0x30;
  sub_141B89FE0(v8 + 0x30, *(_BYTE *)(v7 + 0x1DA));
  v24 = v8;
  *(_QWORD *)(v8 + 0x1A8) = a5;
  qmemcpy(dst_, (const void *)(v7 + 0x1A8), sizeof(dst_));
  v25 = v8;
  qmemcpy((void *)(v8 + 0x190), dst_, 0x18u);
  v26 = v8;
  sub_14030E030(v8 + 0x1B8, v7 + 0x180);
  v11 = *(_DWORD *)(v7 + 0x1C0);
  v27 = v8;
  *(_DWORD *)(v8 + 0x1D4) = v11;
  v12 = *(_DWORD *)(v7 + 0x1C4);
  v28 = v8;
  *(_DWORD *)(v8 + 0x1D0) = v12;
  sub_141A556E0((__int64)v40);
  sub_1402B4740((__int64)v40, a3);
  v41 = a4;
  v29 = v8;
  v30 = v8 + 0x30;
  sub_141B82BC0(v8 + 0x30, v40);
  v31 = v8;
  v32 = v8 + 0x30;
  sub_141B8B3E0(v8 + 0x30, 0);
  v14 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0x90);
  v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x80LL))(v14);
  v35 = *(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD *, __int64))(*(_QWORD *)v13 + 0x18LL);
  v33 = v39;
  v34 = sub_140336EC0(v39, &v8);
  *(_DWORD *)(v7 + 0x150) = *(_DWORD *)v35(v13, v36, v34, v7 + 0x88);
  sub_141A617B0((__int64)v40);
  if ( v9 )
    std::_Ref_count_base::_Decref(v9);
  return sub_140370C50((__int64)v37);
}

// --- End Function: sub_14275B670 (0x14275B670) ---

// --- Function: sub_1429820B0 (0x1429820B0) ---
_QWORD *__fastcall sub_1429820B0(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1429821E0(a1, &v4);
  return a1;
}

// --- End Function: sub_1429820B0 (0x1429820B0) ---

// --- Function: sub_1429821E0 (0x1429821E0) ---
__int64 (__fastcall **__fastcall sub_1429821E0(__int64 (__fastcall **a1)(__int64, char), _QWORD *a2))(__int64, char)
{
  __int64 (__fastcall **result)(__int64, char); // rax
  __int64 (__fastcall *v3)(__int64, char); // [rsp+20h] [rbp-18h]
  __int64 (__fastcall *v4)(__int64, char); // [rsp+28h] [rbp-10h]

  sub_1402A2AD0(a1);
  v3 = (__int64 (__fastcall *)(__int64, char))allocWithProfilerInfo_w(8u);
  if ( v3 )
  {
    *(_QWORD *)v3 = *a2;
    v4 = v3;
  }
  else
  {
    v4 = 0;
  }
  a1[2] = v4;
  *a1 = sub_14298E370;
  result = a1;
  a1[1] = (__int64 (__fastcall *)(__int64, char))sub_14298E660;
  return result;
}

// --- End Function: sub_1429821E0 (0x1429821E0) ---

// --- Function: sub_142988630 (0x142988630) ---
_QWORD *__fastcall sub_142988630(_QWORD *a1)
{
  sub_14053A900((__int64)a1);
  *a1 = off_148684208;
  sub_1403701E0((__int64)(a1 + 0x21), "Entity", 1);
  sub_141369EA0((__int64)(a1 + 0x25), a1 + 0x1B, (__int64)(a1 + 0x21));
  sub_1403701E0((__int64)(a1 + 0x26), "Destination", 1);
  sub_141369EA0((__int64)(a1 + 0x2A), a1 + 0x1B, (__int64)(a1 + 0x26));
  sub_1403701E0((__int64)(a1 + 0x2B), "Position", 1);
  sub_141369EA0((__int64)(a1 + 0x2F), a1 + 0x1B, (__int64)(a1 + 0x2B));
  sub_1403701E0((__int64)(a1 + 0x30), "FragmentID", 1);
  sub_141369EA0((__int64)(a1 + 0x34), a1 + 0x1B, (__int64)(a1 + 0x30));
  sub_1403701E0((__int64)(a1 + 0x35), "FragmentTags", 1);
  sub_141369EA0((__int64)(a1 + 0x39), a1 + 0x1B, (__int64)(a1 + 0x35));
  return a1;
}

// --- End Function: sub_142988630 (0x142988630) ---

// --- Function: sub_14298E370 (0x14298E370) ---
__int64 __fastcall sub_14298E370(__int64 a1, char a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+0h] [rbp-18h]

  v3 = *(_QWORD *)(a1 + 0x10);
  *(_BYTE *)(*(_QWORD *)v3 + 2LL) = a2;
  result = *(_QWORD *)v3;
  *(_BYTE *)(*(_QWORD *)v3 + 1LL) = 0;
  return result;
}

// --- End Function: sub_14298E370 (0x14298E370) ---

// --- Function: sub_14298E660 (0x14298E660) ---
_QWORD *__fastcall sub_14298E660(int n2, __int64 a2, _QWORD *a3)
{
  _QWORD *result; // rax
  _QWORD *v4; // [rsp+50h] [rbp-38h]
  _QWORD *v5; // [rsp+58h] [rbp-30h]
  _QWORD *v6; // [rsp+60h] [rbp-28h]

  if ( n2 )
  {
    if ( n2 == 1 )
    {
      result = a3;
      if ( *a3 )
      {
        if ( a3[1] == 1 )
        {
          *(_QWORD *)(a2 + 0x10) = 0;
          *(_QWORD *)a2 = *a3;
          *(_QWORD *)(a2 + 8) = 1;
        }
        else
        {
          *(_QWORD *)(a2 + 0x10) = a3[2];
          *(_QWORD *)a2 = *a3;
          *(_QWORD *)(a2 + 8) = a3[1];
        }
        a3[2] = 0;
        *a3 = 0;
        result = a3;
        a3[1] = 0;
      }
    }
    else if ( n2 == 2 )
    {
      sub_1402A3D30(*(const void **)(a2 + 0x10));
      *(_QWORD *)(a2 + 0x10) = 0;
      *(_QWORD *)a2 = 0;
      result = (_QWORD *)a2;
      *(_QWORD *)(a2 + 8) = 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v6 = (_QWORD *)a3[2];
    result = a3;
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        *(_QWORD *)(a2 + 0x10) = 0;
        *(_QWORD *)a2 = *a3;
        result = (_QWORD *)a2;
        *(_QWORD *)(a2 + 8) = 1;
      }
      else
      {
        v4 = (_QWORD *)allocWithProfilerInfo_w(8u);
        if ( v4 )
        {
          *v4 = *v6;
          v5 = v4;
        }
        else
        {
          v5 = 0;
        }
        *(_QWORD *)(a2 + 0x10) = v5;
        *(_QWORD *)a2 = sub_14298E370;
        result = (_QWORD *)a2;
        *(_QWORD *)(a2 + 8) = sub_14298E660;
      }
    }
  }
  return result;
}

// --- End Function: sub_14298E660 (0x14298E660) ---

// --- Function: sub_1429912C0 (0x1429912C0) ---
_QWORD *__fastcall sub_1429912C0(__int64 a1, _QWORD *a2)
{
  const char *v2; // rax
  __int64 v4; // [rsp+28h] [rbp-70h]
  _QWORD *buf; // [rsp+30h] [rbp-68h]
  __int64 v6; // [rsp+68h] [rbp-30h]
  _QWORD *v7; // [rsp+70h] [rbp-28h]

  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 0x28) + 0x38LL))(*(_QWORD *)(a1 + 0x28), 0x1D0);
  if ( !v4 )
  {
    v2 = (const char *)sub_1402A2660(a1 + 8);
    LogFatalError("Could not allocate the memory needed for a '%s' subsumption task.", v2);
  }
  v6 = *(_QWORD *)(a1 + 0x28);
  buf = (_QWORD *)sub_1402A2B80(0x1D0, v4);
  memset(buf, 0, 0x1D0u);
  v7 = sub_142988630(buf);
  *a2 = 0;
  a2[1] = 0;
  sub_1426F26B0(a2, v7, v6);
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 8LL))(*a2, *(unsigned __int8 *)(a1 + 0x9D));
  return a2;
}

// --- End Function: sub_1429912C0 (0x1429912C0) ---

// --- Function: sub_14299C5A0 (0x14299C5A0) ---
__int64 __fastcall sub_14299C5A0(__int64 a1, __int64 a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-1F8h]
  _QWORD buf_[58]; // [rsp+30h] [rbp-1E8h] BYREF

  memset(buf_, 0, sizeof(buf_));
  v3 = sub_142988630(buf_);
  sub_1413773B0(v3, a2);
  sub_142703060((__int64)buf_);
  return a2;
}

// --- End Function: sub_14299C5A0 (0x14299C5A0) ---

// --- Function: sub_14299CEA0 (0x14299CEA0) ---
__int64 __fastcall sub_14299CEA0(_DWORD *a1, __int64 a2)
{
  unsigned __int8 *v3; // rax
  int v4; // [rsp+20h] [rbp-6E8h]
  __int64 v5; // [rsp+30h] [rbp-6D8h]
  float v6; // [rsp+38h] [rbp-6D0h] BYREF
  float v7; // [rsp+3Ch] [rbp-6CCh]
  float v8; // [rsp+40h] [rbp-6C8h]
  float v9; // [rsp+44h] [rbp-6C4h]
  float v10; // [rsp+48h] [rbp-6C0h]
  float v11; // [rsp+4Ch] [rbp-6BCh]
  float v12; // [rsp+50h] [rbp-6B8h]
  double v13; // [rsp+58h] [rbp-6B0h]
  double v14; // [rsp+60h] [rbp-6A8h]
  double v15; // [rsp+68h] [rbp-6A0h]
  char v16; // [rsp+70h] [rbp-698h]
  BOOL v17; // [rsp+74h] [rbp-694h]
  BOOL v18; // [rsp+78h] [rbp-690h]
  BOOL v19; // [rsp+7Ch] [rbp-68Ch]
  BOOL v21; // [rsp+84h] [rbp-684h]
  BOOL v22; // [rsp+88h] [rbp-680h]
  BOOL v23; // [rsp+8Ch] [rbp-67Ch]
  double *v24; // [rsp+90h] [rbp-678h]
  double *v25; // [rsp+98h] [rbp-670h]
  double *v26; // [rsp+A0h] [rbp-668h]
  double *v27; // [rsp+A8h] [rbp-660h]
  double v28; // [rsp+B0h] [rbp-658h] BYREF
  double v29; // [rsp+B8h] [rbp-650h]
  double v30; // [rsp+C0h] [rbp-648h]
  double v31; // [rsp+C8h] [rbp-640h]
  double v32; // [rsp+D0h] [rbp-638h]
  double v33; // [rsp+D8h] [rbp-630h]
  double v34; // [rsp+E0h] [rbp-628h]
  double v35; // [rsp+E8h] [rbp-620h]
  unsigned __int64 v36[2]; // [rsp+F0h] [rbp-618h] BYREF
  __int64 v37; // [rsp+100h] [rbp-608h]
  __int64 v38; // [rsp+108h] [rbp-600h]
  __int64 v39; // [rsp+110h] [rbp-5F8h]
  __int64 v40; // [rsp+118h] [rbp-5F0h]
  __int64 v41; // [rsp+120h] [rbp-5E8h]
  double *v42; // [rsp+128h] [rbp-5E0h]
  __int64 v43; // [rsp+130h] [rbp-5D8h]
  _QWORD *v44; // [rsp+138h] [rbp-5D0h]
  __int64 v45; // [rsp+140h] [rbp-5C8h]
  __int64 v46; // [rsp+148h] [rbp-5C0h]
  double v47; // [rsp+150h] [rbp-5B8h]
  double v48; // [rsp+158h] [rbp-5B0h]
  double v49; // [rsp+160h] [rbp-5A8h]
  __int64 v50; // [rsp+168h] [rbp-5A0h]
  __int64 v51; // [rsp+170h] [rbp-598h] BYREF
  __int64 v52; // [rsp+178h] [rbp-590h]
  __int64 v53; // [rsp+180h] [rbp-588h]
  __int64 v54; // [rsp+188h] [rbp-580h] BYREF
  _QWORD v55[5]; // [rsp+190h] [rbp-578h] BYREF
  _QWORD v56[5]; // [rsp+1B8h] [rbp-550h] BYREF
  __int64 v57[5]; // [rsp+1E0h] [rbp-528h] BYREF
  __int64 (__fastcall *v58)(__int64, _BYTE *, __int64); // [rsp+208h] [rbp-500h]
  __int64 v59; // [rsp+210h] [rbp-4F8h]
  __int64 *v60; // [rsp+218h] [rbp-4F0h]
  __int64 v61; // [rsp+220h] [rbp-4E8h]
  __int64 v62; // [rsp+228h] [rbp-4E0h]
  __int64 v63; // [rsp+230h] [rbp-4D8h]
  __int64 v64; // [rsp+238h] [rbp-4D0h]
  __int64 *v65; // [rsp+240h] [rbp-4C8h]
  __int64 v66; // [rsp+248h] [rbp-4C0h]
  void (__fastcall *v67)(__int64, unsigned __int64 *, __int64); // [rsp+250h] [rbp-4B8h]
  __int64 (__fastcall *v68)(__int64, _BYTE *, __int64, _QWORD, char); // [rsp+258h] [rbp-4B0h]
  __int64 (__fastcall *v69)(__int64, _BYTE *); // [rsp+260h] [rbp-4A8h]
  __int64 v70; // [rsp+268h] [rbp-4A0h]
  void (__fastcall *v71)(__int64, double *, __int64, _QWORD, int); // [rsp+270h] [rbp-498h]
  double v72; // [rsp+278h] [rbp-490h]
  double v73; // [rsp+280h] [rbp-488h]
  double v74; // [rsp+288h] [rbp-480h]
  double v75; // [rsp+290h] [rbp-478h]
  double v76; // [rsp+298h] [rbp-470h]
  __int64 (__fastcall *v77)(__int64, _BYTE *); // [rsp+2A0h] [rbp-468h]
  __int64 v78; // [rsp+2A8h] [rbp-460h]
  __int64 *v79; // [rsp+2B0h] [rbp-458h]
  __int64 v80; // [rsp+2B8h] [rbp-450h]
  __int64 v81; // [rsp+2C0h] [rbp-448h]
  __int64 v82; // [rsp+2C8h] [rbp-440h]
  void (__fastcall *v83)(__int64, __int64, _QWORD *); // [rsp+2D0h] [rbp-438h]
  __int64 v84; // [rsp+2D8h] [rbp-430h]
  __int64 v85; // [rsp+2E0h] [rbp-428h]
  __int64 v86; // [rsp+2E8h] [rbp-420h]
  __int64 *v87; // [rsp+2F0h] [rbp-418h]
  __int64 v88; // [rsp+2F8h] [rbp-410h]
  _QWORD v89[5]; // [rsp+300h] [rbp-408h] BYREF
  _QWORD v90[5]; // [rsp+328h] [rbp-3E0h] BYREF
  double v91[4]; // [rsp+350h] [rbp-3B8h] BYREF
  double src_[4]; // [rsp+370h] [rbp-398h] BYREF
  _QWORD v93[3]; // [rsp+390h] [rbp-378h] BYREF
  _BYTE v94[8]; // [rsp+3A8h] [rbp-360h] BYREF
  __int64 v95; // [rsp+3B0h] [rbp-358h] BYREF
  _BYTE v96[8]; // [rsp+3B8h] [rbp-350h] BYREF
  _BYTE v97[8]; // [rsp+3C0h] [rbp-348h] BYREF
  __int64 v98; // [rsp+3C8h] [rbp-340h] BYREF
  double v99[4]; // [rsp+3D0h] [rbp-338h] BYREF
  _BYTE dst_[24]; // [rsp+3F0h] [rbp-318h] BYREF
  double v101[4]; // [rsp+408h] [rbp-300h] BYREF
  _BYTE dst__1[24]; // [rsp+428h] [rbp-2E0h] BYREF
  _BYTE v103[64]; // [rsp+440h] [rbp-2C8h] BYREF
  _QWORD v104[8]; // [rsp+480h] [rbp-288h] BYREF
  _BYTE v105[544]; // [rsp+4C0h] [rbp-248h] BYREF

  v16 = 0;
  v5 = *(_QWORD *)(a2 + 0x58);
  sub_141361F20((__int64)a1, v55, a1 + 0x42, a2);
  sub_141361F20((__int64)a1, v56, a1 + 0x4C, a2);
  sub_141394B60((__int64)a1, v57, a1 + 0x56, a2);
  v17 = v55[0] != 0;
  if ( !v55[0] || (v82 = v55[0], v36[1] = v55[0], v18 = *(_QWORD *)v55[0] == *(_QWORD *)(v55[0] + 8LL)) )
  {
    sub_14053D5C0((__int64)a1, a2, 2u, "Supplied Object is invalid or empty.");
    *(_BYTE *)v5 = 1;
    sub_140370C50((__int64)v57);
    sub_140370C50((__int64)v56);
    return sub_140370C50((__int64)v55);
  }
  v37 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0xA0);
  v58 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)v37 + 0x120LL);
  if ( !v55[0] )
    LogFatalError("Something is trying to access an invalid variable value");
  v84 = v55[0];
  v85 = v55[0];
  v87 = *(__int64 **)v55[0];
  v88 = *v87;
  *(_QWORD *)(v5 + 8) = *(_QWORD *)v58(v37, v94, v88);
  if ( validateHandleAccess((unsigned __int64 *)(v5 + 8)) )
  {
    v53 = sub_14030ECF0((_QWORD *)(v5 + 8));
    if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v53 + 0x50LL))(v53) )
    {
      sub_14053D5C0((__int64)a1, a2, 2u, "Supplied Entity is not fully initialized");
      *(_BYTE *)v5 = 1;
      sub_140370C50((__int64)v57);
      sub_140370C50((__int64)v56);
      return sub_140370C50((__int64)v55);
    }
    v59 = sub_14030ECF0((_QWORD *)(v5 + 8));
    v60 = sub_1425D62E0(v59, &v95);
    v61 = *v60;
    v54 = v61;
    if ( is_valid_handle_typeA(&v54) )
    {
      v38 = v54 & 0xFFFFFFFFFFFFLL;
      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(v54 & 0xFFFFFFFFFFFFLL) + 0x650LL))(v54 & 0xFFFFFFFFFFFFLL) )
      {
        sub_14053D5C0(
          (__int64)a1,
          a2,
          2u,
          "NPCs can't be teleported using this task. Use a RequestAssignmentMoveTeleport instead");
        *(_BYTE *)v5 = 1;
        sub_140370C50((__int64)v57);
        sub_140370C50((__int64)v56);
        return sub_140370C50((__int64)v55);
      }
    }
    sub_1419FAC20((__int64)a1, v90, a1 + 0x60, a2);
    sub_1419FCA10((__int64)a1, v89, a1 + 0x6A, a2);
    v19 = v56[0] != 0;
    if ( v56[0] )
    {
      v62 = v56[0];
      v39 = v56[0];
      if ( *(_QWORD *)v56[0] == *(_QWORD *)(v56[0] + 8LL) )
      {
        sub_14053D5C0((__int64)a1, a2, 2u, "Supplied Destination is empty.");
        *(_BYTE *)v5 = 1;
        sub_140370C50((__int64)v89);
        sub_140370C50((__int64)v90);
        sub_140370C50((__int64)v57);
        sub_140370C50((__int64)v56);
        return sub_140370C50((__int64)v55);
      }
      v40 = *(_QWORD *)(identity_int64((__int64)&qword_149B4FBE0) + 0xA0);
      v67 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v40 + 0x120LL);
      if ( !v56[0] )
        LogFatalError("Something is trying to access an invalid variable value");
      v63 = v56[0];
      v64 = v56[0];
      v65 = *(__int64 **)v56[0];
      v66 = *v65;
      v67(v40, v36, v66);
      if ( !validateHandleAccess(v36) )
      {
        sub_14053D5C0((__int64)a1, a2, 2u, "Supplied Destination is not a valid entity.");
        *(_BYTE *)v5 = 1;
        sub_140370C50((__int64)v89);
        sub_140370C50((__int64)v90);
        sub_140370C50((__int64)v57);
        sub_140370C50((__int64)v56);
        return sub_140370C50((__int64)v55);
      }
      v41 = sub_14030ECF0(v36);
      v68 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64, _QWORD, char))(*(_QWORD *)v41 + 0x1E8LL);
      v42 = (double *)v68(v41, v103, 2, 0, 1);
      v24 = v99;
      v25 = v42;
      v99[3] = v42[3];
      v99[0] = *v42;
      v99[1] = v42[1];
      v99[2] = v42[2];
      qmemcpy(dst_, v42 + 4, sizeof(dst_));
      sub_14030DE50(v5 + 0x10, (__int64)v99);
      v43 = sub_14030ECF0(v36);
      v69 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v43 + 0x660LL);
      *(_QWORD *)(v5 + 0x48) = *(_QWORD *)v69(v43, v96);
    }
    else
    {
      v21 = v57[0] != 0;
      if ( v57[0] )
      {
        v70 = v57[0];
        v44 = sub_14036F3B0(v104, v57[0]);
        v45 = v5 + 0x10;
        sub_14030DE50(v5 + 0x10, (__int64)v44);
        *(_QWORD *)(v5 + 0x48) = v44[7];
      }
      else
      {
        v22 = v90[0] != 0;
        if ( !v90[0] || (v23 = v89[0] != 0, !v89[0]) )
        {
          sub_14053D5C0(
            (__int64)a1,
            a2,
            2u,
            "Supplied Destination, Position or FragmentID/Tag variables are invalid or empty.");
          *(_BYTE *)v5 = 1;
          sub_140370C50((__int64)v89);
          sub_140370C50((__int64)v90);
          sub_140370C50((__int64)v57);
          sub_140370C50((__int64)v56);
          return sub_140370C50((__int64)v55);
        }
        v9 = 1.0;
        v6 = 0.0;
        v7 = 0.0;
        v8 = 0.0;
        v10 = 0.0;
        v11 = 0.0;
        v12 = 0.0;
        sub_1402A2950((__int64)v105);
        if ( !(unsigned __int8)sub_142DF54B0(
                                 *(_QWORD *)(v5 + 8),
                                 (unsigned int)v90,
                                 (unsigned int)v89,
                                 (unsigned int)&v6,
                                 (__int64)v105) )
        {
          v3 = AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)v105);
          sub_14053D5C0((__int64)a1, a2, 2u, (const char *)&Format_, v3);
          *(_BYTE *)v5 = 1;
          sub_1402A2B40((__int64)v105);
          sub_140370C50((__int64)v89);
          sub_140370C50((__int64)v90);
          sub_140370C50((__int64)v57);
          sub_140370C50((__int64)v56);
          return sub_140370C50((__int64)v55);
        }
        v46 = sub_14030ECF0((_QWORD *)(v5 + 8));
        v71 = *(void (__fastcall **)(__int64, double *, __int64, _QWORD, int))(*(_QWORD *)v46 + 0x1E8LL);
        LOBYTE(v4) = 0;
        v71(v46, &v28, 2, 0, v4);
        v72 = v29 * v8 - v30 * v7 + v31 * v6 + v28 * v9;
        v73 = v30 * v6 - v28 * v8 + v31 * v7 + v29 * v9;
        v74 = v28 * v7 - v29 * v6 + v31 * v8 + v30 * v9;
        v75 = v31 * v9 - v28 * v6 - v29 * v7 - v30 * v8;
        v49 = v29 * v12 - v30 * v11 + v31 * v10;
        v48 = v30 * v10 - v28 * v12 + v31 * v11;
        v47 = v28 * v11 - v29 * v10 + v31 * v12;
        v14 = (v47 * v29 - v48 * v30 + v47 * v29 - v48 * v30 + v10) * v35 + v32;
        v13 = (v49 * v30 - v47 * v28 + v49 * v30 - v47 * v28 + v11) * v35 + v33;
        v15 = v48 * v28 - v49 * v29;
        v15 = v15 + v15 + v12;
        v15 = v15 * v35;
        v15 = v15 + v34;
        v76 = v35;
        v91[0] = v72;
        v91[1] = v73;
        v91[2] = v74;
        v91[3] = v75;
        src_[0] = v14;
        src_[1] = v13;
        src_[2] = v15;
        src_[3] = v35;
        v26 = v101;
        v27 = v91;
        v101[3] = v75;
        v101[0] = v72;
        v101[1] = v73;
        v101[2] = v74;
        qmemcpy(dst__1, src_, sizeof(dst__1));
        sub_14030DE50(v5 + 0x10, (__int64)v101);
        v50 = sub_14030ECF0((_QWORD *)(v5 + 8));
        v77 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v50 + 0x660LL);
        *(_QWORD *)(v5 + 0x48) = *(_QWORD *)v77(v50, v97);
        sub_1402A2B40((__int64)v105);
      }
    }
    v78 = sub_14030ECF0((_QWORD *)(v5 + 8));
    v79 = sub_141872140(v78, &v98);
    v80 = *v79;
    v51 = v80;
    if ( is_valid_handle_typeA(&v51) )
    {
      *(_BYTE *)(v5 + 1) = 1;
      v52 = v51 & 0xFFFFFFFFFFFFLL;
      v83 = *(void (__fastcall **)(__int64, __int64, _QWORD *))(*(_QWORD *)(v51 & 0xFFFFFFFFFFFFLL) + 0x5B0LL);
      v81 = v5;
      v86 = v5;
      sub_1429820B0(v93, v5);
      v83(v52, v5 + 0x10, v93);
      sub_1402A2AD0(v93);
    }
    else
    {
      *(_BYTE *)(v5 + 2) = 0;
    }
    sub_140370C50((__int64)v89);
    sub_140370C50((__int64)v90);
  }
  else
  {
    sub_14053D5C0((__int64)a1, a2, 2u, "Supplied Object is not a valid entity.");
    *(_BYTE *)v5 = 1;
  }
  sub_140370C50((__int64)v57);
  sub_140370C50((__int64)v56);
  return sub_140370C50((__int64)v55);
}

// --- End Function: sub_14299CEA0 (0x14299CEA0) ---

// --- Function: sub_1429AA610 (0x1429AA610) ---
__int64 __fastcall sub_1429AA610(__int64 a1, __int64 a2, __int64 a3)
{
  size_t *v4; // rax
  _BYTE v10[8]; // [rsp+50h] [rbp-AC8h] BYREF
  __int64 v11; // [rsp+58h] [rbp-AC0h]
  char v12; // [rsp+60h] [rbp-AB8h]
  __int64 v13; // [rsp+68h] [rbp-AB0h]
  __int64 v14; // [rsp+70h] [rbp-AA8h]
  __int64 v15; // [rsp+78h] [rbp-AA0h] BYREF
  void *v16; // [rsp+80h] [rbp-A98h] BYREF
  __int64 v17; // [rsp+88h] [rbp-A90h]
  float v18[3]; // [rsp+90h] [rbp-A88h] BYREF
  float v19[5]; // [rsp+9Ch] [rbp-A7Ch] BYREF
  double v20; // [rsp+B0h] [rbp-A68h] BYREF
  double v21; // [rsp+B8h] [rbp-A60h]
  double v22; // [rsp+C0h] [rbp-A58h]
  double v23; // [rsp+C8h] [rbp-A50h]
  double v24; // [rsp+D0h] [rbp-A48h]
  double v25; // [rsp+D8h] [rbp-A40h]
  double v26; // [rsp+E0h] [rbp-A38h]
  _BYTE *v27; // [rsp+E8h] [rbp-A30h]
  _BYTE *v28; // [rsp+F0h] [rbp-A28h]
  size_t *v29; // [rsp+F8h] [rbp-A20h]
  __int64 v30; // [rsp+108h] [rbp-A10h]
  __int64 *v31; // [rsp+110h] [rbp-A08h]
  __int64 v32; // [rsp+118h] [rbp-A00h]
  __int64 v33; // [rsp+120h] [rbp-9F8h]
  float *v34; // [rsp+128h] [rbp-9F0h]
  __int64 v35; // [rsp+130h] [rbp-9E8h]
  __int64 *v36; // [rsp+138h] [rbp-9E0h]
  __int64 v37; // [rsp+140h] [rbp-9D8h]
  __int64 v38; // [rsp+148h] [rbp-9D0h]
  void (__fastcall *v39)(__int64, double *, _QWORD, __int64, char, _QWORD); // [rsp+150h] [rbp-9C8h]
  _BYTE *v40; // [rsp+158h] [rbp-9C0h]
  size_t *v41; // [rsp+160h] [rbp-9B8h]
  __int64 v42; // [rsp+168h] [rbp-9B0h]
  _BYTE *v43; // [rsp+170h] [rbp-9A8h]
  size_t *v44; // [rsp+178h] [rbp-9A0h]
  _QWORD v45[3]; // [rsp+188h] [rbp-990h] BYREF
  _QWORD v46[8]; // [rsp+1A0h] [rbp-978h] BYREF
  double v47[8]; // [rsp+1E0h] [rbp-938h] BYREF
  __int64 v48; // [rsp+220h] [rbp-8F8h] BYREF
  __int64 v49[16]; // [rsp+228h] [rbp-8F0h] BYREF
  _BYTE v50[536]; // [rsp+2A8h] [rbp-870h] BYREF
  _BYTE v51[536]; // [rsp+4C0h] [rbp-658h] BYREF
  _BYTE v52[536]; // [rsp+6D8h] [rbp-440h] BYREF
  _BYTE v53[552]; // [rsp+8F0h] [rbp-228h] BYREF

  v12 = 0;
  v11 = *(_QWORD *)(a3 + 0x58);
  if ( *(_BYTE *)v11 )
  {
    v43 = v50;
    v44 = (size_t *)sub_1402A28C0((__int64)v50, &byte_14819E9C2);
    sub_14053A870(a2, 2, *(_QWORD *)(a1 + 0x98), 2, v44);
    return a2;
  }
  else if ( *(_BYTE *)(v11 + 1) )
  {
    v27 = v51;
    v4 = (size_t *)sub_1402A28C0((__int64)v51, &byte_14819E9C2);
    sub_14053A870(a2, 0, 0, 2, v4);
    return a2;
  }
  else if ( *(_BYTE *)(v11 + 2) )
  {
    v28 = v52;
    v29 = (size_t *)sub_1402A28C0((__int64)v52, "Couldn't teleport entity because the destination is obstructed");
    sub_14053A870(a2, 2, *(_QWORD *)(a1 + 0x98), 2, v29);
    return a2;
  }
  else
  {
    v30 = sub_14030ECF0((_QWORD *)(v11 + 8));
    v31 = sub_1425D62E0(v30, &v48);
    v32 = *v31;
    v15 = v32;
    if ( is_valid_handle_typeA(&v15) )
    {
      v33 = v15 & 0xFFFFFFFFFFFFLL;
      v37 = sub_1465EEBE0(v15 & 0xFFFFFFFFFFFFLL);
      memset(v45, 0, sizeof(v45));
      CreateStringObjectFromString(&v16, "Subsumption::TeleportEntity");
      v18[2] = 0.0;
      v18[1] = 0.0;
      _XMM0 = 0;
      v18[0] = 0.0;
      v14 = v11 + 0x10;
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+18h] }
      v19[3] = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax] }
      v19[0] = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+8] }
      v19[1] = *(float *)&_XMM0;
      __asm { vcvtsd2ss xmm0, xmm0, qword ptr [rax+10h] }
      v19[2] = *(float *)&_XMM0;
      v34 = v19;
      v13 = v11 + 0x10;
      v46[0] = *(_QWORD *)(v11 + 0x10);
      v46[1] = *(_QWORD *)(v11 + 0x18);
      v46[2] = *(_QWORD *)(v11 + 0x20);
      v46[3] = *(_QWORD *)(v11 + 0x28);
      v46[4] = *(_QWORD *)(v11 + 0x30);
      v46[5] = *(_QWORD *)(v11 + 0x38);
      v46[6] = *(_QWORD *)(v11 + 0x40);
      *(double *)&v46[7] = 1.0;
      v35 = *(_QWORD *)(v11 + 0x48);
      v36 = sub_1412A8110(v49, v35, (__int64)v46, v19, (__int64)v18, 0, (int)&v16, (int)v45, 0);
      sub_145AEF8F0(v37, v36);
      sub_140370D10(&v16);
      sub_1402A2AD0(v45);
    }
    else
    {
      sub_1412A83D0((__int64)v10);
      v23 = 1.0;
      v20 = 0.0;
      v21 = 0.0;
      v22 = 0.0;
      v24 = 0.0;
      v25 = 0.0;
      v26 = 0.0;
      v38 = v11 + 0x10;
      sub_1403B9CB0(v11 + 0x10, (__int64)&v20);
      v17 = sub_14030ECF0((_QWORD *)(v11 + 8));
      v39 = *(void (__fastcall **)(__int64, double *, _QWORD, __int64, char, _QWORD))(*(_QWORD *)v17 + 0x1D8LL);
      v47[0] = v20;
      v47[1] = v21;
      v47[2] = v22;
      v47[3] = v23;
      v47[4] = v24;
      v47[5] = v25;
      v47[6] = v26;
      v47[7] = 1.0;
      v39(v17, v47, 0, 6, 1, 0);
      sub_1412A9390();
    }
    v40 = v53;
    v41 = (size_t *)sub_1402A28C0((__int64)v53, &byte_14819E9C2);
    v42 = *(_QWORD *)(a1 + 0x90);
    sub_14053A870(a2, 1, v42, 2, v41);
    return a2;
  }
}

// --- End Function: sub_1429AA610 (0x1429AA610) ---

// --- Function: sub_142DF54B0 (0x142DF54B0) ---
char __fastcall sub_142DF54B0(unsigned __int64 a1, unsigned int **a2, int ***a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r13
  __int64 v6; // rbx
  __int64 (__fastcall *v9)(__int64, __int128 *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  unsigned __int64 v11; // rbx
  __int64 v12; // rax
  __int16 n4; // dx
  unsigned __int64 *v14; // rbx
  __int64 v15; // rcx
  __int64 v16; // r14
  __int64 v17; // rax
  __int64 v18; // rbx
  __int64 v19; // rsi
  _QWORD *v20; // rcx
  unsigned int v21; // r15d
  __int64 *v22; // rbx
  __int64 v23; // rax
  bool v24; // al
  unsigned __int64 v25; // rdx
  size_t n511; // rbx
  __int64 v27; // rdi
  __int64 v28; // rax
  unsigned int v29; // eax
  __int64 v30; // rax
  __int64 v31; // rdi
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  _QWORD *v35; // rcx
  unsigned int v36; // edi
  __int64 v37; // rax
  const char *Unable_to_retrieve_the_animation_offset_for_the_given_fragment; // rdx
  __int16 n0xFFFF_1; // [rsp+30h] [rbp-D0h] BYREF
  _QWORD *v41; // [rsp+38h] [rbp-C8h] BYREF
  _BYTE v42[8]; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v43; // [rsp+48h] [rbp-B8h]
  __m256 v44; // [rsp+50h] [rbp-B0h] BYREF
  __m256i v45; // [rsp+70h] [rbp-90h] BYREF
  unsigned int v46; // [rsp+90h] [rbp-70h]
  unsigned int v47; // [rsp+94h] [rbp-6Ch]
  __int128 v48; // [rsp+98h] [rbp-68h] BYREF
  __m256 v49; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE v50[80]; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v51; // [rsp+180h] [rbp+80h] BYREF

  v51 = a1;
  v5 = a5;
  v43 = a4;
  v6 = a1 & 0xFFFFFFFFFFFFLL;
  v9 = *(__int64 (__fastcall **)(__int64, __int128 *, __int16 *))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x340LL);
  n0xFFFF = n0xFFFF_20;
  if ( n0xFFFF_20 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *, const char *))(*(_QWORD *)qword_149B4FC88 + 0x10LL))(
                          qword_149B4FC88,
                          v42,
                          "IActor");
    n0xFFFF_20 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v11 = *(_QWORD *)v9(v6, &v48, &n0xFFFF_1);
  v41 = (_QWORD *)v11;
  if ( v11 )
  {
    v12 = sub_1403B4B50(v11 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v12 + 4);
    if ( n4 != 4
      && *(_WORD *)(v12 + 2) == (HIWORD(v11) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)NtCurrentTeb_w() || sub_140391F30(&v41)) )
    {
      v14 = (unsigned __int64 *)(v11 & 0xFFFFFFFFFFFFLL);
      if ( v14 )
      {
        v15 = validateHandleAccess(v14 + 1) ? v14[1] & 0xFFFFFFFFFFFFLL : 0LL;
        v16 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v15 + 0x4F8LL))(v15, 0);
        v17 = (*(__int64 (__fastcall **)(unsigned __int64 *))(*v14 + 0x6B8))(v14);
        v18 = v17;
        v19 = v17 ? (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 0x588LL))(v17) : 0LL;
        if ( v16 && v18 && v19 && *a2 && *a3 )
        {
          v20 = *(_QWORD **)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0xE0LL))(v19);
          v41 = v20;
          if ( !*a2 )
          {
            LogFatalError("Something is trying to access an invalid variable value");
            v20 = v41;
          }
          v21 = **a2;
          if ( v21 != 0xFFFFFFFF )
          {
            v22 = (__int64 *)sub_1404B5BF0((__int64)v20, v21);
            v48 = 0;
            if ( v22 )
            {
              if ( !*a3 )
                LogFatalError("Something is trying to access an invalid variable value");
              sub_140496870(*a3, v22, (__int64)&v48);
            }
            v23 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0xE0LL))(v19);
            *(_OWORD *)v49.m256_f32 = *(_OWORD *)GetEventDispatcherContext(v23 + 8);
            *(_OWORD *)&v49.m256_f32[4] = v48;
            v24 = validateHandleAccess(&v51);
            v25 = v51 & 0xFFFFFFFFFFFFLL;
            v44 = v49;
            if ( !v24 )
              v25 = 0;
            __asm { vzeroupper }
            sub_140459070((__int64)v50, v21, (__m256i *)&v44, 0xFFFFFFFE, v25, 0);
            n511 = 0xFFFFFFFFFFFFFFFFuLL;
            v27 = sub_1404BB5C0(v41, v21, &v49, 0xFFFFFFFF, 0);
            v28 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0x60LL))(v19);
            v29 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v19 + 0x68LL))(v19, v27 & v28);
            v30 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v19 + 0x88LL))(v19, v29);
            memset(&v44, 0, sizeof(v44));
            v31 = v30;
            __asm { vzeroupper }
            sub_1404590B0(&v45, (__m256i *)&v44, 0xFFFFFFFE);
            v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x38LL))(v31);
            if ( (*(__int64 (__fastcall **)(__int64, _BYTE *, __m256i *))(*(_QWORD *)v32 + 0x60LL))(v32, v50, &v45) )
            {
              v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x38LL))(v31);
              v34 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v33 + 0x80LL))(
                      v33,
                      v21,
                      v46,
                      v47);
              v35 = *(_QWORD **)(v34 + 0x20);
              if ( v35 == *(_QWORD **)(v34 + 0x28) || *v35 == v35[1] )
              {
                Unable_to_retrieve_the_animation_offset_for_the_given_fragment = "Chosen fragment option does not have an"
                                                                                 "y animations configured.";
                do
                  ++n511;
                while ( aChosenFragment_0[n511] );
              }
              else
              {
                v36 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 0x2D8LL))(
                        v16,
                        *(unsigned int *)(*v35 + 0x18LL));
                v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 0x80LL))(v16);
                if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v37 + 0xE8LL))(
                       v37,
                       v36,
                       v43) )
                {
                  return 1;
                }
                Unable_to_retrieve_the_animation_offset_for_the_given_fragment = "Unable to retrieve the animation offset"
                                                                                 " for the given fragment ID and tags. Ch"
                                                                                 "eck that the fragment has a valid animation clip.";
                do
                  ++n511;
                while ( aUnableToRetrie_4[n511] );
              }
            }
            else
            {
              Unable_to_retrieve_the_animation_offset_for_the_given_fragment = "No fragment options exist for the given f"
                                                                               "ragment ID and tags.";
              do
                ++n511;
              while ( aNoFragmentOpti_0[n511] );
            }
            sub_1402A3BE0(v5, Unable_to_retrieve_the_animation_offset_for_the_given_fragment, n511);
          }
        }
      }
    }
  }
  return 0;
}

// --- End Function: sub_142DF54B0 (0x142DF54B0) ---

// --- Function: sub_142F41D00 (0x142F41D00) ---
unsigned __int64 *__fastcall sub_142F41D00(_QWORD *a1, unsigned __int64 *a2, __int16 a3, __int64 a4)
{
  __int64 v7; // rax
  __int64 v8; // rdi
  unsigned __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rdx

  v7 = sub_1465EEBE0(*a1 & 0xFFFFFFFFFFFFLL);
  v8 = v7 + 0x160;
  v9 = sub_1403E3510((volatile signed __int64 *)(v7 + 0x1B0));
  if ( !v9 )
    v9 = sub_1403CA4D0(v8, 0x28u, 0);
  *(_BYTE *)(v9 + 0x18) = 0x65;
  *(_WORD *)(v9 + 0x1A) = a3;
  *(_DWORD *)(v9 + 0x1C) = 0;
  *(_QWORD *)(v9 + 0x20) = v8;
  v10 = allocWithProfilerInfo_w(0x80u);
  v11 = v10;
  if ( v10 )
  {
    *(_QWORD *)v10 = *(_QWORD *)a4;
    *(_QWORD *)(v10 + 0x20) = *(_QWORD *)(a4 + 0x20);
    *(_QWORD *)(v10 + 8) = *(_QWORD *)(a4 + 8);
    *(_QWORD *)(v10 + 0x10) = *(_QWORD *)(a4 + 0x10);
    *(_QWORD *)(v10 + 0x18) = *(_QWORD *)(a4 + 0x18);
    *(_OWORD *)(v10 + 0x28) = *(_OWORD *)(a4 + 0x28);
    *(double *)(v10 + 0x38) = *(double *)(a4 + 0x38);
    *(_QWORD *)(v10 + 0x40) = *(_QWORD *)(a4 + 0x40);
    *(_OWORD *)(v10 + 0x48) = *(_OWORD *)(a4 + 0x48);
    *(double *)(v10 + 0x58) = *(double *)(a4 + 0x58);
    *(_DWORD *)(v10 + 0x6C) = *(_DWORD *)(a4 + 0x6C);
    *(_DWORD *)(v10 + 0x60) = *(_DWORD *)(a4 + 0x60);
    *(_DWORD *)(v10 + 0x64) = *(_DWORD *)(a4 + 0x64);
    *(_DWORD *)(v10 + 0x68) = *(_DWORD *)(a4 + 0x68);
    *(double *)(v10 + 0x70) = *(double *)(a4 + 0x70);
    *(_DWORD *)(v10 + 0x78) = *(_DWORD *)(a4 + 0x78);
    *(_BYTE *)(v10 + 0x7C) = *(_BYTE *)(a4 + 0x7C);
    *(_BYTE *)(v10 + 0x7D) = *(_BYTE *)(a4 + 0x7D);
    *(_BYTE *)(v10 + 0x7E) = *(_BYTE *)(a4 + 0x7E);
    *(_BYTE *)(v10 + 0x7F) = *(_BYTE *)(a4 + 0x7F);
  }
  else
  {
    v11 = 0;
  }
  *(_QWORD *)v9 = v11;
  *a2 = v9;
  _InterlockedIncrement((volatile signed __int32 *)(v9 + 0x1C));
  return a2;
}

// --- End Function: sub_142F41D00 (0x142F41D00) ---

// --- Function: sub_142F63590 (0x142F63590) ---
__int64 *__fastcall sub_142F63590(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rax

  v2 = *a2;
  *a1 = *a2;
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 0x1C));
  return a1;
}

// --- End Function: sub_142F63590 (0x142F63590) ---

// --- Function: sub_142F709D0 (0x142F709D0) ---
_UNKNOWN **__fastcall sub_142F709D0(_QWORD *a1)
{
  _UNKNOWN **result; // rax
  volatile signed __int32 *v3; // rcx

  result = &off_148746580;
  *a1 = &off_148746580;
  v3 = (volatile signed __int32 *)a1[1];
  if ( v3 )
    result = (_UNKNOWN **)sub_142FEFD50(v3);
  a1[1] = 0;
  return result;
}

// --- End Function: sub_142F709D0 (0x142F709D0) ---

// --- Function: sub_142F8F080 (0x142F8F080) ---
__int64 __fastcall sub_142F8F080(__int64 *a1, volatile signed __int32 **a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // r10
  __int64 result; // rax
  _QWORD *v9; // rdi
  __int64 (__fastcall *v10)(_QWORD *, _QWORD *, __int64, _QWORD, volatile signed __int32 *); // rsi
  volatile signed __int32 *v11; // rcx
  _QWORD *v12; // rax
  _QWORD *v13; // rdi
  __int64 (__fastcall *v14)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v15; // rcx
  _QWORD *v16; // rax
  _QWORD *v17; // rdi
  __int64 (__fastcall *v18)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v19; // rcx
  _QWORD *v20; // rax
  _QWORD *v21; // rdi
  __int64 (__fastcall *v22)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rdi
  __int64 (__fastcall *v26)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v27; // rcx
  _QWORD *v28; // rax
  _QWORD *v29; // rdi
  __int64 (__fastcall *v30)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v31; // rcx
  _QWORD *v32; // rax
  _QWORD *v33; // rdi
  __int64 (__fastcall *v34)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v35; // rcx
  _QWORD *v36; // rax
  _QWORD *v37; // rdi
  __int64 (__fastcall *v38)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v39; // rcx
  _QWORD *v40; // rax
  _QWORD *v41; // rdi
  __int64 (__fastcall *v42)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v43; // rcx
  _QWORD *v44; // rax
  _QWORD *v45; // rdi
  __int64 (__fastcall *v46)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v47; // rcx
  _QWORD *v48; // rax
  _QWORD *v49; // rdi
  __int64 (__fastcall *v50)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v51; // rcx
  _QWORD *v52; // rax
  _QWORD *v53; // rdi
  __int64 (__fastcall *v54)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v55; // rcx
  _QWORD *v56; // rax
  _QWORD *v57; // rdi
  __int64 (__fastcall *v58)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v59; // rcx
  _QWORD *v60; // rax
  _QWORD *v61; // rdi
  __int64 (__fastcall *v62)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v63; // rcx
  _QWORD *v64; // rax
  _QWORD *v65; // rdi
  __int64 (__fastcall *v66)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v67; // rcx
  _QWORD *v68; // rax
  _QWORD *v69; // rdi
  __int64 (__fastcall *v70)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v71; // rcx
  _QWORD *v72; // rax
  volatile signed __int32 *v73; // rcx
  _QWORD *v74; // rdi
  __int64 (__fastcall *v75)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v76; // rcx
  _QWORD *v77; // rax
  _QWORD *v78; // rdi
  __int64 (__fastcall *v79)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v80; // rcx
  _QWORD *v81; // rax
  _QWORD *v82; // rdi
  __int64 (__fastcall *v83)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v84; // rcx
  _QWORD *v85; // rax
  _QWORD *v86; // rdi
  __int64 (__fastcall *v87)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v88; // rcx
  _QWORD *v89; // rax
  _QWORD *v90; // rdi
  __int64 (__fastcall *v91)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v92; // rcx
  _QWORD *v93; // rax
  _QWORD *v94; // rdi
  __int64 (__fastcall *v95)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v96; // rcx
  _QWORD *v97; // rax
  _QWORD *v98; // rdi
  __int64 (__fastcall *v99)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v100; // rcx
  _QWORD *v101; // rax
  _QWORD *v102; // rdi
  __int64 (__fastcall *v103)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v104; // rcx
  _QWORD *v105; // rax
  _QWORD *v106; // rdi
  __int64 (__fastcall *v107)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v108; // rcx
  _QWORD *v109; // rax
  _QWORD *v110; // rdi
  __int64 (__fastcall *v111)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v112; // rcx
  _QWORD *v113; // rax
  _QWORD *v114; // rdi
  __int64 (__fastcall *v115)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v116; // rcx
  _QWORD *v117; // rax
  _QWORD *v118; // rdi
  __int64 (__fastcall *v119)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v120; // rcx
  _QWORD *v121; // rax
  _QWORD *v122; // rdi
  __int64 (__fastcall *v123)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v124; // rcx
  _QWORD *v125; // rax
  _QWORD *v126; // rdi
  __int64 (__fastcall *v127)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v128; // rcx
  _QWORD *v129; // rax
  _QWORD *v130; // rdi
  __int64 (__fastcall *v131)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v132; // rcx
  _QWORD *v133; // rax
  _QWORD *v134; // rdi
  __int64 (__fastcall *v135)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v136; // rcx
  _QWORD *v137; // rax
  _QWORD *v138; // rdi
  __int64 (__fastcall *v139)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v140; // rcx
  _QWORD *v141; // rax
  _QWORD *v142; // rdi
  __int64 (__fastcall *v143)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v144; // rcx
  _QWORD *v145; // rax
  _QWORD *v146; // rdi
  __int64 (__fastcall *v147)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v148; // rcx
  _QWORD *v149; // rax
  _QWORD *v150; // rdi
  __int64 (__fastcall *v151)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v152; // rcx
  _QWORD *v153; // rax
  _QWORD *v154; // rdi
  __int64 (__fastcall *v155)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v156; // rcx
  _QWORD *v157; // rax
  _QWORD *v158; // rdi
  __int64 (__fastcall *v159)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v160; // rcx
  _QWORD *v161; // rax
  _QWORD *v162; // rdi
  __int64 (__fastcall *v163)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v164; // rcx
  _QWORD *v165; // rax
  _QWORD *v166; // rdi
  __int64 (__fastcall *v167)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v168; // rcx
  _QWORD *v169; // rax
  _QWORD *v170; // rdi
  __int64 (__fastcall *v171)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v172; // rcx
  _QWORD *v173; // rax
  _QWORD *v174; // rdi
  __int64 (__fastcall *v175)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v176; // rcx
  _QWORD *v177; // rax
  _QWORD *v178; // rdi
  __int64 (__fastcall *v179)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v180; // rcx
  _QWORD *v181; // rax
  _QWORD *v182; // rdi
  __int64 (__fastcall *v183)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v184; // rcx
  _QWORD *v185; // rax
  _QWORD *v186; // rdi
  __int64 (__fastcall *v187)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v188; // rcx
  _QWORD *v189; // rax
  _QWORD *v190; // rdi
  __int64 (__fastcall *v191)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v192; // rcx
  _QWORD *v193; // rax
  _QWORD *v194; // rdi
  __int64 (__fastcall *v195)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v196; // rcx
  _QWORD *v197; // rax
  _QWORD *v198; // rdi
  __int64 (__fastcall *v199)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v200; // rcx
  _QWORD *v201; // rax
  _QWORD *v202; // rdi
  __int64 (__fastcall *v203)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v204; // rcx
  _QWORD *v205; // rax
  _QWORD *v206; // rdi
  __int64 (__fastcall *v207)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v208; // rcx
  _QWORD *v209; // rax
  _QWORD *v210; // rdi
  __int64 (__fastcall *v211)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v212; // rcx
  _QWORD *v213; // rax
  _QWORD *v214; // rdi
  __int64 (__fastcall *v215)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v216; // rcx
  _QWORD *v217; // rax
  _QWORD *v218; // rdi
  __int64 (__fastcall *v219)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v220; // rcx
  _QWORD *v221; // rax
  _QWORD *v222; // rdi
  __int64 (__fastcall *v223)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v224; // rcx
  _QWORD *v225; // rax
  _QWORD *v226; // rdi
  __int64 (__fastcall *v227)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v228; // rcx
  _QWORD *v229; // rax
  _QWORD *v230; // rdi
  __int64 (__fastcall *v231)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v232; // rcx
  _QWORD *v233; // rax
  _QWORD *v234; // rdi
  __int64 (__fastcall *v235)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v236; // rcx
  _QWORD *v237; // rax
  _QWORD *v238; // rdi
  __int64 (__fastcall *v239)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v240; // rcx
  _QWORD *v241; // rax
  _QWORD *v242; // rdi
  __int64 (__fastcall *v243)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v244; // rcx
  _QWORD *v245; // rax
  _QWORD *v246; // rdi
  __int64 (__fastcall *v247)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v248; // rcx
  _QWORD *v249; // rax
  _QWORD *v250; // rdi
  __int64 (__fastcall *v251)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v252; // rcx
  _QWORD *v253; // rax
  _QWORD *v254; // rdi
  __int64 (__fastcall *v255)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v256; // rcx
  _QWORD *v257; // rax
  _QWORD *v258; // rdi
  __int64 (__fastcall *v259)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v260; // rcx
  _QWORD *v261; // rax
  _QWORD *v262; // rdi
  __int64 (__fastcall *v263)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v264; // rcx
  _QWORD *v265; // rax
  _QWORD *v266; // rdi
  __int64 (__fastcall *v267)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v268; // rcx
  _QWORD *v269; // rax
  _QWORD *v270; // rdi
  __int64 (__fastcall *v271)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v272; // rcx
  _QWORD *v273; // rax
  _QWORD *v274; // rdi
  __int64 (__fastcall *v275)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v276; // rcx
  _QWORD *v277; // rax
  _QWORD *v278; // rdi
  __int64 (__fastcall *v279)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v280; // rcx
  _QWORD *v281; // rax
  _QWORD *v282; // rdi
  __int64 (__fastcall *v283)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v284; // rcx
  _QWORD *v285; // rax
  _QWORD *v286; // rdi
  __int64 (__fastcall *v287)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v288; // rcx
  _QWORD *v289; // rax
  _QWORD *v290; // rdi
  __int64 (__fastcall *v291)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v292; // rcx
  _QWORD *v293; // rax
  _QWORD *v294; // rdi
  __int64 (__fastcall *v295)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v296; // rcx
  _QWORD *v297; // rax
  _QWORD *v298; // rdi
  __int64 (__fastcall *v299)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v300; // rcx
  _QWORD *v301; // rax
  _QWORD *v302; // rdi
  __int64 (__fastcall *v303)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v304; // rcx
  _QWORD *v305; // rax
  _QWORD *v306; // rdi
  __int64 (__fastcall *v307)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v308; // rcx
  _QWORD *v309; // rax
  _QWORD *v310; // rdi
  __int64 (__fastcall *v311)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v312; // rcx
  _QWORD *v313; // rax
  _QWORD *v314; // rdi
  __int64 (__fastcall *v315)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v316; // rcx
  _QWORD *v317; // rax
  _QWORD *v318; // rdi
  __int64 (__fastcall *v319)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v320; // rcx
  _QWORD *v321; // rax
  _QWORD *v322; // rdi
  __int64 (__fastcall *v323)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v324; // rcx
  _QWORD *v325; // rax
  _QWORD *v326; // rdi
  __int64 (__fastcall *v327)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v328; // rcx
  _QWORD *v329; // rax
  _QWORD *v330; // rdi
  __int64 (__fastcall *v331)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v332; // rcx
  _QWORD *v333; // rax
  _QWORD *v334; // rdi
  __int64 (__fastcall *v335)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v336; // rcx
  _QWORD *v337; // rax
  _QWORD *v338; // rdi
  __int64 (__fastcall *v339)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v340; // rcx
  _QWORD *v341; // rax
  _QWORD *v342; // rdi
  __int64 (__fastcall *v343)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v344; // rcx
  _QWORD *v345; // rax
  _QWORD *v346; // rdi
  __int64 (__fastcall *v347)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v348; // rcx
  _QWORD *v349; // rax
  _QWORD *v350; // rdi
  __int64 (__fastcall *v351)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v352; // rcx
  _QWORD *v353; // rax
  _QWORD *v354; // rdi
  __int64 (__fastcall *v355)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v356; // rcx
  _QWORD *v357; // rax
  _QWORD *v358; // rdi
  __int64 (__fastcall *v359)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v360; // rcx
  _QWORD *v361; // rax
  _QWORD *v362; // rdi
  __int64 (__fastcall *v363)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v364; // rcx
  _QWORD *v365; // rax
  _QWORD *v366; // rdi
  __int64 (__fastcall *v367)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v368; // rcx
  _QWORD *v369; // rax
  _QWORD *v370; // rdi
  __int64 (__fastcall *v371)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v372; // rcx
  _QWORD *v373; // rax
  _QWORD *v374; // rdi
  __int64 (__fastcall *v375)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v376; // rcx
  _QWORD *v377; // rax
  _QWORD *v378; // rdi
  __int64 (__fastcall *v379)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v380; // rcx
  _QWORD *v381; // rax
  _QWORD *v382; // rdi
  __int64 (__fastcall *v383)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v384; // rcx
  _QWORD *v385; // rax
  _QWORD *v386; // rdi
  __int64 (__fastcall *v387)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v388; // rcx
  _QWORD *v389; // rax
  _QWORD *v390; // rdi
  __int64 (__fastcall *v391)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v392; // rcx
  _QWORD *v393; // rax
  _QWORD *v394; // rdi
  __int64 (__fastcall *v395)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v396; // rcx
  _QWORD *v397; // rax
  _QWORD *v398; // rdi
  __int64 (__fastcall *v399)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v400; // rcx
  _QWORD *v401; // rax
  _QWORD *v402; // rdi
  __int64 (__fastcall *v403)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v404; // rcx
  _QWORD *v405; // rax
  _QWORD *v406; // rdi
  __int64 (__fastcall *v407)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v408; // rcx
  _QWORD *v409; // rax
  _QWORD *v410; // rdi
  __int64 (__fastcall *v411)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v412; // rcx
  _QWORD *v413; // rax
  _QWORD *v414; // rdi
  __int64 (__fastcall *v415)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v416; // rcx
  _QWORD *v417; // rax
  _QWORD *v418; // rdi
  __int64 (__fastcall *v419)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v420; // rcx
  _QWORD *v421; // rax
  _QWORD *v422; // rdi
  __int64 (__fastcall *v423)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v424; // rcx
  _QWORD *v425; // rax
  _QWORD *v426; // rdi
  __int64 (__fastcall *v427)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v428; // rcx
  _QWORD *v429; // rax
  _QWORD *v430; // rdi
  __int64 (__fastcall *v431)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v432; // rcx
  _QWORD *v433; // rax
  _QWORD *v434; // rdi
  __int64 (__fastcall *v435)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v436; // rcx
  _QWORD *v437; // rax
  _QWORD *v438; // rdi
  void (__fastcall *v439)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v440; // rcx
  _QWORD *v441; // rax
  _QWORD *v442; // rdi
  void (__fastcall *v443)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v444; // rcx
  _QWORD *v445; // rax
  _QWORD *v446; // rdi
  void (__fastcall *v447)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v448; // rcx
  _QWORD *v449; // rax
  _QWORD *v450; // rdi
  void (__fastcall *v451)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v452; // rcx
  _QWORD *v453; // rax
  _QWORD *v454; // rdi
  void (__fastcall *v455)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v456; // rcx
  _QWORD *v457; // rax
  _QWORD *v458; // rdi
  void (__fastcall *v459)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v460; // rcx
  _QWORD *v461; // rax
  _QWORD *v462; // rdi
  void (__fastcall *v463)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v464; // rcx
  _QWORD *v465; // rax
  _QWORD *v466; // rdi
  void (__fastcall *v467)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v468; // rcx
  _QWORD *v469; // rax
  _QWORD *v470; // rdi
  void (__fastcall *v471)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v472; // rcx
  _QWORD *v473; // rax
  _QWORD *v474; // rdi
  void (__fastcall *v475)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v476; // rcx
  _QWORD *v477; // rax
  _QWORD *v478; // rdi
  void (__fastcall *v479)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v480; // rcx
  _QWORD *v481; // rax
  _QWORD *v482; // rdi
  void (__fastcall *v483)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v484; // rcx
  _QWORD *v485; // rax
  _QWORD *v486; // rdi
  void (__fastcall *v487)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v488; // rcx
  _QWORD *v489; // rax
  _QWORD *v490; // rdi
  void (__fastcall *v491)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v492; // rcx
  _QWORD *v493; // rax
  _QWORD *v494; // rdi
  void (__fastcall *v495)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v496; // rcx
  _QWORD *v497; // rax
  _QWORD *v498; // rdi
  void (__fastcall *v499)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v500; // rcx
  _QWORD *v501; // rax
  _QWORD *v502; // rdi
  void (__fastcall *v503)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v504; // rcx
  _QWORD *v505; // rax
  _QWORD *v506; // rdi
  void (__fastcall *v507)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v508; // rcx
  _QWORD *v509; // rax
  _QWORD *v510; // rdi
  void (__fastcall *v511)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v512; // rcx
  _QWORD *v513; // rax
  _QWORD *v514; // rdi
  void (__fastcall *v515)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v516; // rcx
  _QWORD *v517; // rax
  _QWORD *v518; // rdi
  void (__fastcall *v519)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v520; // rcx
  _QWORD *v521; // rax
  _QWORD *v522; // rdi
  void (__fastcall *v523)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v524; // rcx
  _QWORD *v525; // rax
  _QWORD *v526; // rdi
  void (__fastcall *v527)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v528; // rcx
  _QWORD *v529; // rax
  _QWORD *v530; // rdi
  void (__fastcall *v531)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v532; // rcx
  _QWORD *v533; // rax
  _QWORD *v534; // rdi
  void (__fastcall *v535)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v536; // rcx
  _QWORD *v537; // rax
  _QWORD *v538; // rdi
  void (__fastcall *v539)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v540; // rcx
  _QWORD *v541; // rax
  _QWORD *v542; // rdi
  void (__fastcall *v543)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v544; // rcx
  _QWORD *v545; // rax
  _QWORD *v546; // rdi
  void (__fastcall *v547)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v548; // rcx
  _QWORD *v549; // rax
  _QWORD *v550; // rdi
  void (__fastcall *v551)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v552; // rcx
  _QWORD *v553; // rax
  _QWORD *v554; // rdi
  void (__fastcall *v555)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v556; // rcx
  _QWORD *v557; // rax
  _QWORD *v558; // rdi
  void (__fastcall *v559)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v560; // rcx
  _QWORD *v561; // rax
  _QWORD *v562; // rdi
  void (__fastcall *v563)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v564; // rcx
  _QWORD *v565; // rax
  _QWORD *v566; // rdi
  void (__fastcall *v567)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v568; // rcx
  _QWORD *v569; // rax
  _QWORD *v570; // rdi
  void (__fastcall *v571)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v572; // rcx
  _QWORD *v573; // rax
  _QWORD *v574; // rdi
  void (__fastcall *v575)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v576; // rcx
  _QWORD *v577; // rax
  _QWORD *v578; // rdi
  void (__fastcall *v579)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v580; // rcx
  _QWORD *v581; // rax
  _QWORD *v582; // rdi
  void (__fastcall *v583)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v584; // rcx
  _QWORD *v585; // rax
  _QWORD *v586; // rdi
  void (__fastcall *v587)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v588; // rcx
  _QWORD *v589; // rax
  _QWORD *v590; // rdi
  void (__fastcall *v591)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v592; // rcx
  _QWORD *v593; // rax
  _QWORD *v594; // rdi
  void (__fastcall *v595)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v596; // rcx
  _QWORD *v597; // rax
  _QWORD *v598; // rdi
  void (__fastcall *v599)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v600; // rcx
  _QWORD *v601; // rax
  _QWORD *v602; // rdi
  void (__fastcall *v603)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v604; // rcx
  _QWORD *v605; // rax
  _QWORD *v606; // rdi
  void (__fastcall *v607)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v608; // rcx
  _QWORD *v609; // rax
  _QWORD *v610; // rdi
  void (__fastcall *v611)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v612; // rcx
  _QWORD *v613; // rax
  _QWORD *v614; // rdi
  void (__fastcall *v615)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v616; // rcx
  _QWORD *v617; // rax
  _QWORD *v618; // rdi
  void (__fastcall *v619)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v620; // rcx
  _QWORD *v621; // rax
  _QWORD *v622; // rdi
  void (__fastcall *v623)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v624; // rcx
  _QWORD *v625; // rax
  _QWORD *v626; // rdi
  void (__fastcall *v627)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v628; // rcx
  _QWORD *v629; // rax
  _QWORD *v630; // rdi
  void (__fastcall *v631)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v632; // rcx
  _QWORD *v633; // rax
  _QWORD *v634; // rdi
  void (__fastcall *v635)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v636; // rcx
  _QWORD *v637; // rax
  _QWORD *v638; // rdi
  void (__fastcall *v639)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v640; // rcx
  _QWORD *v641; // rax
  _QWORD *v642; // rdi
  void (__fastcall *v643)(_QWORD *, _QWORD *, __int64, _QWORD); // rsi
  volatile signed __int32 *v644; // rcx
  _QWORD *v645; // rax
  __int64 *v646; // rax
  _QWORD *v647; // rsi
  void (__fastcall *v648)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v649; // rax
  _QWORD *v650; // rax
  __int64 *v651; // rax
  _QWORD *v652; // rsi
  void (__fastcall *v653)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v654; // rax
  _QWORD *v655; // rax
  __int64 *v656; // rax
  _QWORD *v657; // rsi
  void (__fastcall *v658)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v659; // rax
  _QWORD *v660; // rax
  __int64 *v661; // rax
  _QWORD *v662; // rsi
  void (__fastcall *v663)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v664; // rax
  _QWORD *v665; // rax
  __int64 *v666; // rax
  _QWORD *v667; // rsi
  void (__fastcall *v668)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v669; // rax
  _QWORD *v670; // rax
  __int64 *v671; // rax
  _QWORD *v672; // rsi
  void (__fastcall *v673)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v674; // rax
  _QWORD *v675; // rax
  __int64 *v676; // rax
  _QWORD *v677; // rsi
  void (__fastcall *v678)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v679; // rax
  _QWORD *v680; // rax
  __int64 *v681; // rax
  _QWORD *v682; // rsi
  void (__fastcall *v683)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v684; // rax
  _QWORD *v685; // rax
  __int64 *v686; // rax
  _QWORD *v687; // rsi
  void (__fastcall *v688)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v689; // rax
  _QWORD *v690; // rax
  __int64 *v691; // rax
  _QWORD *v692; // rsi
  void (__fastcall *v693)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v694; // rax
  _QWORD *v695; // rax
  __int64 *v696; // rax
  _QWORD *v697; // rsi
  void (__fastcall *v698)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v699; // rax
  _QWORD *v700; // rax
  __int64 *v701; // rax
  _QWORD *v702; // rsi
  void (__fastcall *v703)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v704; // rax
  _QWORD *v705; // rax
  __int64 *v706; // rax
  _QWORD *v707; // rsi
  void (__fastcall *v708)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v709; // rax
  _QWORD *v710; // rax
  __int64 *v711; // rax
  _QWORD *v712; // rsi
  void (__fastcall *v713)(_QWORD *, _QWORD *, __int64, _QWORD); // rdi
  __int64 *v714; // rax
  _QWORD *v715; // rax
  volatile signed __int32 *v716; // [rsp+20h] [rbp-E0h] BYREF
  volatile signed __int32 *v717; // [rsp+28h] [rbp-D8h] BYREF
  volatile signed __int32 *v718; // [rsp+30h] [rbp-D0h] BYREF
  volatile signed __int32 *v719; // [rsp+38h] [rbp-C8h] BYREF
  volatile signed __int32 *v720; // [rsp+40h] [rbp-C0h] BYREF
  volatile signed __int32 *v721; // [rsp+48h] [rbp-B8h] BYREF
  volatile signed __int32 *v722; // [rsp+50h] [rbp-B0h] BYREF
  volatile signed __int32 *v723; // [rsp+58h] [rbp-A8h] BYREF
  volatile signed __int32 *v724; // [rsp+60h] [rbp-A0h] BYREF
  volatile signed __int32 *v725; // [rsp+68h] [rbp-98h] BYREF
  volatile signed __int32 *v726; // [rsp+70h] [rbp-90h] BYREF
  volatile signed __int32 *v727; // [rsp+78h] [rbp-88h] BYREF
  volatile signed __int32 *v728; // [rsp+80h] [rbp-80h] BYREF
  volatile signed __int32 *v729; // [rsp+88h] [rbp-78h] BYREF
  volatile signed __int32 *v730; // [rsp+90h] [rbp-70h] BYREF
  volatile signed __int32 *v731; // [rsp+98h] [rbp-68h] BYREF
  volatile signed __int32 *v732; // [rsp+A0h] [rbp-60h] BYREF
  volatile signed __int32 *v733; // [rsp+A8h] [rbp-58h] BYREF
  volatile signed __int32 *v734; // [rsp+B0h] [rbp-50h] BYREF
  volatile signed __int32 *v735; // [rsp+B8h] [rbp-48h] BYREF
  volatile signed __int32 *v736; // [rsp+C0h] [rbp-40h] BYREF
  volatile signed __int32 *v737; // [rsp+C8h] [rbp-38h] BYREF
  volatile signed __int32 *v738; // [rsp+D0h] [rbp-30h] BYREF
  volatile signed __int32 *v739; // [rsp+D8h] [rbp-28h] BYREF
  volatile signed __int32 *v740; // [rsp+E0h] [rbp-20h] BYREF
  volatile signed __int32 *v741; // [rsp+E8h] [rbp-18h] BYREF
  volatile signed __int32 *v742; // [rsp+F0h] [rbp-10h] BYREF
  volatile signed __int32 *v743; // [rsp+F8h] [rbp-8h] BYREF
  volatile signed __int32 *v744; // [rsp+100h] [rbp+0h] BYREF
  volatile signed __int32 *v745; // [rsp+108h] [rbp+8h] BYREF
  volatile signed __int32 *v746; // [rsp+110h] [rbp+10h] BYREF
  volatile signed __int32 *v747; // [rsp+118h] [rbp+18h] BYREF
  volatile signed __int32 *v748; // [rsp+120h] [rbp+20h] BYREF
  volatile signed __int32 *v749; // [rsp+128h] [rbp+28h] BYREF
  volatile signed __int32 *v750; // [rsp+130h] [rbp+30h] BYREF
  volatile signed __int32 *v751; // [rsp+138h] [rbp+38h] BYREF
  volatile signed __int32 *v752; // [rsp+140h] [rbp+40h] BYREF
  volatile signed __int32 *v753; // [rsp+148h] [rbp+48h] BYREF
  volatile signed __int32 *v754; // [rsp+150h] [rbp+50h] BYREF
  volatile signed __int32 *v755; // [rsp+158h] [rbp+58h] BYREF
  volatile signed __int32 *v756; // [rsp+160h] [rbp+60h] BYREF
  volatile signed __int32 *v757; // [rsp+168h] [rbp+68h] BYREF
  volatile signed __int32 *v758; // [rsp+170h] [rbp+70h] BYREF
  volatile signed __int32 *v759; // [rsp+178h] [rbp+78h] BYREF
  volatile signed __int32 *v760; // [rsp+180h] [rbp+80h] BYREF
  volatile signed __int32 *v761; // [rsp+188h] [rbp+88h] BYREF
  volatile signed __int32 *v762; // [rsp+190h] [rbp+90h] BYREF
  volatile signed __int32 *v763; // [rsp+198h] [rbp+98h] BYREF
  volatile signed __int32 *v764; // [rsp+1A0h] [rbp+A0h] BYREF
  volatile signed __int32 *v765; // [rsp+1A8h] [rbp+A8h] BYREF
  volatile signed __int32 *v766; // [rsp+1B0h] [rbp+B0h] BYREF
  volatile signed __int32 *v767; // [rsp+1B8h] [rbp+B8h] BYREF
  volatile signed __int32 *v768; // [rsp+1C0h] [rbp+C0h] BYREF
  volatile signed __int32 *v769; // [rsp+1C8h] [rbp+C8h] BYREF
  volatile signed __int32 *v770; // [rsp+1D0h] [rbp+D0h] BYREF
  volatile signed __int32 *v771; // [rsp+1D8h] [rbp+D8h] BYREF
  volatile signed __int32 *v772; // [rsp+1E0h] [rbp+E0h] BYREF
  volatile signed __int32 *v773; // [rsp+1E8h] [rbp+E8h] BYREF
  volatile signed __int32 *v774; // [rsp+1F0h] [rbp+F0h] BYREF
  volatile signed __int32 *v775; // [rsp+1F8h] [rbp+F8h] BYREF
  volatile signed __int32 *v776; // [rsp+200h] [rbp+100h] BYREF
  volatile signed __int32 *v777; // [rsp+208h] [rbp+108h] BYREF
  volatile signed __int32 *v778; // [rsp+210h] [rbp+110h] BYREF
  volatile signed __int32 *v779; // [rsp+218h] [rbp+118h] BYREF
  volatile signed __int32 *v780; // [rsp+220h] [rbp+120h] BYREF
  volatile signed __int32 *v781; // [rsp+228h] [rbp+128h] BYREF
  volatile signed __int32 *v782; // [rsp+230h] [rbp+130h] BYREF
  volatile signed __int32 *v783; // [rsp+238h] [rbp+138h] BYREF
  volatile signed __int32 *v784; // [rsp+240h] [rbp+140h] BYREF
  volatile signed __int32 *v785; // [rsp+248h] [rbp+148h] BYREF
  volatile signed __int32 *v786; // [rsp+250h] [rbp+150h] BYREF
  volatile signed __int32 *v787; // [rsp+258h] [rbp+158h] BYREF
  volatile signed __int32 *v788; // [rsp+260h] [rbp+160h] BYREF
  volatile signed __int32 *v789; // [rsp+268h] [rbp+168h] BYREF
  volatile signed __int32 *v790; // [rsp+270h] [rbp+170h] BYREF
  volatile signed __int32 *v791; // [rsp+278h] [rbp+178h] BYREF
  volatile signed __int32 *v792; // [rsp+280h] [rbp+180h] BYREF
  volatile signed __int32 *v793; // [rsp+288h] [rbp+188h] BYREF
  volatile signed __int32 *v794; // [rsp+290h] [rbp+190h] BYREF
  volatile signed __int32 *v795; // [rsp+298h] [rbp+198h] BYREF
  volatile signed __int32 *v796; // [rsp+2A0h] [rbp+1A0h] BYREF
  volatile signed __int32 *v797; // [rsp+2A8h] [rbp+1A8h] BYREF
  volatile signed __int32 *v798; // [rsp+2B0h] [rbp+1B0h] BYREF
  volatile signed __int32 *v799; // [rsp+2B8h] [rbp+1B8h] BYREF
  volatile signed __int32 *v800; // [rsp+2C0h] [rbp+1C0h] BYREF
  volatile signed __int32 *v801; // [rsp+2C8h] [rbp+1C8h] BYREF
  volatile signed __int32 *v802; // [rsp+2D0h] [rbp+1D0h] BYREF
  volatile signed __int32 *v803; // [rsp+2D8h] [rbp+1D8h] BYREF
  volatile signed __int32 *v804; // [rsp+2E0h] [rbp+1E0h] BYREF
  volatile signed __int32 *v805; // [rsp+2E8h] [rbp+1E8h] BYREF
  volatile signed __int32 *v806; // [rsp+2F0h] [rbp+1F0h] BYREF
  volatile signed __int32 *v807; // [rsp+2F8h] [rbp+1F8h] BYREF
  volatile signed __int32 *v808; // [rsp+300h] [rbp+200h] BYREF
  volatile signed __int32 *v809; // [rsp+308h] [rbp+208h] BYREF
  volatile signed __int32 *v810; // [rsp+310h] [rbp+210h] BYREF
  volatile signed __int32 *v811; // [rsp+318h] [rbp+218h] BYREF
  volatile signed __int32 *v812; // [rsp+320h] [rbp+220h] BYREF
  volatile signed __int32 *v813; // [rsp+328h] [rbp+228h] BYREF
  volatile signed __int32 *v814; // [rsp+330h] [rbp+230h] BYREF
  volatile signed __int32 *v815; // [rsp+338h] [rbp+238h] BYREF
  volatile signed __int32 *v816; // [rsp+340h] [rbp+240h] BYREF
  volatile signed __int32 *v817; // [rsp+348h] [rbp+248h] BYREF
  volatile signed __int32 *v818; // [rsp+350h] [rbp+250h] BYREF
  volatile signed __int32 *v819; // [rsp+358h] [rbp+258h] BYREF
  volatile signed __int32 *v820; // [rsp+360h] [rbp+260h] BYREF
  volatile signed __int32 *v821; // [rsp+368h] [rbp+268h] BYREF
  volatile signed __int32 *v822; // [rsp+370h] [rbp+270h] BYREF
  volatile signed __int32 *v823; // [rsp+378h] [rbp+278h] BYREF
  volatile signed __int32 *v824; // [rsp+380h] [rbp+280h] BYREF
  volatile signed __int32 *v825; // [rsp+388h] [rbp+288h] BYREF
  volatile signed __int32 *v826; // [rsp+390h] [rbp+290h] BYREF
  volatile signed __int32 *v827; // [rsp+398h] [rbp+298h] BYREF
  volatile signed __int32 *v828; // [rsp+3A0h] [rbp+2A0h] BYREF
  volatile signed __int32 *v829; // [rsp+3A8h] [rbp+2A8h] BYREF
  volatile signed __int32 *v830; // [rsp+3B0h] [rbp+2B0h] BYREF
  volatile signed __int32 *v831; // [rsp+3B8h] [rbp+2B8h] BYREF
  volatile signed __int32 *v832; // [rsp+3C0h] [rbp+2C0h] BYREF
  volatile signed __int32 *v833; // [rsp+3C8h] [rbp+2C8h] BYREF
  volatile signed __int32 *v834; // [rsp+3D0h] [rbp+2D0h] BYREF
  volatile signed __int32 *v835; // [rsp+3D8h] [rbp+2D8h] BYREF
  volatile signed __int32 *v836; // [rsp+3E0h] [rbp+2E0h] BYREF
  volatile signed __int32 *v837; // [rsp+3E8h] [rbp+2E8h] BYREF
  volatile signed __int32 *v838; // [rsp+3F0h] [rbp+2F0h] BYREF
  volatile signed __int32 *v839; // [rsp+3F8h] [rbp+2F8h] BYREF
  volatile signed __int32 *v840; // [rsp+400h] [rbp+300h] BYREF
  volatile signed __int32 *v841; // [rsp+408h] [rbp+308h] BYREF
  volatile signed __int32 *v842; // [rsp+410h] [rbp+310h] BYREF
  volatile signed __int32 *v843; // [rsp+418h] [rbp+318h] BYREF
  volatile signed __int32 *v844; // [rsp+420h] [rbp+320h] BYREF
  volatile signed __int32 *v845; // [rsp+428h] [rbp+328h] BYREF
  volatile signed __int32 *v846; // [rsp+430h] [rbp+330h] BYREF
  volatile signed __int32 *v847; // [rsp+438h] [rbp+338h] BYREF
  volatile signed __int32 *v848; // [rsp+440h] [rbp+340h] BYREF
  volatile signed __int32 *v849; // [rsp+448h] [rbp+348h] BYREF
  volatile signed __int32 *v850; // [rsp+450h] [rbp+350h] BYREF
  volatile signed __int32 *v851; // [rsp+458h] [rbp+358h] BYREF
  volatile signed __int32 *v852; // [rsp+460h] [rbp+360h] BYREF
  volatile signed __int32 *v853; // [rsp+468h] [rbp+368h] BYREF
  volatile signed __int32 *v854; // [rsp+470h] [rbp+370h] BYREF
  volatile signed __int32 *v855; // [rsp+478h] [rbp+378h] BYREF
  volatile signed __int32 *v856; // [rsp+480h] [rbp+380h] BYREF
  volatile signed __int32 *v857; // [rsp+488h] [rbp+388h] BYREF
  volatile signed __int32 *v858; // [rsp+490h] [rbp+390h] BYREF
  volatile signed __int32 *v859; // [rsp+498h] [rbp+398h] BYREF
  volatile signed __int32 *v860; // [rsp+4A0h] [rbp+3A0h] BYREF
  volatile signed __int32 *v861; // [rsp+4A8h] [rbp+3A8h] BYREF
  volatile signed __int32 *v862; // [rsp+4B0h] [rbp+3B0h] BYREF
  volatile signed __int32 *v863; // [rsp+4B8h] [rbp+3B8h] BYREF
  volatile signed __int32 *v864; // [rsp+4C0h] [rbp+3C0h] BYREF
  volatile signed __int32 *v865; // [rsp+4C8h] [rbp+3C8h] BYREF
  volatile signed __int32 *v866; // [rsp+4D0h] [rbp+3D0h] BYREF
  volatile signed __int32 *v867; // [rsp+4D8h] [rbp+3D8h] BYREF
  volatile signed __int32 *v868; // [rsp+4E0h] [rbp+3E0h] BYREF
  volatile signed __int32 *v869; // [rsp+4E8h] [rbp+3E8h] BYREF
  volatile signed __int32 *v870; // [rsp+4F0h] [rbp+3F0h] BYREF
  volatile signed __int32 *v871; // [rsp+4F8h] [rbp+3F8h] BYREF
  volatile signed __int32 *v872; // [rsp+500h] [rbp+400h] BYREF
  volatile signed __int32 *v873; // [rsp+508h] [rbp+408h] BYREF
  volatile signed __int32 *v874; // [rsp+510h] [rbp+410h] BYREF
  volatile signed __int32 *v875; // [rsp+518h] [rbp+418h] BYREF
  volatile signed __int32 *v876; // [rsp+520h] [rbp+420h] BYREF
  volatile signed __int32 *v877; // [rsp+528h] [rbp+428h] BYREF
  volatile signed __int32 *v878; // [rsp+530h] [rbp+430h] BYREF
  volatile signed __int32 *v879; // [rsp+538h] [rbp+438h] BYREF
  volatile signed __int32 *v880; // [rsp+540h] [rbp+440h] BYREF
  volatile signed __int32 *v881; // [rsp+548h] [rbp+448h] BYREF
  volatile signed __int32 *v882; // [rsp+550h] [rbp+450h] BYREF
  volatile signed __int32 *v883; // [rsp+558h] [rbp+458h] BYREF
  volatile signed __int32 *v884; // [rsp+560h] [rbp+460h] BYREF
  volatile signed __int32 *v885; // [rsp+568h] [rbp+468h] BYREF
  volatile signed __int32 *v886; // [rsp+570h] [rbp+470h] BYREF
  volatile signed __int32 *v887; // [rsp+578h] [rbp+478h] BYREF
  volatile signed __int32 *v888; // [rsp+580h] [rbp+480h] BYREF
  volatile signed __int32 *v889; // [rsp+588h] [rbp+488h] BYREF
  volatile signed __int32 *v890; // [rsp+590h] [rbp+490h] BYREF
  volatile signed __int32 *v891; // [rsp+598h] [rbp+498h] BYREF
  volatile signed __int32 *v892; // [rsp+5A0h] [rbp+4A0h] BYREF
  volatile signed __int32 *v893; // [rsp+5A8h] [rbp+4A8h] BYREF
  volatile signed __int32 *v894; // [rsp+5B0h] [rbp+4B0h] BYREF
  volatile signed __int32 *v895; // [rsp+5B8h] [rbp+4B8h] BYREF
  volatile signed __int32 *v896; // [rsp+5C0h] [rbp+4C0h] BYREF
  volatile signed __int32 *v897; // [rsp+5C8h] [rbp+4C8h] BYREF
  volatile signed __int32 *v898; // [rsp+5D0h] [rbp+4D0h] BYREF
  volatile signed __int32 *v899; // [rsp+5D8h] [rbp+4D8h] BYREF
  volatile signed __int32 *v900; // [rsp+5E0h] [rbp+4E0h] BYREF
  volatile signed __int32 *v901; // [rsp+5E8h] [rbp+4E8h] BYREF
  volatile signed __int32 *v902; // [rsp+5F0h] [rbp+4F0h] BYREF
  volatile signed __int32 *v903; // [rsp+5F8h] [rbp+4F8h] BYREF
  volatile signed __int32 *v904; // [rsp+600h] [rbp+500h] BYREF
  volatile signed __int32 *v905; // [rsp+608h] [rbp+508h] BYREF
  volatile signed __int32 *v906; // [rsp+610h] [rbp+510h] BYREF
  volatile signed __int32 *v907; // [rsp+618h] [rbp+518h] BYREF
  volatile signed __int32 *v908; // [rsp+620h] [rbp+520h] BYREF
  volatile signed __int32 *v909; // [rsp+628h] [rbp+528h] BYREF
  volatile signed __int32 *v910; // [rsp+630h] [rbp+530h] BYREF
  volatile signed __int32 *v911; // [rsp+638h] [rbp+538h] BYREF
  volatile signed __int32 *v912; // [rsp+640h] [rbp+540h] BYREF
  volatile signed __int32 *v913; // [rsp+648h] [rbp+548h] BYREF
  volatile signed __int32 *v914; // [rsp+650h] [rbp+550h] BYREF
  volatile signed __int32 *v915; // [rsp+658h] [rbp+558h] BYREF
  volatile signed __int32 *v916; // [rsp+660h] [rbp+560h] BYREF
  volatile signed __int32 *v917; // [rsp+668h] [rbp+568h] BYREF
  volatile signed __int32 *v918; // [rsp+670h] [rbp+570h] BYREF
  volatile signed __int32 *v919; // [rsp+678h] [rbp+578h] BYREF
  volatile signed __int32 *v920; // [rsp+680h] [rbp+580h] BYREF
  volatile signed __int32 *v921; // [rsp+688h] [rbp+588h] BYREF
  volatile signed __int32 *v922; // [rsp+690h] [rbp+590h] BYREF
  volatile signed __int32 *v923; // [rsp+698h] [rbp+598h] BYREF
  volatile signed __int32 *v924; // [rsp+6A0h] [rbp+5A0h] BYREF
  volatile signed __int32 *v925; // [rsp+6A8h] [rbp+5A8h] BYREF
  volatile signed __int32 *v926; // [rsp+6B0h] [rbp+5B0h] BYREF
  volatile signed __int32 *v927; // [rsp+6B8h] [rbp+5B8h] BYREF
  volatile signed __int32 *v928; // [rsp+6C0h] [rbp+5C0h] BYREF
  volatile signed __int32 *v929; // [rsp+6C8h] [rbp+5C8h] BYREF
  volatile signed __int32 *v930; // [rsp+6D0h] [rbp+5D0h] BYREF
  volatile signed __int32 *v931; // [rsp+6D8h] [rbp+5D8h] BYREF
  volatile signed __int32 *v932; // [rsp+6E0h] [rbp+5E0h] BYREF
  volatile signed __int32 *v933; // [rsp+6E8h] [rbp+5E8h] BYREF
  volatile signed __int32 *v934; // [rsp+6F0h] [rbp+5F0h] BYREF
  volatile signed __int32 *v935; // [rsp+6F8h] [rbp+5F8h] BYREF
  volatile signed __int32 *v936; // [rsp+700h] [rbp+600h] BYREF
  volatile signed __int32 *v937; // [rsp+708h] [rbp+608h] BYREF
  volatile signed __int32 *v938; // [rsp+710h] [rbp+610h] BYREF
  volatile signed __int32 *v939; // [rsp+718h] [rbp+618h] BYREF
  volatile signed __int32 *v940; // [rsp+720h] [rbp+620h] BYREF
  volatile signed __int32 *v941; // [rsp+728h] [rbp+628h] BYREF
  volatile signed __int32 *v942; // [rsp+730h] [rbp+630h] BYREF
  volatile signed __int32 *v943; // [rsp+738h] [rbp+638h] BYREF
  volatile signed __int32 *v944; // [rsp+740h] [rbp+640h] BYREF
  volatile signed __int32 *v945; // [rsp+748h] [rbp+648h] BYREF
  volatile signed __int32 *v946; // [rsp+750h] [rbp+650h] BYREF
  volatile signed __int32 *v947; // [rsp+758h] [rbp+658h] BYREF
  volatile signed __int32 *v948; // [rsp+760h] [rbp+660h] BYREF
  volatile signed __int32 *v949; // [rsp+768h] [rbp+668h] BYREF
  volatile signed __int32 *v950; // [rsp+770h] [rbp+670h] BYREF
  volatile signed __int32 *v951; // [rsp+778h] [rbp+678h] BYREF
  volatile signed __int32 *v952; // [rsp+780h] [rbp+680h] BYREF
  volatile signed __int32 *v953; // [rsp+788h] [rbp+688h] BYREF
  volatile signed __int32 *v954; // [rsp+790h] [rbp+690h] BYREF
  volatile signed __int32 *v955; // [rsp+798h] [rbp+698h] BYREF
  volatile signed __int32 *v956; // [rsp+7A0h] [rbp+6A0h] BYREF
  volatile signed __int32 *v957; // [rsp+7A8h] [rbp+6A8h] BYREF
  volatile signed __int32 *v958; // [rsp+7B0h] [rbp+6B0h] BYREF
  volatile signed __int32 *v959; // [rsp+7B8h] [rbp+6B8h] BYREF
  volatile signed __int32 *v960; // [rsp+7C0h] [rbp+6C0h] BYREF
  volatile signed __int32 *v961; // [rsp+7C8h] [rbp+6C8h] BYREF
  volatile signed __int32 *v962; // [rsp+7D0h] [rbp+6D0h] BYREF
  volatile signed __int32 *v963; // [rsp+7D8h] [rbp+6D8h] BYREF
  volatile signed __int32 *v964; // [rsp+7E0h] [rbp+6E0h] BYREF
  volatile signed __int32 *v965; // [rsp+7E8h] [rbp+6E8h] BYREF
  volatile signed __int32 *v966; // [rsp+7F0h] [rbp+6F0h] BYREF
  volatile signed __int32 *v967; // [rsp+7F8h] [rbp+6F8h] BYREF
  volatile signed __int32 *v968; // [rsp+800h] [rbp+700h] BYREF
  volatile signed __int32 *v969; // [rsp+808h] [rbp+708h] BYREF
  volatile signed __int32 *v970; // [rsp+810h] [rbp+710h] BYREF
  volatile signed __int32 *v971; // [rsp+818h] [rbp+718h] BYREF
  volatile signed __int32 *v972; // [rsp+820h] [rbp+720h] BYREF
  volatile signed __int32 *v973; // [rsp+828h] [rbp+728h] BYREF
  volatile signed __int32 *v974; // [rsp+830h] [rbp+730h] BYREF
  volatile signed __int32 *v975; // [rsp+838h] [rbp+738h] BYREF
  volatile signed __int32 *v976; // [rsp+840h] [rbp+740h] BYREF
  volatile signed __int32 *v977; // [rsp+848h] [rbp+748h] BYREF
  volatile signed __int32 *v978; // [rsp+850h] [rbp+750h] BYREF
  volatile signed __int32 *v979; // [rsp+858h] [rbp+758h] BYREF
  volatile signed __int32 *v980; // [rsp+860h] [rbp+760h] BYREF
  volatile signed __int32 *v981; // [rsp+868h] [rbp+768h] BYREF
  volatile signed __int32 *v982; // [rsp+870h] [rbp+770h] BYREF
  volatile signed __int32 *v983; // [rsp+878h] [rbp+778h] BYREF
  volatile signed __int32 *v984; // [rsp+880h] [rbp+780h] BYREF
  volatile signed __int32 *v985; // [rsp+888h] [rbp+788h] BYREF
  volatile signed __int32 *v986; // [rsp+890h] [rbp+790h] BYREF
  volatile signed __int32 *v987; // [rsp+898h] [rbp+798h] BYREF
  volatile signed __int32 *v988; // [rsp+8A0h] [rbp+7A0h] BYREF
  volatile signed __int32 *v989; // [rsp+8A8h] [rbp+7A8h] BYREF
  volatile signed __int32 *v990; // [rsp+8B0h] [rbp+7B0h] BYREF
  volatile signed __int32 *v991; // [rsp+8B8h] [rbp+7B8h] BYREF
  volatile signed __int32 *v992; // [rsp+8C0h] [rbp+7C0h] BYREF
  volatile signed __int32 *v993; // [rsp+8C8h] [rbp+7C8h] BYREF
  volatile signed __int32 *v994; // [rsp+8D0h] [rbp+7D0h] BYREF
  volatile signed __int32 *v995; // [rsp+8D8h] [rbp+7D8h] BYREF
  volatile signed __int32 *v996; // [rsp+8E0h] [rbp+7E0h] BYREF
  volatile signed __int32 *v997; // [rsp+8E8h] [rbp+7E8h] BYREF
  volatile signed __int32 *v998; // [rsp+8F0h] [rbp+7F0h] BYREF
  volatile signed __int32 *v999; // [rsp+8F8h] [rbp+7F8h] BYREF
  volatile signed __int32 *v1000; // [rsp+900h] [rbp+800h] BYREF
  volatile signed __int32 *v1001; // [rsp+908h] [rbp+808h] BYREF
  volatile signed __int32 *v1002; // [rsp+910h] [rbp+810h] BYREF
  volatile signed __int32 *v1003; // [rsp+918h] [rbp+818h] BYREF
  volatile signed __int32 *v1004; // [rsp+920h] [rbp+820h] BYREF
  volatile signed __int32 *v1005; // [rsp+928h] [rbp+828h] BYREF
  volatile signed __int32 *v1006; // [rsp+930h] [rbp+830h] BYREF
  volatile signed __int32 *v1007; // [rsp+938h] [rbp+838h] BYREF
  volatile signed __int32 *v1008; // [rsp+940h] [rbp+840h] BYREF
  volatile signed __int32 *v1009; // [rsp+948h] [rbp+848h] BYREF
  volatile signed __int32 *v1010; // [rsp+950h] [rbp+850h] BYREF
  volatile signed __int32 *v1011; // [rsp+958h] [rbp+858h] BYREF
  volatile signed __int32 *v1012; // [rsp+960h] [rbp+860h] BYREF
  volatile signed __int32 *v1013; // [rsp+968h] [rbp+868h] BYREF
  volatile signed __int32 *v1014; // [rsp+970h] [rbp+870h] BYREF
  volatile signed __int32 *v1015; // [rsp+978h] [rbp+878h] BYREF
  volatile signed __int32 *v1016; // [rsp+980h] [rbp+880h] BYREF
  volatile signed __int32 *v1017; // [rsp+988h] [rbp+888h] BYREF
  volatile signed __int32 *v1018; // [rsp+990h] [rbp+890h] BYREF
  volatile signed __int32 *v1019; // [rsp+998h] [rbp+898h] BYREF
  volatile signed __int32 *v1020; // [rsp+9A0h] [rbp+8A0h] BYREF
  volatile signed __int32 *v1021; // [rsp+9A8h] [rbp+8A8h] BYREF
  volatile signed __int32 *v1022; // [rsp+9B0h] [rbp+8B0h] BYREF
  volatile signed __int32 *v1023; // [rsp+9B8h] [rbp+8B8h] BYREF
  volatile signed __int32 *v1024; // [rsp+9C0h] [rbp+8C0h] BYREF
  volatile signed __int32 *v1025; // [rsp+9C8h] [rbp+8C8h] BYREF
  volatile signed __int32 *v1026; // [rsp+9D0h] [rbp+8D0h] BYREF
  volatile signed __int32 *v1027; // [rsp+9D8h] [rbp+8D8h] BYREF
  volatile signed __int32 *v1028; // [rsp+9E0h] [rbp+8E0h] BYREF
  volatile signed __int32 *v1029; // [rsp+9E8h] [rbp+8E8h] BYREF
  volatile signed __int32 *v1030; // [rsp+9F0h] [rbp+8F0h] BYREF
  volatile signed __int32 *v1031; // [rsp+9F8h] [rbp+8F8h] BYREF
  volatile signed __int32 *v1032; // [rsp+A00h] [rbp+900h] BYREF
  _UNKNOWN **v1033; // [rsp+A08h] [rbp+908h] BYREF
  volatile signed __int32 *v1034; // [rsp+A10h] [rbp+910h]
  _UNKNOWN **v1035; // [rsp+A18h] [rbp+918h] BYREF
  volatile signed __int32 *v1036; // [rsp+A20h] [rbp+920h]
  _UNKNOWN **v1037; // [rsp+A28h] [rbp+928h] BYREF
  volatile signed __int32 *v1038; // [rsp+A30h] [rbp+930h]
  _UNKNOWN **v1039; // [rsp+A38h] [rbp+938h] BYREF
  volatile signed __int32 *v1040; // [rsp+A40h] [rbp+940h]
  _UNKNOWN **v1041; // [rsp+A48h] [rbp+948h] BYREF
  volatile signed __int32 *v1042; // [rsp+A50h] [rbp+950h]
  _UNKNOWN **v1043; // [rsp+A58h] [rbp+958h] BYREF
  volatile signed __int32 *v1044; // [rsp+A60h] [rbp+960h]
  _UNKNOWN **v1045; // [rsp+A68h] [rbp+968h] BYREF
  volatile signed __int32 *v1046; // [rsp+A70h] [rbp+970h]
  _UNKNOWN **v1047; // [rsp+A78h] [rbp+978h] BYREF
  volatile signed __int32 *v1048; // [rsp+A80h] [rbp+980h]
  _UNKNOWN **v1049; // [rsp+A88h] [rbp+988h] BYREF
  volatile signed __int32 *v1050; // [rsp+A90h] [rbp+990h]
  _UNKNOWN **v1051; // [rsp+A98h] [rbp+998h] BYREF
  volatile signed __int32 *v1052; // [rsp+AA0h] [rbp+9A0h]
  _UNKNOWN **v1053; // [rsp+AA8h] [rbp+9A8h] BYREF
  volatile signed __int32 *v1054; // [rsp+AB0h] [rbp+9B0h]
  _UNKNOWN **v1055; // [rsp+AB8h] [rbp+9B8h] BYREF
  volatile signed __int32 *v1056; // [rsp+AC0h] [rbp+9C0h]
  _UNKNOWN **v1057; // [rsp+AC8h] [rbp+9C8h] BYREF
  volatile signed __int32 *v1058; // [rsp+AD0h] [rbp+9D0h]
  _UNKNOWN **v1059; // [rsp+AD8h] [rbp+9D8h] BYREF
  volatile signed __int32 *v1060; // [rsp+AE0h] [rbp+9E0h]
  _UNKNOWN **v1061; // [rsp+AE8h] [rbp+9E8h] BYREF
  volatile signed __int32 *v1062; // [rsp+AF0h] [rbp+9F0h]
  _UNKNOWN **v1063; // [rsp+AF8h] [rbp+9F8h] BYREF
  volatile signed __int32 *v1064; // [rsp+B00h] [rbp+A00h]
  _UNKNOWN **v1065; // [rsp+B08h] [rbp+A08h] BYREF
  volatile signed __int32 *v1066; // [rsp+B10h] [rbp+A10h]
  _UNKNOWN **v1067; // [rsp+B18h] [rbp+A18h] BYREF
  volatile signed __int32 *v1068; // [rsp+B20h] [rbp+A20h]
  _UNKNOWN **v1069; // [rsp+B28h] [rbp+A28h] BYREF
  volatile signed __int32 *v1070; // [rsp+B30h] [rbp+A30h]
  _UNKNOWN **v1071; // [rsp+B38h] [rbp+A38h] BYREF
  volatile signed __int32 *v1072; // [rsp+B40h] [rbp+A40h]
  _UNKNOWN **v1073; // [rsp+B48h] [rbp+A48h] BYREF
  volatile signed __int32 *v1074; // [rsp+B50h] [rbp+A50h]
  _UNKNOWN **v1075; // [rsp+B58h] [rbp+A58h] BYREF
  volatile signed __int32 *v1076; // [rsp+B60h] [rbp+A60h]
  _UNKNOWN **v1077; // [rsp+B68h] [rbp+A68h] BYREF
  volatile signed __int32 *v1078; // [rsp+B70h] [rbp+A70h]
  _UNKNOWN **v1079; // [rsp+B78h] [rbp+A78h] BYREF
  volatile signed __int32 *v1080; // [rsp+B80h] [rbp+A80h]
  _UNKNOWN **v1081; // [rsp+B88h] [rbp+A88h] BYREF
  volatile signed __int32 *v1082; // [rsp+B90h] [rbp+A90h]
  _UNKNOWN **v1083; // [rsp+B98h] [rbp+A98h] BYREF
  volatile signed __int32 *v1084; // [rsp+BA0h] [rbp+AA0h]
  _UNKNOWN **v1085; // [rsp+BA8h] [rbp+AA8h] BYREF
  volatile signed __int32 *v1086; // [rsp+BB0h] [rbp+AB0h]
  _UNKNOWN **v1087; // [rsp+BB8h] [rbp+AB8h] BYREF
  volatile signed __int32 *v1088; // [rsp+BC0h] [rbp+AC0h]
  _UNKNOWN **v1089; // [rsp+BC8h] [rbp+AC8h] BYREF
  volatile signed __int32 *v1090; // [rsp+BD0h] [rbp+AD0h]
  _UNKNOWN **v1091; // [rsp+BD8h] [rbp+AD8h] BYREF
  volatile signed __int32 *v1092; // [rsp+BE0h] [rbp+AE0h]
  _UNKNOWN **v1093; // [rsp+BE8h] [rbp+AE8h] BYREF
  volatile signed __int32 *v1094; // [rsp+BF0h] [rbp+AF0h]
  _UNKNOWN **v1095; // [rsp+BF8h] [rbp+AF8h] BYREF
  volatile signed __int32 *v1096; // [rsp+C00h] [rbp+B00h]
  _UNKNOWN **v1097; // [rsp+C08h] [rbp+B08h] BYREF
  volatile signed __int32 *v1098; // [rsp+C10h] [rbp+B10h]
  _UNKNOWN **v1099; // [rsp+C18h] [rbp+B18h] BYREF
  volatile signed __int32 *v1100; // [rsp+C20h] [rbp+B20h]
  _UNKNOWN **v1101; // [rsp+C28h] [rbp+B28h] BYREF
  volatile signed __int32 *v1102; // [rsp+C30h] [rbp+B30h]
  _UNKNOWN **v1103; // [rsp+C38h] [rbp+B38h] BYREF
  volatile signed __int32 *v1104; // [rsp+C40h] [rbp+B40h]
  _UNKNOWN **v1105; // [rsp+C48h] [rbp+B48h] BYREF
  volatile signed __int32 *v1106; // [rsp+C50h] [rbp+B50h]
  _UNKNOWN **v1107; // [rsp+C58h] [rbp+B58h] BYREF
  volatile signed __int32 *v1108; // [rsp+C60h] [rbp+B60h]
  _UNKNOWN **v1109; // [rsp+C68h] [rbp+B68h] BYREF
  volatile signed __int32 *v1110; // [rsp+C70h] [rbp+B70h]
  _UNKNOWN **v1111; // [rsp+C78h] [rbp+B78h] BYREF
  volatile signed __int32 *v1112; // [rsp+C80h] [rbp+B80h]
  _UNKNOWN **v1113; // [rsp+C88h] [rbp+B88h] BYREF
  volatile signed __int32 *v1114; // [rsp+C90h] [rbp+B90h]
  _UNKNOWN **v1115; // [rsp+C98h] [rbp+B98h] BYREF
  volatile signed __int32 *v1116; // [rsp+CA0h] [rbp+BA0h]
  _UNKNOWN **v1117; // [rsp+CA8h] [rbp+BA8h] BYREF
  volatile signed __int32 *v1118; // [rsp+CB0h] [rbp+BB0h]
  _UNKNOWN **v1119; // [rsp+CB8h] [rbp+BB8h] BYREF
  volatile signed __int32 *v1120; // [rsp+CC0h] [rbp+BC0h]
  _UNKNOWN **v1121; // [rsp+CC8h] [rbp+BC8h] BYREF
  volatile signed __int32 *v1122; // [rsp+CD0h] [rbp+BD0h]
  _UNKNOWN **v1123; // [rsp+CD8h] [rbp+BD8h] BYREF
  volatile signed __int32 *v1124; // [rsp+CE0h] [rbp+BE0h]
  _UNKNOWN **v1125; // [rsp+CE8h] [rbp+BE8h] BYREF
  volatile signed __int32 *v1126; // [rsp+CF0h] [rbp+BF0h]
  _UNKNOWN **v1127; // [rsp+CF8h] [rbp+BF8h] BYREF
  volatile signed __int32 *v1128; // [rsp+D00h] [rbp+C00h]
  _UNKNOWN **v1129; // [rsp+D08h] [rbp+C08h] BYREF
  volatile signed __int32 *v1130; // [rsp+D10h] [rbp+C10h]
  _UNKNOWN **v1131; // [rsp+D18h] [rbp+C18h] BYREF
  volatile signed __int32 *v1132; // [rsp+D20h] [rbp+C20h]
  _UNKNOWN **v1133; // [rsp+D28h] [rbp+C28h] BYREF
  volatile signed __int32 *v1134; // [rsp+D30h] [rbp+C30h]
  _UNKNOWN **v1135; // [rsp+D38h] [rbp+C38h] BYREF
  volatile signed __int32 *v1136; // [rsp+D40h] [rbp+C40h]
  _UNKNOWN **v1137; // [rsp+D48h] [rbp+C48h] BYREF
  volatile signed __int32 *v1138; // [rsp+D50h] [rbp+C50h]
  _UNKNOWN **v1139; // [rsp+D58h] [rbp+C58h] BYREF
  volatile signed __int32 *v1140; // [rsp+D60h] [rbp+C60h]
  _UNKNOWN **v1141; // [rsp+D68h] [rbp+C68h] BYREF
  volatile signed __int32 *v1142; // [rsp+D70h] [rbp+C70h]
  _UNKNOWN **v1143; // [rsp+D78h] [rbp+C78h] BYREF
  volatile signed __int32 *v1144; // [rsp+D80h] [rbp+C80h]
  _UNKNOWN **v1145; // [rsp+D88h] [rbp+C88h] BYREF
  volatile signed __int32 *v1146; // [rsp+D90h] [rbp+C90h]
  _UNKNOWN **v1147; // [rsp+D98h] [rbp+C98h] BYREF
  volatile signed __int32 *v1148; // [rsp+DA0h] [rbp+CA0h]
  _UNKNOWN **v1149; // [rsp+DA8h] [rbp+CA8h] BYREF
  volatile signed __int32 *v1150; // [rsp+DB0h] [rbp+CB0h]
  _UNKNOWN **v1151; // [rsp+DB8h] [rbp+CB8h] BYREF
  volatile signed __int32 *v1152; // [rsp+DC0h] [rbp+CC0h]
  _UNKNOWN **v1153; // [rsp+DC8h] [rbp+CC8h] BYREF
  volatile signed __int32 *v1154; // [rsp+DD0h] [rbp+CD0h]
  _UNKNOWN **v1155; // [rsp+DD8h] [rbp+CD8h] BYREF
  volatile signed __int32 *v1156; // [rsp+DE0h] [rbp+CE0h]
  _UNKNOWN **v1157; // [rsp+DE8h] [rbp+CE8h] BYREF
  volatile signed __int32 *v1158; // [rsp+DF0h] [rbp+CF0h]
  _UNKNOWN **v1159; // [rsp+DF8h] [rbp+CF8h] BYREF
  volatile signed __int32 *v1160; // [rsp+E00h] [rbp+D00h]
  _UNKNOWN **v1161; // [rsp+E08h] [rbp+D08h] BYREF
  volatile signed __int32 *v1162; // [rsp+E10h] [rbp+D10h]
  _UNKNOWN **v1163; // [rsp+E18h] [rbp+D18h] BYREF
  volatile signed __int32 *v1164; // [rsp+E20h] [rbp+D20h]
  _UNKNOWN **v1165; // [rsp+E28h] [rbp+D28h] BYREF
  volatile signed __int32 *v1166; // [rsp+E30h] [rbp+D30h]
  _UNKNOWN **v1167; // [rsp+E38h] [rbp+D38h] BYREF
  volatile signed __int32 *v1168; // [rsp+E40h] [rbp+D40h]
  _UNKNOWN **v1169; // [rsp+E48h] [rbp+D48h] BYREF
  volatile signed __int32 *v1170; // [rsp+E50h] [rbp+D50h]
  _UNKNOWN **v1171; // [rsp+E58h] [rbp+D58h] BYREF
  volatile signed __int32 *v1172; // [rsp+E60h] [rbp+D60h]
  _UNKNOWN **v1173; // [rsp+E68h] [rbp+D68h] BYREF
  volatile signed __int32 *v1174; // [rsp+E70h] [rbp+D70h]
  _UNKNOWN **v1175; // [rsp+E78h] [rbp+D78h] BYREF
  volatile signed __int32 *v1176; // [rsp+E80h] [rbp+D80h]
  _UNKNOWN **v1177; // [rsp+E88h] [rbp+D88h] BYREF
  volatile signed __int32 *v1178; // [rsp+E90h] [rbp+D90h]
  _UNKNOWN **v1179; // [rsp+E98h] [rbp+D98h] BYREF
  volatile signed __int32 *v1180; // [rsp+EA0h] [rbp+DA0h]
  _UNKNOWN **v1181; // [rsp+EA8h] [rbp+DA8h] BYREF
  volatile signed __int32 *v1182; // [rsp+EB0h] [rbp+DB0h]
  _UNKNOWN **v1183; // [rsp+EB8h] [rbp+DB8h] BYREF
  volatile signed __int32 *v1184; // [rsp+EC0h] [rbp+DC0h]
  _UNKNOWN **v1185; // [rsp+EC8h] [rbp+DC8h] BYREF
  volatile signed __int32 *v1186; // [rsp+ED0h] [rbp+DD0h]
  _UNKNOWN **v1187; // [rsp+ED8h] [rbp+DD8h] BYREF
  volatile signed __int32 *v1188; // [rsp+EE0h] [rbp+DE0h]
  _UNKNOWN **v1189; // [rsp+EE8h] [rbp+DE8h] BYREF
  volatile signed __int32 *v1190; // [rsp+EF0h] [rbp+DF0h]
  _UNKNOWN **v1191; // [rsp+EF8h] [rbp+DF8h] BYREF
  volatile signed __int32 *v1192; // [rsp+F00h] [rbp+E00h]
  _UNKNOWN **v1193; // [rsp+F08h] [rbp+E08h] BYREF
  volatile signed __int32 *v1194; // [rsp+F10h] [rbp+E10h]
  _UNKNOWN **v1195; // [rsp+F18h] [rbp+E18h] BYREF
  volatile signed __int32 *v1196; // [rsp+F20h] [rbp+E20h]
  _UNKNOWN **v1197; // [rsp+F28h] [rbp+E28h] BYREF
  volatile signed __int32 *v1198; // [rsp+F30h] [rbp+E30h]
  _UNKNOWN **v1199; // [rsp+F38h] [rbp+E38h] BYREF
  volatile signed __int32 *v1200; // [rsp+F40h] [rbp+E40h]
  _UNKNOWN **v1201; // [rsp+F48h] [rbp+E48h] BYREF
  volatile signed __int32 *v1202; // [rsp+F50h] [rbp+E50h]
  _UNKNOWN **v1203; // [rsp+F58h] [rbp+E58h] BYREF
  volatile signed __int32 *v1204; // [rsp+F60h] [rbp+E60h]
  _UNKNOWN **v1205; // [rsp+F68h] [rbp+E68h] BYREF
  volatile signed __int32 *v1206; // [rsp+F70h] [rbp+E70h]
  _UNKNOWN **v1207; // [rsp+F78h] [rbp+E78h] BYREF
  volatile signed __int32 *v1208; // [rsp+F80h] [rbp+E80h]
  _UNKNOWN **v1209; // [rsp+F88h] [rbp+E88h] BYREF
  volatile signed __int32 *v1210; // [rsp+F90h] [rbp+E90h]
  _UNKNOWN **v1211; // [rsp+F98h] [rbp+E98h] BYREF
  volatile signed __int32 *v1212; // [rsp+FA0h] [rbp+EA0h]
  _UNKNOWN **v1213; // [rsp+FA8h] [rbp+EA8h] BYREF
  volatile signed __int32 *v1214; // [rsp+FB0h] [rbp+EB0h]
  _UNKNOWN **v1215; // [rsp+FB8h] [rbp+EB8h] BYREF
  volatile signed __int32 *v1216; // [rsp+FC0h] [rbp+EC0h]
  _UNKNOWN **v1217; // [rsp+FC8h] [rbp+EC8h] BYREF
  volatile signed __int32 *v1218; // [rsp+FD0h] [rbp+ED0h]
  _UNKNOWN **v1219; // [rsp+FD8h] [rbp+ED8h] BYREF
  volatile signed __int32 *v1220; // [rsp+FE0h] [rbp+EE0h]
  _UNKNOWN **v1221; // [rsp+FE8h] [rbp+EE8h] BYREF
  volatile signed __int32 *v1222; // [rsp+FF0h] [rbp+EF0h]
  _UNKNOWN **v1223; // [rsp+FF8h] [rbp+EF8h] BYREF
  volatile signed __int32 *v1224; // [rsp+1000h] [rbp+F00h]
  _UNKNOWN **v1225; // [rsp+1008h] [rbp+F08h] BYREF
  volatile signed __int32 *v1226; // [rsp+1010h] [rbp+F10h]
  _UNKNOWN **v1227; // [rsp+1018h] [rbp+F18h] BYREF
  volatile signed __int32 *v1228; // [rsp+1020h] [rbp+F20h]
  _UNKNOWN **v1229; // [rsp+1028h] [rbp+F28h] BYREF
  volatile signed __int32 *v1230; // [rsp+1030h] [rbp+F30h]
  _UNKNOWN **v1231; // [rsp+1038h] [rbp+F38h] BYREF
  volatile signed __int32 *v1232; // [rsp+1040h] [rbp+F40h]
  _UNKNOWN **v1233; // [rsp+1048h] [rbp+F48h] BYREF
  volatile signed __int32 *v1234; // [rsp+1050h] [rbp+F50h]
  _UNKNOWN **v1235; // [rsp+1058h] [rbp+F58h] BYREF
  volatile signed __int32 *v1236; // [rsp+1060h] [rbp+F60h]
  _UNKNOWN **v1237; // [rsp+1068h] [rbp+F68h] BYREF
  volatile signed __int32 *v1238; // [rsp+1070h] [rbp+F70h]
  _UNKNOWN **v1239; // [rsp+1078h] [rbp+F78h] BYREF
  volatile signed __int32 *v1240; // [rsp+1080h] [rbp+F80h]
  _UNKNOWN **v1241; // [rsp+1088h] [rbp+F88h] BYREF
  volatile signed __int32 *v1242; // [rsp+1090h] [rbp+F90h]
  _UNKNOWN **v1243; // [rsp+1098h] [rbp+F98h] BYREF
  volatile signed __int32 *v1244; // [rsp+10A0h] [rbp+FA0h]
  _UNKNOWN **v1245; // [rsp+10A8h] [rbp+FA8h] BYREF
  volatile signed __int32 *v1246; // [rsp+10B0h] [rbp+FB0h]
  _UNKNOWN **v1247; // [rsp+10B8h] [rbp+FB8h] BYREF
  volatile signed __int32 *v1248; // [rsp+10C0h] [rbp+FC0h]
  _UNKNOWN **v1249; // [rsp+10C8h] [rbp+FC8h] BYREF
  volatile signed __int32 *v1250; // [rsp+10D0h] [rbp+FD0h]
  _UNKNOWN **v1251; // [rsp+10D8h] [rbp+FD8h] BYREF
  volatile signed __int32 *v1252; // [rsp+10E0h] [rbp+FE0h]
  _UNKNOWN **v1253; // [rsp+10E8h] [rbp+FE8h] BYREF
  volatile signed __int32 *v1254; // [rsp+10F0h] [rbp+FF0h]
  _UNKNOWN **v1255; // [rsp+10F8h] [rbp+FF8h] BYREF
  volatile signed __int32 *v1256; // [rsp+1100h] [rbp+1000h]
  _UNKNOWN **v1257; // [rsp+1108h] [rbp+1008h] BYREF
  volatile signed __int32 *v1258; // [rsp+1110h] [rbp+1010h]
  _UNKNOWN **v1259; // [rsp+1118h] [rbp+1018h] BYREF
  volatile signed __int32 *v1260; // [rsp+1120h] [rbp+1020h]
  _UNKNOWN **v1261; // [rsp+1128h] [rbp+1028h] BYREF
  volatile signed __int32 *v1262; // [rsp+1130h] [rbp+1030h]
  _UNKNOWN **v1263; // [rsp+1138h] [rbp+1038h] BYREF
  volatile signed __int32 *v1264; // [rsp+1140h] [rbp+1040h]
  _UNKNOWN **v1265; // [rsp+1148h] [rbp+1048h] BYREF
  volatile signed __int32 *v1266; // [rsp+1150h] [rbp+1050h]
  _UNKNOWN **v1267; // [rsp+1158h] [rbp+1058h] BYREF
  volatile signed __int32 *v1268; // [rsp+1160h] [rbp+1060h]
  _UNKNOWN **v1269; // [rsp+1168h] [rbp+1068h] BYREF
  volatile signed __int32 *v1270; // [rsp+1170h] [rbp+1070h]
  _UNKNOWN **v1271; // [rsp+1178h] [rbp+1078h] BYREF
  volatile signed __int32 *v1272; // [rsp+1180h] [rbp+1080h]
  _UNKNOWN **v1273; // [rsp+1188h] [rbp+1088h] BYREF
  volatile signed __int32 *v1274; // [rsp+1190h] [rbp+1090h]
  _UNKNOWN **v1275; // [rsp+1198h] [rbp+1098h] BYREF
  volatile signed __int32 *v1276; // [rsp+11A0h] [rbp+10A0h]
  _UNKNOWN **v1277; // [rsp+11A8h] [rbp+10A8h] BYREF
  volatile signed __int32 *v1278; // [rsp+11B0h] [rbp+10B0h]
  _UNKNOWN **v1279; // [rsp+11B8h] [rbp+10B8h] BYREF
  volatile signed __int32 *v1280; // [rsp+11C0h] [rbp+10C0h]
  _UNKNOWN **v1281; // [rsp+11C8h] [rbp+10C8h] BYREF
  volatile signed __int32 *v1282; // [rsp+11D0h] [rbp+10D0h]
  _UNKNOWN **v1283; // [rsp+11D8h] [rbp+10D8h] BYREF
  volatile signed __int32 *v1284; // [rsp+11E0h] [rbp+10E0h]
  _UNKNOWN **v1285; // [rsp+11E8h] [rbp+10E8h] BYREF
  volatile signed __int32 *v1286; // [rsp+11F0h] [rbp+10F0h]
  _UNKNOWN **v1287; // [rsp+11F8h] [rbp+10F8h] BYREF
  volatile signed __int32 *v1288; // [rsp+1200h] [rbp+1100h]
  _UNKNOWN **v1289; // [rsp+1208h] [rbp+1108h] BYREF
  volatile signed __int32 *v1290; // [rsp+1210h] [rbp+1110h]
  _UNKNOWN **v1291; // [rsp+1218h] [rbp+1118h] BYREF
  volatile signed __int32 *v1292; // [rsp+1220h] [rbp+1120h]
  _UNKNOWN **v1293; // [rsp+1228h] [rbp+1128h] BYREF
  volatile signed __int32 *v1294; // [rsp+1230h] [rbp+1130h]
  _UNKNOWN **v1295; // [rsp+1238h] [rbp+1138h] BYREF
  volatile signed __int32 *v1296; // [rsp+1240h] [rbp+1140h]
  _UNKNOWN **v1297; // [rsp+1248h] [rbp+1148h] BYREF
  volatile signed __int32 *v1298; // [rsp+1250h] [rbp+1150h]
  _UNKNOWN **v1299; // [rsp+1258h] [rbp+1158h] BYREF
  volatile signed __int32 *v1300; // [rsp+1260h] [rbp+1160h]
  _UNKNOWN **v1301; // [rsp+1268h] [rbp+1168h] BYREF
  volatile signed __int32 *v1302; // [rsp+1270h] [rbp+1170h]
  _UNKNOWN **v1303; // [rsp+1278h] [rbp+1178h] BYREF
  volatile signed __int32 *v1304; // [rsp+1280h] [rbp+1180h]
  _UNKNOWN **v1305; // [rsp+1288h] [rbp+1188h] BYREF
  volatile signed __int32 *v1306; // [rsp+1290h] [rbp+1190h]
  _UNKNOWN **v1307; // [rsp+1298h] [rbp+1198h] BYREF
  volatile signed __int32 *v1308; // [rsp+12A0h] [rbp+11A0h]
  _UNKNOWN **v1309; // [rsp+12A8h] [rbp+11A8h] BYREF
  volatile signed __int32 *v1310; // [rsp+12B0h] [rbp+11B0h]
  _UNKNOWN **v1311; // [rsp+12B8h] [rbp+11B8h] BYREF
  volatile signed __int32 *v1312; // [rsp+12C0h] [rbp+11C0h]
  _UNKNOWN **v1313; // [rsp+12C8h] [rbp+11C8h] BYREF
  volatile signed __int32 *v1314; // [rsp+12D0h] [rbp+11D0h]
  _UNKNOWN **v1315; // [rsp+12D8h] [rbp+11D8h] BYREF
  volatile signed __int32 *v1316; // [rsp+12E0h] [rbp+11E0h]
  _UNKNOWN **v1317; // [rsp+12E8h] [rbp+11E8h] BYREF
  volatile signed __int32 *v1318; // [rsp+12F0h] [rbp+11F0h]
  _UNKNOWN **v1319; // [rsp+12F8h] [rbp+11F8h] BYREF
  volatile signed __int32 *v1320; // [rsp+1300h] [rbp+1200h]
  _UNKNOWN **v1321; // [rsp+1308h] [rbp+1208h] BYREF
  volatile signed __int32 *v1322; // [rsp+1310h] [rbp+1210h]
  _UNKNOWN **v1323; // [rsp+1318h] [rbp+1218h] BYREF
  volatile signed __int32 *v1324; // [rsp+1320h] [rbp+1220h]
  _UNKNOWN **v1325; // [rsp+1328h] [rbp+1228h] BYREF
  volatile signed __int32 *v1326; // [rsp+1330h] [rbp+1230h]
  _UNKNOWN **v1327; // [rsp+1338h] [rbp+1238h] BYREF
  volatile signed __int32 *v1328; // [rsp+1340h] [rbp+1240h]
  _UNKNOWN **v1329; // [rsp+1348h] [rbp+1248h] BYREF
  volatile signed __int32 *v1330; // [rsp+1350h] [rbp+1250h]
  _UNKNOWN **v1331; // [rsp+1358h] [rbp+1258h] BYREF
  volatile signed __int32 *v1332; // [rsp+1360h] [rbp+1260h]
  _UNKNOWN **v1333; // [rsp+1368h] [rbp+1268h] BYREF
  volatile signed __int32 *v1334; // [rsp+1370h] [rbp+1270h]
  _UNKNOWN **v1335; // [rsp+1378h] [rbp+1278h] BYREF
  volatile signed __int32 *v1336; // [rsp+1380h] [rbp+1280h]
  _UNKNOWN **v1337; // [rsp+1388h] [rbp+1288h] BYREF
  volatile signed __int32 *v1338; // [rsp+1390h] [rbp+1290h]
  _UNKNOWN **v1339; // [rsp+1398h] [rbp+1298h] BYREF
  volatile signed __int32 *v1340; // [rsp+13A0h] [rbp+12A0h]
  _UNKNOWN **v1341; // [rsp+13A8h] [rbp+12A8h] BYREF
  volatile signed __int32 *v1342; // [rsp+13B0h] [rbp+12B0h]
  _UNKNOWN **v1343; // [rsp+13B8h] [rbp+12B8h] BYREF
  volatile signed __int32 *v1344; // [rsp+13C0h] [rbp+12C0h]
  _UNKNOWN **v1345; // [rsp+13C8h] [rbp+12C8h] BYREF
  volatile signed __int32 *v1346; // [rsp+13D0h] [rbp+12D0h]
  _UNKNOWN **v1347; // [rsp+13D8h] [rbp+12D8h] BYREF
  volatile signed __int32 *v1348; // [rsp+13E0h] [rbp+12E0h]
  _UNKNOWN **v1349; // [rsp+13E8h] [rbp+12E8h] BYREF
  volatile signed __int32 *v1350; // [rsp+13F0h] [rbp+12F0h]
  _UNKNOWN **v1351; // [rsp+13F8h] [rbp+12F8h] BYREF
  volatile signed __int32 *v1352; // [rsp+1400h] [rbp+1300h]
  _UNKNOWN **v1353; // [rsp+1408h] [rbp+1308h] BYREF
  volatile signed __int32 *v1354; // [rsp+1410h] [rbp+1310h]
  _UNKNOWN **v1355; // [rsp+1418h] [rbp+1318h] BYREF
  volatile signed __int32 *v1356; // [rsp+1420h] [rbp+1320h]
  _UNKNOWN **v1357; // [rsp+1428h] [rbp+1328h] BYREF
  volatile signed __int32 *v1358; // [rsp+1430h] [rbp+1330h]
  _UNKNOWN **v1359; // [rsp+1438h] [rbp+1338h] BYREF
  volatile signed __int32 *v1360; // [rsp+1440h] [rbp+1340h]
  _UNKNOWN **v1361; // [rsp+1448h] [rbp+1348h] BYREF
  volatile signed __int32 *v1362; // [rsp+1450h] [rbp+1350h]
  _UNKNOWN **v1363; // [rsp+1458h] [rbp+1358h] BYREF
  volatile signed __int32 *v1364; // [rsp+1460h] [rbp+1360h]
  _UNKNOWN **v1365; // [rsp+1468h] [rbp+1368h] BYREF
  volatile signed __int32 *v1366; // [rsp+1470h] [rbp+1370h]
  _UNKNOWN **v1367; // [rsp+1478h] [rbp+1378h] BYREF
  volatile signed __int32 *v1368; // [rsp+1480h] [rbp+1380h]
  _UNKNOWN **v1369; // [rsp+1488h] [rbp+1388h] BYREF
  volatile signed __int32 *v1370; // [rsp+1490h] [rbp+1390h]
  _UNKNOWN **v1371; // [rsp+1498h] [rbp+1398h] BYREF
  volatile signed __int32 *v1372; // [rsp+14A0h] [rbp+13A0h]
  _UNKNOWN **v1373; // [rsp+14A8h] [rbp+13A8h] BYREF
  volatile signed __int32 *v1374; // [rsp+14B0h] [rbp+13B0h]
  _UNKNOWN **v1375; // [rsp+14B8h] [rbp+13B8h] BYREF
  volatile signed __int32 *v1376; // [rsp+14C0h] [rbp+13C0h]
  _UNKNOWN **v1377; // [rsp+14C8h] [rbp+13C8h] BYREF
  volatile signed __int32 *v1378; // [rsp+14D0h] [rbp+13D0h]
  _UNKNOWN **v1379; // [rsp+14D8h] [rbp+13D8h] BYREF
  volatile signed __int32 *v1380; // [rsp+14E0h] [rbp+13E0h]
  _UNKNOWN **v1381; // [rsp+14E8h] [rbp+13E8h] BYREF
  volatile signed __int32 *v1382; // [rsp+14F0h] [rbp+13F0h]
  _UNKNOWN **v1383; // [rsp+14F8h] [rbp+13F8h] BYREF
  volatile signed __int32 *v1384; // [rsp+1500h] [rbp+1400h]
  _UNKNOWN **v1385; // [rsp+1508h] [rbp+1408h] BYREF
  volatile signed __int32 *v1386; // [rsp+1510h] [rbp+1410h]
  _UNKNOWN **v1387; // [rsp+1518h] [rbp+1418h] BYREF
  volatile signed __int32 *v1388; // [rsp+1520h] [rbp+1420h]
  _UNKNOWN **v1389; // [rsp+1528h] [rbp+1428h] BYREF
  volatile signed __int32 *v1390; // [rsp+1530h] [rbp+1430h]
  _UNKNOWN **v1391; // [rsp+1538h] [rbp+1438h] BYREF
  volatile signed __int32 *v1392; // [rsp+1540h] [rbp+1440h]
  _UNKNOWN **v1393; // [rsp+1548h] [rbp+1448h] BYREF
  volatile signed __int32 *v1394; // [rsp+1550h] [rbp+1450h]
  _UNKNOWN **v1395; // [rsp+1558h] [rbp+1458h] BYREF
  volatile signed __int32 *v1396; // [rsp+1560h] [rbp+1460h]
  _UNKNOWN **v1397; // [rsp+1568h] [rbp+1468h] BYREF
  volatile signed __int32 *v1398; // [rsp+1570h] [rbp+1470h]
  _UNKNOWN **v1399; // [rsp+1578h] [rbp+1478h] BYREF
  volatile signed __int32 *v1400; // [rsp+1580h] [rbp+1480h]
  _UNKNOWN **v1401; // [rsp+1588h] [rbp+1488h] BYREF
  volatile signed __int32 *v1402; // [rsp+1590h] [rbp+1490h]
  _UNKNOWN **v1403; // [rsp+1598h] [rbp+1498h] BYREF
  volatile signed __int32 *v1404; // [rsp+15A0h] [rbp+14A0h]
  _UNKNOWN **v1405; // [rsp+15A8h] [rbp+14A8h] BYREF
  volatile signed __int32 *v1406; // [rsp+15B0h] [rbp+14B0h]
  _UNKNOWN **v1407; // [rsp+15B8h] [rbp+14B8h] BYREF
  volatile signed __int32 *v1408; // [rsp+15C0h] [rbp+14C0h]
  _UNKNOWN **v1409; // [rsp+15C8h] [rbp+14C8h] BYREF
  volatile signed __int32 *v1410; // [rsp+15D0h] [rbp+14D0h]
  _UNKNOWN **v1411; // [rsp+15D8h] [rbp+14D8h] BYREF
  volatile signed __int32 *v1412; // [rsp+15E0h] [rbp+14E0h]
  _UNKNOWN **v1413; // [rsp+15E8h] [rbp+14E8h] BYREF
  volatile signed __int32 *v1414; // [rsp+15F0h] [rbp+14F0h]
  _UNKNOWN **v1415; // [rsp+15F8h] [rbp+14F8h] BYREF
  volatile signed __int32 *v1416; // [rsp+1600h] [rbp+1500h]
  _UNKNOWN **v1417; // [rsp+1608h] [rbp+1508h] BYREF
  volatile signed __int32 *v1418; // [rsp+1610h] [rbp+1510h]
  _UNKNOWN **v1419; // [rsp+1618h] [rbp+1518h] BYREF
  volatile signed __int32 *v1420; // [rsp+1620h] [rbp+1520h]
  _UNKNOWN **v1421; // [rsp+1628h] [rbp+1528h] BYREF
  volatile signed __int32 *v1422; // [rsp+1630h] [rbp+1530h]
  _UNKNOWN **v1423; // [rsp+1638h] [rbp+1538h] BYREF
  volatile signed __int32 *v1424; // [rsp+1640h] [rbp+1540h]
  _UNKNOWN **v1425; // [rsp+1648h] [rbp+1548h] BYREF
  volatile signed __int32 *v1426; // [rsp+1650h] [rbp+1550h]
  _UNKNOWN **v1427; // [rsp+1658h] [rbp+1558h] BYREF
  volatile signed __int32 *v1428; // [rsp+1660h] [rbp+1560h]
  _UNKNOWN **v1429; // [rsp+1668h] [rbp+1568h] BYREF
  volatile signed __int32 *v1430; // [rsp+1670h] [rbp+1570h]
  _UNKNOWN **v1431; // [rsp+1678h] [rbp+1578h] BYREF
  volatile signed __int32 *v1432; // [rsp+1680h] [rbp+1580h]
  _UNKNOWN **v1433; // [rsp+1688h] [rbp+1588h] BYREF
  volatile signed __int32 *v1434; // [rsp+1690h] [rbp+1590h]
  _UNKNOWN **v1435; // [rsp+1698h] [rbp+1598h] BYREF
  volatile signed __int32 *v1436; // [rsp+16A0h] [rbp+15A0h]
  _UNKNOWN **v1437; // [rsp+16A8h] [rbp+15A8h] BYREF
  volatile signed __int32 *v1438; // [rsp+16B0h] [rbp+15B0h]
  _UNKNOWN **v1439; // [rsp+16B8h] [rbp+15B8h] BYREF
  volatile signed __int32 *v1440; // [rsp+16C0h] [rbp+15C0h]
  _UNKNOWN **v1441; // [rsp+16C8h] [rbp+15C8h] BYREF
  volatile signed __int32 *v1442; // [rsp+16D0h] [rbp+15D0h]
  _UNKNOWN **v1443; // [rsp+16D8h] [rbp+15D8h] BYREF
  volatile signed __int32 *v1444; // [rsp+16E0h] [rbp+15E0h]
  _UNKNOWN **v1445; // [rsp+16E8h] [rbp+15E8h] BYREF
  volatile signed __int32 *v1446; // [rsp+16F0h] [rbp+15F0h]
  _UNKNOWN **v1447; // [rsp+16F8h] [rbp+15F8h] BYREF
  volatile signed __int32 *v1448; // [rsp+1700h] [rbp+1600h]
  _UNKNOWN **v1449; // [rsp+1708h] [rbp+1608h] BYREF
  volatile signed __int32 *v1450; // [rsp+1710h] [rbp+1610h]
  _UNKNOWN **v1451; // [rsp+1718h] [rbp+1618h] BYREF
  volatile signed __int32 *v1452; // [rsp+1720h] [rbp+1620h]
  _UNKNOWN **v1453; // [rsp+1728h] [rbp+1628h] BYREF
  volatile signed __int32 *v1454; // [rsp+1730h] [rbp+1630h]
  _UNKNOWN **v1455; // [rsp+1738h] [rbp+1638h] BYREF
  volatile signed __int32 *v1456; // [rsp+1740h] [rbp+1640h]
  _UNKNOWN **v1457; // [rsp+1748h] [rbp+1648h] BYREF
  volatile signed __int32 *v1458; // [rsp+1750h] [rbp+1650h]
  _UNKNOWN **v1459; // [rsp+1758h] [rbp+1658h] BYREF
  volatile signed __int32 *v1460; // [rsp+1760h] [rbp+1660h]
  __int64 v1461; // [rsp+1768h] [rbp+1668h] BYREF
  __int64 v1462; // [rsp+1770h] [rbp+1670h] BYREF
  __int64 v1463; // [rsp+1778h] [rbp+1678h] BYREF
  __int64 v1464; // [rsp+1780h] [rbp+1680h] BYREF
  __int64 v1465; // [rsp+1788h] [rbp+1688h] BYREF
  __int64 v1466; // [rsp+1790h] [rbp+1690h] BYREF
  __int64 v1467; // [rsp+1798h] [rbp+1698h] BYREF
  __int64 v1468; // [rsp+17A0h] [rbp+16A0h] BYREF
  __int64 v1469; // [rsp+17A8h] [rbp+16A8h] BYREF
  __int64 v1470; // [rsp+17B0h] [rbp+16B0h] BYREF
  __int64 v1471; // [rsp+17B8h] [rbp+16B8h] BYREF
  __int64 v1472; // [rsp+17C0h] [rbp+16C0h] BYREF
  __int64 v1473; // [rsp+17C8h] [rbp+16C8h] BYREF
  __int64 v1474; // [rsp+17D0h] [rbp+16D0h] BYREF
  __int64 v1475; // [rsp+17D8h] [rbp+16D8h] BYREF
  __int64 v1476; // [rsp+17E0h] [rbp+16E0h] BYREF
  __int64 v1477; // [rsp+17E8h] [rbp+16E8h] BYREF
  __int64 v1478; // [rsp+17F0h] [rbp+16F0h] BYREF
  __int64 v1479; // [rsp+17F8h] [rbp+16F8h] BYREF
  __int64 v1480; // [rsp+1800h] [rbp+1700h] BYREF
  __int64 v1481; // [rsp+1808h] [rbp+1708h] BYREF
  __int64 v1482; // [rsp+1810h] [rbp+1710h] BYREF
  __int64 v1483; // [rsp+1818h] [rbp+1718h] BYREF
  __int64 v1484; // [rsp+1820h] [rbp+1720h] BYREF
  __int64 v1485; // [rsp+1828h] [rbp+1728h] BYREF
  __int64 v1486; // [rsp+1830h] [rbp+1730h] BYREF
  __int64 v1487; // [rsp+1838h] [rbp+1738h] BYREF
  __int64 v1488; // [rsp+1840h] [rbp+1740h] BYREF
  _QWORD v1489[2]; // [rsp+1848h] [rbp+1748h] BYREF
  _QWORD v1490[2]; // [rsp+1858h] [rbp+1758h] BYREF
  _QWORD v1491[2]; // [rsp+1868h] [rbp+1768h] BYREF
  _QWORD v1492[2]; // [rsp+1878h] [rbp+1778h] BYREF
  _QWORD v1493[2]; // [rsp+1888h] [rbp+1788h] BYREF
  _QWORD v1494[2]; // [rsp+1898h] [rbp+1798h] BYREF
  _QWORD v1495[2]; // [rsp+18A8h] [rbp+17A8h] BYREF
  _QWORD v1496[2]; // [rsp+18B8h] [rbp+17B8h] BYREF
  _QWORD v1497[2]; // [rsp+18C8h] [rbp+17C8h] BYREF
  _QWORD v1498[2]; // [rsp+18D8h] [rbp+17D8h] BYREF
  _QWORD v1499[2]; // [rsp+18E8h] [rbp+17E8h] BYREF
  _QWORD v1500[2]; // [rsp+18F8h] [rbp+17F8h] BYREF
  _QWORD v1501[2]; // [rsp+1908h] [rbp+1808h] BYREF
  _QWORD v1502[2]; // [rsp+1918h] [rbp+1818h] BYREF
  _QWORD v1503[2]; // [rsp+1928h] [rbp+1828h] BYREF
  _QWORD v1504[2]; // [rsp+1938h] [rbp+1838h] BYREF
  _QWORD v1505[2]; // [rsp+1948h] [rbp+1848h] BYREF
  _QWORD v1506[2]; // [rsp+1958h] [rbp+1858h] BYREF
  _QWORD v1507[2]; // [rsp+1968h] [rbp+1868h] BYREF
  _QWORD v1508[2]; // [rsp+1978h] [rbp+1878h] BYREF
  _QWORD v1509[2]; // [rsp+1988h] [rbp+1888h] BYREF
  _QWORD v1510[2]; // [rsp+1998h] [rbp+1898h] BYREF
  _QWORD v1511[2]; // [rsp+19A8h] [rbp+18A8h] BYREF
  _QWORD v1512[2]; // [rsp+19B8h] [rbp+18B8h] BYREF
  _QWORD v1513[2]; // [rsp+19C8h] [rbp+18C8h] BYREF
  _QWORD v1514[2]; // [rsp+19D8h] [rbp+18D8h] BYREF
  _QWORD v1515[2]; // [rsp+19E8h] [rbp+18E8h] BYREF
  _QWORD v1516[2]; // [rsp+19F8h] [rbp+18F8h] BYREF
  _QWORD v1517[2]; // [rsp+1A08h] [rbp+1908h] BYREF
  _QWORD v1518[2]; // [rsp+1A18h] [rbp+1918h] BYREF
  _QWORD v1519[2]; // [rsp+1A28h] [rbp+1928h] BYREF
  _QWORD v1520[2]; // [rsp+1A38h] [rbp+1938h] BYREF
  _QWORD v1521[2]; // [rsp+1A48h] [rbp+1948h] BYREF
  _QWORD v1522[2]; // [rsp+1A58h] [rbp+1958h] BYREF
  _QWORD v1523[2]; // [rsp+1A68h] [rbp+1968h] BYREF
  _QWORD v1524[2]; // [rsp+1A78h] [rbp+1978h] BYREF
  _QWORD v1525[2]; // [rsp+1A88h] [rbp+1988h] BYREF
  _QWORD v1526[2]; // [rsp+1A98h] [rbp+1998h] BYREF
  _QWORD v1527[2]; // [rsp+1AA8h] [rbp+19A8h] BYREF
  _QWORD v1528[2]; // [rsp+1AB8h] [rbp+19B8h] BYREF
  _QWORD v1529[2]; // [rsp+1AC8h] [rbp+19C8h] BYREF
  _QWORD v1530[2]; // [rsp+1AD8h] [rbp+19D8h] BYREF
  _QWORD v1531[2]; // [rsp+1AE8h] [rbp+19E8h] BYREF
  _QWORD v1532[2]; // [rsp+1AF8h] [rbp+19F8h] BYREF
  _QWORD v1533[2]; // [rsp+1B08h] [rbp+1A08h] BYREF
  _QWORD v1534[2]; // [rsp+1B18h] [rbp+1A18h] BYREF
  _QWORD v1535[2]; // [rsp+1B28h] [rbp+1A28h] BYREF
  _QWORD v1536[2]; // [rsp+1B38h] [rbp+1A38h] BYREF
  _QWORD v1537[2]; // [rsp+1B48h] [rbp+1A48h] BYREF
  _QWORD v1538[2]; // [rsp+1B58h] [rbp+1A58h] BYREF
  _QWORD v1539[2]; // [rsp+1B68h] [rbp+1A68h] BYREF
  _QWORD v1540[2]; // [rsp+1B78h] [rbp+1A78h] BYREF
  _QWORD v1541[2]; // [rsp+1B88h] [rbp+1A88h] BYREF
  _QWORD v1542[2]; // [rsp+1B98h] [rbp+1A98h] BYREF
  _QWORD v1543[2]; // [rsp+1BA8h] [rbp+1AA8h] BYREF
  _QWORD v1544[2]; // [rsp+1BB8h] [rbp+1AB8h] BYREF
  _QWORD v1545[2]; // [rsp+1BC8h] [rbp+1AC8h] BYREF
  _QWORD v1546[2]; // [rsp+1BD8h] [rbp+1AD8h] BYREF
  _QWORD v1547[2]; // [rsp+1BE8h] [rbp+1AE8h] BYREF
  _QWORD v1548[2]; // [rsp+1BF8h] [rbp+1AF8h] BYREF
  _QWORD v1549[2]; // [rsp+1C08h] [rbp+1B08h] BYREF
  _QWORD v1550[2]; // [rsp+1C18h] [rbp+1B18h] BYREF
  _QWORD v1551[2]; // [rsp+1C28h] [rbp+1B28h] BYREF
  _QWORD v1552[2]; // [rsp+1C38h] [rbp+1B38h] BYREF
  _QWORD v1553[2]; // [rsp+1C48h] [rbp+1B48h] BYREF
  _QWORD v1554[2]; // [rsp+1C58h] [rbp+1B58h] BYREF
  _QWORD v1555[2]; // [rsp+1C68h] [rbp+1B68h] BYREF
  _QWORD v1556[2]; // [rsp+1C78h] [rbp+1B78h] BYREF
  _QWORD v1557[2]; // [rsp+1C88h] [rbp+1B88h] BYREF
  _QWORD v1558[2]; // [rsp+1C98h] [rbp+1B98h] BYREF
  _QWORD v1559[2]; // [rsp+1CA8h] [rbp+1BA8h] BYREF
  _QWORD v1560[2]; // [rsp+1CB8h] [rbp+1BB8h] BYREF
  _QWORD v1561[2]; // [rsp+1CC8h] [rbp+1BC8h] BYREF
  _QWORD v1562[2]; // [rsp+1CD8h] [rbp+1BD8h] BYREF
  _QWORD v1563[2]; // [rsp+1CE8h] [rbp+1BE8h] BYREF
  _QWORD v1564[2]; // [rsp+1CF8h] [rbp+1BF8h] BYREF
  _QWORD v1565[2]; // [rsp+1D08h] [rbp+1C08h] BYREF
  _QWORD v1566[2]; // [rsp+1D18h] [rbp+1C18h] BYREF
  _QWORD v1567[2]; // [rsp+1D28h] [rbp+1C28h] BYREF
  _QWORD v1568[2]; // [rsp+1D38h] [rbp+1C38h] BYREF
  _QWORD v1569[2]; // [rsp+1D48h] [rbp+1C48h] BYREF
  _QWORD v1570[2]; // [rsp+1D58h] [rbp+1C58h] BYREF
  _QWORD v1571[2]; // [rsp+1D68h] [rbp+1C68h] BYREF
  _QWORD v1572[2]; // [rsp+1D78h] [rbp+1C78h] BYREF
  _QWORD v1573[2]; // [rsp+1D88h] [rbp+1C88h] BYREF
  _QWORD v1574[2]; // [rsp+1D98h] [rbp+1C98h] BYREF
  _QWORD v1575[2]; // [rsp+1DA8h] [rbp+1CA8h] BYREF
  _QWORD v1576[2]; // [rsp+1DB8h] [rbp+1CB8h] BYREF
  _QWORD v1577[2]; // [rsp+1DC8h] [rbp+1CC8h] BYREF
  _QWORD v1578[2]; // [rsp+1DD8h] [rbp+1CD8h] BYREF
  _QWORD v1579[2]; // [rsp+1DE8h] [rbp+1CE8h] BYREF
  _QWORD v1580[2]; // [rsp+1DF8h] [rbp+1CF8h] BYREF
  _QWORD v1581[2]; // [rsp+1E08h] [rbp+1D08h] BYREF
  _QWORD v1582[2]; // [rsp+1E18h] [rbp+1D18h] BYREF
  _QWORD v1583[2]; // [rsp+1E28h] [rbp+1D28h] BYREF
  _QWORD v1584[2]; // [rsp+1E38h] [rbp+1D38h] BYREF
  _QWORD v1585[2]; // [rsp+1E48h] [rbp+1D48h] BYREF
  _QWORD v1586[2]; // [rsp+1E58h] [rbp+1D58h] BYREF
  _QWORD v1587[2]; // [rsp+1E68h] [rbp+1D68h] BYREF
  _QWORD v1588[2]; // [rsp+1E78h] [rbp+1D78h] BYREF
  _QWORD v1589[2]; // [rsp+1E88h] [rbp+1D88h] BYREF
  _QWORD v1590[2]; // [rsp+1E98h] [rbp+1D98h] BYREF
  _QWORD v1591[2]; // [rsp+1EA8h] [rbp+1DA8h] BYREF
  _QWORD v1592[2]; // [rsp+1EB8h] [rbp+1DB8h] BYREF
  _QWORD v1593[2]; // [rsp+1EC8h] [rbp+1DC8h] BYREF
  _QWORD v1594[2]; // [rsp+1ED8h] [rbp+1DD8h] BYREF
  _QWORD v1595[2]; // [rsp+1EE8h] [rbp+1DE8h] BYREF
  _QWORD v1596[2]; // [rsp+1EF8h] [rbp+1DF8h] BYREF
  _QWORD v1597[2]; // [rsp+1F08h] [rbp+1E08h] BYREF
  _QWORD v1598[2]; // [rsp+1F18h] [rbp+1E18h] BYREF
  _QWORD v1599[2]; // [rsp+1F28h] [rbp+1E28h] BYREF
  _QWORD v1600[2]; // [rsp+1F38h] [rbp+1E38h] BYREF
  _QWORD v1601[2]; // [rsp+1F48h] [rbp+1E48h] BYREF
  _QWORD v1602[2]; // [rsp+1F58h] [rbp+1E58h] BYREF
  _QWORD v1603[2]; // [rsp+1F68h] [rbp+1E68h] BYREF
  _QWORD v1604[2]; // [rsp+1F78h] [rbp+1E78h] BYREF
  _QWORD v1605[2]; // [rsp+1F88h] [rbp+1E88h] BYREF
  _QWORD v1606[2]; // [rsp+1F98h] [rbp+1E98h] BYREF
  _QWORD v1607[2]; // [rsp+1FA8h] [rbp+1EA8h] BYREF
  _QWORD v1608[2]; // [rsp+1FB8h] [rbp+1EB8h] BYREF
  _QWORD v1609[2]; // [rsp+1FC8h] [rbp+1EC8h] BYREF
  _QWORD v1610[2]; // [rsp+1FD8h] [rbp+1ED8h] BYREF
  _QWORD v1611[2]; // [rsp+1FE8h] [rbp+1EE8h] BYREF
  _QWORD v1612[2]; // [rsp+1FF8h] [rbp+1EF8h] BYREF
  _QWORD v1613[2]; // [rsp+2008h] [rbp+1F08h] BYREF
  _QWORD v1614[2]; // [rsp+2018h] [rbp+1F18h] BYREF
  _QWORD v1615[2]; // [rsp+2028h] [rbp+1F28h] BYREF
  _QWORD v1616[2]; // [rsp+2038h] [rbp+1F38h] BYREF
  _QWORD v1617[2]; // [rsp+2048h] [rbp+1F48h] BYREF
  _QWORD v1618[2]; // [rsp+2058h] [rbp+1F58h] BYREF
  _QWORD v1619[2]; // [rsp+2068h] [rbp+1F68h] BYREF
  _QWORD v1620[5]; // [rsp+2078h] [rbp+1F78h] BYREF
  volatile signed __int32 *v1621; // [rsp+20B0h] [rbp+1FB0h] BYREF

  v4 = *a1;
  result = *(unsigned __int8 *)(*a1 + 0x18);
  switch ( *(_BYTE *)(*a1 + 0x18) )
  {
    case 0:
      v1621 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v9 = sub_1455C3F50(&v1303, &v1621);
      v10 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD, volatile signed __int32 *))(*v9 + 0x10LL);
      v11 = *a2;
      v716 = v11;
      if ( v11 )
        _InterlockedIncrement(v11 + 7);
      v12 = sub_1455C3F50(&v1089, &v716);
      result = v10(v9, v12, a3, a4, v716);
      v1089 = &off_148746580;
      if ( v1090 )
        result = sub_142FEFD50(v1090);
      v1090 = 0;
      v1303 = &off_148746580;
      if ( v1304 )
        result = sub_142FEFD50(v1304);
      break;
    case 1:
      v717 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v13 = sub_1455C3FB0(&v1305, &v717);
      v14 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v13 + 0x10LL);
      v15 = *a2;
      v718 = v15;
      if ( v15 )
        _InterlockedIncrement(v15 + 7);
      v16 = sub_1455C3FB0(&v1091, &v718);
      result = v14(v13, v16, a3, a4);
      v1091 = &off_148746580;
      if ( v1092 )
        result = sub_142FEFD50(v1092);
      v1092 = 0;
      v1305 = &off_148746580;
      if ( v1306 )
        result = sub_142FEFD50(v1306);
      break;
    case 2:
      v719 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v17 = sub_1455C4230(&v1307, &v719);
      v18 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v17 + 0x10LL);
      v19 = *a2;
      v720 = v19;
      if ( v19 )
        _InterlockedIncrement(v19 + 7);
      v20 = sub_1455C4230(&v1093, &v720);
      result = v18(v17, v20, a3, a4);
      v1093 = &off_148746580;
      if ( v1094 )
        result = sub_142FEFD50(v1094);
      v1094 = 0;
      v1307 = &off_148746580;
      if ( v1308 )
        result = sub_142FEFD50(v1308);
      break;
    case 3:
      v721 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v21 = sub_1455C4290(&v1309, &v721);
      v22 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v21 + 0x10LL);
      v23 = *a2;
      v722 = v23;
      if ( v23 )
        _InterlockedIncrement(v23 + 7);
      v24 = sub_1455C4290(&v1095, &v722);
      result = v22(v21, v24, a3, a4);
      v1095 = &off_148746580;
      if ( v1096 )
        result = sub_142FEFD50(v1096);
      v1096 = 0;
      v1309 = &off_148746580;
      if ( v1310 )
        result = sub_142FEFD50(v1310);
      break;
    case 4:
      v723 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v25 = sub_1455C7A30(&v1311, &v723);
      v26 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v25 + 0x10LL);
      v27 = *a2;
      v724 = v27;
      if ( v27 )
        _InterlockedIncrement(v27 + 7);
      v28 = sub_1455C7A30(&v1097, &v724);
      result = v26(v25, v28, a3, a4);
      v1097 = &off_148746580;
      if ( v1098 )
        result = sub_142FEFD50(v1098);
      v1098 = 0;
      v1311 = &off_148746580;
      if ( v1312 )
        result = sub_142FEFD50(v1312);
      break;
    case 5:
      v725 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v29 = sub_1455C5220(&v1247, &v725);
      v30 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v29 + 0x10LL);
      v31 = *a2;
      v726 = v31;
      if ( v31 )
        _InterlockedIncrement(v31 + 7);
      v32 = sub_1455C5220(&v1099, &v726);
      result = v30(v29, v32, a3, a4);
      v1099 = &off_148746580;
      if ( v1100 )
        result = sub_142FEFD50(v1100);
      v1100 = 0;
      v1247 = &off_148746580;
      if ( v1248 )
        result = sub_142FEFD50(v1248);
      break;
    case 6:
      v727 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v33 = sub_1455C5890(&v1315, &v727);
      v34 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v33 + 0x10LL);
      v35 = *a2;
      v728 = v35;
      if ( v35 )
        _InterlockedIncrement(v35 + 7);
      v36 = sub_1455C5890(&v1101, &v728);
      result = v34(v33, v36, a3, a4);
      v1101 = &off_148746580;
      if ( v1102 )
        result = sub_142FEFD50(v1102);
      v1102 = 0;
      v1315 = &off_148746580;
      if ( v1316 )
        result = sub_142FEFD50(v1316);
      break;
    case 7:
      v729 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v37 = sub_1455C58F0(&v1317, &v729);
      v38 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v37 + 0x10LL);
      v39 = *a2;
      v730 = v39;
      if ( v39 )
        _InterlockedIncrement(v39 + 7);
      v40 = sub_1455C58F0(&v1103, &v730);
      result = v38(v37, v40, a3, a4);
      v1103 = &off_148746580;
      if ( v1104 )
        result = sub_142FEFD50(v1104);
      v1104 = 0;
      v1317 = &off_148746580;
      if ( v1318 )
        result = sub_142FEFD50(v1318);
      break;
    case 8:
      v731 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v41 = sub_1455C5950(&v1319, &v731);
      v42 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v41 + 0x10LL);
      v43 = *a2;
      v732 = v43;
      if ( v43 )
        _InterlockedIncrement(v43 + 7);
      v44 = sub_1455C5950(&v1105, &v732);
      result = v42(v41, v44, a3, a4);
      v1105 = &off_148746580;
      if ( v1106 )
        result = sub_142FEFD50(v1106);
      v1106 = 0;
      v1319 = &off_148746580;
      if ( v1320 )
        result = sub_142FEFD50(v1320);
      break;
    case 9:
      v733 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v45 = sub_1455C6250(&v1321, &v733);
      v46 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v45 + 0x10LL);
      v47 = *a2;
      v734 = v47;
      if ( v47 )
        _InterlockedIncrement(v47 + 7);
      v48 = sub_1455C6250(&v1107, &v734);
      result = v46(v45, v48, a3, a4);
      v1107 = &off_148746580;
      if ( v1108 )
        result = sub_142FEFD50(v1108);
      v1108 = 0;
      v1321 = &off_148746580;
      if ( v1322 )
        result = sub_142FEFD50(v1322);
      break;
    case 0xA:
      v735 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v49 = sub_1455C6E50(&v1323, &v735);
      v50 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v49 + 0x10LL);
      v51 = *a2;
      v736 = v51;
      if ( v51 )
        _InterlockedIncrement(v51 + 7);
      v52 = sub_1455C6E50(&v1109, &v736);
      result = v50(v49, v52, a3, a4);
      v1109 = &off_148746580;
      if ( v1110 )
        result = sub_142FEFD50(v1110);
      v1110 = 0;
      v1323 = &off_148746580;
      if ( v1324 )
        result = sub_142FEFD50(v1324);
      break;
    case 0xB:
      v737 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v53 = sub_1455C7190(&v1325, &v737);
      v54 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v53 + 0x10LL);
      v55 = *a2;
      v738 = v55;
      if ( v55 )
        _InterlockedIncrement(v55 + 7);
      v56 = sub_1455C7190(&v1111, &v738);
      result = v54(v53, v56, a3, a4);
      v1111 = &off_148746580;
      if ( v1112 )
        result = sub_142FEFD50(v1112);
      v1112 = 0;
      v1325 = &off_148746580;
      if ( v1326 )
        result = sub_142FEFD50(v1326);
      break;
    case 0xC:
      v739 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v57 = sub_1455C5100(&v1327, &v739);
      v58 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v57 + 0x10LL);
      v59 = *a2;
      v740 = v59;
      if ( v59 )
        _InterlockedIncrement(v59 + 7);
      v60 = sub_1455C5100(&v1113, &v740);
      result = v58(v57, v60, a3, a4);
      v1113 = &off_148746580;
      if ( v1114 )
        result = sub_142FEFD50(v1114);
      v1114 = 0;
      v1327 = &off_148746580;
      if ( v1328 )
        result = sub_142FEFD50(v1328);
      break;
    case 0xD:
      v741 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v61 = sub_1455C4B60(&v1329, &v741);
      v62 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v61 + 0x10LL);
      v63 = *a2;
      v742 = v63;
      if ( v63 )
        _InterlockedIncrement(v63 + 7);
      v64 = sub_1455C4B60(&v1115, &v742);
      result = v62(v61, v64, a3, a4);
      v1115 = &off_148746580;
      if ( v1116 )
        result = sub_142FEFD50(v1116);
      v1116 = 0;
      v1329 = &off_148746580;
      if ( v1330 )
        result = sub_142FEFD50(v1330);
      break;
    case 0xE:
      v743 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v65 = sub_1455C64F0(&v1331, &v743);
      v66 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v65 + 0x10LL);
      v67 = *a2;
      v744 = v67;
      if ( v67 )
        _InterlockedIncrement(v67 + 7);
      v68 = sub_1455C64F0(&v1117, &v744);
      result = v66(v65, v68, a3, a4);
      v1117 = &off_148746580;
      if ( v1118 )
        result = sub_142FEFD50(v1118);
      v1118 = 0;
      v1331 = &off_148746580;
      if ( v1332 )
        result = sub_142FEFD50(v1332);
      break;
    case 0xF:
      v745 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v69 = sub_1455C6AF0(&v1333, &v745);
      v70 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v69 + 0x10LL);
      v71 = *a2;
      v746 = v71;
      if ( v71 )
        _InterlockedIncrement(v71 + 7);
      v72 = sub_1455C6AF0(&v1119, &v746);
      result = v70(v69, v72, a3, a4);
      v1119 = &off_148746580;
      if ( v1120 )
        result = sub_142FEFD50(v1120);
      v73 = v1334;
      v1120 = 0;
      v1333 = &off_148746580;
      if ( v1334 )
        goto LABEL_857;
      break;
    case 0x10:
      v747 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v74 = sub_1455C5DD0(&v1335, &v747);
      v75 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v74 + 0x10LL);
      v76 = *a2;
      v748 = v76;
      if ( v76 )
        _InterlockedIncrement(v76 + 7);
      v77 = sub_1455C5DD0(&v1121, &v748);
      result = v75(v74, v77, a3, a4);
      v1121 = &off_148746580;
      if ( v1122 )
        result = sub_142FEFD50(v1122);
      v73 = v1336;
      v1122 = 0;
      v1335 = &off_148746580;
      if ( v1336 )
        goto LABEL_857;
      break;
    case 0x11:
      v749 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v78 = sub_1455C65B0(&v1337, &v749);
      v79 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v78 + 0x10LL);
      v80 = *a2;
      v750 = v80;
      if ( v80 )
        _InterlockedIncrement(v80 + 7);
      v81 = sub_1455C65B0(&v1123, &v750);
      result = v79(v78, v81, a3, a4);
      v1123 = &off_148746580;
      if ( v1124 )
        result = sub_142FEFD50(v1124);
      v73 = v1338;
      v1124 = 0;
      v1337 = &off_148746580;
      if ( v1338 )
        goto LABEL_857;
      break;
    case 0x12:
      v751 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v82 = sub_1455C6610(&v1339, &v751);
      v83 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v82 + 0x10LL);
      v84 = *a2;
      v752 = v84;
      if ( v84 )
        _InterlockedIncrement(v84 + 7);
      v85 = sub_1455C6610(&v1125, &v752);
      result = v83(v82, v85, a3, a4);
      v1125 = &off_148746580;
      if ( v1126 )
        result = sub_142FEFD50(v1126);
      v73 = v1340;
      v1126 = 0;
      v1339 = &off_148746580;
      if ( v1340 )
        goto LABEL_857;
      break;
    case 0x13:
      v753 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v86 = sub_1455C6970(&v1341, &v753);
      v87 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v86 + 0x10LL);
      v88 = *a2;
      v754 = v88;
      if ( v88 )
        _InterlockedIncrement(v88 + 7);
      v89 = sub_1455C6970(&v1127, &v754);
      result = v87(v86, v89, a3, a4);
      v1127 = &off_148746580;
      if ( v1128 )
        result = sub_142FEFD50(v1128);
      v73 = v1342;
      v1128 = 0;
      v1341 = &off_148746580;
      if ( v1342 )
        goto LABEL_857;
      break;
    case 0x14:
      v755 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v90 = sub_1455C6910(&v1343, &v755);
      v91 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v90 + 0x10LL);
      v92 = *a2;
      v756 = v92;
      if ( v92 )
        _InterlockedIncrement(v92 + 7);
      v93 = sub_1455C6910(&v1129, &v756);
      result = v91(v90, v93, a3, a4);
      v1129 = &off_148746580;
      if ( v1130 )
        result = sub_142FEFD50(v1130);
      v73 = v1344;
      v1130 = 0;
      v1343 = &off_148746580;
      if ( v1344 )
        goto LABEL_857;
      break;
    case 0x15:
      v757 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v94 = sub_1455C3B30(&v1345, &v757);
      v95 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v94 + 0x10LL);
      v96 = *a2;
      v758 = v96;
      if ( v96 )
        _InterlockedIncrement(v96 + 7);
      v97 = sub_1455C3B30(&v1131, &v758);
      result = v95(v94, v97, a3, a4);
      v1131 = &off_148746580;
      if ( v1132 )
        result = sub_142FEFD50(v1132);
      v73 = v1346;
      v1132 = 0;
      v1345 = &off_148746580;
      if ( v1346 )
        goto LABEL_857;
      break;
    case 0x16:
      v759 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v98 = sub_1455C3B90(&v1347, &v759);
      v99 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v98 + 0x10LL);
      v100 = *a2;
      v760 = v100;
      if ( v100 )
        _InterlockedIncrement(v100 + 7);
      v101 = sub_1455C3B90(&v1133, &v760);
      result = v99(v98, v101, a3, a4);
      v1133 = &off_148746580;
      if ( v1134 )
        result = sub_142FEFD50(v1134);
      v73 = v1348;
      v1134 = 0;
      v1347 = &off_148746580;
      if ( v1348 )
        goto LABEL_857;
      break;
    case 0x17:
      v761 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v102 = sub_1455C3890(&v1349, &v761);
      v103 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v102 + 0x10LL);
      v104 = *a2;
      v762 = v104;
      if ( v104 )
        _InterlockedIncrement(v104 + 7);
      v105 = sub_1455C3890(&v1135, &v762);
      result = v103(v102, v105, a3, a4);
      v1135 = &off_148746580;
      if ( v1136 )
        result = sub_142FEFD50(v1136);
      v73 = v1350;
      v1136 = 0;
      v1349 = &off_148746580;
      if ( v1350 )
        goto LABEL_857;
      break;
    case 0x18:
      v763 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v106 = sub_1455C38F0(&v1351, &v763);
      v107 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v106 + 0x10LL);
      v108 = *a2;
      v764 = v108;
      if ( v108 )
        _InterlockedIncrement(v108 + 7);
      v109 = sub_1455C38F0(&v1137, &v764);
      result = v107(v106, v109, a3, a4);
      v1137 = &off_148746580;
      if ( v1138 )
        result = sub_142FEFD50(v1138);
      v73 = v1352;
      v1138 = 0;
      v1351 = &off_148746580;
      if ( v1352 )
        goto LABEL_857;
      break;
    case 0x19:
      v765 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v110 = sub_1455C3AD0(&v1353, &v765);
      v111 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v110 + 0x10LL);
      v112 = *a2;
      v766 = v112;
      if ( v112 )
        _InterlockedIncrement(v112 + 7);
      v113 = sub_1455C3AD0(&v1139, &v766);
      result = v111(v110, v113, a3, a4);
      v1139 = &off_148746580;
      if ( v1140 )
        result = sub_142FEFD50(v1140);
      v73 = v1354;
      v1140 = 0;
      v1353 = &off_148746580;
      if ( v1354 )
        goto LABEL_857;
      break;
    case 0x1A:
      v767 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v114 = sub_1455C3950(&v1355, &v767);
      v115 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v114 + 0x10LL);
      v116 = *a2;
      v768 = v116;
      if ( v116 )
        _InterlockedIncrement(v116 + 7);
      v117 = sub_1455C3950(&v1141, &v768);
      result = v115(v114, v117, a3, a4);
      v1141 = &off_148746580;
      if ( v1142 )
        result = sub_142FEFD50(v1142);
      v73 = v1356;
      v1142 = 0;
      v1355 = &off_148746580;
      if ( v1356 )
        goto LABEL_857;
      break;
    case 0x1B:
      v769 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v118 = sub_1455C39B0(&v1357, &v769);
      v119 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v118 + 0x10LL);
      v120 = *a2;
      v770 = v120;
      if ( v120 )
        _InterlockedIncrement(v120 + 7);
      v121 = sub_1455C39B0(&v1143, &v770);
      result = v119(v118, v121, a3, a4);
      v1143 = &off_148746580;
      if ( v1144 )
        result = sub_142FEFD50(v1144);
      v73 = v1358;
      v1144 = 0;
      v1357 = &off_148746580;
      if ( v1358 )
        goto LABEL_857;
      break;
    case 0x1C:
      v771 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v122 = sub_1455C3A70(&v1359, &v771);
      v123 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v122 + 0x10LL);
      v124 = *a2;
      v772 = v124;
      if ( v124 )
        _InterlockedIncrement(v124 + 7);
      v125 = sub_1455C3A70(&v1145, &v772);
      result = v123(v122, v125, a3, a4);
      v1145 = &off_148746580;
      if ( v1146 )
        result = sub_142FEFD50(v1146);
      v73 = v1360;
      v1146 = 0;
      v1359 = &off_148746580;
      if ( v1360 )
        goto LABEL_857;
      break;
    case 0x1D:
      v773 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v126 = sub_1455C3A10(&v1361, &v773);
      v127 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v126 + 0x10LL);
      v128 = *a2;
      v774 = v128;
      if ( v128 )
        _InterlockedIncrement(v128 + 7);
      v129 = sub_1455C3A10(&v1147, &v774);
      result = v127(v126, v129, a3, a4);
      v1147 = &off_148746580;
      if ( v1148 )
        result = sub_142FEFD50(v1148);
      v73 = v1362;
      v1148 = 0;
      v1361 = &off_148746580;
      if ( v1362 )
        goto LABEL_857;
      break;
    case 0x1E:
      v775 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v130 = sub_1455C3BF0(&v1363, &v775);
      v131 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v130 + 0x10LL);
      v132 = *a2;
      v776 = v132;
      if ( v132 )
        _InterlockedIncrement(v132 + 7);
      v133 = sub_1455C3BF0(&v1149, &v776);
      result = v131(v130, v133, a3, a4);
      v1149 = &off_148746580;
      if ( v1150 )
        result = sub_142FEFD50(v1150);
      v73 = v1364;
      v1150 = 0;
      v1363 = &off_148746580;
      if ( v1364 )
        goto LABEL_857;
      break;
    case 0x1F:
      v777 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v134 = sub_1455C3C50(&v1365, &v777);
      v135 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v134 + 0x10LL);
      v136 = *a2;
      v778 = v136;
      if ( v136 )
        _InterlockedIncrement(v136 + 7);
      v137 = sub_1455C3C50(&v1151, &v778);
      result = v135(v134, v137, a3, a4);
      v1151 = &off_148746580;
      if ( v1152 )
        result = sub_142FEFD50(v1152);
      v73 = v1366;
      v1152 = 0;
      v1365 = &off_148746580;
      if ( v1366 )
        goto LABEL_857;
      break;
    case 0x20:
      v779 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v138 = sub_1455C3CB0(&v1367, &v779);
      v139 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v138 + 0x10LL);
      v140 = *a2;
      v780 = v140;
      if ( v140 )
        _InterlockedIncrement(v140 + 7);
      v141 = sub_1455C3CB0(&v1153, &v780);
      result = v139(v138, v141, a3, a4);
      v1153 = &off_148746580;
      if ( v1154 )
        result = sub_142FEFD50(v1154);
      v73 = v1368;
      v1154 = 0;
      v1367 = &off_148746580;
      if ( v1368 )
        goto LABEL_857;
      break;
    case 0x21:
      v781 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v142 = sub_1455C3D70(&v1369, &v781);
      v143 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v142 + 0x10LL);
      v144 = *a2;
      v782 = v144;
      if ( v144 )
        _InterlockedIncrement(v144 + 7);
      v145 = sub_1455C3D70(&v1155, &v782);
      result = v143(v142, v145, a3, a4);
      v1155 = &off_148746580;
      if ( v1156 )
        result = sub_142FEFD50(v1156);
      v73 = v1370;
      v1156 = 0;
      v1369 = &off_148746580;
      if ( v1370 )
        goto LABEL_857;
      break;
    case 0x22:
      v783 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v146 = sub_1455C3DD0(&v1371, &v783);
      v147 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v146 + 0x10LL);
      v148 = *a2;
      v784 = v148;
      if ( v148 )
        _InterlockedIncrement(v148 + 7);
      v149 = sub_1455C3DD0(&v1157, &v784);
      result = v147(v146, v149, a3, a4);
      v1157 = &off_148746580;
      if ( v1158 )
        result = sub_142FEFD50(v1158);
      v73 = v1372;
      v1158 = 0;
      v1371 = &off_148746580;
      if ( v1372 )
        goto LABEL_857;
      break;
    case 0x23:
      v785 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v150 = sub_1455C3E30(&v1373, &v785);
      v151 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v150 + 0x10LL);
      v152 = *a2;
      v786 = v152;
      if ( v152 )
        _InterlockedIncrement(v152 + 7);
      v153 = sub_1455C3E30(&v1159, &v786);
      result = v151(v150, v153, a3, a4);
      v1159 = &off_148746580;
      if ( v1160 )
        result = sub_142FEFD50(v1160);
      v73 = v1374;
      v1160 = 0;
      v1373 = &off_148746580;
      if ( v1374 )
        goto LABEL_857;
      break;
    case 0x24:
      v787 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v154 = sub_1455C3E90(&v1375, &v787);
      v155 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v154 + 0x10LL);
      v156 = *a2;
      v788 = v156;
      if ( v156 )
        _InterlockedIncrement(v156 + 7);
      v157 = sub_1455C3E90(&v1161, &v788);
      result = v155(v154, v157, a3, a4);
      v1161 = &off_148746580;
      if ( v1162 )
        result = sub_142FEFD50(v1162);
      v73 = v1376;
      v1162 = 0;
      v1375 = &off_148746580;
      if ( v1376 )
        goto LABEL_857;
      break;
    case 0x25:
      v789 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v158 = sub_1455C3EF0(&v1377, &v789);
      v159 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v158 + 0x10LL);
      v160 = *a2;
      v790 = v160;
      if ( v160 )
        _InterlockedIncrement(v160 + 7);
      v161 = sub_1455C3EF0(&v1163, &v790);
      result = v159(v158, v161, a3, a4);
      v1163 = &off_148746580;
      if ( v1164 )
        result = sub_142FEFD50(v1164);
      v73 = v1378;
      v1164 = 0;
      v1377 = &off_148746580;
      if ( v1378 )
        goto LABEL_857;
      break;
    case 0x26:
      v791 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v162 = sub_1455C4010(&v1313, &v791);
      v163 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v162 + 0x10LL);
      v164 = *a2;
      v792 = v164;
      if ( v164 )
        _InterlockedIncrement(v164 + 7);
      v165 = sub_1455C4010(&v1165, &v792);
      result = v163(v162, v165, a3, a4);
      v1165 = &off_148746580;
      if ( v1166 )
        result = sub_142FEFD50(v1166);
      v73 = v1314;
      v1166 = 0;
      v1313 = &off_148746580;
      if ( v1314 )
        goto LABEL_857;
      break;
    case 0x27:
      v793 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v166 = sub_1455C40D0(&v1381, &v793);
      v167 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v166 + 0x10LL);
      v168 = *a2;
      v794 = v168;
      if ( v168 )
        _InterlockedIncrement(v168 + 7);
      v169 = sub_1455C40D0(&v1167, &v794);
      result = v167(v166, v169, a3, a4);
      v1167 = &off_148746580;
      if ( v1168 )
        result = sub_142FEFD50(v1168);
      v73 = v1382;
      v1168 = 0;
      v1381 = &off_148746580;
      if ( v1382 )
        goto LABEL_857;
      break;
    case 0x28:
      v795 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v170 = sub_1455C4130(&v1383, &v795);
      v171 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v170 + 0x10LL);
      v172 = *a2;
      v796 = v172;
      if ( v172 )
        _InterlockedIncrement(v172 + 7);
      v173 = sub_1455C4130(&v1169, &v796);
      result = v171(v170, v173, a3, a4);
      v1169 = &off_148746580;
      if ( v1170 )
        result = sub_142FEFD50(v1170);
      v73 = v1384;
      v1170 = 0;
      v1383 = &off_148746580;
      if ( v1384 )
        goto LABEL_857;
      break;
    case 0x29:
      v797 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v174 = sub_1455C4070(&v1385, &v797);
      v175 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v174 + 0x10LL);
      v176 = *a2;
      v798 = v176;
      if ( v176 )
        _InterlockedIncrement(v176 + 7);
      v177 = sub_1455C4070(&v1171, &v798);
      result = v175(v174, v177, a3, a4);
      v1171 = &off_148746580;
      if ( v1172 )
        result = sub_142FEFD50(v1172);
      v73 = v1386;
      v1172 = 0;
      v1385 = &off_148746580;
      if ( v1386 )
        goto LABEL_857;
      break;
    case 0x2A:
      v799 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v178 = sub_1455C41D0(&v1387, &v799);
      v179 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v178 + 0x10LL);
      v180 = *a2;
      v800 = v180;
      if ( v180 )
        _InterlockedIncrement(v180 + 7);
      v181 = sub_1455C41D0(&v1173, &v800);
      result = v179(v178, v181, a3, a4);
      v1173 = &off_148746580;
      if ( v1174 )
        result = sub_142FEFD50(v1174);
      v73 = v1388;
      v1174 = 0;
      v1387 = &off_148746580;
      if ( v1388 )
        goto LABEL_857;
      break;
    case 0x2B:
      v801 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v182 = sub_1455C4410(&v1389, &v801);
      v183 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v182 + 0x10LL);
      v184 = *a2;
      v802 = v184;
      if ( v184 )
        _InterlockedIncrement(v184 + 7);
      v185 = sub_1455C4410(&v1175, &v802);
      result = v183(v182, v185, a3, a4);
      v1175 = &off_148746580;
      if ( v1176 )
        result = sub_142FEFD50(v1176);
      v73 = v1390;
      v1176 = 0;
      v1389 = &off_148746580;
      if ( v1390 )
        goto LABEL_857;
      break;
    case 0x2C:
      v803 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v186 = sub_1455C4470(&v1391, &v803);
      v187 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v186 + 0x10LL);
      v188 = *a2;
      v804 = v188;
      if ( v188 )
        _InterlockedIncrement(v188 + 7);
      v189 = sub_1455C4470(&v1177, &v804);
      result = v187(v186, v189, a3, a4);
      v1177 = &off_148746580;
      if ( v1178 )
        result = sub_142FEFD50(v1178);
      v73 = v1392;
      v1178 = 0;
      v1391 = &off_148746580;
      if ( v1392 )
        goto LABEL_857;
      break;
    case 0x2D:
      v805 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v190 = sub_1455C44D0(&v1393, &v805);
      v191 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v190 + 0x10LL);
      v192 = *a2;
      v806 = v192;
      if ( v192 )
        _InterlockedIncrement(v192 + 7);
      v193 = sub_1455C44D0(&v1179, &v806);
      result = v191(v190, v193, a3, a4);
      v1179 = &off_148746580;
      if ( v1180 )
        result = sub_142FEFD50(v1180);
      v73 = v1394;
      v1180 = 0;
      v1393 = &off_148746580;
      if ( v1394 )
        goto LABEL_857;
      break;
    case 0x2E:
      v807 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v194 = sub_1455C4590(&v1395, &v807);
      v195 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v194 + 0x10LL);
      v196 = *a2;
      v808 = v196;
      if ( v196 )
        _InterlockedIncrement(v196 + 7);
      v197 = sub_1455C4590(&v1181, &v808);
      result = v195(v194, v197, a3, a4);
      v1181 = &off_148746580;
      if ( v1182 )
        result = sub_142FEFD50(v1182);
      v73 = v1396;
      v1182 = 0;
      v1395 = &off_148746580;
      if ( v1396 )
        goto LABEL_857;
      break;
    case 0x2F:
      v809 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v198 = sub_1455C46E0(&v1397, &v809);
      v199 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v198 + 0x10LL);
      v200 = *a2;
      v810 = v200;
      if ( v200 )
        _InterlockedIncrement(v200 + 7);
      v201 = sub_1455C46E0(&v1183, &v810);
      result = v199(v198, v201, a3, a4);
      v1183 = &off_148746580;
      if ( v1184 )
        result = sub_142FEFD50(v1184);
      v73 = v1398;
      v1184 = 0;
      v1397 = &off_148746580;
      if ( v1398 )
        goto LABEL_857;
      break;
    case 0x30:
      v811 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v202 = sub_1455C47A0(&v1399, &v811);
      v203 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v202 + 0x10LL);
      v204 = *a2;
      v812 = v204;
      if ( v204 )
        _InterlockedIncrement(v204 + 7);
      v205 = sub_1455C47A0(&v1185, &v812);
      result = v203(v202, v205, a3, a4);
      v1185 = &off_148746580;
      if ( v1186 )
        result = sub_142FEFD50(v1186);
      v73 = v1400;
      v1186 = 0;
      v1399 = &off_148746580;
      if ( v1400 )
        goto LABEL_857;
      break;
    case 0x31:
      v813 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v206 = sub_1455C4800(&v1401, &v813);
      v207 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v206 + 0x10LL);
      v208 = *a2;
      v814 = v208;
      if ( v208 )
        _InterlockedIncrement(v208 + 7);
      v209 = sub_1455C4800(&v1187, &v814);
      result = v207(v206, v209, a3, a4);
      v1187 = &off_148746580;
      if ( v1188 )
        result = sub_142FEFD50(v1188);
      v73 = v1402;
      v1188 = 0;
      v1401 = &off_148746580;
      if ( v1402 )
        goto LABEL_857;
      break;
    case 0x32:
      v815 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v210 = sub_1455C4860(&v1403, &v815);
      v211 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v210 + 0x10LL);
      v212 = *a2;
      v816 = v212;
      if ( v212 )
        _InterlockedIncrement(v212 + 7);
      v213 = sub_1455C4860(&v1189, &v816);
      result = v211(v210, v213, a3, a4);
      v1189 = &off_148746580;
      if ( v1190 )
        result = sub_142FEFD50(v1190);
      v73 = v1404;
      v1190 = 0;
      v1403 = &off_148746580;
      if ( v1404 )
        goto LABEL_857;
      break;
    case 0x33:
      v817 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v214 = sub_1455C4920(&v1405, &v817);
      v215 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v214 + 0x10LL);
      v216 = *a2;
      v818 = v216;
      if ( v216 )
        _InterlockedIncrement(v216 + 7);
      v217 = sub_1455C4920(&v1191, &v818);
      result = v215(v214, v217, a3, a4);
      v1191 = &off_148746580;
      if ( v1192 )
        result = sub_142FEFD50(v1192);
      v73 = v1406;
      v1192 = 0;
      v1405 = &off_148746580;
      if ( v1406 )
        goto LABEL_857;
      break;
    case 0x34:
      v819 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v218 = sub_1455C4C80(&v1407, &v819);
      v219 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v218 + 0x10LL);
      v220 = *a2;
      v820 = v220;
      if ( v220 )
        _InterlockedIncrement(v220 + 7);
      v221 = sub_1455C4C80(&v1193, &v820);
      result = v219(v218, v221, a3, a4);
      v1193 = &off_148746580;
      if ( v1194 )
        result = sub_142FEFD50(v1194);
      v73 = v1408;
      v1194 = 0;
      v1407 = &off_148746580;
      if ( v1408 )
        goto LABEL_857;
      break;
    case 0x35:
      v821 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v222 = sub_1455C4980(&v1409, &v821);
      v223 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v222 + 0x10LL);
      v224 = *a2;
      v822 = v224;
      if ( v224 )
        _InterlockedIncrement(v224 + 7);
      v225 = sub_1455C4980(&v1195, &v822);
      result = v223(v222, v225, a3, a4);
      v1195 = &off_148746580;
      if ( v1196 )
        result = sub_142FEFD50(v1196);
      v73 = v1410;
      v1196 = 0;
      v1409 = &off_148746580;
      if ( v1410 )
        goto LABEL_857;
      break;
    case 0x36:
      v823 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v226 = sub_1455C4A40(&v1411, &v823);
      v227 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v226 + 0x10LL);
      v228 = *a2;
      v824 = v228;
      if ( v228 )
        _InterlockedIncrement(v228 + 7);
      v229 = sub_1455C4A40(&v1197, &v824);
      result = v227(v226, v229, a3, a4);
      v1197 = &off_148746580;
      if ( v1198 )
        result = sub_142FEFD50(v1198);
      v73 = v1412;
      v1198 = 0;
      v1411 = &off_148746580;
      if ( v1412 )
        goto LABEL_857;
      break;
    case 0x37:
      v825 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v230 = sub_1455C4A40(&v1413, &v825);
      v231 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v230 + 0x10LL);
      v232 = *a2;
      v826 = v232;
      if ( v232 )
        _InterlockedIncrement(v232 + 7);
      v233 = sub_1455C4A40(&v1199, &v826);
      result = v231(v230, v233, a3, a4);
      v1199 = &off_148746580;
      if ( v1200 )
        result = sub_142FEFD50(v1200);
      v73 = v1414;
      v1200 = 0;
      v1413 = &off_148746580;
      if ( v1414 )
        goto LABEL_857;
      break;
    case 0x38:
      v827 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v234 = sub_1455C4AA0(&v1415, &v827);
      v235 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v234 + 0x10LL);
      v236 = *a2;
      v828 = v236;
      if ( v236 )
        _InterlockedIncrement(v236 + 7);
      v237 = sub_1455C4AA0(&v1201, &v828);
      result = v235(v234, v237, a3, a4);
      v1201 = &off_148746580;
      if ( v1202 )
        result = sub_142FEFD50(v1202);
      v73 = v1416;
      v1202 = 0;
      v1415 = &off_148746580;
      if ( v1416 )
        goto LABEL_857;
      break;
    case 0x39:
      v829 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v238 = sub_1455C4980(&v1417, &v829);
      v239 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v238 + 0x10LL);
      v240 = *a2;
      v830 = v240;
      if ( v240 )
        _InterlockedIncrement(v240 + 7);
      v241 = sub_1455C4980(&v1203, &v830);
      result = v239(v238, v241, a3, a4);
      v1203 = &off_148746580;
      if ( v1204 )
        result = sub_142FEFD50(v1204);
      v73 = v1418;
      v1204 = 0;
      v1417 = &off_148746580;
      if ( v1418 )
        goto LABEL_857;
      break;
    case 0x3A:
      v831 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v242 = sub_1455C4CE0(&v1419, &v831);
      v243 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v242 + 0x10LL);
      v244 = *a2;
      v832 = v244;
      if ( v244 )
        _InterlockedIncrement(v244 + 7);
      v245 = sub_1455C4CE0(&v1205, &v832);
      result = v243(v242, v245, a3, a4);
      v1205 = &off_148746580;
      if ( v1206 )
        result = sub_142FEFD50(v1206);
      v73 = v1420;
      v1206 = 0;
      v1419 = &off_148746580;
      if ( v1420 )
        goto LABEL_857;
      break;
    case 0x3B:
      v833 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v246 = sub_1455C4DA0(&v1421, &v833);
      v247 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v246 + 0x10LL);
      v248 = *a2;
      v834 = v248;
      if ( v248 )
        _InterlockedIncrement(v248 + 7);
      v249 = sub_1455C4DA0(&v1207, &v834);
      result = v247(v246, v249, a3, a4);
      v1207 = &off_148746580;
      if ( v1208 )
        result = sub_142FEFD50(v1208);
      v73 = v1422;
      v1208 = 0;
      v1421 = &off_148746580;
      if ( v1422 )
        goto LABEL_857;
      break;
    case 0x3C:
      v835 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v250 = sub_1455C4E00(&v1423, &v835);
      v251 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v250 + 0x10LL);
      v252 = *a2;
      v836 = v252;
      if ( v252 )
        _InterlockedIncrement(v252 + 7);
      v253 = sub_1455C4E00(&v1209, &v836);
      result = v251(v250, v253, a3, a4);
      v1209 = &off_148746580;
      if ( v1210 )
        result = sub_142FEFD50(v1210);
      v73 = v1424;
      v1210 = 0;
      v1423 = &off_148746580;
      if ( v1424 )
        goto LABEL_857;
      break;
    case 0x3D:
      v837 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v254 = sub_1455C4E60(&v1425, &v837);
      v255 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v254 + 0x10LL);
      v256 = *a2;
      v838 = v256;
      if ( v256 )
        _InterlockedIncrement(v256 + 7);
      v257 = sub_1455C4E60(&v1211, &v838);
      result = v255(v254, v257, a3, a4);
      v1211 = &off_148746580;
      if ( v1212 )
        result = sub_142FEFD50(v1212);
      v73 = v1426;
      v1212 = 0;
      v1425 = &off_148746580;
      if ( v1426 )
        goto LABEL_857;
      break;
    case 0x3E:
      v839 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v258 = sub_1455C4F20(&v1427, &v839);
      v259 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v258 + 0x10LL);
      v260 = *a2;
      v840 = v260;
      if ( v260 )
        _InterlockedIncrement(v260 + 7);
      v261 = sub_1455C4F20(&v1213, &v840);
      result = v259(v258, v261, a3, a4);
      v1213 = &off_148746580;
      if ( v1214 )
        result = sub_142FEFD50(v1214);
      v73 = v1428;
      v1214 = 0;
      v1427 = &off_148746580;
      if ( v1428 )
        goto LABEL_857;
      break;
    case 0x3F:
      v841 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v262 = sub_1455C4F80(&v1429, &v841);
      v263 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v262 + 0x10LL);
      v264 = *a2;
      v842 = v264;
      if ( v264 )
        _InterlockedIncrement(v264 + 7);
      v265 = sub_1455C4F80(&v1215, &v842);
      result = v263(v262, v265, a3, a4);
      v1215 = &off_148746580;
      if ( v1216 )
        result = sub_142FEFD50(v1216);
      v73 = v1430;
      v1216 = 0;
      v1429 = &off_148746580;
      if ( v1430 )
        goto LABEL_857;
      break;
    case 0x40:
      v843 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v266 = sub_1455C5040(&v1431, &v843);
      v267 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v266 + 0x10LL);
      v268 = *a2;
      v844 = v268;
      if ( v268 )
        _InterlockedIncrement(v268 + 7);
      v269 = sub_1455C5040(&v1217, &v844);
      result = v267(v266, v269, a3, a4);
      v1217 = &off_148746580;
      if ( v1218 )
        result = sub_142FEFD50(v1218);
      v73 = v1432;
      v1218 = 0;
      v1431 = &off_148746580;
      if ( v1432 )
        goto LABEL_857;
      break;
    case 0x41:
      v845 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v270 = sub_1455C50A0(&v1433, &v845);
      v271 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v270 + 0x10LL);
      v272 = *a2;
      v846 = v272;
      if ( v272 )
        _InterlockedIncrement(v272 + 7);
      v273 = sub_1455C50A0(&v1219, &v846);
      result = v271(v270, v273, a3, a4);
      v1219 = &off_148746580;
      if ( v1220 )
        result = sub_142FEFD50(v1220);
      v73 = v1434;
      v1220 = 0;
      v1433 = &off_148746580;
      if ( v1434 )
        goto LABEL_857;
      break;
    case 0x42:
      v847 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v274 = sub_1455C4A40(&v1435, &v847);
      v275 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v274 + 0x10LL);
      v276 = *a2;
      v848 = v276;
      if ( v276 )
        _InterlockedIncrement(v276 + 7);
      v277 = sub_1455C4A40(&v1221, &v848);
      result = v275(v274, v277, a3, a4);
      v1221 = &off_148746580;
      if ( v1222 )
        result = sub_142FEFD50(v1222);
      v73 = v1436;
      v1222 = 0;
      v1435 = &off_148746580;
      if ( v1436 )
        goto LABEL_857;
      break;
    case 0x43:
      v849 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v278 = sub_1455C51C0(&v1437, &v849);
      v279 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v278 + 0x10LL);
      v280 = *a2;
      v850 = v280;
      if ( v280 )
        _InterlockedIncrement(v280 + 7);
      v281 = sub_1455C51C0(&v1223, &v850);
      result = v279(v278, v281, a3, a4);
      v1223 = &off_148746580;
      if ( v1224 )
        result = sub_142FEFD50(v1224);
      v73 = v1438;
      v1224 = 0;
      v1437 = &off_148746580;
      if ( v1438 )
        goto LABEL_857;
      break;
    case 0x44:
      v851 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v282 = sub_1455C5280(&v1439, &v851);
      v283 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v282 + 0x10LL);
      v284 = *a2;
      v852 = v284;
      if ( v284 )
        _InterlockedIncrement(v284 + 7);
      v285 = sub_1455C5280(&v1225, &v852);
      result = v283(v282, v285, a3, a4);
      v1225 = &off_148746580;
      if ( v1226 )
        result = sub_142FEFD50(v1226);
      v73 = v1440;
      v1226 = 0;
      v1439 = &off_148746580;
      if ( v1440 )
        goto LABEL_857;
      break;
    case 0x45:
      v853 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v286 = sub_1455C52E0(&v1441, &v853);
      v287 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v286 + 0x10LL);
      v288 = *a2;
      v854 = v288;
      if ( v288 )
        _InterlockedIncrement(v288 + 7);
      v289 = sub_1455C52E0(&v1227, &v854);
      result = v287(v286, v289, a3, a4);
      v1227 = &off_148746580;
      if ( v1228 )
        result = sub_142FEFD50(v1228);
      v73 = v1442;
      v1228 = 0;
      v1441 = &off_148746580;
      if ( v1442 )
        goto LABEL_857;
      break;
    case 0x46:
      v855 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v290 = sub_1455C5340(&v1443, &v855);
      v291 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v290 + 0x10LL);
      v292 = *a2;
      v856 = v292;
      if ( v292 )
        _InterlockedIncrement(v292 + 7);
      v293 = sub_1455C5340(&v1229, &v856);
      result = v291(v290, v293, a3, a4);
      v1229 = &off_148746580;
      if ( v1230 )
        result = sub_142FEFD50(v1230);
      v73 = v1444;
      v1230 = 0;
      v1443 = &off_148746580;
      if ( v1444 )
        goto LABEL_857;
      break;
    case 0x47:
      v857 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v294 = sub_1455C4FE0(&v1445, &v857);
      v295 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v294 + 0x10LL);
      v296 = *a2;
      v858 = v296;
      if ( v296 )
        _InterlockedIncrement(v296 + 7);
      v297 = sub_1455C4FE0(&v1231, &v858);
      result = v295(v294, v297, a3, a4);
      v1231 = &off_148746580;
      if ( v1232 )
        result = sub_142FEFD50(v1232);
      v73 = v1446;
      v1232 = 0;
      v1445 = &off_148746580;
      if ( v1446 )
        goto LABEL_857;
      break;
    case 0x48:
      v859 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v298 = sub_1455C5B30(&v1447, &v859);
      v299 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v298 + 0x10LL);
      v300 = *a2;
      v860 = v300;
      if ( v300 )
        _InterlockedIncrement(v300 + 7);
      v301 = sub_1455C5B30(&v1233, &v860);
      result = v299(v298, v301, a3, a4);
      v1233 = &off_148746580;
      if ( v1234 )
        result = sub_142FEFD50(v1234);
      v73 = v1448;
      v1234 = 0;
      v1447 = &off_148746580;
      if ( v1448 )
        goto LABEL_857;
      break;
    case 0x49:
      v861 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v302 = sub_1455C53A0(&v1449, &v861);
      v303 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v302 + 0x10LL);
      v304 = *a2;
      v862 = v304;
      if ( v304 )
        _InterlockedIncrement(v304 + 7);
      v305 = sub_1455C53A0(&v1235, &v862);
      result = v303(v302, v305, a3, a4);
      v1235 = &off_148746580;
      if ( v1236 )
        result = sub_142FEFD50(v1236);
      v73 = v1450;
      v1236 = 0;
      v1449 = &off_148746580;
      if ( v1450 )
        goto LABEL_857;
      break;
    case 0x4A:
      v863 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v306 = sub_1455C4A40(&v1451, &v863);
      v307 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v306 + 0x10LL);
      v308 = *a2;
      v864 = v308;
      if ( v308 )
        _InterlockedIncrement(v308 + 7);
      v309 = sub_1455C4A40(&v1237, &v864);
      result = v307(v306, v309, a3, a4);
      v1237 = &off_148746580;
      if ( v1238 )
        result = sub_142FEFD50(v1238);
      v73 = v1452;
      v1238 = 0;
      v1451 = &off_148746580;
      if ( v1452 )
        goto LABEL_857;
      break;
    case 0x4B:
      v865 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v310 = sub_1455C5640(&v1453, &v865);
      v311 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v310 + 0x10LL);
      v312 = *a2;
      v866 = v312;
      if ( v312 )
        _InterlockedIncrement(v312 + 7);
      v313 = sub_1455C5640(&v1239, &v866);
      result = v311(v310, v313, a3, a4);
      v1239 = &off_148746580;
      if ( v1240 )
        result = sub_142FEFD50(v1240);
      v73 = v1454;
      v1240 = 0;
      v1453 = &off_148746580;
      if ( v1454 )
        goto LABEL_857;
      break;
    case 0x4C:
      v867 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v314 = sub_1455C56A0(&v1455, &v867);
      v315 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v314 + 0x10LL);
      v316 = *a2;
      v868 = v316;
      if ( v316 )
        _InterlockedIncrement(v316 + 7);
      v317 = sub_1455C56A0(&v1241, &v868);
      result = v315(v314, v317, a3, a4);
      v1241 = &off_148746580;
      if ( v1242 )
        result = sub_142FEFD50(v1242);
      v73 = v1456;
      v1242 = 0;
      v1455 = &off_148746580;
      if ( v1456 )
        goto LABEL_857;
      break;
    case 0x4D:
      v869 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v318 = sub_1455C5760(&v1457, &v869);
      v319 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v318 + 0x10LL);
      v320 = *a2;
      v870 = v320;
      if ( v320 )
        _InterlockedIncrement(v320 + 7);
      v321 = sub_1455C5760(&v1243, &v870);
      result = v319(v318, v321, a3, a4);
      v1243 = &off_148746580;
      if ( v1244 )
        result = sub_142FEFD50(v1244);
      v73 = v1458;
      v1244 = 0;
      v1457 = &off_148746580;
      if ( v1458 )
        goto LABEL_857;
      break;
    case 0x4E:
      v871 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v322 = sub_1455C57C0(&v1459, &v871);
      v323 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v322 + 0x10LL);
      v324 = *a2;
      v872 = v324;
      if ( v324 )
        _InterlockedIncrement(v324 + 7);
      v325 = sub_1455C57C0(&v1245, &v872);
      result = v323(v322, v325, a3, a4);
      v1245 = &off_148746580;
      if ( v1246 )
        result = sub_142FEFD50(v1246);
      v73 = v1460;
      v1246 = 0;
      v1459 = &off_148746580;
      if ( v1460 )
        goto LABEL_857;
      break;
    case 0x4F:
      v873 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v326 = sub_1455C5B90(&v1249, &v873);
      v327 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v326 + 0x10LL);
      v328 = *a2;
      v874 = v328;
      if ( v328 )
        _InterlockedIncrement(v328 + 7);
      v329 = sub_1455C5B90(&v1033, &v874);
      result = v327(v326, v329, a3, a4);
      v1033 = &off_148746580;
      if ( v1034 )
        result = sub_142FEFD50(v1034);
      v73 = v1250;
      v1034 = 0;
      v1249 = &off_148746580;
      if ( v1250 )
        goto LABEL_857;
      break;
    case 0x50:
      v875 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v330 = sub_1455C5BF0(&v1251, &v875);
      v331 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v330 + 0x10LL);
      v332 = *a2;
      v876 = v332;
      if ( v332 )
        _InterlockedIncrement(v332 + 7);
      v333 = sub_1455C5BF0(&v1035, &v876);
      result = v331(v330, v333, a3, a4);
      v1035 = &off_148746580;
      if ( v1036 )
        result = sub_142FEFD50(v1036);
      v73 = v1252;
      v1036 = 0;
      v1251 = &off_148746580;
      if ( v1252 )
        goto LABEL_857;
      break;
    case 0x51:
      v877 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v334 = sub_1455C5C50(&v1253, &v877);
      v335 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v334 + 0x10LL);
      v336 = *a2;
      v878 = v336;
      if ( v336 )
        _InterlockedIncrement(v336 + 7);
      v337 = sub_1455C5C50(&v1037, &v878);
      result = v335(v334, v337, a3, a4);
      v1037 = &off_148746580;
      if ( v1038 )
        result = sub_142FEFD50(v1038);
      v73 = v1254;
      v1038 = 0;
      v1253 = &off_148746580;
      if ( v1254 )
        goto LABEL_857;
      break;
    case 0x52:
      v879 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v338 = sub_1455C6C70(&v1255, &v879);
      v339 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v338 + 0x10LL);
      v340 = *a2;
      v880 = v340;
      if ( v340 )
        _InterlockedIncrement(v340 + 7);
      v341 = sub_1455C6C70(&v1039, &v880);
      result = v339(v338, v341, a3, a4);
      v1039 = &off_148746580;
      if ( v1040 )
        result = sub_142FEFD50(v1040);
      v73 = v1256;
      v1040 = 0;
      v1255 = &off_148746580;
      if ( v1256 )
        goto LABEL_857;
      break;
    case 0x53:
      v881 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v342 = sub_1455C5CB0(&v1257, &v881);
      v343 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v342 + 0x10LL);
      v344 = *a2;
      v882 = v344;
      if ( v344 )
        _InterlockedIncrement(v344 + 7);
      v345 = sub_1455C5CB0(&v1041, &v882);
      result = v343(v342, v345, a3, a4);
      v1041 = &off_148746580;
      if ( v1042 )
        result = sub_142FEFD50(v1042);
      v73 = v1258;
      v1042 = 0;
      v1257 = &off_148746580;
      if ( v1258 )
        goto LABEL_857;
      break;
    case 0x54:
      v883 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v346 = sub_1455C5E90(&v1259, &v883);
      v347 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v346 + 0x10LL);
      v348 = *a2;
      v884 = v348;
      if ( v348 )
        _InterlockedIncrement(v348 + 7);
      v349 = sub_1455C5E90(&v1043, &v884);
      result = v347(v346, v349, a3, a4);
      v1043 = &off_148746580;
      if ( v1044 )
        result = sub_142FEFD50(v1044);
      v73 = v1260;
      v1044 = 0;
      v1259 = &off_148746580;
      if ( v1260 )
        goto LABEL_857;
      break;
    case 0x55:
      v885 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v350 = sub_1455C5D70(&v1261, &v885);
      v351 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v350 + 0x10LL);
      v352 = *a2;
      v886 = v352;
      if ( v352 )
        _InterlockedIncrement(v352 + 7);
      v353 = sub_1455C5D70(&v1045, &v886);
      result = v351(v350, v353, a3, a4);
      v1045 = &off_148746580;
      if ( v1046 )
        result = sub_142FEFD50(v1046);
      v73 = v1262;
      v1046 = 0;
      v1261 = &off_148746580;
      if ( v1262 )
        goto LABEL_857;
      break;
    case 0x56:
      v887 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v354 = sub_1455C5F50(&v1263, &v887);
      v355 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v354 + 0x10LL);
      v356 = *a2;
      v888 = v356;
      if ( v356 )
        _InterlockedIncrement(v356 + 7);
      v357 = sub_1455C5F50(&v1047, &v888);
      result = v355(v354, v357, a3, a4);
      v1047 = &off_148746580;
      if ( v1048 )
        result = sub_142FEFD50(v1048);
      v73 = v1264;
      v1048 = 0;
      v1263 = &off_148746580;
      if ( v1264 )
        goto LABEL_857;
      break;
    case 0x57:
      v889 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v358 = sub_1455C6010(&v1265, &v889);
      v359 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v358 + 0x10LL);
      v360 = *a2;
      v890 = v360;
      if ( v360 )
        _InterlockedIncrement(v360 + 7);
      v361 = sub_1455C6010(&v1049, &v890);
      result = v359(v358, v361, a3, a4);
      v1049 = &off_148746580;
      if ( v1050 )
        result = sub_142FEFD50(v1050);
      v73 = v1266;
      v1050 = 0;
      v1265 = &off_148746580;
      if ( v1266 )
        goto LABEL_857;
      break;
    case 0x58:
      v891 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v362 = sub_1455C62B0(&v1267, &v891);
      v363 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v362 + 0x10LL);
      v364 = *a2;
      v892 = v364;
      if ( v364 )
        _InterlockedIncrement(v364 + 7);
      v365 = sub_1455C62B0(&v1051, &v892);
      result = v363(v362, v365, a3, a4);
      v1051 = &off_148746580;
      if ( v1052 )
        result = sub_142FEFD50(v1052);
      v73 = v1268;
      v1052 = 0;
      v1267 = &off_148746580;
      if ( v1268 )
        goto LABEL_857;
      break;
    case 0x59:
      v893 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v366 = sub_1455C6370(&v1269, &v893);
      v367 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v366 + 0x10LL);
      v368 = *a2;
      v894 = v368;
      if ( v368 )
        _InterlockedIncrement(v368 + 7);
      v369 = sub_1455C6370(&v1053, &v894);
      result = v367(v366, v369, a3, a4);
      v1053 = &off_148746580;
      if ( v1054 )
        result = sub_142FEFD50(v1054);
      v73 = v1270;
      v1054 = 0;
      v1269 = &off_148746580;
      if ( v1270 )
        goto LABEL_857;
      break;
    case 0x5A:
      v895 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v370 = sub_1455C6430(&v1271, &v895);
      v371 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v370 + 0x10LL);
      v372 = *a2;
      v896 = v372;
      if ( v372 )
        _InterlockedIncrement(v372 + 7);
      v373 = sub_1455C6430(&v1055, &v896);
      result = v371(v370, v373, a3, a4);
      v1055 = &off_148746580;
      if ( v1056 )
        result = sub_142FEFD50(v1056);
      v73 = v1272;
      v1056 = 0;
      v1271 = &off_148746580;
      if ( v1272 )
        goto LABEL_857;
      break;
    case 0x5B:
      v897 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v374 = sub_1455C6490(&v1273, &v897);
      v375 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v374 + 0x10LL);
      v376 = *a2;
      v898 = v376;
      if ( v376 )
        _InterlockedIncrement(v376 + 7);
      v377 = sub_1455C6490(&v1057, &v898);
      result = v375(v374, v377, a3, a4);
      v1057 = &off_148746580;
      if ( v1058 )
        result = sub_142FEFD50(v1058);
      v73 = v1274;
      v1058 = 0;
      v1273 = &off_148746580;
      if ( v1274 )
        goto LABEL_857;
      break;
    case 0x5C:
      v899 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v378 = sub_1455C6670(&v1275, &v899);
      v379 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v378 + 0x10LL);
      v380 = *a2;
      v900 = v380;
      if ( v380 )
        _InterlockedIncrement(v380 + 7);
      v381 = sub_1455C6670(&v1059, &v900);
      result = v379(v378, v381, a3, a4);
      v1059 = &off_148746580;
      if ( v1060 )
        result = sub_142FEFD50(v1060);
      v73 = v1276;
      v1060 = 0;
      v1275 = &off_148746580;
      if ( v1276 )
        goto LABEL_857;
      break;
    case 0x5D:
      v901 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v382 = sub_1455C66D0(&v1277, &v901);
      v383 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v382 + 0x10LL);
      v384 = *a2;
      v902 = v384;
      if ( v384 )
        _InterlockedIncrement(v384 + 7);
      v385 = sub_1455C66D0(&v1061, &v902);
      result = v383(v382, v385, a3, a4);
      v1061 = &off_148746580;
      if ( v1062 )
        result = sub_142FEFD50(v1062);
      v73 = v1278;
      v1062 = 0;
      v1277 = &off_148746580;
      if ( v1278 )
        goto LABEL_857;
      break;
    case 0x5E:
      v903 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v386 = sub_1455C6730(&v1279, &v903);
      v387 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v386 + 0x10LL);
      v388 = *a2;
      v904 = v388;
      if ( v388 )
        _InterlockedIncrement(v388 + 7);
      v389 = sub_1455C6730(&v1063, &v904);
      result = v387(v386, v389, a3, a4);
      v1063 = &off_148746580;
      if ( v1064 )
        result = sub_142FEFD50(v1064);
      v73 = v1280;
      v1064 = 0;
      v1279 = &off_148746580;
      if ( v1280 )
        goto LABEL_857;
      break;
    case 0x5F:
      v905 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v390 = sub_1455C6790(&v1281, &v905);
      v391 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v390 + 0x10LL);
      v392 = *a2;
      v906 = v392;
      if ( v392 )
        _InterlockedIncrement(v392 + 7);
      v393 = sub_1455C6790(&v1065, &v906);
      result = v391(v390, v393, a3, a4);
      v1065 = &off_148746580;
      if ( v1066 )
        result = sub_142FEFD50(v1066);
      v73 = v1282;
      v1066 = 0;
      v1281 = &off_148746580;
      if ( v1282 )
        goto LABEL_857;
      break;
    case 0x60:
      v907 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v394 = sub_1455C67F0(&v1283, &v907);
      v395 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v394 + 0x10LL);
      v396 = *a2;
      v908 = v396;
      if ( v396 )
        _InterlockedIncrement(v396 + 7);
      v397 = sub_1455C67F0(&v1067, &v908);
      result = v395(v394, v397, a3, a4);
      v1067 = &off_148746580;
      if ( v1068 )
        result = sub_142FEFD50(v1068);
      v73 = v1284;
      v1068 = 0;
      v1283 = &off_148746580;
      if ( v1284 )
        goto LABEL_857;
      break;
    case 0x61:
      v909 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v398 = sub_1455C68B0(&v1285, &v909);
      v399 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v398 + 0x10LL);
      v400 = *a2;
      v910 = v400;
      if ( v400 )
        _InterlockedIncrement(v400 + 7);
      v401 = sub_1455C68B0(&v1069, &v910);
      result = v399(v398, v401, a3, a4);
      v1069 = &off_148746580;
      if ( v1070 )
        result = sub_142FEFD50(v1070);
      v73 = v1286;
      v1070 = 0;
      v1285 = &off_148746580;
      if ( v1286 )
        goto LABEL_857;
      break;
    case 0x62:
      v911 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v402 = sub_1455C6070(&v1287, &v911);
      v403 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v402 + 0x10LL);
      v404 = *a2;
      v912 = v404;
      if ( v404 )
        _InterlockedIncrement(v404 + 7);
      v405 = sub_1455C6070(&v1071, &v912);
      result = v403(v402, v405, a3, a4);
      v1071 = &off_148746580;
      if ( v1072 )
        result = sub_142FEFD50(v1072);
      v73 = v1288;
      v1072 = 0;
      v1287 = &off_148746580;
      if ( v1288 )
        goto LABEL_857;
      break;
    case 0x63:
      v913 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v406 = sub_1455C69D0(&v1289, &v913);
      v407 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v406 + 0x10LL);
      v408 = *a2;
      v914 = v408;
      if ( v408 )
        _InterlockedIncrement(v408 + 7);
      v409 = sub_1455C69D0(&v1073, &v914);
      result = v407(v406, v409, a3, a4);
      v1073 = &off_148746580;
      if ( v1074 )
        result = sub_142FEFD50(v1074);
      v73 = v1290;
      v1074 = 0;
      v1289 = &off_148746580;
      if ( v1290 )
        goto LABEL_857;
      break;
    case 0x64:
      v915 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v410 = sub_1455C6A30(&v1291, &v915);
      v411 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v410 + 0x10LL);
      v412 = *a2;
      v916 = v412;
      if ( v412 )
        _InterlockedIncrement(v412 + 7);
      v413 = sub_1455C6A30(&v1075, &v916);
      result = v411(v410, v413, a3, a4);
      v1075 = &off_148746580;
      if ( v1076 )
        result = sub_142FEFD50(v1076);
      v73 = v1292;
      v1076 = 0;
      v1291 = &off_148746580;
      if ( v1292 )
        goto LABEL_857;
      break;
    case 0x65:
      v917 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v414 = sub_1455C6A90(&v1293, &v917);
      v415 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v414 + 0x10LL);
      v416 = *a2;
      v918 = v416;
      if ( v416 )
        _InterlockedIncrement(v416 + 7);
      v417 = sub_1455C6A90(&v1077, &v918);
      result = v415(v414, v417, a3, a4);
      v1077 = &off_148746580;
      if ( v1078 )
        result = sub_142FEFD50(v1078);
      v73 = v1294;
      v1078 = 0;
      v1293 = &off_148746580;
      if ( v1294 )
        goto LABEL_857;
      break;
    case 0x66:
      v919 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v418 = sub_1455C4A40(&v1295, &v919);
      v419 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v418 + 0x10LL);
      v420 = *a2;
      v920 = v420;
      if ( v420 )
        _InterlockedIncrement(v420 + 7);
      v421 = sub_1455C4A40(&v1079, &v920);
      result = v419(v418, v421, a3, a4);
      v1079 = &off_148746580;
      if ( v1080 )
        result = sub_142FEFD50(v1080);
      v73 = v1296;
      v1080 = 0;
      v1295 = &off_148746580;
      if ( v1296 )
        goto LABEL_857;
      break;
    case 0x67:
      v921 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v422 = sub_1455C5EF0(&v1297, &v921);
      v423 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v422 + 0x10LL);
      v424 = *a2;
      v922 = v424;
      if ( v424 )
        _InterlockedIncrement(v424 + 7);
      v425 = sub_1455C5EF0(&v1081, &v922);
      result = v423(v422, v425, a3, a4);
      v1081 = &off_148746580;
      if ( v1082 )
        result = sub_142FEFD50(v1082);
      v73 = v1298;
      v1082 = 0;
      v1297 = &off_148746580;
      if ( v1298 )
        goto LABEL_857;
      break;
    case 0x68:
      v923 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v426 = sub_1455C71F0(&v1299, &v923);
      v427 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v426 + 0x10LL);
      v428 = *a2;
      v924 = v428;
      if ( v428 )
        _InterlockedIncrement(v428 + 7);
      v429 = sub_1455C71F0(&v1083, &v924);
      result = v427(v426, v429, a3, a4);
      v1083 = &off_148746580;
      if ( v1084 )
        result = sub_142FEFD50(v1084);
      v73 = v1300;
      v1084 = 0;
      v1299 = &off_148746580;
      if ( v1300 )
        goto LABEL_857;
      break;
    case 0x69:
      v925 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v430 = sub_1455C6D90(&v1301, &v925);
      v431 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v430 + 0x10LL);
      v432 = *a2;
      v926 = v432;
      if ( v432 )
        _InterlockedIncrement(v432 + 7);
      v433 = sub_1455C6D90(&v1085, &v926);
      result = v431(v430, v433, a3, a4);
      v1085 = &off_148746580;
      if ( v1086 )
        result = sub_142FEFD50(v1086);
      v73 = v1302;
      v1086 = 0;
      v1301 = &off_148746580;
      if ( v1302 )
        goto LABEL_857;
      break;
    case 0x6A:
      v927 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v434 = sub_1455C6B50(&v1379, &v927);
      v435 = *(__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v434 + 0x10LL);
      v436 = *a2;
      v928 = v436;
      if ( v436 )
        _InterlockedIncrement(v436 + 7);
      v437 = sub_1455C6B50(&v1087, &v928);
      result = v435(v434, v437, a3, a4);
      v1087 = &off_148746580;
      if ( v1088 )
        result = sub_142FEFD50(v1088);
      v73 = v1380;
      v1088 = 0;
      v1379 = &off_148746580;
      if ( v1380 )
LABEL_857:
        result = sub_142FEFD50(v73);
      break;
    case 0x6B:
      v929 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v438 = sub_1455C6C10(v1490, &v929);
      v439 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v438 + 0x10LL);
      v440 = *a2;
      v930 = v440;
      if ( v440 )
        _InterlockedIncrement(v440 + 7);
      v441 = sub_1455C6C10(v1489, &v930);
      v439(v438, v441, a3, a4);
      sub_142F709D0(v1489);
      result = (__int64)sub_142F709D0(v1490);
      break;
    case 0x6C:
      v931 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v442 = sub_1455C6CD0(v1492, &v931);
      v443 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v442 + 0x10LL);
      v444 = *a2;
      v932 = v444;
      if ( v444 )
        _InterlockedIncrement(v444 + 7);
      v445 = sub_1455C6CD0(v1491, &v932);
      v443(v442, v445, a3, a4);
      sub_142F709D0(v1491);
      result = (__int64)sub_142F709D0(v1492);
      break;
    case 0x6D:
      v933 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v446 = sub_1455C6D30(v1494, &v933);
      v447 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v446 + 0x10LL);
      v448 = *a2;
      v934 = v448;
      if ( v448 )
        _InterlockedIncrement(v448 + 7);
      v449 = sub_1455C6D30(v1493, &v934);
      v447(v446, v449, a3, a4);
      sub_142F709D0(v1493);
      result = (__int64)sub_142F709D0(v1494);
      break;
    case 0x6E:
      v935 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v450 = sub_1455C6EB0(v1496, &v935);
      v451 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v450 + 0x10LL);
      v452 = *a2;
      v936 = v452;
      if ( v452 )
        _InterlockedIncrement(v452 + 7);
      v453 = sub_1455C6EB0(v1495, &v936);
      v451(v450, v453, a3, a4);
      sub_142F709D0(v1495);
      result = (__int64)sub_142F709D0(v1496);
      break;
    case 0x6F:
      v937 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v454 = sub_1455C7020(v1498, &v937);
      v455 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v454 + 0x10LL);
      v456 = *a2;
      v938 = v456;
      if ( v456 )
        _InterlockedIncrement(v456 + 7);
      v457 = sub_1455C7020(v1497, &v938);
      v455(v454, v457, a3, a4);
      sub_142F709D0(v1497);
      result = (__int64)sub_142F709D0(v1498);
      break;
    case 0x70:
      v939 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v458 = sub_1455C72C0(v1500, &v939);
      v459 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v458 + 0x10LL);
      v460 = *a2;
      v940 = v460;
      if ( v460 )
        _InterlockedIncrement(v460 + 7);
      v461 = sub_1455C72C0(v1499, &v940);
      v459(v458, v461, a3, a4);
      sub_142F709D0(v1499);
      result = (__int64)sub_142F709D0(v1500);
      break;
    case 0x71:
      v941 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v462 = sub_1455C6DF0(v1502, &v941);
      v463 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v462 + 0x10LL);
      v464 = *a2;
      v942 = v464;
      if ( v464 )
        _InterlockedIncrement(v464 + 7);
      v465 = sub_1455C6DF0(v1501, &v942);
      v463(v462, v465, a3, a4);
      sub_142F709D0(v1501);
      result = (__int64)sub_142F709D0(v1502);
      break;
    case 0x72:
      v943 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v466 = sub_1455C4530(v1504, &v943);
      v467 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v466 + 0x10LL);
      v468 = *a2;
      v944 = v468;
      if ( v468 )
        _InterlockedIncrement(v468 + 7);
      v469 = sub_1455C4530(v1503, &v944);
      v467(v466, v469, a3, a4);
      sub_142F709D0(v1503);
      result = (__int64)sub_142F709D0(v1504);
      break;
    case 0x73:
      v945 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v470 = sub_1455C4B00(v1506, &v945);
      v471 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v470 + 0x10LL);
      v472 = *a2;
      v946 = v472;
      if ( v472 )
        _InterlockedIncrement(v472 + 7);
      v473 = sub_1455C4B00(v1505, &v946);
      v471(v470, v473, a3, a4);
      sub_142F709D0(v1505);
      result = (__int64)sub_142F709D0(v1506);
      break;
    case 0x74:
      v947 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v474 = sub_1455C5D10(v1508, &v947);
      v475 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v474 + 0x10LL);
      v476 = *a2;
      v948 = v476;
      if ( v476 )
        _InterlockedIncrement(v476 + 7);
      v477 = sub_1455C5D10(v1507, &v948);
      v475(v474, v477, a3, a4);
      sub_142F709D0(v1507);
      result = (__int64)sub_142F709D0(v1508);
      break;
    case 0x75:
      v949 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v478 = sub_1455C4A40(v1510, &v949);
      v479 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v478 + 0x10LL);
      v480 = *a2;
      v950 = v480;
      if ( v480 )
        _InterlockedIncrement(v480 + 7);
      v481 = sub_1455C4A40(v1509, &v950);
      v479(v478, v481, a3, a4);
      sub_142F709D0(v1509);
      result = (__int64)sub_142F709D0(v1510);
      break;
    case 0x76:
      v951 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v482 = sub_1455C4A40(v1512, &v951);
      v483 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v482 + 0x10LL);
      v484 = *a2;
      v952 = v484;
      if ( v484 )
        _InterlockedIncrement(v484 + 7);
      v485 = sub_1455C4A40(v1511, &v952);
      v483(v482, v485, a3, a4);
      sub_142F709D0(v1511);
      result = (__int64)sub_142F709D0(v1512);
      break;
    case 0x77:
      v953 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v486 = sub_1455C4980(v1514, &v953);
      v487 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v486 + 0x10LL);
      v488 = *a2;
      v954 = v488;
      if ( v488 )
        _InterlockedIncrement(v488 + 7);
      v489 = sub_1455C4980(v1513, &v954);
      v487(v486, v489, a3, a4);
      sub_142F709D0(v1513);
      result = (__int64)sub_142F709D0(v1514);
      break;
    case 0x78:
      v955 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v490 = sub_1455C7670(v1516, &v955);
      v491 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v490 + 0x10LL);
      v492 = *a2;
      v956 = v492;
      if ( v492 )
        _InterlockedIncrement(v492 + 7);
      v493 = sub_1455C7670(v1515, &v956);
      v491(v490, v493, a3, a4);
      sub_142F709D0(v1515);
      result = (__int64)sub_142F709D0(v1516);
      break;
    case 0x79:
      v957 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v494 = sub_1455C59B0(v1518, &v957);
      v495 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v494 + 0x10LL);
      v496 = *a2;
      v958 = v496;
      if ( v496 )
        _InterlockedIncrement(v496 + 7);
      v497 = sub_1455C59B0(v1517, &v958);
      v495(v494, v497, a3, a4);
      sub_142F709D0(v1517);
      result = (__int64)sub_142F709D0(v1518);
      break;
    case 0x7A:
      v959 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v498 = sub_1455C5A10(v1520, &v959);
      v499 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v498 + 0x10LL);
      v500 = *a2;
      v960 = v500;
      if ( v500 )
        _InterlockedIncrement(v500 + 7);
      v501 = sub_1455C5A10(v1519, &v960);
      v499(v498, v501, a3, a4);
      sub_142F709D0(v1519);
      result = (__int64)sub_142F709D0(v1520);
      break;
    case 0x7B:
      v961 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v502 = sub_1455C5A70(v1522, &v961);
      v503 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v502 + 0x10LL);
      v504 = *a2;
      v962 = v504;
      if ( v504 )
        _InterlockedIncrement(v504 + 7);
      v505 = sub_1455C5A70(v1521, &v962);
      v503(v502, v505, a3, a4);
      sub_142F709D0(v1521);
      result = (__int64)sub_142F709D0(v1522);
      break;
    case 0x7C:
      v963 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v506 = sub_1455C6550(v1524, &v963);
      v507 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v506 + 0x10LL);
      v508 = *a2;
      v964 = v508;
      if ( v508 )
        _InterlockedIncrement(v508 + 7);
      v509 = sub_1455C6550(v1523, &v964);
      v507(v506, v509, a3, a4);
      sub_142F709D0(v1523);
      result = (__int64)sub_142F709D0(v1524);
      break;
    case 0x7D:
      v965 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v510 = sub_1455C4BC0(v1526, &v965);
      v511 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v510 + 0x10LL);
      v512 = *a2;
      v966 = v512;
      if ( v512 )
        _InterlockedIncrement(v512 + 7);
      v513 = sub_1455C4BC0(v1525, &v966);
      v511(v510, v513, a3, a4);
      sub_142F709D0(v1525);
      result = (__int64)sub_142F709D0(v1526);
      break;
    case 0x7E:
      v967 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v514 = sub_1455C76D0(v1528, &v967);
      v515 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v514 + 0x10LL);
      v516 = *a2;
      v968 = v516;
      if ( v516 )
        _InterlockedIncrement(v516 + 7);
      v517 = sub_1455C76D0(v1527, &v968);
      v515(v514, v517, a3, a4);
      sub_142F709D0(v1527);
      result = (__int64)sub_142F709D0(v1528);
      break;
    case 0x7F:
      v969 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v518 = sub_1455C7730(v1530, &v969);
      v519 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v518 + 0x10LL);
      v520 = *a2;
      v970 = v520;
      if ( v520 )
        _InterlockedIncrement(v520 + 7);
      v521 = sub_1455C7730(v1529, &v970);
      v519(v518, v521, a3, a4);
      sub_142F709D0(v1529);
      result = (__int64)sub_142F709D0(v1530);
      break;
    case 0x80:
      v971 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v522 = sub_1455C7790(v1532, &v971);
      v523 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v522 + 0x10LL);
      v524 = *a2;
      v972 = v524;
      if ( v524 )
        _InterlockedIncrement(v524 + 7);
      v525 = sub_1455C7790(v1531, &v972);
      v523(v522, v525, a3, a4);
      sub_142F709D0(v1531);
      result = (__int64)sub_142F709D0(v1532);
      break;
    case 0x81:
      v973 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v526 = sub_1455C77F0(v1534, &v973);
      v527 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v526 + 0x10LL);
      v528 = *a2;
      v974 = v528;
      if ( v528 )
        _InterlockedIncrement(v528 + 7);
      v529 = sub_1455C77F0(v1533, &v974);
      v527(v526, v529, a3, a4);
      sub_142F709D0(v1533);
      result = (__int64)sub_142F709D0(v1534);
      break;
    case 0x82:
      v975 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v530 = sub_1455C7910(v1536, &v975);
      v531 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v530 + 0x10LL);
      v532 = *a2;
      v976 = v532;
      if ( v532 )
        _InterlockedIncrement(v532 + 7);
      v533 = sub_1455C7910(v1535, &v976);
      v531(v530, v533, a3, a4);
      sub_142F709D0(v1535);
      result = (__int64)sub_142F709D0(v1536);
      break;
    case 0x83:
      v977 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v534 = sub_1455C7850(v1538, &v977);
      v535 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v534 + 0x10LL);
      v536 = *a2;
      v978 = v536;
      if ( v536 )
        _InterlockedIncrement(v536 + 7);
      v537 = sub_1455C7850(v1537, &v978);
      v535(v534, v537, a3, a4);
      sub_142F709D0(v1537);
      result = (__int64)sub_142F709D0(v1538);
      break;
    case 0x84:
      v979 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v538 = sub_1455C78B0(v1540, &v979);
      v539 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v538 + 0x10LL);
      v540 = *a2;
      v980 = v540;
      if ( v540 )
        _InterlockedIncrement(v540 + 7);
      v541 = sub_1455C78B0(v1539, &v980);
      v539(v538, v541, a3, a4);
      sub_142F709D0(v1539);
      result = (__int64)sub_142F709D0(v1540);
      break;
    case 0x85:
      v981 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v542 = sub_1455C75B0(v1542, &v981);
      v543 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v542 + 0x10LL);
      v544 = *a2;
      v982 = v544;
      if ( v544 )
        _InterlockedIncrement(v544 + 7);
      v545 = sub_1455C75B0(v1541, &v982);
      v543(v542, v545, a3, a4);
      sub_142F709D0(v1541);
      result = (__int64)sub_142F709D0(v1542);
      break;
    case 0x86:
      v983 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v546 = sub_1455C6190(v1544, &v983);
      v547 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v546 + 0x10LL);
      v548 = *a2;
      v984 = v548;
      if ( v548 )
        _InterlockedIncrement(v548 + 7);
      v549 = sub_1455C6190(v1543, &v984);
      v547(v546, v549, a3, a4);
      sub_142F709D0(v1543);
      result = (__int64)sub_142F709D0(v1544);
      break;
    case 0x87:
      v985 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v550 = sub_1455C48C0(v1546, &v985);
      v551 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v550 + 0x10LL);
      v552 = *a2;
      v986 = v552;
      if ( v552 )
        _InterlockedIncrement(v552 + 7);
      v553 = sub_1455C48C0(v1545, &v986);
      v551(v550, v553, a3, a4);
      sub_142F709D0(v1545);
      result = (__int64)sub_142F709D0(v1546);
      break;
    case 0x88:
      v987 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v554 = sub_1455C5E30(v1548, &v987);
      v555 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v554 + 0x10LL);
      v556 = *a2;
      v988 = v556;
      if ( v556 )
        _InterlockedIncrement(v556 + 7);
      v557 = sub_1455C5E30(v1547, &v988);
      v555(v554, v557, a3, a4);
      sub_142F709D0(v1547);
      result = (__int64)sub_142F709D0(v1548);
      break;
    case 0x89:
      v989 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v558 = sub_1455C49E0(v1550, &v989);
      v559 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v558 + 0x10LL);
      v560 = *a2;
      v990 = v560;
      if ( v560 )
        _InterlockedIncrement(v560 + 7);
      v561 = sub_1455C49E0(v1549, &v990);
      v559(v558, v561, a3, a4);
      sub_142F709D0(v1549);
      result = (__int64)sub_142F709D0(v1550);
      break;
    case 0x8A:
      v991 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v562 = sub_1455C3D10(v1552, &v991);
      v563 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v562 + 0x10LL);
      v564 = *a2;
      v992 = v564;
      if ( v564 )
        _InterlockedIncrement(v564 + 7);
      v565 = sub_1455C3D10(v1551, &v992);
      v563(v562, v565, a3, a4);
      sub_142F709D0(v1551);
      result = (__int64)sub_142F709D0(v1552);
      break;
    case 0x8B:
      v993 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v566 = sub_1455C4680(v1554, &v993);
      v567 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v566 + 0x10LL);
      v568 = *a2;
      v994 = v568;
      if ( v568 )
        _InterlockedIncrement(v568 + 7);
      v569 = sub_1455C4680(v1553, &v994);
      v567(v566, v569, a3, a4);
      sub_142F709D0(v1553);
      result = (__int64)sub_142F709D0(v1554);
      break;
    case 0x8C:
      v995 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v570 = sub_1455C4740(v1556, &v995);
      v571 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v570 + 0x10LL);
      v572 = *a2;
      v996 = v572;
      if ( v572 )
        _InterlockedIncrement(v572 + 7);
      v573 = sub_1455C4740(v1555, &v996);
      v571(v570, v573, a3, a4);
      sub_142F709D0(v1555);
      result = (__int64)sub_142F709D0(v1556);
      break;
    case 0x8D:
      v997 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v574 = sub_1455C5160(v1558, &v997);
      v575 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v574 + 0x10LL);
      v576 = *a2;
      v998 = v576;
      if ( v576 )
        _InterlockedIncrement(v576 + 7);
      v577 = sub_1455C5160(v1557, &v998);
      v575(v574, v577, a3, a4);
      sub_142F709D0(v1557);
      result = (__int64)sub_142F709D0(v1558);
      break;
    case 0x8E:
      v999 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v578 = sub_1455C4D40(v1560, &v999);
      v579 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v578 + 0x10LL);
      v580 = *a2;
      v1000 = v580;
      if ( v580 )
        _InterlockedIncrement(v580 + 7);
      v581 = sub_1455C4D40(v1559, &v1000);
      v579(v578, v581, a3, a4);
      sub_142F709D0(v1559);
      result = (__int64)sub_142F709D0(v1560);
      break;
    case 0x8F:
      v1001 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v582 = sub_1455C4EC0(v1562, &v1001);
      v583 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v582 + 0x10LL);
      v584 = *a2;
      v1002 = v584;
      if ( v584 )
        _InterlockedIncrement(v584 + 7);
      v585 = sub_1455C4EC0(v1561, &v1002);
      v583(v582, v585, a3, a4);
      sub_142F709D0(v1561);
      result = (__int64)sub_142F709D0(v1562);
      break;
    case 0x90:
      v1003 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v586 = sub_1455C5400(v1564, &v1003);
      v587 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v586 + 0x10LL);
      v588 = *a2;
      v1004 = v588;
      if ( v588 )
        _InterlockedIncrement(v588 + 7);
      v589 = sub_1455C5400(v1563, &v1004);
      v587(v586, v589, a3, a4);
      sub_142F709D0(v1563);
      result = (__int64)sub_142F709D0(v1564);
      break;
    case 0x91:
      v1005 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v590 = sub_1455C5460(v1566, &v1005);
      v591 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v590 + 0x10LL);
      v592 = *a2;
      v1006 = v592;
      if ( v592 )
        _InterlockedIncrement(v592 + 7);
      v593 = sub_1455C5460(v1565, &v1006);
      v591(v590, v593, a3, a4);
      sub_142F709D0(v1565);
      result = (__int64)sub_142F709D0(v1566);
      break;
    case 0x92:
      v1007 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v594 = sub_1455C5520(v1568, &v1007);
      v595 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v594 + 0x10LL);
      v596 = *a2;
      v1008 = v596;
      if ( v596 )
        _InterlockedIncrement(v596 + 7);
      v597 = sub_1455C5520(v1567, &v1008);
      v595(v594, v597, a3, a4);
      sub_142F709D0(v1567);
      result = (__int64)sub_142F709D0(v1568);
      break;
    case 0x93:
      v1009 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v598 = sub_1455C5580(v1570, &v1009);
      v599 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v598 + 0x10LL);
      v600 = *a2;
      v1010 = v600;
      if ( v600 )
        _InterlockedIncrement(v600 + 7);
      v601 = sub_1455C5580(v1569, &v1010);
      v599(v598, v601, a3, a4);
      sub_142F709D0(v1569);
      result = (__int64)sub_142F709D0(v1570);
      break;
    case 0x94:
      v1011 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v602 = sub_1455C55E0(v1572, &v1011);
      v603 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v602 + 0x10LL);
      v604 = *a2;
      v1012 = v604;
      if ( v604 )
        _InterlockedIncrement(v604 + 7);
      v605 = sub_1455C55E0(v1571, &v1012);
      v603(v602, v605, a3, a4);
      sub_142F709D0(v1571);
      result = (__int64)sub_142F709D0(v1572);
      break;
    case 0x95:
      v1013 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v606 = sub_1455C5AD0(v1574, &v1013);
      v607 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v606 + 0x10LL);
      v608 = *a2;
      v1014 = v608;
      if ( v608 )
        _InterlockedIncrement(v608 + 7);
      v609 = sub_1455C5AD0(v1573, &v1014);
      v607(v606, v609, a3, a4);
      sub_142F709D0(v1573);
      result = (__int64)sub_142F709D0(v1574);
      break;
    case 0x96:
      v1015 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v610 = sub_1455C5700(v1576, &v1015);
      v611 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v610 + 0x10LL);
      v612 = *a2;
      v1016 = v612;
      if ( v612 )
        _InterlockedIncrement(v612 + 7);
      v613 = sub_1455C5700(v1575, &v1016);
      v611(v610, v613, a3, a4);
      sub_142F709D0(v1575);
      result = (__int64)sub_142F709D0(v1576);
      break;
    case 0x97:
      v1017 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v614 = sub_1455C5FB0(v1578, &v1017);
      v615 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v614 + 0x10LL);
      v616 = *a2;
      v1018 = v616;
      if ( v616 )
        _InterlockedIncrement(v616 + 7);
      v617 = sub_1455C5FB0(v1577, &v1018);
      v615(v614, v617, a3, a4);
      sub_142F709D0(v1577);
      result = (__int64)sub_142F709D0(v1578);
      break;
    case 0x98:
      v1019 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v618 = sub_1455C61F0(v1580, &v1019);
      v619 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v618 + 0x10LL);
      v620 = *a2;
      v1020 = v620;
      if ( v620 )
        _InterlockedIncrement(v620 + 7);
      v621 = sub_1455C61F0(v1579, &v1020);
      v619(v618, v621, a3, a4);
      sub_142F709D0(v1579);
      result = (__int64)sub_142F709D0(v1580);
      break;
    case 0x99:
      v1021 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v622 = sub_1455C6310(v1582, &v1021);
      v623 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v622 + 0x10LL);
      v624 = *a2;
      v1022 = v624;
      if ( v624 )
        _InterlockedIncrement(v624 + 7);
      v625 = sub_1455C6310(v1581, &v1022);
      v623(v622, v625, a3, a4);
      sub_142F709D0(v1581);
      result = (__int64)sub_142F709D0(v1582);
      break;
    case 0x9A:
      v1023 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v626 = sub_1455C6850(v1584, &v1023);
      v627 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v626 + 0x10LL);
      v628 = *a2;
      v1024 = v628;
      if ( v628 )
        _InterlockedIncrement(v628 + 7);
      v629 = sub_1455C6850(v1583, &v1024);
      v627(v626, v629, a3, a4);
      sub_142F709D0(v1583);
      result = (__int64)sub_142F709D0(v1584);
      break;
    case 0x9B:
      v1025 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v630 = sub_1455C6BB0(v1586, &v1025);
      v631 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v630 + 0x10LL);
      v632 = *a2;
      v1026 = v632;
      if ( v632 )
        _InterlockedIncrement(v632 + 7);
      v633 = sub_1455C6BB0(v1585, &v1026);
      v631(v630, v633, a3, a4);
      sub_142F709D0(v1585);
      result = (__int64)sub_142F709D0(v1586);
      break;
    case 0x9C:
      v1027 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v634 = sub_1455C7490(v1588, &v1027);
      v635 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v634 + 0x10LL);
      v636 = *a2;
      v1028 = v636;
      if ( v636 )
        _InterlockedIncrement(v636 + 7);
      v637 = sub_1455C7490(v1587, &v1028);
      v635(v634, v637, a3, a4);
      sub_142F709D0(v1587);
      result = (__int64)sub_142F709D0(v1588);
      break;
    case 0x9D:
      v1029 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v638 = sub_1455C7430(v1590, &v1029);
      v639 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v638 + 0x10LL);
      v640 = *a2;
      v1030 = v640;
      if ( v640 )
        _InterlockedIncrement(v640 + 7);
      v641 = sub_1455C7430(v1589, &v1030);
      v639(v638, v641, a3, a4);
      sub_142F709D0(v1589);
      result = (__int64)sub_142F709D0(v1590);
      break;
    case 0x9E:
      v1031 = (volatile signed __int32 *)*a1;
      if ( v4 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 0x1C));
      v642 = sub_1455C7550(v1592, &v1031);
      v643 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v642 + 0x10LL);
      v644 = *a2;
      v1032 = v644;
      if ( v644 )
        _InterlockedIncrement(v644 + 7);
      v645 = sub_1455C7550(v1591, &v1032);
      v643(v642, v645, a3, a4);
      sub_142F709D0(v1591);
      result = (__int64)sub_142F709D0(v1592);
      break;
    case 0x9F:
      v646 = sub_142F63590(&v1488, a1);
      v647 = sub_1455C74F0(v1594, (volatile signed __int32 **)v646);
      v648 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v647 + 0x10LL);
      v649 = sub_142F63590(&v1461, (__int64 *)a2);
      v650 = sub_1455C74F0(v1593, (volatile signed __int32 **)v649);
      v648(v647, v650, a3, a4);
      sub_142F709D0(v1593);
      result = (__int64)sub_142F709D0(v1594);
      break;
    case 0xA0:
      v651 = sub_142F63590(&v1462, a1);
      v652 = sub_1455C54C0(v1596, (volatile signed __int32 **)v651);
      v653 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v652 + 0x10LL);
      v654 = sub_142F63590(&v1463, (__int64 *)a2);
      v655 = sub_1455C54C0(v1595, (volatile signed __int32 **)v654);
      v653(v652, v655, a3, a4);
      sub_142F709D0(v1595);
      result = (__int64)sub_142F709D0(v1596);
      break;
    case 0xA1:
      v656 = sub_142F63590(&v1464, a1);
      v657 = sub_1455C7A90(v1598, (volatile signed __int32 **)v656);
      v658 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v657 + 0x10LL);
      v659 = sub_142F63590(&v1465, (__int64 *)a2);
      v660 = sub_1455C7A90(v1597, (volatile signed __int32 **)v659);
      v658(v657, v660, a3, a4);
      sub_142F709D0(v1597);
      result = (__int64)sub_142F709D0(v1598);
      break;
    case 0xA2:
      v661 = sub_142F63590(&v1466, a1);
      v662 = sub_1455C7C10(v1600, (volatile signed __int32 **)v661);
      v663 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v662 + 0x10LL);
      v664 = sub_142F63590(&v1467, (__int64 *)a2);
      v665 = sub_1455C7C10(v1599, (volatile signed __int32 **)v664);
      v663(v662, v665, a3, a4);
      sub_142F709D0(v1599);
      result = (__int64)sub_142F709D0(v1600);
      break;
    case 0xA3:
      v666 = sub_142F63590(&v1468, a1);
      v667 = sub_1455C7AF0(v1602, (volatile signed __int32 **)v666);
      v668 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v667 + 0x10LL);
      v669 = sub_142F63590(&v1469, (__int64 *)a2);
      v670 = sub_1455C7AF0(v1601, (volatile signed __int32 **)v669);
      v668(v667, v670, a3, a4);
      sub_142F709D0(v1601);
      result = (__int64)sub_142F709D0(v1602);
      break;
    case 0xA4:
      v671 = sub_142F63590(&v1470, a1);
      v672 = sub_1455C7B50(v1604, (volatile signed __int32 **)v671);
      v673 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v672 + 0x10LL);
      v674 = sub_142F63590(&v1471, (__int64 *)a2);
      v675 = sub_1455C7B50(v1603, (volatile signed __int32 **)v674);
      v673(v672, v675, a3, a4);
      sub_142F709D0(v1603);
      result = (__int64)sub_142F709D0(v1604);
      break;
    case 0xA5:
      v676 = sub_142F63590(&v1472, a1);
      v677 = sub_1455C7BB0(v1606, (volatile signed __int32 **)v676);
      v678 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v677 + 0x10LL);
      v679 = sub_142F63590(&v1473, (__int64 *)a2);
      v680 = sub_1455C7BB0(v1605, (volatile signed __int32 **)v679);
      v678(v677, v680, a3, a4);
      sub_142F709D0(v1605);
      result = (__int64)sub_142F709D0(v1606);
      break;
    case 0xA6:
      v681 = sub_142F63590(&v1474, a1);
      v682 = sub_1455C7320(v1608, (volatile signed __int32 **)v681);
      v683 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v682 + 0x10LL);
      v684 = sub_142F63590(&v1475, (__int64 *)a2);
      v685 = sub_1455C7320(v1607, (volatile signed __int32 **)v684);
      v683(v682, v685, a3, a4);
      sub_142F709D0(v1607);
      result = (__int64)sub_142F709D0(v1608);
      break;
    case 0xA7:
      v686 = sub_142F63590(&v1476, a1);
      v687 = sub_1455C7610(v1610, (volatile signed __int32 **)v686);
      v688 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v687 + 0x10LL);
      v689 = sub_142F63590(&v1477, (__int64 *)a2);
      v690 = sub_1455C7610(v1609, (volatile signed __int32 **)v689);
      v688(v687, v690, a3, a4);
      sub_142F709D0(v1609);
      result = (__int64)sub_142F709D0(v1610);
      break;
    case 0xA8:
      v691 = sub_142F63590(&v1478, a1);
      v692 = sub_1455C7970(v1612, (volatile signed __int32 **)v691);
      v693 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v692 + 0x10LL);
      v694 = sub_142F63590(&v1479, (__int64 *)a2);
      v695 = sub_1455C7970(v1611, (volatile signed __int32 **)v694);
      v693(v692, v695, a3, a4);
      sub_142F709D0(v1611);
      result = (__int64)sub_142F709D0(v1612);
      break;
    case 0xA9:
      v696 = sub_142F63590(&v1480, a1);
      v697 = sub_1455C79D0(v1614, (volatile signed __int32 **)v696);
      v698 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v697 + 0x10LL);
      v699 = sub_142F63590(&v1481, (__int64 *)a2);
      v700 = sub_1455C79D0(v1613, (volatile signed __int32 **)v699);
      v698(v697, v700, a3, a4);
      sub_142F709D0(v1613);
      result = (__int64)sub_142F709D0(v1614);
      break;
    case 0xAA:
      v701 = sub_142F63590(&v1482, a1);
      v702 = sub_1455C6130(v1616, (volatile signed __int32 **)v701);
      v703 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v702 + 0x10LL);
      v704 = sub_142F63590(&v1483, (__int64 *)a2);
      v705 = sub_1455C6130(v1615, (volatile signed __int32 **)v704);
      v703(v702, v705, a3, a4);
      sub_142F709D0(v1615);
      result = (__int64)sub_142F709D0(v1616);
      break;
    case 0xAB:
      v706 = sub_142F63590(&v1484, a1);
      v707 = sub_1455C60D0(v1618, (volatile signed __int32 **)v706);
      v708 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v707 + 0x10LL);
      v709 = sub_142F63590(&v1485, (__int64 *)a2);
      v710 = sub_1455C60D0(v1617, (volatile signed __int32 **)v709);
      v708(v707, v710, a3, a4);
      sub_142F709D0(v1617);
      result = (__int64)sub_142F709D0(v1618);
      break;
    case 0xAC:
      v711 = sub_142F63590(&v1486, a1);
      v712 = sub_1455C63D0(v1620, (volatile signed __int32 **)v711);
      v713 = *(void (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))(*v712 + 0x10LL);
      v714 = sub_142F63590(&v1487, (__int64 *)a2);
      v715 = sub_1455C63D0(v1619, (volatile signed __int32 **)v714);
      v713(v712, v715, a3, a4);
      sub_142F709D0(v1619);
      result = (__int64)sub_142F709D0(v1620);
      break;
    default:
      return result;
  }
  return result;
}

// --- End Function: sub_142F8F080 (0x142F8F080) ---

// --- Function: sub_142FEFD50 (0x142FEFD50) ---
__int64 __fastcall sub_142FEFD50(volatile signed __int32 *a1)
{
  __int64 v1; // xmm0_8
  __int64 result; // rax
  _QWORD *v4; // rdi
  const void *v5; // rcx
  const void *v6; // rcx
  _QWORD *v7; // rcx
  const void *v8; // rcx
  const void *v9; // rcx
  _QWORD *v10; // rcx
  const void *v11; // rcx
  __int64 v12; // rdx

  result = (unsigned int)_InterlockedExchangeAdd(a1 + 7, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    switch ( *((_BYTE *)a1 + 0x18) )
    {
      case 6:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_4;
        break;
      case 0xA:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v5 = (const void *)v4[0xC];
        if ( v5 )
          sub_147605980(v5);
        sub_140370D10(v4 + 0xA);
        v4[5] = &off_1481A0DB8;
        goto LABEL_65;
      case 0xE:
      case 0x60:
      case 0x7C:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x13:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x17:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_4:
        sub_140370D10(v4 + 1);
        goto LABEL_65;
      case 0x18:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_141976650(v4 + 8);
        goto LABEL_65;
      case 0x1A:
      case 0x82:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x1B:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x1C:
      case 0x83:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x1D:
      case 0x27:
      case 0x28:
      case 0x53:
      case 0x6D:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x21:
      case 0x22:
      case 0x24:
      case 0x25:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_20;
        break;
      case 0x23:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_20:
        sub_141976650(*(_QWORD **)a1);
        goto LABEL_65;
      case 0x2B:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x2C:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x2D:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x2E:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v7 = (_QWORD *)v4[1];
        if ( !v7 )
          goto LABEL_65;
        if ( ((v4[3] - (_QWORD)v7) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
          goto LABEL_31;
        if ( (unsigned __int64)v7 - v7[0xFFFFFFFF] - 8 > 0x1F )
LABEL_49:
          invalid_parameter_noinfo_noreturn();
        v7 = (_QWORD *)v7[0xFFFFFFFF];
LABEL_31:
        sub_1402A3D30(v7);
        v4[1] = 0;
        v4[2] = 0;
        v4[3] = 0;
LABEL_65:
        v6 = v4;
LABEL_66:
        sub_1402A3D30(v6);
        break;
      case 0x2F:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x46:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x4C:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x4E:
      case 0x6E:
      case 0x6F:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x54:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v8 = (const void *)v4[5];
        if ( v8 )
          sub_147605980(v8);
        v9 = (const void *)v4[2];
        if ( v9 )
          goto LABEL_40;
        goto LABEL_65;
      case 0x55:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x57:
        v4 = *(_QWORD **)a1;
        if ( *(_QWORD *)a1 )
          goto LABEL_43;
        break;
      case 0x58:
        v10 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        if ( ((*((_QWORD *)a1 + 2) - (_QWORD)v10) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
          goto LABEL_48;
        if ( (unsigned __int64)v10 - v10[0xFFFFFFFF] - 8 > 0x1F )
          goto LABEL_49;
        v10 = (_QWORD *)v10[0xFFFFFFFF];
LABEL_48:
        sub_1402A3D30(v10);
        *(_QWORD *)a1 = 0;
        *((_QWORD *)a1 + 1) = 0;
        *((_QWORD *)a1 + 2) = 0;
        break;
      case 0x5C:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_140370D10(v4 + 5);
        goto LABEL_65;
      case 0x5F:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
LABEL_43:
        sub_140370D10(v4 + 6);
        goto LABEL_65;
      case 0x63:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x65:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x6A:
      case 0x71:
      case 0x74:
      case 0x7A:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x7E:
        v6 = *(const void **)a1;
        goto LABEL_66;
      case 0x7F:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        v11 = (const void *)v4[0xF];
        if ( v11 )
          sub_147605980(v11);
        v9 = (const void *)v4[0xC];
        if ( v9 )
LABEL_40:
          sub_147605980(v9);
        goto LABEL_65;
      case 0x88:
        v4 = *(_QWORD **)a1;
        if ( !*(_QWORD *)a1 )
          break;
        sub_145EEE160(*(_QWORD **)a1);
        goto LABEL_65;
      default:
        break;
    }
    v12 = *((_QWORD *)a1 + 4);
    if ( (unsigned __int64)a1 < *(_QWORD *)v12 || (unsigned __int64)a1 >= *(_QWORD *)(v12 + 0x28) + *(_QWORD *)v12 )
      __debugbreak();
    *(__m256 *)a1 = ymmword_1486BF420;
    *((_QWORD *)a1 + 4) = v1;
    __asm { vzeroupper }
    return sub_1403E35D0((volatile signed __int64 *)(v12 + 0x50), a1);
  }
  return result;
}

// --- End Function: sub_142FEFD50 (0x142FEFD50) ---

// --- Function: sub_1450FE0F0 (0x1450FE0F0) ---
__int64 __fastcall sub_1450FE0F0(__int64 a1, _QWORD **a2, __int64 **a3)
{
  __int64 v3; // rsi
  int v6; // ebp
  int v7; // r12d
  __int64 v8; // rdi
  unsigned __int64 *v9; // rbx
  __int64 *v10; // r8
  __int64 *v11; // rax
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rcx
  bool v14; // cf
  unsigned __int64 v15; // rdx
  bool v16; // cf
  volatile signed __int32 *v17; // rbx
  volatile signed __int32 *v18; // rbx
  __int64 v20; // [rsp+20h] [rbp-58h] BYREF
  volatile signed __int32 *v21; // [rsp+28h] [rbp-50h]
  __int128 v22; // [rsp+30h] [rbp-48h] BYREF

  v3 = 0;
  v6 = 0;
  v7 = sub_14041CB30(*a2);
  if ( v7 > 0 )
  {
    v8 = 1;
    do
    {
      sub_143453840(*a2, &v20, v6);
      if ( (unsigned int)sub_14345A2D0(v20) == 1 )
      {
        v9 = (unsigned __int64 *)sub_14053B590(v20, &v22);
        v10 = *a3;
        v11 = (__int64 *)(*a3)[1];
        if ( !*((_BYTE *)v11 + 0x19) )
        {
          v12 = *v9;
          do
          {
            v13 = v11[4];
            v14 = v13 < v12;
            if ( v13 == v12 )
              v14 = v11[5] < v9[1];
            if ( v14 )
            {
              v11 = (__int64 *)v11[2];
            }
            else
            {
              v10 = v11;
              v11 = (__int64 *)*v11;
            }
          }
          while ( !*((_BYTE *)v11 + 0x19) );
        }
        if ( !*((_BYTE *)v10 + 0x19) )
        {
          v15 = v10[4];
          v16 = *v9 < v15;
          if ( *v9 == v15 )
            v16 = v9[1] < v10[5];
          if ( !v16 && v10 != *a3 )
            v3 |= v8;
        }
      }
      v17 = v21;
      if ( v21 )
      {
        if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v17)(v17);
          if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v17 + 8LL))(v17);
        }
      }
      ++v6;
      v8 = __ROL8__(v8, 1);
    }
    while ( v6 < v7 );
  }
  v18 = (volatile signed __int32 *)a2[1];
  if ( v18 )
  {
    if ( _InterlockedExchangeAdd(v18 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
      if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8LL))(v18);
    }
  }
  return v3;
}

// --- End Function: sub_1450FE0F0 (0x1450FE0F0) ---

// --- Function: sub_1451198C0 (0x1451198C0) ---
__int64 __fastcall sub_1451198C0(__int64 a1, _QWORD *a2, __int64 a3)
{
  int v6; // r14d
  unsigned int i; // r12d
  __int64 v8; // rax
  char *String1_2; // rcx
  const void *v10; // rdi
  size_t n0x1FF_1; // rbx
  char *String1_1; // rax
  bool v13; // zf
  __int64 v14; // rax
  int v15; // eax
  int v16; // r15d
  int v17; // r14d
  __int64 v18; // rax
  char *String1_3; // rcx
  const void *v20; // rdi
  size_t n0x1FF_4; // rbx
  char *String1_5; // rax
  __int64 v23; // rax
  int v24; // eax
  _BYTE *v25; // rdi
  size_t n0x1FF_7; // rbx
  _BYTE *v27; // rax
  __int64 v28; // rax
  char *v29; // rdx
  size_t n0x1FF_12; // rcx
  const void *v31; // rdi
  size_t n0x1FF_10; // rbx
  _BYTE *v33; // rax
  __int128 v34; // xmm0
  _BYTE *Src_1; // rdi
  unsigned __int64 v36; // rbx
  void *v37; // rax
  unsigned __int64 allocSize; // rbx
  __int64 v39; // rax
  const char *p_Choice_text; // r9
  __int64 *v41; // [rsp+30h] [rbp-D0h] BYREF
  int v42; // [rsp+38h] [rbp-C8h]
  unsigned int v43; // [rsp+3Ch] [rbp-C4h]
  __int64 *v44; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v45; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v46; // [rsp+50h] [rbp-B0h] BYREF
  unsigned int v47; // [rsp+58h] [rbp-A8h] BYREF
  const void *v48; // [rsp+60h] [rbp-A0h]
  unsigned __int64 allocSize_1; // [rsp+68h] [rbp-98h]
  __int128 v50; // [rsp+70h] [rbp-90h]
  __int64 v51; // [rsp+80h] [rbp-80h] BYREF
  size_t n0x1FF_5; // [rsp+90h] [rbp-70h]
  __int64 n0x1FF_3; // [rsp+98h] [rbp-68h]
  char *String1_4; // [rsp+A0h] [rbp-60h]
  _BYTE v55[520]; // [rsp+A8h] [rbp-58h] BYREF
  size_t n0x1FF_11; // [rsp+2B0h] [rbp+1B0h]
  __int64 n0x1FF_9; // [rsp+2B8h] [rbp+1B8h]
  void *v58; // [rsp+2C0h] [rbp+1C0h]
  _BYTE v59[520]; // [rsp+2C8h] [rbp+1C8h] BYREF
  size_t n0x1FF_2; // [rsp+4D0h] [rbp+3D0h]
  __int64 n0x1FF; // [rsp+4D8h] [rbp+3D8h]
  char *String1; // [rsp+4E0h] [rbp+3E0h]
  _BYTE v63[520]; // [rsp+4E8h] [rbp+3E8h] BYREF
  size_t n0x1FF_8; // [rsp+6F0h] [rbp+5F0h]
  __int64 n0x1FF_6; // [rsp+6F8h] [rbp+5F8h]
  void *v66; // [rsp+700h] [rbp+600h]
  _BYTE v67[520]; // [rsp+708h] [rbp+608h] BYREF
  __int64 v68; // [rsp+910h] [rbp+810h] BYREF
  __int64 n0x1FF_13; // [rsp+918h] [rbp+818h]
  void *Src; // [rsp+920h] [rbp+820h]
  _BYTE v71[520]; // [rsp+928h] [rbp+828h] BYREF

  if ( (unsigned int)sub_14053C290(a1, a2, a3) != 1 )
    return 0;
  (*(void (__fastcall **)(_QWORD, __int64 *, const char *))(*(_QWORD *)*a2 + 0x168LL))(*a2, &v46, "Variables");
  if ( v46 )
  {
    v42 = (*(__int64 (**)(void))(*(_QWORD *)v46 + 0x158LL))();
    v43 = 0;
    v6 = v42;
    for ( i = 0; (int)i < v6; v43 = i )
    {
      (*(void (__fastcall **)(__int64, __int64 **, _QWORD))(*(_QWORD *)v46 + 0x160LL))(v46, &v44, i);
      v8 = (*(__int64 (__fastcall **)(__int64 *))(*v44 + 0x38))(v44);
      String1_2 = v63;
      v63[0] = 0;
      String1 = v63;
      v10 = (const void *)v8;
      n0x1FF_2 = 0;
      n0x1FF = 0x1FF;
      if ( v8 )
      {
        n0x1FF_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++n0x1FF_1;
        while ( *(_BYTE *)(v8 + n0x1FF_1) );
        if ( n0x1FF_1 )
        {
          String1_1 = v63;
          if ( n0x1FF_1 + 1 > 0x200 )
          {
            String1_1 = (char *)allocWithProfilerInfo(n0x1FF_1 + 1, 0);
            qword_149B3AB68 += n0x1FF_1 + 1;
            n0x1FF = n0x1FF_1;
          }
          String1 = String1_1;
          n0x1FF_2 = n0x1FF_1;
          String1_1[n0x1FF_1] = 0;
          memcpy(String1, v10, n0x1FF_1);
          String1_2 = String1;
        }
      }
      v13 = _stricmp(String1_2, "Variable") == 0;
      v14 = *v44;
      if ( v13 )
      {
        (*(void (__fastcall **)(__int64 *, __int64 *, const char *))(v14 + 0x168))(v44, &v45, "TextFields");
        if ( v45 )
        {
          v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 0x158LL))(v45);
          v17 = 0;
          if ( v16 > 0 )
          {
            do
            {
              (*(void (__fastcall **)(__int64, __int64 **, _QWORD))(*(_QWORD *)v45 + 0x160LL))(
                v45,
                &v41,
                (unsigned int)v17);
              v18 = (*(__int64 (__fastcall **)(__int64 *))(*v41 + 0x38))(v41);
              String1_3 = v55;
              v55[0] = 0;
              String1_4 = v55;
              v20 = (const void *)v18;
              n0x1FF_5 = 0;
              n0x1FF_3 = 0x1FF;
              if ( v18 )
              {
                n0x1FF_4 = 0xFFFFFFFFFFFFFFFFuLL;
                do
                  ++n0x1FF_4;
                while ( *(_BYTE *)(v18 + n0x1FF_4) );
                if ( n0x1FF_4 )
                {
                  String1_5 = v55;
                  if ( n0x1FF_4 + 1 > 0x200 )
                  {
                    String1_5 = (char *)allocWithProfilerInfo(n0x1FF_4 + 1, 0);
                    qword_149B3AB68 += n0x1FF_4 + 1;
                    n0x1FF_3 = n0x1FF_4;
                  }
                  String1_4 = String1_5;
                  n0x1FF_5 = n0x1FF_4;
                  String1_5[n0x1FF_4] = 0;
                  memcpy(String1_4, v20, n0x1FF_4);
                  String1_3 = String1_4;
                }
              }
              v13 = _stricmp(String1_3, "Text") == 0;
              v23 = *v41;
              if ( v13 )
              {
                v25 = (_BYTE *)(*(__int64 (__fastcall **)(__int64 *, const char *))(v23 + 0x110))(v41, "Data");
                v67[0] = 0;
                n0x1FF_8 = 0;
                v66 = v67;
                n0x1FF_6 = 0x1FF;
                if ( v25 )
                {
                  n0x1FF_7 = 0xFFFFFFFFFFFFFFFFuLL;
                  do
                    ++n0x1FF_7;
                  while ( v25[n0x1FF_7] );
                  if ( n0x1FF_7 )
                  {
                    v27 = v67;
                    if ( n0x1FF_7 + 1 > 0x200 )
                    {
                      v27 = (_BYTE *)allocWithProfilerInfo(n0x1FF_7 + 1, 0);
                      qword_149B3AB68 += n0x1FF_7 + 1;
                      n0x1FF_6 = n0x1FF_7;
                    }
                    v66 = v27;
                    n0x1FF_8 = n0x1FF_7;
                    v27[n0x1FF_7] = 0;
                    memcpy(v66, v25, n0x1FF_7);
                  }
                }
                v28 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*v41 + 0x110))(v41, "TaskID");
                v29 = v59;
                v59[0] = 0;
                v58 = v59;
                n0x1FF_12 = 0;
                n0x1FF_11 = 0;
                v31 = (const void *)v28;
                n0x1FF_9 = 0x1FF;
                if ( v28 )
                {
                  n0x1FF_10 = 0xFFFFFFFFFFFFFFFFuLL;
                  do
                    ++n0x1FF_10;
                  while ( *(_BYTE *)(v28 + n0x1FF_10) );
                  if ( n0x1FF_10 )
                  {
                    v33 = v59;
                    if ( n0x1FF_10 + 1 > 0x200 )
                    {
                      v33 = (_BYTE *)allocWithProfilerInfo(n0x1FF_10 + 1, 0);
                      qword_149B3AB68 += n0x1FF_10 + 1;
                      n0x1FF_9 = n0x1FF_10;
                    }
                    v58 = v33;
                    n0x1FF_11 = n0x1FF_10;
                    v33[n0x1FF_10] = 0;
                    memcpy(v58, v31, n0x1FF_10);
                    v29 = (char *)v58;
                    n0x1FF_12 = n0x1FF_11;
                  }
                }
                if ( n0x1FF_8 && n0x1FF_12 )
                {
                  v34 = *(_OWORD *)sub_1402BC380(&v51, v29);
                  v71[0] = 0;
                  Src = v71;
                  v50 = v34;
                  v68 = 0;
                  n0x1FF_13 = 0x1FF;
                  sub_1402A3190((__int64)&v68, "%d", v17);
                  Src_1 = Src;
                  v47 = sub_1402E1FE0((unsigned __int8 *)Src, 0xFFFFFFFF);
                  v48 = 0;
                  allocSize_1 = 0;
                  if ( Src_1 )
                  {
                    v36 = 0xFFFFFFFFFFFFFFFFuLL;
                    do
                      ++v36;
                    while ( Src_1[v36] );
                    v37 = 0;
                    allocSize = v36 + 1;
                    if ( allocSize )
                    {
                      v37 = (void *)allocWithProfilerInfo(allocSize, 0);
                      v48 = v37;
                      allocSize_1 = allocSize;
                    }
                    memcpy(v37, Src_1, allocSize);
                  }
                  v39 = sub_14053ACC0(a1 + 0x60, &v47);
                  *(_OWORD *)v39 = v50;
                  *(_QWORD *)(v39 + 0x10) = 0;
                  if ( v48 )
                    sub_147605980(v48);
                  if ( Src != v71 )
                  {
                    qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_13;
                    sub_147605980(Src);
                  }
                }
                else
                {
                  p_Choice_text = "Linked task";
                  if ( !n0x1FF_8 )
                    p_Choice_text = "Choice text";
                  sub_1405C0E00(
                    4u,
                    2u,
                    "Choice for PlayerChoice Subsumption Task is missing %s - skipping",
                    p_Choice_text);
                }
                if ( v58 != v59 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_9;
                  sub_147605980(v58);
                }
                if ( v66 != v67 )
                {
                  qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_6;
                  sub_147605980(v66);
                }
              }
              else
              {
                v24 = (*(__int64 (**)(void))(v23 + 0x1B0))();
                sub_1405C0E00(
                  4u,
                  2u,
                  "Skipped loading variable for Subsumption task due to having found the tag '%s' at line %d while only t"
                  "he 'Text' tag is expected.",
                  String1_4,
                  v24);
              }
              if ( String1_4 != v55 )
              {
                qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_3;
                sub_147605980(String1_4);
              }
              if ( v41 )
                (*(void (__fastcall **)(__int64 *))(*v41 + 0x28))(v41);
              ++v17;
            }
            while ( v17 < v16 );
            i = v43;
          }
          if ( v45 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v45 + 0x28LL))(v45);
          v6 = v42;
        }
      }
      else
      {
        v15 = (*(__int64 (**)(void))(v14 + 0x1B0))();
        sub_1405C0E00(
          4u,
          2u,
          "Skipped loading variable for Subsumption task due to having found the tag '%s' at line %d while only the 'Vari"
          "able' tag is expected.",
          String1,
          v15);
      }
      if ( String1 != v63 )
      {
        qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
        sub_147605980(String1);
      }
      if ( v44 )
        (*(void (__fastcall **)(__int64 *))(*v44 + 0x28))(v44);
      ++i;
    }
    if ( v46 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v46 + 0x28LL))(v46);
  }
  return 1;
}

// --- End Function: sub_1451198C0 (0x1451198C0) ---

// --- Function: sub_145119FF0 (0x145119FF0) ---
_BOOL8 __fastcall sub_145119FF0(__int64 a1, _QWORD *a2, __int64 a3)
{
  return (unsigned int)sub_14053C290(a1, a2, a3) == 1;
}

// --- End Function: sub_145119FF0 (0x145119FF0) ---

// --- Function: sub_1455C17E0 (0x1455C17E0) ---
_QWORD *__fastcall sub_1455C17E0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB27A8;
  return a1;
}

// --- End Function: sub_1455C17E0 (0x1455C17E0) ---

// --- Function: sub_1455C1850 (0x1455C1850) ---
_QWORD *__fastcall sub_1455C1850(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4710;
  return a1;
}

// --- End Function: sub_1455C1850 (0x1455C1850) ---

// --- Function: sub_1455C18C0 (0x1455C18C0) ---
_QWORD *__fastcall sub_1455C18C0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB30E0;
  return a1;
}

// --- End Function: sub_1455C18C0 (0x1455C18C0) ---

// --- Function: sub_1455C1930 (0x1455C1930) ---
_QWORD *__fastcall sub_1455C1930(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3130;
  return a1;
}

// --- End Function: sub_1455C1930 (0x1455C1930) ---

// --- Function: sub_1455C19A0 (0x1455C19A0) ---
_QWORD *__fastcall sub_1455C19A0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3040;
  return a1;
}

// --- End Function: sub_1455C19A0 (0x1455C19A0) ---

// --- Function: sub_1455C1A10 (0x1455C1A10) ---
_QWORD *__fastcall sub_1455C1A10(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3B08;
  return a1;
}

// --- End Function: sub_1455C1A10 (0x1455C1A10) ---

// --- Function: sub_1455C1A80 (0x1455C1A80) ---
_QWORD *__fastcall sub_1455C1A80(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2668;
  return a1;
}

// --- End Function: sub_1455C1A80 (0x1455C1A80) ---

// --- Function: sub_1455C1AF0 (0x1455C1AF0) ---
_QWORD *__fastcall sub_1455C1AF0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2AA0;
  return a1;
}

// --- End Function: sub_1455C1AF0 (0x1455C1AF0) ---

// --- Function: sub_1455C1B60 (0x1455C1B60) ---
_QWORD *__fastcall sub_1455C1B60(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2AF0;
  return a1;
}

// --- End Function: sub_1455C1B60 (0x1455C1B60) ---

// --- Function: sub_1455C1BD0 (0x1455C1BD0) ---
_QWORD *__fastcall sub_1455C1BD0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2B40;
  return a1;
}

// --- End Function: sub_1455C1BD0 (0x1455C1BD0) ---

// --- Function: sub_1455C1C40 (0x1455C1C40) ---
_QWORD *__fastcall sub_1455C1C40(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2B90;
  return a1;
}

// --- End Function: sub_1455C1C40 (0x1455C1C40) ---

// --- Function: sub_1455C1CB0 (0x1455C1CB0) ---
_QWORD *__fastcall sub_1455C1CB0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2BE0;
  return a1;
}

// --- End Function: sub_1455C1CB0 (0x1455C1CB0) ---

// --- Function: sub_1455C1D20 (0x1455C1D20) ---
_QWORD *__fastcall sub_1455C1D20(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2C30;
  return a1;
}

// --- End Function: sub_1455C1D20 (0x1455C1D20) ---

// --- Function: sub_1455C1D90 (0x1455C1D90) ---
_QWORD *__fastcall sub_1455C1D90(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2C80;
  return a1;
}

// --- End Function: sub_1455C1D90 (0x1455C1D90) ---

// --- Function: sub_1455C1E00 (0x1455C1E00) ---
_QWORD *__fastcall sub_1455C1E00(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB26E0;
  return a1;
}

// --- End Function: sub_1455C1E00 (0x1455C1E00) ---

// --- Function: sub_1455C1E70 (0x1455C1E70) ---
_QWORD *__fastcall sub_1455C1E70(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2758;
  return a1;
}

// --- End Function: sub_1455C1E70 (0x1455C1E70) ---

// --- Function: sub_1455C1EE0 (0x1455C1EE0) ---
_QWORD *__fastcall sub_1455C1EE0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB27F8;
  return a1;
}

// --- End Function: sub_1455C1EE0 (0x1455C1EE0) ---

// --- Function: sub_1455C1F50 (0x1455C1F50) ---
_QWORD *__fastcall sub_1455C1F50(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2870;
  return a1;
}

// --- End Function: sub_1455C1F50 (0x1455C1F50) ---

// --- Function: sub_1455C1FC0 (0x1455C1FC0) ---
_QWORD *__fastcall sub_1455C1FC0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3D38;
  return a1;
}

// --- End Function: sub_1455C1FC0 (0x1455C1FC0) ---

// --- Function: sub_1455C2030 (0x1455C2030) ---
_QWORD *__fastcall sub_1455C2030(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2960;
  return a1;
}

// --- End Function: sub_1455C2030 (0x1455C2030) ---

// --- Function: sub_1455C20A0 (0x1455C20A0) ---
_QWORD *__fastcall sub_1455C20A0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2988;
  return a1;
}

// --- End Function: sub_1455C20A0 (0x1455C20A0) ---

// --- Function: sub_1455C2110 (0x1455C2110) ---
_QWORD *__fastcall sub_1455C2110(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB29D8;
  return a1;
}

// --- End Function: sub_1455C2110 (0x1455C2110) ---

// --- Function: sub_1455C2180 (0x1455C2180) ---
_QWORD *__fastcall sub_1455C2180(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2A28;
  return a1;
}

// --- End Function: sub_1455C2180 (0x1455C2180) ---

// --- Function: sub_1455C21F0 (0x1455C21F0) ---
_QWORD *__fastcall sub_1455C21F0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2CF8;
  return a1;
}

// --- End Function: sub_1455C21F0 (0x1455C21F0) ---

// --- Function: sub_1455C2260 (0x1455C2260) ---
_QWORD *__fastcall sub_1455C2260(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2D48;
  return a1;
}

// --- End Function: sub_1455C2260 (0x1455C2260) ---

// --- Function: sub_1455C22D0 (0x1455C22D0) ---
_QWORD *__fastcall sub_1455C22D0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148924850;
  return a1;
}

// --- End Function: sub_1455C22D0 (0x1455C22D0) ---

// --- Function: sub_1455C2340 (0x1455C2340) ---
_QWORD *__fastcall sub_1455C2340(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2DC0;
  return a1;
}

// --- End Function: sub_1455C2340 (0x1455C2340) ---

// --- Function: sub_1455C23B0 (0x1455C23B0) ---
_QWORD *__fastcall sub_1455C23B0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2E38;
  return a1;
}

// --- End Function: sub_1455C23B0 (0x1455C23B0) ---

// --- Function: sub_1455C2420 (0x1455C2420) ---
_QWORD *__fastcall sub_1455C2420(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2E60;
  return a1;
}

// --- End Function: sub_1455C2420 (0x1455C2420) ---

// --- Function: sub_1455C2490 (0x1455C2490) ---
_QWORD *__fastcall sub_1455C2490(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2E88;
  return a1;
}

// --- End Function: sub_1455C2490 (0x1455C2490) ---

// --- Function: sub_1455C2500 (0x1455C2500) ---
_QWORD *__fastcall sub_1455C2500(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = off_14897FFC0;
  return a1;
}

// --- End Function: sub_1455C2500 (0x1455C2500) ---

// --- Function: sub_1455C2570 (0x1455C2570) ---
_QWORD *__fastcall sub_1455C2570(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = off_148A972E0;
  return a1;
}

// --- End Function: sub_1455C2570 (0x1455C2570) ---

// --- Function: sub_1455C25E0 (0x1455C25E0) ---
_QWORD *__fastcall sub_1455C25E0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB2FA0;
  return a1;
}

// --- End Function: sub_1455C25E0 (0x1455C25E0) ---

// --- Function: sub_1455C2650 (0x1455C2650) ---
_QWORD *__fastcall sub_1455C2650(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3270;
  return a1;
}

// --- End Function: sub_1455C2650 (0x1455C2650) ---

// --- Function: sub_1455C26C0 (0x1455C26C0) ---
_QWORD *__fastcall sub_1455C26C0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB34A0;
  return a1;
}

// --- End Function: sub_1455C26C0 (0x1455C26C0) ---

// --- Function: sub_1455C2730 (0x1455C2730) ---
_QWORD *__fastcall sub_1455C2730(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB34F0;
  return a1;
}

// --- End Function: sub_1455C2730 (0x1455C2730) ---

// --- Function: sub_1455C27A0 (0x1455C27A0) ---
_QWORD *__fastcall sub_1455C27A0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3590;
  return a1;
}

// --- End Function: sub_1455C27A0 (0x1455C27A0) ---

// --- Function: sub_1455C2810 (0x1455C2810) ---
_QWORD *__fastcall sub_1455C2810(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = off_148A56E90;
  return a1;
}

// --- End Function: sub_1455C2810 (0x1455C2810) ---

// --- Function: sub_1455C2880 (0x1455C2880) ---
_QWORD *__fastcall sub_1455C2880(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4648;
  return a1;
}

// --- End Function: sub_1455C2880 (0x1455C2880) ---

// --- Function: sub_1455C28F0 (0x1455C28F0) ---
_QWORD *__fastcall sub_1455C28F0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3748;
  return a1;
}

// --- End Function: sub_1455C28F0 (0x1455C28F0) ---

// --- Function: sub_1455C2960 (0x1455C2960) ---
_QWORD *__fastcall sub_1455C2960(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB37E8;
  return a1;
}

// --- End Function: sub_1455C2960 (0x1455C2960) ---

// --- Function: sub_1455C29D0 (0x1455C29D0) ---
_QWORD *__fastcall sub_1455C29D0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3CE8;
  return a1;
}

// --- End Function: sub_1455C29D0 (0x1455C29D0) ---

// --- Function: sub_1455C2A40 (0x1455C2A40) ---
_QWORD *__fastcall sub_1455C2A40(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = off_148A22E80;
  return a1;
}

// --- End Function: sub_1455C2A40 (0x1455C2A40) ---

// --- Function: sub_1455C2AB0 (0x1455C2AB0) ---
_QWORD *__fastcall sub_1455C2AB0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = off_148A22EA8;
  return a1;
}

// --- End Function: sub_1455C2AB0 (0x1455C2AB0) ---

// --- Function: sub_1455C2B20 (0x1455C2B20) ---
_QWORD *__fastcall sub_1455C2B20(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB38B0;
  return a1;
}

// --- End Function: sub_1455C2B20 (0x1455C2B20) ---

// --- Function: sub_1455C2B90 (0x1455C2B90) ---
_QWORD *__fastcall sub_1455C2B90(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3950;
  return a1;
}

// --- End Function: sub_1455C2B90 (0x1455C2B90) ---

// --- Function: sub_1455C2C00 (0x1455C2C00) ---
_QWORD *__fastcall sub_1455C2C00(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4490;
  return a1;
}

// --- End Function: sub_1455C2C00 (0x1455C2C00) ---

// --- Function: sub_1455C2C70 (0x1455C2C70) ---
_QWORD *__fastcall sub_1455C2C70(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB39C8;
  return a1;
}

// --- End Function: sub_1455C2C70 (0x1455C2C70) ---

// --- Function: sub_1455C2CE0 (0x1455C2CE0) ---
_QWORD *__fastcall sub_1455C2CE0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3AB8;
  return a1;
}

// --- End Function: sub_1455C2CE0 (0x1455C2CE0) ---

// --- Function: sub_1455C2D50 (0x1455C2D50) ---
_QWORD *__fastcall sub_1455C2D50(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3608;
  return a1;
}

// --- End Function: sub_1455C2D50 (0x1455C2D50) ---

// --- Function: sub_1455C2DC0 (0x1455C2DC0) ---
_QWORD *__fastcall sub_1455C2DC0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3E28;
  return a1;
}

// --- End Function: sub_1455C2DC0 (0x1455C2DC0) ---

// --- Function: sub_1455C2E30 (0x1455C2E30) ---
_QWORD *__fastcall sub_1455C2E30(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3BA8;
  return a1;
}

// --- End Function: sub_1455C2E30 (0x1455C2E30) ---

// --- Function: sub_1455C2EA0 (0x1455C2EA0) ---
_QWORD *__fastcall sub_1455C2EA0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4170;
  return a1;
}

// --- End Function: sub_1455C2EA0 (0x1455C2EA0) ---

// --- Function: sub_1455C2F10 (0x1455C2F10) ---
_QWORD *__fastcall sub_1455C2F10(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3E78;
  return a1;
}

// --- End Function: sub_1455C2F10 (0x1455C2F10) ---

// --- Function: sub_1455C2F80 (0x1455C2F80) ---
_QWORD *__fastcall sub_1455C2F80(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB42B0;
  return a1;
}

// --- End Function: sub_1455C2F80 (0x1455C2F80) ---

// --- Function: sub_1455C2FF0 (0x1455C2FF0) ---
_QWORD *__fastcall sub_1455C2FF0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4300;
  return a1;
}

// --- End Function: sub_1455C2FF0 (0x1455C2FF0) ---

// --- Function: sub_1455C3060 (0x1455C3060) ---
_QWORD *__fastcall sub_1455C3060(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4378;
  return a1;
}

// --- End Function: sub_1455C3060 (0x1455C3060) ---

// --- Function: sub_1455C30D0 (0x1455C30D0) ---
_QWORD *__fastcall sub_1455C30D0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB43C8;
  return a1;
}

// --- End Function: sub_1455C30D0 (0x1455C30D0) ---

// --- Function: sub_1455C3140 (0x1455C3140) ---
_QWORD *__fastcall sub_1455C3140(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB45F8;
  return a1;
}

// --- End Function: sub_1455C3140 (0x1455C3140) ---

// --- Function: sub_1455C31B0 (0x1455C31B0) ---
_QWORD *__fastcall sub_1455C31B0(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4760;
  return a1;
}

// --- End Function: sub_1455C31B0 (0x1455C31B0) ---

// --- Function: sub_1455C3220 (0x1455C3220) ---
_QWORD *__fastcall sub_1455C3220(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3090;
  return a1;
}

// --- End Function: sub_1455C3220 (0x1455C3220) ---

// --- Function: sub_1455C3290 (0x1455C3290) ---
_QWORD *__fastcall sub_1455C3290(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB4210;
  return a1;
}

// --- End Function: sub_1455C3290 (0x1455C3290) ---

// --- Function: sub_1455C3300 (0x1455C3300) ---
_QWORD *__fastcall sub_1455C3300(_QWORD *a1, _QWORD *a2)
{
  *a1 = &off_148746580;
  a1[1] = *a2;
  if ( a1[1] )
    InterlockedIncrement_w_17(a1[1]);
  *a1 = &off_148AB3C48;
  return a1;
}

// --- End Function: sub_1455C3300 (0x1455C3300) ---

// --- Function: sub_1455C3890 (0x1455C3890) ---
_QWORD *__fastcall sub_1455C3890(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1AF0(a1, a2);
  *a1 = off_148AB2AC8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3890 (0x1455C3890) ---

// --- Function: sub_1455C38F0 (0x1455C38F0) ---
_QWORD *__fastcall sub_1455C38F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1B60(a1, a2);
  *a1 = off_148AB2B18;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C38F0 (0x1455C38F0) ---

// --- Function: sub_1455C3950 (0x1455C3950) ---
_QWORD *__fastcall sub_1455C3950(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1C40(a1, a2);
  *a1 = off_148AB2BB8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3950 (0x1455C3950) ---

// --- Function: sub_1455C39B0 (0x1455C39B0) ---
_QWORD *__fastcall sub_1455C39B0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1CB0(a1, a2);
  *a1 = off_148AB2C08;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C39B0 (0x1455C39B0) ---

// --- Function: sub_1455C3A10 (0x1455C3A10) ---
_QWORD *__fastcall sub_1455C3A10(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1D90(a1, a2);
  *a1 = off_148AB2CA8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3A10 (0x1455C3A10) ---

// --- Function: sub_1455C3A70 (0x1455C3A70) ---
_QWORD *__fastcall sub_1455C3A70(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1D20(a1, a2);
  *a1 = off_148AB2C58;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3A70 (0x1455C3A70) ---

// --- Function: sub_1455C3AD0 (0x1455C3AD0) ---
_QWORD *__fastcall sub_1455C3AD0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB2B68;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3AD0 (0x1455C3AD0) ---

// --- Function: sub_1455C3B30 (0x1455C3B30) ---
_QWORD *__fastcall sub_1455C3B30(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB2690;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3B30 (0x1455C3B30) ---

// --- Function: sub_1455C3B90 (0x1455C3B90) ---
_QWORD *__fastcall sub_1455C3B90(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB26B8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3B90 (0x1455C3B90) ---

// --- Function: sub_1455C3BF0 (0x1455C3BF0) ---
_QWORD *__fastcall sub_1455C3BF0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E00(a1, a2);
  *a1 = off_148AB2708;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3BF0 (0x1455C3BF0) ---

// --- Function: sub_1455C3C50 (0x1455C3C50) ---
_QWORD *__fastcall sub_1455C3C50(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB2730;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3C50 (0x1455C3C50) ---

// --- Function: sub_1455C3CB0 (0x1455C3CB0) ---
_QWORD *__fastcall sub_1455C3CB0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB2780;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3CB0 (0x1455C3CB0) ---

// --- Function: sub_1455C3D10 (0x1455C3D10) ---
_QWORD *__fastcall sub_1455C3D10(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB27D0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3D10 (0x1455C3D10) ---

// --- Function: sub_1455C3D70 (0x1455C3D70) ---
_QWORD *__fastcall sub_1455C3D70(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1EE0(a1, a2);
  *a1 = off_148AB2820;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3D70 (0x1455C3D70) ---

// --- Function: sub_1455C3DD0 (0x1455C3DD0) ---
_QWORD *__fastcall sub_1455C3DD0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1EE0(a1, a2);
  *a1 = off_148AB2848;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3DD0 (0x1455C3DD0) ---

// --- Function: sub_1455C3E30 (0x1455C3E30) ---
_QWORD *__fastcall sub_1455C3E30(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1F50(a1, a2);
  *a1 = off_148AB2898;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3E30 (0x1455C3E30) ---

// --- Function: sub_1455C3E90 (0x1455C3E90) ---
_QWORD *__fastcall sub_1455C3E90(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1EE0(a1, a2);
  *a1 = off_148AB28C0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3E90 (0x1455C3E90) ---

// --- Function: sub_1455C3EF0 (0x1455C3EF0) ---
_QWORD *__fastcall sub_1455C3EF0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1EE0(a1, a2);
  *a1 = off_148AB28E8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3EF0 (0x1455C3EF0) ---

// --- Function: sub_1455C3F50 (0x1455C3F50) ---
_QWORD *__fastcall sub_1455C3F50(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3DD8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3F50 (0x1455C3F50) ---

// --- Function: sub_1455C3FB0 (0x1455C3FB0) ---
_QWORD *__fastcall sub_1455C3FB0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3E00;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C3FB0 (0x1455C3FB0) ---

// --- Function: sub_1455C4010 (0x1455C4010) ---
_QWORD *__fastcall sub_1455C4010(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB2910;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4010 (0x1455C4010) ---

// --- Function: sub_1455C4070 (0x1455C4070) ---
_QWORD *__fastcall sub_1455C4070(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB4148;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4070 (0x1455C4070) ---

// --- Function: sub_1455C40D0 (0x1455C40D0) ---
_QWORD *__fastcall sub_1455C40D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1FC0(a1, a2);
  *a1 = off_148AB40F8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C40D0 (0x1455C40D0) ---

// --- Function: sub_1455C4130 (0x1455C4130) ---
_QWORD *__fastcall sub_1455C4130(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1FC0(a1, a2);
  *a1 = off_148AB4120;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4130 (0x1455C4130) ---

// --- Function: sub_1455C41D0 (0x1455C41D0) ---
_QWORD *__fastcall sub_1455C41D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB2938;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C41D0 (0x1455C41D0) ---

// --- Function: sub_1455C4230 (0x1455C4230) ---
_QWORD *__fastcall sub_1455C4230(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3A68;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4230 (0x1455C4230) ---

// --- Function: sub_1455C4290 (0x1455C4290) ---
_QWORD *__fastcall sub_1455C4290(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3A90;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4290 (0x1455C4290) ---

// --- Function: sub_1455C4410 (0x1455C4410) ---
_QWORD *__fastcall sub_1455C4410(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2030(a1, a2);
  *a1 = &off_148AB2960;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4410 (0x1455C4410) ---

// --- Function: sub_1455C4470 (0x1455C4470) ---
_QWORD *__fastcall sub_1455C4470(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C20A0(a1, a2);
  *a1 = off_148AB29B0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4470 (0x1455C4470) ---

// --- Function: sub_1455C44D0 (0x1455C44D0) ---
_QWORD *__fastcall sub_1455C44D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2110(a1, a2);
  *a1 = off_148AB2A00;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C44D0 (0x1455C44D0) ---

// --- Function: sub_1455C4530 (0x1455C4530) ---
_QWORD *__fastcall sub_1455C4530(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2DC0(a1, a2);
  *a1 = off_148AB3EC8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4530 (0x1455C4530) ---

// --- Function: sub_1455C4590 (0x1455C4590) ---
_QWORD *__fastcall sub_1455C4590(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2180(a1, a2);
  *a1 = off_148AB2A50;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4590 (0x1455C4590) ---

// --- Function: sub_1455C4680 (0x1455C4680) ---
_QWORD *__fastcall sub_1455C4680(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB2A78;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4680 (0x1455C4680) ---

// --- Function: sub_1455C46E0 (0x1455C46E0) ---
_QWORD *__fastcall sub_1455C46E0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C21F0(a1, a2);
  *a1 = &off_148AB2CF8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C46E0 (0x1455C46E0) ---

// --- Function: sub_1455C4740 (0x1455C4740) ---
_QWORD *__fastcall sub_1455C4740(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB2D20;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4740 (0x1455C4740) ---

// --- Function: sub_1455C47A0 (0x1455C47A0) ---
_QWORD *__fastcall sub_1455C47A0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB2D70;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C47A0 (0x1455C47A0) ---

// --- Function: sub_1455C4800 (0x1455C4800) ---
_QWORD *__fastcall sub_1455C4800(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB3450;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4800 (0x1455C4800) ---

// --- Function: sub_1455C4860 (0x1455C4860) ---
_QWORD *__fastcall sub_1455C4860(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C22D0(a1, a2);
  *a1 = off_148AB2D98;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4860 (0x1455C4860) ---

// --- Function: sub_1455C48C0 (0x1455C48C0) ---
_QWORD *__fastcall sub_1455C48C0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB4558;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C48C0 (0x1455C48C0) ---

// --- Function: sub_1455C4920 (0x1455C4920) ---
_QWORD *__fastcall sub_1455C4920(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2340(a1, a2);
  *a1 = off_148AB2DE8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4920 (0x1455C4920) ---

// --- Function: sub_1455C4980 (0x1455C4980) ---
_QWORD *__fastcall sub_1455C4980(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C23B0(a1, a2);
  *a1 = &off_148AB2E38;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4980 (0x1455C4980) ---

// --- Function: sub_1455C49E0 (0x1455C49E0) ---
_QWORD *__fastcall sub_1455C49E0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C31B0(a1, a2);
  *a1 = off_148AB4788;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C49E0 (0x1455C49E0) ---

// --- Function: sub_1455C4A40 (0x1455C4A40) ---
_QWORD *__fastcall sub_1455C4A40(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2420(a1, a2);
  *a1 = &off_148AB2E60;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4A40 (0x1455C4A40) ---

// --- Function: sub_1455C4AA0 (0x1455C4AA0) ---
_QWORD *__fastcall sub_1455C4AA0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2490(a1, a2);
  *a1 = &off_148AB2E88;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4AA0 (0x1455C4AA0) ---

// --- Function: sub_1455C4B00 (0x1455C4B00) ---
_QWORD *__fastcall sub_1455C4B00(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2DC0(a1, a2);
  *a1 = off_148AB3EF0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4B00 (0x1455C4B00) ---

// --- Function: sub_1455C4B60 (0x1455C4B60) ---
_QWORD *__fastcall sub_1455C4B60(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C3220(a1, a2);
  *a1 = off_148AB4260;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4B60 (0x1455C4B60) ---

// --- Function: sub_1455C4BC0 (0x1455C4BC0) ---
_QWORD *__fastcall sub_1455C4BC0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB44E0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4BC0 (0x1455C4BC0) ---

// --- Function: sub_1455C4C80 (0x1455C4C80) ---
_QWORD *__fastcall sub_1455C4C80(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB2E10;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4C80 (0x1455C4C80) ---

// --- Function: sub_1455C4CE0 (0x1455C4CE0) ---
_QWORD *__fastcall sub_1455C4CE0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB47D8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4CE0 (0x1455C4CE0) ---

// --- Function: sub_1455C4D40 (0x1455C4D40) ---
_QWORD *__fastcall sub_1455C4D40(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB2EB0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4D40 (0x1455C4D40) ---

// --- Function: sub_1455C4DA0 (0x1455C4DA0) ---
_QWORD *__fastcall sub_1455C4DA0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB2ED8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4DA0 (0x1455C4DA0) ---

// --- Function: sub_1455C4E00 (0x1455C4E00) ---
_QWORD *__fastcall sub_1455C4E00(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2500(a1, a2);
  *a1 = off_148AB2F00;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4E00 (0x1455C4E00) ---

// --- Function: sub_1455C4E60 (0x1455C4E60) ---
_QWORD *__fastcall sub_1455C4E60(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2570(a1, a2);
  *a1 = off_148AB2F28;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4E60 (0x1455C4E60) ---

// --- Function: sub_1455C4EC0 (0x1455C4EC0) ---
_QWORD *__fastcall sub_1455C4EC0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB2F50;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4EC0 (0x1455C4EC0) ---

// --- Function: sub_1455C4F20 (0x1455C4F20) ---
_QWORD *__fastcall sub_1455C4F20(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB2F78;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4F20 (0x1455C4F20) ---

// --- Function: sub_1455C4F80 (0x1455C4F80) ---
_QWORD *__fastcall sub_1455C4F80(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB3388;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4F80 (0x1455C4F80) ---

// --- Function: sub_1455C4FE0 (0x1455C4FE0) ---
_QWORD *__fastcall sub_1455C4FE0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB32C0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C4FE0 (0x1455C4FE0) ---

// --- Function: sub_1455C5040 (0x1455C5040) ---
_QWORD *__fastcall sub_1455C5040(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C25E0(a1, a2);
  *a1 = off_148AB2FC8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5040 (0x1455C5040) ---

// --- Function: sub_1455C50A0 (0x1455C50A0) ---
_QWORD *__fastcall sub_1455C50A0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB2FF0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C50A0 (0x1455C50A0) ---

// --- Function: sub_1455C5100 (0x1455C5100) ---
_QWORD *__fastcall sub_1455C5100(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3018;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5100 (0x1455C5100) ---

// --- Function: sub_1455C5160 (0x1455C5160) ---
_QWORD *__fastcall sub_1455C5160(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB31A8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5160 (0x1455C5160) ---

// --- Function: sub_1455C51C0 (0x1455C51C0) ---
_QWORD *__fastcall sub_1455C51C0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB31F8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C51C0 (0x1455C51C0) ---

// --- Function: sub_1455C5220 (0x1455C5220) ---
_QWORD *__fastcall sub_1455C5220(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4828;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5220 (0x1455C5220) ---

// --- Function: sub_1455C5280 (0x1455C5280) ---
_QWORD *__fastcall sub_1455C5280(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB3220;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5280 (0x1455C5280) ---

// --- Function: sub_1455C52E0 (0x1455C52E0) ---
_QWORD *__fastcall sub_1455C52E0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB3248;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C52E0 (0x1455C52E0) ---

// --- Function: sub_1455C5340 (0x1455C5340) ---
_QWORD *__fastcall sub_1455C5340(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2650(a1, a2);
  *a1 = off_148AB3298;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5340 (0x1455C5340) ---

// --- Function: sub_1455C53A0 (0x1455C53A0) ---
_QWORD *__fastcall sub_1455C53A0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB3310;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C53A0 (0x1455C53A0) ---

// --- Function: sub_1455C5400 (0x1455C5400) ---
_QWORD *__fastcall sub_1455C5400(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3338;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5400 (0x1455C5400) ---

// --- Function: sub_1455C5460 (0x1455C5460) ---
_QWORD *__fastcall sub_1455C5460(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB33B0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5460 (0x1455C5460) ---

// --- Function: sub_1455C54C0 (0x1455C54C0) ---
_QWORD *__fastcall sub_1455C54C0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3FE0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C54C0 (0x1455C54C0) ---

// --- Function: sub_1455C5520 (0x1455C5520) ---
_QWORD *__fastcall sub_1455C5520(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB33D8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5520 (0x1455C5520) ---

// --- Function: sub_1455C5580 (0x1455C5580) ---
_QWORD *__fastcall sub_1455C5580(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3400;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5580 (0x1455C5580) ---

// --- Function: sub_1455C55E0 (0x1455C55E0) ---
_QWORD *__fastcall sub_1455C55E0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3428;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C55E0 (0x1455C55E0) ---

// --- Function: sub_1455C5640 (0x1455C5640) ---
_QWORD *__fastcall sub_1455C5640(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C26C0(a1, a2);
  *a1 = off_148AB34C8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5640 (0x1455C5640) ---

// --- Function: sub_1455C56A0 (0x1455C56A0) ---
_QWORD *__fastcall sub_1455C56A0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2730(a1, a2);
  *a1 = off_148AB3518;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C56A0 (0x1455C56A0) ---

// --- Function: sub_1455C5700 (0x1455C5700) ---
_QWORD *__fastcall sub_1455C5700(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3478;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5700 (0x1455C5700) ---

// --- Function: sub_1455C5760 (0x1455C5760) ---
_QWORD *__fastcall sub_1455C5760(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB3540;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5760 (0x1455C5760) ---

// --- Function: sub_1455C57C0 (0x1455C57C0) ---
_QWORD *__fastcall sub_1455C57C0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C27A0(a1, a2);
  *a1 = off_148AB35B8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C57C0 (0x1455C57C0) ---

// --- Function: sub_1455C5890 (0x1455C5890) ---
_QWORD *__fastcall sub_1455C5890(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1850(a1, a2);
  *a1 = off_148AB4738;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5890 (0x1455C5890) ---

// --- Function: sub_1455C58F0 (0x1455C58F0) ---
_QWORD *__fastcall sub_1455C58F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C18C0(a1, a2);
  *a1 = off_148AB3568;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C58F0 (0x1455C58F0) ---

// --- Function: sub_1455C5950 (0x1455C5950) ---
_QWORD *__fastcall sub_1455C5950(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C18C0(a1, a2);
  *a1 = off_148AB3108;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5950 (0x1455C5950) ---

// --- Function: sub_1455C59B0 (0x1455C59B0) ---
_QWORD *__fastcall sub_1455C59B0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB35E0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C59B0 (0x1455C59B0) ---

// --- Function: sub_1455C5A10 (0x1455C5A10) ---
_QWORD *__fastcall sub_1455C5A10(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2D50(a1, a2);
  *a1 = off_148AB3630;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5A10 (0x1455C5A10) ---

// --- Function: sub_1455C5A70 (0x1455C5A70) ---
_QWORD *__fastcall sub_1455C5A70(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB3658;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5A70 (0x1455C5A70) ---

// --- Function: sub_1455C5AD0 (0x1455C5AD0) ---
_QWORD *__fastcall sub_1455C5AD0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3680;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5AD0 (0x1455C5AD0) ---

// --- Function: sub_1455C5B30 (0x1455C5B30) ---
_QWORD *__fastcall sub_1455C5B30(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB32E8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5B30 (0x1455C5B30) ---

// --- Function: sub_1455C5B90 (0x1455C5B90) ---
_QWORD *__fastcall sub_1455C5B90(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB36A8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5B90 (0x1455C5B90) ---

// --- Function: sub_1455C5BF0 (0x1455C5BF0) ---
_QWORD *__fastcall sub_1455C5BF0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB36D0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5BF0 (0x1455C5BF0) ---

// --- Function: sub_1455C5C50 (0x1455C5C50) ---
_QWORD *__fastcall sub_1455C5C50(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2810(a1, a2);
  *a1 = off_148AB36F8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5C50 (0x1455C5C50) ---

// --- Function: sub_1455C5CB0 (0x1455C5CB0) ---
_QWORD *__fastcall sub_1455C5CB0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1FC0(a1, a2);
  *a1 = off_148AB3D60;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5CB0 (0x1455C5CB0) ---

// --- Function: sub_1455C5D10 (0x1455C5D10) ---
_QWORD *__fastcall sub_1455C5D10(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2D50(a1, a2);
  *a1 = off_148AB3F18;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5D10 (0x1455C5D10) ---

// --- Function: sub_1455C5D70 (0x1455C5D70) ---
_QWORD *__fastcall sub_1455C5D70(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C28F0(a1, a2);
  *a1 = off_148AB3770;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5D70 (0x1455C5D70) ---

// --- Function: sub_1455C5DD0 (0x1455C5DD0) ---
_QWORD *__fastcall sub_1455C5DD0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3C20;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5DD0 (0x1455C5DD0) ---

// --- Function: sub_1455C5E30 (0x1455C5E30) ---
_QWORD *__fastcall sub_1455C5E30(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C3140(a1, a2);
  *a1 = off_148AB4620;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5E30 (0x1455C5E30) ---

// --- Function: sub_1455C5E90 (0x1455C5E90) ---
_QWORD *__fastcall sub_1455C5E90(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2880(a1, a2);
  *a1 = off_148AB4670;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5E90 (0x1455C5E90) ---

// --- Function: sub_1455C5EF0 (0x1455C5EF0) ---
_QWORD *__fastcall sub_1455C5EF0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB3B80;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5EF0 (0x1455C5EF0) ---

// --- Function: sub_1455C5F50 (0x1455C5F50) ---
_QWORD *__fastcall sub_1455C5F50(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB3798;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5F50 (0x1455C5F50) ---

// --- Function: sub_1455C5FB0 (0x1455C5FB0) ---
_QWORD *__fastcall sub_1455C5FB0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB37C0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C5FB0 (0x1455C5FB0) ---

// --- Function: sub_1455C6010 (0x1455C6010) ---
_QWORD *__fastcall sub_1455C6010(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2960(a1, a2);
  *a1 = off_148AB3810;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6010 (0x1455C6010) ---

// --- Function: sub_1455C6070 (0x1455C6070) ---
_QWORD *__fastcall sub_1455C6070(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB39A0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6070 (0x1455C6070) ---

// --- Function: sub_1455C60D0 (0x1455C60D0) ---
_QWORD *__fastcall sub_1455C60D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB45A8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C60D0 (0x1455C60D0) ---

// --- Function: sub_1455C6130 (0x1455C6130) ---
_QWORD *__fastcall sub_1455C6130(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4580;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6130 (0x1455C6130) ---

// --- Function: sub_1455C6190 (0x1455C6190) ---
_QWORD *__fastcall sub_1455C6190(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB45D0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6190 (0x1455C6190) ---

// --- Function: sub_1455C61F0 (0x1455C61F0) ---
_QWORD *__fastcall sub_1455C61F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3180;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C61F0 (0x1455C61F0) ---

// --- Function: sub_1455C6250 (0x1455C6250) ---
_QWORD *__fastcall sub_1455C6250(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1930(a1, a2);
  *a1 = off_148AB3158;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6250 (0x1455C6250) ---

// --- Function: sub_1455C62B0 (0x1455C62B0) ---
_QWORD *__fastcall sub_1455C62B0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C29D0(a1, a2);
  *a1 = off_148AB3D10;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C62B0 (0x1455C62B0) ---

// --- Function: sub_1455C6310 (0x1455C6310) ---
_QWORD *__fastcall sub_1455C6310(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3360;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6310 (0x1455C6310) ---

// --- Function: sub_1455C6370 (0x1455C6370) ---
_QWORD *__fastcall sub_1455C6370(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB3860;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6370 (0x1455C6370) ---

// --- Function: sub_1455C63D0 (0x1455C63D0) ---
_QWORD *__fastcall sub_1455C63D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB47B0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C63D0 (0x1455C63D0) ---

// --- Function: sub_1455C6430 (0x1455C6430) ---
_QWORD *__fastcall sub_1455C6430(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2A40(a1, a2);
  *a1 = off_148AB3838;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6430 (0x1455C6430) ---

// --- Function: sub_1455C6490 (0x1455C6490) ---
_QWORD *__fastcall sub_1455C6490(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2AB0(a1, a2);
  *a1 = off_148AB3888;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6490 (0x1455C6490) ---

// --- Function: sub_1455C64F0 (0x1455C64F0) ---
_QWORD *__fastcall sub_1455C64F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C3290(a1, a2);
  *a1 = off_148AB4238;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C64F0 (0x1455C64F0) ---

// --- Function: sub_1455C6550 (0x1455C6550) ---
_QWORD *__fastcall sub_1455C6550(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2C00(a1, a2);
  *a1 = off_148AB44B8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6550 (0x1455C6550) ---

// --- Function: sub_1455C65B0 (0x1455C65B0) ---
_QWORD *__fastcall sub_1455C65B0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3D88;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C65B0 (0x1455C65B0) ---

// --- Function: sub_1455C6610 (0x1455C6610) ---
_QWORD *__fastcall sub_1455C6610(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3DB0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6610 (0x1455C6610) ---

// --- Function: sub_1455C6670 (0x1455C6670) ---
_QWORD *__fastcall sub_1455C6670(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2B20(a1, a2);
  *a1 = off_148AB38D8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6670 (0x1455C6670) ---

// --- Function: sub_1455C66D0 (0x1455C66D0) ---
_QWORD *__fastcall sub_1455C66D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C26C0(a1, a2);
  *a1 = off_148AB3900;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C66D0 (0x1455C66D0) ---

// --- Function: sub_1455C6730 (0x1455C6730) ---
_QWORD *__fastcall sub_1455C6730(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB3928;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6730 (0x1455C6730) ---

// --- Function: sub_1455C6790 (0x1455C6790) ---
_QWORD *__fastcall sub_1455C6790(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2B90(a1, a2);
  *a1 = off_148AB3978;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6790 (0x1455C6790) ---

// --- Function: sub_1455C67F0 (0x1455C67F0) ---
_QWORD *__fastcall sub_1455C67F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2C00(a1, a2);
  *a1 = off_148AB46C0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C67F0 (0x1455C67F0) ---

// --- Function: sub_1455C6850 (0x1455C6850) ---
_QWORD *__fastcall sub_1455C6850(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB46E8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6850 (0x1455C6850) ---

// --- Function: sub_1455C68B0 (0x1455C68B0) ---
_QWORD *__fastcall sub_1455C68B0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB3A40;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C68B0 (0x1455C68B0) ---

// --- Function: sub_1455C6910 (0x1455C6910) ---
_QWORD *__fastcall sub_1455C6910(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3B58;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6910 (0x1455C6910) ---

// --- Function: sub_1455C6970 (0x1455C6970) ---
_QWORD *__fastcall sub_1455C6970(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A10(a1, a2);
  *a1 = off_148AB3B30;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6970 (0x1455C6970) ---

// --- Function: sub_1455C69D0 (0x1455C69D0) ---
_QWORD *__fastcall sub_1455C69D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2C70(a1, a2);
  *a1 = off_148AB39F0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C69D0 (0x1455C69D0) ---

// --- Function: sub_1455C6A30 (0x1455C6A30) ---
_QWORD *__fastcall sub_1455C6A30(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB3A18;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6A30 (0x1455C6A30) ---

// --- Function: sub_1455C6A90 (0x1455C6A90) ---
_QWORD *__fastcall sub_1455C6A90(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2CE0(a1, a2);
  *a1 = off_148AB3AE0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6A90 (0x1455C6A90) ---

// --- Function: sub_1455C6AF0 (0x1455C6AF0) ---
_QWORD *__fastcall sub_1455C6AF0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C3300(a1, a2);
  *a1 = off_148AB3C70;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6AF0 (0x1455C6AF0) ---

// --- Function: sub_1455C6B50 (0x1455C6B50) ---
_QWORD *__fastcall sub_1455C6B50(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2D50(a1, a2);
  *a1 = off_148AB3C98;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6B50 (0x1455C6B50) ---

// --- Function: sub_1455C6BB0 (0x1455C6BB0) ---
_QWORD *__fastcall sub_1455C6BB0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB31D0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6BB0 (0x1455C6BB0) ---

// --- Function: sub_1455C6C10 (0x1455C6C10) ---
_QWORD *__fastcall sub_1455C6C10(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB3CC0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6C10 (0x1455C6C10) ---

// --- Function: sub_1455C6C70 (0x1455C6C70) ---
_QWORD *__fastcall sub_1455C6C70(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB3720;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6C70 (0x1455C6C70) ---

// --- Function: sub_1455C6CD0 (0x1455C6CD0) ---
_QWORD *__fastcall sub_1455C6CD0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2DC0(a1, a2);
  *a1 = off_148AB3E50;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6CD0 (0x1455C6CD0) ---

// --- Function: sub_1455C6D30 (0x1455C6D30) ---
_QWORD *__fastcall sub_1455C6D30(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2E30(a1, a2);
  *a1 = off_148AB3BD0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6D30 (0x1455C6D30) ---

// --- Function: sub_1455C6D90 (0x1455C6D90) ---
_QWORD *__fastcall sub_1455C6D90(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E00(a1, a2);
  *a1 = off_148AB3BF8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6D90 (0x1455C6D90) ---

// --- Function: sub_1455C6DF0 (0x1455C6DF0) ---
_QWORD *__fastcall sub_1455C6DF0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2F10(a1, a2);
  *a1 = off_148AB3EA0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6DF0 (0x1455C6DF0) ---

// --- Function: sub_1455C6E50 (0x1455C6E50) ---
_QWORD *__fastcall sub_1455C6E50(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C19A0(a1, a2);
  *a1 = off_148AB3068;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6E50 (0x1455C6E50) ---

// --- Function: sub_1455C6EB0 (0x1455C6EB0) ---
_QWORD *__fastcall sub_1455C6EB0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2EA0(a1, a2);
  *a1 = off_148AB4198;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C6EB0 (0x1455C6EB0) ---

// --- Function: sub_1455C7020 (0x1455C7020) ---
_QWORD *__fastcall sub_1455C7020(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2EA0(a1, a2);
  *a1 = off_148AB41C0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7020 (0x1455C7020) ---

// --- Function: sub_1455C7190 (0x1455C7190) ---
_QWORD *__fastcall sub_1455C7190(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C3220(a1, a2);
  *a1 = off_148AB30B8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7190 (0x1455C7190) ---

// --- Function: sub_1455C71F0 (0x1455C71F0) ---
_QWORD *__fastcall sub_1455C71F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB4698;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C71F0 (0x1455C71F0) ---

// --- Function: sub_1455C72C0 (0x1455C72C0) ---
_QWORD *__fastcall sub_1455C72C0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1E70(a1, a2);
  *a1 = off_148AB2CD0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C72C0 (0x1455C72C0) ---

// --- Function: sub_1455C7320 (0x1455C7320) ---
_QWORD *__fastcall sub_1455C7320(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB41E8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7320 (0x1455C7320) ---

// --- Function: sub_1455C7430 (0x1455C7430) ---
_QWORD *__fastcall sub_1455C7430(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3F68;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7430 (0x1455C7430) ---

// --- Function: sub_1455C7490 (0x1455C7490) ---
_QWORD *__fastcall sub_1455C7490(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3F40;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7490 (0x1455C7490) ---

// --- Function: sub_1455C74F0 (0x1455C74F0) ---
_QWORD *__fastcall sub_1455C74F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3FB8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C74F0 (0x1455C74F0) ---

// --- Function: sub_1455C7550 (0x1455C7550) ---
_QWORD *__fastcall sub_1455C7550(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB3F90;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7550 (0x1455C7550) ---

// --- Function: sub_1455C75B0 (0x1455C75B0) ---
_QWORD *__fastcall sub_1455C75B0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2260(a1, a2);
  *a1 = off_148AB4530;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C75B0 (0x1455C75B0) ---

// --- Function: sub_1455C7610 (0x1455C7610) ---
_QWORD *__fastcall sub_1455C7610(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4508;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7610 (0x1455C7610) ---

// --- Function: sub_1455C7670 (0x1455C7670) ---
_QWORD *__fastcall sub_1455C7670(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1A80(a1, a2);
  *a1 = off_148AB4008;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7670 (0x1455C7670) ---

// --- Function: sub_1455C76D0 (0x1455C76D0) ---
_QWORD *__fastcall sub_1455C76D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2F80(a1, a2);
  *a1 = off_148AB42D8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C76D0 (0x1455C76D0) ---

// --- Function: sub_1455C7730 (0x1455C7730) ---
_QWORD *__fastcall sub_1455C7730(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2FF0(a1, a2);
  *a1 = off_148AB4328;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7730 (0x1455C7730) ---

// --- Function: sub_1455C7790 (0x1455C7790) ---
_QWORD *__fastcall sub_1455C7790(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2DC0(a1, a2);
  *a1 = off_148AB4350;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7790 (0x1455C7790) ---

// --- Function: sub_1455C77F0 (0x1455C77F0) ---
_QWORD *__fastcall sub_1455C77F0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C2DC0(a1, a2);
  *a1 = off_148AB4288;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C77F0 (0x1455C77F0) ---

// --- Function: sub_1455C7850 (0x1455C7850) ---
_QWORD *__fastcall sub_1455C7850(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C30D0(a1, a2);
  *a1 = off_148AB43F0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7850 (0x1455C7850) ---

// --- Function: sub_1455C78B0 (0x1455C78B0) ---
_QWORD *__fastcall sub_1455C78B0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C1BD0(a1, a2);
  *a1 = off_148AB4418;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C78B0 (0x1455C78B0) ---

// --- Function: sub_1455C7910 (0x1455C7910) ---
_QWORD *__fastcall sub_1455C7910(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C3060(a1, a2);
  *a1 = off_148AB43A0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7910 (0x1455C7910) ---

// --- Function: sub_1455C7970 (0x1455C7970) ---
_QWORD *__fastcall sub_1455C7970(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4440;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7970 (0x1455C7970) ---

// --- Function: sub_1455C79D0 (0x1455C79D0) ---
_QWORD *__fastcall sub_1455C79D0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4468;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C79D0 (0x1455C79D0) ---

// --- Function: sub_1455C7A30 (0x1455C7A30) ---
_QWORD *__fastcall sub_1455C7A30(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4800;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7A30 (0x1455C7A30) ---

// --- Function: sub_1455C7A90 (0x1455C7A90) ---
_QWORD *__fastcall sub_1455C7A90(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4030;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7A90 (0x1455C7A90) ---

// --- Function: sub_1455C7AF0 (0x1455C7AF0) ---
_QWORD *__fastcall sub_1455C7AF0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4080;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7AF0 (0x1455C7AF0) ---

// --- Function: sub_1455C7B50 (0x1455C7B50) ---
_QWORD *__fastcall sub_1455C7B50(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB40A8;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7B50 (0x1455C7B50) ---

// --- Function: sub_1455C7BB0 (0x1455C7BB0) ---
_QWORD *__fastcall sub_1455C7BB0(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB40D0;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7BB0 (0x1455C7BB0) ---

// --- Function: sub_1455C7C10 (0x1455C7C10) ---
_QWORD *__fastcall sub_1455C7C10(_QWORD *a1, volatile signed __int32 **a2)
{
  sub_1455C17E0(a1, a2);
  *a1 = off_148AB4058;
  if ( *a2 )
    sub_142FEFD50(*a2);
  *a2 = 0;
  return a1;
}

// --- End Function: sub_1455C7C10 (0x1455C7C10) ---

// --- Function: sub_145A73A20 (0x145A73A20) ---
__int64 __fastcall sub_145A73A20(__int64 *a1, volatile signed __int32 **a2)
{
  __int64 result; // rax
  __int64 *v3; // [rsp+28h] [rbp-40h]
  __int64 v4; // [rsp+50h] [rbp-18h]

  v3 = a1 + 0x59;
  if ( a1[0x59] )
    return sub_142F8F080(v3, a2, *a1, 1u);
  v4 = *v3;
  *v3 = (__int64)*a2;
  *a2 = (volatile signed __int32 *)v4;
  if ( *a2 )
    sub_142FEFD50(*a2);
  result = (__int64)a2;
  *a2 = 0;
  return result;
}

// --- End Function: sub_145A73A20 (0x145A73A20) ---

// --- Function: sub_145A8DC50 (0x145A8DC50) ---
__int64 __fastcall sub_145A8DC50(__int64 a1, __int64 a2)
{
  unsigned __int16 v3; // [rsp+20h] [rbp-38h]
  volatile signed __int32 *v4[3]; // [rsp+28h] [rbp-30h] BYREF
  __int64 v5[3]; // [rsp+40h] [rbp-18h] BYREF

  v3 = sub_145ACC430(a1);
  v4[1] = (volatile signed __int32 *)(a1 + 0x1178);
  sub_142F41D00((_QWORD *)(a1 + 0x1178), (unsigned __int64 *)v4, v3, a2);
  sub_1402AE3D0(v5, "CSCActorActionHandler::RequestPrivate", a1 + 0x1680, 1);
  v4[2] = (volatile signed __int32 *)(a1 + 0x1178);
  sub_145A73A20((__int64 *)(a1 + 0x1178), v4);
  sub_1402B1820(v5);
  if ( v4[0] )
    sub_142FEFD50(v4[0]);
  return v3;
}

// --- End Function: sub_145A8DC50 (0x145A8DC50) ---

// --- Function: sub_145AB6E60 (0x145AB6E60) ---
const ULONG_PTR *__fastcall sub_145AB6E60(__int64 a1)
{
  __int64 v1; // rax
  unsigned __int8 v3[8]; // [rsp+20h] [rbp-38h] BYREF
  char v4; // [rsp+28h] [rbp-30h]
  _BYTE *v5; // [rsp+30h] [rbp-28h]
  __int64 v6; // [rsp+38h] [rbp-20h] BYREF
  __int64 v7[3]; // [rsp+40h] [rbp-18h] BYREF

  sub_1402AE3D0(&v6, "CSCActorActionHandler::AddForceUpdateOption", a1 + 0x2D8, 1);
  if ( !sub_14046B610(a1 + 0x2B8) )
  {
    v1 = sub_140453020((__int64)v7, *(_QWORD *)(a1 + 0x158), 0xA);
    sub_140469400(a1 + 0x2B8, v1);
    sub_140463990(v7);
  }
  v3[0] = 1;
  v5 = (_BYTE *)identity_int64(a1 + 0x2F0);
  v4 = sub_1402FBEC0(v3);
  *v5 = v4;
  return sub_1402B1820(&v6);
}

// --- End Function: sub_145AB6E60 (0x145AB6E60) ---

// --- Function: sub_145ACC430 (0x145ACC430) ---
__int64 __fastcall sub_145ACC430(__int64 a1)
{
  unsigned __int16 v2; // [rsp+20h] [rbp-18h]

  do
    v2 = InterlockedIncrement16_w((volatile signed __int16 *)(a1 + 0x220));
  while ( !v2 );
  return v2;
}

// --- End Function: sub_145ACC430 (0x145ACC430) ---

// --- Function: sub_145AD5700 (0x145AD5700) ---
bool __fastcall sub_145AD5700(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x158) + 0x758LL))(*(_QWORD *)(a1 + 0x158));
  return sub_1403BFC90(v1);
}

// --- End Function: sub_145AD5700 (0x145AD5700) ---

// --- Function: sub_145AEF8F0 (0x145AEF8F0) ---
const ULONG_PTR *__fastcall sub_145AEF8F0(__int64 a1, __int64 a2)
{
  const ULONG_PTR *result; // rax

  sub_145A8DC50(a1, a2);
  result = (const ULONG_PTR *)sub_145AD5700(a1);
  if ( (_BYTE)result )
    return sub_145AB6E60(a1);
  return result;
}

// --- End Function: sub_145AEF8F0 (0x145AEF8F0) ---

// --- Function: sub_145EEE160 (0x145EEE160) ---
void __fastcall sub_145EEE160(_QWORD *a1)
{
  *a1 = &off_148747D28;
  sub_145F27B80((__int64)a1);
}

// --- End Function: sub_145EEE160 (0x145EEE160) ---

// --- Function: sub_1465EEBE0 (0x1465EEBE0) ---
__int64 __fastcall sub_1465EEBE0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x270);
}

// --- End Function: sub_1465EEBE0 (0x1465EEBE0) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_1475B3F30 (0x1475B3F30) ---
int __fastcall sub_1475B3F30(char *Buffer, size_t BufferCount, unsigned __int64 n0x40000000)
{
  const char *p_%u.%u_MB; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  int v10; // [rsp+20h] [rbp-A8h]
  int v11; // [rsp+28h] [rbp-A0h]
  __m256 DstBuf_; // [rsp+40h] [rbp-88h] BYREF
  __m256 DstBuf__1; // [rsp+60h] [rbp-68h] BYREF
  __m256 v14; // [rsp+80h] [rbp-48h]

  DstBuf_ = (__m256)0LL;
  if ( n0x40000000 >= 0x10000000000LL )
  {
    p_%u.%u_MB = "%u.%u TB";
    v7 = (0xA * (n0x40000000 & 0xFFFFFFFFFFLL)) >> 0x28;
    v8 = n0x40000000 >> 0x28;
LABEL_7:
    v11 = v7;
    v10 = v8;
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, p_%u.%u_MB, v10, v11);
    goto LABEL_11;
  }
  if ( n0x40000000 >= 0x40000000 )
  {
    p_%u.%u_MB = "%u.%u GB";
    v7 = (0xA * (n0x40000000 & 0x3FFFFFFF)) >> 0x1E;
    v8 = n0x40000000 >> 0x1E;
    goto LABEL_7;
  }
  if ( n0x40000000 >= 0x100000 )
  {
    p_%u.%u_MB = "%u.%u MB";
    v7 = (0xA * (n0x40000000 & 0xFFFFF)) >> 0x14;
    v8 = n0x40000000 >> 0x14;
    goto LABEL_7;
  }
  if ( n0x40000000 < 0x400 )
  {
    __asm { vzeroupper }
    snprintf_s((char *)&DstBuf_, 0x20u, 0xFFFFFFFFFFFFFFFFuLL, "%u byte(s)", n0x40000000);
  }
  else
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf_,
      0x20u,
      0xFFFFFFFFFFFFFFFFuLL,
      "%u.%u KB",
      n0x40000000 >> 0xA,
      (0xA * (n0x40000000 & 0x3FF)) >> 0xA);
  }
LABEL_11:
  DstBuf__1 = (__m256)0LL;
  v14 = (__m256)0LL;
  if ( byte_1516B60CF )
  {
    __asm { vzeroupper }
    snprintf_s(
      (char *)&DstBuf__1,
      0x40u,
      0xFFFFFFFFFFFFFFFFuLL,
      " (Started with < %u GB of available system memory.)",
      8);
  }
  __asm { vzeroupper }
  return snprintf_s(
           Buffer,
           BufferCount,
           0xFFFFFFFFFFFFFFFFuLL,
           "Out of system memory. Failed to allocate %s (%zu).%s",
           (const char *)&DstBuf_,
           n0x40000000,
           (const char *)&DstBuf__1);
}

// --- End Function: sub_1475B3F30 (0x1475B3F30) ---

// --- Function: sub_1475DF210 (0x1475DF210) ---
void __fastcall sub_1475DF210(unsigned __int64 n0x6400000)
{
  ULONG_PTR Arguments[2]; // [rsp+20h] [rbp-C8h] BYREF
  char Buffer[160]; // [rsp+30h] [rbp-B8h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_1475B3F30(Buffer, 0xA0u, n0x6400000);
  Arguments[0] = (ULONG_PTR)Buffer;
  RaiseException(0x2BADFF61u, 1u, 1u, Arguments);
}

// --- End Function: sub_1475DF210 (0x1475DF210) ---

// --- Function: sub_147602270 (0x147602270) ---
void __fastcall sub_147602270(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rcx
  _QWORD *v9; // rdi
  __int64 v10; // rcx
  unsigned __int64 v11; // r14
  __int64 v12; // rsi
  __int64 v13; // rcx
  _BYTE v14[32]; // [rsp+30h] [rbp-48h] BYREF

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x11C0));
  v6 = *(_QWORD *)(a1 + 0x1190);
  if ( (unsigned __int64)(0x4000000000LL - *(_QWORD *)(v6 + 8)) < 0x2000000 )
  {
    v7 = *(unsigned int *)(a1 + 0x11AC);
    *(__m256i *)(a1 + 0x1198) = *(__m256i *)sub_14056DBC0(
                                              (__int64)v14,
                                              0x8000000000LL,
                                              *(_DWORD *)(a1 + 0x11AC),
                                              off_148D699A0,
                                              1,
                                              0);// "StarAlloc-Small"
    v6 = (*(_QWORD *)(a1 + 0x1198) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
    __asm { vzeroupper }
    sub_14056DA40(a1 + 0x1198, v6, (v7 + 0x17) & ~(v7 - 1));
    *(_WORD *)(v6 + 0x15) = 0;
    *(_BYTE *)(v6 + 0x17) = 0;
    *(_QWORD *)v6 = 0;
    *(_BYTE *)(v6 + 0x14) = 0;
    *(_QWORD *)(v6 + 8) = ((v6 + 0x2000017) & 0xFFFFFFFFFE000000uLL) - v6;
    *(_DWORD *)(v6 + 0x10) = 0x1337;
    *(_QWORD *)v6 = *(_QWORD *)(a1 + 0x1190);
    *(_BYTE *)(v6 + 0x14) = 1;
    *(_QWORD *)(a1 + 0x1190) = v6;
  }
  v8 = *(_QWORD *)(v6 + 8);
  v9 = (_QWORD *)(v6 + v8 + *(unsigned int *)(a1 + 0x11AC));
  *(_QWORD *)(v6 + 8) = v8 + 0x2000000;
  v10 = *(unsigned int *)(a1 + 0x11AC);
  v11 = a2 + v10 + 0x2F - ((unsigned __int64)v9 + v10 + a2 + 0x2F) % a2;
  if ( *(_BYTE *)(a1 + 0x14F8) )
    v12 = 0x2000000 - v10;
  else
    v12 = ~(v10 - 1) & (v11 + v10 - 1);
  sub_14056DA40(a1 + 0x1198, (__int64)v9, v12);
  v9[5] = 0x1337;
  *v9 = 0;
  v13 = 0x20 * (a3 + 1);
  v9[1] = a3;
  v9[2] = a2;
  v9[4] = v11;
  v9[3] = v12;
  *v9 = *(_QWORD *)(v13 + a1);
  *(_QWORD *)(v13 + a1) = v9;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 0x11C0));
}

// --- End Function: sub_147602270 (0x147602270) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_147602DF0 (0x147602DF0) ---
__int64 __fastcall sub_147602DF0(__int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  __int64 v3; // r12
  __int64 *v4; // rdi
  unsigned __int64 v5; // r11
  unsigned __int128 v9; // rax
  unsigned __int64 v10; // rbx
  __int64 v11; // r9
  __int64 v14; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  _QWORD *v20; // r8
  __int64 v23; // rdx
  __int64 v24; // r9
  __int64 v26; // rbp
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // [rsp+40h] [rbp-68h] BYREF
  __int64 v29; // [rsp+48h] [rbp-60h] BYREF
  __int64 *v30; // [rsp+50h] [rbp-58h] BYREF
  __int64 *v31; // [rsp+58h] [rbp-50h] BYREF
  _BYTE v32[32]; // [rsp+60h] [rbp-48h] BYREF
  _QWORD *v33; // [rsp+B0h] [rbp+8h]

  v3 = *(_QWORD *)(a1 + 0x1270);
  v4 = (__int64 *)(a1 + 0x11F0);
  v5 = *(_QWORD *)(a1 + 0x1208);
  v9 = a2 * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v10 = 0;
  v11 = v5 & ((*((_QWORD *)&v9 + 1) + (_QWORD)v9) >> 7);
  _XMM2 = (BYTE8(v9) + (_BYTE)v9) & 0x7F;
  __asm { vpshufb xmm2, xmm2, xmm0 }
  while ( 1 )
  {
    v14 = *v4;
    _XMM1 = *(_OWORD *)(*v4 + v11);
    __asm
    {
      vpcmpeqb xmm0, xmm2, xmm1
      vpmovmskb eax, xmm0
    }
    if ( _EAX )
      break;
LABEL_6:
    __asm
    {
      vpcmpeqb xmm1, xmm1, cs:xmmword_14819F430
      vpmovmskb eax, xmm1
    }
    if ( _EAX )
    {
      v20 = v33;
      v24 = v14 + v5;
      v23 = v14;
      goto LABEL_11;
    }
    v10 += 0x10LL;
    v11 = v5 & (v10 + v11);
    if ( v10 > v5 )
      __debugbreak();
  }
  while ( 1 )
  {
    _BitScanForward((unsigned int *)&v18, _EAX);
    LODWORD(v33) = 0;
    v19 = v5 & (v11 + v18);
    v20 = (_QWORD *)(v4[1] + 0x10 * v19);
    if ( *v20 == a2 )
      break;
    _EAX &= _EAX - 1;
    if ( !_EAX )
    {
      v14 = *v4;
      goto LABEL_6;
    }
  }
  v23 = *v4;
  v24 = *v4 + v19;
LABEL_11:
  if ( v24 == v23 + *(_QWORD *)(a1 + 0x1208) )
  {
    v26 = *(_QWORD *)(a1 + 0x1260);
    v27 = *(_QWORD *)(a1 + 0x1268);
    *(_QWORD *)(a1 + 0x1260) = v26 + 1;
    if ( 0x10 * v26 >= v27 )
    {
      sub_14056DA40(a1 + 0x1270, v3 + v27, *(unsigned int *)(a1 + 0x1284));
      *(_QWORD *)(a1 + 0x1268) += *(unsigned int *)(a1 + 0x1284);
    }
    v28 = a2;
    v30 = (__int64 *)&v28;
    v29 = v26;
    v31 = &v29;
    *(_QWORD *)(v3 + 0x10 * v26) = a2;
    *a3 = v26;
    sub_147601B90(
      v4,
      (__int64)v32,
      &v28,
      (__PAIR128__(a2, a2) * 0xDE5FB9D2630458E9uLL) >> 0x40,
      (int)&byte_14819E9C1,
      &v30,
      &v31);
    return v3 + 0x10 * v26;
  }
  else
  {
    *a3 = v20[1];
    return v3 + 0x10LL * v20[1];
  }
}

// --- End Function: sub_147602DF0 (0x147602DF0) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476030E0 (0x1476030E0) ---
unsigned __int64 __fastcall sub_1476030E0(unsigned __int64 n0xE000_1, unsigned __int64 n0x10)
{
  unsigned __int64 n0xE000; // r11
  unsigned int v4; // r8d
  int n32; // eax
  unsigned int n32_1; // r8d
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // r10
  __int64 v11; // r8
  __int64 v12; // rdi
  __int64 v13; // r11
  __int64 v14; // r8
  __int64 *v15; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // r11
  unsigned __int64 result; // rax
  __int64 v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // r8

  n0xE000 = n0xE000_1;
  if ( n0x10 > 0x10 )
    n0xE000 = ~(n0x10 - 1) & (n0x10 + n0xE000_1 - 1);
  if ( n0xE000 > 0xE000 )
  {
    result = sub_147603270((__int64)&qword_151700CC0, n0xE000);
  }
  else
  {
    _BitScanReverse(&v4, n0xE000 - 1);
    n32 = 32;
    n32_1 = v4 ^ 0x1F;
    if ( (_DWORD)n0xE000 != 1 )
      n32 = n32_1;
    v7 = 0;
    v8 = 0;
    v9 = (unsigned int)(32 - n32) - 8LL;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = &qword_148D699B0[3 * v8];
    LOBYTE(v7) = n0xE000 % *v10 == 0;
    v11 = n0xE000 / *v10 - v7;
    v12 = v11 + v10[1] - v10[2] / (unsigned __int64)*v10;
    v13 = *v10 * (v11 + 1);
    v14 = 16 * (v12 + 1) + *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3840;
    v15 = *(__int64 **)v14;
    if ( *(_QWORD *)v14 )
    {
      --*(_DWORD *)(v14 + 12);
      v19 = *v15;
      result = (unsigned __int64)v15 - v13 + 8;
      *(_QWORD *)v14 = v19;
    }
    else
    {
      v16 = sub_147604610(&unk_151700CD0[4 * v12]);
      if ( v16 )
        result = v16 - v17 + 8;
      else
        result = sub_1476034A0((__int64)&qword_151700CC0, v17, v12, n0x10);
    }
  }
  v20 = (_QWORD *)qword_151701F50;
  if ( qword_151701F50 )
  {
    while ( result < (unsigned __int64)v20 || result >= (unsigned __int64)v20 + v20[1] )
    {
      v20 = (_QWORD *)*v20;
      if ( !v20 )
        goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    v21 = (_QWORD *)qword_151701E50;
    if ( qword_151701E50 )
    {
      while ( result < (unsigned __int64)v21 || result >= (unsigned __int64)v21 + v21[1] )
      {
        v21 = (_QWORD *)*v21;
        if ( !v21 )
          goto LABEL_22;
      }
    }
    else
    {
LABEL_22:
      __debugbreak();
    }
  }
  return result;
}

// --- End Function: sub_1476030E0 (0x1476030E0) ---

// --- Function: sub_147603270 (0x147603270) ---
__int64 __fastcall sub_147603270(__int64 a1, unsigned __int64 n0xE000)
{
  unsigned __int64 n0xE000_2; // r13
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // rbx
  unsigned __int64 v5; // r12
  __int64 v6; // r15
  __int64 v7; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rsi
  unsigned __int64 v10; // r14
  __int64 v11; // r8
  __int64 v12; // rsi
  __int64 v13; // rax
  __int128 v15; // [rsp+30h] [rbp-40h] BYREF
  double v16; // [rsp+40h] [rbp-30h]
  __int64 v17; // [rsp+48h] [rbp-28h] BYREF
  __int128 v18; // [rsp+50h] [rbp-20h]
  double v19; // [rsp+60h] [rbp-10h]
  double v20; // [rsp+B0h] [rbp+40h] BYREF
  unsigned __int64 n0xE000_1; // [rsp+B8h] [rbp+48h]
  __int64 v22; // [rsp+C0h] [rbp+50h]

  n0xE000_1 = n0xE000;
  n0xE000_2 = n0xE000;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
  v5 = sub_147603A00(n0xE000, 1);
  v6 = ~(*(unsigned int *)(a1 + 0x1284) - 1LL) & (*(unsigned int *)(a1 + 0x1284) + n0xE000_2 - 1);
  v22 = v6;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 0x12C0));
  v20 = 0.0;
  v7 = sub_147602DF0(a1, v5, &v20);
  v8 = *(_QWORD **)(v7 + 8);
  if ( v8 )
  {
    *(_QWORD *)(v7 + 8) = *v8;
    v9 = v8[1];
    v8[1] = 0;
    *v8 = *(_QWORD *)(a1 + 0x12B8);
    *(_QWORD *)(a1 + 0x12B8) = v8;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 0x1290);
    if ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 )
    {
      do
      {
        v11 = *(unsigned int *)(a1 + 0x12AC);
        v12 = (v11 + 0x17) & ~(v11 - 1);
        *(__m256i *)(a1 + 0x1298) = *(__m256i *)sub_14056DBC0((__int64)&v17, 0x8000000000LL, v11, &off_148D699A8, 1, 0);// "StarAlloc-Large"
        v10 = (*(_QWORD *)(a1 + 0x1298) + 0x3FFFFFFFFFLL) & 0xFFFFFFC000000000uLL;
        __asm { vzeroupper }
        sub_14056DA40(a1 + 0x1298, v10, v12);
        *(_WORD *)(v10 + 0x15) = 0;
        *(_BYTE *)(v10 + 0x17) = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)(v10 + 0x10) = 0x1337;
        *(_BYTE *)(v10 + 0x14) = 0;
        *(_QWORD *)(v10 + 8) = v12;
        *(_QWORD *)v10 = *(_QWORD *)(a1 + 0x1290);
        *(_QWORD *)(a1 + 0x1290) = v10;
      }
      while ( 0x4000000000LL - *(_QWORD *)(v10 + 8) < v5 );
      v6 = v22;
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 0x12C0);
      n0xE000_2 = n0xE000_1;
    }
    v13 = *(_QWORD *)(v10 + 8);
    v9 = v13 + v10;
    *(_QWORD *)(v10 + 8) = v5 + v13;
  }
  sub_14056DA40(a1 + 0x1270, v9, v6);
  v16 = v20;
  *(_QWORD *)&v15 = n0xE000_2;
  *((_QWORD *)&v15 + 1) = v6;
  v19 = v20;
  v17 = v9;
  v18 = v15;
  sub_1476044E0((__int64 *)(a1 + 0x1228), (__int64)&v15, &v17);
  LeaveCriticalSection(lpCriticalSection);
  return v9;
}

// --- End Function: sub_147603270 (0x147603270) ---

// --- Function: sub_1476034A0 (0x1476034A0) ---
__int64 __fastcall sub_1476034A0(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 n0x10)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 i; // rax
  __int64 v9; // r11
  signed __int32 v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rbp
  unsigned __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r12
  unsigned __int64 v16; // r15
  unsigned __int64 v17; // rax
  _QWORD *v18; // r8
  unsigned __int64 v19; // rax
  int v20; // r9d
  signed __int64 v21; // rdx
  int n2_1; // [rsp+20h] [rbp-48h] BYREF
  __int64 v24; // [rsp+28h] [rbp-40h]
  int n2; // [rsp+78h] [rbp+10h] BYREF
  __int64 v27; // [rsp+80h] [rbp+18h]

  v27 = a3;
  v4 = *(unsigned int *)(a1 + 0x11AC);
  v24 = v4;
  v5 = 0x20 * a3 + a1 + 0x10;
  v6 = a3;
  for ( i = sub_147604610((volatile signed __int64 *)v5); !i; i = sub_147604610((volatile signed __int64 *)v5) )
  {
    v10 = _InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 1, 0) - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        n2 = 2;
        qword_149B3B480(v5 + 0x18, &n2, 4, 0xFFFFFFFFLL);
      }
      else
      {
        v11 = *(_QWORD *)(v5 + 0x10);
        if ( !v11 || 0x2000000LL - *(_QWORD *)(v11 + 0x20) - v4 < a2 )
        {
          sub_147602270(v9, a2, v6);
          v9 = a1;
        }
        v12 = *(_QWORD *)(v5 + 0x10);
        v13 = v12 - v4 + 0x2000000;
        v14 = *(_QWORD *)(v12 + 0x20);
        v15 = v14 + v12;
        if ( v12 + v14 + 0x20 * a2 < v13 )
          v13 = v12 + v14 + 0x20 * a2;
        v16 = ~(v24 - 1) & (v13 - v12 + v4 - 1);
        v17 = *(_QWORD *)(v12 + 0x18);
        if ( v16 > v17 )
        {
          sub_14056DA40(v9 + 0x1198, v17 + v12, v16 - v17);
          *(_QWORD *)(v12 + 0x18) = v16;
        }
        *(_QWORD *)(v12 + 0x20) = v13 - v12;
        v18 = (_QWORD *)(v15 + a2 - 8);
        v19 = v15 + 2 * a2;
        v20 = 1;
        v21 = (signed __int64)v18;
        for ( *v18 = 0; v19 <= v13; v19 += a2 )
        {
          *(_QWORD *)(v19 - 8) = v21;
          ++v20;
          v21 = v19 - 8;
        }
        sub_1476047E0((volatile signed __int64 *)v5, v21, v18, v20);
        if ( _InterlockedExchange((volatile __int32 *)(v5 + 0x18), 0) == 2 )
          qword_149B3B490(v5 + 0x18);
        v6 = v27;
        v4 = v24;
      }
    }
    else if ( (unsigned int)(_InterlockedCompareExchange((volatile signed __int32 *)(v5 + 0x18), 2, 1) - 1) <= 1 )
    {
      n2_1 = 2;
      qword_149B3B480(v5 + 0x18, &n2_1, 4, 0xFFFFFFFFLL);
    }
  }
  return i - a2 + 8;
}

// --- End Function: sub_1476034A0 (0x1476034A0) ---

// --- Function: sub_147603A00 (0x147603A00) ---
__int64 __fastcall sub_147603A00(unsigned __int64 n0x10000, char a2)
{
  __int64 result; // rax

  if ( !a2 )
    goto LABEL_18;
  if ( n0x10000 <= 0x10000 )
    return 0x10000;
  if ( n0x10000 <= 0x20000 )
    return 0x20000;
  if ( n0x10000 <= 0x30000 )
    return 0x30000;
  if ( n0x10000 <= 0x40000 )
    return 0x40000;
  if ( n0x10000 <= 0x50000 )
    return 0x50000;
  if ( n0x10000 <= 0x60000 )
    return 0x60000;
  if ( n0x10000 <= 0x70000 )
    return 0x70000;
  if ( n0x10000 <= 0x80000 )
    return 0x80000;
LABEL_18:
  if ( n0x10000 <= 0xA0000 )
    return 0xA0000;
  if ( n0x10000 <= 0xC0000 )
    return 0xC0000;
  if ( n0x10000 <= 0xE0000 )
    return 0xE0000;
  if ( n0x10000 <= 0x100000 )
    return 0x100000;
  if ( n0x10000 <= 0x140000 )
    return 0x140000;
  if ( n0x10000 <= 0x180000 )
    return 0x180000;
  if ( n0x10000 <= 0x1C0000 )
    return 0x1C0000;
  if ( n0x10000 <= 0x200000 )
    return 0x200000;
  if ( n0x10000 <= 0x400000 )
    return 0x400000;
  if ( n0x10000 <= 0x600000 )
    return 0x600000;
  if ( n0x10000 <= 0x800000 )
    return 0x800000;
  if ( n0x10000 <= 0xA00000 )
    return 0xA00000;
  if ( n0x10000 <= 0xC00000 )
    return 0xC00000;
  if ( n0x10000 <= 0xE00000 )
    return 0xE00000;
  if ( n0x10000 <= 0x1000000 )
    return 0x1000000;
  if ( n0x10000 <= 0x1400000 )
    return 0x1400000;
  if ( n0x10000 <= 0x1800000 )
    return 0x1800000;
  if ( n0x10000 <= 0x1C00000 )
    return 0x1C00000;
  if ( n0x10000 <= 0x2000000 )
    return 0x2000000;
  if ( n0x10000 <= 0x2800000 )
    return 0x2800000;
  if ( n0x10000 <= 0x3000000 )
    return 0x3000000;
  if ( n0x10000 <= 0x3800000 )
    return 0x3800000;
  if ( n0x10000 <= 0x4000000 )
    return 0x4000000;
  if ( n0x10000 <= 0x5000000 )
    return 0x5000000;
  if ( n0x10000 <= 0x6000000 )
    return 0x6000000;
  if ( n0x10000 <= 0x7000000 )
    return 0x7000000;
  if ( n0x10000 <= 0x8000000 )
    return 0x8000000;
  if ( n0x10000 <= 0xA000000 )
    return 0xA000000;
  if ( n0x10000 <= 0xC000000 )
    return 0xC000000;
  if ( n0x10000 <= 0xE000000 )
    return 0xE000000;
  if ( n0x10000 <= 0x10000000 )
    return 0x10000000;
  if ( n0x10000 <= 0x14000000 )
    return 0x14000000;
  if ( n0x10000 <= 0x18000000 )
    return 0x18000000;
  if ( n0x10000 <= 0x1C000000 )
    return 0x1C000000;
  if ( n0x10000 <= 0x20000000 )
    return 0x20000000;
  if ( n0x10000 <= 0x28000000 )
    return 0x28000000;
  if ( n0x10000 <= 0x30000000 )
    return 0x30000000;
  if ( n0x10000 <= 0x38000000 )
    return 0x38000000;
  if ( n0x10000 <= 0x40000000 )
    return 0x40000000;
  if ( n0x10000 <= 0x50000000 )
    return 0x50000000;
  if ( n0x10000 <= 0x60000000 )
    return 0x60000000;
  if ( n0x10000 <= 0x70000000 )
    return 0x70000000;
  result = 0x80000000LL;
  if ( n0x10000 > 0x80000000 )
  {
    result = 0xA0000000LL;
    if ( n0x10000 > 0xA0000000 )
    {
      result = 0xC0000000LL;
      if ( n0x10000 > 0xC0000000 )
      {
        result = 0xE0000000LL;
        if ( n0x10000 > 0xE0000000 )
        {
          result = 0x100000000LL;
          if ( n0x10000 > 0x100000000LL )
          {
            result = 0x180000000LL;
            if ( n0x10000 > 0x180000000LL )
            {
              result = 0x200000000LL;
              if ( n0x10000 > 0x200000000LL )
              {
                result = 0x280000000LL;
                if ( n0x10000 > 0x280000000LL )
                {
                  result = 0x300000000LL;
                  if ( n0x10000 > 0x300000000LL )
                  {
                    result = 0x380000000LL;
                    if ( n0x10000 > 0x380000000LL )
                    {
                      result = 0x400000000LL;
                      if ( n0x10000 > 0x400000000LL )
                      {
                        result = 0x500000000LL;
                        if ( n0x10000 > 0x500000000LL )
                        {
                          result = 0x600000000LL;
                          if ( n0x10000 > 0x600000000LL )
                          {
                            result = 0x700000000LL;
                            if ( n0x10000 > 0x700000000LL )
                            {
                              result = 0x800000000LL;
                              if ( n0x10000 > 0x800000000LL )
                              {
                                result = 0xA00000000LL;
                                if ( n0x10000 > 0xA00000000LL )
                                {
                                  result = 0xC00000000LL;
                                  if ( n0x10000 > 0xC00000000LL )
                                  {
                                    result = 0xE00000000LL;
                                    if ( n0x10000 > 0xE00000000LL )
                                    {
                                      result = 0x1000000000LL;
                                      if ( n0x10000 > 0x1000000000LL )
                                      {
                                        result = 0x1400000000LL;
                                        if ( n0x10000 > 0x1400000000LL )
                                        {
                                          result = 0x1800000000LL;
                                          if ( n0x10000 > 0x1800000000LL )
                                          {
                                            result = 0x1C00000000LL;
                                            if ( n0x10000 > 0x1C00000000LL )
                                            {
                                              result = 0x2000000000LL;
                                              if ( n0x10000 > 0x2000000000LL )
                                              {
                                                result = 0x2800000000LL;
                                                if ( n0x10000 > 0x2800000000LL )
                                                {
                                                  result = 0x3000000000LL;
                                                  if ( n0x10000 > 0x3000000000LL )
                                                  {
                                                    result = 0x3800000000LL;
                                                    if ( n0x10000 > 0x3800000000LL )
                                                    {
                                                      result = 0x4000000000LL;
                                                      if ( n0x10000 > 0x4000000000LL )
                                                      {
                                                        _XMM0 = 0;
                                                        if ( (n0x10000 & 0x8000000000000000uLL) != 0LL )
                                                        {
                                                          __asm { vcvtsi2sd xmm0, xmm0, rax }
                                                          *(double *)&_XMM0 = *(double *)&_XMM0 + *(double *)&_XMM0;
                                                        }
                                                        else
                                                        {
                                                          __asm { vcvtsi2sd xmm0, xmm0, rcx }
                                                        }
                                                        LogFatalError(
                                                          "StarAlloc: Requested Allocation Size %.2f MB is larger than su"
                                                          "pported by StarAlloc",
                                                          *(double *)&_XMM0 * 0.00000095367431640625);
                                                        return 0;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_147603A00 (0x147603A00) ---

// --- Function: sub_1476044E0 (0x1476044E0) ---
__int64 __fastcall sub_1476044E0(__int64 *a1, __int64 a2, __int64 *a3)
{
  double v3; // r9
  __int128 v4; // xmm0
  double v5; // xmm1_8
  unsigned __int128 v7; // rax
  __int128 v8; // xmm0
  __int64 result; // rax
  double *v10; // [rsp+40h] [rbp-58h] BYREF
  __int128 *v11; // [rsp+48h] [rbp-50h] BYREF
  __int128 v12; // [rsp+50h] [rbp-48h] BYREF
  char v13; // [rsp+60h] [rbp-38h]
  double v14; // [rsp+68h] [rbp-30h] BYREF
  __int128 v15; // [rsp+70h] [rbp-28h] BYREF
  double v16; // [rsp+80h] [rbp-18h]

  v3 = *(double *)a3;
  v4 = *(_OWORD *)(a3 + 1);
  v5 = *((double *)a3 + 3);
  v10 = &v14;
  v14 = v3;
  v11 = &v15;
  v15 = v4;
  v7 = 0x100000001B3LL
     * (HIBYTE(*(_QWORD *)&v3)
      ^ (0x100000001B3LL
       * (BYTE6(v3)
        ^ (0x100000001B3LL
         * (BYTE5(v3)
          ^ (0x100000001B3LL
           * (BYTE4(v3)
            ^ (0x100000001B3LL
             * (BYTE3(v3)
              ^ (0x100000001B3LL
               * (BYTE2(v3) ^ (0x100000001B3LL * ((0x100000001B3LL * (LOBYTE(v3) ^ 0xCBF29CE484222325uLL)) ^ BYTE1(v3))))))))))))))
     * (unsigned __int128)0xDE5FB9D2630458E9uLL;
  v16 = v5;
  sub_147601A00(
    a1,
    (__int64)&v12,
    &v14,
    v7 + *((_QWORD *)&v7 + 1),
    (int)&byte_14819E9C1,
    (_QWORD **)&v10,
    (__int64 *)&v11);
  v8 = v12;
  *(_BYTE *)(a2 + 0x10) = v13;
  result = a2;
  *(_OWORD *)a2 = v8;
  return result;
}

// --- End Function: sub_1476044E0 (0x1476044E0) ---

// --- Function: sub_147604610 (0x147604610) ---
__int64 __fastcall sub_147604610(volatile signed __int64 *a1)
{
  __m128i v1; // rt0
  __m128i v2; // xmm0
  signed __int64 epi64; // r8
  __int64 v4; // rax
  __int32 v5; // edx
  __m128i v6; // rt0
  signed __int64 v8; // [rsp+18h] [rbp-40h]
  __m128i v9; // [rsp+30h] [rbp-28h]

  v1 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v1.m128i_i64);
  v2 = v1;
  if ( !v1.m128i_i64[0] )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v2, 1);
    LODWORD(v8) = epi64 + 1;
    HIDWORD(v8) = HIDWORD(epi64) - 1;
    v6.m128i_i64[0] = v2.m128i_i64[0];
    v6.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v8, *(_QWORD *)v2.m128i_i64[0], v6.m128i_i64);
    v4 = v6.m128i_i64[0];
    v5 = v6.m128i_i32[2];
    v9 = v6;
    if ( v6.m128i_i64[0] == v2.m128i_i64[0] && v5 == (_DWORD)epi64 )
      break;
    v2 = v9;
    if ( !v4 )
      return 0;
  }
  return v2.m128i_i64[0];
}

// --- End Function: sub_147604610 (0x147604610) ---

// --- Function: sub_1476047E0 (0x1476047E0) ---
__int64 __fastcall sub_1476047E0(volatile signed __int64 *a1, signed __int64 a2, _QWORD *a3, int a4)
{
  __m128i v6; // rt0
  __m128i i; // xmm0
  signed __int64 epi64; // r9
  __int64 result; // rax
  __int32 v10; // edx
  __m128i v11; // rt0
  signed __int64 v12; // [rsp+18h] [rbp-50h]
  __m128i v13; // [rsp+30h] [rbp-38h]

  v6 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v6.m128i_i64);
  for ( i = v6; ; i = v13 )
  {
    epi64 = _mm_extract_epi64(i, 1);
    *a3 = i.m128i_i64[0];
    LODWORD(v12) = epi64 + 1;
    HIDWORD(v12) = a4 + HIDWORD(epi64);
    v11.m128i_i64[0] = i.m128i_i64[0];
    v11.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v12, a2, v11.m128i_i64);
    result = v11.m128i_i64[0];
    v10 = v11.m128i_i32[2];
    v13 = v11;
    if ( v11.m128i_i64[0] == i.m128i_i64[0] && v10 == (_DWORD)epi64 )
      break;
  }
  return result;
}

// --- End Function: sub_1476047E0 (0x1476047E0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: ?_Xbad_function_call@std@@YAXXZ (0x14803279A) ---
// attributes: thunk
void std::_Xbad_function_call(void)
{
  __imp_?_Xbad_function_call@std@@YAXXZ();
}

// --- End Function: ?_Xbad_function_call@std@@YAXXZ (0x14803279A) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
// Standard stack security check function. Compares the provided stack cookie with
// the global security cookie. If a mismatch is detected or the cookie is
// corrupted, it triggers a security failure report.
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6320);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6336);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6320) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 6320);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __raise_securityfailure (0x1480338C8) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x1480338C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: capture_previous_context (0x148033AF0) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x148033AF0) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: strrchr (0x14808213D) ---
// attributes: thunk
char *__cdecl strrchr(const char *Str, int Ch)
{
  return __imp_strrchr(Str, Ch);
}

// --- End Function: strrchr (0x14808213D) ---

// --- Function: strchr (0x148082143) ---
// attributes: thunk
char *__cdecl strchr(const char *Str, int Val)
{
  return __imp_strchr(Str, Val);
}

// --- End Function: strchr (0x148082143) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: _CxxThrowException (0x14808217F) ---
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}

// --- End Function: _CxxThrowException (0x14808217F) ---

// --- Function: free_0 (0x1480821F7) ---
// attributes: thunk
void __cdecl free_0(void *Block)
{
  free(Block);
}

// --- End Function: free_0 (0x1480821F7) ---

// --- Function: malloc_0 (0x1480821FD) ---
// attributes: thunk
void *__cdecl malloc_0(size_t Size)
{
  return malloc(Size);
}

// --- End Function: malloc_0 (0x1480821FD) ---

// --- Function: sub_1480BE950 (0x1480BE950) ---
__int64 sub_1480BE950()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = NtCurrentTeb_w();
  sub_1402A3D30(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = NtCurrentTeb_w();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0;
  return result;
}

// --- End Function: sub_1480BE950 (0x1480BE950) ---

