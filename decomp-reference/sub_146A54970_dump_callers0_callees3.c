// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146A54970 (sub_146A54970)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 7
// ------------------------------------------------------------

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 get_thread_context_ptr()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: rw_lock_acquire_read_lock_dispatch (0x1403CB300) ---
// Dispatches to either a profiled read lock acquisition function
// (`rw_lock_acquire_read_lock_profiled`) or a standard, unprofiled one
// (`rw_lock_acquire_read_lock_unprofiled`). The choice depends on a boolean flag
// (`is_profiled_mode`), a debug flag within the thread context (at offset `0x1C`),
// and the availability of the global environment (`gEnv`).
double __fastcall rw_lock_acquire_read_lock_dispatch(
        __int64 p_rw_lock_state,
        signed __int64 current_lock_value,
        const char *caller_name,
        const char *lock_name,
        char is_profiled_mode)
{
  if ( is_profiled_mode && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_read_lock_profiled(p_rw_lock_state, current_lock_value, caller_name, lock_name);
  else
    return rw_lock_acquire_read_lock_unprofiled(p_rw_lock_state, current_lock_value, caller_name, lock_name);
}

// --- End Function: rw_lock_acquire_read_lock_dispatch (0x1403CB300) ---

// --- Function: rw_lock_acquire_read_lock_profiled (0x1403CB380) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`, incorporating the current thread's ID as the
// lock owner. If the lock is contended, it retries. Upon successful acquisition,
// it logs detailed profiling information, including timestamps, lock name, lock
// owner, and caller, using a dedicated profiling system.
double __fastcall rw_lock_acquire_read_lock_profiled(
        __int64 p_rw_lock_state,
        signed __int64 current_lock_value,
        const char *caller_name,
        const char *lock_name)
{
  __int64 p_profiler_system; // r14
  __int64 thread_context_ptr; // rax
  __int64 p_thread_data; // rsi
  unsigned int thread_id; // r15d
  unsigned __int64 new_lock_value_with_thread_id; // rdx
  bool is_exchange_successful; // zf
  signed __int64 current_lock_value_1; // rax
  __int16 profiler_flags; // ax
  signed __int64 current_lock_value_2; // rax
  const ULONG_PTR *lock_owner_name_string_ptr; // rdx
  double result; // xmm0_8
  _BYTE profiler_data_buffer[16]; // [rsp+30h] [rbp-29h] BYREF
  int profiler_event_type; // [rsp+40h] [rbp-19h] BYREF
  __int64 profiler_event_flags; // [rsp+44h] [rbp-15h]
  int profiler_event_level; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 start_timestamp; // [rsp+50h] [rbp-9h]
  unsigned __int64 end_timestamp; // [rsp+58h] [rbp-1h]
  __int64 profiler_data_ptr_1; // [rsp+60h] [rbp+7h]
  __int64 profiler_data_ptr_2; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  p_profiler_system = ::p_profiler_system;
  thread_context_ptr = get_thread_context_ptr();
  p_thread_data = *(_QWORD *)thread_context_ptr;
  thread_id = *(_DWORD *)(*(_QWORD *)thread_context_ptr + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
    p_profiler_system,
    profiler_data_buffer,
    &v27);
  if ( (current_lock_value & 0x200000) == 0 )
    return result;
  new_lock_value_with_thread_id = (unsigned __int64)thread_id << 0x20;
  while ( (current_lock_value & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(p_thread_data + 0x124) = WORD2(current_lock_value);
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value_with_thread_id | current_lock_value & 0xFFFF0000FFFFFFFFuLL,
                             current_lock_value);
    is_exchange_successful = current_lock_value == current_lock_value_1;
    current_lock_value = current_lock_value_1;
    if ( is_exchange_successful )
    {
      profiler_event_type = 0x1600;
      end_timestamp = 0;
      profiler_data_ptr_1 = 0;
      profiler_data_ptr_2 = 0;
      profiler_event_flags = 1;
      profiler_event_level = 2;
      start_timestamp = __rdtsc();
      isProfileFunctionsInitialized(
        &profiler_event_type,
        &::profiler_flags,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      profiler_flags = ::profiler_flags;
      goto LABEL_10;
    }
LABEL_7:
    if ( (current_lock_value & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(p_thread_data + 0x124) = 0xFFFFFFFF;
  current_lock_value_2 = _InterlockedCompareExchange64(
                           (volatile signed __int64 *)p_rw_lock_state,
                           current_lock_value | new_lock_value_with_thread_id,
                           current_lock_value);
  is_exchange_successful = current_lock_value == current_lock_value_2;
  current_lock_value = current_lock_value_2;
  if ( !is_exchange_successful )
    goto LABEL_7;
  profiler_event_type = 0x1600;
  end_timestamp = 0;
  profiler_data_ptr_1 = 0;
  profiler_data_ptr_2 = 0;
  profiler_event_flags = 1;
  profiler_event_level = 2;
  start_timestamp = __rdtsc();
  isProfileFunctionsInitialized(
    &profiler_event_type,
    &profiler_flags_0,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  profiler_flags = profiler_flags_0;
LABEL_10:
  HIWORD(profiler_event_type) = profiler_flags;
  qword_149B4B8B0("Lock: %s", lock_name);
  lock_owner_name_string_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(p_rw_lock_state + 8) )
    lock_owner_name_string_ptr = *(const ULONG_PTR **)(p_rw_lock_state + 8);
  qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr);
  qword_149B4B8B0("Caller: %s", caller_name);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(p_profiler_system, thread_id);
  end_timestamp = __rdtsc();
  return qword_149B4B878(&profiler_event_type);
}

// --- End Function: rw_lock_acquire_read_lock_profiled (0x1403CB380) ---

// --- Function: rw_lock_acquire_read_lock_unprofiled (0x1403CB5B0) ---
// Acquires a read lock on the provided lock structure (`p_rw_lock_state`). It
// enters a loop, waiting if the lock is currently held in a conflicting state
// (e.g., by a writer). It then attempts to atomically set the read lock flag using
// `_InterlockedCompareExchange64`. Upon successful acquisition, it logs basic
// information about the lock, its owner, and the caller. This version does not
// include detailed performance profiling.
double __fastcall rw_lock_acquire_read_lock_unprofiled(
        __int64 p_rw_lock_state,
        signed __int64 rw_lock_state_2,
        const char *caller_name,
        const char *lock_name)
{
  signed __int64 rw_lock_state; // rbx
  const ULONG_PTR *lock_owner_name_string_ptr_1; // rdx
  int *p_profiler_event_type; // rcx
  int new_lock_value; // edi
  bool is_exchange_successful; // zf
  signed __int64 rw_lock_state_3; // rax
  const ULONG_PTR *lock_owner_name_string_ptr_2; // rdx
  double result; // xmm0_8
  int rw_lock_state_1; // [rsp+30h] [rbp-69h] BYREF
  _DWORD lock_state_val_2[3]; // [rsp+34h] [rbp-65h] BYREF
  int profiler_event_type_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 profiler_event_flags_1; // [rsp+44h] [rbp-55h]
  int profiler_event_level_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 start_timestamp_1; // [rsp+50h] [rbp-49h]
  unsigned __int64 end_timestamp_1; // [rsp+58h] [rbp-41h]
  __int64 profiler_data_ptr_1_1; // [rsp+60h] [rbp-39h]
  __int64 profiler_data_ptr_2_1; // [rsp+68h] [rbp-31h]
  int profiler_event_type_2; // [rsp+90h] [rbp-9h] BYREF
  __int64 profiler_event_flags_2; // [rsp+94h] [rbp-5h]
  int profiler_event_level_2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 start_timestamp_2; // [rsp+A0h] [rbp+7h]
  unsigned __int64 end_timestamp_2; // [rsp+A8h] [rbp+Fh]
  __int64 profiler_data_ptr_1_2; // [rsp+B0h] [rbp+17h]
  __int64 profiler_data_ptr_2_2; // [rsp+B8h] [rbp+1Fh]

  if ( (rw_lock_state_2 & 0x200000) != 0 )
  {
    rw_lock_state = rw_lock_state_2;
    while ( 1 )
    {
      if ( (rw_lock_state & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)p_profiler_system + 0x128LL))(
          p_profiler_system,
          p_rw_lock_state);
      if ( (rw_lock_state & 0x100000) != 0 )
        break;
      new_lock_value = rw_lock_state | 0x100000;
      rw_lock_state_3 = _InterlockedCompareExchange64(
                          (volatile signed __int64 *)p_rw_lock_state,
                          rw_lock_state | 0x100000,
                          rw_lock_state);
      is_exchange_successful = rw_lock_state == rw_lock_state_3;
      rw_lock_state = rw_lock_state_3;
      if ( is_exchange_successful )
      {
        profiler_event_type_2 = 0x1600;
        profiler_event_flags_2 = 1;
        profiler_event_level_2 = 2;
        end_timestamp_2 = 0;
        profiler_data_ptr_1_2 = 0;
        profiler_data_ptr_2_2 = 0;
        start_timestamp_2 = __rdtsc();
        isProfileFunctionsInitialized(
          &profiler_event_type_2,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(profiler_event_type_2) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", lock_name);
        lock_owner_name_string_ptr_2 = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(p_rw_lock_state + 8) )
          lock_owner_name_string_ptr_2 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
        qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_2);
        qword_149B4B8B0("Caller: %s", caller_name);
        lock_state_val_2[0] = new_lock_value;
        qword_149B3B480(p_rw_lock_state, lock_state_val_2, 4, 0xFFFFFFFFLL);
        rw_lock_state = *(_QWORD *)p_rw_lock_state;
        p_profiler_event_type = &profiler_event_type_2;
        end_timestamp_2 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (rw_lock_state & 0x200000) == 0 )
        return result;
    }
    profiler_event_type_1 = 0x1600;
    profiler_event_flags_1 = 1;
    profiler_event_level_1 = 2;
    end_timestamp_1 = 0;
    profiler_data_ptr_1_1 = 0;
    profiler_data_ptr_2_1 = 0;
    start_timestamp_1 = __rdtsc();
    isProfileFunctionsInitialized(
      &profiler_event_type_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(profiler_event_type_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", lock_name);
    lock_owner_name_string_ptr_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(p_rw_lock_state + 8) )
      lock_owner_name_string_ptr_1 = *(const ULONG_PTR **)(p_rw_lock_state + 8);
    qword_149B4B8B0("LockOwner: %s", lock_owner_name_string_ptr_1);
    qword_149B4B8B0("Caller: %s", caller_name);
    rw_lock_state_1 = rw_lock_state;
    qword_149B3B480(p_rw_lock_state, &rw_lock_state_1, 4, 0xFFFFFFFFLL);
    rw_lock_state = *(_QWORD *)p_rw_lock_state;
    p_profiler_event_type = &profiler_event_type_1;
    end_timestamp_1 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_profiler_event_type);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: rw_lock_acquire_read_lock_unprofiled (0x1403CB5B0) ---

// --- Function: rw_lock_handle_release_contention (0x1403CB820) ---
// Handles the release of a read-write lock when contention or specific lock flags
// are present. It continuously attempts to atomically update the lock state using
// `_InterlockedCompareExchange64`. Depending on the resulting lock state, it may
// trigger further release operations (e.g., waking waiting threads via
// `qword_149B3B488`) or update thread context information related to lock
// ownership and counts.
__int64 __fastcall rw_lock_handle_release_contention(
        volatile signed __int64 *p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  unsigned __int64 new_lock_value; // rdx
  unsigned int lock_owner_thread_id; // r8d
  __int64 current_lock_value_1; // rax
  unsigned __int64 lock_thread_id_high_word; // rbx
  int thread_context_info_1; // [rsp+60h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+68h] [rbp+10h] BYREF
  __int64 thread_context_ptr_1; // [rsp+70h] [rbp+18h] BYREF
  __int64 thread_context_ptr_2; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value;
    if ( (current_lock_value & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
        p_profiler_system,
        &thread_context_ptr_1,
        &thread_context_info_1);
      new_lock_value = current_lock_value & 0xFFFFFFFFFFFFLL;
      lock_owner_thread_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_1 - 1)) << 9)
                                       + thread_context_ptr_1
                                       + 0x124);
      if ( lock_owner_thread_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)lock_owner_thread_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(p_rw_lock_state, new_lock_value, current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    if ( (current_lock_value_1 & 0x3FF) != 0
      || (current_lock_value_1 & 0x200000) != 0
      || (current_lock_value_1 & 0xFFFF0000FFC00000uLL) == 0 )
    {
      return current_lock_value_1;
    }
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0xFFC00000) != 0 )
    return qword_149B3B488(p_rw_lock_state);
  current_lock_value_1 = 0xFFFF000000000000uLL;
  if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
      p_profiler_system,
      &thread_context_ptr_2,
      &thread_context_info_2);
    lock_thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)lock_thread_id_high_word & (thread_context_info_2 - 1)) << 9)
              + thread_context_ptr_2
              + 0x11C) = (unsigned __int16)(lock_thread_id_high_word + thread_context_info_2);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xD8LL))(
             p_profiler_system,
             (unsigned int)lock_thread_id_high_word);
  }
  return current_lock_value_1;
}

// --- End Function: rw_lock_handle_release_contention (0x1403CB820) ---

// --- Function: sub_146A2FA80 (0x146A2FA80) ---
// /* This function recursively searches for a component name within a tree-like
// data structure. Each node in the tree is structured as follows:   - Offset +0x0:
// uint16_t component_id (or similar identifier)   - Offset +0x2: uint16_t
// name_length   - Offset +0x4: uint32_t child_offset (offset to a child node,
// 0xFFFFFFFF if no child)   - Offset +0x8: uint32_t sibling_offset (offset to a
// sibling node, 0xFFFFFFFF if no sibling)   - Offset +0xC: char
// name_data[name_length]  The search proceeds by comparing the current node's name
// with a segment of the `search_name_ptr`. If a match is found for the current
// segment, it either returns the node address (if the entire `search_name_ptr` has
// been consumed) or recursively searches a child node with the remaining
// `search_name_ptr`. If no match or the child search fails, it attempts to search
// sibling nodes.  Args:   tree_context_ptr: Pointer to a structure containing the
// base address of the component tree data at `tree_context_ptr + 0x10`.
// current_node_offset: The offset from the tree data base address to the current
// node being examined.   search_name_ptr: Pointer to the byte string (component
// name or path segment) to search for.   search_name_len: The length of the
// `search_name_ptr`.  Returns:   The base address of the matched component node if
// found, otherwise 0. */
__int64 __fastcall sub_146A2FA80(__int64 a1, unsigned int a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v6; // r10
  _BYTE *v7; // rdx
  _BYTE *v8; // rbp
  unsigned __int64 v9; // rsi
  __int64 result; // rax
  unsigned int v11; // ebx

  v4 = *(_QWORD *)(a1 + 0x10) + a2;
  v6 = *(unsigned __int16 *)(v4 + 2);
  if ( v6 > a4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) )
  {
    v7 = a3;
    while ( v7[v4 + 0xC - (_QWORD)a3] == *v7 )
    {
      if ( ++v7 - a3 >= v6 )
        goto LABEL_6;
    }
    return 0;
  }
LABEL_6:
  v8 = &a3[v6];
  v9 = a4 - v6;
  if ( a4 == v6 )
    return v4;
  v11 = *(_DWORD *)(v4 + 4);
  if ( v11 == 0xFFFFFFFF )
    return 0;
  while ( 1 )
  {
    result = sub_146A2FA80(a1, v11, v8, v9);
    if ( result )
      break;
    v11 = *(_DWORD *)(v11 + *(_QWORD *)(a1 + 0x10) + 8LL);
    if ( v11 == 0xFFFFFFFF )
      return 0;
  }
  return result;
}

// --- End Function: sub_146A2FA80 (0x146A2FA80) ---

// --- Function: sub_146A54970 (0x146A54970) ---
_QWORD *__fastcall sub_146A54970(__int64 a1, _QWORD *a2, char *a3)
{
  unsigned __int64 n0xA; // rax
  unsigned int v7; // eax
  __int64 v8; // r10
  __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  volatile signed __int64 *p_rw_lock_state; // rsi
  signed __int64 v12; // rdx
  unsigned __int64 v13; // r9
  unsigned __int16 *v14; // rax
  unsigned int v15; // eax
  unsigned __int64 current_lock_value; // rbx

  n0xA = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n0xA;
  while ( a3[n0xA] );
  if ( n0xA >= 0xA )
  {
    p_rw_lock_state = (volatile signed __int64 *)(a1 + 0x120);
    v12 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x120));
    if ( (v12 & 0x200000) != 0 )
      rw_lock_acquire_read_lock_dispatch(
        a1 + 0x120,
        v12,
        "CTagDatabase::GetTagFromGUID",
        "m_tagDatabaseModificationLock",
        1);
    if ( !*(_DWORD *)(a1 + 0x28) )
      goto LABEL_23;
    v13 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v13;
    while ( a3[v13] );
    v14 = (unsigned __int16 *)sub_146A2FA80(a1 + 0x20, 0, a3, v13);
    if ( v14 && (v15 = *v14, (_WORD)v15 != 0xFFFF) )
    {
      *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL * v15);
    }
    else
    {
LABEL_23:
      *a2 = 0;
      *(_WORD *)a2 = 0xFFFF;
    }
    current_lock_value = _InterlockedDecrement64(p_rw_lock_state);
    if ( (current_lock_value & 0x3FF) == 0 && (current_lock_value & 0xFFFF0000FFC00000uLL) != 0 )
      rw_lock_handle_release_contention(p_rw_lock_state, current_lock_value);
  }
  else
  {
    v7 = atoi(a3);
    v8 = *(_QWORD *)(a1 + 0x110);
    v9 = *(_QWORD *)(a1 + 0x108);
    v10 = (v8 - v9) >> 3;
    while ( v10 )
    {
      if ( *(_DWORD *)(v9 + 8 * (v10 >> 1)) >= v7 )
      {
        v10 >>= 1;
      }
      else
      {
        v9 += 8 * (v10 >> 1) + 8;
        v10 += 0xFFFFFFFFFFFFFFFFuLL - (v10 >> 1);
      }
    }
    if ( v9 == v8 )
      goto LABEL_13;
    if ( v7 < *(_DWORD *)v9 )
      v9 = *(_QWORD *)(a1 + 0x110);
    if ( v9 == v8 )
    {
LABEL_13:
      *a2 = 0;
      *(_WORD *)a2 = 0xFFFF;
    }
    else
    {
      *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL * *(unsigned __int16 *)(v9 + 4));
    }
  }
  return a2;
}

// --- End Function: sub_146A54970 (0x146A54970) ---

