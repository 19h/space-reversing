// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1433EAFD0 (sub_1433EAFD0)
// Caller Depth: 3
// Callee/Ref Depth: 5
// Total Functions Found: 19
// ------------------------------------------------------------

// --- Function: sub_140334DC0 (0x140334DC0) ---
__int64 __fastcall sub_140334DC0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_140334DC0 (0x140334DC0) ---

// --- Function: sub_140526930 (0x140526930) ---
unsigned __int64 __fastcall sub_140526930(__int64 a1)
{
  unsigned __int64 result; // rax

  result = (*(_QWORD *)(a1 + 8) + 0x27LL) & 0xFFFFFFFFFFFFFFF8uLL;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

// --- End Function: sub_140526930 (0x140526930) ---

// --- Function: sub_140526B10 (0x140526B10) ---
void __fastcall sub_140526B10(__int64 a1)
{
  ++*(_QWORD *)(a1 + 8);
}

// --- End Function: sub_140526B10 (0x140526B10) ---

// --- Function: sub_140527000 (0x140527000) ---
unsigned __int64 __fastcall sub_140527000(__int64 a1, __int64 a2, unsigned int *a3)
{
  __int64 v3; // r9
  unsigned int v4; // xmm0_4
  __int64 v5; // r8
  unsigned int v6; // eax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  bool v9; // cc
  unsigned __int64 result; // rax
  unsigned __int64 v11; // r8

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *a3;
  v5 = 0;
  v6 = *(unsigned __int8 *)(v3 + 0x18);
  v7 = (unsigned __int64)(*(_QWORD *)(v3 + 0x10) + 7LL) >> 3;
  v8 = 8 * v7 + 0x20;
  v9 = v8 <= *(_QWORD *)(v3 + 8);
  *(_QWORD *)(v3 + 0x10) = v8;
  if ( v9 )
    v5 = v6;
  result = v7 + *(_QWORD *)v3;
  v11 = result * v5;
  if ( v11 )
  {
    result = v4;
    *(_DWORD *)v11 = v4;
  }
  return result;
}

// --- End Function: sub_140527000 (0x140527000) ---

// --- Function: sub_140527370 (0x140527370) ---
int __fastcall sub_140527370(__int64 a1, __int64 a2, char *a3)
{
  __int64 v3; // rdx
  __int64 v4; // r9
  char v5; // r10
  unsigned __int64 v6; // r8
  unsigned int v7; // eax
  bool v8; // cc
  unsigned __int64 v9; // rax
  __int64 v10; // r9
  char v11; // r8

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 0;
  v5 = *a3;
  v6 = *(_QWORD *)(v3 + 0x10);
  v7 = *(unsigned __int8 *)(v3 + 0x18);
  v8 = v6 + 1 <= *(_QWORD *)(v3 + 8);
  *(_QWORD *)(v3 + 0x10) = v6 + 1;
  if ( v8 )
    v4 = v7;
  v9 = *(_QWORD *)v3 + (v6 >> 3);
  v10 = v9 * v4;
  if ( v10 )
  {
    v11 = v6 & 7;
    LODWORD(v9) = *(unsigned __int8 *)v10 & ~(1 << v11);
    LOBYTE(v9) = (v5 << v11) | v9;
    *(_BYTE *)v10 = v9;
  }
  return v9;
}

// --- End Function: sub_140527370 (0x140527370) ---

// --- Function: sub_140598C00 (0x140598C00) ---
_QWORD *__fastcall sub_140598C00(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 - *a3;
  return a2;
}

// --- End Function: sub_140598C00 (0x140598C00) ---

// --- Function: sub_140598DA0 (0x140598DA0) ---
__m128 sub_140598DA0()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.0000001;
  return (__m128)v3;
}

// --- End Function: sub_140598DA0 (0x140598DA0) ---

// --- Function: sub_1411D16B0 (0x1411D16B0) ---
__int64 __fastcall sub_1411D16B0(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))a1)(a2, *(_QWORD *)(a1 + 0x10), *(_QWORD *)(a1 + 8));
}

// --- End Function: sub_1411D16B0 (0x1411D16B0) ---

// --- Function: sub_1433A65F0 (0x1433A65F0) ---
__int64 __fastcall sub_1433A65F0(__int64 a1, float a2, unsigned __int8 a3)
{
  __int64 v4; // rbx
  __int64 *v5; // rbx
  __int16 v6; // dx
  __int64 v7; // rax
  __int64 result; // rax
  __int64 v9; // rdx
  __int64 v10; // r8
  unsigned int v11; // ebx
  void (__fastcall *v12)(int *, __int64, _QWORD); // rax
  unsigned __int8 v13; // [rsp+30h] [rbp-39h] BYREF
  _BYTE v14[8]; // [rsp+38h] [rbp-31h] BYREF
  float v15; // [rsp+40h] [rbp-29h] BYREF
  void *(__fastcall **v16)(std::_Iostream_error_category2 *__hidden, unsigned int); // [rsp+48h] [rbp-21h] BYREF
  __int64 v17; // [rsp+50h] [rbp-19h]
  _QWORD v18[2]; // [rsp+58h] [rbp-11h] BYREF
  _QWORD v19[4]; // [rsp+68h] [rbp-1h] BYREF
  int v20; // [rsp+88h] [rbp+1Fh] BYREF
  __int128 v21; // [rsp+90h] [rbp+27h]

  v13 = a3;
  v15 = a2;
  v20 = 0;
  v4 = *(_QWORD *)(a1 + 0x20);
  v14[0] = 0;
  v21 = xmmword_148699188;
  v5 = (__int64 *)(v4 & 0xFFFFFFFFFFFFLL);
  if ( !v5 )
    return 1;
  v17 = 0;
  v16 = &off_1480EC218;
  sub_140526930((__int64)&v16);
  sub_140526B10((__int64)&v16);
  v6 = *(_WORD *)(a1 + 0x28);
  v7 = *v5;
  v19[0] = sub_1433F4B30;
  v19[1] = &v13;
  v19[2] = &v15;
  v18[0] = v19;
  v18[1] = sub_1411D16B0;
  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, int *, __int64, _QWORD *, _BYTE *))(v7 + 8))(
             v5,
             v6 & 0x3FFF,
             &v20,
             v17,
             v18,
             v14);
  v11 = result;
  if ( v14[0] )
  {
    v12 = *(void (__fastcall **)(int *, __int64, _QWORD))(a1 + 8);
    if ( *(_QWORD *)(a1 + 0x10) == 1 )
      v12(&v20, v9, v13);
    else
      ((void (__fastcall *)(__int64, int *, __int64, _QWORD))v12)(a1 + 8, &v20, v10, v13);
    return v11;
  }
  return result;
}

// --- End Function: sub_1433A65F0 (0x1433A65F0) ---

// --- Function: sub_1433EAFD0 (0x1433EAFD0) ---
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_1433EAFD0(__int64 a1, double a2, char a3, unsigned __int8 a4, char a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int128 v9; // xmm11
  __int64 result; // rax
  __int64 v15; // rdx
  float v17; // xmm8_4
  float v18; // xmm11_4
  int v21; // eax
  int v22; // ebx
  __int128 v23; // xmm6
  __int128 n0x3F800000; // xmm9
  float v25; // xmm10_4
  __int128 n0x42700000; // kr00_16
  __int128 n0x3F800000_1; // kr00_16
  __int128 n0x3F800000_2; // xmm1
  __int128 v33; // kr00_16
  __int128 v35; // kr00_16
  __int64 v36; // rax
  __int64 v37; // rdx
  __int128 v38; // kr00_16
  __int64 v41; // [rsp+20h] [rbp-78h] BYREF
  __int64 v42; // [rsp+28h] [rbp-70h] BYREF
  __int128 v43; // [rsp+30h] [rbp-68h]
  __int128 v44; // [rsp+40h] [rbp-58h]
  __int128 v45; // [rsp+50h] [rbp-48h]
  __int128 v46; // [rsp+60h] [rbp-38h]
  __int128 v47; // [rsp+80h] [rbp-18h]

  v47 = v5;
  _XMM6 = *(_OWORD *)&a2;
  result = sub_140334DC0(a1);
  if ( *(_QWORD *)(result + 0x28) )
  {
    if ( a3 )
    {
      LODWORD(_XMM1) = *(_DWORD *)(sub_140334DC0(a1) + 0x34);
      if ( *(float *)&_XMM6 >= *(float *)&_XMM1 )
        __asm { vminss  xmm1, xmm6, cs:Y }
      *(float *)(a1 + 0x98) = *(float *)&_XMM1;
      return sub_1433A65F0(a1 + 0xC0, v15, a4);
    }
    else
    {
      v46 = v6;
      v43 = v9;
      if ( a5 )
        v17 = *(float *)(*(_QWORD *)(sub_140334DC0(a1) + 0x28) + 0x18LL);
      else
        v17 = 1.0;
      v18 = (float)(v17 * *(float *)(*(_QWORD *)(sub_140334DC0(a1) + 0x28) + 0xCLL)) * *(float *)&a2;
      v41 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149A14250 + 0x38LL))(
                         qword_149A14250,
                         0);
      sub_140598C00(&v41, &v42, (_QWORD *)(a1 + 0xB0));
      _XMM0 = sub_140598DA0();
      *(_QWORD *)(a1 + 0xB0) = v41;
      __asm { vcvtsd2ss xmm8, xmm0, xmm0 }
      v21 = (*(__int64 (__fastcall **)(_LocaleUpdate *))(*(_QWORD *)qword_149A142E8 + 0x538LL))(qword_149A142E8);
      v22 = v21 - *(_DWORD *)(a1 + 0xB8);
      *(_DWORD *)(a1 + 0xB8) = v21;
      v23 = 0;
      if ( *(float *)(*(_QWORD *)(sub_140334DC0(a1) + 0x28) + 0x10LL) > 0.0
        && *(float *)&_XMM8 < *(float *)(*(_QWORD *)(sub_140334DC0(a1) + 0x28) + 0x10LL) )
      {
        v45 = v7;
        v44 = v8;
        n0x3F800000 = 0x3F800000u;
        v25 = 1.0 - (float)(*(float *)&_XMM8 / *(float *)(*(_QWORD *)(sub_140334DC0(a1) + 0x28) + 0x10LL));
        if ( *(float *)&_XMM8 > 0.0 )
        {
          n0x42700000 = 0x42700000u;
          *(float *)&n0x42700000 = 60.0 / (float)((float)v22 / *(float *)&_XMM8);
          n0x3F800000 = n0x42700000;
        }
        _XMM2 = 0x80000000;
        n0x3F800000_1 = n0x3F800000;
        *(float *)&n0x3F800000_1 = (float)(*(float *)&n0x3F800000 * v25)
                                 * *(float *)(*(_QWORD *)(sub_140334DC0(a1) + 0x28) + 0x14LL);
        n0x3F800000_2 = n0x3F800000_1;
        __asm
        {
          vandnps xmm6, xmm6, xmm1
          vroundps xmm0, xmm6, 0
        }
        v33 = _XMM6;
        *(float *)&v33 = *(float *)&_XMM6 - *(float *)&_XMM0;
        _XMM6 = v33;
        __asm { vcmpeqss xmm6, xmm6, dword ptr cs:xmmword_1480DD730 }
        v35 = _XMM6 & xmmword_1480E1F40;
        *(float *)&v35 = COERCE_FLOAT(_XMM6 & 0x3F800000) + *(float *)&_XMM0;
        v23 = v35 | 0x80000000 & n0x3F800000_2;
      }
      v36 = sub_140334DC0(a1);
      v38 = v23;
      *(float *)&v38 = (float)((float)(*(float *)&v23 + 1.0) * v18) + *(float *)(a1 + 0x98);
      _XMM3 = v38;
      LODWORD(_XMM2) = *(_DWORD *)(v36 + 0x34);
      if ( *(float *)&v38 >= *(float *)&_XMM2 )
        __asm { vminss  xmm2, xmm3, xmm7 }
      *(float *)(a1 + 0x98) = *(float *)&_XMM2;
      return sub_1433A65F0(a1 + 0xC0, v37, a4);
    }
  }
  return result;
}

// --- End Function: sub_1433EAFD0 (0x1433EAFD0) ---

// --- Function: sub_1433F4B30 (0x1433F4B30) ---
int __fastcall sub_1433F4B30(__int64 a1, unsigned int *a2, char *a3)
{
  _QWORD v5[3]; // [rsp+20h] [rbp-18h] BYREF

  v5[1] = a1;
  v5[0] = &off_1480EC218;
  sub_140527000((__int64)v5, (__int64)"variable", a2);
  return sub_140527370((__int64)v5, (__int64)"variable", a3);
}

// --- End Function: sub_1433F4B30 (0x1433F4B30) ---

// --- Function: sub_146060B80 (0x146060B80) ---
__int64 __fastcall sub_146060B80(__int64 a1, struct std::pmr::memory_resource **a2)
{
  __int64 result; // rax
  int v3; // edx
  int v4; // r8d
  int v5; // r9d
  __int64 v6; // [rsp+30h] [rbp-68h] BYREF
  __int64 v7; // [rsp+38h] [rbp-60h]
  __int64 v8; // [rsp+40h] [rbp-58h] BYREF
  __int64 v9; // [rsp+48h] [rbp-50h]
  __int64 v10; // [rsp+50h] [rbp-48h]
  __int64 v11; // [rsp+58h] [rbp-40h]
  unsigned __int64 *v12; // [rsp+60h] [rbp-38h]
  std::pmr::_Identity_equal_resource *v13; // [rsp+68h] [rbp-30h] BYREF
  struct std::pmr::memory_resource *v14; // [rsp+70h] [rbp-28h]
  std::pmr::_Identity_equal_resource *v15; // [rsp+78h] [rbp-20h]
  __int64 v16; // [rsp+80h] [rbp-18h]
  __int64 v17; // [rsp+88h] [rbp-10h]

  v8 = *(_QWORD *)(a1 + 0x2F8);
  if ( Handle::IsValid(&v8) )
  {
    v10 = v8 & 0xFFFFFFFFFFFFLL;
    v9 = sub_1439E7780(v8 & 0xFFFFFFFFFFFFLL);
  }
  else
  {
    v9 = 0;
  }
  result = v9;
  v7 = v9;
  if ( v9 )
  {
    result = (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x5F8LL))(v7);
    if ( (_BYTE)result )
    {
      v6 = *(_QWORD *)(a1 + 0x2B8);
      result = Handle::IsValid(&v6);
      if ( (_BYTE)result )
      {
        v14 = *a2;
        v11 = v6 & 0xFFFFFFFFFFFFLL;
        v12 = (unsigned __int64 *)((v6 & 0xFFFFFFFFFFFFLL) + 8);
        sub_1403B29B0(v12, &v13);
        v15 = v13;
        result = std::pmr::_Identity_equal_resource::do_is_equal(v13, v14);
        if ( (_BYTE)result )
        {
          result = sub_146050F00(a1);
          if ( (_DWORD)result == 1 )
          {
            v16 = v6 & 0xFFFFFFFFFFFFLL;
            result = (unsigned __int8)sub_1433ED460(v6 & 0xFFFFFFFFFFFFLL);
            if ( (_BYTE)result )
            {
              v17 = v6 & 0xFFFFFFFFFFFFLL;
              LOBYTE(v5) = 1;
              LOBYTE(v4) = 1;
              return sub_1433EAFD0(v6, v3, v4, v5, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_146060B80 (0x146060B80) ---

// --- Function: sub_146060FF0 (0x146060FF0) ---
__int64 __fastcall sub_146060FF0(__int64 a1, __int64 a2)
{
  __int64 n2; // rax
  int v3; // edx
  __int64 v4; // [rsp+38h] [rbp-30h] BYREF
  _QWORD v5[5]; // [rsp+40h] [rbp-28h] BYREF

  v5[0] = *(_QWORD *)(a1 + 0x2F8);
  n2 = Handle::IsValid(v5);
  if ( (_BYTE)n2 )
  {
    v5[1] = v5[0] & 0xFFFFFFFFFFFFLL;
    n2 = sub_1439F0470(v5[0] & 0xFFFFFFFFFFFFLL);
    if ( (_BYTE)n2 )
    {
      v4 = *(_QWORD *)(a1 + 0x2B8);
      n2 = Handle::IsValid(&v4);
      if ( (_BYTE)n2 )
      {
        if ( (unsigned __int8)sub_1403216E0(a1 + 0x9F0)
          || (unsigned int)sub_146050F00(a1) != 1
          || (v5[2] = v4 & 0xFFFFFFFFFFFFLL, n2 = (unsigned __int8)sub_1433ABF80(v4 & 0xFFFFFFFFFFFFLL), !(_BYTE)n2) )
        {
          n2 = sub_146050F00(a1);
          if ( (_DWORD)n2 != 2 )
          {
            v5[3] = v4 & 0xFFFFFFFFFFFFLL;
            return sub_1433EAFD0(v4, v3, *(unsigned __int8 *)(a2 + 4), 0, *(_BYTE *)(a2 + 5));
          }
        }
      }
    }
  }
  return n2;
}

// --- End Function: sub_146060FF0 (0x146060FF0) ---

// --- Function: sub_14606E380 (0x14606E380) ---
__int64 __fastcall sub_14606E380(__int64 a1, struct std::pmr::memory_resource **a2)
{
  return sub_146060B80(a1, a2);
}

// --- End Function: sub_14606E380 (0x14606E380) ---

// --- Function: sub_14606E710 (0x14606E710) ---
__int64 __fastcall sub_14606E710(__int64 a1, __int64 a2)
{
  return sub_146060FF0(a1, a2);
}

// --- End Function: sub_14606E710 (0x14606E710) ---

// --- Function: __security_check_cookie (0x147F6A880) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x147F6A880) ---

// --- Function: __raise_securityfailure (0x147F6AA48) ---
BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE hProcess; // rax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  hProcess = GetCurrentProcess();
  return TerminateProcess(hProcess, 0xC0000409);
}

// --- End Function: __raise_securityfailure (0x147F6AA48) ---

// --- Function: __report_gsfailure (0x147F6AA7C) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_1515EE080 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1515EE070 = 0xC0000409;
  dword_1515EE074 = 1;
  dword_1515EE088 = 1;
  qword_1515EE090[0] = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147F6AA7C) ---

// --- Function: capture_previous_context (0x147F6AC70) ---
struct _RUNTIME_FUNCTION *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 ControlPc; // rsi
  int n2; // edi
  struct _RUNTIME_FUNCTION *FunctionEntry; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  ControlPc = ContextRecord->Rip;
  for ( n2 = 0; n2 < 2; ++n2 )
  {
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, 0);
    if ( !FunctionEntry )
      break;
    FunctionEntry = (struct _RUNTIME_FUNCTION *)RtlVirtualUnwind(
                                                  0,
                                                  ImageBase,
                                                  ControlPc,
                                                  FunctionEntry,
                                                  ContextRecord,
                                                  &HandlerData,
                                                  &EstablisherFrame,
                                                  0);
  }
  return FunctionEntry;
}

// --- End Function: capture_previous_context (0x147F6AC70) ---

