// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x1436BB390 (sub_1436BB390)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 144
// ------------------------------------------------------------

// --- Function: sub_1402A1380 (0x1402A1380) ---
__int64 *sub_1402A1380(__int64 *a1, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  unsigned __int64 n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A2470();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format, 0, va);
  Buffer[4095] = 0;
  n511 = -1;
  do
  {
    ++n511;
  }
  while ( Buffer[n511] );
  sub_1402A1CD0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A1380 (0x1402A1380) ---

// --- Function: sub_1402A1C40 (0x1402A1C40) ---
_BYTE *__fastcall sub_1402A1C40(__int64 *a1, __int64 n511)
{
  _BYTE *result; // rax
  unsigned __int64 n0x6400000; // rsi
  __int64 n511_1; // rcx

  result = a1 + 3;
  if ( n511 )
  {
    n0x6400000 = n511 + 1;
    if ( (unsigned __int64)(n511 + 1) <= 0x200 )
    {
      n511_1 = 511;
    }
    else
    {
      result = (_BYTE *)sub_14739AFC0(n0x6400000, 0);
      qword_149808368 += n0x6400000;
      n511_1 = n511;
    }
    a1[1] = n511_1;
    *a1 = n511;
    a1[2] = (__int64)result;
    result[n511] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 511;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A1C40 (0x1402A1C40) ---

// --- Function: sub_1402A1CD0 (0x1402A1CD0) ---
__int64 __fastcall sub_1402A1CD0(__int64 *a1, void *Src, unsigned __int64 n511)
{
  unsigned __int64 n511_1; // r8
  __int64 *v7; // rcx
  __int64 *v8; // r14
  __int64 result; // rax

  n511_1 = a1[1];
  if ( n511 > n511_1 )
  {
    v7 = (__int64 *)a1[2];
    v8 = a1 + 3;
    if ( v7 != a1 + 3 )
    {
      qword_149808368 += -1LL - n511_1;
      sub_14739AF10(v7);
    }
    *(_BYTE *)v8 = 0;
    a1[2] = (__int64)v8;
    *a1 = 0;
    a1[1] = 511;
    sub_1402A1C40(a1, n511);
  }
  memmove((void *)a1[2], Src, n511);
  result = a1[2];
  *a1 = n511;
  *(_BYTE *)(n511 + result) = 0;
  return result;
}

// --- End Function: sub_1402A1CD0 (0x1402A1CD0) ---

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: sub_1402A1E30 (0x1402A1E30) ---
__int64 __fastcall sub_1402A1E30(unsigned __int64 n0x6400000)
{
  return sub_14739AFC0(n0x6400000, 0LL);
}

// --- End Function: sub_1402A1E30 (0x1402A1E30) ---

// --- Function: sub_1402A2470 (0x1402A2470) ---
void *sub_1402A2470()
{
  return &unk_149808280;
}

// --- End Function: sub_1402A2470 (0x1402A2470) ---

// --- Function: sub_1402A47D0 (0x1402A47D0) ---
char *__fastcall sub_1402A47D0(__int64 *a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 n0x6400000; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  _BYTE *v20; // rcx
  char *result; // rax

  v3 = (__int64)&a2[-*a1] >> 3;
  v5 = (a1[1] - *a1) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = (a1[2] - *a1) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
  {
    goto LABEL_24;
  }
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
  {
    v11 = v10 + v8;
  }
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_24;
  }
  n0x6400000 = 8 * v11;
  if ( n0x6400000 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      v14 = (_QWORD *)sub_1402A1E30(n0x6400000);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_13;
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_24:
    sub_1402DEE40();
  }
  v13 = sub_1402A1E30(n0x6400000 + 39);
  if ( !v13 )
  {
    goto LABEL_22;
  }
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *a3;
  v16 = v14;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v16 = v15 + 1;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v16, v18, Size);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      free_memory_wrapper(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v20[-*((_QWORD *)v20 - 1) - 8] <= 0x1F )
    {
      v20 = (_BYTE *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v14;
  result = (char *)&v14[v3];
  a1[1] = (__int64)&v14[v9];
  a1[2] = (__int64)&v14[n0x6400000 / 8];
  return result;
}

// --- End Function: sub_1402A47D0 (0x1402A47D0) ---

// --- Function: sub_1402A78B0 (0x1402A78B0) ---
const void **__fastcall sub_1402A78B0(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 n0x6400000; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
  {
    unknown_libname_9();
  }
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    n0x6400000 = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
    {
      v6 = v12 + n0xF;
    }
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
      {
        v15 = 0;
      }
      else
      {
        v15 = (_QWORD *)sub_1402A1E30(v6 + 1);
      }
      goto LABEL_15;
    }
    n0x6400000 = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
    {
      sub_1402DEE40();
    }
  }
  v14 = sub_1402A1E30(n0x6400000);
  if ( !v14 )
  {
    goto LABEL_20;
  }
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  free_memory_wrapper(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A78B0 (0x1402A78B0) ---

// --- Function: sub_1402AF650 (0x1402AF650) ---
_QWORD *__fastcall sub_1402AF650(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_147F343E8;
  return a1;
}

// --- End Function: sub_1402AF650 (0x1402AF650) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 NtCurrentTeb_wrp()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1402C7FC0 (0x1402C7FC0) ---
__int64 __fastcall sub_1402C7FC0(int a1, int n8, unsigned int a3)
{
  __int64 result; // rax
  int v4; // r8d

  while ( 1 )
  {
    result = a3;
    if ( n8 == 8 )
    {
      break;
    }
    v4 = 0;
    if ( (int)result < 0 )
    {
      v4 = a1;
    }
    a3 = (2 * result) ^ v4;
    ++n8;
  }
  return result;
}

// --- End Function: sub_1402C7FC0 (0x1402C7FC0) ---

// --- Function: sub_1402D09F0 (0x1402D09F0) ---
__int64 __fastcall sub_1402D09F0(unsigned int a1, char a2, unsigned int a3, char a4)
{
  char v4; // r11

  while ( 1 )
  {
    v4 = a4;
    if ( a4 == a2 + 1 )
    {
      break;
    }
    ++a4;
    if ( (a1 & 1) != 0 )
    {
      a3 |= 1 << (a2 - v4);
    }
    a1 >>= 1;
  }
  return a3;
}

// --- End Function: sub_1402D09F0 (0x1402D09F0) ---

// --- Function: sub_1402DEC20 (0x1402DEC20) ---
void __fastcall __noreturn sub_1402DEC20(const struct stdext::exception *a1)
{
  if ( std::_Raise_handler )
  {
    std::_Raise_handler(a1);
  }
  (*(void (__fastcall **)(const struct stdext::exception *))(*(_QWORD *)a1 + 16LL))(a1);
  invoke_watson(0LL, 0LL, 0LL, 0, 0LL);
}

// --- End Function: sub_1402DEC20 (0x1402DEC20) ---

// --- Function: sub_1402DEE40 (0x1402DEE40) ---
void __noreturn sub_1402DEE40()
{
  const struct stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (const struct stdext::exception *)sub_1402AF650(v1);
  sub_1402DEC20(v0);
}

// --- End Function: sub_1402DEE40 (0x1402DEE40) ---

// --- Function: unknown_libname_8 (0x1402DFC20) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_8()
{
  std::_Xlength_error("deque<T> too long");
}

// --- End Function: unknown_libname_8 (0x1402DFC20) ---

// --- Function: unknown_libname_10 (0x1402DFC60) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402DFC60) ---

// --- Function: sub_1402DFCB0 (0x1402DFCB0) ---
__int64 __fastcall sub_1402DFCB0(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // rdi
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax

  while ( 1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *a1;
    if ( !(_BYTE)v4 )
    {
      break;
    }
    v5 = v4 + 32;
    if ( (unsigned __int8)(v4 - 65) > 0x19u )
    {
      v5 = v4;
    }
    v6 = sub_1402D09F0(((unsigned __int8)v2 ^ v5) >> 1, 8, (unsigned __int8)((v2 ^ v5) & 1) << 7, 2);
    v7 = sub_1402C7FC0(79764919, 1, (v6 << 25) ^ (unsigned int)((unsigned __int64)(v6 << 24) >> 31) & 0x4C11DB7);
    v8 = sub_1402D09F0(v7 >> 1, 32, v7 << 31, 2);
    a1 = v3 + 1;
    a2 = v8 ^ (v2 >> 8);
  }
  return ~v2;
}

// --- End Function: sub_1402DFCB0 (0x1402DFCB0) ---

// --- Function: sub_1402F5120 (0x1402F5120) ---
int sub_1402F5120(FILE *Stream, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A2470();
  return _stdio_common_vfprintf(*v4, Stream, Format, 0LL, va);
}

// --- End Function: sub_1402F5120 (0x1402F5120) ---

// --- Function: sub_1402F8E30 (0x1402F8E30) ---
void *__fastcall sub_1402F8E30(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 n0x6400000; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_9();
  }
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    n0x6400000 = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_1402A1E30(n0x6400000);
    if ( !v9 )
    {
      invalid_parameter_noinfo_noreturn();
    }
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
  {
    n22 = 22;
  }
  if ( n22 + 1 >= 0x1000 )
  {
    n0x6400000 = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
    {
      sub_1402DEE40();
    }
    goto LABEL_6;
  }
  if ( n22 == -1 )
  {
    v10 = 0;
  }
  else
  {
    v10 = (_QWORD *)sub_1402A1E30(n22 + 1);
  }
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402F8E30 (0x1402F8E30) ---

// --- Function: sub_1402FBC20 (0x1402FBC20) ---
__int64 __fastcall sub_1402FBC20(char *i, char *i_8, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  char *i_1; // r15
  __int64 i_2; // rdi
  char *i_8a_1; // r14
  char *ia_1; // rbp
  char *i_3; // rsi
  size_t n8; // r14
  char *i_4; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i_5; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  char *i_8a; // [rsp+30h] [rbp-38h] BYREF
  char *ia; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (i_8 - i) & 0xFFFFFFFFFFFFFFF8uLL;
  i_1 = i_8;
  i_2 = (__int64)i;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( (char *)i_2 != i_1 )
    {
      i_3 = (char *)(i_2 + 8);
      if ( (char *)(i_2 + 8) != i_1 )
      {
        n8 = 8;
        do
        {
          i_4 = i_3;
          v14 = *(_QWORD *)i_3;
          v15 = *(_QWORD *)(*(_QWORD *)i_2 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)i_3 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)i_3 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)i_2 + 80LL) )
          {
            n256 = (__int64)memmove((void *)(i_2 + 8), (const void *)i_2, n8);
            *(_QWORD *)i_2 = v14;
          }
          else
          {
            for ( i_5 = i_3; ; i_4 = i_5 )
            {
              v17 = *((_QWORD *)i_5 - 1);
              i_5 -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                {
                  break;
                }
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                {
                  break;
                }
              }
              *(_QWORD *)i_4 = v17;
            }
            *(_QWORD *)i_4 = v14;
          }
          i_3 += 8;
          n8 += 8LL;
        }
        while ( i_3 != i_1 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FB540((__int64 **)&i_8a, (__int64 *)i_2, (unsigned __int64)i_1);
      i_8a_1 = i_8a;
      ia_1 = ia;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((unsigned __int64)&i_8a[-i_2] & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((i_1 - ia)
                                                                                       & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FBC20(ia, i_1, a3, a4);
        i_1 = i_8a_1;
      }
      else
      {
        sub_1402FBC20((char *)i_2, i_8a, a3, a4);
        i_2 = (__int64)ia_1;
      }
      n256 = (unsigned __int64)&i_1[-i_2] & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
      {
        goto LABEL_7;
      }
    }
    v18 = (__int64)&i_1[-i_2] >> 3;
    v19 = (__int64)&i_1[-i_2] >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)(i_2 + 8 * v19-- - 8);
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)(i_2 + 8 * j);
          v25 = *(_QWORD *)(i_2 + 8 * j - 8);
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)(i_2 + 8 * v22) = *(_QWORD *)(i_2 + 8 * j);
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)(i_2 + 8 * v22) = *(_QWORD *)(i_2 + 8 * v18 - 8);
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)(i_2 + 8 * v27);
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)(i_2 + 8 * v22) = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)(i_2 + 8 * v22) = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (unsigned __int64)&i_1[-i_2] & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(i_1 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)i_2;
        sub_1402FB800(i_2, 0, ((__int64)v30-- - i_2) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8 - i_2) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FBC20 (0x1402FBC20) ---

// --- Function: sub_1402FD110 (0x1402FD110) ---
_QWORD *__fastcall sub_1402FD110(__int64 **a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *(_QWORD *)(a2 + 16) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)sub_1402A1E30(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)sub_1402A1E30(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = *(_BYTE **)(a2 + 8);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( v7[Size_1] );
    sub_1402F8E30(&Src, v7, Size_1);
    v10 = *(_BYTE **)(a2 + 16);
    do
    {
      ++Size;
    }
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A78B0((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
      {
        p_Src = *(__m256 **)Src.m256_f32;
      }
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
    {
      goto LABEL_26;
    }
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
      {
        p_Src_1 = p_Src_2;
      }
      if ( v18[5] > 0xFu )
      {
        Buf1 = (_QWORD *)*Buf1;
      }
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
      {
        break;
      }
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
      {
        std::_Xlength_error("list too long");
      }
      v23 = sub_1402A1E30(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
      {
        v26 = (_QWORD *)*v26;
      }
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
      {
        v26 = (_QWORD *)*v26;
      }
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      free_memory_wrapper(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FD110 (0x1402FD110) ---

// --- Function: sub_1402FDA00 (0x1402FDA00) ---
bool __fastcall sub_1402FDA00(__int64 a1, _QWORD *a2, __int64 *a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  __int64 v11; // r10
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // bp
  __int64 v18; // rdi
  __int64 v19; // rbx
  unsigned __int64 v20; // rsi
  _QWORD *v21; // r15
  unsigned __int64 v22; // rbx
  __int64 v23; // rdi
  __int64 v24; // r9
  char v25; // al
  __int64 v26; // r8
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rax
  __int64 v30; // [rsp+20h] [rbp-48h]
  bool v32; // [rsp+80h] [rbp+18h]

  v7 = sub_1402FE800(*((unsigned int *)a3 + 9), a2, a3[3], a1);
  if ( v9 + v7 > v10 )
  {
    return 0;
  }
  v13 = *((unsigned int *)a3 + 8);
  v17 = 0;
  if ( (_DWORD)v13 != 1 )
  {
    v14 = sub_1402FE800(v13, v8, v9, v10);
    if ( v15 + v14 < v16 )
    {
      v17 = 1;
    }
  }
  v18 = a3[1];
  v19 = *a3;
  v32 = v17;
  if ( (v18 - *a3) / 104 != a5 )
  {
    if ( v19 != v18 )
    {
      do
      {
        if ( *(_BYTE *)(v19 + 88) && *(_QWORD *)v19 )
        {
          (*(void (**)(void))(v19 + 64))();
        }
        v19 += 104LL;
      }
      while ( v19 != v18 );
      a3[1] = *a3;
    }
    sub_1402FB8F0(a3, a5);
    v11 = a4;
    v17 = 1;
    v32 = 1;
  }
  v20 = 0LL;
  v21 = a2 + 1;
  v22 = 0LL;
  if ( a5 )
  {
    v23 = v11 + 48;
    v24 = -48 - v11;
    v30 = -48 - v11;
    while ( !v17 )
    {
      v21 = a2 + 1;
      if ( v22 < (__int64)(a2[1] - *a2) >> 2 && !*(_DWORD *)(*a2 + 4 * v22) && *(_QWORD *)(v23 + 24) && *(_QWORD *)v23 )
      {
        if ( (a3[1] - *a3) / 104 <= v22 )
        {
          __debugbreak();
        }
        v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v23)(*(_QWORD *)(v23 - 48), *(_QWORD *)(v24 + v23 + *a3));
        v24 = v30;
        v17 = v25 == 0;
        v32 = v25 == 0;
      }
      ++v22;
      v23 += 104LL;
      if ( v22 >= a5 )
      {
        goto LABEL_26;
      }
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v17 )
  {
LABEL_27:
    if ( a5 )
    {
      v26 = -16 - a4;
      v27 = a4 + 16;
      do
      {
        if ( v20 < (__int64)(*v21 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * v20)
          && *(_QWORD *)(v27 + 56)
          && *(_QWORD *)(v27 + 32) )
        {
          if ( (a3[1] - *a3) / 104 <= v20 )
          {
            __debugbreak();
          }
          v28 = v27 + v26 + *a3;
          if ( *(_BYTE *)(v28 + 88) )
          {
            if ( *(_QWORD *)v28 )
            {
              (*(void (**)(void))(v28 + 64))();
            }
          }
          v29 = (*(__int64 (__fastcall **)(_QWORD))(v27 + 56))(*(_QWORD *)(v27 - 16));
          v26 = -16 - a4;
          *(_QWORD *)v28 = v29;
          *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 - 8);
          *(_QWORD *)(v28 + 16) = *(_QWORD *)v27;
          *(_QWORD *)(v28 + 24) = *(_QWORD *)(v27 + 8);
          *(_QWORD *)(v28 + 32) = *(_QWORD *)(v27 + 16);
          *(_QWORD *)(v28 + 48) = *(_QWORD *)(v27 + 32);
          *(_QWORD *)(v28 + 40) = *(_QWORD *)(v27 + 24);
          *(_QWORD *)(v28 + 56) = *(_QWORD *)(v27 + 40);
          *(_QWORD *)(v28 + 64) = *(_QWORD *)(v27 + 48);
          *(_QWORD *)(v28 + 72) = *(_QWORD *)(v27 + 56);
          *(_QWORD *)(v28 + 80) = *(_QWORD *)(v27 + 64);
          *(_QWORD *)(v28 + 96) = *(_QWORD *)(v27 + 80);
          *(_BYTE *)(v28 + 88) = 1;
          *(_BYTE *)(v28 + 89) = *(_BYTE *)(v27 + 73);
        }
        ++v20;
        v27 += 104LL;
      }
      while ( v20 < a5 );
      v17 = v32;
    }
    a3[3] = a1;
  }
  return v17;
}

// --- End Function: sub_1402FDA00 (0x1402FDA00) ---

// --- Function: sub_1402FE700 (0x1402FE700) ---
__int64 __fastcall sub_1402FE700(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
  {
    return 0xFFFFFFFFLL;
  }
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 19), SizeInBytes - 19, ".%03dZ", v3 - 1000 * v7) + 19);
}

// --- End Function: sub_1402FE700 (0x1402FE700) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !qword_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !qword_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_140300090 (0x140300090) ---
__int64 __fastcall sub_140300090(
        int dwLowDateTime,
        __int64 a2,
        __int64 Buffer,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        __int64 a7,
        _QWORD *a8,
        unsigned __int64 a9,
        __int64 a10,
        char *Buffer_1,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_2; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 a13a_1; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_3; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_4; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 v79; // rdi
  _QWORD *v80; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *a4; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *a13a; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_1495F6708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
    {
      v17 = off_1495F6720[0];
    }
  }
  else
  {
    v17 = off_1495F6728[0];
  }
  Size_5 = -1;
  a4 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = -1;
  v21 = (const void **)&off_1495F6738[0][n4];
  do
  {
    ++Size_1;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_1) );
  if ( Size_1 >= Size )
  {
    goto LABEL_25;
  }
  if ( Size_1 )
  {
    if ( Buffer_1 )
    {
      if ( off_1495F6710 )
      {
        memcpy(Buffer_1, off_1495F6710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer_1, 0, Size);
    }
    *errno() = 22;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
  {
    goto LABEL_25;
  }
  if ( !&Buffer_1[(int)Size_1] )
  {
    *errno() = 22;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 34;
    goto LABEL_22;
  }
  Buffer_1[(int)Size_1] = 91;
LABEL_23:
  v22 = sub_1402FC4C0(
          (__int64)Buffer_1,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&a4,
          v21,
          (__int64)&off_1495F6710,
          (__int64)"]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
  {
LABEL_25:
    Sizea_4 = -1;
  }
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
  {
    Sizea_1 = 0;
  }
  v85 = (unsigned int)Sizea_4 >> 31;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_141;
  }
  v24 = off_1495F6710;
  Size_2 = -1;
  do
  {
    ++Size_2;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
  {
    goto LABEL_125;
  }
  Buffer_2 = Buffer_1;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer_1[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 22;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_1495F6710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_1495F6710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
      {
        goto LABEL_34;
      }
      if ( Size_3 < Size_2 )
      {
        *errno() = 34;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
  {
    goto LABEL_125;
  }
  v30 = &Buffer_2[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_2[v29] )
  {
    *errno() = 22;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_2 = Buffer_1;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 34;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 15392;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_1495F6730;
  do
  {
    ++Size_5;
  }
  while ( *((_BYTE *)off_1495F6730 + Size_5) );
  if ( Size_5 + v32 >= Size )
  {
    goto LABEL_125;
  }
  v34 = &Buffer_2[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 22;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_1495F6730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_1495F6730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
      {
        goto LABEL_56;
      }
      if ( Size_6 < Size_5 )
      {
        *errno() = 34;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  Size_7 = -1;
  v37 = v32 + (int)Size_5;
  do
  {
    ++Size_7;
  }
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
  {
    goto LABEL_125;
  }
  v38 = &Buffer_2[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 22;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
      {
        goto LABEL_71;
      }
      if ( Size_8 < Size_7 )
      {
        *errno() = 34;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v40 = off_1495F6710;
  Size_9 = -1;
  v42 = v37 + (int)Size_7;
  a4 = (void *)v42;
  do
  {
    ++Size_9;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_9) );
  if ( Size_9 + v42 >= Size )
  {
    goto LABEL_125;
  }
  v43 = &Buffer_2[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 22;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_1495F6710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_1495F6710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
      {
        goto LABEL_86;
      }
      if ( Size_10 < Size_9 )
      {
        *errno() = 34;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)a4;
    Buffer_2 = Buffer_1;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
  {
    goto LABEL_125;
  }
  v46 = &Buffer_2[v45];
  n2 = Size - v45;
  if ( &Buffer_2[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 8254;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 34;
  }
  else
  {
    *errno() = 22;
  }
  invalid_parameter_noinfo();
  Buffer_2 = Buffer_1;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = -1;
  do
  {
    ++Size_11;
  }
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
  {
    goto LABEL_124;
  }
  v50 = &Buffer_2[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
  {
    goto LABEL_116;
  }
  if ( !v50 )
  {
    goto LABEL_108;
  }
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
    {
      goto LABEL_116;
    }
    *errno() = 34;
  }
  else
  {
LABEL_108:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
  {
    goto LABEL_125;
  }
  v53 = Size_9 + v52;
  if ( v53 < 0 )
  {
    goto LABEL_125;
  }
  v54 = Size_7 + v53;
  if ( v54 < 0 )
  {
    goto LABEL_125;
  }
  v55 = Size_5 + v54;
  if ( v55 < 0 )
  {
    goto LABEL_125;
  }
  v56 = v55 + 2;
  if ( v56 < 0 )
  {
    goto LABEL_125;
  }
  v57 = Size_2 + v56;
  if ( v57 < 0 )
  {
    goto LABEL_125;
  }
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_142;
  }
  v60 = sub_140303140(
          (__int64)Buffer_1,
          Size,
          Sizea_1,
          (char *)a7,
          (__int64)a8,
          a9,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FB040);
  if ( v60 < 0 )
  {
    v58 = 1;
  }
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
  {
    Sizea_1 = Sizea_3;
  }
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_142;
  }
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer_1[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 32;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  a13a_1 = 0;
  a13a = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
  {
    goto LABEL_175;
  }
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = -1;
      v65 = off_1495F6710;
      a4 = (void *)qword_149808630;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * a13a_1);
      do
      {
        ++Size_14;
      }
      while ( *((_BYTE *)off_1495F6710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
      {
        goto LABEL_171;
      }
      Buffer_3 = Buffer_1;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer_1[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_3[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_3[Size_13] = 91;
LABEL_167:
                v70 = sub_1402FC4C0(
                        (__int64)Buffer_1,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_1495F6718,
                        (const void **)((char *)a4 + Sizec),
                        (__int64)&off_1495F6710,
                        (__int64)"]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      a13a_1 = (unsigned __int64)a13a;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 34;
            }
            else
            {
              *errno() = 22;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        a13a_1 = (unsigned __int64)a13a;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
      {
        goto LABEL_150;
      }
      if ( off_1495F6710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_1495F6710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 22;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 34;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_3 = Buffer_1;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    a13a = (int *)++a13a_1;
    v63 = *a5;
  }
  while ( a13a_1 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_194;
  }
  v73 = v88;
  Size_16 = -1;
  do
  {
    ++Size_16;
  }
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_4 = Buffer_1;
  if ( Size_16 + Sizea_1 >= Size )
  {
    goto LABEL_191;
  }
  Size_17 = Size - Sizea_1;
  v77 = &Buffer_1[Sizea_1];
  if ( !Size_16 )
  {
    goto LABEL_189;
  }
  if ( !v77 )
  {
    goto LABEL_181;
  }
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 22;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 34;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
  {
LABEL_191:
    v58 = 1;
  }
  else
  {
    Sizea_1 += Size_16;
  }
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_4 = Buffer_1;
    v58 = 1;
  }
  else
  {
    Buffer_1[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( a9 )
  {
    v79 = 0;
    if ( (*a15 & 4) != 0 )
    {
      v80 = a8;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))v80[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*v80, &Buffer_4[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++v79;
        v80 += 13;
      }
      while ( v79 < a9 );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_4[Size - 4] = 11822;
      Buffer_4[Size - 2] = 46;
    }
  }
  else
  {
    Buffer_4[Sizea_1] = 0;
    if ( v58 )
    {
      goto LABEL_209;
    }
  }
  Buffer_4[Size - 1] = 0;
  if ( v78 )
  {
    qword_149808998(a2, Buffer, n4, Buffer_4, Sizea_1, a14);
  }
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140300090 (0x140300090) ---

// --- Function: sub_140300B90 (0x140300B90) ---
__int64 __fastcall sub_140300B90(
        __int64 a1,
        __int64 a2,
        _BYTE *Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        _BYTE *Src,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 i,
        unsigned __int64 n0xF,
        double *Buffer_1,
        unsigned __int64 n0xFa,
        __int64 a16,
        int i_1,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r11d
  double *Buffer_2; // r15
  _QWORD *v24; // r14
  int n0xFa_2; // ebx
  unsigned __int64 n0xFa_1; // r9
  unsigned __int64 n0xFa_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xFa_19; // r13d
  int v47; // r13d
  int i_3; // edi
  __int64 v49; // rsi
  _BYTE *v50; // rbp
  int v51; // eax
  unsigned int n4_2; // r14d
  int v53; // eax
  bool v54; // dl
  bool v55; // cl
  bool v56; // al
  int v57; // eax
  int n0xFa_4; // ebp
  int n0xFa_5; // esi
  int n0xF_2; // edi
  int v61; // eax
  __int64 *v62; // r9
  __int64 v63; // rdx
  __int64 v64; // rcx
  __int64 v65; // rax
  unsigned __int64 v66; // r8
  __int64 v67; // r15
  __int64 v68; // r14
  _BYTE *v69; // rsi
  __int64 v70; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v73; // rcx
  __int64 v74; // rcx
  size_t n2; // r8
  _WORD *v76; // rcx
  bool v77; // sf
  int v78; // ecx
  __int64 v79; // rax
  __int64 v80; // r15
  __int64 v81; // r14
  int v82; // eax
  int v83; // eax
  int n0xF_4; // ebp
  int n0xFa_7; // r14d
  int n0xFa_8; // r15d
  int n0xFa_9; // edx
  char *Src_2; // r14
  int v89; // eax
  int n0xFa_10; // ecx
  size_t Size_8; // r8
  double *v92; // rcx
  __int64 v93; // rdi
  __int64 i_4; // rbp
  int v95; // eax
  int n0xFa_11; // ecx
  size_t Size_9; // r8
  double *v98; // rcx
  _BYTE *v99; // rcx
  size_t Size_10; // r8
  double *v101; // rcx
  int n0xFa_12; // ebp
  int v103; // eax
  _BYTE *v104; // rcx
  unsigned __int64 n0xF_5; // rdx
  bool v106; // bp
  __int64 v107; // r14
  unsigned __int64 n0xF_8; // r15
  unsigned __int64 v109; // rsi
  __int64 v110; // r14
  int n0xFa_13; // edx
  int n0xF_7; // ecx
  bool v113; // r15
  int n0xFa_14; // r12d
  size_t Size_11; // r8
  _WORD *v116; // rcx
  _BYTE *v117; // rcx
  __int64 v118; // rax
  unsigned __int64 v119; // r9
  double *Buffer_3; // rdx
  _BYTE *v121; // rdi
  __int64 v122; // rbp
  size_t Size_12; // rbx
  char *v124; // rcx
  size_t Size_13; // rsi
  __int64 v126; // rcx
  size_t Size_14; // r8
  _WORD *v128; // rcx
  int v129; // ecx
  _BYTE *v130; // rcx
  unsigned __int64 n0xFa_16; // r8
  double *Buffer_4; // r12
  unsigned __int64 v133; // r8
  _BYTE *v134; // rcx
  int n0xFa_17; // esi
  int v136; // eax
  double *Buffer_5; // rsi
  _BYTE *v138; // rcx
  size_t Size_15; // r8
  _WORD *v140; // rcx
  int v141; // esi
  int v142; // eax
  size_t Size_16; // r8
  double *v144; // rcx
  size_t Size_17; // r8
  _WORD *v146; // rcx
  size_t n0xFa_18; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  unsigned int n4_3; // ebp
  __int64 v151; // r14
  _BYTE *v152; // rsi
  int v154; // [rsp+20h] [rbp-138h]
  _QWORD *v155; // [rsp+28h] [rbp-130h]
  int v156; // [rsp+28h] [rbp-130h]
  int n0xF_3; // [rsp+80h] [rbp-D8h]
  int n0xFa_6; // [rsp+80h] [rbp-D8h]
  int n0xF_6; // [rsp+80h] [rbp-D8h]
  bool v160; // [rsp+90h] [rbp-C8h]
  bool v161; // [rsp+91h] [rbp-C7h]
  bool v162; // [rsp+92h] [rbp-C6h]
  unsigned __int64 n0xFa_15; // [rsp+98h] [rbp-C0h]
  unsigned __int64 n0xF_1; // [rsp+A0h] [rbp-B8h] BYREF
  unsigned __int64 v165; // [rsp+A8h] [rbp-B0h]
  _BYTE *v166; // [rsp+B0h] [rbp-A8h]
  _QWORD *v167; // [rsp+B8h] [rbp-A0h]
  __int64 v168; // [rsp+C0h] [rbp-98h]
  __int64 v169; // [rsp+C8h] [rbp-90h]
  __int64 v170; // [rsp+D0h] [rbp-88h]
  char *Src_1; // [rsp+D8h] [rbp-80h]
  char *v172; // [rsp+E0h] [rbp-78h]
  void (__fastcall *v173)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, __int64, char *, unsigned __int64, __int128 *); // [rsp+E8h] [rbp-70h] BYREF
  __int64 i_2; // [rsp+F0h] [rbp-68h]
  __int128 v175; // [rsp+F8h] [rbp-60h] BYREF

  n4_1 = n4;
  Buffer_2 = Buffer_1;
  v24 = a6;
  Src_1 = Src;
  v172 = (char *)a8;
  v169 = a9;
  i_2 = i;
  v170 = a16;
  v166 = a4;
  n0xFa_2 = 0;
  n0xFa_1 = n0xFa;
  v173 = 0;
  v168 = a2;
  n0xFa_3 = n0xFa + 128;
  LODWORD(n0xF_1) = n4;
  v167 = a6;
  n0xFa_15 = n0xFa + 128;
  v175 = 0;
  if ( (int)n0xFa <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xFa <= 0xF )
  {
    goto LABEL_57;
  }
  if ( Buffer_1 )
  {
    *Buffer_1 = 0x73656D697440227BLL;
    *((_DWORD *)Buffer_1 + 2) = 1886216564;
    *((_WORD *)Buffer_1 + 6) = 14882;
    *((_BYTE *)Buffer_1 + 14) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    n0xFa_1 = n0xFa;
  }
  Size = -1;
  do
  {
    ++Size;
  }
  while ( Buffer[Size] );
  if ( Size + 15 >= n0xFa_1 )
  {
LABEL_56:
    n0xFa_1 = n0xFa;
    n4_1 = n4;
LABEL_57:
    n0xFa_19 = -1;
    goto LABEL_58;
  }
  v29 = (char *)Buffer_1 + 15;
  Size_1 = n0xFa_1 - 15;
  if ( Size )
  {
    if ( Buffer_1 == (double *)-15LL )
    {
LABEL_11:
      *errno() = 22;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( Buffer && Size_1 >= Size )
    {
      memcpy(v29, Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xFa_1 - 15);
      if ( !Buffer )
      {
        goto LABEL_11;
      }
      if ( Size_1 < Size )
      {
        *errno() = 34;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xFa_1 = n0xFa;
  }
  if ( (Size & 0x80000000) != 0LL )
  {
    goto LABEL_56;
  }
  v31 = (int)Size + 15LL;
  if ( (int)Size + 24LL >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v32 = (double *)((char *)Buffer_1 + v31);
  Size_2 = n0xFa_1 - v31;
  if ( !(double *)((char *)Buffer_1 + v31) )
  {
    *errno() = 22;
LABEL_27:
    invalid_parameter_noinfo();
    n0xFa_1 = n0xFa;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 34;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 34;
LABEL_28:
  v34 = (int)Size + 24LL;
  Size_3 = -1;
  do
  {
    ++Size_3;
  }
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v36 = (char *)Buffer_1 + v34;
  Size_4 = n0xFa_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 22;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xFa_1 - v34);
      if ( !a4 )
      {
        goto LABEL_33;
      }
      if ( Size_4 < Size_3 )
      {
        *errno() = 34;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xFa_1 = n0xFa;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
  {
    goto LABEL_56;
  }
  v38 = v34 + (int)Size_3;
  if ( v38 + 13 >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v39 = (double *)((char *)Buffer_1 + v38);
  Size_5 = n0xFa_1 - v38;
  if ( !(double *)((char *)Buffer_1 + v38) )
  {
    *errno() = 22;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 34;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 578315369;
  *((_BYTE *)v39 + 12) = 58;
LABEL_50:
  v41 = sub_1402FC400((__int64)Buffer_1, n0xFa, v38 + 13, a1);
  if ( v41 < 0 )
  {
    goto LABEL_56;
  }
  v42 = v41 + 13;
  if ( v42 < 0 )
  {
    goto LABEL_56;
  }
  v43 = Size_3 + v42;
  if ( v43 < 0 )
  {
    goto LABEL_56;
  }
  v44 = v43 + 9;
  if ( v44 < 0 )
  {
    goto LABEL_56;
  }
  v45 = Size + v44;
  if ( v45 < 0 )
  {
    goto LABEL_56;
  }
  n0xFa_1 = n0xFa;
  n4_1 = n4;
  n0xFa_19 = v45 + 15;
LABEL_58:
  v24 = v167;
  n0xFa_2 = n0xFa_19;
  if ( n0xFa_19 < 0 )
  {
    n0xFa_2 = 0;
  }
  v47 = (unsigned int)n0xFa_19 >> 31;
LABEL_62:
  i_3 = i_1;
  if ( (a18 & 0x10) != 0 && qword_1498089A8 )
  {
    v49 = a10;
    v50 = v166;
    if ( n0xFa_2 >= (int)n0xFa_1 )
    {
      v47 = 1;
    }
    else
    {
      v51 = qword_1498089A8(
              v168,
              v166,
              n4_1,
              Src_1,
              v24,
              v170,
              i_1,
              v169,
              a10,
              (char *)Buffer_1 + n0xFa_2,
              n0xFa_1 - n0xFa_2,
              &a18);
      if ( v51 < 0 )
      {
        v47 = 1;
      }
      else
      {
        n0xFa_2 += v51;
      }
    }
  }
  else
  {
    v50 = v166;
    v49 = a10;
  }
  if ( (a18 & 0xFFF00) == 0 || !qword_1498089B0 )
  {
    goto LABEL_77;
  }
  if ( n0xFa_2 >= (int)n0xFa )
  {
    v47 = 1;
LABEL_77:
    n4_2 = n4;
    goto LABEL_78;
  }
  v155 = v24;
  n4_2 = n4;
  v53 = qword_1498089B0(
          a18,
          v168,
          v50,
          n4,
          Src_1,
          v155,
          v170,
          i_1,
          v172,
          v169,
          v49,
          (char *)Buffer_1 + n0xFa_2,
          n0xFa - n0xFa_2,
          &v175,
          &v173);
  if ( v53 < 0 )
  {
    v47 = 1;
  }
  else
  {
    n0xFa_2 += v53;
  }
LABEL_78:
  v54 = (a18 & 8) != 0 && qword_1498089A0;
  v162 = v54;
  v55 = (a18 & 1) != 0 && n2_1 == 2;
  v160 = v55;
  v56 = (a18 & 2) != 0 && n2_2 == 2;
  v161 = v56;
  if ( !v54 && !v55 && !v56 )
  {
    n4_3 = n4;
    v151 = v168;
    goto LABEL_383;
  }
  if ( qword_149808978 )
  {
    if ( n0xFa_2 >= (int)n0xFa_3 )
    {
      n0xFa_5 = n0xFa + 128;
      n0xF_3 = n0xFa + 128;
      n0xF_2 = n0xFa + 128;
      goto LABEL_104;
    }
    v57 = qword_149808978((char *)Buffer_1 + n0xFa_2, n0xFa_3 - n0xFa_2);
    if ( v57 < 0 )
    {
      v47 = 1;
      n0xF_3 = n0xFa + 128;
      n0xFa_4 = n0xFa_2;
      n0xFa_5 = n0xFa + 128;
      n0xF_2 = n0xFa + 128;
      goto LABEL_98;
    }
    n0xFa_2 += v57;
  }
  n0xF_3 = n0xFa + 128;
  n0xFa_4 = n0xFa_2;
  n0xFa_5 = n0xFa + 128;
  n0xF_2 = n0xFa + 128;
  if ( n0xFa_2 < (int)n0xFa_3 )
  {
LABEL_98:
    v61 = sub_1402FC940(
            (__int64)Buffer_1,
            n0xFa_3,
            n0xFa_2,
            (__int64)",\"@severity\":",
            (unsigned int *)&n0xF_1,
            (__int64)",\"severity\":\"",
            (__int64)&off_1495F6738[0][n4_2],
            (__int64)"\",\"tags\":[");
    if ( v61 < 0 )
    {
      v47 = 1;
    }
    n0xFa_2 += v61;
    if ( v61 < 0 )
    {
      n0xFa_2 = n0xFa_4;
    }
    goto LABEL_105;
  }
LABEL_104:
  v47 = 1;
LABEL_105:
  v62 = v167;
  v63 = v167[1];
  v64 = *v167;
  v65 = (v63 - *v167) >> 2;
  if ( !v65 )
  {
    goto LABEL_154;
  }
  v66 = 0;
  v165 = 0;
  if ( v65 == 1 )
  {
    goto LABEL_143;
  }
  do
  {
    LODWORD(n0xF_1) = n0xF_2;
    n0xFa_6 = n0xFa_5;
    if ( n0xFa_2 >= n0xFa_5 )
    {
      goto LABEL_140;
    }
    v67 = qword_149808630;
    v68 = *(unsigned int *)(v64 + 4 * v66);
    if ( n0xFa_2 + 1LL >= n0xFa_3 )
    {
      goto LABEL_140;
    }
    if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
    {
      *errno() = 22;
LABEL_114:
      invalid_parameter_noinfo();
      goto LABEL_115;
    }
    if ( n0xFa_3 == n0xFa_2 )
    {
      *errno() = 34;
      goto LABEL_114;
    }
    *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
LABEL_115:
    v69 = *(_BYTE **)(v67 + 8 * v68);
    v70 = n0xFa_2 + 1LL;
    Size_6 = -1;
    do
    {
      ++Size_6;
    }
    while ( v69[Size_6] );
    if ( Size_6 + v70 >= n0xFa_15 )
    {
LABEL_138:
      n0xFa_3 = n0xFa + 128;
LABEL_139:
      n0xFa_5 = n0xFa_6;
      n0xF_2 = n0xF_1;
      v66 = v165;
      v62 = v167;
      goto LABEL_140;
    }
    Size_7 = n0xFa_15 - v70;
    v73 = (char *)Buffer_1 + v70;
    if ( Size_6 )
    {
      if ( !v73 )
      {
        goto LABEL_120;
      }
      if ( v69 && Size_7 >= Size_6 )
      {
        memcpy(v73, v69, Size_6);
        goto LABEL_128;
      }
      memset(v73, 0, n0xFa_15 - v70);
      if ( v69 )
      {
        if ( Size_7 >= Size_6 )
        {
          goto LABEL_128;
        }
        *errno() = 34;
      }
      else
      {
LABEL_120:
        *errno() = 22;
      }
      invalid_parameter_noinfo();
    }
LABEL_128:
    if ( (Size_6 & 0x80000000) != 0LL )
    {
      goto LABEL_138;
    }
    v74 = v70 + (int)Size_6;
    n0xFa_3 = n0xFa + 128;
    if ( v74 + 2 >= n0xFa_15 )
    {
      goto LABEL_139;
    }
    n2 = n0xFa_15 - v74;
    v76 = (_WORD *)((char *)Buffer_1 + v74);
    if ( v76 )
    {
      if ( n2 >= 2 )
      {
        *v76 = 11298;
        goto LABEL_136;
      }
      memset(v76, 0, n2);
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
LABEL_136:
    v77 = (int)Size_6 + 3 < 0;
    v78 = Size_6 + 3;
    v66 = v165;
    v62 = v167;
    n0xFa_5 = n0xFa_6;
    n0xF_2 = n0xF_1;
    if ( !v77 )
    {
      n0xFa_2 += v78;
      goto LABEL_141;
    }
LABEL_140:
    v47 = 1;
LABEL_141:
    v63 = v62[1];
    ++v66;
    v64 = *v62;
    v79 = v63 - *v62;
    v165 = v66;
  }
  while ( v66 < (v79 >> 2) - 1 );
  n0xF_3 = n0xF_2;
LABEL_143:
  if ( n0xFa_2 >= n0xFa_5 )
  {
    goto LABEL_157;
  }
  v80 = qword_149808630;
  v81 = *(unsigned int *)(v64 + 4 * ((v63 - v64) >> 2) - 4);
  if ( n0xFa_2 + 1LL >= n0xFa_3 )
  {
    goto LABEL_166;
  }
  if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
  {
    *errno() = 22;
    goto LABEL_150;
  }
  if ( n0xFa_3 == n0xFa_2 )
  {
    *errno() = 34;
LABEL_150:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
  }
  v82 = sub_1402FC670((__int64)Buffer_1, n0xFa_3, n0xFa_2 + 1LL, (const void **)(v80 + 8 * v81), "\"");
  if ( v82 < 0 || (v83 = v82 + 1, v83 < 0) )
  {
LABEL_166:
    n0xF_4 = n0xF_2;
    n0xFa_7 = n0xFa_5;
    v47 = 1;
    n0xFa_8 = n0xFa_2;
    n0xFa_9 = n0xFa_2;
    goto LABEL_155;
  }
  n0xFa_2 += v83;
  n0xF_3 = n0xF_2;
LABEL_154:
  n0xF_4 = n0xF_2;
  n0xFa_7 = n0xFa_5;
  n0xFa_8 = n0xFa_2;
  n0xFa_9 = n0xFa_2;
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_157:
    v47 = 1;
  }
  else
  {
LABEL_155:
    if ( n0xFa_2 + 11LL >= n0xFa_3 )
    {
      n0xFa_2 = n0xFa_9;
      n0xF_3 = n0xF_2;
      goto LABEL_157;
    }
    Size_8 = n0xFa_3 - n0xFa_2;
    v92 = (double *)((char *)Buffer_1 + n0xFa_2);
    if ( !v92 )
    {
      *errno() = 22;
      goto LABEL_172;
    }
    if ( Size_8 < 0xB )
    {
      memset(v92, 0, Size_8);
      *errno() = 34;
LABEL_172:
      invalid_parameter_noinfo();
    }
    else
    {
      *v92 = 0x746E657665222C5DLL;
      *((_WORD *)v92 + 4) = 14882;
      *((_BYTE *)v92 + 10) = 34;
    }
    n0xF_3 = n0xF_4;
    n0xFa_2 = n0xFa_8 + 11;
    n0xFa_5 = n0xFa_7;
    n0xF_2 = n0xF_4;
  }
  if ( *Src_1 )
  {
    Src_2 = Src_1;
    do
    {
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        v89 = sub_1402FE910((double *)((char *)Buffer_1 + n0xFa_2), (int)n0xFa - n0xFa_2, *Src_2);
        if ( v89 < 0 )
        {
          v47 = 1;
        }
        n0xFa_10 = v89 + n0xFa_2;
        if ( v89 < 0 )
        {
          n0xFa_10 = n0xFa_2;
        }
        n0xFa_2 = n0xFa_10;
      }
      ++Src_2;
    }
    while ( *Src_2 );
    n0xF_2 = n0xF_3;
    n0xFa_3 = n0xFa + 128;
  }
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_180:
    v47 = 1;
  }
  else
  {
    if ( n0xFa_2 + 13LL >= n0xFa_3 )
    {
      n0xF_3 = n0xF_2;
      goto LABEL_180;
    }
    Size_9 = n0xFa_3 - n0xFa_2;
    v98 = (double *)((char *)Buffer_1 + n0xFa_2);
    if ( !v98 )
    {
      *errno() = 22;
      goto LABEL_194;
    }
    if ( Size_9 < 0xD )
    {
      memset(v98, 0, Size_9);
      *errno() = 34;
LABEL_194:
      invalid_parameter_noinfo();
    }
    else
    {
      *v98 = 0x617373656D222C22LL;
      *((_DWORD *)v98 + 2) = 975332711;
      *((_BYTE *)v98 + 12) = 34;
    }
    n0xFa_2 += 13;
    n0xF_3 = n0xF_2;
  }
  if ( i_1 > 0 )
  {
    v93 = v170;
    for ( i_4 = 0; i_4 < i_1; ++i_4 )
    {
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        v95 = sub_1402FE910((double *)((char *)Buffer_1 + n0xFa_2), (int)n0xFa - n0xFa_2, *(_BYTE *)(v93 + i_4));
        if ( v95 < 0 )
        {
          v47 = 1;
        }
        n0xFa_11 = v95 + n0xFa_2;
        if ( v95 < 0 )
        {
          n0xFa_11 = n0xFa_2;
        }
        n0xFa_2 = n0xFa_11;
      }
    }
    n0xF_2 = n0xF_3;
    n0xFa_3 = n0xFa + 128;
  }
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_217:
    v47 = 1;
    goto LABEL_218;
  }
  if ( n0xFa_2 + 1LL < n0xFa_3 )
  {
    v99 = (char *)Buffer_1 + n0xFa_2;
    if ( v99 )
    {
      if ( n0xFa_3 != n0xFa_2 )
      {
        *v99 = 34;
LABEL_208:
        ++n0xFa_2;
        goto LABEL_209;
      }
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
    goto LABEL_208;
  }
  v47 = 1;
LABEL_209:
  if ( n0xFa_2 >= n0xFa_5 || n0xFa_2 + 11LL >= n0xFa_3 )
  {
    goto LABEL_217;
  }
  Size_10 = n0xFa_3 - n0xFa_2;
  v101 = (double *)((char *)Buffer_1 + n0xFa_2);
  if ( !v101 )
  {
    *errno() = 22;
    goto LABEL_216;
  }
  if ( Size_10 < 0xB )
  {
    memset(v101, 0, Size_10);
    *errno() = 34;
LABEL_216:
    invalid_parameter_noinfo();
    n0xFa_2 += 11;
  }
  else
  {
    *v101 = 0x6F746F727040222CLL;
    n0xFa_2 += 11;
    *((_WORD *)v101 + 4) = 14882;
    *((_BYTE *)v101 + 10) = 34;
  }
LABEL_218:
  n0xFa_12 = n0xFa_2;
  if ( n0xFa_2 >= (int)n0xFa )
  {
    v47 = 1;
  }
  else
  {
    v103 = sub_140303140(
             (__int64)Buffer_1,
             n0xFa,
             n0xFa_2,
             v172,
             v169,
             a10,
             a11,
             1,
             (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FB080);
    if ( v103 < 0 )
    {
      v47 = 1;
    }
    n0xFa_2 += v103;
    if ( v103 < 0 )
    {
      n0xFa_2 = n0xFa_12;
    }
  }
  if ( n0xFa_2 >= n0xFa_5 || n0xFa_2 + 1LL >= n0xFa_3 )
  {
    v47 = 1;
  }
  else
  {
    v104 = (char *)Buffer_1 + n0xFa_2;
    if ( !v104 )
    {
      *errno() = 22;
      goto LABEL_231;
    }
    if ( n0xFa_3 == n0xFa_2 )
    {
      *errno() = 34;
LABEL_231:
      invalid_parameter_noinfo();
      ++n0xFa_2;
    }
    else
    {
      *v104 = 34;
      ++n0xFa_2;
    }
  }
  n0xF_5 = n0xF;
  v106 = 0;
  n0xF_1 = 0;
  v107 = 0;
  n0xF_8 = 0;
  if ( n0xF )
  {
    while ( !v47 )
    {
      v109 = *(_QWORD *)(i_2 + 8 * n0xF_8);
      v165 = v109;
      if ( v107 != *(_QWORD *)(v109 + 8) )
      {
        if ( v106 )
        {
          if ( n0xFa_2 < n0xF_2 )
          {
            if ( n0xFa_2 + 2LL >= n0xFa_3 )
            {
              v110 = *(_QWORD *)(v109 + 80);
              v47 = 1;
              n0xF_6 = n0xF_2;
              n0xFa_13 = n0xFa_2;
              n0xF_7 = n0xF_2;
              v113 = v110 != -1;
              n0xFa_14 = n0xFa_2;
              goto LABEL_257;
            }
            Size_11 = n0xFa_3 - n0xFa_2;
            v116 = (_WORD *)((char *)Buffer_1 + n0xFa_2);
            if ( !v116 )
            {
              *errno() = 22;
              goto LABEL_245;
            }
            if ( Size_11 < 2 )
            {
              memset(v116, 0, Size_11);
              *errno() = 34;
LABEL_245:
              invalid_parameter_noinfo();
              n0xFa_2 += 2;
            }
            else
            {
              *v116 = 11357;
              n0xFa_2 += 2;
            }
LABEL_256:
            v118 = *(_QWORD *)(v109 + 80);
            n0xFa_13 = n0xFa_2;
            n0xF_6 = n0xF_2;
            n0xF_7 = n0xF_2;
            n0xFa_14 = n0xFa_2;
            v106 = v118 != -1;
            v110 = v118;
            v113 = v106;
            if ( n0xFa_2 < n0xF_2 )
            {
LABEL_257:
              v119 = n0xFa + 128;
              if ( n0xFa_2 + 1LL >= n0xFa_15 )
              {
                v109 = v165;
                n0xF_2 = n0xF_7;
                n0xFa_2 = n0xFa_13;
                v106 = v113;
                v118 = v110;
                goto LABEL_292;
              }
              Buffer_3 = Buffer_1;
              if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
              {
                *errno() = 22;
                goto LABEL_264;
              }
              if ( n0xFa_15 == n0xFa_2 )
              {
                *errno() = 34;
LABEL_264:
                invalid_parameter_noinfo();
                Buffer_3 = Buffer_1;
                v119 = n0xFa + 128;
              }
              else
              {
                *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
              }
              v121 = *(_BYTE **)(v109 + 8);
              v122 = n0xFa_2 + 1LL;
              Size_12 = -1;
              do
              {
                ++Size_12;
              }
              while ( v121[Size_12] );
              if ( Size_12 + v122 >= v119 )
              {
                goto LABEL_289;
              }
              v124 = (char *)Buffer_3 + v122;
              Size_13 = v119 - v122;
              if ( Size_12 )
              {
                if ( !v124 )
                {
                  goto LABEL_270;
                }
                if ( v121 && Size_13 >= Size_12 )
                {
                  memcpy(v124, v121, Size_12);
                  goto LABEL_278;
                }
                memset(v124, 0, v119 - v122);
                if ( !v121 )
                {
LABEL_270:
                  *errno() = 22;
                  goto LABEL_277;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 34;
LABEL_277:
                  invalid_parameter_noinfo();
                }
LABEL_278:
                v119 = n0xFa + 128;
                Buffer_3 = Buffer_1;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v126 = v122 + (int)Size_12, v126 + 2 >= v119) )
              {
LABEL_289:
                n0xF_2 = n0xF_6;
                n0xFa_2 = n0xFa_14;
                v106 = v113;
                v118 = v110;
              }
              else
              {
                Size_14 = v119 - v126;
                v128 = (_WORD *)((char *)Buffer_3 + v126);
                if ( !v128 )
                {
                  *errno() = 22;
                  goto LABEL_286;
                }
                if ( Size_14 < 2 )
                {
                  memset(v128, 0, Size_14);
                  *errno() = 34;
LABEL_286:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v128 = 14882;
                }
                n0xF_2 = n0xF_6;
                v77 = (int)Size_12 + 3 < 0;
                v129 = Size_12 + 3;
                n0xFa_2 = n0xFa_14;
                v118 = v110;
                v106 = v113;
                if ( !v77 )
                {
                  v109 = v165;
                  n0xFa_2 = v129 + n0xFa_14;
                  goto LABEL_293;
                }
              }
              v109 = v165;
            }
LABEL_292:
            v47 = 1;
LABEL_293:
            if ( v118 != -1 )
            {
              if ( n0xFa_2 < n0xF_2 && n0xFa_2 + 1LL < n0xFa_15 )
              {
                v130 = (char *)Buffer_1 + n0xFa_2;
                if ( !v130 )
                {
                  *errno() = 22;
                  goto LABEL_301;
                }
                if ( n0xFa_15 == n0xFa_2 )
                {
                  *errno() = 34;
LABEL_301:
                  invalid_parameter_noinfo();
                  v107 = *(_QWORD *)(v109 + 8);
                  n0xF_8 = n0xF_1;
                  ++n0xFa_2;
                }
                else
                {
                  n0xF_8 = n0xF_1;
                  ++n0xFa_2;
                  *v130 = 91;
                  v107 = *(_QWORD *)(v109 + 8);
                }
LABEL_315:
                Buffer_4 = Buffer_1;
                goto LABEL_316;
              }
              v47 = 1;
            }
            v107 = *(_QWORD *)(v109 + 8);
            n0xF_8 = n0xF_1;
            goto LABEL_315;
          }
LABEL_291:
          v118 = *(_QWORD *)(v109 + 80);
          v106 = v118 != -1;
          goto LABEL_292;
        }
        if ( n0xFa_2 >= n0xF_2 )
        {
          goto LABEL_291;
        }
        if ( n0xFa_2 + 1LL >= n0xFa_3 )
        {
          v110 = *(_QWORD *)(v109 + 80);
          n0xF_7 = n0xF_2;
          n0xF_6 = n0xF_2;
          v47 = 1;
          n0xFa_13 = n0xFa_2;
          v113 = v110 != -1;
          n0xFa_14 = n0xFa_2;
          goto LABEL_257;
        }
        v117 = (char *)Buffer_1 + n0xFa_2;
        if ( !v117 )
        {
          *errno() = 22;
          goto LABEL_254;
        }
        if ( n0xFa_3 == n0xFa_2 )
        {
          *errno() = 34;
LABEL_254:
          invalid_parameter_noinfo();
        }
        else
        {
          *v117 = 44;
        }
        ++n0xFa_2;
        goto LABEL_256;
      }
      if ( !v107 || n0xF_8 >= n0xF_5 )
      {
        goto LABEL_315;
      }
      if ( n0xFa_2 >= n0xF_2 || n0xFa_2 + 1LL >= n0xFa_3 )
      {
        v47 = 1;
        goto LABEL_315;
      }
      n0xFa_16 = n0xFa_3;
      Buffer_4 = Buffer_1;
      v133 = n0xFa_16 - n0xFa_2;
      v134 = (char *)Buffer_1 + n0xFa_2;
      if ( v134 )
      {
        if ( v133 )
        {
          *v134 = 44;
          ++n0xFa_2;
          goto LABEL_316;
        }
        *errno() = 34;
      }
      else
      {
        *errno() = 22;
      }
      invalid_parameter_noinfo();
      ++n0xFa_2;
LABEL_316:
      n0xFa_17 = n0xFa_2;
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(v154) = 1;
        v136 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v165 + 32))(
                 *(_QWORD *)v165,
                 (char *)Buffer_4 + n0xFa_2,
                 n0xFa - n0xFa_2,
                 0,
                 v154,
                 0);
        if ( v136 < 0 )
        {
          v47 = 1;
        }
        n0xFa_2 += v136;
        if ( v136 < 0 )
        {
          n0xFa_2 = n0xFa_17;
        }
        if ( !v47 )
        {
          n0xFa_3 = n0xFa + 128;
          goto LABEL_323;
        }
      }
      n0xFa_3 = n0xFa + 128;
      if ( n0xFa_2 >= n0xF_2 )
      {
        v47 = 1;
LABEL_323:
        Buffer_5 = Buffer_1;
      }
      else
      {
        Buffer_5 = Buffer_1;
        if ( n0xFa_2 + 6LL >= n0xFa_15 )
        {
          v47 = 1;
          goto LABEL_324;
        }
        Size_15 = n0xFa_15 - n0xFa_2;
        v140 = (_WORD *)((char *)Buffer_1 + n0xFa_2);
        if ( !v140 )
        {
          *errno() = 22;
          goto LABEL_340;
        }
        if ( Size_15 < 6 )
        {
          memset(v140, 0, Size_15);
          *errno() = 34;
LABEL_340:
          invalid_parameter_noinfo();
          n0xFa_2 += 6;
        }
        else
        {
          n0xFa_2 += 6;
          *(_DWORD *)v140 = 1819635234;
          v140[2] = 8812;
        }
      }
LABEL_324:
      n0xF_5 = n0xF;
      if ( (n0xF_8 == n0xF - 1 || v47) && v106 )
      {
        if ( n0xFa_2 >= n0xF_2 || n0xFa_2 + 1LL >= n0xFa_3 )
        {
          v47 = 1;
        }
        else
        {
          v138 = (char *)Buffer_5 + n0xFa_2;
          if ( !v138 )
          {
            *errno() = 22;
            goto LABEL_345;
          }
          if ( n0xFa_3 == n0xFa_2 )
          {
            *errno() = 34;
LABEL_345:
            invalid_parameter_noinfo();
            n0xF_5 = n0xF;
            ++n0xFa_2;
          }
          else
          {
            *v138 = 93;
            ++n0xFa_2;
          }
        }
      }
      n0xF_1 = ++n0xF_8;
      if ( n0xF_8 >= n0xF_5 )
      {
        break;
      }
      continue;
    }
  }
  v141 = a19;
  if ( a19 <= 1 )
  {
    Buffer_2 = Buffer_1;
LABEL_353:
    if ( !v47 )
    {
      goto LABEL_363;
    }
    if ( n0xFa_2 < n0xF_2 )
    {
      goto LABEL_355;
    }
    goto LABEL_374;
  }
  if ( n0xFa_2 >= n0xF_2 )
  {
    goto LABEL_374;
  }
  Buffer_2 = Buffer_1;
  v142 = sub_1402FC7C0((__int64)Buffer_1, n0xFa_3, n0xFa_2, (__int64)",\"EVT_COUNT\":", &a19);
  if ( v142 >= 0 )
  {
    n0xFa_2 += v142;
    goto LABEL_353;
  }
LABEL_355:
  if ( n0xFa_2 + 13LL < n0xFa_3 )
  {
    Size_16 = n0xFa_3 - n0xFa_2;
    v144 = (double *)((char *)Buffer_2 + n0xFa_2);
    if ( !v144 )
    {
      *errno() = 22;
      goto LABEL_361;
    }
    if ( Size_16 < 0xD )
    {
      memset(v144, 0, Size_16);
      *errno() = 34;
LABEL_361:
      invalid_parameter_noinfo();
    }
    else
    {
      *v144 = 0x4C465245564F222CLL;
      *((_DWORD *)v144 + 2) = 975329103;
      *((_BYTE *)v144 + 12) = 49;
    }
    n0xFa_2 += 13;
LABEL_363:
    if ( n0xFa_2 >= n0xF_2 )
    {
      goto LABEL_374;
    }
  }
  if ( n0xFa_2 + 2LL >= n0xFa_3 )
  {
    n0xFa_18 = n0xFa_2;
    *((_BYTE *)Buffer_2 + n0xFa_2) = 0;
  }
  else
  {
    Size_17 = n0xFa_3 - n0xFa_2;
    v146 = (_WORD *)((char *)Buffer_2 + n0xFa_2);
    if ( !v146 )
    {
      *errno() = 22;
      goto LABEL_370;
    }
    if ( Size_17 < 2 )
    {
      memset(v146, 0, Size_17);
      *errno() = 34;
LABEL_370:
      invalid_parameter_noinfo();
    }
    else
    {
      *v146 = 2685;
    }
    n0xFa_2 += 2;
    if ( n0xFa_2 < n0xF_2 )
    {
      n0xFa_18 = n0xFa_2;
      *((_BYTE *)Buffer_2 + n0xFa_2) = 0;
      goto LABEL_375;
    }
LABEL_374:
    Buffer_2 = Buffer_1;
    n0xFa_18 = n0xFa_2;
  }
LABEL_375:
  *((_BYTE *)Buffer_2 + n0xFa_3 - 1) = 0;
  if ( v160 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_2, n0xFa_18, 1u, Stream);
  }
  if ( v161 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_2, n0xFa_18, 1u, Stream_1);
  }
  n4_3 = n4;
  v151 = v168;
  if ( v162 )
  {
    v156 = v141;
    v152 = v166;
    qword_1498089A0(v168, v166, n4, Buffer_2, n0xFa_18, v156);
    i_3 = i_1;
    goto LABEL_384;
  }
  i_3 = i_1;
LABEL_383:
  v152 = v166;
LABEL_384:
  if ( v173 )
  {
    v173(
      a18,
      v151,
      v152,
      n4_3,
      Src_1,
      v167,
      v170,
      i_3,
      v172,
      v169,
      a10,
      (char *)Buffer_2 + n0xFa_2,
      n0xFa - n0xFa_2,
      &v175);
  }
  return (unsigned int)n0xFa_2;
}

// --- End Function: sub_140300B90 (0x140300B90) ---

// --- Function: sub_140302260 (0x140302260) ---
unsigned __int64 __fastcall sub_140302260(__int64 a1, unsigned __int64 a2)
{
  const void *v4; // rcx
  unsigned __int64 result; // rax
  __int64 v6; // rdi
  unsigned __int64 n0x6400000; // rcx
  __int64 v8; // rdi
  __int64 v9; // rax
  _QWORD *v10; // rbx

  v4 = *(const void **)a1;
  result = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3;
  if ( a2 > result )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    {
      unknown_libname_10();
    }
    v6 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    n0x6400000 = 8 * a2;
    v8 = v6 >> 3;
    if ( 8 * a2 < 0x1000 )
    {
      if ( n0x6400000 )
      {
        v10 = (_QWORD *)sub_1402A1E30(n0x6400000);
      }
      else
      {
        v10 = 0;
      }
    }
    else
    {
      if ( n0x6400000 + 39 < n0x6400000 )
      {
        sub_1402DEE40();
      }
      v9 = sub_1402A1E30(n0x6400000 + 39);
      if ( !v9 )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v9;
    }
    memmove(v10, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    return (unsigned __int64)sub_1402FD6B0((const void **)a1, (__int64)v10, v8, a2);
  }
  return result;
}

// --- End Function: sub_140302260 (0x140302260) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 v13; // r13
  char result; // al
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  __int64 v18; // r15
  _QWORD *v19; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  __int64 *v22; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v24; // rcx
  _QWORD *v25; // rbx
  _BYTE *v26; // rdx
  _BYTE *v27; // rdx
  __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *v31; // r14
  __int64 *v32; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  __int64 v42; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *Buf2_1; // r15
  _QWORD **v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *v56; // rcx
  __m256 *Buf2_2; // rax
  __int64 *v58; // rax
  __int64 *v59; // r14
  __int64 v60; // rcx
  _QWORD *v61; // rbx
  _BYTE *v62; // rdx
  _BYTE *v63; // rdx
  __int64 v64; // r10
  __int64 v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 Buffer_3; // rax
  const void *Buffer_5; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  Stream *Stream; // rax
  int n2; // r8d
  Stream *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 Buffer_4; // rax
  const void *Buffer_6; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  Stream *Stream_2; // rax
  Stream *Stream_3; // rax
  const void **v103; // rsi
  _QWORD **v104; // rcx
  _QWORD *v105; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *v107; // rdi
  _QWORD *v108; // rcx
  __int64 *v109; // rbx
  _QWORD *v110; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  __int64 *v114; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  __int64 v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *v121; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 v123; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *v125; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  _QWORD *v129; // [rsp+128h] [rbp+88h] BYREF
  __int64 *v130; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *v131; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **v135; // [rsp+158h] [rbp+B8h] BYREF
  __int64 v136; // [rsp+160h] [rbp+C0h]
  __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  v121 = (_QWORD *)a5;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v13 = a6;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, a5, a6);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  v135 = 0;
  v15 = 0;
  v130 = (__int64 *)&v135;
  n0x400 = 0;
  v114 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !a6 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  v19 = v121;
  v20 = v112;
  v125 = v121;
  while ( 2 )
  {
    v21 = *((_BYTE *)v19 + 89) == 0;
    v131 = v19;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = v19;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    v123 = (unsigned __int64)v19;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = v19;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v114 = (__int64 *)sub_1402A1E30(0x18u);
        v15 = v114;
        if ( v114 )
        {
          v22 = v114;
          *v114 = 0;
          n0x400_1 = 0;
          v15[1] = 0;
          v24 = (__int64)v15;
          v15[2] = 0;
        }
        else
        {
          v15 = 0;
          v22 = 0;
          n0x400_1 = 0;
          v114 = 0;
          v24 = 0;
        }
        sub_140302260(v24, v13);
        v25 = v141;
        do
        {
          v26 = (_BYTE *)v22[1];
          if ( v26 == (_BYTE *)v22[2] )
          {
            sub_1402A47D0(v15, v26, v25);
          }
          else
          {
            *(_QWORD *)v26 = *v25;
            v22[1] += 8;
          }
          ++n0x400_1;
          ++v25;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        v19 = v125;
      }
      v27 = (_BYTE *)v15[1];
      if ( v27 == (_BYTE *)v15[2] )
      {
        __asm { vzeroupper }
        sub_1402A47D0(v15, v27, &v123);
      }
      else
      {
        *(_QWORD *)v27 = v19;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    v19[1] = sub_1402FD110(&v130, (__int64)v19);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64))v19[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    v123 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*v19, &v124, &v123, v28);
    v31 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    v32 = v130;
    do
    {
      v131 = v31;
      v31[10] = v18;
      v21 = v31[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)v31[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*v32 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)sub_1402A1E30(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)sub_1402A1E30(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *v32 = (__int64)v33;
        }
        v35 = (_BYTE *)v31[1];
        Size_2 = -1;
        memset(&v138, 0, sizeof(v138));
        Size_1 = -1;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)v31[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        v42 = *v32;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        Buf2_1 = *(__m256 **)v138.m256_f32;
        v129 = (_QWORD *)v42;
        v45 = *(_QWORD ***)v42;
        v46 = **(_QWORD ***)v42;
        if ( v46 == *(_QWORD **)v42 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = Buf2_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        v42 = (__int64)v129;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *(_QWORD *)(v42 + 8) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = sub_1402A1E30(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 32) = 0;
          *(_QWORD *)(v51 + 40) = 0;
          *(__m256 *)(v51 + 16) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*(_QWORD *)(v42 + 8);
          v53 = v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = (_QWORD *)v51;
          *v53 = v51;
          v54 = *(_QWORD *)*v32;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 40LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v56 = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v56 = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)v56 - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(v56);
          }
          v15 = v114;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            Buf2_2 = Buf2_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              Buf2_1 = *(__m256 **)&Buf2_1[-1].m256_f32[6];
              if ( (unsigned __int64)((char *)Buf2_2 - (char *)Buf2_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(Buf2_1);
          }
          v15 = v114;
          n0x400_2 = 0;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
        }
      }
      v31[1] = v55;
      n0x400 = n0xF;
      v129 = v31;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !v15 )
        {
          __asm { vzeroupper }
          v58 = (__int64 *)sub_1402A1E30(0x18u);
          v15 = v58;
          v114 = v58;
          if ( v58 )
          {
            *v58 = 0;
            v59 = v58;
            v58[1] = 0;
            v60 = (__int64)v58;
            v58[2] = 0;
          }
          else
          {
            v15 = 0;
            v114 = 0;
            v59 = 0;
            v60 = 0;
          }
          sub_140302260(v60, a6);
          v61 = v141;
          do
          {
            v62 = (_BYTE *)v59[1];
            if ( v62 == (_BYTE *)v59[2] )
            {
              sub_1402A47D0(v15, v62, v61);
            }
            else
            {
              *(_QWORD *)v62 = *v61;
              v59[1] += 8;
            }
            ++n0x400_2;
            ++v61;
          }
          while ( n0x400_2 < 0x400 );
          v31 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        v63 = (_BYTE *)v15[1];
        if ( v63 == (_BYTE *)v15[2] )
        {
          __asm { vzeroupper }
          sub_1402A47D0(v15, v63, &v129);
        }
        else
        {
          *(_QWORD *)v63 = v31;
          v15[1] += 8;
        }
      }
      else
      {
        v141[n0xF] = v31;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      v31 += 13;
      a13 = v30;
      *(_QWORD *)v116 = v31;
    }
    while ( v30 < v124 );
    v19 = v125;
LABEL_94:
    v28 = v137;
    v13 = a6;
    if ( v123 > 1 )
    {
      v28 = -1;
    }
    v64 = v123 + v117;
    v117 += v123;
LABEL_98:
    v19 += 13;
    v125 = v19;
    v131[10] = v28;
    if ( ++v132 < v13 )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v114 = v15;
  n0xF = n0x400;
  v117 = v64;
  if ( !v15 )
  {
    goto LABEL_106;
  }
  if ( !((v15[1] - *v15) >> 3) )
  {
    __debugbreak();
  }
  i = (char *)*v15;
  v114 = v15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 80LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 80LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 80) = -(__int64)(*(_QWORD *)(v71 + 80) != -1);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (v65 + 1) << 10;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    Buffer_5 = 0;
  }
  else
  {
    Buffer_3 = sub_1402A1E30(Size);
    Buffer_5 = (const void *)Buffer_3;
    if ( Buffer_3 )
    {
      Buffer_1 = (char *)Buffer_3;
      goto LABEL_131;
    }
  }
  v79 = Size + 15;
  if ( Size + 15 < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && qword_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, v121, a6, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            v121,
            a6,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    sub_1402F5120(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    sub_1402F5120(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((n0xF + 2 * v117 + v117 + 32) << 7);
    }
    n0x8000_2 = v93 + 128;
    if ( *p_n0x8000_1 < v93 + 128 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      Buffer_6 = 0;
    }
    else
    {
      Buffer_4 = sub_1402A1E30(n0x8000_2);
      Buffer_6 = (const void *)Buffer_4;
      if ( Buffer_4 )
      {
        Buffer_2 = (double *)Buffer_4;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 15;
    if ( n0x8000_2 + 15 < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      (__int64)v121,
      a6,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 128,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(Buffer_6);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  result = free_memory_wrapper(Buffer_5);
  v103 = v135;
  if ( v135 )
  {
    v104 = (_QWORD **)*v135;
    **((_QWORD **)*v135 + 1) = 0;
    v105 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = v105[5];
        v107 = (_QWORD *)*v105;
        if ( n0xF_2 > 0xF )
        {
          v108 = (_QWORD *)v105[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v108 - *(v108 - 1) - 8 > 0x1F )
            {
              goto LABEL_190;
            }
            v108 = (_QWORD *)*(v108 - 1);
          }
          free_memory_wrapper(v108);
        }
        v105[4] = 0;
        v105[5] = 15;
        *((_BYTE *)v105 + 16) = 0;
        free_memory_wrapper(v105);
        v105 = v107;
      }
      while ( v107 );
    }
    free_memory_wrapper(*v103);
    result = free_memory_wrapper(v103);
  }
  v109 = v114;
  if ( v114 )
  {
    v110 = (_QWORD *)*v114;
    if ( *v114 )
    {
      if ( ((v114[2] - (_QWORD)v110) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v110 - *(v110 - 1) - 8 > 0x1F )
        {
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        }
        v110 = (_QWORD *)*(v110 - 1);
      }
      free_memory_wrapper(v110);
      *v109 = 0;
      v109[1] = 0;
      v109[2] = 0;
    }
    return free_memory_wrapper(v109);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: swprintf (0x140303B50) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A2470();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0LL, va);
  if ( result < 0 )
  {
    return -1;
  }
  return result;
}

// --- End Function: swprintf (0x140303B50) ---

// --- Function: sub_140305AD0 (0x140305AD0) ---
_OWORD *__fastcall sub_140305AD0(const void **a1, _BYTE *a2, _OWORD *a3)
{
  __int64 v4; // r14
  signed __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned __int64 n0x6400000; // rdi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  void *v16; // rcx
  _BYTE *v18; // r8
  _BYTE *v19; // rdx
  size_t Size; // r8
  _BYTE *ptr_to_free; // rcx
  _OWORD *result; // rax

  _R12 = a3;
  v4 = a2 - (_BYTE *)*a1;
  v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) >> 4;
  if ( v5 == 0xFFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = v5 + 1;
  v9 = ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4;
  v10 = v9 >> 1;
  if ( v9 > 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    goto LABEL_24;
  }
  v11 = v8;
  if ( v10 + v9 >= v8 )
  {
    v11 = v10 + v9;
  }
  if ( v11 > 0xFFFFFFFFFFFFFFFLL )
  {
    goto LABEL_24;
  }
  n0x6400000 = 16 * v11;
  if ( n0x6400000 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      v14 = (_QWORD *)sub_1402A1E30(n0x6400000);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_13;
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_24:
    sub_1402DEE40();
  }
  v13 = sub_1402A1E30(n0x6400000 + 39);
  if ( !v13 )
  {
    goto LABEL_22;
  }
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  __asm { vmovups xmm0, xmmword ptr [r12] }
  v16 = v14;
  _R14 = (_OWORD *)((char *)v14 + (v4 & 0xFFFFFFFFFFFFFFF0uLL));
  __asm { vmovups xmmword ptr [r14], xmm0 }
  v18 = a1[1];
  v19 = *a1;
  if ( a2 == v18 )
  {
    Size = v18 - v19;
  }
  else
  {
    memmove(v14, v19, a2 - v19);
    v16 = _R14 + 1;
    Size = (_BYTE *)a1[1] - a2;
    v19 = a2;
  }
  memmove(v16, v19, Size);
  ptr_to_free = *a1;
  if ( *a1 )
  {
    if ( (((_BYTE *)a1[2] - ptr_to_free) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
LABEL_20:
      free_memory_wrapper(ptr_to_free);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&ptr_to_free[-*((_QWORD *)ptr_to_free - 1) - 8] <= 0x1F )
    {
      ptr_to_free = (_BYTE *)*((_QWORD *)ptr_to_free - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = v14;
  result = _R14;
  a1[1] = &v14[2 * v8];
  a1[2] = &v14[n0x6400000 / 8];
  return result;
}

// --- End Function: sub_140305AD0 (0x140305AD0) ---

// --- Function: is_valid_handle_typeA (0x14030C820) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *packed_handle_ptr)
{
  __int64 packed_handle_value; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 metadata_type; // cx

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_metadata_ptr = get_handle_metadata_ptr(packed_handle_value & 0xFFFFFFFFFFFFLL);
  metadata_type = *(_WORD *)(handle_metadata_ptr + 4);
  if ( metadata_type == 4 || *(_WORD *)(handle_metadata_ptr + 2) != (HIWORD(packed_handle_value) & 0xFFF) )
  {
    return 0;
  }
  if ( metadata_type != 2 || *(_QWORD *)get_tls_data_offset_784() )
  {
    return check_handle_access_by_state(packed_handle_ptr) != 0;
  }
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030C820) ---

// --- Function: is_valid_handle_typeB (0x14030C8B0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *packed_handle_ptr)
{
  unsigned __int64 packed_handle_value; // r9
  __int64 handle_ptr; // r10
  unsigned __int64 handle_flags; // r9
  __int64 mask_from_flag; // rax
  __int64 handle_ptr_copy; // r10
  __int64 metadata_ptr; // rbx
  bool is_thread_state_ok; // al

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_ptr = packed_handle_value & 0xFFFFFFFFFFFFLL;
  handle_flags = HIWORD(packed_handle_value);
  if ( (handle_flags & 0xF000) != 0 )
  {
    mask_from_flag = map_flag_to_mask(0x2000u);
    metadata_ptr = handle_ptr_copy & ~(mask_from_flag - 1);
  }
  else
  {
    metadata_ptr = handle_ptr - 6;
  }
  if ( *(_WORD *)(metadata_ptr + 2) != (handle_flags & 0xFFF) )
  {
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || (is_thread_state_ok = is_thread_flag_57_or_38_set()) )
  {
    is_thread_state_ok = 1;
  }
  return *(_WORD *)(metadata_ptr + 4) == 2 && is_thread_state_ok
      || check_handle_access_by_state_extended(packed_handle_ptr) != 0;
}

// --- End Function: is_valid_handle_typeB (0x14030C8B0) ---

// --- Function: check_handle_access_by_state (0x14031DD70) ---
// Checks access permissions for the provided packed handle. Retrieves handle
// metadata using `get_handle_metadata`. Validates access based on the state field
// (metadata + 4): - State 0: Returns false (invalid). - State 1: Checks if the
// handle's payload exists in a thread-local list using
// `check_thread_list_contains_value`. - State 2: Returns true if specific thread
// flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3: Checks thread
// state and compares the payload value against a constant using
// `check_thread_state_and_value_not_equal`. - Other states: Return false.
char __fastcall check_handle_access_by_state(_QWORD *packed_handle_ptr)
{
  __int64 handle_value; // rbx
  __int64 metadata_ptr; // rax
  _QWORD *payload_ptr; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  handle_value = *packed_handle_ptr & 0xFFFFFFFFFFFFLL;
  metadata_ptr = get_handle_metadata_ptr(handle_value);
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    payload_ptr_state1 = get_handle_payload_ptr(handle_value);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( *(_WORD *)(metadata_ptr + 4) == 3 )
    {
      payload_ptr = (_QWORD *)get_handle_payload_ptr(handle_value);
      return check_thread_state_and_value_not_equal(payload_ptr);
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  payload_ptr_state2 = get_handle_payload_ptr(handle_value);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: check_handle_access_by_state (0x14031DD70) ---

// --- Function: map_flag_to_mask (0x140322940) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
      {
        return 0;
      }
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( input_flag == 24576 )
        {
          return 0x4000000;
        }
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140322940) ---

// --- Function: sub_1403419D0 (0x1403419D0) ---
char *__fastcall sub_1403419D0(char **a1, _OWORD *a2)
{
  char *v2; // r15
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rsi
  __int64 v8; // r14
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned __int64 n0x6400000; // rsi
  char *v13; // rax
  char *v14; // rbp
  char *v15; // r14
  void *v16; // rcx
  char *v17; // r8
  char *v18; // rdx
  size_t Size; // r8

  v2 = a1[1];
  v4 = a1[2];
  if ( v2 == v4 )
  {
    v7 = 0xFFFFFFFFFFFFFFFLL;
    v8 = (v2 - *a1) >> 4;
    if ( v8 == 0xFFFFFFFFFFFFFFFLL )
    {
      unknown_libname_10();
    }
    v9 = (v4 - *a1) >> 4;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0xFFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
      {
        v7 = v8 + 1;
      }
    }
    n0x6400000 = 16 * v7;
    v13 = (char *)sub_14038E0B0((__int64)a1, n0x6400000);
    v14 = v13;
    v15 = &v13[16 * v8];
    v16 = v13;
    *(_OWORD *)v15 = *a2;
    v17 = a1[1];
    v18 = *a1;
    if ( v2 == v17 )
    {
      Size = v17 - v18;
    }
    else
    {
      memmove(v13, v18, v2 - v18);
      v16 = v15 + 16;
      Size = a1[1] - v2;
      v18 = v2;
    }
    memmove(v16, v18, Size);
    if ( *a1 )
    {
      sub_14039EFB0((__int64)a1, *a1, (a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL);
    }
    *a1 = v14;
    result = v15;
    a1[1] = &v14[16 * v11];
    a1[2] = &v14[n0x6400000];
  }
  else
  {
    *(_OWORD *)v2 = *a2;
    result = a1[1];
    a1[1] = result + 16;
  }
  return result;
}

// --- End Function: sub_1403419D0 (0x1403419D0) ---

// --- Function: sub_1403561D0 (0x1403561D0) ---
__int64 __fastcall sub_1403561D0(unsigned int a1)
{
  return a1;
}

// --- End Function: sub_1403561D0 (0x1403561D0) ---

// --- Function: initializeEmptyStringStructure (0x140357A40) ---
// Initializes the string structure pointed to by `a1` to represent an empty string
// by setting its internal pointer to the global empty string sentinel
// `qword_149808ABC + 4`.
void __fastcall initializeEmptyStringStructure(_QWORD *string_struct_ptr)
{
  *string_struct_ptr = (char *)&qword_149808ABC + 4;
}

// --- End Function: initializeEmptyStringStructure (0x140357A40) ---

// --- Function: DestroyStringObject (0x14036D270) ---
// Deallocates the memory buffer associated with a string object created by
// `CreateStringObjectFromString`.  It accesses metadata stored 8 bytes before the
// provided data pointer to get the allocation base pointer required by the
// deallocation function `sub_14739AF10`.  @param ppStringObjectData Pointer to the
// variable holding the pointer to the string object's data.
void __fastcall DestroyStringObject(_QWORD *ppStringObjectData)
{
  int *pStringMetadata; // rcx

  pStringMetadata = (int *)(*ppStringObjectData - 8LL);
  if ( pStringMetadata[1] > 0 )
  {
    sub_14739AF10(pStringMetadata);
  }
}

// --- End Function: DestroyStringObject (0x14036D270) ---

// --- Function: sub_14038E0B0 (0x14038E0B0) ---
__int64 __fastcall sub_14038E0B0(__int64 a1, unsigned __int64 n0x6400000)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403AF4C0();
  n0x40 = (n0x6400000 >> 8) + ((_BYTE)n0x6400000 != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
    {
      goto LABEL_7;
    }
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 64LL;
      if ( n0x4000 >= 0x4000 )
      {
        goto LABEL_2;
      }
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
      {
        n0x40_1 = -1;
      }
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
        {
          goto LABEL_2;
        }
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; n0x4000_2 + 64 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL); v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = -1 )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 64LL;
    }
    if ( n0x4000_2 < n0x4000 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 64)) - 1;
    }
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056A090((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056A0D0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_140569F50((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = sub_14739AFC0(n0x6400000, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_14038E0B0 (0x14038E0B0) ---

// --- Function: check_thread_list_contains_value (0x14038E3B0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 thread_data; // rbx
  unsigned __int64 *v3; // rax
  char *list_begin_1; // r10
  char *list_begin; // rcx
  unsigned __int64 search_value; // rdx
  unsigned __int64 search_range_count; // r8
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) )
  {
    return 0;
  }
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &vf_output_temp);
  list_begin_1 = *(char **)(thread_data + 24);
  list_begin = *(char **)(thread_data + 16);
  search_value = *v3;
  search_range_count = (list_begin_1 - list_begin) >> 4;
  while ( search_range_count )
  {
    if ( *(_QWORD *)&list_begin[16 * (search_range_count >> 1)] >= search_value )
    {
      search_range_count >>= 1;
    }
    else
    {
      list_begin += 16 * (search_range_count >> 1) + 16;
      search_range_count += -1LL - (search_range_count >> 1);
    }
  }
  if ( list_begin == list_begin_1 )
  {
    return 0;
  }
  if ( search_value < *(_QWORD *)list_begin )
  {
    list_begin = *(char **)(thread_data + 24);
  }
  return list_begin != list_begin_1;
}

// --- End Function: check_thread_list_contains_value (0x14038E3B0) ---

// --- Function: check_thread_state_and_value_not_equal (0x14038E470) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *value_ptr)
{
  __int64 thread_data; // rax

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
  return thread_data && *(_DWORD *)(thread_data + 8) == 1 && *value_ptr != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x14038E470) ---

// --- Function: validate_access_with_virtual_calls (0x14038E4B0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 thread_data; // rax
  __int64 global_validator_object; // rdi
  __int64 (__fastcall *global_validator_vtable)(__int64, _QWORD); // rbx
  _QWORD *value_from_object_ptr; // rax
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_tls_data_offset_784() )
  {
    return 1;
  }
  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) || !is_illegal_entity_access_check_enabled() )
  {
    return 1;
  }
  global_validator_object = ::global_validator_object;
  global_validator_vtable = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::global_validator_object + 984LL);
  value_from_object_ptr = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                                      payload_ptr_state2,
                                      &vf_output_temp);
  return global_validator_vtable(global_validator_object, *value_from_object_ptr);
}

// --- End Function: validate_access_with_virtual_calls (0x14038E4B0) ---

// --- Function: check_indirect_handle_access_by_state (0x14038E530) ---
// Checks access permissions for a handle stored indirectly. Takes a pointer `a1`
// to a structure containing a primary packed handle. Extracts the primary handle
// `v1 = *a1 & 0xFFFFFFFFFFFFLL`. Retrieves metadata for `v1` using
// `get_handle_metadata`. Validates access based on the state field (metadata + 4):
// - State 0: Returns false. - State 1: Extracts payload handle from `*(v1 + 8)`
// and calls `check_thread_list_contains_value`. - State 2: Extracts payload handle
// from `*(v1 + 8)`; returns true if thread flags set, otherwise calls
// `validate_access_with_virtual_calls` on payload handle. - State 3: Extracts
// payload handle from `*(v1 + 8)`; checks thread state and compares payload handle
// value against 0x13374770CLL. - Other states: Return false.
char __fastcall check_indirect_handle_access_by_state(_QWORD *packed_handle_owner_ptr)
{
  __int64 primary_handle_value; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  primary_handle_value = *packed_handle_owner_ptr & 0xFFFFFFFFFFFFLL;
  metadata_ptr = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 296LL))(
                   global_validator_object,
                   primary_handle_value,
                   0);
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( *(_WORD *)(metadata_ptr + 4) == 3 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *(_QWORD *)(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL) != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls(*(_QWORD *)(primary_handle_value + 8) & 0xFFFFFFFFFFFFLL);
  }
}

// --- End Function: check_indirect_handle_access_by_state (0x14038E530) ---

// --- Function: check_handle_access_by_state_extended (0x14038E620) ---
// Checks access permissions for the provided packed handle using extended logic.
// Calculates the metadata pointer based on high bits in the packed handle.
// Validates access based on the state field (metadata + 4): - State 0: Returns
// false (invalid). - State 1: Checks if the handle's payload exists in a thread-
// local list using `check_thread_list_contains_value`. - State 2: Returns true if
// specific thread flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3 or 4: Returns
// true if thread data exists, its status field at +8 is 1, and the payload value
// is not equal to the constant 0x13374770CLL. - Other states: Return false.
char __fastcall check_handle_access_by_state_extended(_QWORD *packed_handle_ptr)
{
  _QWORD *handle_payload_ptr; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  handle_payload_ptr = (_QWORD *)(*packed_handle_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*packed_handle_ptr & 0xF000000000000000uLL) != 0 )
  {
    metadata_ptr = *packed_handle_ptr & 0xFFFFFF000000LL;
  }
  else
  {
    metadata_ptr = (__int64)handle_payload_ptr - 6;
  }
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value((__int64)handle_payload_ptr);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(metadata_ptr + 4) - 3 <= 1 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *handle_payload_ptr != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls((__int64)handle_payload_ptr);
  }
}

// --- End Function: check_handle_access_by_state_extended (0x14038E620) ---

// --- Function: sub_14039EFB0 (0x14039EFB0) ---
void __fastcall sub_14039EFB0(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403AF4C0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 32) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64 )
    {
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    }
    for ( ; v7 + 64 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 40) = 0 )
    {
      v11 = v7;
      v7 += 64LL;
    }
    if ( v7 < v8 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 40) &= ~((1LL << ((__int64)v8 % 64)) - 1);
    }
  }
  else
  {
    sub_14739AF10(a2);
  }
}

// --- End Function: sub_14039EFB0 (0x14039EFB0) ---

// --- Function: sub_1403A5050 (0x1403A5050) ---
void **sub_1403A5050(void **a1, const char *Format, ...)
{
  _QWORD *v4; // rdi
  int BufferCount_2; // eax
  int BufferCount_1; // ecx
  size_t BufferCount; // rbx
  va_list va; // [rsp+70h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_1402A2470();
  BufferCount_2 = _stdio_common_vsprintf(*v4 | 2LL, 0, 0, Format, 0, va);
  if ( BufferCount_2 < 0 )
  {
    BufferCount_2 = -1;
  }
  BufferCount_1 = 0;
  if ( BufferCount_2 >= 0 )
  {
    BufferCount_1 = BufferCount_2;
  }
  BufferCount = BufferCount_1;
  sub_1403E4C30(a1, BufferCount_1, 32);
  _stdio_common_vsprintf(*v4 | 1LL, (char *)*a1, BufferCount, Format, 0, va);
  return a1;
}

// --- End Function: sub_1403A5050 (0x1403A5050) ---

// --- Function: get_handle_payload_ptr (0x1403AC8D0) ---
// Retrieves the QWORD value at offset +8 from the structure pointed to by
// `metadata_or_object_ptr` and returns its lower 48 bits (masked with
// 0xFFFFFFFFFFFF). This likely extracts an embedded payload pointer or handle.
__int64 __fastcall get_handle_payload_ptr(__int64 metadata_or_object_ptr)
{
  return *(_QWORD *)(metadata_or_object_ptr + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: get_handle_payload_ptr (0x1403AC8D0) ---

// --- Function: sub_1403AC900 (0x1403AC900) ---
_QWORD *__fastcall sub_1403AC900(unsigned __int64 *a1, _QWORD *a2)
{
  if ( is_valid_handle_typeB(a1) )
  {
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1403AC900 (0x1403AC900) ---

// --- Function: sub_1403AF4C0 (0x1403AF4C0) ---
__int64 sub_1403AF4C0()
{
  __int64 v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  result = *(_QWORD *)v0;
  if ( !*(_QWORD *)v0 )
  {
    v2 = (_QWORD *)sub_1402A1E30(0x828u);
    if ( v2 )
    {
      v2[3] = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)v0 = v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 192);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 192) = v6 | 1;
      _tlregdtor((__int64)sub_147E51590);
    }
    return *(_QWORD *)v0;
  }
  return result;
}

// --- End Function: sub_1403AF4C0 (0x1403AF4C0) ---

// --- Function: get_handle_metadata_ptr (0x1403B0A30) ---
// Retrieves a pointer to the metadata structure associated with the given handle.
// Calls the virtual function at offset +296 on the global object
// `global_validator_object`, passing the handle.
__int64 __fastcall get_handle_metadata_ptr(__int64 handle_value)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 296LL))(
           global_validator_object,
           handle_value,
           0);
}

// --- End Function: get_handle_metadata_ptr (0x1403B0A30) ---

// --- Function: sub_1403D85B0 (0x1403D85B0) ---
unsigned __int64 __fastcall sub_1403D85B0(
        volatile signed __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_tls_data_offset_784() + 28) && qword_14981D3D8 )
  {
    return sub_1403D8640(a1, a2);
  }
  else
  {
    return sub_1403D8810(a1, a2);
  }
}

// --- End Function: sub_1403D85B0 (0x1403D85B0) ---

// --- Function: sub_1403D8640 (0x1403D8640) ---
unsigned __int64 __fastcall sub_1403D8640(volatile signed __int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // r15
  __int64 tls_data_offset_784; // rax
  __int64 v6; // rsi
  unsigned int v7; // r14d
  bool v8; // zf
  unsigned __int64 result; // rax
  unsigned __int64 v10; // rdx
  signed __int64 v11; // rax
  signed __int64 v12; // rax
  int n5632; // [rsp+30h] [rbp-81h] BYREF
  __int64 v14; // [rsp+34h] [rbp-7Dh]
  int v15; // [rsp+3Ch] [rbp-75h]
  __int64 v16; // [rsp+40h] [rbp-71h]
  unsigned __int64 v17; // [rsp+48h] [rbp-69h]
  __int64 v18; // [rsp+50h] [rbp-61h]
  __int64 v19; // [rsp+58h] [rbp-59h]
  int n5632_1; // [rsp+80h] [rbp-31h] BYREF
  __int64 v21; // [rsp+84h] [rbp-2Dh]
  int v22; // [rsp+8Ch] [rbp-25h]
  __int64 v23; // [rsp+90h] [rbp-21h]
  unsigned __int64 v24; // [rsp+98h] [rbp-19h]
  __int64 v25; // [rsp+A0h] [rbp-11h]
  __int64 v26; // [rsp+A8h] [rbp-9h]
  char v27; // [rsp+110h] [rbp+5Fh] BYREF
  char v28; // [rsp+118h] [rbp+67h] BYREF

  v2 = qword_14981D318;
  tls_data_offset_784 = get_tls_data_offset_784();
  v6 = *(_QWORD *)tls_data_offset_784;
  v7 = *(_DWORD *)(*(_QWORD *)tls_data_offset_784 + 28LL);
  (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v2 + 248LL))(v2, &v28, &v27);
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v10 = (unsigned __int64)v7 << 48;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v6 + 36) = HIWORD(a2);
        v11 = _InterlockedCompareExchange64(a1, v10 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v8 = a2 == v11;
        a2 = v11;
        if ( v8 )
        {
          n5632 = 5632;
          v14 = 0;
          v15 = 0;
          v17 = 0;
          v18 = 0;
          v19 = 0;
          v16 = 1;
          qword_149818EA0(
            &n5632,
            0,
            &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 232LL))(v2, v7);
          a2 = *a1;
          v7 = *(_DWORD *)(v6 + 28);
          v17 = __rdtsc();
          qword_149818EA8(&n5632);
        }
      }
      else
      {
        *(_DWORD *)(v6 + 36) = -1;
        v12 = _InterlockedCompareExchange64(a1, a2 | v10, a2);
        v8 = a2 == v12;
        a2 = v12;
        if ( v8 )
        {
          n5632_1 = 5632;
          v21 = 0;
          v22 = 0;
          v24 = 0;
          v25 = 0;
          v26 = 0;
          v23 = 1;
          qword_149818EA0(
            &n5632_1,
            0,
            &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 232LL))(v2, v7);
          a2 = *a1;
          v7 = *(_DWORD *)(v6 + 28);
          v24 = __rdtsc();
          qword_149818EA8(&n5632_1);
        }
      }
    }
    result = _InterlockedCompareExchange64(a1, a2 | 0x200000, a2);
    v8 = a2 == result;
    a2 = result;
  }
  while ( !v8 );
  return result;
}

// --- End Function: sub_1403D8640 (0x1403D8640) ---

// --- Function: sub_1403D8810 (0x1403D8810) ---
signed __int64 __fastcall sub_1403D8810(volatile signed __int64 *a1, signed __int64 a2)
{
  char v2; // r14
  signed __int64 v5; // rcx
  bool v6; // zf
  signed __int64 result; // rax
  int v8; // esi
  signed __int64 v9; // rax
  int v10; // [rsp+38h] [rbp-71h] BYREF
  _DWORD v11[3]; // [rsp+3Ch] [rbp-6Dh] BYREF
  int n5632; // [rsp+48h] [rbp-61h] BYREF
  __int64 v13; // [rsp+4Ch] [rbp-5Dh]
  int v14; // [rsp+54h] [rbp-55h]
  __int64 v15; // [rsp+58h] [rbp-51h]
  unsigned __int64 v16; // [rsp+60h] [rbp-49h]
  __int64 v17; // [rsp+68h] [rbp-41h]
  __int64 v18; // [rsp+70h] [rbp-39h]
  int n5632_1; // [rsp+98h] [rbp-11h] BYREF
  __int64 v20; // [rsp+9Ch] [rbp-Dh]
  int v21; // [rsp+A4h] [rbp-5h]
  __int64 v22; // [rsp+A8h] [rbp-1h]
  unsigned __int64 v23; // [rsp+B0h] [rbp+7h]
  __int64 v24; // [rsp+B8h] [rbp+Fh]
  __int64 v25; // [rsp+C0h] [rbp+17h]

  v2 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
      {
        (*(void (__fastcall **)(__int64, volatile signed __int64 *))(*(_QWORD *)qword_14981D318 + 296LL))(
          qword_14981D318,
          a1);
      }
      if ( (a2 & 0x2003FF) == 0 )
      {
        break;
      }
      if ( v2 )
      {
        n5632 = 5632;
        v13 = 0;
        v14 = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v15 = 1;
        qword_149818EA0(
          &n5632,
          0,
          &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
          0);
        v10 = a2;
        qword_149808B88(a1, &v10, 4, 0xFFFFFFFFLL);
        a2 = *a1;
        v16 = __rdtsc();
        qword_149818EA8(&n5632);
      }
      else
      {
        v8 = a2 + 0x400000;
        v9 = _InterlockedCompareExchange64(a1, a2 + 0x400000, a2);
        v6 = a2 == v9;
        a2 = v9;
        if ( v6 )
        {
          n5632_1 = 5632;
          v20 = 0;
          v21 = 0;
          v23 = 0;
          v2 = 1;
          v24 = 0;
          v25 = 0;
          v22 = 1;
          qword_149818EA0(
            &n5632_1,
            0,
            &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
            0);
          v11[0] = v8;
          qword_149808B88(a1, v11, 4, 0xFFFFFFFFLL);
          a2 = *a1;
          v23 = __rdtsc();
          qword_149818EA8(&n5632_1);
        }
      }
    }
    v5 = (a2 | 0x200000) - 0x400000;
    if ( !v2 )
    {
      v5 = a2 | 0x200000;
    }
    result = _InterlockedCompareExchange64(a1, v5, a2);
    v6 = a2 == result;
    a2 = result;
  }
  while ( !v6 );
  return result;
}

// --- End Function: sub_1403D8810 (0x1403D8810) ---

// --- Function: sub_1403D8A00 (0x1403D8A00) ---
__int64 __fastcall sub_1403D8A00(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rdi
  __int64 v9; // r8
  int v10; // ecx
  __int64 v11; // r8
  unsigned __int64 v12; // rbx
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 248LL))(
        qword_14981D318,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(192 * (HIWORD(a2) & (unsigned int)(v14 - 1)) + v16 + 36);
      if ( v5 != -1 )
      {
        v4 |= (unsigned __int64)v5 << 48;
      }
    }
    v6 = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == v6 )
    {
      break;
    }
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
    {
      qword_149808B98(a1);
    }
    result = 0xFFFF00000000LL;
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v8 = qword_14981D318;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 248LL))(
        qword_14981D318,
        &v15,
        &v13);
      v9 = v15 + 192 * (WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1));
      LODWORD(a2) = *(_DWORD *)(v9 + 36);
      *(_DWORD *)(v9 + 28) = (unsigned __int16)(WORD2(a2) + v13);
      for ( result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 216LL))(v8);
            (_DWORD)a2 != -1;
            result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 216LL))(v8) )
      {
        v10 = (unsigned __int16)(a2 + v13);
        v11 = v15 + 192LL * ((unsigned int)a2 & (v13 - 1));
        LODWORD(a2) = *(_DWORD *)(v11 + 36);
        *(_DWORD *)(v11 + 28) = v10;
      }
    }
  }
  else
  {
    result = 4290772992LL;
    if ( (a2 & 0xFFC00000) != 0 )
    {
      return qword_149808B90(a1);
    }
    else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 248LL))(
        qword_14981D318,
        &v15,
        &v13);
      v12 = HIWORD(a2);
      *(_DWORD *)(192LL * ((unsigned int)v12 & (v13 - 1)) + v15 + 28) = (unsigned __int16)(v12 + v13);
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D318 + 216LL))(
               qword_14981D318,
               (unsigned int)v12);
    }
  }
  return result;
}

// --- End Function: sub_1403D8A00 (0x1403D8A00) ---

// --- Function: sub_1403DFFB0 (0x1403DFFB0) ---
__int64 sub_1403DFFB0()
{
  return sub_1402A1E30(1uLL);
}

// --- End Function: sub_1403DFFB0 (0x1403DFFB0) ---

// --- Function: sub_1403DFFC0 (0x1403DFFC0) ---
_OWORD *__fastcall sub_1403DFFC0(_OWORD *a1)
{
  _OWORD *result; // rax

  result = (_OWORD *)sub_1402A1E30(0x10uLL);
  if ( result )
  {
    *result = *a1;
  }
  return result;
}

// --- End Function: sub_1403DFFC0 (0x1403DFFC0) ---

// --- Function: sub_1403DFFF0 (0x1403DFFF0) ---
_QWORD *__fastcall sub_1403DFFF0(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)sub_1402A1E30(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    free_memory_wrapper(0);
    v5 = -1;
    while ( v4[++v5] != 0 )
    {
      ;
    }
    Size = v5 + 1;
    v8 = (void *)sub_1402A1E30(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403DFFF0 (0x1403DFFF0) ---

// --- Function: sub_1403E00D0 (0x1403E00D0) ---
__int64 __fastcall sub_1403E00D0(__int64 a1)
{
  __int64 result; // rax

  result = sub_1402A1E30(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 16) = *(double *)(a1 + 16);
  }
  return result;
}

// --- End Function: sub_1403E00D0 (0x1403E00D0) ---

// --- Function: sub_1403E02C0 (0x1403E02C0) ---
__int64 __fastcall sub_1403E02C0(const void *a1)
{
  return free_memory_wrapper(a1);
}

// --- End Function: sub_1403E02C0 (0x1403E02C0) ---

// --- Function: sub_1403E02D0 (0x1403E02D0) ---
__int64 __fastcall sub_1403E02D0(const void *a1)
{
  return free_memory_wrapper(a1);
}

// --- End Function: sub_1403E02D0 (0x1403E02D0) ---

// --- Function: sub_1403E02E0 (0x1403E02E0) ---
__int64 __fastcall sub_1403E02E0(const void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    free_memory_wrapper(a1[2]);
    return free_memory_wrapper(a1);
  }
  return result;
}

// --- End Function: sub_1403E02E0 (0x1403E02E0) ---

// --- Function: free_memory_wrapper_w (0x1403E0310) ---
void __fastcall sub_1403E0310(const void *ptr_to_free)
{
  free_memory_wrapper(ptr_to_free);
}

// --- End Function: free_memory_wrapper_w (0x1403E0310) ---

// --- Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403E2A90) ---
bool __fastcall FH4::HandlerMap4::iterator::operator==(__int64 a1, __int64 a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

// --- End Function: ??8iterator@HandlerMap4@FH4@@QEBA_NAEBV012@@Z (0x1403E2A90) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E2AA0) ---

// --- Function: sub_1403E2AB0 (0x1403E2AB0) ---
bool __fastcall sub_1403E2AB0(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
  {
    return 1;
  }
  if ( !v2 || !v3 )
  {
    return 0;
  }
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
    {
      break;
    }
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E2AB0 (0x1403E2AB0) ---

// --- Function: sub_1403E2C50 (0x1403E2C50) ---
char __fastcall sub_1403E2C50(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1403E2C50 (0x1403E2C50) ---

// --- Function: sub_1403E4C30 (0x1403E4C30) ---
__int64 __fastcall sub_1403E4C30(void **a1, unsigned __int64 a2, char Val)
{
  _DWORD *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx
  __int64 result; // rax

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
    {
      return result;
    }
    *(v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
  {
    return result;
  }
  if ( a2 <= (int)*(v3 - 1) )
  {
    memset((char *)v3 + v6, Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    result = *((int *)*a1 - 2);
    *((_BYTE *)*a1 + result) = 0;
    return result;
  }
  sub_1403D95E0((char **)a1, a2);
  if ( *a1 != v3 )
  {
    memcpy(*a1, v3, (int)*(v3 - 2));
  }
  result = (__int64)memset((char *)*a1 + (int)*(v3 - 2), Val_1, Size);
  if ( (int)*(v3 - 1) > 0 )
  {
    sub_14739AF10(v3 - 2);
  }
  return result;
}

// --- End Function: sub_1403E4C30 (0x1403E4C30) ---

// --- Function: sub_1403E6400 (0x1403E6400) ---
__int64 __fastcall sub_1403E6400(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_1403571E0(a2, a3, 0, *(unsigned int *)(a1 + 8));
}

// --- End Function: sub_1403E6400 (0x1403E6400) ---

// --- Function: sub_1403E6420 (0x1403E6420) ---
__int64 __fastcall sub_1403E6420(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 16) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 34;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      v6 = sub_1403570D0((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FC400((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
  {
    return 0xFFFFFFFFLL;
  }
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
  {
    return 0xFFFFFFFFLL;
  }
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 34;
    }
    else
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403E6420 (0x1403E6420) ---

// --- Function: sub_1403E6550 (0x1403E6550) ---
__int64 __fastcall sub_1403E6550(__int64 a1, double *a2, unsigned __int64 n9)
{
  __int64 v4; // r8

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    return sub_1402FEA60(a2, n9, v4, 1);
  }
  if ( n9 <= 9 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 0x7274706C6C756E22LL;
    *((_BYTE *)a2 + 8) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  return 9LL;
}

// --- End Function: sub_1403E6550 (0x1403E6550) ---

// --- Function: sub_1403E6700 (0x1403E6700) ---
__int64 __fastcall sub_1403E6700(__int64 a1, __int64 a2, unsigned __int64 n12)
{
  int v3; // edi
  int n12_1; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12_1 = 0;
  if ( (int)n12 > 0 )
  {
    if ( n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 = 12;
      if ( (int)n12 <= 12 )
      {
        goto LABEL_52;
      }
    }
    v8 = sub_1404EEAB0((unsigned __int8 *)a1, (_BYTE *)((unsigned int)n12_1 + a2), n12 - (unsigned int)n12_1);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v8;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12_1);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 19;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v10 = sub_1404EE450((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v10;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12_1;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v12 = sub_1404EE6A0((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12_1);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 18;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v14 = sub_1404EE300((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12_1 += v14;
    if ( n12_1 < (int)n12 )
    {
LABEL_46:
      if ( n12 - n12_1 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12_1);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12_1 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
  {
    return (unsigned int)-1;
  }
  return (unsigned int)n12_1;
}

// --- End Function: sub_1403E6700 (0x1403E6700) ---

// --- Function: sub_1403E6A60 (0x1403E6A60) ---
__int64 __fastcall sub_1403E6A60(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 16) )
  {
    return sub_1403570D0(a2, a3, 0, v3);
  }
  else
  {
    return sub_1402FC400(a2, a3, 0, v3);
  }
}

// --- End Function: sub_1403E6A60 (0x1403E6A60) ---

// --- Function: sub_1403E6A90 (0x1403E6A90) ---
__int64 __fastcall sub_1403E6A90(__int64 a1, __int64 a2, unsigned __int64 Size, __int64 a4, char a5)
{
  _BYTE *v6; // rdx
  __int64 result; // rax
  size_t Size_1; // rbx

  v6 = *(_BYTE **)(a1 + 8);
  if ( v6 )
  {
    if ( a5 )
    {
      return sub_1402FEA60((_BYTE *)a2, Size, *(_QWORD *)(a1 + 8), 0);
    }
    result = -1;
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( v6[Size_1] );
    if ( Size_1 < Size )
    {
      if ( Size_1 )
      {
        if ( !a2 )
        {
          *errno() = 22;
          invalid_parameter_noinfo();
          return (unsigned int)Size_1;
        }
        memcpy((void *)a2, v6, Size_1);
      }
      return (unsigned int)Size_1;
    }
  }
  else if ( Size > 7 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 1819047278;
      *(_WORD *)(a2 + 4) = 29808;
      *(_BYTE *)(a2 + 6) = 114;
    }
    else
    {
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return 7;
  }
  else
  {
    return -1;
  }
  return result;
}

// --- End Function: sub_1403E6A90 (0x1403E6A90) ---

// --- Function: sub_1403E6C00 (0x1403E6C00) ---
// attributes: thunk
__int64 __fastcall sub_1403E6C00(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404EEAB0(a1, a2, n0x21);
}

// --- End Function: sub_1403E6C00 (0x1403E6C00) ---

// --- Function: sub_1404AE300 (0x1404AE300) ---
_QWORD *sub_1404AE300()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  if ( !v0 )
  {
    sub_140535CF0((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A1E30(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_147E52AF0);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404AE300 (0x1404AE300) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 15;
  }
  return (__int64 *)&tls_log_structure_1[22 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: sub_140535CF0 (0x140535CF0) ---
__int64 (__fastcall *__fastcall sub_140535CF0(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_140397520(0LL, "__InitializeThreadInfoBlock__", 0);
  if ( result )
  {
    return (__int64 (__fastcall *)(__int64))result(a1);
  }
  return result;
}

// --- End Function: sub_140535CF0 (0x140535CF0) ---

// --- Function: is_thread_flag_57_or_38_set (0x140535D40) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 thread_data_ptr_offset_16; // rcx

  thread_data_ptr_offset_16 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  if ( thread_data_ptr_offset_16 )
  {
    return *(_BYTE *)(thread_data_ptr_offset_16 + 57) != 0;
  }
  else
  {
    return *(_BYTE *)(get_tls_data_offset_784() + 38) != 0;
  }
}

// --- End Function: is_thread_flag_57_or_38_set (0x140535D40) ---

// --- Function: sub_140569650 (0x140569650) ---
__int64 __fastcall sub_140569650(__int64 a1)
{
  int n624; // ecx
  int *v3; // r9
  __int64 n227; // r10
  int v5; // edx
  int v6; // ecx
  int *v7; // r9
  __int64 n396; // r10
  int v9; // edx
  int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx

  n624 = *(_DWORD *)(a1 + 2504);
  *(_DWORD *)(a1 + 2504) = n624 + 1;
  if ( n624 >= 624 )
  {
    if ( *(_BYTE *)a1 )
    {
      v3 = (int *)(a1 + 4);
      n227 = 227;
      do
      {
        v5 = *v3;
        v6 = v3[1];
        ++v3;
        *(v3 - 1) = v3[396] ^ ((v6 & 1) != 0 ? 0x9908B0DF : 0) ^ ((*(v3 - 1) ^ (v6 ^ v5) & 0x7FFFFFFEu) >> 1);
        --n227;
      }
      while ( n227 );
      v7 = (int *)(a1 + 912);
      n396 = 396;
      do
      {
        v9 = *v7;
        v10 = v7[1];
        ++v7;
        *(v7 - 1) = *(v7 - 228) ^ ((v10 & 1) != 0 ? 0x9908B0DF : 0) ^ ((*(v7 - 1) ^ (v10 ^ v9) & 0x7FFFFFFEu) >> 1);
        --n396;
      }
      while ( n396 );
      *(_DWORD *)(a1 + 2496) = *(_DWORD *)(a1 + 1588)
                             ^ ((*(_DWORD *)(a1 + 4) & 1) != 0 ? 0x9908B0DF : 0)
                             ^ ((*(_DWORD *)(a1 + 2496) ^ (*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a1 + 2496)) & 0x7FFFFFFEu) >> 1);
    }
    *(_DWORD *)(a1 + 2504) = 1;
    n624 = 0;
  }
  v11 = *(_DWORD *)(a1 + 4LL * n624 + 4);
  v12 = ((((v11 >> 11) ^ v11) & 0xFF3A58AD) << 7) ^ (v11 >> 11) ^ v11;
  return ((v12 & 0xFFFFDF8C) << 15) ^ v12 ^ ((((v12 & 0xFFFFDF8C) << 15) ^ v12) >> 18);
}

// --- End Function: sub_140569650 (0x140569650) ---

// --- Function: sub_140569F50 (0x140569F50) ---
char __fastcall sub_140569F50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149818690;
  if ( !qword_149818690 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403DE270(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149818690 = (__int64)v3;
  }
  if ( v3(a2, a3, 4096LL, 4LL) )
  {
    return 1;
  }
  if ( GetLastError() == 1455 )
  {
    sub_14056A220();
  }
  return 0;
}

// --- End Function: sub_140569F50 (0x140569F50) ---

// --- Function: sub_14056A090 (0x14056A090) ---
__int64 __fastcall sub_14056A090(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 4096LL )
      {
        return 4096LL;
      }
      if ( ++v1 == v2 )
      {
        return 4096LL;
      }
    }
  }
  return 4096LL;
}

// --- End Function: sub_14056A090 (0x14056A090) ---

// --- Function: sub_14056A0D0 (0x14056A0D0) ---
__int64 __fastcall sub_14056A0D0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149818690;
  if ( !qword_149818690 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403DE270(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149818690 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0LL, a2, 0x2000LL, 4LL);
  *(_DWORD *)(a1 + 16) = a6;
  *(_QWORD *)(a1 + 24) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 20) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056A0D0 (0x14056A0D0) ---

// --- Function: g_GameTimer.GetCurrentTicks (0x140593A80) ---
_QWORD *__fastcall sub_140593A80(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a1 + *a3;
  return a2;
}

// --- End Function: g_GameTimer.GetCurrentTicks (0x140593A80) ---

// --- Function: sub_140593AF0 (0x140593AF0) ---
bool __fastcall sub_140593AF0(_QWORD *a1, _QWORD *a2)
{
  return *a1 > *a2;
}

// --- End Function: sub_140593AF0 (0x140593AF0) ---

// --- Function: sub_140593C20 (0x140593C20) ---
void **__fastcall sub_140593C20(_QWORD *a1, void **a2)
{
  initializeEmptyStringStructure(a2);
  sub_1403A5050(a2, "%lld", *a1);
  return a2;
}

// --- End Function: sub_140593C20 (0x140593C20) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !Parameter_3 )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = -1;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[4095] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)Parameter_3 + 280LL))(
                      Parameter_3,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: sub_140C12610 (0x140C12610) ---
void __fastcall sub_140C12610(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 n8; // rbx
  unsigned __int64 n8_1; // rcx
  unsigned __int64 v5; // r12
  unsigned __int64 n0x6400000; // rcx
  __int64 v7; // rax
  _QWORD *v8; // r14
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx
  __int64 v11; // r15
  size_t Size; // rdi
  const void *v13; // rdx
  char *v14; // rdi
  size_t Size_1; // r8
  char *v16; // rcx
  const void *ptr_to_free; // rcx

  n8 = 1;
  n8_1 = a1[2];
  if ( n8_1 )
  {
    n8 = n8_1;
  }
  while ( n8 - n8_1 < a2 || n8 < 8 )
  {
    if ( 0x7FFFFFFFFFFFFFFLL - n8 < n8 )
    {
      unknown_libname_8();
    }
    n8 *= 2LL;
  }
  v5 = a1[3];
  if ( n8 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_25;
  }
  n0x6400000 = 8 * n8;
  if ( 8 * n8 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      v8 = (_QWORD *)sub_1402A1E30(n0x6400000);
    }
    else
    {
      v8 = 0;
    }
    goto LABEL_15;
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_25:
    sub_1402DEE40();
  }
  v7 = sub_1402A1E30(n0x6400000 + 39);
  if ( !v7 )
  {
    goto LABEL_24;
  }
  v8 = (_QWORD *)((v7 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v8 - 1) = v7;
LABEL_15:
  v9 = a1[2];
  v10 = n8 - v9;
  v11 = 8 * v5;
  Size = 8 * v9 - 8 * v5;
  memmove(&v8[v5], (const void *)(a1[1] + 8 * v5), Size);
  v13 = (const void *)a1[1];
  v14 = (char *)&v8[v5] + Size;
  if ( v5 > v10 )
  {
    memmove(v14, v13, 8 * v10);
    memmove(v8, (const void *)(8 * v10 + a1[1]), v11 - 8 * v10);
    v16 = (char *)v8 + v11 - 8 * v10;
    Size_1 = 8 * v10;
  }
  else
  {
    memmove(v14, v13, 8 * v5);
    memset(&v14[v11], 0, 8 * (v10 - v5));
    Size_1 = 8 * v5;
    v16 = (char *)v8;
  }
  memset(v16, 0, Size_1);
  ptr_to_free = (const void *)a1[1];
  if ( ptr_to_free )
  {
    if ( (unsigned __int64)(8LL * a1[2]) < 0x1000 )
    {
LABEL_22:
      free_memory_wrapper(ptr_to_free);
      goto LABEL_23;
    }
    if ( (unsigned __int64)ptr_to_free - *((_QWORD *)ptr_to_free - 1) - 8 <= 0x1F )
    {
      ptr_to_free = (const void *)*((_QWORD *)ptr_to_free - 1);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  a1[2] += v10;
  a1[1] = v8;
}

// --- End Function: sub_140C12610 (0x140C12610) ---

// --- Function: sub_141B2DB40 (0x141B2DB40) ---
__int64 __fastcall sub_141B2DB40(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  int v4; // esi
  unsigned __int64 v6; // rax

  *(_QWORD *)a2 = a1;
  v2 = a1 + 40;
  *(_QWORD *)(a2 + 16) = a2 + 24;
  *(_QWORD *)(a2 + 8) = a1 + 40;
  *(_DWORD *)(a2 + 24) = 1;
  v4 = *(_DWORD *)(get_tls_data_offset_784() + 24);
  if ( *(_DWORD *)(v2 + 8) == v4 )
  {
    ++*(_DWORD *)(v2 + 12);
    return a2;
  }
  else
  {
    v6 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
    if ( v6 )
    {
      sub_1403D85B0(
        (volatile signed __int64 *)v2,
        v6,
        0,
        (__int64)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
        (__int64)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
        1);
    }
    *(_DWORD *)(v2 + 8) = v4;
    return a2;
  }
}

// --- End Function: sub_141B2DB40 (0x141B2DB40) ---

// --- Function: sub_1426551B0 (0x1426551B0) ---
int __fastcall sub_1426551B0(char *String1, int a2)
{
  int result; // eax

  result = _stricmp(String1, "Hunger");
  if ( result )
  {
    if ( !_stricmp(String1, "Thirst") )
    {
      return 1;
    }
    else if ( !_stricmp(String1, "BloodDrugLevel") )
    {
      return 2;
    }
    else if ( !_stricmp(String1, "OverdoseLevel") )
    {
      return 3;
    }
    else if ( !_stricmp(String1, "BodyTemperature") )
    {
      return 4;
    }
    else if ( !_stricmp(String1, "SuitTemperature") )
    {
      return 5;
    }
    else if ( !_stricmp(String1, "Stun") )
    {
      return 6;
    }
    else if ( !_stricmp(String1, "Distortion") )
    {
      return 7;
    }
    else if ( !_stricmp(String1, "Pressure") )
    {
      return 8;
    }
    else if ( !_stricmp(String1, "GasSaturationO2") )
    {
      return 9;
    }
    else if ( !_stricmp(String1, "DownedDamage") )
    {
      return 10;
    }
    else if ( !_stricmp(String1, "HealthPool") )
    {
      return 11;
    }
    else if ( !_stricmp(String1, "HealthHead") )
    {
      return 12;
    }
    else if ( !_stricmp(String1, "HealthTorso") )
    {
      return 13;
    }
    else if ( !_stricmp(String1, "HealthLeftArm") )
    {
      return 14;
    }
    else if ( !_stricmp(String1, "HealthRightArm") )
    {
      return 15;
    }
    else if ( !_stricmp(String1, "HealthLeftLeg") )
    {
      return 16;
    }
    else if ( !_stricmp(String1, "HealthRightLeg") )
    {
      return 17;
    }
    else if ( !_stricmp(String1, "WearHead") )
    {
      return 18;
    }
    else if ( !_stricmp(String1, "WearTorso") )
    {
      return 19;
    }
    else if ( !_stricmp(String1, "WearLeftArm") )
    {
      return 20;
    }
    else if ( !_stricmp(String1, "WearRightArm") )
    {
      return 21;
    }
    else if ( !_stricmp(String1, "WearLeftLeg") )
    {
      return 22;
    }
    else if ( !_stricmp(String1, "WearRightLeg") )
    {
      return 23;
    }
    else if ( !_stricmp(String1, "BodyRadiation") )
    {
      return 24;
    }
    else if ( !_stricmp(String1, "SuitRadiation") )
    {
      return 25;
    }
    else if ( !_stricmp(String1, "GasSaturationCO2") )
    {
      return 26;
    }
    else if ( !_stricmp(String1, "GasSaturationCO") )
    {
      return 27;
    }
    else
    {
      if ( !_stricmp(String1, "Hygiene") )
      {
        return 28;
      }
      return a2;
    }
  }
  return result;
}

// --- End Function: sub_1426551B0 (0x1426551B0) ---

// --- Function: sub_142E0ABB0 (0x142E0ABB0) ---
const char *__fastcall sub_142E0ABB0(int a1, const char *p_Hygiene_1)
{
  const char *p_Hygiene; // rax

  switch ( a1 )
  {
    case 0:
      p_Hygiene = "Hunger";
      break;
    case 1:
      p_Hygiene = "Thirst";
      break;
    case 2:
      p_Hygiene = "BloodDrugLevel";
      break;
    case 3:
      p_Hygiene = "OverdoseLevel";
      break;
    case 4:
      p_Hygiene = "BodyTemperature";
      break;
    case 5:
      p_Hygiene = "SuitTemperature";
      break;
    case 6:
      p_Hygiene = "Stun";
      break;
    case 7:
      p_Hygiene = "Distortion";
      break;
    case 8:
      p_Hygiene = "Pressure";
      break;
    case 9:
      p_Hygiene = "GasSaturationO2";
      break;
    case 10:
      p_Hygiene = "DownedDamage";
      break;
    case 11:
      p_Hygiene = "HealthPool";
      break;
    case 12:
      p_Hygiene = "HealthHead";
      break;
    case 13:
      p_Hygiene = "HealthTorso";
      break;
    case 14:
      p_Hygiene = "HealthLeftArm";
      break;
    case 15:
      p_Hygiene = "HealthRightArm";
      break;
    case 16:
      p_Hygiene = "HealthLeftLeg";
      break;
    case 17:
      p_Hygiene = "HealthRightLeg";
      break;
    case 18:
      p_Hygiene = "WearHead";
      break;
    case 19:
      p_Hygiene = "WearTorso";
      break;
    case 20:
      p_Hygiene = "WearLeftArm";
      break;
    case 21:
      p_Hygiene = "WearRightArm";
      break;
    case 22:
      p_Hygiene = "WearLeftLeg";
      break;
    case 23:
      p_Hygiene = "WearRightLeg";
      break;
    case 24:
      p_Hygiene = "BodyRadiation";
      break;
    case 25:
      p_Hygiene = "SuitRadiation";
      break;
    case 26:
      p_Hygiene = "GasSaturationCO2";
      break;
    case 27:
      p_Hygiene = "GasSaturationCO";
      break;
    case 28:
      p_Hygiene = "Hygiene";
      break;
    default:
      p_Hygiene = p_Hygiene_1;
      break;
  }
  return p_Hygiene;
}

// --- End Function: sub_142E0ABB0 (0x142E0ABB0) ---

// --- Function: sub_1435EA200 (0x1435EA200) ---
__int64 __fastcall sub_1435EA200(__int64 a1)
{
  return a1 + 3080;
}

// --- End Function: sub_1435EA200 (0x1435EA200) ---

// --- Function: sub_143675B30 (0x143675B30) ---
__int64 __fastcall sub_143675B30(__int64 a1)
{
  int *v2; // rbx
  int *v3; // rax
  int v4; // ebx
  int v5; // edi
  __int64 v6; // rdi
  __int64 (__fastcall *v7)(__int64, __int64, const char *); // rbx
  __int64 v8; // rax
  char v9; // al
  __int64 v10; // rcx
  _BYTE v12[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v13; // [rsp+28h] [rbp-30h]
  _BYTE v14[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v15; // [rsp+40h] [rbp-18h]

  if ( !a1 )
  {
    return 0;
  }
  v2 = (int *)sub_1436B6D00(v14);
  v3 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 24LL))(a1, v12);
  v4 = *v2;
  v5 = *v3;
  if ( v13 )
  {
    sub_14739AF10(v13);
  }
  if ( v15 )
  {
    sub_14739AF10(v15);
  }
  if ( v4 == v5 )
  {
    return a1;
  }
  if ( !Parameter_3 || !(*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3) )
  {
    return 0;
  }
  v6 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3);
  v7 = *(__int64 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v6 + 256LL);
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
  v9 = v7(v6, v8, "DefaultStatusTrigger");
  v10 = 0;
  if ( v9 )
  {
    return a1;
  }
  return v10;
}

// --- End Function: sub_143675B30 (0x143675B30) ---

// --- Function: sub_143675D30 (0x143675D30) ---
__int64 __fastcall sub_143675D30(__int64 a1)
{
  int *v2; // rbx
  int *v3; // rax
  int v4; // ebx
  int v5; // edi
  __int64 v6; // rdi
  __int64 (__fastcall *v7)(__int64, __int64, const char *); // rbx
  __int64 v8; // rax
  char v9; // al
  __int64 v10; // rcx
  _BYTE v12[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v13; // [rsp+28h] [rbp-30h]
  _BYTE v14[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v15; // [rsp+40h] [rbp-18h]

  if ( !a1 )
  {
    return 0;
  }
  v2 = (int *)sub_1436B71B0(v14);
  v3 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 24LL))(a1, v12);
  v4 = *v2;
  v5 = *v3;
  if ( v13 )
  {
    sub_14739AF10(v13);
  }
  if ( v15 )
  {
    sub_14739AF10(v15);
  }
  if ( v4 == v5 )
  {
    return a1;
  }
  if ( !Parameter_3 || !(*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3) )
  {
    return 0;
  }
  v6 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3);
  v7 = *(__int64 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v6 + 256LL);
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
  v9 = v7(v6, v8, "PercentageStatusTrigger");
  v10 = 0;
  if ( v9 )
  {
    return a1;
  }
  return v10;
}

// --- End Function: sub_143675D30 (0x143675D30) ---

// --- Function: sub_143675E30 (0x143675E30) ---
__int64 __fastcall sub_143675E30(__int64 a1)
{
  int *v2; // rbx
  int *v3; // rax
  int v4; // ebx
  int v5; // edi
  __int64 v6; // rdi
  __int64 (__fastcall *v7)(__int64, __int64, const char *); // rbx
  __int64 v8; // rax
  char v9; // al
  __int64 v10; // rcx
  _BYTE v12[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v13; // [rsp+28h] [rbp-30h]
  _BYTE v14[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v15; // [rsp+40h] [rbp-18h]

  if ( !a1 )
  {
    return 0;
  }
  v2 = (int *)sub_1436B7290(v14);
  v3 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 24LL))(a1, v12);
  v4 = *v2;
  v5 = *v3;
  if ( v13 )
  {
    sub_14739AF10(v13);
  }
  if ( v15 )
  {
    sub_14739AF10(v15);
  }
  if ( v4 == v5 )
  {
    return a1;
  }
  if ( !Parameter_3 || !(*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3) )
  {
    return 0;
  }
  v6 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3);
  v7 = *(__int64 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v6 + 256LL);
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8LL))(a1);
  v9 = v7(v6, v8, "ProbabilisticStatusTrigger");
  v10 = 0;
  if ( v9 )
  {
    return a1;
  }
  return v10;
}

// --- End Function: sub_143675E30 (0x143675E30) ---

// --- Function: sub_14367C570 (0x14367C570) ---
char __fastcall sub_14367C570(
        int n4,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 arg40,
        __int64 arg48,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15)
{
  void *v19; // rsp
  __int64 a8; // [rsp+18h] [rbp-2F8h]
  __int64 a5[82]; // [rsp+30h] [rbp-2E0h] BYREF

  v19 = alloca(736);
  sub_14367C900((unsigned int)a5, arg40, arg48, a11, a12, a13, a14, a15);
  LODWORD(a8) = a6;
  return sub_140302350(n4, a2, a3, a4, (__int64)a5, 7, a7, a8, a9, a10);
}

// --- End Function: sub_14367C570 (0x14367C570) ---

// --- Function: sub_14367C900 (0x14367C900) ---
__int64 __fastcall sub_14367C900(
        __int64 a1,
        __int64 a2,
        _QWORD *a3,
        _QWORD *a4,
        _QWORD *a5,
        _QWORD *a6,
        _QWORD *a7,
        _QWORD *a8)
{
  __int64 n7; // rax

  *(_QWORD *)(a1 + 104) = a3;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_WORD *)(a1 + 88) = 256;
  *(_QWORD *)(a1 + 24) = sub_1403E6C00;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 32) = sub_1403E6700;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = sub_1403E2C50;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = sub_1403E02C0;
  *(_QWORD *)(a1 + 72) = sub_1403DFFB0;
  *(_QWORD *)(a1 + 112) = "Name";
  *(_QWORD *)(a1 + 80) = -1;
  *(_QWORD *)(a1 + 96) = 176;
  *(_BYTE *)(a1 + 193) = 0;
  *(_QWORD *)(a1 + 120) = *a3;
  *(_QWORD *)(a1 + 128) = sub_1403E6A90;
  *(_QWORD *)(a1 + 136) = sub_1403E6550;
  *(_QWORD *)(a1 + 152) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 168) = sub_1403E02E0;
  *(_QWORD *)(a1 + 176) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 216) = "EntityId";
  *(_QWORD *)(a1 + 208) = a4;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 184) = -1;
  *(_BYTE *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 24;
  *(_BYTE *)(a1 + 297) = 1;
  *(_QWORD *)(a1 + 224) = *a4;
  *(_QWORD *)(a1 + 232) = sub_1403E6A60;
  *(_QWORD *)(a1 + 240) = sub_1403E6420;
  *(_QWORD *)(a1 + 256) = std::error_category::operator==;
  *(_QWORD *)(a1 + 272) = free_memory_wrapper_w;
  *(_QWORD *)(a1 + 280) = sub_1403E00D0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 288) = -1;
  *(_BYTE *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 24;
  *(_QWORD *)(a1 + 312) = a5;
  *(_QWORD *)(a1 + 320) = "Message";
  *(_BYTE *)(a1 + 401) = 0;
  *(_QWORD *)(a1 + 328) = *a5;
  *(_QWORD *)(a1 + 336) = sub_1403E6A90;
  *(_QWORD *)(a1 + 344) = sub_1403E6550;
  *(_QWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 360) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = sub_1403E02E0;
  *(_QWORD *)(a1 + 384) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 416) = a6;
  *(_BYTE *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 424) = "Function";
  *(_QWORD *)(a1 + 392) = -1;
  *(_QWORD *)(a1 + 408) = 24;
  *(_BYTE *)(a1 + 505) = 1;
  *(_QWORD *)(a1 + 432) = *a6;
  *(_QWORD *)(a1 + 440) = sub_1403E6A90;
  *(_QWORD *)(a1 + 448) = sub_1403E6550;
  *(_QWORD *)(a1 + 464) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 480) = sub_1403E02E0;
  *(_QWORD *)(a1 + 488) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 520) = a7;
  *(_QWORD *)(a1 + 456) = 0;
  *(_QWORD *)(a1 + 472) = 0;
  *(_BYTE *)(a1 + 504) = 0;
  *(_BYTE *)(a1 + 609) = 0;
  *(_QWORD *)(a1 + 496) = -1;
  *(_QWORD *)(a1 + 512) = 24;
  *(_QWORD *)(a1 + 528) = "Line";
  *(_QWORD *)(a1 + 536) = *a7;
  *(_QWORD *)(a1 + 544) = sub_1403E6400;
  *(_QWORD *)(a1 + 552) = sub_1403E6400;
  *(_QWORD *)(a1 + 568) = FH4::HandlerMap4::iterator::operator==;
  *(_QWORD *)(a1 + 584) = sub_1403E02D0;
  *(_QWORD *)(a1 + 592) = sub_1403DFFC0;
  *(_QWORD *)(a1 + 560) = 0;
  *(_QWORD *)(a1 + 576) = 0;
  *(_BYTE *)(a1 + 608) = 0;
  *(_QWORD *)(a1 + 624) = a8;
  *(_QWORD *)(a1 + 632) = "Message";
  *(_BYTE *)(a1 + 713) = 0;
  *(_QWORD *)(a1 + 600) = -1;
  *(_QWORD *)(a1 + 616) = 16;
  *(_QWORD *)(a1 + 640) = *a8;
  n7 = 7;
  *(_QWORD *)(a1 + 648) = sub_1403E6A90;
  *(_QWORD *)(a1 + 664) = 0;
  *(_QWORD *)(a1 + 680) = 0;
  *(_BYTE *)(a1 + 712) = 0;
  *(_QWORD *)(a1 + 656) = sub_1403E6550;
  *(_QWORD *)(a1 + 672) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 688) = sub_1403E02E0;
  *(_QWORD *)(a1 + 696) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 704) = -1;
  *(_QWORD *)(a1 + 720) = 24;
  return n7;
}

// --- End Function: sub_14367C900 (0x14367C900) ---

// --- Function: sub_143680C40 (0x143680C40) ---
unsigned __int64 __fastcall sub_143680C40(__int64 a1, int n45, float a3, float a4, int a5, char a6)
{
  __int128 v6; // xmm6
  __int128 v7; // xmm7
  __int64 v10; // rbx
  __int64 v11; // rax
  int v12; // r9d
  int v13; // r14d
  char v14; // bp
  __int64 n67; // rbx
  __int64 v16; // r15
  int v17; // eax
  __int64 *v18; // rax
  unsigned __int64 _XMM2_1; // r12
  __int64 v20; // rbx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rdx
  const __m128i *v25; // rax
  __m128i *v26; // rdx
  __int64 v28; // [rsp+50h] [rbp-88h] BYREF
  __int64 v29; // [rsp+58h] [rbp-80h] BYREF
  __int64 (__fastcall **v30)(); // [rsp+60h] [rbp-78h] BYREF
  int n45_1; // [rsp+68h] [rbp-70h]
  unsigned __int64 _XMM2_2; // [rsp+70h] [rbp-68h]
  float v33; // [rsp+78h] [rbp-60h]
  __int64 v34; // [rsp+80h] [rbp-58h]
  __int128 v35; // [rsp+90h] [rbp-48h]
  __int128 v36; // [rsp+A0h] [rbp-38h]
  unsigned __int64 _XMM2; // [rsp+E0h] [rbp+8h] BYREF

  v36 = v6;
  v35 = v7;
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 10376) + 1176LL) + 72LL) + 48LL * n45;
  v11 = sub_143675C30(*(_QWORD *)(v10 + 16));
  if ( v11 )
  {
    v13 = *(_DWORD *)(v11 + 56);
  }
  else
  {
    v13 = 0;
  }
  v14 = a6;
  if ( a3 == 0.0 && !a6 )
  {
    return 0;
  }
  n67 = *(int *)(v10 + 8);
  if ( (_DWORD)n67 == 67 )
  {
    return 0;
  }
  v16 = a1 + (n67 << 7) + 1168;
  _XMM2 = 0;
  v17 = sub_145A403F0(v16, n67, n45, v12, LODWORD(a3), a5, v13, (__int64)&_XMM2, a6);
  if ( v17 )
  {
    if ( v17 == 1 )
    {
      v25 = unknown_libname_247(*(const __m128i **)(a1 + 10248), *(const __m128i **)(a1 + 10256), _XMM2);
      v26 = *(__m128i **)(a1 + 10256);
      if ( v25 == v26 )
      {
        if ( v26 == *(__m128i **)(a1 + 10264) )
        {
          sub_1402A4BA0((__int64 *)(a1 + 10248), v26, &_XMM2);
        }
        else
        {
          v26->m128i_i64[0] = _XMM2;
          *(_QWORD *)(a1 + 10256) += 8LL;
        }
      }
    }
  }
  else
  {
    if ( (_DWORD)n67 == 40 && n45 == 45 && !(unsigned __int8)sub_145A63D70(v16) )
    {
      sub_144920960(a1 + 976);
    }
    v18 = (__int64 *)sub_145A54110(v16, &v29, &_XMM2);
    _XMM2_1 = _XMM2;
    v20 = *v18;
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 664) + 8LL) & 0xFFFFFFFFFFFFLL;
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v21 + 1808LL))(v21) )
    {
      v22 = *(_QWORD *)(sub_14638A930(*(_QWORD *)(a1 + 664)) + 232);
      if ( v22 )
      {
        n45_1 = n45;
        *(_QWORD *)(v22 + 16) |= 0x200000000000uLL;
        v23 = *(_QWORD *)(v22 + 392) + 1856LL;
        v30 = off_147F345C8;
        v33 = a4;
        _XMM2_2 = _XMM2_1;
        v34 = v20;
        v24 = *(_QWORD *)(v23 + 8);
        if ( v24 == *(_QWORD *)(v23 + 16) )
        {
          sub_14367AC00(v23, v24, &v30);
        }
        else
        {
          *(float *)(v24 + 24) = a4;
          *(_QWORD *)v24 = off_147F345C8;
          *(_DWORD *)(v24 + 8) = n45;
          *(_QWORD *)(v24 + 16) = _XMM2_1;
          *(_QWORD *)(v24 + 32) = v20;
          *(_QWORD *)(v23 + 8) += 40LL;
        }
      }
    }
  }
  if ( !v14 )
  {
    sub_145A54110(v16, &v28, &_XMM2);
    v29 = 0;
    if ( std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>((_QWORD *)(a1 + 9744), &v29) )
    {
      *(_BYTE *)(a1 + 10168) = 1;
    }
    v29 = 0;
    if ( std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>((_QWORD *)(a1 + 9744), &v29)
      || sub_140593AD0(&v28, (_QWORD *)(a1 + 9744)) )
    {
      *(_QWORD *)(a1 + 9744) = v28;
    }
  }
  *(_BYTE *)(a1 + 10213) = v13 != 0;
  return _XMM2;
}

// --- End Function: sub_143680C40 (0x143680C40) ---

// --- Function: sub_143681630 (0x143681630) ---
unsigned __int64 __fastcall sub_143681630(__int64 a1)
{
  __int64 v2; // rcx
  unsigned __int64 result; // rax
  __int64 v4; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 664) + 8LL) & 0xFFFFFFFFFFFFLL;
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 1808LL))(v2);
  if ( (_BYTE)result )
  {
    result = sub_145A63D70(a1 + 6672);
    if ( (_BYTE)result )
    {
      result = sub_145A63D70(
                 a1
               + ((__int64)*(int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 10376) + 1176LL) + 72LL) + 920LL) << 7)
               + 1168);
      if ( !(_BYTE)result )
      {
        v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 10376) + 1176LL) + 72LL);
        return sub_143680C40(a1, 19, *(float *)(v4 + 948), *(float *)(v4 + 944), *(_DWORD *)(v4 + 952), 0);
      }
    }
  }
  return result;
}

// --- End Function: sub_143681630 (0x143681630) ---

// --- Function: sub_143681C30 (0x143681C30) ---
void sub_143681C30(_QWORD *rcx0, unsigned int n29_3, double a3, ...)
{
  __int128 v3; // xmm6
  __int128 v4; // xmm7
  __int64 n29_1; // r12
  int n29_2; // eax
  _BYTE *v8; // rcx
  __int64 v9; // rcx
  const char *String2_1; // rax
  int v11; // ebx
  const char *p_null_1; // rax
  const char *v13; // rbx
  const char *v14; // rax
  __int64 *v15; // rax
  const char *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._4; // rbx
  const char *CLIENT:_2; // rdi
  __int64 v18; // rcx
  char v19; // al
  const char *p_Authoritative_2; // r8
  __int64 *v21; // rax
  int v22; // ebx
  __int64 v23; // rax
  __int64 v24; // rcx
  __int64 v25; // rax
  __int64 *ThreadLogContextSlot_2; // rax
  __int64 n225; // rdi
  __int64 v28; // rcx
  char v29; // al
  __int64 v30; // rsi
  int v31; // ebx
  int n29; // eax
  _BYTE *v33; // rcx
  __int64 v34; // rcx
  const char *String2; // rax
  const char *p_null; // rax
  const char *v37; // rdi
  const char *v38; // rax
  __int64 *v39; // rax
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1; // rax
  const char *CLIENT:; // rdi
  __int64 v42; // rcx
  char v43; // al
  const char *p_Authoritative; // r8
  __int64 *v45; // rax
  int v46; // edi
  __int64 v47; // rax
  __int64 v48; // rcx
  __int64 v49; // rax
  __int64 *ThreadLogContextSlot; // rax
  float v51; // xmm8_4
  __int64 v52; // r9
  float v53; // xmm0_4
  __int64 v54; // rax
  __int64 v55; // rax
  __int64 v56; // r9
  bool v57; // zf
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._3; // rax
  const char *CLIENT:_1; // rbx
  __int64 v60; // rcx
  char v61; // al
  const char *p_Authoritative_1; // r8
  __int64 *v63; // rax
  int v64; // ebx
  float v65; // xmm6_4
  const char *v66; // rax
  __int64 p_CSCActorStatus::AdjustStatValue_6; // rcx
  __int64 v68; // rax
  __int64 v69; // rcx
  __int64 v70; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 n225_2; // rbx
  __int64 v73; // r15
  unsigned __int64 v74; // rcx
  _DWORD *i; // rax
  __int64 v76; // rax
  int v77; // r9d
  __int64 n225_3; // rbx
  __int64 v79; // rax
  int v80; // r9d
  __int64 n225_4; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 n4; // dx
  __int64 v84; // rax
  int v85; // r9d
  __int64 v86; // [rsp+28h] [rbp-D8h]
  __int64 v87; // [rsp+28h] [rbp-D8h]
  __int64 v88; // [rsp+28h] [rbp-D8h]
  __int64 p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2; // [rsp+80h] [rbp-80h] BYREF
  char v90; // [rsp+88h] [rbp-78h] BYREF
  unsigned __int64 p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.; // [rsp+90h] [rbp-70h] BYREF
  __int64 n225_1; // [rsp+98h] [rbp-68h] BYREF
  __int64 *p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor; // [rsp+A0h] [rbp-60h] BYREF
  char *v94; // [rsp+A8h] [rbp-58h]
  __int128 v95; // [rsp+B0h] [rbp-50h] BYREF
  const char *p_ClientServerInfo; // [rsp+C0h] [rbp-40h] BYREF
  const char *p_CSCActorStatus::AdjustStatValue_3; // [rsp+C8h] [rbp-38h]
  const void *ptr_to_free_1; // [rsp+D0h] [rbp-30h]
  __int64 v99; // [rsp+D8h] [rbp-28h] BYREF
  const char *p_CSCActorStatus::AdjustStatValue_1; // [rsp+E0h] [rbp-20h]
  const void *ptr_to_free; // [rsp+E8h] [rbp-18h]
  __int64 v102; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v103; // [rsp+F8h] [rbp-8h]
  const void *ptr_to_free_3; // [rsp+100h] [rbp+0h]
  unsigned __int64 v105[2]; // [rsp+108h] [rbp+8h] BYREF
  unsigned __int64 *p_ClientServerInfo_2; // [rsp+118h] [rbp+18h] BYREF
  __int64 *p_n225; // [rsp+120h] [rbp+20h]
  const void *ptr_to_free_5; // [rsp+128h] [rbp+28h]
  const char *p_ClientServerInfo_1; // [rsp+130h] [rbp+30h] BYREF
  const char *p_CSCActorStatus::AdjustStatValue; // [rsp+138h] [rbp+38h]
  const void *ptr_to_free_2; // [rsp+140h] [rbp+40h]
  __int128 v112; // [rsp+148h] [rbp+48h] BYREF
  const void *ptr_to_free_4; // [rsp+158h] [rbp+58h]
  __int64 v114; // [rsp+160h] [rbp+60h] BYREF
  __int64 v115; // [rsp+168h] [rbp+68h]
  char v116; // [rsp+170h] [rbp+70h]
  __int64 v117; // [rsp+180h] [rbp+80h] BYREF
  __int64 n511_12; // [rsp+188h] [rbp+88h]
  __int64 *p_n225_1; // [rsp+190h] [rbp+90h]
  _BYTE v120[520]; // [rsp+198h] [rbp+98h] BYREF
  __int64 v121; // [rsp+3A0h] [rbp+2A0h] BYREF
  __int64 n511_10; // [rsp+3A8h] [rbp+2A8h]
  const char *p_CSCActorStatus::AdjustStatValue_4; // [rsp+3B0h] [rbp+2B0h]
  _BYTE v124[520]; // [rsp+3B8h] [rbp+2B8h] BYREF
  __int64 v125; // [rsp+5C0h] [rbp+4C0h] BYREF
  __int64 n511_4; // [rsp+5C8h] [rbp+4C8h]
  const char *p_CSCActorStatus::AdjustStatValue_5; // [rsp+5D0h] [rbp+4D0h]
  _BYTE v128[520]; // [rsp+5D8h] [rbp+4D8h] BYREF
  __int64 v129; // [rsp+7E0h] [rbp+6E0h] BYREF
  __int64 n511_2; // [rsp+7E8h] [rbp+6E8h]
  _BYTE *v131; // [rsp+7F0h] [rbp+6F0h]
  _BYTE v132[520]; // [rsp+7F8h] [rbp+6F8h] BYREF
  __int64 v133; // [rsp+A00h] [rbp+900h] BYREF
  __int64 n511_6; // [rsp+A08h] [rbp+908h]
  const char *p_CSCActorStatus::AdjustStatValue_2; // [rsp+A10h] [rbp+910h]
  _BYTE v136[520]; // [rsp+A18h] [rbp+918h] BYREF
  __int64 a1; // [rsp+C20h] [rbp+B20h] BYREF
  __int64 n511_9; // [rsp+C28h] [rbp+B28h]
  _BYTE *v139; // [rsp+C30h] [rbp+B30h]
  _BYTE v140[520]; // [rsp+C38h] [rbp+B38h] BYREF
  __int64 v141; // [rsp+E40h] [rbp+D40h] BYREF
  __int64 n511_8; // [rsp+E48h] [rbp+D48h]
  _BYTE *v143; // [rsp+E50h] [rbp+D50h]
  _BYTE v144[520]; // [rsp+E58h] [rbp+D58h] BYREF
  __int64 v145; // [rsp+1060h] [rbp+F60h] BYREF
  __int64 n511_11; // [rsp+1068h] [rbp+F68h]
  _BYTE *v147; // [rsp+1070h] [rbp+F70h]
  _BYTE v148[520]; // [rsp+1078h] [rbp+F78h] BYREF
  __int64 v149; // [rsp+1280h] [rbp+1180h] BYREF
  __int64 n511_1; // [rsp+1288h] [rbp+1188h]
  _BYTE *v151; // [rsp+1290h] [rbp+1190h]
  _BYTE v152[520]; // [rsp+1298h] [rbp+1198h] BYREF
  __int64 v153; // [rsp+14A0h] [rbp+13A0h] BYREF
  __int64 n511; // [rsp+14A8h] [rbp+13A8h]
  _BYTE *v155; // [rsp+14B0h] [rbp+13B0h]
  _BYTE v156[520]; // [rsp+14B8h] [rbp+13B8h] BYREF
  __int64 v157; // [rsp+16C0h] [rbp+15C0h] BYREF
  __int64 n511_3; // [rsp+16C8h] [rbp+15C8h]
  _BYTE *v159; // [rsp+16D0h] [rbp+15D0h]
  _BYTE v160[520]; // [rsp+16D8h] [rbp+15D8h] BYREF
  __int64 v161; // [rsp+18E0h] [rbp+17E0h] BYREF
  __int64 n511_5; // [rsp+18E8h] [rbp+17E8h]
  _BYTE *v163; // [rsp+18F0h] [rbp+17F0h]
  _BYTE v164[520]; // [rsp+18F8h] [rbp+17F8h] BYREF
  __int64 v165; // [rsp+1B00h] [rbp+1A00h] BYREF
  __int64 n511_7; // [rsp+1B08h] [rbp+1A08h]
  _BYTE *v167; // [rsp+1B10h] [rbp+1A10h]
  _BYTE v168[520]; // [rsp+1B18h] [rbp+1A18h] BYREF
  __int128 v169; // [rsp+1D40h] [rbp+1C40h]
  __int128 v170; // [rsp+1D50h] [rbp+1C50h]
  __int64 v171; // [rsp+1DC8h] [rbp+1CC8h] BYREF
  va_list va; // [rsp+1DC8h] [rbp+1CC8h]
  __int64 v173; // [rsp+1DD0h] [rbp+1CD0h]
  va_list va1; // [rsp+1DD8h] [rbp+1CD8h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v171 = va_arg(va1, _QWORD);
  v173 = va_arg(va1, _QWORD);
  v170 = v3;
  n29_1 = (int)n29_3;
  if ( (unsigned __int8)sub_143686580(rcx0, n29_3) )
  {
    if ( *(float *)&a3 >= 0.00000011920929 || *(float *)&a3 <= -0.00000011920929 )
    {
      n225 = rcx0[n29_1 + 1219];
      n225_1 = n225;
      if ( n225 )
      {
        v28 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v28 + 1808LL))(v28)
          || *(_BYTE *)(*(_QWORD *)(n225 + 144) + 42LL) )
        {
          v29 = (*(__int64 (__fastcall **)(_QWORD *))(*rcx0 + 96LL))(rcx0);
          v30 = 0;
          v31 = (unsigned __int16)v173;
          v90 = v29;
          p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (unsigned __int64)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
          if ( *(int *)(qword_149B3B2E0 + 1076) > 0 )
          {
            n29 = sub_1426551B0(*(char **)(qword_149B3B2E0 + 1080), 29);
            if ( n29 == 29 || n29 == (_DWORD)n29_1 )
            {
              if ( ((v33 = *(_BYTE **)(qword_149B3B2E0 + 1088), !*v33) || *v33 == 48) && !v33[1]
                || (v34 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL,
                    String2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 112LL))(v34),
                    !_stricmp(*(const char **)(qword_149B3B2E0 + 1088), String2)) )
              {
                v156[0] = 0;
                v155 = v156;
                v153 = 0;
                v151 = v152;
                n511 = 511;
                v152[0] = 0;
                v149 = 0;
                n511_1 = 511;
                if ( is_valid_handle_typeB((unsigned __int64 *)va) )
                {
                  p_null = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v171 & 0xFFFFFFFFFFFFLL)
                                                                            + 112LL))(v171 & 0xFFFFFFFFFFFFLL);
                }
                else
                {
                  p_null = "null";
                }
                v37 = (const char *)sub_1402A1380(
                                      &v149,
                                      "OldValue: %.4f,  Adjustment: %.4f, Source: %s, HitId: %hu",
                                      *(float *)n225,
                                      *(float *)&a3,
                                      p_null,
                                      v31)[2];
                v38 = sub_142E0ABB0(n29_1, "UNDEFINED");
                v39 = sub_1402A1380(&v153, "| %s | %s", v38, v37);
                v132[0] = 0;
                v131 = v132;
                v129 = 0;
                n511_2 = 511;
                sub_1402A1CD0(&v129, (void *)v39[2], *v39);
                if ( v151 != v152 )
                {
                  qword_149808368 += -1 - n511_1;
                  sub_14739AF10(v151);
                }
                if ( v155 != v156 )
                {
                  qword_149808368 += -1 - n511;
                  sub_14739AF10(v155);
                }
                sub_146284540(qword_149B3B2E8, v105);
                v159 = v160;
                v160[0] = 0;
                v157 = 0;
                n511_3 = 511;
                if ( byte_14981D4A0 || !is_valid_handle_typeB(v105) )
                {
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
                }
                else
                {
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v105[0] & 0xFFFFFFFFFFFFLL) + 112LL))(v105[0] & 0xFFFFFFFFFFFFLL);
                }
                CLIENT: = "CLIENT: ";
                p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2 = (__int64)p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1;
                if ( byte_14981D4A0 )
                {
                  CLIENT: = "SERVER";
                }
                v42 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
                v43 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v42 + 1808LL))(v42);
                p_Authoritative = "Non-Authoritative";
                if ( v43 )
                {
                  p_Authoritative = "Authoritative";
                }
                v45 = sub_1402A1380(
                        &v157,
                        "%s %s%s",
                        p_Authoritative,
                        CLIENT:,
                        p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2);
                v128[0] = 0;
                p_CSCActorStatus::AdjustStatValue_5 = v128;
                v125 = 0;
                n511_4 = 511;
                sub_1402A1CD0(&v125, (void *)v45[2], *v45);
                if ( v159 != v160 )
                {
                  qword_149808368 += -1 - n511_3;
                  sub_14739AF10(v159);
                }
                p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2 = 225;
                p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor = &p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2;
                v94 = &v90;
                v46 = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)&p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor,
                        (__int64)"ACTOR STAT PREDICTION",
                        "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
                if ( (v46 & 0xFFFFF) != 0 )
                {
                  p_CSCActorStatus::AdjustStatValue = "CSCActorStatus::AdjustStatValue";
                  v103 = (__int64)v131;
                  p_ClientServerInfo = "ClientServerInfo";
                  p_CSCActorStatus::AdjustStatValue_3 = p_CSCActorStatus::AdjustStatValue_5;
                  v47 = rcx0[83];
                  v102 = 0;
                  ptr_to_free_3 = 0;
                  p_ClientServerInfo_2 = 0;
                  LODWORD(p_n225) = 3246;
                  p_ClientServerInfo_1 = 0;
                  ptr_to_free_2 = 0;
                  ptr_to_free_1 = 0;
                  v48 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 **))(*(_QWORD *)(*(_QWORD *)(v47 + 8)
                                                                                              & 0xFFFFFFFFFFFFLL)
                                                                                  + 8LL))(
                                     *(_QWORD *)(v47 + 8) & 0xFFFFFFFFFFFFLL,
                                     &p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor);
                  v49 = rcx0[83];
                  v115 = v48;
                  v114 = 0;
                  v116 = 0;
                  p_CSCActorStatus::AdjustStatValue_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v49 + 8) & 0xFFFFFFFFFFFFLL) + 112LL))(*(_QWORD *)(v49 + 8) & 0xFFFFFFFFFFFFLL);
                  v99 = 0;
                  ptr_to_free = 0;
                  ThreadLogContextSlot = getThreadLogContextSlot();
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2 = 225;
                  *(_QWORD *)&v95 = &p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2;
                  *((_QWORD *)&v95 + 1) = &v90;
                  LODWORD(v87) = v46;
                  v112 = 0;
                  sub_14367C570(
                    5,
                    (__int64)&v95,
                    "ACTOR STAT PREDICTION",
                    (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                    1,
                    v87,
                    &v112,
                    0,
                    (__int64)ThreadLogContextSlot,
                    (__int64)&v99,
                    (__int64)&v114,
                    (__int64)&p_ClientServerInfo,
                    (__int64)&p_ClientServerInfo_1,
                    (__int64)&p_ClientServerInfo_2,
                    (__int64)&v102);
                  free_memory_wrapper(ptr_to_free);
                  free_memory_wrapper(ptr_to_free_1);
                  free_memory_wrapper(ptr_to_free_2);
                  free_memory_wrapper(ptr_to_free_3);
                }
                if ( p_CSCActorStatus::AdjustStatValue_5 != v128 )
                {
                  qword_149808368 += -1 - n511_4;
                  sub_14739AF10(p_CSCActorStatus::AdjustStatValue_5);
                }
                if ( v131 != v132 )
                {
                  qword_149808368 += -1 - n511_2;
                  sub_14739AF10(v131);
                }
                n225 = n225_1;
              }
            }
          }
          v51 = *(float *)n225;
          sub_1436BB390(rcx0, (unsigned int)n29_1, n225, a3, 1, 1, v171, v31);
          sub_1436C0520(rcx0, n225);
          LOBYTE(v52) = 1;
          sub_1436B9D10(rcx0, (unsigned int)n29_1, n225, v52);
          *((_BYTE *)rcx0 + n29_1 + 10214) = 1;
          if ( byte_14981D7F5 )
          {
            if ( PathUtils::IsGameAssetPath(rcx0[83]) )
            {
              if ( (unsigned int)n29_1 <= 1 )
              {
                v53 = *(float *)(*(_QWORD *)(n225 + 144) + 12LL);
                if ( v53 == *(float *)n225 && v53 == *(float *)(n225 + 28) )
                {
                  v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 160LL))(qword_14981D298);
                  v55 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v54 + 608LL))(v54);
                  LOBYTE(v56) = 1;
                  (*(void (__fastcall **)(__int64, __int64, _QWORD, __int64))(*(_QWORD *)v55 + 24LL))(v55, 24, 0, v56);
                }
              }
            }
          }
          if ( !v90 )
          {
            if ( (*(unsigned __int8 (__fastcall **)(_QWORD *))(*rcx0 + 96LL))(rcx0) )
            {
              sub_143681630((__int64)rcx0);
              if ( *(int *)(qword_149B3B2E0 + 1072) > 0 )
              {
                sub_146284540(qword_149B3B2E8, &n225_1);
                v57 = byte_14981D4A0 == 0;
                v163 = v164;
                v164[0] = 0;
                v161 = 0;
                n511_5 = 511;
                if ( !byte_14981D4A0 )
                {
                  if ( is_valid_handle_typeB((unsigned __int64 *)&n225_1) )
                  {
                    p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._3 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(n225_1 & 0xFFFFFFFFFFFFLL) + 112LL))(n225_1 & 0xFFFFFFFFFFFFLL);
                  }
                  else
                  {
                    p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._3 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
                  }
                  v57 = byte_14981D4A0 == 0;
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (unsigned __int64)p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._3;
                }
                CLIENT:_1 = "CLIENT: ";
                if ( !v57 )
                {
                  CLIENT:_1 = "SERVER";
                }
                v60 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
                v61 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v60 + 1808LL))(v60);
                p_Authoritative_1 = "Non-Authoritative";
                if ( v61 )
                {
                  p_Authoritative_1 = "Authoritative";
                }
                v63 = sub_1402A1380(
                        &v161,
                        "%s %s%s",
                        p_Authoritative_1,
                        CLIENT:_1,
                        p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.);
                v136[0] = 0;
                p_CSCActorStatus::AdjustStatValue_2 = v136;
                v133 = 0;
                n511_6 = 511;
                sub_1402A1CD0(&v133, (void *)v63[2], *v63);
                if ( v163 != v164 )
                {
                  qword_149808368 += -1 - n511_5;
                  sub_14739AF10(v163);
                }
                p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = 225;
                *(_QWORD *)&v95 = &p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.;
                *((_QWORD *)&v95 + 1) = &n225_1;
                v64 = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)&v95,
                        (__int64)"ACTOR INCAPACITATED",
                        "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
                if ( (v64 & 0xFFFFF) != 0 )
                {
                  v65 = *(float *)n225;
                  v169 = v4;
                  v167 = v168;
                  v168[0] = 0;
                  v165 = 0;
                  n511_7 = 511;
                  v66 = sub_142E0ABB0(n29_1, "UNDEFINED");
                  p_CSCActorStatus::AdjustStatValue_6 = sub_1402A1380(
                                                          &v165,
                                                          "Actor Incapacitated for change in stat: %s, OldValue: %.4f, Cu"
                                                          "rrentValue: %.4f",
                                                          v66,
                                                          v51,
                                                          v65)[2];
                  p_CSCActorStatus::AdjustStatValue_1 = "CSCActorStatus::AdjustStatValue";
                  p_ClientServerInfo_1 = "ClientServerInfo";
                  p_CSCActorStatus::AdjustStatValue = p_CSCActorStatus::AdjustStatValue_2;
                  v68 = rcx0[83];
                  p_CSCActorStatus::AdjustStatValue_3 = (const char *)p_CSCActorStatus::AdjustStatValue_6;
                  p_ClientServerInfo = 0;
                  ptr_to_free_1 = 0;
                  *(_QWORD *)&v95 = 0;
                  DWORD2(v95) = 3259;
                  v99 = 0;
                  ptr_to_free = 0;
                  ptr_to_free_2 = 0;
                  v69 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 **))(*(_QWORD *)(*(_QWORD *)(v68 + 8)
                                                                                              & 0xFFFFFFFFFFFFLL)
                                                                                  + 8LL))(
                                     *(_QWORD *)(v68 + 8) & 0xFFFFFFFFFFFFLL,
                                     &p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor);
                  v70 = rcx0[83];
                  v115 = v69;
                  v114 = 0;
                  v116 = 0;
                  v103 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v70 + 8) & 0xFFFFFFFFFFFFLL)
                                                            + 112LL))(*(_QWORD *)(v70 + 8) & 0xFFFFFFFFFFFFLL);
                  v102 = 0;
                  ptr_to_free_3 = 0;
                  ThreadLogContextSlot_1 = getThreadLogContextSlot();
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = 225;
                  p_ClientServerInfo_2 = &p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.;
                  p_n225 = &n225_1;
                  LODWORD(v88) = v64;
                  v112 = 0;
                  sub_14367C570(
                    5,
                    (__int64)&p_ClientServerInfo_2,
                    "ACTOR INCAPACITATED",
                    (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                    1,
                    v88,
                    &v112,
                    0,
                    (__int64)ThreadLogContextSlot_1,
                    (__int64)&v102,
                    (__int64)&v114,
                    (__int64)&p_ClientServerInfo_1,
                    (__int64)&v99,
                    (__int64)&v95,
                    (__int64)&p_ClientServerInfo);
                  free_memory_wrapper(ptr_to_free_3);
                  free_memory_wrapper(ptr_to_free_2);
                  free_memory_wrapper(ptr_to_free);
                  free_memory_wrapper(ptr_to_free_1);
                  if ( v167 != v168 )
                  {
                    qword_149808368 += -1 - n511_7;
                    sub_14739AF10(v167);
                  }
                }
                if ( p_CSCActorStatus::AdjustStatValue_2 != v136 )
                {
                  qword_149808368 += -1 - n511_6;
                  sub_14739AF10(p_CSCActorStatus::AdjustStatValue_2);
                }
              }
            }
          }
          if ( (unsigned __int8)sub_14369CF80(rcx0, (unsigned int)n29_1) )
          {
            sub_1449208F0(rcx0 + 122, (unsigned int)n29_1);
          }
          n225_2 = rcx0[142];
          n225_1 = n225_2;
          if ( is_valid_handle_typeA(&n225_1) )
          {
            v73 = rcx0[1297];
            if ( v73 )
            {
              v74 = *(_QWORD *)(v73 + 384);
              if ( v74 )
              {
                for ( i = (_DWORD *)(*(_QWORD *)(v73 + 376) + 8LL); *i != (_DWORD)n29_1; i += 16 )
                {
                  if ( ++v30 >= v74 )
                  {
                    return;
                  }
                }
                v76 = sub_1435EA200(n225_2 & 0xFFFFFFFFFFFFLL);
                v105[0] = v30 << 6;
                LOBYTE(v77) = v51 > *(float *)n225;
                sub_1436B5FE0((_DWORD)rcx0, n29_1, n225, v77, *(_QWORD *)(v73 + 376) + (v30 << 6), v76);
                n225_3 = rcx0[144];
                n225_1 = n225_3;
                if ( is_valid_handle_typeA(&n225_1) )
                {
                  v79 = sub_1435EA200(n225_3 & 0xFFFFFFFFFFFFLL);
                  LOBYTE(v80) = v51 > *(float *)n225;
                  sub_1436B5FE0((_DWORD)rcx0, n29_1, n225, v80, *(_QWORD *)(v73 + 376) + v105[0], v79);
                }
                n225_4 = rcx0[145];
                n225_1 = n225_4;
                if ( n225_4 )
                {
                  handle_metadata_ptr = get_handle_metadata_ptr(n225_4 & 0xFFFFFFFFFFFFLL);
                  n4 = *(_WORD *)(handle_metadata_ptr + 4);
                  if ( n4 != 4
                    && *(_WORD *)(handle_metadata_ptr + 2) == (HIWORD(n225_4) & 0xFFF)
                    && (n4 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_handle_access_by_state(&n225_1)) )
                  {
                    v84 = sub_1435EA200(n225_4 & 0xFFFFFFFFFFFFLL);
                    LOBYTE(v85) = v51 > *(float *)n225;
                    sub_1436B5FE0((_DWORD)rcx0, n29_1, n225, v85, *(_QWORD *)(v73 + 376) + (v30 << 6), v84);
                  }
                }
              }
            }
          }
        }
      }
    }
    else if ( *(int *)(qword_149B3B2E0 + 1076) > 0 )
    {
      n29_2 = sub_1426551B0(*(char **)(qword_149B3B2E0 + 1080), 29);
      if ( n29_2 == 29 || n29_2 == (_DWORD)n29_1 )
      {
        if ( ((v8 = *(_BYTE **)(qword_149B3B2E0 + 1088), !*v8) || *v8 == 48) && !v8[1]
          || (v9 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL,
              String2_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 112LL))(v9),
              !_stricmp(*(const char **)(qword_149B3B2E0 + 1088), String2_1)) )
        {
          v11 = (unsigned __int16)v173;
          v143 = v144;
          v144[0] = 0;
          v139 = v140;
          v141 = 0;
          n511_8 = 511;
          v140[0] = 0;
          a1 = 0;
          n511_9 = 511;
          if ( is_valid_handle_typeB((unsigned __int64 *)va) )
          {
            p_null_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v171 & 0xFFFFFFFFFFFFLL) + 112LL))(v171 & 0xFFFFFFFFFFFFLL);
          }
          else
          {
            p_null_1 = "null";
          }
          v13 = (const char *)sub_1402A1380(
                                &a1,
                                "Invalid Adjustment: %.4f, Source: %s, HitId: %hu",
                                *(float *)&a3,
                                p_null_1,
                                v11)[2];
          v14 = sub_142E0ABB0(n29_1, "UNDEFINED");
          v15 = sub_1402A1380(&v141, "| %s | %s", v14, v13);
          v124[0] = 0;
          p_CSCActorStatus::AdjustStatValue_4 = v124;
          v121 = 0;
          n511_10 = 511;
          sub_1402A1CD0(&v121, (void *)v15[2], *v15);
          if ( v139 != v140 )
          {
            qword_149808368 += -1 - n511_9;
            sub_14739AF10(v139);
          }
          if ( v143 != v144 )
          {
            qword_149808368 += -1 - n511_8;
            sub_14739AF10(v143);
          }
          sub_146284540(qword_149B3B2E8, &p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.);
          v147 = v148;
          v148[0] = 0;
          v145 = 0;
          n511_11 = 511;
          if ( byte_14981D4A0
            || !is_valid_handle_typeB(&p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.) )
          {
            p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._4 = (const char *)&p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
          }
          else
          {
            p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._4 = (const char *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. & 0xFFFFFFFFFFFFLL) + 112LL))(
                                                                                                p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.
                                                                                              & 0xFFFFFFFFFFFFLL);
          }
          CLIENT:_2 = "CLIENT: ";
          if ( byte_14981D4A0 )
          {
            CLIENT:_2 = "SERVER";
          }
          v18 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
          v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 1808LL))(v18);
          p_Authoritative_2 = "Non-Authoritative";
          if ( v19 )
          {
            p_Authoritative_2 = "Authoritative";
          }
          v21 = sub_1402A1380(
                  &v145,
                  "%s %s%s",
                  p_Authoritative_2,
                  CLIENT:_2,
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._4);
          v120[0] = 0;
          p_n225_1 = (__int64 *)v120;
          v117 = 0;
          n511_12 = 511;
          sub_1402A1CD0(&v117, (void *)v21[2], *v21);
          if ( v147 != v148 )
          {
            qword_149808368 += -1 - n511_11;
            sub_14739AF10(v147);
          }
          p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2 = 225;
          p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor = &p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2;
          v94 = &v90;
          v22 = invokeGlobalCallbackAndMaskStatusBits(
                  5,
                  (__int64)&p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor,
                  (__int64)"ACTOR STAT PREDICTION",
                  "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
          if ( (v22 & 0xFFFFF) != 0 )
          {
            p_CSCActorStatus::AdjustStatValue_3 = "CSCActorStatus::AdjustStatValue";
            p_CSCActorStatus::AdjustStatValue_1 = p_CSCActorStatus::AdjustStatValue_4;
            p_ClientServerInfo_2 = (unsigned __int64 *)"ClientServerInfo";
            p_n225 = p_n225_1;
            v23 = rcx0[83];
            v99 = 0;
            ptr_to_free = 0;
            p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor = 0;
            LODWORD(v94) = 3226;
            p_ClientServerInfo = 0;
            ptr_to_free_1 = 0;
            ptr_to_free_5 = 0;
            v24 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(*(_QWORD *)(v23 + 8)
                                                                                       & 0xFFFFFFFFFFFFLL)
                                                                           + 8LL))(
                               *(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFLL,
                               &n225_1);
            v25 = rcx0[83];
            v103 = v24;
            v102 = 0;
            LOBYTE(ptr_to_free_3) = 0;
            *((_QWORD *)&v112 + 1) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v25 + 8)
                                                                                    & 0xFFFFFFFFFFFFLL)
                                                                        + 112LL))(*(_QWORD *)(v25 + 8) & 0xFFFFFFFFFFFFLL);
            *(_QWORD *)&v112 = 0;
            ptr_to_free_4 = 0;
            ThreadLogContextSlot_2 = getThreadLogContextSlot();
            p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2 = 225;
            v105[0] = (unsigned __int64)&p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2;
            v105[1] = (unsigned __int64)&v90;
            LODWORD(v86) = v22;
            v95 = 0;
            sub_14367C570(
              5,
              (__int64)v105,
              "ACTOR STAT PREDICTION",
              (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
              1,
              v86,
              &v95,
              0,
              (__int64)ThreadLogContextSlot_2,
              (__int64)&v112,
              (__int64)&v102,
              (__int64)&p_ClientServerInfo_2,
              (__int64)&p_ClientServerInfo,
              (__int64)&p_p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_cor,
              (__int64)&v99);
            free_memory_wrapper(ptr_to_free_4);
            free_memory_wrapper(ptr_to_free_5);
            free_memory_wrapper(ptr_to_free_1);
            free_memory_wrapper(ptr_to_free);
          }
          if ( p_n225_1 != (__int64 *)v120 )
          {
            qword_149808368 += -1 - n511_12;
            sub_14739AF10(p_n225_1);
          }
          if ( p_CSCActorStatus::AdjustStatValue_4 != v124 )
          {
            qword_149808368 += -1 - n511_10;
            sub_14739AF10(p_CSCActorStatus::AdjustStatValue_4);
          }
        }
      }
    }
  }
}

// --- End Function: sub_143681C30 (0x143681C30) ---

// --- Function: sub_143686260 (0x143686260) ---
bool __fastcall sub_143686260(__int64 a1, float a2, float a3, __int64 a4, unsigned __int64 *a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  unsigned __int64 *v8; // rsi
  int v11; // edi
  unsigned int v12; // ebx
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rdx
  float v17; // xmm0_4
  float v18; // xmm8_4
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // r9
  int n2; // eax
  _OWORD *v25; // r9
  _OWORD *v26; // rbx
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // rcx
  unsigned __int64 v29; // r8
  _QWORD *v30; // rdx
  __int64 v31; // rax
  _QWORD *v32; // rcx
  _QWORD *v33; // rdi
  float v34; // kr00_4
  _OWORD v36[4]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v37; // [rsp+80h] [rbp+8h] BYREF

  v8 = a5;
  v36[3] = v5;
  v36[2] = v6;
  v36[1] = v7;
  v11 = sub_1403561D0(*a5);
  v12 = 0;
  v13 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 664) + 2208LL))(*(_QWORD *)(a1 + 664));
  if ( v13 )
  {
    v15 = sub_14522A500(v13);
    LOBYTE(v16) = 3;
    v12 = sub_1461CEF60(v15, v16);
  }
  v17 = sub_1436936C0(a4, v14, v12);
  v18 = v17;
  if ( (unsigned int)(v11 - 16) <= 2 )
  {
    v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 160LL))(qword_14981D298);
    v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 384LL))(v19);
    v21 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 40LL))(v20);
    if ( v21 )
    {
      v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v21 + 1832LL))(v21);
      if ( v22 )
      {
        LOBYTE(v23) = 1;
        v18 = v17
            * (*(float (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v22 + 1424LL))(v22, 2, 1, v23);
      }
    }
  }
  if ( v18 >= 0.99999988 )
  {
    return 1;
  }
  if ( v18 < 0.00000011920929 )
  {
    return 0;
  }
  n2 = *(_DWORD *)(a4 + 56);
  if ( n2 && (n2 != 1 || a2 <= a3) && (n2 != 2 || a2 >= a3) )
  {
    return 0;
  }
  v25 = *(_OWORD **)(a1 + 10064);
  v26 = *(_OWORD **)(a1 + 10056);
  v27 = v25 - v26;
  v28 = v27;
  while ( v28 )
  {
    if ( *(_QWORD *)&v26[v28 >> 1] >= *v8 )
    {
      v28 >>= 1;
    }
    else
    {
      v26 += (v28 >> 1) + 1;
      v28 += -1LL - (v28 >> 1);
    }
  }
  if ( v26 != v25 && *v8 < *(_QWORD *)v26 )
  {
    v26 = *(_OWORD **)(a1 + 10064);
  }
  if ( v26 == *(_OWORD **)(a1 + 10064) )
  {
    v29 = *v8;
    v26 = *(_OWORD **)(a1 + 10056);
    v36[0] = *v8;
    while ( v27 )
    {
      if ( *(_QWORD *)&v26[v27 >> 1] >= v29 )
      {
        v27 >>= 1;
      }
      else
      {
        v26 += (v27 >> 1) + 1;
        v27 += -1LL - (v27 >> 1);
      }
    }
    if ( v26 == v25 || v29 < *(_QWORD *)v26 )
    {
      if ( v25 == *(_OWORD **)(a1 + 10072) )
      {
        v26 = sub_140305AD0((const void **)(a1 + 10056), v26, v36);
      }
      else if ( v26 == v25 )
      {
        *v25 = v36[0];
        *(_QWORD *)(a1 + 10064) += 16LL;
      }
      else
      {
        v30 = v25 - 1;
        *v25 = *(v25 - 1);
        *(_QWORD *)(a1 + 10064) += 16LL;
        if ( v25 - 1 != v26 )
        {
          do
          {
            v31 = *(v30 - 2);
            v32 = v30;
            v30 -= 2;
            *v32 = v31;
            v30[3] = v30[1];
          }
          while ( v30 != (_QWORD *)v26 );
        }
        *v26 = v36[0];
      }
    }
  }
  v33 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D260 + 56LL))(qword_14981D260, 0);
  if ( !sub_140593AF0(v33, (_QWORD *)v26 + 1) )
  {
    return 0;
  }
  v37 = (unsigned int)(int)(float)(*(float *)(a4 + 52) * 10000000.0);
  *((_QWORD *)v26 + 1) = *g_GameTimer_GetCurrentTicks(v33, v36, &v37);
  v34 = (float)(unsigned int)sub_140569650((__int64)&unk_149602570);
  return v18 >= (float)(v34 * 2.3283064e-10);
}

// --- End Function: sub_143686260 (0x143686260) ---

// --- Function: sub_143686580 (0x143686580) ---
bool __fastcall sub_143686580(__int64 a1, int a2)
{
  bool result; // al

  switch ( a2 )
  {
    case 0:
      result = *(_DWORD *)(qword_149B3B2E0 + 1096) != 0;
      break;
    case 1:
      result = *(_DWORD *)(qword_149B3B2E0 + 1104) != 0;
      break;
    case 2:
      result = *(_DWORD *)(qword_149B3B2E0 + 1100) != 0;
      break;
    default:
      result = 1;
      break;
  }
  return result;
}

// --- End Function: sub_143686580 (0x143686580) ---

// --- Function: sub_143692B60 (0x143692B60) ---
__int64 __fastcall sub_143692B60(__int64 a1)
{
  _QWORD *v1; // rsi
  int *v3; // rbx
  int *v4; // rax
  int v5; // ebx
  int v6; // edi
  __int64 v7; // rdi
  unsigned __int8 (__fastcall *v8)(__int64, __int64, const char *); // rbx
  __int64 v9; // rax
  __int64 v11; // rsi
  int *v12; // rbx
  int *v13; // rax
  int v14; // ebx
  int v15; // edi
  __int64 v16; // rdi
  unsigned __int8 (__fastcall *v17)(__int64, __int64, const char *); // rbx
  __int64 v18; // rax
  _BYTE v19[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v20; // [rsp+28h] [rbp-30h]
  _BYTE v21[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v22; // [rsp+40h] [rbp-18h]

  v1 = *(_QWORD **)(a1 + 96);
  if ( v1 )
  {
    v3 = (int *)sub_1436B7740(v21);
    v4 = (int *)(*(__int64 (__fastcall **)(_QWORD *, _BYTE *))(*v1 + 24LL))(v1, v19);
    v5 = *v3;
    v6 = *v4;
    if ( v20 )
    {
      sub_14739AF10(v20);
    }
    if ( v22 )
    {
      sub_14739AF10(v22);
    }
    if ( v5 == v6 )
    {
      return v1[1] + 8LL;
    }
    if ( Parameter_3 )
    {
      if ( (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3) )
      {
        v7 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3);
        v8 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v7 + 256LL);
        v9 = (*(__int64 (__fastcall **)(_QWORD *))(*v1 + 8LL))(v1);
        if ( v8(v7, v9, "StatusEffectSetupPreset") )
        {
          return v1[1] + 8LL;
        }
      }
    }
  }
  v11 = *(_QWORD *)(a1 + 96);
  if ( !v11 )
  {
    return 0;
  }
  v12 = (int *)sub_1436B7660(v19);
  v13 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v11 + 24LL))(v11, v21);
  v14 = *v12;
  v15 = *v13;
  if ( v22 )
  {
    sub_14739AF10(v22);
  }
  if ( v20 )
  {
    sub_14739AF10(v20);
  }
  if ( v14 == v15 )
  {
    return v11;
  }
  if ( Parameter_3
    && (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3)
    && (v16 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
        v17 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v16 + 256LL),
        v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11),
        v17(v16, v18, "StatusEffectSetup")) )
  {
    return v11;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_143692B60 (0x143692B60) ---

// --- Function: sub_1436936C0 (0x1436936C0) ---
float __fastcall sub_1436936C0(__int64 a1, float a2, unsigned int a3)
{
  __int64 v4; // rdi
  __int64 v6; // r8
  int v7; // r10d
  unsigned __int64 v8; // rdx
  float v9; // xmm3_4
  float v10; // xmm4_4
  float v11; // xmm0_4
  float v12; // xmm2_4
  float v13; // xmm5_4
  float v14; // xmm3_4
  __int64 v15; // rcx
  unsigned __int64 v16; // rdx

  v4 = (int)a3;
  if ( a2 < (*(float (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 48LL))(a1, a3) )
  {
    return 0.0;
  }
  if ( a2 >= (*(float (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 64LL))(a1, (unsigned int)v4) )
  {
    return 1.0;
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = v4 - 1;
  v8 = (int)v4 - 1;
  if ( !v6 )
  {
    v9 = *(float *)(a1 + 32);
    v10 = v9;
LABEL_6:
    v11 = *(float *)(a1 + 28);
    v12 = v11;
    goto LABEL_7;
  }
  if ( (int)v4 <= 0 || (unsigned __int64)v7 >= *(_QWORD *)(v6 + 32) )
  {
    v15 = v7;
    v9 = *(float *)(a1 + 32);
    v10 = v9;
    if ( (int)v4 <= 0 || (unsigned __int64)v7 >= *(_QWORD *)(v6 + 32) )
    {
      goto LABEL_6;
    }
  }
  else
  {
    v10 = *(float *)(a1 + 32);
    v9 = (float)(*(float *)(*(_QWORD *)(v6 + 24) + 32LL * v7 + 16) + 1.0) * v10;
    v15 = v7;
  }
  v12 = *(float *)(a1 + 28);
  v11 = (float)(*(float *)(*(_QWORD *)(v6 + 24) + 32 * v15 + 12) + 1.0) * v12;
LABEL_7:
  v13 = v10;
  if ( fabs(v9 - v11) <= 0.00000011920929 )
  {
    return 1.0;
  }
  if ( !v6 )
  {
    v14 = v12;
    goto LABEL_25;
  }
  if ( (int)v4 <= 0 || (v7 = v4 - 1, v8 >= *(_QWORD *)(v6 + 32)) )
  {
    v16 = v7;
    v14 = v12;
    if ( (int)v4 <= 0 )
    {
      goto LABEL_22;
    }
  }
  else
  {
    v14 = (float)(*(float *)(*(_QWORD *)(v6 + 24) + 32 * v8 + 12) + 1.0) * v12;
    v16 = v4 - 1;
  }
  if ( v16 < *(_QWORD *)(v6 + 32) )
  {
    v13 = (float)(*(float *)(*(_QWORD *)(v6 + 24) + 32 * v16 + 16) + 1.0) * v10;
LABEL_24:
    v12 = (float)(*(float *)(*(_QWORD *)(v6 + 24) + 32 * v16 + 12) + 1.0) * v12;
    goto LABEL_25;
  }
LABEL_22:
  v13 = v10;
  if ( (int)v4 > 0 && v16 < *(_QWORD *)(v6 + 32) )
  {
    goto LABEL_24;
  }
LABEL_25:
  LODWORD(_XMM4) = *(_DWORD *)(a1 + 44);
  _XMM6 = *(unsigned int *)(a1 + 48);
  if ( (float)((float)((float)((float)(a2 - v14) / (float)(v13 - v12)) * (float)(*(float *)&_XMM6 - *(float *)&_XMM4))
             + *(float *)&_XMM4) >= *(float *)&_XMM4 )
  {
    __asm { vminss  xmm4, xmm6, xmm0 }
  }
  return *(float *)&_XMM4;
}

// --- End Function: sub_1436936C0 (0x1436936C0) ---

// --- Function: sub_14369CF80 (0x14369CF80) ---
char __fastcall sub_14369CF80(__int64 a1, __int64 n29)
{
  char result; // al

  switch ( (int)n29 )
  {
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

// --- End Function: sub_14369CF80 (0x14369CF80) ---

// --- Function: sub_14369D0B0 (0x14369D0B0) ---
bool __fastcall sub_14369D0B0(__int64 a1, __int64 a2, float *a3, float a4, float a5, float a6, float a7)
{
  _DWORD *v10; // rdi
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rdx
  unsigned int v14; // ebx
  int n2; // eax
  double v16; // xmm7_8
  double v17; // xmm8_8
  double v18; // xmm6_8
  double v19; // xmm0_8
  double v20; // xmm9_8
  double v21; // kr00_8
  double v24; // xmm0_8
  double v25; // xmm7_8
  double v26; // xmm2_8
  double v27; // xmm0_8
  double v28; // xmm1_8
  double v29; // kr00_8
  __int64 v30; // rdi
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rdx
  unsigned int v34; // ebx
  double v35; // xmm0_8
  double v36; // kr00_8
  double v37; // xmm2_8
  double v38; // xmm0_8
  double v39; // xmm1_8
  double v40; // xmm3_8
  bool v41; // zf
  __int64 v42; // rax
  double v43; // xmm4_8
  double v44; // xmm0_8
  double v45; // kr00_8

  v10 = (_DWORD *)sub_143675E30(a2);
  if ( v10 )
  {
    v11 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 664) + 2208LL))(*(_QWORD *)(a1 + 664));
    if ( v11 )
    {
      v12 = sub_14522A500(v11);
      LOBYTE(v13) = 3;
      v14 = sub_1461CEF60(v12, v13);
    }
    else
    {
      v14 = 0;
    }
    n2 = v10[14];
    if ( !n2 || n2 == 1 && a4 > a5 || n2 == 2 && a4 < a5 )
    {
      v24 = (*(double (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)v10 + 56LL))(v10, v14);
      v25 = *(float *)&v24;
      v26 = ((__m128 (__fastcall *)(_DWORD *, _QWORD))*(_QWORD *)(*(_QWORD *)v10 + 48LL))(v10, v14).m128_f32[0];
      v27 = a4;
      v28 = a7;
      v29 = a6;
      if ( a4 <= v25 && v27 >= v26 || v27 <= v29 && v25 == v29 && v26 == v29 )
      {
        return 1;
      }
      if ( v27 < v28 || v25 != v28 )
      {
        return 0;
      }
      return v26 == v28;
    }
    else
    {
      v16 = a7;
      v17 = a6;
      v18 = a4;
      v19 = (*(double (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)v10 + 56LL))(v10, v14);
      v20 = *(float *)&v19;
      v21 = ((__m128 (__fastcall *)(_DWORD *, _QWORD))*(_QWORD *)(*(_QWORD *)v10 + 64LL))(v10, v14).m128_f32[0];
      if ( a4 <= v20 && v18 >= v21 || v18 <= v17 && v20 == v17 && v21 == v17 )
      {
        return 1;
      }
      if ( v18 < v16 || v20 != v16 )
      {
        return 0;
      }
      return v21 == v16;
    }
  }
  v30 = sub_143675D30(a2);
  if ( !v30 )
  {
    v42 = sub_143675B30(a2);
    if ( !v42 )
    {
      return 0;
    }
    v43 = *(float *)(v42 + 28);
    v44 = a4;
    v37 = *(float *)(v42 + 24);
    v39 = a7;
    v45 = a6;
    if ( a4 <= v43 && v44 >= v37 || v44 <= v45 && v43 == v45 && v37 == v45 )
    {
      return 1;
    }
    if ( v44 < v39 )
    {
      return 0;
    }
    v41 = v43 == v39;
    goto LABEL_40;
  }
  v31 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 664) + 2208LL))(*(_QWORD *)(a1 + 664));
  if ( v31 )
  {
    v32 = sub_14522A500(v31);
    LOBYTE(v33) = 3;
    v34 = sub_1461CEF60(v32, v33);
  }
  else
  {
    v34 = 0;
  }
  v35 = (*(double (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v30 + 56LL))(v30, v34);
  v36 = *(float *)&v35;
  v37 = ((__m128 (__fastcall *)(__int64, _QWORD))*(_QWORD *)(*(_QWORD *)v30 + 48LL))(v30, v34).m128_f32[0];
  v38 = *a3;
  v39 = a3[3];
  v40 = a3[2];
  if ( v38 <= v36 && v38 >= v37 || v38 <= v40 && v36 == v40 && v37 == v40 )
  {
    return 1;
  }
  if ( v38 >= v39 )
  {
    v41 = v36 == v39;
LABEL_40:
    if ( v41 && v37 == v39 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_14369D0B0 (0x14369D0B0) ---

// --- Function: sub_1436A7DF0 (0x1436A7DF0) ---
void __fastcall sub_1436A7DF0(__int64 rcx0, __int64 n10, __int64 n225, __int64 a4)
{
  __int64 n10_1; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r8
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rax
  int v19; // r9d
  __int64 v20; // r13
  __int64 v24; // rax
  __int64 v25; // rcx
  __int64 v26; // rax
  int v27; // edx
  int v28; // r8d
  unsigned __int64 v31; // rsi
  unsigned __int64 v32; // rbx
  __int64 v33; // rdi
  __int64 v34; // r15
  unsigned __int64 v35; // rbx
  unsigned __int64 v36; // rsi
  __int64 v37; // r14
  __int64 v38; // rdx
  __int64 v39; // rcx
  unsigned __int64 v40; // rbx
  unsigned __int64 n0x6400000; // rbx
  char *v42; // rdi
  char *v43; // rcx
  signed __int64 v44; // rbx
  char *v45; // r9
  char *v46; // rcx
  unsigned __int64 v47; // rdx
  char *v48; // rdx
  int v50; // eax
  int v53; // [rsp+20h] [rbp-88h]
  int v54; // [rsp+28h] [rbp-80h]
  int v55; // [rsp+30h] [rbp-78h]
  void *Src[2]; // [rsp+40h] [rbp-68h] BYREF
  __int64 v57; // [rsp+50h] [rbp-58h]
  __int64 a1[2]; // [rsp+58h] [rbp-50h] BYREF
  char *v59; // [rsp+68h] [rbp-40h]
  __int64 v61; // [rsp+B0h] [rbp+8h] BYREF

  _RBX = *(_QWORD *)(rcx0 + 10128);
  n10_1 = (int)n10;
  v9 = *(_QWORD *)(rcx0 + 10136);
  v10 = (__int64)(v9 - _RBX) >> 4;
  while ( v10 )
  {
    if ( *(_DWORD *)(_RBX + 16 * (v10 >> 1)) >= (int)n10_1 )
    {
      v10 >>= 1;
    }
    else
    {
      _RBX += 16 * (v10 >> 1) + 16;
      v10 += -1LL - (v10 >> 1);
    }
  }
  if ( _RBX != v9 )
  {
    if ( (int)n10_1 < *(_DWORD *)_RBX )
    {
      _RBX = *(_QWORD *)(rcx0 + 10136);
    }
    if ( _RBX != v9 )
    {
      __asm { vmovss  xmm0, dword ptr [rbx+4] }
      __asm
      {
        vmovaps [rsp+0A8h+var_38], xmm6
        vaddss  xmm1, xmm0, xmm2
        vxorps  xmm6, xmm6, xmm6
        vcomiss xmm1, xmm6
        vmovss  dword ptr [rbx+8], xmm0
      }
      if ( _RBX >= v9 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+0Ch]
          vminss  xmm0, xmm0, xmm1
        }
      }
      else
      {
        __asm { vxorps  xmm0, xmm0, xmm0 }
      }
      v16 = *(_QWORD *)(rcx0 + 8 * n10_1 + 9752);
      __asm { vmovss  dword ptr [rbx+4], xmm0 }
      v17 = *(_QWORD *)(*(_QWORD *)(v16 + 144) + 112LL);
      if ( v17 )
      {
        v18 = (*(__int64 (**)(void))(*(_QWORD *)v17 + 48LL))();
        v20 = v18;
        if ( v18 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbx+0Ch]
            vmovss  xmm3, dword ptr [rbx+4]
          }
          __asm
          {
            vmovss  [rsp+0A8h+var_78], xmm0
            vmovss  xmm0, dword ptr [rbx+8]
            vmovss  [rsp+0A8h+var_80], xmm6
          }
          __asm { vmovss  dword ptr [rsp+0A8h+var_88], xmm0 }
          if ( (unsigned __int8)sub_14369D0B0(rcx0, *(_QWORD *)(v18 + 16), a4, v19, v53, v54, v55) )
          {
            v24 = sub_145A52C30((unsigned int)n10_1, *(unsigned int *)(v20 + 8));
            v25 = *(_QWORD *)(v20 + 16);
            v61 = v24;
            v26 = sub_143675E30(v25);
            if ( !v26 )
            {
              goto LABEL_18;
            }
            __asm
            {
              vmovss  xmm2, dword ptr [rbx+8]
              vmovss  xmm1, dword ptr [rbx+4]
            }
            if ( (unsigned __int8)sub_143686260(rcx0, v27, v28, v26, (__int64)&v61) )
            {
LABEL_18:
              *(_QWORD *)(_RBX + 4) = 0;
              v31 = *(_QWORD *)(sub_143692B60(*(_QWORD *)(a4 + 144)) + 32);
              v32 = v31 - 1;
              v33 = 16 * (v31 - 1);
              while ( v32 < v31 )
              {
                v34 = *(_QWORD *)(v33 + *(_QWORD *)(sub_143692B60(*(_QWORD *)(a4 + 144)) + 24));
                if ( *(_DWORD *)(v34 + 8) == *(_DWORD *)(v20 + 8) )
                {
                  v35 = *(_QWORD *)(v34 + 56);
                  v61 = v35;
                  v36 = 0;
                  if ( v35 )
                  {
                    v37 = 0;
                    do
                    {
                      if ( *(_QWORD *)(v37 + *(_QWORD *)(v34 + 48)) )
                      {
                        v38 = *(unsigned int *)(v20 + 8);
                        v39 = ((__int64)*(int *)(*(_QWORD *)(v37 + *(_QWORD *)(v34 + 48)) + 8LL) << 7) + 1168;
                        v57 = 0;
                        __asm { vpxor   xmm0, xmm0, xmm0 }
                        __asm { vmovdqu xmmword ptr [rsp+0A8h+Src], xmm0 }
                        if ( (unsigned __int8)sub_145A798A0(rcx0 + v39, v38, Src) )
                        {
                          v40 = ((char *)Src[1] - (char *)Src[0]) >> 4;
                          v59 = 0;
                          __asm
                          {
                            vpxor   xmm0, xmm0, xmm0
                            vmovdqu xmmword ptr [rsp+0A8h+a1], xmm0
                          }
                          if ( v40 )
                          {
                            if ( v40 > 0xFFFFFFFFFFFFFFFLL )
                            {
                              unknown_libname_10();
                            }
                            n0x6400000 = 16 * v40;
                            v42 = (char *)sub_14038E0B0((__int64)a1, n0x6400000);
                            a1[0] = (__int64)v42;
                            a1[1] = (__int64)v42;
                            v43 = &v42[n0x6400000];
                            v44 = (char *)Src[1] - (char *)Src[0];
                            v59 = v43;
                            memmove(v42, Src[0], (char *)Src[1] - (char *)Src[0]);
                            a1[1] = (__int64)&v42[v44 & 0xFFFFFFFFFFFFFFF0uLL];
                          }
                          sub_1436B0C70(rcx0, a1);
                          v35 = v61;
                        }
                        if ( Src[0] )
                        {
                          sub_14039EFB0((__int64)Src, Src[0], (v57 - (unsigned __int64)Src[0]) & 0xFFFFFFFFFFFFFFF0uLL);
                        }
                      }
                      ++v36;
                      v37 += 16;
                    }
                    while ( v36 < v35 );
                  }
                  v45 = *(char **)(rcx0 + 10136);
                  v46 = *(char **)(rcx0 + 10128);
                  v47 = (v45 - v46) >> 4;
                  while ( v47 )
                  {
                    if ( *(_DWORD *)&v46[16 * (v47 >> 1)] >= (int)n10_1 )
                    {
                      v47 >>= 1;
                    }
                    else
                    {
                      v46 += 16 * (v47 >> 1) + 16;
                      v47 += -1LL - (v47 >> 1);
                    }
                  }
                  if ( v46 != v45 && (int)n10_1 >= *(_DWORD *)v46 )
                  {
                    v48 = v46 + 16;
                    if ( v46 + 16 != v45 )
                    {
                      _RCX = v46 + 20;
                      do
                      {
                        v50 = *(_DWORD *)v48;
                        v48 += 16;
                        *(_RCX - 5) = v50;
                        __asm
                        {
                          vmovsd  xmm0, qword ptr [rcx]
                          vmovsd  qword ptr [rcx-10h], xmm0
                        }
                        *(_RCX - 2) = _RCX[2];
                        _RCX += 4;
                      }
                      while ( v48 != v45 );
                    }
                    *(_QWORD *)(rcx0 + 10136) -= 16LL;
                  }
                  break;
                }
                --v32;
                v33 -= 16;
              }
            }
          }
        }
      }
      __asm { vmovaps xmm6, [rsp+0A8h+var_38] }
    }
  }
}

// --- End Function: sub_1436A7DF0 (0x1436A7DF0) ---

// --- Function: sub_1436B0C70 (0x1436B0C70) ---
void __fastcall sub_1436B0C70(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  unsigned __int64 v5; // rsi
  __int64 v6; // rbx
  __int64 v7; // rcx
  const void *v8; // rdx
  __int64 v9; // rbp
  __int64 v10; // r9
  __int64 v11; // rax
  __int64 v12; // r8
  __int64 v13; // rdx
  __int128 v14; // [rsp+20h] [rbp-18h]

  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 664) + 8LL)
                                                              & 0xFFFFFFFFFFFFLL)
                                                  + 1808LL))(*(_QWORD *)(*(_QWORD *)(a1 + 664) + 8LL) & 0xFFFFFFFFFFFFLL) )
  {
    v4 = *(_QWORD *)(sub_14638A930(*(_QWORD *)(a1 + 664)) + 232);
    if ( v4 )
    {
      *(_QWORD *)(v4 + 16) |= 0x200000000000uLL;
      v5 = 0;
      v6 = *(_QWORD *)(v4 + 392);
      v7 = *(_QWORD *)(a2 + 8);
      v8 = *(const void **)a2;
      if ( (v7 - *(_QWORD *)a2) >> 4 )
      {
        v9 = 0;
        do
        {
          if ( (v7 - (__int64)v8) >> 4 <= v5 )
          {
            __debugbreak();
          }
          v10 = *(_QWORD *)(v6 + 1864);
          v11 = *(_QWORD *)(v6 + 1856);
          v14 = *(_OWORD *)(*(_QWORD *)a2 + v9);
          if ( v11 != v10 )
          {
            do
            {
              if ( *(_DWORD *)(v11 + 8) == (_DWORD)v14 && *(_QWORD *)(v11 + 16) == *((_QWORD *)&v14 + 1) )
              {
                break;
              }
              v11 += 40;
            }
            while ( v11 != v10 );
            if ( v11 != v10 )
            {
              v12 = v11 + 40;
              if ( v11 + 40 != v10 )
              {
                v13 = v11 + 16;
                do
                {
                  v12 += 40;
                  *(_DWORD *)(v13 - 8) = *(_DWORD *)(v13 + 32);
                  *(_QWORD *)v13 = *(_QWORD *)(v13 + 40);
                  *(_DWORD *)(v13 + 8) = *(_DWORD *)(v13 + 48);
                  *(_QWORD *)(v13 + 16) = *(_QWORD *)(v13 + 56);
                  v13 += 40;
                }
                while ( v12 != v10 );
              }
              (**(void (__fastcall ***)(__int64, _QWORD))(*(_QWORD *)(v6 + 1864) - 40LL))(
                *(_QWORD *)(v6 + 1864) - 40LL,
                0);
              *(_QWORD *)(v6 + 1864) -= 40LL;
            }
          }
          v7 = *(_QWORD *)(a2 + 8);
          ++v5;
          v8 = *(const void **)a2;
          v9 += 16;
        }
        while ( v5 < (v7 - *(_QWORD *)a2) >> 4 );
      }
    }
  }
  if ( *(_QWORD *)a2 )
  {
    sub_14039EFB0(a2, *(const void **)a2, (*(_QWORD *)(a2 + 16) - *(_QWORD *)a2) & 0xFFFFFFFFFFFFFFF0uLL);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
}

// --- End Function: sub_1436B0C70 (0x1436B0C70) ---

// --- Function: sub_1436B5FE0 (0x1436B5FE0) ---
char __fastcall sub_1436B5FE0(__int64 a1, int n29, int n225, char a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rsi
  __int64 n29_1; // r12
  __int64 n4; // rbx
  signed int n2_1; // r8d
  signed int n2_2; // r9d
  __int64 n4_1; // r11
  _QWORD *v18; // rdi
  float *v19; // rax
  int n2; // ecx
  unsigned __int64 v21; // rdx
  int n2_5; // edi
  float *v23; // rdx
  __int64 v24; // r10
  int n2_3; // r9d
  bool v26; // cc
  _QWORD *v27; // rbx
  signed int n2_4; // r10d
  float *v29; // rdx
  unsigned __int64 n2_6; // r11
  float *v31; // rdx
  int v32; // edx
  const void **v34; // rax
  __int64 v35; // rbp
  const void **v36; // rsi

  v6 = a5;
  n29_1 = n29;
  _XMM0 = 0;
  n4 = *(int *)(a5 + 40);
  __asm { vroundss xmm0, xmm0, dword ptr [r8], 2 }
  _XMM1 = 0;
  __asm { vroundss xmm1, xmm1, dword ptr [r8+1Ch], 2 }
  n2_1 = -1;
  if ( a4 )
  {
    n2_2 = 0;
    n4_1 = 0;
    if ( n4 < 4 )
    {
      if ( (int)n4 <= 0 )
      {
LABEL_26:
        n2_5 = n4 - 1;
        goto LABEL_52;
      }
      v18 = (_QWORD *)(a5 + 32);
    }
    else
    {
      v18 = (_QWORD *)(a5 + 32);
      v19 = (float *)(*(_QWORD *)(a5 + 32) + 60LL);
      n2 = 2;
      v21 = ((unsigned __int64)(n4 - 4) >> 2) + 1;
      n4_1 = 4 * v21;
      do
      {
        if ( *(float *)&_XMM0 <= *(v19 - 13) && *(float *)&_XMM1 <= *(v19 - 12) )
        {
          n2_1 = n2_2;
        }
        if ( *(float *)&_XMM0 <= *(v19 - 7) && *(float *)&_XMM1 <= *(v19 - 6) )
        {
          n2_1 = n2 - 1;
        }
        if ( *(float *)&_XMM0 <= *(v19 - 1) && *(float *)&_XMM1 <= *v19 )
        {
          n2_1 = n2;
        }
        if ( *(float *)&_XMM0 <= v19[5] && *(float *)&_XMM1 <= v19[6] )
        {
          n2_1 = n2 + 1;
        }
        n2_2 += 4;
        n2 += 4;
        v19 += 24;
        --v21;
      }
      while ( v21 );
      if ( n4_1 >= n4 )
      {
        n2_5 = n4 - 1;
        goto LABEL_52;
      }
    }
    v23 = (float *)(*v18 + 24 * n4_1 + 12);
    v24 = n4 - n4_1;
    do
    {
      if ( *(float *)&_XMM0 <= *(v23 - 1) && *(float *)&_XMM1 <= *v23 )
      {
        n2_1 = n2_2;
      }
      ++n2_2;
      v23 += 6;
      --v24;
    }
    while ( v24 );
    goto LABEL_26;
  }
  n2_5 = n4 - 1;
  n2_3 = n4 - 1;
  if ( (int)n4 - 1 < 0 )
  {
    goto LABEL_52;
  }
  v26 = (int)n4 < 4;
  v27 = (_QWORD *)(a5 + 32);
  if ( v26 )
  {
    if ( n2_3 < 0 )
    {
      goto LABEL_52;
    }
    n2_6 = n2_3;
    goto LABEL_47;
  }
  n2_4 = n2_5 - 2;
  v29 = (float *)(*v27 - 36LL + 24LL * n2_5);
  n2_6 = n2_5 - (unsigned __int64)((n2_5 + 1) & 0xFFFFFFFC);
  do
  {
    if ( *(float *)&_XMM0 >= v29[11] && *(float *)&_XMM1 >= v29[12] )
    {
      n2_1 = n2_3;
    }
    if ( *(float *)&_XMM0 >= v29[5] && *(float *)&_XMM1 >= v29[6] )
    {
      n2_1 = n2_4 + 1;
    }
    if ( *(float *)&_XMM0 >= *(v29 - 1) && *(float *)&_XMM1 >= *v29 )
    {
      n2_1 = n2_4;
    }
    if ( *(float *)&_XMM0 >= *(v29 - 7) && *(float *)&_XMM1 >= *(v29 - 6) )
    {
      n2_1 = n2_4 - 1;
    }
    v29 -= 24;
    n2_3 -= 4;
    n2_4 -= 4;
  }
  while ( n2_3 >= 3 );
  if ( n2_3 >= 0 )
  {
    v27 = (_QWORD *)(a5 + 32);
LABEL_47:
    v31 = (float *)(*v27 + 24 * n2_6 + 12);
    do
    {
      if ( *(float *)&_XMM0 >= *(v31 - 1) && *(float *)&_XMM1 >= *v31 )
      {
        n2_1 = n2_3;
      }
      v31 -= 6;
      --n2_3;
    }
    while ( n2_3 >= 0 );
  }
LABEL_52:
  if ( n2_1 == -1 )
  {
    return 0;
  }
  v32 = *(unsigned __int8 *)(n29_1 + a1 + 10184);
  if ( _bittest(&v32, n2_1) )
  {
    return 0;
  }
  if ( a4 )
  {
    if ( n2_1 != n2_5 && _bittest(&v32, (unsigned __int8)(n2_1 + 1)) )
    {
      return 0;
    }
  }
  else if ( n2_1 && _bittest(&v32, (unsigned __int8)(n2_1 - 1)) )
  {
    return 0;
  }
  *(_BYTE *)(n29_1 + a1 + 10184) = 1 << n2_1;
  *(_DWORD *)(a1 + 10180) = *(_DWORD *)(v6 + 12);
  v34 = (const void **)sub_14035B5E0(&a5, (unsigned __int8 **)(*(_QWORD *)(v6 + 32) + 8 * (3LL * n2_1 + 2)));
  v35 = a6;
  v36 = v34;
  if ( !*(_BYTE *)(a6 + 112) || (unsigned __int8)sub_14037BBC0(a6 + 144, v34) )
  {
    sub_1403745A0((void **)(v35 + 144), v36);
    *(_BYTE *)(v35 + 112) = 1;
    sub_14032D8D0(v35 + 72, 0);
  }
  DestroyStringObject(&a5);
  if ( !*(_BYTE *)(v35 + 192) || *(_BYTE *)(v35 + 217) != 1 )
  {
    *(_BYTE *)(v35 + 217) = 1;
    *(_BYTE *)(v35 + 192) = 1;
    sub_14032D8D0(v35 + 152, 0);
  }
  return 1;
}

// --- End Function: sub_1436B5FE0 (0x1436B5FE0) ---

// --- Function: sub_1436B6EF0 (0x1436B6EF0) ---
__int64 __fastcall sub_1436B6EF0(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  char *v6; // rax

  v1 = dword_149AEA7D8;
  if ( !dword_149AEA7D8 )
  {
    v3 = sub_1402D09F0(0x49u, 8, 0x80u, 2);
    v4 = sub_1402C7FC0(79764919, 1, (v3 << 25) ^ (unsigned int)((unsigned __int64)(v3 << 24) >> 31) & 0x4C11DB7);
    v5 = sub_1402D09F0(v4 >> 1, 32, v4 << 31, 2);
    v1 = sub_1402DFCB0((unsigned __int8 *)"inkedStat", v5 ^ 0xFFFFFFu);
    v6 = (char *)sub_14739AFC0(0xBu, 0);
    *(double *)v6 = *(double *)"LinkedStat";
    strcpy(v6 + 8, "at");
    dword_149AEA7D8 = v1;
    if ( v6 )
    {
      sub_14739AF10(v6);
      v1 = dword_149AEA7D8;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return a1;
}

// --- End Function: sub_1436B6EF0 (0x1436B6EF0) ---

// --- Function: sub_1436B6FE0 (0x1436B6FE0) ---
__int64 __fastcall sub_1436B6FE0(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  char *LinkedStatPreset; // rax

  v1 = dword_149AEA7D0;
  if ( !dword_149AEA7D0 )
  {
    v3 = sub_1402D09F0(0x49u, 8, 0x80u, 2);
    v4 = sub_1402C7FC0(79764919, 1, (v3 << 25) ^ (unsigned int)((unsigned __int64)(v3 << 24) >> 31) & 0x4C11DB7);
    v5 = sub_1402D09F0(v4 >> 1, 32, v4 << 31, 2);
    v1 = sub_1402DFCB0((unsigned __int8 *)"inkedStatPreset", v5 ^ 0xFFFFFFu);
    LinkedStatPreset = (char *)sub_14739AFC0(0x11u, 0);
    strcpy(LinkedStatPreset, "LinkedStatPreset");
    dword_149AEA7D0 = v1;
    if ( LinkedStatPreset )
    {
      sub_14739AF10(LinkedStatPreset);
      v1 = dword_149AEA7D0;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return a1;
}

// --- End Function: sub_1436B6FE0 (0x1436B6FE0) ---

// --- Function: sub_1436B7290 (0x1436B7290) ---
__int64 __fastcall sub_1436B7290(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  __int64 v6; // rcx

  v1 = dword_149AEA5A0;
  if ( !dword_149AEA5A0 )
  {
    v3 = sub_1402D09F0(0x47u, 8, 0x80u, 2);
    v4 = sub_1402C7FC0(79764919, 1, (v3 << 25) ^ (unsigned int)((unsigned __int64)(v3 << 24) >> 31) & 0x4C11DB7);
    v5 = sub_1402D09F0(v4 >> 1, 32, v4 << 31, 2);
    v1 = sub_1402DFCB0((unsigned __int8 *)"robabilisticStatusTrigger", v5 ^ 0xFFFFFFu);
    v6 = sub_14739AFC0(0x1Bu, 0);
    *(_OWORD *)v6 = *(_OWORD *)"ProbabilisticStatusTrigger";
    *(double *)(v6 + 16) = *(double *)"tusTrigger";
    strcpy((char *)(v6 + 24), "er");
    dword_149AEA5A0 = v1;
    if ( v6 )
    {
      sub_14739AF10((const void *)v6);
      v1 = dword_149AEA5A0;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return a1;
}

// --- End Function: sub_1436B7290 (0x1436B7290) ---

// --- Function: sub_1436B7660 (0x1436B7660) ---
__int64 __fastcall sub_1436B7660(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  char *StatusEffectSetup; // rax

  v1 = dword_149AEA5E0;
  if ( !dword_149AEA5E0 )
  {
    v3 = sub_1402D09F0(0x46u, 8, 0, 2);
    v4 = sub_1402C7FC0(79764919, 1, (v3 << 25) ^ (unsigned int)((unsigned __int64)(v3 << 24) >> 31) & 0x4C11DB7);
    v5 = sub_1402D09F0(v4 >> 1, 32, v4 << 31, 2);
    v1 = sub_1402DFCB0((unsigned __int8 *)"tatusEffectSetup", v5 ^ 0xFFFFFFu);
    StatusEffectSetup = (char *)sub_14739AFC0(0x12u, 0);
    strcpy(StatusEffectSetup, "StatusEffectSetup");
    dword_149AEA5E0 = v1;
    if ( StatusEffectSetup )
    {
      sub_14739AF10(StatusEffectSetup);
      v1 = dword_149AEA5E0;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return a1;
}

// --- End Function: sub_1436B7660 (0x1436B7660) ---

// --- Function: sub_1436B7740 (0x1436B7740) ---
__int64 __fastcall sub_1436B7740(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  double *v6; // rax

  v1 = dword_149AEA5F0;
  if ( !dword_149AEA5F0 )
  {
    v3 = sub_1402D09F0(0x46u, 8, 0, 2);
    v4 = sub_1402C7FC0(79764919, 1, (v3 << 25) ^ (unsigned int)((unsigned __int64)(v3 << 24) >> 31) & 0x4C11DB7);
    v5 = sub_1402D09F0(v4 >> 1, 32, v4 << 31, 2);
    v1 = sub_1402DFCB0((unsigned __int8 *)"tatusEffectSetupPreset", v5 ^ 0xFFFFFFu);
    v6 = (double *)sub_14739AFC0(0x18u, 0);
    *(_OWORD *)v6 = *(_OWORD *)"StatusEffectSetupPreset";
    v6[2] = *(double *)"pPreset";
    dword_149AEA5F0 = v1;
    if ( v6 )
    {
      sub_14739AF10(v6);
      v1 = dword_149AEA5F0;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return a1;
}

// --- End Function: sub_1436B7740 (0x1436B7740) ---

// --- Function: sub_1436B9D10 (0x1436B9D10) ---
unsigned __int64 __fastcall sub_1436B9D10(__int64 rcx0, unsigned int a2, __int64 a3, char a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int64 v10; // rcx
  __int64 v11; // rsi
  unsigned int v12; // r12d
  float v13; // xmm7_4
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  unsigned __int64 result; // rax
  __int64 i; // r13
  __int64 v18; // r13
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rdx
  unsigned int v22; // edi
  __int64 v23; // rax
  __int64 v24; // rcx
  __int64 v25; // r15
  double v26; // xmm0_8
  __int64 v27; // rcx
  int v28; // r12d
  double v29; // rsi
  float v30; // xmm6_4
  __int64 v31; // rdi
  __int64 v32; // rcx
  bool v33; // al
  __int64 v34; // rax
  unsigned int v35; // edi
  unsigned int v36; // esi
  int v37; // ecx
  unsigned __int8 v38; // cf
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rdx
  unsigned int v42; // edi
  double v43; // xmm0_8
  __int64 v44; // rdi
  __int64 v45; // rdx
  char v46; // cl
  __int64 v47; // rdi
  __int64 v48; // rdi
  int n40_1; // esi
  __int64 v50; // r9
  __int64 v51; // r12
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // r9
  __int64 n23; // rdx
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 v58; // rdx
  unsigned __int64 v59; // rdi
  unsigned __int64 n0x6400000; // rdi
  char *v61; // rsi
  char *v62; // rcx
  signed __int64 v63; // rdi
  __int64 v64; // rax
  __int64 v65; // rax
  unsigned int v66; // eax
  unsigned int v67; // eax
  float v68; // kr00_4
  __int64 v69; // rax
  __int64 v70; // rax
  __int64 v71; // rdx
  unsigned int v72; // edi
  __int64 v73; // rcx
  __int64 v74; // rax
  __int64 v75; // rax
  __int64 v76; // rsi
  double v78; // xmm0_8
  int v79; // ecx
  unsigned __int64 v80; // rsi
  __int64 v81; // rdi
  __int64 v82; // rcx
  int n40; // r12d
  unsigned int v84; // eax
  unsigned int v85; // [rsp+48h] [rbp-C0h]
  __int64 v86; // [rsp+50h] [rbp-B8h]
  bool v87; // [rsp+58h] [rbp-B0h]
  unsigned __int64 v88; // [rsp+60h] [rbp-A8h]
  double v89; // [rsp+68h] [rbp-A0h] BYREF
  double v90; // [rsp+70h] [rbp-98h] BYREF
  __int64 n40_2; // [rsp+78h] [rbp-90h]
  unsigned __int64 v92; // [rsp+80h] [rbp-88h]
  void *Src[2]; // [rsp+88h] [rbp-80h] BYREF
  __int64 v94; // [rsp+98h] [rbp-70h]
  __int64 v95; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v96; // [rsp+A8h] [rbp-60h]
  __int64 a1[2]; // [rsp+B0h] [rbp-58h] BYREF
  char *v98; // [rsp+C0h] [rbp-48h]
  __int64 v99; // [rsp+C8h] [rbp-40h] BYREF
  char v100[24]; // [rsp+D0h] [rbp-38h] BYREF
  __int128 v101; // [rsp+E8h] [rbp-20h]
  __int128 v102; // [rsp+F8h] [rbp-10h]
  __int128 v103; // [rsp+108h] [rbp+0h]
  __int128 v104; // [rsp+118h] [rbp+10h]
  __int128 v105; // [rsp+128h] [rbp+20h]

  v105 = v4;
  v10 = *(_QWORD *)(a3 + 144);
  v11 = a3;
  v104 = v5;
  v12 = a2;
  v13 = *(float *)a3;
  v103 = _XMM8;
  LODWORD(_XMM8) = *(_DWORD *)(v10 + 16);
  v102 = v7;
  v101 = v8;
  v86 = sub_143692B60(v10);
  v87 = 0;
  v14 = v86;
  v15 = *(_QWORD *)(v86 + 32);
  v88 = v15;
  result = v15 - 1;
  for ( i = 16 * (v15 - 1); ; i = v96 - 16 )
  {
    v96 = i;
    v92 = result;
    if ( result >= v15 )
    {
      break;
    }
    v18 = *(_QWORD *)(*(_QWORD *)(v14 + 24) + i);
    if ( !v18 )
    {
      goto LABEL_87;
    }
    v19 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(rcx0 + 664) + 2208LL))(*(_QWORD *)(rcx0 + 664));
    if ( v19 )
    {
      v20 = sub_14522A500(v19);
      LOBYTE(v21) = 3;
      v22 = sub_1461CEF60(v20, v21);
    }
    else
    {
      v22 = 0;
    }
    v85 = *(_DWORD *)(v18 + 8);
    v23 = sub_145A52C30(v12, v85);
    v24 = *(_QWORD *)(v18 + 16);
    v25 = v23;
    v95 = v23;
    v26 = (*(double (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v24 + 48LL))(v24, v22);
    v27 = *(_QWORD *)(v18 + 16);
    v89 = *(float *)&v26;
    v90 = ((__m128 (__fastcall *)(__int64, _QWORD))*(_QWORD *)(*(_QWORD *)v27 + 56LL))(v27, v22).m128_f32[0];
    sub_1436BFB30(rcx0, v11, v86, v92, (__int64)&v89, (__int64)&v90);
    v28 = 1 << v12;
    if ( !sub_14369D0B0(
            rcx0,
            *(_QWORD *)(v18 + 16),
            (float *)v11,
            *(float *)v11,
            *(float *)(v11 + 4),
            *(float *)(*(_QWORD *)(v11 + 144) + 16LL),
            *(float *)(*(_QWORD *)(v11 + 144) + 20LL))
      || v87 )
    {
      v79 = *(_DWORD *)(rcx0 + 4LL * (int)v85 + 476);
      if ( (v79 & v28) != 0 )
      {
        v80 = 0;
        *(_DWORD *)(rcx0 + 4LL * (int)v85 + 476) = v79 & ~v28;
        if ( *(_QWORD *)(v18 + 56) )
        {
          v81 = 0;
          do
          {
            v82 = *(_QWORD *)(v81 + *(_QWORD *)(v18 + 48));
            if ( v82 )
            {
              n40 = *(_DWORD *)(v82 + 8);
              if ( (unsigned __int8)sub_145A799A0(rcx0 + ((__int64)n40 << 7) + 1168, v25) )
              {
                if ( n40 == 40 )
                {
                  v84 = sub_145A5C700(v25);
                  sub_144920A40(rcx0 + 976, v84);
                }
              }
            }
            ++v80;
            v81 += 16;
          }
          while ( v80 < *(_QWORD *)(v18 + 56) );
        }
LABEL_84:
        v11 = a3;
      }
LABEL_85:
      v12 = a2;
      goto LABEL_86;
    }
    *(_QWORD *)&v29 = (int)v85;
    *(_QWORD *)&v89 = (int)v85;
    if ( (v28 & *(_DWORD *)(rcx0 + 4LL * (int)v85 + 476)) != 0 )
    {
      v45 = a3;
      v46 = v87;
      if ( *(_BYTE *)(*(_QWORD *)(a3 + 144) + 41LL) )
      {
        v46 = 1;
      }
      v87 = v46;
    }
    else
    {
      v30 = *(float *)(a3 + 4);
      v31 = sub_143675E30(*(_QWORD *)(v18 + 16));
      if ( v31 )
      {
        v32 = *(_QWORD *)(*(_QWORD *)(rcx0 + 664) + 8LL) & 0xFFFFFFFFFFFFLL;
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v32 + 1808LL))(v32) )
        {
          if ( !a4 )
          {
            goto LABEL_84;
          }
          v33 = sub_143686260(rcx0, v13, v30, v31, (unsigned __int64 *)&v95);
        }
        else
        {
          v34 = sub_14638AAC0(*(_QWORD *)(rcx0 + 664));
          v90 = COERCE_DOUBLE(sub_14564C4A0(v34));
          if ( v90 == 0.0 )
          {
            goto LABEL_84;
          }
          v35 = sub_145A5C700(v25);
          v36 = sub_1403561D0(v25);
          v37 = *(_DWORD *)(sub_145DD3410(*(_QWORD *)(*(_QWORD *)&v90 + 392LL), v35) + 60);
          v38 = _bittest(&v37, v36);
          v29 = v89;
          v33 = v38;
        }
        if ( !v33 )
        {
          goto LABEL_84;
        }
      }
      v39 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(rcx0 + 664) + 2208LL))(*(_QWORD *)(rcx0 + 664));
      if ( v39 )
      {
        v40 = sub_14522A500(v39);
        LOBYTE(v41) = 3;
        v42 = sub_1461CEF60(v40, v41);
      }
      else
      {
        v42 = 0;
      }
      v43 = (*(double (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v18 + 16) + 64LL))(*(_QWORD *)(v18 + 16), v42);
      v13 = *(float *)&v43;
      (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v18 + 16) + 72LL))(*(_QWORD *)(v18 + 16), v42);
      if ( *(float *)a3 >= *(float *)&v43 )
      {
        v13 = *(float *)a3;
        if ( *(float *)a3 > *(float *)&v43 )
        {
          *(float *)a3 = *(float *)&v43;
          v13 = *(float *)&v43;
        }
      }
      else
      {
        *(float *)a3 = *(float *)&v43;
      }
      v87 = *(_BYTE *)(*(_QWORD *)(a3 + 144) + 41LL) != 0;
      sub_1436B5900(rcx0, v85);
      sub_1436B53A0(rcx0, v85, a2);
      v44 = sub_14474C110();
      sub_1403AC900((unsigned __int64 *)(*(_QWORD *)(rcx0 + 664) + 8LL), &v99);
      sub_14478D410(v44, &v99, v85);
      v45 = a3;
    }
    *(_DWORD *)(rcx0 + 4LL * *(_QWORD *)&v29 + 476) |= v28;
    v89 = 0.0;
    if ( *(_QWORD *)(v18 + 56) )
    {
      v47 = 0;
      v90 = 0.0;
      while ( 2 )
      {
        v48 = *(_QWORD *)(v47 + *(_QWORD *)(v18 + 48));
        if ( !v48 )
        {
          goto LABEL_59;
        }
        n40_1 = *(_DWORD *)(v48 + 8);
        v50 = *(_QWORD *)(v45 + 144);
        LODWORD(n40_2) = n40_1;
        v51 = rcx0 + ((__int64)n40_1 << 7) + 1168;
        if ( !(unsigned __int8)sub_14369D3A0(rcx0, v45, (unsigned int)&v95, v50, v48) )
        {
          if ( (unsigned __int8)sub_145A799A0(v51, v25) && n40_1 == 40 )
          {
            v67 = sub_145A5C700(v25);
            sub_144920A40(rcx0 + 976, v67);
          }
          goto LABEL_59;
        }
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(v48 + 24) + 48LL))(*(_QWORD *)(v48 + 24));
        if ( (unsigned __int8)sub_145A60890(v51, v25) )
        {
          sub_145A88310(v51, v25);
          goto LABEL_59;
        }
        if ( n40_1 != 8 )
        {
          goto LABEL_47;
        }
        if ( !byte_14981D7F5 || !PathUtils::IsGameAssetPath(*(_QWORD *)(rcx0 + 664)) )
        {
          goto LABEL_46;
        }
        if ( (unsigned __int8)sub_145A63D70(rcx0 + 7952) || (unsigned __int8)sub_145A63D70(rcx0 + 2320) )
        {
          v57 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 160LL))(qword_14981D298);
          v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v57 + 608LL))(v57);
          n23 = 23;
        }
        else
        {
          if ( !(unsigned __int8)sub_145A63D70(rcx0 + 4624) && !(unsigned __int8)sub_145A63D70(rcx0 + 4496) )
          {
            if ( (unsigned __int8)sub_145A63D70(rcx0 + 6416) )
            {
              v52 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 160LL))(qword_14981D298);
              v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 608LL))(v52);
              n23 = 35;
              break;
            }
LABEL_46:
            if ( !(unsigned __int8)sub_145A63D70(rcx0 + 2192) )
            {
LABEL_47:
              v94 = 0;
              *(_OWORD *)Src = 0;
              if ( (unsigned __int8)sub_145A798A0(v51, v85, Src) )
              {
                v59 = ((char *)Src[1] - (char *)Src[0]) >> 4;
                v98 = 0;
                *(_OWORD *)a1 = 0;
                if ( v59 )
                {
                  if ( v59 > 0xFFFFFFFFFFFFFFFLL )
                  {
                    unknown_libname_10();
                  }
                  n0x6400000 = 16 * v59;
                  v61 = (char *)sub_14038E0B0((__int64)a1, n0x6400000);
                  a1[0] = (__int64)v61;
                  a1[1] = (__int64)v61;
                  v62 = &v61[n0x6400000];
                  v63 = (char *)Src[1] - (char *)Src[0];
                  v98 = v62;
                  memmove(v61, Src[0], (char *)Src[1] - (char *)Src[0]);
                  v64 = (__int64)&v61[v63 & 0xFFFFFFFFFFFFFFF0uLL];
                  n40_1 = n40_2;
                  a1[1] = v64;
                }
                sub_1436B0C70(rcx0, (__int64)a1);
              }
              v65 = sub_143A81630(v100, v58, v25);
              sub_145A40770(v51, v65);
              if ( n40_1 == 40 )
              {
                v66 = sub_145A5C700(v25);
                sub_144920B70(rcx0 + 976, v66);
              }
              if ( Src[0] )
              {
                sub_14039EFB0((__int64)Src, Src[0], (v94 - (unsigned __int64)Src[0]) & 0xFFFFFFFFFFFFFFF0uLL);
              }
            }
LABEL_59:
            v45 = a3;
            v47 = *(_QWORD *)&v90 + 16LL;
            ++*(_QWORD *)&v89;
            *(_QWORD *)&v90 += 16LL;
            if ( *(_QWORD *)&v89 >= *(_QWORD *)(v18 + 56) )
            {
              goto LABEL_60;
            }
            continue;
          }
          v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_14981D298 + 160LL))(qword_14981D298);
          v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v56 + 608LL))(v56);
          n23 = 44;
        }
        break;
      }
      LOBYTE(v54) = 1;
      (*(void (__fastcall **)(__int64, __int64, _QWORD, __int64))(*(_QWORD *)v53 + 24LL))(v53, n23, 0, v54);
      goto LABEL_46;
    }
LABEL_60:
    v11 = a3;
    if ( !*(_BYTE *)(*(_QWORD *)(a3 + 144) + 40LL) )
    {
      goto LABEL_85;
    }
    v68 = *(float *)(a3 + 24) * *(float *)(a3 + 16);
    v69 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(rcx0 + 664) + 2208LL))(
            *(_QWORD *)(rcx0 + 664),
            v45);
    if ( v69 )
    {
      v70 = sub_14522A500(v69);
      LOBYTE(v71) = 3;
      v72 = sub_1461CEF60(v70, v71);
    }
    else
    {
      v72 = 0;
    }
    if ( !sub_143675E30(*(_QWORD *)(v18 + 16))
      || (v73 = *(_QWORD *)(*(_QWORD *)(rcx0 + 664) + 8LL) & 0xFFFFFFFFFFFFLL,
          (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v73 + 1808LL))(v73))
      || (v74 = sub_14638AAC0(*(_QWORD *)(rcx0 + 664)), (v75 = sub_14564C4A0(v74)) == 0) )
    {
      v12 = a2;
LABEL_71:
      v78 = (*(double (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v18 + 16) + 64LL))(*(_QWORD *)(v18 + 16), v72);
      LODWORD(_XMM8) = LODWORD(v78);
      if ( v68 < -0.00000011920929 && v13 > *(float *)&v78 || v68 > 0.00000011920929 && v13 < *(float *)&v78 )
      {
        *(float *)&_XMM8 = v13;
      }
      goto LABEL_86;
    }
    v12 = a2;
    v76 = sub_145DD3410(*(_QWORD *)(v75 + 392), a2);
    if ( !v76 )
    {
      v11 = a3;
      goto LABEL_71;
    }
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v18 + 16) + 64LL))(*(_QWORD *)(v18 + 16), v72);
    _XMM1 = *(unsigned int *)(v76 + 12);
    v11 = a3;
    __asm { vminss  xmm8, xmm1, xmm0 }
LABEL_86:
    v14 = v86;
    v15 = v88;
LABEL_87:
    result = v92 - 1;
  }
  *(float *)(v11 + 8) = *(float *)&_XMM8;
  return result;
}

// --- End Function: sub_1436B9D10 (0x1436B9D10) ---

// --- Function: sub_1436BB390 (0x1436BB390) ---
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_1436BB390(
        _QWORD *rcx0,
        __int64 n10_1,
        __int64 n225_4,
        double a4,
        char a5,
        char a6,
        __int64 a7,
        unsigned __int16 a8)
{
  unsigned __int64 v10; // rax
  __int64 n225; // rdi
  unsigned int n10; // r15d
  bool v17; // cf
  char n2; // al
  unsigned __int64 v23; // r8
  __int64 v25; // rax
  int v26; // ebx
  __int64 v27; // rcx
  _QWORD *v28; // r14
  unsigned __int64 *v29; // r10
  _OWORD *v30; // rax
  unsigned __int64 v31; // rdx
  unsigned __int64 v32; // rdx
  __int64 v34; // rcx
  __int64 v35; // rcx
  int n29_1; // eax
  _BYTE *v37; // rcx
  __int64 v38; // rcx
  const char *String2_1; // rax
  const char *v40; // rdi
  const char *p_null_1; // rax
  const char *v42; // rdi
  const char *v43; // rax
  __int64 *v44; // rax
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.; // r14
  const char *CLIENT:; // rdi
  __int64 v47; // rcx
  char v48; // al
  const char *p_Authoritative; // r8
  __int64 *v50; // rax
  int v51; // edi
  __int64 v52; // rax
  volatile signed __int64 *v53; // rcx
  __int64 v54; // rax
  __int64 *ThreadLogContextSlot; // rax
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1; // r12
  int n29; // eax
  _BYTE *v59; // rcx
  __int64 v60; // rcx
  const char *String2; // rax
  __int64 n225_3; // rax
  const char *v69; // rdi
  const char *v70; // rax
  __int64 *v71; // rax
  bool v72; // zf
  const char *CLIENT:_1; // rdi
  __int64 v74; // rcx
  char v75; // al
  const char *p_Authoritative_1; // r8
  __int64 *v77; // rax
  int v78; // edi
  __int64 v79; // rax
  __int64 v80; // rcx
  __int64 v81; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  _QWORD *v90; // r12
  _QWORD *v91; // rax
  _QWORD *v92; // rdi
  unsigned __int64 v94; // rax
  __int64 v95; // rdx
  __int64 v96; // r14
  volatile signed __int64 *v99; // rcx
  int v100; // eax
  int n29_2; // eax
  _BYTE *v102; // rcx
  __int64 v103; // rcx
  const char *String2_2; // rax
  const char *v105; // rdi
  const char *p_null_2; // rax
  unsigned __int64 n0x200000; // rax
  const char *v108; // rdi
  const char *v109; // rax
  __int64 *v110; // rax
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2; // r14
  const char *CLIENT:_2; // rdi
  __int64 v113; // rcx
  char v114; // al
  const char *p_Authoritative_2; // r8
  __int64 *v116; // rax
  int v117; // edi
  __int64 v118; // rax
  __int64 v119; // rcx
  __int64 v120; // rax
  __int64 *ThreadLogContextSlot_2; // rax
  __int64 v123; // [rsp+20h] [rbp-E0h]
  int v124; // [rsp+20h] [rbp-E0h]
  __int64 v125; // [rsp+28h] [rbp-D8h]
  __int16 v126[4]; // [rsp+30h] [rbp-D0h]
  __int64 n225_2; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int64 n225_5; // [rsp+88h] [rbp-78h] BYREF
  __int64 n225_1; // [rsp+90h] [rbp-70h] BYREF
  __int128 v130; // [rsp+98h] [rbp-68h] BYREF
  unsigned __int64 v131; // [rsp+A8h] [rbp-58h] BYREF
  __int64 v132; // [rsp+B0h] [rbp-50h] BYREF
  volatile signed __int64 *v133; // [rsp+B8h] [rbp-48h]
  _DWORD *ptr_to_free_4; // [rsp+C0h] [rbp-40h]
  __int64 n225_6; // [rsp+D0h] [rbp-30h] BYREF
  __int128 v136; // [rsp+D8h] [rbp-28h] BYREF
  const void *ptr_to_free_1; // [rsp+E8h] [rbp-18h]
  __int64 v138; // [rsp+F0h] [rbp-10h] BYREF
  const char *p_ClientServerInfo; // [rsp+F8h] [rbp-8h] BYREF
  const char *p_CSCActorStatus::UpdateCurrentStatValue_2; // [rsp+100h] [rbp+0h]
  const void *ptr_to_free_5; // [rsp+108h] [rbp+8h]
  const char *p_ClientServerInfo_1; // [rsp+110h] [rbp+10h] BYREF
  const char *p_CSCActorStatus::UpdateCurrentStatValue_1; // [rsp+118h] [rbp+18h]
  const void *ptr_to_free_6; // [rsp+120h] [rbp+20h]
  __m256 v145; // [rsp+128h] [rbp+28h] BYREF
  unsigned __int64 v146; // [rsp+148h] [rbp+48h] BYREF
  const char *p_null; // [rsp+150h] [rbp+50h]
  __int64 *p_n225_1; // [rsp+158h] [rbp+58h] BYREF
  unsigned __int64 *p_n225_2; // [rsp+160h] [rbp+60h]
  const void *ptr_to_free_7; // [rsp+168h] [rbp+68h]
  __int64 *p_n225; // [rsp+170h] [rbp+70h] BYREF
  __int128 *v152; // [rsp+178h] [rbp+78h]
  const void *ptr_to_free_3; // [rsp+180h] [rbp+80h]
  __int64 v154; // [rsp+188h] [rbp+88h] BYREF
  const char *p_CSCActorStatus::UpdateCurrentStatValue; // [rsp+190h] [rbp+90h]
  const void *ptr_to_free_2; // [rsp+198h] [rbp+98h]
  __int128 v157; // [rsp+1A0h] [rbp+A0h] BYREF
  __int128 v158; // [rsp+1B0h] [rbp+B0h] BYREF
  const void *ptr_to_free; // [rsp+1C0h] [rbp+C0h]
  _QWORD v160[2]; // [rsp+1C8h] [rbp+C8h] BYREF
  __int64 v161; // [rsp+1D8h] [rbp+D8h] BYREF
  int n3154; // [rsp+1E0h] [rbp+E0h]
  _QWORD v163[3]; // [rsp+1E8h] [rbp+E8h] BYREF
  __int64 v164; // [rsp+200h] [rbp+100h] BYREF
  __int64 n511_4; // [rsp+208h] [rbp+108h]
  _BYTE *v166; // [rsp+210h] [rbp+110h]
  _BYTE v167[520]; // [rsp+218h] [rbp+118h] BYREF
  __int64 v168; // [rsp+420h] [rbp+320h] BYREF
  __int64 n511_2; // [rsp+428h] [rbp+328h]
  __int128 *v170; // [rsp+430h] [rbp+330h]
  _BYTE v171[520]; // [rsp+438h] [rbp+338h] BYREF
  __int64 v172; // [rsp+640h] [rbp+540h] BYREF
  __int64 n511_14; // [rsp+648h] [rbp+548h]
  const char *p_CSCActorStatus::UpdateCurrentStatValue_3; // [rsp+650h] [rbp+550h]
  _BYTE v175[520]; // [rsp+658h] [rbp+558h] BYREF
  __int64 v176; // [rsp+860h] [rbp+760h] BYREF
  __int64 n511_12; // [rsp+868h] [rbp+768h]
  volatile signed __int64 *v178; // [rsp+870h] [rbp+770h]
  _BYTE v179[520]; // [rsp+878h] [rbp+778h] BYREF
  __int64 v180; // [rsp+A80h] [rbp+980h] BYREF
  __int64 n511_9; // [rsp+A88h] [rbp+988h]
  const char *p_CSCActorStatus::UpdateCurrentStatValue_4; // [rsp+A90h] [rbp+990h]
  _BYTE v183[520]; // [rsp+A98h] [rbp+998h] BYREF
  __int64 v184; // [rsp+CA0h] [rbp+BA0h] BYREF
  __int64 n511_7; // [rsp+CA8h] [rbp+BA8h]
  _BYTE *v186; // [rsp+CB0h] [rbp+BB0h]
  _BYTE v187[520]; // [rsp+CB8h] [rbp+BB8h] BYREF
  __int64 a1; // [rsp+EC0h] [rbp+DC0h] BYREF
  __int64 n511_1; // [rsp+EC8h] [rbp+DC8h]
  _BYTE *v190; // [rsp+ED0h] [rbp+DD0h]
  _BYTE v191[520]; // [rsp+ED8h] [rbp+DD8h] BYREF
  __int64 v192; // [rsp+10E0h] [rbp+FE0h] BYREF
  __int64 n511; // [rsp+10E8h] [rbp+FE8h]
  _BYTE *v194; // [rsp+10F0h] [rbp+FF0h]
  _BYTE v195[520]; // [rsp+10F8h] [rbp+FF8h] BYREF
  __int64 v196; // [rsp+1300h] [rbp+1200h] BYREF
  __int64 n511_3; // [rsp+1308h] [rbp+1208h]
  _BYTE *v198; // [rsp+1310h] [rbp+1210h]
  _BYTE v199[520]; // [rsp+1318h] [rbp+1218h] BYREF
  __int64 v200; // [rsp+1520h] [rbp+1420h] BYREF
  __int64 n511_11; // [rsp+1528h] [rbp+1428h]
  _BYTE *v202; // [rsp+1530h] [rbp+1430h]
  _BYTE v203[520]; // [rsp+1538h] [rbp+1438h] BYREF
  __int64 v204; // [rsp+1740h] [rbp+1640h] BYREF
  __int64 n511_10; // [rsp+1748h] [rbp+1648h]
  _BYTE *v206; // [rsp+1750h] [rbp+1650h]
  _BYTE v207[520]; // [rsp+1758h] [rbp+1658h] BYREF
  __int64 v208; // [rsp+1960h] [rbp+1860h] BYREF
  __int64 n511_13; // [rsp+1968h] [rbp+1868h]
  _BYTE *v210; // [rsp+1970h] [rbp+1870h]
  _BYTE v211[520]; // [rsp+1978h] [rbp+1878h] BYREF
  __int64 v212; // [rsp+1B80h] [rbp+1A80h] BYREF
  __int64 n511_6; // [rsp+1B88h] [rbp+1A88h]
  _BYTE *v214; // [rsp+1B90h] [rbp+1A90h]
  _BYTE v215[520]; // [rsp+1B98h] [rbp+1A98h] BYREF
  __int64 v216; // [rsp+1DA0h] [rbp+1CA0h] BYREF
  __int64 n511_5; // [rsp+1DA8h] [rbp+1CA8h]
  _BYTE *v218; // [rsp+1DB0h] [rbp+1CB0h]
  _BYTE v219[520]; // [rsp+1DB8h] [rbp+1CB8h] BYREF
  __int64 v220; // [rsp+1FC0h] [rbp+1EC0h] BYREF
  __int64 n511_8; // [rsp+1FC8h] [rbp+1EC8h]
  _BYTE *v222; // [rsp+1FD0h] [rbp+1ED0h]
  _BYTE v223[520]; // [rsp+1FD8h] [rbp+1ED8h] BYREF
  char v225; // [rsp+2250h] [rbp+2150h] BYREF

  v10 = rcx0[1267];
  n225 = n225_4;
  n10 = n10_1;
  __asm { vmovaps [rsp+2270h+var_50], xmm6 }
  n225_1 = n225_4;
  __asm
  {
    vmovss  xmm8, dword ptr [r8]
    vmovaps xmm9, xmm3
    vaddss  xmm6, xmm3, xmm8
  }
  v17 = rcx0[1266] < v10;
  if ( rcx0[1266] != v10 )
  {
    __asm { vsubss  xmm2, xmm6, dword ptr [r8+0Ch] }
    sub_1436A7DF0(rcx0, n10_1, n225_4, n225_4);
  }
  __asm
  {
    vmovss  xmm7, dword ptr [rdi+8]
    vcomiss xmm6, xmm7
  }
  if ( !v17 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+0Ch]
      vminss  xmm7, xmm0, xmm6
    }
  }
  _RAX = *(_QWORD *)(n225 + 144);
  __asm { vmovaps xmm6, [rsp+2270h+var_50] }
  if ( *(_BYTE *)(_RAX + 43) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax+0Ch]
      vcomiss xmm8, xmm0
    }
    __asm { vcomiss xmm7, xmm0 }
  }
  n2 = sub_145A2B730(rcx0[83]);
  if ( n2 != 2 )
  {
    if ( n2 == 1 )
    {
      if ( n10 == 11 )
      {
        __asm
        {
          vmovss  xmm0, cs:Y
          vcomiss xmm7, xmm0
        }
      }
      else if ( n10 == 10 )
      {
        goto LABEL_102;
      }
    }
LABEL_16:
    v25 = *(_QWORD *)(n225 + 144);
    v26 = a8;
    __asm { vmovss  dword ptr [rdi], xmm7 }
    v72 = *(_BYTE *)(v25 + 42) == 0;
    p_null = "null";
    if ( !v72 )
    {
      v27 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v27 + 1808LL))(v27) )
      {
        if ( is_valid_handle_typeB((unsigned __int64 *)&a7) && (_WORD)v26 != 0xFFFF )
        {
          v28 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D260 + 56LL))(
                            qword_14981D260,
                            0);
          *(_QWORD *)(n225 + 112) = *v28;
          v29 = sub_1403AC900((unsigned __int64 *)&a7, &v138);
          v30 = *(_OWORD **)(n225 + 32);
          v31 = (__int64)(*(_QWORD *)(n225 + 40) - (_QWORD)v30) >> 4;
          if ( v31 )
          {
            _R9 = *v29;
            do
            {
              if ( *(_QWORD *)&v30[v31 >> 1] >= _R9 )
              {
                v31 >>= 1;
              }
              else
              {
                v30 += (v31 >> 1) + 1;
                v31 += -1LL - (v31 >> 1);
              }
            }
            while ( v31 );
          }
          v23 = *(_QWORD *)(n225 + 40);
          if ( v30 == (_OWORD *)v23 || *v29 < *(_QWORD *)v30 )
          {
            v32 = *v29;
            v30 = *(_OWORD **)(n225 + 32);
            *(_QWORD *)&v130 = *v29;
            v23 = (__int64)(v23 - (_QWORD)v30) >> 4;
            WORD4(v130) = 0;
            while ( v23 )
            {
              _R9 = v23 >> 1;
              if ( *(_QWORD *)&v30[v23 >> 1] >= v32 )
              {
                v23 >>= 1;
              }
              else
              {
                v30 += (v23 >> 1) + 1;
                v23 += -1LL - _R9;
              }
            }
            _RCX = *(_OWORD **)(n225 + 40);
            if ( v30 == _RCX || v32 < *(_QWORD *)v30 )
            {
              if ( _RCX == *(_OWORD **)(n225 + 48) )
              {
                v30 = sub_140305AD0((const void **)(n225 + 32), v30, &v130);
              }
              else if ( v30 == _RCX )
              {
                __asm
                {
                  vmovups xmm0, [rbp+2170h+var_21D8]
                  vmovups xmmword ptr [rcx], xmm0
                }
                *(_QWORD *)(n225 + 40) += 16LL;
              }
              else
              {
                _R9 = (unsigned __int64)(_RCX - 1);
                __asm
                {
                  vmovups xmm0, xmmword ptr [r9]
                  vmovups xmmword ptr [rcx], xmm0
                }
                *(_QWORD *)(n225 + 40) += 16LL;
                if ( _RCX - 1 != v30 )
                {
                  do
                  {
                    v34 = *(_QWORD *)(_R9 - 16);
                    v23 = _R9;
                    _R9 -= 16LL;
                    *(_QWORD *)v23 = v34;
                    *(_WORD *)(_R9 + 24) = *(_WORD *)(_R9 + 8);
                  }
                  while ( (_OWORD *)_R9 != v30 );
                }
                *(_QWORD *)v30 = v32;
                *((_WORD *)v30 + 4) = 0;
              }
            }
          }
          *((_WORD *)v30 + 4) = v26;
          v35 = qword_149B3B2E0;
          if ( *(int *)(qword_149B3B2E0 + 1076) <= 0 )
          {
            goto LABEL_71;
          }
          n29_1 = sub_1426551B0(*(char **)(qword_149B3B2E0 + 1080));
          if ( n29_1 == 29 || n29_1 == n10 )
          {
            if ( ((v37 = *(_BYTE **)(qword_149B3B2E0 + 1088), !*v37) || *v37 == 48) && !v37[1]
              || (v38 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL,
                  String2_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 112LL))(v38),
                  !_stricmp(*(const char **)(qword_149B3B2E0 + 1088), String2_1)) )
            {
              v195[0] = 0;
              v192 = 0;
              v194 = v195;
              v191[0] = 0;
              a1 = 0;
              v190 = v191;
              n511 = 511;
              n511_1 = 511;
              v40 = *(const char **)sub_140593C20(v28, &v131);
              if ( is_valid_handle_typeB((unsigned __int64 *)&a7) )
              {
                p_null_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a7 & 0xFFFFFFFFFFFFLL) + 112LL))(a7 & 0xFFFFFFFFFFFFLL);
              }
              else
              {
                p_null_1 = "null";
              }
              v42 = (const char *)sub_1402A1380(
                                    &a1,
                                    "Adding hit to outbox hit map -> HitId: %hu, Source: %s, TimeStamp: %s",
                                    v26,
                                    p_null_1,
                                    v40)[2];
              v43 = (const char *)sub_142E0ABB0(n10, "UNDEFINED");
              v44 = sub_1402A1380(&v192, "| %s | %s", v43, v42);
              v171[0] = 0;
              v170 = (__int128 *)v171;
              v168 = 0;
              n511_2 = 511;
              sub_1402A1CD0(&v168, (void *)v44[2], *v44);
              DestroyStringObject(&v131);
              if ( v190 != v191 )
              {
                qword_149808368 += -1 - n511_1;
                sub_14739AF10(v190);
              }
              if ( v194 != v195 )
              {
                qword_149808368 += -1 - n511;
                sub_14739AF10(v194);
              }
              sub_146284540(qword_149B3B2E8, &n225_5);
              v198 = v199;
              v199[0] = 0;
              v196 = 0;
              n511_3 = 511;
              if ( byte_14981D4A0 || !is_valid_handle_typeB(&n225_5) )
              {
                p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
              }
              else
              {
                p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (const ULONG_PTR *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(n225_5 & 0xFFFFFFFFFFFFLL) + 112LL))(n225_5 & 0xFFFFFFFFFFFFLL);
              }
              CLIENT: = "CLIENT: ";
              if ( byte_14981D4A0 )
              {
                CLIENT: = "SERVER";
              }
              v47 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
              v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v47 + 1808LL))(v47);
              p_Authoritative = "Non-Authoritative";
              if ( v48 )
              {
                p_Authoritative = "Authoritative";
              }
              v50 = sub_1402A1380(
                      &v196,
                      "%s %s%s",
                      p_Authoritative,
                      CLIENT:,
                      p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.);
              v167[0] = 0;
              v166 = v167;
              v164 = 0;
              n511_4 = 511;
              sub_1402A1CD0(&v164, (void *)v50[2], *v50);
              if ( v198 != v199 )
              {
                qword_149808368 += -1 - n511_3;
                sub_14739AF10(v198);
              }
              n225_2 = 225;
              *(_QWORD *)&v130 = &n225_2;
              *((_QWORD *)&v130 + 1) = &n225_5;
              v51 = invokeGlobalCallbackAndMaskStatusBits(
                      5,
                      (__int64)&v130,
                      (__int64)"ACTOR STAT PREDICTION",
                      "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
              if ( (v51 & 0xFFFFF) != 0 )
              {
                p_CSCActorStatus::UpdateCurrentStatValue = "CSCActorStatus::UpdateCurrentStatValue";
                v152 = v170;
                *(_QWORD *)&v136 = "ClientServerInfo";
                *((_QWORD *)&v136 + 1) = v166;
                v52 = rcx0[83];
                p_n225 = 0;
                ptr_to_free_3 = 0;
                *(_QWORD *)&v130 = 0;
                DWORD2(v130) = 3141;
                v154 = 0;
                ptr_to_free_2 = 0;
                ptr_to_free_1 = 0;
                v53 = *(volatile signed __int64 **)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(*(_QWORD *)(v52 + 8) & 0xFFFFFFFFFFFFLL)
                                                                                                 + 8LL))(
                                                     *(_QWORD *)(v52 + 8) & 0xFFFFFFFFFFFFLL,
                                                     &v138);
                v54 = rcx0[83];
                v133 = v53;
                v132 = 0;
                LOBYTE(ptr_to_free_4) = 0;
                *((_QWORD *)&v158 + 1) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v54 + 8)
                                                                                        & 0xFFFFFFFFFFFFLL)
                                                                            + 112LL))(*(_QWORD *)(v54 + 8) & 0xFFFFFFFFFFFFLL);
                *(_QWORD *)&v158 = 0;
                ptr_to_free = 0;
                ThreadLogContextSlot = getThreadLogContextSlot();
                n225_2 = 225;
                v160[0] = &n225_2;
                v160[1] = &n225_5;
                __asm { vpxor   xmm0, xmm0, xmm0 }
                __asm { vmovdqu [rbp+2170h+var_20D0], xmm0 }
                sub_14367C570(
                  5,
                  (__int64)v160,
                  "ACTOR STAT PREDICTION",
                  (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                  1,
                  v51,
                  &v157,
                  0,
                  (__int64)ThreadLogContextSlot,
                  (__int64)&v158,
                  (__int64)&v132,
                  (__int64)&v136,
                  (__int64)&v154,
                  (__int64)&v130,
                  (__int64)&p_n225);
                free_memory_wrapper(ptr_to_free);
                free_memory_wrapper(ptr_to_free_1);
                free_memory_wrapper(ptr_to_free_2);
                free_memory_wrapper(ptr_to_free_3);
              }
              if ( v166 != v167 )
              {
                qword_149808368 += -1 - n511_4;
                sub_14739AF10(v166);
              }
              if ( v170 != (__int128 *)v171 )
              {
                qword_149808368 += -1 - n511_2;
                sub_14739AF10(v170);
                v35 = qword_149B3B2E0;
LABEL_71:
                p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
LABEL_72:
                if ( *(int *)(v35 + 1076) > 0 )
                {
                  __asm { vzeroupper }
                  n29 = sub_1426551B0(*(char **)(v35 + 1080));
                  if ( n29 == 29 || n29 == n10 )
                  {
                    if ( ((v59 = *(_BYTE **)(qword_149B3B2E0 + 1088), !*v59) || *v59 == 48) && !v59[1]
                      || (v60 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL,
                          String2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v60 + 112LL))(v60),
                          !_stricmp(*(const char **)(qword_149B3B2E0 + 1088), String2)) )
                    {
                      v219[0] = 0;
                      v216 = 0;
                      v218 = v219;
                      n511_5 = 511;
                      v214 = v215;
                      v215[0] = 0;
                      v212 = 0;
                      n511_6 = 511;
                      if ( is_valid_handle_typeB((unsigned __int64 *)&a7) )
                      {
                        p_null = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a7 & 0xFFFFFFFFFFFFLL)
                                                                                  + 112LL))(a7 & 0xFFFFFFFFFFFFLL);
                      }
                      n225_3 = n225_1;
                      __asm
                      {
                        vcvtss2sd xmm2, xmm8, xmm8
                        vcvtss2sd xmm0, xmm9, xmm9
                      }
                      *(_DWORD *)v126 = v26;
                      __asm { vmovss  xmm3, dword ptr [rax] }
                      __asm { vcvtss2sd xmm3, xmm3, xmm3 }
                      __asm
                      {
                        vmovq   r9, xmm3
                        vmovq   r8, xmm2
                        vmovsd  qword ptr [rsp+2270h+var_2250], xmm0
                      }
                      v69 = (const char *)sub_1402A1380(
                                            &v212,
                                            "OldValue: %.4f, NewValue: %.4f, Adjustment: %.4f, Source: %s, HitId: %hu",
                                            _R8,
                                            _R9,
                                            v123,
                                            p_null,
                                            *(_QWORD *)v126)[2];
                      v70 = (const char *)sub_142E0ABB0(n10, "UNDEFINED");
                      v71 = sub_1402A1380(&v216, "| %s | %s", v70, v69);
                      v187[0] = 0;
                      v186 = v187;
                      v184 = 0;
                      n511_7 = 511;
                      sub_1402A1CD0(&v184, (void *)v71[2], *v71);
                      if ( v214 != v215 )
                      {
                        qword_149808368 += -1 - n511_6;
                        sub_14739AF10(v214);
                      }
                      if ( v218 != v219 )
                      {
                        qword_149808368 += -1 - n511_5;
                        sub_14739AF10(v218);
                      }
                      sub_146284540(qword_149B3B2E8, &v131);
                      v72 = byte_14981D4A0 == 0;
                      v222 = v223;
                      v223[0] = 0;
                      v220 = 0;
                      n511_8 = 511;
                      if ( !byte_14981D4A0 )
                      {
                        if ( is_valid_handle_typeB(&v131) )
                        {
                          p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v131 & 0xFFFFFFFFFFFFLL) + 112LL))(v131 & 0xFFFFFFFFFFFFLL);
                        }
                        v72 = byte_14981D4A0 == 0;
                      }
                      CLIENT:_1 = "CLIENT: ";
                      if ( !v72 )
                      {
                        CLIENT:_1 = "SERVER";
                      }
                      v74 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
                      v75 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v74 + 1808LL))(v74);
                      p_Authoritative_1 = "Non-Authoritative";
                      if ( v75 )
                      {
                        p_Authoritative_1 = "Authoritative";
                      }
                      v77 = sub_1402A1380(
                              &v220,
                              "%s %s%s",
                              p_Authoritative_1,
                              CLIENT:_1,
                              p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1);
                      v183[0] = 0;
                      p_CSCActorStatus::UpdateCurrentStatValue_4 = v183;
                      v180 = 0;
                      n511_9 = 511;
                      sub_1402A1CD0(&v180, (void *)v77[2], *v77);
                      if ( v222 != v223 )
                      {
                        qword_149808368 += -1 - n511_8;
                        sub_14739AF10(v222);
                      }
                      n225_1 = 225;
                      p_n225 = &n225_1;
                      v152 = &v130;
                      v78 = invokeGlobalCallbackAndMaskStatusBits(
                              5,
                              (__int64)&p_n225,
                              (__int64)"ACTOR STAT PREDICTION",
                              "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
                      if ( (v78 & 0xFFFFF) != 0 )
                      {
                        p_CSCActorStatus::UpdateCurrentStatValue_1 = "CSCActorStatus::UpdateCurrentStatValue";
                        *((_QWORD *)&v136 + 1) = v186;
                        p_ClientServerInfo = "ClientServerInfo";
                        p_CSCActorStatus::UpdateCurrentStatValue_2 = p_CSCActorStatus::UpdateCurrentStatValue_4;
                        v79 = rcx0[83];
                        *(_QWORD *)&v136 = 0;
                        ptr_to_free_1 = 0;
                        v154 = 0;
                        LODWORD(p_CSCActorStatus::UpdateCurrentStatValue) = 3164;
                        p_ClientServerInfo_1 = 0;
                        ptr_to_free_6 = 0;
                        ptr_to_free_5 = 0;
                        v80 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)(*(_QWORD *)(v79 + 8) & 0xFFFFFFFFFFFFLL)
                                                                                        + 8LL))(
                                           *(_QWORD *)(v79 + 8) & 0xFFFFFFFFFFFFLL,
                                           &v130);
                        v81 = rcx0[83];
                        *(_QWORD *)&v145.m256_f32[2] = v80;
                        *(_QWORD *)v145.m256_f32 = 0;
                        LOBYTE(v145.m256_f32[4]) = 0;
                        v133 = (volatile signed __int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v81 + 8) & 0xFFFFFFFFFFFFLL)
                                                                                             + 112LL))(*(_QWORD *)(v81 + 8) & 0xFFFFFFFFFFFFLL);
                        v132 = 0;
                        ptr_to_free_4 = 0;
                        ThreadLogContextSlot_1 = getThreadLogContextSlot();
                        n225_5 = 225;
                        *(_QWORD *)&v157 = &n225_5;
                        *((_QWORD *)&v157 + 1) = &n225_1;
                        __asm { vpxor   xmm0, xmm0, xmm0 }
                        LODWORD(v125) = v78;
                        __asm { vmovdqu [rbp+2170h+var_20C0], xmm0 }
                        sub_14367C570(
                          5,
                          (__int64)&v157,
                          "ACTOR STAT PREDICTION",
                          (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                          1,
                          v125,
                          &v158,
                          0,
                          (__int64)ThreadLogContextSlot_1,
                          (__int64)&v132,
                          (__int64)&v145,
                          (__int64)&p_ClientServerInfo,
                          (__int64)&p_ClientServerInfo_1,
                          (__int64)&v154,
                          (__int64)&v136);
                        free_memory_wrapper(ptr_to_free_4);
                        free_memory_wrapper(ptr_to_free_5);
                        free_memory_wrapper(ptr_to_free_6);
                        free_memory_wrapper(ptr_to_free_1);
                      }
                      if ( p_CSCActorStatus::UpdateCurrentStatValue_4 != v183 )
                      {
                        qword_149808368 += -1 - n511_9;
                        sub_14739AF10(p_CSCActorStatus::UpdateCurrentStatValue_4);
                      }
                      if ( v186 != v187 )
                      {
                        qword_149808368 += -1 - n511_7;
                        sub_14739AF10(v186);
                      }
                    }
                  }
                }
                if ( a6 )
                {
                  __asm
                  {
                    vmovaps xmm3, xmm8
                    vmovaps xmm2, xmm9
                    vmovss  [rsp+2270h+var_2250], xmm7
                    vzeroupper
                  }
                  sub_1436BE340((_DWORD)rcx0, n10, v23, _R9, v124, a7, v26);
                }
                goto LABEL_102;
              }
            }
          }
        }
      }
      else if ( a5 )
      {
        __asm { vucomiss xmm8, xmm7 }
        v90 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D260 + 56LL))(
                          qword_14981D260,
                          0);
        v91 = (_QWORD *)sub_141B2DB40(n225 + 56, &v132);
        *(_QWORD *)&v145.m256_f32[2] = *v90;
        v92 = (_QWORD *)*v91;
        __asm
        {
          vsubss  xmm0, xmm8, xmm7
          vmovss  dword ptr [rbp+2170h+var_2148], xmm0
        }
        LOWORD(v145.m256_f32[4]) = v26;
        v94 = v92[4] + 1LL;
        *(_QWORD *)&v145.m256_f32[6] = a7;
        if ( v92[2] <= v94 )
        {
          sub_140C12610(v92, 1);
        }
        v95 = v92[2] - 1LL;
        v92[3] &= v95;
        v96 = v95 & (v92[4] + v92[3]);
        if ( !*(_QWORD *)(v92[1] + 8 * v96) )
        {
          *(_QWORD *)(v92[1] + 8 * v96) = sub_1402A1E30(0x20u);
        }
        __asm { vmovups ymm0, [rbp+2170h+var_2148] }
        _RCX = *(_QWORD *)(v92[1] + 8 * v96);
        __asm { vmovups ymmword ptr [rcx], ymm0 }
        ++v92[4];
        v72 = (*ptr_to_free_4)-- == 1;
        if ( v72 )
        {
          v99 = v133;
          v100 = *((_DWORD *)v133 + 3);
          if ( v100 )
          {
            *((_DWORD *)v133 + 3) = v100 - 1;
          }
          else
          {
            *((_DWORD *)v133 + 2) = -1;
            n0x200000 = _InterlockedCompareExchange64(v99, 0, 0x200000);
            if ( n0x200000 != 0x200000 )
            {
              __asm { vzeroupper }
              sub_1403D8A00(v99, n0x200000);
            }
          }
        }
        v35 = qword_149B3B2E0;
        if ( *(int *)(qword_149B3B2E0 + 1076) <= 0 )
        {
          goto LABEL_71;
        }
        __asm { vzeroupper }
        n29_2 = sub_1426551B0(*(char **)(qword_149B3B2E0 + 1080));
        if ( n29_2 == 29 || n29_2 == n10 )
        {
          if ( ((v102 = *(_BYTE **)(qword_149B3B2E0 + 1088), !*v102) || *v102 == 48) && !v102[1]
            || (v103 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL,
                String2_2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v103 + 112LL))(v103),
                !_stricmp(*(const char **)(qword_149B3B2E0 + 1088), String2_2)) )
          {
            v207[0] = 0;
            v206 = v207;
            v204 = 0;
            v202 = v203;
            n511_10 = 511;
            v203[0] = 0;
            v200 = 0;
            n511_11 = 511;
            v105 = *(const char **)sub_140593C20(v90, &v138);
            if ( is_valid_handle_typeB((unsigned __int64 *)&a7) )
            {
              p_null_2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a7 & 0xFFFFFFFFFFFFLL) + 112LL))(a7 & 0xFFFFFFFFFFFFLL);
            }
            else
            {
              p_null_2 = "null";
            }
            v108 = (const char *)sub_1402A1380(
                                   &v200,
                                   "Adding hit to local hit cache -> HitId: %hu, Source: %s, TimeStamp: %s",
                                   v26,
                                   p_null_2,
                                   v105)[2];
            v109 = (const char *)sub_142E0ABB0(n10, "UNDEFINED");
            v110 = sub_1402A1380(&v204, "| %s | %s", v109, v108);
            v179[0] = 0;
            v178 = (volatile signed __int64 *)v179;
            v176 = 0;
            n511_12 = 511;
            sub_1402A1CD0(&v176, (void *)v110[2], *v110);
            DestroyStringObject(&v138);
            if ( v202 != v203 )
            {
              qword_149808368 += -1 - n511_11;
              sub_14739AF10(v202);
            }
            if ( v206 != v207 )
            {
              qword_149808368 += -1 - n511_10;
              sub_14739AF10(v206);
            }
            sub_146284540(qword_149B3B2E8, &v146);
            v210 = v211;
            v211[0] = 0;
            v208 = 0;
            n511_13 = 511;
            if ( byte_14981D4A0 || !is_valid_handle_typeB(&v146) )
            {
              p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
              p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
            }
            else
            {
              p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v146 & 0xFFFFFFFFFFFFLL) + 112LL))(v146 & 0xFFFFFFFFFFFFLL);
              p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
            }
            CLIENT:_2 = "CLIENT: ";
            if ( byte_14981D4A0 )
            {
              CLIENT:_2 = "SERVER";
            }
            v113 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
            v114 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v113 + 1808LL))(v113);
            p_Authoritative_2 = "Non-Authoritative";
            if ( v114 )
            {
              p_Authoritative_2 = "Authoritative";
            }
            v116 = sub_1402A1380(
                     &v208,
                     "%s %s%s",
                     p_Authoritative_2,
                     CLIENT:_2,
                     p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._2);
            v175[0] = 0;
            p_CSCActorStatus::UpdateCurrentStatValue_3 = v175;
            v172 = 0;
            n511_14 = 511;
            sub_1402A1CD0(&v172, (void *)v116[2], *v116);
            if ( v210 != v211 )
            {
              qword_149808368 += -1 - n511_13;
              sub_14739AF10(v210);
            }
            n225_2 = 225;
            p_n225_1 = &n225_2;
            p_n225_2 = &n225_5;
            v117 = invokeGlobalCallbackAndMaskStatusBits(
                     5,
                     (__int64)&p_n225_1,
                     (__int64)"ACTOR STAT PREDICTION",
                     "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
            if ( (v117 & 0xFFFFF) != 0 )
            {
              p_CSCActorStatus::UpdateCurrentStatValue_2 = "CSCActorStatus::UpdateCurrentStatValue";
              v133 = v178;
              p_ClientServerInfo_1 = "ClientServerInfo";
              p_CSCActorStatus::UpdateCurrentStatValue_1 = p_CSCActorStatus::UpdateCurrentStatValue_3;
              v118 = rcx0[83];
              v132 = 0;
              ptr_to_free_4 = 0;
              v161 = 0;
              n3154 = 3154;
              p_ClientServerInfo = 0;
              ptr_to_free_5 = 0;
              ptr_to_free_6 = 0;
              v119 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)(*(_QWORD *)(v118 + 8)
                                                                                         & 0xFFFFFFFFFFFFLL)
                                                                             + 8LL))(
                                  *(_QWORD *)(v118 + 8) & 0xFFFFFFFFFFFFLL,
                                  v160);
              v120 = rcx0[83];
              *(_QWORD *)&v145.m256_f32[2] = v119;
              *(_QWORD *)v145.m256_f32 = 0;
              LOBYTE(v145.m256_f32[4]) = 0;
              p_n225_2 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v120 + 8)
                                                                                            & 0xFFFFFFFFFFFFLL)
                                                                                + 112LL))(*(_QWORD *)(v120 + 8) & 0xFFFFFFFFFFFFLL);
              p_n225_1 = 0;
              ptr_to_free_7 = 0;
              ThreadLogContextSlot_2 = getThreadLogContextSlot();
              n225_6 = 225;
              v163[0] = &n225_6;
              v163[1] = &v136;
              __asm { vpxor   xmm0, xmm0, xmm0 }
              __asm { vmovdqu [rbp+2170h+var_2198], xmm0 }
              sub_14367C570(
                5,
                (__int64)v163,
                "ACTOR STAT PREDICTION",
                (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                1,
                v117,
                &v136,
                0,
                (__int64)ThreadLogContextSlot_2,
                (__int64)&p_n225_1,
                (__int64)&v145,
                (__int64)&p_ClientServerInfo_1,
                (__int64)&p_ClientServerInfo,
                (__int64)&v161,
                (__int64)&v132);
              free_memory_wrapper(ptr_to_free_7);
              free_memory_wrapper(ptr_to_free_6);
              free_memory_wrapper(ptr_to_free_5);
              free_memory_wrapper(ptr_to_free_4);
            }
            if ( p_CSCActorStatus::UpdateCurrentStatValue_3 != v175 )
            {
              qword_149808368 += -1 - n511_14;
              sub_14739AF10(p_CSCActorStatus::UpdateCurrentStatValue_3);
            }
            if ( v178 != (volatile signed __int64 *)v179 )
            {
              qword_149808368 += -1 - n511_12;
              sub_14739AF10((const void *)v178);
              v35 = qword_149B3B2E0;
              goto LABEL_72;
            }
LABEL_143:
            v35 = qword_149B3B2E0;
            goto LABEL_72;
          }
        }
      }
    }
    p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
    goto LABEL_143;
  }
  switch ( n10 )
  {
    case 0xBu:
    case 0xCu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
      break;
    default:
      switch ( n10 )
      {
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
          goto LABEL_102;
        default:
          if ( n10 != 10 )
          {
            goto LABEL_16;
          }
          break;
      }
      break;
  }
LABEL_102:
  __asm { vzeroupper; jumptable 00000001436BB490 cases 11-17 }
  _R11 = &v225;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-40h]
    vmovaps xmm8, xmmword ptr [r11-50h]
    vmovaps xmm9, xmmword ptr [r11-60h]
  }
}

// --- End Function: sub_1436BB390 (0x1436BB390) ---

// --- Function: sub_1436BE340 (0x1436BE340) ---
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_1436BE340(_QWORD *rcx0, int n10, double _XMM2_8, double _XMM3_8, int a5, __int64 a6, __int16 a7)
{
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // r13
  _QWORD *v16; // r15
  int *v17; // rsi
  int *v18; // rax
  int v19; // esi
  int v20; // r14d
  __int64 v21; // r14
  unsigned __int8 (__fastcall *v22)(__int64, __int64, const char *); // rsi
  __int64 v23; // rax
  __int64 v24; // rax
  _QWORD *v25; // rcx
  _QWORD *v26; // r15
  int *v27; // rsi
  int *v28; // rax
  int v29; // esi
  int v30; // r14d
  __int64 v31; // r14
  unsigned __int8 (__fastcall *v32)(__int64, __int64, const char *); // rsi
  __int64 v33; // rax
  int n29; // eax
  int n10_1; // r15d
  _BYTE *v39; // rcx
  __int64 v40; // rcx
  const char *String2; // rax
  const char *v42; // rsi
  __int64 *v43; // rax
  __int64 *v44; // rax
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.; // r14
  const char *CLIENT:; // rsi
  __int64 v47; // rcx
  char v48; // al
  const char *p_Authoritative; // r8
  __int64 *v50; // rax
  int v51; // esi
  __int64 v52; // rax
  const void *v53; // rcx
  __int64 v54; // rax
  __int64 *ThreadLogContextSlot; // rax
  char v56; // si
  int v63; // r8d
  const ULONG_PTR *p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1; // r14
  const char *CLIENT:_1; // rsi
  __int64 v66; // rcx
  char v67; // al
  const char *p_Authoritative_1; // r8
  __int64 *v69; // rax
  int v70; // esi
  const char *v71; // rax
  __int64 v72; // rcx
  __int64 v73; // rax
  const void *v74; // rcx
  __int64 v75; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v80; // [rsp+28h] [rbp-D8h]
  __int64 v82; // [rsp+88h] [rbp-78h] BYREF
  const void *v83; // [rsp+90h] [rbp-70h]
  const void *ptr_to_free_3; // [rsp+98h] [rbp-68h]
  __int64 n225; // [rsp+A0h] [rbp-60h] BYREF
  __int64 n225_1; // [rsp+A8h] [rbp-58h] BYREF
  __int64 n225_2; // [rsp+B0h] [rbp-50h] BYREF
  __int64 n225_3; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v89; // [rsp+C0h] [rbp-40h] BYREF
  const void *v90; // [rsp+C8h] [rbp-38h]
  char v91; // [rsp+D0h] [rbp-30h]
  __int64 v92; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v93; // [rsp+E0h] [rbp-20h]
  const void *ptr_to_free; // [rsp+E8h] [rbp-18h]
  const char *p_ClientServerInfo; // [rsp+F0h] [rbp-10h] BYREF
  const char *p_CSCActorStatus::UpdateLinkedStats_1; // [rsp+F8h] [rbp-8h]
  const void *ptr_to_free_1; // [rsp+100h] [rbp+0h]
  const char *p_ClientServerInfo_1; // [rsp+108h] [rbp+8h] BYREF
  const char *p_CSCActorStatus::UpdateLinkedStats; // [rsp+110h] [rbp+10h]
  const void *ptr_to_free_2; // [rsp+118h] [rbp+18h]
  unsigned __int64 v101; // [rsp+120h] [rbp+20h] BYREF
  _QWORD *v102; // [rsp+128h] [rbp+28h]
  unsigned __int64 v103; // [rsp+130h] [rbp+30h] BYREF
  __int64 v104; // [rsp+138h] [rbp+38h]
  _QWORD v105[2]; // [rsp+140h] [rbp+40h] BYREF
  __int64 v106; // [rsp+150h] [rbp+50h] BYREF
  int n1335; // [rsp+158h] [rbp+58h]
  _QWORD v108[2]; // [rsp+160h] [rbp+60h] BYREF
  _QWORD v109[2]; // [rsp+170h] [rbp+70h] BYREF
  __int64 v110; // [rsp+180h] [rbp+80h] BYREF
  int n1341; // [rsp+188h] [rbp+88h]
  _QWORD v112[2]; // [rsp+190h] [rbp+90h] BYREF
  _BYTE v113[8]; // [rsp+1A0h] [rbp+A0h] BYREF
  _BYTE v114[8]; // [rsp+1A8h] [rbp+A8h] BYREF
  __int128 v115; // [rsp+1B0h] [rbp+B0h] BYREF
  __int128 v116; // [rsp+1C0h] [rbp+C0h] BYREF
  __int64 v117; // [rsp+1D0h] [rbp+D0h] BYREF
  __int64 n511_4; // [rsp+1D8h] [rbp+D8h]
  const char *p_CSCActorStatus::UpdateLinkedStats_3; // [rsp+1E0h] [rbp+E0h]
  _BYTE v120[520]; // [rsp+1E8h] [rbp+E8h] BYREF
  __int64 v121; // [rsp+3F0h] [rbp+2F0h] BYREF
  __int64 n511_2; // [rsp+3F8h] [rbp+2F8h]
  _BYTE *v123; // [rsp+400h] [rbp+300h]
  _BYTE v124[520]; // [rsp+408h] [rbp+308h] BYREF
  __int64 v125; // [rsp+610h] [rbp+510h] BYREF
  __int64 n511_6; // [rsp+618h] [rbp+518h]
  const char *p_CSCActorStatus::UpdateLinkedStats_2; // [rsp+620h] [rbp+520h]
  _BYTE v128[520]; // [rsp+628h] [rbp+528h] BYREF
  __int64 a1; // [rsp+830h] [rbp+730h] BYREF
  __int64 n511_1; // [rsp+838h] [rbp+738h]
  _BYTE *v131; // [rsp+840h] [rbp+740h]
  _BYTE v132[520]; // [rsp+848h] [rbp+748h] BYREF
  __int64 v133; // [rsp+A50h] [rbp+950h] BYREF
  __int64 n511; // [rsp+A58h] [rbp+958h]
  _BYTE *v135; // [rsp+A60h] [rbp+960h]
  _BYTE v136[520]; // [rsp+A68h] [rbp+968h] BYREF
  __int64 v137; // [rsp+C70h] [rbp+B70h] BYREF
  __int64 n511_3; // [rsp+C78h] [rbp+B78h]
  _BYTE *v139; // [rsp+C80h] [rbp+B80h]
  _BYTE v140[520]; // [rsp+C88h] [rbp+B88h] BYREF
  __int64 v141; // [rsp+E90h] [rbp+D90h] BYREF
  __int64 n511_5; // [rsp+E98h] [rbp+D98h]
  _BYTE *v143; // [rsp+EA0h] [rbp+DA0h]
  _BYTE v144[520]; // [rsp+EA8h] [rbp+DA8h] BYREF
  __int64 v145; // [rsp+10B0h] [rbp+FB0h] BYREF
  __int64 n511_7; // [rsp+10B8h] [rbp+FB8h]
  _BYTE *v147; // [rsp+10C0h] [rbp+FC0h]
  _BYTE v148[520]; // [rsp+10C8h] [rbp+FC8h] BYREF

  __asm
  {
    vmovaps xmm7, xmm3
    vmovaps xmm6, xmm2
  }
  v12 = rcx0[n10 + 1219];
  if ( v12 )
  {
    v13 = *(_QWORD *)(v12 + 144);
    v14 = *(_QWORD *)(v13 + 64);
    v104 = v14 + 16LL * *(_QWORD *)(v13 + 72);
    if ( v14 != v104 )
    {
      __asm
      {
        vmovaps [rsp+1350h+var_70], xmm8
        vmovss  xmm8, [rbp+1250h+arg_20]
      }
      do
      {
        v16 = *(_QWORD **)v14;
        if ( !*(_QWORD *)v14 )
        {
          goto LABEL_14;
        }
        v17 = (int *)sub_1436B6FE0(&v82);
        v18 = (int *)(*(__int64 (__fastcall **)(_QWORD *, __int64 *))(*v16 + 24LL))(v16, &v89);
        v19 = *v17;
        v20 = *v18;
        if ( v90 )
        {
          sub_14739AF10(v90);
        }
        if ( v83 )
        {
          sub_14739AF10(v83);
        }
        if ( v19 == v20
          || Parameter_3
          && (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3)
          && (v21 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
              v22 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v21 + 256LL),
              v23 = (*(__int64 (__fastcall **)(_QWORD *))(*v16 + 8LL))(v16),
              v22(v21, v23, "LinkedStatPreset")) )
        {
          v24 = v16[2];
          v102 = (_QWORD *)(v24 + 32);
          v25 = (_QWORD *)(v24 + 16);
        }
        else
        {
LABEL_14:
          v26 = *(_QWORD **)v14;
          if ( !*(_QWORD *)v14 )
          {
            goto LABEL_23;
          }
          v27 = (int *)sub_1436B6EF0(&v82);
          v28 = (int *)(*(__int64 (__fastcall **)(_QWORD *, __int64 *))(*v26 + 24LL))(v26, &v89);
          v29 = *v27;
          v30 = *v28;
          if ( v90 )
          {
            sub_14739AF10(v90);
          }
          if ( v83 )
          {
            sub_14739AF10(v83);
          }
          if ( v29 != v30 )
          {
            if ( !Parameter_3
              || !(*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3)
              || (v31 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 576LL))(Parameter_3),
                  v32 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v31 + 256LL),
                  v33 = (*(__int64 (__fastcall **)(_QWORD *))(*v26 + 8LL))(v26),
                  !v32(v31, v33, "LinkedStat")) )
            {
LABEL_23:
              v26 = 0;
            }
          }
          v102 = v26 + 5;
          v25 = v26 + 3;
        }
        __asm
        {
          vmovaps xmm3, xmm6
          vmovaps xmm2, xmm8
          vmovaps xmm1, xmm7
        }
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(*(_QWORD *)*v25 + 48LL))(*v25) )
        {
          if ( *(int *)(qword_149B3B2E0 + 1076) <= 0 )
          {
            n10_1 = n10;
          }
          else
          {
            n29 = sub_1426551B0(*(char **)(qword_149B3B2E0 + 1080), 29);
            n10_1 = n10;
            if ( n29 == 29 || n29 == n10 )
            {
              if ( ((v39 = *(_BYTE **)(qword_149B3B2E0 + 1088), !*v39) || *v39 == 48) && !v39[1]
                || (v40 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL,
                    String2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v40 + 112LL))(v40),
                    !_stricmp(*(const char **)(qword_149B3B2E0 + 1088), String2)) )
              {
                v136[0] = 0;
                v133 = 0;
                v135 = v136;
                n511 = 511;
                v131 = v132;
                v132[0] = 0;
                a1 = 0;
                n511_1 = 511;
                v42 = sub_142E0ABB0(n10, "UNDEFINED");
                v43 = sub_1402A1380(&a1, "Adjusting stat value from linked stat: %s", v42);
                v44 = sub_1402A1380(&v133, "| %s | %s", v42, (const char *)v43[2]);
                v124[0] = 0;
                v123 = v124;
                v121 = 0;
                n511_2 = 511;
                sub_1402A1CD0(&v121, (void *)v44[2], *v44);
                if ( v131 != v132 )
                {
                  qword_149808368 += -1 - n511_1;
                  sub_14739AF10(v131);
                }
                if ( v135 != v136 )
                {
                  qword_149808368 += -1 - n511;
                  sub_14739AF10(v135);
                }
                sub_146284540(qword_149B3B2E8, &v101);
                v139 = v140;
                v140[0] = 0;
                v137 = 0;
                n511_3 = 511;
                if ( byte_14981D4A0 || !is_valid_handle_typeB(&v101) )
                {
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
                }
                else
                {
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core. = (const ULONG_PTR *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v101 & 0xFFFFFFFFFFFFLL) + 112LL))(v101 & 0xFFFFFFFFFFFFLL);
                }
                CLIENT: = "CLIENT: ";
                if ( byte_14981D4A0 )
                {
                  CLIENT: = "SERVER";
                }
                v47 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
                v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v47 + 1808LL))(v47);
                p_Authoritative = "Non-Authoritative";
                if ( v48 )
                {
                  p_Authoritative = "Authoritative";
                }
                v50 = sub_1402A1380(
                        &v137,
                        "%s %s%s",
                        p_Authoritative,
                        CLIENT:,
                        p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core.);
                v120[0] = 0;
                p_CSCActorStatus::UpdateLinkedStats_3 = v120;
                v117 = 0;
                n511_4 = 511;
                sub_1402A1CD0(&v117, (void *)v50[2], *v50);
                if ( v139 != v140 )
                {
                  qword_149808368 += -1 - n511_3;
                  sub_14739AF10(v139);
                }
                n225 = 225;
                v105[0] = &n225;
                v105[1] = &n225_1;
                v51 = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)v105,
                        (__int64)"ACTOR STAT PREDICTION",
                        "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
                if ( (v51 & 0xFFFFF) != 0 )
                {
                  p_CSCActorStatus::UpdateLinkedStats = "CSCActorStatus::UpdateLinkedStats";
                  v83 = v123;
                  p_ClientServerInfo = "ClientServerInfo";
                  p_CSCActorStatus::UpdateLinkedStats_1 = p_CSCActorStatus::UpdateLinkedStats_3;
                  v52 = rcx0[83];
                  v82 = 0;
                  ptr_to_free_3 = 0;
                  v106 = 0;
                  n1335 = 1335;
                  p_ClientServerInfo_1 = 0;
                  ptr_to_free_2 = 0;
                  ptr_to_free_1 = 0;
                  v53 = *(const void **)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)(*(_QWORD *)(v52 + 8)
                                                                                                & 0xFFFFFFFFFFFFLL)
                                                                                    + 8LL))(
                                          *(_QWORD *)(v52 + 8) & 0xFFFFFFFFFFFFLL,
                                          v113);
                  v54 = rcx0[83];
                  v90 = v53;
                  v89 = 0;
                  v91 = 0;
                  v93 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v54 + 8) & 0xFFFFFFFFFFFFLL) + 112LL))(*(_QWORD *)(v54 + 8) & 0xFFFFFFFFFFFFLL);
                  v92 = 0;
                  ptr_to_free = 0;
                  ThreadLogContextSlot = getThreadLogContextSlot();
                  n225_1 = 225;
                  v108[0] = &n225_1;
                  v108[1] = &n225_2;
                  __asm { vpxor   xmm0, xmm0, xmm0 }
                  LODWORD(v80) = v51;
                  __asm { vmovdqu [rbp+1250h+var_11A0], xmm0 }
                  sub_14367C570(
                    5,
                    (__int64)v108,
                    "ACTOR STAT PREDICTION",
                    (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                    1,
                    v80,
                    &v115,
                    0,
                    (__int64)ThreadLogContextSlot,
                    (__int64)&v92,
                    (__int64)&v89,
                    (__int64)&p_ClientServerInfo,
                    (__int64)&p_ClientServerInfo_1,
                    (__int64)&v106,
                    (__int64)&v82);
                  free_memory_wrapper(ptr_to_free);
                  free_memory_wrapper(ptr_to_free_1);
                  free_memory_wrapper(ptr_to_free_2);
                  free_memory_wrapper(ptr_to_free_3);
                }
                if ( p_CSCActorStatus::UpdateLinkedStats_3 != v120 )
                {
                  qword_149808368 += -1 - n511_4;
                  sub_14739AF10(p_CSCActorStatus::UpdateLinkedStats_3);
                }
                if ( v123 != v124 )
                {
                  qword_149808368 += -1 - n511_2;
                  sub_14739AF10(v123);
                }
              }
            }
          }
          v56 = (*(__int64 (__fastcall **)(_QWORD *))(*rcx0 + 96LL))(rcx0);
          if ( rcx0[*(int *)(*(_QWORD *)v14 + 8LL) + 1219] )
          {
            __asm { vmovss  xmm3, dword ptr [rcx] }
          }
          else
          {
            __asm { vxorps  xmm3, xmm3, xmm3 }
          }
          __asm
          {
            vmovaps xmm2, xmm7
            vmovaps xmm1, xmm6
          }
          *(double *)&_XMM0 = (*(double (__fastcall **)(_QWORD))(*(_QWORD *)*v102 + 48LL))(*v102);
          __asm { vmovaps xmm2, xmm0 }
          *(double *)&_XMM0 = sub_143681C30((_DWORD)rcx0, *(_DWORD *)(*(_QWORD *)v14 + 8LL), v63, a6, a7);
          if ( !v56 )
          {
            if ( (*(unsigned __int8 (__fastcall **)(_QWORD *))(*rcx0 + 96LL))(rcx0) )
            {
              sub_143681630(rcx0);
              if ( *(int *)(qword_149B3B2E0 + 1072) > 0 )
              {
                sub_146284540(qword_149B3B2E8, &v103);
                v143 = v144;
                v144[0] = 0;
                v141 = 0;
                n511_5 = 511;
                if ( byte_14981D4A0 || !is_valid_handle_typeB(&v103) )
                {
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp;
                }
                else
                {
                  p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v103 & 0xFFFFFFFFFFFFLL) + 112LL))(v103 & 0xFFFFFFFFFFFFLL);
                }
                CLIENT:_1 = "CLIENT: ";
                if ( byte_14981D4A0 )
                {
                  CLIENT:_1 = "SERVER";
                }
                v66 = *(_QWORD *)(rcx0[83] + 8LL) & 0xFFFFFFFFFFFFLL;
                v67 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v66 + 1808LL))(v66);
                p_Authoritative_1 = "Non-Authoritative";
                if ( v67 )
                {
                  p_Authoritative_1 = "Authoritative";
                }
                v69 = sub_1402A1380(
                        &v141,
                        "%s %s%s",
                        p_Authoritative_1,
                        CLIENT:_1,
                        p_p_W:_p4_src_CryEngine_Code_SDKs_Optick_1.3.1_src_optick_core._1);
                v128[0] = 0;
                p_CSCActorStatus::UpdateLinkedStats_2 = v128;
                v125 = 0;
                n511_6 = 511;
                sub_1402A1CD0(&v125, (void *)v69[2], *v69);
                if ( v143 != v144 )
                {
                  qword_149808368 += -1 - n511_5;
                  sub_14739AF10(v143);
                }
                n225_2 = 225;
                v109[0] = &n225_2;
                v109[1] = &n225_3;
                v70 = invokeGlobalCallbackAndMaskStatusBits(
                        5,
                        (__int64)v109,
                        (__int64)"ACTOR INCAPACITATED",
                        "Actor: %% ID: %% (%%) | [%%:%%] | -> %%");
                if ( (v70 & 0xFFFFF) != 0 )
                {
                  v148[0] = 0;
                  v147 = v148;
                  v145 = 0;
                  n511_7 = 511;
                  v71 = sub_142E0ABB0(n10_1, "UNDEFINED");
                  v72 = sub_1402A1380(&v145, "Actor Incapacitated from linked stat: %s", v71)[2];
                  p_CSCActorStatus::UpdateLinkedStats_1 = "CSCActorStatus::UpdateLinkedStats";
                  p_ClientServerInfo_1 = "ClientServerInfo";
                  p_CSCActorStatus::UpdateLinkedStats = p_CSCActorStatus::UpdateLinkedStats_2;
                  v73 = rcx0[83];
                  v93 = v72;
                  v92 = 0;
                  ptr_to_free = 0;
                  v110 = 0;
                  n1341 = 1341;
                  p_ClientServerInfo = 0;
                  ptr_to_free_1 = 0;
                  ptr_to_free_2 = 0;
                  v74 = *(const void **)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)(*(_QWORD *)(v73 + 8)
                                                                                                & 0xFFFFFFFFFFFFLL)
                                                                                    + 8LL))(
                                          *(_QWORD *)(v73 + 8) & 0xFFFFFFFFFFFFLL,
                                          v114);
                  v75 = rcx0[83];
                  v90 = v74;
                  v89 = 0;
                  v91 = 0;
                  v83 = (const void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v75 + 8)
                                                                                     & 0xFFFFFFFFFFFFLL)
                                                                         + 112LL))(*(_QWORD *)(v75 + 8) & 0xFFFFFFFFFFFFLL);
                  v82 = 0;
                  ptr_to_free_3 = 0;
                  ThreadLogContextSlot_1 = getThreadLogContextSlot();
                  n225_3 = 225;
                  v112[0] = &n225_3;
                  v112[1] = &v89;
                  __asm { vpxor   xmm0, xmm0, xmm0 }
                  LODWORD(v80) = v70;
                  __asm { vmovdqu [rbp+1250h+var_1190], xmm0 }
                  sub_14367C570(
                    5,
                    (__int64)v112,
                    "ACTOR INCAPACITATED",
                    (__int64)"Actor: %% ID: %% (%%) | [%%:%%] | -> %%",
                    1,
                    v80,
                    &v116,
                    0,
                    (__int64)ThreadLogContextSlot_1,
                    (__int64)&v82,
                    (__int64)&v89,
                    (__int64)&p_ClientServerInfo_1,
                    (__int64)&p_ClientServerInfo,
                    (__int64)&v110,
                    (__int64)&v92);
                  free_memory_wrapper(ptr_to_free_3);
                  free_memory_wrapper(ptr_to_free_2);
                  free_memory_wrapper(ptr_to_free_1);
                  free_memory_wrapper(ptr_to_free);
                  if ( v147 != v148 )
                  {
                    qword_149808368 += -1 - n511_7;
                    sub_14739AF10(v147);
                  }
                }
                if ( p_CSCActorStatus::UpdateLinkedStats_2 != v128 )
                {
                  qword_149808368 += -1 - n511_6;
                  sub_14739AF10(p_CSCActorStatus::UpdateLinkedStats_2);
                }
              }
            }
          }
        }
        v14 += 16;
      }
      while ( v14 != v104 );
      __asm { vmovaps xmm8, [rsp+1350h+var_70] }
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+1350h+var_50]
    vmovaps xmm7, [rsp+1350h+var_60]
  }
}

// --- End Function: sub_1436BE340 (0x1436BE340) ---

// --- Function: sub_1436C0520 (0x1436C0520) ---
__int64 __fastcall sub_1436C0520(__int64 a1, __int64 n225, float a3)
{
  __int64 result; // rax
  int v4; // ecx
  float v5; // kr00_4

  result = *(_QWORD *)(n225 + 144);
  v4 = *(_DWORD *)(result + 36);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      v5 = (float)(*(float *)(result + 28) + *(float *)(n225 + 28)) + a3;
      LODWORD(_XMM2) = *(_DWORD *)(n225 + 8);
      if ( v5 >= *(float *)&_XMM2 )
      {
        _XMM0 = *(unsigned int *)(n225 + 12);
        __asm { vminss  xmm2, xmm0, xmm3 }
      }
      *(float *)(n225 + 28) = *(float *)&_XMM2;
    }
  }
  else
  {
    *(float *)(n225 + 28) = a3 + *(float *)(result + 28);
  }
  return result;
}

// --- End Function: sub_1436C0520 (0x1436C0520) ---

// --- Function: sub_1449208F0 (0x1449208F0) ---
__int64 __fastcall sub_1449208F0(__int64 a1, __int64 n29)
{
  __int64 result; // rax
  unsigned int n29_1; // [rsp+48h] [rbp+10h]

  n29_1 = n29;
  result = (unsigned __int8)sub_14369A9C0(*(_QWORD *)(a1 + 8), 40);
  if ( (_BYTE)result )
  {
    result = (unsigned __int8)sub_14369D090(*(_QWORD *)(a1 + 8), n29_1, 40);
    if ( (_BYTE)result )
    {
      return sub_144999360(a1, n29_1);
    }
  }
  return result;
}

// --- End Function: sub_1449208F0 (0x1449208F0) ---

// --- Function: sub_14522A500 (0x14522A500) ---
__int64 __fastcall sub_14522A500(__int64 a1)
{
  return a1 + 968;
}

// --- End Function: sub_14522A500 (0x14522A500) ---

// --- Function: sub_14564CE30 (0x14564CE30) ---
__int64 __fastcall sub_14564CE30(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 13720);
}

// --- End Function: sub_14564CE30 (0x14564CE30) ---

// --- Function: sub_145A2B730 (0x145A2B730) ---
char __fastcall sub_145A2B730(__int64 a1)
{
  __int64 v1; // rax
  int n2; // edx
  char result; // al
  int n3; // ecx
  __int64 v5; // rax

  v1 = qword_149B3B2E0;
  n2 = *(_DWORD *)(qword_149B3B2E0 + 236);
  if ( n2 <= 0 )
  {
    v5 = sub_14638AAC0(a1);
    return sub_14564CE30(v5);
  }
  else
  {
    if ( n2 >= 2 )
    {
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 1616LL))(a1);
      if ( !result )
      {
        return result;
      }
      v1 = qword_149B3B2E0;
    }
    n3 = *(_DWORD *)(v1 + 236);
    if ( (unsigned int)(n3 - 1) > 1 )
    {
      return n3 == 3;
    }
    else
    {
      return 2;
    }
  }
}

// --- End Function: sub_145A2B730 (0x145A2B730) ---

// --- Function: sub_145A52C30 (0x145A52C30) ---
unsigned __int64 __fastcall sub_145A52C30(int a1, int a2)
{
  return a2 | (unsigned __int64)((__int64)a1 << 32);
}

// --- End Function: sub_145A52C30 (0x145A52C30) ---

// --- Function: sub_145A63D70 (0x145A63D70) ---
bool __fastcall sub_145A63D70(__int64 a1)
{
  return (*(_BYTE *)(a1 + 73) || *(_BYTE *)(a1 + 72)) && !(unsigned __int8)sub_145A66BB0();
}

// --- End Function: sub_145A63D70 (0x145A63D70) ---

// --- Function: sub_145A67F90 (0x145A67F90) ---
void __fastcall sub_145A67F90(__int64 a1, char a2, char a3, float a4)
{
  __int64 v5; // rbx
  char v6; // si
  char v7; // r14
  __int64 v8; // r15
  int v9; // ecx
  __int64 v10; // r8
  __int64 v11; // rdx
  unsigned __int64 v12; // rax
  unsigned __int64 i; // [rsp+20h] [rbp-28h] BYREF

  if ( a3 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = 0;
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 16);
    for ( i = 0x8000000000000000uLL; v5 != v8; v5 += 40 )
    {
      v7 |= *(_BYTE *)(v5 + 32);
      v6 = 1;
      if ( *(_DWORD *)(v5 + 28) && sub_140593AF0((_QWORD *)(v5 + 16), &i) )
      {
        v9 = *(_DWORD *)(v5 + 28);
        if ( v9 == -1
          || (v10 = *(_QWORD *)(a1 + 40), v11 = *(_QWORD *)(a1 + 32), ((v10 - v11) & 0xFFFFFFFFFFFFFFF0uLL) == 0) )
        {
          i = *(_QWORD *)(v5 + 16);
        }
        else
        {
          for ( ; v11 != v10; v11 += 16 )
          {
            if ( _bittest(&v9, *(_DWORD *)(v11 + 8)) )
            {
              i = *(_QWORD *)(v5 + 16);
              v9 = *(_DWORD *)(v5 + 28);
            }
            else
            {
              v6 = 0;
            }
          }
        }
      }
    }
    v12 = i;
    *(_BYTE *)(a1 + 88) = v6;
    *(_BYTE *)(a1 + 104) = v7;
    *(_QWORD *)(a1 + 96) = v12;
  }
  else if ( a2 )
  {
    if ( a4 <= 1.0000001 )
    {
      if ( a4 < 0.99999988 )
      {
        ++*(_DWORD *)(a1 + 84);
      }
    }
    else
    {
      ++*(_DWORD *)(a1 + 80);
    }
  }
}

// --- End Function: sub_145A67F90 (0x145A67F90) ---

// --- Function: sub_145A798A0 (0x145A798A0) ---
char __fastcall sub_145A798A0(__int64 a1, unsigned int a2, char **p_Src)
{
  __int128 v3; // xmm6
  char v4; // di
  _BYTE *v5; // rbx
  int v8; // edx
  float v9; // xmm6_4
  char v10; // di
  char result; // al
  _OWORD v12[3]; // [rsp+20h] [rbp-48h] BYREF

  v4 = 0;
  v5 = *(_BYTE **)(a1 + 8);
  if ( v5 != *(_BYTE **)(a1 + 16) )
  {
    v12[2] = v3;
    do
    {
      v8 = *((_DWORD *)v5 + 7);
      if ( v8 && _bittest(&v8, a2) && v5[32] )
      {
        if ( p_Src )
        {
          LODWORD(v12[0]) = *(_DWORD *)v5;
          *((_QWORD *)&v12[0] + 1) = *((_QWORD *)v5 + 1);
          sub_1403419D0(p_Src, v12);
        }
        v9 = *((float *)v5 + 6);
        v10 = *((_DWORD *)v5 + 7) != 0;
        memmove(v5, v5 + 40, *(_QWORD *)(a1 + 16) - (_QWORD)(v5 + 40));
        *(_QWORD *)(a1 + 16) -= 40LL;
        sub_145A67F90(a1, 0, v10, v9);
        v4 = 1;
      }
      else
      {
        v5 += 40;
      }
    }
    while ( v5 != *(_BYTE **)(a1 + 16) );
  }
  result = sub_145A85CF0(a1);
  if ( result || v4 )
  {
    *(_BYTE *)a1 = 1;
    return 1;
  }
  return result;
}

// --- End Function: sub_145A798A0 (0x145A798A0) ---

// --- Function: sub_145A85CF0 (0x145A85CF0) ---
__int64 __fastcall sub_145A85CF0(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v2; // r8
  __int128 n0x3F800000; // xmm0
  int v4; // r9d
  __int128 n0x3F800000_2; // kr00_16
  __int128 n0x3F800000_1; // kr00_16
  __int128 n0x3F800000_3; // kr00_16

  *(_BYTE *)(a1 + 72) = 0;
  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  n0x3F800000 = 0;
  if ( v1 != v2 )
  {
    v4 = *(_DWORD *)(a1 + 76);
    if ( v4 )
    {
      switch ( v4 )
      {
        case 1:
          n0x3F800000 = 0x3F800000u;
          break;
        case 2:
          n0x3F800000 = 0x800000u;
          break;
        case 3:
          n0x3F800000 = 0x7F7FFFFFu;
          break;
      }
    }
    do
    {
      if ( !*(_DWORD *)(v1 + 28) )
      {
        _XMM1 = *(unsigned int *)(v1 + 24);
        if ( v4 )
        {
          switch ( v4 )
          {
            case 1:
              n0x3F800000_1 = *(unsigned int *)(v1 + 24);
              *(float *)&n0x3F800000_1 = (float)(*(float *)&_XMM1 + *(float *)&n0x3F800000) - 1.0;
              n0x3F800000 = n0x3F800000_1;
              break;
            case 2:
              __asm { vmaxss  xmm0, xmm1, xmm0 }
              break;
            case 3:
              __asm { vminss  xmm0, xmm1, xmm0 }
              break;
            case 4:
              n0x3F800000_2 = n0x3F800000;
              *(float *)&n0x3F800000_2 = (float)(*(float *)&n0x3F800000 + 1.0) - *(float *)&_XMM1;
              n0x3F800000 = n0x3F800000_2;
              break;
            default:
              n0x3F800000 = 0;
              break;
          }
        }
        else
        {
          n0x3F800000_3 = n0x3F800000;
          *(float *)&n0x3F800000_3 = *(float *)&n0x3F800000 + *(float *)&_XMM1;
          n0x3F800000 = n0x3F800000_3;
        }
        *(_BYTE *)(a1 + 72) = 1;
      }
      v1 += 40;
    }
    while ( v1 != v2 );
  }
  *(float *)(a1 + 64) = *(float *)&n0x3F800000;
  return sub_145A88100(a1);
}

// --- End Function: sub_145A85CF0 (0x145A85CF0) ---

// --- Function: sub_145DD3300 (0x145DD3300) ---
_QWORD *__fastcall sub_145DD3300(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 960);
  return a2;
}

// --- End Function: sub_145DD3300 (0x145DD3300) ---

// --- Function: sub_1461CEF60 (0x1461CEF60) ---
__int64 __fastcall sub_1461CEF60(__int64 a1, unsigned __int8 n6)
{
  if ( n6 < 6u )
  {
    return *(unsigned __int8 *)(32LL * n6 + a1 + 24);
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

// --- End Function: sub_1461CEF60 (0x1461CEF60) ---

// --- Function: sub_146284540 (0x146284540) ---
_QWORD *__fastcall sub_146284540(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 n4; // dx
  __int64 v6; // rbx
  __int64 handle_metadata_ptr_1; // rax
  __int16 n4_1; // dx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 3072);
  v10 = v2;
  if ( v2
    && (handle_metadata_ptr = get_handle_metadata_ptr(v2 & 0xFFFFFFFFFFFFLL),
        n4 = *(_WORD *)(handle_metadata_ptr + 4),
        n4 != 4)
    && *(_WORD *)(handle_metadata_ptr + 2) == (HIWORD(v2) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_handle_access_by_state(&v10))
    && (v6 = *(_QWORD *)sub_145DD3300(v2 & 0xFFFFFFFFFFFFLL, &v10), (v10 = v6) != 0)
    && (handle_metadata_ptr_1 = get_handle_metadata_ptr(v6 & 0xFFFFFFFFFFFFLL),
        n4_1 = *(_WORD *)(handle_metadata_ptr_1 + 4),
        n4_1 != 4)
    && *(_WORD *)(handle_metadata_ptr_1 + 2) == (HIWORD(v6) & 0xFFF)
    && (n4_1 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_indirect_handle_access_by_state(&v10)) )
  {
    *a2 = *(_QWORD *)((v6 & 0xFFFFFFFFFFFFLL) + 8);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_146284540 (0x146284540) ---

// --- Function: PathUtils::IsGameAssetPath (0x14636EA80) ---
char __fastcall PathUtils::IsGameAssetPath(__int64 a1)
{
  __int64 v1; // rax
  __int64 v3[4]; // [rsp+28h] [rbp-20h] BYREF

  v3[0] = *(_QWORD *)(a1 + 1672);
  if ( !is_valid_handle_typeA(v3) )
  {
    return 0;
  }
  v3[1] = v3[0] & 0xFFFFFFFFFFFFLL;
  v1 = sub_1461EAAA0(v3[0] & 0xFFFFFFFFFFFFLL);
  return sub_1412CFD30(v1);
}

// --- End Function: PathUtils::IsGameAssetPath (0x14636EA80) ---

// --- Function: sub_14638A930 (0x14638A930) ---
__int64 __fastcall sub_14638A930(__int64 a1)
{
  return *(_QWORD *)(a1 + 600) + 10448LL;
}

// --- End Function: sub_14638A930 (0x14638A930) ---

// --- Function: sub_14638AAC0 (0x14638AAC0) ---
__int64 __fastcall sub_14638AAC0(__int64 a1)
{
  return *(_QWORD *)(a1 + 600) + 11072LL;
}

// --- End Function: sub_14638AAC0 (0x14638AAC0) ---

// --- Function: sub_147397F30 (0x147397F30) ---
void __fastcall sub_147397F30(__int64 a1)
{
  sub_147397F40(a1);
}

// --- End Function: sub_147397F30 (0x147397F30) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(const void *a1)
{
  if ( a1 )
  {
    if ( qword_14981D3D8 && pCZoneSystem && a1 == (const void *)pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)a1 < qword_1497CE098 || (unsigned __int64)a1 >= qword_1497CE098 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_1497CE078 && (unsigned __int64)a1 < qword_1497CE078 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      }
      sub_147397F30((__int64)a1);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: sub_14739AFC0 (0x14739AFC0) ---
__int64 __fastcall sub_14739AFC0(unsigned __int64 n0x6400000, struct _exception *n0x10)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( n0x6400000 )
  {
    v4 = sub_147273B30();
    sub_140566BA0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(n0x10);
    result = sub_1473986B0(v5 + n0x6400000, (unsigned __int64)n0x10);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(n0x6400000);
  }
  return 0LL;
}

// --- End Function: sub_14739AFC0 (0x14739AFC0) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---

// --- Function: __alloca_probe (0x147DC7830) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
  {
    StackLimit_1 = 0;
  }
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x147DC7830) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __tlregdtor (0x147DC7958) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6032);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6048);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6032) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100uLL);
    free_0(0LL);
    if ( !v3 )
    {
      return 0xFFFFFFFFLL;
    }
    v3[1] = *(_QWORD *)(v2 + 6032);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0LL;
}

// --- End Function: __tlregdtor (0x147DC7958) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memmove (0x147E162C1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x147E162C1) ---

// --- Function: memset (0x147E162C7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x147E162C7) ---

// --- Function: memcmp (0x147E162E5) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x147E162E5) ---

// --- Function: sub_147E52AF0 (0x147E52AF0) ---
__int64 sub_147E52AF0()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = get_tls_data_offset_784();
  free_memory_wrapper(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = get_tls_data_offset_784();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0LL;
  return result;
}

// --- End Function: sub_147E52AF0 (0x147E52AF0) ---

