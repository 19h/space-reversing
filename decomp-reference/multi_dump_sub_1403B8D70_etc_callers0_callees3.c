// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x1403B8D70 (sub_1403B8D70)
//   - 0x140518100 (sub_140518100)
//   - 0x141F4E8E0 (sub_141F4E8E0)
//   - 0x146A1B960 (sub_146A1B960)
//   - 0x146A1CA30 (sub_146A1CA30)
//   - 0x146A24480 (sub_146A24480)
//   - 0x146A27DC0 (sub_146A27DC0)
//   - 0x146A2D6C0 (sub_146A2D6C0)
//   - 0x146A2D800 (sub_146A2D800)
//   - 0x146A2D940 (sub_146A2D940)
//   - 0x146A2DA50 (sub_146A2DA50)
//   - 0x146A2DDF0 (sub_146A2DDF0)
//   - 0x146A2DEF0 (sub_146A2DEF0)
//   - 0x146A2E020 (sub_146A2E020)
//   - 0x146A2E140 (sub_146A2E140)
//   - 0x146A2F670 (sub_146A2F670)
//   - 0x146A31880 (sub_146A31880)
//   - 0x146A31930 (sub_146A31930)
//   - 0x146A31AE0 (sub_146A31AE0)
//   - 0x146A31E30 (sub_146A31E30)
//   - 0x146A31E70 (sub_146A31E70)
//   - 0x146A320C0 (sub_146A320C0)
//   - 0x146A321C0 (sub_146A321C0)
//   - 0x146A32280 (sub_146A32280)
//   - 0x146A322A0 (sub_146A322A0)
//   - 0x146A322C0 (sub_146A322C0)
//   - 0x146A32360 (sub_146A32360)
//   - 0x146A32380 (sub_146A32380)
//   - 0x146A323B0 (sub_146A323B0)
//   - 0x146A32530 (sub_146A32530)
//   - 0x146A327B0 (sub_146A327B0)
//   - 0x146A33560 (sub_146A33560)
//   - 0x146A38520 (sub_146A38520)
//   - 0x146A398F0 (LogTraceConditional_w)
//   - 0x146A414F0 (sub_146A414F0)
//   - 0x146A41530 (sub_146A41530)
//   - 0x146A42040 (sub_146A42040)
//   - 0x146A429B0 (sub_146A429B0)
//   - 0x146A42A40 (sub_146A42A40)
//   - 0x146A42B00 (sub_146A42B00)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 204
// ------------------------------------------------------------

// --- Function: sub_1402A2B80 (0x1402A2B80) ---
__int64 __fastcall sub_1402A2B80(__int64 a1, __int64 a2)
{
  return a2;
}

// --- End Function: sub_1402A2B80 (0x1402A2B80) ---

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3190 (0x1402A3190) ---
__int64 sub_1402A3190(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n511;
  while ( Buffer[n511] );
  sub_1402A3BE0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A3190 (0x1402A3190) ---

// --- Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---
bool __fastcall AK::WriteBytesCount::Reserve(AK::WriteBytesCount *this)
{
  return 0;
}

// --- End Function: ?Reserve@WriteBytesCount@AK@@UEAA_NH@Z (0x1402A3250) ---

// --- Function: sub_1402A3B50 (0x1402A3B50) ---
_BYTE *__fastcall sub_1402A3B50(__int64 *a1, __int64 n511_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n0x1FF; // rcx

  result = a1 + 3;
  if ( n511_1 )
  {
    allocSize = n511_1 + 1;
    if ( (unsigned __int64)(n511_1 + 1) <= 0x200 )
    {
      n0x1FF = 0x1FF;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3AB68 += allocSize;
      n0x1FF = n511_1;
    }
    a1[1] = n0x1FF;
    *a1 = n511_1;
    a1[2] = (__int64)result;
    result[n511_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 0x1FF;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A3B50 (0x1402A3B50) ---

// --- Function: sub_1402A3BE0 (0x1402A3BE0) ---
__int64 __fastcall sub_1402A3BE0(__int64 a1, const void *a2, size_t n511)
{
  size_t n511_1; // r8
  const void *v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  n511_1 = *(_QWORD *)(a1 + 8);
  if ( n511 > n511_1 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n511_1;
      sub_147605980(v7);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x1FF;
    sub_1402A3B50((__int64 *)a1, n511);
  }
  memmove(*(void **)(a1 + 0x10), a2, n511);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n511;
  *(_BYTE *)(n511 + result) = 0;
  return result;
}

// --- End Function: sub_1402A3BE0 (0x1402A3BE0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
void __fastcall sub_1402A3D30(const void *a1)
{
  sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall allocWithProfilerInfo_w(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall sub_1402A6760(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PEAVListener@Logger@gte@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@1@PEAU?$_Tree_node@PEAVListener@Logger@gte@@PEAX@1@@Z (0x1402A7F70) ---
void __fastcall std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
        std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *this,
        std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *_Al,
        std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode)
{
  std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode_1; // rbx
  std::_Tree_node<gte::Logger::Listener *,void *> *_Rootnode_2; // rcx

  _Rootnode_1 = _Rootnode;
  while ( !*((_BYTE *)_Rootnode_1 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      this,
      _Al,
      *((std::_Tree_node<gte::Logger::Listener *,void *> **)_Rootnode_1 + 2));
    _Rootnode_2 = _Rootnode_1;
    _Rootnode_1 = *(std::_Tree_node<gte::Logger::Listener *,void *> **)_Rootnode_1;
    sub_1402A3D30(_Rootnode_2);
  }
}

// --- End Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PEAVListener@Logger@gte@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@PEAVListener@Logger@gte@@PEAX@std@@@1@PEAU?$_Tree_node@PEAVListener@Logger@gte@@PEAX@1@@Z (0x1402A7F70) ---

// --- Function: ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@0@0AEBV10@@Z (0x1402AD370) ---
void __fastcall std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>>>(
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *const _First,
        std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *const _Last,
        const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *_Val)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *_First_1; // r9
  unsigned __int64 n2; // rdx
  char *_Val_1; // rcx
  unsigned __int64 v7; // rdx

  _First_1 = _First;
  n2 = (unsigned __int64)(_Last - _First + 7) >> 3;
  if ( _First > _Last )
    n2 = 0;
  if ( n2 >= 2 )
  {
    _Val_1 = (char *)_First + 8 * n2 + 0xFFFFFFF8;
    if ( _First_1 > _Val || _Val_1 < (char *)_Val )
    {
      v7 = 8 * (n2 & 0xFFFFFFFFFFFFFFFEuLL);
      memset64(_First_1, *(_QWORD *)_Val, v7 >> 3);
      _First_1 = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)((char *)_First_1 + v7);
    }
  }
  for ( ;
        _First_1 != _Last;
        _First_1 = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)((char *)_First_1 + 8) )
  {
    *(_QWORD *)_First_1 = *(_QWORD *)_Val;
  }
}

// --- End Function: ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHUGainProcessors@GainMixer@vraudio@@@std@@@std@@@std@@@0@0AEBV10@@Z (0x1402AD370) ---

// --- Function: unknown_libname_2 (0x1402ADBA0) ---
// Microsoft VisualC v14 64bit runtime
_QWORD *__fastcall unknown_libname_2(_QWORD *a1, _QWORD *a2)
{
  if ( *a2 < *a1 )
    return a2;
  return a1;
}

// --- End Function: unknown_libname_2 (0x1402ADBA0) ---

// --- Function: sub_1402B1680 (0x1402B1680) ---
_QWORD *__fastcall sub_1402B1680(_QWORD *a1)
{
  a1[1] = "bad array new length";
  *a1 = off_1481A05A8;
  return a1;
}

// --- End Function: sub_1402B1680 (0x1402B1680) ---

// --- Function: sub_1402B9A90 (0x1402B9A90) ---
__int64 __fastcall sub_1402B9A90(int *a1, int a2)
{
  unsigned int v2; // edi
  unsigned int v5; // eax
  unsigned int allocSize; // ecx

  v2 = *a1;
  v5 = *a1;
  allocSize = *a1 + a2;
  if ( a1[1] < allocSize )
  {
    *((_QWORD *)a1 + 2) = sub_147605AA0(*((void **)a1 + 2), allocSize, 0);
    v5 = *a1;
    a1[1] = *a1 + a2;
  }
  *a1 = v5 + a2;
  return v2;
}

// --- End Function: sub_1402B9A90 (0x1402B9A90) ---

// --- Function: LogTraceConditional (0x1402C1000) ---
// Logs a formatted message with level 3 if global logging flags `qword_14981D3D8`
// and `Parameter_3` are enabled and the global logger object `qword_14981D2D0` is
// available. Calls the virtual function at offset +8 of the logger object.
void LogTraceConditional(const char *format_string, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, format_string);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( qword_149B4FCB0 )
      (*(void (__fastcall **)(__int64, __int64, const char *, __int64 *))(*(_QWORD *)qword_149B4FCB0 + 8LL))(
        qword_149B4FCB0,
        3,
        format_string,
        (__int64 *)va);
  }
}

// --- End Function: LogTraceConditional (0x1402C1000) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402D2790 (0x1402D2790) ---
unsigned __int64 __fastcall sub_1402D2790(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 0x10) == *(_DWORD *)(result + 0x18) && (result = *(unsigned int *)(a1 + 0x14), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 0x14) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CB820((volatile signed __int64 *)a1, v3);
    }
  }
  return result;
}

// --- End Function: sub_1402D2790 (0x1402D2790) ---

// --- Function: sub_1402DB100 (0x1402DB100) ---
const ULONG_PTR *__fastcall sub_1402DB100(__int64 a1)
{
  unsigned __int32 v1; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  v1 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 0, 1);
  if ( v1 != 1 )
    return sub_1403DB1F0(a1, v1);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402DB100 (0x1402DB100) ---

// --- Function: ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@2@@Z (0x1402DE6E0) ---
unsigned __int64 __fastcall std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
        unsigned __int64 **a1,
        unsigned __int64 a2,
        unsigned __int64 buf)
{
  std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *_Last; // rcx
  unsigned __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int64 *v8; // rdi
  unsigned __int64 *v9; // rcx
  signed __int64 v10; // rax
  unsigned __int64 result; // rax
  unsigned __int64 buf_1; // [rsp+40h] [rbp+18h] BYREF

  buf_1 = buf;
  _Last = (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)a1[1];
  if ( (_Last
      - (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)*a1) >> 3 >= a2 )
  {
    std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>> *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const,vraudio::GainMixer::GainProcessors>>>>>(
      (std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *const)*a1,
      _Last,
      (const std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,vraudio::GainMixer::GainProcessors> > > > *)&buf_1);
    return result;
  }
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_20;
  v6 = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( v6 )
      v8 = (unsigned __int64 *)allocWithProfilerInfo_w(8 * a2);
    else
      v8 = 0;
    goto LABEL_10;
  }
  if ( v6 + 0x27 < v6 )
LABEL_20:
    sub_1402E1170();
  v7 = allocWithProfilerInfo_w(v6 + 0x27);
  if ( !v7 )
    goto LABEL_18;
  v8 = (unsigned __int64 *)((v7 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v8[0xFFFFFFFF] = v7;
LABEL_10:
  v9 = *a1;
  v10 = a1[2] - *a1;
  if ( !v10 )
    goto LABEL_15;
  if ( (unsigned __int64)(8 * v10) >= 0x1000 )
  {
    if ( (unsigned __int64)v9 - v9[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v9 = (unsigned __int64 *)v9[0xFFFFFFFF];
      goto LABEL_14;
    }
LABEL_18:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_14:
  sub_1402A3D30(v9);
LABEL_15:
  result = (unsigned __int64)&v8[v6 / 8];
  *a1 = v8;
  a1[1] = &v8[v6 / 8];
  a1[2] = &v8[v6 / 8];
  if ( v8 != &v8[v6 / 8] )
  {
    do
      *v8++ = buf;
    while ( v8 != (unsigned __int64 *)result );
  }
  return result;
}

// --- End Function: ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAV?$Output@PEBVAudioBuffer@vraudio@@@Node@vraudio@@V?$shared_ptr@VNode@vraudio@@@std@@@std@@@std@@@std@@@2@@Z (0x1402DE6E0) ---

// --- Function: ?_Forced_rehash@?$_Hash@V?$_Umap_traits@HV?$shared_ptr@VAmbisonicMixingEncoderNode@vraudio@@@std@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@2@V?$allocator@U?$pair@$$CBHV?$shared_ptr@VAmbisonicMixingEncoderNode@vraudio@@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z (0x1402E0400) ---
unsigned __int64 __fastcall std::_Hash<std::_Umap_traits<int,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>>>,0>>::_Forced_rehash(
        unsigned __int64 **a1,
        unsigned __int64 a2)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 *buf; // rbx
  unsigned __int64 v5; // rcx
  unsigned __int64 *v6; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 *buf_2; // rcx
  unsigned __int64 *buf_1; // rdx
  unsigned __int64 *v10; // r11
  unsigned __int64 v11; // r9
  int v12; // r8d
  unsigned __int64 *v13; // r8
  unsigned __int64 **v14; // r10
  unsigned __int64 **v15; // r9
  unsigned __int64 **v16; // r10
  _QWORD *v17; // r9
  unsigned __int64 **v18; // r8
  unsigned __int64 *v19; // r10
  unsigned __int64 **v20; // r9
  unsigned __int64 **v21; // r8

  _BitScanReverse64(&v3, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v3 )
    std::_Xlength_error("invalid hash bucket count");
  buf = a1[1];
  _BitScanReverse64(&v5, (a2 - 1) | 1);
  v6 = (unsigned __int64 *)(1LL << ((unsigned __int8)v5 + 1));
  std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
    a1 + 3,
    2LL * (_QWORD)v6,
    (unsigned __int64)buf);
  a1[7] = v6;
  result = (unsigned __int64)v6 + 0xFFFFFFFF;
  a1[6] = (unsigned __int64 *)((char *)v6 + 0xFFFFFFFF);
  buf_2 = (unsigned __int64 *)*a1[1];
  for ( buf_1 = buf_2; buf_1 != buf; buf_2 = buf_1 )
  {
    buf_1 = (unsigned __int64 *)*buf_1;
    result = *((unsigned __int8 *)buf_2 + 0x13);
    v10 = &a1[3][2
               * ((unsigned __int64)a1[6]
                & (0x100000001B3LL
                 * (result
                  ^ (0x100000001B3LL
                   * (*((unsigned __int8 *)buf_2 + 0x12)
                    ^ (0x100000001B3LL
                     * (*((unsigned __int8 *)buf_2 + 0x11)
                      ^ (0x100000001B3LL * (*((unsigned __int8 *)buf_2 + 0x10) ^ 0xCBF29CE484222325uLL)))))))))];
    v11 = *v10;
    if ( (unsigned __int64 *)*v10 == buf )
    {
      *v10 = (unsigned __int64)buf_2;
      v10[1] = (unsigned __int64)buf_2;
    }
    else
    {
      result = v10[1];
      v12 = *((_DWORD *)buf_2 + 4);
      if ( v12 == *(_DWORD *)(result + 0x10) )
      {
        v13 = *(unsigned __int64 **)result;
        if ( *(unsigned __int64 **)result != buf_2 )
        {
          v14 = (unsigned __int64 **)buf_2[1];
          *v14 = buf_1;
          v15 = (unsigned __int64 **)buf_1[1];
          *v15 = v13;
          result = v13[1];
          *(_QWORD *)result = buf_2;
          v13[1] = (unsigned __int64)v15;
          buf_1[1] = (unsigned __int64)v14;
          buf_2[1] = result;
        }
        v10[1] = (unsigned __int64)buf_2;
      }
      else if ( v11 == result )
      {
LABEL_12:
        v16 = (unsigned __int64 **)buf_2[1];
        *v16 = buf_1;
        v17 = (_QWORD *)buf_1[1];
        *v17 = result;
        v18 = *(unsigned __int64 ***)(result + 8);
        *v18 = buf_2;
        *(_QWORD *)(result + 8) = v17;
        buf_1[1] = (unsigned __int64)v16;
        buf_2[1] = (unsigned __int64)v18;
        *v10 = (unsigned __int64)buf_2;
      }
      else
      {
        while ( 1 )
        {
          result = *(_QWORD *)(result + 8);
          if ( v12 == *(_DWORD *)(result + 0x10) )
            break;
          if ( v11 == result )
            goto LABEL_12;
        }
        v19 = *(unsigned __int64 **)result;
        v20 = (unsigned __int64 **)buf_2[1];
        *v20 = buf_1;
        v21 = (unsigned __int64 **)buf_1[1];
        *v21 = v19;
        result = v19[1];
        *(_QWORD *)result = buf_2;
        v19[1] = (unsigned __int64)v21;
        buf_1[1] = (unsigned __int64)v20;
        buf_2[1] = result;
      }
    }
  }
  return result;
}

// --- End Function: ?_Forced_rehash@?$_Hash@V?$_Umap_traits@HV?$shared_ptr@VAmbisonicMixingEncoderNode@vraudio@@@std@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@2@V?$allocator@U?$pair@$$CBHV?$shared_ptr@VAmbisonicMixingEncoderNode@vraudio@@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z (0x1402E0400) ---

// --- Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
        __int64 **a1,
        __int64 a2,
        __int64 a3)
{
  __int64 *v4; // r11
  __int64 *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (__int64 *)((char *)a1[1] + 1);
  v4 = *a1;
  v6 = *(__int64 **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 0x18) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (__int64 *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (__int64 *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 0x18LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 0x18) )
      {
        v13 = *(_QWORD **)(v9 + 0x10);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 0x10) = *v13;
          if ( !*(_BYTE *)(*v13 + 0x19LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = (__int64)v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 0x10LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 0x19) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v12 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 0x18) )
      {
        v19 = *(_QWORD *)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = *(_QWORD *)(v19 + 0x10);
          v20 = *(_QWORD *)(v19 + 0x10);
          if ( !*(_BYTE *)(v20 + 0x19) )
            *(_QWORD *)(v20 + 8) = v9;
          *(_QWORD *)(v19 + 8) = *(_QWORD *)(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(__int64 **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          *(_QWORD *)(v19 + 0x10) = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 0x18LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 0x19LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == (_QWORD *)(*a1)[1] )
        {
          (*a1)[1] = (__int64)v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 0x18) = 1;
      *(_BYTE *)(v11 + 0x18) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 0x18LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 0x18) = 1;
  return a3;
}

// --- End Function: ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBVCoord@math@v8_1@openvdb@@UNodeStruct@?$RootNode@V?$InternalNode@V?$InternalNode@V?$LeafNode@V?$Vec4@M@math@v8_1@openvdb@@$02@tree@v8_1@openvdb@@$03@tree@v8_1@openvdb@@$04@tree@v8_1@openvdb@@@tree@34@@std@@PEAX@std@@@2@QEAU32@@Z (0x1402E0C00) ---

// --- Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---
void __fastcall __noreturn stdext::exception::_Raise(stdext::exception *this)
{
  if ( std::_Raise_handler )
    std::_Raise_handler(this);
  (*(void (__fastcall **)(stdext::exception *))(*(_QWORD *)this + 0x10LL))(this);
  invoke_watson(0, 0, 0, 0, 0);
}

// --- End Function: ?_Raise@exception@stdext@@QEBAXXZ (0x1402E0F50) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_7 (0x1402E11B0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_7()
{
  std::_Xlength_error("map/set too long");
}

// --- End Function: unknown_libname_7 (0x1402E11B0) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: unknown_libname_11 (0x1402E1FB0) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_11()
{
  std::_Xout_of_range("invalid vector subscript");
  JUMPOUT(0x1402E1FC0LL);
}

// --- End Function: unknown_libname_11 (0x1402E1FB0) ---

// --- Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---
// Microsoft VisualC v14 64bit runtime
__int64 __fastcall __crt_strtox::maximum_signed_value(__crt_strtox *this)
{
  return 0x7FFFFFFFFFFFFFFFLL;
}

// --- End Function: ?maximum_signed_value@__crt_strtox@@YA_J_K@Z (0x1402E37E0) ---

// --- Function: unknown_libname_473 (0x1402E37F0) ---
// Microsoft VisualC v14 64bit runtime
// Microsoft VisualC 64bit universal runtime
unsigned __int64 unknown_libname_473()
{
  return 0xFFFFFFFFFFFFFFFFuLL;
}

// --- End Function: unknown_libname_473 (0x1402E37F0) ---

// --- Function: sub_1402FACB0 (0x1402FACB0) ---
unsigned __int64 __fastcall sub_1402FACB0(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  unsigned __int64 result; // rax

  if ( a2 > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_11;
  v3 = 4 * a2;
  if ( 4 * a2 < 0x1000 )
  {
    if ( v3 )
      v6 = allocWithProfilerInfo_w(4 * a2);
    else
      v6 = 0;
    goto LABEL_10;
  }
  if ( v3 + 0x27 < v3 )
LABEL_11:
    sub_1402E1170();
  v4 = allocWithProfilerInfo_w(v3 + 0x27);
  v5 = v4;
  if ( !v4 )
    invalid_parameter_noinfo_noreturn();
  v6 = (v4 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v6 - 8) = v5;
LABEL_10:
  *a1 = v6;
  a1[1] = v6;
  result = v3 + v6;
  a1[2] = result;
  return result;
}

// --- End Function: sub_1402FACB0 (0x1402FACB0) ---

// --- Function: sub_140307340 (0x140307340) ---
char *__fastcall sub_140307340(unsigned __int64 *a1, char *a2, unsigned __int64 a3)
{
  void *v5; // rcx
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdi
  char *result; // rax
  unsigned __int64 v12; // rsi
  char *v13; // rdi
  unsigned __int64 v14; // rbx

  v5 = (void *)*a1;
  v7 = (__int64)(a1[2] - (_QWORD)v5) >> 2;
  if ( a3 <= v7 )
  {
    v12 = (__int64)(a1[1] - (_QWORD)v5) >> 2;
    if ( a3 <= v12 )
    {
      v14 = (unsigned __int64)v5 + 4 * a3;
      result = (char *)memmove(v5, a2, 4 * a3);
      a1[1] = v14;
    }
    else
    {
      memmove(v5, a2, 4 * v12);
      v13 = (char *)a1[1];
      memmove(v13, &a2[4 * v12], 4 * (a3 - v12));
      result = &v13[4 * (a3 - v12)];
      a1[1] = (unsigned __int64)result;
    }
  }
  else
  {
    v8 = 0x3FFFFFFFFFFFFFFFLL;
    if ( a3 > 0x3FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = v7 >> 1;
    if ( v7 <= 0x3FFFFFFFFFFFFFFFLL - (v7 >> 1) )
    {
      v8 = v9 + v7;
      if ( v9 + v7 < a3 )
        v8 = a3;
    }
    if ( v5 )
    {
      if ( 4 * v7 >= 0x1000 )
      {
        if ( (unsigned __int64)v5 - *((_QWORD *)v5 + 0xFFFFFFFF) - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v5 = (void *)*((_QWORD *)v5 + 0xFFFFFFFF);
      }
      sub_1402A3D30(v5);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    sub_1402FACB0(a1, v8);
    v10 = *a1;
    memmove((void *)*a1, a2, 4 * a3);
    result = (char *)(4 * a3 + v10);
    a1[1] = (unsigned __int64)result;
  }
  return result;
}

// --- End Function: sub_140307340 (0x140307340) ---

// --- Function: sub_140307890 (0x140307890) ---
char *__fastcall sub_140307890(__int64 a1, _WORD *a2)
{
  char *v2; // rsi
  char *v4; // rcx
  char *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r14
  __int64 v12; // r12
  _WORD *v13; // rdi
  void *v14; // rcx
  char *v15; // r8
  char *v16; // rdx
  char *v17; // rbp
  size_t Size; // r8

  v2 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 0x10);
  if ( v2 == v4 )
  {
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    v8 = (__int64)&v2[-*(_QWORD *)a1] >> 1;
    if ( v8 == 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = (__int64)&v4[-*(_QWORD *)a1] >> 1;
    v10 = v9 >> 1;
    v11 = v8 + 1;
    if ( v9 <= 0x7FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    {
      v7 = v10 + v9;
      if ( v10 + v9 < v11 )
        v7 = v8 + 1;
    }
    v12 = v7;
    v13 = (_WORD *)sub_140391AB0(a1, 2 * v7);
    v13[v8] = *a2;
    v14 = v13;
    v15 = *(char **)(a1 + 8);
    v16 = *(char **)a1;
    v17 = (char *)&v13[v8];
    if ( v2 == v15 )
    {
      Size = v15 - v16;
    }
    else
    {
      memmove(v13, v16, v2 - v16);
      v14 = v17 + 2;
      Size = *(_QWORD *)(a1 + 8) - (_QWORD)v2;
      v16 = v2;
    }
    memmove(v14, v16, Size);
    if ( *(_QWORD *)a1 )
      sub_1403A3120(a1, *(const void **)a1, 2 * ((__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 1));
    *(_QWORD *)a1 = v13;
    result = v17;
    *(_QWORD *)(a1 + 8) = &v13[v11];
    *(_QWORD *)(a1 + 0x10) = &v13[v12];
  }
  else
  {
    *(_WORD *)v2 = *a2;
    result = *(char **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result + 2;
  }
  return result;
}

// --- End Function: sub_140307890 (0x140307890) ---

// --- Function: sub_1403084D0 (0x1403084D0) ---
void __fastcall sub_1403084D0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  _QWORD *v6; // rdi

  v3 = a3;
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    sub_1403084D0(a1, a2, v3[2]);
    v6 = v3;
    v3 = (__int64 *)*v3;
    sub_140370D10(v6 + 5);
    sub_1402A3D30(v6);
  }
}

// --- End Function: sub_1403084D0 (0x1403084D0) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14031FE20 (0x14031FE20) ---
char __fastcall sub_14031FE20(_QWORD *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  v1 = *a1 & 0xFFFFFFFFFFFFLL;
  v2 = sub_1403B4B50(v1);
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
  {
    payload_ptr_state1 = sub_1403B0A40(v1);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( *(_WORD *)(v2 + 4) == 3 )
    {
      v3 = (_QWORD *)sub_1403B0A40(v1);
      return check_thread_state_and_value_not_equal(v3);
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  payload_ptr_state2 = sub_1403B0A40(v1);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: sub_14031FE20 (0x14031FE20) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 0x6000 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_140347820 (0x140347820) ---
ARLabelMovementType *__fastcall sub_140347820(__int64 *a1, _BYTE *a2, __m256i *a3)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rdi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  void *v15; // rcx
  ARLabelMovementType *v16; // r14
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  _BYTE *v20; // rcx
  ARLabelMovementType *result; // rax

  v4 = (unsigned __int64)&a2[-*a1];
  v5 = (a1[1] - *a1) >> 5;
  if ( v5 == 0x7FFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 5;
  v10 = v9 >> 1;
  if ( v9 > 0x7FFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_24;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 0x20 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = v14;
  v16 = (ARLabelMovementType *)((char *)v14 + (v4 & 0xFFFFFFFFFFFFFFE0uLL));
  *(__m256i *)v16 = *a3;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
    __asm { vzeroupper }
  }
  else
  {
    __asm { vzeroupper }
    memmove(v14, v18, a2 - v18);
    v15 = v16 + 8;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v15, v18, Size);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v20[-*((_QWORD *)v20 + 0xFFFFFFFF) - 8] <= 0x1F )
    {
      v20 = (_BYTE *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v14;
  result = v16;
  a1[1] = (__int64)&v14[4 * v8];
  a1[2] = (__int64)&v14[allocSize / 8];
  return result;
}

// --- End Function: sub_140347820 (0x140347820) ---

// --- Function: sub_14035B140 (0x14035B140) ---
_QWORD *__fastcall sub_14035B140(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  v2 = *a2;
  *a2 = (__int64)&qword_149B3B33C + 4;
  *a1 = v2;
  return a1;
}

// --- End Function: sub_14035B140 (0x14035B140) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_140360130 (0x140360130) ---
_DWORD *__fastcall sub_140360130(_DWORD *a1)
{
  *a1 = 0xF0000000;
  return a1;
}

// --- End Function: sub_140360130 (0x140360130) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140378B00 (0x140378B00) ---
_QWORD *__fastcall sub_140378B00(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4; // rcx

  if ( a1 != a2 )
  {
    v4 = (_QWORD *)*a1;
    if ( v4 )
    {
      if ( (unsigned __int64)(2 * ((__int64)(a1[2] - (_QWORD)v4) >> 1)) >= 0x1000 )
      {
        if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v4 = (_QWORD *)v4[0xFFFFFFFF];
      }
      sub_1402A3D30(v4);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = *a2;
    a1[1] = a2[1];
    a1[2] = a2[2];
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return a1;
}

// --- End Function: sub_140378B00 (0x140378B00) ---

// --- Function: sub_140378C90 (0x140378C90) ---
const void **__fastcall sub_140378C90(const void **a1, const void **a2)
{
  _QWORD *v4; // rcx

  if ( a1 != a2 )
  {
    v4 = *a1;
    if ( v4 )
    {
      if ( (((_BYTE *)a1[2] - (_BYTE *)v4) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v4 = (_QWORD *)v4[0xFFFFFFFF];
      }
      sub_1402A3D30(v4);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = *a2;
    a1[1] = a2[1];
    a1[2] = a2[2];
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return a1;
}

// --- End Function: sub_140378C90 (0x140378C90) ---

// --- Function: sub_1403912C0 (0x1403912C0) ---
char __fastcall sub_1403912C0(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+38h] [rbp+10h] BYREF

  v3 = a2;
  if ( (_WORD)a2 == 0xFFFF )
    return 0;
  else
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)qword_149B4FBF8 + 0x70LL))(
             qword_149B4FBF8,
             a1,
             &v3);
}

// --- End Function: sub_1403912C0 (0x1403912C0) ---

// --- Function: sub_140391AB0 (0x140391AB0) ---
__int64 __fastcall sub_140391AB0(__int64 a1, unsigned __int64 allocSize)
{
  __m256i *v3; // rsi
  unsigned __int64 n0x40; // rbp
  __int64 result; // rax
  unsigned __int64 n0x40_1; // r9
  unsigned __int64 n0x4000; // rbx
  __int64 v8; // rcx
  unsigned __int64 n0x4000_1; // rcx
  unsigned __int64 n0x4000_2; // r8
  unsigned __int64 n0x40_2; // rcx
  unsigned __int64 n0x4000_3; // rax
  int v13; // eax
  unsigned __int64 v14; // rdx
  unsigned int v15; // edi
  _QWORD v16[2]; // [rsp+30h] [rbp-38h] BYREF
  _QWORD v17[4]; // [rsp+40h] [rbp-28h] BYREF
  const char *p_CigTemporaryAllocator; // [rsp+78h] [rbp+10h] BYREF

  v3 = (__m256i *)sub_1403B38D0();
  n0x40 = (allocSize >> 8) + ((_BYTE)allocSize != 0);
  if ( n0x40 < 0x4000 )
  {
    n0x40_1 = 0;
    n0x4000 = 0;
    if ( n0x40 <= 0x40 )
      goto LABEL_7;
    while ( v3[1].m256i_i64[(n0x4000 >> 6) + 1] )
    {
      n0x4000 += 0x40LL;
      if ( n0x4000 >= 0x4000 )
        goto LABEL_2;
    }
LABEL_7:
    while ( n0x40_1 != n0x40 )
    {
      v8 = v3[1].m256i_i64[(n0x4000 >> 6) + 1];
      if ( _bittest64(&v8, n0x4000 & 0x3F) )
        n0x40_1 = 0xFFFFFFFFFFFFFFFFuLL;
      ++n0x4000;
      ++n0x40_1;
      if ( n0x4000 >= 0x4000 )
      {
        if ( n0x40_1 != n0x40 )
          goto LABEL_2;
        break;
      }
    }
    n0x4000_1 = n0x4000;
    n0x4000_2 = n0x4000 - n0x40_1;
    if ( n0x4000 >= ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      n0x4000_1 = (n0x4000_2 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40_2 = n0x4000_1 - n0x4000_2;
    if ( (n0x4000_2 & 0x3F) != 0 || n0x40_2 < 0x40 )
    {
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= ((1LL << n0x40_2) - 1) << ((n0x4000 - n0x40_1) & 0x3F);
      n0x4000_2 = ((n0x4000 - n0x40_1) & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ;
          n0x4000_2 + 0x40 <= (n0x4000 & 0xFFFFFFFFFFFFFFC0uLL);
          v3[1].m256i_i64[(n0x4000_3 >> 6) + 1] = 0xFFFFFFFFFFFFFFFFuLL )
    {
      n0x4000_3 = n0x4000_2;
      n0x4000_2 += 0x40LL;
    }
    if ( n0x4000_2 < n0x4000 )
      v3[1].m256i_i64[(n0x4000_2 >> 6) + 1] |= (1LL << ((__int64)n0x4000 % 0x40)) - 1;
    if ( !v3->m256i_i64[0] )
    {
      v16[0] = 0x200000;
      v17[0] = v16;
      v16[1] = 0;
      v17[1] = v17;
      v13 = sub_14056DB80((__int64)v17);
      p_CigTemporaryAllocator = "CigTemporaryAllocator";
      *v3 = *(__m256i *)sub_14056DBC0((__int64)v17, 0x400000, v13, &p_CigTemporaryAllocator, 0, 0);
    }
    v14 = v3[1].m256i_u32[0];
    if ( n0x4000 << 8 > v14 )
    {
      v15 = -v3->m256i_i32[5] & (((_DWORD)n0x4000 << 8) - v14 + v3->m256i_i32[5] - 1);
      __asm { vzeroupper }
      sub_14056DA40((__int64)v3, v3->m256i_i64[0] + v14, v15);
      v3[1].m256i_i32[0] += v15;
    }
    result = v3->m256i_i64[0] + ((n0x4000 - n0x40) << 8);
  }
  else
  {
LABEL_2:
    result = allocWithProfilerInfo(allocSize, 0);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_140391AB0 (0x140391AB0) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 0x18);
  v5 = *(char **)(v2 + 0x10);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[0x10 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 0x10 * (v7 >> 1) + 0x10;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 0x18);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 0x3D8LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 + 0xFFFFFFFA;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 0x10) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403A3120 (0x1403A3120) ---
void __fastcall sub_1403A3120(__int64 a1, const void *a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rcx
  unsigned __int64 n0x40; // rcx
  unsigned __int64 v11; // rcx

  v5 = sub_1403B38D0();
  v6 = *(_QWORD *)v5;
  if ( *(_QWORD *)v5 && (unsigned __int64)a2 >= v6 && (unsigned __int64)a2 < v6 + *(unsigned int *)(v5 + 0x20) )
  {
    v7 = ((unsigned __int64)a2 - v6) >> 8;
    v8 = (a3 >> 8) + v7 + ((_BYTE)a3 != 0);
    v9 = v8;
    if ( v8 >= (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40 )
      v9 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    n0x40 = v9 - v7;
    if ( (v7 & 0x3F) != 0 || n0x40 < 0x40 )
    {
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~(((1LL << n0x40) - 1) << (v7 & 0x3F));
      v7 = (v7 & 0xFFFFFFFFFFFFFFC0uLL) + 0x40;
    }
    for ( ; v7 + 0x40 <= (v8 & 0xFFFFFFFFFFFFFFC0uLL); *(_QWORD *)(v5 + 8 * (v11 >> 6) + 0x28) = 0 )
    {
      v11 = v7;
      v7 += 0x40LL;
    }
    if ( v7 < v8 )
      *(_QWORD *)(v5 + 8 * (v7 >> 6) + 0x28) &= ~((1LL << ((__int64)v8 % 0x40)) - 1);
  }
  else
  {
    sub_147605980(a2);
  }
}

// --- End Function: sub_1403A3120 (0x1403A3120) ---

// --- Function: sub_1403AC700 (0x1403AC700) ---
const char *__fastcall sub_1403AC700(int a1)
{
  const char *p_Unknown_Pass; // rax

  switch ( a1 )
  {
    case 0:
      p_Unknown_Pass = "PostNetworkStartUpdate";
      break;
    case 1:
      p_Unknown_Pass = "PrePhysicsUpdate-UpdateZoneHost";
      break;
    case 2:
      p_Unknown_Pass = "PrePhysicsUpdate";
      break;
    case 3:
      p_Unknown_Pass = "PrePhysicsUpdate2";
      break;
    case 4:
      p_Unknown_Pass = "TrackviewInterruptUpdate";
      break;
    case 5:
      p_Unknown_Pass = "PreUpdate";
      break;
    case 6:
      p_Unknown_Pass = "Update-UpdateZoneHosts";
      break;
    case 7:
      p_Unknown_Pass = "Update";
      break;
    case 8:
      p_Unknown_Pass = "PostUpdate";
      break;
    case 9:
      p_Unknown_Pass = "PostAnimationUpdate";
      break;
    case 0xA:
      p_Unknown_Pass = "PreRenderUpdate_AimableController";
      break;
    case 0xB:
      p_Unknown_Pass = "PreRenderUpdate_LocalPlayerAimComponent";
      break;
    case 0xC:
      p_Unknown_Pass = "PreRenderUpdate";
      break;
    case 0xD:
      p_Unknown_Pass = "EndOfFrameUpdate";
      break;
    default:
      __debugbreak();
      p_Unknown_Pass = "Unknown Pass";
      break;
  }
  return p_Unknown_Pass;
}

// --- End Function: sub_1403AC700 (0x1403AC700) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B38D0 (0x1403B38D0) ---
__int64 sub_1403B38D0()
{
  __int64 v0; // rdi
  __int64 result; // rax
  _QWORD *v2; // rbx
  _QWORD *ThreadLocalStoragePointer; // rcx
  __int64 TlsIndex; // rax
  __int64 v5; // rax
  int v6; // ecx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  result = *(_QWORD *)v0;
  if ( !*(_QWORD *)v0 )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0x828u);
    if ( v2 )
    {
      v2[3] = &p_p_p_p_p_p_p_p_p_p_p_Source;
      v2[4] = 0;
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      memset(v2 + 5, 0, 0x800u);
    }
    else
    {
      v2 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)v0 = v2;
    v5 = ThreadLocalStoragePointer[TlsIndex];
    v6 = *(_DWORD *)(v5 + 0xC0);
    if ( (v6 & 1) == 0 )
    {
      *(_DWORD *)(v5 + 0xC0) = v6 | 1;
      _tlregdtor((__int64)sub_1480BD400);
    }
    return *(_QWORD *)v0;
  }
  return result;
}

// --- End Function: sub_1403B38D0 (0x1403B38D0) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 0x128LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403B8D70 (0x1403B8D70) ---
__int64 __fastcall sub_1403B8D70(__int64 a1)
{
  return a1 + 0x88;
}

// --- End Function: sub_1403B8D70 (0x1403B8D70) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 v3; // r15
  __int64 v7; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 result; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  v3 = qword_149B4FCF8;
  v7 = NtCurrentTeb_w();
  v8 = *(_QWORD *)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v3 + 0xF8LL))(v3, v32, &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 0xE8LL))(v3, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  result = NtCurrentTeb_w();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(result + 0x20);
  return result;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403CA4D0 (0x1403CA4D0) ---
unsigned __int64 __fastcall sub_1403CA4D0(__int64 a1, unsigned __int64 a2, signed __int64 *a3)
{
  signed __int64 v6; // rdi
  unsigned __int64 v7; // r15
  int v8; // ebp
  signed __int32 v9; // r12d
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  __int64 v12; // rbp
  unsigned __int64 v13; // r9
  int v14; // eax

  v6 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 0x20), a2);
  v7 = v6 + a2;
  if ( v6 + a2 > *(_QWORD *)(a1 + 0x28) )
  {
    v8 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(a1 + 0x48) == v8 )
    {
      ++*(_DWORD *)(a1 + 0x4C);
    }
    else
    {
      v9 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 0x38), 1, 0);
      if ( v9 )
      {
        if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
          sub_1403C3410(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
        else
          sub_1403C3680(a1 + 0x38, v9, "CIGThreadSafeContainer::PushBack");
      }
      else
      {
        *(_QWORD *)(a1 + 0x40) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      }
      *(_DWORD *)(a1 + 0x48) = v8;
    }
    v10 = *(_QWORD *)(a1 + 0x28);
    if ( v7 > v10 )
    {
      v11 = (v7 - v10) % *(_QWORD *)(a1 + 0x30);
      v12 = *(_QWORD *)(a1 + 0x30) + v7 - v10 - v11;
      v13 = *(_QWORD *)(a1 + 0x30) + v7 - v11;
      if ( v13 > *(_QWORD *)(a1 + 8) )
        LogFatalError(
          "Not enough storage reserved for thread safe container. Allocating %zu, Page size %u, Required %zu, Reserved %zu",
          a2,
          *(_DWORD *)(a1 + 0x14),
          v13,
          *(_QWORD *)(a1 + 8));
      sub_14056DA40(a1, *(_QWORD *)a1 + *(_QWORD *)(a1 + 0x28), v12);
      *(_QWORD *)(a1 + 0x28) += v12;
    }
    v14 = *(_DWORD *)(a1 + 0x4C);
    if ( v14 )
    {
      *(_DWORD *)(a1 + 0x4C) = v14 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0x48) = 0xFFFFFFFF;
      sub_1402DB100(a1 + 0x38);
    }
  }
  if ( a3 )
    *a3 = v6;
  return v7 + *(_QWORD *)a1 - a2;
}

// --- End Function: sub_1403CA4D0 (0x1403CA4D0) ---

// --- Function: sub_1403CA640 (0x1403CA640) ---
const ULONG_PTR *__fastcall sub_1403CA640(__int64 a1, const void *a2, size_t Size)
{
  int v6; // esi
  signed __int32 v7; // edi
  __int64 v8; // r14
  __int64 v9; // rdi
  size_t v10; // rcx
  int v11; // eax
  const ULONG_PTR *result; // rax

  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v6 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0);
    if ( v7 )
    {
      if ( *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
        sub_1403C3410(a1, v7, "CWriteCopyUpdateContainerBase::PushBack");
      else
        sub_1403C3680(a1, v7, "CWriteCopyUpdateContainerBase::PushBack");
    }
    else
    {
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    }
    *(_DWORD *)(a1 + 0x10) = v6;
  }
  v8 = *(unsigned int *)(a1 + 0x28LL * *(_QWORD *)(a1 + 0x68) + 0x38);
  v9 = a1 + 0x28LL * *(_QWORD *)(a1 + 0x68);
  v10 = *(unsigned int *)(v9 + 0x3C);
  if ( v8 + Size > v10 )
  {
    if ( (unsigned __int64)(unsigned int)(v10 + *(_DWORD *)(v9 + 0x2C)) > *(_QWORD *)(v9 + 0x20) )
      LogFatalError("Out of Virtual Memory in CWriteCopyUpdateContainer");
    sub_14056DA40(v9 + 0x18, *(_QWORD *)(v9 + 0x18) + *(unsigned int *)(v9 + 0x3C), *(unsigned int *)(v9 + 0x2C));
    *(_DWORD *)(v9 + 0x3C) += *(_DWORD *)(v9 + 0x2C);
  }
  *(_DWORD *)(v9 + 0x38) += Size;
  memcpy((void *)(v8 + *(_QWORD *)(v9 + 0x18)), a2, Size);
  v11 = *(_DWORD *)(a1 + 0x14);
  if ( v11 )
  {
    result = (const ULONG_PTR *)(unsigned int)(v11 - 1);
    *(_DWORD *)(a1 + 0x14) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    return sub_1402DB100(a1);
  }
  return result;
}

// --- End Function: sub_1403CA640 (0x1403CA640) ---

// --- Function: sub_1403CB300 (0x1403CB300) ---
double __fastcall sub_1403CB300(__int64 a1, signed __int64 a2, const char *a3, const char *a4, char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
    return sub_1403CB380(a1, a2, a3, a4);
  else
    return sub_1403CB5B0(a1, a2, a3, a4);
}

// --- End Function: sub_1403CB300 (0x1403CB300) ---

// --- Function: sub_1403CB380 (0x1403CB380) ---
double __fastcall sub_1403CB380(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  _BYTE v19[16]; // [rsp+30h] [rbp-29h] BYREF
  int n0x1600; // [rsp+40h] [rbp-19h] BYREF
  __int64 v21; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v23; // [rsp+50h] [rbp-9h]
  unsigned __int64 v24; // [rsp+58h] [rbp-1h]
  __int64 v25; // [rsp+60h] [rbp+7h]
  __int64 v26; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 0xF8LL))(v4, v19, &v27);
  if ( (a2 & 0x200000) == 0 )
    return result;
  v12 = (unsigned __int64)v11 << 0x20;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 0x124) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n0x1600 = 0x1600;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v21 = 1;
      n2 = 2;
      v23 = __rdtsc();
      qword_149B4B870(
        &n0x1600,
        &word_149B3E384,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        0x92);
      v15 = word_149B3E384;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n0x1600 = 0x1600;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  n2 = 2;
  v23 = __rdtsc();
  qword_149B4B870(
    &n0x1600,
    &word_149B3E388,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    0xB1);
  v15 = word_149B3E388;
LABEL_10:
  HIWORD(n0x1600) = v15;
  qword_149B4B8B0("Lock: %s", a4);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
  qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
  qword_149B4B8B0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 0xE8LL))(v4, v11);
  v24 = __rdtsc();
  return qword_149B4B878(&n0x1600);
}

// --- End Function: sub_1403CB380 (0x1403CB380) ---

// --- Function: sub_1403CB5B0 (0x1403CB5B0) ---
double __fastcall sub_1403CB5B0(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int *p_n0x1600; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  int v15; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v16[3]; // [rsp+34h] [rbp-65h] BYREF
  int n0x1600_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v18; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+50h] [rbp-49h]
  unsigned __int64 v21; // [rsp+58h] [rbp-41h]
  __int64 v22; // [rsp+60h] [rbp-39h]
  __int64 v23; // [rsp+68h] [rbp-31h]
  int n0x1600; // [rsp+90h] [rbp-9h] BYREF
  __int64 v25; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v27; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v28; // [rsp+A8h] [rbp+Fh]
  __int64 v29; // [rsp+B0h] [rbp+17h]
  __int64 v30; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 0x128LL))(qword_149B4FCF8, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n0x1600 = 0x1600;
        v25 = 1;
        n2 = 2;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v27 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x62);
        HIWORD(n0x1600) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", a4);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v16[0] = v10;
        qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n0x1600 = &n0x1600;
        v28 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return result;
    }
    n0x1600_1 = 0x1600;
    v18 = 1;
    n2_1 = 2;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v20 = __rdtsc();
    qword_149B4B870(
      &n0x1600_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      0x4A);
    HIWORD(n0x1600_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", a4);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
    qword_149B4B8B0("Caller: %s", a3);
    v15 = v6;
    qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n0x1600 = &n0x1600_1;
    v21 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_n0x1600);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: sub_1403CB5B0 (0x1403CB5B0) ---

// --- Function: sub_1403CB820 (0x1403CB820) ---
__int64 __fastcall sub_1403CB820(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v8 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
      break;
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
      return result;
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
    return qword_149B3B488(a1);
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
      qword_149B4FCF8,
      &v11,
      &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v7 & (v9 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FCF8 + 0xD8LL))(
             qword_149B4FCF8,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: sub_1403CB820 (0x1403CB820) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(NtCurrentTeb_w() + 0x1C) && qword_149B4FDB8 )
    return sub_1403DCDF0(a1, a2, a3, a4, a5);
  else
    return sub_1403DD0B0(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: sub_1403DCDF0 (0x1403DCDF0) ---
__int64 __fastcall sub_1403DCDF0(__int64 a1, unsigned __int64 a2, __int64 a3, const char *a4, const char *a5)
{
  __int64 v5; // r15
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r14d
  const char *v12; // r13
  bool v13; // zf
  signed __int64 v14; // rax
  __int64 result; // rax
  unsigned __int64 v16; // rdx
  signed __int64 v17; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int64 v19; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-91h] BYREF
  __int64 v22; // [rsp+34h] [rbp-8Dh]
  int n2; // [rsp+3Ch] [rbp-85h]
  unsigned __int64 v24; // [rsp+40h] [rbp-81h]
  unsigned __int64 v25; // [rsp+48h] [rbp-79h]
  __int64 v26; // [rsp+50h] [rbp-71h]
  __int64 v27; // [rsp+58h] [rbp-69h]
  int n0x1600_1; // [rsp+80h] [rbp-41h] BYREF
  __int64 v29; // [rsp+84h] [rbp-3Dh]
  int n2_1; // [rsp+8Ch] [rbp-35h]
  unsigned __int64 v31; // [rsp+90h] [rbp-31h]
  unsigned __int64 v32; // [rsp+98h] [rbp-29h]
  __int64 v33; // [rsp+A0h] [rbp-21h]
  __int64 v34; // [rsp+A8h] [rbp-19h]
  _BYTE v35[64]; // [rsp+D0h] [rbp+Fh] BYREF
  char v36; // [rsp+120h] [rbp+5Fh] BYREF
  __int64 v37; // [rsp+130h] [rbp+6Fh]

  v37 = a3;
  v5 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v5 + 0xF8LL))(v5, v35, &v36);
  v12 = a5;
  do
  {
    while ( (a2 & 0x2003FF) != 0 )
    {
      v16 = (unsigned __int64)v11 << 0x30;
      if ( (a2 & 0xFFFF000000000000uLL) != 0 )
      {
        *(_DWORD *)(v10 + 0x124) = HIWORD(a2);
        v17 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v16 | a2 & 0xFFFFFFFFFFFFLL, a2);
        v13 = a2 == v17;
        a2 = v17;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v22 = 1;
          n2 = 2;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v24 = __rdtsc();
          qword_149B4B870(
            &n0x1600,
            &word_149B3E394,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x18D);
          HIWORD(n0x1600) = word_149B3E394;
          qword_149B4B8B0("Lock: %s", v12);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v25 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v10 + 0x124) = 0xFFFFFFFF;
        v19 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v16, a2);
        v13 = a2 == v19;
        a2 = v19;
        if ( v13 )
        {
          n0x1600_1 = 0x1600;
          v29 = 1;
          n2_1 = 2;
          v32 = 0;
          v33 = 0;
          v34 = 0;
          v31 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E398,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x1AE);
          HIWORD(n0x1600_1) = word_149B3E398;
          qword_149B4B8B0("Lock: %s", v12);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a4);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 0xE8LL))(v5, v11);
          a2 = *(_QWORD *)a1;
          v11 = *(_DWORD *)(v10 + 0x11C);
          v32 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | 0x200000, a2);
    v13 = a2 == v14;
    a2 = v14;
  }
  while ( !v13 );
  result = v37;
  *(_QWORD *)(a1 + 8) = v37;
  return result;
}

// --- End Function: sub_1403DCDF0 (0x1403DCDF0) ---

// --- Function: sub_1403DD0B0 (0x1403DD0B0) ---
signed __int64 __fastcall sub_1403DD0B0(__int64 a1, signed __int64 a2, __int64 a3, const char *a4, const char *a5)
{
  char v5; // r14
  signed __int64 v9; // rcx
  bool v10; // zf
  signed __int64 result; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  int v13; // esi
  signed __int64 v14; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int v16; // [rsp+38h] [rbp-81h] BYREF
  _DWORD v17[3]; // [rsp+3Ch] [rbp-7Dh] BYREF
  int n0x1600; // [rsp+48h] [rbp-71h] BYREF
  __int64 v19; // [rsp+4Ch] [rbp-6Dh]
  int n2; // [rsp+54h] [rbp-65h]
  unsigned __int64 v21; // [rsp+58h] [rbp-61h]
  unsigned __int64 v22; // [rsp+60h] [rbp-59h]
  __int64 v23; // [rsp+68h] [rbp-51h]
  __int64 v24; // [rsp+70h] [rbp-49h]
  int n0x1600_1; // [rsp+98h] [rbp-21h] BYREF
  __int64 v26; // [rsp+9Ch] [rbp-1Dh]
  int n2_1; // [rsp+A4h] [rbp-15h]
  unsigned __int64 v28; // [rsp+A8h] [rbp-11h]
  unsigned __int64 v29; // [rsp+B0h] [rbp-9h]
  __int64 v30; // [rsp+B8h] [rbp-1h]
  __int64 v31; // [rsp+C0h] [rbp+7h]

  v5 = 0;
  do
  {
    while ( 1 )
    {
      if ( (a2 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 0x128LL))(qword_149B4FCF8, a1);
      if ( (a2 & 0x2003FF) == 0 )
        break;
      if ( v5 )
      {
        n0x1600 = 0x1600;
        v19 = 1;
        n2 = 2;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v21 = __rdtsc();
        qword_149B4B870(
          &n0x1600,
          &word_149B3E38C,
          "Wait For WLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          0x143);
        HIWORD(n0x1600) = word_149B3E38C;
        qword_149B4B8B0("Lock: %s", a5);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a4);
        v16 = a2;
        qword_149B3B480(a1, &v16, 4, 0xFFFFFFFFLL);
        a2 = *(_QWORD *)a1;
        v22 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v13 = a2 + 0x400000;
        v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 + 0x400000, a2);
        v10 = a2 == v14;
        a2 = v14;
        if ( v10 )
        {
          v5 = 1;
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          qword_149B4B870(
            &n0x1600_1,
            &word_149B3E390,
            "Wait For WLock",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
            0x15D);
          HIWORD(n0x1600_1) = word_149B3E390;
          qword_149B4B8B0("Lock: %s", a5);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a4);
          v17[0] = v13;
          qword_149B3B480(a1, v17, 4, 0xFFFFFFFFLL);
          a2 = *(_QWORD *)a1;
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v9 = (a2 | 0x200000) - 0x400000;
    if ( !v5 )
      v9 = a2 | 0x200000;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v9, a2);
    v10 = a2 == result;
    a2 = result;
  }
  while ( !v10 );
  *(_QWORD *)(a1 + 8) = a3;
  return result;
}

// --- End Function: sub_1403DD0B0 (0x1403DD0B0) ---

// --- Function: sub_1403DD380 (0x1403DD380) ---
const ULONG_PTR *__fastcall sub_1403DD380(__int64 a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // r8
  int v9; // ecx
  __int64 v10; // r8
  unsigned __int64 v11; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v14 - 1)) << 9) + v16 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 |= (unsigned __int64)v5 << 0x30;
    }
    v6 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
      qword_149B3B490(a1);
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v7 = qword_149B4FCF8;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
        qword_149B4FCF8,
        &v15,
        &v13);
      v8 = v15 + ((WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1)) << 9);
      LODWORD(a2) = *(_DWORD *)(v8 + 0x124);
      *(_DWORD *)(v8 + 0x11C) = (unsigned __int16)(WORD2(a2) + v13);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0xD8LL))(v7);
      while ( (_DWORD)a2 != 0xFFFFFFFF )
      {
        v9 = (unsigned __int16)(a2 + v13);
        v10 = v15 + ((unsigned __int64)((unsigned int)a2 & (v13 - 1)) << 9);
        LODWORD(a2) = *(_DWORD *)(v10 + 0x124);
        *(_DWORD *)(v10 + 0x11C) = v9;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0xD8LL))(v7);
      }
    }
  }
  else if ( (a2 & 0xFFC00000) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 0xF8LL))(
      qword_149B4FCF8,
      &v15,
      &v13);
    v11 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v11 & (v13 - 1)) << 9) + v15 + 0x11C) = (unsigned __int16)(v11 + v13);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FCF8 + 0xD8LL))(qword_149B4FCF8, (unsigned int)v11);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DD380 (0x1403DD380) ---

// --- Function: sub_1403DE850 (0x1403DE850) ---
unsigned __int64 __fastcall sub_1403DE850(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // r9

  result = 0x7FFFFFFFFFFFFFFFLL;
  v3 = (__int64)(a1[2] - *a1) >> 1;
  v4 = v3 >> 1;
  if ( v3 <= 0x7FFFFFFFFFFFFFFFLL - (v3 >> 1) )
  {
    result = v4 + v3;
    if ( v4 + v3 < a2 )
      return a2;
  }
  return result;
}

// --- End Function: sub_1403DE850 (0x1403DE850) ---

// --- Function: sub_1403DEA10 (0x1403DEA10) ---
const void *__fastcall sub_1403DEA10(const void **a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // rcx
  const void *result; // rax

  v6 = *a1;
  if ( v6 )
  {
    if ( (unsigned __int64)(2 * (((_BYTE *)a1[2] - (_BYTE *)v6) >> 1)) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - v6[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)v6[0xFFFFFFFF];
    }
    sub_1402A3D30(v6);
  }
  *a1 = (const void *)a2;
  a1[1] = (const void *)(a2 + 2 * a3);
  result = (const void *)(a2 + 2 * a4);
  a1[2] = result;
  return result;
}

// --- End Function: sub_1403DEA10 (0x1403DEA10) ---

// --- Function: sub_1403E2280 (0x1403E2280) ---
__int64 __fastcall sub_1403E2280(__int64 a1, __int64 a2)
{
  return sub_140391AB0(a1, 2 * a2);
}

// --- End Function: sub_1403E2280 (0x1403E2280) ---

// --- Function: sub_1403E4D00 (0x1403E4D00) ---
void __fastcall sub_1403E4D00(__int64 a1, const void *a2, __int64 a3)
{
  sub_1403A3120(a1, a2, 2 * a3);
}

// --- End Function: sub_1403E4D00 (0x1403E4D00) ---

// --- Function: sub_1403F6E80 (0x1403F6E80) ---
void __fastcall sub_1403F6E80(__int64 *a1)
{
  _QWORD *v2; // rcx
  __int64 v3; // rcx
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx

  v2 = (_QWORD *)a1[3];
  if ( v2 )
  {
    if ( ((a1[5] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[3] = 0;
    a1[4] = 0;
    a1[5] = 0;
  }
  v3 = a1[1];
  **(_QWORD **)(v3 + 8) = 0;
  v4 = *(_QWORD **)v3;
  if ( v4 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      sub_1402A3D30(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  sub_1402A3D30((const void *)a1[1]);
}

// --- End Function: sub_1403F6E80 (0x1403F6E80) ---

// --- Function: sub_140418C10 (0x140418C10) ---
bool __fastcall sub_140418C10(__int64 a1)
{
  return (*(_DWORD *)(a1 + 8) & 0x10) != 0;
}

// --- End Function: sub_140418C10 (0x140418C10) ---

// --- Function: sub_14042EF40 (0x14042EF40) ---
__int64 __fastcall sub_14042EF40(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  volatile signed __int32 *v4; // rbx
  __int64 result; // rax

  if ( a1 != a2 )
  {
    v3 = a1;
    do
    {
      v4 = *(volatile signed __int32 **)(v3 + 0x10);
      if ( v4 )
      {
        result = (unsigned int)_InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF);
        if ( (_DWORD)result == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v4)(v4);
          result = (unsigned int)_InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF);
          if ( (_DWORD)result == 1 )
            result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
        }
      }
      v3 += 0x18;
    }
    while ( v3 != a2 );
  }
  return result;
}

// --- End Function: sub_14042EF40 (0x14042EF40) ---

// --- Function: sub_140518100 (0x140518100) ---
__int64 __fastcall sub_140518100(__int64 a1)
{
  return a1 + 0xD8;
}

// --- End Function: sub_140518100 (0x140518100) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 0x10);
  if ( v0 )
    return *(_BYTE *)(v0 + 0x42) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 0x12E) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
      n2 = 1;
      break;
    case 9:
    case 0xA:
      n2 = 2;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
      n2 = 3;
      break;
    case 0xF:
    case 0x12:
    case 0x13:
    case 0x41:
      n2 = 0xB;
      break;
    case 0x21:
    case 0x29:
    case 0x2A:
    case 0x30:
    case 0x32:
    case 0x34:
    case 0x35:
    case 0x37:
    case 0x3D:
    case 0x47:
    case 0x48:
    case 0x4C:
      n2 = 0x19;
      break;
    case 0x22:
    case 0x45:
    case 0x60:
    case 0x61:
      n2 = 4;
      break;
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x44:
      n2 = 5;
      break;
    case 0x26:
    case 0x4D:
      n2 = 6;
      break;
    case 0x27:
      n2 = 7;
      break;
    case 0x28:
      n2 = 9;
      break;
    case 0x2C:
    case 0x2D:
    case 0x2F:
    case 0x3C:
    case 0x3E:
    case 0x49:
    case 0x4A:
      n2 = 0xA;
      break;
    case 0x31:
      n2 = 0x1E;
      break;
    case 0x36:
      n2 = 0x15;
      break;
    case 0x38:
    case 0x39:
    case 0x3B:
      n2 = 0x1C;
      break;
    case 0x3A:
    case 0x4F:
    case 0x50:
      n2 = 0xC;
      break;
    case 0x3F:
    case 0x4B:
      n2 = 0x1B;
      break;
    case 0x40:
    case 0x4E:
      n2 = 0x17;
      break;
    case 0x42:
    case 0x43:
      n2 = 0x1A;
      break;
    case 0x46:
      n2 = 0x1D;
      break;
    case 0x52:
    case 0x53:
      n2 = 0xE;
      break;
    case 0x58:
    case 0x59:
      n2 = 0x18;
      break;
    case 0x5A:
    case 0x5B:
      n2 = 0xF;
      break;
    case 0x5C:
      n2 = 0x10;
      break;
    case 0x5D:
    case 0x5E:
    case 0x5F:
      n2 = 0x11;
      break;
    case 0x62:
    case 0x63:
      n2 = 0x12;
      break;
    case 0x64:
      n2 = 0x13;
      break;
    case 0x65:
    case 0x66:
      n2 = 0x14;
      break;
    case 0x67:
      n2 = 0x16;
      break;
    case 0x68:
      n2 = 0x1F;
      break;
    case 0x69:
      n2 = 0x33;
      break;
    case 0x6A:
      n2 = 0x34;
      break;
    case 0x6B:
      n2 = 0x35;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: sub_14056DA40 (0x14056DA40) ---
char __fastcall sub_14056DA40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_1403E2E40(
                                                                       (__int64)"kernel32.dll",
                                                                       (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v3;
  }
  if ( v3(a2, a3, 0x1000, 4) )
    return 1;
  if ( GetLastError() == ERROR_COMMITMENT_LIMIT )
    sub_14056DD10();
  return 0;
}

// --- End Function: sub_14056DA40 (0x14056DA40) ---

// --- Function: sub_14056DB80 (0x14056DB80) ---
__int64 __fastcall sub_14056DB80(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rdx

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if ( *(_QWORD **)a1 != v2 )
  {
    while ( *v1 )
    {
      if ( *v1 == 0x1000 )
        return 0x1000;
      if ( ++v1 == v2 )
        return 0x1000;
    }
  }
  return 0x1000;
}

// --- End Function: sub_14056DB80 (0x14056DB80) ---

// --- Function: sub_14056DBC0 (0x14056DBC0) ---
__int64 __fastcall sub_14056DBC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  __int64 (__fastcall *v6)(_QWORD, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))qword_149B4B040;
  if ( !qword_149B4B040 )
  {
    v6 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64))sub_1403E2E40(
                                                                      (__int64)"kernel32.dll",
                                                                      (__int64)"VirtualAlloc");
    qword_149B4B040 = (__int64)v6;
  }
  *(_QWORD *)a1 = v6(0, a2, 0x2000, 4);
  *(_DWORD *)(a1 + 0x10) = a6;
  *(_QWORD *)(a1 + 0x18) = *a4;
  result = a1;
  *(_DWORD *)(a1 + 0x14) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

// --- End Function: sub_14056DBC0 (0x14056DBC0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = 0xFFFFFFFF;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[0xFFF] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 0x118LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_1405C0E00 (0x1405C0E00) ---
__int64 sub_1405C0E00(unsigned int a1, unsigned int a2, const char *a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( qword_149B4FDB8 && qword_149B4FCA0 )
  {
    if ( a3 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _QWORD, const char *, __int64 *))(*(_QWORD *)qword_149B4FCA0 + 0x158LL))(
               qword_149B4FCA0,
               a1,
               a2,
               0,
               0,
               a3,
               (__int64 *)va);
  }
  return result;
}

// --- End Function: sub_1405C0E00 (0x1405C0E00) ---

// --- Function: sub_1408FBC10 (0x1408FBC10) ---
void __fastcall sub_1408FBC10(__int64 a1)
{
  const void **v2; // rcx
  unsigned __int64 i; // rbx

  sub_147605980(*(const void **)(a1 + 0x10));
  sub_147605980(*(const void **)(a1 + 0x18));
  sub_147605980(*(const void **)(a1 + 0x20));
  v2 = *(const void ***)(a1 + 0x38);
  for ( i = 0; i < (__int64)(*(_QWORD *)(a1 + 0x40) - (_QWORD)v2) >> 3; ++i )
  {
    sub_147605980(v2[i]);
    v2 = *(const void ***)(a1 + 0x38);
  }
  if ( v2 )
  {
    if ( ((*(_QWORD *)(a1 + 0x48) - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)((char *)v2 - (_BYTE *)v2[0xFFFFFFFF] - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (const void **)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    *(_QWORD *)(a1 + 0x38) = 0;
    *(_QWORD *)(a1 + 0x40) = 0;
    *(_QWORD *)(a1 + 0x48) = 0;
  }
}

// --- End Function: sub_1408FBC10 (0x1408FBC10) ---

// --- Function: sub_1411F87F0 (0x1411F87F0) ---
char *__fastcall sub_1411F87F0(__int64 a1, _BYTE *a2, _WORD *a3)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v13; // rax
  char *v14; // rbx
  char *v15; // rcx
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  size_t Size; // r8

  v3 = (__int64)&a2[-*(_QWORD *)a1] >> 1;
  v5 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if ( v5 == 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 1;
  v9 = v8 >> 1;
  v10 = v5 + 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_19;
  v11 = v5 + 1;
  if ( v9 + v8 >= v10 )
    v11 = v9 + v8;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL )
    goto LABEL_19;
  allocSize = 2 * v11;
  if ( 2 * v11 < 0x1000 )
  {
    if ( allocSize )
      v14 = (char *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_14;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_19:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    invalid_parameter_noinfo_noreturn();
  v14 = (char *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)v14 + 0xFFFFFFFF) = v13;
LABEL_14:
  v15 = v14;
  *(_WORD *)&v14[2 * v3] = *a3;
  v16 = *(_BYTE **)(a1 + 8);
  v17 = *(_BYTE **)a1;
  if ( a2 == v16 )
  {
    Size = v16 - v17;
  }
  else
  {
    memmove(v14, v17, a2 - v17);
    v15 = &v14[2 * v3 + 2];
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v15, v17, Size);
  sub_1403DEA10((const void **)a1, (__int64)v14, v10, v11);
  return &v14[2 * v3];
}

// --- End Function: sub_1411F87F0 (0x1411F87F0) ---

// --- Function: sub_14166FBB0 (0x14166FBB0) ---
__int64 __fastcall sub_14166FBB0(const void **a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    if ( (unsigned __int64)(0x78 * (((_BYTE *)a1[2] - (_BYTE *)v2) / 0x78)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_14166FBB0 (0x14166FBB0) ---

// --- Function: sub_14195D2E0 (0x14195D2E0) ---
__int64 __fastcall sub_14195D2E0(__int64 *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    sub_14042EF40(v2, a1[1]);
    v3 = (_QWORD *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_14195D2E0 (0x14195D2E0) ---

// --- Function: sub_141F4E8E0 (0x141F4E8E0) ---
__int64 __fastcall sub_141F4E8E0(__int64 a1)
{
  return a1 + 0xF0;
}

// --- End Function: sub_141F4E8E0 (0x141F4E8E0) ---

// --- Function: sub_142306700 (0x142306700) ---
__int64 __fastcall sub_142306700(__int64 a1)
{
  return a1 + 0x320;
}

// --- End Function: sub_142306700 (0x142306700) ---

// --- Function: sub_142478E00 (0x142478E00) ---
char *__fastcall sub_142478E00(const void **a1, _BYTE *a2, _WORD *a3)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _WORD *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  char *result; // rax

  v3 = (a2 - (_BYTE *)*a1) >> 1;
  v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) >> 1;
  if ( v5 == 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 1;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 2 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = (_WORD *)v14 + v3;
  *v15 = *a3;
  v16 = v14;
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v16 = v15 + 1;
    Size = (_BYTE *)a1[1] - a2;
    v18 = a2;
  }
  memmove(v16, v18, Size);
  v20 = *a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(2 * (((_BYTE *)a1[2] - (_BYTE *)v20) >> 1)) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = v14;
  result = (char *)v14 + 2 * v3;
  a1[1] = (char *)v14 + 2 * v9;
  a1[2] = (char *)v14 + allocSize;
  return result;
}

// --- End Function: sub_142478E00 (0x142478E00) ---

// --- Function: sub_143A965E0 (0x143A965E0) ---
__int64 __fastcall sub_143A965E0(__int64 *a1, _WORD *a2)
{
  __int64 *v3; // [rsp+20h] [rbp-38h]
  __int64 v4; // [rsp+28h] [rbp-30h]
  __int64 v5; // [rsp+48h] [rbp-10h]

  v3 = a1 + 1;
  v4 = a1[1];
  AK::WriteBytesCount::Reserve((AK::WriteBytesCount *)a1);
  *(_WORD *)sub_1402A2B80(2, v4) = *a2;
  v5 = *v3;
  *v3 += 2;
  return v5;
}

// --- End Function: sub_143A965E0 (0x143A965E0) ---

// --- Function: sub_143A96E90 (0x143A96E90) ---
__int64 __fastcall sub_143A96E90(__int64 *a1, _WORD *a2)
{
  if ( a1[1] == a1[2] )
    return sub_143A99AB0(a1, a1[1], a2);
  else
    return sub_143A965E0(a1, a2);
}

// --- End Function: sub_143A96E90 (0x143A96E90) ---

// --- Function: sub_143A99AB0 (0x143A99AB0) ---
__int64 __fastcall sub_143A99AB0(_QWORD *a1, __int64 a2, _WORD *a3)
{
  __int64 v4; // [rsp+20h] [rbp-88h]
  __int64 v6; // [rsp+30h] [rbp-78h]
  _QWORD *v8; // [rsp+40h] [rbp-68h]
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  __int64 v10; // [rsp+58h] [rbp-50h]
  unsigned __int64 v11; // [rsp+70h] [rbp-38h] BYREF
  __int64 v12; // [rsp+78h] [rbp-30h] BYREF
  __int64 v13; // [rsp+80h] [rbp-28h]
  __int64 v14; // [rsp+88h] [rbp-20h]
  _WORD *v15; // [rsp+90h] [rbp-18h]

  v8 = a1 + 1;
  v6 = (a2 - *a1) >> 1;
  v10 = (__int64)(a1[1] - *a1) >> 1;
  v11 = unknown_libname_473() / 2;
  v12 = __crt_strtox::maximum_signed_value((__crt_strtox *)2);
  v13 = *unknown_libname_2(&v12, &v11);
  if ( v10 == v13 )
    unknown_libname_10();
  v9 = sub_1403DE850(a1, v10 + 1);
  v4 = sub_1403E2280((__int64)a1, v9);
  v14 = v4 + 2 * v6 + 2;
  v15 = (_WORD *)sub_1402A2B80(2, v4 + 2 * v6);
  *v15 = *a3;
  if ( a2 == *v8 )
  {
    sub_143AA3510(*a1, *v8, v4, a1);
  }
  else
  {
    sub_143AA3510(*a1, a2, v4, a1);
    sub_143AA3510(a2, *v8, v4 + 2 * v6 + 2, a1);
  }
  sub_143B14C80(a1, v4, v10 + 1, v9);
  return v4 + 2 * v6;
}

// --- End Function: sub_143A99AB0 (0x143A99AB0) ---

// --- Function: sub_143AA3510 (0x143AA3510) ---
char *__fastcall sub_143AA3510(AK::WriteBytesCount *Src_1, char *Src_2, int *_Dest)
{
  char *Src; // [rsp+20h] [rbp-58h]
  __int64 _Dest_1; // [rsp+38h] [rbp-40h]

  Src = (char *)Src_1;
  if ( AK::WriteBytesCount::Reserve(Src_1) )
  {
    _Dest_1 = (__int64)_Dest;
    while ( Src != Src_2 )
    {
      *(_WORD *)sub_1402A2B80(2, _Dest_1) = *(_WORD *)Src;
      _Dest_1 += 2;
      Src += 2;
    }
    return (char *)_Dest_1;
  }
  else
  {
    std::_Copy_memmove<int *,int *>(Src, Src_2, _Dest);
    return (char *)_Dest + 2 * ((Src_2 - Src) >> 1);
  }
}

// --- End Function: sub_143AA3510 (0x143AA3510) ---

// --- Function: sub_143B14C80 (0x143B14C80) ---
char *__fastcall sub_143B14C80(Parameter *Parameter, char *a2, __int64 a3, __int64 a4)
{
  char *result; // rax
  char **v6; // [rsp+30h] [rbp-28h]
  _QWORD *v8; // [rsp+40h] [rbp-18h]

  v8 = Parameter + 1;
  v6 = (char **)(Parameter + 2);
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( *Parameter )
    sub_1403E4D00((__int64)Parameter, *Parameter, (*v6 - (_BYTE *)*Parameter) >> 1);
  *Parameter = a2;
  *v8 = &a2[2 * a3];
  result = &a2[2 * a4];
  *v6 = result;
  return result;
}

// --- End Function: sub_143B14C80 (0x143B14C80) ---

// --- Function: sub_146A0CB20 (0x146A0CB20) ---
__int64 __fastcall sub_146A0CB20(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  __int64 v4; // r8
  volatile signed __int32 *v5; // rbx

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 0x10);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 0x10) = 0;
  v5 = *(volatile signed __int32 **)(a1 + 0x10);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 0x10) = v4;
  if ( !v5 )
    return a1;
  if ( _InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
    if ( _InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
  }
  return a1;
}

// --- End Function: sub_146A0CB20 (0x146A0CB20) ---

// --- Function: sub_146A11EE0 (0x146A11EE0) ---
char *__fastcall sub_146A11EE0(std::vector<short> *a1, char *a2, unsigned __int64 _Newcapacity_1)
{
  char *v5; // rcx
  unsigned __int64 _Newcapacity_2; // r8
  unsigned __int64 _Newcapacity; // rbx
  unsigned __int64 v9; // rdx
  char *v10; // rdi
  char *result; // rax
  unsigned __int64 _Newcapacity_3; // rsi
  char *v13; // rdi
  char *v14; // rbx

  v5 = *(char **)a1;
  _Newcapacity_2 = (__int64)(*((_QWORD *)a1 + 2) - (_QWORD)v5) >> 1;
  if ( _Newcapacity_1 <= _Newcapacity_2 )
  {
    _Newcapacity_3 = (__int64)(*((_QWORD *)a1 + 1) - (_QWORD)v5) >> 1;
    if ( _Newcapacity_1 <= _Newcapacity_3 )
    {
      v14 = &v5[2 * _Newcapacity_1];
      result = (char *)memmove(v5, a2, 2 * _Newcapacity_1);
      *((_QWORD *)a1 + 1) = v14;
    }
    else
    {
      memmove(v5, a2, 2 * _Newcapacity_3);
      v13 = (char *)*((_QWORD *)a1 + 1);
      memmove(v13, &a2[2 * _Newcapacity_3], 2 * (_Newcapacity_1 - _Newcapacity_3));
      result = &v13[2 * (_Newcapacity_1 - _Newcapacity_3)];
      *((_QWORD *)a1 + 1) = result;
    }
  }
  else
  {
    _Newcapacity = 0x7FFFFFFFFFFFFFFFLL;
    if ( _Newcapacity_1 > 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v9 = _Newcapacity_2 >> 1;
    if ( _Newcapacity_2 <= 0x7FFFFFFFFFFFFFFFLL - (_Newcapacity_2 >> 1) )
    {
      _Newcapacity = v9 + _Newcapacity_2;
      if ( v9 + _Newcapacity_2 < _Newcapacity_1 )
        _Newcapacity = _Newcapacity_1;
    }
    if ( v5 )
    {
      if ( 2 * _Newcapacity_2 >= 0x1000 )
      {
        if ( (unsigned __int64)&v5[-*((_QWORD *)v5 + 0xFFFFFFFF) - 8] > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v5 = (char *)*((_QWORD *)v5 + 0xFFFFFFFF);
      }
      sub_1402A3D30(v5);
      *(_QWORD *)a1 = 0;
      *((_QWORD *)a1 + 1) = 0;
      *((_QWORD *)a1 + 2) = 0;
    }
    std::vector<short>::_Buy_raw(a1, _Newcapacity);
    v10 = *(char **)a1;
    memmove(*(void **)a1, a2, 2 * _Newcapacity_1);
    result = &v10[2 * _Newcapacity_1];
    *((_QWORD *)a1 + 1) = result;
  }
  return result;
}

// --- End Function: sub_146A11EE0 (0x146A11EE0) ---

// --- Function: sub_146A12030 (0x146A12030) ---
void __fastcall sub_146A12030(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  _QWORD *v4; // rcx

  if ( a1 != a2 )
  {
    v3 = a1;
    do
    {
      v4 = *(_QWORD **)v3;
      if ( *(_QWORD *)v3 )
      {
        if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(v3 + 0x10) - (_QWORD)v4) >> 1)) >= 0x1000 )
        {
          if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
            invalid_parameter_noinfo_noreturn();
          v4 = (_QWORD *)v4[0xFFFFFFFF];
        }
        sub_1402A3D30(v4);
        *(_QWORD *)v3 = 0;
        *(_QWORD *)(v3 + 8) = 0;
        *(_QWORD *)(v3 + 0x10) = 0;
      }
      v3 += 0x18;
    }
    while ( v3 != a2 );
  }
}

// --- End Function: sub_146A12030 (0x146A12030) ---

// --- Function: sub_146A126F0 (0x146A126F0) ---
_WORD *__fastcall sub_146A126F0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // r15
  __int64 v7; // rdx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r14
  __int64 v12; // rax
  _WORD *v13; // rdi
  _WORD *v14; // r15
  __int64 v15; // rdx
  _WORD *v16; // r8
  __int64 v17; // rcx
  __int64 v18; // rbx
  __int64 i; // rbp
  _QWORD *v20; // r8
  _WORD *result; // rax

  v6 = (a2 - *a1) / 0x48;
  v7 = (a1[1] - *a1) / 0x48;
  if ( v7 == 0x38E38E38E38E38ELL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x48;
  if ( v9 > 0x38E38E38E38E38ELL - (v9 >> 1) )
    goto LABEL_24;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0x38E38E38E38E38ELL )
    goto LABEL_24;
  v11 = 0x48 * v10;
  if ( 0x48 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = (_WORD *)allocWithProfilerInfo_w(0x48 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_24:
    sub_1402E1170();
  v12 = allocWithProfilerInfo_w(v11 + 0x27);
  if ( !v12 )
    goto LABEL_23;
  v13 = (_WORD *)((v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)v13 + 0xFFFFFFFF) = v12;
LABEL_13:
  v14 = &v13[0x24 * v6];
  sub_146A19EB0(a1, v14, a3);
  v15 = a1[1];
  v16 = v13;
  v17 = *a1;
  if ( a2 != v15 )
  {
    sub_146A16B00(v17, a2, v13);
    v15 = a1[1];
    v16 = v14 + 0x24;
    v17 = a2;
  }
  sub_146A16B00(v17, v15, v16);
  v18 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v18 != i; v18 += 0x48 )
      sub_146A1CF50(v18);
    v20 = (_QWORD *)*a1;
    if ( (unsigned __int64)(0x48 * ((a1[2] - *a1) / 0x48)) < 0x1000 )
      goto LABEL_21;
    if ( (unsigned __int64)v20 - v20[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v20 = (_QWORD *)v20[0xFFFFFFFF];
LABEL_21:
      sub_1402A3D30(v20);
      goto LABEL_22;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  *a1 = (__int64)v13;
  a1[1] = (__int64)&v13[0x24 * v8];
  result = v14;
  a1[2] = (__int64)&v13[v11 / 2];
  return result;
}

// --- End Function: sub_146A126F0 (0x146A126F0) ---

// --- Function: sub_146A12910 (0x146A12910) ---
unsigned __int64 __fastcall sub_146A12910(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // r14
  __int64 v7; // rdx
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // r14
  __int64 v16; // rdx
  __int64 v17; // rcx
  const void *v18; // r8
  unsigned __int64 result; // rax

  v6 = (a2 - *a1) / 0x18;
  v7 = (a1[1] - *a1) / 0x18;
  if ( v7 == 0xAAAAAAAAAAAAAAALL )
    unknown_libname_10();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 0x18;
  if ( v9 > 0xAAAAAAAAAAAAAAALL - (v9 >> 1) )
    goto LABEL_23;
  v10 = v8;
  if ( (v9 >> 1) + v9 >= v8 )
    v10 = (v9 >> 1) + v9;
  if ( v10 > 0xAAAAAAAAAAAAAAALL )
    goto LABEL_23;
  v11 = 0x18 * v10;
  if ( 0x18 * v10 < 0x1000 )
  {
    if ( v11 )
      v13 = allocWithProfilerInfo_w(0x18 * v10);
    else
      v13 = 0;
    goto LABEL_13;
  }
  if ( v11 + 0x27 < v11 )
LABEL_23:
    sub_1402E1170();
  v12 = allocWithProfilerInfo_w(v11 + 0x27);
  if ( !v12 )
    goto LABEL_21;
  v13 = (v12 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v12;
LABEL_13:
  v14 = v13;
  v15 = v13 + 0x18 * v6;
  *(_WORD *)v15 = *(_WORD *)a3;
  *(_QWORD *)(v15 + 8) = 0;
  *(_QWORD *)(v15 + 0x10) = 0;
  *(_QWORD *)(v15 + 8) = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(v15 + 0x10) = *(_QWORD *)(a3 + 0x10);
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 0x10) = 0;
  v16 = a1[1];
  v17 = *a1;
  if ( a2 != v16 )
  {
    sub_146A16910(v17, a2, v13, a1);
    v16 = a1[1];
    v14 = v15 + 0x18;
    v17 = a2;
  }
  sub_146A16910(v17, v16, v14, a1);
  if ( *a1 )
  {
    sub_14042EF40(*a1, a1[1]);
    v18 = (const void *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) < 0x1000 )
    {
LABEL_19:
      sub_1402A3D30(v18);
      goto LABEL_20;
    }
    if ( (unsigned __int64)v18 - *((_QWORD *)v18 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v18 = (const void *)*((_QWORD *)v18 + 0xFFFFFFFF);
      goto LABEL_19;
    }
LABEL_21:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_20:
  *a1 = v13;
  result = v15;
  a1[1] = v13 + 0x18 * v8;
  a1[2] = v11 + v13;
  return result;
}

// --- End Function: sub_146A12910 (0x146A12910) ---

// --- Function: sub_146A12EE0 (0x146A12EE0) ---
__int64 __fastcall sub_146A12EE0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 n0x28; // rdx
  __int64 v7; // r12
  __int64 v8; // r15
  __int64 v9; // rsi
  __int64 v10; // r14
  __int64 v11; // r14
  __int64 v12; // rdi
  __int64 result; // rax

  n0x28 = (a3 - a1) / 0x48;
  if ( n0x28 <= 0x28 )
  {
    if ( *(_DWORD *)(a2 + 4) < *(_DWORD *)(a1 + 4) )
      sub_146A1B2A0(a2, a1);
    result = *(unsigned int *)(a2 + 4);
    if ( *(_DWORD *)(a3 + 4) < (unsigned int)result )
    {
      sub_146A1B2A0(a3, a2);
      result = *(unsigned int *)(a1 + 4);
      if ( *(_DWORD *)(a2 + 4) < (unsigned int)result )
        return sub_146A1B2A0(a2, a1);
    }
  }
  else
  {
    v7 = 0x90 * ((n0x28 + 1) >> 3);
    v8 = 0x48 * ((n0x28 + 1) >> 3);
    v9 = v8 + a1;
    v10 = v7 + a1;
    if ( *(_DWORD *)(v8 + a1 + 4) < *(_DWORD *)(a1 + 4) )
      sub_146A1B2A0(v8 + a1, a1);
    if ( *(_DWORD *)(v10 + 4) < *(_DWORD *)(v9 + 4) )
    {
      sub_146A1B2A0(v10, v9);
      if ( *(_DWORD *)(v9 + 4) < *(_DWORD *)(a1 + 4) )
        sub_146A1B2A0(v9, a1);
    }
    if ( *(_DWORD *)(a2 + 4) < *(_DWORD *)(a2 - v8 + 4) )
      sub_146A1B2A0(a2, a2 - v8);
    if ( *(_DWORD *)(v8 + a2 + 4) < *(_DWORD *)(a2 + 4) )
    {
      sub_146A1B2A0(v8 + a2, a2);
      if ( *(_DWORD *)(a2 + 4) < *(_DWORD *)(a2 - v8 + 4) )
        sub_146A1B2A0(a2, a2 - v8);
    }
    v11 = a3 - v7;
    v12 = a3 - v8;
    if ( *(_DWORD *)(a3 - v8 + 4) < *(_DWORD *)(a3 - v7 + 4) )
      sub_146A1B2A0(v12, v11);
    if ( *(_DWORD *)(a3 + 4) < *(_DWORD *)(v12 + 4) )
    {
      sub_146A1B2A0(a3, v12);
      if ( *(_DWORD *)(v12 + 4) < *(_DWORD *)(v11 + 4) )
        sub_146A1B2A0(v12, v11);
    }
    if ( *(_DWORD *)(a2 + 4) < *(_DWORD *)(v9 + 4) )
      sub_146A1B2A0(a2, v9);
    result = *(unsigned int *)(a2 + 4);
    if ( *(_DWORD *)(v12 + 4) < (unsigned int)result )
    {
      sub_146A1B2A0(v12, a2);
      result = *(unsigned int *)(v9 + 4);
      if ( *(_DWORD *)(a2 + 4) < (unsigned int)result )
        return sub_146A1B2A0(a2, v9);
    }
  }
  return result;
}

// --- End Function: sub_146A12EE0 (0x146A12EE0) ---

// --- Function: sub_146A13430 (0x146A13430) ---
_WORD *__fastcall sub_146A13430(__int64 a1, _WORD *a2)
{
  _WORD *v2; // r8
  _WORD *v4; // rbp
  _QWORD *v5; // r15
  unsigned int v6; // r12d
  _WORD *v7; // rdi
  __int16 v8; // bx
  char v9; // r13
  __int64 v10; // rdx
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rax
  const void *v14; // rax
  const void *v15; // rcx
  __int64 v16; // rdx
  char *v17; // rdi
  _QWORD *v18; // rsi
  const void *v19; // rcx
  const void *v20; // rcx
  char v22; // [rsp+20h] [rbp-98h]
  char v23; // [rsp+21h] [rbp-97h]
  char v24; // [rsp+22h] [rbp-96h]
  __int16 v25; // [rsp+24h] [rbp-94h]
  int v26; // [rsp+28h] [rbp-90h]
  _QWORD v27[2]; // [rsp+48h] [rbp-70h] BYREF
  __int64 v28; // [rsp+58h] [rbp-60h]
  const void *v29[2]; // [rsp+60h] [rbp-58h] BYREF
  __int64 v30; // [rsp+70h] [rbp-48h]
  char v31; // [rsp+C0h] [rbp+8h]
  char v33; // [rsp+D8h] [rbp+20h]

  v2 = a2;
  if ( (_WORD *)a1 != a2 )
  {
    v4 = (_WORD *)(a1 + 0x48);
    if ( (_WORD *)(a1 + 0x48) != a2 )
    {
      v5 = (_QWORD *)(a1 + 0x68);
      do
      {
        v6 = *((_DWORD *)v5 + 0xFFFFFFF9);
        v7 = v4;
        v8 = *v4;
        v9 = *((_BYTE *)v5 + 0xFFFFFFE2);
        v10 = v5[1];
        v11 = *v5;
        v25 = *((_WORD *)v5 + 0xFFFFFFF4);
        v31 = *((_BYTE *)v5 + 0xFFFFFFEA);
        v33 = *((_BYTE *)v5 + 0xFFFFFFEB);
        v22 = *((_BYTE *)v5 + 0xFFFFFFEC);
        v26 = *((_DWORD *)v5 + 0xFFFFFFFC);
        v23 = *((_BYTE *)v5 + 0xFFFFFFF4);
        v12 = *((_BYTE *)v5 + 0xFFFFFFF5);
        v5[1] = 0;
        *v5 = 0;
        v24 = v12;
        v13 = v5[0xFFFFFFFF];
        v5[0xFFFFFFFF] = 0;
        v27[0] = v13;
        v14 = (const void *)v5[2];
        v27[1] = v11;
        v15 = (const void *)v5[3];
        v28 = v10;
        v16 = v5[4];
        v5[2] = 0;
        v5[4] = 0;
        v5[3] = 0;
        v29[0] = v14;
        v29[1] = v15;
        v30 = v16;
        if ( v6 >= *(_DWORD *)(a1 + 4) )
        {
          v18 = v5 + 0xFFFFFFF3;
          if ( v6 < *((_DWORD *)v5 + 0xFFFFFFE7) )
          {
            do
            {
              *v7 = *(_WORD *)v18;
              *((_BYTE *)v7 + 2) = *((_BYTE *)v18 + 2);
              *((_DWORD *)v7 + 1) = *((_DWORD *)v18 + 1);
              v7[4] = *((_WORD *)v18 + 4);
              *((_BYTE *)v7 + 0xA) = *((_BYTE *)v18 + 0xA);
              *((_BYTE *)v7 + 0xB) = *((_BYTE *)v18 + 0xB);
              *((_BYTE *)v7 + 0xC) = *((_BYTE *)v18 + 0xC);
              *((_DWORD *)v7 + 4) = *((_DWORD *)v18 + 4);
              *((_BYTE *)v7 + 0x14) = *((_BYTE *)v18 + 0x14);
              *((_BYTE *)v7 + 0x15) = *((_BYTE *)v18 + 0x15);
              sub_140378B00((_QWORD *)v7 + 3, v18 + 3);
              sub_140378C90((const void **)v7 + 6, (const void **)v18 + 6);
              v7 = v18;
              v18 += 0xFFFFFFF7;
            }
            while ( v6 < *((_DWORD *)v18 + 1) );
          }
          v7[4] = v25;
          *((_BYTE *)v7 + 0xA) = v31;
          *((_BYTE *)v7 + 0xB) = v33;
          *((_BYTE *)v7 + 0xC) = v22;
          *((_DWORD *)v7 + 4) = v26;
          *((_BYTE *)v7 + 0x14) = v23;
          *((_BYTE *)v7 + 0x15) = v24;
          *v7 = v8;
          *((_BYTE *)v7 + 2) = v9;
          *((_DWORD *)v7 + 1) = v6;
        }
        else
        {
          if ( v4 != (_WORD *)a1 )
          {
            v17 = (char *)v5 + 0x2C;
            do
            {
              v17 += 0xFFFFFFB8;
              *((_WORD *)v17 + 0xFFFFFFFE) = *((_WORD *)v17 + 0xFFFFFFDA);
              v17[0xFFFFFFFE] = v17[0xFFFFFFB6];
              *(_DWORD *)v17 = *((_DWORD *)v17 + 0xFFFFFFEE);
              *((_WORD *)v17 + 2) = *((_WORD *)v17 + 0xFFFFFFDE);
              v17[6] = v17[0xFFFFFFBE];
              v17[7] = v17[0xFFFFFFBF];
              v17[8] = v17[0xFFFFFFC0];
              *((_DWORD *)v17 + 3) = *((_DWORD *)v17 + 0xFFFFFFF1);
              v17[0x10] = v17[0xFFFFFFC8];
              v17[0x11] = v17[0xFFFFFFC9];
              sub_140378B00(v17 + 0x14, v17 + 0xFFFFFFCC);
              sub_140378C90((const void **)(v17 + 0x2C), (const void **)(v17 + 0xFFFFFFE4));
            }
            while ( v17 + 0xFFFFFFB4 != (char *)a1 );
          }
          v7 = (_WORD *)a1;
          *(_WORD *)(a1 + 8) = v25;
          *(_BYTE *)(a1 + 0xA) = v31;
          *(_BYTE *)(a1 + 0xB) = v33;
          *(_BYTE *)(a1 + 0xC) = v22;
          *(_DWORD *)(a1 + 0x10) = v26;
          *(_BYTE *)(a1 + 0x14) = v23;
          *(_BYTE *)(a1 + 0x15) = v24;
          *(_WORD *)a1 = v8;
          *(_BYTE *)(a1 + 2) = v9;
          *(_DWORD *)(a1 + 4) = v6;
        }
        sub_140378B00((_QWORD *)v7 + 3, v27);
        sub_140378C90((const void **)v7 + 6, v29);
        v19 = v29[0];
        if ( v29[0] )
        {
          if ( ((v30 - (unsigned __int64)v29[0]) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
          {
            v19 = (const void *)*((_QWORD *)v29[0] + 0xFFFFFFFF);
            if ( (unsigned __int64)((char *)v29[0] - (char *)v19 - 8) > 0x1F )
LABEL_22:
              invalid_parameter_noinfo_noreturn();
          }
          sub_1402A3D30(v19);
        }
        v20 = (const void *)v27[0];
        if ( v27[0] )
        {
          if ( (unsigned __int64)(2 * ((v28 - v27[0]) >> 1)) >= 0x1000 )
          {
            v20 = *(const void **)(v27[0] - 8LL);
            if ( (unsigned __int64)(v27[0] - (_QWORD)v20 - 8LL) > 0x1F )
              goto LABEL_22;
          }
          sub_1402A3D30(v20);
        }
        v2 = a2;
        v4 += 0x24;
        v5 += 9;
      }
      while ( v4 != a2 );
    }
  }
  return v2;
}

// --- End Function: sub_146A13430 (0x146A13430) ---

// --- Function: sub_146A13A40 (0x146A13A40) ---
void __fastcall sub_146A13A40(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v4; // r9
  __int64 v5; // rbp
  __int64 v6; // rdi
  __int64 v7; // r10
  _QWORD *v8; // r15
  char v9; // al
  __int64 v10; // r14
  __int16 v11; // bx
  unsigned int v12; // r13d
  __int64 v13; // rdx
  __int64 v14; // rcx
  char v15; // al
  __int64 v16; // rax
  const void *v17; // rax
  const void *v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // r8
  __int64 v21; // rsi
  __int64 v22; // rdi
  __int64 v23; // r14
  __int64 v24; // rsi
  __int64 v25; // rdi
  const void *v26; // rcx
  const void *v27; // rcx
  char v28; // [rsp+20h] [rbp-C8h]
  char v29; // [rsp+21h] [rbp-C7h]
  char v30; // [rsp+22h] [rbp-C6h]
  __int16 v31; // [rsp+24h] [rbp-C4h]
  int v32; // [rsp+28h] [rbp-C0h]
  __int64 v33; // [rsp+30h] [rbp-B8h]
  __int64 v34; // [rsp+38h] [rbp-B0h]
  __int64 v35; // [rsp+40h] [rbp-A8h]
  _QWORD v36[2]; // [rsp+68h] [rbp-80h] BYREF
  __int64 v37; // [rsp+78h] [rbp-70h]
  const void *v38[2]; // [rsp+80h] [rbp-68h] BYREF
  __int64 v39; // [rsp+90h] [rbp-58h]
  _QWORD *v40; // [rsp+A0h] [rbp-48h]
  char v41; // [rsp+F0h] [rbp+8h]
  char v42; // [rsp+F8h] [rbp+10h]
  char v43; // [rsp+108h] [rbp+20h]

  v2 = (unsigned __int128)((a2 - a1) * (__int128)0xE38E38E38E38E39LL) >> 0x40;
  v4 = ((unsigned __int64)v2 >> 0x3F) + (v2 >> 2);
  v34 = v4;
  v5 = v4 >> 1;
  if ( v4 >> 1 > 0 )
  {
    v6 = v4 - 1;
    v7 = (v4 - 1) >> 1;
    v35 = v4 - 1;
    v33 = v7;
    v8 = (_QWORD *)(a1 + 8 * (v5 + 8 * v5 + 4));
    while ( 1 )
    {
      v9 = *((_BYTE *)v8 + 0xFFFFFF9A);
      v8 += 0xFFFFFFF7;
      v41 = v9;
      --v5;
      v40 = v8;
      v10 = v5;
      v11 = *((_WORD *)v8 + 0xFFFFFFF0);
      v12 = *((_DWORD *)v8 + 0xFFFFFFF9);
      v13 = v8[1];
      v14 = *v8;
      v31 = *((_WORD *)v8 + 0xFFFFFFF4);
      v42 = *((_BYTE *)v8 + 0xFFFFFFEA);
      v43 = *((_BYTE *)v8 + 0xFFFFFFEB);
      v28 = *((_BYTE *)v8 + 0xFFFFFFEC);
      v32 = *((_DWORD *)v8 + 0xFFFFFFFC);
      v29 = *((_BYTE *)v8 + 0xFFFFFFF4);
      v15 = *((_BYTE *)v8 + 0xFFFFFFF5);
      v8[1] = 0;
      *v8 = 0;
      v30 = v15;
      v16 = v8[0xFFFFFFFF];
      v8[0xFFFFFFFF] = 0;
      v36[0] = v16;
      v17 = (const void *)v8[2];
      v36[1] = v14;
      v18 = (const void *)v8[3];
      v37 = v13;
      v19 = v8[4];
      v8[2] = 0;
      v8[4] = 0;
      v8[3] = 0;
      v20 = v5;
      v38[0] = v17;
      v38[1] = v18;
      v39 = v19;
      if ( v5 < v7 )
      {
        do
        {
          v10 = 2 * v10 + 2LL - (*(_DWORD *)(a1 + 0x90 * v10 + 0x94) < *(_DWORD *)(a1 + 0x90 * v10 + 0x4C));
          v21 = a1 + 0x48 * v10;
          v22 = a1 + 0x48 * v20;
          *(_WORD *)v22 = *(_WORD *)v21;
          *(_BYTE *)(v22 + 2) = *(_BYTE *)(v21 + 2);
          *(_DWORD *)(v22 + 4) = *(_DWORD *)(v21 + 4);
          *(_WORD *)(v22 + 8) = *(_WORD *)(v21 + 8);
          *(_BYTE *)(v22 + 0xA) = *(_BYTE *)(v21 + 0xA);
          *(_BYTE *)(v22 + 0xB) = *(_BYTE *)(v21 + 0xB);
          *(_BYTE *)(v22 + 0xC) = *(_BYTE *)(v21 + 0xC);
          *(_DWORD *)(v22 + 0x10) = *(_DWORD *)(v21 + 0x10);
          *(_BYTE *)(v22 + 0x14) = *(_BYTE *)(v21 + 0x14);
          *(_BYTE *)(v22 + 0x15) = *(_BYTE *)(v21 + 0x15);
          sub_140378B00((_QWORD *)(v22 + 0x18), (_QWORD *)(v21 + 0x18));
          sub_140378C90((const void **)(v22 + 0x30), (const void **)(v21 + 0x30));
          v20 = v10;
        }
        while ( v10 < v33 );
        v8 = v40;
        v4 = v34;
        v7 = v33;
        v6 = v35;
      }
      if ( v20 == v7 && (v4 & 1) == 0 )
      {
        sub_146A1D000(a1 + 0x48 * v20, a1 + 0x48 * (v4 - 1));
        v20 = v6;
      }
      if ( v5 < v20 )
      {
        do
        {
          v23 = (v20 - 1) >> 1;
          if ( *(_DWORD *)(a1 + 0x48 * v23 + 4) >= v12 )
            break;
          v24 = a1 + 0x48 * v20;
          *(_WORD *)v24 = *(_WORD *)(a1 + 0x48 * v23);
          *(_BYTE *)(v24 + 2) = *(_BYTE *)(a1 + 0x48 * v23 + 2);
          *(_DWORD *)(v24 + 4) = *(_DWORD *)(a1 + 0x48 * v23 + 4);
          *(_WORD *)(v24 + 8) = *(_WORD *)(a1 + 0x48 * v23 + 8);
          *(_BYTE *)(v24 + 0xA) = *(_BYTE *)(a1 + 0x48 * v23 + 0xA);
          *(_BYTE *)(v24 + 0xB) = *(_BYTE *)(a1 + 0x48 * v23 + 0xB);
          *(_BYTE *)(v24 + 0xC) = *(_BYTE *)(a1 + 0x48 * v23 + 0xC);
          *(_DWORD *)(v24 + 0x10) = *(_DWORD *)(a1 + 0x48 * v23 + 0x10);
          *(_BYTE *)(v24 + 0x14) = *(_BYTE *)(a1 + 0x48 * v23 + 0x14);
          *(_BYTE *)(v24 + 0x15) = *(_BYTE *)(a1 + 0x48 * v23 + 0x15);
          sub_140378B00((_QWORD *)(v24 + 0x18), (_QWORD *)(a1 + 0x18 + 0x48 * v23));
          sub_140378C90((const void **)(v24 + 0x30), (const void **)(a1 + 0x30 + 0x48 * v23));
          v20 = v23;
        }
        while ( v5 < v23 );
      }
      v25 = a1 + 0x48 * v20;
      *(_WORD *)v25 = v11;
      *(_BYTE *)(v25 + 2) = v41;
      *(_WORD *)(v25 + 8) = v31;
      *(_BYTE *)(v25 + 0xA) = v42;
      *(_BYTE *)(v25 + 0xB) = v43;
      *(_BYTE *)(v25 + 0xC) = v28;
      *(_DWORD *)(v25 + 0x10) = v32;
      *(_BYTE *)(v25 + 0x14) = v29;
      *(_BYTE *)(v25 + 0x15) = v30;
      *(_DWORD *)(v25 + 4) = v12;
      sub_140378B00((_QWORD *)(v25 + 0x18), v36);
      sub_140378C90((const void **)(v25 + 0x30), v38);
      v26 = v38[0];
      if ( v38[0] )
      {
        if ( ((v39 - (unsigned __int64)v38[0]) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
        {
          v26 = (const void *)*((_QWORD *)v38[0] + 0xFFFFFFFF);
          if ( (unsigned __int64)((char *)v38[0] - (char *)v26 - 8) > 0x1F )
LABEL_22:
            invalid_parameter_noinfo_noreturn();
        }
        sub_1402A3D30(v26);
      }
      v27 = (const void *)v36[0];
      if ( v36[0] )
      {
        if ( (unsigned __int64)(2 * ((v37 - v36[0]) >> 1)) >= 0x1000 )
        {
          v27 = *(const void **)(v36[0] - 8LL);
          if ( (unsigned __int64)(v36[0] - (_QWORD)v27 - 8LL) > 0x1F )
            goto LABEL_22;
        }
        sub_1402A3D30(v27);
      }
      if ( v5 <= 0 )
        return;
      v4 = v34;
      v7 = v33;
      v6 = v35;
    }
  }
}

// --- End Function: sub_146A13A40 (0x146A13A40) ---

// --- Function: sub_146A14530 (0x146A14530) ---
unsigned __int64 *__fastcall sub_146A14530(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // r9
  char **v10; // rsi
  unsigned int v11; // eax
  __int16 v12; // bx
  char v13; // si
  int v14; // r14d
  __int16 v15; // r15
  char v16; // r12
  char v17; // r13
  char *v18; // rax
  char *v19; // rax
  char *v20; // rax
  char **v21; // rax
  const void **v22; // rbx
  char *v23; // rcx
  char *v24; // r14
  char *v25; // rbx
  const void **v26; // r15
  char *v27; // rcx
  char *v28; // r8
  char *v29; // rcx
  char *v30; // rax
  char *v31; // rax
  bool v32; // zf
  char *v33; // rbx
  char *v34; // r8
  char *v35; // r10
  __int16 v36; // bx
  char v37; // r13
  char v38; // r12
  int v39; // r15d
  char v40; // r14
  char v41; // si
  __int64 v42; // rdx
  __int64 v43; // rcx
  char v44; // al
  _BYTE *v45; // rax
  __int64 v46; // rcx
  __int64 v47; // rdx
  char *v48; // rax
  char *v49; // rcx
  _BYTE *v50; // rcx
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // r8
  __int16 v53; // bx
  char v54; // r13
  char v55; // r12
  int v56; // r15d
  char v57; // r14
  char v58; // si
  __int64 v59; // rdx
  __int64 v60; // rcx
  char v61; // al
  _BYTE *v62; // rax
  __int64 v63; // rcx
  __int64 v64; // rdx
  char *v65; // rax
  char *v66; // rcx
  const void *v67; // rcx
  __int16 v68; // bx
  char v69; // r13
  char v70; // r12
  int v71; // r15d
  char v72; // r14
  char v73; // si
  __int64 v74; // rdx
  __int64 v75; // rcx
  _BYTE *v76; // rax
  __int64 v77; // rdx
  __int64 v78; // rcx
  char *v79; // rax
  unsigned __int64 v80; // r9
  __int16 v81; // bx
  char v82; // si
  int v83; // r14d
  __int16 v84; // r15
  char v85; // r12
  char v86; // r13
  char *v87; // rax
  char *v88; // rax
  char *v89; // rax
  char *v90; // rax
  const void **v91; // rbx
  _QWORD *v92; // rcx
  char *v93; // rsi
  char *v94; // rbx
  const void **v95; // r14
  _QWORD *v96; // rcx
  char *v97; // r8
  char *v98; // rcx
  char *v99; // rax
  char *v100; // rax
  char v101; // al
  __int16 v102; // bx
  __int64 v103; // rdx
  __int64 v104; // rcx
  char v105; // r13
  char v106; // r12
  char v107; // r14
  char v108; // si
  int v109; // r15d
  _BYTE *v110; // rax
  __int64 v111; // rcx
  __int64 v112; // rdx
  char *v113; // rax
  char *v114; // rcx
  _BYTE *v115; // r10
  char v116; // al
  __int16 v117; // bx
  __int64 v118; // rdx
  __int64 v119; // rcx
  char v120; // r13
  char v121; // r12
  char v122; // r14
  char v123; // si
  int v124; // r15d
  _BYTE *v125; // rax
  __int64 v126; // rcx
  __int64 v127; // rdx
  char *v128; // rax
  unsigned __int64 *result; // rax
  char v130; // [rsp+20h] [rbp-E0h]
  char v131; // [rsp+20h] [rbp-E0h]
  char v132; // [rsp+20h] [rbp-E0h]
  char v133; // [rsp+20h] [rbp-E0h]
  char v134; // [rsp+20h] [rbp-E0h]
  char v135; // [rsp+20h] [rbp-E0h]
  char v136; // [rsp+20h] [rbp-E0h]
  char v137; // [rsp+22h] [rbp-DEh]
  __int16 v138; // [rsp+22h] [rbp-DEh]
  __int16 v139; // [rsp+22h] [rbp-DEh]
  __int16 v140; // [rsp+22h] [rbp-DEh]
  char v141; // [rsp+22h] [rbp-DEh]
  __int16 v142; // [rsp+22h] [rbp-DEh]
  __int16 v143; // [rsp+22h] [rbp-DEh]
  int v144; // [rsp+24h] [rbp-DCh]
  int v145; // [rsp+24h] [rbp-DCh]
  int v146; // [rsp+24h] [rbp-DCh]
  int v147; // [rsp+24h] [rbp-DCh]
  int v148; // [rsp+24h] [rbp-DCh]
  int v149; // [rsp+24h] [rbp-DCh]
  int v150; // [rsp+24h] [rbp-DCh]
  unsigned __int64 i; // [rsp+28h] [rbp-D8h]
  unsigned __int64 v152; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v153; // [rsp+38h] [rbp-C8h]
  __int16 v154; // [rsp+40h] [rbp-C0h] BYREF
  char v155; // [rsp+42h] [rbp-BEh]
  int v156; // [rsp+44h] [rbp-BCh]
  __int16 v157; // [rsp+48h] [rbp-B8h]
  char v158; // [rsp+4Ah] [rbp-B6h]
  char v159; // [rsp+4Bh] [rbp-B5h]
  char v160; // [rsp+4Ch] [rbp-B4h]
  int v161; // [rsp+50h] [rbp-B0h]
  char v162; // [rsp+54h] [rbp-ACh]
  char v163; // [rsp+55h] [rbp-ABh]
  _BYTE *v164; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v165; // [rsp+60h] [rbp-A0h]
  __int64 v166; // [rsp+68h] [rbp-98h]
  char *v167; // [rsp+70h] [rbp-90h] BYREF
  __int64 v168; // [rsp+78h] [rbp-88h]
  __int64 v169; // [rsp+80h] [rbp-80h]
  char *v170; // [rsp+90h] [rbp-70h]
  char *v171; // [rsp+98h] [rbp-68h]
  char *v172; // [rsp+A0h] [rbp-60h]
  char *v173; // [rsp+A8h] [rbp-58h]
  char *v174; // [rsp+B0h] [rbp-50h]
  char **v175; // [rsp+B8h] [rbp-48h]
  char *v176; // [rsp+C0h] [rbp-40h]
  char v177; // [rsp+E8h] [rbp-18h] BYREF
  char v178; // [rsp+100h] [rbp+0h] BYREF
  char v179; // [rsp+138h] [rbp+38h] BYREF
  char v180; // [rsp+150h] [rbp+50h] BYREF
  char v184; // [rsp+1D8h] [rbp+D8h]
  char v185; // [rsp+1D8h] [rbp+D8h]
  char v186; // [rsp+1D8h] [rbp+D8h]
  char v187; // [rsp+1D8h] [rbp+D8h]
  char v188; // [rsp+1D8h] [rbp+D8h]
  char v189; // [rsp+1D8h] [rbp+D8h]
  char v190; // [rsp+1D8h] [rbp+D8h]

  v3 = a3;
  v4 = a2 + 0x48 * (((__int64)(a3 - a2) / 0x48) >> 1);
  sub_146A12EE0(a2, v4, a3 - 0x48);
  v5 = v4 + 0x48;
  for ( i = v4 + 0x48; a2 < v4; v4 -= 0x48LL )
  {
    v6 = *(_DWORD *)(v4 - 0x44);
    if ( v6 < *(_DWORD *)(v4 + 4) )
      break;
    if ( v6 > *(_DWORD *)(v4 + 4) )
      break;
  }
  if ( v5 < v3 )
  {
    v7 = *(_DWORD *)(v4 + 4);
    do
    {
      if ( *(_DWORD *)(v5 + 4) < v7 )
        break;
      if ( *(_DWORD *)(v5 + 4) > v7 )
        break;
      v5 += 0x48LL;
    }
    while ( v5 < v3 );
    i = v5;
  }
  v8 = v5;
  v152 = v5;
  v9 = v4;
  v153 = v4;
  while ( 2 )
  {
    while ( 2 )
    {
      if ( v8 < v3 )
      {
        v10 = (char **)(v8 + 0x28);
        v175 = (char **)(v8 + 0x28);
        do
        {
          v11 = *(_DWORD *)(v4 + 4);
          if ( v11 >= *((_DWORD *)v10 + 0xFFFFFFF7) )
          {
            if ( v11 > *((_DWORD *)v10 + 0xFFFFFFF7) )
              break;
            if ( v5 == v8 )
            {
              v5 += 0x48LL;
            }
            else
            {
              v12 = *(_WORD *)v5;
              v13 = *(_BYTE *)(v5 + 2);
              v14 = *(_DWORD *)(v5 + 4);
              v15 = *(_WORD *)(v5 + 8);
              v16 = *(_BYTE *)(v5 + 0xA);
              v17 = *(_BYTE *)(v5 + 0xB);
              v184 = *(_BYTE *)(v5 + 0xC);
              v144 = *(_DWORD *)(v5 + 0x10);
              v137 = *(_BYTE *)(v5 + 0x14);
              v130 = *(_BYTE *)(v5 + 0x15);
              v18 = *(char **)(v5 + 0x28);
              *(_QWORD *)(v5 + 0x28) = 0;
              v172 = v18;
              v19 = *(char **)(v5 + 0x20);
              *(_QWORD *)(v5 + 0x20) = 0;
              v176 = v19;
              v20 = *(char **)(v5 + 0x18);
              *(_QWORD *)(v5 + 0x18) = 0;
              v173 = v20;
              v170 = *(char **)(v5 + 0x40);
              v174 = *(char **)(v5 + 0x38);
              v171 = *(char **)(v5 + 0x30);
              *(_QWORD *)(v5 + 0x40) = 0;
              *(_QWORD *)(v5 + 0x38) = 0;
              *(_QWORD *)(v5 + 0x30) = 0;
              sub_146A1D000(v5, v8);
              *(_WORD *)v152 = v12;
              v21 = v175;
              *((_BYTE *)v175 + 0xFFFFFFDA) = v13;
              v10 = v21;
              *((_DWORD *)v21 + 0xFFFFFFF7) = v14;
              *((_WORD *)v21 + 0xFFFFFFF0) = v15;
              *((_BYTE *)v21 + 0xFFFFFFE2) = v16;
              *((_BYTE *)v21 + 0xFFFFFFE3) = v17;
              v22 = (const void **)(v21 + 0xFFFFFFFE);
              *((_BYTE *)v21 + 0xFFFFFFE4) = v184;
              *((_DWORD *)v21 + 0xFFFFFFFA) = v144;
              *((_BYTE *)v21 + 0xFFFFFFEC) = v137;
              *((_BYTE *)v21 + 0xFFFFFFED) = v130;
              if ( v21 + 0xFFFFFFFE == (char **)&v177 )
              {
                v25 = v172;
                v24 = v173;
              }
              else
              {
                v23 = (char *)*v22;
                if ( *v22 )
                {
                  if ( (unsigned __int64)(2 * ((*v21 - v23) >> 1)) >= 0x1000 )
                  {
                    if ( (unsigned __int64)&v23[-*((_QWORD *)v23 + 0xFFFFFFFF) - 8] > 0x1F )
                      goto LABEL_113;
                    v23 = (char *)*((_QWORD *)v23 + 0xFFFFFFFF);
                  }
                  sub_1402A3D30(v23);
                }
                v24 = 0;
                *v22 = v173;
                v25 = 0;
                v10[0xFFFFFFFF] = v176;
                *v10 = v172;
              }
              v26 = (const void **)(v10 + 1);
              if ( v10 + 1 == (char **)&v178 )
              {
                v29 = v170;
                v28 = v171;
              }
              else
              {
                v27 = (char *)*v26;
                if ( *v26 )
                {
                  if ( ((v10[3] - v27) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
                  {
                    if ( (unsigned __int64)&v27[-*((_QWORD *)v27 + 0xFFFFFFFF) - 8] > 0x1F )
                      goto LABEL_113;
                    v27 = (char *)*((_QWORD *)v27 + 0xFFFFFFFF);
                  }
                  sub_1402A3D30(v27);
                }
                v28 = 0;
                *v26 = v171;
                v29 = 0;
                v10[2] = v174;
                v10[3] = v170;
              }
              if ( v28 )
              {
                v30 = v28;
                if ( ((v29 - v28) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
                {
                  v28 = (char *)*((_QWORD *)v28 + 0xFFFFFFFF);
                  if ( (unsigned __int64)(v30 - v28 - 8) > 0x1F )
                    goto LABEL_113;
                }
                sub_1402A3D30(v28);
              }
              if ( v24 )
              {
                v31 = v24;
                if ( (unsigned __int64)(2 * ((v25 - v24) >> 1)) >= 0x1000 )
                {
                  v24 = (char *)*((_QWORD *)v24 + 0xFFFFFFFF);
                  if ( (unsigned __int64)(v31 - v24 - 8) > 0x1F )
                    goto LABEL_113;
                }
                sub_1402A3D30(v24);
              }
              v8 = v152;
              v5 = i + 0x48;
              v3 = a3;
            }
            i = v5;
          }
          v8 += 0x48LL;
          v10 += 9;
          v152 = v8;
          v175 = v10;
        }
        while ( v8 < v3 );
        v9 = v153;
      }
      v32 = v9 == a2;
      if ( v9 <= a2 )
        goto LABEL_64;
      v33 = (char *)(v9 - 0x44);
      v170 = (char *)(v9 - 0x44);
      v34 = (char *)(v4 + 0x20);
      while ( 1 )
      {
        if ( *(_DWORD *)v33 < *((_DWORD *)v34 + 0xFFFFFFF9) )
          goto LABEL_60;
        if ( *(_DWORD *)v33 > *((_DWORD *)v34 + 0xFFFFFFF9) )
          break;
        v34 += 0xFFFFFFB8;
        v35 = v33 + 0xFFFFFFFC;
        v4 -= 0x48LL;
        v171 = v34;
        v174 = v33 + 0xFFFFFFFC;
        if ( (char *)v4 != v33 + 0xFFFFFFFC )
        {
          v36 = *(_WORD *)v4;
          v37 = v34[0xFFFFFFEB];
          v38 = v34[0xFFFFFFEC];
          v39 = *((_DWORD *)v34 + 0xFFFFFFFC);
          v40 = v34[0xFFFFFFF4];
          v41 = v34[0xFFFFFFF5];
          v42 = *((_QWORD *)v34 + 1);
          v43 = *(_QWORD *)v34;
          v155 = v34[0xFFFFFFE2];
          v185 = v155;
          v156 = *((_DWORD *)v34 + 0xFFFFFFF9);
          v145 = v156;
          v157 = *((_WORD *)v34 + 0xFFFFFFF4);
          v138 = v157;
          v44 = v34[0xFFFFFFEA];
          *((_QWORD *)v34 + 1) = 0;
          *(_QWORD *)v34 = 0;
          v131 = v44;
          v158 = v44;
          v45 = (_BYTE *)*((_QWORD *)v34 + 0xFFFFFFFF);
          *((_QWORD *)v34 + 0xFFFFFFFF) = 0;
          v165 = v43;
          v46 = *((_QWORD *)v34 + 3);
          v166 = v42;
          v47 = *((_QWORD *)v34 + 4);
          v164 = v45;
          v48 = (char *)*((_QWORD *)v34 + 2);
          v168 = v46;
          v169 = v47;
          v154 = v36;
          v159 = v37;
          v160 = v38;
          v161 = v39;
          v162 = v40;
          v163 = v41;
          *((_QWORD *)v34 + 4) = 0;
          *((_QWORD *)v34 + 3) = 0;
          *((_QWORD *)v34 + 2) = 0;
          v167 = v48;
          sub_146A1D000(v4, v35);
          *(_WORD *)v174 = v36;
          v33 = v170;
          v170[0xFFFFFFFE] = v185;
          *(_DWORD *)v33 = v145;
          *((_WORD *)v33 + 2) = v138;
          v33[6] = v131;
          v33[7] = v37;
          v33[8] = v38;
          *((_DWORD *)v33 + 3) = v39;
          v33[0x10] = v40;
          v33[0x11] = v41;
          sub_140378B00(v33 + 0x14, &v164);
          sub_140378C90((const void **)(v33 + 0x2C), (const void **)&v167);
          v49 = v167;
          if ( v167 )
          {
            if ( ((v169 - (_QWORD)v167) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
            {
              v49 = (char *)*((_QWORD *)v167 + 0xFFFFFFFF);
              if ( (unsigned __int64)(v167 - v49 - 8) > 0x1F )
                goto LABEL_113;
            }
            sub_1402A3D30(v49);
          }
          v50 = v164;
          if ( v164 )
          {
            if ( (unsigned __int64)(2 * ((v166 - (__int64)v164) >> 1)) >= 0x1000 )
            {
              v50 = (_BYTE *)*((_QWORD *)v164 + 0xFFFFFFFF);
              if ( (unsigned __int64)(v164 - v50 - 8) > 0x1F )
                goto LABEL_113;
            }
            sub_1402A3D30(v50);
          }
          v9 = v153;
          v34 = v171;
        }
LABEL_60:
        v51 = a2;
        v9 -= 0x48LL;
        v33 += 0xFFFFFFB8;
        v153 = v9;
        v170 = v33;
        if ( a2 >= v9 )
          goto LABEL_63;
      }
      v51 = a2;
LABEL_63:
      v3 = a3;
      v32 = v9 == v51;
      v8 = v152;
LABEL_64:
      if ( !v32 )
      {
        v80 = v9 - 0x48;
        v153 = v80;
        if ( v8 == v3 )
        {
          v4 -= 0x48LL;
          if ( v80 != v4 )
          {
            v81 = *(_WORD *)v80;
            v82 = *(_BYTE *)(v80 + 2);
            v83 = *(_DWORD *)(v80 + 4);
            v84 = *(_WORD *)(v80 + 8);
            v85 = *(_BYTE *)(v80 + 0xA);
            v86 = *(_BYTE *)(v80 + 0xB);
            v188 = *(_BYTE *)(v80 + 0xC);
            v148 = *(_DWORD *)(v80 + 0x10);
            v134 = *(_BYTE *)(v80 + 0x14);
            v141 = *(_BYTE *)(v80 + 0x15);
            v87 = *(char **)(v80 + 0x28);
            *(_QWORD *)(v80 + 0x28) = 0;
            v171 = v87;
            v88 = *(char **)(v80 + 0x20);
            *(_QWORD *)(v80 + 0x20) = 0;
            v174 = v88;
            v89 = *(char **)(v80 + 0x18);
            *(_QWORD *)(v80 + 0x18) = 0;
            v170 = v89;
            v173 = *(char **)(v80 + 0x40);
            v176 = *(char **)(v80 + 0x38);
            v90 = *(char **)(v80 + 0x30);
            *(_QWORD *)(v80 + 0x30) = 0;
            *(_QWORD *)(v80 + 0x40) = 0;
            *(_QWORD *)(v80 + 0x38) = 0;
            v172 = v90;
            sub_146A1D000(v80, v4);
            *(_BYTE *)(v4 + 0xC) = v188;
            *(_DWORD *)(v4 + 0x10) = v148;
            *(_BYTE *)(v4 + 0x14) = v134;
            *(_BYTE *)(v4 + 0x15) = v141;
            *(_WORD *)v4 = v81;
            v91 = (const void **)(v4 + 0x18);
            *(_BYTE *)(v4 + 2) = v82;
            *(_DWORD *)(v4 + 4) = v83;
            *(_WORD *)(v4 + 8) = v84;
            *(_BYTE *)(v4 + 0xA) = v85;
            *(_BYTE *)(v4 + 0xB) = v86;
            if ( (char *)(v4 + 0x18) == &v179 )
            {
              v94 = v171;
              v93 = v170;
            }
            else
            {
              v92 = *v91;
              if ( *v91 )
              {
                if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(v4 + 0x28) - (_QWORD)v92) >> 1)) >= 0x1000 )
                {
                  if ( (unsigned __int64)v92 - v92[0xFFFFFFFF] - 8 > 0x1F )
                    goto LABEL_113;
                  v92 = (_QWORD *)v92[0xFFFFFFFF];
                }
                sub_1402A3D30(v92);
              }
              v93 = 0;
              *v91 = v170;
              *(_QWORD *)(v4 + 0x20) = v174;
              *(_QWORD *)(v4 + 0x28) = v171;
              v94 = 0;
            }
            v95 = (const void **)(v4 + 0x30);
            if ( (char *)(v4 + 0x30) == &v180 )
            {
              v98 = v173;
              v97 = v172;
            }
            else
            {
              v96 = *v95;
              if ( *v95 )
              {
                if ( ((*(_QWORD *)(v4 + 0x40) - (_QWORD)v96) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
                {
                  if ( (unsigned __int64)v96 - v96[0xFFFFFFFF] - 8 > 0x1F )
                    goto LABEL_113;
                  v96 = (_QWORD *)v96[0xFFFFFFFF];
                }
                sub_1402A3D30(v96);
              }
              v97 = 0;
              *v95 = v172;
              v98 = 0;
              *(_QWORD *)(v4 + 0x38) = v176;
              *(_QWORD *)(v4 + 0x40) = v173;
            }
            if ( v97 )
            {
              v99 = v97;
              if ( ((v98 - v97) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
              {
                v97 = (char *)*((_QWORD *)v97 + 0xFFFFFFFF);
                if ( (unsigned __int64)(v99 - v97 - 8) > 0x1F )
                  goto LABEL_113;
              }
              sub_1402A3D30(v97);
            }
            if ( v93 )
            {
              v100 = v93;
              if ( (unsigned __int64)(2 * ((v94 - v93) >> 1)) >= 0x1000 )
              {
                v93 = (char *)*((_QWORD *)v93 + 0xFFFFFFFF);
                if ( (unsigned __int64)(v100 - v93 - 8) > 0x1F )
                  goto LABEL_113;
              }
              sub_1402A3D30(v93);
            }
          }
          v101 = *(_BYTE *)(v4 + 2);
          v102 = *(_WORD *)v4;
          v103 = *(_QWORD *)(v4 + 0x28);
          v104 = *(_QWORD *)(v4 + 0x20);
          v105 = *(_BYTE *)(v4 + 0xB);
          v106 = *(_BYTE *)(v4 + 0xC);
          v107 = *(_BYTE *)(v4 + 0x14);
          v108 = *(_BYTE *)(v4 + 0x15);
          v109 = *(_DWORD *)(v4 + 0x10);
          *(_QWORD *)(v4 + 0x28) = 0;
          *(_QWORD *)(v4 + 0x20) = 0;
          v189 = v101;
          v155 = v101;
          v156 = *(_DWORD *)(v4 + 4);
          v149 = v156;
          v157 = *(_WORD *)(v4 + 8);
          v142 = v157;
          v158 = *(_BYTE *)(v4 + 0xA);
          v135 = v158;
          v110 = *(_BYTE **)(v4 + 0x18);
          *(_QWORD *)(v4 + 0x18) = 0;
          v165 = v104;
          v111 = *(_QWORD *)(v4 + 0x38);
          v166 = v103;
          v112 = *(_QWORD *)(v4 + 0x40);
          v164 = v110;
          v113 = *(char **)(v4 + 0x30);
          v168 = v111;
          v169 = v112;
          i -= 0x48LL;
          v154 = v102;
          v159 = v105;
          v160 = v106;
          v161 = v109;
          v162 = v107;
          v163 = v108;
          *(_QWORD *)(v4 + 0x40) = 0;
          *(_QWORD *)(v4 + 0x38) = 0;
          *(_QWORD *)(v4 + 0x30) = 0;
          v167 = v113;
          sub_146A1D000(v4, i);
          *(_BYTE *)(i + 2) = v189;
          *(_DWORD *)(i + 4) = v149;
          *(_WORD *)(i + 8) = v142;
          *(_BYTE *)(i + 0xA) = v135;
          *(_WORD *)i = v102;
          *(_BYTE *)(i + 0xB) = v105;
          *(_BYTE *)(i + 0xC) = v106;
          *(_DWORD *)(i + 0x10) = v109;
          *(_BYTE *)(i + 0x14) = v107;
          *(_BYTE *)(i + 0x15) = v108;
          sub_140378B00((_QWORD *)(i + 0x18), &v164);
          sub_140378C90((const void **)(i + 0x30), (const void **)&v167);
          v114 = v167;
          if ( v167 )
          {
            if ( ((v169 - (_QWORD)v167) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
            {
              v114 = (char *)*((_QWORD *)v167 + 0xFFFFFFFF);
              if ( (unsigned __int64)(v167 - v114 - 8) > 0x1F )
                goto LABEL_113;
            }
            sub_1402A3D30(v114);
          }
          v115 = v164;
          v5 = i;
          v8 = v152;
          v9 = v153;
          v3 = a3;
          if ( v164 )
          {
            if ( (unsigned __int64)(2 * ((v166 - (__int64)v164) >> 1)) >= 0x1000 )
            {
              v115 = (_BYTE *)*((_QWORD *)v164 + 0xFFFFFFFF);
              if ( (unsigned __int64)(v164 - v115 - 8) > 0x1F )
                goto LABEL_113;
            }
            sub_1402A3D30(v115);
            v5 = i;
            v8 = v152;
            v9 = v153;
            v3 = a3;
          }
        }
        else
        {
          v116 = *(_BYTE *)(v8 + 2);
          v117 = *(_WORD *)v8;
          v118 = *(_QWORD *)(v8 + 0x28);
          v119 = *(_QWORD *)(v8 + 0x20);
          v120 = *(_BYTE *)(v8 + 0xB);
          v121 = *(_BYTE *)(v8 + 0xC);
          v122 = *(_BYTE *)(v8 + 0x14);
          v123 = *(_BYTE *)(v8 + 0x15);
          v124 = *(_DWORD *)(v8 + 0x10);
          *(_QWORD *)(v8 + 0x28) = 0;
          *(_QWORD *)(v8 + 0x20) = 0;
          v190 = v116;
          v155 = v116;
          v156 = *(_DWORD *)(v8 + 4);
          v150 = v156;
          v157 = *(_WORD *)(v8 + 8);
          v143 = v157;
          v158 = *(_BYTE *)(v8 + 0xA);
          v136 = v158;
          v125 = *(_BYTE **)(v8 + 0x18);
          *(_QWORD *)(v8 + 0x18) = 0;
          v165 = v119;
          v126 = *(_QWORD *)(v8 + 0x38);
          v166 = v118;
          v127 = *(_QWORD *)(v8 + 0x40);
          v164 = v125;
          v128 = *(char **)(v8 + 0x30);
          v168 = v126;
          v169 = v127;
          v153 = v80;
          v154 = v117;
          v159 = v120;
          v160 = v121;
          v161 = v124;
          v162 = v122;
          v163 = v123;
          *(_QWORD *)(v8 + 0x40) = 0;
          *(_QWORD *)(v8 + 0x38) = 0;
          *(_QWORD *)(v8 + 0x30) = 0;
          v167 = v128;
          sub_146A1D000(v8, v80);
          *(_BYTE *)(v153 + 2) = v190;
          *(_DWORD *)(v153 + 4) = v150;
          *(_WORD *)(v153 + 8) = v143;
          *(_BYTE *)(v153 + 0xA) = v136;
          *(_WORD *)v153 = v117;
          *(_BYTE *)(v153 + 0xB) = v120;
          *(_BYTE *)(v153 + 0xC) = v121;
          *(_DWORD *)(v153 + 0x10) = v124;
          *(_BYTE *)(v153 + 0x14) = v122;
          *(_BYTE *)(v153 + 0x15) = v123;
          sub_140378B00((_QWORD *)(v153 + 0x18), &v164);
          sub_140378C90((const void **)(v153 + 0x30), (const void **)&v167);
          sub_146A1CF50(&v154);
          v5 = i;
          v8 = v152 + 0x48;
          v9 = v153;
          v3 = a3;
          v152 += 0x48LL;
        }
        continue;
      }
      break;
    }
    if ( v8 != v3 )
    {
      v52 = i;
      if ( i == v152 )
        goto LABEL_76;
      v53 = *(_WORD *)v4;
      v54 = *(_BYTE *)(v4 + 0xB);
      v55 = *(_BYTE *)(v4 + 0xC);
      v56 = *(_DWORD *)(v4 + 0x10);
      v57 = *(_BYTE *)(v4 + 0x14);
      v58 = *(_BYTE *)(v4 + 0x15);
      v59 = *(_QWORD *)(v4 + 0x28);
      v60 = *(_QWORD *)(v4 + 0x20);
      v155 = *(_BYTE *)(v4 + 2);
      v186 = v155;
      v156 = *(_DWORD *)(v4 + 4);
      v146 = v156;
      v157 = *(_WORD *)(v4 + 8);
      v139 = v157;
      v61 = *(_BYTE *)(v4 + 0xA);
      *(_QWORD *)(v4 + 0x28) = 0;
      *(_QWORD *)(v4 + 0x20) = 0;
      v132 = v61;
      v158 = v61;
      v62 = *(_BYTE **)(v4 + 0x18);
      *(_QWORD *)(v4 + 0x18) = 0;
      v165 = v60;
      v63 = *(_QWORD *)(v4 + 0x38);
      v166 = v59;
      v64 = *(_QWORD *)(v4 + 0x40);
      v164 = v62;
      v65 = *(char **)(v4 + 0x30);
      v168 = v63;
      v169 = v64;
      v154 = v53;
      v159 = v54;
      v160 = v55;
      v161 = v56;
      v162 = v57;
      v163 = v58;
      *(_QWORD *)(v4 + 0x40) = 0;
      *(_QWORD *)(v4 + 0x38) = 0;
      *(_QWORD *)(v4 + 0x30) = 0;
      v167 = v65;
      sub_146A1D000(v4, i);
      *(_BYTE *)(i + 2) = v186;
      *(_DWORD *)(i + 4) = v146;
      *(_WORD *)(i + 8) = v139;
      *(_BYTE *)(i + 0xA) = v132;
      *(_WORD *)i = v53;
      *(_BYTE *)(i + 0xB) = v54;
      *(_BYTE *)(i + 0xC) = v55;
      *(_DWORD *)(i + 0x10) = v56;
      *(_BYTE *)(i + 0x14) = v57;
      *(_BYTE *)(i + 0x15) = v58;
      sub_140378B00((_QWORD *)(i + 0x18), &v164);
      sub_140378C90((const void **)(i + 0x30), (const void **)&v167);
      v66 = v167;
      if ( !v167 )
        goto LABEL_71;
      if ( ((v169 - (_QWORD)v167) & 0xFFFFFFFFFFFFFFFCuLL) < 0x1000
        || (v66 = (char *)*((_QWORD *)v167 + 0xFFFFFFFF), (unsigned __int64)(v167 - v66 - 8) <= 0x1F) )
      {
        sub_1402A3D30(v66);
LABEL_71:
        v67 = v164;
        if ( !v164 )
        {
LABEL_75:
          v52 = i;
LABEL_76:
          v68 = *(_WORD *)v4;
          v69 = *(_BYTE *)(v4 + 0xB);
          v70 = *(_BYTE *)(v4 + 0xC);
          v71 = *(_DWORD *)(v4 + 0x10);
          v72 = *(_BYTE *)(v4 + 0x14);
          v73 = *(_BYTE *)(v4 + 0x15);
          v74 = *(_QWORD *)(v4 + 0x28);
          v75 = *(_QWORD *)(v4 + 0x20);
          v155 = *(_BYTE *)(v4 + 2);
          v187 = v155;
          v156 = *(_DWORD *)(v4 + 4);
          v147 = v156;
          v157 = *(_WORD *)(v4 + 8);
          v140 = v157;
          v158 = *(_BYTE *)(v4 + 0xA);
          v133 = v158;
          v76 = *(_BYTE **)(v4 + 0x18);
          v165 = v75;
          v166 = v74;
          i = v52 + 0x48;
          *(_QWORD *)(v4 + 0x18) = 0;
          *(_QWORD *)(v4 + 0x28) = 0;
          *(_QWORD *)(v4 + 0x20) = 0;
          v77 = *(_QWORD *)(v4 + 0x40);
          v78 = *(_QWORD *)(v4 + 0x38);
          v164 = v76;
          v79 = *(char **)(v4 + 0x30);
          v168 = v78;
          v169 = v77;
          v154 = v68;
          v159 = v69;
          v160 = v70;
          v161 = v71;
          v162 = v72;
          v163 = v73;
          *(_QWORD *)(v4 + 0x40) = 0;
          *(_QWORD *)(v4 + 0x38) = 0;
          *(_QWORD *)(v4 + 0x30) = 0;
          v167 = v79;
          sub_146A1D000(v4, v152);
          *(_BYTE *)(v152 + 2) = v187;
          *(_DWORD *)(v152 + 4) = v147;
          *(_WORD *)(v152 + 8) = v140;
          *(_BYTE *)(v152 + 0xA) = v133;
          *(_WORD *)v152 = v68;
          *(_BYTE *)(v152 + 0xB) = v69;
          *(_BYTE *)(v152 + 0xC) = v70;
          *(_DWORD *)(v152 + 0x10) = v71;
          *(_BYTE *)(v152 + 0x14) = v72;
          *(_BYTE *)(v152 + 0x15) = v73;
          sub_140378B00((_QWORD *)(v152 + 0x18), &v164);
          sub_140378C90((const void **)(v152 + 0x30), (const void **)&v167);
          sub_146A1CF50(&v154);
          v4 += 0x48LL;
          v5 = i;
          v8 = v152 + 0x48;
          v9 = v153;
          v3 = a3;
          v152 += 0x48LL;
          continue;
        }
        if ( (unsigned __int64)(2 * ((v166 - (__int64)v164) >> 1)) < 0x1000
          || (v67 = (const void *)*((_QWORD *)v164 + 0xFFFFFFFF), (unsigned __int64)(v164 - (_BYTE *)v67 - 8) <= 0x1F) )
        {
          sub_1402A3D30(v67);
          goto LABEL_75;
        }
      }
LABEL_113:
      invalid_parameter_noinfo_noreturn();
    }
    break;
  }
  a1[1] = i;
  result = a1;
  *a1 = v4;
  return result;
}

// --- End Function: sub_146A14530 (0x146A14530) ---

// --- Function: sub_146A15600 (0x146A15600) ---
__int64 __fastcall sub_146A15600(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rbp
  __int64 v8; // r10
  __int64 v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rbx
  __int64 v14; // rsi
  __int64 v15; // rdi

  v4 = a3 - 1;
  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v11 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v11 = 2 * v11 + 2LL - (*(_DWORD *)(a1 + 0x90 * v11 + 0x94) < *(_DWORD *)(a1 + 0x90 * v11 + 0x4C));
      v12 = a1 + 0x48 * v11;
      v13 = a1 + 0x48 * v8;
      *(_WORD *)v13 = *(_WORD *)v12;
      *(_BYTE *)(v13 + 2) = *(_BYTE *)(v12 + 2);
      *(_DWORD *)(v13 + 4) = *(_DWORD *)(v12 + 4);
      *(_WORD *)(v13 + 8) = *(_WORD *)(v12 + 8);
      *(_BYTE *)(v13 + 0xA) = *(_BYTE *)(v12 + 0xA);
      *(_BYTE *)(v13 + 0xB) = *(_BYTE *)(v12 + 0xB);
      *(_BYTE *)(v13 + 0xC) = *(_BYTE *)(v12 + 0xC);
      *(_DWORD *)(v13 + 0x10) = *(_DWORD *)(v12 + 0x10);
      *(_BYTE *)(v13 + 0x14) = *(_BYTE *)(v12 + 0x14);
      *(_BYTE *)(v13 + 0x15) = *(_BYTE *)(v12 + 0x15);
      sub_140378B00((_QWORD *)(v13 + 0x18), (_QWORD *)(v12 + 0x18));
      sub_140378C90((const void **)(v13 + 0x30), (const void **)(v12 + 0x30));
      v8 = v11;
    }
    while ( v11 < v5 );
    v4 = a3 - 1;
  }
  if ( v11 == v5 && (a3 & 1) == 0 )
  {
    sub_146A1D000(a1 + 0x48 * v8, a1 + 0x48 * (a3 - 1));
    v8 = v4;
  }
  if ( a2 < v8 )
  {
    do
    {
      v14 = (v8 - 1) >> 1;
      if ( *(_DWORD *)(a1 + 0x48 * v14 + 4) >= *(_DWORD *)(a4 + 4) )
        break;
      v15 = a1 + 0x48 * v8;
      *(_WORD *)v15 = *(_WORD *)(a1 + 0x48 * v14);
      *(_BYTE *)(v15 + 2) = *(_BYTE *)(a1 + 0x48 * v14 + 2);
      *(_DWORD *)(v15 + 4) = *(_DWORD *)(a1 + 0x48 * v14 + 4);
      *(_WORD *)(v15 + 8) = *(_WORD *)(a1 + 0x48 * v14 + 8);
      *(_BYTE *)(v15 + 0xA) = *(_BYTE *)(a1 + 0x48 * v14 + 0xA);
      *(_BYTE *)(v15 + 0xB) = *(_BYTE *)(a1 + 0x48 * v14 + 0xB);
      *(_BYTE *)(v15 + 0xC) = *(_BYTE *)(a1 + 0x48 * v14 + 0xC);
      *(_DWORD *)(v15 + 0x10) = *(_DWORD *)(a1 + 0x48 * v14 + 0x10);
      *(_BYTE *)(v15 + 0x14) = *(_BYTE *)(a1 + 0x48 * v14 + 0x14);
      *(_BYTE *)(v15 + 0x15) = *(_BYTE *)(a1 + 0x48 * v14 + 0x15);
      sub_140378B00((_QWORD *)(v15 + 0x18), (_QWORD *)(a1 + 0x18 + 0x48 * v14));
      sub_140378C90((const void **)(v15 + 0x30), (const void **)(a1 + 0x30 + 0x48 * v14));
      v8 = v14;
    }
    while ( a2 < v14 );
  }
  return sub_146A1D000(a1 + 0x48 * v8, a4);
}

// --- End Function: sub_146A15600 (0x146A15600) ---

// --- Function: sub_146A15B80 (0x146A15B80) ---
unsigned __int64 __fastcall sub_146A15B80(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  __int64 v8; // rax
  unsigned __int64 v9; // r14
  __int64 v10; // rax
  unsigned __int64 v11; // rbx
  _QWORD *v12; // rcx
  unsigned __int64 v13; // rax
  __int64 *v14; // r10
  _QWORD *v15; // rcx
  __int64 *i; // rax
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // rdx
  const void *v20; // r8
  unsigned __int64 result; // rax

  if ( a2 > 0xAAAAAAAAAAAAAAALL )
    unknown_libname_10();
  v4 = (a1[1] - *a1) / 0x18;
  v5 = (a1[2] - *a1) / 0x18;
  v6 = v5 >> 1;
  if ( v5 > 0xAAAAAAAAAAAAAAALL - (v5 >> 1) )
    goto LABEL_25;
  v7 = v6 + v5;
  if ( v6 + v5 >= a2 )
  {
    if ( v7 > 0xAAAAAAAAAAAAAAALL )
      goto LABEL_25;
  }
  else
  {
    v7 = a2;
  }
  v8 = 3 * v7;
  v9 = 8 * v8;
  if ( (unsigned __int64)(8 * v8) < 0x1000 )
  {
    if ( v9 )
      v11 = allocWithProfilerInfo_w(8 * v8);
    else
      v11 = 0;
    goto LABEL_13;
  }
  if ( v9 + 0x27 < v9 )
LABEL_25:
    sub_1402E1170();
  v10 = allocWithProfilerInfo_w(v9 + 0x27);
  if ( !v10 )
    goto LABEL_23;
  v11 = (v10 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v11 - 8) = v10;
LABEL_13:
  v12 = (_QWORD *)(v11 + 0x18 * v4);
  v13 = a2 - v4;
  if ( a2 != v4 )
  {
    do
    {
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      v12 += 3;
      --v13;
    }
    while ( v13 );
  }
  sub_146A12030((__int64)v12, (__int64)v12);
  v14 = (__int64 *)a1[1];
  v15 = (_QWORD *)v11;
  for ( i = (__int64 *)*a1; i != v14; v15 += 3 )
  {
    v17 = i[2];
    v18 = i[1];
    v19 = *i;
    i[2] = 0;
    i[1] = 0;
    *i = 0;
    i += 3;
    *v15 = v19;
    v15[1] = v18;
    v15[2] = v17;
  }
  sub_146A12030((__int64)v15, (__int64)v15);
  if ( *a1 )
  {
    sub_146A12030(*a1, a1[1]);
    v20 = (const void *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) < 0x1000 )
    {
LABEL_21:
      sub_1402A3D30(v20);
      goto LABEL_22;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_21;
    }
LABEL_23:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_22:
  result = v9 + v11;
  *a1 = v11;
  a1[1] = v11 + 0x18 * a2;
  a1[2] = v9 + v11;
  return result;
}

// --- End Function: sub_146A15B80 (0x146A15B80) ---

// --- Function: sub_146A15F20 (0x146A15F20) ---
_WORD *__fastcall sub_146A15F20(unsigned __int64 a1, _WORD *a2, __int64 a3, unsigned __int8 a4)
{
  _WORD *v6; // rbp
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // r15
  _WORD *result; // rax
  _QWORD *v11; // rdi
  unsigned __int64 v12; // r14
  __int64 v13; // rdx
  __int64 v14; // rcx
  char v15; // al
  __int64 v16; // rax
  __int64 v17; // r8
  __int64 v18; // rdx
  __int64 v19; // rax
  unsigned __int64 v20; // [rsp+30h] [rbp-78h] BYREF
  unsigned __int64 v21; // [rsp+38h] [rbp-70h]
  __int16 v22; // [rsp+40h] [rbp-68h] BYREF
  char v23; // [rsp+42h] [rbp-66h]
  int v24; // [rsp+44h] [rbp-64h]
  __int16 v25; // [rsp+48h] [rbp-60h]
  char v26; // [rsp+4Ah] [rbp-5Eh]
  char v27; // [rsp+4Bh] [rbp-5Dh]
  char v28; // [rsp+4Ch] [rbp-5Ch]
  int v29; // [rsp+50h] [rbp-58h]
  char v30; // [rsp+54h] [rbp-54h]
  char v31; // [rsp+55h] [rbp-53h]
  __int64 v32; // [rsp+58h] [rbp-50h]
  __int64 v33; // [rsp+60h] [rbp-48h]
  __int64 v34; // [rsp+68h] [rbp-40h]
  __int64 v35; // [rsp+70h] [rbp-38h]
  __int64 v36; // [rsp+78h] [rbp-30h]
  __int64 v37; // [rsp+80h] [rbp-28h]

  v6 = a2;
  v7 = a1;
  if ( (__int64)((__int64)a2 - a1) < 0x948 )
    return sub_146A13430(v7, v6);
  while ( a3 > 0 )
  {
    sub_146A14530(&v20, v7, (unsigned __int64)v6);
    v8 = v21;
    v9 = v20;
    a3 = (a3 >> 2) + (a3 >> 1);
    if ( (__int64)(v20 - v7) / 0x48 >= (__int64)((__int64)v6 - v21) / 0x48 )
    {
      sub_146A15F20(v21, v6, a3, a4);
      v6 = (_WORD *)v9;
    }
    else
    {
      sub_146A15F20(v7, v20, a3, a4);
      v7 = v8;
    }
    if ( (__int64)((__int64)v6 - v7) < 0x948 )
      return sub_146A13430(v7, v6);
  }
  sub_146A13A40(v7, (__int64)v6);
  result = (_WORD *)((char *)v6 - v7);
  if ( (__int64)((__int64)v6 - v7) >= 0x90 )
  {
    v11 = v6 + 0xFFFFFFEC;
    v12 = 0x28 - v7;
    do
    {
      if ( (__int64)((__int64)v11 + v12) / 0x48 >= 2 )
      {
        v13 = v11[1];
        v14 = *v11;
        v22 = *((_WORD *)v11 + 0xFFFFFFF0);
        v23 = *((_BYTE *)v11 + 0xFFFFFFE2);
        v24 = *((_DWORD *)v11 + 0xFFFFFFF9);
        v25 = *((_WORD *)v11 + 0xFFFFFFF4);
        v26 = *((_BYTE *)v11 + 0xFFFFFFEA);
        v27 = *((_BYTE *)v11 + 0xFFFFFFEB);
        v28 = *((_BYTE *)v11 + 0xFFFFFFEC);
        v29 = *((_DWORD *)v11 + 0xFFFFFFFC);
        v30 = *((_BYTE *)v11 + 0xFFFFFFF4);
        v15 = *((_BYTE *)v11 + 0xFFFFFFF5);
        v11[1] = 0;
        *v11 = 0;
        v31 = v15;
        v16 = v11[0xFFFFFFFF];
        v11[0xFFFFFFFF] = 0;
        v17 = v11[4];
        v34 = v13;
        v18 = v11[3];
        v32 = v16;
        v19 = v11[2];
        v36 = v18;
        v33 = v14;
        v11[4] = 0;
        v11[3] = 0;
        v11[2] = 0;
        v35 = v19;
        v37 = v17;
        sub_146A1D000(v11 + 0xFFFFFFFC, v7);
        sub_146A15600(v7, 0, (__int64)((__int64)v11 - 0x20 - v7) / 0x48, (__int64)&v22);
        sub_146A1CF50(&v22);
      }
      v11 += 0xFFFFFFF7;
      result = (_WORD *)((char *)v11 + v12);
    }
    while ( (__int64)((__int64)v11 + v12) >= 0x90 );
  }
  return result;
}

// --- End Function: sub_146A15F20 (0x146A15F20) ---

// --- Function: sub_146A165D0 (0x146A165D0) ---
__int64 __fastcall sub_146A165D0(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 *v5; // r15
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 *v8; // rbx
  __int64 *v9; // rbp
  __int64 *v10; // rcx
  __int64 **v12; // r13
  _QWORD *v13; // r12
  __int64 v14; // rdi
  __int64 v15; // rcx
  float v16; // xmm1_4
  float v17; // kr00_4
  unsigned __int64 n8_2; // rdx
  float v19; // xmm0_4
  float v20; // kr00_4
  unsigned __int64 v23; // rcx
  unsigned __int64 n8_1; // rax
  unsigned __int64 n8; // rcx
  unsigned __int64 v26; // r8
  __int64 v27; // rdx
  __int64 *v28; // rax
  __int64 *v29; // rdx
  int v30; // ecx
  __int64 *v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // rax
  __int64 *v34; // r8
  unsigned __int64 v35; // [rsp+70h] [rbp+8h]

  v5 = *(__int64 **)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 0x18);
  v35 = 0x100000001B3LL
      * (a3[3]
       ^ (0x100000001B3LL * (a3[2] ^ (0x100000001B3LL * (a3[1] ^ (0x100000001B3LL * (*a3 ^ 0xCBF29CE484222325uLL)))))));
  v7 = 2 * (v35 & *(_QWORD *)(a1 + 0x30));
  v8 = *(__int64 **)(v6 + 8 * v7 + 8);
  if ( v8 == v5 )
  {
    v8 = v5;
    v9 = v5;
  }
  else
  {
    v10 = *(__int64 **)(v6 + 8 * v7);
    if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
    {
LABEL_6:
      *(_QWORD *)a2 = v8;
      *(_BYTE *)(a2 + 8) = 0;
      return a2;
    }
    while ( v8 != v10 )
    {
      v8 = (__int64 *)v8[1];
      if ( *(_DWORD *)a3 == *((_DWORD *)v8 + 4) )
        goto LABEL_6;
    }
    v5 = v8;
    v9 = v8;
  }
  v12 = (__int64 **)(a1 + 8);
  v13 = (_QWORD *)(a1 + 0x30);
  if ( *(_QWORD *)(a1 + 0x10) == 0xAAAAAAAAAAAAAAALL )
    std::_Xlength_error("unordered_map/set too long");
  v14 = allocWithProfilerInfo_w(0x18u);
  *(_DWORD *)(v14 + 0x10) = *(_DWORD *)a3;
  *(_WORD *)(v14 + 0x14) = 0xFFFF;
  v15 = *(_QWORD *)(a1 + 0x10) + 1LL;
  if ( v15 < 0 )
  {
    v17 = (float)(v15 & 1 | ((unsigned __int64)v15 >> 1));
    v16 = v17 + v17;
  }
  else
  {
    v16 = (float)v15;
  }
  n8_2 = *(_QWORD *)(a1 + 0x38);
  if ( (n8_2 & 0x8000000000000000uLL) != 0LL )
  {
    v20 = (float)(*(_QWORD *)(a1 + 0x38) & 1LL | (n8_2 >> 1));
    v19 = v20 + v20;
  }
  else
  {
    v19 = (float)(__int64)n8_2;
  }
  if ( *(float *)a1 >= (float)(v16 / v19) )
  {
    v26 = v35;
  }
  else
  {
    _XMM1 = 0;
    __asm { vroundss xmm1, xmm1, xmm0, 2 }
    v23 = 0;
    if ( *(float *)&_XMM1 >= 9.223372e18 )
    {
      *(float *)&_XMM1 = *(float *)&_XMM1 - 9.223372e18;
      if ( *(float *)&_XMM1 < 9.223372e18 )
        v23 = 0x8000000000000000uLL;
    }
    n8_1 = v23 + (unsigned int)(int)*(float *)&_XMM1;
    n8 = 8;
    if ( n8_1 > 8 )
      n8 = n8_1;
    if ( n8_2 < n8 )
    {
      if ( n8_2 >= 0x200 || (n8_2 *= 8LL, n8_2 < n8) )
        n8_2 = n8;
    }
    std::_Hash<std::_Umap_traits<int,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int>>,std::allocator<std::pair<int const,std::shared_ptr<vraudio::AmbisonicMixingEncoderNode>>>,0>>::_Forced_rehash(
      (unsigned __int64 **)a1,
      n8_2);
    v26 = v35;
    v27 = *(_QWORD *)(a1 + 0x18);
    v8 = *(__int64 **)(a1 + 8);
    v28 = *(__int64 **)(v27 + 0x10 * (v35 & *(_QWORD *)(a1 + 0x30)) + 8);
    if ( v28 != v8 )
    {
      v29 = *(__int64 **)(v27 + 0x10 * (v35 & *(_QWORD *)(a1 + 0x30)));
      v30 = *(_DWORD *)(v14 + 0x10);
      if ( v30 != *((_DWORD *)v28 + 4) )
      {
        while ( 1 )
        {
          v8 = v28;
          if ( v28 == v29 )
            break;
          v28 = (__int64 *)v28[1];
          if ( v30 == *((_DWORD *)v28 + 4) )
            goto LABEL_30;
        }
        v13 = (_QWORD *)(a1 + 0x30);
        v12 = (__int64 **)(a1 + 8);
        v9 = v28;
        v5 = v28;
        goto LABEL_34;
      }
LABEL_30:
      v8 = (__int64 *)*v28;
    }
    v13 = (_QWORD *)(a1 + 0x30);
    v9 = v8;
    v12 = (__int64 **)(a1 + 8);
    v5 = v8;
  }
LABEL_34:
  v31 = (__int64 *)v8[1];
  ++*(_QWORD *)(a1 + 0x10);
  *(_QWORD *)v14 = v5;
  *(_QWORD *)(v14 + 8) = v31;
  *v31 = v14;
  v8[1] = v14;
  v32 = *(_QWORD *)(a1 + 0x18);
  v33 = 2 * (v26 & *v13);
  v34 = *(__int64 **)(v32 + 0x10 * (v26 & *v13));
  if ( v34 == *v12 )
  {
    *(_QWORD *)(v32 + 8 * v33) = v14;
    goto LABEL_39;
  }
  if ( v34 != v9 )
  {
    if ( *(__int64 **)(v32 + 8 * v33 + 8) != v31 )
    {
LABEL_40:
      *(_QWORD *)a2 = v14;
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
LABEL_39:
    *(_QWORD *)(v32 + 8 * v33 + 8) = v14;
    goto LABEL_40;
  }
  *(_QWORD *)(v32 + 8 * v33) = v14;
  *(_QWORD *)a2 = v14;
  *(_BYTE *)(a2 + 8) = 1;
  return a2;
}

// --- End Function: sub_146A165D0 (0x146A165D0) ---

// --- Function: sub_146A16910 (0x146A16910) ---
_WORD *__fastcall sub_146A16910(__int64 a1, __int64 a2, _WORD *a3)
{
  __int64 v4; // r8
  char *v5; // r10
  __int16 v6; // ax

  if ( a1 != a2 )
  {
    v4 = a1 + 8;
    v5 = (char *)a3 - a1;
    do
    {
      v6 = *(_WORD *)(v4 - 8);
      v4 += 0x18;
      *a3 = v6;
      *(_QWORD *)&v5[v4 - 0x18] = 0;
      a3 += 0xC;
      *(_QWORD *)&v5[v4 - 0x10] = 0;
      *(_QWORD *)&v5[v4 - 0x18] = *(_QWORD *)(v4 - 0x18);
      *(_QWORD *)&v5[v4 - 0x10] = *(_QWORD *)(v4 - 0x10);
      *(_QWORD *)(v4 - 0x18) = 0;
      *(_QWORD *)(v4 - 0x10) = 0;
    }
    while ( v4 - 8 != a2 );
  }
  sub_14042EF40((__int64)a3, (__int64)a3);
  return a3;
}

// --- End Function: sub_146A16910 (0x146A16910) ---

// --- Function: sub_146A16B00 (0x146A16B00) ---
_WORD *__fastcall sub_146A16B00(__int64 a1, __int64 a2, _WORD *a3)
{
  _WORD *v3; // r11
  char *v5; // r10
  __int64 v6; // r8
  __int16 v7; // ax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r9
  __int64 v13; // rdx

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = (char *)a3 - a1;
    v6 = a1 + 0x20;
    do
    {
      v7 = *(_WORD *)(v6 - 0x20);
      v6 += 0x48;
      *v3 = v7;
      v3 += 0x24;
      v5[v6 - 0x66] = *(_BYTE *)(v6 - 0x66);
      *(_DWORD *)&v5[v6 - 0x64] = *(_DWORD *)(v6 - 0x64);
      *(_WORD *)&v5[v6 - 0x60] = *(_WORD *)(v6 - 0x60);
      v5[v6 - 0x5E] = *(_BYTE *)(v6 - 0x5E);
      v5[v6 - 0x5D] = *(_BYTE *)(v6 - 0x5D);
      v5[v6 - 0x5C] = *(_BYTE *)(v6 - 0x5C);
      *(_DWORD *)&v5[v6 - 0x58] = *(_DWORD *)(v6 - 0x58);
      v5[v6 - 0x54] = *(_BYTE *)(v6 - 0x54);
      v5[v6 - 0x53] = *(_BYTE *)(v6 - 0x53);
      v8 = *(_QWORD *)(v6 - 0x40);
      v9 = *(_QWORD *)(v6 - 0x48);
      v10 = *(_QWORD *)(v6 - 0x50);
      *(_QWORD *)(v6 - 0x40) = 0;
      *(_QWORD *)(v6 - 0x48) = 0;
      *(_QWORD *)(v6 - 0x50) = 0;
      *(_QWORD *)&v5[v6 - 0x48] = v9;
      *(_QWORD *)&v5[v6 - 0x50] = v10;
      *(_QWORD *)&v5[v6 - 0x40] = v8;
      v11 = *(_QWORD *)(v6 - 0x38);
      v12 = *(_QWORD *)(v6 - 0x28);
      v13 = *(_QWORD *)(v6 - 0x30);
      *(_QWORD *)(v6 - 0x28) = 0;
      *(_QWORD *)(v6 - 0x30) = 0;
      *(_QWORD *)(v6 - 0x38) = 0;
      *(_QWORD *)&v5[v6 - 0x38] = v11;
      *(_QWORD *)&v5[v6 - 0x30] = v13;
      *(_QWORD *)&v5[v6 - 0x28] = v12;
    }
    while ( v6 - 0x20 != a2 );
  }
  return v3;
}

// --- End Function: sub_146A16B00 (0x146A16B00) ---

// --- Function: sub_146A19EB0 (0x146A19EB0) ---
char *__fastcall sub_146A19EB0(__int64 a1, __int64 a2, __int64 a3)
{
  char *result; // rax
  unsigned __int64 _Newcapacity; // rdx
  const void *v7; // rdx
  char *v8; // rdi
  signed __int64 Size; // rbx
  unsigned __int64 v10; // rdx
  const void *v11; // rdx
  char *v12; // rdi
  signed __int64 Size_1; // rbx

  *(_WORD *)a2 = *(_WORD *)a3;
  *(_BYTE *)(a2 + 2) = *(_BYTE *)(a3 + 2);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  *(_WORD *)(a2 + 8) = *(_WORD *)(a3 + 8);
  *(_BYTE *)(a2 + 0xA) = *(_BYTE *)(a3 + 0xA);
  *(_BYTE *)(a2 + 0xB) = *(_BYTE *)(a3 + 0xB);
  *(_BYTE *)(a2 + 0xC) = *(_BYTE *)(a3 + 0xC);
  *(_DWORD *)(a2 + 0x10) = *(_DWORD *)(a3 + 0x10);
  *(_BYTE *)(a2 + 0x14) = *(_BYTE *)(a3 + 0x14);
  result = (char *)*(unsigned __int8 *)(a3 + 0x15);
  *(_BYTE *)(a2 + 0x15) = (_BYTE)result;
  *(_QWORD *)(a2 + 0x18) = 0;
  *(_QWORD *)(a2 + 0x20) = 0;
  *(_QWORD *)(a2 + 0x28) = 0;
  _Newcapacity = (__int64)(*(_QWORD *)(a3 + 0x20) - *(_QWORD *)(a3 + 0x18)) >> 1;
  if ( _Newcapacity )
  {
    if ( _Newcapacity > 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    std::vector<short>::_Buy_raw((std::vector<short> *)(a2 + 0x18), _Newcapacity);
    v7 = *(const void **)(a3 + 0x18);
    v8 = *(char **)(a2 + 0x18);
    Size = *(_QWORD *)(a3 + 0x20) - (_QWORD)v7;
    memmove(v8, v7, Size);
    result = &v8[2 * (Size >> 1)];
    *(_QWORD *)(a2 + 0x20) = result;
  }
  *(_QWORD *)(a2 + 0x30) = 0;
  *(_QWORD *)(a2 + 0x38) = 0;
  *(_QWORD *)(a2 + 0x40) = 0;
  v10 = (__int64)(*(_QWORD *)(a3 + 0x38) - *(_QWORD *)(a3 + 0x30)) >> 2;
  if ( v10 )
  {
    if ( v10 > 0x3FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    sub_1402FACB0((unsigned __int64 *)(a2 + 0x30), v10);
    v11 = *(const void **)(a3 + 0x30);
    v12 = *(char **)(a2 + 0x30);
    Size_1 = *(_QWORD *)(a3 + 0x38) - (_QWORD)v11;
    memmove(v12, v11, Size_1);
    result = &v12[4 * (Size_1 >> 2)];
    *(_QWORD *)(a2 + 0x38) = result;
  }
  return result;
}

// --- End Function: sub_146A19EB0 (0x146A19EB0) ---

// --- Function: sub_146A1A160 (0x146A1A160) ---
_QWORD *__fastcall sub_146A1A160(__int64 a1, _QWORD *a2, __int64 a3, int *a4)
{
  __int64 v6; // r8
  int v8; // r11d
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdx
  const void *v12; // rax
  __int64 v13; // rdx
  const void *v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rdi
  __int64 v17; // rcx
  __int64 v18; // rdx
  int v19; // eax
  _DWORD *v20; // rcx
  const void *v21; // rcx
  _QWORD *result; // rax
  int v23; // [rsp+28h] [rbp-30h]
  const void *v24[2]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v25; // [rsp+40h] [rbp-18h]

  v6 = *(_QWORD *)(a1 + 8);
  if ( v6 == *(_QWORD *)(a1 + 0x10) )
  {
    *a2 = sub_140CE8470(a1, a3, a4);
    return a2;
  }
  else
  {
    v8 = *a4;
    if ( a3 == v6 )
    {
      *(_DWORD *)v6 = v8;
      v9 = *((_QWORD *)a4 + 1);
      v10 = *((_QWORD *)a4 + 2);
      v11 = *((_QWORD *)a4 + 3);
      *((_QWORD *)a4 + 3) = 0;
      *((_QWORD *)a4 + 2) = 0;
      *((_QWORD *)a4 + 1) = 0;
      *(_QWORD *)(v6 + 8) = v9;
      *(_QWORD *)(v6 + 0x10) = v10;
      *(_QWORD *)(v6 + 0x18) = v11;
      *(_QWORD *)(a1 + 8) += 0x20LL;
    }
    else
    {
      v12 = (const void *)*((_QWORD *)a4 + 1);
      v13 = *((_QWORD *)a4 + 3);
      v14 = (const void *)*((_QWORD *)a4 + 2);
      *((_QWORD *)a4 + 3) = 0;
      *((_QWORD *)a4 + 2) = 0;
      *((_QWORD *)a4 + 1) = 0;
      v24[0] = v12;
      *(_DWORD *)v6 = *(_DWORD *)(v6 - 0x20);
      v15 = *(_QWORD *)(v6 - 0x18);
      *(_QWORD *)(v6 - 0x18) = 0;
      v16 = v6 - 0x20;
      v24[1] = v14;
      v17 = *(_QWORD *)(v6 - 0x10);
      *(_QWORD *)(v16 + 0x10) = 0;
      v25 = v13;
      v18 = *(_QWORD *)(v6 - 8);
      *(_QWORD *)(v16 + 0x18) = 0;
      *(_QWORD *)(v6 + 8) = v15;
      *(_QWORD *)(v6 + 0x10) = v17;
      *(_QWORD *)(v6 + 0x18) = v18;
      *(_QWORD *)(a1 + 8) += 0x20LL;
      v23 = v8;
      if ( v6 - 0x20 != a3 )
      {
        do
        {
          v19 = *(_DWORD *)(v16 - 0x20);
          v20 = (_DWORD *)v16;
          v16 -= 0x20;
          *v20 = v19;
          sub_140378C90((const void **)(v16 + 0x28), (const void **)(v16 + 8));
        }
        while ( v16 != a3 );
        v8 = v23;
      }
      *(_DWORD *)a3 = v8;
      sub_140378C90((const void **)(a3 + 8), v24);
      v21 = v24[0];
      if ( v24[0] )
      {
        if ( ((v25 - (unsigned __int64)v24[0]) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
        {
          v21 = (const void *)*((_QWORD *)v24[0] + 0xFFFFFFFF);
          if ( (unsigned __int64)((char *)v24[0] - (char *)v21 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_1402A3D30(v21);
      }
    }
    result = a2;
    *a2 = a3;
  }
  return result;
}

// --- End Function: sub_146A1A160 (0x146A1A160) ---

// --- Function: sub_146A1A2E0 (0x146A1A2E0) ---
_QWORD *__fastcall sub_146A1A2E0(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v6; // r8
  __int16 v7; // ax
  _QWORD *result; // rax
  __int128 v9; // xmm0
  __int64 v10; // r14
  volatile signed __int32 **v11; // rsi
  volatile signed __int32 *v12; // rax
  volatile signed __int32 *v13; // rcx
  volatile signed __int32 *v14; // rdi
  volatile signed __int32 *v15; // rdi
  __int16 v16; // [rsp+28h] [rbp-30h] BYREF
  __int128 v17; // [rsp+30h] [rbp-28h]

  v6 = a1[1];
  if ( v6 == a1[2] )
  {
    *a2 = sub_146A12910(a1, a3, a4);
    return a2;
  }
  else
  {
    v7 = *(_WORD *)a4;
    if ( a3 == v6 )
    {
      *(_WORD *)v6 = v7;
      *(_QWORD *)(v6 + 8) = 0;
      *(_QWORD *)(v6 + 0x10) = 0;
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(a4 + 8);
      *(_QWORD *)(v6 + 0x10) = *(_QWORD *)(a4 + 0x10);
      result = a2;
      *(_QWORD *)(a4 + 8) = 0;
      *(_QWORD *)(a4 + 0x10) = 0;
      a1[1] += 0x18;
      *a2 = a3;
    }
    else
    {
      v9 = *(_OWORD *)(a4 + 8);
      *(_QWORD *)(a4 + 8) = 0;
      *(_QWORD *)(a4 + 0x10) = 0;
      v16 = v7;
      *(_WORD *)v6 = *(_WORD *)(v6 - 0x18);
      *(_QWORD *)(v6 + 8) = 0;
      *(_QWORD *)(v6 + 0x10) = 0;
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(v6 - 0x10);
      *(_QWORD *)(v6 + 0x10) = *(_QWORD *)(v6 - 8);
      v10 = v6 - 0x18;
      *(_QWORD *)(v10 + 8) = 0;
      *(_QWORD *)(v10 + 0x10) = 0;
      a1[1] += 0x18;
      v17 = v9;
      if ( v6 - 0x18 != a3 )
      {
        v11 = (volatile signed __int32 **)(v6 + 0x10);
        do
        {
          v11 += 0xFFFFFFFD;
          *((_WORD *)v11 + 0xFFFFFFF8) = *(_WORD *)(v10 - 0x18);
          v10 -= 0x18;
          v12 = v11[0xFFFFFFFC];
          v13 = v11[0xFFFFFFFD];
          v11[0xFFFFFFFC] = 0;
          v11[0xFFFFFFFD] = 0;
          v14 = *v11;
          v11[0xFFFFFFFF] = v12;
          *v11 = v13;
          if ( v14 )
          {
            if ( _InterlockedExchangeAdd(v14 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v14)(v14);
              if ( _InterlockedExchangeAdd(v14 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v14 + 8LL))(v14);
            }
          }
        }
        while ( v10 != a3 );
      }
      sub_146A0CB20(a3, (__int64)&v16);
      v15 = (volatile signed __int32 *)*((_QWORD *)&v17 + 1);
      if ( *((_QWORD *)&v17 + 1)
        && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v17 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v15)(v15);
        if ( _InterlockedExchangeAdd(v15 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v15 + 8LL))(v15);
      }
      result = a2;
      *a2 = a3;
    }
  }
  return result;
}

// --- End Function: sub_146A1A2E0 (0x146A1A2E0) ---

// --- Function: sub_146A1B960 (0x146A1B960) ---
__int64 __fastcall sub_146A1B960(__int64 a1)
{
  __int16 v2; // bp
  __int64 v3; // rax
  const vraudio::AudioBuffer **_Whereptr; // rdx
  _QWORD *v5; // rax
  __int64 v6; // rcx
  _QWORD *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rax
  _QWORD *v11; // rax
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rdi
  char *v15; // rsi
  _QWORD *v16; // rcx

  *(_QWORD *)a1 = off_148C17B90;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  v2 = *(_WORD *)(a1 + 0x28);
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  ++*(_DWORD *)(a1 + 0x28);
  *(_QWORD *)(a1 + 0x30) = sub_147605AA0(*(void **)(a1 + 0x30), 0xCu, 0);
  *(_DWORD *)(a1 + 0x20) = 0xC;
  *(_DWORD *)(a1 + 0x24) = 0xC;
  v3 = allocWithProfilerInfo(0x1000u, 0);
  *(_QWORD *)(a1 + 0x48) = v3;
  *(_QWORD *)(a1 + 0x50) = 2;
  _Whereptr = *(const vraudio::AudioBuffer ***)(a1 + 0x60);
  if ( _Whereptr == *(const vraudio::AudioBuffer ***)(a1 + 0x68) )
  {
    sub_1402A6760(
      (std::vector<vraudio::AudioBuffer const *> *)(a1 + 0x58),
      _Whereptr,
      (const vraudio::AudioBuffer **)(a1 + 0x48));
  }
  else
  {
    *_Whereptr = (const vraudio::AudioBuffer *)v3;
    *(_QWORD *)(a1 + 0x60) += 8LL;
  }
  v5 = (_QWORD *)sub_147605AA0(*(void **)(a1 + 0x38), 8LL * *(unsigned int *)(a1 + 0x28), 0);
  v6 = *(_QWORD *)(a1 + 0x48);
  *(_QWORD *)(a1 + 0x38) = v5;
  *v5 = v6;
  ***(_BYTE ***)(a1 + 0x38) = 0;
  v7 = (_QWORD *)sub_147605AA0(*(void **)(a1 + 0x40), 8LL * *(unsigned int *)(a1 + 0x28), 0);
  v8 = *(_QWORD *)(a1 + 0x48);
  *(_QWORD *)(a1 + 0x40) = v7;
  *v7 = v8 + 1;
  ***(_BYTE ***)(a1 + 0x40) = 0;
  *(_DWORD *)(a1 + 0x2C) = *(_DWORD *)(a1 + 0x28);
  v9 = *(_QWORD *)(a1 + 0x30);
  *(_WORD *)v9 = v2;
  *(_WORD *)(v9 + 2) = 0;
  *(_QWORD *)(v9 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  v10 = allocWithProfilerInfo_w(0x28u);
  *(_QWORD *)v10 = v10;
  *(_QWORD *)(v10 + 8) = v10;
  *(_QWORD *)(v10 + 0x10) = v10;
  *(_WORD *)(v10 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x88) = v10;
  *(_DWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  v11 = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  *v11 = v11;
  v11[1] = v11;
  *(_QWORD *)(a1 + 0xA0) = v11;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 7;
  *(_QWORD *)(a1 + 0xD0) = 8;
  *(_DWORD *)(a1 + 0x98) = 0x3F800000;
  std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<vraudio::Node::Output<vraudio::AudioBuffer const *> * const,std::shared_ptr<vraudio::Node>>>>>>>::_Assign_grow(
    (unsigned __int64 **)(a1 + 0xB0),
    0x10u,
    *(_QWORD *)(a1 + 0xA0));
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_QWORD *)(a1 + 0xE0) = 0;
  *(_QWORD *)(a1 + 0xE8) = 0;
  *(_QWORD *)(a1 + 0xF0) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  v12 = allocWithProfilerInfo_w(0x30u);
  *(_QWORD *)v12 = v12;
  *(_QWORD *)(v12 + 8) = v12;
  *(_QWORD *)(v12 + 0x10) = v12;
  *(_WORD *)(v12 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0xF0) = v12;
  *(_DWORD *)(a1 + 0x100) = 0;
  *(_WORD *)(a1 + 0x104) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  v13 = *(_QWORD *)(a1 + 0xD8);
  if ( (unsigned __int64)((*(_QWORD *)(a1 + 0xE8) - v13) >> 1) < 0x40 )
  {
    v14 = (*(_QWORD *)(a1 + 0xE0) - v13) >> 1;
    v15 = (char *)allocWithProfilerInfo_w(0x80u);
    memmove(v15, *(const void **)(a1 + 0xD8), *(_QWORD *)(a1 + 0xE0) - *(_QWORD *)(a1 + 0xD8));
    v16 = *(_QWORD **)(a1 + 0xD8);
    if ( v16 )
    {
      if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(a1 + 0xE8) - (_QWORD)v16) >> 1)) >= 0x1000 )
      {
        if ( (unsigned __int64)v16 - v16[0xFFFFFFFF] - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v16 = (_QWORD *)v16[0xFFFFFFFF];
      }
      sub_1402A3D30(v16);
    }
    *(_QWORD *)(a1 + 0xD8) = v15;
    *(_QWORD *)(a1 + 0xE0) = &v15[2 * v14];
    *(_QWORD *)(a1 + 0xE8) = v15 + 0x80;
  }
  return a1;
}

// --- End Function: sub_146A1B960 (0x146A1B960) ---

// --- Function: sub_146A1C9A0 (0x146A1C9A0) ---
__int64 __fastcall sub_146A1C9A0(__int64 *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    sub_146A12030(v2, a1[1]);
    v3 = (_QWORD *)*a1;
    if ( (unsigned __int64)(0x18 * ((a1[2] - *a1) / 0x18)) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)v3[0xFFFFFFFF];
    }
    sub_1402A3D30(v3);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_146A1C9A0 (0x146A1C9A0) ---

// --- Function: sub_146A1CA30 (0x146A1CA30) ---
__int64 (__fastcall **__fastcall sub_146A1CA30(__int64 a1))()
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rbx
  const void *v4; // rcx
  __int64 (__fastcall **result)(); // rax

  *(_QWORD *)a1 = off_148C17B90;
  sub_14166FBB0((const void **)(a1 + 0x108));
  sub_1403084D0(a1 + 0xF0, a1 + 0xF0, *(__int64 **)(*(_QWORD *)(a1 + 0xF0) + 8LL));
  sub_1402A3D30(*(const void **)(a1 + 0xF0));
  v2 = *(_QWORD **)(a1 + 0xD8);
  if ( v2 )
  {
    if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(a1 + 0xE8) - (_QWORD)v2) >> 1)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    *(_QWORD *)(a1 + 0xD8) = 0;
    *(_QWORD *)(a1 + 0xE0) = 0;
    *(_QWORD *)(a1 + 0xE8) = 0;
  }
  sub_1403F6E80((__int64 *)(a1 + 0x98));
  v3 = *(_QWORD **)(*(_QWORD *)(a1 + 0x88) + 8LL);
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *)(a1 + 0x88),
      (std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *)(a1 + 0x88),
      (std::_Tree_node<gte::Logger::Listener *,void *> *)v3[2]);
    v4 = v3;
    v3 = (_QWORD *)*v3;
    sub_1402A3D30(v4);
  }
  sub_1402A3D30(*(const void **)(a1 + 0x88));
  sub_146A1C9A0((__int64 *)(a1 + 0x70));
  sub_1408FBC10(a1 + 0x20);
  sub_14195D2E0((__int64 *)(a1 + 8));
  result = &off_1481C0BC8;
  *(_QWORD *)a1 = &off_1481C0BC8;
  return result;
}

// --- End Function: sub_146A1CA30 (0x146A1CA30) ---

// --- Function: sub_146A1CF50 (0x146A1CF50) ---
void __fastcall sub_146A1CF50(_QWORD *a1)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rcx

  v2 = (_QWORD *)a1[6];
  if ( v2 )
  {
    if ( ((a1[8] - (_QWORD)v2) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        goto LABEL_11;
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    a1[6] = 0;
    a1[7] = 0;
    a1[8] = 0;
  }
  v3 = (_QWORD *)a1[3];
  if ( !v3 )
    return;
  if ( (unsigned __int64)(2 * ((__int64)(a1[5] - (_QWORD)v3) >> 1)) >= 0x1000 )
  {
    if ( (unsigned __int64)v3 - v3[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v3 = (_QWORD *)v3[0xFFFFFFFF];
      goto LABEL_10;
    }
LABEL_11:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_1402A3D30(v3);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
}

// --- End Function: sub_146A1CF50 (0x146A1CF50) ---

// --- Function: sub_146A1D000 (0x146A1D000) ---
__int64 __fastcall sub_146A1D000(__int64 a1, __int64 a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(_BYTE *)(a1 + 0xA) = *(_BYTE *)(a2 + 0xA);
  *(_BYTE *)(a1 + 0xB) = *(_BYTE *)(a2 + 0xB);
  *(_BYTE *)(a1 + 0xC) = *(_BYTE *)(a2 + 0xC);
  *(_DWORD *)(a1 + 0x10) = *(_DWORD *)(a2 + 0x10);
  *(_BYTE *)(a1 + 0x14) = *(_BYTE *)(a2 + 0x14);
  *(_BYTE *)(a1 + 0x15) = *(_BYTE *)(a2 + 0x15);
  sub_140378B00((_QWORD *)(a1 + 0x18), (_QWORD *)(a2 + 0x18));
  sub_140378C90((const void **)(a1 + 0x30), (const void **)(a2 + 0x30));
  return a1;
}

// --- End Function: sub_146A1D000 (0x146A1D000) ---

// --- Function: sub_146A1D080 (0x146A1D080) ---
__int64 __fastcall sub_146A1D080(__int64 *a1, unsigned __int16 *a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // r9
  unsigned __int16 v6; // r11
  __int64 v7; // rax
  int v8; // edi
  __int64 v9; // rdx
  __int64 v10; // rax
  unsigned __int16 v11; // r9
  __int64 *v12; // rax
  const void *v13; // rcx
  int v15; // [rsp+20h] [rbp-28h] BYREF
  __int128 v16; // [rsp+28h] [rbp-20h]
  __int64 v17; // [rsp+38h] [rbp-10h]
  __int64 v18; // [rsp+50h] [rbp+8h] BYREF

  v2 = a1[1];
  v3 = *a1;
  v4 = (v2 - *a1) >> 5;
  v5 = v4;
  if ( v4 )
  {
    v6 = *a2;
    do
    {
      v7 = 0x20 * (v5 >> 1);
      if ( *(_WORD *)(v7 + v3) < v6 || *(_WORD *)(v7 + v3) <= v6 && *(_BYTE *)(v7 + v3 + 2) < *((_BYTE *)a2 + 2) )
      {
        v3 += v7 + 0x20;
        v5 += 0xFFFFFFFFFFFFFFFFuLL - (v5 >> 1);
      }
      else
      {
        v5 >>= 1;
      }
    }
    while ( v5 );
  }
  if ( v3 == v2 )
    goto LABEL_15;
  if ( *a2 < *(_WORD *)v3 || *a2 <= *(_WORD *)v3 && *((_BYTE *)a2 + 2) < *(_BYTE *)(v3 + 2) )
    v3 = a1[1];
  if ( v3 == v2 )
  {
LABEL_15:
    v8 = *(_DWORD *)a2;
    v9 = 0;
    v3 = *a1;
    v15 = v8;
    v17 = 0;
    v16 = 0;
    while ( v4 )
    {
      v10 = 0x20 * (v4 >> 1);
      v11 = *(_WORD *)(v10 + v3);
      if ( v11 < (unsigned __int16)v8 || (unsigned __int16)v8 >= v11 && *(_BYTE *)(v10 + v3 + 2) < BYTE2(v8) )
      {
        v3 += v10 + 0x20;
        v4 += 0xFFFFFFFFFFFFFFFFuLL - (v4 >> 1);
      }
      else
      {
        v4 >>= 1;
      }
    }
    if ( v3 == v2
      || (unsigned __int16)v8 < *(_WORD *)v3
      || (unsigned __int16)v8 <= *(_WORD *)v3 && BYTE2(v8) < *(_BYTE *)(v3 + 2) )
    {
      v12 = sub_146A1A160((__int64)a1, &v18, v3, &v15);
      v9 = v17;
      v3 = *v12;
    }
    v13 = (const void *)v16;
    if ( (_QWORD)v16 )
    {
      if ( ((v9 - (_QWORD)v16) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
      {
        v13 = *(const void **)(v16 - 8);
        if ( (unsigned __int64)(v16 - (_QWORD)v13 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v13);
    }
  }
  return v3 + 8;
}

// --- End Function: sub_146A1D080 (0x146A1D080) ---

// --- Function: sub_146A1D220 (0x146A1D220) ---
_WORD *__fastcall sub_146A1D220(__int64 a1, __int16 *a2)
{
  _WORD *v2; // r9
  _WORD *v3; // rbx
  unsigned __int64 v4; // r8
  __int64 v5; // rax
  _WORD **v6; // rax
  const void *v7; // rcx
  _BYTE v9[16]; // [rsp+20h] [rbp-38h] BYREF
  __int16 v10; // [rsp+30h] [rbp-28h] BYREF
  __int128 v11; // [rsp+38h] [rbp-20h]
  __int64 v12; // [rsp+48h] [rbp-10h]

  v2 = *(_WORD **)(a1 + 8);
  v3 = *(_WORD **)a1;
  v4 = ((__int64)v2 - *(_QWORD *)a1) >> 5;
  while ( v4 )
  {
    v5 = 0x10 * (v4 >> 1);
    if ( v3[v5] >= (unsigned __int16)*a2 )
    {
      v4 >>= 1;
    }
    else
    {
      v3 = (_WORD *)((char *)v3 + v5 * 2 + 0x20);
      v4 += 0xFFFFFFFFFFFFFFFFuLL - (v4 >> 1);
    }
  }
  if ( v3 == v2 )
    goto LABEL_10;
  if ( (unsigned __int16)*a2 < *v3 )
    v3 = *(_WORD **)(a1 + 8);
  if ( v3 == v2 )
  {
LABEL_10:
    v10 = *a2;
    v12 = 0;
    v11 = 0;
    v6 = (_WORD **)sub_146A49DC0(a1, v9, &v10);
    v7 = (const void *)v11;
    v3 = *v6;
    if ( (_QWORD)v11 )
    {
      if ( (unsigned __int64)(2 * ((v12 - (__int64)v11) >> 1)) >= 0x1000 )
      {
        v7 = *(const void **)(v11 - 8);
        if ( (unsigned __int64)(v11 - (_QWORD)v7 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v7);
    }
  }
  return v3 + 4;
}

// --- End Function: sub_146A1D220 (0x146A1D220) ---

// --- Function: sub_146A24480 (0x146A24480) ---
char *__fastcall sub_146A24480(char *a1, char a2)
{
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  const void *v6; // rcx

  *(_QWORD *)a1 = off_148C17B90;
  sub_14166FBB0((const void **)a1 + 0x21);
  sub_1403084D0((__int64)(a1 + 0xF0), (__int64)(a1 + 0xF0), *(__int64 **)(*((_QWORD *)a1 + 0x1E) + 8LL));
  sub_1402A3D30(*((const void **)a1 + 0x1E));
  v4 = (_QWORD *)*((_QWORD *)a1 + 0x1B);
  if ( v4 )
  {
    if ( (unsigned __int64)(2 * ((__int64)(*((_QWORD *)a1 + 0x1D) - (_QWORD)v4) >> 1)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    *((_QWORD *)a1 + 0x1B) = 0;
    *((_QWORD *)a1 + 0x1C) = 0;
    *((_QWORD *)a1 + 0x1D) = 0;
  }
  sub_1403F6E80((__int64 *)a1 + 0x13);
  v5 = *(_QWORD **)(*((_QWORD *)a1 + 0x11) + 8LL);
  while ( !*((_BYTE *)v5 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *>>::_Erase_tree<std::allocator<std::_Tree_node<gte::Logger::Listener *,void *>>>(
      (std::_Tree_val<std::_Tree_simple_types<gte::Logger::Listener *> > *)(a1 + 0x88),
      (std::allocator<std::_Tree_node<gte::Logger::Listener *,void *> > *)(a1 + 0x88),
      (std::_Tree_node<gte::Logger::Listener *,void *> *)v5[2]);
    v6 = v5;
    v5 = (_QWORD *)*v5;
    sub_1402A3D30(v6);
  }
  sub_1402A3D30(*((const void **)a1 + 0x11));
  sub_146A1C9A0((__int64 *)a1 + 0xE);
  sub_1408FBC10((__int64)(a1 + 0x20));
  sub_14195D2E0((__int64 *)a1 + 1);
  *(_QWORD *)a1 = &off_1481C0BC8;
  if ( (a2 & 1) != 0 )
    sub_1402A3D30(a1);
  return a1;
}

// --- End Function: sub_146A24480 (0x146A24480) ---

// --- Function: sub_146A24990 (0x146A24990) ---
double __fastcall sub_146A24990(__int64 a1, __int64 a2, char a3, char a4)
{
  __int64 v7; // r8
  unsigned __int64 v8; // rdx
  __int64 n0xE; // r12
  __int64 v10; // rbx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rcx
  __int64 v13; // rcx
  bool v14; // r15
  volatile signed __int64 *v15; // rdi
  signed __int64 v16; // rdx
  int n0xE_1; // ecx
  char v18; // si
  _OWORD *v19; // rax
  char v20; // si
  unsigned __int64 p_p_sub_146A26220[2]; // [rsp+30h] [rbp-69h] BYREF
  int n0x1000; // [rsp+40h] [rbp-59h] BYREF
  __int64 v24; // [rsp+44h] [rbp-55h]
  int v25; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v26; // [rsp+50h] [rbp-49h]
  unsigned __int64 v27; // [rsp+58h] [rbp-41h]
  __int64 v28; // [rsp+60h] [rbp-39h]
  __int64 v29; // [rsp+68h] [rbp-31h]
  __int128 v30; // [rsp+90h] [rbp-9h]
  __int64 v31; // [rsp+A0h] [rbp+7h] BYREF
  char v32; // [rsp+A8h] [rbp+Fh]
  __int64 v33; // [rsp+B0h] [rbp+17h] BYREF
  char v34; // [rsp+B8h] [rbp+1Fh]
  __int64 v35; // [rsp+108h] [rbp+6Fh]

  n0x1000 = 0x1000;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v24 = 1;
  v26 = __rdtsc();
  qword_149B4B870(
    &n0x1000,
    &word_1515B005C,
    "CEntityComponentUpdateScheduler::ActivateComponent",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\ComponentSystemCore/EntityComponentUpdateScheduler.cpp",
    0xF65);
  HIWORD(n0x1000) = word_1515B005C;
  p_p_sub_146A26220[0] = *(_QWORD *)(a2 + 8);
  if ( !sub_14030EC00(p_p_sub_146A26220) )
    goto LABEL_39;
  v7 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v8 = __popcnt(*(_QWORD *)(v7 + a1 + 0x42B8) & ((1LL << a3) - 1));
  n0xE = *(int *)(*(_QWORD *)(v7 + a1 + 0x4150) + 0x20 * v8 + 0xC);
  v10 = *(_QWORD *)(a2 + 0x18) + 0xC * v8;
  v11 = p_p_sub_146A26220[0];
  if ( p_p_sub_146A26220[0] )
  {
    v12 = (p_p_sub_146A26220[0] & 0xF000000000000000uLL) != 0
        ? p_p_sub_146A26220[0] & 0xFFFFFF000000LL
        : (p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL) - 6;
    if ( *(_WORD *)(v12 + 2) == (HIWORD(p_p_sub_146A26220[0]) & 0xFFF) )
    {
      if ( *(_WORD *)(v12 + 4) < 3u )
      {
LABEL_10:
        if ( (v11 & 0xFFFFFFFFFFFFLL) != 0 )
        {
          v13 = (v11 & 0xF000000000000000uLL) != 0 ? v11 & 0xFFFFFF000000LL : (v11 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v13 + 4) == 1 )
          {
            _InterlockedOr8((volatile signed __int8 *)(v10 + 0xB), 2u);
            goto LABEL_39;
          }
        }
        goto LABEL_16;
      }
      if ( check_thread_state_and_value_not_equal((_QWORD *)(p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL)) )
      {
        v11 = p_p_sub_146A26220[0];
        goto LABEL_10;
      }
    }
  }
LABEL_16:
  v14 = !sub_140539D80() && !*(_BYTE *)(NtCurrentTeb_w() + 0x12D);
  v35 = a1 + 0x478 * n0xE;
  v15 = (volatile signed __int64 *)(v35 + 0x1D0);
  if ( *(_DWORD *)(v35 + 0x1E0) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(v35 + 0x1E4);
  }
  else
  {
    v16 = _InterlockedIncrement64(v15);
    if ( (v16 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)v15,
        v16,
        "CEntityComponentUpdateScheduler::ActivateComponent",
        "m_perPassState[nPass].bIsRunningLock",
        1);
  }
  if ( a4
    || v14
    || (n0xE_1 = *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x920LL),
        n0xE_1 == 0x10)
    || n0xE_1 != (_DWORD)n0xE && *(_BYTE *)(v35 + 0x1C9) )
  {
    v34 = a3;
    v33 = a2;
    _InterlockedIncrement16((volatile signed __int16 *)(a2 + 0x22));
    sub_1403CA640(a1 + 0x30, &v33, 0x10u);
  }
  else if ( !*(_BYTE *)(v10 + 9) )
  {
    if ( n0xE_1 == (_DWORD)n0xE )
    {
      if ( !*(_BYTE *)(v10 + 0xA) )
      {
        v18 = *(_BYTE *)(v10 + 0xA);
        *(_BYTE *)(v10 + 0xA) = 1;
        if ( !v18 )
        {
          *(_QWORD *)&v30 = a2;
          BYTE8(v30) = a3;
          v19 = (_OWORD *)sub_1403CA4D0(a1 + 0x174970, 0x10u, 0);
          *v19 = v30;
        }
      }
    }
    else
    {
      v20 = *(_BYTE *)(v10 + 9);
      *(_BYTE *)(v10 + 9) = 1;
      if ( !v20 )
      {
        *(_BYTE *)(v10 + 7) = 0;
        v31 = a2;
        v32 = a3;
        if ( (unsigned __int8)sub_146A4A420((p_p_sub_146A26220[0] & 0xFFFFFFFFFFFFLL) + 0x18 * (n0xE + 0x25), &v31, 0) )
          sub_146A24D00(a1, p_p_sub_146A26220, (unsigned int)n0xE, 0);
      }
    }
  }
  sub_1402D2790((__int64)v15);
LABEL_39:
  v27 = __rdtsc();
  return qword_149B4B878(&n0x1000);
}

// --- End Function: sub_146A24990 (0x146A24990) ---

// --- Function: sub_146A24D00 (0x146A24D00) ---
void __fastcall sub_146A24D00(__int64 a1, unsigned __int64 *p_p_sub_146A26220, unsigned __int64 n0xE, char a4)
{
  __int64 n0xE_1; // r12
  __int64 v8; // r15
  unsigned __int64 v9; // rsi
  __int64 v10; // rax
  unsigned __int64 v11; // rbx
  __int64 v12; // rax
  char v13; // al
  volatile signed __int64 *v14; // rbx
  signed __int64 v15; // rdx
  unsigned __int64 v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v19; // [rsp+78h] [rbp+10h] BYREF

  n0xE_1 = (int)n0xE;
  v8 = 0x18LL * (int)n0xE;
  while ( 1 )
  {
    v9 = *p_p_sub_146A26220 & 0xFFFFFFFFFFFFLL;
    v10 = sub_14030EC00((unsigned __int64 *)(v9 + 0x4C8)) ? *(_QWORD *)(v9 + 0x4C8) & 0xFFFFFFFFFFFFLL : 0LL;
    if ( v9 == v10 )
      break;
    v11 = *p_p_sub_146A26220 & 0xFFFFFFFFFFFFLL;
    if ( !sub_14030EC00((unsigned __int64 *)(v11 + 0x4C0))
      || (v12 = *(_QWORD *)(v11 + 0x4C0) & 0xFFFFFFFFFFFFLL, *(_BYTE *)(v12 + 0xD) >= 5u) )
    {
      v14 = (volatile signed __int64 *)(a1 + 0x1749C0);
      if ( !a4 )
      {
        v15 = _InterlockedIncrement64(v14);
        if ( (v15 & 0x200000) != 0 )
          sub_1403CB300(
            a1 + 0x1749C0,
            v15,
            "CEntityComponentUpdateScheduler::ActivateComponent_AddToHierarchy_Recursive",
            "m_arDeferredECUSGroupsHierarchyUpdateLock",
            1);
        v16 = _InterlockedDecrement64(v14);
        if ( (v16 & 0x3FF) == 0 && (v16 & 0xFFFF0000FFC00000uLL) != 0 )
          sub_1403CB820((volatile signed __int64 *)(a1 + 0x1749C0), v16);
      }
      return;
    }
    if ( *(_DWORD *)(v8 + v9 + 0x374) != 0xFFFFFFFF )
      return;
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(v8 + v9 + 0x374), 0xFFFFFFFE, 0xFFFFFFFF) != 0xFFFFFFFF )
      return;
    v18 = 0xFFFFFFFFFFFFFFFFuLL;
    v13 = sub_146A4A620(v8 + v12 + 0x380, p_p_sub_146A26220, &v18);
    _InterlockedExchange((volatile __int32 *)(v8 + v9 + 0x374), v18);
    if ( !v13 )
      return;
    p_p_sub_146A26220 = (unsigned __int64 *)(v11 + 0x4C0);
  }
  if ( *(_DWORD *)(v8 + v9 + 0x370) == 0xFFFFFFFF
    && _InterlockedCompareExchange((volatile signed __int32 *)(v8 + v9 + 0x370), 0xFFFFFFFE, 0xFFFFFFFF) == 0xFFFFFFFF )
  {
    v19 = 0xFFFFFFFFFFFFFFFFuLL;
    v17 = (_QWORD *)sub_1403CA4D0(a1 + 0x478 * n0xE_1 + 0x5E8, 8u, (signed __int64 *)&v19);
    v19 >>= 3;
    *v17 = *p_p_sub_146A26220;
    _InterlockedExchange((volatile __int32 *)(v8 + v9 + 0x370), v19);
  }
}

// --- End Function: sub_146A24D00 (0x146A24D00) ---

// --- Function: sub_146A24F10 (0x146A24F10) ---
unsigned __int64 __fastcall sub_146A24F10(__int64 a1, const vraudio::AudioBuffer *__Val_0___1, __int64 a3)
{
  __int64 v4; // rbx
  const vraudio::AudioBuffer *__Val_0___2; // rsi
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v7; // ebp
  __int64 v8; // r8
  __int64 __Val_0___3; // rdx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  int v11; // eax
  unsigned __int64 n0x200000; // rax
  const vraudio::AudioBuffer *__Val_0__; // [rsp+58h] [rbp+10h] BYREF

  __Val_0__ = __Val_0___1;
  v4 = a3 + 0x10;
  __Val_0___2 = __Val_0___1;
  p_p_p_p_p_p_p_p_p_p_p_p_Source = NtCurrentTeb_w();
  v7 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v8 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    p_p_p_p_p_p_p_p_p_p_p_p_Source = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0x200000, 0);
    if ( p_p_p_p_p_p_p_p_p_p_p_p_Source )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1403DCD60(
                                         v4,
                                         p_p_p_p_p_p_p_p_p_p_p_p_Source,
                                         v8,
                                         "CEntityComponentUpdateScheduler::ActivateDebugUpdate",
                                         "pAllocator->lock",
                                         1);
    else
      *(_QWORD *)(v4 + 8) = v8;
    __Val_0___2 = __Val_0__;
    *(_DWORD *)(v4 + 0x10) = v7;
  }
  if ( !*((_BYTE *)__Val_0___2 + 0x68) )
  {
    __Val_0___3 = *(_QWORD *)(*(_QWORD *)(a3 + 0x2D0) - 8LL);
    if ( (const vraudio::AudioBuffer *)__Val_0___3 != __Val_0___2 )
    {
      *(_QWORD *)(*(_QWORD *)(a3 + 0x2C8) + 8LL * *((unsigned int *)__Val_0___2 + 0x19)) = __Val_0___3;
      *(_DWORD *)(__Val_0___3 + 0x64) = *((_DWORD *)__Val_0___2 + 0x19);
    }
    *(_QWORD *)(a3 + 0x2D0) -= 8LL;
    _Whereptr = *(const vraudio::AudioBuffer ***)(a3 + 0x2B8);
    if ( _Whereptr == *(const vraudio::AudioBuffer ***)(a3 + 0x2C0) )
    {
      sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)(a3 + 0x2B0), _Whereptr, &__Val_0__);
    }
    else
    {
      *_Whereptr = __Val_0___2;
      *(_QWORD *)(a3 + 0x2B8) += 8LL;
    }
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)((__int64)(*(_QWORD *)(a3 + 0x2B8) - *(_QWORD *)(a3 + 0x2B0)) >> 3)
                                   - 1;
    *((_DWORD *)__Val_0___2 + 0x19) = p_p_p_p_p_p_p_p_p_p_p_p_Source;
    *((_BYTE *)__Val_0___2 + 0x68) = 1;
  }
  if ( v4 )
  {
    v11 = *(_DWORD *)(v4 + 0x14);
    if ( v11 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)(v11 - 1);
      *(_DWORD *)(v4 + 0x14) = p_p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v4 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return (unsigned __int64)sub_1403DD380(v4, n0x200000);
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_146A24F10 (0x146A24F10) ---

// --- Function: sub_146A25430 (0x146A25430) ---
__int64 __fastcall sub_146A25430(__int64 a1, unsigned __int16 a2, char *a3, __int64 a4, unsigned __int8 *a5)
{
  unsigned int v5; // eax
  __int64 v8; // r15
  __int64 v10; // rax
  __int64 v11; // rdx
  void *v12; // rcx
  __int64 v13; // rax
  const vraudio::AudioBuffer **_Whereptr; // rdx
  _BYTE *v15; // rcx
  char v16; // al
  unsigned __int8 *v17; // rdi
  unsigned __int64 v18; // rsi
  __int64 v19; // rax
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  __int64 v21; // rax
  _BYTE *v22; // rdx
  __int64 result; // rax

  v5 = *(_DWORD *)(a1 + 8);
  v8 = a2;
  if ( v5 >= *(_DWORD *)(a1 + 0xC) )
  {
    v10 = sub_147605AA0(*(void **)(a1 + 0x18), 8LL * v5, 0);
    v11 = *(unsigned int *)(a1 + 8);
    v12 = *(void **)(a1 + 0x20);
    *(_QWORD *)(a1 + 0x18) = v10;
    *(_QWORD *)(a1 + 0x20) = sub_147605AA0(v12, 8 * v11, 0);
    *(_DWORD *)(a1 + 0xC) = *(_DWORD *)(a1 + 8);
  }
  if ( (unsigned __int64)(a4 + *(_QWORD *)(a1 + 0x30) + 1LL) > 0x1000 )
  {
    v13 = allocWithProfilerInfo(0x1000u, 0);
    *(_QWORD *)(a1 + 0x28) = v13;
    *(_QWORD *)(a1 + 0x30) = 0;
    _Whereptr = *(const vraudio::AudioBuffer ***)(a1 + 0x40);
    if ( _Whereptr == *(const vraudio::AudioBuffer ***)(a1 + 0x48) )
    {
      sub_1402A6760(
        (std::vector<vraudio::AudioBuffer const *> *)(a1 + 0x38),
        _Whereptr,
        (const vraudio::AudioBuffer **)(a1 + 0x28));
    }
    else
    {
      *_Whereptr = (const vraudio::AudioBuffer *)v13;
      *(_QWORD *)(a1 + 0x40) += 8LL;
    }
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 0x18) + 8 * v8) = *(_QWORD *)(a1 + 0x30) + *(_QWORD *)(a1 + 0x28);
  *(_QWORD *)(a1 + 0x30) += a4 + 1;
  v15 = *(_BYTE **)(*(_QWORD *)(a1 + 0x18) + 8 * v8);
  do
  {
    v16 = *a3++;
    *v15++ = v16;
  }
  while ( v16 );
  v17 = a5;
  v18 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v18;
  while ( a5[v18] );
  if ( v18 + *(_QWORD *)(a1 + 0x30) + 1LL > 0x1000 )
  {
    v19 = allocWithProfilerInfo(0x1000u, 0);
    *(_QWORD *)(a1 + 0x28) = v19;
    *(_QWORD *)(a1 + 0x30) = 0;
    _Whereptr_1 = *(const vraudio::AudioBuffer ***)(a1 + 0x40);
    if ( _Whereptr_1 == *(const vraudio::AudioBuffer ***)(a1 + 0x48) )
    {
      sub_1402A6760(
        (std::vector<vraudio::AudioBuffer const *> *)(a1 + 0x38),
        _Whereptr_1,
        (const vraudio::AudioBuffer **)(a1 + 0x28));
    }
    else
    {
      *_Whereptr_1 = (const vraudio::AudioBuffer *)v19;
      *(_QWORD *)(a1 + 0x40) += 8LL;
    }
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 0x20) + 8 * v8) = *(_QWORD *)(a1 + 0x28) + *(_QWORD *)(a1 + 0x30);
  v21 = *(_QWORD *)(a1 + 0x20);
  *(_QWORD *)(a1 + 0x30) += v18 + 1;
  v22 = *(_BYTE **)(v21 + 8 * v8);
  do
  {
    result = *v17++;
    *v22++ = result;
  }
  while ( (_BYTE)result );
  return result;
}

// --- End Function: sub_146A25430 (0x146A25430) ---

// --- Function: sub_146A27DC0 (0x146A27DC0) ---
unsigned __int64 __fastcall sub_146A27DC0(__int64 a1, unsigned __int16 a2, __int16 a3)
{
  __int64 v3; // rsi
  __int64 v5; // rbp
  __int64 v6; // rbx
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // edi
  __int64 v9; // r8
  int v10; // eax
  unsigned __int64 n0x200000; // rax

  v3 = qword_1515B19F0;
  v5 = 0x2E0LL * a2;
  v6 = v5 + qword_1515B19F0 + 0x4068;
  p_p_p_p_p_p_p_p_p_p_p_p_Source = NtCurrentTeb_w();
  v8 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18);
  if ( *(_DWORD *)(v6 + 0x10) == v8 )
  {
    ++*(_DWORD *)(v6 + 0x14);
  }
  else
  {
    v9 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    p_p_p_p_p_p_p_p_p_p_p_p_Source = _InterlockedCompareExchange64((volatile signed __int64 *)v6, 0x200000, 0);
    if ( p_p_p_p_p_p_p_p_p_p_p_p_Source )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1403DCD60(
                                         v6,
                                         p_p_p_p_p_p_p_p_p_p_p_p_Source,
                                         v9,
                                         "CEntityComponentUpdateScheduler::ChangeComponentDebugUpdatePolicy",
                                         "pAllocator->lock",
                                         1);
    else
      *(_QWORD *)(v6 + 8) = v9;
    *(_DWORD *)(v6 + 0x10) = v8;
  }
  *(_WORD *)(v5 + v3 + 0x4098) = a3;
  *(_BYTE *)(v3 + 0x1F4F62) = 1;
  if ( v6 )
  {
    v10 = *(_DWORD *)(v6 + 0x14);
    if ( v10 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)(v10 - 1);
      *(_DWORD *)(v6 + 0x14) = p_p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      *(_DWORD *)(v6 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v6, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v6 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return (unsigned __int64)sub_1403DD380(v6, n0x200000);
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_146A27DC0 (0x146A27DC0) ---

// --- Function: sub_146A28460 (0x146A28460) ---
__int64 __fastcall sub_146A28460(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v6; // rax
  _BYTE *v7; // rdx
  _QWORD *v8; // r12
  __int64 n4; // rcx
  bool v10; // zf
  _BYTE *v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r10
  __int64 v16; // r11
  __int64 v17; // rdi
  __int64 v18; // rsi
  __int64 n4_1; // rcx
  _QWORD *v20; // rdi
  _QWORD *i; // rbp
  __int64 v22; // rbx
  __int64 v23; // rdx
  char *v24; // r8
  char *v25; // r9
  char *v26; // r10
  __int64 v27; // rcx
  __int64 n4_2; // rdx
  bool v29; // al
  __int64 v30; // rsi
  __int64 v31; // rdx
  __int64 v32; // rax
  unsigned __int16 v33; // cx
  __int64 v34; // rax
  __int128 v35; // xmm0
  int v36; // ecx
  __int128 v37; // [rsp+20h] [rbp-78h] BYREF
  double v38; // [rsp+40h] [rbp-58h] BYREF
  int v39; // [rsp+48h] [rbp-50h] BYREF

  result = sub_142306700(a2);
  if ( *(_DWORD *)((*(_QWORD *)result & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF )
  {
    v6 = sub_146B49880(qword_1515B1A08, (_QWORD *)result);
    v7 = (_BYTE *)(a3 + 0x2A0);
    v8 = (_QWORD *)v6;
    n4 = 4;
    do
    {
      v10 = (v7++)[v6 - a3 - 0x22C] == 0;
      v7[0xFFFFFFFF] = !v10;
      v7[3] = v7[v6 - a3 - 0x225] != 0;
      v7[7] = v7[v6 - a3 - 0x1ED];
      v7[0xB] = v7[v6 - a3 - 0x231] != 0;
      v7[0xF] = v7[v6 - a3 - 0x229] != 0;
      v7[0x13] = v7[v6 - a3 - 0x1E9];
      --n4;
    }
    while ( n4 );
    result = *(unsigned __int16 *)(a2 + 0x2EC);
    if ( (_WORD)result != 0xFFFF )
    {
      v11 = (_BYTE *)(a3 + 0x2B8);
      v12 = v8[1] + 0x38 * result - a3;
      v13 = v12 - 0x29C;
      v14 = v12 - 0x294;
      v15 = v12 - 0x290;
      v16 = v12 - 0x2A0;
      v17 = v12 - 0x298;
      v18 = v12 - 0x28C;
      n4_1 = 4;
      do
      {
        v10 = (v11++)[v13] == 0;
        v11[0xFFFFFFFF] = !v10;
        v11[3] = v11[v14 - 1] != 0;
        v11[7] = v11[v15 - 1];
        v11[0xB] = v11[v16 - 1] != 0;
        v11[0xF] = v11[v17 - 1] != 0;
        result = (unsigned __int8)v11[v18 - 1];
        v11[0x13] = result;
        --n4_1;
      }
      while ( n4_1 );
    }
    v20 = *(_QWORD **)(a2 + 0x240);
    for ( i = *(_QWORD **)(a2 + 0x248); v20 != i; ++v20 )
    {
      v22 = *v20 & 0xFFFFFFFFFFFFLL;
      result = *(unsigned __int16 *)(v22 + 0x62);
      if ( (_WORD)result != 0xFFFF )
      {
        v23 = *v8 + 0x20LL * *(unsigned __int16 *)(v22 + 0x62);
        v24 = (char *)&v38 - v23;
        v25 = (char *)&v38 - v23 + 4;
        v26 = (char *)&v39 - v23;
        v27 = v23 + 0x10;
        n4_2 = 4;
        do
        {
          v10 = *(_BYTE *)(v27 - 4) == 0;
          ++v27;
          v29 = !v10;
          v10 = *(_BYTE *)(v27 - 1) == 0;
          v24[v27 - 0x11] = v29;
          v25[v27 - 0x11] = !v10;
          v26[v27 - 0x11] = *(_BYTE *)(v27 + 3);
          --n4_2;
        }
        while ( n4_2 );
        v30 = *(_QWORD *)(a3 + 0x2D0);
        DWORD2(v37) = 0;
        v31 = v30;
        v32 = *(_QWORD *)(v30 + 8);
        *(_QWORD *)&v37 = v32;
        if ( !*(_BYTE *)(v32 + 0x19) )
        {
          v33 = *(_WORD *)(v22 + 0x10);
          do
          {
            *(_QWORD *)&v37 = v32;
            if ( *(_WORD *)(v32 + 0x1A) >= v33 )
            {
              v31 = v32;
              DWORD2(v37) = 1;
              v32 = *(_QWORD *)v32;
            }
            else
            {
              v32 = *(_QWORD *)(v32 + 0x10);
              DWORD2(v37) = 0;
            }
          }
          while ( !*(_BYTE *)(v32 + 0x19) );
        }
        if ( *(_BYTE *)(v31 + 0x19)
          || (result = *(unsigned __int16 *)(v31 + 0x1A), *(_WORD *)(v22 + 0x10) < (unsigned __int16)result) )
        {
          if ( *(_QWORD *)(a3 + 0x2D8) == 0x666666666666666LL )
            unknown_libname_7();
          v34 = allocWithProfilerInfo_w(0x28u);
          v35 = v37;
          *(_WORD *)(v34 + 0x1A) = *(_WORD *)(v22 + 0x10);
          *(_QWORD *)(v34 + 0x1C) = 0;
          *(_DWORD *)(v34 + 0x24) = 0;
          *(_QWORD *)v34 = v30;
          *(_QWORD *)(v34 + 8) = v30;
          *(_QWORD *)(v34 + 0x10) = v30;
          *(_WORD *)(v34 + 0x18) = 0;
          v37 = v35;
          result = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                     (__int64 **)(a3 + 0x2D0),
                     (__int64)&v37,
                     v34);
          v31 = result;
        }
        v36 = v39;
        *(double *)(v31 + 0x1C) = v38;
        *(_DWORD *)(v31 + 0x24) = v36;
      }
    }
  }
  return result;
}

// --- End Function: sub_146A28460 (0x146A28460) ---

// --- Function: sub_146A28BD0 (0x146A28BD0) ---
unsigned __int64 __fastcall sub_146A28BD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int16 *v4; // r13
  __int64 *v5; // rbx
  _QWORD *v6; // r11
  unsigned __int64 v7; // r15
  int n0xE; // r14d
  __int64 **v9; // rax
  __int64 *v10; // rdi
  __int64 *v11; // r12
  __int64 v12; // rsi
  __int16 v13; // r10
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rcx
  __int64 v16; // rax
  bool v17; // zf
  __int64 v18; // rdx
  __int64 v19; // r14
  const void **v20; // rax
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 *v23; // rcx
  const void *v24; // rcx
  _BYTE *v25; // rcx
  __int64 v26; // r8
  __int64 v27; // rbx
  unsigned __int64 result; // rax
  _QWORD *v29; // rsi
  __int64 v30; // rdi
  float v31; // ecx
  __int64 v32; // rax
  unsigned __int8 v33; // cf
  __int64 *v34; // rcx
  __m256 *v35; // rdx
  int n0xE_2; // [rsp+30h] [rbp-79h]
  __int16 v37; // [rsp+34h] [rbp-75h] BYREF
  char v38; // [rsp+36h] [rbp-73h]
  _QWORD *v39; // [rsp+38h] [rbp-71h]
  __int64 **v40; // [rsp+40h] [rbp-69h]
  __int16 v41; // [rsp+50h] [rbp-59h] BYREF
  char v42; // [rsp+52h] [rbp-57h]
  int v43; // [rsp+54h] [rbp-55h]
  __int16 v44; // [rsp+58h] [rbp-51h]
  char v45; // [rsp+5Ah] [rbp-4Fh]
  char v46; // [rsp+5Bh] [rbp-4Eh]
  char v47; // [rsp+5Ch] [rbp-4Dh]
  int n0xE_1; // [rsp+60h] [rbp-49h]
  bool v49; // [rsp+64h] [rbp-45h]
  bool v50; // [rsp+65h] [rbp-44h]
  _BYTE *v51; // [rsp+68h] [rbp-41h] BYREF
  __int128 v52; // [rsp+70h] [rbp-39h]
  __int128 v53; // [rsp+80h] [rbp-29h] BYREF
  __int64 v54; // [rsp+90h] [rbp-19h]
  __m256 v55; // [rsp+A0h] [rbp-9h] BYREF
  __int64 v57; // [rsp+118h] [rbp+6Fh]

  v57 = a2;
  v4 = (__int16 *)(a2 + 0x10);
  v5 = (__int64 *)(a4 + 8);
  v6 = (_QWORD *)(a1 + 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10) + 0x4058);
  v7 = 0;
  v39 = v6;
  n0xE = 0;
  n0xE_2 = 0;
  v9 = (__int64 **)(v6 + 0x22);
  v40 = (__int64 **)(v6 + 0x22);
  do
  {
    v10 = *v9;
    v11 = v9[1];
    if ( *v9 != v11 )
    {
      do
      {
        v12 = *v10;
        v13 = *(_WORD *)(*v10 + 8);
        if ( v13 )
        {
          v42 = *(_BYTE *)(v12 + 0x10);
          v51 = 0;
          v14 = v6[0x4C] & ((1LL << v42) - 1);
          v52 = 0;
          v15 = 3 * __popcnt(v14);
          v54 = 0;
          v16 = *(_QWORD *)(a2 + 0x18);
          v17 = *(_BYTE *)(v16 + 4 * v15) == 0;
          v18 = v16 + 4 * v15;
          LOWORD(v16) = *v4;
          v49 = !v17;
          v41 = v16;
          v43 = *(_DWORD *)(v12 + 0x18);
          v45 = *(_BYTE *)(v12 + 0xB);
          v46 = *(_BYTE *)(v18 + 5);
          v47 = *(_BYTE *)(v12 + 0xA);
          v53 = 0;
          v44 = v13;
          n0xE_1 = n0xE;
          v50 = sub_146A38570(a1, a3, v57, (__int64)v6, __popcnt(v14));
          v19 = a1 + 0x478LL * n0xE;
          v20 = (const void **)sub_146A1D220(v19 + 0x5B8, v4);
          if ( &v51 != (_BYTE **)v20 )
            sub_146A11EE0((std::vector<short> *)&v51, (char *)*v20, ((_BYTE *)v20[1] - (_BYTE *)*v20) >> 1);
          v37 = *v4;
          v38 = *(_BYTE *)(v12 + 0x10);
          v21 = sub_146A1D080((__int64 *)(v19 + 0x5D0), (unsigned __int16 *)&v37);
          if ( &v53 != (__int128 *)v21 )
            sub_140307340(
              (unsigned __int64 *)&v53,
              *(char **)v21,
              (__int64)(*(_QWORD *)(v21 + 8) - *(_QWORD *)v21) >> 2);
          v22 = *v5;
          v23 = v5 + 0xFFFFFFFF;
          if ( *v5 == v5[1] )
          {
            sub_146A126F0(v23, v22, (__int64)&v41);
          }
          else
          {
            sub_146A19EB0((__int64)v23, v22, (__int64)&v41);
            *v5 += 0x48;
          }
          v24 = (const void *)v53;
          if ( (_QWORD)v53 )
          {
            if ( ((v54 - (_QWORD)v53) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
            {
              v24 = *(const void **)(v53 - 8);
              if ( (unsigned __int64)(v53 - (_QWORD)v24 - 8) > 0x1F )
LABEL_28:
                invalid_parameter_noinfo_noreturn();
            }
            sub_1402A3D30(v24);
          }
          v25 = v51;
          if ( v51 )
          {
            if ( (unsigned __int64)(2 * ((__int64)(*((_QWORD *)&v52 + 1) - (_QWORD)v51) >> 1)) >= 0x1000 )
            {
              v25 = (_BYTE *)*((_QWORD *)v51 + 0xFFFFFFFF);
              if ( (unsigned __int64)(v51 - v25 - 8) > 0x1F )
                goto LABEL_28;
            }
            sub_1402A3D30(v25);
          }
          a2 = v57;
          v6 = v39;
          n0xE = n0xE_2;
        }
        ++v10;
      }
      while ( v10 != v11 );
      v9 = v40;
    }
    ++n0xE;
    v9 += 3;
    v5 += 6;
    n0xE_2 = n0xE;
    v40 = v9;
  }
  while ( n0xE < 0xE );
  v26 = v6[0x17];
  v27 = v6[0x16];
  result = (unsigned __int64)((unsigned __int128)((v26 - v27) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F;
  if ( (v26 - v27) / 0x30 )
  {
    v29 = v39;
    v30 = 0;
    do
    {
      if ( (v26 - v27) / 0x30 <= v7 )
      {
        __asm { vzeroupper }
        unknown_libname_11();
      }
      v31 = *(float *)(v30 + v27 + 0x14);
      LOWORD(v55.m256_f32[0]) = *v4;
      v55.m256_f32[1] = *(float *)(v30 + v27);
      LOWORD(v55.m256_f32[2]) = *(_WORD *)(v30 + v27 + 0x18);
      BYTE2(v55.m256_f32[2]) = *(_BYTE *)(v30 + v27 + 0x1A);
      *(_QWORD *)&v55.m256_f32[4] = *(_QWORD *)(v30 + v27 + 0x20);
      v32 = *(_QWORD *)(v57 + 0x58);
      v33 = _bittest64(&v32, v7);
      v55.m256_f32[3] = v31;
      LOBYTE(v55.m256_f32[6]) = v33;
      __asm { vzeroupper }
      BYTE1(v55.m256_f32[6]) = sub_146A37FA0(a1, a3, v57, v7);
      v34 = (__int64 *)(a4 + 0x30LL * *(int *)(v30 + v27 + 0x14) + 0x18);
      v35 = (__m256 *)v34[1];
      if ( v35 == (__m256 *)v34[2] )
      {
        sub_140347820(v34, v35, (__m256i *)&v55);
      }
      else
      {
        *v35 = v55;
        v34[1] += 0x20;
      }
      v26 = v29[0x17];
      v27 = v29[0x16];
      ++v7;
      v30 += 0x30;
      result = (unsigned __int64)((unsigned __int128)((v26 - v27) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 0x40) >> 0x3F;
    }
    while ( v7 < (v26 - v27) / 0x30 );
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_146A28BD0 (0x146A28BD0) ---

// --- Function: sub_146A2D6C0 (0x146A2D6C0) ---
unsigned __int64 __fastcall sub_146A2D6C0(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbx
  __int64 v4; // rsi
  volatile signed __int64 *v5; // rdi
  unsigned __int64 n0x200000; // rax
  int v7; // ebp
  __int64 v8; // r8
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // r9
  int v10; // eax

  v2 = qword_1515B19F0;
  v3 = a2;
  v4 = qword_1515B19F0 + 0x2E0LL * a2;
  v5 = (volatile signed __int64 *)(v4 + 0x4068);
  n0x200000 = NtCurrentTeb_w();
  v7 = *(_DWORD *)(n0x200000 + 0x18);
  if ( *(_DWORD *)(v4 + 0x4078) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x407C);
  }
  else
  {
    v8 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    n0x200000 = _InterlockedCompareExchange64(v5, 0x200000, 0);
    if ( n0x200000 )
      n0x200000 = sub_1403DCD60(
                    v4 + 0x4068,
                    n0x200000,
                    v8,
                    "CEntityComponentUpdateScheduler::DisableComponentDebugUpdate",
                    "pAllocator->lock",
                    1);
    else
      *(_QWORD *)(v4 + 0x4070) = v8;
    *(_DWORD *)(v4 + 0x4078) = v7;
  }
  if ( !*(_QWORD *)(v4 + 0x40C0) )
  {
    if ( (_WORD)v3 == 0xFFFF )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const char **)(*(_QWORD *)(qword_149B4FC88 + 0x38) + 8 * v3);
    n0x200000 = sub_1405C0E00(
                  6u,
                  2u,
                  "%s is disabling debug update before it was enabled!",
                  p_p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  --*(_QWORD *)(v4 + 0x40C0);
  *(_BYTE *)(v2 + 0x1F4F62) = 1;
  if ( v4 != 0xFFFFFFFFFFFFBF98uLL )
  {
    v10 = *(_DWORD *)(v4 + 0x407C);
    if ( v10 )
    {
      n0x200000 = (unsigned int)(v10 - 1);
      *(_DWORD *)(v4 + 0x407C) = n0x200000;
    }
    else
    {
      *(_DWORD *)(v4 + 0x4078) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64(v5, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
        *(_QWORD *)(v4 + 0x4070) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        return (unsigned __int64)sub_1403DD380(v4 + 0x4068, n0x200000);
    }
  }
  return n0x200000;
}

// --- End Function: sub_146A2D6C0 (0x146A2D6C0) ---

// --- Function: sub_146A2D800 (0x146A2D800) ---
__int64 __fastcall sub_146A2D800(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r9
  __int64 v5; // rdi
  unsigned int *v6; // rcx
  unsigned __int64 v7; // r8
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  __int64 result; // rax

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v5 = qword_1515B19F0 + 0x2E0 * v3;
  v6 = *(unsigned int **)(v5 + 0x4108);
  v7 = (*(_QWORD *)(v5 + 0x4110) - (_QWORD)v6) / 0x30LL;
  while ( v7 )
  {
    if ( v6[0xC * (v7 >> 1)] >= a3 )
    {
      v7 >>= 1;
    }
    else
    {
      v6 += 0xC * (v7 >> 1) + 0xC;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
    goto LABEL_10;
  if ( a3 < *v6 )
    v6 = *(unsigned int **)(v5 + 0x4110);
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
  {
LABEL_10:
    if ( (_WORD)v3 == 0xFFFF )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const char **)(*(_QWORD *)(qword_149B4FC88 + 0x38) + 8 * v3);
    return sub_1405C0E00(
             6u,
             2u,
             "Calling DisableComponentEventHandler for Event %d on Component %s which doesn't have a handler registered for this event",
             a3,
             p_p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  else
  {
    result = ~(1LL << (((__int64)v6 - *(_QWORD *)(v5 + 0x4108)) / 0x30));
    *(_QWORD *)(a2 + 0x58) &= result;
  }
  return result;
}

// --- End Function: sub_146A2D800 (0x146A2D800) ---

// --- Function: sub_146A2D940 (0x146A2D940) ---
unsigned __int64 __fastcall sub_146A2D940(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  __int64 v5; // rbx
  int v6; // esi
  __int64 v7; // r8
  int v8; // eax
  unsigned __int64 n0x200000; // rax

  v3 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  if ( *(_WORD *)(v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4098) == 3 )
  {
    v5 = v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4068;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = NtCurrentTeb_w();
    v6 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x18);
    if ( *(_DWORD *)(v5 + 0x10) == v6 )
    {
      ++*(_DWORD *)(v5 + 0x14);
    }
    else
    {
      v7 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      p_p_p_p_p_p_p_p_p_p_p_p_Source = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
      if ( p_p_p_p_p_p_p_p_p_p_p_p_Source )
        p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1403DCD60(
                                           v5,
                                           p_p_p_p_p_p_p_p_p_p_p_p_Source,
                                           v7,
                                           "CEntityComponentUpdateScheduler::DisableComponentInstanceDebugUpdate",
                                           "pAllocator->lock",
                                           1);
      else
        *(_QWORD *)(v5 + 8) = v7;
      *(_DWORD *)(v5 + 0x10) = v6;
    }
    *(_BYTE *)(a2 + 0x69) = 0;
    if ( v5 )
    {
      v8 = *(_DWORD *)(v5 + 0x14);
      if ( v8 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)(v8 - 1);
        *(_DWORD *)(v5 + 0x14) = p_p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v5 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          return (unsigned __int64)sub_1403DD380(v5, n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_146A2D940 (0x146A2D940) ---

// --- Function: sub_146A2DA50 (0x146A2DA50) ---
__int64 __fastcall sub_146A2DA50(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rbx
  int v4; // r15d
  __int64 v6; // r9
  unsigned __int64 v7; // rdx
  __int64 v8; // r8
  __int64 result; // rax
  __int64 v10; // rdi
  const char *v11; // rbp
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdi
  __int64 v13; // rcx
  const char *v14; // rax

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v4 = a3;
  v6 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0 * v3;
  v7 = __popcnt(*(_QWORD *)(v6 + 0x42B8) & ((1LL << a3) - 1));
  v8 = *(_QWORD *)(v6 + 0x4150) + 0x20 * v7;
  switch ( *(_WORD *)(v8 + 8) )
  {
    case 2:
    case 5:
    case 6:
    case 9:
    case 0xA:
    case 0xC:
    case 0xF:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
      result = *(_QWORD *)(a2 + 0x18);
      *(_BYTE *)(result + 0xC * v7) = 0;
      break;
    default:
      v10 = qword_149B4FC88;
      v11 = sub_1403AC700(*(_DWORD *)(v8 + 0xC));
      if ( (_WORD)v3 == 0xFFFF )
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const char **)(*(_QWORD *)(v10 + 0x38) + 8 * v3);
      if ( sub_14030EC00((unsigned __int64 *)(a2 + 8)) )
        v13 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v13 = 0;
      v14 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x70LL))(v13);
      result = sub_1405C0E00(
                 6u,
                 2u,
                 "DisableComponentUpdate called Component %s.%s for Pass %s (Id %d) which is not set to use the Manual update policy",
                 v14,
                 p_p_p_p_p_p_p_p_p_p_p_p_Source,
                 v11,
                 v4);
      break;
  }
  return result;
}

// --- End Function: sub_146A2DA50 (0x146A2DA50) ---

// --- Function: sub_146A2DDF0 (0x146A2DDF0) ---
unsigned __int64 __fastcall sub_146A2DDF0(__int64 a1, unsigned __int16 a2)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbp
  __int64 v3; // rdi
  __int64 v4; // rbx
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rax
  int v6; // esi
  __int64 v7; // r8
  int v8; // eax
  unsigned __int64 n0x200000; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v3 = 0x2E0LL * a2;
  v4 = v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4068;
  p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = NtCurrentTeb_w();
  v6 = *(_DWORD *)(p_p_p_p_p_p_p_p_p_p_p_p_Source_1 + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v6 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v7 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0x200000, 0);
    if ( p_p_p_p_p_p_p_p_p_p_p_p_Source_1 )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = sub_1403DCD60(
                                           v4,
                                           p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
                                           v7,
                                           "CEntityComponentUpdateScheduler::EnableComponentDebugUpdate",
                                           "pAllocator->lock",
                                           1);
    else
      *(_QWORD *)(v4 + 8) = v7;
    *(_DWORD *)(v4 + 0x10) = v6;
  }
  ++*(_QWORD *)(v3 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x40C0);
  *(_BYTE *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1F4F62) = 1;
  if ( v4 )
  {
    v8 = *(_DWORD *)(v4 + 0x14);
    if ( v8 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (unsigned int)(v8 - 1);
      *(_DWORD *)(v4 + 0x14) = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
    }
    else
    {
      *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v4, 0, 0x200000);
      if ( n0x200000 == 0x200000 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v4 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return (unsigned __int64)sub_1403DD380(v4, n0x200000);
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
}

// --- End Function: sub_146A2DDF0 (0x146A2DDF0) ---

// --- Function: sub_146A2DEF0 (0x146A2DEF0) ---
__int64 __fastcall sub_146A2DEF0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r9
  __int64 v5; // rbx
  unsigned int *v6; // rcx
  unsigned __int64 v7; // r8
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  __int64 result; // rax

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v5 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0 * v3;
  v6 = *(unsigned int **)(v5 + 0x4108);
  v7 = (*(_QWORD *)(v5 + 0x4110) - (_QWORD)v6) / 0x30LL;
  while ( v7 )
  {
    if ( v6[0xC * (v7 >> 1)] >= a3 )
    {
      v7 >>= 1;
    }
    else
    {
      v6 += 0xC * (v7 >> 1) + 0xC;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
    goto LABEL_10;
  if ( a3 < *v6 )
    v6 = *(unsigned int **)(v5 + 0x4110);
  if ( v6 == *(unsigned int **)(v5 + 0x4110) )
  {
LABEL_10:
    if ( (_WORD)v3 == 0xFFFF )
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const char **)(*(_QWORD *)(qword_149B4FC88 + 0x38) + 8 * v3);
    return sub_1405C0E00(
             6u,
             2u,
             "Calling EnableComponentEventHandler for Event %d on Component %s which doesn't have a handler registered for this event",
             a3,
             p_p_p_p_p_p_p_p_p_p_p_p_Source);
  }
  else
  {
    result = 1LL << (((__int64)v6 - *(_QWORD *)(v5 + 0x4108)) / 0x30);
    *(_QWORD *)(a2 + 0x58) |= result;
  }
  return result;
}

// --- End Function: sub_146A2DEF0 (0x146A2DEF0) ---

// --- Function: sub_146A2E020 (0x146A2E020) ---
unsigned __int64 __fastcall sub_146A2E020(__int64 a1, __int64 __Val_0__)
{
  unsigned __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rax
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rbp
  __int64 v5; // rdi
  volatile signed __int64 *v6; // rbx
  int v7; // r14d
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  int v10; // eax
  unsigned __int64 n0x200000; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(unsigned __int16 *)(__Val_0__ + 0x10);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v5 = p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x2E0 * p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
  if ( *(_WORD *)(v5 + 0x4098) == 3 )
  {
    v6 = (volatile signed __int64 *)(v5 + 0x4068);
    v7 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
    if ( *(_DWORD *)(v5 + 0x4078) == v7 )
    {
      ++*(_DWORD *)(v5 + 0x407C);
    }
    else
    {
      v8 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
      v9 = _InterlockedCompareExchange64(v6, 0x200000, 0);
      if ( v9 )
        sub_1403DCD60(
          v5 + 0x4068,
          v9,
          v8,
          "CEntityComponentUpdateScheduler::EnableComponentInstanceDebugUpdate",
          "pAllocator->lock",
          1);
      else
        *(_QWORD *)(v5 + 0x4070) = v8;
      *(_DWORD *)(v5 + 0x4078) = v7;
    }
    *(_BYTE *)(__Val_0__ + 0x69) = 1;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = sub_146A37E70(p_p_p_p_p_p_p_p_p_p_p_p_Source, __Val_0__, v5 + 0x4058);
    if ( (_BYTE)p_p_p_p_p_p_p_p_p_p_p_p_Source_1 )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = sub_146A24F10(
                                           p_p_p_p_p_p_p_p_p_p_p_p_Source,
                                           (const vraudio::AudioBuffer *)__Val_0__,
                                           v5 + 0x4058);
    if ( v5 != 0xFFFFFFFFFFFFBF98uLL )
    {
      v10 = *(_DWORD *)(v5 + 0x407C);
      if ( v10 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (unsigned int)(v10 - 1);
        *(_DWORD *)(v5 + 0x407C) = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
      }
      else
      {
        *(_DWORD *)(v5 + 0x4078) = 0xFFFFFFFF;
        n0x200000 = _InterlockedCompareExchange64(v6, 0, 0x200000);
        if ( n0x200000 == 0x200000 )
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (unsigned __int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
          *(_QWORD *)(v5 + 0x4070) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        else
        {
          return (unsigned __int64)sub_1403DD380(v5 + 0x4068, n0x200000);
        }
      }
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
}

// --- End Function: sub_146A2E020 (0x146A2E020) ---

// --- Function: sub_146A2E140 (0x146A2E140) ---
__int64 __fastcall sub_146A2E140(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_146A2E150(p_p_p_p_p_p_p_p_p_p_p_p_Source_8, a2, a3);
}

// --- End Function: sub_146A2E140 (0x146A2E140) ---

// --- Function: sub_146A2E150 (0x146A2E150) ---
void __fastcall sub_146A2E150(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rbx
  int v5; // r12d
  __int64 v7; // r13
  unsigned __int64 v8; // rsi
  __int64 v9; // rdx
  unsigned __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  bool v13; // al
  unsigned __int64 v14; // rdx
  __int64 v15; // rsi
  const char *v16; // r14
  const char *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rsi
  __int64 v18; // rcx
  const char *v19; // rax
  unsigned __int64 v20; // [rsp+80h] [rbp+8h] BYREF
  __int64 v21; // [rsp+88h] [rbp+10h]

  v3 = *(unsigned __int16 *)(a2 + 0x10);
  v5 = a3;
  v7 = p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0 * v3;
  v21 = (1LL << a3) - 1;
  v8 = __popcnt(*(_QWORD *)(v7 + 0x42B8) & v21);
  v9 = *(_QWORD *)(v7 + 0x4150) + 0x20 * v8;
  switch ( *(_WORD *)(v9 + 8) )
  {
    case 2:
    case 5:
    case 6:
    case 9:
    case 0xA:
    case 0xC:
    case 0xF:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
      v10 = *(_QWORD *)(a2 + 8);
      v20 = v10;
      if ( !v10 )
        goto LABEL_16;
      v11 = (v10 & 0xF000000000000000uLL) != 0 ? v10 & 0xFFFFFF000000LL : (v10 & 0xFFFFFFFFFFFFLL) - 6;
      if ( *(_WORD *)(v11 + 2) != (HIWORD(v10) & 0xFFF) )
        goto LABEL_16;
      if ( *(_WORD *)(v11 + 4) < 3u )
        goto LABEL_10;
      if ( check_thread_state_and_value_not_equal((_QWORD *)(v10 & 0xFFFFFFFFFFFFLL)) )
      {
        v10 = v20;
LABEL_10:
        if ( (v10 & 0xFFFFFFFFFFFFLL) != 0 )
        {
          v12 = (v10 & 0xF000000000000000uLL) != 0 ? v10 & 0xFFFFFF000000LL : (v10 & 0xFFFFFFFFFFFFLL) - 6;
          if ( *(_WORD *)(v12 + 4) == 1 )
          {
            _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a2 + 0x18) + 0xC * v8 + 0xB), 1u);
            return;
          }
        }
      }
LABEL_16:
      *(_BYTE *)(*(_QWORD *)(a2 + 0x18) + 0xC * v8) = 1;
      v13 = sub_14030EC00(&v20);
      v14 = v20 & 0xFFFFFFFFFFFFLL;
      if ( !v13 )
        v14 = 0;
      if ( sub_146A38570(p_p_p_p_p_p_p_p_p_p_p_p_Source, v14, a2, v7 + 0x4058, __popcnt(*(_QWORD *)(v7 + 0x42B8) & v21)) )
        sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a2, v5, 0);
      return;
    default:
      v15 = qword_149B4FC88;
      v16 = sub_1403AC700(*(_DWORD *)(v9 + 0xC));
      if ( (_WORD)v3 == 0xFFFF )
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const char **)(*(_QWORD *)(v15 + 0x38) + 8 * v3);
      if ( sub_14030EC00((unsigned __int64 *)(a2 + 8)) )
        v18 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFLL;
      else
        v18 = 0;
      v19 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x70LL))(v18);
      sub_1405C0E00(
        6u,
        2u,
        "EnableComponentUpdate called Component %s.%s for Pass %s (Id %d) which is not set to use the Manual update policy",
        v19,
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1,
        v16,
        v5);
      return;
  }
}

// --- End Function: sub_146A2E150 (0x146A2E150) ---

// --- Function: sub_146A2F670 (0x146A2F670) ---
void __fastcall sub_146A2F670(__int64 a1)
{
  __int64 v1; // rdi
  __int64 i; // rbx
  _QWORD *v3; // r14
  const char **v4; // rbp
  _BYTE *v5; // rcx
  const char **v6; // rsi
  __int64 n0x1FF; // rdx
  __int128 v8; // [rsp+20h] [rbp-278h] BYREF
  __int64 v9; // [rsp+30h] [rbp-268h]
  __int64 v10; // [rsp+38h] [rbp-260h] BYREF
  __int64 v11; // [rsp+40h] [rbp-258h] BYREF
  __int64 n0x1FF_1; // [rsp+48h] [rbp-250h]
  _BYTE *v13; // [rsp+50h] [rbp-248h]
  _BYTE v14[520]; // [rsp+58h] [rbp-240h] BYREF

  *(_BYTE *)(a1 + 0x105) = 1;
  v1 = *(_QWORD *)(a1 + 0x10);
  for ( i = *(_QWORD *)(a1 + 8); i != v1; i += 0x18 )
  {
    v3 = *(_QWORD **)(i + 8);
    v8 = 0;
    v9 = 0;
    (*(void (__fastcall **)(_QWORD, __int128 *))(*(_QWORD *)*v3 + 0x30LL))(*v3, &v8);
    v4 = (const char **)*((_QWORD *)&v8 + 1);
    v5 = v14;
    v6 = (const char **)v8;
    n0x1FF = 0x1FF;
    v13 = v14;
    n0x1FF_1 = 0x1FF;
    v14[0] = 0;
    v11 = 0;
    if ( (_QWORD)v8 != *((_QWORD *)&v8 + 1) )
    {
      do
      {
        sub_1402A3190((__int64)&v11, "%s%s", "Engine.Components.", *v6);
        (*(void (__fastcall **)(__int64, __int64 *, _BYTE *))(*(_QWORD *)qword_149B4FBF8 + 0x28LL))(
          qword_149B4FBF8,
          &v10,
          v13);
        if ( (_WORD)v10 != 0xFFFF )
          sub_1403912C0((__int64)(v3 + 6), v10);
        ++v6;
      }
      while ( v6 != v4 );
      v6 = (const char **)v8;
      v5 = v13;
      n0x1FF = n0x1FF_1;
    }
    if ( v5 != v14 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v5);
      v6 = (const char **)v8;
    }
    if ( v6 )
      sub_1403A3120((__int64)&v8, v6, (v9 - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8uLL);
  }
}

// --- End Function: sub_146A2F670 (0x146A2F670) ---

// --- Function: sub_146A2F970 (0x146A2F970) ---
__int64 __fastcall sub_146A2F970(__int64 a1, unsigned int a2, _BYTE **a3, _WORD *a4, _BYTE *a5)
{
  __int64 v6; // rbx
  unsigned __int64 v10; // r8
  _BYTE *v11; // r10
  __int64 result; // rax
  _BYTE *v13; // rcx
  unsigned int v14; // ebx

  v6 = *(_QWORD *)(a1 + 0x10) + a2;
  v10 = *(unsigned __int16 *)(v6 + 2);
  v11 = (_BYTE *)(v6 + 0xC);
  if ( (_WORD)v10 && *v11 != **a3 )
    return 0xFFFFFFFFLL;
  if ( (unsigned __int16)v10 > *a4 )
    goto LABEL_14;
  if ( *(_WORD *)(v6 + 2) )
  {
    v13 = (_BYTE *)(v6 + 0xC);
    while ( *v13 == v13[*a3 - v11] )
    {
      if ( ++v13 - v11 >= v10 )
        goto LABEL_9;
    }
LABEL_14:
    *a5 = 1;
    return a2;
  }
LABEL_9:
  *a4 -= *(_WORD *)(v6 + 2);
  *a3 += *(unsigned __int16 *)(v6 + 2);
  if ( !*a4 )
    return a2;
  v14 = *(_DWORD *)(v6 + 4);
  if ( v14 == 0xFFFFFFFF )
    return a2;
  while ( 1 )
  {
    result = sub_146A2F970(a1, v14, a3, a4, a5);
    if ( (_DWORD)result != 0xFFFFFFFF )
      break;
    v14 = *(_DWORD *)(v14 + *(_QWORD *)(a1 + 0x10) + 8LL);
    if ( v14 == 0xFFFFFFFF )
      return a2;
  }
  return result;
}

// --- End Function: sub_146A2F970 (0x146A2F970) ---

// --- Function: sub_146A2FA80 (0x146A2FA80) ---
__int64 __fastcall sub_146A2FA80(__int64 a1, unsigned int a2, _BYTE *a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v6; // r10
  _BYTE *v7; // rdx
  _BYTE *v8; // rbp
  unsigned __int64 v9; // rsi
  __int64 result; // rax
  unsigned int v11; // ebx

  v4 = *(_QWORD *)(a1 + 0x10) + a2;
  v6 = *(unsigned __int16 *)(v4 + 2);
  if ( v6 > a4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) )
  {
    v7 = a3;
    while ( v7[v4 + 0xC - (_QWORD)a3] == *v7 )
    {
      if ( ++v7 - a3 >= v6 )
        goto LABEL_6;
    }
    return 0;
  }
LABEL_6:
  v8 = &a3[v6];
  v9 = a4 - v6;
  if ( a4 == v6 )
    return v4;
  v11 = *(_DWORD *)(v4 + 4);
  if ( v11 == 0xFFFFFFFF )
    return 0;
  while ( 1 )
  {
    result = sub_146A2FA80(a1, v11, v8, v9);
    if ( result )
      break;
    v11 = *(_DWORD *)(v11 + *(_QWORD *)(a1 + 0x10) + 8LL);
    if ( v11 == 0xFFFFFFFF )
      return 0;
  }
  return result;
}

// --- End Function: sub_146A2FA80 (0x146A2FA80) ---

// --- Function: sub_146A31880 (0x146A31880) ---
__int64 __fastcall sub_146A31880(__int64 a1, unsigned __int16 a2, __int64 *a3)
{
  __int16 **v5; // rbx
  __int64 result; // rax
  unsigned __int16 *v7; // rbp
  __int16 *i; // rbx
  __int16 v9; // ax
  __int16 v10; // [rsp+48h] [rbp+10h] BYREF

  v10 = a2;
  v5 = (__int16 **)(*(_QWORD *)(a1 + 0x70) + 0x18LL * a2);
  sub_146A4A820(a3, v5[1] - *v5 + ((a3[1] - *a3) >> 1) + 1);
  result = (__int64)sub_140307890((__int64)a3, &v10);
  v7 = (unsigned __int16 *)v5[1];
  for ( i = *v5; i != (__int16 *)v7; ++i )
  {
    v9 = 0xFFFF;
    if ( (unsigned int)(unsigned __int16)*i < *(_DWORD *)(a1 + 0x28) )
      v9 = *i;
    v10 = v9;
    result = sub_143A96E90(a3, &v10);
  }
  return result;
}

// --- End Function: sub_146A31880 (0x146A31880) ---

// --- Function: sub_146A31930 (0x146A31930) ---
void __fastcall sub_146A31930(__int64 a1, unsigned __int16 a2, __int64 *a3)
{
  __int64 **v5; // rax
  __int64 *v6; // rcx
  __int64 v7; // rax
  const char **v8; // r14
  const char **v9; // rdi
  __int64 v10; // rsi
  __int16 n0xFFFF; // ax
  const char *v12; // rbx
  unsigned __int64 v13; // r9
  __int16 *v14; // rax
  __int128 v15; // [rsp+20h] [rbp-38h] BYREF
  __int64 v16; // [rsp+30h] [rbp-28h]
  __int16 n0xFFFF_1; // [rsp+78h] [rbp+20h] BYREF

  v5 = (__int64 **)sub_146A31EC0(a1, a2);
  if ( v5 )
  {
    v6 = *v5;
    if ( *v5 )
    {
      v7 = *v6;
      v15 = 0;
      v16 = 0;
      (*(void (__fastcall **)(__int64 *, __int128 *))(v7 + 0x30))(v6, &v15);
      sub_146A4A820(a3, ((__int64)(*((_QWORD *)&v15 + 1) - v15) >> 3) + ((a3[1] - *a3) >> 1));
      v8 = (const char **)*((_QWORD *)&v15 + 1);
      v9 = (const char **)v15;
      if ( (_QWORD)v15 != *((_QWORD *)&v15 + 1) )
      {
        v10 = a1 + 0x20;
        while ( 1 )
        {
          n0xFFFF = 0xFFFF;
          v12 = *v9;
          if ( *(_DWORD *)(v10 + 8) )
          {
            v13 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++v13;
            while ( v12[v13] );
            v14 = (__int16 *)sub_146A2FA80(v10, 0, *v9, v13);
            if ( !v14 )
            {
              n0xFFFF_1 = 0xFFFF;
LABEL_11:
              LogFatalError("Trying to get a component id from name %s which has not yet been registered", v12);
              goto LABEL_12;
            }
            n0xFFFF = *v14;
          }
          n0xFFFF_1 = n0xFFFF;
          if ( n0xFFFF == (__int16)0xFFFF )
            goto LABEL_11;
LABEL_12:
          sub_143A96E90(a3, &n0xFFFF_1);
          if ( ++v9 == v8 )
          {
            v9 = (const char **)v15;
            break;
          }
        }
      }
      if ( v9 )
        sub_1403A3120((__int64)&v15, v9, (v16 - (_QWORD)v9) & 0xFFFFFFFFFFFFFFF8uLL);
    }
  }
}

// --- End Function: sub_146A31930 (0x146A31930) ---

// --- Function: sub_146A31AE0 (0x146A31AE0) ---
void __fastcall sub_146A31AE0(__int64 a1, unsigned __int16 n0xFFFF_4, __int64 *a3)
{
  __int64 n0xFFFF_2; // rbx
  __int64 v5; // rdx
  __int64 v7; // r8
  __int64 v8; // rax
  __int16 **v9; // rdi
  unsigned __int16 *v10; // r14
  __int16 *i; // rdi
  __int16 n0xFFFF_3; // ax
  __int64 **v13; // rax
  __int64 *v14; // rcx
  __int64 v15; // rax
  const char **v16; // r14
  const char **v17; // rdi
  __int16 n0xFFFF; // ax
  const char *v19; // rbx
  unsigned __int64 v20; // r9
  __int16 *v21; // rax
  __int128 v22; // [rsp+20h] [rbp-38h] BYREF
  __int64 v23; // [rsp+30h] [rbp-28h]
  __int16 n0xFFFF_1; // [rsp+68h] [rbp+10h] BYREF

  n0xFFFF_2 = n0xFFFF_4;
  v5 = *a3;
  v7 = a3[1];
  if ( v5 != v7 )
  {
    a3[1] = v5;
    v7 = v5;
  }
  v8 = *(_QWORD *)(a1 + 0x70);
  n0xFFFF_1 = n0xFFFF_2;
  v9 = (__int16 **)(v8 + 0x18 * n0xFFFF_2);
  sub_146A4A820(a3, ((v7 - v5) >> 1) + v9[1] - *v9 + 1);
  sub_140307890((__int64)a3, &n0xFFFF_1);
  v10 = (unsigned __int16 *)v9[1];
  for ( i = *v9; i != (__int16 *)v10; ++i )
  {
    n0xFFFF_3 = 0xFFFF;
    if ( (unsigned int)(unsigned __int16)*i < *(_DWORD *)(a1 + 0x28) )
      n0xFFFF_3 = *i;
    n0xFFFF_1 = n0xFFFF_3;
    sub_143A96E90(a3, &n0xFFFF_1);
  }
  v13 = (__int64 **)sub_146A31EC0(a1, n0xFFFF_2);
  if ( v13 )
  {
    v14 = *v13;
    if ( *v13 )
    {
      v15 = *v14;
      v22 = 0;
      v23 = 0;
      (*(void (__fastcall **)(__int64 *, __int128 *))(v15 + 0x30))(v14, &v22);
      sub_146A4A820(a3, ((__int64)(*((_QWORD *)&v22 + 1) - v22) >> 3) + ((a3[1] - *a3) >> 1));
      v16 = (const char **)*((_QWORD *)&v22 + 1);
      v17 = (const char **)v22;
      if ( (_QWORD)v22 != *((_QWORD *)&v22 + 1) )
      {
        while ( 1 )
        {
          n0xFFFF = 0xFFFF;
          v19 = *v17;
          if ( *(_DWORD *)(a1 + 0x28) )
          {
            v20 = 0xFFFFFFFFFFFFFFFFuLL;
            do
              ++v20;
            while ( v19[v20] );
            v21 = (__int16 *)sub_146A2FA80(a1 + 0x20, 0, *v17, v20);
            if ( !v21 )
            {
              n0xFFFF_1 = 0xFFFF;
LABEL_16:
              LogFatalError("Trying to get a component id from name %s which has not yet been registered", v19);
              goto LABEL_17;
            }
            n0xFFFF = *v21;
          }
          n0xFFFF_1 = n0xFFFF;
          if ( n0xFFFF == (__int16)0xFFFF )
            goto LABEL_16;
LABEL_17:
          sub_143A96E90(a3, &n0xFFFF_1);
          if ( ++v17 == v16 )
          {
            v17 = (const char **)v22;
            break;
          }
        }
      }
      if ( v17 )
        sub_1403A3120((__int64)&v22, v17, (v23 - (_QWORD)v17) & 0xFFFFFFFFFFFFFFF8uLL);
    }
  }
}

// --- End Function: sub_146A31AE0 (0x146A31AE0) ---

// --- Function: sub_146A31E30 (0x146A31E30) ---
__int64 __fastcall sub_146A31E30(__int64 a1, unsigned __int16 a2)
{
  _QWORD *v2; // rax

  v2 = (_QWORD *)sub_146A31EC0(a1, a2);
  return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v2 + 0x20LL))(*v2);
}

// --- End Function: sub_146A31E30 (0x146A31E30) ---

// --- Function: sub_146A31E70 (0x146A31E70) ---
__int64 __fastcall sub_146A31E70(__int64 a1, unsigned __int16 a2)
{
  _QWORD *v2; // rax

  v2 = (_QWORD *)sub_146A31EC0(a1, a2);
  if ( v2 && *v2 )
    return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v2 + 0x48LL))(*v2);
  else
    return 0;
}

// --- End Function: sub_146A31E70 (0x146A31E70) ---

// --- Function: sub_146A31EC0 (0x146A31EC0) ---
__int64 __fastcall sub_146A31EC0(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // r10
  __int64 v4; // r8
  unsigned __int64 v5; // rdx

  v2 = *(_QWORD *)(a1 + 0x10);
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (v2 - v4) / 0x18;
  while ( v5 )
  {
    if ( *(_WORD *)(v4 + 0x18 * (v5 >> 1)) >= a2 )
    {
      v5 >>= 1;
    }
    else
    {
      v4 += 0x18 * (v5 >> 1) + 0x18;
      v5 += 0xFFFFFFFFFFFFFFFFuLL - (v5 >> 1);
    }
  }
  if ( v4 == v2 )
    return 0;
  if ( a2 < *(_WORD *)v4 )
    v4 = *(_QWORD *)(a1 + 0x10);
  if ( v4 == v2 )
    return 0;
  else
    return *(_QWORD *)(v4 + 8);
}

// --- End Function: sub_146A31EC0 (0x146A31EC0) ---

// --- Function: sub_146A320C0 (0x146A320C0) ---
_WORD *__fastcall sub_146A320C0(__int64 a1, _WORD *a2, const char *a3)
{
  sub_146A32730(a1 + 0x20);
  if ( *a2 == 0xFFFF )
    LogFatalError("Trying to get a component id from name %s which has not yet been registered", a3);
  return a2;
}

// --- End Function: sub_146A320C0 (0x146A320C0) ---

// --- Function: sub_146A321C0 (0x146A321C0) ---
_WORD *__fastcall sub_146A321C0(_QWORD *a1, _WORD *a2, int a3)
{
  __int64 v3; // r9
  __int64 *v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rcx
  __int16 v7; // cx
  _WORD *result; // rax

  v3 = a1[0x14];
  v4 = (__int64 *)(a1[0x16]
                 + 0x10
                 * ((0x100000001B3LL
                   * (HIBYTE(a3)
                    ^ (0x100000001B3LL
                     * (BYTE2(a3)
                      ^ (0x100000001B3LL
                       * (BYTE1(a3) ^ (0x100000001B3LL * ((unsigned __int8)a3 ^ 0xCBF29CE484222325uLL))))))))
                  & a1[0x19]));
  v5 = v4[1];
  if ( v5 != v3 )
  {
    v6 = *v4;
    if ( a3 == *(_DWORD *)(v5 + 0x10) )
      goto LABEL_7;
    while ( v5 != v6 )
    {
      v5 = *(_QWORD *)(v5 + 8);
      if ( a3 == *(_DWORD *)(v5 + 0x10) )
        goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  if ( !v5 )
    v5 = v3;
  if ( v5 == v3 )
  {
    *a2 = 0xFFFF;
    return a2;
  }
  else
  {
    v7 = *(_WORD *)(v5 + 0x14);
    result = a2;
    *a2 = v7;
  }
  return result;
}

// --- End Function: sub_146A321C0 (0x146A321C0) ---

// --- Function: sub_146A32280 (0x146A32280) ---
const ULONG_PTR *__fastcall sub_146A32280(__int64 a1, unsigned __int16 a2)
{
  if ( a2 == 0xFFFF )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(*(_QWORD *)(a1 + 0x38) + 8LL * a2);
}

// --- End Function: sub_146A32280 (0x146A32280) ---

// --- Function: sub_146A322A0 (0x146A322A0) ---
const ULONG_PTR *__fastcall sub_146A322A0(__int64 a1, unsigned __int16 a2)
{
  if ( a2 == 0xFFFF )
    return &p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    return *(const ULONG_PTR **)(*(_QWORD *)(a1 + 0x40) + 8LL * a2);
}

// --- End Function: sub_146A322A0 (0x146A322A0) ---

// --- Function: sub_146A322C0 (0x146A322C0) ---
__int64 __fastcall sub_146A322C0(__int64 a1)
{
  __int64 *v2; // r10
  unsigned int v3; // r8d
  __int64 *j; // rax
  __int64 **v5; // rcx
  __int64 *i; // rcx
  __int64 *v7; // rdx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 0x104) )
    return *(unsigned int *)(a1 + 0x100);
  v2 = *(__int64 **)(a1 + 0x88);
  v3 = *(_DWORD *)(a1 + 0x90);
  j = (__int64 *)*v2;
  while ( j != v2 )
  {
    v5 = (__int64 **)j[2];
    v3 ^= *((_DWORD *)j + 7);
    if ( *((_BYTE *)v5 + 0x19) )
    {
      for ( i = (__int64 *)j[1]; !*((_BYTE *)i + 0x19); i = (__int64 *)i[1] )
      {
        if ( j != (__int64 *)i[2] )
          break;
        j = i;
      }
      j = i;
    }
    else
    {
      v7 = *v5;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v7 + 0x19); v7 = (__int64 *)*v7 )
        j = v7;
    }
  }
  *(_DWORD *)(a1 + 0x100) = v3;
  result = v3;
  *(_BYTE *)(a1 + 0x104) = 1;
  return result;
}

// --- End Function: sub_146A322C0 (0x146A322C0) ---

// --- Function: sub_146A32360 (0x146A32360) ---
__int64 __fastcall sub_146A32360(__int64 a1, unsigned __int16 a2)
{
  _QWORD *v2; // rax

  v2 = (_QWORD *)sub_146A31EC0(a1, a2);
  return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v2 + 0x18LL))(*v2);
}

// --- End Function: sub_146A32360 (0x146A32360) ---

// --- Function: sub_146A32380 (0x146A32380) ---
char __fastcall sub_146A32380(__int64 a1, unsigned __int16 a2)
{
  if ( a2 == 0xFFFF )
    return 0;
  else
    return *(_BYTE *)(0x2E0LL * a2 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4062);
}

// --- End Function: sub_146A32380 (0x146A32380) ---

// --- Function: sub_146A323B0 (0x146A323B0) ---
__int64 __fastcall sub_146A323B0(__int64 a1)
{
  LogTraceConditional("Component Timings is disabled, you can enable it at ComponentStats.h");
  return a1 + 0x108;
}

// --- End Function: sub_146A323B0 (0x146A323B0) ---

// --- Function: sub_146A32530 (0x146A32530) ---
__int64 __fastcall sub_146A32530(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // r14
  _QWORD *v4; // rax
  __int64 n0xE; // r15
  __int64 n0xE_1; // rcx
  __int64 v9; // rax
  __int64 *v10; // rsi
  __int64 *i; // rbx
  __int64 v12; // rdx
  __int64 v13; // rsi
  unsigned __int8 v15; // [rsp+20h] [rbp-48h]

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v4 = (_QWORD *)(a2 + 0x28);
  n0xE = 0xE;
  n0xE_1 = 0xE;
  do
  {
    v4[0xFFFFFFFB] = 0;
    v4[0xFFFFFFFC] = 0;
    v4[0xFFFFFFFD] = 0;
    v4[0xFFFFFFFE] = 0;
    v4[0xFFFFFFFF] = 0;
    *v4 = 0;
    v4 += 6;
    --n0xE_1;
  }
  while ( n0xE_1 );
  *(_QWORD *)(a2 + 0x2D0) = 0;
  *(_QWORD *)(a2 + 0x2D8) = 0;
  v9 = allocWithProfilerInfo_w(0x28u);
  *(_QWORD *)v9 = v9;
  *(_QWORD *)(v9 + 8) = v9;
  *(_QWORD *)(v9 + 0x10) = v9;
  *(_WORD *)(v9 + 0x18) = 0x101;
  *(_QWORD *)(a2 + 0x2D0) = v9;
  v10 = *(__int64 **)(a3 + 0x248);
  for ( i = *(__int64 **)(a3 + 0x240); i != v10; ++i )
  {
    if ( is_valid_handle_typeA(i) )
      v12 = *i & 0xFFFFFFFFFFFFLL;
    else
      v12 = 0;
    sub_146A28BD0(p_p_p_p_p_p_p_p_p_p_p_p_Source, v12, a3, a2);
  }
  v13 = a2;
  do
  {
    sub_146A15F20(*(_QWORD *)v13, *(_WORD **)(v13 + 8), (*(_QWORD *)(v13 + 8) - *(_QWORD *)v13) / 0x48LL, v15);
    v13 += 0x30;
    --n0xE;
  }
  while ( n0xE );
  sub_146A28460(p_p_p_p_p_p_p_p_p_p_p_p_Source, a3, a2);
  return a2;
}

// --- End Function: sub_146A32530 (0x146A32530) ---

// --- Function: sub_146A32730 (0x146A32730) ---
_WORD *__fastcall sub_146A32730(__int64 a1, _WORD *a2, _BYTE *a3)
{
  unsigned __int64 v4; // r9
  _WORD *v5; // rax
  _WORD *result; // rax

  if ( *(_DWORD *)(a1 + 8) )
  {
    v4 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++v4;
    while ( a3[v4] );
    v5 = (_WORD *)sub_146A2FA80(a1, 0, a3, v4);
    if ( v5 )
      *a2 = *v5;
    else
      *a2 = 0xFFFF;
    return a2;
  }
  else
  {
    result = a2;
    *a2 = 0xFFFF;
  }
  return result;
}

// --- End Function: sub_146A32730 (0x146A32730) ---

// --- Function: sub_146A327B0 (0x146A327B0) ---
unsigned __int64 __fastcall sub_146A327B0(__int64 a1, __int16 a2)
{
  _WORD *v2; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r9

  v2 = *(_WORD **)(a1 + 0xD8);
  result = 0;
  v4 = (__int64)(*(_QWORD *)(a1 + 0xE0) - (_QWORD)v2) >> 1;
  if ( !v4 )
    return 0x40;
  while ( *v2 != a2 )
  {
    ++result;
    ++v2;
    if ( result >= v4 )
      return 0x40;
  }
  return result;
}

// --- End Function: sub_146A327B0 (0x146A327B0) ---

// --- Function: sub_146A33560 (0x146A33560) ---
__int64 __fastcall sub_146A33560(__int64 a1, unsigned __int16 a2)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // r9
  unsigned int v3; // r10d
  char p_p_p_p_p_p_p_p_p_p_p_Source; // r8
  char p_p_p_p_p_p_p_p_p_p_p_Source_1; // cl

  if ( a2 == 0xFFFF )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = &::p_p_p_p_p_p_p_p_p_p_p_Source;
  else
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(*(_QWORD *)(a1 + 0x38) + 8LL * a2);
  v3 = 0x811C9DC5;
  do
  {
    p_p_p_p_p_p_p_p_p_p_p_Source = *(_BYTE *)p_p_p_p_p_p_p_p_p_p_p_p_Source;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)((char *)p_p_p_p_p_p_p_p_p_p_p_p_Source + 1);
    p_p_p_p_p_p_p_p_p_p_p_Source_1 = p_p_p_p_p_p_p_p_p_p_p_Source - 0x20;
    if ( (unsigned __int8)(p_p_p_p_p_p_p_p_p_p_p_Source - 0x61) > 0x19u )
      p_p_p_p_p_p_p_p_p_p_p_Source_1 = p_p_p_p_p_p_p_p_p_p_p_Source;
    v3 = 0x1000193 * (v3 ^ p_p_p_p_p_p_p_p_p_p_p_Source_1);
  }
  while ( p_p_p_p_p_p_p_p_p_p_p_Source );
  return v3;
}

// --- End Function: sub_146A33560 (0x146A33560) ---

// --- Function: sub_146A36EA0 (0x146A36EA0) ---
__int64 __fastcall sub_146A36EA0(unsigned int *a1, char *Src_1, unsigned __int16 Size_4, unsigned __int8 *a4)
{
  __int64 v4; // rdi
  unsigned __int16 v5; // bp
  __int64 Size_11; // r13
  char *Src_2; // r10
  _BYTE *v10; // rdx
  unsigned __int64 Size_6; // r9
  unsigned __int16 Size_5; // r14
  __int64 v13; // rsi
  __int64 v14; // r15
  unsigned __int16 v15; // di
  __int64 result; // rax
  _BYTE *Src_3; // rcx
  __int64 v18; // rdx
  unsigned int v19; // edi
  unsigned int v20; // eax
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // rax
  unsigned int j; // ecx
  unsigned __int16 Size_9; // ax
  __int64 v27; // rcx
  size_t Size_2; // r8
  void *Src_4; // rdx
  unsigned __int64 Size_7; // rdx
  __int64 v31; // r11
  unsigned __int64 Size_8; // r15
  unsigned __int16 Size_1; // r14
  unsigned __int16 Size; // r15
  __int64 v35; // r13
  unsigned int v36; // edx
  int v37; // edi
  int v38; // ecx
  __int64 v39; // rax
  __int64 v40; // rsi
  __int64 v41; // rdi
  __int64 Size_13; // r9
  unsigned __int8 *v43; // rax
  int v44; // r8d
  int v45; // eax
  __int64 v46; // rax
  _WORD *v47; // rcx
  __int64 v48; // rdi
  __int16 v49; // ax
  __int64 v50; // rsi
  __int64 Size_12; // r9
  unsigned __int16 v52; // bp
  unsigned __int8 *v53; // rax
  char *v54; // rdx
  __int64 v55; // rcx
  _WORD *v56; // rax
  __int64 v57; // rdx
  unsigned int v58; // ecx
  __int64 i; // rax
  unsigned __int8 *v60; // [rsp+20h] [rbp-78h]
  int v61; // [rsp+30h] [rbp-68h]
  unsigned int v62; // [rsp+30h] [rbp-68h]
  int v63; // [rsp+34h] [rbp-64h]
  void *Src; // [rsp+38h] [rbp-60h] BYREF
  _WORD *v65; // [rsp+40h] [rbp-58h]
  char v66; // [rsp+A0h] [rbp+8h] BYREF
  unsigned __int16 Size_3; // [rsp+A8h] [rbp+10h] BYREF
  unsigned __int16 Size_10; // [rsp+B0h] [rbp+18h]
  unsigned __int8 *v69; // [rsp+B8h] [rbp+20h]

  v69 = a4;
  Size_10 = Size_4;
  v4 = *((_QWORD *)a1 + 2);
  v5 = 0;
  Size_11 = Size_4;
  Src = Src_1;
  Src_2 = Src_1;
  v66 = 0;
  Size_3 = Size_4;
  v10 = (_BYTE *)(v4 + 0xC);
  Size_6 = *(unsigned __int16 *)(v4 + 2);
  Size_5 = Size_4;
  if ( (_WORD)Size_6 && *v10 != *Src_2 )
  {
    v13 = 0xFFFFFFFFLL;
    goto LABEL_7;
  }
  if ( (unsigned __int16)Size_6 > Size_4 )
    goto LABEL_5;
  if ( *(_WORD *)(v4 + 2) )
  {
    Src_3 = Src_1;
    v18 = v10 - Src_1;
    while ( Src_3[v18] == *Src_3 )
    {
      if ( ++Src_3 - Src_1 >= Size_6 )
        goto LABEL_14;
    }
LABEL_5:
    v66 = 1;
LABEL_6:
    v13 = 0;
    goto LABEL_7;
  }
LABEL_14:
  Size_5 = Size_4 - Size_6;
  Size_3 = Size_4 - Size_6;
  Src_2 = &Src_1[*(unsigned __int16 *)(v4 + 2)];
  Src = Src_2;
  if ( Size_4 == (_WORD)Size_6 )
    goto LABEL_6;
  v19 = *(_DWORD *)(v4 + 4);
  if ( v19 == 0xFFFFFFFF )
    goto LABEL_6;
  while ( 1 )
  {
    v20 = sub_146A2F970((__int64)a1, v19, (_BYTE **)&Src, &Size_3, &v66);
    v13 = v20;
    if ( v20 != 0xFFFFFFFF )
      break;
    v19 = *(_DWORD *)(v19 + *((_QWORD *)a1 + 2) + 8LL);
    if ( v19 == 0xFFFFFFFF )
    {
      Src_2 = (char *)Src;
      Size_5 = Size_3;
      goto LABEL_6;
    }
  }
  Src_2 = (char *)Src;
  Size_5 = Size_3;
LABEL_7:
  v14 = (unsigned int)v13;
  if ( v66 )
  {
    Size_7 = 0;
    v31 = (unsigned int)v13 + *((_QWORD *)a1 + 2);
    Size_8 = *(unsigned __int16 *)(v31 + 2);
    if ( *(_WORD *)(v31 + 2) )
    {
      do
      {
        if ( Size_5 < Size_7 )
          break;
        if ( *(_BYTE *)(Size_7 + v31 + 0xC) != Src_2[Size_7] )
          break;
        ++v5;
        ++Size_7;
      }
      while ( Size_7 < Size_8 );
    }
    Size_1 = Size_5 - v5;
    Size = Size_8 - v5;
    if ( !Size )
      __debugbreak();
    v35 = *a1;
    v36 = a1[1];
    v37 = Size + 0xC;
    v63 = *(_DWORD *)(v31 + 4);
    if ( Size_1 )
    {
      v44 = *a1;
      v45 = v37 + Size_1 + 0xC;
      v61 = v45;
      if ( v36 < v45 + (int)v35 )
      {
        v46 = sub_147605AA0(*((void **)a1 + 2), (unsigned int)(v45 + v35), 0);
        v44 = *a1;
        *((_QWORD *)a1 + 2) = v46;
        a1[1] = v44 + v61;
        v45 = v61;
      }
      v47 = (_WORD *)(*((_QWORD *)a1 + 2) + (unsigned int)v13);
      *a1 = v44 + v45;
      v62 = v37 + v35;
      v48 = *((_QWORD *)a1 + 2) + v35;
      v49 = *v47;
      v65 = v47;
      v50 = v5;
      *(_WORD *)v48 = v49;
      *(_WORD *)(v48 + 2) = Size;
      *(_QWORD *)(v48 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v48 + 0xC), (char *)v47 + v5 + 0xC, Size);
      Size_12 = Size_10;
      *(_DWORD *)(v48 + 4) = v63;
      v52 = *((_WORD *)a1 + 4);
      v53 = v69;
      ++a1[2];
      sub_146A25430((__int64)a1, v52, Src_1, Size_12, v53);
      v54 = (char *)Src + v50;
      v55 = *((_QWORD *)a1 + 2) + v62;
      *(_WORD *)v55 = v52;
      *(_WORD *)(v55 + 2) = Size_1;
      *(_QWORD *)(v55 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v55 + 0xC), v54, Size_1);
      v56 = v65;
      v65[1] -= Size;
      *v56 = 0xFFFF;
      *((_DWORD *)v56 + 1) = v35;
      if ( (_DWORD)v35 == 0xFFFFFFFF )
      {
        *((_DWORD *)v56 + 1) = v62;
      }
      else
      {
        v57 = *((_QWORD *)a1 + 2);
        v58 = *(_DWORD *)(v57 + v35 + 8);
        for ( i = v57 + v35; v58 != 0xFFFFFFFF; v58 = *(_DWORD *)(i + 8) )
          i = v57 + v58;
        *(_DWORD *)(i + 8) = v62;
      }
      return v52;
    }
    else
    {
      v38 = *a1;
      if ( v36 < v37 + (int)v35 )
      {
        v39 = sub_147605AA0(*((void **)a1 + 2), (unsigned int)(v37 + v35), 0);
        v38 = *a1;
        *((_QWORD *)a1 + 2) = v39;
        a1[1] = v38 + v37;
      }
      v40 = *((_QWORD *)a1 + 2) + v13;
      *a1 = v38 + v37;
      v41 = *((_QWORD *)a1 + 2) + v35;
      *(_WORD *)v41 = *(_WORD *)v40;
      *(_WORD *)(v41 + 2) = Size;
      *(_QWORD *)(v41 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v41 + 0xC), (const void *)(v40 + v5 + 0xCLL), Size);
      Size_13 = Size_10;
      *(_DWORD *)(v41 + 4) = v63;
      LOWORD(v41) = *((_WORD *)a1 + 4);
      v43 = v69;
      ++a1[2];
      sub_146A25430((__int64)a1, v41, Src_1, Size_13, v43);
      *(_WORD *)(v40 + 2) -= Size;
      result = (unsigned __int16)v41;
      *(_WORD *)v40 = v41;
      *(_DWORD *)(v40 + 4) = v35;
    }
  }
  else
  {
    v15 = *((_WORD *)a1 + 4);
    ++a1[2];
    if ( Size_5 )
    {
      v21 = (unsigned int)sub_1402B9A90((int *)a1, (unsigned int)Size_5 + 0xC);
      sub_146A25430((__int64)a1, v15, Src_1, Size_11, v69);
      v22 = *((_QWORD *)a1 + 2);
      v23 = *(unsigned int *)(v14 + v22 + 4);
      if ( (_DWORD)v23 == 0xFFFFFFFF )
      {
        *(_DWORD *)(v14 + v22 + 4) = v21;
      }
      else
      {
        v24 = v22 + v23;
        for ( j = *(_DWORD *)(v22 + v23 + 8); j != 0xFFFFFFFF; j = *(_DWORD *)(v24 + 8) )
          v24 = v22 + j;
        *(_DWORD *)(v24 + 8) = v21;
      }
      Size_9 = Size_3;
      v27 = *((_QWORD *)a1 + 2) + v21;
      Size_2 = Size_3;
      Src_4 = Src;
      *(_WORD *)v27 = v15;
      *(_WORD *)(v27 + 2) = Size_9;
      *(_QWORD *)(v27 + 4) = 0xFFFFFFFFFFFFFFFFuLL;
      memcpy((void *)(v27 + 0xC), Src_4, Size_2);
      return v15;
    }
    else
    {
      v60 = v69;
      *(_WORD *)(v13 + *((_QWORD *)a1 + 2)) = v15;
      sub_146A25430((__int64)a1, v15, Src_1, Size_11, v60);
      return v15;
    }
  }
  return result;
}

// --- End Function: sub_146A36EA0 (0x146A36EA0) ---

// --- Function: sub_146A37560 (0x146A37560) ---
bool __fastcall sub_146A37560(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  bool v11; // bl
  __int64 v12; // rax
  unsigned int v13; // edx
  __int64 v14; // rcx
  bool v15; // zf

  v4 = a4;
  if ( a3 )
  {
    if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149AC4C0C;
    }
    else
    {
      v9 = _InterlockedIncrement64(&qword_149AC4BF8);
      if ( (v9 & 0x200000) != 0 )
        sub_1403CB300(
          (__int64)&qword_149AC4BF8,
          v9,
          "CEntityComponentUpdateScheduler::IsAggregateCompleteBoundsInRange",
          "CEntity::s_aggregateHierarchyLock",
          1);
    }
    v10 = (_QWORD *)sub_142306700(a2);
    if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
    {
      v11 = 0;
    }
    else
    {
      v12 = sub_146B49880(qword_1515B1A08, v10);
      v13 = *(_DWORD *)(v12 + 0x8C);
      if ( v13 == 0xFFFFFFFF )
      {
LABEL_14:
        v15 = *(_BYTE *)(v4 + v12 + 0x74) == 0;
      }
      else
      {
        while ( 1 )
        {
          v14 = *(_QWORD *)(qword_1515B1A08 + 0x180) + 0x20LL * v13;
          if ( *(_QWORD *)v14 == a3 )
            break;
          v13 = *(_DWORD *)(v14 + 0x18);
          if ( v13 == 0xFFFFFFFF )
            goto LABEL_14;
        }
        v15 = *(_BYTE *)(v4 + v14 + 0xC) == 0;
      }
      v11 = !v15;
    }
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return v11;
  }
  else
  {
    v7 = (_QWORD *)sub_142306700(a2);
    return *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
        && *(_BYTE *)(v4 + sub_146B49880(qword_1515B1A08, v7) + 0x74) != 0;
  }
}

// --- End Function: sub_146A37560 (0x146A37560) ---

// --- Function: sub_146A376D0 (0x146A376D0) ---
bool __fastcall sub_146A376D0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  __int64 v11; // rax
  unsigned int v12; // edx
  __int64 v13; // rcx
  bool v14; // zf
  bool v15; // bl

  v5 = a4;
  if ( BYTE1(qword_149B501D6) )
    return 0;
  if ( !a3 )
  {
    v7 = (_QWORD *)sub_142306700(a2);
    if ( *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF )
      return *(_BYTE *)(v5 + sub_146B49880(qword_1515B1A08, v7) + 0x7C) != 0;
    return 0;
  }
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v9 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v9 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v9,
        "CEntityComponentUpdateScheduler::IsAggregateCompleteBoundsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v10 = (_QWORD *)sub_142306700(a2);
  if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return 0;
  }
  else
  {
    v11 = sub_146B49880(qword_1515B1A08, v10);
    v12 = *(_DWORD *)(v11 + 0x90);
    if ( v12 == 0xFFFFFFFF )
    {
LABEL_14:
      v14 = *(_BYTE *)(v5 + v11 + 0x7C) == 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = *(_QWORD *)(qword_1515B1A08 + 0x1E0) + 0x18LL * v12;
        if ( *(_QWORD *)v13 == a3 )
          break;
        v12 = *(_DWORD *)(v13 + 0x10);
        if ( v12 == 0xFFFFFFFF )
          goto LABEL_14;
      }
      v14 = *(_BYTE *)(v5 + v13 + 0xC) == 0;
    }
    v15 = !v14;
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return v15;
  }
}

// --- End Function: sub_146A376D0 (0x146A376D0) ---

// --- Function: sub_146A37860 (0x146A37860) ---
bool __fastcall sub_146A37860(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  bool v11; // bl
  __int64 v12; // rax
  unsigned int v13; // edx
  __int64 v14; // rcx
  bool v15; // zf

  v4 = a4;
  if ( a3 )
  {
    if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
    {
      ++dword_149AC4C0C;
    }
    else
    {
      v9 = _InterlockedIncrement64(&qword_149AC4BF8);
      if ( (v9 & 0x200000) != 0 )
        sub_1403CB300(
          (__int64)&qword_149AC4BF8,
          v9,
          "CEntityComponentUpdateScheduler::IsAggregateRenderingBoundsInRange",
          "CEntity::s_aggregateHierarchyLock",
          1);
    }
    v10 = (_QWORD *)sub_142306700(a2);
    if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
    {
      v11 = 0;
    }
    else
    {
      v12 = sub_146B49880(qword_1515B1A08, v10);
      v13 = *(_DWORD *)(v12 + 0x8C);
      if ( v13 == 0xFFFFFFFF )
      {
LABEL_14:
        v15 = *(_BYTE *)(v4 + v12 + 0x70) == 0;
      }
      else
      {
        while ( 1 )
        {
          v14 = *(_QWORD *)(qword_1515B1A08 + 0x180) + 0x20LL * v13;
          if ( *(_QWORD *)v14 == a3 )
            break;
          v13 = *(_DWORD *)(v14 + 0x18);
          if ( v13 == 0xFFFFFFFF )
            goto LABEL_14;
        }
        v15 = *(_BYTE *)(v4 + v14 + 8) == 0;
      }
      v11 = !v15;
    }
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return v11;
  }
  else
  {
    v7 = (_QWORD *)sub_142306700(a2);
    return *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
        && *(_BYTE *)(v4 + sub_146B49880(qword_1515B1A08, v7) + 0x70) != 0;
  }
}

// --- End Function: sub_146A37860 (0x146A37860) ---

// --- Function: sub_146A379D0 (0x146A379D0) ---
bool __fastcall sub_146A379D0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  _QWORD *v7; // rax
  signed __int64 v9; // rdx
  _QWORD *v10; // rax
  __int64 v11; // rax
  unsigned int v12; // edx
  __int64 v13; // rcx
  bool v14; // zf
  bool v15; // bl

  v5 = a4;
  if ( BYTE1(qword_149B501D6) )
    return 0;
  if ( !a3 )
  {
    v7 = (_QWORD *)sub_142306700(a2);
    if ( *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF )
      return *(_BYTE *)(v5 + sub_146B49880(qword_1515B1A08, v7) + 0x78) != 0;
    return 0;
  }
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v9 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v9 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v9,
        "CEntityComponentUpdateScheduler::IsAggregateRenderingBoundsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v10 = (_QWORD *)sub_142306700(a2);
  if ( *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return 0;
  }
  else
  {
    v11 = sub_146B49880(qword_1515B1A08, v10);
    v12 = *(_DWORD *)(v11 + 0x90);
    if ( v12 == 0xFFFFFFFF )
    {
LABEL_14:
      v14 = *(_BYTE *)(v5 + v11 + 0x78) == 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = *(_QWORD *)(qword_1515B1A08 + 0x1E0) + 0x18LL * v12;
        if ( *(_QWORD *)v13 == a3 )
          break;
        v12 = *(_DWORD *)(v13 + 0x10);
        if ( v12 == 0xFFFFFFFF )
          goto LABEL_14;
      }
      v14 = *(_BYTE *)(v5 + v13 + 8) == 0;
    }
    v15 = !v14;
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return v15;
  }
}

// --- End Function: sub_146A379D0 (0x146A379D0) ---

// --- Function: sub_146A37E70 (0x146A37E70) ---
bool __fastcall sub_146A37E70(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 __Val_0__, __int64 a3)
{
  bool v6; // al
  unsigned __int64 v7; // rdx
  bool result; // al
  signed __int64 v9; // rdx
  bool v10; // bl
  unsigned __int64 v11; // [rsp+48h] [rbp+10h] BYREF

  v11 = *(_QWORD *)(__Val_0__ + 8);
  v6 = sub_14030EC00(&v11);
  v7 = v11 & 0xFFFFFFFFFFFFLL;
  if ( !v6 )
    v7 = 0;
  switch ( *(_WORD *)(a3 + 0x40) )
  {
    case 0:
      return 1;
    case 1:
      return sub_146A37560(p_p_p_p_p_p_p_p_p_p_p_p_Source, v7, __Val_0__, 1u);
    case 2:
      result = sub_146A376D0(p_p_p_p_p_p_p_p_p_p_p_p_Source, v7, __Val_0__, 1u);
      if ( result )
        return 1;
      break;
    case 3:
      if ( *(_DWORD *)(a3 + 0x20) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(a3 + 0x24);
      }
      else
      {
        v9 = _InterlockedIncrement64((volatile signed __int64 *)(a3 + 0x10));
        if ( (v9 & 0x200000) != 0 )
          sub_1403CB300(
            a3 + 0x10,
            v9,
            "CEntityComponentUpdateScheduler::IsComponentDebugUpdateActive",
            "pAllocator->lock",
            1);
      }
      v10 = *(_BYTE *)(__Val_0__ + 0x69) != 0;
      sub_1402D2790(a3 + 0x10);
      return v10;
    default:
      __debugbreak();
      return 1;
  }
  return result;
}

// --- End Function: sub_146A37E70 (0x146A37E70) ---

// --- Function: sub_146A37FA0 (0x146A37FA0) ---
bool __fastcall sub_146A37FA0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v5; // r10
  char v7; // r15
  __int64 v9; // r8
  int *v10; // rbx
  unsigned int v11; // r14d
  bool v12; // al
  __int64 v13; // rdx
  bool result; // al
  bool v15; // al

  v5 = 0x2E0LL * *(unsigned __int16 *)(a3 + 0x10);
  v7 = a4;
  v9 = *(_QWORD *)(v5 + a1 + 0x4108);
  if ( (*(_QWORD *)(v5 + a1 + 0x4110) - v9) / 0x30 <= (unsigned __int64)a4 )
    unknown_libname_11();
  v10 = (int *)(v9 + 0x30LL * a4);
  v11 = *v10;
  if ( *((_BYTE *)v10 + 0x28) )
  {
    if ( *((_BYTE *)v10 + 0x28) == 1 )
    {
      v12 = sub_140418C10(a2);
    }
    else
    {
      if ( *((_BYTE *)v10 + 0x28) != 2 )
        return 0;
      v12 = !sub_140418C10(a2);
    }
    if ( v12 )
      goto LABEL_8;
    return 0;
  }
LABEL_8:
  if ( (unsigned __int8)sub_146A38E70(v11) )
    return 0;
  v13 = *(_QWORD *)(a3 + 0x58) & (1LL << v7);
  switch ( *((_WORD *)v10 + 0xC) )
  {
    case 0:
      return 0;
    case 1:
      goto LABEL_16;
    case 2:
      return v13 != 0;
    case 3:
      return sub_146A37860(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
    case 4:
      return sub_146A37560(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
    case 5:
      if ( !v13 )
        return 0;
      v15 = sub_146A37860(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 6:
      if ( !v13 )
        return 0;
      v15 = sub_146A37560(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 7:
      return sub_146A38C30(a1, a2, *((_BYTE *)v10 + 0x1A));
    case 8:
      return sub_146A389F0(a1, a2, *((_BYTE *)v10 + 0x1A));
    case 9:
      if ( !v13 )
        return 0;
      v15 = sub_146A38C30(a1, a2, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 0xA:
      if ( !v13 )
        return 0;
      v15 = sub_146A389F0(a1, a2, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 0xB:
      return sub_146A38340(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
    case 0xC:
      if ( !v13 )
        return 0;
      v15 = sub_146A38340(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 0xD:
      return sub_146A379D0(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
    case 0xE:
      return sub_146A376D0(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
    case 0xF:
      if ( !v13 )
        return 0;
      v15 = sub_146A379D0(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 0x10:
      if ( !v13 )
        return 0;
      v15 = sub_146A376D0(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 0x11:
      return sub_146A38D10(a1, a2, *((_BYTE *)v10 + 0x1A));
    case 0x12:
      return sub_146A38AD0(a1, a2, *((_BYTE *)v10 + 0x1A));
    case 0x13:
      if ( !v13 )
        return 0;
      v15 = sub_146A38D10(a1, a2, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 0x14:
      if ( !v13 )
        return 0;
      v15 = sub_146A38AD0(a1, a2, *((_BYTE *)v10 + 0x1A));
      goto LABEL_15;
    case 0x15:
      return sub_146A38430(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
    case 0x16:
      if ( !v13 )
        return 0;
      v15 = sub_146A38430(a1, a2, a3, *((_BYTE *)v10 + 0x1A));
LABEL_15:
      if ( !v15 )
        return 0;
LABEL_16:
      result = 1;
      break;
    default:
      __debugbreak();
      return 0;
  }
  return result;
}

// --- End Function: sub_146A37FA0 (0x146A37FA0) ---

// --- Function: sub_146A38340 (0x146A38340) ---
bool __fastcall sub_146A38340(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  signed __int64 v8; // rdx
  _QWORD *v9; // rax
  bool v10; // bl

  v5 = a4;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v8 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v8 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v8,
        "CEntityComponentUpdateScheduler::IsComponentInRange",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v9 = (_QWORD *)sub_142306700(a2);
  v10 = *(_DWORD *)((*v9 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
     && *(_BYTE *)(v5 + 0x20LL * *(unsigned __int16 *)(a3 + 0x62) + *(_QWORD *)sub_146B49880(qword_1515B1A08, v9) + 0xC) != 0;
  sub_1402D2790((__int64)&qword_149AC4BF8);
  return v10;
}

// --- End Function: sub_146A38340 (0x146A38340) ---

// --- Function: sub_146A38430 (0x146A38430) ---
bool __fastcall sub_146A38430(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v5; // rdi
  signed __int64 v8; // rdx
  _QWORD *v9; // rax
  bool v10; // bl

  v5 = a4;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v8 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v8 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v8,
        "CEntityComponentUpdateScheduler::IsComponentIsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v9 = (_QWORD *)sub_142306700(a2);
  v10 = *(_DWORD *)((*v9 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
     && *(_BYTE *)(v5 + 0x20LL * *(unsigned __int16 *)(a3 + 0x62) + *(_QWORD *)sub_146B49880(qword_1515B1A08, v9) + 0x10) != 0;
  sub_1402D2790((__int64)&qword_149AC4BF8);
  return v10;
}

// --- End Function: sub_146A38430 (0x146A38430) ---

// --- Function: sub_146A38520 (0x146A38520) ---
bool __fastcall sub_146A38520(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // r9
  _WORD *v4; // rax

  v2 = a1 + 0x20;
  if ( !*(_DWORD *)(v2 + 8) )
    return 0;
  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v3;
  while ( a2[v3] );
  v4 = (_WORD *)sub_146A2FA80(v2, 0, a2, v3);
  return v4 && *v4 != 0xFFFF;
}

// --- End Function: sub_146A38520 (0x146A38520) ---

// --- Function: sub_146A38570 (0x146A38570) ---
bool __fastcall sub_146A38570(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v8; // rdi
  _BYTE *v9; // rbx
  bool v10; // al

  if ( !a2 )
    return 0;
  if ( *(_BYTE *)(a2 + 0xD) >= 5u )
    return 0;
  v8 = *(_QWORD *)(a4 + 0xF8) + 0x20LL * a5;
  v9 = (_BYTE *)(*(_QWORD *)(a3 + 0x18) + 0xCLL * a5);
  if ( v9[3] )
    return 0;
  if ( *(_BYTE *)(v8 + 0x11) )
  {
    if ( *(_BYTE *)(v8 + 0x11) == 1 )
    {
      v10 = sub_140418C10(a2);
    }
    else
    {
      if ( *(_BYTE *)(v8 + 0x11) != 2 )
        return 0;
      v10 = !sub_140418C10(a2);
    }
    if ( v10 )
      goto LABEL_10;
    return 0;
  }
LABEL_10:
  if ( !v9[4] )
  {
    switch ( *(_WORD *)(v8 + 8) )
    {
      case 0:
        return 0;
      case 1:
        return 1;
      case 2:
        return *v9 != 0;
      case 3:
        if ( v9[2] )
          return 1;
        return sub_146A37860(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 4:
        if ( v9[2] )
          return 1;
        return sub_146A37560(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 5:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A37860(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 6:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A37560(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 7:
        if ( v9[2] )
          return 1;
        return sub_146A38C30(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 8:
        if ( v9[2] )
          return 1;
        return sub_146A389F0(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 9:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A38C30(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 0xA:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A389F0(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 0xB:
        if ( v9[2] )
          return 1;
        return sub_146A38340(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 0xC:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A38340(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 0xD:
        if ( v9[2] )
          return 1;
        return sub_146A379D0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 0xE:
        if ( v9[2] )
          return 1;
        return sub_146A376D0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 0xF:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A379D0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 0x10:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A376D0(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 0x11:
        if ( v9[2] )
          return 1;
        return sub_146A38D10(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 0x12:
        if ( v9[2] )
          return 1;
        return sub_146A38AD0(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 0x13:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A38D10(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 0x14:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A38AD0(a1, a2, *(_BYTE *)(v8 + 0xA));
      case 0x15:
        if ( v9[2] )
          return 1;
        return sub_146A38430(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      case 0x16:
        if ( !*v9 )
          return 0;
        if ( v9[2] )
          return 1;
        return sub_146A38430(a1, a2, a3, *(_BYTE *)(v8 + 0xA));
      default:
        __debugbreak();
        return 0;
    }
  }
  return 1;
}

// --- End Function: sub_146A38570 (0x146A38570) ---

// --- Function: sub_146A389F0 (0x146A389F0) ---
bool __fastcall sub_146A389F0(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v6; // rdx
  _QWORD *v7; // rax
  bool v8; // bl

  v4 = a3;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v6 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v6 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v6,
        "CEntityComponentUpdateScheduler::IsEntityCompleteBoundsInRange",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v7 = (_QWORD *)sub_142306700(a2);
  v8 = *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
    && *(_BYTE *)(*(_QWORD *)(sub_146B49880(qword_1515B1A08, v7) + 8)
                + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                + v4
                + 0x1C) != 0;
  sub_1402D2790((__int64)&qword_149AC4BF8);
  return v8;
}

// --- End Function: sub_146A389F0 (0x146A389F0) ---

// --- Function: sub_146A38AD0 (0x146A38AD0) ---
bool __fastcall sub_146A38AD0(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v5; // rdx
  _QWORD *v6; // rax
  bool v8; // bl

  v4 = a3;
  if ( BYTE1(qword_149B501D6) || (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v5 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v5 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v5,
        "CEntityComponentUpdateScheduler::IsEntityCompleteBoundsIsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v6 = (_QWORD *)sub_142306700(a2);
  if ( *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return 0;
  }
  else
  {
    v8 = *(_BYTE *)(*(_QWORD *)(sub_146B49880(qword_1515B1A08, v6) + 8)
                  + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                  + v4
                  + 0x24) != 0;
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return v8;
  }
}

// --- End Function: sub_146A38AD0 (0x146A38AD0) ---

// --- Function: sub_146A38C30 (0x146A38C30) ---
bool __fastcall sub_146A38C30(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v6; // rdx
  _QWORD *v7; // rax
  bool v8; // bl

  v4 = a3;
  if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v6 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v6 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v6,
        "CEntityComponentUpdateScheduler::IsEntityRenderingBoundsInRange",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v7 = (_QWORD *)sub_142306700(a2);
  v8 = *(_DWORD *)((*v7 & 0xFFFFFFFFFFFFLL) + 0x2F0) != 0xFFFFFFFF
    && *(_BYTE *)(*(_QWORD *)(sub_146B49880(qword_1515B1A08, v7) + 8)
                + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                + v4
                + 0x18) != 0;
  sub_1402D2790((__int64)&qword_149AC4BF8);
  return v8;
}

// --- End Function: sub_146A38C30 (0x146A38C30) ---

// --- Function: sub_146A38D10 (0x146A38D10) ---
bool __fastcall sub_146A38D10(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v4; // rdi
  signed __int64 v5; // rdx
  _QWORD *v6; // rax
  bool v8; // bl

  v4 = a3;
  if ( BYTE1(qword_149B501D6) || (*(_DWORD *)(a2 + 8) & 0x100) == 0 )
    return 0;
  if ( dword_149AC4C08 == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++dword_149AC4C0C;
  }
  else
  {
    v5 = _InterlockedIncrement64(&qword_149AC4BF8);
    if ( (v5 & 0x200000) != 0 )
      sub_1403CB300(
        (__int64)&qword_149AC4BF8,
        v5,
        "CEntityComponentUpdateScheduler::IsEntityRenderingBoundsIsVisible",
        "CEntity::s_aggregateHierarchyLock",
        1);
  }
  v6 = (_QWORD *)sub_142306700(a2);
  if ( *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFLL) + 0x2F0) == 0xFFFFFFFF )
  {
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return 0;
  }
  else
  {
    v8 = *(_BYTE *)(*(_QWORD *)(sub_146B49880(qword_1515B1A08, v6) + 8)
                  + 0x38LL * *(unsigned __int16 *)(a2 + 0x2EC)
                  + v4
                  + 0x20) != 0;
    sub_1402D2790((__int64)&qword_149AC4BF8);
    return v8;
  }
}

// --- End Function: sub_146A38D10 (0x146A38D10) ---

// --- Function: sub_146A38E70 (0x146A38E70) ---
bool __fastcall sub_146A38E70(int event_key_from_source_location_1)
{
  int event_key_from_source_location; // eax
  int event_key_from_source_location_2; // eax
  int event_key_from_source_location_3; // eax
  int event_key_from_source_location_4; // eax
  int event_key_from_source_location_5; // eax
  int event_key_from_source_location_6; // eax
  int event_key_from_source_location_7; // eax
  int event_key_from_source_location_8; // eax
  int event_key_from_source_location_9; // eax
  int event_key_from_source_location_10; // eax
  int event_key_from_source_location_11; // eax
  int event_key_from_source_location_12; // eax
  int event_key_from_source_location_13; // eax
  int event_key_from_source_location_14; // eax
  int event_key_from_source_location_15; // eax
  int event_key_from_source_location_16; // eax
  int event_key_from_source_location_17; // eax
  int event_key_from_source_location_18; // eax
  int event_key_from_source_location_19; // eax
  int event_key_from_source_location_20; // eax
  int event_key_from_source_location_21; // eax
  int event_key_from_source_location_22; // eax
  int event_key_from_source_location_23; // eax
  int event_key_from_source_location_24; // eax
  int event_key_from_source_location_25; // eax
  int event_key_from_source_location_26; // eax
  int event_key_from_source_location_27; // eax
  int event_key_from_source_location_28; // eax
  int event_key_from_source_location_29; // eax
  int event_key_from_source_location_30; // eax
  int event_key_from_source_location_31; // eax
  int event_key_from_source_location_32; // eax
  int event_key_from_source_location_33; // eax
  int event_key_from_source_location_34; // eax
  int event_key_from_source_location_35; // eax
  int event_key_from_source_location_36; // eax
  int event_key_from_source_location_37; // eax
  int event_key_from_source_location_38; // eax
  int event_key_from_source_location_39; // eax
  int event_key_from_source_location_40; // eax
  int event_key_from_source_location_41; // eax
  int event_key_from_source_location_42; // eax
  int event_key_from_source_location_43; // eax
  int event_key_from_source_location_44; // eax
  int event_key_from_source_location_45; // eax
  int event_key_from_source_location_46; // eax
  int event_key_from_source_location_47; // eax
  int event_key_from_source_location_48; // eax
  int event_key_from_source_location_49; // eax
  int event_key_from_source_location_50; // eax
  int event_key_from_source_location_51; // eax
  int event_key_from_source_location_52; // eax
  int event_key_from_source_location_53; // eax
  int event_key_from_source_location_54; // eax
  int event_key_from_source_location_55; // eax
  int event_key_from_source_location_56; // eax
  int event_key_from_source_location_57; // eax
  int event_key_from_source_location_58; // eax
  int event_key_from_source_location_59; // eax
  int event_key_from_source_location_60; // eax

  event_key_from_source_location = ::event_key_from_source_location_52;
  if ( !::event_key_from_source_location_52 )
    event_key_from_source_location = get_event_key_from_source_location(
                                       &::event_key_from_source_location_52,
                                       (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                       0xA);
  if ( event_key_from_source_location_1 == event_key_from_source_location )
    return 1;
  event_key_from_source_location_2 = ::event_key_from_source_location_53;
  if ( !::event_key_from_source_location_53 )
    event_key_from_source_location_2 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_53,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x13);
  if ( event_key_from_source_location_1 == event_key_from_source_location_2 )
    return 1;
  event_key_from_source_location_3 = ::event_key_from_source_location_54;
  if ( !::event_key_from_source_location_54 )
    event_key_from_source_location_3 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_54,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x1C);
  if ( event_key_from_source_location_1 == event_key_from_source_location_3 )
    return 1;
  event_key_from_source_location_4 = ::event_key_from_source_location_55;
  if ( !::event_key_from_source_location_55 )
    event_key_from_source_location_4 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_55,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x25);
  if ( event_key_from_source_location_1 == event_key_from_source_location_4 )
    return 1;
  event_key_from_source_location_5 = ::event_key_from_source_location_56;
  if ( !::event_key_from_source_location_56 )
    event_key_from_source_location_5 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_56,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x54);
  if ( event_key_from_source_location_1 == event_key_from_source_location_5 )
    return 1;
  event_key_from_source_location_6 = ::event_key_from_source_location_57;
  if ( !::event_key_from_source_location_57 )
    event_key_from_source_location_6 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_57,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x5D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_6 )
    return 1;
  event_key_from_source_location_7 = ::event_key_from_source_location_58;
  if ( !::event_key_from_source_location_58 )
    event_key_from_source_location_7 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_58,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x66);
  if ( event_key_from_source_location_1 == event_key_from_source_location_7 )
    return 1;
  event_key_from_source_location_8 = ::event_key_from_source_location_59;
  if ( !::event_key_from_source_location_59 )
    event_key_from_source_location_8 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_59,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x6F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_8 )
    return 1;
  event_key_from_source_location_9 = ::event_key_from_source_location_60;
  if ( !::event_key_from_source_location_60 )
    event_key_from_source_location_9 = get_event_key_from_source_location(
                                         &::event_key_from_source_location_60,
                                         (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                         0x2F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_9 )
    return 1;
  event_key_from_source_location_10 = event_key_from_source_location_61;
  if ( !event_key_from_source_location_61 )
    event_key_from_source_location_10 = get_event_key_from_source_location(
                                          &event_key_from_source_location_61,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x38);
  if ( event_key_from_source_location_1 == event_key_from_source_location_10 )
    return 1;
  event_key_from_source_location_11 = event_key_from_source_location_62;
  if ( !event_key_from_source_location_62 )
    event_key_from_source_location_11 = get_event_key_from_source_location(
                                          &event_key_from_source_location_62,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x41);
  if ( event_key_from_source_location_1 == event_key_from_source_location_11 )
    return 1;
  event_key_from_source_location_12 = event_key_from_source_location_63;
  if ( !event_key_from_source_location_63 )
    event_key_from_source_location_12 = get_event_key_from_source_location(
                                          &event_key_from_source_location_63,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x4A);
  if ( event_key_from_source_location_1 == event_key_from_source_location_12 )
    return 1;
  event_key_from_source_location_13 = event_key_from_source_location_64;
  if ( !event_key_from_source_location_64 )
    event_key_from_source_location_13 = get_event_key_from_source_location(
                                          &event_key_from_source_location_64,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x79);
  if ( event_key_from_source_location_1 == event_key_from_source_location_13 )
    return 1;
  event_key_from_source_location_14 = event_key_from_source_location_65;
  if ( !event_key_from_source_location_65 )
    event_key_from_source_location_14 = get_event_key_from_source_location(
                                          &event_key_from_source_location_65,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x82);
  if ( event_key_from_source_location_1 == event_key_from_source_location_14 )
    return 1;
  event_key_from_source_location_15 = event_key_from_source_location_66;
  if ( !event_key_from_source_location_66 )
    event_key_from_source_location_15 = get_event_key_from_source_location(
                                          &event_key_from_source_location_66,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x8B);
  if ( event_key_from_source_location_1 == event_key_from_source_location_15 )
    return 1;
  event_key_from_source_location_16 = event_key_from_source_location_67;
  if ( !event_key_from_source_location_67 )
    event_key_from_source_location_16 = get_event_key_from_source_location(
                                          &event_key_from_source_location_67,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x94);
  if ( event_key_from_source_location_1 == event_key_from_source_location_16 )
    return 1;
  event_key_from_source_location_17 = ::event_key_from_source_location_1;
  if ( !::event_key_from_source_location_1 )
    event_key_from_source_location_17 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_1,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x17C);
  if ( event_key_from_source_location_1 == event_key_from_source_location_17 )
    return 1;
  event_key_from_source_location_18 = ::event_key_from_source_location_2;
  if ( !::event_key_from_source_location_2 )
    event_key_from_source_location_18 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_2,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x18D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_18 )
    return 1;
  event_key_from_source_location_19 = ::event_key_from_source_location_3;
  if ( !::event_key_from_source_location_3 )
    event_key_from_source_location_19 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_3,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1A1);
  if ( event_key_from_source_location_1 == event_key_from_source_location_19 )
    return 1;
  event_key_from_source_location_20 = ::event_key_from_source_location_4;
  if ( !::event_key_from_source_location_4 )
    event_key_from_source_location_20 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_4,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1B6);
  if ( event_key_from_source_location_1 == event_key_from_source_location_20 )
    return 1;
  event_key_from_source_location_21 = ::event_key_from_source_location_5;
  if ( !::event_key_from_source_location_5 )
    event_key_from_source_location_21 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_5,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1CD);
  if ( event_key_from_source_location_1 == event_key_from_source_location_21 )
    return 1;
  event_key_from_source_location_22 = ::event_key_from_source_location_6;
  if ( !::event_key_from_source_location_6 )
    event_key_from_source_location_22 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_6,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1DE);
  if ( event_key_from_source_location_1 == event_key_from_source_location_22 )
    return 1;
  event_key_from_source_location_23 = ::event_key_from_source_location_7;
  if ( !::event_key_from_source_location_7 )
    event_key_from_source_location_23 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_7,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x1F2);
  if ( event_key_from_source_location_1 == event_key_from_source_location_23 )
    return 1;
  event_key_from_source_location_24 = ::event_key_from_source_location_8;
  if ( !::event_key_from_source_location_8 )
    event_key_from_source_location_24 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_8,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x207);
  if ( event_key_from_source_location_1 == event_key_from_source_location_24 )
    return 1;
  event_key_from_source_location_25 = event_key_from_source_location_68;
  if ( !event_key_from_source_location_68 )
    event_key_from_source_location_25 = get_event_key_from_source_location(
                                          &event_key_from_source_location_68,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x9E);
  if ( event_key_from_source_location_1 == event_key_from_source_location_25 )
    return 1;
  event_key_from_source_location_26 = event_key_from_source_location_69;
  if ( !event_key_from_source_location_69 )
    event_key_from_source_location_26 = get_event_key_from_source_location(
                                          &event_key_from_source_location_69,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xA7);
  if ( event_key_from_source_location_1 == event_key_from_source_location_26 )
    return 1;
  event_key_from_source_location_27 = event_key_from_source_location_70;
  if ( !event_key_from_source_location_70 )
    event_key_from_source_location_27 = get_event_key_from_source_location(
                                          &event_key_from_source_location_70,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xB0);
  if ( event_key_from_source_location_1 == event_key_from_source_location_27 )
    return 1;
  event_key_from_source_location_28 = event_key_from_source_location_71;
  if ( !event_key_from_source_location_71 )
    event_key_from_source_location_28 = get_event_key_from_source_location(
                                          &event_key_from_source_location_71,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xB9);
  if ( event_key_from_source_location_1 == event_key_from_source_location_28 )
    return 1;
  event_key_from_source_location_29 = event_key_from_source_location_72;
  if ( !event_key_from_source_location_72 )
    event_key_from_source_location_29 = get_event_key_from_source_location(
                                          &event_key_from_source_location_72,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xC3);
  if ( event_key_from_source_location_1 == event_key_from_source_location_29 )
    return 1;
  event_key_from_source_location_30 = event_key_from_source_location_73;
  if ( !event_key_from_source_location_73 )
    event_key_from_source_location_30 = get_event_key_from_source_location(
                                          &event_key_from_source_location_73,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xCC);
  if ( event_key_from_source_location_1 == event_key_from_source_location_30 )
    return 1;
  event_key_from_source_location_31 = event_key_from_source_location_74;
  if ( !event_key_from_source_location_74 )
    event_key_from_source_location_31 = get_event_key_from_source_location(
                                          &event_key_from_source_location_74,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xD5);
  if ( event_key_from_source_location_1 == event_key_from_source_location_31 )
    return 1;
  event_key_from_source_location_32 = event_key_from_source_location_75;
  if ( !event_key_from_source_location_75 )
    event_key_from_source_location_32 = get_event_key_from_source_location(
                                          &event_key_from_source_location_75,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xDE);
  if ( event_key_from_source_location_1 == event_key_from_source_location_32 )
    return 1;
  event_key_from_source_location_33 = event_key_from_source_location_76;
  if ( !event_key_from_source_location_76 )
    event_key_from_source_location_33 = get_event_key_from_source_location(
                                          &event_key_from_source_location_76,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xE8);
  if ( event_key_from_source_location_1 == event_key_from_source_location_33 )
    return 1;
  event_key_from_source_location_34 = event_key_from_source_location_77;
  if ( !event_key_from_source_location_77 )
    event_key_from_source_location_34 = get_event_key_from_source_location(
                                          &event_key_from_source_location_77,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xF1);
  if ( event_key_from_source_location_1 == event_key_from_source_location_34 )
    return 1;
  event_key_from_source_location_35 = event_key_from_source_location_78;
  if ( !event_key_from_source_location_78 )
    event_key_from_source_location_35 = get_event_key_from_source_location(
                                          &event_key_from_source_location_78,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0xFA);
  if ( event_key_from_source_location_1 == event_key_from_source_location_35 )
    return 1;
  event_key_from_source_location_36 = event_key_from_source_location_79;
  if ( !event_key_from_source_location_79 )
    event_key_from_source_location_36 = get_event_key_from_source_location(
                                          &event_key_from_source_location_79,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x103);
  if ( event_key_from_source_location_1 == event_key_from_source_location_36 )
    return 1;
  event_key_from_source_location_37 = event_key_from_source_location_80;
  if ( !event_key_from_source_location_80 )
    event_key_from_source_location_37 = get_event_key_from_source_location(
                                          &event_key_from_source_location_80,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x10D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_37 )
    return 1;
  event_key_from_source_location_38 = event_key_from_source_location_81;
  if ( !event_key_from_source_location_81 )
    event_key_from_source_location_38 = get_event_key_from_source_location(
                                          &event_key_from_source_location_81,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x116);
  if ( event_key_from_source_location_1 == event_key_from_source_location_38 )
    return 1;
  event_key_from_source_location_39 = event_key_from_source_location_82;
  if ( !event_key_from_source_location_82 )
    event_key_from_source_location_39 = get_event_key_from_source_location(
                                          &event_key_from_source_location_82,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x11F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_39 )
    return 1;
  event_key_from_source_location_40 = event_key_from_source_location_83;
  if ( !event_key_from_source_location_83 )
    event_key_from_source_location_40 = get_event_key_from_source_location(
                                          &event_key_from_source_location_83,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x128);
  if ( event_key_from_source_location_1 == event_key_from_source_location_40 )
    return 1;
  event_key_from_source_location_41 = ::event_key_from_source_location_9;
  if ( !::event_key_from_source_location_9 )
    event_key_from_source_location_41 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_9,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x21E);
  if ( event_key_from_source_location_1 == event_key_from_source_location_41 )
    return 1;
  event_key_from_source_location_42 = ::event_key_from_source_location_10;
  if ( !::event_key_from_source_location_10 )
    event_key_from_source_location_42 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_10,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x22F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_42 )
    return 1;
  event_key_from_source_location_43 = ::event_key_from_source_location_11;
  if ( !::event_key_from_source_location_11 )
    event_key_from_source_location_43 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_11,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x243);
  if ( event_key_from_source_location_1 == event_key_from_source_location_43 )
    return 1;
  event_key_from_source_location_44 = ::event_key_from_source_location_12;
  if ( !::event_key_from_source_location_12 )
    event_key_from_source_location_44 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_12,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x258);
  if ( event_key_from_source_location_1 == event_key_from_source_location_44 )
    return 1;
  event_key_from_source_location_45 = ::event_key_from_source_location_13;
  if ( !::event_key_from_source_location_13 )
    event_key_from_source_location_45 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_13,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x26F);
  if ( event_key_from_source_location_1 == event_key_from_source_location_45 )
    return 1;
  event_key_from_source_location_46 = ::event_key_from_source_location_14;
  if ( !::event_key_from_source_location_14 )
    event_key_from_source_location_46 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_14,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x280);
  if ( event_key_from_source_location_1 == event_key_from_source_location_46 )
    return 1;
  event_key_from_source_location_47 = ::event_key_from_source_location_15;
  if ( !::event_key_from_source_location_15 )
    event_key_from_source_location_47 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_15,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x294);
  if ( event_key_from_source_location_1 == event_key_from_source_location_47 )
    return 1;
  event_key_from_source_location_48 = ::event_key_from_source_location_16;
  if ( !::event_key_from_source_location_16 )
    event_key_from_source_location_48 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_16,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2A9);
  if ( event_key_from_source_location_1 == event_key_from_source_location_48 )
    return 1;
  event_key_from_source_location_49 = event_key_from_source_location_84;
  if ( !event_key_from_source_location_84 )
    event_key_from_source_location_49 = get_event_key_from_source_location(
                                          &event_key_from_source_location_84,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x132);
  if ( event_key_from_source_location_1 == event_key_from_source_location_49 )
    return 1;
  event_key_from_source_location_50 = event_key_from_source_location_85;
  if ( !event_key_from_source_location_85 )
    event_key_from_source_location_50 = get_event_key_from_source_location(
                                          &event_key_from_source_location_85,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x13B);
  if ( event_key_from_source_location_1 == event_key_from_source_location_50 )
    return 1;
  event_key_from_source_location_51 = event_key_from_source_location_86;
  if ( !event_key_from_source_location_86 )
    event_key_from_source_location_51 = get_event_key_from_source_location(
                                          &event_key_from_source_location_86,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x144);
  if ( event_key_from_source_location_1 == event_key_from_source_location_51 )
    return 1;
  event_key_from_source_location_52 = event_key_from_source_location_87;
  if ( !event_key_from_source_location_87 )
    event_key_from_source_location_52 = get_event_key_from_source_location(
                                          &event_key_from_source_location_87,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x14D);
  if ( event_key_from_source_location_1 == event_key_from_source_location_52 )
    return 1;
  event_key_from_source_location_53 = event_key_from_source_location_88;
  if ( !event_key_from_source_location_88 )
    event_key_from_source_location_53 = get_event_key_from_source_location(
                                          &event_key_from_source_location_88,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x157);
  if ( event_key_from_source_location_1 == event_key_from_source_location_53 )
    return 1;
  event_key_from_source_location_54 = event_key_from_source_location_89;
  if ( !event_key_from_source_location_89 )
    event_key_from_source_location_54 = get_event_key_from_source_location(
                                          &event_key_from_source_location_89,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x160);
  if ( event_key_from_source_location_1 == event_key_from_source_location_54 )
    return 1;
  event_key_from_source_location_55 = event_key_from_source_location_90;
  if ( !event_key_from_source_location_90 )
    event_key_from_source_location_55 = get_event_key_from_source_location(
                                          &event_key_from_source_location_90,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x169);
  if ( event_key_from_source_location_1 == event_key_from_source_location_55 )
    return 1;
  event_key_from_source_location_56 = event_key_from_source_location_91;
  if ( !event_key_from_source_location_91 )
    event_key_from_source_location_56 = get_event_key_from_source_location(
                                          &event_key_from_source_location_91,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x172);
  if ( event_key_from_source_location_1 == event_key_from_source_location_56 )
    return 1;
  event_key_from_source_location_57 = ::event_key_from_source_location_17;
  if ( !::event_key_from_source_location_17 )
    event_key_from_source_location_57 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_17,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2C0);
  if ( event_key_from_source_location_1 == event_key_from_source_location_57 )
    return 1;
  event_key_from_source_location_58 = ::event_key_from_source_location_18;
  if ( !::event_key_from_source_location_18 )
    event_key_from_source_location_58 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_18,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2D1);
  if ( event_key_from_source_location_1 == event_key_from_source_location_58 )
    return 1;
  event_key_from_source_location_59 = ::event_key_from_source_location_19;
  if ( !::event_key_from_source_location_19 )
    event_key_from_source_location_59 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_19,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2E5);
  if ( event_key_from_source_location_1 == event_key_from_source_location_59 )
    return 1;
  event_key_from_source_location_60 = ::event_key_from_source_location_20;
  if ( !::event_key_from_source_location_20 )
    event_key_from_source_location_60 = get_event_key_from_source_location(
                                          &::event_key_from_source_location_20,
                                          (__int64)"W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Events/ECUS/Events.h",
                                          0x2FA);
  return event_key_from_source_location_1 == event_key_from_source_location_60;
}

// --- End Function: sub_146A38E70 (0x146A38E70) ---

// --- Function: LogTraceConditional_w (0x146A398F0) ---
void sub_146A398F0()
{
  LogTraceConditional("Component Timings is disabled, enable it at ComponentStats.h");
}

// --- End Function: LogTraceConditional_w (0x146A398F0) ---

// --- Function: sub_146A414F0 (0x146A414F0) ---
char *__fastcall sub_146A414F0(__int64 a1, __int16 a2)
{
  __int64 v2; // rcx
  char *result; // rax
  __int16 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  v2 = a1 + 0xD8;
  result = *(char **)(v2 + 8);
  if ( result == *(char **)(v2 + 0x10) )
    return sub_1411F87F0(v2, *(_BYTE **)(v2 + 8), &v4);
  *(_WORD *)result = a2;
  *(_QWORD *)(v2 + 8) += 2LL;
  return result;
}

// --- End Function: sub_146A414F0 (0x146A414F0) ---

// --- Function: sub_146A41530 (0x146A41530) ---
void __fastcall sub_146A41530(__int64 a1, __int64 *a2)
{
  __int64 v4; // rax
  unsigned int *v5; // r13
  unsigned __int8 *v6; // r14
  unsigned __int64 Size; // rdi
  char *v8; // rsi
  unsigned __int16 *v9; // rax
  unsigned __int16 n0x800; // bx
  unsigned int v11; // r9d
  char *v12; // r10
  char v13; // r8
  char v14; // cl
  __int64 v15; // rdi
  __int64 inserted; // rcx
  __int64 v17; // rax
  __int64 v18; // rax
  __int128 v19; // xmm0
  _QWORD *v20; // rsi
  __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // r9
  __int64 v24; // rdi
  unsigned __int64 i; // r9
  unsigned __int64 j; // r15
  unsigned __int64 Size_1; // rdi
  char *v28; // r14
  unsigned __int16 *v29; // rax
  unsigned __int16 n0x800_1; // si
  __int64 v31; // rcx
  _WORD *v32; // rax
  __int64 v33; // rcx
  _BYTE *v34; // rdx
  _QWORD *v35; // r8
  __int64 *v36; // rsi
  __int64 v37; // rcx
  unsigned __int64 v38; // rdx
  __int64 v39; // rax
  __int64 *v40; // r14
  __int64 v41; // rdi
  unsigned int v42; // eax
  __int64 v43; // rcx
  char *v44; // r9
  char *v45; // r8
  unsigned __int64 v46; // rdx
  __int64 v47; // rdi
  __int128 v48; // [rsp+20h] [rbp-59h]
  __int128 v49; // [rsp+30h] [rbp-49h] BYREF
  __int128 v50; // [rsp+40h] [rbp-39h] BYREF
  __int128 v51; // [rsp+58h] [rbp-21h] BYREF
  __int64 v52; // [rsp+68h] [rbp-11h]
  unsigned __int16 n0x800_3; // [rsp+70h] [rbp-9h] BYREF
  __int128 v54; // [rsp+78h] [rbp-1h]
  _QWORD *v55; // [rsp+E0h] [rbp+67h] BYREF
  __int64 *v56; // [rsp+E8h] [rbp+6Fh]
  unsigned __int16 n0x800_2; // [rsp+F0h] [rbp+77h] BYREF
  unsigned int v58; // [rsp+F8h] [rbp+7Fh] BYREF

  v56 = a2;
  v55 = (_QWORD *)a1;
  v52 = 0;
  v4 = *a2;
  v51 = 0;
  (*(void (__fastcall **)(__int64 *, __int128 *))(v4 + 0x30))(a2, &v51);
  if ( (_QWORD)v51 == *((_QWORD *)&v51 + 1) )
    LogFatalError("Failed to retrieve component name on registration");
  v5 = (unsigned int *)(a1 + 0x20);
  v6 = (unsigned __int8 *)(*(__int64 (__fastcall **)(__int64 *))(*a2 + 0x38))(a2);
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  v8 = *(char **)v51;
  do
    ++Size;
  while ( v8[Size] );
  if ( !*(_DWORD *)(a1 + 0x28)
    || (v9 = (unsigned __int16 *)sub_146A2FA80(a1 + 0x20, 0, *(_BYTE **)v51, (unsigned __int16)Size)) == 0
    || (n0x800 = *v9, *v9 == 0xFFFF) )
  {
    n0x800 = sub_146A36EA0((unsigned int *)(a1 + 0x20), v8, Size, v6);
  }
  if ( n0x800 >= 0x800u )
    LogFatalError(
      "Too many registered components. Please increase CEntity::MAX_SUPPORTED_COMPONENTS (current value %d)",
      0x800);
  v11 = 0x811C9DC5;
  v12 = *(char **)v51;
  do
  {
    v13 = *v12++;
    v14 = v13 - 0x20;
    if ( (unsigned __int8)(v13 - 0x61) > 0x19u )
      v14 = v13;
    v11 = 0x1000193 * (v11 ^ v14);
  }
  while ( v13 );
  v15 = *(_QWORD *)(a1 + 0x88);
  v58 = v11;
  inserted = v15;
  DWORD2(v50) = 0;
  v17 = *(_QWORD *)(v15 + 8);
  *(_QWORD *)&v50 = v17;
  while ( !*(_BYTE *)(v17 + 0x19) )
  {
    *(_QWORD *)&v50 = v17;
    if ( *(_DWORD *)(v17 + 0x1C) >= v11 )
    {
      inserted = v17;
      DWORD2(v50) = 1;
      v17 = *(_QWORD *)v17;
    }
    else
    {
      v17 = *(_QWORD *)(v17 + 0x10);
      DWORD2(v50) = 0;
    }
  }
  if ( *(_BYTE *)(inserted + 0x19) || v11 < *(_DWORD *)(inserted + 0x1C) )
  {
    if ( *(_QWORD *)(a1 + 0x90) == 0x666666666666666LL )
      unknown_libname_7();
    v18 = allocWithProfilerInfo_w(0x28u);
    v19 = v50;
    *(_DWORD *)(v18 + 0x1C) = v58;
    *(_WORD *)(v18 + 0x20) = 0xFFFF;
    *(_QWORD *)v18 = v15;
    *(_QWORD *)(v18 + 8) = v15;
    *(_QWORD *)(v18 + 0x10) = v15;
    *(_WORD *)(v18 + 0x18) = 0;
    v49 = v19;
    inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                 (__int64 **)(a1 + 0x88),
                 (__int64)&v49,
                 v18);
  }
  *(_WORD *)(inserted + 0x20) = n0x800;
  *(_WORD *)(*(_QWORD *)sub_146A165D0(a1 + 0x98, (__int64)&v50, (unsigned __int8 *)&v58) + 0x14LL) = n0x800;
  v20 = *(_QWORD **)(a1 + 0x78);
  v21 = *(_QWORD *)(a1 + 0x70);
  v22 = (__int64)v20 - v21;
  v23 = *(unsigned int *)(a1 + 0x28) + ((__int64)(*((_QWORD *)&v51 + 1) - v51) >> 3);
  if ( v23 >= ((__int64)v20 - v21) / 0x18 )
  {
    if ( v23 > v22 / 0x18 )
    {
      if ( v23 <= (*(_QWORD *)(a1 + 0x80) - v21) / 0x18 )
      {
        for ( i = v23 - v22 / 0x18; i; --i )
        {
          *v20 = 0;
          v20[1] = 0;
          v20[2] = 0;
          v20 += 3;
        }
        sub_146A12030((__int64)v20, (__int64)v20);
        *(_QWORD *)(a1 + 0x78) = v20;
      }
      else
      {
        sub_146A15B80(
          (__int64 *)(a1 + 0x70),
          *(unsigned int *)(a1 + 0x28) + ((__int64)(*((_QWORD *)&v51 + 1) - v51) >> 3));
      }
    }
  }
  else
  {
    v24 = v21 + 0x18 * v23;
    sub_146A12030(v24, *(_QWORD *)(a1 + 0x78));
    *(_QWORD *)(a1 + 0x78) = v24;
  }
  for ( j = 1; j < (__int64)(*((_QWORD *)&v51 + 1) - v51) >> 3; ++j )
  {
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    v28 = *(char **)(v51 + 8 * j);
    do
      ++Size_1;
    while ( v28[Size_1] );
    if ( !v5[2]
      || (v29 = (unsigned __int16 *)sub_146A2FA80((__int64)v5, 0, *(_BYTE **)(v51 + 8 * j), (unsigned __int16)Size_1)) == 0
      || (n0x800_1 = *v29, *v29 == 0xFFFF) )
    {
      n0x800_1 = sub_146A36EA0(v5, v28, Size_1, (unsigned __int8 *)&p_p_p_p_p_p_p_p_p_p_p_Source);
    }
    if ( n0x800_1 > 0x800u )
      LogFatalError("Too many registered components. Please increase MAX_SUPPORTED_COMPONENTS");
    v31 = v55[0xE];
    v32 = *(_WORD **)(v31 + 0x18LL * n0x800_1);
    v33 = v31 + 0x18LL * n0x800_1;
    v34 = *(_BYTE **)(v33 + 8);
    if ( v32 == (_WORD *)v34 )
    {
LABEL_44:
      n0x800_2 = n0x800;
      if ( v34 == *(_BYTE **)(v33 + 0x10) )
      {
        sub_142478E00((const void **)v33, v34, &n0x800_2);
      }
      else
      {
        *(_WORD *)v34 = n0x800;
        *(_QWORD *)(v33 + 8) += 2LL;
      }
    }
    else
    {
      while ( *v32 != n0x800_1 )
      {
        if ( ++v32 == (_WORD *)v34 )
          goto LABEL_44;
      }
    }
  }
  v35 = v55;
  v36 = v55 + 1;
  v37 = v55[1];
  v38 = (v55[2] - v37) / 0x18;
  if ( v38 )
  {
    do
    {
      if ( *(_WORD *)(v37 + 0x18 * (v38 >> 1)) >= n0x800 )
      {
        v38 >>= 1;
      }
      else
      {
        v37 += 0x18 * (v38 >> 1) + 0x18;
        v38 += 0xFFFFFFFFFFFFFFFFuLL - (v38 >> 1);
      }
    }
    while ( v38 );
    v35 = v55;
  }
  if ( v37 != v55[2] && n0x800 < *(_WORD *)v37 )
    v37 = v55[2];
  if ( v37 != v35[2] && *(_QWORD *)(v37 + 8) )
    LogFatalError("Remapping Component Factories is not Supported!");
  v39 = allocWithProfilerInfo_w(0x50u);
  v40 = v56;
  v41 = v39;
  if ( v39 )
  {
    *(_DWORD *)(v39 + 8) = 1;
    *(_DWORD *)(v39 + 0xC) = 1;
    *(_QWORD *)v39 = off_148C1CE70;
    *(_QWORD *)(v39 + 0x18) = 0;
    *(_QWORD *)(v39 + 0x20) = 0;
    *(_QWORD *)(v39 + 0x10) = v40;
    *(_QWORD *)(v39 + 0x30) = 0;
    *(_QWORD *)(v39 + 0x38) = 0;
    sub_140360130((_DWORD *)(v39 + 0x40));
    v42 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v41 + 0x10) + 0x18LL))(*(_QWORD *)(v41 + 0x10));
    v43 = *(_QWORD *)(v41 + 0x10);
    *(_QWORD *)(v41 + 0x18) = v42;
    *(_QWORD *)(v41 + 0x20) = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v43 + 0x20LL))(v43);
  }
  else
  {
    v41 = 0;
  }
  v44 = (char *)v36[1];
  v45 = (char *)*v36;
  *(_QWORD *)&v48 = v41 + 0x10;
  *((_QWORD *)&v48 + 1) = v41;
  n0x800_3 = n0x800;
  v54 = v48;
  v46 = (v44 - v45) / 0x18;
  while ( v46 )
  {
    if ( *(_WORD *)&v45[0x18 * (v46 >> 1)] >= n0x800 )
    {
      v46 >>= 1;
    }
    else
    {
      v45 += 0x18 * (v46 >> 1) + 0x18;
      v46 += 0xFFFFFFFFFFFFFFFFuLL - (v46 >> 1);
    }
  }
  if ( v45 == v44 || n0x800 < *(_WORD *)v45 )
    sub_146A1A2E0(v36, &v55, (__int64)v45, (__int64)&n0x800_3);
  if ( *((_QWORD *)&v54 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v54 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      v47 = *((_QWORD *)&v54 + 1);
      (***((void (__fastcall ****)(_QWORD))&v54 + 1))(*((_QWORD *)&v54 + 1));
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v47 + 0xC), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v54 + 1) + 8LL))(*((_QWORD *)&v54 + 1));
    }
  }
  *(_QWORD *)(0x2E0LL * n0x800 + p_p_p_p_p_p_p_p_p_p_p_p_Source_8 + 0x4058) = v40;
  if ( (_QWORD)v51 )
    sub_1403A3120((__int64)&v51, (const void *)v51, (v52 - v51) & 0xFFFFFFFFFFFFFFF8uLL);
}

// --- End Function: sub_146A41530 (0x146A41530) ---

// --- Function: sub_146A42040 (0x146A42040) ---
void __fastcall sub_146A42040(__int64 a1, unsigned __int16 a2, const char *a3)
{
  __int64 v3; // rdi
  __int64 *v4; // rsi
  __int64 *v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rbx
  __int128 v8; // xmm0
  void *v10; // [rsp+28h] [rbp-30h] BYREF
  __int128 v11; // [rsp+30h] [rbp-28h] BYREF

  v3 = a1 + 0xF0;
  CreateStringObjectFromString(&v10, a3);
  v4 = *(__int64 **)v3;
  v5 = v4;
  DWORD2(v11) = 0;
  v6 = v4[1];
  *(_QWORD *)&v11 = v6;
  while ( !*(_BYTE *)(v6 + 0x19) )
  {
    *(_QWORD *)&v11 = v6;
    if ( *(_WORD *)(v6 + 0x20) >= a2 )
    {
      v5 = (__int64 *)v6;
      DWORD2(v11) = 1;
      v6 = *(_QWORD *)v6;
    }
    else
    {
      v6 = *(_QWORD *)(v6 + 0x10);
      DWORD2(v11) = 0;
    }
  }
  if ( *((_BYTE *)v5 + 0x19) || a2 < *((_WORD *)v5 + 0x10) )
  {
    if ( *(_QWORD *)(v3 + 8) == 0x555555555555555LL )
      unknown_libname_7();
    v7 = allocWithProfilerInfo_w(0x30u);
    *(_WORD *)(v7 + 0x20) = a2;
    sub_14035B140((_QWORD *)(v7 + 0x28), (__int64 *)&v10);
    v8 = v11;
    *(_QWORD *)v7 = v4;
    *(_QWORD *)(v7 + 8) = v4;
    *(_QWORD *)(v7 + 0x10) = v4;
    *(_WORD *)(v7 + 0x18) = 0;
    v11 = v8;
    std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
      (__int64 **)v3,
      (__int64)&v11,
      v7);
  }
  sub_140370D10(&v10);
}

// --- End Function: sub_146A42040 (0x146A42040) ---

// --- Function: sub_146A429B0 (0x146A429B0) ---
double __fastcall sub_146A429B0(__int64 a1, __int64 a2)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdi
  __int64 v4; // rax
  double result; // xmm0_8
  unsigned __int64 v6; // [rsp+38h] [rbp+10h] BYREF

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  if ( !*(_BYTE *)(a2 + 0x20) )
  {
    v6 = *(_QWORD *)(a2 + 8);
    if ( sub_14030EC00(&v6) && *(_BYTE *)((v6 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
    {
      v4 = *(unsigned __int16 *)(a2 + 0x10);
      *(_BYTE *)(a2 + 0x20) = 1;
      return sub_146A24990(
               p_p_p_p_p_p_p_p_p_p_p_p_Source,
               a2,
               *(_BYTE *)(**(_QWORD **)(p_p_p_p_p_p_p_p_p_p_p_p_Source
                                      + 0x2E0 * v4
                                      + 0x18LL * *(int *)(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0 * v4 + 0x4080)
                                      + 0x4168)
                        + 0x10LL),
               0);
    }
  }
  return result;
}

// --- End Function: sub_146A429B0 (0x146A429B0) ---

// --- Function: sub_146A42A40 (0x146A42A40) ---
double __fastcall sub_146A42A40(__int64 a1, __int64 a2, char a3)
{
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rsi
  __int64 v5; // rdi
  __int64 v7; // rax
  unsigned __int64 v8; // r8
  char v9; // dl
  char *v10; // r8
  char *v11; // rax
  double result; // xmm0_8
  char v13; // [rsp+48h] [rbp+10h] BYREF
  unsigned __int64 v14; // [rsp+58h] [rbp+20h] BYREF

  p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_8;
  v5 = 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v14 = *(_QWORD *)(a2 + 8);
  if ( sub_14030EC00(&v14) && *(_BYTE *)((v14 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
  {
    v13 = 1;
    v7 = *(_QWORD *)(a2 + 0x18);
    v8 = 3 * __popcnt(*(_QWORD *)(v5 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x42B8) & ((1LL << a3) - 1)) + 1;
    v9 = *(_BYTE *)(v7 + 4 * v8);
    v10 = (char *)(v7 + 4 * v8);
    v11 = &v13;
    if ( v9 )
      v11 = v10;
    *v10 = *v11;
    if ( !v9 )
      return sub_146A24990(p_p_p_p_p_p_p_p_p_p_p_p_Source, a2, a3, 0);
  }
  return result;
}

// --- End Function: sub_146A42A40 (0x146A42A40) ---

// --- Function: sub_146A42B00 (0x146A42B00) ---
__int64 sub_146A42B00()
{
  return sub_146A42B10(p_p_p_p_p_p_p_p_p_p_p_p_Source_8);
}

// --- End Function: sub_146A42B00 (0x146A42B00) ---

// --- Function: sub_146A42B10 (0x146A42B10) ---
char __fastcall sub_146A42B10(__int64 p_p_p_p_p_p_p_p_p_p_p_p_Source, __int64 a2, char a3, char a4)
{
  __int64 v6; // r15
  char result; // al
  __int64 v8; // r12
  int v9; // r14d
  bool v10; // bl
  char v11; // di
  unsigned __int64 v12; // rax
  _DWORD *v13; // r13
  unsigned __int64 v14; // rcx
  bool v15; // zf
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // rcx
  char v19; // r14
  __int64 v20; // rbx
  signed __int64 v21; // rbp
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rcx
  __int64 v24; // rcx
  unsigned __int64 v25; // [rsp+30h] [rbp-68h] BYREF
  __int64 v26; // [rsp+38h] [rbp-60h] BYREF
  int n0xF; // [rsp+40h] [rbp-58h]
  char v28; // [rsp+44h] [rbp-54h]
  char v29; // [rsp+45h] [rbp-53h]
  int v31; // [rsp+A8h] [rbp+10h]

  v6 = p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x2E0LL * *(unsigned __int16 *)(a2 + 0x10);
  v25 = *(_QWORD *)(a2 + 8);
  result = sub_14030EC00(&v25);
  if ( result )
  {
    result = v25;
    if ( (v25 & 0xFFFFFFFFFFFFLL) != 0 && *(_BYTE *)((v25 & 0xFFFFFFFFFFFFLL) + 0xD) < 5u )
    {
      v8 = (1LL << a3) - 1;
      v9 = *(_DWORD *)(0x20 * __popcnt(v8 & *(_QWORD *)(v6 + 0x42B8)) + *(_QWORD *)(v6 + 0x4150) + 0xC);
      v31 = v9;
      v10 = !sub_140539D80() && !*(_BYTE *)(NtCurrentTeb_w() + 0x12D);
      v11 = 0;
      v12 = v25;
      v13 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x920LL);
      if ( *v13 == v9 )
      {
        if ( !v25
          || ((v25 & 0xF000000000000000uLL) == 0 ? (v14 = (v25 & 0xFFFFFFFFFFFFLL) - 6) : (v14 = v25 & 0xFFFFFF000000LL),
              *(_WORD *)(v14 + 2) != (HIWORD(v25) & 0xFFF)
           || *(_WORD *)(v14 + 4) >= 3u
           && (v15 = !check_thread_state_and_value_not_equal((_QWORD *)(v25 & 0xFFFFFFFFFFFFLL)), v12 = v25, v15)
           || (v12 & 0xFFFFFFFFFFFFLL) == 0
           || ((v12 & 0xF000000000000000uLL) == 0
             ? (v16 = (v12 & 0xFFFFFFFFFFFFLL) - 6)
             : (v16 = v12 & 0xFFFFFF000000LL),
               *(_WORD *)(v16 + 4) != 1)) )
        {
          v11 = 1;
        }
      }
      if ( v10 )
      {
        if ( !v12 )
          goto LABEL_36;
        v17 = (v12 & 0xF000000000000000uLL) != 0 ? v12 & 0xFFFFFF000000LL : (v12 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v17 + 2) != (HIWORD(v12) & 0xFFF) )
          goto LABEL_36;
        if ( *(_WORD *)(v17 + 4) >= 3u )
        {
          if ( !check_thread_state_and_value_not_equal((_QWORD *)(v12 & 0xFFFFFFFFFFFFLL)) )
          {
LABEL_36:
            v11 = 1;
            goto LABEL_37;
          }
          v12 = v25;
        }
        if ( (v12 & 0xFFFFFFFFFFFFLL) == 0 )
          goto LABEL_36;
        v18 = (v12 & 0xF000000000000000uLL) != 0 ? v12 & 0xFFFFFF000000LL : (v12 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v18 + 4) != 1 )
          goto LABEL_36;
      }
LABEL_37:
      v19 = v11;
      if ( *v13 == 0x10 )
        v19 = 1;
      v20 = 0x478LL * v31 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1D0;
      if ( *(_DWORD *)(v20 + 0x10) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
      {
        ++*(_DWORD *)(v20 + 0x14);
      }
      else
      {
        v21 = _InterlockedIncrement64((volatile signed __int64 *)v20);
        if ( (v21 & 0x200000) != 0 )
          sub_1403CB300(
            v20,
            v21,
            "CEntityComponentUpdateScheduler::SetFrequencyForComponentUpdate",
            "m_perPassState[nPass].bIsRunningLock",
            1);
      }
      if ( *(_BYTE *)(0x478LL * v31 + p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x1C9) )
      {
        v22 = v25;
        if ( !v25 )
          goto LABEL_58;
        v23 = (v25 & 0xF000000000000000uLL) != 0 ? v25 & 0xFFFFFF000000LL : (v25 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v23 + 2) != (HIWORD(v25) & 0xFFF) )
          goto LABEL_58;
        if ( *(_WORD *)(v23 + 4) >= 3u )
        {
          if ( !check_thread_state_and_value_not_equal((_QWORD *)(v25 & 0xFFFFFFFFFFFFLL)) )
            goto LABEL_58;
          v22 = v25;
        }
        if ( (v22 & 0xFFFFFFFFFFFFLL) == 0 )
          goto LABEL_58;
        v24 = (v22 & 0xF000000000000000uLL) != 0 ? v22 & 0xFFFFFF000000LL : (v22 & 0xFFFFFFFFFFFFLL) - 6;
        if ( *(_WORD *)(v24 + 4) != 1 )
          goto LABEL_58;
      }
      if ( !v19 )
      {
        *(_BYTE *)(*(_QWORD *)(a2 + 0x18) + 0xC * __popcnt(*(_QWORD *)(v6 + 0x42B8) & v8) + 5) = a4;
        return sub_1402D2790(v20);
      }
LABEL_58:
      v28 = a3;
      v29 = a4;
      n0xF = 0xF;
      v26 = a2;
      _InterlockedIncrement16((volatile signed __int16 *)(a2 + 0x22));
      sub_1403CA640(p_p_p_p_p_p_p_p_p_p_p_p_Source + 0x140, &v26, 0x10u);
      return sub_1402D2790(v20);
    }
  }
  return result;
}

// --- End Function: sub_146A42B10 (0x146A42B10) ---

// --- Function: ?_Buy_raw@?$vector@FV?$allocator@F@std@@@std@@AEAAX_K@Z (0x146A493A0) ---
void __fastcall std::vector<short>::_Buy_raw(std::vector<short> *this, unsigned __int64 _Newcapacity)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rax

  if ( _Newcapacity > 0x7FFFFFFFFFFFFFFFLL )
    goto LABEL_11;
  v3 = 2 * _Newcapacity;
  if ( 2 * _Newcapacity < 0x1000 )
  {
    if ( v3 )
      v6 = allocWithProfilerInfo_w(2 * _Newcapacity);
    else
      v6 = 0;
    goto LABEL_10;
  }
  if ( v3 + 0x27 < v3 )
LABEL_11:
    sub_1402E1170();
  v4 = allocWithProfilerInfo_w(v3 + 0x27);
  v5 = v4;
  if ( !v4 )
    invalid_parameter_noinfo_noreturn();
  v6 = (v4 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v6 - 8) = v5;
LABEL_10:
  *(_QWORD *)this = v6;
  *((_QWORD *)this + 1) = v6;
  *((_QWORD *)this + 2) = v3 + v6;
}

// --- End Function: ?_Buy_raw@?$vector@FV?$allocator@F@std@@@std@@AEAAX_K@Z (0x146A493A0) ---

// --- Function: sub_146A49DC0 (0x146A49DC0) ---
__int64 __fastcall sub_146A49DC0(__int64 *a1, __int64 a2, unsigned __int16 *a3)
{
  __int64 v3; // r10
  _QWORD *v4; // r14
  __int64 v5; // rbx
  unsigned __int64 v7; // r9
  __int64 *v9; // r15
  __int64 v10; // rax
  char v11; // cl
  unsigned __int16 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // rax
  _QWORD *v19; // rdi
  __int64 v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rax
  __int16 v23; // ax
  _WORD *v24; // rcx
  __int64 result; // rax
  unsigned __int16 v26; // [rsp+28h] [rbp-30h] BYREF
  _QWORD v27[5]; // [rsp+30h] [rbp-28h] BYREF

  v3 = a1[1];
  v4 = a1 + 1;
  v5 = *a1;
  v7 = (v3 - *a1) >> 5;
  v9 = a1 + 1;
  if ( v7 )
  {
    do
    {
      v10 = 0x20 * (v7 >> 1);
      if ( *(_WORD *)(v10 + v5) >= *a3 )
      {
        v7 >>= 1;
      }
      else
      {
        v5 += v10 + 0x20;
        v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
      }
    }
    while ( v7 );
    v9 = a1 + 1;
  }
  v11 = 0;
  if ( v5 == v3 || *a3 < *(_WORD *)v5 )
  {
    if ( v3 == a1[2] )
    {
      v5 = sub_146A12B50(a1, v5);
    }
    else
    {
      v12 = *a3;
      if ( v5 == v3 )
      {
        *(_WORD *)v3 = v12;
        v13 = *((_QWORD *)a3 + 1);
        v14 = *((_QWORD *)a3 + 2);
        v15 = *((_QWORD *)a3 + 3);
        *((_QWORD *)a3 + 3) = 0;
        *((_QWORD *)a3 + 2) = 0;
        *((_QWORD *)a3 + 1) = 0;
        *(_QWORD *)(v3 + 8) = v13;
        *(_QWORD *)(v3 + 0x10) = v14;
        *(_QWORD *)(v3 + 0x18) = v15;
        *v4 += 0x20LL;
      }
      else
      {
        v16 = *((_QWORD *)a3 + 3);
        v17 = *((_QWORD *)a3 + 2);
        v27[0] = *((_QWORD *)a3 + 1);
        *((_QWORD *)a3 + 3) = 0;
        *((_QWORD *)a3 + 2) = 0;
        *((_QWORD *)a3 + 1) = 0;
        *(_WORD *)v3 = *(_WORD *)(v3 - 0x20);
        v18 = *(_QWORD *)(v3 - 0x18);
        *(_QWORD *)(v3 - 0x18) = 0;
        v19 = (_QWORD *)(v3 - 0x20);
        v27[1] = v17;
        v20 = *(_QWORD *)(v3 - 0x10);
        v19[2] = 0;
        v27[2] = v16;
        v21 = *(_QWORD *)(v3 - 8);
        v19[3] = 0;
        *(_QWORD *)(v3 + 8) = v18;
        *(_QWORD *)(v3 + 0x10) = v20;
        *(_QWORD *)(v3 + 0x18) = v21;
        v22 = *v4 + 0x20LL;
        v26 = v12;
        *v9 = v22;
        if ( v3 - 0x20 != v5 )
        {
          do
          {
            v23 = *((_WORD *)v19 + 0xFFFFFFF0);
            v24 = v19;
            v19 += 0xFFFFFFFC;
            *v24 = v23;
            sub_140378B00(v19 + 5, v19 + 1);
          }
          while ( v19 != (_QWORD *)v5 );
          v12 = v26;
        }
        *(_WORD *)v5 = v12;
        sub_140378B00((_QWORD *)(v5 + 8), v27);
        sub_141FE11E0(&v26);
      }
    }
    v11 = 1;
  }
  result = a2;
  *(_QWORD *)a2 = v5;
  *(_BYTE *)(a2 + 8) = v11;
  return result;
}

// --- End Function: sub_146A49DC0 (0x146A49DC0) ---

// --- Function: sub_146A4A420 (0x146A4A420) ---
bool __fastcall sub_146A4A420(volatile signed __int64 *a1, _OWORD *a2, unsigned __int64 *a3)
{
  signed __int64 v3; // rax
  unsigned int v7; // rcx^4
  signed __int64 v8; // rtt
  unsigned __int64 v9; // rbx
  signed __int64 v10; // rtt
  __int64 v11; // rbp
  unsigned __int64 v12; // rdi
  __int64 v13; // r15
  unsigned __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // r14
  _OWORD *v17; // rdx
  __int64 v18; // r8
  unsigned __int64 v19; // rcx
  signed __int64 i; // rax
  int v22; // [rsp+50h] [rbp+8h] BYREF

  v3 = *a1;
  do
  {
    while ( (v3 & 0x4000000000000000LL) != 0 )
    {
      if ( v3 < 0 )
        goto LABEL_6;
      v7 = HIDWORD(v3) | 0x80000000;
      v8 = v3;
      v3 = _InterlockedCompareExchange64(a1, v3 | 0x8000000000000000uLL, v3);
      if ( v8 == v3 )
      {
        HIDWORD(v3) = v7;
LABEL_6:
        v22 = HIDWORD(v3);
        qword_149B3B480((char *)a1 + 4, &v22, 4, 0xFFFFFFFFLL);
        v3 = *a1;
      }
    }
    v9 = v3 | 0x4000000000000000LL;
    v10 = v3;
    v3 = _InterlockedCompareExchange64(a1, v3 | 0x4000000000000000LL, v3);
  }
  while ( v10 != v3 );
  v11 = HIWORD(v9) & 0x1FFF;
  v12 = v9 & 0x3FFFFFFFFFFFFFFFLL;
  v13 = v9 & 0xFFFFFFFFFFFFLL;
  v14 = (v11 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
  if ( v11 == v14 )
  {
    v15 = allocWithProfilerInfo(0x10 * (v14 + 4), (struct _exception *)8);
    v16 = v15;
    if ( v11 )
    {
      v17 = (_OWORD *)v15;
      v18 = HIWORD(v9) & 0x1FFF;
      do
      {
        *v17 = *(_OWORD *)((char *)v17 + v13 - v15);
        ++v17;
        --v18;
      }
      while ( v18 );
    }
    sub_147605980((const void *)(v9 & 0xFFFFFFFFFFFFLL));
    v13 = v16;
    v12 = v16 ^ (v16 ^ v12) & 0xFFFF000000000000uLL;
  }
  *(_OWORD *)(v13 + 0x10 * v11) = *a2;
  v19 = (v12 + 0x1000000000000LL) ^ (v12 ^ (v12 + 0x1000000000000LL)) & 0xE000FFFFFFFFFFFFuLL | 0x2000000000000000LL;
  for ( i = _InterlockedCompareExchange64(a1, v19, v9); i != v9; i = _InterlockedCompareExchange64(a1, v19, i) )
    v9 = i;
  if ( (v9 & 0x8000000000000000uLL) != 0LL )
    qword_149B3B490((char *)a1 + 4);
  if ( a3 )
    *a3 = HIWORD(v9) & 0x1FFF;
  return (v9 & 0x1FFF000000000000LL) == 0;
}

// --- End Function: sub_146A4A420 (0x146A4A420) ---

// --- Function: sub_146A4A620 (0x146A4A620) ---
bool __fastcall sub_146A4A620(volatile signed __int64 *a1, unsigned __int64 *p_p_sub_146A26220, unsigned __int64 *a3)
{
  signed __int64 v3; // rax
  unsigned int v7; // rcx^4
  signed __int64 v8; // rtt
  unsigned __int64 v9; // rbx
  signed __int64 v10; // rtt
  __int64 v11; // rbp
  unsigned __int64 v12; // rdi
  __int64 v13; // r14
  unsigned __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // r15
  _QWORD *v17; // r8
  __int64 v18; // r9
  unsigned __int64 v19; // rcx
  signed __int64 i; // rax
  int v22; // [rsp+50h] [rbp+8h] BYREF

  v3 = *a1;
  do
  {
    while ( (v3 & 0x4000000000000000LL) != 0 )
    {
      if ( v3 < 0 )
        goto LABEL_6;
      v7 = HIDWORD(v3) | 0x80000000;
      v8 = v3;
      v3 = _InterlockedCompareExchange64(a1, v3 | 0x8000000000000000uLL, v3);
      if ( v8 == v3 )
      {
        HIDWORD(v3) = v7;
LABEL_6:
        v22 = HIDWORD(v3);
        qword_149B3B480((char *)a1 + 4, &v22, 4, 0xFFFFFFFFLL);
        v3 = *a1;
      }
    }
    v9 = v3 | 0x4000000000000000LL;
    v10 = v3;
    v3 = _InterlockedCompareExchange64(a1, v3 | 0x4000000000000000LL, v3);
  }
  while ( v10 != v3 );
  v11 = HIWORD(v9) & 0x1FFF;
  v12 = v9 & 0x3FFFFFFFFFFFFFFFLL;
  v13 = v9 & 0xFFFFFFFFFFFFLL;
  v14 = (v11 + 3) & 0xFFFFFFFFFFFFFFFCuLL;
  if ( v11 == v14 )
  {
    v15 = allocWithProfilerInfo(8 * v14 + 0x20, (struct _exception *)8);
    v16 = v15;
    if ( v11 )
    {
      v17 = (_QWORD *)(v9 & 0xFFFFFFFFFFFFLL);
      v18 = HIWORD(v9) & 0x1FFF;
      do
      {
        *(_QWORD *)((char *)v17 + v15 - v13) = *v17;
        *v17++ = 0;
        --v18;
      }
      while ( v18 );
    }
    sub_147605980((const void *)(v9 & 0xFFFFFFFFFFFFLL));
    v13 = v16;
    v12 = v16 ^ (v16 ^ v12) & 0xFFFF000000000000uLL;
  }
  *(_QWORD *)(v13 + 8 * v11) = *p_p_sub_146A26220;
  v19 = (v12 + 0x1000000000000LL) ^ (v12 ^ (v12 + 0x1000000000000LL)) & 0xE000FFFFFFFFFFFFuLL | 0x2000000000000000LL;
  for ( i = _InterlockedCompareExchange64(a1, v19, v9); i != v9; i = _InterlockedCompareExchange64(a1, v19, i) )
    v9 = i;
  if ( (v9 & 0x8000000000000000uLL) != 0LL )
    qword_149B3B490((char *)a1 + 4);
  if ( a3 )
    *a3 = HIWORD(v9) & 0x1FFF;
  return (v9 & 0x1FFF000000000000LL) == 0;
}

// --- End Function: sub_146A4A620 (0x146A4A620) ---

// --- Function: sub_146A4A820 (0x146A4A820) ---
unsigned __int64 __fastcall sub_146A4A820(__int64 a1, unsigned __int64 a2)
{
  const void *v3; // rcx
  unsigned __int64 result; // rax
  __int64 v5; // r14
  __int64 v6; // rsi
  char *v7; // rdi

  v3 = *(const void **)a1;
  result = (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v3) >> 1;
  if ( a2 > result )
  {
    if ( a2 > 0x7FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = 2 * a2;
    v6 = (__int64)(*(_QWORD *)(a1 + 8) - (_QWORD)v3) >> 1;
    v7 = (char *)sub_140391AB0(a1, 2 * a2);
    memmove(v7, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    if ( *(_QWORD *)a1 )
      sub_1403A3120(a1, *(const void **)a1, 2 * ((__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 1));
    *(_QWORD *)a1 = v7;
    *(_QWORD *)(a1 + 8) = &v7[2 * v6];
    result = (unsigned __int64)&v7[v5];
    *(_QWORD *)(a1 + 0x10) = &v7[v5];
  }
  return result;
}

// --- End Function: sub_146A4A820 (0x146A4A820) ---

// --- Function: sub_146B49880 (0x146B49880) ---
__int64 __fastcall sub_146B49880(__int64 a1, _QWORD *a2)
{
  return *(_QWORD *)(a1 + 0x120) + 0xC0LL * *(unsigned int *)((*a2 & 0xFFFFFFFFFFFFLL) + 0x2F0);
}

// --- End Function: sub_146B49880 (0x146B49880) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0xE58LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_147603760 (0x147603760) ---
unsigned __int64 __fastcall sub_147603760(__int64 a1, size_t Size, unsigned __int64 n0x10)
{
  return sub_147603780(a1, Size, n0x10);
}

// --- End Function: sub_147603760 (0x147603760) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n0x6900; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n0x6900 = 0x6900;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n0x6900,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    0xA7);
  HIWORD(n0x6900) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n0x6900);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: sub_147605AA0 (0x147605AA0) ---
unsigned __int64 __fastcall sub_147605AA0(void *a1, unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  unsigned __int64 result; // rax
  char v7; // al
  __int64 v8; // rax

  if ( !a1 )
    return allocWithProfilerInfo(allocSize, profilerInfo);
  if ( !allocSize )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
      return 0;
    }
    return 0;
  }
  if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (void *)qword_149B4FBE8 )
    __debugbreak();
  if ( (unsigned __int64)a1 >= qword_149B00898 && (unsigned __int64)a1 < qword_149B00898 + 0x8000000000LL )
    LogFatalError("Address %p was allocated by streaming malloc and cannot be reallocated!", a1);
  if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
    LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
  v7 = sub_1474DA7B0();
  sub_14056A7D0(v7);
  v8 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
  result = sub_147603760((__int64)a1, v8 + allocSize, (unsigned __int64)profilerInfo);
  if ( !result )
  {
    sub_1476052F0(allocSize);
    return 0;
  }
  return result;
}

// --- End Function: sub_147605AA0 (0x147605AA0) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: ?_Xout_of_range@std@@YAXPEBD@Z (0x148032794) ---
// attributes: thunk
void __fastcall std::_Xout_of_range(const char *a1)
{
  __imp_?_Xout_of_range@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xout_of_range@std@@YAXPEBD@Z (0x148032794) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

