// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x140C02FC0 (initializeEpicOnlineServices)
// Caller Depth: 1
// Callee/Ref Depth: 4
// Total Functions Found: 85
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A1370) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0LL;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A1370) ---

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: sub_1402A1E30 (0x1402A1E30) ---
__int64 __fastcall sub_1402A1E30(unsigned __int64 n0x6400000)
{
  return sub_14739AFC0(n0x6400000, 0LL);
}

// --- End Function: sub_1402A1E30 (0x1402A1E30) ---

// --- Function: sub_1402A2470 (0x1402A2470) ---
void *sub_1402A2470()
{
  return &unk_149808280;
}

// --- End Function: sub_1402A2470 (0x1402A2470) ---

// --- Function: sub_1402A47D0 (0x1402A47D0) ---
char *__fastcall sub_1402A47D0(__int64 *a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 n0x6400000; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t Size; // r8
  _BYTE *v20; // rcx
  char *result; // rax

  v3 = (__int64)&a2[-*a1] >> 3;
  v5 = (a1[1] - *a1) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = (a1[2] - *a1) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
  {
    goto LABEL_24;
  }
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
  {
    v11 = v10 + v8;
  }
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
  {
    goto LABEL_24;
  }
  n0x6400000 = 8 * v11;
  if ( n0x6400000 < 0x1000 )
  {
    if ( n0x6400000 )
    {
      v14 = (_QWORD *)sub_1402A1E30(n0x6400000);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_13;
  }
  if ( n0x6400000 + 39 < n0x6400000 )
  {
LABEL_24:
    sub_1402DEE40();
  }
  v13 = sub_1402A1E30(n0x6400000 + 39);
  if ( !v13 )
  {
    goto LABEL_22;
  }
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *a3;
  v16 = v14;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    Size = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v16 = v15 + 1;
    Size = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v16, v18, Size);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      free_memory_wrapper(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)&v20[-*((_QWORD *)v20 - 1) - 8] <= 0x1F )
    {
      v20 = (_BYTE *)*((_QWORD *)v20 - 1);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *a1 = (__int64)v14;
  result = (char *)&v14[v3];
  a1[1] = (__int64)&v14[v9];
  a1[2] = (__int64)&v14[n0x6400000 / 8];
  return result;
}

// --- End Function: sub_1402A47D0 (0x1402A47D0) ---

// --- Function: sub_1402A78B0 (0x1402A78B0) ---
const void **__fastcall sub_1402A78B0(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 n0x6400000; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
  {
    unknown_libname_9();
  }
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    n0x6400000 = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
    {
      v6 = v12 + n0xF;
    }
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
      {
        v15 = 0;
      }
      else
      {
        v15 = (_QWORD *)sub_1402A1E30(v6 + 1);
      }
      goto LABEL_15;
    }
    n0x6400000 = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
    {
      sub_1402DEE40();
    }
  }
  v14 = sub_1402A1E30(n0x6400000);
  if ( !v14 )
  {
    goto LABEL_20;
  }
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  free_memory_wrapper(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A78B0 (0x1402A78B0) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 NtCurrentTeb_wrp()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: sub_1402DEE40 (0x1402DEE40) ---
void __noreturn sub_1402DEE40()
{
  const struct stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (const struct stdext::exception *)sub_1402AF650(v1);
  sub_1402DEC20(v0);
}

// --- End Function: sub_1402DEE40 (0x1402DEE40) ---

// --- Function: unknown_libname_9 (0x1402DFC40) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402DFC40) ---

// --- Function: unknown_libname_10 (0x1402DFC60) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402DFC60) ---

// --- Function: sub_1402F5120 (0x1402F5120) ---
int sub_1402F5120(FILE *Stream, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A2470();
  return _stdio_common_vfprintf(*v4, Stream, Format, 0LL, va);
}

// --- End Function: sub_1402F5120 (0x1402F5120) ---

// --- Function: sub_1402F8E30 (0x1402F8E30) ---
void *__fastcall sub_1402F8E30(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 n0x6400000; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
  {
    unknown_libname_9();
  }
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    n0x6400000 = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_1402A1E30(n0x6400000);
    if ( !v9 )
    {
      invalid_parameter_noinfo_noreturn();
    }
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
  {
    n22 = 22;
  }
  if ( n22 + 1 >= 0x1000 )
  {
    n0x6400000 = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
    {
      sub_1402DEE40();
    }
    goto LABEL_6;
  }
  if ( n22 == -1 )
  {
    v10 = 0;
  }
  else
  {
    v10 = (_QWORD *)sub_1402A1E30(n22 + 1);
  }
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402F8E30 (0x1402F8E30) ---

// --- Function: sub_1402FB040 (0x1402FB040) ---
__int64 __fastcall sub_1402FB040(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  if ( a4 < a5 )
  {
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(a3 + 104 * a4 + 24))(
             *(_QWORD *)(a3 + 104 * a4),
             a1,
             a2,
             a4 - a5 + 1);
  }
  else
  {
    return 0LL;
  }
}

// --- End Function: sub_1402FB040 (0x1402FB040) ---

// --- Function: sub_1402FB080 (0x1402FB080) ---
__int64 __fastcall sub_1402FB080(int a1, int a2, int a3, __int64 a4, __int64 a5)
{
  char v6; // [rsp+40h] [rbp-18h] BYREF

  return sub_1402FD3D0((unsigned int)&v6, a1, a2, a3, a4, a5);
}

// --- End Function: sub_1402FB080 (0x1402FB080) ---

// --- Function: sub_1402FB540 (0x1402FB540) ---
__int64 **__fastcall sub_1402FB540(__int64 **p_i_8a, __int64 *i, unsigned __int64 a3)
{
  __int64 *i_1; // rcx
  __int64 *i_3; // rbx
  __int64 n40; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 *i_2; // rbp
  __int64 v13; // rdx
  __int64 v14; // r8
  __int64 *v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // r9
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rdx
  __int64 *i_4; // r9
  __int64 v26; // rsi
  __int64 v27; // rdi
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r10
  __int64 v30; // rax
  bool v31; // zf
  __int64 *v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rsi
  unsigned __int64 v35; // rdi
  unsigned __int64 v36; // r11
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 **p_i_8a_1; // rax

  i_1 = i;
  i_3 = &i[(__int64)(a3 - (_QWORD)i) >> 4];
  n40 = (__int64)(a3 - 8 - (_QWORD)i) >> 3;
  if ( n40 <= 40 )
  {
    v14 = a3 - 8;
  }
  else
  {
    v9 = (n40 + 1) >> 3;
    v10 = 16 * v9;
    v11 = 8 * v9;
    i_2 = &i[v9];
    sub_1402FB4C0(i, i_2, &i[2 * v9]);
    sub_1402FB4C0(&i_3[v11 / 0xFFFFFFFFFFFFFFF8uLL], i_3, &i_3[(unsigned __int64)v11 / 8]);
    sub_1402FB4C0((__int64 *)(a3 - 8 - v10), (__int64 *)(a3 - 8 - v11), a3 - 8);
    v14 = v13;
    i_1 = i_2;
  }
  sub_1402FB4C0(i_1, i_3, v14);
  v15 = i_3 + 1;
  if ( i < i_3 )
  {
    v16 = *i_3;
    do
    {
      v17 = *(i_3 - 1);
      v18 = *(_QWORD *)(v16 + 8);
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 < v18 || v19 == v18 && *(_QWORD *)(v17 + 80) < *(_QWORD *)(v16 + 80) )
      {
        break;
      }
      if ( v18 < v19 || v18 == v19 && *(_QWORD *)(v16 + 80) < *(_QWORD *)(v17 + 80) )
      {
        break;
      }
      --i_3;
      v16 = v17;
    }
    while ( i < i_3 );
  }
  if ( (unsigned __int64)v15 < a3 )
  {
    v20 = *i_3;
    v21 = *(_QWORD *)(*i_3 + 8);
    do
    {
      v22 = *v15;
      v23 = *(_QWORD *)(*v15 + 8);
      if ( v23 < v21 || v23 == v21 && *(_QWORD *)(v22 + 80) < *(_QWORD *)(v20 + 80) )
      {
        break;
      }
      if ( v21 < v23 || v21 == v23 && *(_QWORD *)(v20 + 80) < *(_QWORD *)(v22 + 80) )
      {
        break;
      }
      ++v15;
    }
    while ( (unsigned __int64)v15 < a3 );
  }
  v24 = (unsigned __int64)v15;
  i_4 = i_3;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( v24 < a3 )
      {
        v26 = *(_QWORD *)v24;
        v27 = *i_3;
        v28 = *(_QWORD *)(*(_QWORD *)v24 + 8LL);
        v29 = *(_QWORD *)(*i_3 + 8);
        if ( v29 >= v28 && (v29 != v28 || *(_QWORD *)(v27 + 80) >= *(_QWORD *)(v26 + 80)) )
        {
          if ( v28 < v29 || v28 == v29 && *(_QWORD *)(v26 + 80) < *(_QWORD *)(v27 + 80) )
          {
            break;
          }
          if ( v15 != (__int64 *)v24 )
          {
            v30 = *v15;
            *v15 = v26;
            *(_QWORD *)v24 = v30;
          }
          ++v15;
        }
        v24 += 8LL;
      }
      v31 = i_4 == i;
      if ( i_4 <= i )
      {
        goto LABEL_46;
      }
      v32 = i_4 - 1;
      while ( 1 )
      {
        v33 = *i_3;
        v34 = *v32;
        v35 = *(_QWORD *)(*i_3 + 8);
        v36 = *(_QWORD *)(*v32 + 8);
        if ( v36 >= v35 && (v36 != v35 || *(_QWORD *)(v34 + 80) >= *(_QWORD *)(v33 + 80)) )
        {
          break;
        }
LABEL_44:
        --i_4;
        --v32;
        if ( i >= i_4 )
        {
          goto LABEL_45;
        }
      }
      if ( v35 >= v36 && (v35 != v36 || *(_QWORD *)(v33 + 80) >= *(_QWORD *)(v34 + 80)) )
      {
        if ( --i_3 != v32 )
        {
          v37 = *i_3;
          *i_3 = v34;
          *v32 = v37;
        }
        goto LABEL_44;
      }
LABEL_45:
      v31 = i_4 == i;
LABEL_46:
      if ( !v31 )
      {
        --i_4;
        if ( v24 == a3 )
        {
          if ( i_4 != --i_3 )
          {
            v40 = *i_4;
            *i_4 = *i_3;
            *i_3 = v40;
          }
          v41 = *--v15;
          v42 = *i_3;
          *i_3 = v41;
          *v15 = v42;
        }
        else
        {
          v43 = *(_QWORD *)v24;
          *(_QWORD *)v24 = *i_4;
          v24 += 8LL;
          *i_4 = v43;
        }
        continue;
      }
      break;
    }
    if ( v24 != a3 )
    {
      if ( v15 != (__int64 *)v24 )
      {
        v38 = *i_3;
        *i_3 = *v15;
        *v15 = v38;
      }
      ++v15;
      v39 = *i_3;
      *i_3++ = *(_QWORD *)v24;
      *(_QWORD *)v24 = v39;
      v24 += 8LL;
      continue;
    }
    break;
  }
  p_i_8a_1 = p_i_8a;
  *p_i_8a = i_3;
  p_i_8a[1] = v15;
  return p_i_8a_1;
}

// --- End Function: sub_1402FB540 (0x1402FB540) ---

// --- Function: sub_1402FB800 (0x1402FB800) ---
unsigned __int64 __fastcall sub_1402FB800(__int64 i, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rdi
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r11
  __int64 v11; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 n2; // rax
  unsigned __int64 v15; // r11
  __int64 v16; // rcx
  __int64 v17; // r8
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v10 = 2 * v9;
      v11 = *(_QWORD *)(i + 16 * v9 + 16);
      v12 = *(_QWORD *)(i + 16 * v9 + 8);
      v13 = *(_QWORD *)(v11 + 8);
      if ( v13 < *(_QWORD *)(v12 + 8) || v13 == *(_QWORD *)(v12 + 8) && *(_QWORD *)(v11 + 80) < *(_QWORD *)(v12 + 80) )
      {
        n2 = 1;
      }
      else
      {
        n2 = 2;
      }
      v9 = v10 + n2;
      *(_QWORD *)(i + 8 * a2) = *(_QWORD *)(i + 8 * (v10 + n2));
      a2 = v10 + n2;
    }
    while ( v10 + n2 < v5 );
  }
  if ( v9 == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(i + 8 * a2) = *(_QWORD *)(i + 8 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v8 >= a2 )
  {
    result = *a4;
    *(_QWORD *)(i + 8 * a2) = *a4;
  }
  else
  {
    while ( 1 )
    {
      v15 = *a4;
      v16 = (a2 - 1) >> 1;
      v17 = *(_QWORD *)(i + 8 * v16);
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(*a4 + 8) )
      {
        if ( result != *(_QWORD *)(*a4 + 8) )
        {
          break;
        }
        result = *(_QWORD *)(v15 + 80);
        if ( *(_QWORD *)(v17 + 80) >= result )
        {
          break;
        }
      }
      *(_QWORD *)(i + 8 * a2) = v17;
      a2 = (a2 - 1) >> 1;
      if ( v8 >= v16 )
      {
        result = *a4;
        *(_QWORD *)(i + 8 * v16) = *a4;
        return result;
      }
    }
    *(_QWORD *)(i + 8 * a2) = v15;
  }
  return result;
}

// --- End Function: sub_1402FB800 (0x1402FB800) ---

// --- Function: sub_1402FB8F0 (0x1402FB8F0) ---
unsigned __int64 __fastcall sub_1402FB8F0(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 n0x6400000; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4EC4EC4EC4EC4EC5LL) >> 64) >> 63;
  v7 = ((__int64)v2 - *a1) / 104;
  if ( a2 < v7 )
  {
    v8 = v4 + 104 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 104 )
    {
      if ( *(_BYTE *)(i + 88) )
      {
        if ( *(_QWORD *)i )
        {
          result = (*(__int64 (**)(void))(i + 64))();
        }
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
  {
    return result;
  }
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4EC4EC4EC4EC4EC5LL) >> 64) >> 63;
  v11 = v10 / 104;
  if ( a2 > v10 / 104 )
  {
    if ( a2 > 0x276276276276276LL )
    {
      unknown_libname_10();
    }
    v12 = v11 >> 1;
    if ( v11 <= 0x276276276276276LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x276276276276276LL )
        {
          goto LABEL_29;
        }
      }
      else
      {
        v13 = a2;
      }
      n0x6400000 = 104 * v13;
      if ( 104 * v13 < 0x1000 )
      {
        if ( n0x6400000 )
        {
          v16 = sub_1402A1E30(n0x6400000);
        }
        else
        {
          v16 = 0;
        }
LABEL_23:
        v17 = (_QWORD *)(v16 + 104 * v7);
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 13;
            --v18;
          }
          while ( v18 );
        }
        sub_1402FBFF0(*a1, a1[1], v16, a1);
        return sub_1402FD840(a1, v16, a2, v13);
      }
      if ( n0x6400000 + 39 >= n0x6400000 )
      {
        v15 = sub_1402A1E30(n0x6400000 + 39);
        if ( !v15 )
        {
          invalid_parameter_noinfo_noreturn();
        }
        v16 = (v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
        *(_QWORD *)(v16 - 8) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402DEE40();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 13;
  }
  a1[1] = v2;
  return result;
}

// --- End Function: sub_1402FB8F0 (0x1402FB8F0) ---

// --- Function: sub_1402FBC20 (0x1402FBC20) ---
__int64 __fastcall sub_1402FBC20(char *i, char *i_8, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  char *i_1; // r15
  __int64 i_2; // rdi
  char *i_8a_1; // r14
  char *ia_1; // rbp
  char *i_3; // rsi
  size_t n8; // r14
  char *i_4; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i_5; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  char *i_8a; // [rsp+30h] [rbp-38h] BYREF
  char *ia; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (i_8 - i) & 0xFFFFFFFFFFFFFFF8uLL;
  i_1 = i_8;
  i_2 = (__int64)i;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( (char *)i_2 != i_1 )
    {
      i_3 = (char *)(i_2 + 8);
      if ( (char *)(i_2 + 8) != i_1 )
      {
        n8 = 8;
        do
        {
          i_4 = i_3;
          v14 = *(_QWORD *)i_3;
          v15 = *(_QWORD *)(*(_QWORD *)i_2 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)i_3 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)i_3 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)i_2 + 80LL) )
          {
            n256 = (__int64)memmove((void *)(i_2 + 8), (const void *)i_2, n8);
            *(_QWORD *)i_2 = v14;
          }
          else
          {
            for ( i_5 = i_3; ; i_4 = i_5 )
            {
              v17 = *((_QWORD *)i_5 - 1);
              i_5 -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                {
                  break;
                }
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                {
                  break;
                }
              }
              *(_QWORD *)i_4 = v17;
            }
            *(_QWORD *)i_4 = v14;
          }
          i_3 += 8;
          n8 += 8LL;
        }
        while ( i_3 != i_1 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FB540((__int64 **)&i_8a, (__int64 *)i_2, (unsigned __int64)i_1);
      i_8a_1 = i_8a;
      ia_1 = ia;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)((unsigned __int64)&i_8a[-i_2] & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((i_1 - ia)
                                                                                       & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FBC20(ia, i_1, a3, a4);
        i_1 = i_8a_1;
      }
      else
      {
        sub_1402FBC20((char *)i_2, i_8a, a3, a4);
        i_2 = (__int64)ia_1;
      }
      n256 = (unsigned __int64)&i_1[-i_2] & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
      {
        goto LABEL_7;
      }
    }
    v18 = (__int64)&i_1[-i_2] >> 3;
    v19 = (__int64)&i_1[-i_2] >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)(i_2 + 8 * v19-- - 8);
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)(i_2 + 8 * j);
          v25 = *(_QWORD *)(i_2 + 8 * j - 8);
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)(i_2 + 8 * v22) = *(_QWORD *)(i_2 + 8 * j);
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)(i_2 + 8 * v22) = *(_QWORD *)(i_2 + 8 * v18 - 8);
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)(i_2 + 8 * v27);
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)(i_2 + 8 * v22) = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)(i_2 + 8 * v22) = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (unsigned __int64)&i_1[-i_2] & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(i_1 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)i_2;
        sub_1402FB800(i_2, 0, ((__int64)v30-- - i_2) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8 - i_2) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FBC20 (0x1402FBC20) ---

// --- Function: sub_1402FC400 (0x1402FC400) ---
__int64 __fastcall sub_1402FC400(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0LL;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
    {
      return 0xFFFFFFFFLL;
    }
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAuLL;
    *(_BYTE *)(v6 + v5) = v9 + 48;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_1402FC400 (0x1402FC400) ---

// --- Function: sub_1402FC4C0 (0x1402FC4C0) ---
__int64 __fastcall sub_1402FC4C0(
        __int64 Buffer,
        size_t Size,
        __int64 a3,
        const void **a4,
        const void **a5,
        __int64 a6,
        __int64 ])
{
  _BYTE *v7; // rdi
  size_t Size_1; // rbx
  void *v12; // rcx
  size_t Size_2; // rsi
  size_t Size_3; // rdi
  __int64 v15; // r14
  _BYTE *v16; // rsi
  void *v17; // rcx
  size_t Size_4; // rbp
  int v19; // eax
  int v20; // ecx
  __int64 result; // rax

  v7 = *a4;
  Size_1 = -1;
  do
  {
    ++Size_1;
  }
  while ( v7[Size_1] );
  if ( Size_1 + a3 >= Size )
  {
    return 0xFFFFFFFFLL;
  }
  v12 = (void *)(a3 + Buffer);
  Size_2 = Size - a3;
  if ( Size_1 )
  {
    if ( !v12 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v7 && Size_2 >= Size_1 )
    {
      memcpy(v12, *a4, Size_1);
    }
    else
    {
      memset(v12, 0, Size - a3);
      if ( !v7 )
      {
        goto LABEL_6;
      }
      if ( Size_2 < Size_1 )
      {
        *errno() = 34;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size_1 & 0x80000000) != 0LL )
  {
    return 0xFFFFFFFFLL;
  }
  Size_3 = -1;
  v15 = a3 + (int)Size_1;
  v16 = *a5;
  do
  {
    ++Size_3;
  }
  while ( v16[Size_3] );
  if ( Size_3 + v15 >= Size )
  {
    return 0xFFFFFFFFLL;
  }
  v17 = (void *)(v15 + Buffer);
  Size_4 = Size - v15;
  if ( !Size_3 )
  {
    goto LABEL_28;
  }
  if ( !v17 )
  {
    goto LABEL_20;
  }
  if ( v16 && Size_4 >= Size_3 )
  {
    memcpy(v17, *a5, Size_3);
  }
  else
  {
    memset(v17, 0, Size - v15);
    if ( !v16 )
    {
LABEL_20:
      *errno() = 22;
LABEL_27:
      invalid_parameter_noinfo();
      goto LABEL_28;
    }
    if ( Size_4 < Size_3 )
    {
      *errno() = 34;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( (Size_3 & 0x80000000) != 0LL )
  {
    return 0xFFFFFFFFLL;
  }
  v19 = sub_1402FC670(Buffer, Size, v15 + (int)Size_3, (const void **)a6, (_BYTE *)]);
  if ( v19 < 0 )
  {
    return 0xFFFFFFFFLL;
  }
  v20 = Size_3 + v19;
  result = (unsigned int)(Size_1 + Size_3 + v19);
  if ( v20 < 0 )
  {
    return 0xFFFFFFFFLL;
  }
  return result;
}

// --- End Function: sub_1402FC4C0 (0x1402FC4C0) ---

// --- Function: sub_1402FC670 (0x1402FC670) ---
__int64 __fastcall sub_1402FC670(__int64 Buffer, unsigned __int64 n0xF, __int64 a3, const void **a4, _BYTE *__)
{
  _BYTE *v5; // rsi
  size_t Size; // rbx
  void *v10; // rcx
  size_t Size_1; // rbp
  __int64 v12; // rcx
  size_t Size_2; // rdi
  _BYTE *v14; // rcx

  v5 = *a4;
  Size = -1;
  do
  {
    ++Size;
  }
  while ( v5[Size] );
  if ( Size + a3 >= n0xF )
  {
    return 0xFFFFFFFFLL;
  }
  v10 = (void *)(a3 + Buffer);
  Size_1 = n0xF - a3;
  if ( !Size )
  {
    goto LABEL_14;
  }
  if ( !v10 )
  {
    goto LABEL_6;
  }
  if ( v5 && Size_1 >= Size )
  {
    memcpy(v10, v5, Size);
  }
  else
  {
    memset(v10, 0, n0xF - a3);
    if ( !v5 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( Size_1 < Size )
    {
      *errno() = 34;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) != 0LL )
  {
    return 0xFFFFFFFFLL;
  }
  v12 = a3 + (int)Size;
  if ( v12 + 1 >= n0xF )
  {
    return 0xFFFFFFFFLL;
  }
  Size_2 = n0xF - v12;
  v14 = (_BYTE *)(Buffer + v12);
  if ( !v14 )
  {
LABEL_17:
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(Size + 1);
  }
  if ( __ && Size_2 )
  {
    *v14 = *__;
    return (unsigned int)(Size + 1);
  }
  else
  {
    memset(v14, 0, Size_2);
    if ( !__ )
    {
      goto LABEL_17;
    }
    if ( !Size_2 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(Size + 1);
  }
}

// --- End Function: sub_1402FC670 (0x1402FC670) ---

// --- Function: sub_1402FC7C0 (0x1402FC7C0) ---
__int64 __fastcall sub_1402FC7C0(
        __int64 Buffer,
        unsigned __int64 n0xF,
        __int64 n0xFa,
        __int64 ___EVT_COUNT__:,
        int *a5)
{
  unsigned __int64 n0xD; // rdi
  _DWORD *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r10
  int v13; // ecx
  int v14; // r9d
  __int64 v15; // rdi
  __int64 i; // r8
  __int64 v17; // r11
  int v18; // eax
  char *v19; // r8
  char *v20; // rax
  __int64 v21; // r10
  char v22; // cl
  char v23; // dl
  __int64 result; // rax

  if ( n0xFa + 13 >= n0xF )
  {
    return 0xFFFFFFFFLL;
  }
  n0xD = n0xF - n0xFa;
  v10 = (_DWORD *)(n0xFa + Buffer);
  if ( !v10 )
  {
    goto LABEL_3;
  }
  if ( ___EVT_COUNT__: && n0xD >= 0xD )
  {
    *(double *)v10 = *(double *)___EVT_COUNT__:;
    v10[2] = *(_DWORD *)(___EVT_COUNT__: + 8);
    *((_BYTE *)v10 + 12) = *(_BYTE *)(___EVT_COUNT__: + 12);
    goto LABEL_11;
  }
  memset(v10, 0, n0xF - n0xFa);
  if ( ___EVT_COUNT__: )
  {
    if ( n0xD >= 0xD )
    {
      goto LABEL_11;
    }
    *errno() = 34;
  }
  else
  {
LABEL_3:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v11 = n0xF - (n0xFa + 13);
  v12 = n0xFa + 13 + Buffer;
  v13 = *a5;
  if ( *a5 >= 0 )
  {
    v14 = 0;
  }
  else if ( v11 )
  {
    *(_BYTE *)v12 = 45;
    v13 = -v13 & 0x7FFFFFFF;
    v14 = 1;
  }
  else
  {
    v14 = -1;
  }
  v15 = v14;
  for ( i = v14; ; ++i )
  {
    v17 = v14;
    if ( v14 >= (int)v11 || i < 0 )
    {
      break;
    }
    ++v14;
    v18 = v13 % 10;
    v13 /= 10;
    *(_BYTE *)(i + v12) = v18 + 48;
    if ( !v13 )
    {
      if ( v15 < v17 )
      {
        v19 = (char *)(v17 + v12);
        v20 = (char *)(v15 + v12);
        v21 = -v12;
        do
        {
          v22 = *v19--;
          v23 = *v20;
          *v20++ = v22;
          v19[1] = v23;
        }
        while ( (__int64)&v20[v21] < (__int64)&v19[v21] );
      }
      result = (unsigned int)(v14 + 13);
      if ( v14 >= 0 )
      {
        return result;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FC7C0 (0x1402FC7C0) ---

// --- Function: sub_1402FC940 (0x1402FC940) ---
__int64 __fastcall sub_1402FC940(
        __int64 Buffer,
        unsigned __int64 n0xF,
        __int64 n0xFa,
        __int64 ___@severity__:,
        unsigned int *p_n0xF,
        __int64 ___severity__:__,
        __int64 a7,
        __int64 _____tags__:[)
{
  int n0xF_1; // ebp
  unsigned __int64 n0xD; // rbx
  _DWORD *v13; // rcx
  int v14; // ebx
  __int64 v15; // rsi
  __int64 v16; // rcx
  unsigned int n0xF_2; // r9d
  __int64 v18; // r8
  __int64 v19; // r11
  unsigned int v20; // eax
  char *v21; // rdx
  __int64 v22; // r9
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  __int64 result; // rax

  n0xF_1 = n0xF;
  if ( n0xFa + 13 >= n0xF )
  {
    return 0xFFFFFFFFLL;
  }
  n0xD = n0xF - n0xFa;
  v13 = (_DWORD *)(n0xFa + Buffer);
  if ( !v13 )
  {
    goto LABEL_3;
  }
  if ( ___@severity__: && n0xD >= 0xD )
  {
    *(double *)v13 = *(double *)___@severity__:;
    v13[2] = *(_DWORD *)(___@severity__: + 8);
    *((_BYTE *)v13 + 12) = *(_BYTE *)(___@severity__: + 12);
    goto LABEL_11;
  }
  memset(v13, 0, n0xF - n0xFa);
  if ( ___@severity__: )
  {
    if ( n0xD >= 0xD )
    {
      goto LABEL_11;
    }
    *errno() = 34;
  }
  else
  {
LABEL_3:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v14 = 0;
  v15 = n0xFa + 13;
  v16 = 0;
  n0xF_2 = *p_n0xF;
  v18 = v15 + Buffer;
  while ( 1 )
  {
    v19 = v14;
    if ( v14 >= n0xF_1 - (int)v15 || v16 < 0 )
    {
      break;
    }
    ++v14;
    v20 = n0xF_2 % 0xA;
    n0xF_2 /= 0xAu;
    *(_BYTE *)(v16 + v18) = v20 + 48;
    ++v16;
    if ( !n0xF_2 )
    {
      if ( (int)v19 > 0 )
      {
        v21 = (char *)(v19 + v18);
        v22 = -v18;
        do
        {
          v23 = *v21--;
          v24 = *(_BYTE *)v18;
          *(_BYTE *)v18++ = v23;
          v21[1] = v24;
        }
        while ( v22 + v18 < (__int64)&v21[v22] );
      }
      if ( v14 >= 0 )
      {
        v25 = sub_1402FCAE0(Buffer, n0xF_1, (int)v15 + v14, ___severity__:__, a7, _____tags__:[);
        if ( v25 >= 0 )
        {
          v26 = v14 + v25;
          result = (unsigned int)(v14 + v25 + 13);
          if ( v26 < 0 )
          {
            return 0xFFFFFFFFLL;
          }
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FC940 (0x1402FC940) ---

// --- Function: sub_1402FD110 (0x1402FD110) ---
_QWORD *__fastcall sub_1402FD110(__int64 **a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *(_QWORD *)(a2 + 16) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)sub_1402A1E30(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)sub_1402A1E30(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = *(_BYTE **)(a2 + 8);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( v7[Size_1] );
    sub_1402F8E30(&Src, v7, Size_1);
    v10 = *(_BYTE **)(a2 + 16);
    do
    {
      ++Size;
    }
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A78B0((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
      {
        p_Src = *(__m256 **)Src.m256_f32;
      }
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
    {
      goto LABEL_26;
    }
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
      {
        p_Src_1 = p_Src_2;
      }
      if ( v18[5] > 0xFu )
      {
        Buf1 = (_QWORD *)*Buf1;
      }
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
      {
        break;
      }
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
      {
        std::_Xlength_error("list too long");
      }
      v23 = sub_1402A1E30(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
      {
        v26 = (_QWORD *)*v26;
      }
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
      {
        v26 = (_QWORD *)*v26;
      }
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      free_memory_wrapper(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FD110 (0x1402FD110) ---

// --- Function: sub_1402FD6B0 (0x1402FD6B0) ---
const void *__fastcall sub_1402FD6B0(const void **a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // rcx
  const void *result; // rax

  v6 = *a1;
  if ( v6 )
  {
    if ( (((_BYTE *)a1[2] - (_BYTE *)v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v6 = (_QWORD *)*(v6 - 1);
    }
    free_memory_wrapper(v6);
  }
  *a1 = (const void *)a2;
  a1[1] = (const void *)(a2 + 8 * a3);
  result = (const void *)(a2 + 8 * a4);
  a1[2] = result;
  return result;
}

// --- End Function: sub_1402FD6B0 (0x1402FD6B0) ---

// --- Function: sub_1402FDA00 (0x1402FDA00) ---
bool __fastcall sub_1402FDA00(__int64 a1, _QWORD *a2, __int64 *a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  __int64 v11; // r10
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned __int64 v16; // r9
  bool v17; // bp
  __int64 v18; // rdi
  __int64 v19; // rbx
  unsigned __int64 v20; // rsi
  _QWORD *v21; // r15
  unsigned __int64 v22; // rbx
  __int64 v23; // rdi
  __int64 v24; // r9
  char v25; // al
  __int64 v26; // r8
  __int64 v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rax
  __int64 v30; // [rsp+20h] [rbp-48h]
  bool v32; // [rsp+80h] [rbp+18h]

  v7 = sub_1402FE800(*((unsigned int *)a3 + 9), a2, a3[3], a1);
  if ( v9 + v7 > v10 )
  {
    return 0;
  }
  v13 = *((unsigned int *)a3 + 8);
  v17 = 0;
  if ( (_DWORD)v13 != 1 )
  {
    v14 = sub_1402FE800(v13, v8, v9, v10);
    if ( v15 + v14 < v16 )
    {
      v17 = 1;
    }
  }
  v18 = a3[1];
  v19 = *a3;
  v32 = v17;
  if ( (v18 - *a3) / 104 != a5 )
  {
    if ( v19 != v18 )
    {
      do
      {
        if ( *(_BYTE *)(v19 + 88) && *(_QWORD *)v19 )
        {
          (*(void (**)(void))(v19 + 64))();
        }
        v19 += 104LL;
      }
      while ( v19 != v18 );
      a3[1] = *a3;
    }
    sub_1402FB8F0(a3, a5);
    v11 = a4;
    v17 = 1;
    v32 = 1;
  }
  v20 = 0LL;
  v21 = a2 + 1;
  v22 = 0LL;
  if ( a5 )
  {
    v23 = v11 + 48;
    v24 = -48 - v11;
    v30 = -48 - v11;
    while ( !v17 )
    {
      v21 = a2 + 1;
      if ( v22 < (__int64)(a2[1] - *a2) >> 2 && !*(_DWORD *)(*a2 + 4 * v22) && *(_QWORD *)(v23 + 24) && *(_QWORD *)v23 )
      {
        if ( (a3[1] - *a3) / 104 <= v22 )
        {
          __debugbreak();
        }
        v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v23)(*(_QWORD *)(v23 - 48), *(_QWORD *)(v24 + v23 + *a3));
        v24 = v30;
        v17 = v25 == 0;
        v32 = v25 == 0;
      }
      ++v22;
      v23 += 104LL;
      if ( v22 >= a5 )
      {
        goto LABEL_26;
      }
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v17 )
  {
LABEL_27:
    if ( a5 )
    {
      v26 = -16 - a4;
      v27 = a4 + 16;
      do
      {
        if ( v20 < (__int64)(*v21 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * v20)
          && *(_QWORD *)(v27 + 56)
          && *(_QWORD *)(v27 + 32) )
        {
          if ( (a3[1] - *a3) / 104 <= v20 )
          {
            __debugbreak();
          }
          v28 = v27 + v26 + *a3;
          if ( *(_BYTE *)(v28 + 88) )
          {
            if ( *(_QWORD *)v28 )
            {
              (*(void (**)(void))(v28 + 64))();
            }
          }
          v29 = (*(__int64 (__fastcall **)(_QWORD))(v27 + 56))(*(_QWORD *)(v27 - 16));
          v26 = -16 - a4;
          *(_QWORD *)v28 = v29;
          *(_QWORD *)(v28 + 8) = *(_QWORD *)(v27 - 8);
          *(_QWORD *)(v28 + 16) = *(_QWORD *)v27;
          *(_QWORD *)(v28 + 24) = *(_QWORD *)(v27 + 8);
          *(_QWORD *)(v28 + 32) = *(_QWORD *)(v27 + 16);
          *(_QWORD *)(v28 + 48) = *(_QWORD *)(v27 + 32);
          *(_QWORD *)(v28 + 40) = *(_QWORD *)(v27 + 24);
          *(_QWORD *)(v28 + 56) = *(_QWORD *)(v27 + 40);
          *(_QWORD *)(v28 + 64) = *(_QWORD *)(v27 + 48);
          *(_QWORD *)(v28 + 72) = *(_QWORD *)(v27 + 56);
          *(_QWORD *)(v28 + 80) = *(_QWORD *)(v27 + 64);
          *(_QWORD *)(v28 + 96) = *(_QWORD *)(v27 + 80);
          *(_BYTE *)(v28 + 88) = 1;
          *(_BYTE *)(v28 + 89) = *(_BYTE *)(v27 + 73);
        }
        ++v20;
        v27 += 104LL;
      }
      while ( v20 < a5 );
      v17 = v32;
    }
    a3[3] = a1;
  }
  return v17;
}

// --- End Function: sub_1402FDA00 (0x1402FDA00) ---

// --- Function: sub_1402FE700 (0x1402FE700) ---
__int64 __fastcall sub_1402FE700(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
  {
    return 0xFFFFFFFFLL;
  }
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 19), SizeInBytes - 19, ".%03dZ", v3 - 1000 * v7) + 19);
}

// --- End Function: sub_1402FE700 (0x1402FE700) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !qword_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !qword_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_1402FE800 (0x1402FE800) ---
__int64 __fastcall sub_1402FE800(int a1)
{
  __int64 n1000; // rax

  switch ( a1 )
  {
    case 2:
      n1000 = 1000;
      break;
    case 3:
      n1000 = 5000;
      break;
    case 4:
      n1000 = 15000;
      break;
    case 5:
      n1000 = 30000;
      break;
    case 6:
      n1000 = 60000;
      break;
    case 7:
      n1000 = 300000;
      break;
    case 8:
      n1000 = 900000;
      break;
    case 9:
      n1000 = 1800000;
      break;
    default:
      n1000 = 0;
      break;
  }
  return n1000;
}

// --- End Function: sub_1402FE800 (0x1402FE800) ---

// --- Function: sub_1402FE910 (0x1402FE910) ---
__int64 __fastcall sub_1402FE910(_WORD *a1, int a2, char n37)
{
  unsigned int n2_1; // r10d
  __int64 n2; // rax

  n2_1 = 0;
  switch ( n37 )
  {
    case 8:
      if ( a2 <= 1 )
      {
        goto LABEL_18;
      }
      *a1 = 25180;
      n2 = 2;
      break;
    case 9:
      if ( a2 <= 1 )
      {
        goto LABEL_18;
      }
      *a1 = 29788;
      n2 = 2;
      break;
    case 10:
      if ( a2 <= 1 )
      {
        goto LABEL_18;
      }
      *a1 = 28252;
      n2 = 2;
      break;
    case 12:
      if ( a2 <= 1 )
      {
        goto LABEL_18;
      }
      *a1 = 26204;
      n2 = 2;
      break;
    case 13:
      if ( a2 <= 1 )
      {
        goto LABEL_18;
      }
      *a1 = 29276;
      n2 = 2;
      break;
    case 34:
      if ( a2 <= 1 )
      {
        goto LABEL_18;
      }
      *a1 = 8796;
      n2 = 2;
      break;
    case 92:
      if ( a2 <= 1 )
      {
        goto LABEL_18;
      }
      *a1 = 23644;
      n2 = 2;
      break;
    default:
      if ( a2 > 0 )
      {
        *(_BYTE *)a1 = n37;
        n2_1 = 1;
      }
LABEL_18:
      n2 = n2_1;
      break;
  }
  return n2;
}

// --- End Function: sub_1402FE910 (0x1402FE910) ---

// --- Function: sub_140300090 (0x140300090) ---
__int64 __fastcall sub_140300090(
        int dwLowDateTime,
        __int64 a2,
        __int64 Buffer,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        __int64 a7,
        _QWORD *a8,
        unsigned __int64 a9,
        __int64 a10,
        char *Buffer_1,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_2; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 a13a_1; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_3; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_4; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 v79; // rdi
  _QWORD *v80; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *a4; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *a13a; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_1495F6708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
    {
      v17 = off_1495F6720[0];
    }
  }
  else
  {
    v17 = off_1495F6728[0];
  }
  Size_5 = -1;
  a4 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = -1;
  v21 = (const void **)&off_1495F6738[0][n4];
  do
  {
    ++Size_1;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_1) );
  if ( Size_1 >= Size )
  {
    goto LABEL_25;
  }
  if ( Size_1 )
  {
    if ( Buffer_1 )
    {
      if ( off_1495F6710 )
      {
        memcpy(Buffer_1, off_1495F6710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer_1, 0, Size);
    }
    *errno() = 22;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
  {
    goto LABEL_25;
  }
  if ( !&Buffer_1[(int)Size_1] )
  {
    *errno() = 22;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 34;
    goto LABEL_22;
  }
  Buffer_1[(int)Size_1] = 91;
LABEL_23:
  v22 = sub_1402FC4C0(
          (__int64)Buffer_1,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&a4,
          v21,
          (__int64)&off_1495F6710,
          (__int64)"]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
  {
LABEL_25:
    Sizea_4 = -1;
  }
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
  {
    Sizea_1 = 0;
  }
  v85 = (unsigned int)Sizea_4 >> 31;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_141;
  }
  v24 = off_1495F6710;
  Size_2 = -1;
  do
  {
    ++Size_2;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
  {
    goto LABEL_125;
  }
  Buffer_2 = Buffer_1;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer_1[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 22;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_1495F6710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_1495F6710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
      {
        goto LABEL_34;
      }
      if ( Size_3 < Size_2 )
      {
        *errno() = 34;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
  {
    goto LABEL_125;
  }
  v30 = &Buffer_2[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_2[v29] )
  {
    *errno() = 22;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_2 = Buffer_1;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 34;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 15392;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_1495F6730;
  do
  {
    ++Size_5;
  }
  while ( *((_BYTE *)off_1495F6730 + Size_5) );
  if ( Size_5 + v32 >= Size )
  {
    goto LABEL_125;
  }
  v34 = &Buffer_2[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 22;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_1495F6730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_1495F6730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
      {
        goto LABEL_56;
      }
      if ( Size_6 < Size_5 )
      {
        *errno() = 34;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  Size_7 = -1;
  v37 = v32 + (int)Size_5;
  do
  {
    ++Size_7;
  }
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
  {
    goto LABEL_125;
  }
  v38 = &Buffer_2[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 22;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
      {
        goto LABEL_71;
      }
      if ( Size_8 < Size_7 )
      {
        *errno() = 34;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_2 = Buffer_1;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v40 = off_1495F6710;
  Size_9 = -1;
  v42 = v37 + (int)Size_7;
  a4 = (void *)v42;
  do
  {
    ++Size_9;
  }
  while ( *((_BYTE *)off_1495F6710 + Size_9) );
  if ( Size_9 + v42 >= Size )
  {
    goto LABEL_125;
  }
  v43 = &Buffer_2[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 22;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_1495F6710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_1495F6710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
      {
        goto LABEL_86;
      }
      if ( Size_10 < Size_9 )
      {
        *errno() = 34;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)a4;
    Buffer_2 = Buffer_1;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
  {
    goto LABEL_125;
  }
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
  {
    goto LABEL_125;
  }
  v46 = &Buffer_2[v45];
  n2 = Size - v45;
  if ( &Buffer_2[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 8254;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 34;
  }
  else
  {
    *errno() = 22;
  }
  invalid_parameter_noinfo();
  Buffer_2 = Buffer_1;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = -1;
  do
  {
    ++Size_11;
  }
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
  {
    goto LABEL_124;
  }
  v50 = &Buffer_2[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
  {
    goto LABEL_116;
  }
  if ( !v50 )
  {
    goto LABEL_108;
  }
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
    {
      goto LABEL_116;
    }
    *errno() = 34;
  }
  else
  {
LABEL_108:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
  {
    goto LABEL_125;
  }
  v53 = Size_9 + v52;
  if ( v53 < 0 )
  {
    goto LABEL_125;
  }
  v54 = Size_7 + v53;
  if ( v54 < 0 )
  {
    goto LABEL_125;
  }
  v55 = Size_5 + v54;
  if ( v55 < 0 )
  {
    goto LABEL_125;
  }
  v56 = v55 + 2;
  if ( v56 < 0 )
  {
    goto LABEL_125;
  }
  v57 = Size_2 + v56;
  if ( v57 < 0 )
  {
    goto LABEL_125;
  }
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_142;
  }
  v60 = sub_140303140(
          (__int64)Buffer_1,
          Size,
          Sizea_1,
          (char *)a7,
          (__int64)a8,
          a9,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FB040);
  if ( v60 < 0 )
  {
    v58 = 1;
  }
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
  {
    Sizea_1 = Sizea_3;
  }
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_142;
  }
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer_1[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 32;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  a13a_1 = 0;
  a13a = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
  {
    goto LABEL_175;
  }
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = -1;
      v65 = off_1495F6710;
      a4 = (void *)qword_149808630;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * a13a_1);
      do
      {
        ++Size_14;
      }
      while ( *((_BYTE *)off_1495F6710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
      {
        goto LABEL_171;
      }
      Buffer_3 = Buffer_1;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer_1[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_3[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_3[Size_13] = 91;
LABEL_167:
                v70 = sub_1402FC4C0(
                        (__int64)Buffer_1,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_1495F6718,
                        (const void **)((char *)a4 + Sizec),
                        (__int64)&off_1495F6710,
                        (__int64)"]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      a13a_1 = (unsigned __int64)a13a;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 34;
            }
            else
            {
              *errno() = 22;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        a13a_1 = (unsigned __int64)a13a;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
      {
        goto LABEL_150;
      }
      if ( off_1495F6710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_1495F6710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 22;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 34;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_3 = Buffer_1;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    a13a = (int *)++a13a_1;
    v63 = *a5;
  }
  while ( a13a_1 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
  {
    goto LABEL_194;
  }
  v73 = v88;
  Size_16 = -1;
  do
  {
    ++Size_16;
  }
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_4 = Buffer_1;
  if ( Size_16 + Sizea_1 >= Size )
  {
    goto LABEL_191;
  }
  Size_17 = Size - Sizea_1;
  v77 = &Buffer_1[Sizea_1];
  if ( !Size_16 )
  {
    goto LABEL_189;
  }
  if ( !v77 )
  {
    goto LABEL_181;
  }
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 22;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 34;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
  {
LABEL_191:
    v58 = 1;
  }
  else
  {
    Sizea_1 += Size_16;
  }
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_4 = Buffer_1;
    v58 = 1;
  }
  else
  {
    Buffer_1[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( a9 )
  {
    v79 = 0;
    if ( (*a15 & 4) != 0 )
    {
      v80 = a8;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))v80[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*v80, &Buffer_4[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++v79;
        v80 += 13;
      }
      while ( v79 < a9 );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_4[Size - 4] = 11822;
      Buffer_4[Size - 2] = 46;
    }
  }
  else
  {
    Buffer_4[Sizea_1] = 0;
    if ( v58 )
    {
      goto LABEL_209;
    }
  }
  Buffer_4[Size - 1] = 0;
  if ( v78 )
  {
    qword_149808998(a2, Buffer, n4, Buffer_4, Sizea_1, a14);
  }
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140300090 (0x140300090) ---

// --- Function: sub_140300B90 (0x140300B90) ---
__int64 __fastcall sub_140300B90(
        __int64 a1,
        __int64 a2,
        _BYTE *Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        _BYTE *Src,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 i,
        unsigned __int64 n0xF,
        double *Buffer_1,
        unsigned __int64 n0xFa,
        __int64 a16,
        int i_1,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r11d
  double *Buffer_2; // r15
  _QWORD *v24; // r14
  int n0xFa_2; // ebx
  unsigned __int64 n0xFa_1; // r9
  unsigned __int64 n0xFa_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xFa_19; // r13d
  int v47; // r13d
  int i_3; // edi
  __int64 v49; // rsi
  _BYTE *v50; // rbp
  int v51; // eax
  unsigned int n4_2; // r14d
  int v53; // eax
  bool v54; // dl
  bool v55; // cl
  bool v56; // al
  int v57; // eax
  int n0xFa_4; // ebp
  int n0xFa_5; // esi
  int n0xF_2; // edi
  int v61; // eax
  __int64 *v62; // r9
  __int64 v63; // rdx
  __int64 v64; // rcx
  __int64 v65; // rax
  unsigned __int64 v66; // r8
  __int64 v67; // r15
  __int64 v68; // r14
  _BYTE *v69; // rsi
  __int64 v70; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v73; // rcx
  __int64 v74; // rcx
  size_t n2; // r8
  _WORD *v76; // rcx
  bool v77; // sf
  int v78; // ecx
  __int64 v79; // rax
  __int64 v80; // r15
  __int64 v81; // r14
  int v82; // eax
  int v83; // eax
  int n0xF_4; // ebp
  int n0xFa_7; // r14d
  int n0xFa_8; // r15d
  int n0xFa_9; // edx
  char *Src_2; // r14
  int v89; // eax
  int n0xFa_10; // ecx
  size_t Size_8; // r8
  double *v92; // rcx
  __int64 v93; // rdi
  __int64 i_4; // rbp
  int v95; // eax
  int n0xFa_11; // ecx
  size_t Size_9; // r8
  double *v98; // rcx
  _BYTE *v99; // rcx
  size_t Size_10; // r8
  double *v101; // rcx
  int n0xFa_12; // ebp
  int v103; // eax
  _BYTE *v104; // rcx
  unsigned __int64 n0xF_5; // rdx
  bool v106; // bp
  __int64 v107; // r14
  unsigned __int64 n0xF_8; // r15
  unsigned __int64 v109; // rsi
  __int64 v110; // r14
  int n0xFa_13; // edx
  int n0xF_7; // ecx
  bool v113; // r15
  int n0xFa_14; // r12d
  size_t Size_11; // r8
  _WORD *v116; // rcx
  _BYTE *v117; // rcx
  __int64 v118; // rax
  unsigned __int64 v119; // r9
  double *Buffer_3; // rdx
  _BYTE *v121; // rdi
  __int64 v122; // rbp
  size_t Size_12; // rbx
  char *v124; // rcx
  size_t Size_13; // rsi
  __int64 v126; // rcx
  size_t Size_14; // r8
  _WORD *v128; // rcx
  int v129; // ecx
  _BYTE *v130; // rcx
  unsigned __int64 n0xFa_16; // r8
  double *Buffer_4; // r12
  unsigned __int64 v133; // r8
  _BYTE *v134; // rcx
  int n0xFa_17; // esi
  int v136; // eax
  double *Buffer_5; // rsi
  _BYTE *v138; // rcx
  size_t Size_15; // r8
  _WORD *v140; // rcx
  int v141; // esi
  int v142; // eax
  size_t Size_16; // r8
  double *v144; // rcx
  size_t Size_17; // r8
  _WORD *v146; // rcx
  size_t n0xFa_18; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  unsigned int n4_3; // ebp
  __int64 v151; // r14
  _BYTE *v152; // rsi
  int v154; // [rsp+20h] [rbp-138h]
  _QWORD *v155; // [rsp+28h] [rbp-130h]
  int v156; // [rsp+28h] [rbp-130h]
  int n0xF_3; // [rsp+80h] [rbp-D8h]
  int n0xFa_6; // [rsp+80h] [rbp-D8h]
  int n0xF_6; // [rsp+80h] [rbp-D8h]
  bool v160; // [rsp+90h] [rbp-C8h]
  bool v161; // [rsp+91h] [rbp-C7h]
  bool v162; // [rsp+92h] [rbp-C6h]
  unsigned __int64 n0xFa_15; // [rsp+98h] [rbp-C0h]
  unsigned __int64 n0xF_1; // [rsp+A0h] [rbp-B8h] BYREF
  unsigned __int64 v165; // [rsp+A8h] [rbp-B0h]
  _BYTE *v166; // [rsp+B0h] [rbp-A8h]
  _QWORD *v167; // [rsp+B8h] [rbp-A0h]
  __int64 v168; // [rsp+C0h] [rbp-98h]
  __int64 v169; // [rsp+C8h] [rbp-90h]
  __int64 v170; // [rsp+D0h] [rbp-88h]
  char *Src_1; // [rsp+D8h] [rbp-80h]
  char *v172; // [rsp+E0h] [rbp-78h]
  void (__fastcall *v173)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, __int64, char *, unsigned __int64, __int128 *); // [rsp+E8h] [rbp-70h] BYREF
  __int64 i_2; // [rsp+F0h] [rbp-68h]
  __int128 v175; // [rsp+F8h] [rbp-60h] BYREF

  n4_1 = n4;
  Buffer_2 = Buffer_1;
  v24 = a6;
  Src_1 = Src;
  v172 = (char *)a8;
  v169 = a9;
  i_2 = i;
  v170 = a16;
  v166 = a4;
  n0xFa_2 = 0;
  n0xFa_1 = n0xFa;
  v173 = 0;
  v168 = a2;
  n0xFa_3 = n0xFa + 128;
  LODWORD(n0xF_1) = n4;
  v167 = a6;
  n0xFa_15 = n0xFa + 128;
  v175 = 0;
  if ( (int)n0xFa <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xFa <= 0xF )
  {
    goto LABEL_57;
  }
  if ( Buffer_1 )
  {
    *Buffer_1 = 0x73656D697440227BLL;
    *((_DWORD *)Buffer_1 + 2) = 1886216564;
    *((_WORD *)Buffer_1 + 6) = 14882;
    *((_BYTE *)Buffer_1 + 14) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    n0xFa_1 = n0xFa;
  }
  Size = -1;
  do
  {
    ++Size;
  }
  while ( Buffer[Size] );
  if ( Size + 15 >= n0xFa_1 )
  {
LABEL_56:
    n0xFa_1 = n0xFa;
    n4_1 = n4;
LABEL_57:
    n0xFa_19 = -1;
    goto LABEL_58;
  }
  v29 = (char *)Buffer_1 + 15;
  Size_1 = n0xFa_1 - 15;
  if ( Size )
  {
    if ( Buffer_1 == (double *)-15LL )
    {
LABEL_11:
      *errno() = 22;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( Buffer && Size_1 >= Size )
    {
      memcpy(v29, Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xFa_1 - 15);
      if ( !Buffer )
      {
        goto LABEL_11;
      }
      if ( Size_1 < Size )
      {
        *errno() = 34;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xFa_1 = n0xFa;
  }
  if ( (Size & 0x80000000) != 0LL )
  {
    goto LABEL_56;
  }
  v31 = (int)Size + 15LL;
  if ( (int)Size + 24LL >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v32 = (double *)((char *)Buffer_1 + v31);
  Size_2 = n0xFa_1 - v31;
  if ( !(double *)((char *)Buffer_1 + v31) )
  {
    *errno() = 22;
LABEL_27:
    invalid_parameter_noinfo();
    n0xFa_1 = n0xFa;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 34;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 34;
LABEL_28:
  v34 = (int)Size + 24LL;
  Size_3 = -1;
  do
  {
    ++Size_3;
  }
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v36 = (char *)Buffer_1 + v34;
  Size_4 = n0xFa_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 22;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xFa_1 - v34);
      if ( !a4 )
      {
        goto LABEL_33;
      }
      if ( Size_4 < Size_3 )
      {
        *errno() = 34;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xFa_1 = n0xFa;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
  {
    goto LABEL_56;
  }
  v38 = v34 + (int)Size_3;
  if ( v38 + 13 >= n0xFa_1 )
  {
    goto LABEL_56;
  }
  v39 = (double *)((char *)Buffer_1 + v38);
  Size_5 = n0xFa_1 - v38;
  if ( !(double *)((char *)Buffer_1 + v38) )
  {
    *errno() = 22;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 34;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 578315369;
  *((_BYTE *)v39 + 12) = 58;
LABEL_50:
  v41 = sub_1402FC400((__int64)Buffer_1, n0xFa, v38 + 13, a1);
  if ( v41 < 0 )
  {
    goto LABEL_56;
  }
  v42 = v41 + 13;
  if ( v42 < 0 )
  {
    goto LABEL_56;
  }
  v43 = Size_3 + v42;
  if ( v43 < 0 )
  {
    goto LABEL_56;
  }
  v44 = v43 + 9;
  if ( v44 < 0 )
  {
    goto LABEL_56;
  }
  v45 = Size + v44;
  if ( v45 < 0 )
  {
    goto LABEL_56;
  }
  n0xFa_1 = n0xFa;
  n4_1 = n4;
  n0xFa_19 = v45 + 15;
LABEL_58:
  v24 = v167;
  n0xFa_2 = n0xFa_19;
  if ( n0xFa_19 < 0 )
  {
    n0xFa_2 = 0;
  }
  v47 = (unsigned int)n0xFa_19 >> 31;
LABEL_62:
  i_3 = i_1;
  if ( (a18 & 0x10) != 0 && qword_1498089A8 )
  {
    v49 = a10;
    v50 = v166;
    if ( n0xFa_2 >= (int)n0xFa_1 )
    {
      v47 = 1;
    }
    else
    {
      v51 = qword_1498089A8(
              v168,
              v166,
              n4_1,
              Src_1,
              v24,
              v170,
              i_1,
              v169,
              a10,
              (char *)Buffer_1 + n0xFa_2,
              n0xFa_1 - n0xFa_2,
              &a18);
      if ( v51 < 0 )
      {
        v47 = 1;
      }
      else
      {
        n0xFa_2 += v51;
      }
    }
  }
  else
  {
    v50 = v166;
    v49 = a10;
  }
  if ( (a18 & 0xFFF00) == 0 || !qword_1498089B0 )
  {
    goto LABEL_77;
  }
  if ( n0xFa_2 >= (int)n0xFa )
  {
    v47 = 1;
LABEL_77:
    n4_2 = n4;
    goto LABEL_78;
  }
  v155 = v24;
  n4_2 = n4;
  v53 = qword_1498089B0(
          a18,
          v168,
          v50,
          n4,
          Src_1,
          v155,
          v170,
          i_1,
          v172,
          v169,
          v49,
          (char *)Buffer_1 + n0xFa_2,
          n0xFa - n0xFa_2,
          &v175,
          &v173);
  if ( v53 < 0 )
  {
    v47 = 1;
  }
  else
  {
    n0xFa_2 += v53;
  }
LABEL_78:
  v54 = (a18 & 8) != 0 && qword_1498089A0;
  v162 = v54;
  v55 = (a18 & 1) != 0 && n2_1 == 2;
  v160 = v55;
  v56 = (a18 & 2) != 0 && n2_2 == 2;
  v161 = v56;
  if ( !v54 && !v55 && !v56 )
  {
    n4_3 = n4;
    v151 = v168;
    goto LABEL_383;
  }
  if ( qword_149808978 )
  {
    if ( n0xFa_2 >= (int)n0xFa_3 )
    {
      n0xFa_5 = n0xFa + 128;
      n0xF_3 = n0xFa + 128;
      n0xF_2 = n0xFa + 128;
      goto LABEL_104;
    }
    v57 = qword_149808978((char *)Buffer_1 + n0xFa_2, n0xFa_3 - n0xFa_2);
    if ( v57 < 0 )
    {
      v47 = 1;
      n0xF_3 = n0xFa + 128;
      n0xFa_4 = n0xFa_2;
      n0xFa_5 = n0xFa + 128;
      n0xF_2 = n0xFa + 128;
      goto LABEL_98;
    }
    n0xFa_2 += v57;
  }
  n0xF_3 = n0xFa + 128;
  n0xFa_4 = n0xFa_2;
  n0xFa_5 = n0xFa + 128;
  n0xF_2 = n0xFa + 128;
  if ( n0xFa_2 < (int)n0xFa_3 )
  {
LABEL_98:
    v61 = sub_1402FC940(
            (__int64)Buffer_1,
            n0xFa_3,
            n0xFa_2,
            (__int64)",\"@severity\":",
            (unsigned int *)&n0xF_1,
            (__int64)",\"severity\":\"",
            (__int64)&off_1495F6738[0][n4_2],
            (__int64)"\",\"tags\":[");
    if ( v61 < 0 )
    {
      v47 = 1;
    }
    n0xFa_2 += v61;
    if ( v61 < 0 )
    {
      n0xFa_2 = n0xFa_4;
    }
    goto LABEL_105;
  }
LABEL_104:
  v47 = 1;
LABEL_105:
  v62 = v167;
  v63 = v167[1];
  v64 = *v167;
  v65 = (v63 - *v167) >> 2;
  if ( !v65 )
  {
    goto LABEL_154;
  }
  v66 = 0;
  v165 = 0;
  if ( v65 == 1 )
  {
    goto LABEL_143;
  }
  do
  {
    LODWORD(n0xF_1) = n0xF_2;
    n0xFa_6 = n0xFa_5;
    if ( n0xFa_2 >= n0xFa_5 )
    {
      goto LABEL_140;
    }
    v67 = qword_149808630;
    v68 = *(unsigned int *)(v64 + 4 * v66);
    if ( n0xFa_2 + 1LL >= n0xFa_3 )
    {
      goto LABEL_140;
    }
    if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
    {
      *errno() = 22;
LABEL_114:
      invalid_parameter_noinfo();
      goto LABEL_115;
    }
    if ( n0xFa_3 == n0xFa_2 )
    {
      *errno() = 34;
      goto LABEL_114;
    }
    *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
LABEL_115:
    v69 = *(_BYTE **)(v67 + 8 * v68);
    v70 = n0xFa_2 + 1LL;
    Size_6 = -1;
    do
    {
      ++Size_6;
    }
    while ( v69[Size_6] );
    if ( Size_6 + v70 >= n0xFa_15 )
    {
LABEL_138:
      n0xFa_3 = n0xFa + 128;
LABEL_139:
      n0xFa_5 = n0xFa_6;
      n0xF_2 = n0xF_1;
      v66 = v165;
      v62 = v167;
      goto LABEL_140;
    }
    Size_7 = n0xFa_15 - v70;
    v73 = (char *)Buffer_1 + v70;
    if ( Size_6 )
    {
      if ( !v73 )
      {
        goto LABEL_120;
      }
      if ( v69 && Size_7 >= Size_6 )
      {
        memcpy(v73, v69, Size_6);
        goto LABEL_128;
      }
      memset(v73, 0, n0xFa_15 - v70);
      if ( v69 )
      {
        if ( Size_7 >= Size_6 )
        {
          goto LABEL_128;
        }
        *errno() = 34;
      }
      else
      {
LABEL_120:
        *errno() = 22;
      }
      invalid_parameter_noinfo();
    }
LABEL_128:
    if ( (Size_6 & 0x80000000) != 0LL )
    {
      goto LABEL_138;
    }
    v74 = v70 + (int)Size_6;
    n0xFa_3 = n0xFa + 128;
    if ( v74 + 2 >= n0xFa_15 )
    {
      goto LABEL_139;
    }
    n2 = n0xFa_15 - v74;
    v76 = (_WORD *)((char *)Buffer_1 + v74);
    if ( v76 )
    {
      if ( n2 >= 2 )
      {
        *v76 = 11298;
        goto LABEL_136;
      }
      memset(v76, 0, n2);
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
LABEL_136:
    v77 = (int)Size_6 + 3 < 0;
    v78 = Size_6 + 3;
    v66 = v165;
    v62 = v167;
    n0xFa_5 = n0xFa_6;
    n0xF_2 = n0xF_1;
    if ( !v77 )
    {
      n0xFa_2 += v78;
      goto LABEL_141;
    }
LABEL_140:
    v47 = 1;
LABEL_141:
    v63 = v62[1];
    ++v66;
    v64 = *v62;
    v79 = v63 - *v62;
    v165 = v66;
  }
  while ( v66 < (v79 >> 2) - 1 );
  n0xF_3 = n0xF_2;
LABEL_143:
  if ( n0xFa_2 >= n0xFa_5 )
  {
    goto LABEL_157;
  }
  v80 = qword_149808630;
  v81 = *(unsigned int *)(v64 + 4 * ((v63 - v64) >> 2) - 4);
  if ( n0xFa_2 + 1LL >= n0xFa_3 )
  {
    goto LABEL_166;
  }
  if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
  {
    *errno() = 22;
    goto LABEL_150;
  }
  if ( n0xFa_3 == n0xFa_2 )
  {
    *errno() = 34;
LABEL_150:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
  }
  v82 = sub_1402FC670((__int64)Buffer_1, n0xFa_3, n0xFa_2 + 1LL, (const void **)(v80 + 8 * v81), "\"");
  if ( v82 < 0 || (v83 = v82 + 1, v83 < 0) )
  {
LABEL_166:
    n0xF_4 = n0xF_2;
    n0xFa_7 = n0xFa_5;
    v47 = 1;
    n0xFa_8 = n0xFa_2;
    n0xFa_9 = n0xFa_2;
    goto LABEL_155;
  }
  n0xFa_2 += v83;
  n0xF_3 = n0xF_2;
LABEL_154:
  n0xF_4 = n0xF_2;
  n0xFa_7 = n0xFa_5;
  n0xFa_8 = n0xFa_2;
  n0xFa_9 = n0xFa_2;
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_157:
    v47 = 1;
  }
  else
  {
LABEL_155:
    if ( n0xFa_2 + 11LL >= n0xFa_3 )
    {
      n0xFa_2 = n0xFa_9;
      n0xF_3 = n0xF_2;
      goto LABEL_157;
    }
    Size_8 = n0xFa_3 - n0xFa_2;
    v92 = (double *)((char *)Buffer_1 + n0xFa_2);
    if ( !v92 )
    {
      *errno() = 22;
      goto LABEL_172;
    }
    if ( Size_8 < 0xB )
    {
      memset(v92, 0, Size_8);
      *errno() = 34;
LABEL_172:
      invalid_parameter_noinfo();
    }
    else
    {
      *v92 = 0x746E657665222C5DLL;
      *((_WORD *)v92 + 4) = 14882;
      *((_BYTE *)v92 + 10) = 34;
    }
    n0xF_3 = n0xF_4;
    n0xFa_2 = n0xFa_8 + 11;
    n0xFa_5 = n0xFa_7;
    n0xF_2 = n0xF_4;
  }
  if ( *Src_1 )
  {
    Src_2 = Src_1;
    do
    {
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        v89 = sub_1402FE910((double *)((char *)Buffer_1 + n0xFa_2), (int)n0xFa - n0xFa_2, *Src_2);
        if ( v89 < 0 )
        {
          v47 = 1;
        }
        n0xFa_10 = v89 + n0xFa_2;
        if ( v89 < 0 )
        {
          n0xFa_10 = n0xFa_2;
        }
        n0xFa_2 = n0xFa_10;
      }
      ++Src_2;
    }
    while ( *Src_2 );
    n0xF_2 = n0xF_3;
    n0xFa_3 = n0xFa + 128;
  }
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_180:
    v47 = 1;
  }
  else
  {
    if ( n0xFa_2 + 13LL >= n0xFa_3 )
    {
      n0xF_3 = n0xF_2;
      goto LABEL_180;
    }
    Size_9 = n0xFa_3 - n0xFa_2;
    v98 = (double *)((char *)Buffer_1 + n0xFa_2);
    if ( !v98 )
    {
      *errno() = 22;
      goto LABEL_194;
    }
    if ( Size_9 < 0xD )
    {
      memset(v98, 0, Size_9);
      *errno() = 34;
LABEL_194:
      invalid_parameter_noinfo();
    }
    else
    {
      *v98 = 0x617373656D222C22LL;
      *((_DWORD *)v98 + 2) = 975332711;
      *((_BYTE *)v98 + 12) = 34;
    }
    n0xFa_2 += 13;
    n0xF_3 = n0xF_2;
  }
  if ( i_1 > 0 )
  {
    v93 = v170;
    for ( i_4 = 0; i_4 < i_1; ++i_4 )
    {
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        v95 = sub_1402FE910((double *)((char *)Buffer_1 + n0xFa_2), (int)n0xFa - n0xFa_2, *(_BYTE *)(v93 + i_4));
        if ( v95 < 0 )
        {
          v47 = 1;
        }
        n0xFa_11 = v95 + n0xFa_2;
        if ( v95 < 0 )
        {
          n0xFa_11 = n0xFa_2;
        }
        n0xFa_2 = n0xFa_11;
      }
    }
    n0xF_2 = n0xF_3;
    n0xFa_3 = n0xFa + 128;
  }
  if ( n0xFa_2 >= n0xFa_5 )
  {
LABEL_217:
    v47 = 1;
    goto LABEL_218;
  }
  if ( n0xFa_2 + 1LL < n0xFa_3 )
  {
    v99 = (char *)Buffer_1 + n0xFa_2;
    if ( v99 )
    {
      if ( n0xFa_3 != n0xFa_2 )
      {
        *v99 = 34;
LABEL_208:
        ++n0xFa_2;
        goto LABEL_209;
      }
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
    goto LABEL_208;
  }
  v47 = 1;
LABEL_209:
  if ( n0xFa_2 >= n0xFa_5 || n0xFa_2 + 11LL >= n0xFa_3 )
  {
    goto LABEL_217;
  }
  Size_10 = n0xFa_3 - n0xFa_2;
  v101 = (double *)((char *)Buffer_1 + n0xFa_2);
  if ( !v101 )
  {
    *errno() = 22;
    goto LABEL_216;
  }
  if ( Size_10 < 0xB )
  {
    memset(v101, 0, Size_10);
    *errno() = 34;
LABEL_216:
    invalid_parameter_noinfo();
    n0xFa_2 += 11;
  }
  else
  {
    *v101 = 0x6F746F727040222CLL;
    n0xFa_2 += 11;
    *((_WORD *)v101 + 4) = 14882;
    *((_BYTE *)v101 + 10) = 34;
  }
LABEL_218:
  n0xFa_12 = n0xFa_2;
  if ( n0xFa_2 >= (int)n0xFa )
  {
    v47 = 1;
  }
  else
  {
    v103 = sub_140303140(
             (__int64)Buffer_1,
             n0xFa,
             n0xFa_2,
             v172,
             v169,
             a10,
             a11,
             1,
             (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FB080);
    if ( v103 < 0 )
    {
      v47 = 1;
    }
    n0xFa_2 += v103;
    if ( v103 < 0 )
    {
      n0xFa_2 = n0xFa_12;
    }
  }
  if ( n0xFa_2 >= n0xFa_5 || n0xFa_2 + 1LL >= n0xFa_3 )
  {
    v47 = 1;
  }
  else
  {
    v104 = (char *)Buffer_1 + n0xFa_2;
    if ( !v104 )
    {
      *errno() = 22;
      goto LABEL_231;
    }
    if ( n0xFa_3 == n0xFa_2 )
    {
      *errno() = 34;
LABEL_231:
      invalid_parameter_noinfo();
      ++n0xFa_2;
    }
    else
    {
      *v104 = 34;
      ++n0xFa_2;
    }
  }
  n0xF_5 = n0xF;
  v106 = 0;
  n0xF_1 = 0;
  v107 = 0;
  n0xF_8 = 0;
  if ( n0xF )
  {
    while ( !v47 )
    {
      v109 = *(_QWORD *)(i_2 + 8 * n0xF_8);
      v165 = v109;
      if ( v107 != *(_QWORD *)(v109 + 8) )
      {
        if ( v106 )
        {
          if ( n0xFa_2 < n0xF_2 )
          {
            if ( n0xFa_2 + 2LL >= n0xFa_3 )
            {
              v110 = *(_QWORD *)(v109 + 80);
              v47 = 1;
              n0xF_6 = n0xF_2;
              n0xFa_13 = n0xFa_2;
              n0xF_7 = n0xF_2;
              v113 = v110 != -1;
              n0xFa_14 = n0xFa_2;
              goto LABEL_257;
            }
            Size_11 = n0xFa_3 - n0xFa_2;
            v116 = (_WORD *)((char *)Buffer_1 + n0xFa_2);
            if ( !v116 )
            {
              *errno() = 22;
              goto LABEL_245;
            }
            if ( Size_11 < 2 )
            {
              memset(v116, 0, Size_11);
              *errno() = 34;
LABEL_245:
              invalid_parameter_noinfo();
              n0xFa_2 += 2;
            }
            else
            {
              *v116 = 11357;
              n0xFa_2 += 2;
            }
LABEL_256:
            v118 = *(_QWORD *)(v109 + 80);
            n0xFa_13 = n0xFa_2;
            n0xF_6 = n0xF_2;
            n0xF_7 = n0xF_2;
            n0xFa_14 = n0xFa_2;
            v106 = v118 != -1;
            v110 = v118;
            v113 = v106;
            if ( n0xFa_2 < n0xF_2 )
            {
LABEL_257:
              v119 = n0xFa + 128;
              if ( n0xFa_2 + 1LL >= n0xFa_15 )
              {
                v109 = v165;
                n0xF_2 = n0xF_7;
                n0xFa_2 = n0xFa_13;
                v106 = v113;
                v118 = v110;
                goto LABEL_292;
              }
              Buffer_3 = Buffer_1;
              if ( !(double *)((char *)Buffer_1 + n0xFa_2) )
              {
                *errno() = 22;
                goto LABEL_264;
              }
              if ( n0xFa_15 == n0xFa_2 )
              {
                *errno() = 34;
LABEL_264:
                invalid_parameter_noinfo();
                Buffer_3 = Buffer_1;
                v119 = n0xFa + 128;
              }
              else
              {
                *((_BYTE *)Buffer_1 + n0xFa_2) = 34;
              }
              v121 = *(_BYTE **)(v109 + 8);
              v122 = n0xFa_2 + 1LL;
              Size_12 = -1;
              do
              {
                ++Size_12;
              }
              while ( v121[Size_12] );
              if ( Size_12 + v122 >= v119 )
              {
                goto LABEL_289;
              }
              v124 = (char *)Buffer_3 + v122;
              Size_13 = v119 - v122;
              if ( Size_12 )
              {
                if ( !v124 )
                {
                  goto LABEL_270;
                }
                if ( v121 && Size_13 >= Size_12 )
                {
                  memcpy(v124, v121, Size_12);
                  goto LABEL_278;
                }
                memset(v124, 0, v119 - v122);
                if ( !v121 )
                {
LABEL_270:
                  *errno() = 22;
                  goto LABEL_277;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 34;
LABEL_277:
                  invalid_parameter_noinfo();
                }
LABEL_278:
                v119 = n0xFa + 128;
                Buffer_3 = Buffer_1;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v126 = v122 + (int)Size_12, v126 + 2 >= v119) )
              {
LABEL_289:
                n0xF_2 = n0xF_6;
                n0xFa_2 = n0xFa_14;
                v106 = v113;
                v118 = v110;
              }
              else
              {
                Size_14 = v119 - v126;
                v128 = (_WORD *)((char *)Buffer_3 + v126);
                if ( !v128 )
                {
                  *errno() = 22;
                  goto LABEL_286;
                }
                if ( Size_14 < 2 )
                {
                  memset(v128, 0, Size_14);
                  *errno() = 34;
LABEL_286:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v128 = 14882;
                }
                n0xF_2 = n0xF_6;
                v77 = (int)Size_12 + 3 < 0;
                v129 = Size_12 + 3;
                n0xFa_2 = n0xFa_14;
                v118 = v110;
                v106 = v113;
                if ( !v77 )
                {
                  v109 = v165;
                  n0xFa_2 = v129 + n0xFa_14;
                  goto LABEL_293;
                }
              }
              v109 = v165;
            }
LABEL_292:
            v47 = 1;
LABEL_293:
            if ( v118 != -1 )
            {
              if ( n0xFa_2 < n0xF_2 && n0xFa_2 + 1LL < n0xFa_15 )
              {
                v130 = (char *)Buffer_1 + n0xFa_2;
                if ( !v130 )
                {
                  *errno() = 22;
                  goto LABEL_301;
                }
                if ( n0xFa_15 == n0xFa_2 )
                {
                  *errno() = 34;
LABEL_301:
                  invalid_parameter_noinfo();
                  v107 = *(_QWORD *)(v109 + 8);
                  n0xF_8 = n0xF_1;
                  ++n0xFa_2;
                }
                else
                {
                  n0xF_8 = n0xF_1;
                  ++n0xFa_2;
                  *v130 = 91;
                  v107 = *(_QWORD *)(v109 + 8);
                }
LABEL_315:
                Buffer_4 = Buffer_1;
                goto LABEL_316;
              }
              v47 = 1;
            }
            v107 = *(_QWORD *)(v109 + 8);
            n0xF_8 = n0xF_1;
            goto LABEL_315;
          }
LABEL_291:
          v118 = *(_QWORD *)(v109 + 80);
          v106 = v118 != -1;
          goto LABEL_292;
        }
        if ( n0xFa_2 >= n0xF_2 )
        {
          goto LABEL_291;
        }
        if ( n0xFa_2 + 1LL >= n0xFa_3 )
        {
          v110 = *(_QWORD *)(v109 + 80);
          n0xF_7 = n0xF_2;
          n0xF_6 = n0xF_2;
          v47 = 1;
          n0xFa_13 = n0xFa_2;
          v113 = v110 != -1;
          n0xFa_14 = n0xFa_2;
          goto LABEL_257;
        }
        v117 = (char *)Buffer_1 + n0xFa_2;
        if ( !v117 )
        {
          *errno() = 22;
          goto LABEL_254;
        }
        if ( n0xFa_3 == n0xFa_2 )
        {
          *errno() = 34;
LABEL_254:
          invalid_parameter_noinfo();
        }
        else
        {
          *v117 = 44;
        }
        ++n0xFa_2;
        goto LABEL_256;
      }
      if ( !v107 || n0xF_8 >= n0xF_5 )
      {
        goto LABEL_315;
      }
      if ( n0xFa_2 >= n0xF_2 || n0xFa_2 + 1LL >= n0xFa_3 )
      {
        v47 = 1;
        goto LABEL_315;
      }
      n0xFa_16 = n0xFa_3;
      Buffer_4 = Buffer_1;
      v133 = n0xFa_16 - n0xFa_2;
      v134 = (char *)Buffer_1 + n0xFa_2;
      if ( v134 )
      {
        if ( v133 )
        {
          *v134 = 44;
          ++n0xFa_2;
          goto LABEL_316;
        }
        *errno() = 34;
      }
      else
      {
        *errno() = 22;
      }
      invalid_parameter_noinfo();
      ++n0xFa_2;
LABEL_316:
      n0xFa_17 = n0xFa_2;
      if ( n0xFa_2 >= (int)n0xFa )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(v154) = 1;
        v136 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v165 + 32))(
                 *(_QWORD *)v165,
                 (char *)Buffer_4 + n0xFa_2,
                 n0xFa - n0xFa_2,
                 0,
                 v154,
                 0);
        if ( v136 < 0 )
        {
          v47 = 1;
        }
        n0xFa_2 += v136;
        if ( v136 < 0 )
        {
          n0xFa_2 = n0xFa_17;
        }
        if ( !v47 )
        {
          n0xFa_3 = n0xFa + 128;
          goto LABEL_323;
        }
      }
      n0xFa_3 = n0xFa + 128;
      if ( n0xFa_2 >= n0xF_2 )
      {
        v47 = 1;
LABEL_323:
        Buffer_5 = Buffer_1;
      }
      else
      {
        Buffer_5 = Buffer_1;
        if ( n0xFa_2 + 6LL >= n0xFa_15 )
        {
          v47 = 1;
          goto LABEL_324;
        }
        Size_15 = n0xFa_15 - n0xFa_2;
        v140 = (_WORD *)((char *)Buffer_1 + n0xFa_2);
        if ( !v140 )
        {
          *errno() = 22;
          goto LABEL_340;
        }
        if ( Size_15 < 6 )
        {
          memset(v140, 0, Size_15);
          *errno() = 34;
LABEL_340:
          invalid_parameter_noinfo();
          n0xFa_2 += 6;
        }
        else
        {
          n0xFa_2 += 6;
          *(_DWORD *)v140 = 1819635234;
          v140[2] = 8812;
        }
      }
LABEL_324:
      n0xF_5 = n0xF;
      if ( (n0xF_8 == n0xF - 1 || v47) && v106 )
      {
        if ( n0xFa_2 >= n0xF_2 || n0xFa_2 + 1LL >= n0xFa_3 )
        {
          v47 = 1;
        }
        else
        {
          v138 = (char *)Buffer_5 + n0xFa_2;
          if ( !v138 )
          {
            *errno() = 22;
            goto LABEL_345;
          }
          if ( n0xFa_3 == n0xFa_2 )
          {
            *errno() = 34;
LABEL_345:
            invalid_parameter_noinfo();
            n0xF_5 = n0xF;
            ++n0xFa_2;
          }
          else
          {
            *v138 = 93;
            ++n0xFa_2;
          }
        }
      }
      n0xF_1 = ++n0xF_8;
      if ( n0xF_8 >= n0xF_5 )
      {
        break;
      }
      continue;
    }
  }
  v141 = a19;
  if ( a19 <= 1 )
  {
    Buffer_2 = Buffer_1;
LABEL_353:
    if ( !v47 )
    {
      goto LABEL_363;
    }
    if ( n0xFa_2 < n0xF_2 )
    {
      goto LABEL_355;
    }
    goto LABEL_374;
  }
  if ( n0xFa_2 >= n0xF_2 )
  {
    goto LABEL_374;
  }
  Buffer_2 = Buffer_1;
  v142 = sub_1402FC7C0((__int64)Buffer_1, n0xFa_3, n0xFa_2, (__int64)",\"EVT_COUNT\":", &a19);
  if ( v142 >= 0 )
  {
    n0xFa_2 += v142;
    goto LABEL_353;
  }
LABEL_355:
  if ( n0xFa_2 + 13LL < n0xFa_3 )
  {
    Size_16 = n0xFa_3 - n0xFa_2;
    v144 = (double *)((char *)Buffer_2 + n0xFa_2);
    if ( !v144 )
    {
      *errno() = 22;
      goto LABEL_361;
    }
    if ( Size_16 < 0xD )
    {
      memset(v144, 0, Size_16);
      *errno() = 34;
LABEL_361:
      invalid_parameter_noinfo();
    }
    else
    {
      *v144 = 0x4C465245564F222CLL;
      *((_DWORD *)v144 + 2) = 975329103;
      *((_BYTE *)v144 + 12) = 49;
    }
    n0xFa_2 += 13;
LABEL_363:
    if ( n0xFa_2 >= n0xF_2 )
    {
      goto LABEL_374;
    }
  }
  if ( n0xFa_2 + 2LL >= n0xFa_3 )
  {
    n0xFa_18 = n0xFa_2;
    *((_BYTE *)Buffer_2 + n0xFa_2) = 0;
  }
  else
  {
    Size_17 = n0xFa_3 - n0xFa_2;
    v146 = (_WORD *)((char *)Buffer_2 + n0xFa_2);
    if ( !v146 )
    {
      *errno() = 22;
      goto LABEL_370;
    }
    if ( Size_17 < 2 )
    {
      memset(v146, 0, Size_17);
      *errno() = 34;
LABEL_370:
      invalid_parameter_noinfo();
    }
    else
    {
      *v146 = 2685;
    }
    n0xFa_2 += 2;
    if ( n0xFa_2 < n0xF_2 )
    {
      n0xFa_18 = n0xFa_2;
      *((_BYTE *)Buffer_2 + n0xFa_2) = 0;
      goto LABEL_375;
    }
LABEL_374:
    Buffer_2 = Buffer_1;
    n0xFa_18 = n0xFa_2;
  }
LABEL_375:
  *((_BYTE *)Buffer_2 + n0xFa_3 - 1) = 0;
  if ( v160 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_2, n0xFa_18, 1u, Stream);
  }
  if ( v161 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_2, n0xFa_18, 1u, Stream_1);
  }
  n4_3 = n4;
  v151 = v168;
  if ( v162 )
  {
    v156 = v141;
    v152 = v166;
    qword_1498089A0(v168, v166, n4, Buffer_2, n0xFa_18, v156);
    i_3 = i_1;
    goto LABEL_384;
  }
  i_3 = i_1;
LABEL_383:
  v152 = v166;
LABEL_384:
  if ( v173 )
  {
    v173(
      a18,
      v151,
      v152,
      n4_3,
      Src_1,
      v167,
      v170,
      i_3,
      v172,
      v169,
      a10,
      (char *)Buffer_2 + n0xFa_2,
      n0xFa - n0xFa_2,
      &v175);
  }
  return (unsigned int)n0xFa_2;
}

// --- End Function: sub_140300B90 (0x140300B90) ---

// --- Function: sub_140302260 (0x140302260) ---
unsigned __int64 __fastcall sub_140302260(__int64 a1, unsigned __int64 a2)
{
  const void *v4; // rcx
  unsigned __int64 result; // rax
  __int64 v6; // rdi
  unsigned __int64 n0x6400000; // rcx
  __int64 v8; // rdi
  __int64 v9; // rax
  _QWORD *v10; // rbx

  v4 = *(const void **)a1;
  result = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3;
  if ( a2 > result )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    {
      unknown_libname_10();
    }
    v6 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    n0x6400000 = 8 * a2;
    v8 = v6 >> 3;
    if ( 8 * a2 < 0x1000 )
    {
      if ( n0x6400000 )
      {
        v10 = (_QWORD *)sub_1402A1E30(n0x6400000);
      }
      else
      {
        v10 = 0;
      }
    }
    else
    {
      if ( n0x6400000 + 39 < n0x6400000 )
      {
        sub_1402DEE40();
      }
      v9 = sub_1402A1E30(n0x6400000 + 39);
      if ( !v9 )
      {
        invalid_parameter_noinfo_noreturn();
      }
      v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v9;
    }
    memmove(v10, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    return (unsigned __int64)sub_1402FD6B0((const void **)a1, (__int64)v10, v8, a2);
  }
  return result;
}

// --- End Function: sub_140302260 (0x140302260) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 v13; // r13
  char result; // al
  __int64 *v15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  __int64 v18; // r15
  _QWORD *v19; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  __int64 *v22; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v24; // rcx
  _QWORD *v25; // rbx
  _BYTE *v26; // rdx
  _BYTE *v27; // rdx
  __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *v31; // r14
  __int64 *v32; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  __int64 v42; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *Buf2_1; // r15
  _QWORD **v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *v56; // rcx
  __m256 *Buf2_2; // rax
  __int64 *v58; // rax
  __int64 *v59; // r14
  __int64 v60; // rcx
  _QWORD *v61; // rbx
  _BYTE *v62; // rdx
  _BYTE *v63; // rdx
  __int64 v64; // r10
  __int64 v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 Buffer_3; // rax
  const void *Buffer_5; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  Stream *Stream; // rax
  int n2; // r8d
  Stream *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 Buffer_4; // rax
  const void *Buffer_6; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  Stream *Stream_2; // rax
  Stream *Stream_3; // rax
  const void **v103; // rsi
  _QWORD **v104; // rcx
  _QWORD *v105; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *v107; // rdi
  _QWORD *v108; // rcx
  __int64 *v109; // rbx
  _QWORD *v110; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  __int64 *v114; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  __int64 v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *v121; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 v123; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *v125; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  _QWORD *v129; // [rsp+128h] [rbp+88h] BYREF
  __int64 *v130; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *v131; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **v135; // [rsp+158h] [rbp+B8h] BYREF
  __int64 v136; // [rsp+160h] [rbp+C0h]
  __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  v121 = (_QWORD *)a5;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v13 = a6;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, a5, a6);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  v135 = 0;
  v15 = 0;
  v130 = (__int64 *)&v135;
  n0x400 = 0;
  v114 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !a6 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  v19 = v121;
  v20 = v112;
  v125 = v121;
  while ( 2 )
  {
    v21 = *((_BYTE *)v19 + 89) == 0;
    v131 = v19;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = v19;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    v123 = (unsigned __int64)v19;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = v19;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !v15 )
      {
        __asm { vzeroupper }
        v114 = (__int64 *)sub_1402A1E30(0x18u);
        v15 = v114;
        if ( v114 )
        {
          v22 = v114;
          *v114 = 0;
          n0x400_1 = 0;
          v15[1] = 0;
          v24 = (__int64)v15;
          v15[2] = 0;
        }
        else
        {
          v15 = 0;
          v22 = 0;
          n0x400_1 = 0;
          v114 = 0;
          v24 = 0;
        }
        sub_140302260(v24, v13);
        v25 = v141;
        do
        {
          v26 = (_BYTE *)v22[1];
          if ( v26 == (_BYTE *)v22[2] )
          {
            sub_1402A47D0(v15, v26, v25);
          }
          else
          {
            *(_QWORD *)v26 = *v25;
            v22[1] += 8;
          }
          ++n0x400_1;
          ++v25;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        v19 = v125;
      }
      v27 = (_BYTE *)v15[1];
      if ( v27 == (_BYTE *)v15[2] )
      {
        __asm { vzeroupper }
        sub_1402A47D0(v15, v27, &v123);
      }
      else
      {
        *(_QWORD *)v27 = v19;
        v15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    v19[1] = sub_1402FD110(&v130, (__int64)v19);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, __int64))v19[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    v123 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*v19, &v124, &v123, v28);
    v31 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    v32 = v130;
    do
    {
      v131 = v31;
      v31[10] = v18;
      v21 = v31[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)v31[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*v32 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)sub_1402A1E30(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)sub_1402A1E30(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *v32 = (__int64)v33;
        }
        v35 = (_BYTE *)v31[1];
        Size_2 = -1;
        memset(&v138, 0, sizeof(v138));
        Size_1 = -1;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)v31[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        v42 = *v32;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        Buf2_1 = *(__m256 **)v138.m256_f32;
        v129 = (_QWORD *)v42;
        v45 = *(_QWORD ***)v42;
        v46 = **(_QWORD ***)v42;
        if ( v46 == *(_QWORD **)v42 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = Buf2_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        v42 = (__int64)v129;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *(_QWORD *)(v42 + 8) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = sub_1402A1E30(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 32) = 0;
          *(_QWORD *)(v51 + 40) = 0;
          *(__m256 *)(v51 + 16) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*(_QWORD *)(v42 + 8);
          v53 = v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = (_QWORD *)v51;
          *v53 = v51;
          v54 = *(_QWORD *)*v32;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 40LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v56 = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v56 = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)v56 - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(v56);
          }
          v15 = v114;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            Buf2_2 = Buf2_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              Buf2_1 = *(__m256 **)&Buf2_1[-1].m256_f32[6];
              if ( (unsigned __int64)((char *)Buf2_2 - (char *)Buf2_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(Buf2_1);
          }
          v15 = v114;
          n0x400_2 = 0;
          v31 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 15;
        }
      }
      v31[1] = v55;
      n0x400 = n0xF;
      v129 = v31;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !v15 )
        {
          __asm { vzeroupper }
          v58 = (__int64 *)sub_1402A1E30(0x18u);
          v15 = v58;
          v114 = v58;
          if ( v58 )
          {
            *v58 = 0;
            v59 = v58;
            v58[1] = 0;
            v60 = (__int64)v58;
            v58[2] = 0;
          }
          else
          {
            v15 = 0;
            v114 = 0;
            v59 = 0;
            v60 = 0;
          }
          sub_140302260(v60, a6);
          v61 = v141;
          do
          {
            v62 = (_BYTE *)v59[1];
            if ( v62 == (_BYTE *)v59[2] )
            {
              sub_1402A47D0(v15, v62, v61);
            }
            else
            {
              *(_QWORD *)v62 = *v61;
              v59[1] += 8;
            }
            ++n0x400_2;
            ++v61;
          }
          while ( n0x400_2 < 0x400 );
          v31 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        v63 = (_BYTE *)v15[1];
        if ( v63 == (_BYTE *)v15[2] )
        {
          __asm { vzeroupper }
          sub_1402A47D0(v15, v63, &v129);
        }
        else
        {
          *(_QWORD *)v63 = v31;
          v15[1] += 8;
        }
      }
      else
      {
        v141[n0xF] = v31;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      v31 += 13;
      a13 = v30;
      *(_QWORD *)v116 = v31;
    }
    while ( v30 < v124 );
    v19 = v125;
LABEL_94:
    v28 = v137;
    v13 = a6;
    if ( v123 > 1 )
    {
      v28 = -1;
    }
    v64 = v123 + v117;
    v117 += v123;
LABEL_98:
    v19 += 13;
    v125 = v19;
    v131[10] = v28;
    if ( ++v132 < v13 )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v114 = v15;
  n0xF = n0x400;
  v117 = v64;
  if ( !v15 )
  {
    goto LABEL_106;
  }
  if ( !((v15[1] - *v15) >> 3) )
  {
    __debugbreak();
  }
  i = (char *)*v15;
  v114 = v15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 80LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 80LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 80) = -(__int64)(*(_QWORD *)(v71 + 80) != -1);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (v65 + 1) << 10;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    Buffer_5 = 0;
  }
  else
  {
    Buffer_3 = sub_1402A1E30(Size);
    Buffer_5 = (const void *)Buffer_3;
    if ( Buffer_3 )
    {
      Buffer_1 = (char *)Buffer_3;
      goto LABEL_131;
    }
  }
  v79 = Size + 15;
  if ( Size + 15 < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && qword_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, v121, a6, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            v121,
            a6,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    sub_1402F5120(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    sub_1402F5120(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((n0xF + 2 * v117 + v117 + 32) << 7);
    }
    n0x8000_2 = v93 + 128;
    if ( *p_n0x8000_1 < v93 + 128 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      Buffer_6 = 0;
    }
    else
    {
      Buffer_4 = sub_1402A1E30(n0x8000_2);
      Buffer_6 = (const void *)Buffer_4;
      if ( Buffer_4 )
      {
        Buffer_2 = (double *)Buffer_4;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 15;
    if ( n0x8000_2 + 15 < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      (__int64)v121,
      a6,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 128,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(Buffer_6);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  result = free_memory_wrapper(Buffer_5);
  v103 = v135;
  if ( v135 )
  {
    v104 = (_QWORD **)*v135;
    **((_QWORD **)*v135 + 1) = 0;
    v105 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = v105[5];
        v107 = (_QWORD *)*v105;
        if ( n0xF_2 > 0xF )
        {
          v108 = (_QWORD *)v105[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v108 - *(v108 - 1) - 8 > 0x1F )
            {
              goto LABEL_190;
            }
            v108 = (_QWORD *)*(v108 - 1);
          }
          free_memory_wrapper(v108);
        }
        v105[4] = 0;
        v105[5] = 15;
        *((_BYTE *)v105 + 16) = 0;
        free_memory_wrapper(v105);
        v105 = v107;
      }
      while ( v107 );
    }
    free_memory_wrapper(*v103);
    result = free_memory_wrapper(v103);
  }
  v109 = v114;
  if ( v114 )
  {
    v110 = (_QWORD *)*v114;
    if ( *v114 )
    {
      if ( ((v114[2] - (_QWORD)v110) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v110 - *(v110 - 1) - 8 > 0x1F )
        {
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        }
        v110 = (_QWORD *)*(v110 - 1);
      }
      free_memory_wrapper(v110);
      *v109 = 0;
      v109[1] = 0;
      v109[2] = 0;
    }
    return free_memory_wrapper(v109);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: sub_140303140 (0x140303140) ---
__int64 __fastcall sub_140303140(
        __int64 a1,
        __int64 a2,
        int a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        __int64 (__fastcall *a9)(__int64, __int64, __int64, __int64, __int64, _BYTE *))
{
  __int64 v9; // rbp
  int v11; // ecx
  int v12; // esi
  char n37; // r8
  __int64 v14; // r15
  char *v15; // rbx
  __int64 v17; // rcx
  char n36; // cl
  __int64 v19; // rdi
  _BYTE *v20; // r11
  unsigned __int64 n0x39; // rcx
  char *v22; // r10
  int n31_2; // r8d
  __int64 n31; // rdx
  __int64 v25; // r9
  int n31_1; // eax
  int v27; // eax
  int v28; // edi
  _BYTE *v29; // rbp
  int n31_4; // r9d
  __int64 n31_5; // r8
  char *v32; // r11
  __int64 v33; // r10
  unsigned __int64 n0x39_1; // rdx
  int n31_3; // eax
  int v36; // eax
  int v37; // eax
  __int64 v38; // rax
  _BYTE *v40; // [rsp+28h] [rbp-90h]
  char String[4]; // [rsp+30h] [rbp-88h] BYREF
  int v42; // [rsp+34h] [rbp-84h]
  __int64 (__fastcall *v43)(__int64, __int64, __int64, __int64, __int64, _BYTE *); // [rsp+38h] [rbp-80h]
  __int64 v44; // [rsp+40h] [rbp-78h]
  _BYTE v45[32]; // [rsp+48h] [rbp-70h] BYREF

  v9 = a5;
  v11 = a3;
  v12 = a3;
  v44 = a5;
  n37 = *a4;
  v14 = 0;
  v43 = a9;
  v15 = a4;
  v42 = v11;
  if ( n37 )
  {
    do
    {
      v17 = 0x3FF6C0900000000LL;
      if ( n37 == 36 )
      {
        n36 = *++v15;
        v19 = 0;
        if ( n36 == 36 )
        {
LABEL_6:
          v19 = v14++;
        }
        else
        {
          while ( (unsigned __int8)(n36 - 48) <= 9u )
          {
            String[0] = n36;
            ++v15;
            v19 = atoi(String) + 10 * v19;
            n36 = *v15;
            if ( *v15 == 36 )
            {
              goto LABEL_6;
            }
          }
          --v15;
        }
        v20 = 0;
        if ( v15[1] == 123 )
        {
          n0x39 = (unsigned __int8)v15[2];
          v22 = v15;
          v15 += 2;
          n31_2 = 0;
          n31 = 0;
          if ( (_BYTE)n0x39 != 125 )
          {
            do
            {
              if ( n31 >= 31 || (unsigned __int8)n0x39 > 0x39u || (v25 = 0x3FF6C0900000000LL, !_bittest64(&v25, n0x39)) )
              {
                v15 = v22;
                goto LABEL_20;
              }
              ++v15;
              v45[n31] = n0x39;
              ++n31_2;
              ++n31;
              n0x39 = (unsigned __int8)*v15;
            }
            while ( (_BYTE)n0x39 != 125 );
            if ( n31_2 > 0 )
            {
              n31_1 = 31;
              if ( n31_2 < 31 )
              {
                n31_1 = n31_2;
              }
              if ( (unsigned __int64)n31_1 >= 0x20 )
              {
LABEL_55:
                _report_rangecheckfailure();
              }
              v45[n31_1] = 0;
              v20 = v45;
            }
          }
        }
LABEL_20:
        if ( v12 < (int)a2 )
        {
          v27 = v43(v12 + a1, a2 - v12, v9, v19 + a7, a6, v20);
          if ( v27 >= 0 )
          {
            v12 += v27;
          }
        }
        v28 = a2;
      }
      else if ( n37 == 37 )
      {
        v29 = 0;
        n31_4 = 0;
        n31_5 = 0;
        v32 = v15;
        v33 = 0;
        while ( 2 )
        {
          n0x39_1 = *++v15;
          switch ( (int)n0x39_1 )
          {
            case 0:
              v15 = v32 + 1;
              goto LABEL_39;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64:
            case 66:
            case 68:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 84:
            case 85:
            case 86:
            case 87:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            case 96:
            case 98:
            case 104:
            case 106:
            case 107:
            case 108:
            case 109:
            case 113:
            case 114:
            case 116:
            case 118:
            case 119:
              v17 = 0x3FF6C0900000000LL;
              goto LABEL_28;
            case 37:
            case 65:
            case 67:
            case 69:
            case 70:
            case 71:
            case 83:
            case 88:
            case 90:
            case 97:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 105:
            case 110:
            case 111:
            case 112:
            case 115:
            case 117:
            case 120:
              if ( n31_4 <= 0 )
              {
                goto LABEL_37;
              }
              n31_3 = 31;
              if ( n31_4 < 31 )
              {
                n31_3 = n31_4;
              }
              if ( (unsigned __int64)n31_3 >= 0x20 )
              {
                goto LABEL_55;
              }
              v45[n31_3] = 0;
              v29 = v45;
LABEL_37:
              v33 = v14++;
LABEL_39:
              v28 = a2;
              if ( v12 >= (int)a2 )
              {
                v9 = v44;
              }
              else
              {
                v40 = v29;
                v9 = v44;
                v36 = v43(v12 + a1, a2 - v12, v44, v33 + a7, a6, v40);
                if ( v36 >= 0 )
                {
                  v12 += v36;
                }
              }
              break;
            default:
LABEL_28:
              if ( n31_5 < 31 && (unsigned __int8)n0x39_1 <= 0x39u && _bittest64(&v17, n0x39_1) )
              {
                ++n31_4;
                v45[n31_5++] = n0x39_1;
              }
              continue;
          }
          break;
        }
      }
      else
      {
        v28 = a2;
        if ( a8 )
        {
          if ( v12 < (int)a2 )
          {
            v37 = sub_1402FE910((_WORD *)(v12 + a1), (int)a2 - v12, n37);
            if ( v37 >= 0 )
            {
              v12 += v37;
            }
          }
        }
        else if ( v12 < (int)a2 )
        {
          v38 = v12++;
          *(_BYTE *)(v38 + a1) = n37;
        }
      }
      n37 = *++v15;
    }
    while ( n37 );
    v11 = v42;
  }
  else
  {
    v28 = a2;
  }
  if ( v12 < v28 )
  {
    *(_BYTE *)(v12 + a1) = 0;
  }
  return (unsigned int)(v12 - v11);
}

// --- End Function: sub_140303140 (0x140303140) ---

// --- Function: swprintf (0x140303B50) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A2470();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0LL, va);
  if ( result < 0 )
  {
    return -1;
  }
  return result;
}

// --- End Function: swprintf (0x140303B50) ---

// --- Function: submitTraceContext (0x14034E9F0) ---
// Prepares a trace context structure with specific handler functions and metadata,
// then submits this context along with other logging parameters (level, category,
// message, tags, etc.) to the core logging function `sub_140302350`.
char __fastcall submitTraceContext(
        int log_level,
        __int64 category_ptr,
        void *message_format,
        __int64 arg_ptr_1,
        __int64 trace_context_handlers,
        int status_flags,
        _QWORD *tags_ptr,
        __int64 *list_ptr,
        __int64 thread_log_context_slot)
{
  __int64 status_flags_storage; // [rsp+18h] [rbp-88h]
  __int64 trace_context_handlers_data[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n256; // [rsp+88h] [rbp-18h]
  __int64 n176; // [rsp+90h] [rbp-10h]

  trace_context_handlers_data[0] = thread_log_context_slot;
  trace_context_handlers_data[1] = (__int64)"TraceContext";
  trace_context_handlers_data[3] = (__int64)sub_1403E6C00;
  trace_context_handlers_data[4] = (__int64)sub_1403E6700;
  trace_context_handlers_data[6] = (__int64)sub_1403E2C50;
  trace_context_handlers_data[8] = (__int64)sub_1403E02C0;
  trace_context_handlers_data[9] = (__int64)sub_1403DFFB0;
  LODWORD(status_flags_storage) = status_flags;
  n256 = 256;
  trace_context_handlers_data[2] = 0;
  trace_context_handlers_data[5] = 0;
  trace_context_handlers_data[7] = 0;
  trace_context_handlers_data[10] = -1;
  n176 = 176;
  return sub_140302350(
           log_level,
           category_ptr,
           message_format,
           arg_ptr_1,
           (__int64)trace_context_handlers_data,
           1,
           trace_context_handlers,
           status_flags_storage,
           tags_ptr,
           list_ptr);
}

// --- End Function: submitTraceContext (0x14034E9F0) ---

// --- Function: initializeEmptyStringStructure (0x140357A40) ---
// Initializes the string structure pointed to by `a1` to represent an empty string
// by setting its internal pointer to the global empty string sentinel
// `qword_149808ABC + 4`.
void __fastcall initializeEmptyStringStructure(_QWORD *string_struct_ptr)
{
  *string_struct_ptr = (char *)&qword_149808ABC + 4;
}

// --- End Function: initializeEmptyStringStructure (0x140357A40) ---

// --- Function: copyStringStructure (0x1403744C0) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
void **__fastcall copyStringStructure(void **dest_string_struct_ptr, const void **src_string_struct_ptr)
{
  unsigned __int64 src_size; // rdi

  src_size = *((int *)*src_string_struct_ptr - 2);
  sub_1403E4C30(dest_string_struct_ptr, src_size, 32);
  if ( src_size && *dest_string_struct_ptr != *src_string_struct_ptr )
  {
    memcpy(*dest_string_struct_ptr, *src_string_struct_ptr, src_size);
  }
  return dest_string_struct_ptr;
}

// --- End Function: copyStringStructure (0x1403744C0) ---

// --- Function: assignCStringToStringStructure (0x140374520) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **string_struct_ptr, _BYTE *c_string)
{
  __int64 c_string_length; // rax

  if ( c_string )
  {
    c_string_length = -1;
    do
    {
      ++c_string_length;
    }
    while ( c_string[c_string_length] );
    sub_1403D9750(string_struct_ptr, c_string, (int)c_string_length);
    return string_struct_ptr;
  }
  else
  {
    sub_1403D9750(string_struct_ptr, 0, 0);
    return string_struct_ptr;
  }
}

// --- End Function: assignCStringToStringStructure (0x140374520) ---

// --- Function: sub_140397520 (0x140397520) ---
FARPROC __fastcall sub_140397520(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
    {
      return result;
    }
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
  {
    return GetProcAddress(hModule_1, lpProcName);
  }
  else
  {
    return v7;
  }
}

// --- End Function: sub_140397520 (0x140397520) ---

// --- Function: sub_1403D95E0 (0x1403D95E0) ---
char *__fastcall sub_1403D95E0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = sub_14739AFC0(a2 + 9, 0LL);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149808ABC + 4;
    *a1 = (char *)&qword_149808ABC + 4;
  }
  return result;
}

// --- End Function: sub_1403D95E0 (0x1403D95E0) ---

// --- Function: sub_1403D9750 (0x1403D9750) ---
void *__fastcall sub_1403D9750(void **a1, void *a2, size_t Size)
{
  char *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = (char *)*a1;
  if ( Size > *((int *)v5 - 1) )
  {
    v7 = (int *)(v5 - 8);
    if ( v7[1] > 0 )
    {
      sub_14739AF10(v7);
    }
    *a1 = (char *)&qword_149808ABC + 4;
    if ( Size )
    {
      v8 = (_DWORD *)sub_14739AFC0(Size + 9, 0LL);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
  {
    memcpy(*a1, a2, Size);
  }
  *((_DWORD *)*a1 - 2) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403D9750 (0x1403D9750) ---

// --- Function: sub_1403DFFB0 (0x1403DFFB0) ---
__int64 sub_1403DFFB0()
{
  return sub_1402A1E30(1uLL);
}

// --- End Function: sub_1403DFFB0 (0x1403DFFB0) ---

// --- Function: sub_1403DFFF0 (0x1403DFFF0) ---
_QWORD *__fastcall sub_1403DFFF0(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)sub_1402A1E30(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    free_memory_wrapper(0);
    v5 = -1;
    while ( v4[++v5] != 0 )
    {
      ;
    }
    Size = v5 + 1;
    v8 = (void *)sub_1402A1E30(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403DFFF0 (0x1403DFFF0) ---

// --- Function: sub_1403E02C0 (0x1403E02C0) ---
__int64 __fastcall sub_1403E02C0(const void *a1)
{
  return free_memory_wrapper(a1);
}

// --- End Function: sub_1403E02C0 (0x1403E02C0) ---

// --- Function: sub_1403E02E0 (0x1403E02E0) ---
__int64 __fastcall sub_1403E02E0(const void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    free_memory_wrapper(a1[2]);
    return free_memory_wrapper(a1);
  }
  return result;
}

// --- End Function: sub_1403E02E0 (0x1403E02E0) ---

// --- Function: sub_1403E2AB0 (0x1403E2AB0) ---
bool __fastcall sub_1403E2AB0(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
  {
    return 1;
  }
  if ( !v2 || !v3 )
  {
    return 0;
  }
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
    {
      break;
    }
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E2AB0 (0x1403E2AB0) ---

// --- Function: sub_1403E2C50 (0x1403E2C50) ---
char __fastcall sub_1403E2C50(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
    {
      return 1;
    }
  }
  return 0;
}

// --- End Function: sub_1403E2C50 (0x1403E2C50) ---

// --- Function: sub_1403E4C30 (0x1403E4C30) ---
__int64 __fastcall sub_1403E4C30(void **a1, unsigned __int64 a2, char Val)
{
  _DWORD *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx
  __int64 result; // rax

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
    {
      return result;
    }
    *(v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
  {
    return result;
  }
  if ( a2 <= (int)*(v3 - 1) )
  {
    memset((char *)v3 + v6, Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    result = *((int *)*a1 - 2);
    *((_BYTE *)*a1 + result) = 0;
    return result;
  }
  sub_1403D95E0((char **)a1, a2);
  if ( *a1 != v3 )
  {
    memcpy(*a1, v3, (int)*(v3 - 2));
  }
  result = (__int64)memset((char *)*a1 + (int)*(v3 - 2), Val_1, Size);
  if ( (int)*(v3 - 1) > 0 )
  {
    sub_14739AF10(v3 - 2);
  }
  return result;
}

// --- End Function: sub_1403E4C30 (0x1403E4C30) ---

// --- Function: sub_1403E6550 (0x1403E6550) ---
__int64 __fastcall sub_1403E6550(__int64 a1, double *a2, unsigned __int64 n9)
{
  __int64 v4; // r8

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    return sub_1402FEA60(a2, n9, v4, 1);
  }
  if ( n9 <= 9 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( a2 )
  {
    *a2 = 0x7274706C6C756E22LL;
    *((_BYTE *)a2 + 8) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  return 9LL;
}

// --- End Function: sub_1403E6550 (0x1403E6550) ---

// --- Function: sub_1403E6700 (0x1403E6700) ---
__int64 __fastcall sub_1403E6700(__int64 a1, __int64 a2, unsigned __int64 n12)
{
  int v3; // edi
  int n12_1; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12_1 = 0;
  if ( (int)n12 > 0 )
  {
    if ( n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 = 12;
      if ( (int)n12 <= 12 )
      {
        goto LABEL_52;
      }
    }
    v8 = sub_1404EEAB0((unsigned __int8 *)a1, (_BYTE *)((unsigned int)n12_1 + a2), n12 - (unsigned int)n12_1);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v8;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12_1);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 19;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v10 = sub_1404EE450((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v10;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12_1;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v12 = sub_1404EE6A0((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12_1 += v12;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    if ( n12 - n12_1 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12_1);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12_1 += 18;
      if ( n12_1 >= (int)n12 )
      {
        goto LABEL_52;
      }
    }
    v14 = sub_1404EE300((unsigned __int8 *)a1, (_BYTE *)(n12_1 + a2), n12 - n12_1);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12_1 += v14;
    if ( n12_1 < (int)n12 )
    {
LABEL_46:
      if ( n12 - n12_1 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12_1);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12_1 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
  {
    return (unsigned int)-1;
  }
  return (unsigned int)n12_1;
}

// --- End Function: sub_1403E6700 (0x1403E6700) ---

// --- Function: sub_1403E6A90 (0x1403E6A90) ---
__int64 __fastcall sub_1403E6A90(__int64 a1, __int64 a2, unsigned __int64 Size, __int64 a4, char a5)
{
  _BYTE *v6; // rdx
  __int64 result; // rax
  size_t Size_1; // rbx

  v6 = *(_BYTE **)(a1 + 8);
  if ( v6 )
  {
    if ( a5 )
    {
      return sub_1402FEA60((_BYTE *)a2, Size, *(_QWORD *)(a1 + 8), 0);
    }
    result = -1;
    Size_1 = -1;
    do
    {
      ++Size_1;
    }
    while ( v6[Size_1] );
    if ( Size_1 < Size )
    {
      if ( Size_1 )
      {
        if ( !a2 )
        {
          *errno() = 22;
          invalid_parameter_noinfo();
          return (unsigned int)Size_1;
        }
        memcpy((void *)a2, v6, Size_1);
      }
      return (unsigned int)Size_1;
    }
  }
  else if ( Size > 7 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 1819047278;
      *(_WORD *)(a2 + 4) = 29808;
      *(_BYTE *)(a2 + 6) = 114;
    }
    else
    {
      *errno() = 22;
      invalid_parameter_noinfo();
    }
    return 7;
  }
  else
  {
    return -1;
  }
  return result;
}

// --- End Function: sub_1403E6A90 (0x1403E6A90) ---

// --- Function: sub_1403E6C00 (0x1403E6C00) ---
// attributes: thunk
__int64 __fastcall sub_1403E6C00(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404EEAB0(a1, a2, n0x21);
}

// --- End Function: sub_1403E6C00 (0x1403E6C00) ---

// --- Function: sub_1404AE300 (0x1404AE300) ---
_QWORD *sub_1404AE300()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  if ( !v0 )
  {
    sub_140535CF0((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)sub_1402A1E30(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_147E52AF0);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404AE300 (0x1404AE300) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 15;
  }
  return (__int64 *)&tls_log_structure_1[22 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: sub_1404EE300 (0x1404EE300) ---
__int64 __fastcall sub_1404EE300(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)a1[40] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[40] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[41] >> 4];
  a2[3] = _0123456789abcdef_[a1[41] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[42] >> 4];
  a2[5] = _0123456789abcdef_[a1[42] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[43] >> 4];
  a2[7] = _0123456789abcdef_[a1[43] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[44] >> 4];
  a2[9] = _0123456789abcdef_[a1[44] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[45] >> 4];
  a2[11] = _0123456789abcdef_[a1[45] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[46] >> 4];
  a2[13] = _0123456789abcdef_[a1[46] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[47] >> 4];
  a2[15] = _0123456789abcdef_[a1[47] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404EE300 (0x1404EE300) ---

// --- Function: sub_1404EE450 (0x1404EE450) ---
__int64 __fastcall sub_1404EE450(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)a1[16] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[16] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[17] >> 4];
  a2[3] = _0123456789abcdef_[a1[17] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[18] >> 4];
  a2[5] = _0123456789abcdef_[a1[18] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[19] >> 4];
  a2[7] = _0123456789abcdef_[a1[19] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[20] >> 4];
  a2[9] = _0123456789abcdef_[a1[20] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[21] >> 4];
  a2[11] = _0123456789abcdef_[a1[21] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[22] >> 4];
  a2[13] = _0123456789abcdef_[a1[22] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[23] >> 4];
  a2[15] = _0123456789abcdef_[a1[23] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[24] >> 4];
  a2[17] = _0123456789abcdef_[a1[24] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[25] >> 4];
  a2[19] = _0123456789abcdef_[a1[25] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[26] >> 4];
  a2[21] = _0123456789abcdef_[a1[26] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[27] >> 4];
  a2[23] = _0123456789abcdef_[a1[27] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[28] >> 4];
  a2[25] = _0123456789abcdef_[a1[28] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[29] >> 4];
  a2[27] = _0123456789abcdef_[a1[29] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[30] >> 4];
  a2[29] = _0123456789abcdef_[a1[30] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[31] >> 4];
  a2[31] = _0123456789abcdef_[a1[31] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404EE450 (0x1404EE450) ---

// --- Function: sub_1404EE6A0 (0x1404EE6A0) ---
__int64 __fastcall sub_1404EE6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)a1[32] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[32] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[33] >> 4];
  a2[3] = _0123456789abcdef_[a1[33] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[34] >> 4];
  a2[5] = _0123456789abcdef_[a1[34] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[35] >> 4];
  a2[7] = _0123456789abcdef_[a1[35] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[36] >> 4];
  a2[9] = _0123456789abcdef_[a1[36] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[37] >> 4];
  a2[11] = _0123456789abcdef_[a1[37] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[38] >> 4];
  a2[13] = _0123456789abcdef_[a1[38] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[39] >> 4];
  a2[15] = _0123456789abcdef_[a1[39] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404EE6A0 (0x1404EE6A0) ---

// --- Function: sub_1404EEAB0 (0x1404EEAB0) ---
__int64 __fastcall sub_1404EEAB0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[11] = _0123456789abcdef_[a1[5] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[13] = _0123456789abcdef_[a1[6] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[15] = _0123456789abcdef_[a1[7] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[17] = _0123456789abcdef_[a1[8] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[19] = _0123456789abcdef_[a1[9] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[10] >> 4];
  a2[21] = _0123456789abcdef_[a1[10] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[11] >> 4];
  a2[23] = _0123456789abcdef_[a1[11] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[12] >> 4];
  a2[25] = _0123456789abcdef_[a1[12] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[13] >> 4];
  a2[27] = _0123456789abcdef_[a1[13] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[14] >> 4];
  a2[29] = _0123456789abcdef_[a1[14] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[15] >> 4];
  a2[31] = _0123456789abcdef_[a1[15] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404EEAB0 (0x1404EEAB0) ---

// --- Function: sub_140535CF0 (0x140535CF0) ---
__int64 (__fastcall *__fastcall sub_140535CF0(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_140397520(0LL, "__InitializeThreadInfoBlock__", 0);
  if ( result )
  {
    return (__int64 (__fastcall *)(__int64))result(a1);
  }
  return result;
}

// --- End Function: sub_140535CF0 (0x140535CF0) ---

// --- Function: sub_140566BA0 (0x140566BA0) ---
char __fastcall sub_140566BA0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 12;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
      n2 = 26;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
    case 50:
    case 76:
      n2 = 11;
      break;
    case 54:
      n2 = 22;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 29;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 13;
      break;
    case 63:
    case 75:
      n2 = 28;
      break;
    case 64:
    case 78:
      n2 = 24;
      break;
    case 66:
    case 67:
      n2 = 27;
      break;
    case 70:
      n2 = 30;
      break;
    case 82:
    case 83:
      n2 = 15;
      break;
    case 88:
    case 89:
      n2 = 25;
      break;
    case 90:
    case 91:
      n2 = 16;
      break;
    case 92:
      n2 = 17;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 18;
      break;
    case 98:
    case 99:
      n2 = 19;
      break;
    case 100:
      n2 = 20;
      break;
    case 101:
    case 102:
      n2 = 21;
      break;
    case 103:
      n2 = 23;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_140566BA0 (0x140566BA0) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !Parameter_3 )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = -1;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[4095] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)Parameter_3 + 280LL))(
                      Parameter_3,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: eosLogCallbackHandler (0x140BD7080) ---
// Wrapper function that forwards the log message parameters (`a1`) to the internal
// logging function `sub_140BF6410`. Used as the callback for EOS logging.
void __fastcall eosLogCallbackHandler(__int64 *log_params_ptr)
{
  __int64 v1; // [rsp+10h] [rbp+10h] BYREF

  sub_140BF6410((__int64)&v1, log_params_ptr);
}

// --- End Function: eosLogCallbackHandler (0x140BD7080) ---

// --- Function: sub_140BE7370 (0x140BE7370) ---
char __fastcall sub_140BE7370(
        int n4,
        int **p_p_n221,
        void *p_EOS_Logging,
        char *p_[$$]_$$,
        __int64 a7,
        __int64 a6,
        _QWORD *a9,
        __int64 *a10,
        __int64 *ThreadLogContextSlot,
        _QWORD *p_p_Category,
        _QWORD *a11)
{
  void *v11; // rsp
  __int64 a8; // [rsp+18h] [rbp-158h]
  __int64 a5[11]; // [rsp+30h] [rbp-140h] BYREF
  __int16 n256; // [rsp+88h] [rbp-E8h]
  __int64 n176; // [rsp+90h] [rbp-E0h]
  _QWORD *p_p_Category_1; // [rsp+98h] [rbp-D8h]
  const char *p_Text; // [rsp+A0h] [rbp-D0h]
  __int64 p_Category; // [rsp+A8h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403E6A90)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+B0h] [rbp-C0h]
  __int64 (__fastcall *p_sub_1403E6550)(__int64, double *, unsigned __int64); // [rsp+B8h] [rbp-B8h]
  __int64 v22; // [rsp+C0h] [rbp-B0h]
  bool (__fastcall *p_sub_1403E2AB0)(__int64, __int64); // [rsp+C8h] [rbp-A8h]
  __int64 v24; // [rsp+D0h] [rbp-A0h]
  __int64 (__fastcall *p_sub_1403E02E0)(const void **); // [rsp+D8h] [rbp-98h]
  _QWORD *(__fastcall *p_sub_1403DFFF0)(_QWORD *); // [rsp+E0h] [rbp-90h]
  __int64 v27; // [rsp+E8h] [rbp-88h]
  char v28; // [rsp+F0h] [rbp-80h]
  char v29; // [rsp+F1h] [rbp-7Fh]
  __int64 n24; // [rsp+F8h] [rbp-78h]
  _QWORD *v31; // [rsp+100h] [rbp-70h]
  Message **p_Message; // [rsp+108h] [rbp-68h]
  __int64 v33; // [rsp+110h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403E6A90_1)(__int64, __int64, unsigned __int64, __int64, char); // [rsp+118h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403E6550_1)(__int64, double *, unsigned __int64); // [rsp+120h] [rbp-50h]
  __int64 v36; // [rsp+128h] [rbp-48h]
  bool (__fastcall *p_sub_1403E2AB0_1)(__int64, __int64); // [rsp+130h] [rbp-40h]
  __int64 v38; // [rsp+138h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E02E0_1)(const void **); // [rsp+140h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403DFFF0_1)(_QWORD *); // [rsp+148h] [rbp-28h]
  __int64 v41; // [rsp+150h] [rbp-20h]
  char v42; // [rsp+158h] [rbp-18h]
  char v43; // [rsp+159h] [rbp-17h]
  __int64 n24_1; // [rsp+160h] [rbp-10h]

  v11 = alloca(320);
  a5[0] = (__int64)ThreadLogContextSlot;
  p_Text = "Text";
  a5[1] = (__int64)"TraceContext";
  n256 = 256;
  a5[3] = (__int64)sub_1403E6C00;
  a5[4] = (__int64)sub_1403E6700;
  a5[6] = (__int64)sub_1403E2C50;
  a5[8] = (__int64)sub_1403E02C0;
  a5[9] = (__int64)sub_1403DFFB0;
  p_p_Category_1 = p_p_Category;
  a5[2] = 0;
  a5[5] = 0;
  a5[7] = 0;
  a5[10] = -1;
  n176 = 176;
  v29 = 0;
  p_Category = *p_p_Category;
  p_sub_1403E6A90 = sub_1403E6A90;
  p_sub_1403E6550 = sub_1403E6550;
  p_sub_1403E2AB0 = sub_1403E2AB0;
  p_sub_1403E02E0 = sub_1403E02E0;
  p_sub_1403DFFF0 = sub_1403DFFF0;
  v31 = a11;
  v22 = 0;
  v24 = 0;
  v27 = -1;
  v28 = 0;
  n24 = 24;
  p_Message = "Message";
  v43 = 0;
  v33 = *a11;
  p_sub_1403E6A90_1 = sub_1403E6A90;
  p_sub_1403E6550_1 = sub_1403E6550;
  p_sub_1403E2AB0_1 = sub_1403E2AB0;
  p_sub_1403E02E0_1 = sub_1403E02E0;
  p_sub_1403DFFF0_1 = sub_1403DFFF0;
  LODWORD(a8) = a6;
  v36 = 0;
  v38 = 0;
  v41 = -1;
  v42 = 0;
  n24_1 = 24;
  return sub_140302350(n4, (__int64)p_p_n221, p_EOS_Logging, (__int64)p_[$$]_$$, (__int64)a5, 3, a7, a8, a9, a10);
}

// --- End Function: sub_140BE7370 (0x140BE7370) ---

// --- Function: sub_140BF6410 (0x140BF6410) ---
void __fastcall sub_140BF6410(__int64 a1, __int64 *log_params_ptr)
{
  int n400; // ecx
  int v4; // ecx
  int n100_1; // ecx
  int v6; // esi
  __int64 v7; // rax
  __int64 *ThreadLogContextSlot; // rax
  const void *ptr_to_free_2; // rcx
  int v10; // esi
  __int64 v11; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  int n7; // ecx
  __int64 v14; // rax
  int n100; // ecx
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // [rsp+28h] [rbp-31h]
  int *p_n221; // [rsp+60h] [rbp+7h] BYREF
  __int64 *v20; // [rsp+68h] [rbp+Fh]
  __int128 v21; // [rsp+70h] [rbp+17h] BYREF
  const char *p_Category_1; // [rsp+80h] [rbp+27h] BYREF
  __int64 v23; // [rsp+88h] [rbp+2Fh]
  const void *ptr_to_free_1; // [rsp+90h] [rbp+37h]
  const char *p_Category; // [rsp+98h] [rbp+3Fh] BYREF
  __int64 v26; // [rsp+A0h] [rbp+47h]
  const void *ptr_to_free; // [rsp+A8h] [rbp+4Fh]
  int n221; // [rsp+C8h] [rbp+6Fh] BYREF
  int n6; // [rsp+CCh] [rbp+73h]
  __int64 v30; // [rsp+D0h] [rbp+77h] BYREF

  n400 = *((_DWORD *)log_params_ptr + 4);
  if ( n400 > 400 )
  {
    n100 = n400 - 500;
    if ( n100 )
    {
      if ( n100 != 100 )
      {
        return;
      }
      n221 = 221;
      p_n221 = &n221;
      n6 = 6;
      v20 = &v30;
      v10 = invokeGlobalCallbackAndMaskStatusBits(7, (__int64)&p_n221, (__int64)"EOS_Logging", "[$$] $$");
      if ( (v10 & 0xFFFFF) == 0 )
      {
        return;
      }
      v16 = *log_params_ptr;
      v23 = log_params_ptr[1];
      p_Category = "Category";
      p_Category_1 = 0;
      ptr_to_free_1 = 0;
      v26 = v16;
      ptr_to_free = 0;
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      p_n221 = &n221;
      v20 = &v30;
      n7 = 7;
    }
    else
    {
      n221 = 221;
      p_n221 = &n221;
      n6 = 6;
      v20 = &v30;
      v10 = invokeGlobalCallbackAndMaskStatusBits(6, (__int64)&p_n221, (__int64)"EOS_Logging", "[$$] $$");
      if ( (v10 & 0xFFFFF) == 0 )
      {
        return;
      }
      v17 = *log_params_ptr;
      v23 = log_params_ptr[1];
      p_Category = "Category";
      p_Category_1 = 0;
      ptr_to_free_1 = 0;
      v26 = v17;
      ptr_to_free = 0;
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      p_n221 = &n221;
      v20 = &v30;
      n7 = 6;
    }
LABEL_18:
    LODWORD(v18) = v10;
    v21 = 0;
    n221 = 221;
    n6 = 6;
    sub_140BE7370(
      n7,
      &p_n221,
      "EOS_Logging",
      "[$$] $$",
      1,
      v18,
      &v21,
      0,
      ThreadLogContextSlot_1,
      &p_Category,
      &p_Category_1);
    free_memory_wrapper(ptr_to_free);
    ptr_to_free_2 = ptr_to_free_1;
    goto LABEL_19;
  }
  if ( n400 == 400 )
  {
    n221 = 221;
    p_n221 = &n221;
    n6 = 6;
    v20 = &v30;
    v10 = invokeGlobalCallbackAndMaskStatusBits(5, (__int64)&p_n221, (__int64)"EOS_Logging", "[$$] $$");
    if ( (v10 & 0xFFFFF) == 0 )
    {
      return;
    }
    v14 = *log_params_ptr;
    v23 = log_params_ptr[1];
    p_Category = "Category";
    p_Category_1 = 0;
    ptr_to_free_1 = 0;
    v26 = v14;
    ptr_to_free = 0;
    ThreadLogContextSlot_1 = getThreadLogContextSlot();
    p_n221 = &n221;
    v20 = &v30;
    n7 = 5;
    goto LABEL_18;
  }
  v4 = n400 - 100;
  if ( !v4 || (n100_1 = v4 - 100) == 0 )
  {
    n221 = 221;
    p_n221 = &n221;
    n6 = 6;
    v20 = &v30;
    v10 = invokeGlobalCallbackAndMaskStatusBits(3, (__int64)&p_n221, (__int64)"EOS_Logging", "[$$] $$");
    if ( (v10 & 0xFFFFF) == 0 )
    {
      return;
    }
    v11 = *log_params_ptr;
    v23 = log_params_ptr[1];
    p_Category = "Category";
    p_Category_1 = 0;
    ptr_to_free_1 = 0;
    v26 = v11;
    ptr_to_free = 0;
    ThreadLogContextSlot_1 = getThreadLogContextSlot();
    p_n221 = &n221;
    v20 = &v30;
    n7 = 3;
    goto LABEL_18;
  }
  if ( n100_1 == 100 )
  {
    n221 = 221;
    p_n221 = &n221;
    n6 = 6;
    v20 = &v30;
    v6 = invokeGlobalCallbackAndMaskStatusBits(4, (__int64)&p_n221, (__int64)"EOS_Logging", "[$$] $$");
    if ( (v6 & 0xFFFFF) != 0 )
    {
      v7 = *log_params_ptr;
      v26 = log_params_ptr[1];
      p_Category_1 = "Category";
      p_Category = 0;
      ptr_to_free = 0;
      v23 = v7;
      ptr_to_free_1 = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      n221 = 221;
      p_n221 = &n221;
      n6 = 6;
      v20 = &v30;
      LODWORD(v18) = v6;
      v21 = 0;
      sub_140BE7370(
        4,
        &p_n221,
        "EOS_Logging",
        "[$$] $$",
        1,
        v18,
        &v21,
        0,
        ThreadLogContextSlot,
        &p_Category_1,
        &p_Category);
      free_memory_wrapper(ptr_to_free_1);
      ptr_to_free_2 = ptr_to_free;
LABEL_19:
      free_memory_wrapper(ptr_to_free_2);
    }
  }
}

// --- End Function: sub_140BF6410 (0x140BF6410) ---

// --- Function: initializeEpicOnlineServices (0x140C02FC0) ---
// Initializes the Epic Online Services (EOS) interface. 1. Initializes the status
// structure `init_status_ptr`. 2. Copies configuration strings (product ID,
// sandbox ID, deployment ID, client ID, client secret) into `eos_config_ptr`. 3.
// Calls `EOS_Initialize` with product details. 4. Sets the EOS logging callback to
// `eosLogCallbackHandler`. 5. Sets the EOS logging level based on configuration.
// 6. Updates the status structure and logs errors if any step fails.
__int64 __fastcall initializeEpicOnlineServices(
        __int64 eos_config_ptr,
        __int64 init_status_ptr,
        const void **product_id_ptr,
        const void **sandbox_id_ptr,
        const void **deployment_id_ptr,
        const void **client_id_ptr,
        const void **client_secret_ptr)
{
  int v11; // eax
  int callback_status_bits; // ebx
  __int64 *thread_log_context_slot; // rax
  const char *error_message; // r9
  int v15; // eax
  int v16; // eax
  __int64 log_source_info_ptr; // [rsp+50h] [rbp-51h] BYREF
  __int64 *log_tags_ptr; // [rsp+58h] [rbp-49h]
  __int128 log_extra_data; // [rsp+60h] [rbp-41h] BYREF
  int eos_init_options; // [rsp+70h] [rbp-31h] BYREF
  __int64 v22; // [rsp+74h] [rbp-2Dh]
  __int64 v23; // [rsp+7Ch] [rbp-25h]
  __int64 v24; // [rsp+84h] [rbp-1Dh]
  int v25; // [rsp+8Ch] [rbp-15h]
  const CHAR *product_name; // [rsp+90h] [rbp-11h]
  const char *product_version; // [rsp+98h] [rbp-9h]
  __int128 v28; // [rsp+A0h] [rbp-1h]
  __int64 v29; // [rsp+B0h] [rbp+Fh]
  int n221; // [rsp+F0h] [rbp+4Fh] BYREF
  int n6; // [rsp+F4h] [rbp+53h]
  __int64 v32; // [rsp+F8h] [rbp+57h] BYREF

  *(_QWORD *)init_status_ptr = 0;
  initializeEmptyStringStructure((_QWORD *)(init_status_ptr + 8));
  copyStringStructure((void **)eos_config_ptr, product_id_ptr);
  copyStringStructure((void **)(eos_config_ptr + 8), sandbox_id_ptr);
  copyStringStructure((void **)(eos_config_ptr + 16), deployment_id_ptr);
  copyStringStructure((void **)(eos_config_ptr + 24), client_id_ptr);
  copyStringStructure((void **)(eos_config_ptr + 32), client_secret_ptr);
  v22 = 0;
  product_name = "StarCitizen";
  v23 = 0;
  product_version = "1.0";
  v24 = 0;
  v25 = 0;
  v28 = 0;
  v29 = 0;
  eos_init_options = 4;
  v11 = EOS_Initialize(&eos_init_options);
  if ( v11 )
  {
    *(_DWORD *)init_status_ptr = 3;
    *(_WORD *)(init_status_ptr + 4) = v11;
    assignCStringToStringStructure((void **)(init_status_ptr + 8), "EOS_Initialize failed");
    n221 = 221;
    log_source_info_ptr = (__int64)&n221;
    n6 = 6;
    log_tags_ptr = &v32;
    callback_status_bits = invokeGlobalCallbackAndMaskStatusBits(
                             3,
                             (__int64)&log_source_info_ptr,
                             (__int64)"CEpicOnlineServices::Init",
                             "EOS_Initialize failed");
    if ( (callback_status_bits & 0xFFFFF) != 0 )
    {
      thread_log_context_slot = getThreadLogContextSlot();
      error_message = "EOS_Initialize failed";
LABEL_11:
      log_source_info_ptr = (__int64)&n221;
      log_tags_ptr = &v32;
      log_extra_data = 0;
      n221 = 221;
      n6 = 6;
      submitTraceContext(
        3,
        (__int64)&log_source_info_ptr,
        "CEpicOnlineServices::Init",
        (__int64)error_message,
        1,
        callback_status_bits,
        &log_extra_data,
        0,
        (__int64)thread_log_context_slot);
    }
  }
  else
  {
    v15 = EOS_Logging_SetCallback(eosLogCallbackHandler);
    if ( v15 )
    {
      *(_DWORD *)init_status_ptr = 3;
      *(_WORD *)(init_status_ptr + 4) = v15;
      assignCStringToStringStructure((void **)(init_status_ptr + 8), "EOS_Logging_SetCallback failed");
      n221 = 221;
      log_source_info_ptr = (__int64)&n221;
      n6 = 6;
      log_tags_ptr = &v32;
      callback_status_bits = invokeGlobalCallbackAndMaskStatusBits(
                               3,
                               (__int64)&log_source_info_ptr,
                               (__int64)"CEpicOnlineServices::Init",
                               "EOS_Logging_SetCallback failed");
      if ( (callback_status_bits & 0xFFFFF) != 0 )
      {
        thread_log_context_slot = getThreadLogContextSlot();
        error_message = "EOS_Logging_SetCallback failed";
        goto LABEL_11;
      }
    }
    else
    {
      v16 = EOS_Logging_SetLogLevel(0x7FFFFFFF, 200);
      if ( v16
        || (v16 = EOS_Logging_SetLogLevel(
                    *(unsigned int *)(*(_QWORD *)(eos_config_ptr + 40) + 72LL),
                    *(unsigned int *)(*(_QWORD *)(eos_config_ptr + 40) + 112LL))) != 0 )
      {
        *(_DWORD *)init_status_ptr = 3;
        *(_WORD *)(init_status_ptr + 4) = v16;
        assignCStringToStringStructure((void **)(init_status_ptr + 8), "EOS_Logging_SetLogLevel failed");
        n221 = 221;
        log_source_info_ptr = (__int64)&n221;
        n6 = 6;
        log_tags_ptr = &v32;
        callback_status_bits = invokeGlobalCallbackAndMaskStatusBits(
                                 3,
                                 (__int64)&log_source_info_ptr,
                                 (__int64)"CEpicOnlineServices::Init",
                                 "EOS_Logging_SetLogLevel failed");
        if ( (callback_status_bits & 0xFFFFF) != 0 )
        {
          thread_log_context_slot = getThreadLogContextSlot();
          error_message = "EOS_Logging_SetLogLevel failed";
          goto LABEL_11;
        }
      }
    }
  }
  return init_status_ptr;
}

// --- End Function: initializeEpicOnlineServices (0x140C02FC0) ---

// --- Function: sub_147273B30 (0x147273B30) ---
__int64 sub_147273B30()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3400LL);
  if ( result )
  {
    return *(unsigned __int8 *)(result + 1);
  }
  return result;
}

// --- End Function: sub_147273B30 (0x147273B30) ---

// --- Function: sub_147397F30 (0x147397F30) ---
void __fastcall sub_147397F30(__int64 a1)
{
  sub_147397F40(a1);
}

// --- End Function: sub_147397F30 (0x147397F30) ---

// --- Function: sub_1473986B0 (0x1473986B0) ---
unsigned __int64 __fastcall sub_1473986B0(unsigned __int64 n0xE000, unsigned __int64 n0x10)
{
  return sub_1473986C0(n0xE000, n0x10);
}

// --- End Function: sub_1473986B0 (0x1473986B0) ---

// --- Function: sub_14739A8D0 (0x14739A8D0) ---
__int64 __fastcall sub_14739A8D0(unsigned __int64 n0x6400000)
{
  __int64 result; // rax
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1513BD53C == 1 )
  {
    sub_1417C3450(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_14981D4C4 = 1;
  ::n0x6400000 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
  {
    sub_1473755E0(n0x6400000);
  }
  n26880 = 26880;
  v5 = 0;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = 1;
  qword_149818EA0(
    &n26880,
    0,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    &p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
    0);
  sub_1473755E0(n0x6400000);
  v8 = __rdtsc();
  qword_149818EA8(&n26880);
  return result;
}

// --- End Function: sub_14739A8D0 (0x14739A8D0) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(const void *a1)
{
  if ( a1 )
  {
    if ( qword_14981D3D8 && pCZoneSystem && a1 == (const void *)pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)a1 < qword_1497CE098 || (unsigned __int64)a1 >= qword_1497CE098 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_1497CE078 && (unsigned __int64)a1 < qword_1497CE078 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      }
      sub_147397F30((__int64)a1);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: sub_14739AFC0 (0x14739AFC0) ---
__int64 __fastcall sub_14739AFC0(unsigned __int64 n0x6400000, struct _exception *n0x10)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( n0x6400000 )
  {
    v4 = sub_147273B30();
    sub_140566BA0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(n0x10);
    result = sub_1473986B0(v5 + n0x6400000, (unsigned __int64)n0x10);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(n0x6400000);
  }
  return 0LL;
}

// --- End Function: sub_14739AFC0 (0x14739AFC0) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x147DC691E) ---

// --- Function: __alloca_probe (0x147DC7830) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
  {
    StackLimit_1 = 0;
  }
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x147DC7830) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __tlregdtor (0x147DC7958) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6032);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6048);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6032) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100uLL);
    free_0(0LL);
    if ( !v3 )
    {
      return 0xFFFFFFFFLL;
    }
    v3[1] = *(_QWORD *)(v2 + 6032);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0LL;
}

// --- End Function: __tlregdtor (0x147DC7958) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memcpy (0x147E162BB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x147E162BB) ---

// --- Function: memmove (0x147E162C1) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x147E162C1) ---

// --- Function: memset (0x147E162C7) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x147E162C7) ---

// --- Function: memcmp (0x147E162E5) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x147E162E5) ---

// --- Function: free_0 (0x147E16387) ---
// attributes: thunk
void __cdecl free_0(void *Block)
{
  free(Block);
}

// --- End Function: free_0 (0x147E16387) ---

// --- Function: malloc_0 (0x147E1638D) ---
// attributes: thunk
void *__cdecl malloc_0(size_t Size)
{
  return malloc(Size);
}

// --- End Function: malloc_0 (0x147E1638D) ---

// --- Function: sub_147E52AF0 (0x147E52AF0) ---
__int64 sub_147E52AF0()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = get_tls_data_offset_784();
  free_memory_wrapper(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = get_tls_data_offset_784();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0LL;
  return result;
}

// --- End Function: sub_147E52AF0 (0x147E52AF0) ---

