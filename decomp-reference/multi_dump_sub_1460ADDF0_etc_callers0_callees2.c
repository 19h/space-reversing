// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x1460ADDF0 (sub_1460ADDF0)
//   - 0x146108820 (sub_146108820)
//   - 0x146109950 (sub_146109950)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 152
// ------------------------------------------------------------

// --- Function: _ (0x1402A08E0) ---
__int64 __fastcall _(__int64 a1)
{
  return a1;
}

// --- End Function: _ (0x1402A08E0) ---

// --- Function: _Current_set (0x1402A08F0) ---
bool __fastcall Current_set(unsigned __int8 **a1, _QWORD *a2)
{
  return (unsigned int)sub_1403DFBE0(a1, a2) == 0;
}

// --- End Function: _Current_set (0x1402A08F0) ---

// --- Function: SEntityProxy::AsJson (0x1402A0A50) ---
__int64 __fastcall SEntityProxy::AsJson(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: SEntityProxy::AsJson (0x1402A0A50) ---

// --- Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A0C60) ---
_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *__fastcall _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        _lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *this,
        const struct __crt_stdio_stream *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

// --- End Function: ??0_lambda_9a32fed5bf61b6b509b2d3f6003082a1_@@QEAA@AEBV__crt_stdio_stream@@@Z (0x1402A0C60) ---

// --- Function: sub_1402A0D40 (0x1402A0D40) ---
__int64 __fastcall sub_1402A0D40(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  result = a1;
  *(_QWORD *)(a1 + 8) = 0x1FF;
  return result;
}

// --- End Function: sub_1402A0D40 (0x1402A0D40) ---

// --- Function: sub_1402A0F30 (0x1402A0F30) ---
void __fastcall sub_1402A0F30(__int64 a1)
{
  unsigned __int64 v1; // rax
  const void *v2; // rcx

  if ( *(_QWORD *)(a1 + 0x10) != a1 + 0x18 )
  {
    v1 = 0xFFFFFFFFFFFFFFFFuLL - *(_QWORD *)(a1 + 8);
    v2 = *(const void **)(a1 + 0x10);
    qword_149808368 += v1;
    sub_14739AF10(v2);
  }
}

// --- End Function: sub_1402A0F30 (0x1402A0F30) ---

// --- Function: sub_1402A1380 (0x1402A1380) ---
__int64 *sub_1402A1380(__int64 *a1, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  unsigned __int64 n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A2470();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format, 0, va);
  Buffer[0xFFF] = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
  {
    ++n511;
  }
  while ( Buffer[n511] );
  sub_1402A1CD0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A1380 (0x1402A1380) ---

// --- Function: __StarEngineModule__ (0x1402A16B0) ---
void __fastcall _StarEngineModule__(ULONG_PTR Parameter)
{
  ;
}

// --- End Function: __StarEngineModule__ (0x1402A16B0) ---

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A1E80) ---
unsigned __int8 *__fastcall AK::WriteBytesMem::Bytes(AK::WriteBytesMem *this)
{
  return (unsigned __int8 *)*((_QWORD *)this + 2);
}

// --- End Function: ?Bytes@WriteBytesMem@AK@@UEBAPEAEXZ (0x1402A1E80) ---

// --- Function: sub_1402A2630 (0x1402A2630) ---
bool __fastcall sub_1402A2630(unsigned __int8 **a1, _QWORD *a2)
{
  return (unsigned int)sub_1403DFBE0(a1, a2) != 0;
}

// --- End Function: sub_1402A2630 (0x1402A2630) ---

// --- Function: unknown_libname_472 (0x1402AC2A0) ---
// Microsoft VisualC 64bit universal runtime
void __fastcall unknown_libname_472(_QWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

// --- End Function: unknown_libname_472 (0x1402AC2A0) ---

// --- Function: sub_1402AC3D0 (0x1402AC3D0) ---
_QWORD *__fastcall sub_1402AC3D0(_QWORD *a1, __int64 a2, __int64 a3, char a4)
{
  int v8; // esi
  unsigned __int32 v9; // eax

  *a1 = a3;
  v8 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( *(_DWORD *)(a3 + 4) == v8 )
  {
    ++*(_DWORD *)(a3 + 8);
  }
  else
  {
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a3, 1, 0);
    if ( v9 )
    {
      sub_1403BF290((volatile signed __int32 *)a3, v9, a2, a4);
    }
    *(_DWORD *)(a3 + 4) = v8;
  }
  return a1;
}

// --- End Function: sub_1402AC3D0 (0x1402AC3D0) ---

// --- Function: sub_1402AF610 (0x1402AF610) ---
void __fastcall sub_1402AF610(_QWORD *a1)
{
  *a1 = 0;
}

// --- End Function: sub_1402AF610 (0x1402AF610) ---

// --- Function: sub_1402AF7F0 (0x1402AF7F0) ---
__int64 __fastcall sub_1402AF7F0(__int64 *a1)
{
  __int64 v1; // rcx
  int v2; // eax
  __int64 result; // rax

  v1 = *a1;
  v2 = *(_DWORD *)(v1 + 8);
  if ( v2 )
  {
    result = (unsigned int)(v2 - 1);
    *(_DWORD *)(v1 + 8) = result;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = 0xFFFFFFFF;
    result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)v1, 0, 1);
    if ( (_DWORD)result != 1 )
    {
      return sub_1403D6A80((volatile signed __int32 *)v1, result);
    }
  }
  return result;
}

// --- End Function: sub_1402AF7F0 (0x1402AF7F0) ---

// --- Function: sub_1402AF8A0 (0x1402AF8A0) ---
unsigned __int64 __fastcall sub_1402AF8A0(__int64 a1)
{
  unsigned __int64 n0x200000; // rax
  __int64 v2; // rcx
  int v3; // eax

  --**(_DWORD **)(a1 + 0x10);
  n0x200000 = *(_QWORD *)(a1 + 0x10);
  if ( !*(_DWORD *)n0x200000 )
  {
    v2 = *(_QWORD *)(a1 + 8);
    v3 = *(_DWORD *)(v2 + 0xC);
    if ( v3 )
    {
      n0x200000 = (unsigned int)(v3 - 1);
      *(_DWORD *)(v2 + 0xC) = n0x200000;
    }
    else
    {
      *(_DWORD *)(v2 + 8) = 0xFFFFFFFF;
      n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v2, 0, 0x200000);
      if ( n0x200000 != 0x200000 )
      {
        return sub_1403D8A00((volatile signed __int64 *)v2, n0x200000);
      }
    }
  }
  return n0x200000;
}

// --- End Function: sub_1402AF8A0 (0x1402AF8A0) ---

// --- Function: sub_1402B05B0 (0x1402B05B0) ---
__int64 __fastcall sub_1402B05B0(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 i; // rdi
  _QWORD *ptr_to_free; // rcx
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != (_QWORD *)i; ++v1 )
    {
      DestroyStringObject(v1);
    }
    ptr_to_free = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)ptr_to_free - ptr_to_free[0xFFFFFFFF] - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      ptr_to_free = (_QWORD *)ptr_to_free[0xFFFFFFFF];
    }
    free_memory_wrapper(ptr_to_free);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1402B05B0 (0x1402B05B0) ---

// --- Function: sub_1402B07B0 (0x1402B07B0) ---
__int64 __fastcall sub_1402B07B0(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)a1 )
  {
    sub_14039EFB0(a1, *(const void **)a1, (*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_1402B07B0 (0x1402B07B0) ---

// --- Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B2B00) ---
bool __fastcall std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

// --- End Function: ??$?8$$CBU_EXCEPTION_RECORD@@$$CBU0@@std@@YA_NAEBV?$shared_ptr@$$CBU_EXCEPTION_RECORD@@@0@0@Z (0x1402B2B00) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E0110) ---
_QWORD *__fastcall std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
        _QWORD *a1,
        _QWORD *a2)
{
  *a2 = *a1;
  return a2;
}

// --- End Function: ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QEAXU_Mutex_count_pair@?A0xd833279a@@@std@@@std@@@std@@@2@XZ (0x1402E0110) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(
        __int64 callback_arg1,
        __int64 callback_arg2,
        __int64 callback_arg3,
        const char *callback_arg4,
        ...)
{
  __int64 status_bits; // rax

  if ( qword_149808980 )
  {
    status_bits = qword_149808980(callback_arg1, callback_arg2, callback_arg3, callback_arg4);
  }
  else
  {
    status_bits = 1;
  }
  if ( !qword_149808998 )
  {
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  }
  if ( !qword_1498089A0 )
  {
    return (unsigned int)status_bits & 0xFFFFFFF7;
  }
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x1402FE7C0) ---

// --- Function: sub_140302350 (0x140302350) ---
char __fastcall sub_140302350(
        int n4,
        __int64 a2,
        void *Src_1,
        __int64 a4,
        __int64 ptr_to_free_29,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 *a10)
{
  _QWORD *v10; // rdi
  __int64 *v11; // rbx
  __int64 v12; // rsi
  unsigned __int64 v13; // r13
  char result; // al
  __int64 *ptr_to_free_15; // r12
  unsigned __int64 n0x400; // rbx
  unsigned __int64 n0x10; // r14
  unsigned __int64 v18; // r15
  _QWORD *ptr_to_free_25; // rdi
  unsigned __int8 v20; // si
  bool v21; // zf
  __int64 *ptr_to_free_16; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 ptr_to_free_17; // rcx
  _QWORD *v25; // rbx
  _BYTE *v26; // rdx
  _BYTE *v27; // rdx
  unsigned __int64 v28; // r9
  __int64 (__fastcall *v29)(_QWORD, unsigned __int64 *, unsigned __int64 *, unsigned __int64); // rax
  unsigned __int64 v30; // r13
  _QWORD *ptr_to_free_20; // r14
  __int64 *p_ptr_to_free_1; // rdi
  _QWORD *v33; // rbx
  _QWORD *v34; // rax
  _BYTE *v35; // rdx
  unsigned __int64 Size_2; // rbx
  size_t Size_1; // r8
  _BYTE *v38; // r9
  __int64 v39; // rcx
  __m256 *v40; // r14
  char *v41; // r14
  __int64 ptr_to_free_18; // r12
  unsigned __int64 n0xF_1; // r13
  __m256 *ptr_to_free_1; // r15
  _QWORD **v45; // r14
  _QWORD *v46; // rbx
  __int64 Size_4; // r12
  size_t Size_3; // r8
  _QWORD *Buf1; // rcx
  __m256 *Buf2; // rdx
  __int64 v51; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 *v53; // rcx
  __int64 v54; // rcx
  _QWORD *v55; // rbx
  const void *ptr_to_free; // rcx
  __m256 *ptr_to_free_10; // rax
  __int64 *ptr_to_free_21; // rax
  __int64 *ptr_to_free_22; // r14
  __int64 ptr_to_free_23; // rcx
  _QWORD *v61; // rbx
  _BYTE *v62; // rdx
  _BYTE *v63; // rdx
  __int64 v64; // r10
  __int64 v65; // r14
  char *i; // rdi
  int v67; // r13d
  __int64 v68; // rcx
  __int64 v69; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v71; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 Size; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 ptr_to_free_11; // rax
  const void *ptr_to_free_3; // r15
  char *Buffer_1; // r14
  __int64 v79; // rax
  void *v80; // rsp
  __int64 (__fastcall *v81)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int a14; // edx
  int v83; // r12d
  char v84; // cl
  int v85; // eax
  FILE *Stream; // rax
  int n2; // r8d
  FILE *Stream_1; // rax
  char v89; // al
  bool v90; // dl
  bool v91; // cl
  unsigned __int64 *p_n0x8000_1; // rdx
  unsigned __int64 v93; // rcx
  unsigned __int64 n0x8000_2; // rbx
  __int64 ptr_to_free_12; // rax
  const void *ptr_to_free_2; // rsi
  double *Buffer_2; // r8
  __int64 v98; // rax
  void *v99; // rsp
  char v100; // dl
  FILE *Stream_2; // rax
  FILE *Stream_3; // rax
  const void **ptr_to_free_7; // rsi
  _QWORD **v104; // rcx
  _QWORD *ptr_to_free_5; // rbx
  unsigned __int64 n0xF_2; // rdx
  _QWORD *ptr_to_free_6; // rdi
  _QWORD *ptr_to_free_4; // rcx
  __int64 *ptr_to_free_9; // rbx
  _QWORD *ptr_to_free_8; // rcx
  int a19; // [rsp+90h] [rbp-10h]
  unsigned __int8 v112; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF; // [rsp+A8h] [rbp+8h]
  __int64 *ptr_to_free_14; // [rsp+B0h] [rbp+10h]
  unsigned int n4a; // [rsp+B8h] [rbp+18h]
  int v116[2]; // [rsp+C0h] [rbp+20h]
  __int64 v117; // [rsp+C8h] [rbp+28h]
  __int64 a13; // [rsp+D0h] [rbp+30h] BYREF
  struct _FILETIME FileTime; // [rsp+D8h] [rbp+38h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E0h] [rbp+40h]
  _QWORD *ptr_to_free_28; // [rsp+E8h] [rbp+48h]
  __int64 a2a; // [rsp+F0h] [rbp+50h]
  unsigned __int64 ptr_to_free_26; // [rsp+F8h] [rbp+58h] BYREF
  unsigned __int64 v124; // [rsp+100h] [rbp+60h] BYREF
  _QWORD *ptr_to_free_27; // [rsp+108h] [rbp+68h]
  __int64 v126; // [rsp+110h] [rbp+70h]
  _BYTE *Src; // [rsp+118h] [rbp+78h]
  __int64 *v128; // [rsp+120h] [rbp+80h]
  _QWORD *ptr_to_free_19; // [rsp+128h] [rbp+88h] BYREF
  __int64 *p_ptr_to_free; // [rsp+130h] [rbp+90h] BYREF
  _QWORD *ptr_to_free_24; // [rsp+138h] [rbp+98h]
  __int64 v132; // [rsp+140h] [rbp+A0h]
  __int64 n0x100000_1; // [rsp+148h] [rbp+A8h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+150h] [rbp+B0h] BYREF
  const void **ptr_to_free_13; // [rsp+158h] [rbp+B8h] BYREF
  unsigned __int64 v136; // [rsp+160h] [rbp+C0h]
  unsigned __int64 v137; // [rsp+168h] [rbp+C8h]
  __m256 v138; // [rsp+170h] [rbp+D0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+190h] [rbp+F0h] BYREF
  _QWORD v140[16]; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v141[1024]; // [rsp+220h] [rbp+180h] BYREF
  char Buffer[32]; // [rsp+2220h] [rbp+2180h] BYREF
  wchar_t Buffer_[20]; // [rsp+2240h] [rbp+21A0h] BYREF

  v10 = a9;
  v11 = a10;
  v126 = a4;
  Src = Src_1;
  v128 = (__int64 *)a2;
  n4a = n4;
  ptr_to_free_28 = (_QWORD *)ptr_to_free_29;
  if ( qword_149808918 )
  {
    v12 = qword_149808918();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  v13 = a6;
  a2a = v12;
  if ( v11 )
  {
    result = sub_1402FDA00(v12, v10, v11, ptr_to_free_29, a6);
    if ( !result )
    {
      return result;
    }
  }
  if ( qword_149808970 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149808970)(Buffer_, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_1498089E0++;
    swprintf(Buffer_, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1402FE700(Buffer, 0x20u, v12);
  ptr_to_free_13 = 0;
  ptr_to_free_15 = 0;
  p_ptr_to_free = (__int64 *)&ptr_to_free_13;
  n0x400 = 0;
  ptr_to_free_14 = 0;
  n0x10 = 0;
  n0xF = 0;
  v18 = 0;
  n0x10_1 = 0;
  v117 = 0;
  v132 = 0;
  if ( !a6 )
  {
    v65 = 0;
LABEL_106:
    i = (char *)v141;
    goto LABEL_107;
  }
  ptr_to_free_25 = ptr_to_free_28;
  v20 = v112;
  ptr_to_free_27 = ptr_to_free_28;
  while ( 2 )
  {
    v21 = *((_BYTE *)ptr_to_free_25 + 0x59) == 0;
    ptr_to_free_24 = ptr_to_free_25;
    if ( !v21 && n0x10 < 0x10 )
    {
      v140[n0x10++] = ptr_to_free_25;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    ptr_to_free_26 = (unsigned __int64)ptr_to_free_25;
    if ( n0x400 < 0x400 )
    {
      v141[n0x400] = ptr_to_free_25;
LABEL_30:
      n0xF = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_1495F6748 )
    {
      if ( !ptr_to_free_15 )
      {
        __asm { vzeroupper }
        ptr_to_free_14 = (__int64 *)allocWithoutProfiling(0x18u);
        ptr_to_free_15 = ptr_to_free_14;
        if ( ptr_to_free_14 )
        {
          ptr_to_free_16 = ptr_to_free_14;
          *ptr_to_free_14 = 0;
          n0x400_1 = 0;
          ptr_to_free_15[1] = 0;
          ptr_to_free_17 = (__int64)ptr_to_free_15;
          ptr_to_free_15[2] = 0;
        }
        else
        {
          ptr_to_free_15 = 0;
          ptr_to_free_16 = 0;
          n0x400_1 = 0;
          ptr_to_free_14 = 0;
          ptr_to_free_17 = 0;
        }
        sub_140302260(ptr_to_free_17, v13);
        v25 = v141;
        do
        {
          v26 = (_BYTE *)ptr_to_free_16[1];
          if ( v26 == (_BYTE *)ptr_to_free_16[2] )
          {
            std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
              ptr_to_free_15,
              v26,
              v25);
          }
          else
          {
            *(_QWORD *)v26 = *v25;
            ptr_to_free_16[1] += 8;
          }
          ++n0x400_1;
          ++v25;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF;
        ptr_to_free_25 = ptr_to_free_27;
      }
      v27 = (_BYTE *)ptr_to_free_15[1];
      if ( v27 == (_BYTE *)ptr_to_free_15[2] )
      {
        __asm { vzeroupper }
        std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
          ptr_to_free_15,
          v27,
          &ptr_to_free_26);
      }
      else
      {
        *(_QWORD *)v27 = ptr_to_free_25;
        ptr_to_free_15[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    __asm { vzeroupper }
    ptr_to_free_25[1] = sub_1402FD110(&p_ptr_to_free, ptr_to_free_25);
    v28 = v18;
    v29 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *, unsigned __int64))ptr_to_free_25[7];
    v137 = v18++;
    if ( !v29 )
    {
      v64 = v117;
      goto LABEL_98;
    }
    ptr_to_free_26 = 0;
    v124 = 0;
    v30 = 0;
    *(_QWORD *)v116 = v29(*ptr_to_free_25, &v124, &ptr_to_free_26, v28);
    ptr_to_free_20 = *(_QWORD **)v116;
    a13 = 0;
    if ( !v124 )
    {
      goto LABEL_94;
    }
    p_ptr_to_free_1 = p_ptr_to_free;
    do
    {
      ptr_to_free_24 = ptr_to_free_20;
      ptr_to_free_20[0xA] = v18;
      v21 = ptr_to_free_20[2] == 0;
      v136 = v18 + 1;
      if ( v21 )
      {
        v55 = (_QWORD *)ptr_to_free_20[1];
        n0x400_2 = 0;
      }
      else
      {
        if ( !*p_ptr_to_free_1 )
        {
          __asm { vzeroupper }
          v33 = (_QWORD *)allocWithoutProfiling(0x10u);
          if ( v33 )
          {
            *v33 = 0;
            v33[1] = 0;
            v34 = (_QWORD *)allocWithoutProfiling(0x30u);
            *v34 = v34;
            v34[1] = v34;
            *v33 = v34;
          }
          else
          {
            v33 = 0;
          }
          *p_ptr_to_free_1 = (__int64)v33;
        }
        v35 = (_BYTE *)ptr_to_free_20[1];
        Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&v138, 0, sizeof(v138));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
        {
          ++Size_1;
        }
        while ( v35[Size_1] );
        __asm { vzeroupper }
        sub_1402F8E30(&v138, v35, Size_1);
        v38 = (_BYTE *)ptr_to_free_20[2];
        do
        {
          ++Size_2;
        }
        while ( v38[Size_2] );
        v39 = *(_QWORD *)&v138.m256_f32[4];
        if ( Size_2 > *(_QWORD *)&v138.m256_f32[6] - *(_QWORD *)&v138.m256_f32[4] )
        {
          sub_1402A78B0((const void **)&v138, Size_2, v20, v38, Size_2);
        }
        else
        {
          v40 = &v138;
          *(_QWORD *)&v138.m256_f32[4] += Size_2;
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            v40 = *(__m256 **)v138.m256_f32;
          }
          v41 = (char *)v40 + v39;
          memmove(v41, v38, Size_2);
          v41[Size_2] = 0;
        }
        ptr_to_free_18 = *p_ptr_to_free_1;
        n0xF_1 = *(_QWORD *)&v138.m256_f32[6];
        ptr_to_free_1 = *(__m256 **)v138.m256_f32;
        ptr_to_free_19 = (_QWORD *)ptr_to_free_18;
        v45 = *(_QWORD ***)ptr_to_free_18;
        v46 = **(_QWORD ***)ptr_to_free_18;
        if ( v46 == *(_QWORD **)ptr_to_free_18 )
        {
          goto LABEL_59;
        }
        Size_4 = *(_QWORD *)&v138.m256_f32[4];
        do
        {
          Size_3 = v46[4];
          Buf1 = v46 + 2;
          Buf2 = &v138;
          if ( n0xF_1 > 0xF )
          {
            Buf2 = ptr_to_free_1;
          }
          if ( v46[5] > 0xFu )
          {
            Buf1 = (_QWORD *)*Buf1;
          }
          if ( Size_3 == Size_4 && !memcmp(Buf1, Buf2, Size_3) )
          {
            break;
          }
          v46 = (_QWORD *)*v46;
        }
        while ( v46 != v45 );
        ptr_to_free_18 = (__int64)ptr_to_free_19;
        if ( v46 == v45 )
        {
LABEL_59:
          if ( *(_QWORD *)(ptr_to_free_18 + 8) == 0x555555555555555LL )
          {
            std::_Xlength_error("list too long");
          }
          v51 = allocWithoutProfiling(0x30u);
          n0x400_2 = 0;
          *(_QWORD *)(v51 + 0x20) = 0;
          *(_QWORD *)(v51 + 0x28) = 0;
          *(__m256 *)(v51 + 0x10) = v138;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
          LOBYTE(v138.m256_f32[0]) = 0;
          ++*(_QWORD *)(ptr_to_free_18 + 8);
          v53 = v45[1];
          *(_QWORD *)v51 = v45;
          *(_QWORD *)(v51 + 8) = v53;
          v45[1] = (_QWORD *)v51;
          *v53 = v51;
          v54 = *(_QWORD *)*p_ptr_to_free_1;
          v55 = (_QWORD *)(*(_QWORD *)(v54 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v54 + 8) + 0x28LL) > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( *(_QWORD *)&v138.m256_f32[6] > 0xFu )
          {
            ptr_to_free = *(const void **)v138.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&v138.m256_f32[6] + 1LL) >= 0x1000 )
            {
              ptr_to_free = *(const void **)(*(_QWORD *)v138.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)v138.m256_f32 - (_QWORD)ptr_to_free - 8LL) > 0x1F )
              {
                goto LABEL_100;
              }
            }
            __asm { vzeroupper }
            free_memory_wrapper(ptr_to_free);
          }
          ptr_to_free_15 = ptr_to_free_14;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
          LOBYTE(v138.m256_f32[0]) = 0;
        }
        else
        {
          v55 = v46 + 2;
          if ( v55[3] > 0xFu )
          {
            v55 = (_QWORD *)*v55;
          }
          if ( n0xF_1 > 0xF )
          {
            ptr_to_free_10 = ptr_to_free_1;
            if ( n0xF_1 + 1 >= 0x1000 )
            {
              ptr_to_free_1 = *(__m256 **)&ptr_to_free_1[0xFFFFFFFF].m256_f32[6];
              if ( (unsigned __int64)((char *)ptr_to_free_10 - (char *)ptr_to_free_1 - 8) > 0x1F )
              {
LABEL_100:
                __asm { vzeroupper }
                invalid_parameter_noinfo_noreturn();
              }
            }
            free_memory_wrapper(ptr_to_free_1);
          }
          ptr_to_free_15 = ptr_to_free_14;
          n0x400_2 = 0;
          ptr_to_free_20 = *(_QWORD **)v116;
          v30 = a13;
          *(_QWORD *)&v138.m256_f32[4] = 0;
          LOBYTE(v138.m256_f32[0]) = 0;
          *(_QWORD *)&v138.m256_f32[6] = 0xF;
        }
      }
      ptr_to_free_20[1] = v55;
      n0x400 = n0xF;
      ptr_to_free_19 = ptr_to_free_20;
      if ( n0xF >= 0x400 )
      {
        if ( !byte_1495F6748 )
        {
          goto LABEL_92;
        }
        if ( !ptr_to_free_15 )
        {
          __asm { vzeroupper }
          ptr_to_free_21 = (__int64 *)allocWithoutProfiling(0x18u);
          ptr_to_free_15 = ptr_to_free_21;
          ptr_to_free_14 = ptr_to_free_21;
          if ( ptr_to_free_21 )
          {
            *ptr_to_free_21 = 0;
            ptr_to_free_22 = ptr_to_free_21;
            ptr_to_free_21[1] = 0;
            ptr_to_free_23 = (__int64)ptr_to_free_21;
            ptr_to_free_21[2] = 0;
          }
          else
          {
            ptr_to_free_15 = 0;
            ptr_to_free_14 = 0;
            ptr_to_free_22 = 0;
            ptr_to_free_23 = 0;
          }
          sub_140302260(ptr_to_free_23, a6);
          v61 = v141;
          do
          {
            v62 = (_BYTE *)ptr_to_free_22[1];
            if ( v62 == (_BYTE *)ptr_to_free_22[2] )
            {
              std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
                ptr_to_free_15,
                v62,
                v61);
            }
            else
            {
              *(_QWORD *)v62 = *v61;
              ptr_to_free_22[1] += 8;
            }
            ++n0x400_2;
            ++v61;
          }
          while ( n0x400_2 < 0x400 );
          ptr_to_free_20 = *(_QWORD **)v116;
          n0x400 = n0xF;
        }
        v63 = (_BYTE *)ptr_to_free_15[1];
        if ( v63 == (_BYTE *)ptr_to_free_15[2] )
        {
          __asm { vzeroupper }
          std::vector<vraudio::AudioBuffer const *>::_Emplace_reallocate<vraudio::AudioBuffer const *>(
            ptr_to_free_15,
            v63,
            &ptr_to_free_19);
        }
        else
        {
          *(_QWORD *)v63 = ptr_to_free_20;
          ptr_to_free_15[1] += 8;
        }
      }
      else
      {
        v141[n0xF] = ptr_to_free_20;
      }
      n0xF = ++n0x400;
LABEL_92:
      v18 = v136;
      ++v30;
      ptr_to_free_20 += 0xD;
      a13 = v30;
      *(_QWORD *)v116 = ptr_to_free_20;
    }
    while ( v30 < v124 );
    ptr_to_free_25 = ptr_to_free_27;
LABEL_94:
    v28 = v137;
    v13 = a6;
    if ( ptr_to_free_26 > 1 )
    {
      v28 = 0xFFFFFFFFFFFFFFFFuLL;
    }
    v64 = ptr_to_free_26 + v117;
    v117 += ptr_to_free_26;
LABEL_98:
    ptr_to_free_25 += 0xD;
    ptr_to_free_27 = ptr_to_free_25;
    ptr_to_free_24[0xA] = v28;
    if ( ++v132 < v13 )
    {
      n0x10 = n0x10_1;
      continue;
    }
    break;
  }
  v65 = v64;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  v117 = v64;
  if ( !ptr_to_free_15 )
  {
    goto LABEL_106;
  }
  if ( !((ptr_to_free_15[1] - *ptr_to_free_15) >> 3) )
  {
    __debugbreak();
  }
  i = (char *)*ptr_to_free_15;
  ptr_to_free_14 = ptr_to_free_15;
  n0xF = n0x400;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v117 = v64;
LABEL_107:
  __asm { vzeroupper }
  sub_1402FBC20(i, &i[8 * n0x400], (__int64)(8 * n0x400) >> 3, v112);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v71 = *(_QWORD *)&i[8 * n0x400_3];
    if ( v69 == *(_QWORD *)(v71 + 8) )
    {
      if ( ++v68 == 1 )
      {
        *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3 - 8] + 0x50LL) = 0;
      }
      *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 0x50LL) = v68;
    }
    else
    {
      v68 = 0;
      *(_QWORD *)(v71 + 0x50) = -(__int64)(*(_QWORD *)(v71 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v69 = *(_QWORD *)(*(_QWORD *)&i[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  Size = Size_0;
  n0x100000 = 0x100000;
  if ( ::n0x8000 )
  {
    n0x8000 = ::n0x8000;
  }
  n0x8000_1 = n0x8000;
  if ( ::n0x100000 )
  {
    n0x100000 = ::n0x100000;
  }
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_1495F6748 )
  {
    p_n0x8000 = &n0x8000_1;
  }
  if ( !Size_0 )
  {
    Size = (v65 + 1) << 0xA;
  }
  if ( *p_n0x8000 < Size )
  {
    Size = *p_n0x8000;
  }
  if ( Size <= n0x8000 )
  {
    ptr_to_free_3 = 0;
  }
  else
  {
    ptr_to_free_11 = allocWithoutProfiling(Size);
    ptr_to_free_3 = (const void *)ptr_to_free_11;
    if ( ptr_to_free_11 )
    {
      Buffer_1 = (char *)ptr_to_free_11;
      goto LABEL_131;
    }
  }
  v79 = Size + 0xF;
  if ( Size + 0xF < Size )
  {
    v79 = 0xFFFFFFFFFFFFFF0LL;
  }
  v80 = alloca(v79 & 0xFFFFFFFFFFFFFFF0uLL);
  Buffer_1 = (char *)&v112;
LABEL_131:
  v81 = (__int64 (__fastcall *)(__int64, _QWORD, _BYTE *, __int64 *, __int64, _QWORD *, __int64, _QWORD *, unsigned __int64, __int64 *))qword_149808988;
  a14 = 1;
  *Buffer_1 = 0;
  v83 = 0;
  LODWORD(a13) = 0;
  v116[0] = 1;
  if ( v81 && qword_149808990 && byte_1495F6748 )
  {
    a14 = v81(a2a, n4a, Src, v128, v126, ptr_to_free_28, a6, v140, n0x10_1, &a8);
    v116[0] = a14;
  }
  v84 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v85 = sub_140300090(
            FileTime.dwLowDateTime,
            a2a,
            (__int64)Buffer_,
            n4a,
            v128,
            Src,
            v126,
            ptr_to_free_28,
            a6,
            a7,
            Buffer_1,
            Size,
            (int *)&a13,
            a14,
            &a8);
    v84 = a8;
    v83 = v85;
    v67 = a13;
  }
  if ( n2_1 == 1 && (v84 & 1) != 0 )
  {
    Stream = __acrt_iob_func(1u);
    fprintf(Stream, "%s %s\n", Buffer, Buffer_1);
    v84 = a8;
  }
  n2 = n2_2;
  if ( n2_2 == 1 && (v84 & 2) != 0 )
  {
    Stream_1 = __acrt_iob_func(n2_2 + 1);
    fprintf(Stream_1, "%s %s\n", Buffer, Buffer_1);
    n2 = n2_2;
  }
  Buffer_1[v83] = 0;
  v89 = a8;
  v90 = (a8 & 1) != 0 && n2_1 == 2;
  v91 = (a8 & 2) != 0 && n2 == 2;
  if ( (a8 & 0xFFF18) != 0 || v90 || v91 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    v93 = qword_1498089C8;
    if ( !byte_1495F6748 )
    {
      p_n0x8000_1 = &n0x8000_1;
    }
    if ( !qword_1498089C8 )
    {
      v93 = v83 + ((n0xF + 2 * v117 + v117 + 0x20) << 7);
    }
    n0x8000_2 = v93 + 0x80;
    if ( *p_n0x8000_1 < v93 + 0x80 )
    {
      n0x8000_2 = *p_n0x8000_1;
    }
    if ( n0x8000_2 <= n0x8000 )
    {
      ptr_to_free_2 = 0;
    }
    else
    {
      ptr_to_free_12 = allocWithoutProfiling(n0x8000_2);
      ptr_to_free_2 = (const void *)ptr_to_free_12;
      if ( ptr_to_free_12 )
      {
        Buffer_2 = (double *)ptr_to_free_12;
        goto LABEL_167;
      }
    }
    v98 = n0x8000_2 + 0xF;
    if ( n0x8000_2 + 0xF < n0x8000_2 )
    {
      v98 = 0xFFFFFFFFFFFFFF0LL;
    }
    v99 = alloca(v98 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_2 = (double *)&v112;
LABEL_167:
    a19 = v116[0];
    *(_BYTE *)Buffer_2 = 0;
    sub_140300B90(
      *(_QWORD *)&FileTime,
      a2a,
      Buffer,
      Buffer_,
      n4a,
      v128,
      Src,
      v126,
      ptr_to_free_28,
      a6,
      a7,
      (__int64)i,
      n0xF,
      Buffer_2,
      n0x8000_2 - 0x80,
      (__int64)&Buffer_1[v67],
      v83 - v67,
      a8,
      a19);
    free_memory_wrapper(ptr_to_free_2);
    v89 = a8;
  }
  v100 = byte_149808638;
  if ( byte_149808638 )
  {
    if ( (v89 & 1) != 0 )
    {
      Stream_2 = __acrt_iob_func(1u);
      fflush(Stream_2);
      v89 = a8;
      v100 = byte_149808638;
    }
    if ( v100 )
    {
      if ( (v89 & 2) != 0 )
      {
        Stream_3 = __acrt_iob_func(2u);
        fflush(Stream_3);
      }
    }
  }
  free_memory_wrapper(ptr_to_free_3);
  ptr_to_free_7 = ptr_to_free_13;
  if ( ptr_to_free_13 )
  {
    v104 = (_QWORD **)*ptr_to_free_13;
    **((_QWORD **)*ptr_to_free_13 + 1) = 0;
    ptr_to_free_5 = *v104;
    if ( *v104 )
    {
      do
      {
        n0xF_2 = ptr_to_free_5[5];
        ptr_to_free_6 = (_QWORD *)*ptr_to_free_5;
        if ( n0xF_2 > 0xF )
        {
          ptr_to_free_4 = (_QWORD *)ptr_to_free_5[2];
          if ( n0xF_2 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)ptr_to_free_4 - ptr_to_free_4[0xFFFFFFFF] - 8 > 0x1F )
            {
              goto LABEL_191;
            }
            ptr_to_free_4 = (_QWORD *)ptr_to_free_4[0xFFFFFFFF];
          }
          free_memory_wrapper(ptr_to_free_4);
        }
        ptr_to_free_5[4] = 0;
        ptr_to_free_5[5] = 0xF;
        *((_BYTE *)ptr_to_free_5 + 0x10) = 0;
        free_memory_wrapper(ptr_to_free_5);
        ptr_to_free_5 = ptr_to_free_6;
      }
      while ( ptr_to_free_6 );
    }
    free_memory_wrapper(*ptr_to_free_7);
    free_memory_wrapper(ptr_to_free_7);
  }
  ptr_to_free_9 = ptr_to_free_14;
  if ( ptr_to_free_14 )
  {
    ptr_to_free_8 = (_QWORD *)*ptr_to_free_14;
    if ( *ptr_to_free_14 )
    {
      if ( ((ptr_to_free_14[2] - (_QWORD)ptr_to_free_8) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)ptr_to_free_8 - ptr_to_free_8[0xFFFFFFFF] - 8 > 0x1F )
        {
LABEL_191:
          invalid_parameter_noinfo_noreturn();
        }
        ptr_to_free_8 = (_QWORD *)ptr_to_free_8[0xFFFFFFFF];
      }
      free_memory_wrapper(ptr_to_free_8);
      *ptr_to_free_9 = 0;
      ptr_to_free_9[1] = 0;
      ptr_to_free_9[2] = 0;
    }
    free_memory_wrapper(ptr_to_free_9);
  }
  return result;
}

// --- End Function: sub_140302350 (0x140302350) ---

// --- Function: is_valid_handle_typeA (0x14030C820) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *packed_handle_ptr)
{
  __int64 packed_handle_value; // rbx
  __int64 handle_metadata_ptr; // rax
  __int16 metadata_type; // cx

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_metadata_ptr = get_handle_metadata_ptr(packed_handle_value & 0xFFFFFFFFFFFFLL);
  metadata_type = *(_WORD *)(handle_metadata_ptr + 4);
  if ( metadata_type == 4 || *(_WORD *)(handle_metadata_ptr + 2) != (HIWORD(packed_handle_value) & 0xFFF) )
  {
    return 0;
  }
  if ( metadata_type != 2 || *(_QWORD *)get_tls_data_offset_784() )
  {
    return check_handle_access_by_state(packed_handle_ptr) != 0;
  }
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030C820) ---

// --- Function: is_valid_handle_typeB (0x14030C8B0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *packed_handle_ptr)
{
  unsigned __int64 packed_handle_value; // r9
  __int64 handle_ptr; // r10
  unsigned __int64 handle_flags; // r9
  __int64 mask_from_flag; // rax
  __int64 handle_ptr_copy; // r10
  __int64 metadata_ptr; // rbx
  bool is_thread_state_ok; // al

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_ptr = packed_handle_value & 0xFFFFFFFFFFFFLL;
  handle_flags = HIWORD(packed_handle_value);
  if ( (handle_flags & 0xF000) != 0 )
  {
    mask_from_flag = map_flag_to_mask(0x2000u);
    metadata_ptr = handle_ptr_copy & ~(mask_from_flag - 1);
  }
  else
  {
    metadata_ptr = handle_ptr - 6;
  }
  if ( *(_WORD *)(metadata_ptr + 2) != (handle_flags & 0xFFF) )
  {
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (is_thread_state_ok = is_thread_flag_57_or_38_set()) )
  {
    is_thread_state_ok = 1;
  }
  return *(_WORD *)(metadata_ptr + 4) == 2 && is_thread_state_ok
      || check_handle_access_by_state_extended(packed_handle_ptr) != 0;
}

// --- End Function: is_valid_handle_typeB (0x14030C8B0) ---

// --- Function: Handle::ToIndex (0x14030C9A0) ---
__int64 __fastcall Handle::ToIndex(_QWORD *a1)
{
  return *a1 & 0xFFFFFFFFFFFFLL;
}

// --- End Function: Handle::ToIndex (0x14030C9A0) ---

// --- Function: check_handle_access_by_state (0x14031DD70) ---
// Checks access permissions for the provided packed handle. Retrieves handle
// metadata using `get_handle_metadata`. Validates access based on the state field
// (metadata + 4): - State 0: Returns false (invalid). - State 1: Checks if the
// handle's payload exists in a thread-local list using
// `check_thread_list_contains_value`. - State 2: Returns true if specific thread
// flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3: Checks thread
// state and compares the payload value against a constant using
// `check_thread_state_and_value_not_equal`. - Other states: Return false.
char __fastcall check_handle_access_by_state(_QWORD *packed_handle_ptr)
{
  __int64 handle_value; // rbx
  __int64 metadata_ptr; // rax
  _QWORD *payload_ptr; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  handle_value = *packed_handle_ptr & 0xFFFFFFFFFFFFLL;
  metadata_ptr = get_handle_metadata_ptr(handle_value);
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    payload_ptr_state1 = get_handle_payload_ptr(handle_value);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( *(_WORD *)(metadata_ptr + 4) == 3 )
    {
      payload_ptr = (_QWORD *)get_handle_payload_ptr(handle_value);
      return check_thread_state_and_value_not_equal(payload_ptr);
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  payload_ptr_state2 = get_handle_payload_ptr(handle_value);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: check_handle_access_by_state (0x14031DD70) ---

// --- Function: map_flag_to_mask (0x140322940) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
      {
        return 0;
      }
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( input_flag == 0x6000 )
        {
          return 0x4000000;
        }
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140322940) ---

// --- Function: sub_140338B30 (0x140338B30) ---
__int64 __fastcall sub_140338B30(__int64 a1, __int16 a2)
{
  __int64 *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v7; // rsi
  int *v8; // rbx
  int *v9; // rax
  int v10; // ebx
  int v11; // edi
  __int64 v12; // rdi
  unsigned __int8 (__fastcall *v13)(__int64, __int64, const char *); // rbx
  __int64 v14; // rax
  _BYTE v15[8]; // [rsp+20h] [rbp-38h] BYREF
  const void *v16; // [rsp+28h] [rbp-30h]
  _BYTE v17[8]; // [rsp+38h] [rbp-20h] BYREF
  const void *v18; // [rsp+40h] [rbp-18h]

  v3 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x60LL))(a1);
  v4 = *v3;
  v5 = v3[1];
  if ( *v3 == v5 )
  {
    return 0;
  }
  while ( *(_WORD *)v4 != a2 )
  {
    v4 += 0x20;
    if ( v4 == v5 )
    {
      return 0;
    }
  }
  v7 = *(_QWORD *)(v4 + 8);
  if ( !v7 )
  {
    return 0;
  }
  v8 = (int *)sub_1403D6440(v17);
  v9 = (int *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v7 + 0x18LL))(v7, v15);
  v10 = *v8;
  v11 = *v9;
  if ( v16 )
  {
    sub_14739AF10(v16);
  }
  if ( v18 )
  {
    sub_14739AF10(v18);
  }
  if ( v10 != v11 )
  {
    if ( !CSystem )
    {
      return 0;
    }
    if ( !(*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)CSystem + 0x240LL))(CSystem) )
    {
      return 0;
    }
    v12 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)CSystem + 0x240LL))(CSystem);
    v13 = *(unsigned __int8 (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)v12 + 0x100LL);
    v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
    if ( !v13(v12, v14, "SCItemInventoryContainerComponentParams") )
    {
      return 0;
    }
  }
  return v7;
}

// --- End Function: sub_140338B30 (0x140338B30) ---

// --- Function: sub_1403577C0 (0x1403577C0) ---
void **__fastcall sub_1403577C0(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149808ABC + 4;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
    {
      memcpy(*a1, *a2, Size);
    }
  }
  return a1;
}

// --- End Function: sub_1403577C0 (0x1403577C0) ---

// --- Function: CreateStringObjectFromString (0x140357920) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **__fastcall CreateStringObjectFromString(void **ppStringObjectData, _BYTE *pszInputString)
{
  unsigned __int64 inputStringLength; // rbx
  _DWORD *pAllocatedBuffer; // rax

  *ppStringObjectData = (char *)&qword_149808ABC + 4;
  if ( !pszInputString )
  {
    return ppStringObjectData;
  }
  inputStringLength = 0xFFFFFFFFFFFFFFFFuLL;
  do
  {
    ++inputStringLength;
  }
  while ( pszInputString[inputStringLength] );
  if ( (_DWORD)inputStringLength )
  {
    pAllocatedBuffer = (_DWORD *)allocWithProfilerInfo((int)inputStringLength + 9LL, 0);
    *ppStringObjectData = pAllocatedBuffer + 2;
    *pAllocatedBuffer = inputStringLength;
    pAllocatedBuffer[1] = inputStringLength;
    *((_BYTE *)*ppStringObjectData + (int)inputStringLength) = 0;
    if ( *ppStringObjectData != pszInputString )
    {
      memcpy(*ppStringObjectData, pszInputString, (int)inputStringLength);
    }
  }
  return ppStringObjectData;
}

// --- End Function: CreateStringObjectFromString (0x140357920) ---

// --- Function: initializeEmptyStringStructure (0x140357A40) ---
// Initializes the string structure pointed to by `a1` to represent an empty string
// by setting its internal pointer to the global empty string sentinel
// `qword_149808ABC + 4`.
void __fastcall initializeEmptyStringStructure(_QWORD *string_struct_ptr)
{
  *string_struct_ptr = (char *)&qword_149808ABC + 4;
}

// --- End Function: initializeEmptyStringStructure (0x140357A40) ---

// --- Function: sub_140357A70 (0x140357A70) ---
void **__fastcall sub_140357A70(void **a1, const void **a2)
{
  __int64 v4; // rdi

  *a1 = &unk_14980BB68;
  v4 = *((int *)*a2 + 0xFFFFFFFE);
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
  {
    sub_1403D9640(a1, *((int *)*a2 + 0xFFFFFFFE));
    if ( *a1 != *a2 )
    {
      memcpy(*a1, *a2, 2 * v4);
    }
  }
  return a1;
}

// --- End Function: sub_140357A70 (0x140357A70) ---

// --- Function: sub_140357E70 (0x140357E70) ---
_QWORD *__fastcall sub_140357E70(_QWORD *a1, _BYTE *a2, char a3, __int64 a4)
{
  unsigned __int64 v6; // rax
  size_t Size; // rsi
  void *v9; // rax

  *a1 = a4;
  a1[1] = a2;
  a1[2] = 0;
  if ( a3 )
  {
    free_memory_wrapper(0);
    v6 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( a2[++v6] != 0 )
    {
      ;
    }
    Size = v6 + 1;
    v9 = (void *)allocWithoutProfiling(v6 + 1);
    a1[2] = v9;
    a1[1] = v9;
    if ( Size )
    {
      if ( v9 )
      {
        if ( a2 )
        {
          memcpy(v9, a2, Size);
          return a1;
        }
        memset(v9, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
  }
  return a1;
}

// --- End Function: sub_140357E70 (0x140357E70) ---

// --- Function: sub_140358CF0 (0x140358CF0) ---
_QWORD *__fastcall sub_140358CF0(_QWORD *a1, __int64 a2, __int64 a3)
{
  _BYTE *v5; // rdi
  unsigned __int64 v6; // rax
  size_t Size; // rbx
  void *v9; // rax
  _BYTE v11[8]; // [rsp+20h] [rbp-248h] BYREF
  __int64 v12; // [rsp+28h] [rbp-240h]
  char *v13; // [rsp+30h] [rbp-238h]
  char v14; // [rsp+38h] [rbp-230h] BYREF

  v5 = *(_BYTE **)(sub_1405AC850(a2, v11) + 0x10);
  a1[1] = v5;
  *a1 = a3;
  a1[2] = 0;
  free_memory_wrapper(0);
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  while ( v5[++v6] != 0 )
  {
    ;
  }
  Size = v6 + 1;
  v9 = (void *)allocWithoutProfiling(v6 + 1);
  a1[2] = v9;
  a1[1] = v9;
  if ( Size )
  {
    if ( v9 )
    {
      if ( v5 )
      {
        memcpy(v9, v5, Size);
        goto LABEL_9;
      }
      memset(v9, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_9:
  if ( v13 != &v14 )
  {
    qword_149808368 += 0xFFFFFFFFFFFFFFFFuLL - v12;
    sub_14739AF10(v13);
  }
  return a1;
}

// --- End Function: sub_140358CF0 (0x140358CF0) ---

// --- Function: DestroyStringObject (0x14036D270) ---
// Deallocates the memory buffer associated with a string object created by
// `CreateStringObjectFromString`.  It accesses metadata stored 8 bytes before the
// provided data pointer to get the allocation base pointer required by the
// deallocation function `sub_14739AF10`.  @param ppStringObjectData Pointer to the
// variable holding the pointer to the string object's data.
void __fastcall DestroyStringObject(_QWORD *ppStringObjectData)
{
  int *pStringMetadata; // rcx

  pStringMetadata = (int *)(*ppStringObjectData - 8LL);
  if ( pStringMetadata[1] > 0 )
  {
    sub_14739AF10(pStringMetadata);
  }
}

// --- End Function: DestroyStringObject (0x14036D270) ---

// --- Function: sub_140374480 (0x140374480) ---
void **__fastcall sub_140374480(void **a1, void **a2)
{
  void *v2; // r8

  v2 = *a2;
  *a2 = *a1;
  *a1 = v2;
  if ( *((_DWORD *)*a2 + 0xFFFFFFFE) )
  {
    sub_1403E4C30(a2, 0, 0x20);
  }
  return a1;
}

// --- End Function: sub_140374480 (0x140374480) ---

// --- Function: copyStringStructure (0x1403744C0) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
void **__fastcall copyStringStructure(void **dest_string_struct_ptr, const void **src_string_struct_ptr)
{
  unsigned __int64 src_size; // rdi

  src_size = *((int *)*src_string_struct_ptr + 0xFFFFFFFE);
  sub_1403E4C30(dest_string_struct_ptr, src_size, 0x20);
  if ( src_size && *dest_string_struct_ptr != *src_string_struct_ptr )
  {
    memcpy(*dest_string_struct_ptr, *src_string_struct_ptr, src_size);
  }
  return dest_string_struct_ptr;
}

// --- End Function: copyStringStructure (0x1403744C0) ---

// --- Function: assignCStringToStringStructure (0x140374520) ---
// Assigns the content of the null-terminated C-string `a2` to the custom string
// structure pointed to by `a1`. Calculates the length of `a2` and calls
// `sub_1403D9750` to handle buffer management and copying.
void **__fastcall assignCStringToStringStructure(void **string_struct_ptr, _BYTE *c_string)
{
  unsigned __int64 c_string_length; // rax

  if ( c_string )
  {
    c_string_length = 0xFFFFFFFFFFFFFFFFuLL;
    do
    {
      ++c_string_length;
    }
    while ( c_string[c_string_length] );
    sub_1403D9750(string_struct_ptr, c_string, (int)c_string_length);
    return string_struct_ptr;
  }
  else
  {
    sub_1403D9750(string_struct_ptr, 0, 0);
    return string_struct_ptr;
  }
}

// --- End Function: assignCStringToStringStructure (0x140374520) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037C210) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
  {
    return 0;
  }
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
         global_validator_object,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
  {
    return 0;
  }
  if ( n4 != 2 || *(_QWORD *)get_tls_data_offset_784() )
  {
    return check_indirect_handle_access_by_state(a1) != 0;
  }
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037C210) ---

// --- Function: check_handle_access_by_state_extended (0x14038E620) ---
// Checks access permissions for the provided packed handle using extended logic.
// Calculates the metadata pointer based on high bits in the packed handle.
// Validates access based on the state field (metadata + 4): - State 0: Returns
// false (invalid). - State 1: Checks if the handle's payload exists in a thread-
// local list using `check_thread_list_contains_value`. - State 2: Returns true if
// specific thread flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3 or 4: Returns
// true if thread data exists, its status field at +8 is 1, and the payload value
// is not equal to the constant 0x13374770CLL. - Other states: Return false.
char __fastcall check_handle_access_by_state_extended(_QWORD *packed_handle_ptr)
{
  _QWORD *handle_payload_ptr; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  handle_payload_ptr = (_QWORD *)(*packed_handle_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*packed_handle_ptr & 0xF000000000000000uLL) != 0 )
  {
    metadata_ptr = *packed_handle_ptr & 0xFFFFFF000000LL;
  }
  else
  {
    metadata_ptr = (__int64)handle_payload_ptr + 0xFFFFFFFA;
  }
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value((__int64)handle_payload_ptr);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(metadata_ptr + 4) - 3 <= 1 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 0x10) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *handle_payload_ptr != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls((__int64)handle_payload_ptr);
  }
}

// --- End Function: check_handle_access_by_state_extended (0x14038E620) ---

// --- Function: sub_140396030 (0x140396030) ---
char __fastcall sub_140396030(float *a1, float *a2)
{
  float v11; // xmm6_4
  float v14; // kr00_4

  if ( *a1 == 0.0 && a1[1] == 0.0 && a1[2] == 0.0 )
  {
    return 1;
  }
  _XMM2 = *(unsigned int *)a2;
  __asm
  {
    vmaxss  xmm0, xmm2, xmm4
    vmaxss  xmm5, xmm0, xmm3
    vminss  xmm1, xmm2, xmm4
  }
  __asm { vminss  xmm8, xmm1, xmm3 }
  _XMM3 = *((unsigned int *)a1 + 1);
  __asm
  {
    vmaxss  xmm0, xmm3, xmm7
    vmaxss  xmm4, xmm0, xmm2
  }
  v11 = (float)((float)((float)(*(float *)&_XMM2 + a2[1]) + a2[2]) - *(float *)&_XMM5) - *(float *)&_XMM8;
  __asm { vminss  xmm1, xmm3, xmm7 }
  __asm { vminss  xmm9, xmm1, xmm2 }
  v14 = (float)((float)((float)(*(float *)&_XMM3 + *a1) + a1[2]) - *(float *)&_XMM4) - *(float *)&_XMM9;
  if ( *(float *)&_XMM8 != *(float *)&_XMM9 )
  {
    if ( *(float *)&_XMM8 > *(float *)&_XMM9 )
    {
      return 0;
    }
    goto LABEL_10;
  }
  if ( v11 != v14 )
  {
LABEL_10:
    if ( v11 > v14 )
    {
      return 0;
    }
    return *(float *)&_XMM5 <= *(float *)&_XMM4;
  }
  if ( *(float *)&_XMM5 == *(float *)&_XMM4 )
  {
    return 0;
  }
  return *(float *)&_XMM5 <= *(float *)&_XMM4;
}

// --- End Function: sub_140396030 (0x140396030) ---

// --- Function: sub_140396410 (0x140396410) ---
char __fastcall sub_140396410(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // eax
  double v8; // xmm0_8
  int v9; // eax
  __int64 v10; // [rsp+20h] [rbp-28h] BYREF
  int v11; // [rsp+28h] [rbp-20h]
  double v12; // [rsp+30h] [rbp-18h] BYREF
  int v13; // [rsp+38h] [rbp-10h]

  if ( a3 && a5 + a4 - a6 > a3 )
  {
    return 0;
  }
  v7 = *((_DWORD *)a2 + 2);
  v10 = *a2;
  v8 = *(double *)a1;
  v11 = v7;
  v9 = *(_DWORD *)(a1 + 8);
  v12 = v8;
  v13 = v9;
  return sub_140396030((float *)&v12, (float *)&v10);
}

// --- End Function: sub_140396410 (0x140396410) ---

// --- Function: sub_1403A6BF0 (0x1403A6BF0) ---
void **__fastcall sub_1403A6BF0(void **a1, char **rdx0, char **a3)
{
  unsigned int n0xC_2; // ebx
  unsigned int n0xC_1; // ebp
  unsigned __int64 n0xC; // rdx
  unsigned __int64 v9; // rcx
  unsigned int n0xB; // r10d
  unsigned __int64 i; // rcx
  __int64 v12; // r9
  _BYTE v14[8]; // [rsp+20h] [rbp-48h] BYREF
  char a2[16]; // [rsp+28h] [rbp-40h] BYREF

  n0xC_2 = *((_DWORD *)*rdx0 + 0xFFFFFFFE);
  n0xC_1 = *((_DWORD *)*a3 + 0xFFFFFFFE);
  *a1 = (char *)&qword_149808ABC + 4;
  n0xC = *((int *)*rdx0 + 0xFFFFFFFE);
  if ( n0xC < *((int *)*a3 + 0xFFFFFFFE) )
  {
    n0xC = *((int *)*a3 + 0xFFFFFFFE);
  }
  if ( n0xC < 0xC )
  {
    n0xC = 0xC;
  }
  sub_1403E4500(a1, n0xC + 1);
  if ( n0xC_2 <= 0xC )
  {
    if ( n0xC_1 <= 0xC )
    {
      v9 = *(_QWORD *)(*(__int64 (__fastcall **)(_QWORD, _BYTE *))(*(_QWORD *)qword_14981D260 + 0x50LL))(
                        qword_14981D260,
                        v14);
      memset(a2, 0x61, 0xC);
      if ( v9 <= 0xD3E514E070E9FFFLL )
      {
        n0xB = 0xB;
        for ( i = v9 / 0xA; i; i /= 0x1Au )
        {
          v12 = n0xB--;
          a2[v12] = i % 0x1A + 0x61;
        }
      }
      sub_1403DB450(a1, a2, 0xCu);
    }
    else
    {
      sub_1403DB450(a1, *a3, 0xCu);
    }
  }
  else
  {
    sub_1403DB450(a1, *rdx0, 0xCu);
  }
  sub_1403A6E20(a1);
  return a1;
}

// --- End Function: sub_1403A6BF0 (0x1403A6BF0) ---

// --- Function: sub_1403A6DB0 (0x1403A6DB0) ---
void **__fastcall sub_1403A6DB0(void **a1)
{
  char *v3; // [rsp+30h] [rbp+8h] BYREF
  char *v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = (char *)&qword_149808ABC + 4;
  v3 = (char *)&qword_149808ABC + 4;
  sub_1403A6BF0(a1, &v3, &v4);
  if ( *((int *)v3 + 0xFFFFFFFF) > 0 )
  {
    sub_14739AF10(v3 + 0xFFFFFFF8);
  }
  if ( *((int *)v4 + 0xFFFFFFFF) > 0 )
  {
    sub_14739AF10(v4 + 0xFFFFFFF8);
  }
  return a1;
}

// --- End Function: sub_1403A6DB0 (0x1403A6DB0) ---

// --- Function: sub_1403A6E20 (0x1403A6E20) ---
void __fastcall sub_1403A6E20(void **a1, __int64 rdx0, _BYTE *a3)
{
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rbp
  int v6; // r12d
  _BYTE *v7; // r15
  __int64 v8; // r13
  char n0x61_2; // di
  char n0x61_1; // bl
  _BYTE *v11; // rsi
  char *i; // rsi
  char n0x61; // [rsp+78h] [rbp+20h] BYREF

  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  v4 = 0xFFFFFFFFFFFFFFFFuLL;
  do
  {
    ++v4;
  }
  while ( *(_BYTE *)(rdx0 + v4) );
  do
  {
    ++v3;
  }
  while ( a3[v3] );
  v6 = 0;
  v7 = a3;
  v8 = rdx0 - (_QWORD)a3;
  while ( 1 )
  {
    n0x61_2 = v6 >= v4 ? 0x60 : v7[v8];
    n0x61_1 = v6 >= v3 ? 0x7B : *v7;
    if ( n0x61_2 != n0x61_1 )
    {
      break;
    }
    n0x61 = n0x61_2;
    sub_1403DB450(a1, &n0x61, 1u);
    ++v6;
    ++v7;
  }
  if ( n0x61_2 == 0x60 )
  {
    if ( n0x61_1 == 0x61 )
    {
      v11 = &a3[v6];
      do
      {
        n0x61 = 0x61;
        sub_1403DB450(a1, &n0x61, 1u);
        n0x61_1 = *++v11;
        if ( !n0x61_1 )
        {
          goto LABEL_20;
        }
      }
      while ( n0x61_1 == 0x61 );
    }
    if ( n0x61_1 == 0x62 )
    {
      n0x61 = 0x61;
      sub_1403DB450(a1, &n0x61, 1u);
LABEL_20:
      n0x61_1 = 0x7B;
    }
  }
  else if ( n0x61_2 + 1 == n0x61_1 )
  {
    n0x61 = n0x61_2;
    n0x61_1 = 0x7B;
    sub_1403DB450(a1, &n0x61, 1u);
    for ( i = (char *)(v6 + rdx0 + 1); ; ++i )
    {
      n0x61_2 = *i;
      if ( !*i )
      {
        break;
      }
      if ( n0x61_2 != 0x7A )
      {
        goto LABEL_27;
      }
      n0x61 = 0x7A;
      sub_1403DB450(a1, &n0x61, 1u);
    }
    n0x61_2 = 0x60;
  }
LABEL_27:
  n0x61 = n0x61_1 - (n0x61_1 - n0x61_2) / 2;
  sub_1403DB450(a1, &n0x61, 1u);
}

// --- End Function: sub_1403A6E20 (0x1403A6E20) ---

// --- Function: sub_1403A7040 (0x1403A7040) ---
__int64 *__fastcall sub_1403A7040(__int64 *a1)
{
  __int64 v2; // rax
  __int64 v4; // [rsp+48h] [rbp+10h] BYREF

  if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) )
  {
    if ( (dword_14980BAD8 & 1) == 0 )
    {
      dword_14980BAD8 |= 1u;
      (*(void (__fastcall **)(__int64, __int64 *, char *))(*(_QWORD *)qword_14981D218 + 0x28LL))(
        qword_14981D218,
        &qword_14980BAD0,
        off_1495F7FC8[0]);                      // "Item.Inventory.OnlyAllowedInPersonalInventory"
    }
    v2 = qword_14980BAD0;
    if ( (_WORD)qword_14980BAD0 == 0xFFFF )
    {
      sub_1405BD4A0(
        0xAu,
        2u,
        "[%s] Could not find the allowed only in personal inventory entity tag %s",
        "InventoryUtils::GetAllowedOnlyInPersonalInventoryEntityTag",
        off_1495F7FC8[0]);                      // "Item.Inventory.OnlyAllowedInPersonalInventory"
      *a1 = qword_14980BAD0;
      return a1;
    }
  }
  else
  {
    (*(void (__fastcall **)(__int64, __int64 *, char *))(*(_QWORD *)qword_14981D218 + 0x28LL))(
      qword_14981D218,
      &v4,
      off_1495F7FC8[0]);                        // "Item.Inventory.OnlyAllowedInPersonalInventory"
    v2 = v4;
    if ( (_WORD)v4 == 0xFFFF )
    {
      sub_1405BD4A0(
        0xAu,
        2u,
        "[%s] Could not find the  allowed only in personal inventory  entity tag %s",
        "InventoryUtils::GetAllowedOnlyInPersonalInventoryEntityTag",
        off_1495F7FC8[0]);                      // "Item.Inventory.OnlyAllowedInPersonalInventory"
      v2 = v4;
    }
  }
  *a1 = v2;
  return a1;
}

// --- End Function: sub_1403A7040 (0x1403A7040) ---

// --- Function: sub_1403AA300 (0x1403AA300) ---
__int64 sub_1403AA300()
{
  __int64 result; // rax
  void **ptr_to_free; // rbx
  signed __int64 v2; // rdi

  result = qword_14980B9D8;
  if ( !qword_14980B9D8 )
  {
    ptr_to_free = (void **)allocWithoutProfiling(8u);
    if ( ptr_to_free )
    {
      *ptr_to_free = &unk_14980BB68;
      sub_1403D97F0(ptr_to_free, (void *)&Source_, 0);
    }
    else
    {
      ptr_to_free = 0;
    }
    v2 = _InterlockedCompareExchange64(&qword_14980B9D8, (signed __int64)ptr_to_free, 0);
    if ( v2 )
    {
      if ( ptr_to_free )
      {
        if ( *((int *)*ptr_to_free + 0xFFFFFFFF) > 0 )
        {
          sub_14739AF10((char *)*ptr_to_free + 0xFFFFFFF8);
        }
        free_memory_wrapper(ptr_to_free);
      }
      return v2;
    }
    else
    {
      return qword_14980B9D8;
    }
  }
  return result;
}

// --- End Function: sub_1403AA300 (0x1403AA300) ---

// --- Function: sub_1403AC900 (0x1403AC900) ---
_QWORD *__fastcall sub_1403AC900(unsigned __int64 *a1, _QWORD *a2)
{
  if ( is_valid_handle_typeB(a1) )
  {
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1403AC900 (0x1403AC900) ---

// --- Function: sub_1403ADFC0 (0x1403ADFC0) ---
__int64 __fastcall sub_1403ADFC0(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  double v7; // [rsp+20h] [rbp-18h]
  float v8; // [rsp+28h] [rbp-10h]
  char v9; // [rsp+40h] [rbp+8h] BYREF
  unsigned __int64 v10; // [rsp+48h] [rbp+10h] BYREF

  v10 = a2;
  if ( !is_valid_handle_typeB(&v10) )
  {
    goto LABEL_7;
  }
  v4 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL) + 0x20LL))(a2 & 0xFFFFFFFFFFFFLL);
  if ( !v4 )
  {
    goto LABEL_7;
  }
  if ( n0xFFFF_23 == (__int16)0xFFFF )
  {
    n0xFFFF_23 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                    + 0x10LL))(
                             global_dispatcher_ptr,
                             &v9,
                             "AttachableComponent");
  }
  v5 = sub_140303E90(v4);
  if ( v5 )
  {
    v7 = *(double *)(v5 + 0x190);
    v8 = *(float *)(v5 + 0x198);
  }
  else
  {
LABEL_7:
    v8 = 1.0;
    v7 = 0.007812501848093234;
  }
  *(double *)a1 = v7;
  *(float *)(a1 + 8) = v8;
  return a1;
}

// --- End Function: sub_1403ADFC0 (0x1403ADFC0) ---

// --- Function: sub_1403B05B0 (0x1403B05B0) ---
_QWORD *__fastcall sub_1403B05B0(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v4; // rdi
  __int64 (__fastcall *v5)(__int64, _BYTE *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v7; // rdi
  __int64 v8; // rax
  __int16 n4; // dx
  __int64 v10; // rdi
  __int64 v11; // rcx
  __int64 v12; // rax
  _QWORD *result; // rax
  __int64 v14; // [rsp+20h] [rbp-28h] BYREF
  _BYTE v15[32]; // [rsp+28h] [rbp-20h] BYREF
  unsigned __int64 v16; // [rsp+58h] [rbp+10h] BYREF
  __int16 n0xFFFF_1; // [rsp+60h] [rbp+18h] BYREF
  char v18; // [rsp+68h] [rbp+20h] BYREF

  v16 = a2;
  if ( !is_valid_handle_typeB(&v16) )
  {
    goto LABEL_13;
  }
  v4 = a2 & 0xFFFFFFFFFFFFLL;
  v5 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int16 *))(*(_QWORD *)v4 + 0x338LL);
  n0xFFFF = n0xFFFF_24;
  if ( n0xFFFF_24 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                 + 0x10LL))(
                          global_dispatcher_ptr,
                          &v18,
                          "IAttachableComponent");
    n0xFFFF_24 = n0xFFFF;
  }
  if ( (n0xFFFF_1 = n0xFFFF, v7 = *(_QWORD *)v5(v4, v15, &n0xFFFF_1), (v14 = v7) != 0)
    && (v8 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
               global_validator_object,
               v7 & 0xFFFFFFFFFFFFLL,
               0),
        n4 = *(_WORD *)(v8 + 4),
        n4 != 4)
    && *(_WORD *)(v8 + 2) == (HIWORD(v7) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_indirect_handle_access_by_state(&v14))
    && (v10 = v7 & 0xFFFFFFFFFFFFLL) != 0
    && (v11 = *(_QWORD *)((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x570LL))(v10) + 0x160)) != 0 )
  {
    v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x40LL))(v11);
    *a1 = off_147F3F7D8;
    a1[2] = v12;
    result = a1;
    a1[1] = off_147F3F7A8;
  }
  else
  {
LABEL_13:
    result = a1;
    *a1 = off_147F3F7D8;
    a1[1] = off_147F3F7A8;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: sub_1403B05B0 (0x1403B05B0) ---

// --- Function: get_handle_metadata_ptr (0x1403B0A30) ---
// Retrieves a pointer to the metadata structure associated with the given handle.
// Calls the virtual function at offset +296 on the global object
// `global_validator_object`, passing the handle.
__int64 __fastcall get_handle_metadata_ptr(__int64 handle_value)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 0x128LL))(
           global_validator_object,
           handle_value,
           0);
}

// --- End Function: get_handle_metadata_ptr (0x1403B0A30) ---

// --- Function: sub_1403B6270 (0x1403B6270) ---
__int64 __fastcall sub_1403B6270(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)qword_14981D218 + 0x110LL))(
           qword_14981D218,
           a1,
           a2);
}

// --- End Function: sub_1403B6270 (0x1403B6270) ---

// --- Function: sub_1403BB9F0 (0x1403BB9F0) ---
bool __fastcall sub_1403BB9F0(_QWORD *a1)
{
  return *(_DWORD *)(*a1 - 8LL) == 0;
}

// --- End Function: sub_1403BB9F0 (0x1403BB9F0) ---

// --- Function: sub_1403BBB00 (0x1403BBB00) ---
bool __fastcall sub_1403BBB00(__int64 a1)
{
  __int64 v1; // r8
  unsigned __int64 v3; // [rsp+30h] [rbp+8h] BYREF
  char v4; // [rsp+38h] [rbp+10h] BYREF

  if ( !a1 )
  {
    return 0;
  }
  (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)global_validator_object + 0x120LL))(
    global_validator_object,
    &v3,
    a1);
  if ( !is_valid_handle_typeB(&v3) )
  {
    return 0;
  }
  (*(void (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_14981D218 + 0x28LL))(
    qword_14981D218,
    &v4,
    "Item.Inventory.Unlootable");
  LOBYTE(v1) = 1;
  return (*(unsigned __int8 (__fastcall **)(unsigned __int64, char *, __int64))(*(_QWORD *)(v3 & 0xFFFFFFFFFFFFLL)
                                                                              + 0x618LL))(
           v3 & 0xFFFFFFFFFFFFLL,
           &v4,
           v1) != 0;
}

// --- End Function: sub_1403BBB00 (0x1403BBB00) ---

// --- Function: sub_1403D6440 (0x1403D6440) ---
__int64 __fastcall sub_1403D6440(__int64 a1)
{
  int v1; // edi
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  double *v6; // rax
  __int64 result; // rax

  v1 = dword_14980B71C;
  if ( !dword_14980B71C )
  {
    v3 = sub_1402D09F0(0x46u, 8, 0, 2);
    v4 = sub_1402C7FC0(0x4C11DB7, 1, (v3 << 0x19) ^ (unsigned int)((unsigned __int64)(v3 << 0x18) >> 0x1F) & 0x4C11DB7);
    v5 = sub_1402D09F0(v4 >> 1, 0x20, v4 << 0x1F, 2);
    v1 = sub_1402DFCB0((unsigned __int8 *)"CItemInventoryContainerComponentParams", v5 ^ 0xFFFFFFu);
    v6 = (double *)allocWithProfilerInfo(0x28u, 0);
    *(__m256i *)v6 = *(__m256i *)"SCItemInventoryContainerComponentParams";
    v6[4] = *(double *)"tParams";
    dword_14980B71C = v1;
    if ( v6 )
    {
      __asm { vzeroupper }
      sub_14739AF10(v6);
      v1 = dword_14980B71C;
    }
  }
  *(_DWORD *)a1 = v1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  result = a1;
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1403D6440 (0x1403D6440) ---

// --- Function: sub_1403D85B0 (0x1403D85B0) ---
signed __int64 __fastcall sub_1403D85B0(
        volatile signed __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_tls_data_offset_784() + 0x1C) && qword_14981D3D8 )
  {
    return sub_1403D8640(a1, a2);
  }
  else
  {
    return sub_1403D8810(a1, a2);
  }
}

// --- End Function: sub_1403D85B0 (0x1403D85B0) ---

// --- Function: sub_1403D8A00 (0x1403D8A00) ---
__int64 __fastcall sub_1403D8A00(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdi
  unsigned int v5; // edx
  signed __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rdi
  __int64 v9; // r8
  int v10; // ecx
  __int64 v11; // r8
  unsigned __int64 v12; // rbx
  int v13; // [rsp+70h] [rbp+8h] BYREF
  int v14; // [rsp+78h] [rbp+10h] BYREF
  __int64 v15; // [rsp+80h] [rbp+18h] BYREF
  __int64 v16; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFFFFD003FFuLL;
    if ( (a2 & 0xFFFF00100000LL) != 0 )
    {
      v4 = a2 & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (a2 & 0xFFC003FF) == 0 && (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v16,
        &v14);
      v4 = a2 & 0xFFFFFFD003FFLL;
      v5 = *(_DWORD *)(0xC0 * (HIWORD(a2) & (unsigned int)(v14 - 1)) + v16 + 0x24);
      if ( v5 != 0xFFFFFFFF )
      {
        v4 |= (unsigned __int64)v5 << 0x30;
      }
    }
    v6 = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == v6 )
    {
      break;
    }
    a2 = v6;
  }
  if ( (a2 & 0x3FF) != 0 )
  {
    if ( (a2 & 0x100000) != 0 )
    {
      qword_149808B98(a1);
    }
    result = 0xFFFF00000000LL;
    if ( (a2 & 0xFFFF00000000LL) != 0 )
    {
      v8 = qword_14981D318;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v15,
        &v13);
      v9 = v15 + 0xC0 * (WORD2(a2) & (unsigned __int64)(unsigned int)(v13 - 1));
      LODWORD(a2) = *(_DWORD *)(v9 + 0x24);
      *(_DWORD *)(v9 + 0x1C) = (unsigned __int16)(WORD2(a2) + v13);
      for ( result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8);
            (_DWORD)a2 != 0xFFFFFFFF;
            result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 0xD8LL))(v8) )
      {
        v10 = (unsigned __int16)(a2 + v13);
        v11 = v15 + 0xC0LL * ((unsigned int)a2 & (v13 - 1));
        LODWORD(a2) = *(_DWORD *)(v11 + 0x24);
        *(_DWORD *)(v11 + 0x1C) = v10;
      }
    }
  }
  else
  {
    result = 0xFFC00000LL;
    if ( (a2 & 0xFFC00000) != 0 )
    {
      return qword_149808B90(a1);
    }
    else if ( (a2 & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_14981D318 + 0xF8LL))(
        qword_14981D318,
        &v15,
        &v13);
      v12 = HIWORD(a2);
      *(_DWORD *)(0xC0LL * ((unsigned int)v12 & (v13 - 1)) + v15 + 0x1C) = (unsigned __int16)(v12 + v13);
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_14981D318 + 0xD8LL))(
               qword_14981D318,
               (unsigned int)v12);
    }
  }
  return result;
}

// --- End Function: sub_1403D8A00 (0x1403D8A00) ---

// --- Function: sub_1403D9750 (0x1403D9750) ---
void *__fastcall sub_1403D9750(void **a1, void *a2, size_t Size)
{
  char *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = (char *)*a1;
  if ( Size > *((int *)v5 + 0xFFFFFFFF) )
  {
    v7 = (int *)(v5 + 0xFFFFFFF8);
    if ( v7[1] > 0 )
    {
      sub_14739AF10(v7);
    }
    *a1 = (char *)&qword_149808ABC + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
  {
    memcpy(*a1, a2, Size);
  }
  *((_DWORD *)*a1 + 0xFFFFFFFE) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403D9750 (0x1403D9750) ---

// --- Function: sub_1403DB450 (0x1403DB450) ---
void __fastcall sub_1403DB450(void **a1, char *a2, size_t Size)
{
  char *v4; // rbp
  __int64 Size_1; // r13
  unsigned __int64 n8; // r15
  _DWORD *v9; // rax
  char *v10; // rcx

  if ( Size )
  {
    v4 = (char *)*a1;
    Size_1 = *((int *)*a1 + 0xFFFFFFFE);
    if ( Size + Size_1 <= *((int *)*a1 + 0xFFFFFFFF) )
    {
      if ( &v4[Size_1] != a2 )
      {
        memcpy(&v4[Size_1], a2, Size);
      }
      *((_DWORD *)*a1 + 0xFFFFFFFE) += Size;
      *((_BYTE *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= Size + Size_1 )
      {
        n8 = Size + Size_1;
      }
      if ( n8 )
      {
        if ( n8 < 8 )
        {
          n8 = 8;
        }
        v9 = (_DWORD *)allocWithProfilerInfo(n8 + 9, 0);
        *a1 = v9 + 2;
        *v9 = n8;
        v9[1] = n8;
        *((_BYTE *)*a1 + n8) = 0;
        if ( *a1 != v4 )
        {
          memcpy(*a1, v4, Size_1);
        }
        v10 = (char *)*a1 + Size_1;
        if ( v10 != a2 )
        {
          memcpy(v10, a2, Size);
        }
        *((_DWORD *)*a1 + 0xFFFFFFFE) = Size + Size_1;
        *((_BYTE *)*a1 + Size_1 + Size) = 0;
      }
      if ( *((int *)v4 + 0xFFFFFFFF) > 0 )
      {
        sub_14739AF10(v4 + 0xFFFFFFF8);
      }
    }
  }
}

// --- End Function: sub_1403DB450 (0x1403DB450) ---

// --- Function: sub_1403DFBE0 (0x1403DFBE0) ---
__int64 __fastcall sub_1403DFBE0(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
    {
      break;
    }
    ++v2;
    if ( !v4 )
    {
      return 0;
    }
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403DFBE0 (0x1403DFBE0) ---

// --- Function: sub_1403E1BB0 (0x1403E1BB0) ---
unsigned __int64 __fastcall sub_1403E1BB0(unsigned __int64 *a1)
{
  if ( is_valid_handle_typeB(a1) )
  {
    return *a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_1403E1BB0 (0x1403E1BB0) ---

// --- Function: sub_1403E4500 (0x1403E4500) ---
void __fastcall sub_1403E4500(void **a1, unsigned __int64 a2)
{
  _BYTE *v2; // rdi
  unsigned __int64 v5; // rcx
  _DWORD *v6; // rax

  v2 = *a1;
  v5 = *((int *)*a1 + 0xFFFFFFFF);
  if ( a2 > v5 )
  {
    if ( a2 )
    {
      v6 = (_DWORD *)allocWithProfilerInfo(a2 + 9, 0);
      *a1 = v6 + 2;
      *v6 = a2;
      v6[1] = a2;
      *((_BYTE *)*a1 + a2) = 0;
    }
    else
    {
      *a1 = (char *)&qword_149808ABC + 4;
    }
    if ( *a1 != v2 )
    {
      memcpy(*a1, v2, *((int *)v2 + 0xFFFFFFFE));
    }
    *((_DWORD *)*a1 + 0xFFFFFFFE) = *((_DWORD *)v2 + 0xFFFFFFFE);
    *((_BYTE *)*a1 + *((int *)v2 + 0xFFFFFFFE)) = 0;
LABEL_12:
    if ( *((int *)v2 + 0xFFFFFFFF) > 0 )
    {
      sub_14739AF10(v2 + 0xFFFFFFF8);
    }
    return;
  }
  if ( !a2 && *((_DWORD *)v2 + 0xFFFFFFFE) != (_DWORD)v5 )
  {
    sub_1403D95E0((char **)a1, *((int *)v2 + 0xFFFFFFFE));
    if ( *a1 != v2 )
    {
      memcpy(*a1, v2, *((int *)v2 + 0xFFFFFFFE));
    }
    goto LABEL_12;
  }
}

// --- End Function: sub_1403E4500 (0x1403E4500) ---

// --- Function: sub_1403E4C30 (0x1403E4C30) ---
__int64 __fastcall sub_1403E4C30(void **a1, unsigned __int64 a2, char Val)
{
  _DWORD *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx
  __int64 result; // rax

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 + 0xFFFFFFFE);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
    {
      return result;
    }
    v3[0xFFFFFFFE] = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
  {
    return result;
  }
  if ( a2 <= (int)v3[0xFFFFFFFF] )
  {
    memset((char *)v3 + v6, Val, Size);
    *((_DWORD *)*a1 + 0xFFFFFFFE) = v6 + Size;
LABEL_11:
    result = *((int *)*a1 + 0xFFFFFFFE);
    *((_BYTE *)*a1 + result) = 0;
    return result;
  }
  sub_1403D95E0((char **)a1, a2);
  if ( *a1 != v3 )
  {
    memcpy(*a1, v3, (int)v3[0xFFFFFFFE]);
  }
  result = (__int64)memset((char *)*a1 + (int)v3[0xFFFFFFFE], Val_1, Size);
  if ( (int)v3[0xFFFFFFFF] > 0 )
  {
    sub_14739AF10(v3 + 0xFFFFFFFE);
  }
  return result;
}

// --- End Function: sub_1403E4C30 (0x1403E4C30) ---

// --- Function: sub_1404AB370 (0x1404AB370) ---
__int64 __fastcall sub_1404AB370(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x38);
}

// --- End Function: sub_1404AB370 (0x1404AB370) ---

// --- Function: getThreadLogContextSlot (0x1404B79A0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *tls_log_structure; // rax
  unsigned __int64 *tls_log_structure_1; // rcx
  unsigned __int64 slot_index; // rax

  tls_log_structure = sub_1404AE300();
  tls_log_structure_1 = tls_log_structure;
  if ( !tls_log_structure )
  {
    return &arg40;
  }
  slot_index = *tls_log_structure;
  if ( slot_index > 0xF )
  {
    slot_index = 0xF;
  }
  return (__int64 *)&tls_log_structure_1[0x16 * slot_index + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404B79A0) ---

// --- Function: _InterlockedIncrement16_w (0x140504410) ---
signed __int16 __fastcall InterlockedIncrement16_w(volatile signed __int16 *a1)
{
  return _InterlockedIncrement16(a1);
}

// --- End Function: _InterlockedIncrement16_w (0x140504410) ---

// --- Function: is_thread_flag_57_or_38_set (0x140535D40) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 thread_data_ptr_offset_16; // rcx

  thread_data_ptr_offset_16 = *(_QWORD *)(get_tls_data_offset_784() + 0x10);
  if ( thread_data_ptr_offset_16 )
  {
    return *(_BYTE *)(thread_data_ptr_offset_16 + 0x39) != 0;
  }
  else
  {
    return *(_BYTE *)(get_tls_data_offset_784() + 0x26) != 0;
  }
}

// --- End Function: is_thread_flag_57_or_38_set (0x140535D40) ---

// --- Function: sub_1405AC280 (0x1405AC280) ---
bool __fastcall sub_1405AC280(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a1 == *(_QWORD *)a2
      && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(_QWORD *)(a1 + 0x10) == *(_QWORD *)(a2 + 0x10);
}

// --- End Function: sub_1405AC280 (0x1405AC280) ---

// --- Function: sub_1405AC2A0 (0x1405AC2A0) ---
bool __fastcall sub_1405AC2A0(__int64 a1, __int64 a2)
{
  return *(_QWORD *)a1 != *(_QWORD *)a2
      || *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
      || *(_QWORD *)(a1 + 0x10) != *(_QWORD *)(a2 + 0x10);
}

// --- End Function: sub_1405AC2A0 (0x1405AC2A0) ---

// --- Function: sub_1405AC2C0 (0x1405AC2C0) ---
bool __fastcall sub_1405AC2C0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax

  if ( *(_QWORD *)a1 >= *(_QWORD *)a2 )
  {
    if ( *(_QWORD *)a1 > *(_QWORD *)a2 )
    {
      return 0;
    }
    v2 = *(_DWORD *)(a1 + 8);
    if ( v2 >= *(_DWORD *)(a2 + 8) )
    {
      if ( v2 <= *(_DWORD *)(a2 + 8) )
      {
        return *(_QWORD *)(a1 + 0x10) < *(_QWORD *)(a2 + 0x10);
      }
      return 0;
    }
  }
  return 1;
}

// --- End Function: sub_1405AC2C0 (0x1405AC2C0) ---

// --- Function: sub_1405AC2F0 (0x1405AC2F0) ---
__int64 __fastcall sub_1405AC2F0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  return a1;
}

// --- End Function: sub_1405AC2F0 (0x1405AC2F0) ---

// --- Function: sub_1405AC850 (0x1405AC850) ---
__int64 __fastcall sub_1405AC850(__int64 a1, __int64 a2)
{
  size_t n511; // rbx
  PlayerInventory **p_UNDEFINED; // r9

  *(_BYTE *)(a2 + 0x18) = 0;
  *(_QWORD *)(a2 + 0x10) = a2 + 0x18;
  *(_QWORD *)a2 = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a2 + 8) = 0x1FF;
  do
  {
    ++n511;
  }
  while ( aInvalid_0[n511] );
  if ( n511 )
  {
    sub_1402A1C40((__int64 *)a2, n511);
    memcpy(*(void **)(a2 + 0x10), "INVALID", n511);
  }
  if ( *(_QWORD *)a1 && *(_DWORD *)(a1 + 8) != 9 )
  {
    switch ( *(_DWORD *)(a1 + 8) )
    {
      case 0:
        p_UNDEFINED = "Container";
        break;
      case 1:
        p_UNDEFINED = "Debug";
        break;
      case 2:
        p_UNDEFINED = "Entitlement";
        break;
      case 3:
        p_UNDEFINED = "Location";
        break;
      case 4:
        p_UNDEFINED = "PlayerInventory";
        break;
      case 5:
        p_UNDEFINED = "Prison";
        break;
      case 6:
        p_UNDEFINED = "PersonalEntityInventory";
        break;
      case 7:
        p_UNDEFINED = "Hangar";
        break;
      case 8:
        p_UNDEFINED = "Undefined";
        break;
      default:
        p_UNDEFINED = "UNDEFINED";
        break;
    }
    sub_1402A1380((__int64 *)a2, "%llu:%s:%llu", *(_QWORD *)a1, p_UNDEFINED, *(_QWORD *)(a1 + 0x10));
  }
  return a2;
}

// --- End Function: sub_1405AC850 (0x1405AC850) ---

// --- Function: sub_140973B70 (0x140973B70) ---
_DWORD *__fastcall sub_140973B70(__int64 a1)
{
  _DWORD *tls_data_offset_784; // rax
  __int64 v2; // rbx
  int v3; // edi

  ++**(_DWORD **)(a1 + 0x10);
  tls_data_offset_784 = *(_DWORD **)(a1 + 0x10);
  if ( *tls_data_offset_784 == 1 )
  {
    v2 = *(_QWORD *)(a1 + 8);
    tls_data_offset_784 = (_DWORD *)get_tls_data_offset_784();
    v3 = tls_data_offset_784[6];
    if ( *(_DWORD *)(v2 + 8) == v3 )
    {
      ++*(_DWORD *)(v2 + 0xC);
    }
    else
    {
      tls_data_offset_784 = (_DWORD *)_InterlockedCompareExchange64((volatile signed __int64 *)v2, 0x200000, 0);
      if ( tls_data_offset_784 )
      {
        tls_data_offset_784 = (_DWORD *)sub_1403D85B0(
                                          (volatile signed __int64 *)v2,
                                          (unsigned __int64)tls_data_offset_784,
                                          0,
                                          (__int64)&p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
                                          (__int64)&p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
                                          1);
      }
      *(_DWORD *)(v2 + 8) = v3;
    }
  }
  return tls_data_offset_784;
}

// --- End Function: sub_140973B70 (0x140973B70) ---

// --- Function: sub_140BE7830 (0x140BE7830) ---
__int64 __fastcall sub_140BE7830(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 n3; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_QWORD *)(a1 + 0x68) = a3;
  *(_QWORD *)(a1 + 0x18) = sub_1403E6C00;
  *(_QWORD *)(a1 + 0x70) = "Text";
  *(_QWORD *)(a1 + 0x20) = sub_1403E6700;
  *(_BYTE *)(a1 + 0xC1) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E2C50;
  *(_QWORD *)(a1 + 0x40) = free_memory_wrapper_w_1;
  *(_QWORD *)(a1 + 0x48) = allocWithoutProfiling_w;
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x78) = *a3;
  *(_QWORD *)(a1 + 0x80) = sub_1403E6A90;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  *(_BYTE *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xD8) = "Text";
  *(_BYTE *)(a1 + 0x129) = 0;
  *(_QWORD *)(a1 + 0xA8) = sub_1403E02E0;
  *(_QWORD *)(a1 + 0x88) = sub_1403E6550;
  *(_QWORD *)(a1 + 0x98) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 0xB8) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xC8) = 0x18;
  *(_QWORD *)(a1 + 0xD0) = a4;
  *(_QWORD *)(a1 + 0xE0) = *a4;
  n3 = 3;
  *(_QWORD *)(a1 + 0xE8) = sub_1403E6A90;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_BYTE *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0xF0) = sub_1403E6550;
  *(_QWORD *)(a1 + 0x100) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 0x110) = sub_1403E02E0;
  *(_QWORD *)(a1 + 0x118) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 0x120) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x130) = 0x18;
  return n3;
}

// --- End Function: sub_140BE7830 (0x140BE7830) ---

// --- Function: sub_140DA5650 (0x140DA5650) ---
__int64 __fastcall sub_140DA5650(_QWORD *a1)
{
  if ( *a1 )
  {
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)*a1 + 8LL) + 8 * (a1[2] & (*(_QWORD *)(*(_QWORD *)*a1 + 0x10LL) - 1LL)));
  }
  else
  {
    return *(_QWORD *)(MEMORY[8] + 8 * (a1[2] & (MEMORY[0x10] - 1LL)));
  }
}

// --- End Function: sub_140DA5650 (0x140DA5650) ---

// --- Function: sub_14188AE40 (0x14188AE40) ---
__int64 __fastcall sub_14188AE40(__int64 a1, __int64 a2, __int64 a3)
{
  int v5; // esi
  unsigned __int64 v7; // rax

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 0x18) = 1;
  v5 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( *(_DWORD *)(a3 + 8) == v5 )
  {
    ++*(_DWORD *)(a3 + 0xC);
    return a1;
  }
  else
  {
    v7 = _InterlockedCompareExchange64((volatile signed __int64 *)a3, 0x200000, 0);
    if ( v7 )
    {
      sub_1403D85B0(
        (volatile signed __int64 *)a3,
        v7,
        0,
        (__int64)&p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
        (__int64)&p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp,
        1);
    }
    *(_DWORD *)(a3 + 8) = v5;
    return a1;
  }
}

// --- End Function: sub_14188AE40 (0x14188AE40) ---

// --- Function: sub_14262AA60 (0x14262AA60) ---
_QWORD *__fastcall sub_14262AA60(Parameter *Parameter)
{
  *Parameter = 0;
  Parameter[1] = 0;
  Parameter[2] = 0;
  _StarEngineModule__((ULONG_PTR)Parameter);
  return Parameter;
}

// --- End Function: sub_14262AA60 (0x14262AA60) ---

// --- Function: sub_142656CA0 (0x142656CA0) ---
__int64 __fastcall sub_142656CA0(unsigned __int8 a1)
{
  return (unsigned int)a1 + 0xC6;
}

// --- End Function: sub_142656CA0 (0x142656CA0) ---

// --- Function: sub_142A18E60 (0x142A18E60) ---
_QWORD *__fastcall sub_142A18E60(_QWORD *a1)
{
  _BYTE v2[8]; // [rsp+20h] [rbp-28h] BYREF
  _QWORD *v3; // [rsp+28h] [rbp-20h]
  __int64 v4; // [rsp+30h] [rbp-18h]

  *a1 = 0;
  a1[1] = 0;
  v3 = a1 + 2;
  v4 = _((__int64)v2);
  _((__int64)v3);
  *v3 = 0;
  return a1;
}

// --- End Function: sub_142A18E60 (0x142A18E60) ---

// --- Function: sub_142E6E0D0 (0x142E6E0D0) ---
_QWORD *__fastcall sub_142E6E0D0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax

  a2[2] = a1[3] + a1[4];
  *a2 = *a1;
  result = a2;
  a2[1] = 0;
  return result;
}

// --- End Function: sub_142E6E0D0 (0x142E6E0D0) ---

// --- Function: sub_142EC6F70 (0x142EC6F70) ---
__int64 __fastcall sub_142EC6F70(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  __int64 n4; // rax

  *(_QWORD *)a1 = a2;
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403E6C00;
  *(_QWORD *)(a1 + 0x20) = sub_1403E6700;
  *(_QWORD *)(a1 + 0x30) = sub_1403E2C50;
  *(_QWORD *)(a1 + 0x40) = free_memory_wrapper_w_1;
  *(_QWORD *)(a1 + 0x48) = allocWithoutProfiling_w;
  *(_QWORD *)(a1 + 0x70) = "Text";
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = a3;
  *(_BYTE *)(a1 + 0xC1) = 0;
  *(_QWORD *)(a1 + 0x78) = *a3;
  *(_QWORD *)(a1 + 0x80) = sub_1403E6A90;
  *(_QWORD *)(a1 + 0x88) = sub_1403E6550;
  *(_QWORD *)(a1 + 0x98) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 0xA8) = sub_1403E02E0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 0xD8) = "UInt";
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_QWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0x18;
  *(_QWORD *)(a1 + 0xD0) = a4;
  *(_BYTE *)(a1 + 0x129) = 0;
  *(_QWORD *)(a1 + 0xE0) = *a4;
  *(_QWORD *)(a1 + 0xE8) = sub_1403E65D0;
  *(_QWORD *)(a1 + 0xF0) = sub_1403E65D0;
  *(_QWORD *)(a1 + 0x100) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x110) = free_memory_wrapper_w_2;
  *(_QWORD *)(a1 + 0x118) = sub_1403DFFC0;
  *(_QWORD *)(a1 + 0x138) = a5;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x120) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x128) = 0;
  *(_QWORD *)(a1 + 0x130) = 0x10;
  *(_QWORD *)(a1 + 0x140) = "Name";
  *(_BYTE *)(a1 + 0x191) = 0;
  *(_QWORD *)(a1 + 0x148) = *a5;
  *(_QWORD *)(a1 + 0x150) = sub_1403E6A90;
  *(_QWORD *)(a1 + 0x158) = sub_1403E6550;
  *(_QWORD *)(a1 + 0x168) = sub_1403E2AB0;
  *(_QWORD *)(a1 + 0x178) = sub_1403E02E0;
  *(_QWORD *)(a1 + 0x180) = sub_1403DFFF0;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_QWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x188) = 0xFFFFFFFFFFFFFFFFuLL;
  n4 = 4;
  *(_BYTE *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = 0x18;
  return n4;
}

// --- End Function: sub_142EC6F70 (0x142EC6F70) ---

// --- Function: sub_142F433C0 (0x142F433C0) ---
__int16 *__fastcall sub_142F433C0(__int16 *a1)
{
  __int16 n0xFFFF; // cx
  __int16 *result; // rax
  char v4; // [rsp+30h] [rbp+8h] BYREF

  if ( n0xFFFF_25 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                 + 0x10LL))(
                          global_dispatcher_ptr,
                          &v4,
                          "InventoryContainerComponent");
    result = a1;
    n0xFFFF_25 = n0xFFFF;
    *a1 = n0xFFFF;
  }
  else
  {
    *a1 = n0xFFFF_25;
    return a1;
  }
  return result;
}

// --- End Function: sub_142F433C0 (0x142F433C0) ---

// --- Function: sub_14326D650 (0x14326D650) ---
__int64 *__fastcall sub_14326D650(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rdi
  __int64 *v5; // rbx
  bool v6; // zf
  __int64 *result; // rax

  v2 = (__int64 *)*a1;
  v5 = *(__int64 **)(*a1 + 8);
  while ( !*((_BYTE *)v5 + 0x19) )
  {
    if ( sub_1405AC2C0((__int64)(v5 + 4), a2) )
    {
      v5 = (__int64 *)v5[2];
    }
    else
    {
      v2 = v5;
      v5 = (__int64 *)*v5;
    }
  }
  if ( *((_BYTE *)v2 + 0x19) )
  {
    return (__int64 *)*a1;
  }
  v6 = !sub_1405AC2C0(a2, (__int64)(v2 + 4));
  result = v2;
  if ( !v6 )
  {
    return (__int64 *)*a1;
  }
  return result;
}

// --- End Function: sub_14326D650 (0x14326D650) ---

// --- Function: sub_143271EA0 (0x143271EA0) ---
_QWORD *__fastcall sub_143271EA0(_QWORD *a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // rax

  v3 = 0;
  a1[2] = a2;
  *a1 = 0;
  a1[1] = 0;
  if ( a3 )
  {
    v3 = *a3;
  }
  *a1 = v3;
  return a1;
}

// --- End Function: sub_143271EA0 (0x143271EA0) ---

// --- Function: sub_143277150 (0x143277150) ---
__int64 __fastcall sub_143277150(__int64 a1)
{
  const void **v2; // rax
  const void **v3; // rax
  const void **v4; // rax
  const void **v5; // rax
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  *(_OWORD *)(a1 + 8) = xmmword_147F82E80;
  *(double *)(a1 + 0x18) = 0;
  *(_DWORD *)(a1 + 0x20) = 0;
  sub_1403577C0((void **)(a1 + 0x28), &qword_149AE4228);
  *(_DWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x48) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  initializeEmptyStringStructure((_QWORD *)(a1 + 0x58));
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_DWORD *)(a1 + 0x68) = 0;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  v2 = (const void **)sub_1403AA300();
  sub_140357A70((void **)(a1 + 0x90), v2);
  v3 = (const void **)sub_1403AA300();
  sub_140357A70((void **)(a1 + 0x98), v3);
  v4 = (const void **)sub_1403AA300();
  sub_140357A70((void **)(a1 + 0xA0), v4);
  v5 = (const void **)sub_1403AA300();
  sub_140357A70((void **)(a1 + 0xA8), v5);
  result = a1;
  *(_BYTE *)(a1 + 0xB0) = 0;
  return result;
}

// --- End Function: sub_143277150 (0x143277150) ---

// --- Function: sub_143278A40 (0x143278A40) ---
void __fastcall sub_143278A40(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rdi
  _QWORD *v4; // rbp
  _QWORD *v5; // rbx
  const void *v6; // rcx
  _QWORD *v7; // rcx
  _QWORD *ptr_to_free; // r8

  v2 = (_QWORD *)*a1;
  if ( *a1 )
  {
    v4 = (_QWORD *)a1[1];
    if ( v2 != v4 )
    {
      v5 = v2 + 0xC;
      do
      {
        v6 = (const void *)v5[7];
        if ( v6 )
        {
          sub_14739AF10(v6);
        }
        v7 = (_QWORD *)*v5;
        if ( *v5 )
        {
          LOBYTE(a2) = v7 != v5 + 0xFFFFFFF9;
          (*(void (__fastcall **)(_QWORD *, __int64))(*v7 + 0x20LL))(v7, a2);
          *v5 = 0;
        }
        DestroyStringObject(v5 + 0xFFFFFFF7);
        DestroyStringObject(v5 + 0xFFFFFFF5);
        v2 += 0x17;
        v5 += 0x17;
      }
      while ( v2 != v4 );
    }
    ptr_to_free = (_QWORD *)*a1;
    if ( (unsigned __int64)(0xB8 * ((a1[2] - *a1) / 0xB8LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)ptr_to_free - ptr_to_free[0xFFFFFFFF] - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      ptr_to_free = (_QWORD *)ptr_to_free[0xFFFFFFFF];
    }
    free_memory_wrapper(ptr_to_free);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

// --- End Function: sub_143278A40 (0x143278A40) ---

// --- Function: sub_14327A370 (0x14327A370) ---
void __fastcall sub_14327A370(_QWORD *a1)
{
  DestroyStringObject(a1 + 0x15);
  DestroyStringObject(a1 + 0x14);
  DestroyStringObject(a1 + 0x13);
  DestroyStringObject(a1 + 0x12);
  DestroyStringObject(a1 + 0xB);
  DestroyStringObject(a1 + 5);
}

// --- End Function: sub_14327A370 (0x14327A370) ---

// --- Function: sub_14327A430 (0x14327A430) ---
__int64 __fastcall sub_14327A430(__int64 a1)
{
  DestroyStringObject((_QWORD *)(a1 + 0x88));
  sub_1432787D0(a1 + 0x50);
  return sub_1432787D0(a1 + 0x38);
}

// --- End Function: sub_14327A430 (0x14327A430) ---

// --- Function: sub_1439924E0 (0x1439924E0) ---
__int64 __fastcall sub_1439924E0(__int64 a1)
{
  sub_143A95670(a1);
  return 0;
}

// --- End Function: sub_1439924E0 (0x1439924E0) ---

// --- Function: sub_143992C50 (0x143992C50) ---
__int64 __fastcall sub_143992C50(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = sub_1402A0F70(0x1A8, a1);
  sub_143A876C0(v3, a2);
  result = *(_QWORD *)(a2 + 0x1A0);
  *(_QWORD *)(v3 + 0x1A0) = result;
  return result;
}

// --- End Function: sub_143992C50 (0x143992C50) ---

// --- Function: sub_1439C6510 (0x1439C6510) ---
__int64 __fastcall sub_1439C6510(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+28h] [rbp-30h] BYREF
  int v5; // [rsp+30h] [rbp-28h]
  __int64 n0x1A8; // [rsp+38h] [rbp-20h]
  __int64 (__fastcall *p_sub_1439924E0)(__int64); // [rsp+40h] [rbp-18h]
  __int64 (__fastcall *p_sub_143992C50)(__int64, __int64); // [rsp+48h] [rbp-10h]

  v4 = a3;
  v5 = sub_143B34C50();
  n0x1A8 = 0x1A8;
  p_sub_1439924E0 = sub_1439924E0;
  p_sub_143992C50 = sub_143992C50;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a1 + 0x358LL))(a1, a2, &v4);
}

// --- End Function: sub_1439C6510 (0x1439C6510) ---

// --- Function: sub_1439C77F0 (0x1439C77F0) ---
char __fastcall sub_1439C77F0(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+28h] [rbp-30h] BYREF
  int v5; // [rsp+30h] [rbp-28h]
  __int64 n0x60; // [rsp+38h] [rbp-20h]
  __int64 (__fastcall *p_sub_143992630)(); // [rsp+40h] [rbp-18h]
  __int64 (__fastcall *p_sub_143992F90)(); // [rsp+48h] [rbp-10h]
  unsigned __int64 v10; // [rsp+68h] [rbp+10h] BYREF
  __int64 v11; // [rsp+70h] [rbp+18h]

  v11 = a3;
  v10 = a2;
  if ( is_valid_handle_typeB_w(&v10) )
  {
    return 0;
  }
  v4 = v11;
  v5 = sub_143B34A40();
  n0x60 = 0x60;
  p_sub_143992630 = sub_143992630;
  p_sub_143992F90 = sub_143992F90;
  return (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64 *))(*(_QWORD *)a1 + 0x360LL))(a1, v10, &v4);
}

// --- End Function: sub_1439C77F0 (0x1439C77F0) ---

// --- Function: sub_143A49990 (0x143A49990) ---
__int64 __fastcall sub_143A49990(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403AFA50();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403E6C00;
  *(_QWORD *)(a1 + 0x20) = sub_1403E6700;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E2C50;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = free_memory_wrapper_w_1;
  *(_QWORD *)(a1 + 0x48) = allocWithoutProfiling_w;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  return sub_143A57A40(a1 + 0x68, a3, a4, a5) + 1;
}

// --- End Function: sub_143A49990 (0x143A49990) ---

// --- Function: sub_143A82040 (0x143A82040) ---
__int64 __fastcall sub_143A82040(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        float a6,
        char a7,
        char a8,
        int a9,
        int a10)
{
  double v10; // xmm1_8
  __int64 result; // rax

  v10 = *(double *)(a2 + 0x10);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(double *)(a1 + 0x10) = v10;
  sub_143A70770(a1 + 0x18, a3);
  sub_143A705C0(a1 + 0x30, a4);
  *(_QWORD *)(a1 + 0x48) = a5;
  *(_BYTE *)(a1 + 0x54) = a7;
  *(_BYTE *)(a1 + 0x55) = a8;
  *(_DWORD *)(a1 + 0x58) = a9;
  *(_DWORD *)(a1 + 0x5C) = a10;
  result = a1;
  *(float *)(a1 + 0x50) = a6;
  return result;
}

// --- End Function: sub_143A82040 (0x143A82040) ---

// --- Function: sub_143A874A0 (0x143A874A0) ---
__int64 __fastcall sub_143A874A0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  qmemcpy((void *)(a1 + 8), (const void *)(a2 + 8), 0x1Cu);
  sub_1403577C0((void **)(a1 + 0x28), (const void **)(a2 + 0x28));
  *(_DWORD *)(a1 + 0x30) = *(_DWORD *)(a2 + 0x30);
  *(_QWORD *)(a1 + 0x38) = *(_QWORD *)(a2 + 0x38);
  qmemcpy((void *)(a1 + 0x40), (const void *)(a2 + 0x40), 0xCu);
  qmemcpy((void *)(a1 + 0x4C), (const void *)(a2 + 0x4C), 0xCu);
  sub_1403577C0((void **)(a1 + 0x58), (const void **)(a2 + 0x58));
  *(float *)(a1 + 0x60) = *(float *)(a2 + 0x60);
  *(_DWORD *)(a1 + 0x64) = *(_DWORD *)(a2 + 0x64);
  *(_DWORD *)(a1 + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_QWORD *)(a1 + 0x70) = *(_QWORD *)(a2 + 0x70);
  *(_QWORD *)(a1 + 0x78) = *(_QWORD *)(a2 + 0x78);
  qmemcpy((void *)(a1 + 0x80), (const void *)(a2 + 0x80), 0x10u);
  sub_140357A70((void **)(a1 + 0x90), (const void **)(a2 + 0x90));
  sub_140357A70((void **)(a1 + 0x98), (const void **)(a2 + 0x98));
  sub_140357A70((void **)(a1 + 0xA0), (const void **)(a2 + 0xA0));
  sub_140357A70((void **)(a1 + 0xA8), (const void **)(a2 + 0xA8));
  *(_BYTE *)(a1 + 0xB0) = *(_BYTE *)(a2 + 0xB0);
  return a1;
}

// --- End Function: sub_143A874A0 (0x143A874A0) ---

// --- Function: sub_143A876C0 (0x143A876C0) ---
__int64 __fastcall sub_143A876C0(__int64 a1, __int64 a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 0x10) = *(_OWORD *)(a2 + 0x10);
  *(double *)(a1 + 0x20) = *(double *)(a2 + 0x20);
  *(_OWORD *)(a1 + 0x28) = *(_OWORD *)(a2 + 0x28);
  *(double *)(a1 + 0x38) = *(double *)(a2 + 0x38);
  *(_DWORD *)(a1 + 0x40) = *(_DWORD *)(a2 + 0x40);
  *(_DWORD *)(a1 + 0x44) = *(_DWORD *)(a2 + 0x44);
  sub_1403577C0((void **)(a1 + 0x48), (const void **)(a2 + 0x48));
  sub_143A6F7C0(a1 + 0x50, a2 + 0x50);
  *(_DWORD *)(a1 + 0x68) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(a1 + 0x6C) = *(_DWORD *)(a2 + 0x6C);
  sub_1403577C0((void **)(a1 + 0x70), (const void **)(a2 + 0x70));
  sub_140359A10(a1 + 0x78, a2 + 0x78);
  *(_QWORD *)(a1 + 0x90) = *(_QWORD *)(a2 + 0x90);
  *(_OWORD *)(a1 + 0x98) = *(_OWORD *)(a2 + 0x98);
  *(_DWORD *)(a1 + 0xA8) = *(_DWORD *)(a2 + 0xA8);
  *(_BYTE *)(a1 + 0xAC) = *(_BYTE *)(a2 + 0xAC);
  *(_DWORD *)(a1 + 0xB0) = *(_DWORD *)(a2 + 0xB0);
  sub_143A700B0(a1 + 0xB8, a2 + 0xB8);
  *(_DWORD *)(a1 + 0xD0) = *(_DWORD *)(a2 + 0xD0);
  sub_1403577C0((void **)(a1 + 0xD8), (const void **)(a2 + 0xD8));
  *(_DWORD *)(a1 + 0xE0) = *(_DWORD *)(a2 + 0xE0);
  sub_1403577C0((void **)(a1 + 0xE8), (const void **)(a2 + 0xE8));
  *(_DWORD *)(a1 + 0xF0) = *(_DWORD *)(a2 + 0xF0);
  *(_OWORD *)(a1 + 0xF8) = *(_OWORD *)(a2 + 0xF8);
  *(double *)(a1 + 0x108) = *(double *)(a2 + 0x108);
  *(_OWORD *)(a1 + 0x110) = *(_OWORD *)(a2 + 0x110);
  *(double *)(a1 + 0x120) = *(double *)(a2 + 0x120);
  *(_DWORD *)(a1 + 0x128) = *(_DWORD *)(a2 + 0x128);
  sub_1405B31C0(a1 + 0x130, a2 + 0x130);
  sub_1405B31C0(a1 + 0x140, a2 + 0x140);
  sub_1403577C0((void **)(a1 + 0x150), (const void **)(a2 + 0x150));
  sub_1403577C0((void **)(a1 + 0x158), (const void **)(a2 + 0x158));
  *(_BYTE *)(a1 + 0x160) = *(_BYTE *)(a2 + 0x160);
  *(double *)(a1 + 0x168) = *(double *)(a2 + 0x168);
  *(_DWORD *)(a1 + 0x170) = *(_DWORD *)(a2 + 0x170);
  *(_QWORD *)(a1 + 0x178) = *(_QWORD *)(a2 + 0x178);
  sub_1403577C0((void **)(a1 + 0x180), (const void **)(a2 + 0x180));
  *(_OWORD *)(a1 + 0x188) = *(_OWORD *)(a2 + 0x188);
  *(_BYTE *)(a1 + 0x198) = *(_BYTE *)(a2 + 0x198);
  return a1;
}

// --- End Function: sub_143A876C0 (0x143A876C0) ---

// --- Function: sub_143A87910 (0x143A87910) ---
__int64 __fastcall sub_143A87910(__int64 a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0xE;
  *(_OWORD *)(a1 + 0x10) = xmmword_147F82E80;
  *(double *)(a1 + 0x20) = 0;
  *(_OWORD *)(a1 + 0x28) = xmmword_147F82E80;
  *(double *)(a1 + 0x38) = 0;
  *(_DWORD *)(a1 + 0x44) = 0;
  sub_1403577C0((void **)(a1 + 0x48), &qword_149AF2560);
  sub_14262AA60((Parameter *)(a1 + 0x50));
  *(_DWORD *)(a1 + 0x6C) = 0;
  sub_1403577C0((void **)(a1 + 0x70), &qword_149AF2560);
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_QWORD *)(a1 + 0x88) = 0;
  *(_QWORD *)(a1 + 0x90) = 0;
  *(_OWORD *)(a1 + 0x98) = xmmword_14857B130;
  *(_DWORD *)(a1 + 0xA8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xAC) = 0;
  *(_DWORD *)(a1 + 0xB0) = 0;
  sub_14262AA60((Parameter *)(a1 + 0xB8));
  sub_143A89FA0(a1 + 0xD0);
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_DWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x178) = 0;
  initializeEmptyStringStructure((_QWORD *)(a1 + 0x180));
  *(_OWORD *)(a1 + 0x188) = xmmword_14857B130;
  *(_BYTE *)(a1 + 0x198) = 0;
  return a1;
}

// --- End Function: sub_143A87910 (0x143A87910) ---

// --- Function: sub_143A89FA0 (0x143A89FA0) ---
__int64 __fastcall sub_143A89FA0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 result; // rax

  *(_DWORD *)a1 = 0xFFFFFFFF;
  initializeEmptyStringStructure((_QWORD *)(a1 + 8));
  *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
  initializeEmptyStringStructure((_QWORD *)(a1 + 0x18));
  *(_DWORD *)(a1 + 0x20) = 1;
  *(_OWORD *)(a1 + 0x28) = xmmword_147F82E80;
  *(double *)(a1 + 0x38) = 0;
  *(_OWORD *)(a1 + 0x40) = xmmword_147F82E80;
  *(double *)(a1 + 0x50) = 0;
  *(_DWORD *)(a1 + 0x58) = 3;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  v2 = allocWithoutProfiling(0x40u);
  *(_QWORD *)v2 = v2;
  *(_QWORD *)(v2 + 8) = v2;
  *(_QWORD *)(v2 + 0x10) = v2;
  *(_WORD *)(v2 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x60) = v2;
  *(_QWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  v3 = allocWithoutProfiling(0x40u);
  *(_QWORD *)v3 = v3;
  *(_QWORD *)(v3 + 8) = v3;
  *(_QWORD *)(v3 + 0x10) = v3;
  *(_WORD *)(v3 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0x70) = v3;
  initializeEmptyStringStructure((_QWORD *)(a1 + 0x80));
  initializeEmptyStringStructure((_QWORD *)(a1 + 0x88));
  result = a1;
  *(_BYTE *)(a1 + 0x90) = 0;
  return result;
}

// --- End Function: sub_143A89FA0 (0x143A89FA0) ---

// --- Function: release_context_lock_0 (0x143A913E0) ---
__int64 __fastcall sub_143A913E0(__int64 a1)
{
  return sub_143C0B930(a1);
}

// --- End Function: release_context_lock_0 (0x143A913E0) ---

// --- Function: release_context_lock_1 (0x143A915A0) ---
__int64 __fastcall sub_143A915A0(__int64 a1)
{
  return sub_143C0C8A0(a1);
}

// --- End Function: release_context_lock_1 (0x143A915A0) ---

// --- Function: sub_143A91640 (0x143A91640) ---
__int64 __fastcall sub_143A91640(__int64 a1)
{
  _QWORD *i; // [rsp+20h] [rbp-28h]
  _QWORD *v3; // [rsp+30h] [rbp-18h]

  v3 = *(_QWORD **)(a1 + 8);
  for ( i = *(_QWORD **)a1; i != v3; i += 0x17 )
  {
    sub_14327A370(i);
  }
  return sub_143A8DAD0(a1);
}

// --- End Function: sub_143A91640 (0x143A91640) ---

// --- Function: sub_143A916E0 (0x143A916E0) ---
__int64 __fastcall sub_143A916E0(char **a1)
{
  char *i; // [rsp+20h] [rbp-28h]
  char *v3; // [rsp+30h] [rbp-18h]

  v3 = a1[1];
  for ( i = *a1; i != v3; i += 0x28 )
  {
    sub_14327A460(i);
  }
  return sub_143A8DA60(a1);
}

// --- End Function: sub_143A916E0 (0x143A916E0) ---

// --- Function: sub_143A95670 (0x143A95670) ---
void __fastcall sub_143A95670(_QWORD *a1)
{
  DestroyStringObject(a1 + 0x30);
  sub_143A96890(a1 + 0x1A);
  release_context_lock_1((__int64)(a1 + 0x17));
  sub_1402B05B0(a1 + 0xF);
  DestroyStringObject(a1 + 0xE);
  release_context_lock_0((__int64)(a1 + 0xA));
  DestroyStringObject(a1 + 9);
}

// --- End Function: sub_143A95670 (0x143A95670) ---

// --- Function: sub_143A96890 (0x143A96890) ---
void __fastcall sub_143A96890(__int64 a1)
{
  DestroyStringObject((_QWORD *)(a1 + 0x88));
  DestroyStringObject((_QWORD *)(a1 + 0x80));
  sub_140306170(a1 + 0x70, a1 + 0x70, *(_QWORD *)(*(_QWORD *)(a1 + 0x70) + 8LL));
  free_memory_wrapper(*(const void **)(a1 + 0x70));
  sub_140306170(a1 + 0x60, a1 + 0x60, *(_QWORD *)(*(_QWORD *)(a1 + 0x60) + 8LL));
  free_memory_wrapper(*(const void **)(a1 + 0x60));
  DestroyStringObject((_QWORD *)(a1 + 0x18));
  DestroyStringObject((_QWORD *)(a1 + 8));
}

// --- End Function: sub_143A96890 (0x143A96890) ---

// --- Function: sub_143B2BAC0 (0x143B2BAC0) ---
const char *__fastcall sub_143B2BAC0(int a1, const char *p_Invalid_1)
{
  const char *p_Invalid; // rax

  switch ( a1 )
  {
    case 0:
      p_Invalid = "Drop";
      break;
    case 1:
      p_Invalid = "Interaction";
      break;
    case 2:
      p_Invalid = (const char *)&dword_1482B2C30;
      break;
    case 3:
      p_Invalid = "Sort";
      break;
    case 4:
      p_Invalid = "Split";
      break;
    case 5:
      p_Invalid = "Stack";
      break;
    case 6:
      p_Invalid = "Swap";
      break;
    case 7:
      p_Invalid = dword_1481B1E7C;
      break;
    case 8:
      p_Invalid = "StoreAndHide";
      break;
    case 9:
      p_Invalid = "OpenNestedInventory";
      break;
    case 0xA:
      p_Invalid = "QueryInventory";
      break;
    case 0xB:
      p_Invalid = "QueryOrCreate";
      break;
    case 0xC:
      p_Invalid = "SwapOutfit";
      break;
    case 0xD:
      p_Invalid = "AmmoRepool";
      break;
    case 0xE:
      p_Invalid = "Invalid";
      break;
    default:
      p_Invalid = p_Invalid_1;
      break;
  }
  return p_Invalid;
}

// --- End Function: sub_143B2BAC0 (0x143B2BAC0) ---

// --- Function: sub_143B2F500 (0x143B2F500) ---
__int64 __fastcall sub_143B2F500(__int64 a1)
{
  __int64 v2; // rax

  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)global_validator_object + 0xC0LL))(global_validator_object);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 0x10LL))(v2, *(unsigned int *)(a1 + 0x20));
}

// --- End Function: sub_143B2F500 (0x143B2F500) ---

// --- Function: sub_143B34C50 (0x143B34C50) ---
__int64 sub_143B34C50()
{
  __int64 result; // rax

  result = (unsigned int)dword_149AF39EC;
  if ( !dword_149AF39EC )
  {
    return get_event_key_from_source_location(
             &dword_149AF39EC,
             (__int64)"W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\GameInventory/InventoryEvents.h",
             0x465);
  }
  return result;
}

// --- End Function: sub_143B34C50 (0x143B34C50) ---

// --- Function: sub_144CBD720 (0x144CBD720) ---
__int64 __fastcall sub_144CBD720(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  sub_143A876C0(a1, a2);
  result = a1;
  *(_QWORD *)(a1 + 0x1A0) = 0;
  return result;
}

// --- End Function: sub_144CBD720 (0x144CBD720) ---

// --- Function: sub_145A47090 (0x145A47090) ---
bool __fastcall sub_145A47090(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v6; // rax
  __int64 v7; // rax
  bool result; // al

  result = *(_DWORD *)(a1 + 0x20) == *(_DWORD *)(a2 + 0x20)
        && (v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)global_validator_object + 0xC0LL))(global_validator_object),
            v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 0x10LL))(v6, *(unsigned int *)(a1 + 0x20)),
            (unsigned __int8)sub_140396260(v7, a3))
        && (unsigned int)sub_1403DFBE0((unsigned __int8 **)(a1 + 0x58), (_QWORD *)(a2 + 0x58)) == 0;
  return result;
}

// --- End Function: sub_145A47090 (0x145A47090) ---

// --- Function: sub_145A47430 (0x145A47430) ---
bool __fastcall sub_145A47430(int a1)
{
  return a1 != 1;
}

// --- End Function: sub_145A47430 (0x145A47430) ---

// --- Function: sub_145A6E100 (0x145A6E100) ---
__int64 __fastcall sub_145A6E100(__int64 a1)
{
  void *v2; // rax
  char v4; // [rsp+30h] [rbp+8h] BYREF

  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 & 0xFFFFFFFFFFFFLL) + 0x20LL))(a1 & 0xFFFFFFFFFFFFLL);
  v2 = (void *)sub_145A58B60(&v4, a1);
  return sub_145A6D4E0(v2);
}

// --- End Function: sub_145A6E100 (0x145A6E100) ---

// --- Function: sub_145A7B2B0 (0x145A7B2B0) ---
char __fastcall sub_145A7B2B0(unsigned __int64 a1)
{
  _QWORD *v1; // rax
  __int64 v2; // r8
  char v4; // [rsp+30h] [rbp-48h]
  char v5; // [rsp+38h] [rbp-40h]
  __int64 (__fastcall **v6)(); // [rsp+40h] [rbp-38h] BYREF
  void *(__fastcall **v7)(AK::WriteBytesBuffer *__hidden, unsigned int); // [rsp+48h] [rbp-30h]
  __int128 v8; // [rsp+50h] [rbp-28h] BYREF
  float v9; // [rsp+60h] [rbp-18h]
  float v10; // [rsp+64h] [rbp-14h]
  __int16 v11; // [rsp+68h] [rbp-10h]
  unsigned __int64 v12; // [rsp+80h] [rbp+8h] BYREF
  unsigned __int64 v13; // [rsp+88h] [rbp+10h] BYREF

  v12 = a1;
  LOBYTE(v1) = is_valid_handle_typeB(&v12);
  if ( (_BYTE)v1 )
  {
    v11 = 0;
    v6 = off_148541828;
    v7 = &off_1482A5900;
    v8 = 0;
    v13 = v12;
    v10 = 1.0;
    v9 = 1.0;
    LOBYTE(v1) = is_valid_handle_typeB(&v13);
    if ( (_BYTE)v1 )
    {
      if ( (unsigned __int8)sub_142A52EE0(v13) )
      {
        v1 = (_QWORD *)sub_142A3F510(v13);
        if ( v1 )
        {
          v1 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD *))(*v1 + 0x218LL))(v1);
          if ( v1 )
          {
            v5 = 1;
            v4 = 1;
            LOBYTE(v1) = (*(__int64 (__fastcall **)(_QWORD *, __int128 *, _QWORD, _QWORD, float, unsigned int, char, char, __int64 (__fastcall **)(), void *(__fastcall **)(AK::WriteBytesBuffer *__hidden, unsigned int)))(*v1 + 0x48LL))(
                           v1,
                           &v8,
                           *v1,
                           (unsigned __int8)v11,
                           COERCE_FLOAT(LODWORD(v10)),
                           0xFFFFFFFF,
                           v4,
                           v5,
                           v6,
                           v7);
          }
        }
      }
      else
      {
        LOBYTE(v2) = 1;
        LOBYTE(v1) = sub_145A7E940(v13, &v6, v2);
      }
    }
  }
  return (char)v1;
}

// --- End Function: sub_145A7B2B0 (0x145A7B2B0) ---

// --- Function: sub_145A9BDF0 (0x145A9BDF0) ---
__int64 __fastcall sub_145A9BDF0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r14
  _QWORD *v3; // rsi
  int v5; // edi
  unsigned __int32 v6; // eax
  unsigned __int8 v7; // r12
  __int64 v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // r15
  _QWORD *v11; // r13
  unsigned __int64 v12; // rax
  __int64 v13; // rbx
  unsigned __int64 v14; // rax
  __int64 v15; // rbx
  bool v16; // al
  __int64 v17; // rbx
  __int64 (__fastcall *v18)(__int64, char *, __int16 *); // rdi
  __int16 inventory_container_component_type_id; // ax
  __int64 v20; // rdi
  __int64 handle_metadata_ptr; // rax
  __int16 n4_1; // dx
  __int64 v23; // rbx
  __int64 (__fastcall *v24)(__int64, char *, __int16 *); // r14
  __int16 n0xFFFF; // ax
  __int64 v26; // rbx
  __int64 handle_metadata_ptr_1; // rax
  __int16 n4; // dx
  __int64 v29; // rax
  void *v30; // rbx
  signed __int64 v31; // r15
  unsigned __int64 v32; // r12
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // rdx
  __int64 v35; // rax
  __int64 v36; // r13
  char *v37; // r14
  char *v38; // rcx
  const void *v39; // rdx
  char *Size; // r8
  char *v41; // rax
  _QWORD *v42; // rdi
  _QWORD *v43; // rbx
  int v44; // eax
  unsigned __int32 v45; // eax
  void *Src[2]; // [rsp+20h] [rbp-49h] BYREF
  char *v48; // [rsp+30h] [rbp-39h]
  char v49[8]; // [rsp+38h] [rbp-31h] BYREF
  unsigned __int64 v50; // [rsp+40h] [rbp-29h] BYREF
  _QWORD *v51; // [rsp+48h] [rbp-21h]
  __int64 v52; // [rsp+50h] [rbp-19h] BYREF
  __int64 v53; // [rsp+58h] [rbp-11h] BYREF
  __int64 v54; // [rsp+60h] [rbp-9h] BYREF
  _QWORD *v55; // [rsp+68h] [rbp-1h]
  char v56[8]; // [rsp+70h] [rbp+7h] BYREF
  char v57[72]; // [rsp+78h] [rbp+Fh] BYREF
  __int16 inventory_container_component_type_id_1; // [rsp+D0h] [rbp+67h] BYREF
  __int64 v59; // [rsp+D8h] [rbp+6Fh] BYREF
  __int16 n0xFFFF_1; // [rsp+E0h] [rbp+77h] BYREF
  char v61; // [rsp+E8h] [rbp+7Fh] BYREF

  v59 = a2;
  v2 = a2;
  v3 = a1 + 9;
  v5 = *(_DWORD *)(get_tls_data_offset_784() + 0x18);
  if ( *((_DWORD *)v3 + 1) == v5 )
  {
    ++*((_DWORD *)v3 + 2);
  }
  else
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 1, 0);
    if ( v6 )
    {
      sub_1403BF290((volatile signed __int32 *)v3, v6, (__int64)"CSCActorInventory::GetPersonalInventoryContainers", 1);
    }
    *((_DWORD *)v3 + 1) = v5;
  }
  if ( *(_QWORD *)v2 != *(_QWORD *)(v2 + 8) )
  {
    *(_QWORD *)(v2 + 8) = *(_QWORD *)v2;
  }
  v7 = 0;
  v8 = sub_14638A930(a1[0xE]);
  v9 = sub_1402C5060(v8);
  sub_145D034E0(v9, &v52, 2u);
  v10 = (_QWORD *)a1[6];
  v11 = (_QWORD *)a1[7];
  v48 = 0;
  v51 = v10;
  v55 = v11;
  *(_OWORD *)Src = 0;
  if ( v10 != v11 )
  {
    do
    {
      v12 = *v10;
      v50 = v12;
      if ( v12 )
      {
        v13 = v12 & 0xFFFFFFFFFFFFLL;
        v14 = HIWORD(v12);
        v15 = (v14 & 0xF000) != 0 ? v13 & 0xFFFFFF000000LL : v13 - 6;
        if ( *(_WORD *)(v15 + 2) == (v14 & 0xFFF) )
        {
          if ( *(_BYTE *)(get_tls_data_offset_784() + 0x25) || (v16 = is_thread_flag_57_or_38_set()) )
          {
            v16 = 1;
          }
          if ( (*(_WORD *)(v15 + 4) == 2 && v16 || check_handle_access_by_state_extended(&v50)) && v50 != v52 )
          {
            v17 = v50 & 0xFFFFFFFFFFFFLL;
            v18 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)(v50 & 0xFFFFFFFFFFFFLL) + 0x338LL);
            inventory_container_component_type_id = ::inventory_container_component_type_id;
            if ( ::inventory_container_component_type_id == (__int16)0xFFFF )
            {
              inventory_container_component_type_id = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr + 0x10LL))(
                                                                  global_dispatcher_ptr,
                                                                  &v61,
                                                                  "InventoryContainerComponent");
              ::inventory_container_component_type_id = inventory_container_component_type_id;
            }
            inventory_container_component_type_id_1 = inventory_container_component_type_id;
            v20 = *(_QWORD *)v18(v17, v56, &inventory_container_component_type_id_1);
            v53 = v20;
            if ( v20 )
            {
              handle_metadata_ptr = get_handle_metadata_ptr(v20 & 0xFFFFFFFFFFFFLL);
              n4_1 = *(_WORD *)(handle_metadata_ptr + 4);
              if ( n4_1 != 4
                && *(_WORD *)(handle_metadata_ptr + 2) == (HIWORD(v20) & 0xFFF)
                && (n4_1 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_handle_access_by_state(&v53)) )
              {
                v23 = v50 & 0xFFFFFFFFFFFFLL;
                v24 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)(v50 & 0xFFFFFFFFFFFFLL)
                                                                           + 0x338LL);
                n0xFFFF = n0xFFFF_24;
                if ( n0xFFFF_24 == (__int16)0xFFFF )
                {
                  n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr
                                                                                               + 0x10LL))(
                                        global_dispatcher_ptr,
                                        v49,
                                        "IAttachableComponent");
                  n0xFFFF_24 = n0xFFFF;
                }
                n0xFFFF_1 = n0xFFFF;
                v26 = *(_QWORD *)v24(v23, v57, &n0xFFFF_1);
                v54 = v26;
                if ( v26 )
                {
                  handle_metadata_ptr_1 = get_handle_metadata_ptr(v26 & 0xFFFFFFFFFFFFLL);
                  n4 = *(_WORD *)(handle_metadata_ptr_1 + 4);
                  if ( n4 != 4
                    && *(_WORD *)(handle_metadata_ptr_1 + 2) == (HIWORD(v26) & 0xFFF)
                    && (n4 == 2 && !*(_QWORD *)get_tls_data_offset_784() || check_indirect_handle_access_by_state(&v54)) )
                  {
                    v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v26 & 0xFFFFFFFFFFFFLL) + 0x608LL))(v26 & 0xFFFFFFFFFFFFLL);
                    if ( v29 )
                    {
                      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v29 + 0x210LL))(v29) )
                      {
                        v30 = Src[1];
                        if ( Src[1] == v48 )
                        {
                          v31 = ((char *)Src[1] - (char *)Src[0]) >> 3;
                          if ( v31 == 0x1FFFFFFFFFFFFFFFLL )
                          {
                            unknown_libname_10();
                          }
                          v32 = v31 + 1;
                          v33 = (v48 - (char *)Src[0]) >> 3;
                          v34 = v33 >> 1;
                          if ( v33 <= 0x1FFFFFFFFFFFFFFFLL - (v33 >> 1) )
                          {
                            v35 = v33 + v34;
                            if ( v33 + v34 < v32 )
                            {
                              v35 = v31 + 1;
                            }
                          }
                          else
                          {
                            v35 = 0x1FFFFFFFFFFFFFFFLL;
                          }
                          v36 = 8 * v35;
                          v37 = (char *)sub_14038E0B0((__int64)Src, 8 * v35);
                          v38 = v37;
                          *(_QWORD *)&v37[8 * v31] = v20;
                          v39 = Src[0];
                          if ( v30 == Src[1] )
                          {
                            Size = (char *)((char *)Src[1] - (char *)Src[0]);
                          }
                          else
                          {
                            memmove(v37, Src[0], (size_t)v30 - (unsigned __int64)Src[0]);
                            v38 = &v37[8 * v31 + 8];
                            Size = (char *)((char *)Src[1] - (char *)v30);
                            v39 = v30;
                          }
                          memmove(v38, v39, (size_t)Size);
                          if ( Src[0] )
                          {
                            sub_14039EFB0((__int64)Src, Src[0], (v48 - (char *)Src[0]) & 0xFFFFFFFFFFFFFFF8uLL);
                          }
                          v10 = v51;
                          Src[1] = &v37[8 * v32];
                          v41 = &v37[v36];
                          v11 = v55;
                          v48 = v41;
                          Src[0] = v37;
                        }
                        else
                        {
                          *(_QWORD *)Src[1] = v20;
                          Src[1] = (char *)Src[1] + 8;
                        }
                        v7 = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v51 = ++v10;
    }
    while ( v10 != v11 );
    v2 = v59;
  }
  sub_145A8EA10(Src[0], Src[1], ((char *)Src[1] - (char *)Src[0]) >> 3, (unsigned __int8)v59);
  v42 = Src[1];
  v43 = Src[0];
  if ( Src[0] != Src[1] )
  {
    do
    {
      v59 = *(_QWORD *)((*v43 & 0xFFFFFFFFFFFFLL) + 8);
      sub_1402A4690((char **)v2, &v59);
      ++v43;
    }
    while ( v43 != v42 );
    v43 = Src[0];
  }
  if ( v43 )
  {
    sub_14039EFB0((__int64)Src, v43, (v48 - (char *)v43) & 0xFFFFFFFFFFFFFFF8uLL);
    *(_OWORD *)Src = 0;
    v48 = 0;
  }
  v44 = *((_DWORD *)v3 + 2);
  if ( v44 )
  {
    *((_DWORD *)v3 + 2) = v44 - 1;
  }
  else
  {
    *((_DWORD *)v3 + 1) = 0xFFFFFFFF;
    v45 = _InterlockedCompareExchange((volatile signed __int32 *)v3, 0, 1);
    if ( v45 != 1 )
    {
      sub_1403D6A80((volatile signed __int32 *)v3, v45);
    }
  }
  return v7;
}

// --- End Function: sub_145A9BDF0 (0x145A9BDF0) ---

// --- Function: sub_145FE4CF0 (0x145FE4CF0) ---
void __fastcall sub_145FE4CF0(_QWORD *a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rax
  ULONG_PTR Parameter; // [rsp+20h] [rbp-38h] BYREF
  _QWORD *v6; // [rsp+28h] [rbp-30h]
  _QWORD *v7; // [rsp+30h] [rbp-28h]
  void *v8; // [rsp+38h] [rbp-20h]
  _QWORD *v9; // [rsp+40h] [rbp-18h]

  v9 = a1;
  v8 = &unk_147F3417C;
  v6 = a1;
  _((__int64)&Parameter);
  if ( a2 )
  {
    sub_143BFB360(a1, a2);
    v7 = a1;
    v4 = sub_145FF5C40(*a3, *a4, *v6, v9);
    v6[1] = v4;
    v7 = 0;
  }
  _StarEngineModule__((ULONG_PTR)&Parameter);
}

// --- End Function: sub_145FE4CF0 (0x145FE4CF0) ---

// --- Function: sub_145FE60C0 (0x145FE60C0) ---
__int64 __fastcall sub_145FE60C0(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+28h] [rbp-80h]
  __int64 v4; // [rsp+78h] [rbp-30h]

  if ( a1[2] <= (unsigned __int64)(a1[4] + 1LL) )
  {
    sub_14611BA20(a1, 1);
  }
  a1[3] &= a1[2] - 1LL;
  v3 = (a1[2] - 1LL) & (a1[4] + a1[3]);
  if ( !*(_QWORD *)(a1[1] + 8 * v3) )
  {
    *(_QWORD *)(a1[1] + 8 * v3) = std::_Allocate<16,std::_Default_allocate_traits,0>(0x98u);
  }
  v4 = sub_1402A0F70(0x98, *(_QWORD *)(a1[1] + 8 * v3));
  sub_14600DD80(v4, a2);
  result = a1[4] + 1LL;
  a1[4] = result;
  return result;
}

// --- End Function: sub_145FE60C0 (0x145FE60C0) ---

// --- Function: sub_145FF7F50 (0x145FF7F50) ---
__int64 __fastcall sub_145FF7F50(
        __int64 a1,
        __int64 a2,
        int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403AFA50();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403E6C00;
  *(_QWORD *)(a1 + 0x20) = sub_1403E6700;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E2C50;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = free_memory_wrapper_w_1;
  *(_QWORD *)(a1 + 0x48) = allocWithoutProfiling_w;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  return sub_145FFC250((int)a1 + 0x68, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) + 1;
}

// --- End Function: sub_145FF7F50 (0x145FF7F50) ---

// --- Function: sub_145FF9210 (0x145FF9210) ---
__int64 __fastcall sub_145FF9210(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = sub_1403AFA50();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403E6C00;
  *(_QWORD *)(a1 + 0x20) = sub_1403E6700;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E2C50;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = free_memory_wrapper_w_1;
  *(_QWORD *)(a1 + 0x48) = allocWithoutProfiling_w;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  return sub_146000670((int)a1 + 0x68, a3, a4, a5, a6) + 1;
}

// --- End Function: sub_145FF9210 (0x145FF9210) ---

// --- Function: sub_146003A00 (0x146003A00) ---
__int64 __fastcall sub_146003A00(__int64 a1, __int64 a2, __int64 a3)
{
  while ( a1 != a2 && !sub_1405AC280(a1 + 8, a3) )
  {
    a1 += 0xD0;
  }
  return a1;
}

// --- End Function: sub_146003A00 (0x146003A00) ---

// --- Function: sub_1460057D0 (0x1460057D0) ---
__int64 __fastcall sub_1460057D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // [rsp+20h] [rbp-18h]
  __int64 v5; // [rsp+40h] [rbp+8h]

  v5 = a1;
  for ( i = (a2 - a1) / 0xD0; i > 0; --i )
  {
    sub_143A9DF70(a3, v5);
    sub_146012A90(a3 + 0xB8, v5 + 0xB8);
    v5 += 0xD0;
    a3 += 0xD0;
  }
  return a3;
}

// --- End Function: sub_1460057D0 (0x1460057D0) ---

// --- Function: sub_146006F50 (0x146006F50) ---
__int64 __fastcall sub_146006F50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+20h] [rbp-48h]
  __int64 v5; // [rsp+28h] [rbp-40h]

  v5 = a1;
  v4 = (a2 - a1) / 0xD0;
  while ( v4 > 0 )
  {
    if ( (unsigned __int8)sub_140335630(a3 + 0x28, 0xD0 * (v4 / 2) + v5 + 0x28) )
    {
      v4 /= 2;
    }
    else
    {
      v5 += 0xD0 * (v4 / 2) + 0xD0;
      v4 -= v4 / 2 + 1;
    }
  }
  return v5;
}

// --- End Function: sub_146006F50 (0x146006F50) ---

// --- Function: sub_146007080 (0x146007080) ---
__int64 __fastcall sub_146007080(__int64 a1, _QWORD *a2)
{
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = a2[1];
  *(_QWORD *)(a1 + 0x10) = a2[2];
  *(_DWORD *)(a1 + 0x18) = 0xFFFFFFFF;
  sub_140973B70(a1);
  return a1;
}

// --- End Function: sub_146007080 (0x146007080) ---

// --- Function: sub_146008970 (0x146008970) ---
_QWORD *__fastcall sub_146008970(_QWORD *a1, _QWORD *a2)
{
  _BYTE v3[8]; // [rsp+20h] [rbp-38h] BYREF
  _QWORD *v4; // [rsp+30h] [rbp-28h]
  _QWORD *v5; // [rsp+38h] [rbp-20h]
  _BYTE *v6; // [rsp+48h] [rbp-10h]

  v5 = a1;
  v6 = v3;
  v3[2] = v3[1];
  v4 = a1;
  *a1 = 0;
  v4[1] = 0;
  v4[2] = 0;
  sub_145FE4CF0(a1, (a2[1] - *a2) / 0xB8LL, a2, a2 + 1);
  return a1;
}

// --- End Function: sub_146008970 (0x146008970) ---

// --- Function: sub_14600DEE0 (0x14600DEE0) ---
__int64 __fastcall sub_14600DEE0(__int64 a1)
{
  *(_DWORD *)a1 = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 4) = 0xE;
  qmemcpy((void *)(a1 + 8), &src__3, 0x18u);
  qmemcpy((void *)(a1 + 0x20), &src__3, 0x18u);
  sub_142A18E60((_QWORD *)(a1 + 0x38));
  sub_142A18E60((_QWORD *)(a1 + 0x50));
  sub_1402AF610((_QWORD *)(a1 + 0x68));
  *(_BYTE *)(a1 + 0x70) = 0;
  *(_DWORD *)(a1 + 0x74) = 6;
  sub_1402AF610((_QWORD *)(a1 + 0x78));
  sub_1402AF610((_QWORD *)(a1 + 0x80));
  initializeEmptyStringStructure((_QWORD *)(a1 + 0x88));
  sub_1402AF610((_QWORD *)(a1 + 0x90));
  return a1;
}

// --- End Function: sub_14600DEE0 (0x14600DEE0) ---

// --- Function: sub_146012830 (0x146012830) ---
_QWORD *__fastcall sub_146012830(_QWORD *a1, _QWORD *a2)
{
  int v3; // [rsp+20h] [rbp-38h]

  if ( a1 != a2 )
  {
    LOBYTE(v3) = 0;
    BYTE1(v3) = HIBYTE(v3);
    BYTE2(v3) = HIBYTE(v3);
    sub_145FD36F0(a1, *a2, a2[1], HIBYTE(v3), v3, a2[1], *a2);
  }
  return a1;
}

// --- End Function: sub_146012830 (0x146012830) ---

// --- Function: sub_146026600 (0x146026600) ---
__int64 sub_146026600(__int64 rcx0, int edx0, const void *src, _QWORD *a4, const void *src_1, _QWORD *arg28, ...)
{
  __int64 v6; // r8
  __int64 v7; // rdx
  AK::WriteBytesMem *v8; // rax
  unsigned __int8 *v9; // rax
  AK::WriteBytesMem *v10; // rax
  unsigned __int8 *v11; // rax
  void *v12; // rsp
  __int64 a8; // [rsp+18h] [rbp-5F8h]
  _BYTE v15[1328]; // [rsp+60h] [rbp-5B0h] BYREF
  const char *v16; // [rsp+5B0h] [rbp-60h]
  BOOL v17; // [rsp+610h] [rbp+0h]
  int v18; // [rsp+614h] [rbp+4h]
  int v19; // [rsp+618h] [rbp+8h]
  int v20; // [rsp+620h] [rbp+10h]
  unsigned int v21; // [rsp+628h] [rbp+18h]
  _DWORD v22[2]; // [rsp+630h] [rbp+20h] BYREF
  char v23; // [rsp+638h] [rbp+28h] BYREF
  _DWORD v24[2]; // [rsp+640h] [rbp+30h] BYREF
  char v25; // [rsp+648h] [rbp+38h] BYREF
  __int64 v26; // [rsp+650h] [rbp+40h]
  __int64 v27; // [rsp+658h] [rbp+48h]
  __int64 v28; // [rsp+660h] [rbp+50h]
  unsigned __int64 v29; // [rsp+668h] [rbp+58h]
  __int64 v30; // [rsp+670h] [rbp+60h]
  __int64 v31; // [rsp+678h] [rbp+68h]
  __int64 *v32; // [rsp+680h] [rbp+70h]
  __int64 **v33; // [rsp+688h] [rbp+78h]
  ULONG_PTR Parameter; // [rsp+690h] [rbp+80h]
  __int64 v35; // [rsp+698h] [rbp+88h]
  const char *p_NULL; // [rsp+6A0h] [rbp+90h]
  const char *p_No; // [rsp+6A8h] [rbp+98h]
  __int64 v38; // [rsp+6B0h] [rbp+A0h]
  const char *p_NULL_1; // [rsp+6B8h] [rbp+A8h]
  __int64 v40; // [rsp+6C0h] [rbp+B0h]
  const char *p_NULL_2; // [rsp+6C8h] [rbp+B8h]
  _BYTE *v42; // [rsp+6D0h] [rbp+C0h]
  __int64 v43; // [rsp+6D8h] [rbp+C8h]
  __int64 v44; // [rsp+6E0h] [rbp+D0h]
  __int64 v45; // [rsp+6E8h] [rbp+D8h]
  __int64 v46; // [rsp+6F0h] [rbp+E0h] BYREF
  void (__fastcall *v47)(__int64, __int64, __int64, _QWORD); // [rsp+6F8h] [rbp+E8h]
  __int64 v48; // [rsp+700h] [rbp+F0h]
  unsigned __int64 v49; // [rsp+708h] [rbp+F8h]
  __int64 *v50; // [rsp+710h] [rbp+100h]
  __int64 v51; // [rsp+718h] [rbp+108h]
  __int64 *v52; // [rsp+720h] [rbp+110h]
  int *v53; // [rsp+728h] [rbp+118h]
  const char *v54; // [rsp+730h] [rbp+120h]
  unsigned __int8 *v55; // [rsp+738h] [rbp+128h]
  __int64 v56; // [rsp+740h] [rbp+130h]
  __int64 v57; // [rsp+748h] [rbp+138h]
  const char *v58; // [rsp+750h] [rbp+140h]
  unsigned __int64 v59; // [rsp+758h] [rbp+148h] BYREF
  __int64 v60; // [rsp+760h] [rbp+150h] BYREF
  _QWORD *v61; // [rsp+768h] [rbp+158h]
  _QWORD *v62; // [rsp+770h] [rbp+160h]
  _QWORD *v63; // [rsp+778h] [rbp+168h]
  _QWORD *v64; // [rsp+780h] [rbp+170h]
  _QWORD *v65; // [rsp+788h] [rbp+178h]
  _QWORD *a10; // [rsp+790h] [rbp+180h]
  _QWORD *a9; // [rsp+798h] [rbp+188h]
  _QWORD *v68; // [rsp+7A0h] [rbp+190h]
  _QWORD *a7; // [rsp+7A8h] [rbp+198h]
  _QWORD *a6; // [rsp+7B0h] [rbp+1A0h]
  _QWORD *a5; // [rsp+7B8h] [rbp+1A8h]
  _QWORD *v72; // [rsp+7C0h] [rbp+1B0h]
  _QWORD *v73; // [rsp+7C8h] [rbp+1B8h]
  __int64 *ThreadLogContextSlot; // [rsp+7D0h] [rbp+1C0h]
  const void *ptr_to_free_11; // [rsp+7D8h] [rbp+1C8h]
  const void *ptr_to_free_12; // [rsp+7E0h] [rbp+1D0h]
  const void *ptr_to_free_13; // [rsp+7E8h] [rbp+1D8h]
  const void *ptr_to_free_14; // [rsp+7F0h] [rbp+1E0h]
  const void *ptr_to_free_15; // [rsp+7F8h] [rbp+1E8h]
  const void *ptr_to_free_16; // [rsp+800h] [rbp+1F0h]
  const void *ptr_to_free_17; // [rsp+808h] [rbp+1F8h]
  const void *ptr_to_free_18; // [rsp+810h] [rbp+200h]
  const void *ptr_to_free_19; // [rsp+818h] [rbp+208h]
  const void *ptr_to_free_20; // [rsp+820h] [rbp+210h]
  const void *ptr_to_free_21; // [rsp+828h] [rbp+218h]
  __int64 v86; // [rsp+830h] [rbp+220h] BYREF
  __int64 (__fastcall *v87)(__int64, _BYTE *); // [rsp+838h] [rbp+228h]
  __int64 (__fastcall *v88)(__int64, _BYTE *); // [rsp+840h] [rbp+230h]
  _QWORD v89[2]; // [rsp+848h] [rbp+238h] BYREF
  const void *ptr_to_free_6; // [rsp+858h] [rbp+248h]
  _QWORD v91[2]; // [rsp+860h] [rbp+250h] BYREF
  __int64 v92; // [rsp+870h] [rbp+260h]
  _QWORD v93[2]; // [rsp+878h] [rbp+268h] BYREF
  const void *ptr_to_free; // [rsp+888h] [rbp+278h]
  _QWORD v95[2]; // [rsp+890h] [rbp+280h] BYREF
  const void *ptr_to_free_1; // [rsp+8A0h] [rbp+290h]
  _QWORD v97[2]; // [rsp+8A8h] [rbp+298h] BYREF
  const void *ptr_to_free_4; // [rsp+8B8h] [rbp+2A8h]
  _QWORD v99[2]; // [rsp+8C0h] [rbp+2B0h] BYREF
  const void *ptr_to_free_5; // [rsp+8D0h] [rbp+2C0h]
  _QWORD v101[2]; // [rsp+8D8h] [rbp+2C8h] BYREF
  const void *ptr_to_free_7; // [rsp+8E8h] [rbp+2D8h]
  _QWORD v103[2]; // [rsp+8F0h] [rbp+2E0h] BYREF
  const void *ptr_to_free_8; // [rsp+900h] [rbp+2F0h]
  _QWORD v105[2]; // [rsp+908h] [rbp+2F8h] BYREF
  const void *ptr_to_free_9; // [rsp+918h] [rbp+308h]
  _QWORD v107[2]; // [rsp+920h] [rbp+310h] BYREF
  const void *ptr_to_free_10; // [rsp+930h] [rbp+320h]
  _DWORD v109[2]; // [rsp+940h] [rbp+330h] BYREF
  _BYTE dst_[24]; // [rsp+948h] [rbp+338h] BYREF
  _BYTE dst__1[24]; // [rsp+960h] [rbp+350h] BYREF
  _QWORD v112[3]; // [rsp+978h] [rbp+368h] BYREF
  _QWORD v113[3]; // [rsp+990h] [rbp+380h] BYREF
  unsigned __int64 v114; // [rsp+9A8h] [rbp+398h] BYREF
  char v115; // [rsp+9B0h] [rbp+3A0h]
  int v116; // [rsp+9B4h] [rbp+3A4h]
  __int64 v117; // [rsp+9B8h] [rbp+3A8h]
  unsigned __int64 v118; // [rsp+9C0h] [rbp+3B0h] BYREF
  void *v119[3]; // [rsp+9C8h] [rbp+3B8h] BYREF
  _QWORD v120[2]; // [rsp+9E0h] [rbp+3D0h] BYREF
  _QWORD v121[2]; // [rsp+9F0h] [rbp+3E0h] BYREF
  _QWORD src__1[2]; // [rsp+A00h] [rbp+3F0h] BYREF
  _QWORD v123[2]; // [rsp+A10h] [rbp+400h] BYREF
  _QWORD src_[2]; // [rsp+A20h] [rbp+410h] BYREF
  __int64 *v125[5]; // [rsp+A30h] [rbp+420h] BYREF
  _BYTE v126[8]; // [rsp+A58h] [rbp+448h] BYREF
  _BYTE v127[8]; // [rsp+A60h] [rbp+450h] BYREF
  _BYTE dst__2[16]; // [rsp+A68h] [rbp+458h] BYREF
  __int64 dst__3[2]; // [rsp+A78h] [rbp+468h] BYREF
  _QWORD v130[2]; // [rsp+A88h] [rbp+478h] BYREF
  const void *ptr_to_free_2; // [rsp+A98h] [rbp+488h]
  _QWORD v132[2]; // [rsp+AA0h] [rbp+490h] BYREF
  const void *ptr_to_free_3; // [rsp+AB0h] [rbp+4A0h]
  __int64 v134; // [rsp+AB8h] [rbp+4A8h] BYREF
  __int64 v135; // [rsp+AC8h] [rbp+4B8h]
  __int64 a1[68]; // [rsp+AD0h] [rbp+4C0h] BYREF
  _BYTE v137[544]; // [rsp+CF0h] [rbp+6E0h] BYREF
  _BYTE v138[544]; // [rsp+F10h] [rbp+900h] BYREF
  __int64 v143; // [rsp+1190h] [rbp+B80h] BYREF
  va_list va; // [rsp+1190h] [rbp+B80h]
  __int64 v145; // [rsp+1198h] [rbp+B88h]
  __int64 v146; // [rsp+11A0h] [rbp+B90h]
  __int64 v147; // [rsp+11A8h] [rbp+B98h]
  __int64 v148; // [rsp+11B0h] [rbp+BA0h]
  va_list va1; // [rsp+11B8h] [rbp+BA8h] BYREF

  va_start(va1, arg28);
  va_start(va, arg28);
  v143 = va_arg(va1, _QWORD);
  v145 = va_arg(va1, _QWORD);
  v146 = va_arg(va1, _QWORD);
  v147 = va_arg(va1, _QWORD);
  v148 = va_arg(va1, _QWORD);
  sub_1402AC3D0(&v86, (__int64)"CSCLocalPlayerPersonalThoughtComponent::AddInventoryManagementMove", rcx0 + 0x348, 1);
  v26 = rcx0 + 0x358;
  sub_14188AE40((__int64)v125, rcx0 + 0x358, rcx0 + 0x380);
  sub_14600DEE0((__int64)v109);
  v109[0] = (unsigned __int16)InterlockedIncrement16_w(&word_149B35A6C);
  v27 = *(_QWORD *)(_((__int64)&gEnv) + 0x60);
  v87 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v27 + 0x48LL);
  *(_QWORD *)(rcx0 + 0x2D0) = *(_QWORD *)v87(v27, v126);
  v28 = *(_QWORD *)(_((__int64)&gEnv) + 0x60);
  v88 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v28 + 0x48LL);
  v117 = *(_QWORD *)v88(v28, v127);
  v109[1] = edx0;
  qmemcpy(dst_, src, sizeof(dst_));
  qmemcpy(dst__1, src_1, sizeof(dst__1));
  if ( a4 )
  {
    sub_146012830(v112, a4);
  }
  if ( arg28 )
  {
    sub_146012830(v113, arg28);
  }
  if ( AssetMeta::HasActorSubresource((__int64 *)va) )
  {
    v44 = v143 & 0xFFFFFFFFFFFFLL;
    v29 = sub_1403E1BB0((unsigned __int64 *)((v143 & 0xFFFFFFFFFFFFLL) + 8));
    if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)v29 + 0x710LL))(v29) )
    {
      v30 = v143 & 0xFFFFFFFFFFFFLL;
      v115 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v143 & 0xFFFFFFFFFFFFLL) + 0x5F8LL))(v143 & 0xFFFFFFFFFFFFLL);
      v45 = v143 & 0xFFFFFFFFFFFFLL;
      v46 = *(_QWORD *)((v143 & 0xFFFFFFFFFFFFLL) + 8);
      v31 = Handle::ToIndex(&v46);
      v47 = *(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)v31 + 0x308LL);
      LOBYTE(v6) = 1;
      LOBYTE(v7) = 1;
      v47(v31, v7, v6, 0);
    }
    v48 = v143 & 0xFFFFFFFFFFFFLL;
    v49 = *(_QWORD *)((v143 & 0xFFFFFFFFFFFFLL) + 8);
    v114 = v49;
  }
  v118 = *(_QWORD *)v145;
  copyStringStructure(v119, (const void **)(v145 + 8));
  v119[1] = *(void **)(v145 + 0x10);
  sub_145A7B2B0(v118);
  v116 = v147;
  sub_1402A0D40((__int64)a1);
  v33 = v125;
  v32 = v125[0];
  v50 = v125[0];
  v51 = v125[0][3];
  sub_143271EA0(v91, v51, v125[0]);
  v52 = v125[0];
  sub_142E6E0D0(v125[0], &v134);
  while ( 1 )
  {
    v17 = v92 == v135;
    if ( v92 == v135 )
    {
      break;
    }
    v53 = (int *)sub_140DA5650(v91);
    v19 = *v53;
    v54 = (const char *)AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)a1);
    sub_1402A1380(a1, "%s %u", v54, v19);
    ++v92;
  }
  Parameter = (ULONG_PTR)v125[0];
  _StarEngineModule__((ULONG_PTR)v125[0]);
  sub_145FE60C0((_QWORD *)Parameter, (__int64)v109);
  v22[0] = sub_142656CA0(0x1Bu);
  v22[1] = 0x4D;
  src_[0] = v22;
  src_[1] = &v23;
  qmemcpy(dst__2, src_, sizeof(dst__2));
  v18 = invokeGlobalCallbackAndMaskStatusBits(
          5,
          (__int64)dst__2,
          (__int64)"InventoryManagement",
          "New request[$$] Player[$$] Type[$$] SourceInventory[$$] TargetInventory[$$] ItemClass[$$] StoredEntity[$$] Loc"
          "allyDetached[$$] LocalAttached[$$, $$] PendingMoves[$$, $$] Caller[%s]",
          v16);
  if ( (v18 & 0xFFFFF) != 0 )
  {
    v107[0] = 0;
    v107[1] = v148;
    ptr_to_free_10 = 0;
    v61 = v107;
    v55 = AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)a1);
    v105[0] = 0;
    v105[1] = v55;
    ptr_to_free_9 = 0;
    v62 = v105;
    v56 = v125[0][4];
    v120[0] = 0;
    v120[1] = v56;
    v63 = v120;
    v57 = SEntityProxy::AsJson((__int64)v119);
    v103[0] = 0;
    v103[1] = v57;
    ptr_to_free_8 = 0;
    v64 = v103;
    if ( is_valid_handle_typeB(&v118) )
    {
      v35 = Handle::ToIndex(&v118);
      p_NULL = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v35 + 0x70LL))(v35);
    }
    else
    {
      p_NULL = "NULL";
    }
    v101[0] = 0;
    v101[1] = p_NULL;
    ptr_to_free_7 = 0;
    v65 = v101;
    if ( v115 )
    {
      p_No = "Yes";
    }
    else
    {
      p_No = "No";
    }
    v89[0] = 0;
    v89[1] = p_No;
    ptr_to_free_6 = 0;
    a10 = v89;
    if ( is_valid_handle_typeB(&v114) )
    {
      v38 = Handle::ToIndex(&v114);
      p_NULL_1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 0x70LL))(v38);
    }
    else
    {
      p_NULL_1 = "NULL";
    }
    v99[0] = 0;
    v99[1] = p_NULL_1;
    ptr_to_free_5 = 0;
    a9 = v99;
    v97[0] = 0;
    v97[1] = v146;
    ptr_to_free_4 = 0;
    v68 = v97;
    v8 = (AK::WriteBytesMem *)sub_1405AC850((__int64)src_1, (__int64)v137);
    v9 = AK::WriteBytesMem::Bytes(v8);
    sub_140357E70(v132, v9, 1, 0);
    sub_1402A0F30((__int64)v137);
    a7 = v132;
    v10 = (AK::WriteBytesMem *)sub_1405AC850((__int64)src, (__int64)v138);
    v11 = AK::WriteBytesMem::Bytes(v10);
    sub_140357E70(v130, v11, 1, 0);
    sub_1402A0F30((__int64)v138);
    a6 = v130;
    v58 = sub_143B2BAC0(edx0, "UNDEFINED");
    v95[0] = 0;
    v95[1] = v58;
    ptr_to_free_1 = 0;
    a5 = v95;
    v59 = *(_QWORD *)(rcx0 + 8);
    if ( is_valid_handle_typeB(&v59) )
    {
      v60 = *(_QWORD *)(rcx0 + 8);
      v40 = Handle::ToIndex(&v60);
      p_NULL_2 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v40 + 0x70LL))(v40);
    }
    else
    {
      p_NULL_2 = "NULL";
    }
    v93[0] = 0;
    v93[1] = p_NULL_2;
    ptr_to_free = 0;
    v72 = v93;
    v20 = v109[0];
    v121[0] = 0;
    v121[1] = v109[0];
    v73 = v121;
    ThreadLogContextSlot = getThreadLogContextSlot();
    v123[0] = 0;
    v123[1] = 0;
    v24[0] = sub_142656CA0(0x1Bu);
    v24[1] = 0x4D;
    src__1[0] = v24;
    src__1[1] = &v25;
    qmemcpy(dst__3, src__1, sizeof(dst__3));
    v125[4] = (__int64 *)0xE;
    v12 = alloca(0x5B0);
    v42 = v15;
    v43 = (__int64)v15;
    sub_145FF7F50(
      (__int64)v15,
      (__int64)ThreadLogContextSlot,
      (int)v73,
      (int)v72,
      (__int64)a5,
      (__int64)a6,
      (__int64)a7,
      (__int64)v68,
      (__int64)a9,
      (__int64)a10,
      (__int64)v65,
      (__int64)v64,
      (__int64)v63,
      (__int64)v62,
      (__int64)v61);
    LODWORD(a8) = v18;
    sub_140302350(
      5,
      (__int64)dst__3,
      "InventoryManagement",
      (__int64)"New request[$$] Player[$$] Type[$$] SourceInventory[$$] TargetInventory[$$] ItemClass[$$] StoredEntity[$$"
               "] LocallyDetached[$$] LocalAttached[$$, $$] PendingMoves[$$, $$] Caller[%s]",
      v43,
      0xE,
      1,
      a8,
      v123,
      0);
    ptr_to_free_11 = ptr_to_free;
    free_memory_wrapper(ptr_to_free);
    ptr_to_free_12 = ptr_to_free_1;
    free_memory_wrapper(ptr_to_free_1);
    ptr_to_free_13 = ptr_to_free_2;
    free_memory_wrapper(ptr_to_free_2);
    ptr_to_free_14 = ptr_to_free_3;
    free_memory_wrapper(ptr_to_free_3);
    ptr_to_free_15 = ptr_to_free_4;
    free_memory_wrapper(ptr_to_free_4);
    ptr_to_free_16 = ptr_to_free_5;
    free_memory_wrapper(ptr_to_free_5);
    ptr_to_free_17 = ptr_to_free_6;
    free_memory_wrapper(ptr_to_free_6);
    ptr_to_free_18 = ptr_to_free_7;
    free_memory_wrapper(ptr_to_free_7);
    ptr_to_free_19 = ptr_to_free_8;
    free_memory_wrapper(ptr_to_free_8);
    ptr_to_free_20 = ptr_to_free_9;
    free_memory_wrapper(ptr_to_free_9);
    ptr_to_free_21 = ptr_to_free_10;
    free_memory_wrapper(ptr_to_free_10);
  }
  sub_1402AF610(&v114);
  sub_1402AF610(&v118);
  v21 = v109[0];
  sub_1402A0F30((__int64)a1);
  sub_14327A430((__int64)v109);
  sub_1402AF8A0((__int64)v125);
  sub_1402AF7F0(&v86);
  return v21;
}

// --- End Function: sub_146026600 (0x146026600) ---

// --- Function: sub_14603C6A0 (0x14603C6A0) ---
bool __fastcall sub_14603C6A0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, const void *src)
{
  __int64 AssetMeta; // rax
  bool v7; // [rsp+20h] [rbp-178h]
  _QWORD *Parameter__3; // [rsp+30h] [rbp-168h]
  __int64 v9; // [rsp+40h] [rbp-158h]
  _QWORD *v10; // [rsp+48h] [rbp-150h]
  ULONG_PTR Parameter[2]; // [rsp+58h] [rbp-140h] BYREF
  ULONG_PTR Parameter_; // [rsp+68h] [rbp-130h] BYREF
  unsigned __int64 v13[2]; // [rsp+70h] [rbp-128h] BYREF
  ULONG_PTR Parameter__7; // [rsp+80h] [rbp-118h] BYREF
  __int64 *v15; // [rsp+88h] [rbp-110h]
  __int64 v16; // [rsp+90h] [rbp-108h]
  void (__fastcall *v17)(__int64, unsigned __int64 *, __int64); // [rsp+98h] [rbp-100h]
  __int64 v18; // [rsp+A0h] [rbp-F8h]
  ULONG_PTR Parameter__11; // [rsp+A8h] [rbp-F0h]
  Parameter *Parameter_2; // [rsp+B0h] [rbp-E8h]
  ULONG_PTR Parameter__12; // [rsp+B8h] [rbp-E0h]
  Parameter *Parameter_3; // [rsp+C0h] [rbp-D8h]
  ULONG_PTR Parameter__9; // [rsp+C8h] [rbp-D0h]
  ULONG_PTR Parameter__1; // [rsp+D0h] [rbp-C8h]
  ULONG_PTR Parameter__13; // [rsp+D8h] [rbp-C0h]
  ULONG_PTR Parameter__2; // [rsp+E0h] [rbp-B8h]
  _QWORD *Parameter__4; // [rsp+E8h] [rbp-B0h]
  _QWORD *Parameter__5; // [rsp+F0h] [rbp-A8h]
  _QWORD *Parameter__6; // [rsp+F8h] [rbp-A0h]
  _QWORD v30[3]; // [rsp+100h] [rbp-98h] BYREF
  _QWORD *v31; // [rsp+118h] [rbp-80h]
  Parameter *Parameter_1; // [rsp+120h] [rbp-78h]
  __int64 v33; // [rsp+128h] [rbp-70h] BYREF
  __int64 v34; // [rsp+130h] [rbp-68h]
  ULONG_PTR Parameter__8; // [rsp+138h] [rbp-60h] BYREF
  ULONG_PTR Parameter__10; // [rsp+140h] [rbp-58h]
  __int64 v37; // [rsp+150h] [rbp-48h] BYREF
  _BYTE dst_[56]; // [rsp+160h] [rbp-38h] BYREF

  v7 = 0;
  v9 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
  v17 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v9 + 0x120LL);
  v16 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
           a2,
           &v37);
  v17(v9, v13, v16);
  if ( is_valid_handle_typeB(v13) )
  {
    unknown_libname_472(&Parameter__8);
    v18 = *(_QWORD *)(a1 + 0x1A0) & 0xFFFFFFFFFFFFLL;
    AssetMeta = AssetDB::GetAssetMeta(v18);
    v10 = (_QWORD *)sub_1404AB370(AssetMeta);
    if ( v10 )
    {
      sub_145A9BDF0(v10, (__int64)&Parameter__8);
    }
    Parameter_2 = &Parameter__8;
    Parameter__11 = Parameter__10;
    Parameter[0] = Parameter__10;
    _StarEngineModule__((ULONG_PTR)Parameter);
    Parameter__9 = Parameter[0];
    Parameter[1] = (ULONG_PTR)&Parameter__8;
    Parameter_3 = &Parameter__8;
    Parameter__12 = Parameter__8;
    Parameter_ = Parameter__8;
    _StarEngineModule__((ULONG_PTR)&Parameter_);
    Parameter__1 = Parameter_;
    Parameter__13 = Parameter__9;
    Parameter__4 = (_QWORD *)Parameter__9;
    Parameter__2 = Parameter_;
    for ( Parameter__3 = (_QWORD *)Parameter_;
          Parameter__3 != Parameter__4
       && !std::operator==<_EXCEPTION_RECORD const,_EXCEPTION_RECORD const>(Parameter__3, v13);
          ++Parameter__3 )
    {
      ;
    }
    Parameter__5 = Parameter__3;
    Parameter__6 = Parameter__3;
    v30[0] = Parameter__3;
    v31 = v30;
    v13[1] = (unsigned __int64)&Parameter__8;
    v30[2] = &Parameter__8;
    v30[1] = Parameter__10;
    Parameter__7 = Parameter__10;
    _StarEngineModule__((ULONG_PTR)&Parameter__7);
    Parameter_1 = &Parameter__7;
    v7 = *v31 != Parameter__7;
    sub_1402B07B0((__int64)&Parameter__8);
  }
  if ( v7 )
  {
    return 1;
  }
  sub_1403A7040(&v33);
  v15 = &v33;
  v34 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 0x78LL))(a4);
  if ( (unsigned __int8)sub_1403B6270(v34, (__int64)v15) )
  {
    return 0;
  }
  if ( !sub_1405AC2A0((__int64)src, (__int64)&src__3) )
  {
    return 1;
  }
  qmemcpy(dst_, src, 0x18u);
  return (unsigned __int8)sub_146041670(a1, dst_, v15) == 0;
}

// --- End Function: sub_14603C6A0 (0x14603C6A0) ---

// --- Function: sub_146041670 (0x146041670) ---
__int64 __fastcall sub_146041670(__int64 a1, _BYTE *dst, __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rdx
  __int64 v6; // rdx
  unsigned __int8 v7; // [rsp+21h] [rbp-127h]
  unsigned __int64 i; // [rsp+28h] [rbp-120h]
  _QWORD *v9; // [rsp+30h] [rbp-118h] BYREF
  unsigned __int64 v10; // [rsp+38h] [rbp-110h]
  _QWORD *v11; // [rsp+40h] [rbp-108h]
  __int64 v12; // [rsp+48h] [rbp-100h]
  _QWORD *v13; // [rsp+50h] [rbp-F8h]
  __int64 v14; // [rsp+58h] [rbp-F0h]
  __int64 *v15; // [rsp+60h] [rbp-E8h]
  __int64 **v16; // [rsp+68h] [rbp-E0h]
  __int64 *v17; // [rsp+70h] [rbp-D8h]
  ULONG_PTR Parameter[4]; // [rsp+78h] [rbp-D0h] BYREF
  struct __crt_stdio_stream *v19; // [rsp+98h] [rbp-B0h]
  __int64 *v20; // [rsp+A0h] [rbp-A8h]
  ULONG_PTR v21; // [rsp+A8h] [rbp-A0h]
  _QWORD *v22; // [rsp+B0h] [rbp-98h]
  _QWORD *v23; // [rsp+B8h] [rbp-90h]
  __int64 v24; // [rsp+C0h] [rbp-88h]
  __int64 v25; // [rsp+C8h] [rbp-80h]
  _QWORD *v26; // [rsp+D0h] [rbp-78h]
  _QWORD *v27; // [rsp+D8h] [rbp-70h]
  _QWORD *v28; // [rsp+E0h] [rbp-68h]
  __int64 *v29[5]; // [rsp+E8h] [rbp-60h] BYREF
  _BYTE dst_[56]; // [rsp+110h] [rbp-38h] BYREF

  v14 = a1 + 0x290;
  sub_141509F20(v29, a1 + 0x290, a1 + 0x2A0);
  v16 = v29;
  v15 = v29[0];
  Parameter[3] = (ULONG_PTR)v29[0];
  v19 = (struct __crt_stdio_stream *)sub_14326D650(v29[0], (__int64)dst);
  _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
    (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&v9,
    v19);
  if ( !sub_1405AC2A0((__int64)dst, (__int64)&src__3) )
  {
    goto LABEL_15;
  }
  v20 = *v16;
  v17 = v20;
  v21 = *v20;
  Parameter[0] = v21;
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( v9 == (_QWORD *)Parameter[0] )
  {
    goto LABEL_15;
  }
  for ( i = 0; ; ++i )
  {
    v22 = v9 + 4;
    Parameter[1] = (ULONG_PTR)(v9 + 0x14);
    if ( i >= (v9[0x15] - v9[0x14]) / 0xD0LL )
    {
      break;
    }
    v23 = v9 + 4;
    v11 = v9 + 0x14;
    if ( i >= (v9[0x15] - v9[0x14]) / 0xD0LL )
    {
      __debugbreak();
    }
    v24 = *v11 + 0xD0 * i;
    v12 = sub_143B2F500(v24);
    if ( v12 )
    {
      v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x78LL))(v12);
      if ( (unsigned __int8)sub_1403B6270(v25, a3) )
      {
        sub_141578BB0(v29, v4);
        return 1;
      }
    }
  }
  v10 = 0;
  v26 = v9 + 4;
  Parameter[2] = (ULONG_PTR)(v9 + 0x17);
  v3 = (v9[0x18] - v9[0x17]) % 0x18LL;
  if ( (v9[0x18] - v9[0x17]) / 0x18LL )
  {
    v27 = v9 + 4;
    v28 = v9 + 0x17;
    v13 = v9 + 0x17;
    if ( (v9[0x18] - v9[0x17]) / 0x18LL <= v10 )
    {
      __debugbreak();
    }
    qmemcpy(dst_, (const void *)(*v13 + 0x18 * v10), 0x18u);
    v7 = sub_146041670(a1, dst_, a3);
    sub_141578BB0(v29, v6);
    return v7;
  }
  else
  {
LABEL_15:
    sub_141578BB0(v29, v3);
    return 0;
  }
}

// --- End Function: sub_146041670 (0x146041670) ---

// --- Function: sub_146046100 (0x146046100) ---
void __fastcall sub_146046100(__int64 a1, unsigned __int64 a2, int a3, void *a4, __int64 a5)
{
  AK::WriteBytesMem *v5; // rax
  unsigned __int8 *v6; // rax
  int v7; // eax
  const void *src; // rax
  __int64 v9; // [rsp+20h] [rbp-58h]
  __int64 v10; // [rsp+28h] [rbp-50h]
  _BYTE v11[16]; // [rsp+30h] [rbp-48h] BYREF
  _QWORD v12[7]; // [rsp+40h] [rbp-38h] BYREF
  unsigned __int64 v13; // [rsp+88h] [rbp+10h] BYREF
  int v14; // [rsp+90h] [rbp+18h]
  void *v15; // [rsp+98h] [rbp+20h]

  v15 = a4;
  v14 = a3;
  v13 = a2;
  if ( is_valid_handle_typeB(&v13) )
  {
    v10 = Handle::ToIndex(&v13);
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x20LL))(v10);
    if ( v9 )
    {
      *(_DWORD *)(a5 + 0x30) = v14;
      copyStringStructure((void **)(a5 + 0x28), (const void **)v15);
      v5 = (AK::WriteBytesMem *)sub_1403B05B0(v12, v13);
      v6 = AK::WriteBytesMem::Bytes(v5);
      *(_QWORD *)(a5 + 0x38) = v6;
      v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x28LL))(v9);
      *(_DWORD *)(a5 + 0x20) = v7;
      src = (const void *)sub_1403ADFC0((__int64)v11, v13);
      qmemcpy((void *)(a5 + 0x40), src, 0xCu);
      sub_145A6E100(v13);
    }
  }
  DestroyStringObject(v15);
}

// --- End Function: sub_146046100 (0x146046100) ---

// --- Function: sub_146056B30 (0x146056B30) ---
void __fastcall sub_146056B30(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 0x198) |= a2;
}

// --- End Function: sub_146056B30 (0x146056B30) ---

// --- Function: sub_14605D240 (0x14605D240) ---
void **__fastcall sub_14605D240(int a1, void **a2, __int64 a3, __int64 a4, int n2, void **a6, void **a7, bool *a8)
{
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  void **v10; // rax
  _BYTE *v11; // rax
  void **v12; // rax
  void **v13; // rax
  int v14; // eax
  void **v15; // rax
  unsigned __int64 i; // [rsp+38h] [rbp-110h]
  unsigned __int64 v18; // [rsp+80h] [rbp-C8h]
  __int64 v19; // [rsp+98h] [rbp-B0h]
  unsigned __int64 v20; // [rsp+A8h] [rbp-A0h]
  unsigned __int64 v21; // [rsp+B0h] [rbp-98h]
  void *v22; // [rsp+B8h] [rbp-90h] BYREF
  void *v23; // [rsp+C0h] [rbp-88h] BYREF
  void *v24; // [rsp+C8h] [rbp-80h] BYREF
  void *v25; // [rsp+D0h] [rbp-78h] BYREF
  __int64 v26; // [rsp+D8h] [rbp-70h]
  __int64 v27; // [rsp+E0h] [rbp-68h]
  __int64 v28; // [rsp+E8h] [rbp-60h]
  __int64 v29; // [rsp+F0h] [rbp-58h]
  void *v30; // [rsp+F8h] [rbp-50h] BYREF
  __int64 v31; // [rsp+100h] [rbp-48h]
  void *v32; // [rsp+108h] [rbp-40h] BYREF
  void *v33; // [rsp+110h] [rbp-38h] BYREF
  _QWORD v34[4]; // [rsp+128h] [rbp-20h] BYREF

  v34[1] = sub_1403577C0(a2, &qword_149B35AA8);
  copyStringStructure(a6, &qword_149B35AA8);
  copyStringStructure(a7, &qword_149B35AA8);
  *a8 = 0;
  if ( n2 == 2 || n2 == 3 )
  {
    v18 = (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL;
    for ( i = 0; i < v18; ++i )
    {
      if ( i >= (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
      {
        __debugbreak();
      }
      v19 = *(_QWORD *)(a3 + 0x68) + 0xD0 * i;
      *a8 = sub_145A47090(a4, v19, *(_DWORD *)(a3 + 0x5C) != 5);
      if ( *a8 )
      {
        if ( i + 1 < v18 )
        {
          if ( i + 1 >= (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
          {
            __debugbreak();
          }
          copyStringStructure(a7, (const void **)(*(_QWORD *)(a3 + 0x68) + 0xD0 * (i + 1) + 0x28));
        }
        if ( i )
        {
          if ( i - 1 >= (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
          {
            __debugbreak();
          }
          copyStringStructure(a6, (const void **)(*(_QWORD *)(a3 + 0x68) + 0xD0 * (i - 1) + 0x28));
        }
        copyStringStructure(a2, (const void **)(v19 + 0x28));
        break;
      }
    }
  }
  if ( !*a8 )
  {
    if ( n2 && n2 != 2 )
    {
      v26 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
      v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0xC0LL))(v26);
      v14 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v27 + 0x10LL))(v27, *(unsigned int *)(a4 + 0x20));
      v15 = (void **)sub_146076F70(a1, (unsigned int)v34, a3, v14, (__int64)a6, (__int64)a7);
      sub_140374480(a2, v15);
      DestroyStringObject(v34);
    }
    else if ( (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
    {
      if ( *(int *)(a3 + 0xB0) <= 0 )
      {
        if ( !((*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL) )
        {
          __debugbreak();
        }
        v31 = *(_QWORD *)(a3 + 0x68);
        v11 = (_BYTE *)SEntityProxy::AsJson(v31 + 0x28);
        CreateStringObjectFromString(&v25, v11);
        CreateStringObjectFromString(&v24, &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
        v12 = sub_1403A6BF0(&v32, (char **)&v24, (char **)&v25);
        sub_140374480(a2, v12);
        DestroyStringObject(&v32);
        DestroyStringObject(&v24);
        DestroyStringObject(&v25);
      }
      else
      {
        v20 = *(int *)(a3 + 0xB0);
        if ( v20 >= (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
        {
          __debugbreak();
        }
        v28 = *(_QWORD *)(a3 + 0x68) + 0xD0 * v20;
        v8 = (_BYTE *)SEntityProxy::AsJson(v28 + 0x28);
        CreateStringObjectFromString(&v23, v8);
        v21 = *(_DWORD *)(a3 + 0xB0) - 1;
        if ( v21 >= (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
        {
          __debugbreak();
        }
        v29 = *(_QWORD *)(a3 + 0x68) + 0xD0 * v21;
        v9 = (_BYTE *)SEntityProxy::AsJson(v29 + 0x28);
        CreateStringObjectFromString(&v22, v9);
        v10 = sub_1403A6BF0(&v30, (char **)&v22, (char **)&v23);
        sub_140374480(a2, v10);
        DestroyStringObject(&v30);
        DestroyStringObject(&v22);
        DestroyStringObject(&v23);
      }
    }
    else
    {
      v13 = sub_1403A6DB0(&v33);
      sub_140374480(a2, v13);
      DestroyStringObject(&v33);
    }
  }
  return a2;
}

// --- End Function: sub_14605D240 (0x14605D240) ---

// --- Function: sub_146069080 (0x146069080) ---
__int64 __fastcall sub_146069080(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4, __int64 a5)
{
  __int128 v5; // xmm0
  __int128 v6; // xmm1
  __int64 v7; // rdx
  __int64 *v8; // rax
  __int64 v9; // rdx
  _BYTE *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rdx
  __int128 v15; // xmm0
  __int128 v16; // kr00_16
  __int128 v17; // kr00_16
  __int128 v18; // kr00_16
  _QWORD *v20; // [rsp+30h] [rbp-3D8h]
  __int64 v21; // [rsp+38h] [rbp-3D0h]
  __int64 v22; // [rsp+40h] [rbp-3C8h]
  __int64 v23; // [rsp+48h] [rbp-3C0h]
  int i; // [rsp+50h] [rbp-3B8h]
  int v25; // [rsp+54h] [rbp-3B4h]
  int v26; // [rsp+58h] [rbp-3B0h]
  unsigned __int64 k; // [rsp+60h] [rbp-3A8h]
  __int64 v28; // [rsp+68h] [rbp-3A0h]
  unsigned __int64 j; // [rsp+70h] [rbp-398h]
  __int64 v30; // [rsp+80h] [rbp-388h]
  __int64 v31; // [rsp+88h] [rbp-380h]
  _BYTE v32[4]; // [rsp+90h] [rbp-378h] BYREF
  int v33; // [rsp+94h] [rbp-374h]
  unsigned int v34; // [rsp+98h] [rbp-370h]
  unsigned int v35; // [rsp+9Ch] [rbp-36Ch]
  unsigned int v36; // [rsp+A0h] [rbp-368h]
  _BYTE v37[4]; // [rsp+A4h] [rbp-364h] BYREF
  float v38; // [rsp+A8h] [rbp-360h]
  float v39; // [rsp+B0h] [rbp-358h]
  unsigned int v40; // [rsp+B8h] [rbp-350h]
  float v41; // [rsp+C0h] [rbp-348h]
  __int64 v42; // [rsp+C8h] [rbp-340h]
  __int64 v43; // [rsp+D0h] [rbp-338h]
  float v44; // [rsp+D8h] [rbp-330h] BYREF
  float v45; // [rsp+DCh] [rbp-32Ch]
  float v46; // [rsp+E0h] [rbp-328h]
  __int64 v47; // [rsp+E8h] [rbp-320h]
  ULONG_PTR Parameter; // [rsp+F0h] [rbp-318h] BYREF
  Parameter *Parameter_2; // [rsp+F8h] [rbp-310h] BYREF
  __int64 v50; // [rsp+100h] [rbp-308h]
  __int64 v51; // [rsp+108h] [rbp-300h]
  __int64 v52; // [rsp+110h] [rbp-2F8h]
  __int64 v53; // [rsp+118h] [rbp-2F0h]
  __int64 v54; // [rsp+120h] [rbp-2E8h]
  __int64 v55; // [rsp+128h] [rbp-2E0h]
  __int64 v56; // [rsp+130h] [rbp-2D8h]
  unsigned __int64 v57; // [rsp+138h] [rbp-2D0h] BYREF
  __int64 v58; // [rsp+140h] [rbp-2C8h] BYREF
  __int64 v59; // [rsp+148h] [rbp-2C0h]
  __int64 *v60; // [rsp+150h] [rbp-2B8h]
  __int64 v61; // [rsp+158h] [rbp-2B0h]
  __int64 v62; // [rsp+160h] [rbp-2A8h]
  __int64 v63; // [rsp+168h] [rbp-2A0h]
  __int64 v64; // [rsp+170h] [rbp-298h]
  _BYTE v65[24]; // [rsp+178h] [rbp-290h] BYREF
  void *v66; // [rsp+190h] [rbp-278h] BYREF
  int v67; // [rsp+198h] [rbp-270h]
  float src_[3]; // [rsp+1A0h] [rbp-268h] BYREF
  __int64 v69; // [rsp+1B0h] [rbp-258h]
  unsigned __int64 v70; // [rsp+1B8h] [rbp-250h]
  __int64 v71; // [rsp+1C0h] [rbp-248h]
  __int64 (__fastcall *v72)(__int64, _QWORD); // [rsp+1C8h] [rbp-240h]
  __int64 (__fastcall *v74)(__int64, _QWORD); // [rsp+1D8h] [rbp-230h]
  __int64 v75; // [rsp+1E0h] [rbp-228h] BYREF
  __int64 v76; // [rsp+1E8h] [rbp-220h]
  void (__fastcall *v77)(__int64, unsigned __int64 *, __int64); // [rsp+1F0h] [rbp-218h]
  __int64 v78; // [rsp+1F8h] [rbp-210h]
  __int64 *v79; // [rsp+200h] [rbp-208h]
  __int64 v80; // [rsp+208h] [rbp-200h]
  __int64 v81; // [rsp+210h] [rbp-1F8h]
  __int64 v82; // [rsp+218h] [rbp-1F0h]
  __int64 v83; // [rsp+220h] [rbp-1E8h] BYREF
  __int64 v84; // [rsp+228h] [rbp-1E0h]
  __int64 v85; // [rsp+230h] [rbp-1D8h]
  void (__fastcall *v86)(__int64, _QWORD *); // [rsp+238h] [rbp-1D0h]
  __int64 v87; // [rsp+240h] [rbp-1C8h] BYREF
  __int64 v88; // [rsp+248h] [rbp-1C0h]
  __int64 v89; // [rsp+250h] [rbp-1B8h]
  __int64 v90; // [rsp+258h] [rbp-1B0h]
  __int64 (__fastcall *v91)(__int64, _QWORD); // [rsp+260h] [rbp-1A8h]
  __int64 v92; // [rsp+268h] [rbp-1A0h]
  __int64 v93; // [rsp+270h] [rbp-198h] BYREF
  Parameter *Parameter_1; // [rsp+278h] [rbp-190h]
  _BYTE dst__4[16]; // [rsp+280h] [rbp-188h] BYREF
  _BYTE dst__5[16]; // [rsp+290h] [rbp-178h] BYREF
  __int64 v97; // [rsp+2A0h] [rbp-168h] BYREF
  __int64 v98; // [rsp+2A8h] [rbp-160h] BYREF
  _QWORD v99[4]; // [rsp+2B0h] [rbp-158h] BYREF
  _BYTE v100[8]; // [rsp+2D0h] [rbp-138h] BYREF
  _BYTE v101[12]; // [rsp+2D8h] [rbp-130h] BYREF
  _BYTE v102[12]; // [rsp+2E4h] [rbp-124h] BYREF
  __int64 v103; // [rsp+2F0h] [rbp-118h] BYREF
  _QWORD v104[2]; // [rsp+300h] [rbp-108h] BYREF
  __int64 v105; // [rsp+310h] [rbp-F8h] BYREF
  _BYTE dst__3[24]; // [rsp+318h] [rbp-F0h] BYREF
  int v107; // [rsp+330h] [rbp-D8h]
  void *v108; // [rsp+338h] [rbp-D0h] BYREF
  int v109; // [rsp+340h] [rbp-C8h]
  __int64 v110; // [rsp+348h] [rbp-C0h]
  _BYTE dst__1[12]; // [rsp+350h] [rbp-B8h] BYREF
  float dst__2[9]; // [rsp+35Ch] [rbp-ACh] BYREF
  __int64 v113; // [rsp+380h] [rbp-88h]
  __int64 v114; // [rsp+388h] [rbp-80h]
  _QWORD v115[5]; // [rsp+390h] [rbp-78h] BYREF
  __int64 v116; // [rsp+3B8h] [rbp-50h] BYREF
  char v117; // [rsp+3C0h] [rbp-48h]
  _QWORD dst_[2]; // [rsp+3D0h] [rbp-38h] BYREF

  sub_143C13CF0(a4);
  sub_143C13C60(a5);
  *(_DWORD *)a2 = 0;
  *(_BYTE *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 5) = 0;
  *(_DWORD *)(a2 + 8) = 1;
  *(_DWORD *)(a2 + 0xC) = 1;
  v64 = a1 + 0x290;
  sub_141509F20(v99, a1 + 0x290, a1 + 0x2A0);
  sub_1432DF020(v99, &Parameter_2, a3);
  v92 = v99[0];
  v47 = v99[0];
  Parameter_1 = *(_QWORD *)v99[0];
  Parameter = Parameter_1;
  _StarEngineModule__((ULONG_PTR)&Parameter);
  if ( Parameter_2 != Parameter )
  {
    v69 = Parameter_2 + 0x20;
    v22 = Parameter_2 + 0x38;
    if ( !*(_BYTE *)(Parameter_2 + 0x12B) )
    {
      if ( *(_BYTE *)(Parameter_2 + 0x12C) )
      {
        v26 = sub_14606F680(a1);
        v20 = (_QWORD *)(v22 + 0x68);
        if ( *(int *)(v22 + 0xB0) > 0 )
        {
          v70 = *(int *)(v22 + 0xB0);
          if ( v70 <= (*(_QWORD *)(v22 + 0x70) - *(_QWORD *)(v22 + 0x68)) / 0xD0LL )
          {
            v50 = *(int *)(v22 + 0xB0);
          }
          else
          {
            v50 = (*(_QWORD *)(v22 + 0x70) - *(_QWORD *)(v22 + 0x68)) / 0xD0LL;
          }
          v33 = v50;
          for ( i = v50 - 1; i >= 0; --i )
          {
            v51 = i;
            if ( i >= (unsigned __int64)((*(_QWORD *)(v22 + 0x70) - *(_QWORD *)(v22 + 0x68)) / 0xD0LL) )
            {
              __debugbreak();
            }
            v71 = *v20 + 0xD0 * v51;
            v52 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
            v53 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 0xC0LL))(v52);
            v72 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v53 + 0x10LL);
            v34 = *(_DWORD *)(v71 + 0x20);
            v42 = v72(v53, v34);
            if ( v42 )
            {
              if ( (unsigned __int8)sub_14609EEB0(a1, v22, v42) )
              {
                sub_1403266D0(v37);
                if ( sub_140303E90(v42) )
                {
                  *(_BYTE *)(a2 + 5) = 1;
                  break;
                }
              }
            }
          }
        }
        for ( j = *(int *)(v22 + 0xB0); j < (*(_QWORD *)(v22 + 0x70) - *(_QWORD *)(v22 + 0x68)) / 0xD0LL; ++j )
        {
          v21 = *v20 + 0xD0 * j;
          v54 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
          v55 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v54 + 0xC0LL))(v54);
          v74 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v55 + 0x10LL);
          v35 = *(_DWORD *)(v21 + 0x20);
          v23 = v74(v55, v35);
          if ( v23 && (unsigned __int8)sub_14609EEB0(a1, v22, v23) )
          {
            sub_1432772C0(v65);
            sub_143277150((__int64)&v105);
            sub_1403266D0(v32);
            v31 = sub_140303E90(v23);
            if ( v31 )
            {
              sub_140375E30(v65, v31 + 0x88);
              v8 = (__int64 *)sub_145A592B0(&v75, v23, v21 + 0x58);
              sub_140374560(&v116, v8);
              j_DestroyStringObject(&v75);
              v56 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
              v77 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v56 + 0x120LL);
              v76 = *(_QWORD *)v21;
              v77(v56, &v57, v76);
              if ( is_valid_handle_typeB(&v57) )
              {
                v78 = Handle::ToIndex(&v57);
                v79 = sub_140337E40(v78, &v97);
                v80 = *v79;
                v58 = v80;
                v28 = AssetMeta::HasActorSubresource(&v58) ? v58 & 0xFFFFFFFFFFFFLL : 0LL;
                if ( v28 )
                {
                  if ( *(_DWORD *)(v22 + 0x5C) == 1 )
                  {
                    v81 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x570LL))(v28);
                    v36 = *(_DWORD *)(v22 + 0x30);
                    v117 = sub_145A663D0(v36, v81);
                  }
                  v43 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x608LL))(v28);
                  if ( v43 )
                  {
                    v59 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v43 + 0xD0LL))(v43);
                    if ( v59 )
                    {
                      v82 = v59 + 8;
                      sub_1403AC900((unsigned __int64 *)(v59 + 8), &v83);
                      v84 = v83;
                      v85 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
                               a3,
                               &v98);
                      if ( sub_14037BB50(v85, v84) )
                      {
                        LOBYTE(v9) = 2;
                        sub_143B27600(v65, v9);
                      }
                    }
                  }
                }
              }
              v10 = (_BYTE *)sub_143B2FBF0(v21);
              assignCStringToStringStructure(&v66, v10);
              v65[9] = 1;
              v65[8] = 0;
              v67 = 0;
              copyStringStructure(&v108, (const void **)(v21 + 0x28));
              v110 = *(_QWORD *)(v21 + 0x38);
              v109 = *(_DWORD *)(v21 + 0x30);
              v107 = *(_DWORD *)(v21 + 0x20);
              v105 = *(_QWORD *)v21;
              if ( (unsigned __int8)sub_145A64360(v23) )
              {
                LOBYTE(v11) = 4;
                sub_143B27600(v65, v11);
                v5 = *(unsigned int *)(v21 + 0x60);
                dst__2[5] = *(float *)(v21 + 0x60);
              }
              if ( (unsigned __int8)sub_145A63E20(v23) )
              {
                LOBYTE(v12) = 8;
                sub_143B27600(v65, v12);
                dst__2[6] = *(float *)(v21 + 0x64);
                dst__2[7] = *(float *)(v21 + 0x68);
              }
              if ( (unsigned __int8)sub_145A65BD0(v23) && !(unsigned __int8)sub_145A66780(v23) )
              {
                LOBYTE(v13) = 1;
                sub_143B27600(v65, v13);
                v113 = *(_QWORD *)(v21 + 0x70);
                v114 = *(_QWORD *)(v21 + 0x78);
              }
              v60 = (__int64 *)sub_1414BBAB0(a1, v100);
              if ( is_valid_handle_typeA(v60) )
              {
                v30 = *v60 & 0xFFFFFFFFFFFFLL;
              }
              else
              {
                v30 = 0;
              }
              if ( v30 )
              {
                v86 = *(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v30 + 0x598LL);
                v86(v30, v104);
                v93 = 0;
                v87 = 0;
                qmemcpy(dst_, unknown_libname_6(&v103, &v87, &v93), sizeof(dst_));
                if ( sub_1402B2B30(v104, dst_) && sub_1402B2B10(v104, v115) )
                {
                  LOBYTE(v14) = 0x10;
                  sub_143B27600(v65, v14);
                }
              }
              qmemcpy(dst__1, (const void *)sub_145A5A530(v101, v23), sizeof(dst__1));
              qmemcpy(dst__2, (const void *)(*(_QWORD *)(a1 + 0x190) + 0x4A0LL), 0xCu);
              qmemcpy(dst__3, (const void *)(v21 + 8), sizeof(dst__3));
              sub_1402AC880((__int64)&v44);
              v88 = *(_QWORD *)(a1 + 0x190) + 0x2C0LL;
              if ( (unsigned __int8)sub_1432B1B90(
                                      v88,
                                      *(_DWORD *)(v31 + 0x20),
                                      *(_DWORD *)(v31 + 0x24),
                                      (unsigned int)&v44,
                                      v23) )
              {
                v39 = dst__2[2] + v46;
                v38 = dst__2[1] + v45;
                v41 = dst__2[0] + v44;
                src_[0] = dst__2[0] + v44;
                src_[1] = dst__2[1] + v45;
                v5 = COERCE_UNSIGNED_INT(dst__2[2] + v46);
                src_[2] = dst__2[2] + v46;
                qmemcpy(dst__2, src_, 0xCu);
              }
              qmemcpy(dst__4, dst__2, 0xCu);
              qmemcpy(dst__5, dst__1, 0xCu);
              qmemcpy(dst__1, (const void *)sub_145A5E270(v102, dst__5, dst__4), sizeof(dst__1));
              if ( (unsigned __int8)sub_142A76BF0(a4) )
              {
                *(_DWORD *)a2 = j;
              }
              v89 = v26;
              if ( (a4[1] - *a4) / 0x28LL >= (unsigned __int64)v26 )
              {
                *(_BYTE *)(a2 + 4) = 1;
                sub_14327A370(&v105);
                sub_14327A460(v65);
                break;
              }
              sub_146120330(a4, v65);
              sub_143C29280(a5, &v105);
            }
            sub_14327A370(&v105);
            sub_14327A460(v65);
          }
        }
        v25 = 0;
        for ( k = 0; k < (*(_QWORD *)(v22 + 0x70) - *(_QWORD *)(v22 + 0x68)) / 0xD0LL; ++k )
        {
          v90 = *v20 + 0xD0 * k;
          v61 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
          v62 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v61 + 0xC0LL))(v61);
          v91 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v62 + 0x10LL);
          v40 = *(_DWORD *)(v90 + 0x20);
          v63 = v91(v62, v40);
          if ( v63 && (unsigned __int8)sub_14609EEB0(a1, v22, v63) )
          {
            ++v25;
            if ( k == *(_DWORD *)a2 )
            {
              v16 = v5;
              *(float *)&v16 = (float)v25;
              v15 = v16;
              v17 = v6;
              *(float *)&v17 = (float)v26;
              v6 = v17;
              v18 = v15;
              *(float *)&v18 = *(float *)&v15 / *(float *)&v6;
              v5 = v18;
              *(float *)&v5 = sub_1402C2A30();
              *(_DWORD *)(a2 + 8) = (int)*(float *)&v5;
            }
          }
        }
        v7 = (unsigned int)((v25 + v26 - 1) >> 0x1F);
        LODWORD(v7) = (v25 + v26 - 1) % v26;
        *(_DWORD *)(a2 + 0xC) = (v25 + v26 - 1) / v26;
      }
    }
  }
  sub_141578BB0(v99, v7);
  return a2;
}

// --- End Function: sub_146069080 (0x146069080) ---

// --- Function: sub_146076F70 (0x146076F70) ---
void **__fastcall sub_146076F70(__int64 a1, void **a2, __int64 a3, __int64 a4, void **a5, void **a6)
{
  _BYTE *v6; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  _BYTE *v11; // rax
  _BYTE *v12; // rax
  _BYTE *v13; // rax
  _BYTE *v14; // rax
  void **v15; // rax
  unsigned __int64 i; // [rsp+20h] [rbp-C8h]
  __int64 v17; // [rsp+28h] [rbp-C0h]
  __int64 v18; // [rsp+40h] [rbp-A8h]
  __int64 v19; // [rsp+60h] [rbp-88h]
  __int64 v20; // [rsp+68h] [rbp-80h]
  __int64 v21; // [rsp+70h] [rbp-78h]
  void *v22; // [rsp+88h] [rbp-60h] BYREF
  void *v23; // [rsp+90h] [rbp-58h] BYREF
  void *v24; // [rsp+98h] [rbp-50h] BYREF
  void *v25; // [rsp+A0h] [rbp-48h] BYREF
  void *v26; // [rsp+A8h] [rbp-40h] BYREF
  void *v27; // [rsp+B0h] [rbp-38h] BYREF
  __int64 (__fastcall *v28)(__int64, _QWORD); // [rsp+B8h] [rbp-30h]
  __int64 v29; // [rsp+C0h] [rbp-28h]
  __int64 v30; // [rsp+C8h] [rbp-20h]
  __int64 v31; // [rsp+D0h] [rbp-18h]
  __int64 v32; // [rsp+D8h] [rbp-10h]

  if ( (unsigned __int8)sub_142A76BF0(a3 + 0x68) )
  {
    v15 = assignCStringToStringStructure(a6, &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
    copyStringStructure(a5, (const void **)v15);
    sub_1403A6DB0(a2);
    return a2;
  }
  else
  {
    if ( (unsigned __int8)sub_14609EEB0(a1, a3, a4) )
    {
      v18 = 0;
      for ( i = *(int *)(a3 + 0xB0); i < (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL; ++i )
      {
        v17 = *(_QWORD *)(a3 + 0x68) + 0xD0 * i;
        v19 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
        v20 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 0xC0LL))(v19);
        v28 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v20 + 0x10LL);
        v21 = v28(v20, *(unsigned int *)(v17 + 0x20));
        if ( v21 )
        {
          if ( (unsigned __int8)sub_14609EEB0(a1, a3, v21) )
          {
            if ( ++v18 == (int)sub_14606F680(a1) )
            {
              if ( i )
              {
                if ( i - 1 >= (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
                {
                  __debugbreak();
                }
                v29 = *(_QWORD *)(a3 + 0x68) + 0xD0 * (i - 1);
                v6 = (_BYTE *)SEntityProxy::AsJson(v29 + 0x28);
                assignCStringToStringStructure(a5, v6);
                v7 = (_BYTE *)SEntityProxy::AsJson(v17 + 0x28);
                assignCStringToStringStructure(a6, v7);
                v8 = (_BYTE *)SEntityProxy::AsJson(v17 + 0x28);
                CreateStringObjectFromString(&v23, v8);
                if ( i - 1 >= (*(_QWORD *)(a3 + 0x70) - *(_QWORD *)(a3 + 0x68)) / 0xD0LL )
                {
                  __debugbreak();
                }
                v30 = *(_QWORD *)(a3 + 0x68) + 0xD0 * (i - 1);
                v9 = (_BYTE *)SEntityProxy::AsJson(v30 + 0x28);
                CreateStringObjectFromString(&v22, v9);
                sub_1403A6BF0(a2, (char **)&v22, (char **)&v23);
                DestroyStringObject(&v22);
                DestroyStringObject(&v23);
                return a2;
              }
              else
              {
                assignCStringToStringStructure(
                  a5,
                  &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
                v11 = (_BYTE *)SEntityProxy::AsJson(v17 + 0x28);
                assignCStringToStringStructure(a6, v11);
                v12 = (_BYTE *)SEntityProxy::AsJson(v17 + 0x28);
                CreateStringObjectFromString(&v25, v12);
                CreateStringObjectFromString(
                  &v24,
                  &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
                sub_1403A6BF0(a2, (char **)&v24, (char **)&v25);
                DestroyStringObject(&v24);
                DestroyStringObject(&v25);
                return a2;
              }
            }
          }
        }
      }
    }
    v31 = *(_QWORD *)(a3 + 0x70) - 0xD0LL;
    v13 = (_BYTE *)SEntityProxy::AsJson(v31 + 0x28);
    assignCStringToStringStructure(a5, v13);
    assignCStringToStringStructure(a6, &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
    CreateStringObjectFromString(&v27, &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
    v32 = *(_QWORD *)(a3 + 0x70) - 0xD0LL;
    v14 = (_BYTE *)SEntityProxy::AsJson(v32 + 0x28);
    CreateStringObjectFromString(&v26, v14);
    sub_1403A6BF0(a2, (char **)&v26, (char **)&v27);
    DestroyStringObject(&v26);
    DestroyStringObject(&v27);
    return a2;
  }
}

// --- End Function: sub_146076F70 (0x146076F70) ---

// --- Function: sub_14609EEB0 (0x14609EEB0) ---
__int64 __fastcall sub_14609EEB0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int8 v4; // [rsp+20h] [rbp-308h]
  char v5; // [rsp+21h] [rbp-307h]
  __int64 v6; // [rsp+38h] [rbp-2F0h] BYREF
  struct __crt_locale_data *locinfo; // [rsp+40h] [rbp-2E8h]
  ULONG_PTR i; // [rsp+48h] [rbp-2E0h] BYREF
  struct __crt_locale_data *locinfo_2; // [rsp+50h] [rbp-2D8h]
  __int64 v10; // [rsp+58h] [rbp-2D0h]
  struct __crt_locale_data *locinfo_1; // [rsp+60h] [rbp-2C8h]
  struct __crt_locale_data *locinfo_3; // [rsp+68h] [rbp-2C0h]
  __int64 v13[4]; // [rsp+70h] [rbp-2B8h] BYREF
  ULONG_PTR Parameter[2]; // [rsp+90h] [rbp-298h] BYREF
  ULONG_PTR Parameter__2[4]; // [rsp+A0h] [rbp-288h] BYREF
  __int64 v16; // [rsp+C0h] [rbp-268h] BYREF
  __int64 v17; // [rsp+C8h] [rbp-260h]
  void *v18; // [rsp+D0h] [rbp-258h]
  __int64 v19; // [rsp+D8h] [rbp-250h]
  _QWORD Parameter_[2]; // [rsp+E0h] [rbp-248h] BYREF
  _QWORD Parameter__1[2]; // [rsp+F0h] [rbp-238h] BYREF
  struct __crt_locale_pointers *LocaleT; // [rsp+100h] [rbp-228h]
  struct __crt_multibyte_data *mbcinfo; // [rsp+108h] [rbp-220h]
  ULONG_PTR v24; // [rsp+110h] [rbp-218h]
  __int64 v25; // [rsp+118h] [rbp-210h]
  ULONG_PTR v26; // [rsp+120h] [rbp-208h]
  struct __crt_locale_pointers *v27; // [rsp+128h] [rbp-200h]
  struct __crt_multibyte_data *mbcinfo_1; // [rsp+130h] [rbp-1F8h]
  ULONG_PTR v29; // [rsp+138h] [rbp-1F0h]
  _BYTE v30[8]; // [rsp+140h] [rbp-1E8h] BYREF
  int v31; // [rsp+148h] [rbp-1E0h]
  int v32; // [rsp+14Ch] [rbp-1DCh]

  sub_1402AC3D0(
    v13,
    (__int64)"CSCLocalPlayerPersonalThoughtComponent::IsFilteredInInventoryContainer",
    (__int64)&qword_14974FDF0,
    1);
  v4 = 1;
  sub_140453470(v30);
  if ( (unsigned __int8)sub_145A59230(a3, v30) )
  {
    v5 = 0;
    Parameter__2[2] = a2 + 0xC0;
    unknown_libname_482(&v6, *(_QWORD *)(a2 + 0xC8));
    while ( 1 )
    {
      Parameter__2[3] = a2 + 0xC0;
      unknown_libname_482(&v16, a2 + 0xC0);
      if ( v6 == v16 )
      {
        break;
      }
      if ( *(_BYTE *)(std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v6)
                    + 8) )
      {
        v17 = std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::operator*(&v6);
        v18 = &unk_149B35D28;
        v19 = sub_142A0DB90(&unk_149B35D28, v17);
        std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
          (Parameter *)Parameter_,
          v19);
        v10 = Parameter_[0];
        if ( Parameter_[0] == qword_149B35D38 )
        {
          v5 = 1;
        }
        else
        {
          v13[1] = (__int64)&unk_149B35D28;
          Parameter_[1] = unk_149B35D28;
          std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>,std::_Iterator_base0>(
            (Parameter *)Parameter__1,
            unk_149B35D28);
          if ( v10 != Parameter__1[0] )
          {
            Parameter__1[1] = v10 + 0x20;
            LocaleT = _LocaleUpdate::GetLocaleT((_LocaleUpdate *)(v10 + 0x28));
            v13[2] = (__int64)LocaleT;
            locinfo = LocaleT->locinfo;
            mbcinfo = LocaleT->mbcinfo;
            while ( locinfo != mbcinfo )
            {
              locinfo_1 = locinfo;
              if ( *(_DWORD *)locinfo == v31
                && (*((_DWORD *)locinfo_1 + 1) == 0x95 || *((_DWORD *)locinfo_1 + 1) == v32) )
              {
                sub_14030AC80(v30);
                sub_1402AF7F0(v13);
                return 1;
              }
              v4 = 0;
              locinfo = (struct __crt_locale_data *)((char *)locinfo + 8);
            }
          }
        }
      }
      sub_142AA22D0(&v6);
    }
    if ( v5 )
    {
      v13[3] = (__int64)&unk_149B35D28;
      v24 = *unk_149B35D28;
      Parameter[0] = v24;
      _StarEngineModule__((ULONG_PTR)Parameter);
      for ( i = Parameter[0]; ; sub_142A205A0(&i) )
      {
        Parameter[1] = (ULONG_PTR)&unk_149B35D28;
        v25 = unk_149B35D28;
        Parameter__2[0] = unk_149B35D28;
        _StarEngineModule__((ULONG_PTR)Parameter__2);
        if ( i == Parameter__2[0] )
        {
          break;
        }
        v26 = i + 0x20;
        v27 = _LocaleUpdate::GetLocaleT((_LocaleUpdate *)(i + 0x28));
        Parameter__2[1] = (ULONG_PTR)v27;
        locinfo_2 = v27->locinfo;
        mbcinfo_1 = v27->mbcinfo;
        while ( locinfo_2 != mbcinfo_1 )
        {
          locinfo_3 = locinfo_2;
          if ( *(_DWORD *)locinfo_2 == v31 && (*((_DWORD *)locinfo_3 + 1) == 0x95 || *((_DWORD *)locinfo_3 + 1) == v32) )
          {
            sub_14030AC80(v30);
            sub_1402AF7F0(v13);
            return 0;
          }
          v4 = 1;
          locinfo_2 = (struct __crt_locale_data *)((char *)locinfo_2 + 8);
        }
        v29 = i;
      }
    }
  }
  sub_14030AC80(v30);
  sub_1402AF7F0(v13);
  return v4;
}

// --- End Function: sub_14609EEB0 (0x14609EEB0) ---

// --- Function: sub_1460A5320 (0x1460A5320) ---
unsigned __int64 __fastcall sub_1460A5320(__int64 a1, __int64 **a2, __int64 a3, const void *src, int a5)
{
  Parameter *Parameter_2; // [rsp+28h] [rbp-120h] BYREF
  __int64 v7; // [rsp+30h] [rbp-118h]
  __int64 *v8; // [rsp+38h] [rbp-110h]
  __int64 *v9; // [rsp+40h] [rbp-108h]
  ULONG_PTR Parameter; // [rsp+48h] [rbp-100h] BYREF
  __int64 v11; // [rsp+50h] [rbp-F8h]
  __int64 v12; // [rsp+58h] [rbp-F0h]
  __int64 v13; // [rsp+60h] [rbp-E8h]
  __int64 *v14; // [rsp+68h] [rbp-E0h]
  struct __crt_stdio_stream *v15; // [rsp+70h] [rbp-D8h]
  __int64 *v16; // [rsp+78h] [rbp-D0h]
  Parameter *Parameter_1; // [rsp+80h] [rbp-C8h]
  __int64 v18; // [rsp+88h] [rbp-C0h]
  __int64 v19; // [rsp+90h] [rbp-B8h]
  __int64 v20; // [rsp+98h] [rbp-B0h]
  __int64 v21; // [rsp+A0h] [rbp-A8h]
  __int64 v22; // [rsp+A8h] [rbp-A0h]
  __int64 v23; // [rsp+B0h] [rbp-98h]
  __int64 v24; // [rsp+B8h] [rbp-90h]
  _BYTE dst_[24]; // [rsp+C0h] [rbp-88h] BYREF
  _BYTE dst__1[24]; // [rsp+D8h] [rbp-70h] BYREF
  _BYTE dst__2[24]; // [rsp+F0h] [rbp-58h] BYREF
  _BYTE dst__3[56]; // [rsp+110h] [rbp-38h] BYREF

  v13 = a3 + 0x38;
  if ( sub_1405AC2A0(a3 + 0x38, (__int64)&src__3) )
  {
    v8 = *a2;
    v14 = v8;
    v15 = (struct __crt_stdio_stream *)sub_14326D650(v8, a3 + 0x38);
    _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
      (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&Parameter_2,
      v15);
    v16 = *a2;
    v9 = v16;
    Parameter_1 = *v16;
    Parameter = Parameter_1;
    _StarEngineModule__((ULONG_PTR)&Parameter);
    if ( Parameter_2 != Parameter )
    {
      qmemcpy(dst_, src, sizeof(dst_));
      qmemcpy(dst__1, dst_, sizeof(dst__1));
      qmemcpy(dst__2, dst__1, sizeof(dst__2));
      v18 = Parameter_2 + 0x20;
      v11 = v23;
      v11 = *(_QWORD *)(Parameter_2 + 0xA8);
      v19 = Parameter_2 + 0x20;
      v12 = v24;
      v12 = *(_QWORD *)(Parameter_2 + 0xA0);
      qmemcpy(dst__3, dst__2, 0x18u);
      v7 = sub_146003A00(v12, v11, (__int64)dst__3);
      v20 = Parameter_2 + 0x20;
      v21 = *(_QWORD *)(Parameter_2 + 0xA8);
      if ( v7 != v21 )
      {
        *(_QWORD *)(v7 + 0x70) += a5;
        v22 = Parameter_2 + 0x20;
        sub_14610E030(a1, Parameter_2 + 0x38);
      }
    }
  }
  return sub_1402AF8A0((__int64)a2);
}

// --- End Function: sub_1460A5320 (0x1460A5320) ---

// --- Function: sub_1460ADDF0 (0x1460ADDF0) ---
__int64 __fastcall sub_1460ADDF0(
        __int64 a1,
        const void *src_1,
        const void *src,
        unsigned int a4,
        unsigned int a5,
        int n2)
{
  __int64 result; // rax
  _BYTE *v7; // rax
  _BYTE *v8; // rax
  void **v9; // rax
  _BYTE *v10; // rax
  _BYTE *v11; // rax
  void **v12; // rax
  void **v13; // rax
  __int64 v14; // rdx
  bool v15; // [rsp+60h] [rbp-968h] BYREF
  __int64 v16; // [rsp+68h] [rbp-960h]
  __int64 v17; // [rsp+70h] [rbp-958h]
  __int64 v18; // [rsp+78h] [rbp-950h]
  int v19; // [rsp+80h] [rbp-948h]
  int v20; // [rsp+84h] [rbp-944h]
  signed int v21; // [rsp+88h] [rbp-940h]
  void *v22; // [rsp+90h] [rbp-938h] BYREF
  BOOL v23; // [rsp+98h] [rbp-930h]
  BOOL v24; // [rsp+9Ch] [rbp-92Ch]
  __int64 v25; // [rsp+A0h] [rbp-928h]
  __int64 v26; // [rsp+A8h] [rbp-920h]
  unsigned int v27; // [rsp+B0h] [rbp-918h]
  unsigned int v28; // [rsp+B4h] [rbp-914h]
  int v29; // [rsp+B8h] [rbp-910h]
  _QWORD *v30; // [rsp+C0h] [rbp-908h]
  _QWORD *v31; // [rsp+C8h] [rbp-900h]
  __int64 v32; // [rsp+D0h] [rbp-8F8h]
  __int64 v33; // [rsp+D8h] [rbp-8F0h]
  __int64 v34; // [rsp+E0h] [rbp-8E8h]
  void *v35; // [rsp+E8h] [rbp-8E0h] BYREF
  _QWORD *v36; // [rsp+F0h] [rbp-8D8h]
  __int64 v37; // [rsp+F8h] [rbp-8D0h]
  __int64 *v38; // [rsp+100h] [rbp-8C8h]
  __int64 *v39; // [rsp+108h] [rbp-8C0h]
  __int64 *v40; // [rsp+110h] [rbp-8B8h]
  ULONG_PTR Parameter[2]; // [rsp+118h] [rbp-8B0h] BYREF
  ULONG_PTR Parameter_; // [rsp+128h] [rbp-8A0h] BYREF
  __int64 v43; // [rsp+130h] [rbp-898h] BYREF
  _QWORD v44[2]; // [rsp+138h] [rbp-890h] BYREF
  __int64 v45; // [rsp+148h] [rbp-880h]
  __int64 v46; // [rsp+150h] [rbp-878h]
  __int64 v47; // [rsp+158h] [rbp-870h]
  __int64 v48; // [rsp+160h] [rbp-868h]
  unsigned __int64 v49; // [rsp+168h] [rbp-860h]
  void *v50; // [rsp+170h] [rbp-858h] BYREF
  void *v51; // [rsp+178h] [rbp-850h] BYREF
  void *v52; // [rsp+180h] [rbp-848h] BYREF
  void *v53[3]; // [rsp+188h] [rbp-840h] BYREF
  __int64 **v54; // [rsp+1A0h] [rbp-828h]
  __int64 **v55; // [rsp+1A8h] [rbp-820h]
  void *v56; // [rsp+1B0h] [rbp-818h] BYREF
  __int64 *v57[4]; // [rsp+1B8h] [rbp-810h] BYREF
  struct __crt_stdio_stream *v58; // [rsp+1D8h] [rbp-7F0h]
  __int64 *v59; // [rsp+1E0h] [rbp-7E8h]
  struct __crt_stdio_stream *v60; // [rsp+1E8h] [rbp-7E0h]
  __int64 *v61; // [rsp+1F0h] [rbp-7D8h]
  ULONG_PTR v62; // [rsp+1F8h] [rbp-7D0h]
  __int64 *v63; // [rsp+200h] [rbp-7C8h]
  ULONG_PTR Parameter__1; // [rsp+208h] [rbp-7C0h]
  __int64 v65; // [rsp+210h] [rbp-7B8h]
  __int64 v66; // [rsp+218h] [rbp-7B0h]
  __int64 v67; // [rsp+220h] [rbp-7A8h]
  __int64 v68; // [rsp+228h] [rbp-7A0h]
  __int64 (__fastcall *v69)(__int64, _QWORD); // [rsp+230h] [rbp-798h]
  __int64 v70; // [rsp+238h] [rbp-790h]
  __int64 v71; // [rsp+240h] [rbp-788h]
  __int64 v72; // [rsp+248h] [rbp-780h]
  void *v73; // [rsp+250h] [rbp-778h] BYREF
  void *v74; // [rsp+258h] [rbp-770h] BYREF
  void *v75[4]; // [rsp+260h] [rbp-768h] BYREF
  __int64 v76; // [rsp+280h] [rbp-748h]
  _QWORD *buf; // [rsp+288h] [rbp-740h]
  __int64 v78; // [rsp+290h] [rbp-738h]
  __int64 v79; // [rsp+298h] [rbp-730h]
  __int64 v80; // [rsp+2A0h] [rbp-728h] BYREF
  __int64 v81; // [rsp+2A8h] [rbp-720h]
  __int64 v82; // [rsp+2B0h] [rbp-718h]
  _QWORD *v83; // [rsp+2B8h] [rbp-710h]
  _QWORD *v84; // [rsp+2C0h] [rbp-708h]
  __int64 v85; // [rsp+2C8h] [rbp-700h]
  __int64 v86; // [rsp+2D0h] [rbp-6F8h]
  __int64 **v87; // [rsp+2D8h] [rbp-6F0h]
  __int64 **v88; // [rsp+2E0h] [rbp-6E8h]
  _QWORD buf_[5]; // [rsp+2E8h] [rbp-6E0h] BYREF
  _BYTE dst__1[16]; // [rsp+310h] [rbp-6B8h] BYREF
  __int64 dst_[2]; // [rsp+320h] [rbp-6A8h] BYREF
  __int64 v92; // [rsp+330h] [rbp-698h] BYREF
  _BYTE dst__2[24]; // [rsp+338h] [rbp-690h] BYREF
  _BYTE dst__3[24]; // [rsp+350h] [rbp-678h] BYREF
  _BYTE dst__5[24]; // [rsp+368h] [rbp-660h] BYREF
  _BYTE dst__4[24]; // [rsp+380h] [rbp-648h] BYREF
  _BYTE dst__6[24]; // [rsp+398h] [rbp-630h] BYREF
  _BYTE dst__7[32]; // [rsp+3B0h] [rbp-618h] BYREF
  _QWORD dst__8[4]; // [rsp+3D0h] [rbp-5F8h] BYREF
  _BYTE dst__9[24]; // [rsp+3F0h] [rbp-5D8h] BYREF
  _BYTE dst__10[24]; // [rsp+408h] [rbp-5C0h] BYREF
  _BYTE dst__12[24]; // [rsp+420h] [rbp-5A8h] BYREF
  _BYTE dst__13[24]; // [rsp+438h] [rbp-590h] BYREF
  _BYTE dst__11[24]; // [rsp+450h] [rbp-578h] BYREF
  _BYTE dst__14[24]; // [rsp+468h] [rbp-560h] BYREF
  _BYTE dst__15[32]; // [rsp+480h] [rbp-548h] BYREF
  _BYTE dst__16[32]; // [rsp+4A0h] [rbp-528h] BYREF
  _BYTE dst__19[24]; // [rsp+4C0h] [rbp-508h] BYREF
  _BYTE dst__20[32]; // [rsp+4E0h] [rbp-4E8h] BYREF
  _BYTE dst__21[24]; // [rsp+500h] [rbp-4C8h] BYREF
  _BYTE dst__22[32]; // [rsp+520h] [rbp-4A8h] BYREF
  _QWORD v112[2]; // [rsp+540h] [rbp-488h] BYREF
  _BYTE dst__17[24]; // [rsp+550h] [rbp-478h] BYREF
  _BYTE dst__18[24]; // [rsp+568h] [rbp-460h] BYREF
  int v115; // [rsp+580h] [rbp-448h]
  int v116; // [rsp+584h] [rbp-444h]
  void *v117; // [rsp+588h] [rbp-440h] BYREF
  void *v118[7]; // [rsp+5B0h] [rbp-418h] BYREF
  char v119; // [rsp+5ECh] [rbp-3DCh]
  _BYTE v120[32]; // [rsp+6E0h] [rbp-2E8h] BYREF
  _BYTE v121[32]; // [rsp+700h] [rbp-2C8h] BYREF
  _QWORD v122[54]; // [rsp+720h] [rbp-2A8h] BYREF
  _QWORD v123[5]; // [rsp+8D0h] [rbp-F8h] BYREF
  void *v124; // [rsp+8F8h] [rbp-D0h] BYREF
  int v125; // [rsp+900h] [rbp-C8h]
  _QWORD v126[3]; // [rsp+988h] [rbp-40h] BYREF

  result = sub_1405AC280((__int64)src_1, (__int64)src);
  if ( !(_BYTE)result )
  {
    v36 = (_QWORD *)(a1 + 0x1A8);
    result = is_valid_handle_typeA((__int64 *)(a1 + 0x1A8));
    if ( (_BYTE)result )
    {
      result = *v36 & 0xFFFFFFFFFFFFLL;
      v25 = result;
    }
    else
    {
      v25 = 0;
    }
    if ( v25 )
    {
      v37 = a1 + 0x290;
      sub_14188AE40((__int64)v57, a1 + 0x290, a1 + 0x2A0);
      v38 = v57[0];
      buf_[3] = v57[0];
      v58 = (struct __crt_stdio_stream *)sub_14326D650(v57[0], (__int64)src_1);
      _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)&v43,
        v58);
      v39 = v57[0];
      v59 = v57[0];
      v60 = (struct __crt_stdio_stream *)sub_14326D650(v57[0], (__int64)src);
      _lambda_9a32fed5bf61b6b509b2d3f6003082a1_::_lambda_9a32fed5bf61b6b509b2d3f6003082a1_(
        (_lambda_9a32fed5bf61b6b509b2d3f6003082a1_ *)v44,
        v60);
      v61 = v57[0];
      v40 = v57[0];
      v62 = *v57[0];
      Parameter[0] = v62;
      _StarEngineModule__((ULONG_PTR)Parameter);
      v23 = v43 == Parameter[0];
      if ( v43 != Parameter[0] )
      {
        v63 = v57[0];
        Parameter[1] = (ULONG_PTR)v57[0];
        Parameter__1 = *v57[0];
        Parameter_ = Parameter__1;
        _StarEngineModule__((ULONG_PTR)&Parameter_);
        v24 = v44[0] == Parameter_;
        if ( v44[0] != Parameter_ )
        {
          v65 = v43 + 0x20;
          v18 = v43 + 0x38;
          v66 = v44[0] + 0x20LL;
          v16 = v44[0] + 0x38LL;
          v21 = sub_1460B81C0(a1, v43 + 0x38, a4);
          if ( v21 > (int)0xFFFFFFFF )
          {
            v44[1] = v18 + 0x68;
            v67 = v21;
            if ( v21 < (unsigned __int64)((*(_QWORD *)(v18 + 0x70) - *(_QWORD *)(v18 + 0x68)) / 0xD0LL) )
            {
              v68 = *(_QWORD *)(v18 + 0x68);
              v17 = 0xD0LL * v21 + v68;
              v45 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
              v46 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v45 + 0xC0LL))(v45);
              v69 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v46 + 0x10LL);
              v27 = *(_DWORD *)(v17 + 0x20);
              v33 = v69(v46, v27);
              if ( !v33 )
              {
                return sub_1402AF8A0((__int64)v57);
              }
              v20 = *(_DWORD *)(v17 + 0x38) * *(_DWORD *)(v17 + 0x30);
              if ( sub_1405AC2A0((__int64)src_1, (__int64)src) )
              {
                qmemcpy(dst_, (const void *)(v17 + 0x40), 0xCu);
                qmemcpy(dst__1, (const void *)(v16 + 0x50), 0xCu);
                if ( !sub_140396410((__int64)dst__1, dst_, *(int *)(v16 + 0x60), *(int *)(v16 + 0x64), v20, 0) )
                {
                  return sub_1402AF8A0((__int64)v57);
                }
                qmemcpy(dst__2, (const void *)(v17 + 8), sizeof(dst__2));
                qmemcpy(dst__3, dst__2, sizeof(dst__3));
                qmemcpy(dst__4, dst__3, sizeof(dst__4));
                v70 = sub_143B2F500(v17);
                v28 = *(_DWORD *)(v16 + 0x5C);
                qmemcpy(dst__5, src, sizeof(dst__5));
                qmemcpy(dst__6, dst__5, sizeof(dst__6));
                qmemcpy(dst__7, dst__4, 0x18u);
                qmemcpy(dst__8, dst__6, 0x18u);
                if ( !sub_14603C6A0(a1, dst__8, v28, v70, dst__7) )
                {
                  return sub_1402AF8A0((__int64)v57);
                }
              }
              if ( *(_DWORD *)(v18 + 0x5C) == 1 || *(_DWORD *)(v16 + 0x5C) == 1 )
              {
                sub_1460CCF90(a1, v18, v21, v16, 0xFFFFFFFF);
                return sub_1402AF8A0((__int64)v57);
              }
              initializeEmptyStringStructure(&v22);
              initializeEmptyStringStructure(&v56);
              sub_1403577C0(&v35, &qword_149B35AA8);
              v15 = 0;
              v19 = sub_1460B81C0(a1, v16, a5);
              if ( v19 <= (int)0xFFFFFFFF
                || (v47 = v16 + 0x68,
                    v71 = v19,
                    v19 >= (unsigned __int64)((*(_QWORD *)(v16 + 0x70) - *(_QWORD *)(v16 + 0x68)) / 0xD0LL)) )
              {
                v13 = sub_14605D240(a1, v75, v16, v17, n2, &v56, &v35, &v15);
                sub_140374480(&v22, v13);
                DestroyStringObject(v75);
              }
              else
              {
                v30 = (_QWORD *)(v16 + 0x68);
                v48 = v19;
                if ( v19 >= (unsigned __int64)((*(_QWORD *)(v16 + 0x70) - *(_QWORD *)(v16 + 0x68)) / 0xD0LL) )
                {
                  __debugbreak();
                }
                v32 = *v30 + 0xD0 * v48;
                if ( v19 <= 0 )
                {
                  v11 = (_BYTE *)SEntityProxy::AsJson(v32 + 0x28);
                  CreateStringObjectFromString(v53, v11);
                  CreateStringObjectFromString(
                    &v52,
                    &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
                  v12 = sub_1403A6BF0(&v74, (char **)&v52, (char **)v53);
                  sub_140374480(&v22, v12);
                  DestroyStringObject(&v74);
                  DestroyStringObject(&v52);
                  DestroyStringObject(v53);
                }
                else
                {
                  v7 = (_BYTE *)SEntityProxy::AsJson(v32 + 0x28);
                  CreateStringObjectFromString(&v51, v7);
                  v31 = (_QWORD *)(v16 + 0x68);
                  v49 = v19 - 1;
                  if ( v49 >= (*(_QWORD *)(v16 + 0x70) - *(_QWORD *)(v16 + 0x68)) / 0xD0LL )
                  {
                    __debugbreak();
                  }
                  v72 = *v31 + 0xD0 * v49;
                  v8 = (_BYTE *)SEntityProxy::AsJson(v72 + 0x28);
                  CreateStringObjectFromString(&v50, v8);
                  v9 = sub_1403A6BF0(&v73, (char **)&v50, (char **)&v51);
                  sub_140374480(&v22, v9);
                  DestroyStringObject(&v73);
                  DestroyStringObject(&v50);
                  DestroyStringObject(&v51);
                  v10 = (_BYTE *)SEntityProxy::AsJson(v32 + 0x28);
                  assignCStringToStringStructure(&v35, v10);
                }
              }
              v76 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v33 + 0x18LL))(v33);
              memset(buf_, 0, 0x18u);
              sub_1402AF610(buf_);
              initializeEmptyStringStructure(&buf_[1]);
              sub_1402AF610(&buf_[2]);
              buf = buf_;
              v53[1] = &v92;
              v92 = 0;
              memset(&v75[1], 0, 0x18);
              v78 = 0;
              qmemcpy(dst__9, src, sizeof(dst__9));
              qmemcpy(dst__10, dst__9, sizeof(dst__10));
              qmemcpy(dst__11, dst__10, sizeof(dst__11));
              qmemcpy(dst__12, src_1, sizeof(dst__12));
              qmemcpy(dst__13, dst__12, sizeof(dst__13));
              qmemcpy(dst__14, dst__13, sizeof(dst__14));
              qmemcpy(dst__15, dst__11, 0x18u);
              qmemcpy(dst__16, dst__14, 0x18u);
              v29 = sub_146026600(
                      a1,
                      2,
                      dst__16,
                      (_QWORD *)(v18 + 0x68),
                      dst__15,
                      (_QWORD *)(v16 + 0x68),
                      0,
                      buf_,
                      v76,
                      6,
                      "CSCLocalPlayerPersonalThoughtComponent::OnInventoryMoveItemOntoUnoccupiedPosition");
              DestroyStringObject(&buf_[1]);
              sub_143A87910((__int64)v112, v29);
              sub_146056B30((__int64)v112, 1);
              HIDWORD(v112[0]) = 2;
              v79 = v25 + 8;
              sub_1403AC900((unsigned __int64 *)(v25 + 8), &v80);
              v112[1] = v80;
              qmemcpy(dst__17, src_1, sizeof(dst__17));
              qmemcpy(dst__18, src, sizeof(dst__18));
              v115 = *(_DWORD *)(v17 + 0x20);
              copyStringStructure(&v117, (const void **)(v17 + 0x28));
              v116 = *(_DWORD *)(v17 + 0x30);
              copyStringStructure(v118, (const void **)&v22);
              v119 = 0;
              v82 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
              v81 = sub_144CBD720((__int64)v122, (__int64)v112);
              sub_1439C6510(v82, v25, v81);
              sub_143A95670(v122);
              v83 = v123;
              sub_143A874A0((__int64)v123, v17);
              v84 = v126;
              sub_146008970(v126, (_QWORD *)(v17 + 0xB8));
              copyStringStructure(&v124, (const void **)v118);
              if ( v15 )
              {
                v53[2] = (void *)(v16 + 0x68);
                v26 = *(_QWORD *)(v16 + 0x68);
                v85 = *(_QWORD *)(v16 + 0x70);
                while ( v26 != v85 )
                {
                  v34 = v26;
                  if ( Current_set((unsigned __int8 **)(v26 + 0x28), &v124) )
                  {
                    *(_DWORD *)(v34 + 0x30) += v125;
                    *(_DWORD *)(v16 + 0x64) += v20;
                    break;
                  }
                  v26 += 0xD0;
                }
              }
              else
              {
                sub_146108820(a1, v16, (unsigned int)v123, 0, (__int64)&v22);
              }
              v86 = v18 + 0x68;
              sub_14611EFB0(v18 + 0x68, v17);
              *(_DWORD *)(v18 + 0x64) -= v20;
              qmemcpy(dst__19, src_1, sizeof(dst__19));
              v54 = (__int64 **)v120;
              sub_146007080((__int64)v120, v57);
              v87 = v54;
              qmemcpy(dst__20, dst__19, 0x18u);
              sub_1460A5320(a1, v54, v18, dst__20, -v20);
              qmemcpy(dst__21, src, sizeof(dst__21));
              v55 = (__int64 **)v121;
              sub_146007080((__int64)v121, v57);
              v88 = v55;
              qmemcpy(dst__22, dst__21, 0x18u);
              sub_1460A5320(a1, v55, v16, dst__22, v20);
              sub_146116780(a1, v18);
              sub_146116780(a1, v16);
              sub_14610E030(a1, v18);
              sub_14610E030(a1, v16);
              sub_143278A40(v126, v14);
              sub_14327A370(v123);
              sub_143A95670(v112);
              DestroyStringObject(&v35);
              DestroyStringObject(&v56);
              DestroyStringObject(&v22);
            }
          }
        }
      }
      return sub_1402AF8A0((__int64)v57);
    }
  }
  return result;
}

// --- End Function: sub_1460ADDF0 (0x1460ADDF0) ---

// --- Function: sub_1460B81C0 (0x1460B81C0) ---
__int64 __fastcall sub_1460B81C0(__int64 a1, __int64 a2, int a3)
{
  int v4; // [rsp+20h] [rbp-78h]
  unsigned __int64 i; // [rsp+28h] [rbp-70h]
  __int64 v6; // [rsp+50h] [rbp-48h]
  __int64 v7; // [rsp+58h] [rbp-40h]
  __int64 v8; // [rsp+60h] [rbp-38h]
  __int64 v9; // [rsp+78h] [rbp-20h]

  if ( a3 < 0
    || a3 + *(_DWORD *)(a2 + 0xB0) >= (unsigned __int64)((*(_QWORD *)(a2 + 0x70) - *(_QWORD *)(a2 + 0x68)) / 0xD0LL) )
  {
    return 0xFFFFFFFFLL;
  }
  v4 = 0;
  for ( i = *(int *)(a2 + 0xB0); i < (*(_QWORD *)(a2 + 0x70) - *(_QWORD *)(a2 + 0x68)) / 0xD0LL; ++i )
  {
    v9 = *(_QWORD *)(a2 + 0x68) + 0xD0 * i;
    v6 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0xC0LL))(v6);
    v8 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 0x10LL))(v7, *(unsigned int *)(v9 + 0x20));
    if ( v8 )
    {
      if ( (unsigned __int8)sub_14609EEB0(a1, a2, v8) )
      {
        if ( ++v4 > a3 )
        {
          return (unsigned int)i;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1460B81C0 (0x1460B81C0) ---

// --- Function: sub_1460CCF90 (0x1460CCF90) ---
__int64 __fastcall sub_1460CCF90(__int64 a1, __int64 a2, int a3, __int64 a4, int a5)
{
  __int64 result; // rax
  __int64 v6; // rax
  __int64 *v7; // [rsp+30h] [rbp-78h]
  __int64 v8; // [rsp+60h] [rbp-48h] BYREF
  _BYTE dst_[56]; // [rsp+70h] [rbp-38h] BYREF

  result = sub_145A47430(*(_DWORD *)(a4 + 0x5C));
  if ( (_BYTE)result )
  {
    result = a2;
    if ( *(_DWORD *)(a2 + 0x5C) == 1 )
    {
      v7 = (__int64 *)(0xD0LL * a3 + *(_QWORD *)(a2 + 0x68));
      result = *(_QWORD *)(a2 + 0x70);
      if ( v7 != (__int64 *)result )
      {
        result = sub_1403BBB00(*v7);
        if ( !(_BYTE)result )
        {
          result = *((unsigned __int8 *)v7 + 0xB0);
          if ( !*((_BYTE *)v7 + 0xB0) )
          {
            v6 = _((__int64)&gEnv);
            (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(**(_QWORD **)(v6 + 0xA0) + 0x120LL))(
              *(_QWORD *)(v6 + 0xA0),
              &v8,
              *v7);
            qmemcpy(dst_, (const void *)(a2 + 0x18), 0x18u);
            result = (unsigned __int8)sub_1460FD590(a1, a4, a5, v8, (__int64)dst_, 1);
            if ( (_BYTE)result )
            {
              sub_14610E030(a1, a2);
              return sub_14610E030(a1, a4);
            }
          }
        }
      }
    }
  }
  return result;
}

// --- End Function: sub_1460CCF90 (0x1460CCF90) ---

// --- Function: sub_1460F57F0 (0x1460F57F0) ---
unsigned __int64 __fastcall sub_1460F57F0(__int64 a1, __int64 a2, signed int a3, int a4)
{
  __int64 v5; // [rsp+28h] [rbp-B0h]
  __int64 *v6; // [rsp+30h] [rbp-A8h]
  _QWORD v7[3]; // [rsp+40h] [rbp-98h] BYREF
  ULONG_PTR Parameter[3]; // [rsp+58h] [rbp-80h] BYREF
  ULONG_PTR v9; // [rsp+70h] [rbp-68h]
  __int64 v10; // [rsp+78h] [rbp-60h]
  __int64 v11; // [rsp+80h] [rbp-58h]
  __int64 v12; // [rsp+88h] [rbp-50h]
  __int64 v13; // [rsp+90h] [rbp-48h]
  __int64 v14; // [rsp+98h] [rbp-40h]
  void *v15; // [rsp+A0h] [rbp-38h] BYREF
  _QWORD v16[6]; // [rsp+A8h] [rbp-30h] BYREF

  v7[1] = a1 + 0x290;
  sub_14188AE40((__int64)v16, a1 + 0x290, a1 + 0x2A0);
  sub_1432DF000(v16, v7, a2);
  Parameter[2] = v16[0];
  v7[2] = v16[0];
  v9 = *(_QWORD *)v16[0];
  Parameter[0] = v9;
  _StarEngineModule__((ULONG_PTR)Parameter);
  if ( v7[0] != Parameter[0] )
  {
    v10 = v7[0] + 0x20LL;
    v6 = (__int64 *)(v7[0] + 0xA0LL);
    if ( a3 > (int)0xFFFFFFFF )
    {
      v11 = a3;
      if ( a3 < (unsigned __int64)((*(_QWORD *)(v7[0] + 0xA8LL) - *(_QWORD *)(v7[0] + 0xA0LL)) / 0xD0LL) )
      {
        v12 = *v6;
        v5 = 0xD0LL * a3 + v12;
        v14 = *(_QWORD *)(v5 + 0x38) * (a4 - *(_DWORD *)(v5 + 0x30));
        v13 = v7[0] + 0x20LL;
        Parameter[1] = v7[0] + 0x9CLL;
        *(_DWORD *)(v7[0] + 0x9CLL) += v14;
        if ( a4 > 0 )
        {
          *(_DWORD *)(v5 + 0x30) = a4;
        }
        else
        {
          sub_1403577C0(&v15, (const void **)(v5 + 0x28));
          sub_14611EFB0(v6, v5);
          DestroyStringObject(&v15);
        }
      }
    }
  }
  return sub_1402AF8A0((__int64)v16);
}

// --- End Function: sub_1460F57F0 (0x1460F57F0) ---

// --- Function: sub_1460FD590 (0x1460FD590) ---
char __fastcall sub_1460FD590(_QWORD *a1, __int64 rdx0, int a3, unsigned __int64 a4, _BYTE *dst, int n2)
{
  __int64 v7; // rdx
  _BYTE *v8; // rax
  _BYTE *v9; // rax
  void **v10; // rax
  _BYTE *v11; // rax
  _BYTE *v12; // rax
  void **v13; // rax
  _BYTE *v14; // rax
  void **v15; // rax
  __int64 v16; // rdx
  __int64 *v17; // rax
  int v18; // edx
  int v19; // r8d
  void *v20; // rsp
  _BYTE *v21; // rax
  _BYTE *v22; // rax
  void **v23; // rax
  __int64 *v24; // rax
  __int64 a8; // [rsp+18h] [rbp-308h]
  _BYTE v26[640]; // [rsp+40h] [rbp-2E0h] BYREF
  __int64 v27; // [rsp+308h] [rbp-18h]
  char v28; // [rsp+320h] [rbp+0h] BYREF
  bool v29; // [rsp+321h] [rbp+1h]
  char v30; // [rsp+322h] [rbp+2h]
  bool v31; // [rsp+323h] [rbp+3h] BYREF
  char v32; // [rsp+324h] [rbp+4h]
  char v33; // [rsp+325h] [rbp+5h]
  __int64 Parameter__1; // [rsp+328h] [rbp+8h] BYREF
  void *v35; // [rsp+330h] [rbp+10h] BYREF
  _QWORD *v36; // [rsp+338h] [rbp+18h]
  unsigned __int64 i; // [rsp+340h] [rbp+20h]
  __int64 v38; // [rsp+348h] [rbp+28h] BYREF
  void *v39; // [rsp+350h] [rbp+30h] BYREF
  BOOL v40; // [rsp+358h] [rbp+38h]
  BOOL v41; // [rsp+35Ch] [rbp+3Ch]
  BOOL v42; // [rsp+360h] [rbp+40h]
  BOOL v43; // [rsp+364h] [rbp+44h]
  _DWORD v44[2]; // [rsp+368h] [rbp+48h] BYREF
  int v45; // [rsp+370h] [rbp+50h]
  int v46; // [rsp+374h] [rbp+54h]
  BOOL v47; // [rsp+378h] [rbp+58h]
  BOOL v48; // [rsp+37Ch] [rbp+5Ch]
  BOOL v49; // [rsp+380h] [rbp+60h]
  __int64 v50; // [rsp+388h] [rbp+68h]
  char *v51; // [rsp+390h] [rbp+70h]
  __int64 v52; // [rsp+398h] [rbp+78h] BYREF
  int v53; // [rsp+3A0h] [rbp+80h]
  int v54; // [rsp+3A8h] [rbp+88h]
  _QWORD *v55; // [rsp+3B0h] [rbp+90h]
  _QWORD *v56; // [rsp+3B8h] [rbp+98h]
  __int64 v57; // [rsp+3C0h] [rbp+A0h] BYREF
  __int64 v58; // [rsp+3C8h] [rbp+A8h]
  void *v59; // [rsp+3D0h] [rbp+B0h] BYREF
  _DWORD v60[2]; // [rsp+3D8h] [rbp+B8h] BYREF
  char v61; // [rsp+3E0h] [rbp+C0h] BYREF
  _DWORD v62[2]; // [rsp+3E8h] [rbp+C8h] BYREF
  char v63; // [rsp+3F0h] [rbp+D0h] BYREF
  __int64 v64; // [rsp+3F8h] [rbp+D8h]
  __int64 v65; // [rsp+400h] [rbp+E0h] BYREF
  unsigned __int64 v66; // [rsp+408h] [rbp+E8h] BYREF
  __int64 v67; // [rsp+410h] [rbp+F0h]
  _QWORD *v68; // [rsp+418h] [rbp+F8h]
  __int64 *v69; // [rsp+420h] [rbp+100h]
  ULONG_PTR Parameter[2]; // [rsp+428h] [rbp+108h] BYREF
  __int64 v71; // [rsp+438h] [rbp+118h]
  unsigned __int64 v72; // [rsp+440h] [rbp+120h]
  void *v73; // [rsp+448h] [rbp+128h] BYREF
  void *v74; // [rsp+450h] [rbp+130h] BYREF
  void *v75; // [rsp+458h] [rbp+138h] BYREF
  void *v76[4]; // [rsp+460h] [rbp+140h] BYREF
  ULONG_PTR Parameter_; // [rsp+480h] [rbp+160h] BYREF
  __int64 v78; // [rsp+488h] [rbp+168h]
  __int64 v79; // [rsp+490h] [rbp+170h]
  __int64 v80; // [rsp+498h] [rbp+178h]
  __int64 v81; // [rsp+4A0h] [rbp+180h]
  __int64 v82; // [rsp+4A8h] [rbp+188h]
  __int64 v83; // [rsp+4B0h] [rbp+190h]
  __int64 v84; // [rsp+4B8h] [rbp+198h]
  __int64 v85; // [rsp+4C0h] [rbp+1A0h]
  _BYTE *v86; // [rsp+4C8h] [rbp+1A8h]
  __int64 a5; // [rsp+4D0h] [rbp+1B0h]
  void *v88; // [rsp+4D8h] [rbp+1B8h] BYREF
  void *v89[2]; // [rsp+4E0h] [rbp+1C0h] BYREF
  ULONG_PTR Parameter__2; // [rsp+4F0h] [rbp+1D0h] BYREF
  __int64 v91; // [rsp+4F8h] [rbp+1D8h]
  __int64 v92; // [rsp+500h] [rbp+1E0h]
  __int64 *v93; // [rsp+508h] [rbp+1E8h]
  ULONG_PTR Parameter__3[2]; // [rsp+510h] [rbp+1F0h] BYREF
  ULONG_PTR Parameter__4[2]; // [rsp+520h] [rbp+200h] BYREF
  ULONG_PTR Parameter__5; // [rsp+530h] [rbp+210h] BYREF
  _QWORD *v97; // [rsp+538h] [rbp+218h]
  __int64 v98; // [rsp+540h] [rbp+220h]
  __int64 *v99[4]; // [rsp+548h] [rbp+228h] BYREF
  char *v100; // [rsp+568h] [rbp+248h] BYREF
  char *v101; // [rsp+570h] [rbp+250h]
  __int64 v102; // [rsp+580h] [rbp+260h]
  __int64 v103; // [rsp+588h] [rbp+268h]
  void (__fastcall *v104)(__int64, unsigned __int64 *, __int64); // [rsp+590h] [rbp+270h]
  __int64 v105; // [rsp+598h] [rbp+278h]
  __int64 *v106; // [rsp+5A0h] [rbp+280h]
  __int64 v107; // [rsp+5A8h] [rbp+288h]
  void (__fastcall *v108)(__int64, __int64, _QWORD *); // [rsp+5B0h] [rbp+290h]
  __int64 *v109; // [rsp+5B8h] [rbp+298h]
  ULONG_PTR v110; // [rsp+5C0h] [rbp+2A0h]
  __int64 v111; // [rsp+5C8h] [rbp+2A8h]
  __int64 v112; // [rsp+5D0h] [rbp+2B0h]
  __int64 v113; // [rsp+5D8h] [rbp+2B8h]
  void *v114; // [rsp+5E0h] [rbp+2C0h] BYREF
  void *v115[2]; // [rsp+5E8h] [rbp+2C8h] BYREF
  void **v116; // [rsp+5F8h] [rbp+2D8h]
  unsigned __int64 v117; // [rsp+600h] [rbp+2E0h]
  void *v118[2]; // [rsp+608h] [rbp+2E8h] BYREF
  __int64 AssetMeta; // [rsp+618h] [rbp+2F8h]
  _QWORD *v120; // [rsp+620h] [rbp+300h]
  __int64 v121; // [rsp+628h] [rbp+308h]
  void **v122; // [rsp+630h] [rbp+310h]
  void *v123; // [rsp+638h] [rbp+318h]
  int v124[2]; // [rsp+640h] [rbp+320h]
  char *v125; // [rsp+648h] [rbp+328h]
  __int64 *v126; // [rsp+650h] [rbp+330h]
  ULONG_PTR Parameter__6; // [rsp+658h] [rbp+338h]
  __int64 v128; // [rsp+660h] [rbp+340h]
  __int64 v129; // [rsp+668h] [rbp+348h]
  __int64 v130; // [rsp+670h] [rbp+350h]
  __int64 v131; // [rsp+678h] [rbp+358h]
  __int64 v132; // [rsp+680h] [rbp+360h]
  __int64 v133; // [rsp+688h] [rbp+368h]
  _QWORD *buf_1; // [rsp+690h] [rbp+370h]
  __int64 v135; // [rsp+698h] [rbp+378h]
  __int64 v136; // [rsp+6A0h] [rbp+380h]
  __int64 v137; // [rsp+6A8h] [rbp+388h]
  __int64 v138; // [rsp+6B0h] [rbp+390h]
  _QWORD *buf; // [rsp+6B8h] [rbp+398h]
  __int64 v140; // [rsp+6C0h] [rbp+3A0h]
  __int64 v141; // [rsp+6C8h] [rbp+3A8h]
  unsigned __int64 *v142; // [rsp+6D0h] [rbp+3B0h]
  __int64 v143; // [rsp+6D8h] [rbp+3B8h] BYREF
  __int64 (__fastcall *v144)(__int64, _BYTE *); // [rsp+6E0h] [rbp+3C0h]
  __int64 v145; // [rsp+6E8h] [rbp+3C8h]
  __int64 v146; // [rsp+6F0h] [rbp+3D0h]
  __int64 v147; // [rsp+6F8h] [rbp+3D8h]
  __int64 v148; // [rsp+700h] [rbp+3E0h]
  _QWORD *v149; // [rsp+708h] [rbp+3E8h]
  _QWORD *v150; // [rsp+710h] [rbp+3F0h]
  _QWORD *v151; // [rsp+718h] [rbp+3F8h]
  _QWORD *v152; // [rsp+720h] [rbp+400h]
  _QWORD *v153; // [rsp+728h] [rbp+408h]
  _QWORD *v154; // [rsp+730h] [rbp+410h]
  __int64 *ThreadLogContextSlot; // [rsp+738h] [rbp+418h]
  const void *ptr_to_free_3; // [rsp+740h] [rbp+420h]
  const void *ptr_to_free_4; // [rsp+748h] [rbp+428h]
  const void *ptr_to_free_5; // [rsp+750h] [rbp+430h]
  __int64 v159; // [rsp+758h] [rbp+438h]
  __int64 v160; // [rsp+760h] [rbp+440h]
  void *v161[2]; // [rsp+768h] [rbp+448h] BYREF
  ULONG_PTR Parameter__7; // [rsp+778h] [rbp+458h]
  __int64 v163; // [rsp+780h] [rbp+460h]
  __int64 (__fastcall *v164)(__int64, _BYTE *); // [rsp+788h] [rbp+468h]
  struct std::pmr::memory_resource *v165; // [rsp+790h] [rbp+470h]
  std::pmr::_Identity_equal_resource *v166; // [rsp+798h] [rbp+478h]
  __int64 v167; // [rsp+7A0h] [rbp+480h]
  __int64 (__fastcall *v168)(__int64, _BYTE *); // [rsp+7A8h] [rbp+488h]
  __int64 *v169; // [rsp+7B0h] [rbp+490h]
  __int64 *v170; // [rsp+7B8h] [rbp+498h]
  __int64 *v171; // [rsp+7C0h] [rbp+4A0h]
  ULONG_PTR v172; // [rsp+7C8h] [rbp+4A8h]
  ULONG_PTR v173; // [rsp+7D0h] [rbp+4B0h]
  __int64 v174; // [rsp+7D8h] [rbp+4B8h]
  __int64 v175; // [rsp+7E0h] [rbp+4C0h]
  __int64 v176; // [rsp+7E8h] [rbp+4C8h]
  __int64 v177; // [rsp+7F0h] [rbp+4D0h]
  __int64 v178; // [rsp+7F8h] [rbp+4D8h]
  __int64 *v179; // [rsp+800h] [rbp+4E0h]
  ULONG_PTR Parameter__8; // [rsp+808h] [rbp+4E8h]
  __int64 v181; // [rsp+810h] [rbp+4F0h]
  __int64 v182; // [rsp+818h] [rbp+4F8h]
  __int64 *v183; // [rsp+820h] [rbp+500h]
  __int64 v184; // [rsp+828h] [rbp+508h]
  _QWORD buf__1[3]; // [rsp+830h] [rbp+510h] BYREF
  _QWORD buf_[3]; // [rsp+848h] [rbp+528h] BYREF
  __int64 v187; // [rsp+860h] [rbp+540h]
  _QWORD v188[2]; // [rsp+868h] [rbp+548h] BYREF
  const void *ptr_to_free_1; // [rsp+878h] [rbp+558h]
  _QWORD v190[2]; // [rsp+880h] [rbp+560h] BYREF
  const void *ptr_to_free_2; // [rsp+890h] [rbp+570h]
  _QWORD src_[2]; // [rsp+898h] [rbp+578h] BYREF
  _QWORD src__1[2]; // [rsp+8A8h] [rbp+588h] BYREF
  _QWORD v194[2]; // [rsp+8B8h] [rbp+598h] BYREF
  _QWORD v195[2]; // [rsp+8C8h] [rbp+5A8h] BYREF
  _QWORD src__2[2]; // [rsp+8D8h] [rbp+5B8h] BYREF
  _QWORD a9[3]; // [rsp+8E8h] [rbp+5C8h] BYREF
  _BYTE dst_[16]; // [rsp+900h] [rbp+5E0h] BYREF
  _QWORD v199[2]; // [rsp+910h] [rbp+5F0h] BYREF
  char v200; // [rsp+920h] [rbp+600h]
  _BYTE v201[8]; // [rsp+928h] [rbp+608h] BYREF
  __int64 n7; // [rsp+930h] [rbp+610h]
  _BYTE v203[8]; // [rsp+938h] [rbp+618h] BYREF
  _BYTE v204[8]; // [rsp+940h] [rbp+620h] BYREF
  __int64 v205; // [rsp+948h] [rbp+628h] BYREF
  __int64 v206; // [rsp+950h] [rbp+630h] BYREF
  void *v207; // [rsp+958h] [rbp+638h] BYREF
  __int128 dst__1; // [rsp+960h] [rbp+640h] BYREF
  __int128 dst__2; // [rsp+970h] [rbp+650h] BYREF
  _BYTE dst__21[16]; // [rsp+980h] [rbp+660h] BYREF
  __int64 dst__22[2]; // [rsp+990h] [rbp+670h] BYREF
  __int64 v212; // [rsp+9A0h] [rbp+680h] BYREF
  void *v213; // [rsp+9A8h] [rbp+688h] BYREF
  _BYTE v214[8]; // [rsp+9B0h] [rbp+690h] BYREF
  _QWORD v215[3]; // [rsp+9B8h] [rbp+698h] BYREF
  _QWORD v216[3]; // [rsp+9D0h] [rbp+6B0h] BYREF
  _BYTE src__3[24]; // [rsp+9E8h] [rbp+6C8h] BYREF
  _BYTE v218[8]; // [rsp+A00h] [rbp+6E0h] BYREF
  _BYTE dst__27[24]; // [rsp+A08h] [rbp+6E8h] BYREF
  int dst__28[6]; // [rsp+A20h] [rbp+700h] BYREF
  _BYTE dst__9[24]; // [rsp+A40h] [rbp+720h] BYREF
  _BYTE dst__10[24]; // [rsp+A58h] [rbp+738h] BYREF
  _BYTE dst__11[24]; // [rsp+A70h] [rbp+750h] BYREF
  _BYTE dst__12[24]; // [rsp+A88h] [rbp+768h] BYREF
  _BYTE dst__14[24]; // [rsp+AA0h] [rbp+780h] BYREF
  _BYTE dst__15[24]; // [rsp+AB8h] [rbp+798h] BYREF
  _BYTE dst__16[24]; // [rsp+AD0h] [rbp+7B0h] BYREF
  _BYTE dst__13[24]; // [rsp+AE8h] [rbp+7C8h] BYREF
  _BYTE dst__17[24]; // [rsp+B00h] [rbp+7E0h] BYREF
  _BYTE dst__18[32]; // [rsp+B20h] [rbp+800h] BYREF
  _BYTE dst__19[32]; // [rsp+B40h] [rbp+820h] BYREF
  _BYTE dst__3[24]; // [rsp+B60h] [rbp+840h] BYREF
  _BYTE dst__5[24]; // [rsp+B78h] [rbp+858h] BYREF
  _BYTE dst__4[24]; // [rsp+B90h] [rbp+870h] BYREF
  _BYTE dst__6[24]; // [rsp+BA8h] [rbp+888h] BYREF
  _BYTE dst__7[32]; // [rsp+BC0h] [rbp+8A0h] BYREF
  _BYTE dst__8[32]; // [rsp+BE0h] [rbp+8C0h] BYREF
  __int64 v238; // [rsp+C00h] [rbp+8E0h] BYREF
  const void *ptr_to_free; // [rsp+C10h] [rbp+8F0h]
  _BYTE dst__23[24]; // [rsp+C18h] [rbp+8F8h] BYREF
  _BYTE dst__24[32]; // [rsp+C30h] [rbp+910h] BYREF
  _BYTE dst__25[32]; // [rsp+C50h] [rbp+930h] BYREF
  _BYTE dst__26[24]; // [rsp+C70h] [rbp+950h] BYREF
  _BYTE v244[24]; // [rsp+C88h] [rbp+968h] BYREF
  _QWORD v245[2]; // [rsp+CA0h] [rbp+980h] BYREF
  _BYTE v246[24]; // [rsp+CB0h] [rbp+990h] BYREF
  _BYTE dst__20[24]; // [rsp+CC8h] [rbp+9A8h] BYREF
  void *v248[4]; // [rsp+D10h] [rbp+9F0h] BYREF
  __int64 v249; // [rsp+D30h] [rbp+A10h]
  _QWORD v250[54]; // [rsp+E40h] [rbp+B20h] BYREF
  _QWORD v251[23]; // [rsp+FF0h] [rbp+CD0h] BYREF
  _QWORD v252[3]; // [rsp+10A8h] [rbp+D88h] BYREF
  unsigned __int64 v256; // [rsp+1108h] [rbp+DE8h] BYREF

  v256 = a4;
  v52 = a1[0x34];
  v97 = a1 + 0x35;
  if ( is_valid_handle_typeA(a1 + 0x35) )
  {
    v58 = *v97 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v58 = 0;
  }
  if ( *(_BYTE *)(rdx0 + 0xF3) )
  {
    return 0;
  }
  v40 = !is_valid_handle_typeA(&v52);
  if ( v40 || !v58 || is_valid_handle_typeB_w(&v256) )
  {
    return 0;
  }
  v182 = Handle::ToIndex(&v256);
  v183 = sub_140337E40(v182, &v205);
  v184 = *v183;
  v57 = v184;
  v98 = Handle::ToIndex(&v256);
  v187 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v98 + 0x20LL))(v98);
  v41 = !AssetMeta::HasActorSubresource(&v57);
  if ( v41 || !v187 )
  {
    return 0;
  }
  qmemcpy(dst_, (const void *)(rdx0 + 0x50), 0xCu);
  if ( !(unsigned __int8)sub_140396470(dst_, *(int *)(rdx0 + 0x60), *(int *)(rdx0 + 0x64), v256) )
  {
    return 0;
  }
  v64 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
  v104 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v64 + 0x120LL);
  v102 = rdx0 + 0x18;
  v103 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
            (_QWORD *)(rdx0 + 0x18),
            &v206);
  v104(v64, &v66, v103);
  if ( is_valid_handle_typeB(&v66) )
  {
    v105 = Handle::ToIndex(&v256);
    v106 = sub_140338450(v105, &v212);
    v107 = *v106;
    v65 = v107;
    if ( AssetMeta::HasActorSubresource(&v65) )
    {
      v28 = 0;
      v67 = v65 & 0xFFFFFFFFFFFFLL;
      v108 = *(void (__fastcall **)(__int64, __int64, _QWORD *))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 0x638LL);
      src_[0] = v66;
      src_[1] = &v28;
      qmemcpy(&dst__1, src_, sizeof(dst__1));
      dst__2 = dst__1;
      sub_145FCEFB0(v215, &dst__2);
      LOBYTE(v7) = 1;
      v108(v67, v7, v215);
      sub_1402A0EC0(v215);
      if ( v28 )
      {
        return 0;
      }
    }
  }
  v68 = a1 + 0x52;
  sub_14188AE40((__int64)v99, (__int64)(a1 + 0x52), (__int64)(a1 + 0x54));
  sub_1432DF000(v99, &Parameter__1, dst);
  if ( sub_1405AC2A0((__int64)dst, (__int64)&::src__3)
    && ((v109 = v99[0],
         v69 = v99[0],
         v110 = *v99[0],
         Parameter[0] = v110,
         _StarEngineModule__((ULONG_PTR)Parameter),
         v42 = Parameter__1 == Parameter[0])
     || (v111 = Parameter__1 + 0x20, *(_BYTE *)(Parameter__1 + 0x12B))) )
  {
    v30 = 0;
    sub_1402AF8A0((__int64)v99);
    return v30;
  }
  else
  {
    initializeEmptyStringStructure(&v35);
    initializeEmptyStringStructure(&v59);
    sub_1403577C0(&v39, &qword_149B35AA8);
    if ( a3 <= (int)0xFFFFFFFF
      || (Parameter[1] = rdx0 + 0x68,
          v112 = a3,
          a3 >= (unsigned __int64)((*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL)) )
    {
      sub_143277150((__int64)v251);
      unknown_libname_472(v252);
      v115[1] = &v213;
      v116 = sub_1403577C0(&v213, &qword_149B35AA8);
      v117 = v256;
      sub_146046100((__int64)a1, v256, 1, v116, (__int64)v251);
      v31 = 0;
      v15 = sub_14605D240((int)a1, v118, rdx0, (__int64)v251, n2, &v59, &v39, &v31);
      sub_140374480(&v35, v15);
      DestroyStringObject(v118);
      sub_143278A40(v252, v16);
      sub_14327A370(v251);
    }
    else
    {
      v55 = (_QWORD *)(rdx0 + 0x68);
      v71 = a3;
      if ( a3 >= (unsigned __int64)((*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL) )
      {
        __debugbreak();
      }
      v50 = *v55 + 0xD0 * v71;
      if ( a3 <= 0 )
      {
        v12 = (_BYTE *)SEntityProxy::AsJson(v50 + 0x28);
        CreateStringObjectFromString(v76, v12);
        CreateStringObjectFromString(&v75, &p_p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
        v13 = sub_1403A6BF0(v115, (char **)&v75, (char **)v76);
        sub_140374480(&v35, v13);
        DestroyStringObject(v115);
        DestroyStringObject(&v75);
        DestroyStringObject(v76);
        v14 = (_BYTE *)SEntityProxy::AsJson(v50 + 0x28);
        assignCStringToStringStructure(&v39, v14);
      }
      else
      {
        v8 = (_BYTE *)SEntityProxy::AsJson(v50 + 0x28);
        CreateStringObjectFromString(&v74, v8);
        v56 = (_QWORD *)(rdx0 + 0x68);
        v72 = a3 - 1;
        if ( v72 >= (*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL )
        {
          __debugbreak();
        }
        v113 = *v56 + 0xD0 * v72;
        v9 = (_BYTE *)SEntityProxy::AsJson(v113 + 0x28);
        CreateStringObjectFromString(&v73, v9);
        v10 = sub_1403A6BF0(&v114, (char **)&v73, (char **)&v74);
        sub_140374480(&v35, v10);
        DestroyStringObject(&v114);
        DestroyStringObject(&v73);
        DestroyStringObject(&v74);
        v11 = (_BYTE *)SEntityProxy::AsJson(v50 + 0x28);
        assignCStringToStringStructure(&v39, v11);
      }
    }
    unknown_libname_472(&v100);
    v29 = 1;
    v118[1] = (void *)(v52 & 0xFFFFFFFFFFFFLL);
    AssetMeta = AssetDB::GetAssetMeta(v52 & 0xFFFFFFFFFFFFLL);
    v120 = (_QWORD *)sub_145D02840(AssetMeta, v214);
    if ( unknown_libname_23(v120, &v256) )
    {
      v17 = (__int64 *)sub_1403AE0A0(v218);
      sub_14035C280(v44, v17);
      unknown_libname_472(v216);
      LOBYTE(v18) = 1;
      sub_1403AD2F0(v256, v18, (unsigned int)&v100, (unsigned int)v216, (__int64)v44, 0);
      sub_1402B07B0((__int64)v216);
      v76[1] = &v100;
      v43 = v100 == v101;
      v29 = v100 == v101;
      sub_1402A4690(&v100, &v256);
      sub_14036EF50(v44);
      v76[2] = &v100;
      v51 = v100;
      v125 = v101;
      while ( v51 != v125 )
      {
        v38 = *(_QWORD *)v51;
        v126 = v99[0];
        v76[3] = v99[0];
        Parameter__6 = *v99[0];
        Parameter_ = Parameter__6;
        _StarEngineModule__((ULONG_PTR)&Parameter_);
        v44[1] = Parameter__1 == Parameter_;
        if ( Parameter__1 == Parameter_ )
        {
          v80 = Handle::ToIndex(&v38);
          v81 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v80 + 0x20LL))(v80);
          v138 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v81 + 0x18LL))(v81);
          memset(buf_, 0, sizeof(buf_));
          sub_1402AF610(buf_);
          initializeEmptyStringStructure(&buf_[1]);
          sub_1402AF610(&buf_[2]);
          buf = buf_;
          v137 = v57;
          v140 = v57;
          qmemcpy(dst__3, &::src__3, sizeof(dst__3));
          qmemcpy(dst__4, dst__3, sizeof(dst__4));
          qmemcpy(dst__5, (const void *)(rdx0 + 0x18), sizeof(dst__5));
          qmemcpy(dst__6, dst__5, sizeof(dst__6));
          qmemcpy(dst__7, dst__4, 0x18u);
          qmemcpy(dst__8, dst__6, 0x18u);
          LODWORD(v27) = 6;
          v45 = sub_146026600(
                  (__int64)a1,
                  7,
                  dst__8,
                  (_QWORD *)(rdx0 + 0x68),
                  dst__7,
                  0,
                  v57,
                  buf_,
                  v138,
                  v27,
                  "CSCLocalPlayerPersonalThoughtComponent::StoreItem");
          DestroyStringObject(&buf_[1]);
        }
        else
        {
          v78 = Handle::ToIndex(&v38);
          v79 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v78 + 0x20LL))(v78);
          v133 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v79 + 0x18LL))(v79);
          memset(buf__1, 0, sizeof(buf__1));
          sub_1402AF610(buf__1);
          initializeEmptyStringStructure(&buf__1[1]);
          sub_1402AF610(&buf__1[2]);
          buf_1 = buf__1;
          v128 = v57;
          v129 = v57;
          v130 = v57;
          v135 = v57;
          v131 = Parameter__1 + 0x20;
          v136 = Parameter__1 + 0xA0;
          v132 = Parameter__1 + 0x20;
          qmemcpy(dst__9, (const void *)(Parameter__1 + 0x20), sizeof(dst__9));
          qmemcpy(dst__10, dst__9, sizeof(dst__10));
          qmemcpy(dst__11, dst__10, sizeof(dst__11));
          qmemcpy(dst__12, dst__11, sizeof(dst__12));
          qmemcpy(dst__13, dst__12, sizeof(dst__13));
          qmemcpy(dst__14, (const void *)(rdx0 + 0x18), sizeof(dst__14));
          qmemcpy(dst__15, dst__14, sizeof(dst__15));
          qmemcpy(dst__16, dst__15, sizeof(dst__16));
          qmemcpy(dst__17, dst__16, sizeof(dst__17));
          qmemcpy(dst__18, dst__13, 0x18u);
          qmemcpy(dst__19, dst__17, 0x18u);
          LODWORD(v27) = 6;
          v45 = sub_146026600(
                  (__int64)a1,
                  7,
                  dst__19,
                  (_QWORD *)(rdx0 + 0x68),
                  dst__18,
                  (_QWORD *)(Parameter__1 + 0xA0),
                  v57,
                  buf__1,
                  v133,
                  v27,
                  "CSCLocalPlayerPersonalThoughtComponent::StoreItem");
          DestroyStringObject(&buf__1[1]);
        }
        sub_143A87910((__int64)v245, v45);
        sub_146056B30((__int64)v245, 1);
        HIDWORD(v245[0]) = 7;
        v141 = v52 & 0xFFFFFFFFFFFFLL;
        v142 = (unsigned __int64 *)((v52 & 0xFFFFFFFFFFFFLL) + 8);
        sub_1403AC900(v142, &v143);
        v245[1] = v143;
        qmemcpy(dst__20, (const void *)(rdx0 + 0x18), sizeof(dst__20));
        copyStringStructure(v248, (const void **)&v35);
        v82 = Handle::ToIndex(&v38);
        v144 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v82 + 8LL);
        v249 = *(_QWORD *)v144(v82, v201);
        v60[0] = sub_142656CA0(0x1Bu);
        v60[1] = 0x4D;
        src__1[0] = v60;
        src__1[1] = &v61;
        qmemcpy(dst__21, src__1, sizeof(dst__21));
        v46 = invokeGlobalCallbackAndMaskStatusBits(
                5,
                (__int64)dst__21,
                (__int64)"StoreItem",
                "Request[$$] store Entity[$$] To Inventory[$$] Class[$$] Rank[$$] ItemsCount[$$]");
        if ( (v46 & 0xFFFFF) != 0 )
        {
          v83 = rdx0 + 0x68;
          v145 = (*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL;
          v194[0] = 0;
          v194[1] = v145;
          v149 = v194;
          v146 = SEntityProxy::AsJson((__int64)v248);
          v190[0] = 0;
          v190[1] = v146;
          ptr_to_free_2 = 0;
          v150 = v190;
          v84 = Handle::ToIndex(&v38);
          v85 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v84 + 0x20LL))(v84);
          v147 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v85 + 0x18LL))(v85);
          v188[0] = 0;
          v188[1] = v147;
          ptr_to_free_1 = 0;
          v151 = v188;
          v148 = _(v249);
          v199[0] = 0;
          v199[1] = v148;
          v200 = 0;
          v152 = v199;
          v153 = sub_140358CF0(&v238, (__int64)v246, 0);
          v54 = v245[0];
          v195[0] = 0;
          v195[1] = LODWORD(v245[0]);
          v154 = v195;
          ThreadLogContextSlot = getThreadLogContextSlot();
          a9[0] = 0;
          a9[1] = 0;
          v62[0] = sub_142656CA0(0x1Bu);
          v62[1] = 0x4D;
          src__2[0] = v62;
          src__2[1] = &v63;
          qmemcpy(dst__22, src__2, sizeof(dst__22));
          n7 = 7;
          v20 = alloca(0x2E0);
          v86 = v26;
          a5 = (__int64)v26;
          sub_145FF7820(
            (unsigned int)v26,
            (_DWORD)ThreadLogContextSlot,
            (_DWORD)v154,
            (_DWORD)v153,
            (__int64)v152,
            (__int64)v151,
            (__int64)v150,
            (__int64)v149);
          LODWORD(a8) = v46;
          sub_140302350(
            5,
            (__int64)dst__22,
            "StoreItem",
            (__int64)"Request[$$] store Entity[$$] To Inventory[$$] Class[$$] Rank[$$] ItemsCount[$$]",
            a5,
            7,
            1,
            a8,
            a9,
            0);
          ptr_to_free_3 = ptr_to_free;
          free_memory_wrapper(ptr_to_free);
          ptr_to_free_4 = ptr_to_free_1;
          free_memory_wrapper(ptr_to_free_1);
          ptr_to_free_5 = ptr_to_free_2;
          free_memory_wrapper(ptr_to_free_2);
        }
        v160 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
        v159 = sub_144CBD720((__int64)v250, (__int64)v245);
        sub_1439C6510(v160, v58, v159);
        sub_143A95670(v250);
        sub_146109950((_DWORD)a1, rdx0, v38, v29, (__int64)&v35);
        v21 = (_BYTE *)SEntityProxy::AsJson((__int64)&v39);
        CreateStringObjectFromString(v89, v21);
        v22 = (_BYTE *)SEntityProxy::AsJson((__int64)&v35);
        CreateStringObjectFromString(&v88, v22);
        v23 = sub_1403A6BF0(v161, (char **)&v88, (char **)v89);
        sub_140374480(&v35, v23);
        DestroyStringObject(v161);
        DestroyStringObject(&v88);
        DestroyStringObject(v89);
        v161[1] = v99[0];
        v89[1] = v99[0];
        Parameter__7 = *v99[0];
        Parameter__2 = Parameter__7;
        _StarEngineModule__((ULONG_PTR)&Parameter__2);
        v47 = Parameter__1 == Parameter__2;
        if ( Parameter__1 != Parameter__2 )
        {
          v163 = Parameter__1 + 0x20;
          v36 = (_QWORD *)(Parameter__1 + 0xA0);
          for ( i = 0; i < (v36[1] - *v36) / 0xD0LL; ++i )
          {
            v91 = Handle::ToIndex(&v38);
            v164 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v91 + 8LL);
            v165 = *(struct std::pmr::memory_resource **)v164(v91, v203);
            if ( i >= (v36[1] - *v36) / 0xD0LL )
            {
              __debugbreak();
            }
            v166 = *(std::pmr::_Identity_equal_resource **)(*v36 + 0xD0 * i);
            if ( std::pmr::_Identity_equal_resource::do_is_equal(v166, v165) )
            {
              if ( i >= (v36[1] - *v36) / 0xD0LL )
              {
                __debugbreak();
              }
              v53 = *(_DWORD *)(*v36 + 0xD0 * i + 0x30) - 1;
              v167 = Parameter__1 + 0x20;
              qmemcpy(dst__23, (const void *)(Parameter__1 + 0x20), sizeof(dst__23));
              qmemcpy(dst__24, dst__23, 0x18u);
              sub_1460F57F0((__int64)a1, (__int64)dst__24, i, v53);
              break;
            }
          }
        }
        v92 = Handle::ToIndex(&v38);
        v168 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v92 + 8LL);
        v24 = (__int64 *)v168(v92, v204);
        sub_1405AC2F0((__int64)src__3, *v24);
        v93 = v99[0];
        v170 = v99[0];
        v169 = sub_14326D650(v99[0], (__int64)src__3);
        Parameter__3[0] = (ULONG_PTR)v169;
        _StarEngineModule__((ULONG_PTR)Parameter__3);
        v173 = Parameter__3[0];
        v171 = v99[0];
        Parameter__3[1] = (ULONG_PTR)v99[0];
        v172 = *v99[0];
        Parameter__4[0] = v172;
        _StarEngineModule__((ULONG_PTR)Parameter__4);
        v48 = v173 == Parameter__4[0];
        if ( v173 != Parameter__4[0] )
        {
          v178 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
          qmemcpy(dst__25, src__3, 0x18u);
          v176 = sub_142889820(v244, dst__25);
          v174 = a1[1];
          v175 = v174;
          v177 = v174;
          sub_1439C7760(v178, v174, v176);
        }
        sub_143A95670(v245);
        v51 += 8;
      }
      v179 = v99[0];
      Parameter__4[1] = (ULONG_PTR)v99[0];
      Parameter__8 = *v99[0];
      Parameter__5 = Parameter__8;
      _StarEngineModule__((ULONG_PTR)&Parameter__5);
      v49 = Parameter__1 == Parameter__5;
      if ( Parameter__1 != Parameter__5 )
      {
        v181 = Parameter__1 + 0x20;
        sub_146116780(a1, Parameter__1 + 0x38);
      }
      v33 = 1;
      sub_1402B07B0((__int64)&v100);
      DestroyStringObject(&v39);
      DestroyStringObject(&v59);
      DestroyStringObject(&v35);
      sub_1402AF8A0((__int64)v99);
      return v33;
    }
    else
    {
      v121 = v52 & 0xFFFFFFFFFFFFLL;
      *(_QWORD *)v124 = sub_14638A840(v52 & 0xFFFFFFFFFFFFLL);
      v122 = &v207;
      v123 = sub_1403577C0(&v207, (const void **)&v35);
      qmemcpy(dst__26, (const void *)(rdx0 + 0x18), sizeof(dst__26));
      qmemcpy(dst__27, dst__26, sizeof(dst__27));
      qmemcpy(dst__28, dst__27, sizeof(dst__28));
      LOBYTE(v19) = 1;
      sub_1458F5110(v124[0], (int)dst__28, v19, 2, v123);
      v32 = 1;
      sub_1402B07B0((__int64)&v100);
      DestroyStringObject(&v39);
      DestroyStringObject(&v59);
      DestroyStringObject(&v35);
      sub_1402AF8A0((__int64)v99);
      return v32;
    }
  }
}

// --- End Function: sub_1460FD590 (0x1460FD590) ---

// --- Function: sub_146108820 (0x146108820) ---
__int64 __fastcall sub_146108820(__int64 a1, __int64 rdx0, __int64 a3, char a4, unsigned __int8 **arg20)
{
  __int64 result; // rax
  AK::WriteBytesMem *v6; // rax
  unsigned __int8 *v7; // rax
  void *v8; // rsp
  void *v9; // rsp
  void *v10; // rsp
  void **v11; // rax
  void *v12; // rsp
  __int64 v13; // [rsp+18h] [rbp-358h]
  _BYTE v14[256]; // [rsp+30h] [rbp-340h] BYREF
  __int64 v15; // [rsp+148h] [rbp-228h]
  _BYTE v16[32]; // [rsp+160h] [rbp-210h] BYREF
  __int64 a8; // [rsp+1B8h] [rbp-1B8h]
  _BYTE v18[336]; // [rsp+1D0h] [rbp-1A0h] BYREF
  char v19; // [rsp+370h] [rbp+0h]
  unsigned __int8 v20; // [rsp+371h] [rbp+1h]
  bool v21; // [rsp+372h] [rbp+2h]
  unsigned __int8 v22; // [rsp+373h] [rbp+3h]
  bool v23; // [rsp+374h] [rbp+4h]
  char v24; // [rsp+375h] [rbp+5h]
  char v25; // [rsp+376h] [rbp+6h]
  __int64 v26; // [rsp+378h] [rbp+8h]
  char v27; // [rsp+380h] [rbp+10h]
  unsigned __int64 i; // [rsp+388h] [rbp+18h]
  unsigned __int64 j; // [rsp+390h] [rbp+20h]
  int v30; // [rsp+398h] [rbp+28h]
  int v31; // [rsp+39Ch] [rbp+2Ch]
  int v32; // [rsp+3A0h] [rbp+30h]
  int v33; // [rsp+3A4h] [rbp+34h]
  int v34; // [rsp+3A8h] [rbp+38h]
  unsigned int v35; // [rsp+3ACh] [rbp+3Ch]
  _QWORD *v36; // [rsp+3B0h] [rbp+40h]
  __int64 v37; // [rsp+3B8h] [rbp+48h]
  _QWORD *v38; // [rsp+3C0h] [rbp+50h]
  __int64 v39; // [rsp+3C8h] [rbp+58h]
  _DWORD v40[2]; // [rsp+3D0h] [rbp+60h] BYREF
  char v41; // [rsp+3D8h] [rbp+68h] BYREF
  _DWORD v42[2]; // [rsp+3E0h] [rbp+70h] BYREF
  char v43; // [rsp+3E8h] [rbp+78h] BYREF
  _DWORD v44[2]; // [rsp+3F0h] [rbp+80h] BYREF
  char v45; // [rsp+3F8h] [rbp+88h] BYREF
  _DWORD v46[2]; // [rsp+400h] [rbp+90h] BYREF
  char v47; // [rsp+408h] [rbp+98h] BYREF
  _DWORD v48[2]; // [rsp+410h] [rbp+A0h] BYREF
  char v49; // [rsp+418h] [rbp+A8h] BYREF
  _DWORD v50[2]; // [rsp+420h] [rbp+B0h] BYREF
  char v51; // [rsp+428h] [rbp+B8h] BYREF
  _DWORD v52[2]; // [rsp+430h] [rbp+C0h] BYREF
  char v53; // [rsp+438h] [rbp+C8h] BYREF
  _DWORD v54[2]; // [rsp+440h] [rbp+D0h] BYREF
  char v55; // [rsp+448h] [rbp+D8h] BYREF
  __int64 v56; // [rsp+450h] [rbp+E0h]
  __int64 v57; // [rsp+458h] [rbp+E8h]
  void *a6; // [rsp+460h] [rbp+F0h] BYREF
  void *v59[3]; // [rsp+468h] [rbp+F8h] BYREF
  __int64 v60; // [rsp+480h] [rbp+110h]
  __int64 v61; // [rsp+488h] [rbp+118h]
  _BYTE *v62; // [rsp+490h] [rbp+120h]
  __int64 v63; // [rsp+498h] [rbp+128h]
  __int64 v64; // [rsp+4A0h] [rbp+130h]
  _BYTE *v65; // [rsp+4A8h] [rbp+138h]
  __int64 v66; // [rsp+4B0h] [rbp+140h]
  __int64 v67; // [rsp+4B8h] [rbp+148h]
  _BYTE *v68; // [rsp+4C0h] [rbp+150h]
  __int64 v69; // [rsp+4C8h] [rbp+158h]
  const void *ptr_to_free_14; // [rsp+4D0h] [rbp+160h]
  const void *ptr_to_free_15; // [rsp+4D8h] [rbp+168h]
  __int64 v72; // [rsp+4E0h] [rbp+170h]
  __int64 v73; // [rsp+4E8h] [rbp+178h]
  _QWORD *v74; // [rsp+4F0h] [rbp+180h]
  _QWORD *v75; // [rsp+4F8h] [rbp+188h]
  _QWORD *v76; // [rsp+500h] [rbp+190h]
  __int64 *ThreadLogContextSlot_1; // [rsp+508h] [rbp+198h]
  const void *ptr_to_free_16; // [rsp+510h] [rbp+1A0h]
  const void *ptr_to_free_17; // [rsp+518h] [rbp+1A8h]
  const void *ptr_to_free_18; // [rsp+520h] [rbp+1B0h]
  __int64 v81; // [rsp+528h] [rbp+1B8h]
  __int64 v82; // [rsp+530h] [rbp+1C0h]
  __int64 v83; // [rsp+538h] [rbp+1C8h]
  __int64 v84; // [rsp+540h] [rbp+1D0h]
  __int64 v85; // [rsp+548h] [rbp+1D8h]
  _QWORD *v86; // [rsp+550h] [rbp+1E0h]
  _QWORD *v87; // [rsp+558h] [rbp+1E8h]
  _QWORD *v88; // [rsp+560h] [rbp+1F0h]
  _QWORD *v89; // [rsp+568h] [rbp+1F8h]
  __int64 *ThreadLogContextSlot_2; // [rsp+570h] [rbp+200h]
  const void *ptr_to_free_19; // [rsp+578h] [rbp+208h]
  const void *ptr_to_free_20; // [rsp+580h] [rbp+210h]
  const void *ptr_to_free_21; // [rsp+588h] [rbp+218h]
  const void *ptr_to_free_22; // [rsp+590h] [rbp+220h]
  void *v95; // [rsp+598h] [rbp+228h] BYREF
  __int64 v96; // [rsp+5A0h] [rbp+230h]
  __int64 v97; // [rsp+5A8h] [rbp+238h]
  _QWORD *v98; // [rsp+5B0h] [rbp+240h]
  _QWORD *v99; // [rsp+5B8h] [rbp+248h]
  _QWORD *v100; // [rsp+5C0h] [rbp+250h]
  __int64 *ThreadLogContextSlot_3; // [rsp+5C8h] [rbp+258h]
  const void *ptr_to_free_23; // [rsp+5D0h] [rbp+260h]
  const void *ptr_to_free_24; // [rsp+5D8h] [rbp+268h]
  const void *ptr_to_free_25; // [rsp+5E0h] [rbp+270h]
  __int64 v105; // [rsp+5E8h] [rbp+278h]
  __int64 v106; // [rsp+5F0h] [rbp+280h]
  __int64 (__fastcall *v107)(__int64, _QWORD); // [rsp+5F8h] [rbp+288h]
  __int64 v108; // [rsp+600h] [rbp+290h]
  __int64 v109; // [rsp+608h] [rbp+298h]
  _QWORD *a5; // [rsp+610h] [rbp+2A0h]
  _QWORD *v111; // [rsp+618h] [rbp+2A8h]
  _QWORD *v112; // [rsp+620h] [rbp+2B0h]
  __int64 *ThreadLogContextSlot; // [rsp+628h] [rbp+2B8h]
  const void *ptr_to_free_13; // [rsp+630h] [rbp+2C0h]
  _QWORD v115[2]; // [rsp+638h] [rbp+2C8h] BYREF
  const void *ptr_to_free; // [rsp+648h] [rbp+2D8h]
  _QWORD v117[2]; // [rsp+650h] [rbp+2E0h] BYREF
  const void *ptr_to_free_1; // [rsp+660h] [rbp+2F0h]
  _QWORD v119[2]; // [rsp+668h] [rbp+2F8h] BYREF
  const void *ptr_to_free_3; // [rsp+678h] [rbp+308h]
  _QWORD v121[2]; // [rsp+680h] [rbp+310h] BYREF
  const void *ptr_to_free_4; // [rsp+690h] [rbp+320h]
  _QWORD v123[2]; // [rsp+698h] [rbp+328h] BYREF
  const void *ptr_to_free_6; // [rsp+6A8h] [rbp+338h]
  _QWORD v125[2]; // [rsp+6B0h] [rbp+340h] BYREF
  const void *ptr_to_free_7; // [rsp+6C0h] [rbp+350h]
  _QWORD v127[2]; // [rsp+6C8h] [rbp+358h] BYREF
  const void *ptr_to_free_8; // [rsp+6D8h] [rbp+368h]
  _QWORD v129[2]; // [rsp+6E0h] [rbp+370h] BYREF
  const void *ptr_to_free_10; // [rsp+6F0h] [rbp+380h]
  _QWORD v131[2]; // [rsp+6F8h] [rbp+388h] BYREF
  const void *ptr_to_free_11; // [rsp+708h] [rbp+398h]
  _QWORD src__3[2]; // [rsp+710h] [rbp+3A0h] BYREF
  _QWORD src__5[2]; // [rsp+720h] [rbp+3B0h] BYREF
  _QWORD v135[2]; // [rsp+730h] [rbp+3C0h] BYREF
  _QWORD src__6[2]; // [rsp+740h] [rbp+3D0h] BYREF
  _QWORD src__7[2]; // [rsp+750h] [rbp+3E0h] BYREF
  _QWORD src_[2]; // [rsp+760h] [rbp+3F0h] BYREF
  _QWORD src__1[2]; // [rsp+770h] [rbp+400h] BYREF
  _QWORD a9[2]; // [rsp+780h] [rbp+410h] BYREF
  _QWORD src__2[2]; // [rsp+790h] [rbp+420h] BYREF
  _QWORD v142[2]; // [rsp+7A0h] [rbp+430h] BYREF
  _QWORD v143[2]; // [rsp+7B0h] [rbp+440h] BYREF
  _QWORD src__4[3]; // [rsp+7C0h] [rbp+450h] BYREF
  _BYTE dst__5[16]; // [rsp+7D8h] [rbp+468h] BYREF
  __int64 dst__6[2]; // [rsp+7E8h] [rbp+478h] BYREF
  _BYTE dst__8[16]; // [rsp+7F8h] [rbp+488h] BYREF
  __int64 dst__9[2]; // [rsp+808h] [rbp+498h] BYREF
  __int64 dst__4[7]; // [rsp+818h] [rbp+4A8h] BYREF
  _BYTE dst_[16]; // [rsp+850h] [rbp+4E0h] BYREF
  __int64 dst__1[2]; // [rsp+860h] [rbp+4F0h] BYREF
  _BYTE dst__3[16]; // [rsp+870h] [rbp+500h] BYREF
  _QWORD v153[2]; // [rsp+880h] [rbp+510h] BYREF
  const void *ptr_to_free_2; // [rsp+890h] [rbp+520h]
  _BYTE dst__2[32]; // [rsp+8A0h] [rbp+530h] BYREF
  __int64 v156; // [rsp+8C0h] [rbp+550h] BYREF
  const void *ptr_to_free_5; // [rsp+8D0h] [rbp+560h]
  __int64 v158; // [rsp+8D8h] [rbp+568h] BYREF
  const void *ptr_to_free_9; // [rsp+8E8h] [rbp+578h]
  _BYTE dst__7[32]; // [rsp+8F0h] [rbp+580h] BYREF
  __int64 v161; // [rsp+910h] [rbp+5A0h] BYREF
  const void *ptr_to_free_12; // [rsp+920h] [rbp+5B0h]
  _BYTE v163[544]; // [rsp+930h] [rbp+5C0h] BYREF

  v56 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
  v64 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v56 + 0xC0LL))(v56);
  v107 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v64 + 0x10LL);
  v35 = *(_DWORD *)(a3 + 0x20);
  result = v107(v64, v35);
  v26 = result;
  if ( result )
  {
    v34 = *(_DWORD *)(a3 + 0x30) * *(_DWORD *)(a3 + 0x38);
    v19 = 0;
    if ( sub_1402A2630(arg20, &qword_149B35AA8) )
    {
      for ( i = 0; ; ++i )
      {
        v59[2] = (void *)(rdx0 + 0x68);
        if ( i >= (*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL )
        {
          break;
        }
        v36 = (_QWORD *)(rdx0 + 0x68);
        if ( i >= (*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL )
        {
          __debugbreak();
        }
        v37 = *v36 + 0xD0 * i;
        if ( Current_set((unsigned __int8 **)(v37 + 0x28), arg20) )
        {
          v19 = 1;
          v21 = a4 && (v20 = *(_DWORD *)(rdx0 + 0x5C) != 5, sub_145A47090(a3, v37, v20));
          v23 = v21;
          if ( v21 )
          {
            v46[0] = sub_142656CA0(0x1Bu);
            v46[1] = 0x4D;
            src_[0] = v46;
            src_[1] = &v47;
            qmemcpy(dst_, src_, sizeof(dst_));
            v30 = invokeGlobalCallbackAndMaskStatusBits(
                    5,
                    (__int64)dst_,
                    (__int64)"InventoryManagement",
                    "Add Stack Entity Class[$$] Rank[$$] SourceInventory[$$]");
            if ( (v30 & 0xFFFFF) != 0 )
            {
              v6 = (AK::WriteBytesMem *)sub_1405AC850(rdx0 + 0x18, (__int64)v163);
              v7 = AK::WriteBytesMem::Bytes(v6);
              sub_140357E70(v153, v7, 1, 0);
              sub_1402A0F30((__int64)v163);
              a5 = v153;
              v108 = SEntityProxy::AsJson((__int64)arg20);
              v117[0] = 0;
              v117[1] = v108;
              ptr_to_free_1 = 0;
              v111 = v117;
              v109 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x18LL))(v26);
              v115[0] = 0;
              v115[1] = v109;
              ptr_to_free = 0;
              v112 = v115;
              ThreadLogContextSlot = getThreadLogContextSlot();
              a9[0] = 0;
              a9[1] = 0;
              v48[0] = sub_142656CA0(0x1Bu);
              v48[1] = 0x4D;
              src__1[0] = v48;
              src__1[1] = &v49;
              qmemcpy(dst__1, src__1, sizeof(dst__1));
              dst__4[5] = 4;
              v8 = alloca(0x1A0);
              v62 = v18;
              v63 = (__int64)v18;
              sub_143A49990((__int64)v18, (__int64)ThreadLogContextSlot, (__int64)v112, (__int64)v111, (__int64)a5);
              LODWORD(a8) = v30;
              sub_140302350(
                5,
                (__int64)dst__1,
                "InventoryManagement",
                (__int64)"Add Stack Entity Class[$$] Rank[$$] SourceInventory[$$]",
                v63,
                4,
                1,
                a8,
                a9,
                0);
              ptr_to_free_13 = ptr_to_free;
              free_memory_wrapper(ptr_to_free);
              ptr_to_free_14 = ptr_to_free_1;
              free_memory_wrapper(ptr_to_free_1);
              ptr_to_free_15 = ptr_to_free_2;
              free_memory_wrapper(ptr_to_free_2);
            }
            qmemcpy(dst__2, (const void *)(rdx0 + 0x18), 0x18u);
            sub_1460F57F0(a1, (__int64)dst__2, i, *(_DWORD *)(a3 + 0x30) + *(_DWORD *)(v37 + 0x30));
          }
          else
          {
            v44[0] = sub_142656CA0(0x1Bu);
            v44[1] = 0x4D;
            src__2[0] = v44;
            src__2[1] = &v45;
            qmemcpy(dst__3, src__2, sizeof(dst__3));
            v31 = invokeGlobalCallbackAndMaskStatusBits(
                    5,
                    (__int64)dst__3,
                    (__int64)"InventoryManagement",
                    "Create Stack Entity Class[$$] Rank[$$] SourceInventory[$$]");
            if ( (v31 & 0xFFFFF) != 0 )
            {
              v74 = sub_140358CF0(&v156, rdx0 + 0x18, 0);
              v72 = SEntityProxy::AsJson((__int64)arg20);
              v121[0] = 0;
              v121[1] = v72;
              ptr_to_free_4 = 0;
              v75 = v121;
              v73 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x18LL))(v26);
              v119[0] = 0;
              v119[1] = v73;
              ptr_to_free_3 = 0;
              v76 = v119;
              ThreadLogContextSlot_1 = getThreadLogContextSlot();
              v143[0] = 0;
              v143[1] = 0;
              v50[0] = sub_142656CA0(0x1Bu);
              v50[1] = 0x4D;
              src__3[0] = v50;
              src__3[1] = &v51;
              qmemcpy(dst__4, src__3, 0x10u);
              dst__4[6] = 4;
              v9 = alloca(0x1A0);
              v65 = v18;
              v66 = (__int64)v18;
              sub_143A49990((__int64)v18, (__int64)ThreadLogContextSlot_1, (__int64)v76, (__int64)v75, (__int64)v74);
              LODWORD(a8) = v31;
              sub_140302350(
                5,
                (__int64)dst__4,
                "InventoryManagement",
                (__int64)"Create Stack Entity Class[$$] Rank[$$] SourceInventory[$$]",
                v66,
                4,
                1,
                a8,
                v143,
                0);
              ptr_to_free_16 = ptr_to_free_3;
              free_memory_wrapper(ptr_to_free_3);
              ptr_to_free_17 = ptr_to_free_4;
              free_memory_wrapper(ptr_to_free_4);
              ptr_to_free_18 = ptr_to_free_5;
              free_memory_wrapper(ptr_to_free_5);
            }
            v82 = rdx0 + 0x68;
            v81 = *(_QWORD *)(rdx0 + 0x68);
            sub_14611F400(rdx0 + 0x68, 0xD0 * i + v81, a3);
            *(_DWORD *)(rdx0 + 0x64) += v34;
          }
          break;
        }
      }
    }
    else if ( a4 )
    {
      for ( j = 0; ; ++j )
      {
        v67 = rdx0 + 0x68;
        if ( j >= (*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL )
        {
          break;
        }
        v38 = (_QWORD *)(rdx0 + 0x68);
        if ( j >= (*(_QWORD *)(rdx0 + 0x70) - *(_QWORD *)(rdx0 + 0x68)) / 0xD0LL )
        {
          __debugbreak();
        }
        v39 = *v38 + 0xD0 * j;
        v22 = *(_DWORD *)(rdx0 + 0x5C) != 5;
        if ( sub_145A47090(a3, v39, v22) )
        {
          v52[0] = sub_142656CA0(0x1Bu);
          v52[1] = 0x4D;
          src__4[0] = v52;
          src__4[1] = &v53;
          qmemcpy(dst__5, src__4, sizeof(dst__5));
          v32 = invokeGlobalCallbackAndMaskStatusBits(
                  5,
                  (__int64)dst__5,
                  (__int64)"InventoryManagement",
                  "Add Stack Entity Class[$$] Rank[$$] Found[$$] SourceInventory[$$]");
          if ( (v32 & 0xFFFFF) != 0 )
          {
            v86 = sub_140358CF0(&v158, rdx0 + 0x18, 0);
            v83 = SEntityProxy::AsJson(v39 + 0x28);
            v127[0] = 0;
            v127[1] = v83;
            ptr_to_free_8 = 0;
            v87 = v127;
            v84 = SEntityProxy::AsJson((__int64)arg20);
            v125[0] = 0;
            v125[1] = v84;
            ptr_to_free_7 = 0;
            v88 = v125;
            v85 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x18LL))(v26);
            v123[0] = 0;
            v123[1] = v85;
            ptr_to_free_6 = 0;
            v89 = v123;
            ThreadLogContextSlot_2 = getThreadLogContextSlot();
            v135[0] = 0;
            v135[1] = 0;
            v54[0] = sub_142656CA0(0x1Bu);
            v54[1] = 0x4D;
            src__5[0] = v54;
            src__5[1] = &v55;
            qmemcpy(dst__6, src__5, sizeof(dst__6));
            src__4[2] = 5;
            v10 = alloca(0x210);
            v68 = v16;
            v57 = (__int64)v16;
            sub_145FF9210((__int64)v16, (__int64)ThreadLogContextSlot_2, (int)v89, (int)v88, (__int64)v87, (__int64)v86);
            LODWORD(v15) = v32;
            sub_140302350(
              5,
              (__int64)dst__6,
              "InventoryManagement",
              (__int64)"Add Stack Entity Class[$$] Rank[$$] Found[$$] SourceInventory[$$]",
              v57,
              5,
              1,
              v15,
              v135,
              0);
            ptr_to_free_19 = ptr_to_free_6;
            free_memory_wrapper(ptr_to_free_6);
            ptr_to_free_20 = ptr_to_free_7;
            free_memory_wrapper(ptr_to_free_7);
            ptr_to_free_21 = ptr_to_free_8;
            free_memory_wrapper(ptr_to_free_8);
            ptr_to_free_22 = ptr_to_free_9;
            free_memory_wrapper(ptr_to_free_9);
          }
          qmemcpy(dst__7, (const void *)(rdx0 + 0x18), 0x18u);
          sub_1460F57F0(a1, (__int64)dst__7, j, *(_DWORD *)(a3 + 0x30) + *(_DWORD *)(v39 + 0x30));
          v19 = 1;
          break;
        }
      }
    }
    if ( !v19 )
    {
      if ( Current_set(arg20, &qword_149B35AA8) )
      {
        initializeEmptyStringStructure(v59);
        sub_1403577C0(&a6, &qword_149B35AA8);
        v11 = sub_146076F70(a1, &v95, rdx0, v26, v59, &a6);
        sub_140374480((void **)(a3 + 0x28), v11);
        DestroyStringObject(&v95);
        DestroyStringObject(&a6);
        DestroyStringObject(v59);
      }
      v40[0] = sub_142656CA0(0x1Bu);
      v40[1] = 0x4D;
      src__6[0] = v40;
      src__6[1] = &v41;
      qmemcpy(dst__8, src__6, sizeof(dst__8));
      v33 = invokeGlobalCallbackAndMaskStatusBits(
              5,
              (__int64)dst__8,
              (__int64)"InventoryManagement",
              "End Page Entity Class[$$] Rank[$$] SourceInventory[$$]");
      if ( (v33 & 0xFFFFF) != 0 )
      {
        v98 = sub_140358CF0(&v161, rdx0 + 0x18, 0);
        v96 = SEntityProxy::AsJson((__int64)arg20);
        v131[0] = 0;
        v131[1] = v96;
        ptr_to_free_11 = 0;
        v99 = v131;
        v97 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x18LL))(v26);
        v129[0] = 0;
        v129[1] = v97;
        ptr_to_free_10 = 0;
        v100 = v129;
        ThreadLogContextSlot_3 = getThreadLogContextSlot();
        v142[0] = 0;
        v142[1] = 0;
        v42[0] = sub_142656CA0(0x1Bu);
        v42[1] = 0x4D;
        src__7[0] = v42;
        src__7[1] = &v43;
        qmemcpy(dst__9, src__7, sizeof(dst__9));
        dst__4[2] = 4;
        v12 = alloca(0x1A0);
        v59[1] = v14;
        v69 = (__int64)v14;
        sub_143A49990((__int64)v14, (__int64)ThreadLogContextSlot_3, (__int64)v100, (__int64)v99, (__int64)v98);
        LODWORD(v13) = v33;
        sub_140302350(
          5,
          (__int64)dst__9,
          "InventoryManagement",
          (__int64)"End Page Entity Class[$$] Rank[$$] SourceInventory[$$]",
          v69,
          4,
          1,
          v13,
          v142,
          0);
        ptr_to_free_23 = ptr_to_free_10;
        free_memory_wrapper(ptr_to_free_10);
        ptr_to_free_24 = ptr_to_free_11;
        free_memory_wrapper(ptr_to_free_11);
        ptr_to_free_25 = ptr_to_free_12;
        free_memory_wrapper(ptr_to_free_12);
      }
      v24 = v27;
      v25 = v27;
      v60 = dst__4[3];
      v60 = *(_QWORD *)(rdx0 + 0x70);
      v61 = dst__4[4];
      v61 = *(_QWORD *)(rdx0 + 0x68);
      v105 = sub_146006F50(v61, v60, a3);
      v106 = rdx0 + 0x68;
      sub_14611F400(rdx0 + 0x68, v105, a3);
      *(_DWORD *)(rdx0 + 0x64) += v34;
    }
    return sub_146116780(a1, rdx0);
  }
  return result;
}

// --- End Function: sub_146108820 (0x146108820) ---

// --- Function: sub_146109950 (0x146109950) ---
void __fastcall sub_146109950(__int64 a1, __int64 a2, unsigned __int64 a3, char a4, const void **a5)
{
  __int16 *v5; // rax
  __int64 *v6; // rax
  __int64 v7; // rdx
  __int16 v8; // [rsp+30h] [rbp-168h] BYREF
  __int64 v9; // [rsp+38h] [rbp-160h]
  __int64 v10; // [rsp+40h] [rbp-158h]
  __int64 v11; // [rsp+48h] [rbp-150h]
  void **v12; // [rsp+50h] [rbp-148h]
  void **v13; // [rsp+58h] [rbp-140h]
  unsigned __int64 v14; // [rsp+60h] [rbp-138h]
  __int64 (__fastcall *v15)(__int64, _BYTE *); // [rsp+68h] [rbp-130h]
  void *v16; // [rsp+70h] [rbp-128h] BYREF
  _BYTE v17[8]; // [rsp+78h] [rbp-120h] BYREF
  _BYTE v18[32]; // [rsp+80h] [rbp-118h] BYREF
  __int64 v19; // [rsp+A0h] [rbp-F8h] BYREF
  _BYTE dst_[24]; // [rsp+A8h] [rbp-F0h] BYREF
  _QWORD v21[3]; // [rsp+158h] [rbp-40h] BYREF
  unsigned __int64 v24; // [rsp+1B0h] [rbp+18h] BYREF
  char v25; // [rsp+1B8h] [rbp+20h]

  v25 = a4;
  v24 = a3;
  if ( is_valid_handle_typeB(&v24) )
  {
    v9 = Handle::ToIndex(&v24);
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 0x20LL))(v9);
    if ( v10 )
    {
      sub_143277150((__int64)&v19);
      unknown_libname_472(v21);
      v12 = &v16;
      v13 = sub_1403577C0(&v16, a5);
      v14 = v24;
      sub_146046100(a1, v24, 1, v13, (__int64)&v19);
      v5 = sub_142F433C0(&v8);
      if ( sub_140338B30(v10, *v5) )
      {
        v11 = Handle::ToIndex(&v24);
        v15 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v11 + 8LL);
        v6 = (__int64 *)v15(v11, v17);
        qmemcpy(dst_, (const void *)sub_1405AC2F0((__int64)v18, *v6), sizeof(dst_));
      }
      sub_146108820(a1, a2, (__int64)&v19, v25, (unsigned __int8 **)a5);
      sub_143278A40(v21, v7);
      sub_14327A370(&v19);
    }
  }
}

// --- End Function: sub_146109950 (0x146109950) ---

// --- Function: sub_14610E030 (0x14610E030) ---
__int64 __fastcall sub_14610E030(__int64 a1, __int64 a2)
{
  float v3; // [rsp+50h] [rbp-128h]
  __int64 v4; // [rsp+68h] [rbp-110h]
  __int64 v5; // [rsp+78h] [rbp-100h]
  _QWORD v6[3]; // [rsp+80h] [rbp-F8h] BYREF
  char *v7[3]; // [rsp+98h] [rbp-E0h] BYREF
  _QWORD dst_[4]; // [rsp+B0h] [rbp-C8h] BYREF
  _BYTE dst__1[32]; // [rsp+D0h] [rbp-A8h] BYREF
  _BYTE v10[16]; // [rsp+F0h] [rbp-88h] BYREF
  _BYTE v11[24]; // [rsp+100h] [rbp-78h] BYREF
  char *v12; // [rsp+118h] [rbp-60h] BYREF
  _BYTE v13[72]; // [rsp+130h] [rbp-48h] BYREF

  sub_142A18E60(v7);
  sub_142A18E60(v6);
  qmemcpy(dst_, (const void *)(a2 + 0x18), 0x18u);
  qmemcpy((void *)(a2 + 0xB0), (const void *)sub_146069080(a1, (__int64)v10, dst_, v7, (__int64)v6), 0x10u);
  if ( *(_DWORD *)(a2 + 0x60) )
  {
    v3 = (float)*(int *)(a2 + 0x64) / (float)*(int *)(a2 + 0x60);
  }
  else
  {
    v3 = 0.0;
  }
  v5 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
  qmemcpy(dst__1, (const void *)(a2 + 0x18), 0x18u);
  v4 = sub_143A82040(
         (__int64)v11,
         (__int64)dst__1,
         (__int64)v7,
         (__int64)v6,
         *(int *)(a2 + 0x64),
         v3,
         *(_BYTE *)(a2 + 0xB4),
         *(_BYTE *)(a2 + 0xB5),
         *(_DWORD *)(a2 + 0xB8),
         *(_DWORD *)(a2 + 0xBC));
  sub_1439C77F0(v5, *(_QWORD *)(a1 + 8), v4);
  sub_143A91640((__int64)v13);
  sub_143A916E0(&v12);
  *(_DWORD *)(a1 + 0x6FC) |= 4u;
  sub_143A91640((__int64)v6);
  return sub_143A916E0(v7);
}

// --- End Function: sub_14610E030 (0x14610E030) ---

// --- Function: sub_146116780 (0x146116780) ---
char __fastcall sub_146116780(__int64 a1, _QWORD *rdx0)
{
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  void *v4; // rsp
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  void *v7; // rsp
  __int64 v9; // [rsp+18h] [rbp-1B8h]
  _BYTE v10[48]; // [rsp+30h] [rbp-1A0h] BYREF
  __int64 a8; // [rsp+78h] [rbp-158h]
  _BYTE v12[240]; // [rsp+90h] [rbp-140h] BYREF
  bool v13; // [rsp+1D0h] [rbp+0h]
  __int64 v14; // [rsp+1D8h] [rbp+8h]
  int v16; // [rsp+1E4h] [rbp+14h]
  int v17; // [rsp+1E8h] [rbp+18h]
  BOOL v18; // [rsp+1ECh] [rbp+1Ch]
  unsigned __int64 i; // [rsp+1F0h] [rbp+20h]
  void *v20; // [rsp+1F8h] [rbp+28h] BYREF
  __int64 *v21; // [rsp+200h] [rbp+30h]
  _QWORD *v22; // [rsp+208h] [rbp+38h]
  _QWORD *v23; // [rsp+210h] [rbp+40h]
  __int64 v24; // [rsp+218h] [rbp+48h]
  _QWORD *v25; // [rsp+220h] [rbp+50h]
  _QWORD *v26; // [rsp+228h] [rbp+58h]
  __int64 v27; // [rsp+230h] [rbp+60h]
  __int64 v28; // [rsp+238h] [rbp+68h]
  _BYTE *v29; // [rsp+240h] [rbp+70h]
  __int64 a5; // [rsp+248h] [rbp+78h]
  __int64 v31; // [rsp+250h] [rbp+80h]
  __int64 v32; // [rsp+258h] [rbp+88h]
  unsigned __int64 v33; // [rsp+260h] [rbp+90h] BYREF
  __int64 v34; // [rsp+268h] [rbp+98h]
  const char *p_N_A; // [rsp+270h] [rbp+A0h]
  __int64 v36; // [rsp+278h] [rbp+A8h]
  _BYTE *v37; // [rsp+280h] [rbp+B0h]
  __int64 v38; // [rsp+288h] [rbp+B8h]
  __int64 v39; // [rsp+290h] [rbp+C0h]
  __int64 v40; // [rsp+298h] [rbp+C8h]
  __int64 v41; // [rsp+2A0h] [rbp+D0h]
  _QWORD *v42; // [rsp+2A8h] [rbp+D8h]
  _QWORD *v43; // [rsp+2B0h] [rbp+E0h]
  __int64 *ThreadLogContextSlot; // [rsp+2B8h] [rbp+E8h]
  const void *ptr_to_free_4; // [rsp+2C0h] [rbp+F0h]
  const void *ptr_to_free_5; // [rsp+2C8h] [rbp+F8h]
  _QWORD *v47; // [rsp+2D0h] [rbp+100h]
  __int64 v48; // [rsp+2D8h] [rbp+108h]
  void (__fastcall *v49)(__int64, unsigned __int64 *, __int64); // [rsp+2E0h] [rbp+110h]
  _QWORD *v50; // [rsp+2E8h] [rbp+118h]
  _QWORD *v51; // [rsp+2F0h] [rbp+120h]
  _QWORD *v52; // [rsp+2F8h] [rbp+128h]
  __int64 *ThreadLogContextSlot_1; // [rsp+300h] [rbp+130h]
  const void *ptr_to_free_6; // [rsp+308h] [rbp+138h]
  const void *ptr_to_free_7; // [rsp+310h] [rbp+140h]
  _QWORD v56[2]; // [rsp+318h] [rbp+148h] BYREF
  const void *ptr_to_free_3; // [rsp+328h] [rbp+158h]
  _QWORD v58[2]; // [rsp+330h] [rbp+160h] BYREF
  const void *ptr_to_free; // [rsp+340h] [rbp+170h]
  _QWORD v60[2]; // [rsp+348h] [rbp+178h] BYREF
  const void *ptr_to_free_1; // [rsp+358h] [rbp+188h]
  _QWORD v62[2]; // [rsp+360h] [rbp+190h] BYREF
  const void *ptr_to_free_2; // [rsp+370h] [rbp+1A0h]
  _QWORD src_[2]; // [rsp+378h] [rbp+1A8h] BYREF
  _QWORD src__1[2]; // [rsp+388h] [rbp+1B8h] BYREF
  _QWORD a9[2]; // [rsp+398h] [rbp+1C8h] BYREF
  _QWORD src__2[2]; // [rsp+3A8h] [rbp+1D8h] BYREF
  _QWORD v68[2]; // [rsp+3B8h] [rbp+1E8h] BYREF
  _QWORD src__3[2]; // [rsp+3C8h] [rbp+1F8h] BYREF
  _QWORD v70[3]; // [rsp+3D8h] [rbp+208h] BYREF
  _QWORD v71[2]; // [rsp+3F0h] [rbp+220h] BYREF
  _BYTE dst_[16]; // [rsp+400h] [rbp+230h] BYREF
  __int64 dst__1[2]; // [rsp+410h] [rbp+240h] BYREF
  _BYTE dst__2[16]; // [rsp+420h] [rbp+250h] BYREF
  __int64 dst__3[2]; // [rsp+430h] [rbp+260h] BYREF
  _DWORD v76[3]; // [rsp+440h] [rbp+270h] BYREF
  char v77; // [rsp+44Ch] [rbp+27Ch] BYREF
  _DWORD v78[3]; // [rsp+450h] [rbp+280h] BYREF
  char v79; // [rsp+45Ch] [rbp+28Ch] BYREF
  _DWORD v80[3]; // [rsp+460h] [rbp+290h] BYREF
  char v81; // [rsp+46Ch] [rbp+29Ch] BYREF
  _DWORD v82[3]; // [rsp+470h] [rbp+2A0h] BYREF
  char v83; // [rsp+47Ch] [rbp+2ACh] BYREF

  v25 = rdx0 + 0xD;
  if ( (unsigned __int64)((rdx0[0xE] - rdx0[0xD]) / 0xD0LL) <= 1 )
  {
    return 1;
  }
  v21 = rdx0 + 0xD;
  if ( !((rdx0[0xE] - rdx0[0xD]) / 0xD0LL) )
  {
    __debugbreak();
  }
  v39 = *v21;
  if ( sub_1403BB9F0((_QWORD *)(v39 + 0x28)) )
  {
    return 1;
  }
  v22 = rdx0 + 0xD;
  if ( !((rdx0[0xE] - rdx0[0xD]) / 0xD0LL) )
  {
    __debugbreak();
  }
  sub_1403577C0(&v20, (const void **)(*v22 + 0x28LL));
  v14 = 0;
  for ( i = 1; ; ++i )
  {
    v26 = rdx0 + 0xD;
    if ( i >= (rdx0[0xE] - rdx0[0xD]) / 0xD0LL )
    {
      break;
    }
    v23 = rdx0 + 0xD;
    if ( i >= (rdx0[0xE] - rdx0[0xD]) / 0xD0LL )
    {
      __debugbreak();
    }
    v24 = *v23 + 0xD0 * i;
    if ( (int)sub_1403DFBE0((unsigned __int8 **)(v24 + 0x28), &v20) <= 0 )
    {
      if ( !v14 )
      {
        v27 = *(_QWORD *)(_((__int64)&gEnv) + 0xC0);
        v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x728LL))(v27);
        v76[0] = sub_142656CA0(v2);
        v76[1] = 0x11;
        v76[2] = 0x4D;
        src_[0] = v76;
        src_[1] = &v77;
        qmemcpy(dst_, src_, sizeof(dst_));
        v16 = invokeGlobalCallbackAndMaskStatusBits(
                4,
                (__int64)dst_,
                (__int64)"Out-of-order ranks in inventory container",
                "Out-of-order ranks in inventory container: \"$$\" is not less than \"$$\".");
        if ( (v16 & 0xFFFFF) != 0 )
        {
          v40 = SEntityProxy::AsJson(v24 + 0x28);
          v60[0] = 0;
          v60[1] = v40;
          ptr_to_free_1 = 0;
          v42 = v60;
          v41 = SEntityProxy::AsJson((__int64)&v20);
          v58[0] = 0;
          v58[1] = v41;
          ptr_to_free = 0;
          v43 = v58;
          ThreadLogContextSlot = getThreadLogContextSlot();
          a9[0] = 0;
          a9[1] = 0;
          v28 = *(_QWORD *)(_((__int64)&gEnv) + 0xC0);
          v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 0x728LL))(v28);
          v78[0] = sub_142656CA0(v3);
          v78[1] = 0x11;
          v78[2] = 0x4D;
          src__1[0] = v78;
          src__1[1] = &v79;
          qmemcpy(dst__1, src__1, sizeof(dst__1));
          v70[2] = 3;
          v4 = alloca(0x140);
          v29 = v12;
          a5 = (__int64)v12;
          sub_140BE7830((__int64)v12, (__int64)ThreadLogContextSlot, v43, v42);
          LODWORD(a8) = v16;
          sub_140302350(
            4,
            (__int64)dst__1,
            "Out-of-order ranks in inventory container",
            (__int64)"Out-of-order ranks in inventory container: \"$$\" is not less than \"$$\".",
            a5,
            3,
            1,
            a8,
            a9,
            0);
          ptr_to_free_4 = ptr_to_free;
          free_memory_wrapper(ptr_to_free);
          ptr_to_free_5 = ptr_to_free_1;
          free_memory_wrapper(ptr_to_free_1);
        }
      }
      ++v14;
    }
    copyStringStructure(&v20, (const void **)(v24 + 0x28));
  }
  v31 = *(_QWORD *)(_((__int64)&gEnv) + 0xA0);
  v49 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)v31 + 0x120LL);
  v47 = rdx0 + 3;
  v48 = *std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<void * const,`anonymous namespace'::_Mutex_count_pair>>>>::_Unwrapped(
           rdx0 + 3,
           v71);
  v49(v31, &v33, v48);
  if ( v14 )
  {
    v32 = *(_QWORD *)(_((__int64)&gEnv) + 0xC0);
    v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 0x728LL))(v32);
    v82[0] = sub_142656CA0(v5);
    v82[1] = 0x11;
    v82[2] = 0x4D;
    src__2[0] = v82;
    src__2[1] = &v83;
    qmemcpy(dst__2, src__2, sizeof(dst__2));
    v17 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)dst__2,
            (__int64)"Out-of-order ranks in inventory container",
            "$$: $$ errors found in cached inventory grid order for container owned by '$$'!");
    if ( (v17 & 0xFFFFF) != 0 )
    {
      if ( is_valid_handle_typeB(&v33) )
      {
        v34 = Handle::ToIndex(&v33);
        p_N_A = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 0x70LL))(v34);
      }
      else
      {
        p_N_A = "N/A";
      }
      v56[0] = 0;
      v56[1] = p_N_A;
      ptr_to_free_3 = 0;
      v50 = v56;
      v68[0] = 0;
      v68[1] = v14;
      v51 = v68;
      v62[0] = 0;
      v62[1] = "CSCLocalPlayerPersonalThoughtComponent::ValidateInventoryContainer";
      ptr_to_free_2 = 0;
      v52 = v62;
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      v70[0] = 0;
      v70[1] = 0;
      v36 = *(_QWORD *)(_((__int64)&gEnv) + 0xC0);
      v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x728LL))(v36);
      v80[0] = sub_142656CA0(v6);
      v80[1] = 0x11;
      v80[2] = 0x4D;
      src__3[0] = v80;
      src__3[1] = &v81;
      qmemcpy(dst__3, src__3, sizeof(dst__3));
      v71[1] = 4;
      v7 = alloca(0x1A0);
      v37 = v10;
      v38 = (__int64)v10;
      sub_142EC6F70((__int64)v10, (__int64)ThreadLogContextSlot_1, v52, v51, v50);
      LODWORD(v9) = v17;
      sub_140302350(
        3,
        (__int64)dst__3,
        "Out-of-order ranks in inventory container",
        (__int64)"$$: $$ errors found in cached inventory grid order for container owned by '$$'!",
        v38,
        4,
        1,
        v9,
        v70,
        0);
      ptr_to_free_6 = ptr_to_free_2;
      free_memory_wrapper(ptr_to_free_2);
      ptr_to_free_7 = ptr_to_free_3;
      free_memory_wrapper(ptr_to_free_3);
    }
  }
  v18 = v14 == 0;
  v13 = v14 == 0;
  DestroyStringObject(&v20);
  return v13;
}

// --- End Function: sub_146116780 (0x146116780) ---

// --- Function: sub_14611EFB0 (0x14611EFB0) ---
__int64 __fastcall sub_14611EFB0(__int64 a1, __int64 a2)
{
  _QWORD *v3; // [rsp+28h] [rbp-50h]

  if ( (unsigned __int64)(a2 + 0xD0) < *(_QWORD *)(a1 + 8) )
  {
    sub_1460057D0(a2 + 0xD0, *(_QWORD *)(a1 + 8), a2);
  }
  *(_QWORD *)(a1 + 8) -= 0xD0LL;
  v3 = *(_QWORD **)(a1 + 8);
  sub_143278A40(v3 + 0x17, a2);
  sub_14327A370(v3);
  return a2;
}

// --- End Function: sub_14611EFB0 (0x14611EFB0) ---

// --- Function: sub_14611F400 (0x14611F400) ---
__int64 __fastcall sub_14611F400(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+20h] [rbp-28h]
  __int64 v5; // [rsp+38h] [rbp-10h]

  v5 = (a2 - *a1) / 0xD0;
  if ( a1[1] != a1[2] && a2 == a1[1] )
  {
    v4 = sub_1402A0F70(0xD0, a1[1]);
    sub_143A874A0(v4, a3);
    sub_146008970((_QWORD *)(v4 + 0xB8), (_QWORD *)(a3 + 0xB8));
    a1[1] += 0xD0LL;
  }
  else
  {
    sub_145FD4E60(a1, a2, a3);
  }
  return *a1 + 0xD0 * v5;
}

// --- End Function: sub_14611F400 (0x14611F400) ---

// --- Function: AssetDB::GetAssetMeta (0x14638AB20) ---
__int64 __fastcall AssetDB::GetAssetMeta(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x258) + 0x6AA8LL;
}

// --- End Function: AssetDB::GetAssetMeta (0x14638AB20) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(const void *pCZoneSystem)
{
  if ( pCZoneSystem )
  {
    if ( qword_14981D3D8 && ::pCZoneSystem && pCZoneSystem == (const void *)::pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)pCZoneSystem < pCZoneSystem_1
      || (unsigned __int64)pCZoneSystem >= pCZoneSystem_1 + 0x8000000000LL )
    {
      if ( (unsigned __int64)pCZoneSystem >= pCZoneSystem_0
        && (unsigned __int64)pCZoneSystem < pCZoneSystem_0 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", pCZoneSystem);
      }
      sub_147397F30((__int64)pCZoneSystem);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: allocWithProfilerInfo (0x14739AFC0) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char tls_byte_at_offset_3401; // al
  __int64 profileSize; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    tls_byte_at_offset_3401 = get_tls_byte_at_offset_3401();
    sub_140566BA0(tls_byte_at_offset_3401);
    profileSize = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1473986B0(profileSize + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x14739AFC0) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

// --- Function: __report_gsfailure (0x147DC7A8C) ---
// Reports a stack buffer overrun detected by __security_check_cookie. Captures the
// execution context, sets up exception information, and calls
// __raise_securityfailure to terminate the process. May use __fastfail if
// available.
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_copy; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_copy = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
  {
    __fastfail(2u);
  }
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_copy;
  qword_1513F1640 = retaddr;
  ContextRecord.Rcx = StackCookie_copy;
  dword_1513F1630 = -1073740791;
  dword_1513F1634 = 1;
  dword_1513F1648 = 1;
  n2_3 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x147DC7A8C) ---

// --- Function: memcpy (0x147E162BB) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x147E162BB) ---

