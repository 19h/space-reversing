// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x144D5B060 (sub_144D5B060)
// Caller Depth: 1
// Callee/Ref Depth: 5
// Total Functions Found: 212
// ------------------------------------------------------------

// --- Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---
__int64 __fastcall AK::MemoryMgr::StopProfileThreadUsage(struct _exception *a1)
{
  return 0;
}

// --- End Function: ?StopProfileThreadUsage@MemoryMgr@AK@@YA_KXZ (0x1402A3180) ---

// --- Function: sub_1402A3190 (0x1402A3190) ---
__int64 sub_1402A3190(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n511; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n511 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n511;
  while ( Buffer[n511] );
  sub_1402A3BE0(a1, Buffer, n511);
  return a1;
}

// --- End Function: sub_1402A3190 (0x1402A3190) ---

// --- Function: sub_1402A3B50 (0x1402A3B50) ---
_BYTE *__fastcall sub_1402A3B50(__int64 *a1, __int64 n511_1)
{
  _BYTE *result; // rax
  unsigned __int64 allocSize; // rsi
  __int64 n511; // rcx

  result = a1 + 3;
  if ( n511_1 )
  {
    allocSize = n511_1 + 1;
    if ( (unsigned __int64)(n511_1 + 1) <= 0x200 )
    {
      n511 = 511;
    }
    else
    {
      result = (_BYTE *)allocWithProfilerInfo(allocSize, 0);
      qword_149B3AB68 += allocSize;
      n511 = n511_1;
    }
    a1[1] = n511;
    *a1 = n511_1;
    a1[2] = (__int64)result;
    result[n511_1] = 0;
  }
  else
  {
    a1[2] = (__int64)result;
    *a1 = 0;
    a1[1] = 511;
    *result = 0;
  }
  return result;
}

// --- End Function: sub_1402A3B50 (0x1402A3B50) ---

// --- Function: sub_1402A3BE0 (0x1402A3BE0) ---
__int64 __fastcall sub_1402A3BE0(__int64 a1, const void *a2, size_t n511)
{
  size_t n511_1; // r8
  const void *v7; // rcx
  _BYTE *v8; // r14
  __int64 result; // rax

  n511_1 = *(_QWORD *)(a1 + 8);
  if ( n511 > n511_1 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n511_1;
      sub_147605980(v7);
    }
    *v8 = 0;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0x1FF;
    sub_1402A3B50((__int64 *)a1, n511);
  }
  memmove(*(void **)(a1 + 0x10), a2, n511);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n511;
  *(_BYTE *)(n511 + result) = 0;
  return result;
}

// --- End Function: sub_1402A3BE0 (0x1402A3BE0) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
__int64 __fastcall sub_1402A3D30(const void *a1)
{
  return sub_147605980(a1);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
__int64 __fastcall sub_1402A3D40(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall sub_1402A6760(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: sub_1402A6B30 (0x1402A6B30) ---
char *__fastcall sub_1402A6B30(__int64 a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v4; // rbp
  unsigned __int64 _Count; // rdi
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  std::array<int,2> *v12; // rsi
  std::array<int,2> *v13; // rcx
  _BYTE *v14; // r8
  _BYTE *v15; // rdx
  char *v16; // rbp
  size_t Size; // r8
  _QWORD *v18; // rcx
  char *result; // rax

  v4 = (__int64)&a2[-*(_QWORD *)a1] >> 3;
  _Count = 0x1FFFFFFFFFFFFFFFLL;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v9 = (__int64)(*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) >> 3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    _Count = v11 + v9;
    if ( v11 + v9 < v10 )
      _Count = v6 + 1;
  }
  v12 = std::allocator<std::array<int,2>>::allocate((std::allocator<std::array<int,2> > *)a1, _Count);
  *((_QWORD *)v12 + v4) = *a3;
  v13 = v12;
  v14 = *(_BYTE **)(a1 + 8);
  v15 = *(_BYTE **)a1;
  v16 = (char *)v12 + 8 * v4;
  if ( a2 == v14 )
  {
    Size = v14 - v15;
  }
  else
  {
    memmove(v12, v15, a2 - v15);
    v13 = (std::array<int,2> *)(v16 + 8);
    Size = *(_QWORD *)(a1 + 8) - (_QWORD)a2;
    v15 = a2;
  }
  memmove(v13, v15, Size);
  v18 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v18) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v18 - v18[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v18 = (_QWORD *)v18[0xFFFFFFFF];
    }
    sub_1402A3D30(v18);
  }
  *(_QWORD *)a1 = v12;
  result = v16;
  *(_QWORD *)(a1 + 8) = (char *)v12 + 8 * v10;
  *(_QWORD *)(a1 + 0x10) = (char *)v12 + 8 * _Count;
  return result;
}

// --- End Function: sub_1402A6B30 (0x1402A6B30) ---

// --- Function: sub_1402A7E90 (0x1402A7E90) ---
void __fastcall sub_1402A7E90(
        std::_Tree_val<std::_Tree_simple_types<std::pair<double const ,int> > > *a1,
        std::allocator<std::_Tree_node<std::pair<double const ,int>,void *> > *_Al)
{
  _QWORD *v4; // rbx
  const void *v5; // rcx

  v4 = *(_QWORD **)(*(_QWORD *)a1 + 8LL);
  while ( !*((_BYTE *)v4 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
      a1,
      _Al,
      (std::_Tree_node<std::pair<double const ,int>,void *> *)v4[2]);
    v5 = v4;
    v4 = (_QWORD *)*v4;
    sub_1402A3D30(v5);
  }
  sub_1402A3D30(*(const void **)a1);
}

// --- End Function: sub_1402A7E90 (0x1402A7E90) ---

// --- Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBNH@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@1@@Z (0x1402A8190) ---
void __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
        std::_Tree_val<std::_Tree_simple_types<std::pair<double const ,int> > > *this,
        std::allocator<std::_Tree_node<std::pair<double const ,int>,void *> > *_Al,
        std::_Tree_node<std::pair<double const ,int>,void *> *_Rootnode)
{
  std::_Tree_node<std::pair<double const ,int>,void *> *_Rootnode_1; // rbx
  std::_Tree_node<std::pair<double const ,int>,void *> *_Rootnode_2; // rcx

  _Rootnode_1 = _Rootnode;
  while ( !*((_BYTE *)_Rootnode_1 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
      this,
      _Al,
      *((std::_Tree_node<std::pair<double const ,int>,void *> **)_Rootnode_1 + 2));
    _Rootnode_2 = _Rootnode_1;
    _Rootnode_1 = *(std::_Tree_node<std::pair<double const ,int>,void *> **)_Rootnode_1;
    sub_1402A3D30(_Rootnode_2);
  }
}

// --- End Function: ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBNH@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBNH@std@@PEAX@1@@Z (0x1402A8190) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v15 - 1) = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - *(v17 - 1) - 8 <= 0x1F )
    {
      v17 = (_QWORD *)*(v17 - 1);
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: sub_1402C4680 (0x1402C4680) ---
__int64 __fastcall sub_1402C4680(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x10) = a1 + 0x18;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0x24;
  sub_1402C61F0(
    a1,
    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    *(unsigned __int8 *)(a2 + 7),
    *(unsigned __int8 *)(a2 + 6),
    *(unsigned __int8 *)(a2 + 5),
    *(unsigned __int8 *)(a2 + 4),
    HIBYTE(*(_DWORD *)a2),
    (unsigned __int8)BYTE2(*(_DWORD *)a2),
    BYTE1(*(_DWORD *)a2),
    (unsigned __int8)*(_DWORD *)a2,
    *(unsigned __int8 *)(a2 + 0xF),
    *(unsigned __int8 *)(a2 + 0xE),
    *(unsigned __int8 *)(a2 + 0xD),
    *(unsigned __int8 *)(a2 + 0xC),
    HIBYTE(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)BYTE2(*(_DWORD *)(a2 + 8)),
    BYTE1(*(_DWORD *)(a2 + 8)),
    (unsigned __int8)*(_DWORD *)(a2 + 8));
  return a1;
}

// --- End Function: sub_1402C4680 (0x1402C4680) ---

// --- Function: sub_1402C61F0 (0x1402C61F0) ---
__int64 sub_1402C61F0(__int64 a1, const char *Format_1, ...)
{
  unsigned __int64 *v4; // rax
  size_t n36; // r8
  char Buffer[4096]; // [rsp+40h] [rbp-1028h] BYREF
  va_list va; // [rsp+1080h] [rbp+18h] BYREF

  va_start(va, Format_1);
  v4 = (unsigned __int64 *)sub_1402A4380();
  _stdio_common_vsnprintf_s(*v4, Buffer, 0x1000u, 0xFFFu, Format_1, 0, va);
  Buffer[0xFFF] = 0;
  n36 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++n36;
  while ( Buffer[n36] );
  sub_1402DE5F0(a1, Buffer, n36);
  return a1;
}

// --- End Function: sub_1402C61F0 (0x1402C61F0) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402DE5F0 (0x1402DE5F0) ---
__int64 __fastcall sub_1402DE5F0(__int64 a1, const void *a2, size_t n36_1)
{
  size_t n36; // r8
  const void *v7; // rcx
  _BYTE *v8; // rsi
  size_t n0x24; // rax
  __int64 v10; // rax
  __int64 result; // rax

  n36 = *(_QWORD *)(a1 + 8);
  if ( n36_1 > n36 )
  {
    v7 = *(const void **)(a1 + 0x10);
    v8 = (_BYTE *)(a1 + 0x18);
    if ( v7 != (const void *)(a1 + 0x18) )
    {
      qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - n36;
      sub_147605980(v7);
    }
    *v8 = 0;
    n0x24 = 0x24;
    *(_QWORD *)(a1 + 8) = 0x24;
    *(_QWORD *)(a1 + 0x10) = v8;
    *(_QWORD *)a1 = 0;
    if ( n36_1 )
    {
      if ( n36_1 + 1 > 0x25 )
      {
        v10 = allocWithProfilerInfo(n36_1 + 1, 0);
        qword_149B3AD38 += n36_1 + 1;
        v8 = (_BYTE *)v10;
        n0x24 = n36_1;
      }
      *(_QWORD *)(a1 + 8) = n0x24;
      *(_QWORD *)a1 = n36_1;
      *(_QWORD *)(a1 + 0x10) = v8;
      v8[n36_1] = 0;
    }
  }
  memmove(*(void **)(a1 + 0x10), a2, n36_1);
  result = *(_QWORD *)(a1 + 0x10);
  *(_QWORD *)a1 = n36_1;
  *(_BYTE *)(n36_1 + result) = 0;
  return result;
}

// --- End Function: sub_1402DE5F0 (0x1402DE5F0) ---

// --- Function: sub_1402DECA0 (0x1402DECA0) ---
void __fastcall sub_1402DECA0(unsigned __int64 *a1, const void *a2, size_t Size)
{
  unsigned __int64 *v5; // rsi
  size_t Size_1; // r14
  unsigned __int64 v8; // rbp
  unsigned __int64 n8; // rdx
  unsigned __int64 v10; // rax

  if ( Size )
  {
    v5 = (unsigned __int64 *)a1[2];
    Size_1 = *a1;
    v8 = *a1 + Size;
    if ( v8 <= a1[1] )
    {
      memcpy((char *)v5 + Size_1, a2, Size);
      *a1 += Size;
      *(_BYTE *)(*a1 + a1[2]) = 0;
    }
    else
    {
      n8 = 2 * Size_1;
      if ( 2 * Size_1 <= v8 )
        n8 = *a1 + Size;
      if ( n8 )
      {
        if ( n8 < 8 )
          n8 = 8;
        sub_1402A3B50((__int64 *)a1, n8);
        memcpy((void *)a1[2], v5, Size_1);
        memcpy((void *)(Size_1 + a1[2]), a2, Size);
        v10 = a1[2];
        *a1 = v8;
        *(_BYTE *)(Size_1 + Size + v10) = 0;
      }
      if ( v5 != a1 + 3 )
      {
        qword_149B3AB68 += -1LL - a1[1];
        sub_147605980(v5);
      }
    }
  }
}

// --- End Function: sub_1402DECA0 (0x1402DECA0) ---

// --- Function: sub_1402E07B0 (0x1402E07B0) ---
__int64 __fastcall sub_1402E07B0(__int64 this)
{
  return this + 8;
}

// --- End Function: sub_1402E07B0 (0x1402E07B0) ---

// --- Function: sub_1402E1170 (0x1402E1170) ---
void __noreturn sub_1402E1170()
{
  stdext::exception *v0; // rax
  _QWORD v1[3]; // [rsp+20h] [rbp-18h] BYREF

  v0 = (stdext::exception *)sub_1402B1680(v1);
  stdext::exception::_Raise(v0);
}

// --- End Function: sub_1402E1170 (0x1402E1170) ---

// --- Function: unknown_libname_9 (0x1402E1F70) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_9()
{
  std::_Xlength_error("string too long");
}

// --- End Function: unknown_libname_9 (0x1402E1F70) ---

// --- Function: unknown_libname_10 (0x1402E1F90) ---
// Microsoft VisualC v14 64bit runtime
void __noreturn unknown_libname_10()
{
  std::_Xlength_error("vector too long");
}

// --- End Function: unknown_libname_10 (0x1402E1F90) ---

// --- Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---
std::array<int,2> *__fastcall std::allocator<std::array<int,2>>::allocate(
        std::allocator<std::array<int,2> > *this,
        unsigned __int64 _Count)
{
  unsigned __int64 allocSize; // rcx
  __int64 v3; // rax
  __int64 v4; // rcx
  std::array<int,2> *result; // rax

  if ( _Count > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  allocSize = 8 * _Count;
  if ( 8 * _Count < 0x1000 )
  {
    if ( allocSize )
      return (std::array<int,2> *)allocWithProfilerInfo_w(allocSize);
    else
      return 0;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_10:
    sub_1402E1170();
  v3 = allocWithProfilerInfo_w(allocSize + 0x27);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (std::array<int,2> *)((v3 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  *((_QWORD *)result + 0xFFFFFFFF) = v4;
  return result;
}

// --- End Function: ?allocate@?$allocator@V?$array@H$01@std@@@std@@QEAAPEAV?$array@H$01@2@_K@Z (0x1402E2170) ---

// --- Function: NtCurrentTeb_ww (0x1402E2460) ---
bool NtCurrentTeb_ww()
{
  return *(_QWORD *)NtCurrentTeb_w() != 0;
}

// --- End Function: NtCurrentTeb_ww (0x1402E2460) ---

// --- Function: NtCurrentTeb_ww_0 (0x1402E2480) ---
__int64 NtCurrentTeb_ww_0()
{
  return *(unsigned __int8 *)(NtCurrentTeb_w() + 0x12D);
}

// --- End Function: NtCurrentTeb_ww_0 (0x1402E2480) ---

// --- Function: ?clear@?$_Tree@V?$_Tmap_traits@NHU?$less@N@std@@V?$allocator@U?$pair@$$CBNH@std@@@2@$0A@@std@@@std@@QEAAXXZ (0x1402E2960) ---
void __fastcall std::_Tree<std::_Tmap_traits<double,int,std::less<double>,std::allocator<std::pair<double const,int>>,0>>::clear(
        std::_Tree<std::_Tmap_traits<double,int,std::less<double>,std::allocator<std::pair<double const ,int> >,0> > *this)
{
  _QWORD *v1; // rdi
  _QWORD *v3; // rbx
  const void *v4; // rcx

  v1 = *(_QWORD **)this;
  v3 = *(_QWORD **)(*(_QWORD *)this + 8LL);
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    std::_Tree_val<std::_Tree_simple_types<std::pair<double const,int>>>::_Erase_tree<std::allocator<std::_Tree_node<std::pair<double const,int>,void *>>>(
      this,
      this,
      (std::_Tree_node<std::pair<double const ,int>,void *> *)v3[2]);
    v4 = v3;
    v3 = (_QWORD *)*v3;
    sub_1402A3D30(v4);
  }
  v1[1] = v1;
  *v1 = v1;
  v1[2] = v1;
  *((_QWORD *)this + 1) = 0;
}

// --- End Function: ?clear@?$_Tree@V?$_Tmap_traits@NHU?$less@N@std@@V?$allocator@U?$pair@$$CBNH@std@@@2@$0A@@std@@@std@@QEAAXXZ (0x1402E2960) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n22; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n22 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 15;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  n22 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n22 = 22;
  if ( n22 + 1 >= 0x1000 )
  {
    allocSize = n22 + 40;
    if ( n22 + 40 < n22 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n22 == -1 )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n22 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n22;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FD310 (0x1402FD310) ---
__int64 __fastcall sub_1402FD310(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  if ( a4 < a5 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, unsigned __int64))(a3 + 112 * a4 + 24))(
             *(_QWORD *)(a3 + 112 * a4),
             a1,
             a2,
             a4 - a5 + 1);
  else
    return 0;
}

// --- End Function: sub_1402FD310 (0x1402FD310) ---

// --- Function: sub_1402FD350 (0x1402FD350) ---
__int64 __fastcall sub_1402FD350(_BYTE *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  _BYTE v6[24]; // [rsp+40h] [rbp-18h] BYREF

  return sub_1402FF680((__int64)v6, a1, a2, a3, a4, a5);
}

// --- End Function: sub_1402FD350 (0x1402FD350) ---

// --- Function: sub_1402FD7E0 (0x1402FD7E0) ---
__int64 **__fastcall sub_1402FD7E0(__int64 **a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v6; // rcx
  __int64 *v7; // rbx
  __int64 n40; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 *v12; // rbp
  __int64 *v13; // rdx
  __int64 *v14; // r8
  __int64 *v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // r9
  __int64 v20; // r9
  unsigned __int64 v21; // r10
  __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  __int64 *v24; // rdx
  __int64 *v25; // r9
  __int64 v26; // rsi
  __int64 v27; // rdi
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r10
  __int64 v30; // rax
  bool v31; // zf
  __int64 *v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rsi
  unsigned __int64 v35; // rdi
  unsigned __int64 v36; // r11
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 **result; // rax

  v6 = a2;
  v7 = &a2[(__int64)(a3 - (_QWORD)a2) >> 4];
  n40 = (__int64)(a3 - 8 - (_QWORD)a2) >> 3;
  if ( n40 <= 40 )
  {
    v14 = (__int64 *)(a3 - 8);
  }
  else
  {
    v9 = (n40 + 1) >> 3;
    v10 = 16 * v9;
    v11 = 8 * v9;
    v12 = &a2[v9];
    sub_1402FD760(a2, v12, &a2[2 * v9]);
    sub_1402FD760(&v7[v11 / 0xFFFFFFFFFFFFFFF8uLL], v7, &v7[(unsigned __int64)v11 / 8]);
    sub_1402FD760((__int64 *)(a3 - 8 - v10), (__int64 *)(a3 - 8 - v11), (__int64 *)(a3 - 8));
    v14 = v13;
    v6 = v12;
  }
  sub_1402FD760(v6, v7, v14);
  v15 = v7 + 1;
  if ( a2 < v7 )
  {
    v16 = *v7;
    do
    {
      v17 = *(v7 - 1);
      v18 = *(_QWORD *)(v16 + 8);
      v19 = *(_QWORD *)(v17 + 8);
      if ( v19 < v18 || v19 == v18 && *(_QWORD *)(v17 + 80) < *(_QWORD *)(v16 + 80) )
        break;
      if ( v18 < v19 || v18 == v19 && *(_QWORD *)(v16 + 80) < *(_QWORD *)(v17 + 80) )
        break;
      --v7;
      v16 = v17;
    }
    while ( a2 < v7 );
  }
  if ( (unsigned __int64)v15 < a3 )
  {
    v20 = *v7;
    v21 = *(_QWORD *)(*v7 + 8);
    do
    {
      v22 = *v15;
      v23 = *(_QWORD *)(*v15 + 8);
      if ( v23 < v21 || v23 == v21 && *(_QWORD *)(v22 + 80) < *(_QWORD *)(v20 + 80) )
        break;
      if ( v21 < v23 || v21 == v23 && *(_QWORD *)(v20 + 80) < *(_QWORD *)(v22 + 80) )
        break;
      ++v15;
    }
    while ( (unsigned __int64)v15 < a3 );
  }
  v24 = v15;
  v25 = v7;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( (unsigned __int64)v24 < a3 )
      {
        v26 = *v24;
        v27 = *v7;
        v28 = *(_QWORD *)(*v24 + 8);
        v29 = *(_QWORD *)(*v7 + 8);
        if ( v29 >= v28 && (v29 != v28 || *(_QWORD *)(v27 + 80) >= *(_QWORD *)(v26 + 80)) )
        {
          if ( v28 < v29 || v28 == v29 && *(_QWORD *)(v26 + 80) < *(_QWORD *)(v27 + 80) )
            break;
          if ( v15 != v24 )
          {
            v30 = *v15;
            *v15 = v26;
            *v24 = v30;
          }
          ++v15;
        }
        ++v24;
      }
      v31 = v25 == a2;
      if ( v25 <= a2 )
        goto LABEL_46;
      v32 = v25 - 1;
      while ( 1 )
      {
        v33 = *v7;
        v34 = *v32;
        v35 = *(_QWORD *)(*v7 + 8);
        v36 = *(_QWORD *)(*v32 + 8);
        if ( v36 >= v35 && (v36 != v35 || *(_QWORD *)(v34 + 80) >= *(_QWORD *)(v33 + 80)) )
          break;
LABEL_44:
        --v25;
        --v32;
        if ( a2 >= v25 )
          goto LABEL_45;
      }
      if ( v35 >= v36 && (v35 != v36 || *(_QWORD *)(v33 + 80) >= *(_QWORD *)(v34 + 80)) )
      {
        if ( --v7 != v32 )
        {
          v37 = *v7;
          *v7 = v34;
          *v32 = v37;
        }
        goto LABEL_44;
      }
LABEL_45:
      v31 = v25 == a2;
LABEL_46:
      if ( !v31 )
      {
        --v25;
        if ( v24 == (__int64 *)a3 )
        {
          if ( v25 != --v7 )
          {
            v40 = *v25;
            *v25 = *v7;
            *v7 = v40;
          }
          v41 = *--v15;
          v42 = *v7;
          *v7 = v41;
          *v15 = v42;
        }
        else
        {
          v43 = *v24;
          *v24++ = *v25;
          *v25 = v43;
        }
        continue;
      }
      break;
    }
    if ( v24 != (__int64 *)a3 )
    {
      if ( v15 != v24 )
      {
        v38 = *v7;
        *v7 = *v15;
        *v15 = v38;
      }
      ++v15;
      v39 = *v7;
      *v7++ = *v24;
      *v24++ = v39;
      continue;
    }
    break;
  }
  result = a1;
  *a1 = v7;
  a1[1] = v15;
  return result;
}

// --- End Function: sub_1402FD7E0 (0x1402FD7E0) ---

// --- Function: sub_1402FDAA0 (0x1402FDAA0) ---
unsigned __int64 __fastcall sub_1402FDAA0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 *a4)
{
  __int64 v5; // rdi
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r11
  __int64 v11; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 n2; // rax
  unsigned __int64 v15; // r11
  __int64 v16; // rcx
  __int64 v17; // r8
  unsigned __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v8 = a2;
  v9 = a2;
  if ( a2 < v5 )
  {
    do
    {
      v10 = 2 * v9;
      v11 = *(_QWORD *)(a1 + 16 * v9 + 16);
      v12 = *(_QWORD *)(a1 + 16 * v9 + 8);
      v13 = *(_QWORD *)(v11 + 8);
      if ( v13 < *(_QWORD *)(v12 + 8) || v13 == *(_QWORD *)(v12 + 8) && *(_QWORD *)(v11 + 80) < *(_QWORD *)(v12 + 80) )
        n2 = 1;
      else
        n2 = 2;
      v9 = v10 + n2;
      *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * (v10 + n2));
      a2 = v10 + n2;
    }
    while ( v10 + n2 < v5 );
  }
  if ( v9 == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(a1 + 8 * a3 - 8);
    a2 = a3 - 1;
  }
  if ( v8 >= a2 )
  {
    result = *a4;
    *(_QWORD *)(a1 + 8 * a2) = *a4;
  }
  else
  {
    while ( 1 )
    {
      v15 = *a4;
      v16 = (a2 - 1) >> 1;
      v17 = *(_QWORD *)(a1 + 8 * v16);
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(*a4 + 8) )
      {
        if ( result != *(_QWORD *)(*a4 + 8) )
          break;
        result = *(_QWORD *)(v15 + 80);
        if ( *(_QWORD *)(v17 + 80) >= result )
          break;
      }
      *(_QWORD *)(a1 + 8 * a2) = v17;
      a2 = (a2 - 1) >> 1;
      if ( v8 >= v16 )
      {
        result = *a4;
        *(_QWORD *)(a1 + 8 * v16) = *a4;
        return result;
      }
    }
    *(_QWORD *)(a1 + 8 * a2) = v15;
  }
  return result;
}

// --- End Function: sub_1402FDAA0 (0x1402FDAA0) ---

// --- Function: sub_1402FDB90 (0x1402FDB90) ---
unsigned __int64 __fastcall sub_1402FDB90(__int64 *a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v4; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rsi
  __int64 i; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rbp
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  _QWORD *v16; // rdi
  _QWORD *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 j; // rbx

  v2 = (_QWORD *)a1[1];
  v4 = *a1;
  result = (unsigned __int64)((unsigned __int128)(((__int64)v2 - *a1) * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v7 = ((__int64)v2 - *a1) / 112;
  if ( a2 < v7 )
  {
    v8 = v4 + 112 * a2;
    for ( i = v8; (_QWORD *)i != v2; i += 112 )
    {
      if ( *(_BYTE *)(i + 88) )
      {
        if ( *(_QWORD *)i )
          result = (*(__int64 (**)(void))(i + 64))();
      }
    }
    a1[1] = v8;
    return result;
  }
  if ( a2 <= v7 )
    return result;
  v10 = a1[2] - v4;
  result = (unsigned __int64)((unsigned __int128)(v10 * (__int128)0x4924924924924925LL) >> 64) >> 63;
  v11 = v10 / 112;
  if ( a2 > v10 / 112 )
  {
    if ( a2 > 0x249249249249249LL )
      unknown_libname_10();
    v12 = v11 >> 1;
    if ( v11 <= 0x249249249249249LL - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 >= a2 )
      {
        if ( v13 > 0x249249249249249LL )
          goto LABEL_29;
      }
      else
      {
        v13 = a2;
      }
      allocSize = 112 * v13;
      if ( 112 * v13 < 0x1000 )
      {
        if ( allocSize )
          v16 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
        else
          v16 = 0;
LABEL_23:
        v17 = &v16[14 * v7];
        v18 = a2 - v7;
        if ( a2 != v7 )
        {
          do
          {
            *v17 = 0;
            v17 += 14;
            --v18;
          }
          while ( v18 );
        }
        sub_1402FE290(*a1, a1[1], v16);
        return sub_1402FFAF0(a1, (__int64)v16, a2, v13);
      }
      if ( allocSize + 39 >= allocSize )
      {
        v15 = allocWithProfilerInfo_w(allocSize + 39);
        if ( !v15 )
          invalid_parameter_noinfo_noreturn();
        v16 = (_QWORD *)((v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v16 - 1) = v15;
        goto LABEL_23;
      }
    }
LABEL_29:
    sub_1402E1170();
  }
  for ( j = a2 - v7; j; --j )
  {
    *v2 = 0;
    v2 += 14;
  }
  a1[1] = (__int64)v2;
  return result;
}

// --- End Function: sub_1402FDB90 (0x1402FDB90) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n256; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n256 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n256 <= 256 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 80) < *(_QWORD *)(*(_QWORD *)v8 + 80LL) )
          {
            n256 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i - 1);
              i -= 8;
              n256 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n256 )
              {
                if ( *(_QWORD *)(v14 + 8) != n256 )
                  break;
                n256 = *(_QWORD *)(v17 + 80);
                if ( *(_QWORD *)(v14 + 80) >= (unsigned __int64)n256 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n256 <= 256 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 80) < *(_QWORD *)(v25 + 80) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 80) >= *(_QWORD *)(v21 + 80)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n256 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n256 >= 16 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30-- - v8) >> 3, &v33);
        n256 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n256 >= 16 );
    }
  }
  return n256;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: sub_1402FE6B0 (0x1402FE6B0) ---
__int64 __fastcall sub_1402FE6B0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rcx
  __int64 v6; // r11
  int v7; // ebx
  __int64 v8; // r8
  unsigned __int64 v9; // rax
  char *v10; // r9
  __int64 v11; // rax
  char v12; // dl
  char v13; // r8

  v4 = 0;
  v5 = a3 + a1;
  v6 = 0;
  v7 = a2 - a3;
  do
  {
    v8 = (int)v4;
    if ( (int)v4 >= v7 || v6 < 0 )
      return 0xFFFFFFFFLL;
    ++v4;
    v9 = a4 % 0xA;
    a4 /= 0xAu;
    *(_BYTE *)(v6 + v5) = v9 + 48;
    ++v6;
  }
  while ( a4 );
  if ( (int)v8 > 0 )
  {
    v10 = (char *)(v8 + v5);
    v11 = -v5;
    do
    {
      v12 = *v10--;
      v13 = *(_BYTE *)v5;
      *(_BYTE *)v5++ = v12;
      v10[1] = v13;
    }
    while ( v11 + v5 < (__int64)&v10[v11] );
  }
  return v4;
}

// --- End Function: sub_1402FE6B0 (0x1402FE6B0) ---

// --- Function: sub_1402FE770 (0x1402FE770) ---
__int64 __fastcall sub_1402FE770(
        double *Buffer,
        unsigned __int64 Size,
        __int64 a3,
        const void **a4,
        const void **a5,
        const void **a6,
        _BYTE *p_])
{
  _BYTE *v7; // rdi
  size_t Size_1; // rbx
  char *v12; // rcx
  size_t Size_2; // rsi
  size_t Size_3; // rdi
  __int64 v15; // r14
  _BYTE *v16; // rsi
  char *v17; // rcx
  size_t Size_4; // rbp
  int v19; // eax
  int v20; // ecx
  __int64 result; // rax

  v7 = *a4;
  Size_1 = -1;
  do
    ++Size_1;
  while ( v7[Size_1] );
  if ( Size_1 + a3 >= Size )
    return 0xFFFFFFFFLL;
  v12 = (char *)Buffer + a3;
  Size_2 = Size - a3;
  if ( Size_1 )
  {
    if ( !v12 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( v7 && Size_2 >= Size_1 )
    {
      memcpy(v12, *a4, Size_1);
    }
    else
    {
      memset(v12, 0, Size - a3);
      if ( !v7 )
        goto LABEL_6;
      if ( Size_2 < Size_1 )
      {
        *errno() = 34;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  if ( (Size_1 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  Size_3 = -1;
  v15 = a3 + (int)Size_1;
  v16 = *a5;
  do
    ++Size_3;
  while ( v16[Size_3] );
  if ( Size_3 + v15 >= Size )
    return 0xFFFFFFFFLL;
  v17 = (char *)Buffer + v15;
  Size_4 = Size - v15;
  if ( !Size_3 )
    goto LABEL_28;
  if ( !v17 )
    goto LABEL_20;
  if ( v16 && Size_4 >= Size_3 )
  {
    memcpy(v17, *a5, Size_3);
  }
  else
  {
    memset(v17, 0, Size - v15);
    if ( !v16 )
    {
LABEL_20:
      *errno() = 22;
LABEL_27:
      invalid_parameter_noinfo();
      goto LABEL_28;
    }
    if ( Size_4 < Size_3 )
    {
      *errno() = 34;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( (Size_3 & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v19 = sub_1402FE920(Buffer, Size, v15 + (int)Size_3, a6, p_]);
  if ( v19 < 0 )
    return 0xFFFFFFFFLL;
  v20 = Size_3 + v19;
  result = (unsigned int)(Size_1 + Size_3 + v19);
  if ( v20 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

// --- End Function: sub_1402FE770 (0x1402FE770) ---

// --- Function: sub_1402FE920 (0x1402FE920) ---
__int64 __fastcall sub_1402FE920(double *Buffer, unsigned __int64 n0xF, __int64 a3, const void **a4, _BYTE *_)
{
  _BYTE *v5; // rsi
  size_t Size; // rbx
  char *v10; // rcx
  size_t Size_1; // rbp
  __int64 v12; // rcx
  size_t Size_2; // rdi
  _BYTE *v14; // rcx

  v5 = *a4;
  Size = -1;
  do
    ++Size;
  while ( v5[Size] );
  if ( Size + a3 >= n0xF )
    return 0xFFFFFFFFLL;
  v10 = (char *)Buffer + a3;
  Size_1 = n0xF - a3;
  if ( !Size )
    goto LABEL_14;
  if ( !v10 )
    goto LABEL_6;
  if ( v5 && Size_1 >= Size )
  {
    memcpy(v10, v5, Size);
  }
  else
  {
    memset(v10, 0, n0xF - a3);
    if ( !v5 )
    {
LABEL_6:
      *errno() = 22;
LABEL_13:
      invalid_parameter_noinfo();
      goto LABEL_14;
    }
    if ( Size_1 < Size )
    {
      *errno() = 34;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( (Size & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  v12 = a3 + (int)Size;
  if ( v12 + 1 >= n0xF )
    return 0xFFFFFFFFLL;
  Size_2 = n0xF - v12;
  v14 = (char *)Buffer + v12;
  if ( !v14 )
  {
LABEL_17:
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(Size + 1);
  }
  if ( _ && Size_2 )
  {
    *v14 = *_;
    return (unsigned int)(Size + 1);
  }
  else
  {
    memset(v14, 0, Size_2);
    if ( !_ )
      goto LABEL_17;
    if ( !Size_2 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(Size + 1);
  }
}

// --- End Function: sub_1402FE920 (0x1402FE920) ---

// --- Function: sub_1402FEA70 (0x1402FEA70) ---
__int64 __fastcall sub_1402FEA70(double *Buffer, unsigned __int64 n0xF, __int64 a3, char *p____EVT_COUNT__:, int *a5)
{
  unsigned __int64 n0xD; // rdi
  char *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r10
  int v13; // ecx
  int v14; // r9d
  __int64 v15; // rdi
  __int64 i; // r8
  __int64 v17; // r11
  int v18; // eax
  char *v19; // r8
  char *v20; // rax
  __int64 v21; // r10
  char v22; // cl
  char v23; // dl
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v10 = (char *)Buffer + a3;
  if ( !v10 )
    goto LABEL_3;
  if ( p____EVT_COUNT__: && n0xD >= 0xD )
  {
    *(double *)v10 = *(double *)p____EVT_COUNT__:;
    *((_DWORD *)v10 + 2) = *((_DWORD *)p____EVT_COUNT__: + 2);
    v10[0xC] = p____EVT_COUNT__:[0xC];
    goto LABEL_11;
  }
  memset(v10, 0, n0xF - a3);
  if ( p____EVT_COUNT__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v11 = n0xF - (a3 + 0xD);
  v12 = (__int64)Buffer + a3 + 0xD;
  v13 = *a5;
  if ( *a5 >= 0 )
  {
    v14 = 0;
  }
  else if ( v11 )
  {
    *(_BYTE *)v12 = 0x2D;
    v13 = -v13 & 0x7FFFFFFF;
    v14 = 1;
  }
  else
  {
    v14 = 0xFFFFFFFF;
  }
  v15 = v14;
  for ( i = v14; ; ++i )
  {
    v17 = v14;
    if ( v14 >= (int)v11 || i < 0 )
      break;
    ++v14;
    v18 = v13 % 0xA;
    v13 /= 0xA;
    *(_BYTE *)(i + v12) = v18 + 0x30;
    if ( !v13 )
    {
      if ( v15 < v17 )
      {
        v19 = (char *)(v17 + v12);
        v20 = (char *)(v15 + v12);
        v21 = -v12;
        do
        {
          v22 = *v19--;
          v23 = *v20;
          *v20++ = v22;
          v19[1] = v23;
        }
        while ( (__int64)&v20[v21] < (__int64)&v19[v21] );
      }
      result = (unsigned int)(v14 + 0xD);
      if ( v14 >= 0 )
        return result;
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEA70 (0x1402FEA70) ---

// --- Function: sub_1402FEBF0 (0x1402FEBF0) ---
__int64 __fastcall sub_1402FEBF0(
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a3,
        char *p____@severity__:,
        unsigned int *p_n0xF,
        char *___severity__:_,
        const void **a7,
        char *p______tags__:[)
{
  unsigned __int64 n0xD; // rbx
  char *v13; // rcx
  int v14; // ebx
  __int64 v15; // rsi
  __int64 v16; // rcx
  unsigned int n0xF_1; // r9d
  __int64 v18; // r8
  __int64 v19; // r11
  unsigned int v20; // eax
  char *v21; // rdx
  __int64 v22; // r9
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  __int64 result; // rax

  if ( a3 + 0xD >= n0xF )
    return 0xFFFFFFFFLL;
  n0xD = n0xF - a3;
  v13 = (char *)Buffer + a3;
  if ( !v13 )
    goto LABEL_3;
  if ( p____@severity__: && n0xD >= 0xD )
  {
    *(double *)v13 = *(double *)p____@severity__:;
    *((_DWORD *)v13 + 2) = *((_DWORD *)p____@severity__: + 2);
    v13[0xC] = p____@severity__:[0xC];
    goto LABEL_11;
  }
  memset(v13, 0, n0xF - a3);
  if ( p____@severity__: )
  {
    if ( n0xD >= 0xD )
      goto LABEL_11;
    *errno() = 0x22;
  }
  else
  {
LABEL_3:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_11:
  v14 = 0;
  v15 = a3 + 0xD;
  v16 = 0;
  n0xF_1 = *p_n0xF;
  v18 = (__int64)Buffer + v15;
  while ( 1 )
  {
    v19 = v14;
    if ( v14 >= (int)n0xF - (int)v15 || v16 < 0 )
      break;
    ++v14;
    v20 = n0xF_1 % 0xA;
    n0xF_1 /= 0xAu;
    *(_BYTE *)(v16 + v18) = v20 + 0x30;
    ++v16;
    if ( !n0xF_1 )
    {
      if ( (int)v19 > 0 )
      {
        v21 = (char *)(v19 + v18);
        v22 = -v18;
        do
        {
          v23 = *v21--;
          v24 = *(_BYTE *)v18;
          *(_BYTE *)v18++ = v23;
          v21[1] = v24;
        }
        while ( v22 + v18 < (__int64)&v21[v22] );
      }
      if ( v14 >= 0 )
      {
        v25 = sub_1402FED90(Buffer, n0xF, v15 + v14, ___severity__:_, a7, p______tags__:[);
        if ( v25 >= 0 )
        {
          v26 = v14 + v25;
          result = (unsigned int)(v14 + v25 + 0xD);
          if ( v26 < 0 )
            return 0xFFFFFFFFLL;
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return 0xFFFFFFFFLL;
}

// --- End Function: sub_1402FEBF0 (0x1402FEBF0) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = -1;
    memset(&Src, 0, sizeof(Src));
    Size_1 = -1;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 32) = 0;
      *(_QWORD *)(v23 + 40) = 0;
      *(__m256 *)(v23 + 16) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 15;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 16LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 40LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[-1].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---
void __fastcall std::vector<vraudio::AudioBuffer const *>::_Change_array(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Newvec,
        const unsigned __int64 _Newsize,
        const unsigned __int64 _Newcapacity)
{
  _QWORD *v6; // rcx

  v6 = *(_QWORD **)this;
  if ( v6 )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = (_QWORD *)*(v6 - 1);
    }
    sub_1402A3D30(v6);
  }
  *(_QWORD *)this = _Newvec;
  *((_QWORD *)this + 1) = &_Newvec[_Newsize];
  *((_QWORD *)this + 2) = &_Newvec[_Newcapacity];
}

// --- End Function: ?_Change_array@?$vector@PEBVAudioBuffer@vraudio@@V?$allocator@PEBVAudioBuffer@vraudio@@@std@@@std@@AEAAXQEAPEBVAudioBuffer@vraudio@@_K1@Z (0x1402FF960) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(__int64 a1, _QWORD *a2, __int64 a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(a3 + 36));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(a3 + 32);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(a3 + 8);
  v18 = *(_QWORD *)a3;
  v31 = v16;
  if ( (v17 - *(_QWORD *)a3) / 112 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 88) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 64))();
        v18 += 112;
      }
      while ( v18 != v17 );
      *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
    }
    sub_1402FDB90((__int64 *)a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 48;
    v23 = -48 - __Val_0___1;
    v29 = -48 - __Val_0___1;
    while ( !v16 )
    {
      v20 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 24)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 112LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 48),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)a3));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 112;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = -16 - __Val_0__;
      v26 = __Val_0__ + 16;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 56)
          && *(_QWORD *)(v26 + 32) )
        {
          if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 112LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)a3;
          if ( *(_BYTE *)(v27 + 88) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 64))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 56))(*(_QWORD *)(v26 - 16));
          v25 = -16 - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 16) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 24) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 32) = *(_QWORD *)(v26 + 16);
          *(_QWORD *)(v27 + 48) = *(_QWORD *)(v26 + 32);
          *(_QWORD *)(v27 + 40) = *(_QWORD *)(v26 + 24);
          *(_QWORD *)(v27 + 56) = *(_QWORD *)(v26 + 40);
          *(_QWORD *)(v27 + 64) = *(_QWORD *)(v26 + 48);
          *(_QWORD *)(v27 + 72) = *(_QWORD *)(v26 + 56);
          *(_QWORD *)(v27 + 80) = *(_QWORD *)(v26 + 64);
          *(_QWORD *)(v27 + 96) = *(_QWORD *)(v26 + 80);
          *(_QWORD *)(v27 + 104) = *(_QWORD *)(v26 + 88);
          *(_BYTE *)(v27 + 88) = 1;
          *(_BYTE *)(v27 + 89) = *(_BYTE *)(v26 + 73);
        }
        ++_Newcapacity_2;
        v26 += 112;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(a3 + 24) = a1;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 19), SizeInBytes - 19, ".%03dZ", v3 - 1000 * v7) + 19);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Invokes the global callback function stored in `qword_149808980` if it is non-
// null, passing the provided arguments. If the callback is null, it defaults to
// returning 1. The result (status bits) is then potentially modified by clearing
// bit 2 if `qword_149808998` is zero, and clearing bit 3 if `qword_1498089A0` is
// zero.
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 result; // rax

  if ( qword_149B3B1F0 )
    result = qword_149B3B1F0(a1, a2, a3, a4);
  else
    result = 1;
  if ( !qword_149B3B208 )
    result = (unsigned int)result & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)result & 0xFFFFFFF7;
  return result;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140300AB0 (0x140300AB0) ---
__int64 __fastcall sub_140300AB0(int a1)
{
  __int64 n1000; // rax

  switch ( a1 )
  {
    case 2:
      n1000 = 1000;
      break;
    case 3:
      n1000 = 5000;
      break;
    case 4:
      n1000 = 15000;
      break;
    case 5:
      n1000 = 30000;
      break;
    case 6:
      n1000 = 60000;
      break;
    case 7:
      n1000 = 300000;
      break;
    case 8:
      n1000 = 900000;
      break;
    case 9:
      n1000 = 1800000;
      break;
    default:
      n1000 = 0;
      break;
  }
  return n1000;
}

// --- End Function: sub_140300AB0 (0x140300AB0) ---

// --- Function: sub_140300BC0 (0x140300BC0) ---
__int64 __fastcall sub_140300BC0(_WORD *a1, int a2, char n37)
{
  unsigned int n2_1; // r10d
  __int64 n2; // rax

  n2_1 = 0;
  switch ( n37 )
  {
    case 8:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 25180;
      n2 = 2;
      break;
    case 9:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29788;
      n2 = 2;
      break;
    case 10:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 28252;
      n2 = 2;
      break;
    case 12:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 26204;
      n2 = 2;
      break;
    case 13:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 29276;
      n2 = 2;
      break;
    case 34:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 8796;
      n2 = 2;
      break;
    case 92:
      if ( a2 <= 1 )
        goto LABEL_18;
      *a1 = 23644;
      n2 = 2;
      break;
    default:
      if ( a2 > 0 )
      {
        *(_BYTE *)a1 = n37;
        n2_1 = 1;
      }
LABEL_18:
      n2 = n2_1;
      break;
  }
  return n2;
}

// --- End Function: sub_140300BC0 (0x140300BC0) ---

// --- Function: sub_140300D10 (0x140300D10) ---
__int64 __fastcall sub_140300D10(_BYTE *a1, int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // r10
  int v8; // edx
  int v9; // ebp
  unsigned __int64 i; // rbx
  int v11; // r11d
  int v12; // r9d
  _WORD *v13; // r8
  __int64 v14; // rax
  unsigned int v15; // edx

  v4 = -1;
  do
    ++v4;
  while ( *(_BYTE *)(a3 + v4) );
  v8 = 0;
  v9 = 0;
  if ( a4 )
  {
    if ( a2 <= 0 )
    {
      v9 = 1;
    }
    else
    {
      *a1 = 34;
      v8 = 1;
    }
  }
  for ( i = 0; i < v4; ++i )
  {
    if ( v8 >= a2 )
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = a2 - v8;
      v13 = &a1[v8];
      switch ( *(_BYTE *)(i + a3) )
      {
        case 8:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 25180;
          v8 += 2;
          break;
        case 9:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 29788;
          v8 += 2;
          break;
        case 0xA:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 28252;
          v8 += 2;
          break;
        case 0xC:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 26204;
          v8 += 2;
          break;
        case 0xD:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 29276;
          v8 += 2;
          break;
        case 0x22:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 8796;
          v8 += 2;
          break;
        case 0x5C:
          if ( v12 <= 1 )
            goto LABEL_26;
          *v13 = 23644;
          v8 += 2;
          break;
        default:
          if ( v12 > 0 )
          {
            *(_BYTE *)v13 = *(_BYTE *)(i + a3);
            v11 = 1;
          }
LABEL_26:
          v8 += v11;
          break;
      }
    }
  }
  if ( a4 )
  {
    if ( v8 < a2 )
    {
      v14 = v8;
      v15 = v8 + 1;
      if ( v9 )
        v15 = -1;
      a1[v14] = 34;
      return v15;
    }
    v9 = 1;
  }
  if ( v9 )
    return (unsigned int)-1;
  return (unsigned int)v8;
}

// --- End Function: sub_140300D10 (0x140300D10) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *a5,
        _BYTE *Src,
        char *a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = -1;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = -1;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 22;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 22;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 34;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 91;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = -1;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 31;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = -1;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 22;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 34;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 22;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 34;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 15392;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 22;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 34;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = -1;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 22;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 34;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = -1;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 22;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 34;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 8254;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 34;
  }
  else
  {
    *errno() = 22;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = -1;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 34;
  }
  else
  {
LABEL_108:
    *errno() = 22;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 32;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *a5;
  if ( !((a5[1] - *a5) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = -1;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 91;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 34;
            }
            else
            {
              *errno() = 22;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 22;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 34;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *a5;
  }
  while ( v62 < (a5[1] - *a5) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = -1;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 22;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 34;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 14;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 11822;
      Buffer_3[Size - 2] = 46;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *a6,
        char *a7,
        char *a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *v24; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *v58; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *v159; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  v24 = a6;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 128;
  n0xF_5[0] = n4;
  v159 = a6;
  n0xF_17 = n0xF + 128;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 1886216564;
    *((_WORD *)Buffer + 6) = 14882;
    *((_BYTE *)Buffer + 14) = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = -1;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 15 >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    v24 = v159;
LABEL_57:
    n0xF_25 = -1;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 15;
  Size_1 = n0xF_1 - 15;
  if ( Size )
  {
    if ( Buffer == (double *)-15LL )
    {
LABEL_11:
      *errno() = 22;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 15);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 34;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 15LL;
  if ( (int)Size + 24LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 22;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 34;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 34;
LABEL_28:
  v34 = (int)Size + 24LL;
  Size_3 = -1;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 22;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 34;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 13 >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 22;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 34;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 578315369;
  *((_BYTE *)v39 + 12) = 58;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 13, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 13;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  v24 = v159;
  n0xF_25 = v45 + 15;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 31;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              v162,
              v161,
              n4_1,
              v166,
              v24,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (a18 & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 128;
      n0xF_26 = n0xF + 128;
      n0xF_18 = n0xF + 128;
      goto LABEL_95;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 128;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 128;
      n0xF_18 = n0xF + 128;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 128;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 128;
  n0xF_18 = n0xF + 128;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  v58 = v159;
  v59 = v159[1];
  v60 = *v159;
  v61 = (v59 - *v159) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 22;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 34;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 34;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = -1;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_129:
      n0xF_3 = n0xF + 128;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      v58 = v159;
      goto LABEL_131;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 34;
      }
      else
      {
LABEL_111:
        *errno() = 22;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 128;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_130;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 11298;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    v58 = v159;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = v58[1];
    ++v62;
    v60 = *v58;
    v75 = v59 - *v58;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 22;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 34;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 34;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_145:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 11LL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 22;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 34;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 14882;
      *((_BYTE *)v88 + 10) = 34;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 11;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 128;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 13LL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 22;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 34;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 975332711;
      *((_BYTE *)v94 + 12) = 34;
    }
    n0xF_2 += 13;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 128;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 34;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 34;
    }
    else
    {
      *errno() = 22;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 11LL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 22;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 34;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 11;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 11;
    *((_WORD *)v97 + 4) = 14882;
    *((_BYTE *)v97 + 10) = 34;
  }
LABEL_209:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            v164,
            __Val_0___1,
            _Newcapacity,
            a11,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 22;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 34;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 34;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 80);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != -1;
              n0xF_16 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 22;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 34;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 11357;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 80);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != -1;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_248:
              v115 = n0xF + 128;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 22;
                goto LABEL_255;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 34;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 128;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 34;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = -1;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 22;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 34;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 128;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 22;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 34;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 14882;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != -1 )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 22;
                  goto LABEL_292;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 34;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 91;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 80);
          v102 = v114 != -1;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 80);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != -1;
          n0xF_16 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 22;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 34;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 44;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 44;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 34;
      }
      else
      {
        *errno() = 22;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 32))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 128;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 128;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 22;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 34;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 1819635234;
          v136[2] = 8812;
        }
      }
LABEL_315:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 22;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 34;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 93;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 13LL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 22;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 34;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 975329103;
        *((_BYTE *)v139 + 12) = 49;
      }
      n0xF_2 += 13;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 v159,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 22;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 34;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 2685;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    v147 = v161;
    qword_149B3B210(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      v159,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 39 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 39);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(_Newvec - 1) = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
char __fastcall sub_1403045C0(
        unsigned int n4_1,
        __int64 *a2,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  char result; // al
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned __int64 n0x10; // rax
  __int64 *v17; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v19; // r13
  char *v20; // r15
  __int64 v21; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v23; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  __int64 *v25; // rax
  __int64 *v26; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v28; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  __int64 v32; // r13
  __int64 (__fastcall *v33)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v34; // rax
  unsigned __int64 v35; // rcx
  __int64 *v36; // rdi
  _QWORD *v37; // r13
  bool v38; // zf
  _QWORD *v39; // rbx
  _QWORD *v40; // rax
  _BYTE *v41; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v44; // r9
  __int64 v45; // rcx
  __m256 *p_Src; // r14
  char *v47; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __int64 p_Src_2; // r15
  _QWORD *v51; // r14
  _QWORD *v52; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v57; // rax
  __int64 *v58; // rcx
  __int64 v59; // rcx
  _QWORD *v60; // rbx
  __int64 v61; // rcx
  __int64 *v62; // r14
  __int64 p_Src_3; // rax
  __int64 *v64; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v66; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v70; // rax
  char *v71; // r11
  unsigned __int64 _Newcapacity_1; // r10
  char *v73; // rdi
  int v74; // r13d
  __int64 v75; // rcx
  __int64 v76; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v78; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v83; // rax
  __int64 v84; // r15
  char *v85; // r14
  __int64 v86; // rax
  void *v87; // rsp
  __int64 (__fastcall *v88)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v89; // edx
  int v90; // r12d
  char v91; // cl
  int v92; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v96; // al
  bool v97; // dl
  bool v98; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v100; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  __int64 Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v105; // rax
  void *v106; // rsp
  char v107; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 *v110; // rsi
  _QWORD **v111; // rcx
  _QWORD *v112; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v114; // rdi
  __int64 v115; // rcx
  __int64 *v116; // rbx
  __int64 v117; // rcx
  int v118; // [rsp+90h] [rbp-10h]
  unsigned __int8 v119; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  __int64 *v121; // [rsp+B0h] [rbp+10h]
  __int64 v122; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v124; // [rsp+C8h] [rbp+28h] BYREF
  int v125[2]; // [rsp+D0h] [rbp+30h]
  char *v126; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v130; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v132; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v134; // [rsp+118h] [rbp+78h]
  char *v135; // [rsp+120h] [rbp+80h]
  __int64 *v136; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v138; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  __int64 *v143; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v144; // [rsp+168h] [rbp+C8h] BYREF
  __int64 v145; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v148[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v149[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v134 = a4;
  v135 = a3;
  v136 = a2;
  n4 = n4_1;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 1000LL * (int)((*(_QWORD *)&FileTime - 116444736000000000LL) / 0x989680uLL);
  }
  v130 = v12;
  if ( v11 )
  {
    result = sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity);
    if ( !result )
      return result;
  }
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 37);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v144 = (__int64 *)&v143;
  n0x10 = 0;
  v143 = 0;
  v17 = 0;
  v121 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v19 = 0;
  v122 = 0;
  v20 = 0;
  n0x10_1 = 0;
  v21 = 0;
  v126 = 0;
  v124 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v73 = (char *)v149;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v23 = v119;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 89) && n0x10 < 0x10 )
    {
      v148[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v149[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v17 )
      {
        __asm { vzeroupper }
        v25 = (__int64 *)allocWithProfilerInfo_w(0x18u);
        v17 = v25;
        v121 = v25;
        if ( v25 )
        {
          v26 = v25;
          *v25 = 0;
          n0x400_1 = 0;
          v25[1] = 0;
          v28 = (__int64)v25;
          v25[2] = 0;
        }
        else
        {
          v17 = 0;
          v26 = 0;
          n0x400_1 = 0;
          v121 = 0;
          v28 = 0;
        }
        sub_1403044D0(v28, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v149;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)v26[1];
          if ( _Whereptr == (const vraudio::AudioBuffer **)v26[2] )
          {
            sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)v17, _Whereptr, __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            v26[1] += 8;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v21 = v124;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)v17[1];
      if ( _Whereptr_1 == (const vraudio::AudioBuffer **)v17[2] )
      {
        __asm { vzeroupper }
        sub_1402A6760(
          (std::vector<vraudio::AudioBuffer const *> *)v17,
          _Whereptr_1,
          (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        v17[1] += 8;
      }
      goto LABEL_30;
    }
LABEL_31:
    v122 = *((_QWORD *)__Val_0___1 + 13) + v19;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v144, __Val_0___1, v14, v15);
    v32 = v21;
    v33 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v145 = v21++;
    v124 = v21;
    if ( !v33 )
    {
      v71 = v126;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v132 = 0;
    v34 = v33(*(_QWORD *)__Val_0___1, &v132, &__Val_0___4);
    v35 = 0;
    *(_QWORD *)v125 = 0;
    if ( !v132 )
      goto LABEL_94;
    v36 = v144;
    v37 = (_QWORD *)(v34 + 16);
    v138 = (_QWORD *)(v34 + 16);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v37 - 2);
      __Val_0___5 = (vraudio::AudioBuffer *)(v37 - 2);
      v38 = *v37 == 0;
      v124 = v21 + 1;
      v37[8] = v21;
      if ( v38 )
      {
        v60 = (_QWORD *)*(v37 - 1);
        v62 = 0;
      }
      else
      {
        if ( !*v36 )
        {
          __asm { vzeroupper }
          v39 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v39 )
          {
            *v39 = 0;
            v39[1] = 0;
            v40 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v40 = v40;
            v40[1] = v40;
            *v39 = v40;
          }
          else
          {
            v39 = 0;
          }
          *v36 = (__int64)v39;
        }
        v41 = (_BYTE *)*(v37 - 1);
        Size = -1;
        memset(&Src, 0, sizeof(Src));
        Size_1 = -1;
        do
          ++Size_1;
        while ( v41[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v41, Size_1, v15);
        v44 = (_BYTE *)*v37;
        do
          ++Size;
        while ( v44[Size] );
        v45 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v23, v44, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v47 = (char *)p_Src + v45;
          memmove(v47, v44, Size);
          v47[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v36;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(_QWORD *)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v51 = *(_QWORD **)__Val_0___7;
        v52 = **(_QWORD ***)__Val_0___7;
        if ( v52 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v52[4];
          Buf1 = v52 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = (__m256 *)p_Src_2;
          if ( v52[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v52 = (_QWORD *)*v52;
        }
        while ( v52 != v51 );
        __Val_0___7 = __Val_0___6;
        if ( v52 == v51 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v57 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v57 + 32) = 0;
          *(_QWORD *)(v57 + 40) = 0;
          *(__m256 *)(v57 + 16) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v58 = (__int64 *)v51[1];
          *(_QWORD *)v57 = v51;
          *(_QWORD *)(v57 + 8) = v58;
          v51[1] = v57;
          *v58 = v57;
          v59 = *(_QWORD *)*v36;
          v60 = (_QWORD *)(*(_QWORD *)(v59 + 8) + 16LL);
          if ( *(_QWORD *)(*(_QWORD *)(v59 + 8) + 40LL) > 0xFu )
            v60 = (_QWORD *)*v60;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v61 = *(_QWORD *)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v61 = *(_QWORD *)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - v61 - 8) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v61);
          }
LABEL_66:
          v17 = v121;
          v62 = 0;
          v37 = v138;
          __Val_0___3 = __Val_0___5;
          v35 = *(_QWORD *)v125;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 15;
          goto LABEL_74;
        }
        v60 = v52 + 2;
        if ( v60[3] > 0xFu )
          v60 = (_QWORD *)*v60;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(_QWORD *)(p_Src_2 - 8);
          if ( (unsigned __int64)(p_Src_3 - p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v17 = v121;
        v62 = 0;
        v37 = v138;
        __Val_0___3 = __Val_0___5;
        v35 = *(_QWORD *)v125;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 15;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v60;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v17 )
        {
          __asm { vzeroupper }
          v64 = (__int64 *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v121 = v64;
          v17 = v64;
          if ( v64 )
          {
            *v64 = 0;
            v66 = (__int64)v64;
            v64[1] = 0;
            v64[2] = 0;
            v62 = v64;
          }
          else
          {
            v17 = 0;
            v121 = 0;
            v66 = 0;
          }
          sub_1403044D0(v66, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v149;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)v62[1];
            if ( _Whereptr_2 == (const vraudio::AudioBuffer **)v62[2] )
            {
              sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)v17, _Whereptr_2, __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              v62[1] += 8;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)v17[1];
        if ( _Whereptr_3 == (const vraudio::AudioBuffer **)v17[2] )
        {
          __asm { vzeroupper }
          sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)v17, _Whereptr_3, &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          v17[1] += 8;
        }
        v35 = *(_QWORD *)v125;
      }
      else
      {
        v149[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v35;
      v70 = v37[11] + v122;
      v37 += 14;
      v21 = v124;
      v122 = v70;
      *(_QWORD *)v125 = v35;
      v138 = v37;
    }
    while ( v35 < v132 );
    __Val_0___1 = __Val_0___2;
    v32 = v145;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v32 = -1;
    v71 = &v126[__Val_0___4];
    v126 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 112);
    v14 = v122;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 10) = v32;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v19 = v14;
      continue;
    }
    break;
  }
  v20 = v71;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  v126 = v71;
  if ( !v17 )
    goto LABEL_105;
  if ( !((v17[1] - *v17) >> 3) )
    __debugbreak();
  v73 = (char *)*v17;
  v121 = v17;
  n0xF_29 = n0x400;
  v122 = v14;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v126 = v71;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v73, (unsigned __int64)&v73[8 * n0x400], (__int64)(8 * n0x400) >> 3, v119);
  v74 = 0;
  v75 = 0;
  v76 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v78 = *(_QWORD *)&v73[8 * n0x400_3];
    if ( v76 == *(_QWORD *)(v78 + 8) )
    {
      if ( ++v75 == 1 )
        *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3 - 8] + 80LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 80LL) = v75;
    }
    else
    {
      v75 = 0;
      *(_QWORD *)(v78 + 80) = -(__int64)(*(_QWORD *)(v78 + 80) != -1);
      v76 = *(_QWORD *)(*(_QWORD *)&v73[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v20 + 1) << 10;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v84 = 0;
  }
  else
  {
    v83 = allocWithProfilerInfo_w(n0x8000_2);
    v84 = v83;
    if ( v83 )
    {
      v85 = (char *)v83;
      goto LABEL_130;
    }
  }
  v86 = n0x8000_2 + 15;
  if ( n0x8000_2 + 15 < n0x8000_2 )
    v86 = 0xFFFFFFFFFFFFFF0LL;
  v87 = alloca(v86 & 0xFFFFFFFFFFFFFFF0uLL);
  v85 = (char *)&v119;
LABEL_130:
  v88 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v89 = 1;
  *v85 = 0;
  v90 = 0;
  LODWORD(v124) = 0;
  v125[0] = 1;
  if ( v88 && qword_149B3B200 && byte_149924748 )
  {
    v89 = v88(v130, n4, v135, v136, v134, __Val_0__, _Newcapacity, v148, n0x10_1, &a8);
    v125[0] = v89;
  }
  v91 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v92 = sub_140302340(
            *(_QWORD *)&FileTime,
            v130,
            (__int64)String,
            n4,
            v136,
            v135,
            v134,
            __Val_0__,
            _Newcapacity,
            a7,
            v85,
            n0x8000_2,
            (int *)&v124,
            v89,
            &a8);
    v91 = a8;
    v90 = v92;
    v74 = v124;
  }
  if ( n2_125 == 1 && (v91 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v85);
    v91 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v91 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v85);
    n2_126 = ::n2_126;
  }
  v85[v90] = 0;
  v96 = a8;
  v97 = (a8 & 1) != 0 && n2_125 == 2;
  v98 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v97 || v98 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v100 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v100 = v122 + v90 + ((_QWORD)(v126 + 4) << 9);
    n0x8000_3 = v100 + 128;
    if ( *p_n0x8000_1 < v100 + 128 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v105 = n0x8000_3 + 15;
    if ( n0x8000_3 + 15 < n0x8000_3 )
      v105 = 0xFFFFFFFFFFFFFF0LL;
    v106 = alloca(v105 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v119;
LABEL_166:
    v118 = v125[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v130,
      Buffer,
      String,
      n4,
      v136,
      v135,
      v134,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v73,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 128,
      (__int64)&v85[v74],
      v90 - v74,
      a8,
      v118);
    sub_1402A3D30(Buffer_3);
    v96 = a8;
  }
  v107 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v96 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v96 = a8;
      v107 = byte_149B3AEA8;
    }
    if ( v107 )
    {
      if ( (v96 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  result = sub_1402A3D30(v84);
  v110 = v143;
  if ( v143 )
  {
    v111 = (_QWORD **)*v143;
    **(_QWORD **)(*v143 + 8) = 0;
    v112 = *v111;
    if ( *v111 )
    {
      do
      {
        n0xF_1 = v112[5];
        v114 = (_QWORD *)*v112;
        if ( n0xF_1 > 0xF )
        {
          v115 = v112[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)(v115 - *(_QWORD *)(v115 - 8) - 8) > 0x1F )
              goto LABEL_189;
            v115 = *(_QWORD *)(v115 - 8);
          }
          sub_1402A3D30(v115);
        }
        v112[4] = 0;
        v112[5] = 15;
        *((_BYTE *)v112 + 16) = 0;
        sub_1402A3D30((__int64)v112);
        v112 = v114;
      }
      while ( v114 );
    }
    sub_1402A3D30(*v110);
    result = sub_1402A3D30((__int64)v110);
  }
  v116 = v121;
  if ( v121 )
  {
    v117 = *v121;
    if ( *v121 )
    {
      if ( ((v121[2] - v117) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v117 - *(_QWORD *)(v117 - 8) - 8) > 0x1F )
LABEL_189:
          invalid_parameter_noinfo_noreturn();
        v117 = *(_QWORD *)(v117 - 8);
      }
      sub_1402A3D30(v117);
      *v116 = 0;
      v116[1] = 0;
      v116[2] = 0;
    }
    return sub_1402A3D30((__int64)v116);
  }
  return result;
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: sub_140305400 (0x140305400) ---
__int64 __fastcall sub_140305400(
        __int64 a1,
        __int64 a2,
        int a3,
        char *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        __int64 (__fastcall *a9)(__int64, __int64, __int64, __int64, __int64, _BYTE *))
{
  __int64 v9; // rbp
  int v11; // ecx
  int v12; // esi
  char n37; // r8
  __int64 v14; // r15
  char *v15; // rbx
  __int64 v17; // rcx
  char n36; // cl
  __int64 v19; // rdi
  _BYTE *v20; // r11
  unsigned __int64 n0x39; // rcx
  char *v22; // r10
  int n31_2; // r8d
  __int64 n31; // rdx
  __int64 v25; // r9
  int n31_1; // eax
  __int64 n31_3; // rcx
  int v28; // eax
  int v29; // edi
  _BYTE *v30; // rbp
  int n31_5; // r9d
  __int64 n31_6; // r8
  char *v33; // r11
  __int64 v34; // r10
  unsigned __int64 n0x39_1; // rdx
  int n31_4; // eax
  int v37; // eax
  int v38; // eax
  __int64 v39; // rax
  _BYTE *v41; // [rsp+28h] [rbp-90h]
  char String[4]; // [rsp+30h] [rbp-88h] BYREF
  int v43; // [rsp+34h] [rbp-84h]
  __int64 (__fastcall *v44)(__int64, __int64, __int64, __int64, __int64, _BYTE *); // [rsp+38h] [rbp-80h]
  __int64 v45; // [rsp+40h] [rbp-78h]
  _BYTE v46[32]; // [rsp+48h] [rbp-70h] BYREF

  v9 = a5;
  v11 = a3;
  v12 = a3;
  v45 = a5;
  n37 = *a4;
  v14 = 0;
  v44 = a9;
  v15 = a4;
  v43 = v11;
  if ( n37 )
  {
    do
    {
      v17 = 0x3FF6C0900000000LL;
      if ( n37 == 36 )
      {
        n36 = *++v15;
        v19 = 0;
        if ( n36 == 36 )
        {
LABEL_6:
          v19 = v14++;
        }
        else
        {
          while ( (unsigned __int8)(n36 - 48) <= 9u )
          {
            String[0] = n36;
            ++v15;
            v19 = atoi(String) + 10 * v19;
            n36 = *v15;
            if ( *v15 == 36 )
              goto LABEL_6;
          }
          --v15;
        }
        v20 = 0;
        if ( v15[1] == 123 )
        {
          n0x39 = (unsigned __int8)v15[2];
          v22 = v15;
          v15 += 2;
          n31_2 = 0;
          n31 = 0;
          if ( (_BYTE)n0x39 != 125 )
          {
            do
            {
              if ( n31 >= 31 || (unsigned __int8)n0x39 > 0x39u || (v25 = 0x3FF6C0900000000LL, !_bittest64(&v25, n0x39)) )
              {
                v15 = v22;
                goto LABEL_20;
              }
              ++v15;
              v46[n31] = n0x39;
              ++n31_2;
              ++n31;
              n0x39 = (unsigned __int8)*v15;
            }
            while ( (_BYTE)n0x39 != 125 );
            if ( n31_2 > 0 )
            {
              n31_1 = 31;
              if ( n31_2 < 31 )
                n31_1 = n31_2;
              n31_3 = n31_1;
              if ( (unsigned __int64)n31_1 >= 0x20 )
LABEL_55:
                _report_rangecheckfailure(n31_3);
              v46[n31_1] = 0;
              v20 = v46;
            }
          }
        }
LABEL_20:
        if ( v12 < (int)a2 )
        {
          v28 = v44(v12 + a1, a2 - v12, v9, v19 + a7, a6, v20);
          if ( v28 >= 0 )
            v12 += v28;
        }
        v29 = a2;
      }
      else if ( n37 == 37 )
      {
        v30 = 0;
        n31_5 = 0;
        n31_6 = 0;
        v33 = v15;
        v34 = 0;
        while ( 2 )
        {
          n0x39_1 = *++v15;
          switch ( (int)n0x39_1 )
          {
            case 0:
              v15 = v33 + 1;
              goto LABEL_39;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64:
            case 66:
            case 68:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 84:
            case 85:
            case 86:
            case 87:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            case 96:
            case 98:
            case 104:
            case 106:
            case 107:
            case 108:
            case 109:
            case 113:
            case 114:
            case 116:
            case 118:
            case 119:
              v17 = 0x3FF6C0900000000LL;
              goto LABEL_28;
            case 37:
            case 65:
            case 67:
            case 69:
            case 70:
            case 71:
            case 83:
            case 88:
            case 90:
            case 97:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 105:
            case 110:
            case 111:
            case 112:
            case 115:
            case 117:
            case 120:
              if ( n31_5 <= 0 )
                goto LABEL_37;
              n31_4 = 31;
              if ( n31_5 < 31 )
                n31_4 = n31_5;
              n31_3 = n31_4;
              if ( (unsigned __int64)n31_4 >= 0x20 )
                goto LABEL_55;
              v46[n31_4] = 0;
              v30 = v46;
LABEL_37:
              v34 = v14++;
LABEL_39:
              v29 = a2;
              if ( v12 >= (int)a2 )
              {
                v9 = v45;
              }
              else
              {
                v41 = v30;
                v9 = v45;
                v37 = v44(v12 + a1, a2 - v12, v45, v34 + a7, a6, v41);
                if ( v37 >= 0 )
                  v12 += v37;
              }
              break;
            default:
LABEL_28:
              if ( n31_6 < 31 && (unsigned __int8)n0x39_1 <= 0x39u && _bittest64(&v17, n0x39_1) )
              {
                ++n31_5;
                v46[n31_6++] = n0x39_1;
              }
              continue;
          }
          break;
        }
      }
      else
      {
        v29 = a2;
        if ( a8 )
        {
          if ( v12 < (int)a2 )
          {
            v38 = sub_140300BC0((_WORD *)(v12 + a1), (int)a2 - v12, n37);
            if ( v38 >= 0 )
              v12 += v38;
          }
        }
        else if ( v12 < (int)a2 )
        {
          v39 = v12++;
          *(_BYTE *)(v39 + a1) = n37;
        }
      }
      n37 = *++v15;
    }
    while ( n37 );
    v11 = v43;
  }
  else
  {
    v29 = a2;
  }
  if ( v12 < v29 )
    *(_BYTE *)(v12 + a1) = 0;
  return (unsigned int)(v12 - v11);
}

// --- End Function: sub_140305400 (0x140305400) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: sub_140305E80 (0x140305E80) ---
__int64 __fastcall sub_140305E80(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x30LL))(a1);
}

// --- End Function: sub_140305E80 (0x140305E80) ---

// --- Function: sub_14030A1B0 (0x14030A1B0) ---
__int64 __fastcall sub_14030A1B0(__int64 a1, __int64 a2)
{
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)a1 = off_1481ACC20;
  *(_WORD *)(a1 + 0x28) = 0xFFFF;
  *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a2 + 0x20);
  *(_WORD *)(a1 + 0x28) = *(_WORD *)(a2 + 0x28);
  return a1;
}

// --- End Function: sub_14030A1B0 (0x14030A1B0) ---

// --- Function: sub_14030A1F0 (0x14030A1F0) ---
unsigned int *__fastcall sub_14030A1F0(unsigned int *a1, unsigned int *a2, unsigned __int8 *a3)
{
  unsigned int v4; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // eax
  __int64 v8; // r8
  __int64 v10; // r8

  *a1 = 0xFFFFFFFF;
  v4 = *a2;
  if ( *a2 == 0xFFFFFFFF )
  {
    if ( a3 && *a3 )
    {
      v10 = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++v10;
      while ( a3[v10] );
      *a1 = ~(unsigned int)psub_140336210(0xFFFFFFFF, a3, v10);
    }
    return a1;
  }
  *a1 = v4;
  if ( !a3 || !*a3 )
    return a1;
  v6 = ~v4;
  *a1 = v6;
  v7 = psub_140336210(v6, (unsigned __int8 *)Control_, 1);
  *a1 = v7;
  v8 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v8;
  while ( a3[v8] );
  *a1 = ~(unsigned int)psub_140336210(v7, a3, v8);
  return a1;
}

// --- End Function: sub_14030A1F0 (0x14030A1F0) ---

// --- Function: sub_14030A470 (0x14030A470) ---
__int64 __fastcall sub_14030A470(__int64 a1)
{
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)a1 = off_1481AB408;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  sub_14035B5F0((_QWORD *)(a1 + 0x40));
  sub_14035B5F0((_QWORD *)(a1 + 0x48));
  *(_QWORD *)a1 = off_1481AB568;
  return a1;
}

// --- End Function: sub_14030A470 (0x14030A470) ---

// --- Function: sub_14030C070 (0x14030C070) ---
__int64 __fastcall sub_14030C070(__int64 *a1)
{
  __int64 result; // rax
  volatile signed __int32 *v3; // rcx

  *a1 = (__int64)off_1481AAE78;
  result = sub_1403318F0(a1);
  v3 = (volatile signed __int32 *)a1[3];
  if ( v3 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v3 + 3, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8LL))(v3);
  }
  return result;
}

// --- End Function: sub_14030C070 (0x14030C070) ---

// --- Function: sub_14030C0C0 (0x14030C0C0) ---
__int64 __fastcall sub_14030C0C0(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  __int64 (__fastcall *p_sub_140323650)(__int64); // r8
  volatile signed __int32 *v5; // rcx

  *(_QWORD *)a1 = &off_1481ACBC0;
  result = *(_QWORD *)(a1 + 0x18);
  if ( result && *(_DWORD *)(result + 8) )
  {
    v3 = sub_14030ED10(a1 + 8);
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 0x40LL))(v3, a1);
    p_sub_140323650 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 0x38LL);
    if ( p_sub_140323650 == sub_140323650 )
    {
      *(_BYTE *)(a1 + 0xC) = 0;
      result = sub_140333220((_QWORD *)(a1 + 0x10));
      *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
    }
    else
    {
      result = ((__int64 (__fastcall *)(__int64, _QWORD))p_sub_140323650)(a1, 0);
    }
  }
  v5 = *(volatile signed __int32 **)(a1 + 0x18);
  if ( v5 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
  }
  return result;
}

// --- End Function: sub_14030C0C0 (0x14030C0C0) ---

// --- Function: is_valid_handle_typeA (0x14030EB70) ---
// Validates a packed handle/flags value pointed to by `packed_handle_ptr`.
// Extracts the handle (lower 48 bits) and flags (upper 16 bits). Retrieves
// metadata for the handle using `get_handle_metadata`. Checks if the metadata type
// (at offset +4) is 4, or if it's 2 and specific thread conditions are met (TEB
// data exists or `check_handle_state_and_access` passes). Also verifies
// consistency between metadata flags (at offset +2) and the input flags.
bool __fastcall is_valid_handle_typeA(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)NtCurrentTeb_w() )
    return sub_14031FE20(a1) != 0;
  return 1;
}

// --- End Function: is_valid_handle_typeA (0x14030EB70) ---

// --- Function: sub_14030EC00 (0x14030EC00) ---
bool __fastcall sub_14030EC00(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // rbx
  bool v8; // al

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v1 & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(v1);
  if ( (v4 & 0xF000) != 0 )
  {
    v5 = map_flag_to_mask(0x2000u);
    v7 = v6 & ~(v5 - 1);
  }
  else
  {
    v7 = v3 - 6;
  }
  if ( *(_WORD *)(v7 + 2) != (v4 & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || (v8 = sub_140539D80()) )
    v8 = 1;
  return *(_WORD *)(v7 + 4) == 2 && v8 || sub_140392020(a1) != 0;
}

// --- End Function: sub_14030EC00 (0x14030EC00) ---

// --- Function: sub_14030ECC0 (0x14030ECC0) ---
bool __fastcall sub_14030ECC0(__int64 a1)
{
  __int64 v1; // rax

  v1 = *(_QWORD *)(a1 + 0x10);
  return v1 && *(_DWORD *)(v1 + 8) != 0;
}

// --- End Function: sub_14030ECC0 (0x14030ECC0) ---

// --- Function: sub_14030ED10 (0x14030ED10) ---
__int64 __fastcall sub_14030ED10(__int64 a1)
{
  __int64 v1; // rdx
  signed __int32 v2; // eax
  signed __int32 v3; // ett
  __int64 v5; // rdi
  volatile signed __int32 *v6; // rbx

  v1 = *(_QWORD *)(a1 + 0x10);
  if ( !v1 )
    return 0;
  v2 = *(_DWORD *)(v1 + 8);
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v3 = v2;
    v2 = _InterlockedCompareExchange((volatile signed __int32 *)(v1 + 8), v2 + 1, v2);
    if ( v3 == v2 )
      break;
    if ( !v2 )
      return 0;
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(volatile signed __int32 **)(a1 + 0x10);
  if ( !v6 )
    return *(_QWORD *)(a1 + 8);
  if ( _InterlockedExchangeAdd(v6 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v6)(v6);
    if ( _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
  }
  return v5;
}

// --- End Function: sub_14030ED10 (0x14030ED10) ---

// --- Function: sub_140320320 (0x140320320) ---
_QWORD *sub_140320320()
{
  if ( (dword_149B3B2F8 & 1) == 0 )
  {
    dword_149B3B2F8 |= 1u;
    sub_14035B3E0(&unk_149B3B2F0);
    atexit(sub_1480BC650);
  }
  return &unk_149B3B2F0;
}

// --- End Function: sub_140320320 (0x140320320) ---

// --- Function: sub_140323650 (0x140323650) ---
__int64 __fastcall sub_140323650(__int64 a1)
{
  __int64 result; // rax
  volatile signed __int32 *v3; // rcx

  result = 0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  v3 = *(volatile signed __int32 **)(a1 + 0x18);
  *(_QWORD *)(a1 + 0x18) = 0;
  if ( v3 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v3 + 3, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8LL))(v3);
  }
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  return result;
}

// --- End Function: sub_140323650 (0x140323650) ---

// --- Function: sub_1403236A0 (0x1403236A0) ---
void __fastcall sub_1403236A0(__int64 *a1, char a2)
{
  __int64 v3; // rax
  void (__fastcall *v4)(__int64 *, __int64, __int64 (__fastcall **)(__int64, __int64)); // rbx
  __int64 v5; // rax
  volatile signed __int32 *v6; // rcx
  __int64 (__fastcall *p_sub_140305E90)(__int64, __int64); // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 n2; // [rsp+28h] [rbp-20h]
  __int64 v9; // [rsp+30h] [rbp-18h]

  if ( a2 )
  {
    v3 = *a1;
    p_sub_140305E90 = sub_140305E90;
    v9 = 0;
    v4 = *(void (__fastcall **)(__int64 *, __int64, __int64 (__fastcall **)(__int64, __int64)))(v3 + 8);
    n2 = 1;
    v5 = (*(__int64 (__fastcall **)(__int64 *))(v3 + 0x10))(a1);
    v4(a1, v5, &p_sub_140305E90);
    if ( n2 >= 2 )
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))n2)(2, &p_sub_140305E90);
  }
  v6 = (volatile signed __int32 *)a1[3];
  *((_BYTE *)a1 + 0xC) = 0;
  a1[2] = 0;
  a1[3] = 0;
  if ( v6 && _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
  *((_DWORD *)a1 + 2) = 0xFFFFFFFF;
}

// --- End Function: sub_1403236A0 (0x1403236A0) ---

// --- Function: sub_140323750 (0x140323750) ---
void __fastcall sub_140323750(__int64 *a1, char a2)
{
  *((_WORD *)a1 + 0x20) = 0xFFFF;
  sub_1403236A0(a1, a2);
}

// --- End Function: sub_140323750 (0x140323750) ---

// --- Function: map_flag_to_mask (0x140324A20) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 n24576)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( n24576 > 0x8000u )
  {
    if ( n24576 == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( n24576 != 0xC000 )
        return 0;
    }
  }
  else
  {
    switch ( n24576 )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( n24576 == 24576 )
          return 0x4000000;
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140324A20) ---

// --- Function: sub_1403297E0 (0x1403297E0) ---
_QWORD *__fastcall sub_1403297E0(__int64 a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 0x20);
  return a2;
}

// --- End Function: sub_1403297E0 (0x1403297E0) ---

// --- Function: sub_1403302D0 (0x1403302D0) ---
__int64 __fastcall sub_1403302D0(__int64 a1, char a2)
{
  __int64 v4; // rcx
  __int64 result; // rax
  bool v6; // zf
  __int64 v7; // rax

  v4 = *(_QWORD *)(a1 + 0x18);
  result = *(unsigned __int8 *)(a1 + 0x2A);
  if ( v4 && *(_DWORD *)(v4 + 8) )
  {
    if ( !(_BYTE)result || a2 )
    {
      v6 = *(_BYTE *)(a1 + 0x2B) == 0;
      *(_BYTE *)(a1 + 0x2A) = 1;
      if ( !v6 )
      {
        v7 = sub_14030ED10(a1 + 8);
        result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 0x18LL))(v7, *(unsigned int *)(a1 + 8));
      }
      goto LABEL_10;
    }
  }
  else if ( !(_BYTE)result || a2 )
  {
    *(_BYTE *)(a1 + 0x2A) = 1;
LABEL_10:
    if ( a2 )
      *(_BYTE *)(a1 + 0x29) = 0;
  }
  return result;
}

// --- End Function: sub_1403302D0 (0x1403302D0) ---

// --- Function: sub_1403318F0 (0x1403318F0) ---
__int64 __fastcall sub_1403318F0(__int64 *a1)
{
  __int64 v1; // rax
  void (__fastcall *v3)(__int64 *, __int64, __int64 (__fastcall **)(__int64)); // rbx
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rax
  __int64 v7; // rdx
  bool v8; // zf
  __int64 v9; // rax
  __int64 (__fastcall *p_sub_140305E80)(__int64); // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 n2; // [rsp+28h] [rbp-20h]
  __int64 v12; // [rsp+30h] [rbp-18h]

  v1 = *a1;
  v12 = 0;
  p_sub_140305E80 = sub_140305E80;
  n2 = 1;
  v3 = *(void (__fastcall **)(__int64 *, __int64, __int64 (__fastcall **)(__int64)))(v1 + 8);
  v4 = (*(__int64 (__fastcall **)(__int64 *))(v1 + 0x10))(a1);
  v3(a1, v4, &p_sub_140305E80);
  if ( n2 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64)))n2)(2, &p_sub_140305E80);
  result = a1[3];
  if ( result && *(_DWORD *)(result + 8) )
  {
    v6 = sub_14030ED10((__int64)(a1 + 1));
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v6 + 0x30LL))(v6, a1);
    LOBYTE(v7) = 1;
    (*(void (__fastcall **)(__int64 *, __int64))(*a1 + 0x38))(a1, v7);
    result = a1[3];
    if ( result && *(_DWORD *)(result + 8) )
    {
      v8 = *((_BYTE *)a1 + 0x2B) == 0;
      *((_BYTE *)a1 + 0x2A) = 1;
      if ( !v8 )
      {
        v9 = sub_14030ED10((__int64)(a1 + 1));
        result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + 0x18LL))(v9, *((unsigned int *)a1 + 2));
      }
      *((_BYTE *)a1 + 0x29) = 0;
    }
    else
    {
      *(_WORD *)((char *)a1 + 0x29) = 0x100;
    }
  }
  return result;
}

// --- End Function: sub_1403318F0 (0x1403318F0) ---

// --- Function: sub_1403319D0 (0x1403319D0) ---
__int64 __fastcall sub_1403319D0(__int64 *a1)
{
  *((_WORD *)a1 + 0x20) = 0xFFFF;
  return sub_1403318F0(a1);
}

// --- End Function: sub_1403319D0 (0x1403319D0) ---

// --- Function: sub_140333220 (0x140333220) ---
__int64 __fastcall sub_140333220(_QWORD *a1)
{
  volatile signed __int32 *v1; // rdx
  __int64 result; // rax

  v1 = (volatile signed __int32 *)a1[1];
  result = 0;
  *a1 = 0;
  a1[1] = 0;
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
  }
  return result;
}

// --- End Function: sub_140333220 (0x140333220) ---

// --- Function: sub_140351340 (0x140351340) ---
signed __int64 __fastcall sub_140351340(volatile signed __int64 *a1, void **a2)
{
  void **v4; // rbx
  _BYTE *v5; // rdx
  unsigned __int64 Size; // rax
  signed __int64 v7; // rsi

  if ( *a1 )
    return *a1;
  v4 = (void **)allocWithProfilerInfo_w(8u);
  if ( v4 )
  {
    *v4 = (char *)&qword_149B3B33C + 4;
    v5 = *a2;
    if ( *a2 )
    {
      Size = 0xFFFFFFFFFFFFFFFFuLL;
      do
        ++Size;
      while ( v5[Size] );
      sub_1403DE230(v4, v5, (int)Size);
    }
    else
    {
      sub_1403DE230(v4, 0, 0);
    }
  }
  else
  {
    v4 = 0;
  }
  v7 = _InterlockedCompareExchange64(a1, (signed __int64)v4, 0);
  if ( !v7 )
    return *a1;
  if ( v4 )
  {
    if ( *((int *)*v4 + 0xFFFFFFFF) > 0 )
      sub_147605980((char *)*v4 + 0xFFFFFFF8);
    sub_1402A3D30(v4);
  }
  return v7;
}

// --- End Function: sub_140351340 (0x140351340) ---

// --- Function: sub_1403515F0 (0x1403515F0) ---
char __fastcall sub_1403515F0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v10; // [rsp+18h] [rbp-88h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-70h] BYREF
  __int16 n256; // [rsp+88h] [rbp-18h]
  __int64 n176; // [rsp+90h] [rbp-10h]
  __int64 n168; // [rsp+98h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  LODWORD(v10) = a6;
  n256 = 256;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[10] = -1;
  n176 = 176;
  n168 = 168;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 1u, a5, v10, a7, a8);
}

// --- End Function: sub_1403515F0 (0x1403515F0) ---

// --- Function: sub_140351BB0 (0x140351BB0) ---
char __fastcall sub_140351BB0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int64 v11; // rax
  const char *p_null; // rdx
  __int64 v14; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v19; // [rsp+A0h] [rbp-70h]
  GUID **p_GUID; // [rsp+A8h] [rbp-68h]
  __int64 v21; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+C0h] [rbp-50h]
  __int64 v24; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v26; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4E80)(const void **); // [rsp+E0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v29; // [rsp+F0h] [rbp-20h]
  char v30; // [rsp+F8h] [rbp-18h]
  char v31; // [rsp+F9h] [rbp-17h]
  __int64 n0x18; // [rsp+100h] [rbp-10h]
  unsigned __int64 v33; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  p_GUID = "GUID";
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  v19 = a10;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v31 = 0;
  v21 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v24 = 0;
  v26 = 0;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v30 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  do
    ++v11;
  while ( p_null[v11] );
  v33 = v11;
  LODWORD(v14) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 2u, a5, v14, a7, a8);
}

// --- End Function: sub_140351BB0 (0x140351BB0) ---

// --- Function: sub_140357960 (0x140357960) ---
__int64 __fastcall sub_140357960(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v3; // rax
  const char *p_null_2; // rcx
  const char *p_null; // rdx
  const char *p_null_1; // r8
  unsigned __int64 v9; // rcx

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Text";
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_2 = (const char *)a2[1];
  p_null = "null";
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v9 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v9;
  while ( p_null_1[v9] );
  *(_QWORD *)(a1 + 0x68) = v9;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Text";
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  if ( a3[1] )
    p_null = (const char *)a3[1];
  do
    ++v3;
  while ( p_null[v3] );
  *(_QWORD *)(a1 + 0xD8) = v3;
  return 2;
}

// --- End Function: sub_140357960 (0x140357960) ---

// --- Function: sub_14035AA80 (0x14035AA80) ---
__int64 __fastcall sub_14035AA80(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // rbx
  int v6; // r11d
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rax
  char *v11; // r9
  char *v12; // rcx
  __int64 v13; // r10
  char v14; // dl
  char v15; // r8

  v4 = a1 + a3;
  v5 = a2 - a3;
  if ( a4 >= 0 )
  {
    v6 = 0;
  }
  else if ( v5 )
  {
    *(_BYTE *)v4 = 45;
    v6 = 1;
    a4 = -a4 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = -1;
  }
  v7 = v6;
  v8 = v6;
  do
  {
    v9 = v6;
    if ( v6 >= (int)v5 || v8 < 0 )
      return 0xFFFFFFFFLL;
    ++v6;
    v10 = a4 % 10;
    a4 /= 10;
    *(_BYTE *)(v8 + v4) = v10 + 48;
    ++v8;
  }
  while ( a4 );
  if ( v7 < v9 )
  {
    v11 = (char *)(v9 + v4);
    v12 = (char *)(v7 + v4);
    v13 = -v4;
    do
    {
      v14 = *v11--;
      v15 = *v12;
      *v12++ = v14;
      v11[1] = v15;
    }
    while ( (__int64)&v12[v13] < (__int64)&v11[v13] );
  }
  return (unsigned int)v6;
}

// --- End Function: sub_14035AA80 (0x14035AA80) ---

// --- Function: CreateStringObjectFromString (0x14035B2C0) ---
// Creates a managed string object from a null-terminated C-style string.
// Allocates memory to hold metadata (length, capacity) and the string data. The
// returned pointer points to the string data, with metadata stored immediately
// before it.  Memory Layout: `[DWORD length] [DWORD capacity] [char data...] [char
// '\0']`  @param ppStringObjectData Output parameter; receives the pointer to the
// string data within the newly created object. @param pszInputString The null-
// terminated C-style string to copy. @return Returns the `ppStringObjectData`
// pointer.
void **CreateStringObjectFromString(void **a1, const char *a2, ...)
{
  unsigned __int64 Size; // rbx
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  if ( !a2 )
    return a1;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( a2[Size] );
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo((int)Size + 9LL, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + (int)Size) = 0;
    if ( *a1 != a2 )
      memcpy(*a1, a2, (int)Size);
  }
  return a1;
}

// --- End Function: CreateStringObjectFromString (0x14035B2C0) ---

// --- Function: sub_14035B3E0 (0x14035B3E0) ---
void __fastcall sub_14035B3E0(_QWORD *a1)
{
  *a1 = (char *)&qword_149B3B33C + 4;
}

// --- End Function: sub_14035B3E0 (0x14035B3E0) ---

// --- Function: sub_14035B5F0 (0x14035B5F0) ---
_QWORD *__fastcall sub_14035B5F0(_QWORD *a1)
{
  *a1 = &unk_149B3E478;
  return a1;
}

// --- End Function: sub_14035B5F0 (0x14035B5F0) ---

// --- Function: sub_14035BF60 (0x14035BF60) ---
_OWORD *__fastcall sub_14035BF60(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_14035BF60 (0x14035BF60) ---

// --- Function: sub_14035F010 (0x14035F010) ---
_QWORD *__fastcall sub_14035F010(_QWORD *a1, unsigned __int8 **a2)
{
  void **v4; // rax
  _QWORD *v5; // rax
  __int64 v6; // rdx
  unsigned __int8 *v7; // r8
  __int64 v8; // r9
  int v9; // eax
  int v10; // ecx
  __int64 v11; // rax

  *a1 = &unk_149B3E478;
  v4 = (void **)sub_1403AE5D0();
  v5 = (_QWORD *)sub_140351340(&unk_149B3E230, v4);
  v7 = *a2;
  v8 = *v5 - (_QWORD)*a2;
  do
  {
    v9 = v7[v8];
    v10 = *v7 - v9;
    if ( v10 )
      break;
    ++v7;
  }
  while ( v9 );
  if ( v10 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 *))(*(_QWORD *)qword_149B4FCA0 + 0x4E0LL))(
            qword_149B4FCA0,
            v6,
            v7);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD *, _QWORD))(*(_QWORD *)v11 + 0xA8LL))(v11, *a2, a1, 0);
  }
  return a1;
}

// --- End Function: sub_14035F010 (0x14035F010) ---

// --- Function: sub_14036A710 (0x14036A710) ---
_QWORD *__fastcall sub_14036A710(_QWORD *a1, __int64 a2)
{
  *a1 = off_1481ABEC0;
  a1[1] = off_1481ABE90;
  a1[2] = 0;
  a1[2] = 0x2710LL * *(_QWORD *)(a2 + 8);
  return a1;
}

// --- End Function: sub_14036A710 (0x14036A710) ---

// --- Function: sub_14036A7C0 (0x14036A7C0) ---
_QWORD *__fastcall sub_14036A7C0(_QWORD *a1)
{
  *a1 = off_1481ABEC0;
  a1[1] = off_1481ABE90;
  a1[2] = 0;
  return a1;
}

// --- End Function: sub_14036A7C0 (0x14036A7C0) ---

// --- Function: sub_14036A800 (0x14036A800) ---
_QWORD *__fastcall sub_14036A800(_QWORD *a1, __int64 a2)
{
  a1[1] = a2;
  *a1 = &off_1481B0288;
  return a1;
}

// --- End Function: sub_14036A800 (0x14036A800) ---

// --- Function: sub_14036D890 (0x14036D890) ---
_QWORD *__fastcall sub_14036D890(_QWORD *a1, __int64 a2)
{
  a1[1] = a2;
  *a1 = off_1481ABE90;
  return a1;
}

// --- End Function: sub_14036D890 (0x14036D890) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___ (0x140372330) ---
__int64 __fastcall std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___(
        const void **a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    if ( (unsigned __int64)(0x30 * (((_BYTE *)a1[2] - (_BYTE *)v2) / 0x30)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v2 = (_QWORD *)v2[0xFFFFFFFF];
    }
    sub_1402A3D30(v2);
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

// --- End Function: std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___ (0x140372330) ---

// --- Function: copyStringStructure (0x140377F40) ---
// Copies the string data from the source structure `a2` to the destination
// structure `a1`. Ensures the destination buffer `*a1` is large enough (using
// `sub_1403E4C30`) and copies the content from `*a2`.
char **__fastcall copyStringStructure(char **a1, char **a2)
{
  unsigned __int64 Size; // rdi

  Size = *((int *)*a2 + 0xFFFFFFFE);
  sub_1403E9810(a1, Size, 0x20);
  if ( Size && *a1 != *a2 )
    memcpy(*a1, *a2, Size);
  return a1;
}

// --- End Function: copyStringStructure (0x140377F40) ---

// --- Function: sub_140378020 (0x140378020) ---
void **__fastcall sub_140378020(void **a1, const void **a2)
{
  unsigned __int64 v4; // rdi

  v4 = *((int *)*a2 + 0xFFFFFFFE);
  sub_1403E98E0(a1, v4, 0x20);
  if ( v4 && *a1 != *a2 )
    memcpy(*a1, *a2, 2 * v4);
  return a1;
}

// --- End Function: sub_140378020 (0x140378020) ---

// --- Function: sub_14037F680 (0x14037F680) ---
bool __fastcall sub_14037F680(unsigned __int16 **a1, _QWORD *a2)
{
  unsigned __int16 *v2; // rax
  __int64 v3; // r8
  int v4; // ecx
  int v5; // edx

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  do
  {
    v4 = *(unsigned __int16 *)((char *)v2 + v3);
    v5 = *v2 - v4;
    if ( v5 )
      break;
    ++v2;
  }
  while ( v4 );
  return v5 != 0;
}

// --- End Function: sub_14037F680 (0x14037F680) ---

// --- Function: sub_14037FC70 (0x14037FC70) ---
const ULONG_PTR *__fastcall sub_14037FC70(__int64 a1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)a1 )
    return *(const ULONG_PTR **)a1;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14037FC70 (0x14037FC70) ---

// --- Function: check_thread_list_contains_value (0x140391DB0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rax
  char *v4; // r10
  char *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r8
  char v9; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) )
    return 0;
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &v9);
  v4 = *(char **)(v2 + 24);
  v5 = *(char **)(v2 + 16);
  v6 = *v3;
  v7 = (v4 - v5) >> 4;
  while ( v7 )
  {
    if ( *(_QWORD *)&v5[16 * (v7 >> 1)] >= v6 )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += 16 * (v7 >> 1) + 16;
      v7 += -1LL - (v7 >> 1);
    }
  }
  if ( v5 == v4 )
    return 0;
  if ( v6 < *(_QWORD *)v5 )
    v5 = *(char **)(v2 + 24);
  return v5 != v4;
}

// --- End Function: check_thread_list_contains_value (0x140391DB0) ---

// --- Function: check_thread_state_and_value_not_equal (0x140391E70) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *a1)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  return v2 && *(_DWORD *)(v2 + 8) == 1 && *a1 != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x140391E70) ---

// --- Function: validate_access_with_virtual_calls (0x140391EB0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 v2; // rax
  __int64 gEnv; // rdi
  __int64 (__fastcall *v4)(__int64, _QWORD); // rbx
  _QWORD *v5; // rax
  char v7; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)NtCurrentTeb_w() )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
  if ( !v2 || *(_DWORD *)(v2 + 8) || !is_illegal_entity_access_check_enabled() )
    return 1;
  gEnv = ::gEnv;
  v4 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::gEnv + 984LL);
  v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                   payload_ptr_state2,
                   &v7);
  return v4(gEnv, *v5);
}

// --- End Function: validate_access_with_virtual_calls (0x140391EB0) ---

// --- Function: sub_140392020 (0x140392020) ---
char __fastcall sub_140392020(_QWORD *a1)
{
  _QWORD *payload_ptr_state1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax

  payload_ptr_state1 = (_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL);
  if ( (*a1 & 0xF000000000000000uLL) != 0 )
    v2 = *a1 & 0xFFFFFF000000LL;
  else
    v2 = (__int64)payload_ptr_state1 - 6;
  if ( !*(_WORD *)(v2 + 4) )
    return 0;
  if ( *(_WORD *)(v2 + 4) == 1 )
    return check_thread_list_contains_value((__int64)payload_ptr_state1);
  if ( *(_WORD *)(v2 + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(v2 + 4) - 3 <= 1 )
    {
      v3 = *(_QWORD *)(*(_QWORD *)(NtCurrentTeb_w() + 16) + 8LL);
      if ( v3 )
      {
        if ( *(_DWORD *)(v3 + 8) == 1 )
          return *payload_ptr_state1 != 0x13374770CLL;
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(NtCurrentTeb_w() + 301) || sub_140539D80() )
    return 1;
  else
    return validate_access_with_virtual_calls((__int64)payload_ptr_state1);
}

// --- End Function: sub_140392020 (0x140392020) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403AE5D0 (0x1403AE5D0) ---
__int64 sub_1403AE5D0()
{
  __int64 result; // rax
  _QWORD *v1; // rcx
  signed __int64 v2; // rbx

  result = qword_149B3E248;
  if ( !qword_149B3E248 )
  {
    v1 = (_QWORD *)allocWithProfilerInfo_w(8u);
    if ( v1 )
      *v1 = "@LOC_EMPTY";
    else
      v1 = 0;
    v2 = _InterlockedCompareExchange64(&qword_149B3E248, (signed __int64)v1, 0);
    if ( v2 )
    {
      sub_1402A3D30(v1);
      return v2;
    }
    else
    {
      return qword_149B3E248;
    }
  }
  return result;
}

// --- End Function: sub_1403AE5D0 (0x1403AE5D0) ---

// --- Function: sub_1403AF3B0 (0x1403AF3B0) ---
__m128 sub_1403AF3B0()
{
  __int128 v3; // kr00_16

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, qword ptr [rcx+10h] }
  *((_QWORD *)&v3 + 1) = *((_QWORD *)&_XMM0 + 1);
  *(double *)&v3 = *(double *)&_XMM0 * 0.000001;
  return (__m128)v3;
}

// --- End Function: sub_1403AF3B0 (0x1403AF3B0) ---

// --- Function: sub_1403B0A40 (0x1403B0A40) ---
__int64 __fastcall sub_1403B0A40(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: sub_1403B0A40 (0x1403B0A40) ---

// --- Function: sub_1403B0A70 (0x1403B0A70) ---
_QWORD *__fastcall sub_1403B0A70(unsigned __int64 *a1, _QWORD *a2)
{
  if ( sub_14030EC00(a1) )
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  else
    *a2 = 0;
  return a2;
}

// --- End Function: sub_1403B0A70 (0x1403B0A70) ---

// --- Function: sub_1403B3D00 (0x1403B3D00) ---
__int64 *__fastcall sub_1403B3D00(__int64 a1)
{
  __int64 (__fastcall ***v2)(_QWORD, __int64); // rax
  __int64 v3; // rax

  v2 = (__int64 (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0
                                                                                     + 0x240LL))(qword_149B4FCA0);
  v3 = (**v2)(v2, a1);
  if ( v3 )
    return (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x10LL))(v3);
  if ( (dword_149B3E068 & 1) == 0 )
  {
    dword_149B3E068 |= 1u;
    qword_149B3E060 = (__int64)&qword_149B3B33C + 4;
    atexit(sub_1480BD370);
  }
  return &qword_149B3E060;
}

// --- End Function: sub_1403B3D00 (0x1403B3D00) ---

// --- Function: sub_1403B4B50 (0x1403B4B50) ---
__int64 __fastcall sub_1403B4B50(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)gEnv + 296LL))(gEnv, a1, 0);
}

// --- End Function: sub_1403B4B50 (0x1403B4B50) ---

// --- Function: sub_1403B6AB0 (0x1403B6AB0) ---
__m128 sub_1403B6AB0()
{
  __m128 result; // xmm0

  _XMM0 = 0;
  __asm { vcvtsi2sd xmm0, xmm0, rax }
  return result;
}

// --- End Function: sub_1403B6AB0 (0x1403B6AB0) ---

// --- Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---
// Checks if the 'es_check_illegal_entity_access_spawning' feature flag is enabled
// (state > 1). Retrieves the flag state using virtual calls on global objects
// (`qword_14981D2B0`, etc.) on the first call and caches the result (1 for state
// <= 1, 2 for state > 1). Returns true if the cached state is 2.
bool is_illegal_entity_access_check_enabled()
{
  char n2; // al
  __int64 v1; // rax
  bool v2; // cc

  n2 = byte_149B3DFC8;
  if ( !byte_149B3DFC8 )
  {
    v1 = (*(__int64 (__fastcall **)(Parameter *, const char *))(*(_QWORD *)qword_149B4FC90 + 192LL))(
           qword_149B4FC90,
           "es_check_illegal_entity_access_spawning");
    if ( !v1 || (v2 = (*(int (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1) <= 1, n2 = 2, v2) )
      n2 = 1;
    byte_149B3DFC8 = n2;
  }
  return n2 == 2;
}

// --- End Function: is_illegal_entity_access_check_enabled (0x1403D6A90) ---

// --- Function: sub_1403DE0C0 (0x1403DE0C0) ---
char *__fastcall sub_1403DE0C0(char **a1, __int64 a2)
{
  char *result; // rax
  __int64 v5; // rax

  if ( a2 )
  {
    v5 = allocWithProfilerInfo(a2 + 9, 0);
    *a1 = (char *)(v5 + 8);
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v5 + 4) = a2;
    result = *a1;
    (*a1)[a2] = 0;
  }
  else
  {
    result = (char *)&qword_149B3B33C + 4;
    *a1 = (char *)&qword_149B3B33C + 4;
  }
  return result;
}

// --- End Function: sub_1403DE0C0 (0x1403DE0C0) ---

// --- Function: sub_1403DE120 (0x1403DE120) ---
_WORD *__fastcall sub_1403DE120(void **a1, __int64 a2)
{
  _WORD *result; // rax
  _DWORD *v5; // rax

  if ( a2 )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(2 * a2 + 0xA, 0);
    *a1 = v5 + 2;
    *v5 = a2;
    v5[1] = a2;
    result = *a1;
    *((_WORD *)*a1 + a2) = 0;
  }
  else
  {
    result = &unk_149B3E478;
    *a1 = &unk_149B3E478;
  }
  return result;
}

// --- End Function: sub_1403DE120 (0x1403DE120) ---

// --- Function: sub_1403DE230 (0x1403DE230) ---
void *__fastcall sub_1403DE230(void **a1, void *a2, size_t Size)
{
  _BYTE *v5; // rcx
  int *v7; // rcx
  _DWORD *v8; // rax
  void *result; // rax

  v5 = *a1;
  if ( Size > *((int *)v5 - 1) )
  {
    v7 = (int *)(v5 - 8);
    if ( v7[1] > 0 )
      sub_147605980(v7);
    *a1 = (char *)&qword_149B3B33C + 4;
    if ( Size )
    {
      v8 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
      *a1 = v8 + 2;
      *v8 = Size;
      v8[1] = Size;
      *((_BYTE *)*a1 + Size) = 0;
    }
  }
  if ( *a1 != a2 )
    memcpy(*a1, a2, Size);
  *((_DWORD *)*a1 - 2) = Size;
  result = *a1;
  *((_BYTE *)*a1 + Size) = 0;
  return result;
}

// --- End Function: sub_1403DE230 (0x1403DE230) ---

// --- Function: sub_1403E4780 (0x1403E4780) ---
__int64 __fastcall sub_1403E4780(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E4780 (0x1403E4780) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 sub_1403E4B50()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4B90 (0x1403E4B90) ---
_QWORD *__fastcall sub_1403E4B90(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A3D30(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)allocWithProfilerInfo_w(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E4B90 (0x1403E4B90) ---

// --- Function: sub_1403E4C70 (0x1403E4C70) ---
__int64 __fastcall sub_1403E4C70(__int64 a1)
{
  __int64 result; // rax

  result = allocWithProfilerInfo_w(0x18u);
  if ( result )
  {
    *(_OWORD *)result = *(_OWORD *)a1;
    *(double *)(result + 16) = *(double *)(a1 + 16);
  }
  return result;
}

// --- End Function: sub_1403E4C70 (0x1403E4C70) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
__int64 __fastcall sub_1403E4E60(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4E80 (0x1403E4E80) ---
__int64 __fastcall sub_1403E4E80(const void **a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_1402A3D30(a1[2]);
    return sub_1402A3D30(a1);
  }
  return result;
}

// --- End Function: sub_1403E4E80 (0x1403E4E80) ---

// --- Function: sub_1403E4EB0 (0x1403E4EB0) ---
__int64 __fastcall sub_1403E4EB0(const void *a1)
{
  return sub_1402A3D30(a1);
}

// --- End Function: sub_1403E4EB0 (0x1403E4EB0) ---

// --- Function: sub_1403E5570 (0x1403E5570) ---
bool __fastcall sub_1403E5570(_QWORD *a1)
{
  return !*a1 || !*(_BYTE *)*a1;
}

// --- End Function: sub_1403E5570 (0x1403E5570) ---

// --- Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---
bool __fastcall std::error_category::operator==(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
}

// --- End Function: ??8error_category@std@@QEBA_NAEBV01@@Z (0x1403E7640) ---

// --- Function: sub_1403E7650 (0x1403E7650) ---
bool __fastcall sub_1403E7650(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E7650 (0x1403E7650) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403E9810 (0x1403E9810) ---
void __fastcall sub_1403E9810(char **a1, unsigned __int64 a2, char Val)
{
  char *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
      return;
    *((_DWORD *)v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
    return;
  if ( a2 <= *((int *)v3 - 1) )
  {
    memset(&v3[v6], Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    (*a1)[*((int *)*a1 - 2)] = 0;
    return;
  }
  sub_1403DE0C0(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, *((int *)v3 - 2));
  memset(&(*a1)[*((int *)v3 - 2)], Val_1, Size);
  if ( *((int *)v3 - 1) > 0 )
    sub_147605980(v3 - 8);
}

// --- End Function: sub_1403E9810 (0x1403E9810) ---

// --- Function: sub_1403E98E0 (0x1403E98E0) ---
void __fastcall sub_1403E98E0(void **a1, unsigned __int64 a2, __int16 a3)
{
  _WORD *v3; // rdi
  unsigned __int64 v5; // r9
  int *v6; // rsi
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  _WORD *v10; // rdi
  _WORD *v11; // rdi
  unsigned __int64 i; // rcx

  v3 = *a1;
  v5 = *((int *)*a1 + 0xFFFFFFFE);
  v6 = (int *)((char *)*a1 + 0xFFFFFFF8);
  if ( a2 <= v5 )
  {
    if ( a2 >= v5 )
      return;
    *v6 = a2;
    goto LABEL_17;
  }
  v8 = a2 - v5;
  if ( a2 == v5 )
    return;
  if ( a2 <= *((int *)v3 + 0xFFFFFFFF) )
  {
    v11 = &v3[v5];
    for ( i = a2 - v5; i; --i )
      *v11++ = a3;
    *((_DWORD *)*a1 + 0xFFFFFFFE) = a2;
LABEL_17:
    *((_WORD *)*a1 + *((int *)*a1 + 0xFFFFFFFE)) = 0;
    return;
  }
  sub_1403DE120(a1, a2);
  if ( *a1 != v3 )
    memcpy(*a1, v3, 2LL * *v6);
  v9 = v8;
  v10 = (char *)*a1 + 2 * *v6;
  while ( v9 )
  {
    *v10++ = a3;
    --v9;
  }
  if ( v6[1] > 0 )
    sub_147605980(v6);
}

// --- End Function: sub_1403E98E0 (0x1403E98E0) ---

// --- Function: sub_1403EAFB0 (0x1403EAFB0) ---
__int64 __fastcall sub_1403EAFB0(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v6; // eax
  unsigned __int64 v7; // rbp
  int v8; // ebp
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx

  if ( *(_BYTE *)(a1 + 16) )
  {
    if ( a3 > 1 )
    {
      if ( a2 )
      {
        *a2 = 34;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      v6 = sub_14035AA80((__int64)a2, a3, 1, *(_QWORD *)(a1 + 8));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if ( a3 <= 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    *a2 = 34;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
  v6 = sub_1402FE6B0((__int64)a2, a3, 1, v7);
LABEL_12:
  v8 = v6;
  if ( v6 < 0 )
    return 0xFFFFFFFFLL;
  v9 = v6 + 1LL;
  if ( v6 + 2LL >= a3 )
    return 0xFFFFFFFFLL;
  v10 = a3 - v9;
  if ( &a2[v9] )
  {
    if ( v10 )
    {
      a2[v9] = 34;
    }
    else
    {
      *errno() = 34;
      invalid_parameter_noinfo();
    }
    return (unsigned int)(v8 + 2);
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return (unsigned int)(v8 + 2);
  }
}

// --- End Function: sub_1403EAFB0 (0x1403EAFB0) ---

// --- Function: sub_1403EB0E0 (0x1403EB0E0) ---
__int64 __fastcall sub_1403EB0E0(__int64 a1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EB0E0 (0x1403EB0E0) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n12; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n12 = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 = 12;
      if ( (int)n12_1 <= 12 )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n12 + a2), n12_1 - (unsigned int)n12);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v8;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n12);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 19);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 19;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v10;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n12;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 574235236;
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n12 += v12;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n12 <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n12);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 18);
      }
      else
      {
        *errno() = 22;
        invalid_parameter_noinfo();
      }
      n12 += 18;
      if ( n12 >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n12 + a2), n12_1 - n12);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n12 += v14;
    if ( n12 < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n12 <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n12);
        if ( v15 )
        {
          *v15 = 32034;
        }
        else
        {
          *errno() = 22;
          invalid_parameter_noinfo();
        }
        n12 += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return (unsigned int)-1;
  return (unsigned int)n12;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB550 (0x1403EB550) ---
__int64 __fastcall sub_1403EB550(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9

  v3 = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 16) )
    return sub_14035AA80(a2, a3, 0, v3);
  else
    return sub_1402FE6B0(a2, a3, 0, v3);
}

// --- End Function: sub_1403EB550 (0x1403EB550) ---

// --- Function: sub_1403EB580 (0x1403EB580) ---
__int64 __fastcall sub_1403EB580(__int64 a1, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB580 (0x1403EB580) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: sub_140441C40 (0x140441C40) ---
char __fastcall sub_140441C40(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v15; // rsp
  __int64 v17; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  __int64 v22; // [rsp+A0h] [rbp-E0h] BYREF

  v15 = alloca(0x150);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_1404496D0((__int64)&v22, a10, a11);
  LODWORD(v17) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 3u, a5, v17, a7, a8);
}

// --- End Function: sub_140441C40 (0x140441C40) ---

// --- Function: sub_140442EF0 (0x140442EF0) ---
char __fastcall sub_140442EF0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int64 v11; // rax
  const char *p_null; // rdx
  __int64 v14; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v19; // [rsp+A0h] [rbp-70h]
  const char *p_Function; // [rsp+A8h] [rbp-68h]
  __int64 v21; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+C0h] [rbp-50h]
  __int64 v24; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v26; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4E80)(const void **); // [rsp+E0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v29; // [rsp+F0h] [rbp-20h]
  char v30; // [rsp+F8h] [rbp-18h]
  char v31; // [rsp+F9h] [rbp-17h]
  __int64 n0x18; // [rsp+100h] [rbp-10h]
  unsigned __int64 v33; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  p_Function = "Function";
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  v19 = a10;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v31 = 1;
  v21 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v24 = 0;
  v26 = 0;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v30 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  do
    ++v11;
  while ( p_null[v11] );
  v33 = v11;
  LODWORD(v14) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 2u, a5, v14, a7, a8);
}

// --- End Function: sub_140442EF0 (0x140442EF0) ---

// --- Function: sub_1404439B0 (0x1404439B0) ---
char __fastcall sub_1404439B0(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int64 v11; // rax
  const char *p_null; // rdx
  __int64 v14; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v19; // [rsp+A0h] [rbp-70h]
  const char *p_Name; // [rsp+A8h] [rbp-68h]
  __int64 v21; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+C0h] [rbp-50h]
  __int64 v24; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v26; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4E80)(const void **); // [rsp+E0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v29; // [rsp+F0h] [rbp-20h]
  char v30; // [rsp+F8h] [rbp-18h]
  char v31; // [rsp+F9h] [rbp-17h]
  __int64 n0x18; // [rsp+100h] [rbp-10h]
  unsigned __int64 v33; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  p_Name = "Name";
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  v19 = a10;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v31 = 0;
  v21 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v24 = 0;
  v26 = 0;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v30 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  do
    ++v11;
  while ( p_null[v11] );
  v33 = v11;
  LODWORD(v14) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 2u, a5, v14, a7, a8);
}

// --- End Function: sub_1404439B0 (0x1404439B0) ---

// --- Function: sub_140444D10 (0x140444D10) ---
char __fastcall sub_140444D10(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10)
{
  unsigned __int64 v11; // rax
  const char *p_null; // rdx
  __int64 v14; // [rsp+18h] [rbp-F8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-E0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-88h]
  __int64 n0xB0; // [rsp+90h] [rbp-80h]
  __int64 n0xA8; // [rsp+98h] [rbp-78h]
  _QWORD *v19; // [rsp+A0h] [rbp-70h]
  const char *p_Text; // [rsp+A8h] [rbp-68h]
  __int64 v21; // [rsp+B0h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+B8h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+C0h] [rbp-50h]
  __int64 v24; // [rsp+C8h] [rbp-48h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+D0h] [rbp-40h]
  __int64 v26; // [rsp+D8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4E80)(__int64); // [rsp+E0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+E8h] [rbp-28h]
  unsigned __int64 v29; // [rsp+F0h] [rbp-20h]
  char v30; // [rsp+F8h] [rbp-18h]
  char v31; // [rsp+F9h] [rbp-17h]
  __int64 n0x18; // [rsp+100h] [rbp-10h]
  unsigned __int64 v33; // [rsp+108h] [rbp-8h]

  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  p_Text = "Text";
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  v19 = a10;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v11 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v31 = 0;
  v21 = *a10;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v24 = 0;
  v26 = 0;
  v29 = 0xFFFFFFFFFFFFFFFFuLL;
  v30 = 0;
  n0x18 = 0x18;
  p_null = "null";
  if ( a10[1] )
    p_null = (const char *)a10[1];
  do
    ++v11;
  while ( p_null[v11] );
  v33 = v11;
  LODWORD(v14) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 2u, a5, v14, a7, a8);
}

// --- End Function: sub_140444D10 (0x140444D10) ---

// --- Function: sub_1404496D0 (0x1404496D0) ---
__int64 __fastcall sub_1404496D0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v3; // rax
  const char *p_null; // rdx

  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 8) = "EntityId";
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB550;
  *(_QWORD *)(a1 + 0x20) = sub_1403EAFB0;
  *(_QWORD *)(a1 + 0x30) = std::error_category::operator==;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4EB0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4C70;
  v3 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  *(_QWORD *)(a1 + 0x68) = 0x17;
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)(a1 + 0x78) = "Name";
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_BYTE *)(a1 + 0xC8) = 0;
  p_null = "null";
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  if ( a3[1] )
    p_null = (const char *)a3[1];
  do
    ++v3;
  while ( p_null[v3] );
  *(_QWORD *)(a1 + 0xD8) = v3;
  return 2;
}

// --- End Function: sub_1404496D0 (0x1404496D0) ---

// --- Function: sub_140458AF0 (0x140458AF0) ---
__int64 __fastcall sub_140458AF0(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0;
  result = a1;
  *(_DWORD *)(a1 + 8) = 3;
  return result;
}

// --- End Function: sub_140458AF0 (0x140458AF0) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n16; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  }
  result = *(_QWORD **)(v0 + 24);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n16 = 16;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 10) = (__m256i)0LL;
        *(__m256i *)(v5 + 14) = (__m256i)0LL;
        *(__m256i *)(v5 + 18) = (__m256i)0LL;
        v5 += 22;
        --n16;
      }
      while ( n16 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 24) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 240);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 240) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor(sub_1480BE950, v3);
      v3 = *(_QWORD **)(v0 + 24);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rcx
  unsigned __int64 n15; // rax

  v0 = sub_1404B3EA0();
  v1 = v0;
  if ( !v0 )
    return &dword_149B45F40;
  n15 = *v0;
  if ( n15 > 0xF )
    n15 = 15;
  return (__int64 *)&v1[22 * n15 + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_1404EE670 (0x1404EE670) ---
__int64 __fastcall sub_1404EE670(int a1)
{
  int v1; // ecx
  int v2; // ecx
  __int64 result; // rax

  if ( a1 )
  {
    v1 = a1 - 1;
    if ( !v1 || (v2 = v1 - 1) == 0 )
    {
      _XMM1 = 0;
      __asm
      {
        vroundsd xmm1, xmm1, xmm0, 2
        vcvttsd2si rax, xmm1
      }
      return result;
    }
    if ( v2 == 1 )
    {
      _XMM1 = 0;
      __asm
      {
        vroundsd xmm1, xmm1, xmm0, 1
        vmaxsd  xmm0, xmm1, cs:qword_1481A4C40
        vcvttsd2si rax, xmm0
      }
      return result;
    }
  }
  _XMM1 = 0;
  __asm
  {
    vroundsd xmm1, xmm1, xmm0, 1
    vcvttsd2si rax, xmm1
  }
  return result;
}

// --- End Function: sub_1404EE670 (0x1404EE670) ---

// --- Function: sub_1404F3FB0 (0x1404F3FB0) ---
__int64 __fastcall sub_1404F3FB0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[40] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[40] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[41] >> 4];
  a2[3] = _0123456789abcdef_[a1[41] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[42] >> 4];
  a2[5] = _0123456789abcdef_[a1[42] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[43] >> 4];
  a2[7] = _0123456789abcdef_[a1[43] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[44] >> 4];
  a2[9] = _0123456789abcdef_[a1[44] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[45] >> 4];
  a2[11] = _0123456789abcdef_[a1[45] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[46] >> 4];
  a2[13] = _0123456789abcdef_[a1[46] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[47] >> 4];
  a2[15] = _0123456789abcdef_[a1[47] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F3FB0 (0x1404F3FB0) ---

// --- Function: sub_1404F4100 (0x1404F4100) ---
__int64 __fastcall sub_1404F4100(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[16] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[16] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[17] >> 4];
  a2[3] = _0123456789abcdef_[a1[17] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[18] >> 4];
  a2[5] = _0123456789abcdef_[a1[18] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[19] >> 4];
  a2[7] = _0123456789abcdef_[a1[19] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[20] >> 4];
  a2[9] = _0123456789abcdef_[a1[20] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[21] >> 4];
  a2[11] = _0123456789abcdef_[a1[21] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[22] >> 4];
  a2[13] = _0123456789abcdef_[a1[22] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[23] >> 4];
  a2[15] = _0123456789abcdef_[a1[23] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[24] >> 4];
  a2[17] = _0123456789abcdef_[a1[24] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[25] >> 4];
  a2[19] = _0123456789abcdef_[a1[25] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[26] >> 4];
  a2[21] = _0123456789abcdef_[a1[26] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[27] >> 4];
  a2[23] = _0123456789abcdef_[a1[27] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[28] >> 4];
  a2[25] = _0123456789abcdef_[a1[28] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[29] >> 4];
  a2[27] = _0123456789abcdef_[a1[29] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[30] >> 4];
  a2[29] = _0123456789abcdef_[a1[30] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[31] >> 4];
  a2[31] = _0123456789abcdef_[a1[31] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4100 (0x1404F4100) ---

// --- Function: sub_1404F4350 (0x1404F4350) ---
__int64 __fastcall sub_1404F4350(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x11)
{
  __int64 n16; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-28h] BYREF

  if ( n0x11 < 0x11 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)a1[32] >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[a1[32] & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[33] >> 4];
  a2[3] = _0123456789abcdef_[a1[33] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[34] >> 4];
  a2[5] = _0123456789abcdef_[a1[34] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[35] >> 4];
  a2[7] = _0123456789abcdef_[a1[35] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[36] >> 4];
  a2[9] = _0123456789abcdef_[a1[36] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[37] >> 4];
  a2[11] = _0123456789abcdef_[a1[37] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[38] >> 4];
  a2[13] = _0123456789abcdef_[a1[38] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[39] >> 4];
  a2[15] = _0123456789abcdef_[a1[39] & 0xF];
  n16 = 16;
  a2[16] = 0;
  return n16;
}

// --- End Function: sub_1404F4350 (0x1404F4350) ---

// --- Function: sub_1404F4760 (0x1404F4760) ---
__int64 __fastcall sub_1404F4760(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  __int64 n32; // rax
  unsigned __int64 v4; // rax
  char _0123456789abcdef_[24]; // [rsp+0h] [rbp-20h] BYREF

  if ( n0x21 < 0x21 )
    return 0xFFFFFFFFLL;
  v4 = (unsigned __int64)*a1 >> 4;
  strcpy(_0123456789abcdef_, "0123456789abcdef");
  *a2 = _0123456789abcdef_[v4];
  a2[1] = _0123456789abcdef_[*a1 & 0xF];
  a2[2] = _0123456789abcdef_[(unsigned __int64)a1[1] >> 4];
  a2[3] = _0123456789abcdef_[a1[1] & 0xF];
  a2[4] = _0123456789abcdef_[(unsigned __int64)a1[2] >> 4];
  a2[5] = _0123456789abcdef_[a1[2] & 0xF];
  a2[6] = _0123456789abcdef_[(unsigned __int64)a1[3] >> 4];
  a2[7] = _0123456789abcdef_[a1[3] & 0xF];
  a2[8] = _0123456789abcdef_[(unsigned __int64)a1[4] >> 4];
  a2[9] = _0123456789abcdef_[a1[4] & 0xF];
  a2[10] = _0123456789abcdef_[(unsigned __int64)a1[5] >> 4];
  a2[11] = _0123456789abcdef_[a1[5] & 0xF];
  a2[12] = _0123456789abcdef_[(unsigned __int64)a1[6] >> 4];
  a2[13] = _0123456789abcdef_[a1[6] & 0xF];
  a2[14] = _0123456789abcdef_[(unsigned __int64)a1[7] >> 4];
  a2[15] = _0123456789abcdef_[a1[7] & 0xF];
  a2[16] = _0123456789abcdef_[(unsigned __int64)a1[8] >> 4];
  a2[17] = _0123456789abcdef_[a1[8] & 0xF];
  a2[18] = _0123456789abcdef_[(unsigned __int64)a1[9] >> 4];
  a2[19] = _0123456789abcdef_[a1[9] & 0xF];
  a2[20] = _0123456789abcdef_[(unsigned __int64)a1[10] >> 4];
  a2[21] = _0123456789abcdef_[a1[10] & 0xF];
  a2[22] = _0123456789abcdef_[(unsigned __int64)a1[11] >> 4];
  a2[23] = _0123456789abcdef_[a1[11] & 0xF];
  a2[24] = _0123456789abcdef_[(unsigned __int64)a1[12] >> 4];
  a2[25] = _0123456789abcdef_[a1[12] & 0xF];
  a2[26] = _0123456789abcdef_[(unsigned __int64)a1[13] >> 4];
  a2[27] = _0123456789abcdef_[a1[13] & 0xF];
  a2[28] = _0123456789abcdef_[(unsigned __int64)a1[14] >> 4];
  a2[29] = _0123456789abcdef_[a1[14] & 0xF];
  a2[30] = _0123456789abcdef_[(unsigned __int64)a1[15] >> 4];
  a2[31] = _0123456789abcdef_[a1[15] & 0xF];
  n32 = 32;
  a2[32] = 0;
  return n32;
}

// --- End Function: sub_1404F4760 (0x1404F4760) ---

// --- Function: sub_140539D30 (0x140539D30) ---
__int64 (__fastcall *__fastcall sub_140539D30(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))sub_14039B170(0, "__InitializeThreadInfoBlock__", 0);
  if ( result )
    return (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}

// --- End Function: sub_140539D30 (0x140539D30) ---

// --- Function: sub_140539D80 (0x140539D80) ---
bool sub_140539D80()
{
  __int64 v0; // rcx

  v0 = *(_QWORD *)(NtCurrentTeb_w() + 16);
  if ( v0 )
    return *(_BYTE *)(v0 + 66) != 0;
  else
    return *(_BYTE *)(NtCurrentTeb_w() + 302) != 0;
}

// --- End Function: sub_140539D80 (0x140539D80) ---

// --- Function: sub_14056A7D0 (0x14056A7D0) ---
char __fastcall sub_14056A7D0(char a1)
{
  char n2; // al

  switch ( a1 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 84:
    case 85:
    case 86:
    case 87:
      n2 = 1;
      break;
    case 9:
    case 10:
      n2 = 2;
      break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      n2 = 3;
      break;
    case 15:
    case 18:
    case 19:
    case 65:
      n2 = 11;
      break;
    case 33:
    case 41:
    case 42:
    case 48:
    case 50:
    case 52:
    case 53:
    case 55:
    case 61:
    case 71:
    case 72:
    case 76:
      n2 = 25;
      break;
    case 34:
    case 69:
    case 96:
    case 97:
      n2 = 4;
      break;
    case 35:
    case 36:
    case 37:
    case 68:
      n2 = 5;
      break;
    case 38:
    case 77:
      n2 = 6;
      break;
    case 39:
      n2 = 7;
      break;
    case 40:
      n2 = 9;
      break;
    case 44:
    case 45:
    case 47:
    case 60:
    case 62:
    case 73:
    case 74:
      n2 = 10;
      break;
    case 49:
      n2 = 30;
      break;
    case 54:
      n2 = 21;
      break;
    case 56:
    case 57:
    case 59:
      n2 = 28;
      break;
    case 58:
    case 79:
    case 80:
      n2 = 12;
      break;
    case 63:
    case 75:
      n2 = 27;
      break;
    case 64:
    case 78:
      n2 = 23;
      break;
    case 66:
    case 67:
      n2 = 26;
      break;
    case 70:
      n2 = 29;
      break;
    case 82:
    case 83:
      n2 = 14;
      break;
    case 88:
    case 89:
      n2 = 24;
      break;
    case 90:
    case 91:
      n2 = 15;
      break;
    case 92:
      n2 = 16;
      break;
    case 93:
    case 94:
    case 95:
      n2 = 17;
      break;
    case 98:
    case 99:
      n2 = 18;
      break;
    case 100:
      n2 = 19;
      break;
    case 101:
    case 102:
      n2 = 20;
      break;
    case 103:
      n2 = 22;
      break;
    case 104:
      n2 = 31;
      break;
    case 105:
      n2 = 51;
      break;
    case 106:
      n2 = 52;
      break;
    case 107:
      n2 = 53;
      break;
    default:
      n2 = 0;
      break;
  }
  return n2;
}

// --- End Function: sub_14056A7D0 (0x14056A7D0) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: sub_141533220 (0x141533220) ---
__int64 __fastcall sub_141533220(__int64 a1, __int64 a2)
{
  bool v4; // zf

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)a1 = off_1481AB408;
  sub_14035B5F0((_QWORD *)(a1 + 0x40));
  sub_14035B5F0((_QWORD *)(a1 + 0x48));
  v4 = *(_BYTE *)(a1 + 0x28) == 0;
  *(_QWORD *)a1 = off_1481AB568;
  if ( v4 || sub_14037F680((unsigned __int16 **)(a1 + 0x48), (_QWORD *)(a2 + 0x48)) )
  {
    sub_140378020((void **)(a1 + 0x48), (const void **)(a2 + 0x48));
    *(_BYTE *)(a1 + 0x28) = 1;
    sub_1403302D0(a1, 0);
  }
  return a1;
}

// --- End Function: sub_141533220 (0x141533220) ---

// --- Function: sub_14157AD70 (0x14157AD70) ---
__int64 __fastcall sub_14157AD70(__int64 a1, __int64 a2)
{
  bool v4; // zf

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)a1 = off_148424DA0;
  sub_14035B3E0((_QWORD *)(a1 + 0x40));
  sub_14035B3E0((_QWORD *)(a1 + 0x48));
  v4 = *(_BYTE *)(a1 + 0x28) == 0;
  *(_QWORD *)a1 = off_148424F00;
  if ( v4 || (unsigned int)sub_1403E4780((unsigned __int8 **)(a1 + 0x48), (_QWORD *)(a2 + 0x48)) )
  {
    copyStringStructure((char **)(a1 + 0x48), (char **)(a2 + 0x48));
    *(_BYTE *)(a1 + 0x28) = 1;
    sub_1403302D0(a1, 0);
  }
  return a1;
}

// --- End Function: sub_14157AD70 (0x14157AD70) ---

// --- Function: sub_14157AE20 (0x14157AE20) ---
__int64 __fastcall sub_14157AE20(__int64 a1)
{
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)a1 = off_148424DA0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  sub_14035B3E0((_QWORD *)(a1 + 0x40));
  sub_14035B3E0((_QWORD *)(a1 + 0x48));
  *(_QWORD *)a1 = off_148424F00;
  return a1;
}

// --- End Function: sub_14157AE20 (0x14157AE20) ---

// --- Function: sub_141580E30 (0x141580E30) ---
__int64 __fastcall sub_141580E30(__int64 a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 0x18) )
  {
    v2 = *(_QWORD **)a1;
    if ( v2 )
    {
      if ( ((*(_QWORD *)(a1 + 0x10) - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v2 - v2[0xFFFFFFFF] - 8 > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v2 = (_QWORD *)v2[0xFFFFFFFF];
      }
      sub_1402A3D30(v2);
      result = 0;
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 0x10) = 0;
    }
  }
  return result;
}

// --- End Function: sub_141580E30 (0x141580E30) ---

// --- Function: sub_1415DBB70 (0x1415DBB70) ---
void __fastcall sub_1415DBB70(_LocaleUpdate *this, __int64 a2, __int64 a3)
{
  __int64 v6; // r14
  void (__fastcall *v7)(__int64, __int64, unsigned int *, _QWORD *, __int16); // r15
  __int64 *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rsi
  unsigned int *v11; // rax
  unsigned int *v12; // rax
  __int16 v13; // [rsp+20h] [rbp-288h]
  unsigned int v14; // [rsp+30h] [rbp-278h] BYREF
  _BYTE v15[8]; // [rsp+38h] [rbp-270h] BYREF
  _BYTE v16[8]; // [rsp+40h] [rbp-268h] BYREF
  __int64 v17; // [rsp+48h] [rbp-260h] BYREF
  __int64 v18; // [rsp+50h] [rbp-258h] BYREF
  __int64 n0x1FF; // [rsp+58h] [rbp-250h]
  unsigned __int8 *v20; // [rsp+60h] [rbp-248h]
  _BYTE v21[520]; // [rsp+68h] [rbp-240h] BYREF

  if ( sub_14030ECC0((__int64)this + 8) )
  {
    v20 = v21;
    v21[0] = 0;
    v18 = 0;
    n0x1FF = 0x1FF;
    sub_1402A3190((__int64)&v18, "[%04llu]", a3);
    v6 = sub_14030ED10((__int64)this + 8);
    v7 = *(void (__fastcall **)(__int64, __int64, unsigned int *, _QWORD *, __int16))(*(_QWORD *)v6 + 8LL);
    v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a2 + 0x20LL))(a2, v15);
    if ( is_valid_handle_typeA(v8) )
      v9 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a2 + 0x20LL))(a2, v16);
    else
      v9 = sub_1403297E0((__int64)this, &v17);
    v10 = v9;
    v11 = (unsigned int *)sub_1402E07B0((__int64)this);
    v12 = sub_14030A1F0(&v14, v11, v20);
    v13 = a3;
    v7(v6, a2, v12, v10, v13);
    if ( v20 != v21 )
    {
      qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
      sub_147605980(v20);
    }
  }
}

// --- End Function: sub_1415DBB70 (0x1415DBB70) ---

// --- Function: sub_14164D250 (0x14164D250) ---
char __fastcall sub_14164D250(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11)
{
  void *v15; // rsp
  __int64 v17; // [rsp+18h] [rbp-168h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-150h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-F8h]
  __int64 n0xB0; // [rsp+90h] [rbp-F0h]
  __int64 n0xA8; // [rsp+98h] [rbp-E8h]
  __int64 v22; // [rsp+A0h] [rbp-E0h] BYREF

  v15 = alloca(0x150);
  __Val_0___[0] = a9;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  n0x100 = 0x100;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  sub_14165C540((__int64)&v22, a10, a11);
  LODWORD(v17) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 3u, a5, v17, a7, a8);
}

// --- End Function: sub_14164D250 (0x14164D250) ---

// --- Function: sub_14165AC20 (0x14165AC20) ---
__int64 __fastcall sub_14165AC20(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  unsigned __int64 v5; // rax
  const char *p_null_1; // rcx
  const char *p_null; // rdx

  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 8) = "Name";
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_1 = (const char *)a2[1];
  p_null = "null";
  if ( p_null_1 )
    p_null = p_null_1;
  do
    ++v5;
  while ( p_null[v5] );
  *(_QWORD *)(a1 + 0x68) = v5;
  return sub_140357960(a1 + 0x70, a3, a4) + 1;
}

// --- End Function: sub_14165AC20 (0x14165AC20) ---

// --- Function: sub_14165C540 (0x14165C540) ---
__int64 __fastcall sub_14165C540(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v5; // rax
  const char *p_null_2; // rcx
  const char *p_null; // rdx
  const char *p_null_1; // r8
  unsigned __int64 v9; // rcx

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "Text";
  *(_BYTE *)(a1 + 0x59) = 0;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  p_null_2 = (const char *)a2[1];
  p_null = "null";
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v9 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v9;
  while ( p_null_1[v9] );
  *(_QWORD *)(a1 + 0x68) = v9;
  *(_QWORD *)(a1 + 0x78) = "Name";
  *(_QWORD *)(a1 + 0x70) = a3;
  *(_BYTE *)(a1 + 0xC9) = 0;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  if ( a3[1] )
    p_null = (const char *)a3[1];
  do
    ++v5;
  while ( p_null[v5] );
  *(_QWORD *)(a1 + 0xD8) = v5;
  return 2;
}

// --- End Function: sub_14165C540 (0x14165C540) ---

// --- Function: Handle::IsValid (0x142705070) ---
bool __fastcall Handle::IsValid(_QWORD *a1)
{
  __int16 n4; // [rsp+20h] [rbp-28h]
  __int16 v3; // [rsp+24h] [rbp-24h]
  __int64 v4; // [rsp+28h] [rbp-20h]

  if ( !*a1 )
    return 0;
  v3 = HIWORD(*a1);
  v4 = sub_1403B4B50(*a1 & 0xFFFFFFFFFFFFLL);
  n4 = *(_WORD *)(v4 + 4);
  if ( n4 == 4 )
    return 0;
  if ( *(_WORD *)(v4 + 2) != (v3 & 0xFFF) )
    return 0;
  return n4 == 2 && !NtCurrentTeb_ww() || sub_142714E30(a1);
}

// --- End Function: Handle::IsValid (0x142705070) ---

// --- Function: sub_142714E30 (0x142714E30) ---
char __fastcall sub_142714E30(_QWORD *a1)
{
  __int64 payload_ptr_state1; // rax
  __int64 payload_ptr_state2; // rax
  _QWORD *v4; // rax
  __int16 v6; // [rsp+24h] [rbp-24h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = *a1 & 0xFFFFFFFFFFFFLL;
  v6 = *(_WORD *)(sub_1403B4B50(v7) + 4);
  switch ( v6 )
  {
    case 0:
      return 0;
    case 1:
      payload_ptr_state1 = sub_1403B0A40(v7);
      return check_thread_list_contains_value(payload_ptr_state1);
    case 2:
      if ( (unsigned __int8)NtCurrentTeb_ww_0() || sub_140539D80() )
      {
        return 1;
      }
      else
      {
        payload_ptr_state2 = sub_1403B0A40(v7);
        return validate_access_with_virtual_calls(payload_ptr_state2);
      }
    case 3:
      v4 = (_QWORD *)sub_1403B0A40(v7);
      return check_thread_state_and_value_not_equal(v4);
    default:
      return 0;
  }
}

// --- End Function: sub_142714E30 (0x142714E30) ---

// --- Function: sub_142DD7370 (0x142DD7370) ---
void __fastcall sub_142DD7370(__int64 *a1)
{
  __int64 v1; // rbp
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // r14
  __int64 v4; // rdi
  __int64 *v5; // rsi
  __int64 v6; // r13
  __int64 v7; // rcx
  __int64 *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // r15
  unsigned int *v11; // rax
  unsigned int *v12; // rax
  int v13; // [rsp+20h] [rbp-298h]
  unsigned int v14; // [rsp+30h] [rbp-288h] BYREF
  void (__fastcall *v15)(__int64, __int64 *, unsigned int *, _QWORD *, int); // [rsp+38h] [rbp-280h]
  _BYTE v16[8]; // [rsp+40h] [rbp-278h] BYREF
  _BYTE v17[8]; // [rsp+48h] [rbp-270h] BYREF
  __int64 v18; // [rsp+50h] [rbp-268h] BYREF
  __int64 v19; // [rsp+60h] [rbp-258h] BYREF
  __int64 n0x1FF; // [rsp+68h] [rbp-250h]
  unsigned __int8 *v21; // [rsp+70h] [rbp-248h]
  _BYTE v22[520]; // [rsp+78h] [rbp-240h] BYREF

  v1 = *a1;
  if ( sub_14030ECC0(*a1 + 8) )
  {
    v2 = 0;
    v3 = (*(_QWORD *)(v1 + 0x68) - *(_QWORD *)(v1 + 0x60)) / 0x180LL;
    if ( v3 )
    {
      v4 = 0;
      do
      {
        v5 = (__int64 *)(v4 + *(_QWORD *)(v1 + 0x60));
        if ( sub_14030ECC0(v1 + 8) )
        {
          v22[0] = 0;
          v21 = v22;
          v19 = 0;
          n0x1FF = 0x1FF;
          sub_1402A3190((__int64)&v19, "[%04llu]", v2);
          v6 = sub_14030ED10(v1 + 8);
          v7 = *v5;
          v15 = *(void (__fastcall **)(__int64, __int64 *, unsigned int *, _QWORD *, int))(*(_QWORD *)v6 + 8LL);
          v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64 *, _BYTE *))(v7 + 0x20))(v5, v16);
          if ( is_valid_handle_typeA(v8) )
            v9 = (_QWORD *)(*(__int64 (__fastcall **)(__int64 *, _BYTE *))(*v5 + 0x20))(v5, v17);
          else
            v9 = sub_1403297E0(v1, &v18);
          v10 = v9;
          v11 = (unsigned int *)sub_1402E07B0(v1);
          v12 = sub_14030A1F0(&v14, v11, v21);
          LOWORD(v13) = v2;
          v15(v6, v5, v12, v10, v13);
          if ( v21 != v22 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
            sub_147605980(v21);
          }
        }
        ++v2;
        v4 += 0x180;
      }
      while ( v2 < v3 );
    }
  }
}

// --- End Function: sub_142DD7370 (0x142DD7370) ---

// --- Function: sub_142E31D90 (0x142E31D90) ---
_QWORD *__fastcall sub_142E31D90(_QWORD *a1, __int64 a2)
{
  _QWORD *v4; // rdi
  _QWORD *v6; // [rsp+30h] [rbp+8h] BYREF

  sub_142E78260(a2);
  v6 = a1;
  sub_142E78260(a1);
  v4 = (_QWORD *)(a2 + 0x60);
  if ( a1 + 0xC != (_QWORD *)(a2 + 0x60) )
  {
    sub_142E84FE0(a1 + 0xC);
    a1[0xC] = *v4;
    a1[0xD] = *(_QWORD *)(a2 + 0x68);
    a1[0xE] = *(_QWORD *)(a2 + 0x70);
    *v4 = 0;
    *(_QWORD *)(a2 + 0x68) = 0;
    *(_QWORD *)(a2 + 0x70) = 0;
  }
  if ( sub_14032A4B0(a2) )
    sub_1403302D0((__int64)a1, 0);
  sub_142DD7370((__int64 *)&v6);
  return a1;
}

// --- End Function: sub_142E31D90 (0x142E31D90) ---

// --- Function: sub_142E78260 (0x142E78260) ---
char __fastcall sub_142E78260(__int64 a1)
{
  __int64 v1; // rsi
  char result; // al
  __int64 v4; // rdi
  __int64 i; // rbx
  __int64 v6; // rax

  v1 = a1 + 8;
  result = sub_14030ECC0(a1 + 8);
  if ( result )
  {
    v4 = *(_QWORD *)(a1 + 0x68);
    for ( i = *(_QWORD *)(a1 + 0x60); i != v4; i += 0x180 )
    {
      v6 = sub_14030ED10(v1);
      result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x10LL))(v6, i);
    }
  }
  return result;
}

// --- End Function: sub_142E78260 (0x142E78260) ---

// --- Function: sub_142E83950 (0x142E83950) ---
__int64 __fastcall sub_142E83950(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rdi
  _QWORD *v10; // r8
  __int64 result; // rax

  v4 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(_QWORD **)(a1 + 8); v4 != i; v4 += 0x30 )
      (*(void (__fastcall **)(_QWORD *, _QWORD))*v4)(v4, 0);
    v10 = *(_QWORD **)a1;
    if ( (unsigned __int64)(0x180 * ((*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) / 0x180LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v10 - v10[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = (_QWORD *)v10[0xFFFFFFFF];
    }
    sub_1402A3D30(v10);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 0x180 * a3;
  result = a2 + 0x180 * a4;
  *(_QWORD *)(a1 + 0x10) = result;
  return result;
}

// --- End Function: sub_142E83950 (0x142E83950) ---

// --- Function: sub_142E84FE0 (0x142E84FE0) ---
__int64 __fastcall sub_142E84FE0(__int64 a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rsi
  _QWORD *v4; // r8
  __int64 result; // rax

  v1 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(_QWORD **)(a1 + 8); v1 != i; v1 += 0x30 )
      (*(void (__fastcall **)(_QWORD *, _QWORD))*v1)(v1, 0);
    v4 = *(_QWORD **)a1;
    if ( (unsigned __int64)(0x180 * ((*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) / 0x180LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - v4[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = (_QWORD *)v4[0xFFFFFFFF];
    }
    sub_1402A3D30(v4);
    result = 0;
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 0x10) = 0;
  }
  return result;
}

// --- End Function: sub_142E84FE0 (0x142E84FE0) ---

// --- Function: sub_142E87100 (0x142E87100) ---
__int64 __fastcall sub_142E87100(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  void (__fastcall ***v4)(_QWORD, _QWORD); // rbx
  void (__fastcall ***v5)(_QWORD, _QWORD); // rsi

  result = *(_QWORD *)(a1 + 0x68);
  if ( *(_QWORD *)(a1 + 0x60) != result )
  {
    if ( *(_BYTE *)(a1 + 0x58) )
    {
      v3 = *(_QWORD *)(a1 + 0x40);
      if ( v3 != *(_QWORD *)(a1 + 0x48) )
        *(_QWORD *)(a1 + 0x48) = v3;
    }
    v4 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 0x60);
    v5 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 0x68);
    if ( v4 != v5 )
    {
      do
      {
        (**v4)(v4, 0);
        v4 += 0x30;
      }
      while ( v4 != v5 );
      *(_QWORD *)(a1 + 0x68) = *(_QWORD *)(a1 + 0x60);
    }
    return sub_1403302D0(a1, 0);
  }
  return result;
}

// --- End Function: sub_142E87100 (0x142E87100) ---

// --- Function: sub_144BC41F0 (0x144BC41F0) ---
__int64 __fastcall sub_144BC41F0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  __int64 v7; // r15
  __int64 v8; // rdx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  unsigned __int64 allocSize_1; // rax
  unsigned __int64 v13; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  __int64 v16; // rbx
  __int64 v17; // rdx
  __int64 v18; // rcx

  v6 = 0xAAAAAAAAAAAAAALL;
  v7 = (a2 - *a1) / 0x180;
  v8 = (a1[1] - *a1) / 0x180;
  if ( v8 == 0xAAAAAAAAAAAAAALL )
    unknown_libname_10();
  v9 = v8 + 1;
  v10 = (a1[2] - *a1) / 0x180;
  v11 = v10 >> 1;
  if ( v10 <= 0xAAAAAAAAAAAAAALL - (v10 >> 1) )
  {
    v13 = v9;
    if ( v11 + v10 >= v9 )
      v13 = v11 + v10;
    if ( v13 > 0xAAAAAAAAAAAAAALL )
      goto LABEL_19;
    v6 = v13;
    allocSize = 0x180 * v13;
    if ( 0x180 * v13 < 0x1000 )
    {
      if ( allocSize )
        v16 = allocWithProfilerInfo_w(allocSize);
      else
        v16 = 0;
      goto LABEL_15;
    }
    allocSize_1 = allocSize + 0x27;
    if ( allocSize + 0x27 < allocSize )
LABEL_19:
      sub_1402E1170();
  }
  else
  {
    allocSize_1 = 0xFFFFFFFFFFFFFF27uLL;
  }
  v15 = allocWithProfilerInfo_w(allocSize_1);
  if ( !v15 )
    invalid_parameter_noinfo_noreturn();
  v16 = (v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v16 - 8) = v15;
LABEL_15:
  sub_144C2CBA0(v16 + 0x180 * v7, a3);
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    sub_144BD60F0(v18, v17, v16, a1);
  }
  else
  {
    sub_144BD60F0(v18, a2, v16, a1);
    sub_144BD60F0(a2, a1[1], v16 + 0x180 * v7 + 0x180, a1);
  }
  sub_142E83950((__int64)a1, v16, v9, v6);
  return v16 + 0x180 * v7;
}

// --- End Function: sub_144BC41F0 (0x144BC41F0) ---

// --- Function: sub_144BC7F30 (0x144BC7F30) ---
unsigned __int64 __fastcall sub_144BC7F30(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  __int64 v7; // r12
  __int64 v8; // rdx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  unsigned __int64 allocSize_1; // rax
  unsigned __int64 v13; // rdi
  unsigned __int64 allocSize; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rbx
  __int64 v17; // rdx
  __int64 v18; // rcx

  v6 = 0x13813813813813LL;
  v7 = (a2 - *a1) / 0xD20;
  v8 = (a1[1] - *a1) / 0xD20;
  if ( v8 == 0x13813813813813LL )
    unknown_libname_10();
  v9 = v8 + 1;
  v10 = (a1[2] - *a1) / 0xD20;
  v11 = v10 >> 1;
  if ( v10 <= 0x13813813813813LL - (v10 >> 1) )
  {
    v13 = v9;
    if ( v11 + v10 >= v9 )
      v13 = v11 + v10;
    if ( v13 > 0x13813813813813LL )
      goto LABEL_19;
    allocSize = 0xD20 * v13;
    v6 = v13;
    if ( 0xD20 * v13 < 0x1000 )
    {
      if ( allocSize )
        v16 = allocWithProfilerInfo_w(allocSize);
      else
        v16 = 0;
      goto LABEL_15;
    }
    allocSize_1 = allocSize + 0x27;
    if ( allocSize + 0x27 < allocSize )
LABEL_19:
      sub_1402E1170();
  }
  else
  {
    allocSize_1 = 0xFFFFFFFFFFFFF987uLL;
  }
  v15 = allocWithProfilerInfo_w(allocSize_1);
  if ( !v15 )
    invalid_parameter_noinfo_noreturn();
  v16 = (v15 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v16 - 8) = v15;
LABEL_15:
  sub_144C2CF00(v16 + 0xD20 * v7, a3);
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    sub_144BD6150(v18, v17, v16, a1);
  }
  else
  {
    sub_144BD7440(v18, a2, v16, a1);
    sub_144BD7440(a2, a1[1], v16 + 0xD20 * v7 + 0xD20, a1);
  }
  sub_144E07F40(a1, v16, v9, v6);
  return v16 + 0xD20 * v7;
}

// --- End Function: sub_144BC7F30 (0x144BC7F30) ---

// --- Function: sub_144BCBCD0 (0x144BCBCD0) ---
void __fastcall sub_144BCBCD0(__int64 a1, __int64 a2, const void **a3)
{
  const void **v3; // rbx
  const void **v6; // rdi

  v3 = a3;
  while ( !*((_BYTE *)v3 + 0x19) )
  {
    sub_144BCBCD0(a1, a2, v3[2]);
    v6 = v3;
    v3 = (const void **)*v3;
    std::vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___::_vector__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node_std::allocator__GSC::AI::GameGraph::generate_game_graph_::_246_::search_node___(v6 + 7);
    sub_1402A3D30(v6);
  }
}

// --- End Function: sub_144BCBCD0 (0x144BCBCD0) ---

// --- Function: sub_144BD60F0 (0x144BD60F0) ---
__int64 __fastcall sub_144BD60F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx

  for ( i = a1; i != a2; i += 0x180 )
  {
    sub_144C2CBA0(a3, i);
    a3 += 0x180;
  }
  return a3;
}

// --- End Function: sub_144BD60F0 (0x144BD60F0) ---

// --- Function: sub_144BD6150 (0x144BD6150) ---
__int64 __fastcall sub_144BD6150(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx

  for ( i = a1; i != a2; i += 0xD20 )
  {
    sub_144C2DB60(a3, i);
    a3 += 0xD20;
  }
  return a3;
}

// --- End Function: sub_144BD6150 (0x144BD6150) ---

// --- Function: sub_144BD7440 (0x144BD7440) ---
__int64 __fastcall sub_144BD7440(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx

  for ( i = a1; i != a2; i += 0xD20 )
  {
    sub_144C2CF00(a3, i);
    a3 += 0xD20;
  }
  return a3;
}

// --- End Function: sub_144BD7440 (0x144BD7440) ---

// --- Function: __crtLCMapStringA_65 (0x144BE5790) ---
char __fastcall _crtLCMapStringA_65(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12,
        _QWORD *a13,
        _QWORD *a14)
{
  void *v18; // rsp
  __int64 v19; // rax
  __int64 v21; // [rsp+18h] [rbp-2B8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-2A0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-248h]
  __int64 n0xB0; // [rsp+90h] [rbp-240h]
  __int64 n0xA8; // [rsp+98h] [rbp-238h]
  _QWORD *v26; // [rsp+A0h] [rbp-230h]
  const char *p_EntityId; // [rsp+A8h] [rbp-228h]
  __int64 v28; // [rsp+B0h] [rbp-220h]
  __int64 (__fastcall *p_sub_1403EB550)(__int64, __int64, __int64); // [rsp+B8h] [rbp-218h]
  __int64 (__fastcall *p_sub_1403EAFB0)(__int64, _BYTE *, unsigned __int64); // [rsp+C0h] [rbp-210h]
  __int64 v31; // [rsp+C8h] [rbp-208h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+D0h] [rbp-200h]
  __int64 v33; // [rsp+D8h] [rbp-1F8h]
  __int64 (__fastcall *p_sub_1403E4EB0)(const void *); // [rsp+E0h] [rbp-1F0h]
  __int64 (__fastcall *p_sub_1403E4C70)(__int64); // [rsp+E8h] [rbp-1E8h]
  unsigned __int64 v36; // [rsp+F0h] [rbp-1E0h]
  char v37; // [rsp+F8h] [rbp-1D8h]
  char v38; // [rsp+F9h] [rbp-1D7h]
  __int64 n0x18; // [rsp+100h] [rbp-1D0h]
  __int64 n0x17; // [rsp+108h] [rbp-1C8h]
  _QWORD *v41; // [rsp+110h] [rbp-1C0h]
  const char *p_EntityId_1; // [rsp+118h] [rbp-1B8h]
  __int64 v43; // [rsp+120h] [rbp-1B0h]
  __int64 (__fastcall *p_sub_1403EB550_1)(__int64, __int64, __int64); // [rsp+128h] [rbp-1A8h]
  __int64 (__fastcall *p_sub_1403EAFB0_1)(__int64, _BYTE *, unsigned __int64); // [rsp+130h] [rbp-1A0h]
  __int64 v46; // [rsp+138h] [rbp-198h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z_1)(__int64, __int64); // [rsp+140h] [rbp-190h]
  __int64 v48; // [rsp+148h] [rbp-188h]
  __int64 (__fastcall *p_sub_1403E4EB0_1)(const void *); // [rsp+150h] [rbp-180h]
  __int64 (__fastcall *p_sub_1403E4C70_1)(__int64); // [rsp+158h] [rbp-178h]
  unsigned __int64 v51; // [rsp+160h] [rbp-170h]
  char v52; // [rsp+168h] [rbp-168h]
  char v53; // [rsp+169h] [rbp-167h]
  __int64 n0x18_1; // [rsp+170h] [rbp-160h]
  __int64 n0x17_1; // [rsp+178h] [rbp-158h]
  __int64 v56; // [rsp+180h] [rbp-150h] BYREF

  v18 = alloca(0x2A0);
  __Val_0___[0] = a9;
  n0x100 = 0x100;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  __Val_0___[1] = "TraceContext";
  __Val_0___[3] = sub_1403EB6A0;
  __Val_0___[4] = sub_1403EB240;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v26 = a10;
  n0xA8 = 0xA8;
  p_EntityId = "EntityId";
  v38 = 1;
  v28 = *a10;
  p_sub_1403EAFB0 = sub_1403EAFB0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E4EB0 = sub_1403E4EB0;
  p_sub_1403E4C70 = sub_1403E4C70;
  p_sub_1403EB550 = sub_1403EB550;
  v31 = 0;
  v33 = 0;
  v36 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = 0;
  n0x18 = 0x18;
  n0x17 = 0x17;
  v41 = a11;
  p_EntityId_1 = "EntityId";
  v53 = 1;
  v19 = *a11;
  p_sub_1403EAFB0_1 = sub_1403EAFB0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z_1 = std::error_category::operator==;
  p_sub_1403E4EB0_1 = sub_1403E4EB0;
  p_sub_1403E4C70_1 = sub_1403E4C70;
  v43 = v19;
  p_sub_1403EB550_1 = sub_1403EB550;
  v46 = 0;
  v48 = 0;
  v51 = 0xFFFFFFFFFFFFFFFFuLL;
  v52 = 0;
  n0x18_1 = 0x18;
  n0x17_1 = 0x17;
  sub_14165AC20((__int64)&v56, a12, a13, a14);
  LODWORD(v21) = a6;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 6u, a5, v21, a7, a8);
}

// --- End Function: __crtLCMapStringA_65 (0x144BE5790) ---

// --- Function: sub_144BE9850 (0x144BE9850) ---
char __fastcall sub_144BE9850(
        unsigned int n4,
        __int64 *a2,
        char *a3,
        char *a4,
        __int64 a5,
        int a6,
        _QWORD *a7,
        __int64 a8,
        __int64 a9,
        _QWORD *a10,
        _QWORD *a11,
        _QWORD *a12)
{
  void *v16; // rsp
  const char *p_null; // r9
  unsigned __int64 v18; // r8
  const char *p_null_1; // rdx
  unsigned __int64 v20; // rcx
  __int64 v22; // [rsp+18h] [rbp-1D8h]
  _QWORD __Val_0___[11]; // [rsp+30h] [rbp-1C0h] BYREF
  __int16 n0x100; // [rsp+88h] [rbp-168h]
  __int64 n0xB0; // [rsp+90h] [rbp-160h]
  __int64 n0xA8; // [rsp+98h] [rbp-158h]
  _QWORD *v27; // [rsp+A0h] [rbp-150h]
  const char *p_EntityId; // [rsp+A8h] [rbp-148h]
  __int64 v29; // [rsp+B0h] [rbp-140h]
  __int64 (__fastcall *p_sub_1403EB550)(__int64, __int64, __int64); // [rsp+B8h] [rbp-138h]
  __int64 (__fastcall *p_sub_1403EAFB0)(__int64, _BYTE *, unsigned __int64); // [rsp+C0h] [rbp-130h]
  __int64 v32; // [rsp+C8h] [rbp-128h]
  bool (__fastcall *p_??8error_category@std@@QEBA_NAEBV01@@Z)(__int64, __int64); // [rsp+D0h] [rbp-120h]
  __int64 v34; // [rsp+D8h] [rbp-118h]
  __int64 (__fastcall *p_sub_1403E4EB0)(const void *); // [rsp+E0h] [rbp-110h]
  __int64 (__fastcall *p_sub_1403E4C70)(__int64); // [rsp+E8h] [rbp-108h]
  unsigned __int64 v37; // [rsp+F0h] [rbp-100h]
  char v38; // [rsp+F8h] [rbp-F8h]
  char v39; // [rsp+F9h] [rbp-F7h]
  __int64 n0x18; // [rsp+100h] [rbp-F0h]
  __int64 n0x17; // [rsp+108h] [rbp-E8h]
  _QWORD *v42; // [rsp+110h] [rbp-E0h]
  const char *p_Name; // [rsp+118h] [rbp-D8h]
  __int64 v44; // [rsp+120h] [rbp-D0h]
  __int64 (__fastcall *p_sub_1403EB580)(__int64, _BYTE *, size_t, __int64, char); // [rsp+128h] [rbp-C8h]
  __int64 (__fastcall *p_sub_1403EB0E0)(__int64, _BYTE *, int); // [rsp+130h] [rbp-C0h]
  __int64 v47; // [rsp+138h] [rbp-B8h]
  bool (__fastcall *p_sub_1403E7650)(__int64, __int64); // [rsp+140h] [rbp-B0h]
  __int64 v49; // [rsp+148h] [rbp-A8h]
  __int64 (__fastcall *p_sub_1403E4E80)(const void **); // [rsp+150h] [rbp-A0h]
  _QWORD *(__fastcall *p_sub_1403E4B90)(_QWORD *); // [rsp+158h] [rbp-98h]
  unsigned __int64 v52; // [rsp+160h] [rbp-90h]
  char v53; // [rsp+168h] [rbp-88h]
  char v54; // [rsp+169h] [rbp-87h]
  __int64 n0x18_1; // [rsp+170h] [rbp-80h]
  unsigned __int64 v56; // [rsp+178h] [rbp-78h]
  _QWORD *v57; // [rsp+180h] [rbp-70h]
  const char *p_Function; // [rsp+188h] [rbp-68h]
  __int64 v59; // [rsp+190h] [rbp-60h]
  __int64 (__fastcall *p_sub_1403EB580_1)(__int64, _BYTE *, size_t, __int64, char); // [rsp+198h] [rbp-58h]
  __int64 (__fastcall *p_sub_1403EB0E0_1)(__int64, _BYTE *, int); // [rsp+1A0h] [rbp-50h]
  __int64 v62; // [rsp+1A8h] [rbp-48h]
  bool (__fastcall *p_sub_1403E7650_1)(__int64, __int64); // [rsp+1B0h] [rbp-40h]
  __int64 v64; // [rsp+1B8h] [rbp-38h]
  __int64 (__fastcall *p_sub_1403E4E80_1)(const void **); // [rsp+1C0h] [rbp-30h]
  _QWORD *(__fastcall *p_sub_1403E4B90_1)(_QWORD *); // [rsp+1C8h] [rbp-28h]
  unsigned __int64 v67; // [rsp+1D0h] [rbp-20h]
  char v68; // [rsp+1D8h] [rbp-18h]
  char v69; // [rsp+1D9h] [rbp-17h]
  __int64 n0x18_2; // [rsp+1E0h] [rbp-10h]
  unsigned __int64 v71; // [rsp+1E8h] [rbp-8h]

  v16 = alloca(0x1C0);
  __Val_0___[1] = "TraceContext";
  p_EntityId = "EntityId";
  p_null = "null";
  __Val_0___[3] = sub_1403EB6A0;
  v18 = 0xFFFFFFFFFFFFFFFFuLL;
  __Val_0___[0] = a9;
  __Val_0___[4] = sub_1403EB240;
  n0x100 = 0x100;
  __Val_0___[6] = sub_1403E77F0;
  __Val_0___[8] = sub_1403E4E60;
  __Val_0___[9] = allocWithProfilerInfo_ww;
  v27 = a10;
  __Val_0___[2] = 0;
  __Val_0___[5] = 0;
  __Val_0___[7] = 0;
  __Val_0___[0xA] = 0xFFFFFFFFFFFFFFFFuLL;
  n0xB0 = 0xB0;
  n0xA8 = 0xA8;
  v39 = 1;
  v29 = *a10;
  p_sub_1403EB550 = sub_1403EB550;
  p_sub_1403EAFB0 = sub_1403EAFB0;
  p_??8error_category@std@@QEBA_NAEBV01@@Z = std::error_category::operator==;
  p_sub_1403E4EB0 = sub_1403E4EB0;
  p_sub_1403E4C70 = sub_1403E4C70;
  p_Name = "Name";
  v42 = a11;
  v32 = 0;
  v34 = 0;
  v37 = 0xFFFFFFFFFFFFFFFFuLL;
  v38 = 0;
  n0x18 = 0x18;
  n0x17 = 0x17;
  v54 = 0;
  v44 = *a11;
  p_sub_1403EB580 = sub_1403EB580;
  p_sub_1403EB0E0 = sub_1403EB0E0;
  p_sub_1403E7650 = sub_1403E7650;
  p_sub_1403E4E80 = sub_1403E4E80;
  p_sub_1403E4B90 = sub_1403E4B90;
  v47 = 0;
  v49 = 0;
  v52 = 0xFFFFFFFFFFFFFFFFuLL;
  v53 = 0;
  n0x18_1 = 0x18;
  p_null_1 = "null";
  if ( a11[1] )
    p_null_1 = (const char *)a11[1];
  v20 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v20;
  while ( p_null_1[v20] );
  v56 = v20;
  p_Function = "Function";
  v57 = a12;
  v69 = 1;
  v59 = *a12;
  p_sub_1403EB580_1 = sub_1403EB580;
  p_sub_1403EB0E0_1 = sub_1403EB0E0;
  p_sub_1403E7650_1 = sub_1403E7650;
  p_sub_1403E4E80_1 = sub_1403E4E80;
  p_sub_1403E4B90_1 = sub_1403E4B90;
  v62 = 0;
  v64 = 0;
  v67 = 0xFFFFFFFFFFFFFFFFuLL;
  v68 = 0;
  n0x18_2 = 0x18;
  if ( a12[1] )
    p_null = (const char *)a12[1];
  do
    ++v18;
  while ( p_null[v18] );
  LODWORD(v22) = a6;
  v71 = v18;
  return sub_1403045C0(n4, a2, a3, a4, (vraudio::AudioBuffer *)__Val_0___, 4u, a5, v22, a7, a8);
}

// --- End Function: sub_144BE9850 (0x144BE9850) ---

// --- Function: sub_144C2CBA0 (0x144C2CBA0) ---
__int64 __fastcall sub_144C2CBA0(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx

  *(_QWORD *)a1 = off_1481AAE78;
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a2 + 0x20);
  *(_BYTE *)(a1 + 0x28) = *(_BYTE *)(a2 + 0x28);
  *(_BYTE *)(a1 + 0x29) = *(_BYTE *)(a2 + 0x29);
  *(_BYTE *)(a1 + 0x2A) = *(_BYTE *)(a2 + 0x2A);
  *(_BYTE *)(a1 + 0x2B) = *(_BYTE *)(a2 + 0x2B);
  *(_BYTE *)(a1 + 0x2C) = *(_BYTE *)(a2 + 0x2C);
  *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x38) = *(_DWORD *)(a2 + 0x38);
  *(_QWORD *)a1 = off_1481AAFE8;
  *(_WORD *)(a1 + 0x40) = *(_WORD *)(a2 + 0x40);
  *(_QWORD *)a1 = off_148A05888;
  v4 = a1 + 0x48;
  *(_DWORD *)(v4 + 8) = 0xFFFFFFFF;
  *(_BYTE *)(v4 + 0xC) = 0;
  *(_QWORD *)(v4 + 0x10) = 0;
  *(_QWORD *)(v4 + 0x18) = 0;
  *(_QWORD *)(v4 + 0x20) = 0;
  *(_DWORD *)(v4 + 0x28) = 0x1000000;
  *(_QWORD *)(v4 + 0x30) = 0;
  *(_BYTE *)(v4 + 0x2C) = 0;
  *(_DWORD *)(v4 + 0x38) = 0;
  *(_QWORD *)v4 = off_1481AB2A8;
  *(_QWORD *)(v4 + 0x48) = *(_QWORD *)(a2 + 0x90);
  *(_BYTE *)(v4 + 0x28) = 1;
  sub_1403302D0(v4, 0);
  *(_DWORD *)(a1 + 0xA0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xA4) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_DWORD *)(a1 + 0xC0) = 0x1000000;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_BYTE *)(a1 + 0xC4) = 0;
  *(_DWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0x98) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0xE0) = *(_QWORD *)(a2 + 0xE0);
  *(_BYTE *)(a1 + 0xC0) = 1;
  sub_1403302D0(a1 + 0x98, 0);
  *(_DWORD *)(a1 + 0xF0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xF4) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_DWORD *)(a1 + 0x110) = 0x1000000;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_BYTE *)(a1 + 0x114) = 0;
  *(_DWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0xE8) = off_1481AB148;
  *(_BYTE *)(a1 + 0x129) = *(_BYTE *)(a2 + 0x129);
  *(_BYTE *)(a1 + 0x110) = 1;
  sub_1403302D0(a1 + 0xE8, 0);
  *(_DWORD *)(a1 + 0x138) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x13C) = 0;
  *(_QWORD *)(a1 + 0x140) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_DWORD *)(a1 + 0x158) = 0x1000000;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_BYTE *)(a1 + 0x15C) = 0;
  *(_DWORD *)(a1 + 0x168) = 0;
  *(_QWORD *)(a1 + 0x130) = off_1481AB148;
  *(_BYTE *)(a1 + 0x171) = *(_BYTE *)(a2 + 0x171);
  *(_BYTE *)(a1 + 0x158) = 1;
  sub_1403302D0(a1 + 0x130, 0);
  *(_BYTE *)(a1 + 0x178) = *(_BYTE *)(a2 + 0x178);
  *(_DWORD *)(a1 + 0x17C) = *(_DWORD *)(a2 + 0x17C);
  return a1;
}

// --- End Function: sub_144C2CBA0 (0x144C2CBA0) ---

// --- Function: sub_144C2CD90 (0x144C2CD90) ---
__int64 __fastcall sub_144C2CD90(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)a1 = off_148A05888;
  *(_QWORD *)(a1 + 0x48) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x98) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0xE8) = off_1481AB148;
  *(_QWORD *)(a1 + 0x130) = off_1481AB148;
  result = a1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_WORD *)(a1 + 0x40) = 0xFFFF;
  *(_DWORD *)(a1 + 0x50) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x54) = 0;
  *(_QWORD *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_DWORD *)(a1 + 0x70) = 0x1000000;
  *(_BYTE *)(a1 + 0x74) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_DWORD *)(a1 + 0x80) = 0;
  *(_DWORD *)(a1 + 0xA0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xA4) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xB0) = 0;
  *(_QWORD *)(a1 + 0xB8) = 0;
  *(_DWORD *)(a1 + 0xC0) = 0x1000000;
  *(_BYTE *)(a1 + 0xC4) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_DWORD *)(a1 + 0xD0) = 0;
  *(_DWORD *)(a1 + 0xF0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xF4) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_DWORD *)(a1 + 0x110) = 0x1000000;
  *(_BYTE *)(a1 + 0x114) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_DWORD *)(a1 + 0x120) = 0;
  *(_DWORD *)(a1 + 0x138) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x13C) = 0;
  *(_QWORD *)(a1 + 0x140) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_DWORD *)(a1 + 0x158) = 0x1000000;
  *(_BYTE *)(a1 + 0x15C) = 0;
  *(_QWORD *)(a1 + 0x160) = 0;
  *(_DWORD *)(a1 + 0x168) = 0;
  *(_BYTE *)(a1 + 0x178) = 0;
  *(_DWORD *)(a1 + 0x17C) = 0;
  return result;
}

// --- End Function: sub_144C2CD90 (0x144C2CD90) ---

// --- Function: sub_144C2CF00 (0x144C2CF00) ---
__int64 __fastcall sub_144C2CF00(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx

  *(_QWORD *)a1 = off_1481AAE78;
  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = *(_QWORD *)(a2 + 0x20);
  *(_BYTE *)(a1 + 0x28) = *(_BYTE *)(a2 + 0x28);
  *(_BYTE *)(a1 + 0x29) = *(_BYTE *)(a2 + 0x29);
  *(_BYTE *)(a1 + 0x2A) = *(_BYTE *)(a2 + 0x2A);
  *(_BYTE *)(a1 + 0x2B) = *(_BYTE *)(a2 + 0x2B);
  *(_BYTE *)(a1 + 0x2C) = *(_BYTE *)(a2 + 0x2C);
  *(_QWORD *)(a1 + 0x30) = *(_QWORD *)(a2 + 0x30);
  *(_DWORD *)(a1 + 0x38) = *(_DWORD *)(a2 + 0x38);
  *(_QWORD *)a1 = off_1481AAFE8;
  *(_WORD *)(a1 + 0x40) = *(_WORD *)(a2 + 0x40);
  *(_QWORD *)a1 = off_148A05CA0;
  sub_141533220(a1 + 0x48, a2 + 0x48);
  sub_14157AD70(a1 + 0x98, a2 + 0x98);
  *(_DWORD *)(a1 + 0xF0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xF4) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_DWORD *)(a1 + 0x110) = 0x1000000;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_BYTE *)(a1 + 0x114) = 0;
  *(_DWORD *)(a1 + 0x120) = 0;
  *(_QWORD *)(a1 + 0xE8) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x130) = *(_QWORD *)(a2 + 0x130);
  *(_BYTE *)(a1 + 0x110) = 1;
  sub_1403302D0(a1 + 0xE8, 0);
  *(_DWORD *)(a1 + 0x140) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x144) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = 0;
  *(_DWORD *)(a1 + 0x160) = 0x1000000;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_BYTE *)(a1 + 0x164) = 0;
  *(_DWORD *)(a1 + 0x170) = 0;
  *(_QWORD *)(a1 + 0x138) = off_148424C40;
  *(float *)(a1 + 0x17C) = *(float *)(a2 + 0x17C);
  *(_BYTE *)(a1 + 0x160) = 1;
  sub_1403302D0(a1 + 0x138, 0);
  *(_DWORD *)(a1 + 0x188) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x18C) = 0;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0;
  *(_DWORD *)(a1 + 0x1A8) = 0x1000000;
  *(_QWORD *)(a1 + 0x1B0) = 0;
  *(_BYTE *)(a1 + 0x1AC) = 0;
  *(_DWORD *)(a1 + 0x1B8) = 0;
  *(_QWORD *)(a1 + 0x180) = off_148424C40;
  *(float *)(a1 + 0x1C4) = *(float *)(a2 + 0x1C4);
  *(_BYTE *)(a1 + 0x1A8) = 1;
  sub_1403302D0(a1 + 0x180, 0);
  *(_DWORD *)(a1 + 0x1D0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x1D4) = 0;
  *(_QWORD *)(a1 + 0x1D8) = 0;
  *(_QWORD *)(a1 + 0x1E0) = 0;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_DWORD *)(a1 + 0x1F0) = 0x1000000;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_BYTE *)(a1 + 0x1F4) = 0;
  *(_DWORD *)(a1 + 0x200) = 0;
  *(_QWORD *)(a1 + 0x1C8) = off_148424C40;
  *(float *)(a1 + 0x20C) = *(float *)(a2 + 0x20C);
  *(_BYTE *)(a1 + 0x1F0) = 1;
  sub_1403302D0(a1 + 0x1C8, 0);
  *(_DWORD *)(a1 + 0x218) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x21C) = 0;
  *(_QWORD *)(a1 + 0x220) = 0;
  *(_QWORD *)(a1 + 0x228) = 0;
  *(_QWORD *)(a1 + 0x230) = 0;
  *(_DWORD *)(a1 + 0x238) = 0x1000000;
  *(_QWORD *)(a1 + 0x240) = 0;
  *(_BYTE *)(a1 + 0x23C) = 0;
  *(_DWORD *)(a1 + 0x248) = 0;
  *(_QWORD *)(a1 + 0x210) = off_148424C40;
  *(float *)(a1 + 0x254) = *(float *)(a2 + 0x254);
  *(_BYTE *)(a1 + 0x238) = 1;
  sub_1403302D0(a1 + 0x210, 0);
  *(_DWORD *)(a1 + 0x260) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x264) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = 0;
  *(_QWORD *)(a1 + 0x278) = 0;
  *(_DWORD *)(a1 + 0x280) = 0x1000000;
  *(_QWORD *)(a1 + 0x288) = 0;
  *(_BYTE *)(a1 + 0x284) = 0;
  *(_DWORD *)(a1 + 0x290) = 0;
  *(_QWORD *)(a1 + 0x258) = off_1481AB148;
  *(_BYTE *)(a1 + 0x299) = *(_BYTE *)(a2 + 0x299);
  *(_BYTE *)(a1 + 0x280) = 1;
  sub_1403302D0(a1 + 0x258, 0);
  *(_DWORD *)(a1 + 0x2A8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x2AC) = 0;
  *(_QWORD *)(a1 + 0x2B0) = 0;
  *(_QWORD *)(a1 + 0x2B8) = 0;
  *(_QWORD *)(a1 + 0x2C0) = 0;
  *(_DWORD *)(a1 + 0x2C8) = 0x1000000;
  *(_QWORD *)(a1 + 0x2D0) = 0;
  *(_BYTE *)(a1 + 0x2CC) = 0;
  *(_DWORD *)(a1 + 0x2D8) = 0;
  *(_QWORD *)(a1 + 0x2A0) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x2E8) = *(_QWORD *)(a2 + 0x2E8);
  *(_BYTE *)(a1 + 0x2C8) = 1;
  sub_1403302D0(a1 + 0x2A0, 0);
  sub_14157AD70(a1 + 0x2F0, a2 + 0x2F0);
  *(_DWORD *)(a1 + 0x348) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x34C) = 0;
  *(_QWORD *)(a1 + 0x350) = 0;
  *(_QWORD *)(a1 + 0x358) = 0;
  *(_QWORD *)(a1 + 0x360) = 0;
  *(_DWORD *)(a1 + 0x368) = 0x1000000;
  *(_QWORD *)(a1 + 0x370) = 0;
  *(_BYTE *)(a1 + 0x36C) = 0;
  *(_DWORD *)(a1 + 0x378) = 0;
  *(_QWORD *)(a1 + 0x340) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x388) = *(_QWORD *)(a2 + 0x388);
  *(_BYTE *)(a1 + 0x368) = 1;
  sub_1403302D0(a1 + 0x340, 0);
  *(_DWORD *)(a1 + 0x398) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x39C) = 0;
  *(_QWORD *)(a1 + 0x3A0) = 0;
  *(_QWORD *)(a1 + 0x3A8) = 0;
  *(_QWORD *)(a1 + 0x3B0) = 0;
  *(_DWORD *)(a1 + 0x3B8) = 0x1000000;
  *(_QWORD *)(a1 + 0x3C0) = 0;
  *(_BYTE *)(a1 + 0x3BC) = 0;
  *(_DWORD *)(a1 + 0x3C8) = 0;
  *(_QWORD *)(a1 + 0x390) = off_1481AB148;
  *(_BYTE *)(a1 + 0x3D1) = *(_BYTE *)(a2 + 0x3D1);
  *(_BYTE *)(a1 + 0x3B8) = 1;
  sub_1403302D0(a1 + 0x390, 0);
  *(_DWORD *)(a1 + 0x3E0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x3E4) = 0;
  *(_QWORD *)(a1 + 0x3E8) = 0;
  *(_QWORD *)(a1 + 0x3F0) = 0;
  *(_QWORD *)(a1 + 0x3F8) = 0;
  *(_DWORD *)(a1 + 0x400) = 0x1000000;
  *(_QWORD *)(a1 + 0x408) = 0;
  *(_BYTE *)(a1 + 0x404) = 0;
  *(_DWORD *)(a1 + 0x410) = 0;
  *(_QWORD *)(a1 + 0x3D8) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x420) = *(_QWORD *)(a2 + 0x420);
  *(_BYTE *)(a1 + 0x400) = 1;
  sub_1403302D0(a1 + 0x3D8, 0);
  sub_14030A1B0(a1 + 0x428, a2 + 0x428);
  sub_14030A1B0(a1 + 0x458, a2 + 0x458);
  sub_14030A1B0(a1 + 0x488, a2 + 0x488);
  sub_14030A1B0(a1 + 0x4B8, a2 + 0x4B8);
  sub_14030A1B0(a1 + 0x4E8, a2 + 0x4E8);
  sub_14030A1B0(a1 + 0x518, a2 + 0x518);
  *(_DWORD *)(a1 + 0x550) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x554) = 0;
  *(_QWORD *)(a1 + 0x558) = 0;
  *(_QWORD *)(a1 + 0x560) = 0;
  *(_QWORD *)(a1 + 0x568) = 0;
  *(_DWORD *)(a1 + 0x570) = 0x1000000;
  *(_QWORD *)(a1 + 0x578) = 0;
  *(_BYTE *)(a1 + 0x574) = 0;
  *(_DWORD *)(a1 + 0x580) = 0;
  *(_QWORD *)(a1 + 0x548) = off_1481AB148;
  *(_BYTE *)(a1 + 0x589) = *(_BYTE *)(a2 + 0x589);
  *(_BYTE *)(a1 + 0x570) = 1;
  sub_1403302D0(a1 + 0x548, 0);
  *(_DWORD *)(a1 + 0x598) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x59C) = 0;
  *(_QWORD *)(a1 + 0x5A0) = 0;
  *(_QWORD *)(a1 + 0x5A8) = 0;
  *(_QWORD *)(a1 + 0x5B0) = 0;
  *(_DWORD *)(a1 + 0x5B8) = 0x1000000;
  *(_QWORD *)(a1 + 0x5C0) = 0;
  *(_BYTE *)(a1 + 0x5BC) = 0;
  *(_DWORD *)(a1 + 0x5C8) = 0;
  *(_QWORD *)(a1 + 0x590) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x5D8) = *(_QWORD *)(a2 + 0x5D8);
  *(_BYTE *)(a1 + 0x5B8) = 1;
  sub_1403302D0(a1 + 0x590, 0);
  sub_141533220(a1 + 0x5E0, a2 + 0x5E0);
  *(_DWORD *)(a1 + 0x638) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x63C) = 0;
  *(_QWORD *)(a1 + 0x640) = 0;
  *(_QWORD *)(a1 + 0x648) = 0;
  *(_QWORD *)(a1 + 0x650) = 0;
  *(_DWORD *)(a1 + 0x658) = 0x1000000;
  *(_QWORD *)(a1 + 0x660) = 0;
  *(_BYTE *)(a1 + 0x65C) = 0;
  *(_DWORD *)(a1 + 0x668) = 0;
  *(_QWORD *)(a1 + 0x630) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x678) = *(_QWORD *)(a2 + 0x678);
  *(_BYTE *)(a1 + 0x658) = 1;
  sub_1403302D0(a1 + 0x630, 0);
  *(_DWORD *)(a1 + 0x688) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x68C) = 0;
  *(_QWORD *)(a1 + 0x690) = 0;
  *(_QWORD *)(a1 + 0x698) = 0;
  *(_QWORD *)(a1 + 0x6A0) = 0;
  *(_DWORD *)(a1 + 0x6A8) = 0x1000000;
  *(_QWORD *)(a1 + 0x6B0) = 0;
  *(_BYTE *)(a1 + 0x6AC) = 0;
  *(_DWORD *)(a1 + 0x6B8) = 0;
  *(_QWORD *)(a1 + 0x680) = off_148424C40;
  *(float *)(a1 + 0x6C4) = *(float *)(a2 + 0x6C4);
  *(_BYTE *)(a1 + 0x6A8) = 1;
  sub_1403302D0(a1 + 0x680, 0);
  *(_DWORD *)(a1 + 0x6D0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x6D4) = 0;
  *(_QWORD *)(a1 + 0x6D8) = 0;
  *(_QWORD *)(a1 + 0x6E0) = 0;
  *(_QWORD *)(a1 + 0x6E8) = 0;
  *(_DWORD *)(a1 + 0x6F0) = 0x1000000;
  *(_QWORD *)(a1 + 0x6F8) = 0;
  *(_BYTE *)(a1 + 0x6F4) = 0;
  *(_DWORD *)(a1 + 0x700) = 0;
  *(_QWORD *)(a1 + 0x6C8) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x710) = *(_QWORD *)(a2 + 0x710);
  *(_BYTE *)(a1 + 0x6F0) = 1;
  sub_1403302D0(a1 + 0x6C8, 0);
  *(_DWORD *)(a1 + 0x720) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x724) = 0;
  *(_QWORD *)(a1 + 0x728) = 0;
  *(_QWORD *)(a1 + 0x730) = 0;
  *(_QWORD *)(a1 + 0x738) = 0;
  *(_DWORD *)(a1 + 0x740) = 0x1000000;
  *(_QWORD *)(a1 + 0x748) = 0;
  *(_BYTE *)(a1 + 0x744) = 0;
  *(_DWORD *)(a1 + 0x750) = 0;
  *(_QWORD *)(a1 + 0x718) = off_1481AB148;
  *(_BYTE *)(a1 + 0x759) = *(_BYTE *)(a2 + 0x759);
  *(_BYTE *)(a1 + 0x740) = 1;
  sub_1403302D0(a1 + 0x718, 0);
  *(_DWORD *)(a1 + 0x768) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x76C) = 0;
  *(_QWORD *)(a1 + 0x770) = 0;
  *(_QWORD *)(a1 + 0x778) = 0;
  *(_QWORD *)(a1 + 0x780) = 0;
  *(_DWORD *)(a1 + 0x788) = 0x1000000;
  *(_QWORD *)(a1 + 0x790) = 0;
  *(_BYTE *)(a1 + 0x78C) = 0;
  *(_DWORD *)(a1 + 0x798) = 0;
  *(_QWORD *)(a1 + 0x760) = off_1481AB148;
  *(_BYTE *)(a1 + 0x7A1) = *(_BYTE *)(a2 + 0x7A1);
  *(_BYTE *)(a1 + 0x788) = 1;
  sub_1403302D0(a1 + 0x760, 0);
  *(_DWORD *)(a1 + 0x7B0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x7B4) = 0;
  *(_QWORD *)(a1 + 0x7B8) = 0;
  *(_QWORD *)(a1 + 0x7C0) = 0;
  *(_QWORD *)(a1 + 0x7C8) = 0;
  *(_DWORD *)(a1 + 0x7D0) = 0x1000000;
  *(_BYTE *)(a1 + 0x7D4) = 0;
  *(_QWORD *)(a1 + 0x7D8) = 0;
  *(_DWORD *)(a1 + 0x7E0) = 0;
  *(_BYTE *)(a1 + 0x800) = 0;
  *(_QWORD *)(a1 + 0x808) = 0;
  *(_QWORD *)(a1 + 0x810) = 0;
  *(_QWORD *)(a1 + 0x818) = 0;
  *(_QWORD *)(a1 + 0x7A8) = off_148A05B18;
  sub_142E31D90((_QWORD *)(a1 + 0x7A8), a2 + 0x7A8);
  *(_DWORD *)(a1 + 0x828) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x82C) = 0;
  *(_QWORD *)(a1 + 0x830) = 0;
  *(_QWORD *)(a1 + 0x838) = 0;
  *(_QWORD *)(a1 + 0x840) = 0;
  *(_DWORD *)(a1 + 0x848) = 0x1000000;
  *(_BYTE *)(a1 + 0x84C) = 0;
  *(_QWORD *)(a1 + 0x850) = 0;
  *(_DWORD *)(a1 + 0x858) = 0;
  *(_BYTE *)(a1 + 0x878) = 0;
  *(_QWORD *)(a1 + 0x880) = 0;
  *(_QWORD *)(a1 + 0x888) = 0;
  *(_QWORD *)(a1 + 0x890) = 0;
  *(_QWORD *)(a1 + 0x820) = off_148A05B18;
  sub_142E31D90((_QWORD *)(a1 + 0x820), a2 + 0x820);
  *(_DWORD *)(a1 + 0x8A0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x8A4) = 0;
  *(_QWORD *)(a1 + 0x8A8) = 0;
  *(_QWORD *)(a1 + 0x8B0) = 0;
  *(_QWORD *)(a1 + 0x8B8) = 0;
  *(_DWORD *)(a1 + 0x8C0) = 0x1000000;
  *(_QWORD *)(a1 + 0x8C8) = 0;
  *(_BYTE *)(a1 + 0x8C4) = 0;
  *(_DWORD *)(a1 + 0x8D0) = 0;
  *(_QWORD *)(a1 + 0x898) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x8E0) = *(_QWORD *)(a2 + 0x8E0);
  *(_BYTE *)(a1 + 0x8C0) = 1;
  sub_1403302D0(a1 + 0x898, 0);
  *(_DWORD *)(a1 + 0x8F0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x8F4) = 0;
  *(_QWORD *)(a1 + 0x8F8) = 0;
  *(_QWORD *)(a1 + 0x900) = 0;
  *(_QWORD *)(a1 + 0x908) = 0;
  *(_DWORD *)(a1 + 0x910) = 0x1000000;
  *(_BYTE *)(a1 + 0x914) = 0;
  *(_QWORD *)(a1 + 0x918) = 0;
  *(_DWORD *)(a1 + 0x920) = 0;
  *(_BYTE *)(a1 + 0x940) = 0;
  *(_QWORD *)(a1 + 0x948) = 0;
  *(_QWORD *)(a1 + 0x950) = 0;
  *(_QWORD *)(a1 + 0x958) = 0;
  *(_QWORD *)(a1 + 0x8E8) = off_148A05B18;
  sub_142E31D90((_QWORD *)(a1 + 0x8E8), a2 + 0x8E8);
  *(_DWORD *)(a1 + 0x968) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x96C) = 0;
  *(_QWORD *)(a1 + 0x970) = 0;
  *(_QWORD *)(a1 + 0x978) = 0;
  *(_QWORD *)(a1 + 0x980) = 0;
  *(_DWORD *)(a1 + 0x988) = 0x1000000;
  *(_QWORD *)(a1 + 0x990) = 0;
  *(_BYTE *)(a1 + 0x98C) = 0;
  *(_DWORD *)(a1 + 0x998) = 0;
  *(_QWORD *)(a1 + 0x960) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x9A8) = *(_QWORD *)(a2 + 0x9A8);
  *(_BYTE *)(a1 + 0x988) = 1;
  sub_1403302D0(a1 + 0x960, 0);
  *(_DWORD *)(a1 + 0x9B8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x9BC) = 0;
  *(_QWORD *)(a1 + 0x9C0) = 0;
  *(_QWORD *)(a1 + 0x9C8) = 0;
  *(_QWORD *)(a1 + 0x9D0) = 0;
  *(_DWORD *)(a1 + 0x9D8) = 0x1000000;
  *(_BYTE *)(a1 + 0x9DC) = 0;
  *(_QWORD *)(a1 + 0x9E0) = 0;
  *(_DWORD *)(a1 + 0x9E8) = 0;
  *(_BYTE *)(a1 + 0xA08) = 0;
  *(_QWORD *)(a1 + 0xA10) = 0;
  *(_QWORD *)(a1 + 0xA18) = 0;
  *(_QWORD *)(a1 + 0xA20) = 0;
  *(_QWORD *)(a1 + 0x9B0) = off_148A05B18;
  sub_142E31D90((_QWORD *)(a1 + 0x9B0), a2 + 0x9B0);
  *(_DWORD *)(a1 + 0xA30) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xA34) = 0;
  *(_QWORD *)(a1 + 0xA38) = 0;
  *(_QWORD *)(a1 + 0xA40) = 0;
  *(_QWORD *)(a1 + 0xA48) = 0;
  *(_DWORD *)(a1 + 0xA50) = 0x1000000;
  *(_QWORD *)(a1 + 0xA58) = 0;
  *(_BYTE *)(a1 + 0xA54) = 0;
  *(_DWORD *)(a1 + 0xA60) = 0;
  *(_QWORD *)(a1 + 0xA28) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0xA70) = *(_QWORD *)(a2 + 0xA70);
  *(_BYTE *)(a1 + 0xA50) = 1;
  sub_1403302D0(a1 + 0xA28, 0);
  *(_DWORD *)(a1 + 0xA80) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xA84) = 0;
  *(_QWORD *)(a1 + 0xA88) = 0;
  *(_QWORD *)(a1 + 0xA90) = 0;
  *(_QWORD *)(a1 + 0xA98) = 0;
  *(_DWORD *)(a1 + 0xAA0) = 0x1000000;
  *(_QWORD *)(a1 + 0xAA8) = 0;
  *(_BYTE *)(a1 + 0xAA4) = 0;
  *(_DWORD *)(a1 + 0xAB0) = 0;
  *(_QWORD *)(a1 + 0xA78) = off_1481AB148;
  *(_BYTE *)(a1 + 0xAB9) = *(_BYTE *)(a2 + 0xAB9);
  *(_BYTE *)(a1 + 0xAA0) = 1;
  sub_1403302D0(a1 + 0xA78, 0);
  sub_14030A1B0(a1 + 0xAC0, a2 + 0xAC0);
  *(_DWORD *)(a1 + 0xAF8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xAFC) = 0;
  *(_QWORD *)(a1 + 0xB00) = 0;
  *(_QWORD *)(a1 + 0xB08) = 0;
  *(_QWORD *)(a1 + 0xB10) = 0;
  *(_DWORD *)(a1 + 0xB18) = 0x1000000;
  *(_QWORD *)(a1 + 0xB20) = 0;
  *(_BYTE *)(a1 + 0xB1C) = 0;
  *(_DWORD *)(a1 + 0xB28) = 0;
  *(_QWORD *)(a1 + 0xAF0) = off_1481AB148;
  *(_BYTE *)(a1 + 0xB31) = *(_BYTE *)(a2 + 0xB31);
  *(_BYTE *)(a1 + 0xB18) = 1;
  sub_1403302D0(a1 + 0xAF0, 0);
  *(_DWORD *)(a1 + 0xB40) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xB44) = 0;
  *(_QWORD *)(a1 + 0xB48) = 0;
  *(_QWORD *)(a1 + 0xB50) = 0;
  *(_QWORD *)(a1 + 0xB58) = 0;
  *(_DWORD *)(a1 + 0xB60) = 0x1000000;
  *(_QWORD *)(a1 + 0xB68) = 0;
  *(_BYTE *)(a1 + 0xB64) = 0;
  *(_DWORD *)(a1 + 0xB70) = 0;
  *(_QWORD *)(a1 + 0xB38) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0xB80) = *(_QWORD *)(a2 + 0xB80);
  *(_BYTE *)(a1 + 0xB60) = 1;
  sub_1403302D0(a1 + 0xB38, 0);
  *(_DWORD *)(a1 + 0xB90) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xB94) = 0;
  *(_QWORD *)(a1 + 0xB98) = 0;
  *(_QWORD *)(a1 + 0xBA0) = 0;
  *(_QWORD *)(a1 + 0xBA8) = 0;
  *(_DWORD *)(a1 + 0xBB0) = 0x1000000;
  *(_QWORD *)(a1 + 0xBB8) = 0;
  *(_BYTE *)(a1 + 0xBB4) = 0;
  *(_DWORD *)(a1 + 0xBC0) = 0;
  *(_QWORD *)(a1 + 0xB88) = off_148424C40;
  *(float *)(a1 + 0xBCC) = *(float *)(a2 + 0xBCC);
  *(_BYTE *)(a1 + 0xBB0) = 1;
  sub_1403302D0(a1 + 0xB88, 0);
  *(_OWORD *)(a1 + 0xBD0) = *(_OWORD *)(a2 + 0xBD0);
  *(_OWORD *)(a1 + 0xBE0) = *(_OWORD *)(a2 + 0xBE0);
  *(_OWORD *)(a1 + 0xBF0) = *(_OWORD *)(a2 + 0xBF0);
  *(double *)(a1 + 0xC00) = *(double *)(a2 + 0xC00);
  *(_DWORD *)(a1 + 0xC08) = *(_DWORD *)(a2 + 0xC08);
  *(_OWORD *)(a1 + 0xC10) = *(_OWORD *)(a2 + 0xC10);
  *(_DWORD *)(a1 + 0xC20) = *(_DWORD *)(a2 + 0xC20);
  *(_DWORD *)(a1 + 0xC24) = *(_DWORD *)(a2 + 0xC24);
  *(_QWORD *)(a1 + 0xC28) = off_1481ABEC0;
  *(_QWORD *)(a1 + 0xC30) = off_1481ABE90;
  *(_QWORD *)(a1 + 0xC38) = *(_QWORD *)(a2 + 0xC38);
  *(_QWORD *)(a1 + 0xC40) = *(_QWORD *)(a2 + 0xC40);
  *(_QWORD *)(a1 + 0xC48) = *(_QWORD *)(a2 + 0xC48);
  *(_QWORD *)(a1 + 0xC50) = off_1481ABEC0;
  *(_QWORD *)(a1 + 0xC58) = off_1481ABE90;
  *(_QWORD *)(a1 + 0xC60) = *(_QWORD *)(a2 + 0xC60);
  *(_QWORD *)(a1 + 0xC68) = off_1481ABEC0;
  *(_QWORD *)(a1 + 0xC70) = off_1481ABE90;
  *(_QWORD *)(a1 + 0xC78) = *(_QWORD *)(a2 + 0xC78);
  *(_QWORD *)(a1 + 0xC80) = off_1481ABEC0;
  *(_QWORD *)(a1 + 0xC88) = off_1481ABE90;
  *(_QWORD *)(a1 + 0xC90) = *(_QWORD *)(a2 + 0xC90);
  *(_QWORD *)(a1 + 0xC98) = off_1481ABEC0;
  *(_QWORD *)(a1 + 0xCA0) = off_1481ABE90;
  *(_QWORD *)(a1 + 0xCA8) = *(_QWORD *)(a2 + 0xCA8);
  *(_QWORD *)(a1 + 0xCB0) = off_1481ABEC0;
  *(_QWORD *)(a1 + 0xCB8) = off_1481ABE90;
  *(_QWORD *)(a1 + 0xCC0) = *(_QWORD *)(a2 + 0xCC0);
  *(_QWORD *)(a1 + 0xCC8) = 0;
  *(_QWORD *)(a1 + 0xCD0) = 0;
  v4 = allocWithProfilerInfo_w(0x30u);
  *(_QWORD *)v4 = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)(v4 + 0x10) = v4;
  *(_WORD *)(v4 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0xCC8) = v4;
  *(_QWORD *)(a1 + 0xCC8) = *(_QWORD *)(a2 + 0xCC8);
  *(_QWORD *)(a2 + 0xCC8) = v4;
  v5 = *(_QWORD *)(a1 + 0xCD0);
  *(_QWORD *)(a1 + 0xCD0) = *(_QWORD *)(a2 + 0xCD0);
  *(_QWORD *)(a2 + 0xCD0) = v5;
  *(_QWORD *)(a1 + 0xCD8) = *(_QWORD *)(a2 + 0xCD8);
  *(_DWORD *)(a1 + 0xCE0) = *(_DWORD *)(a2 + 0xCE0);
  *(_DWORD *)(a1 + 0xCE4) = *(_DWORD *)(a2 + 0xCE4);
  *(_DWORD *)(a1 + 0xCE8) = *(_DWORD *)(a2 + 0xCE8);
  *(_BYTE *)(a1 + 0xCEC) = *(_BYTE *)(a2 + 0xCEC);
  *(_DWORD *)(a1 + 0xCF0) = *(_DWORD *)(a2 + 0xCF0);
  *(_OWORD *)(a1 + 0xCF8) = *(_OWORD *)(a2 + 0xCF8);
  *(_QWORD *)(a1 + 0xD08) = 0;
  *(_QWORD *)(a1 + 0xD10) = 0;
  v6 = allocWithProfilerInfo_w(0x50u);
  *(_QWORD *)v6 = v6;
  *(_QWORD *)(v6 + 8) = v6;
  *(_QWORD *)(v6 + 0x10) = v6;
  *(_WORD *)(v6 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0xD08) = v6;
  *(_QWORD *)(a1 + 0xD08) = *(_QWORD *)(a2 + 0xD08);
  *(_QWORD *)(a2 + 0xD08) = v6;
  v7 = *(_QWORD *)(a1 + 0xD10);
  *(_QWORD *)(a1 + 0xD10) = *(_QWORD *)(a2 + 0xD10);
  *(_QWORD *)(a2 + 0xD10) = v7;
  *(_DWORD *)(a1 + 0xD18) = *(_DWORD *)(a2 + 0xD18);
  *(_DWORD *)(a1 + 0xD1C) = *(_DWORD *)(a2 + 0xD1C);
  return a1;
}

// --- End Function: sub_144C2CF00 (0x144C2CF00) ---

// --- Function: sub_144C2E780 (0x144C2E780) ---
__int64 __fastcall sub_144C2E780(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 result; // rax

  *(_DWORD *)(a1 + 8) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = 0;
  *(_QWORD *)(a1 + 0x20) = 0;
  *(_BYTE *)(a1 + 0x2C) = 0;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0x38) = 0;
  *(_WORD *)(a1 + 0x40) = 0xFFFF;
  *(_QWORD *)a1 = off_148A05CA0;
  *(_BYTE *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x1000000;
  sub_14030A470(a1 + 0x48);
  sub_14157AE20(a1 + 0x98);
  *(_DWORD *)(a1 + 0xF0) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x138) = off_148424C40;
  *(_QWORD *)(a1 + 0xE8) = off_1481AB2A8;
  *(_QWORD *)(a1 + 0x180) = off_148424C40;
  *(_QWORD *)(a1 + 0x1C8) = off_148424C40;
  *(_QWORD *)(a1 + 0x210) = off_148424C40;
  *(_BYTE *)(a1 + 0xF4) = 0;
  *(_QWORD *)(a1 + 0xF8) = 0;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_DWORD *)(a1 + 0x110) = 0x1000000;
  *(_BYTE *)(a1 + 0x114) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_DWORD *)(a1 + 0x120) = 0;
  *(_DWORD *)(a1 + 0x140) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x144) = 0;
  *(_QWORD *)(a1 + 0x148) = 0;
  *(_QWORD *)(a1 + 0x150) = 0;
  *(_QWORD *)(a1 + 0x158) = 0;
  *(_DWORD *)(a1 + 0x160) = 0x1000000;
  *(_BYTE *)(a1 + 0x164) = 0;
  *(_QWORD *)(a1 + 0x168) = 0;
  *(_DWORD *)(a1 + 0x170) = 0;
  *(_DWORD *)(a1 + 0x188) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x18C) = 0;
  *(_QWORD *)(a1 + 0x190) = 0;
  *(_QWORD *)(a1 + 0x198) = 0;
  *(_QWORD *)(a1 + 0x1A0) = 0;
  *(_DWORD *)(a1 + 0x1A8) = 0x1000000;
  *(_BYTE *)(a1 + 0x1AC) = 0;
  *(_QWORD *)(a1 + 0x1B0) = 0;
  *(_DWORD *)(a1 + 0x1B8) = 0;
  *(_DWORD *)(a1 + 0x1D0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x1D4) = 0;
  *(_QWORD *)(a1 + 0x1D8) = 0;
  *(_QWORD *)(a1 + 0x1E0) = 0;
  *(_QWORD *)(a1 + 0x1E8) = 0;
  *(_DWORD *)(a1 + 0x1F0) = 0x1000000;
  *(_BYTE *)(a1 + 0x1F4) = 0;
  *(_QWORD *)(a1 + 0x1F8) = 0;
  *(_DWORD *)(a1 + 0x200) = 0;
  *(_DWORD *)(a1 + 0x218) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x21C) = 0;
  *(_QWORD *)(a1 + 0x220) = 0;
  *(_QWORD *)(a1 + 0x228) = 0;
  *(_QWORD *)(a1 + 0x230) = 0;
  *(_DWORD *)(a1 + 0x238) = 0x1000000;
  *(_BYTE *)(a1 + 0x23C) = 0;
  *(_QWORD *)(a1 + 0x240) = 0;
  *(_DWORD *)(a1 + 0x248) = 0;
  *(_DWORD *)(a1 + 0x260) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x264) = 0;
  *(_QWORD *)(a1 + 0x268) = 0;
  *(_QWORD *)(a1 + 0x270) = 0;
  *(_QWORD *)(a1 + 0x278) = 0;
  *(_DWORD *)(a1 + 0x280) = 0x1000000;
  *(_BYTE *)(a1 + 0x284) = 0;
  *(_QWORD *)(a1 + 0x288) = 0;
  *(_DWORD *)(a1 + 0x290) = 0;
  *(_QWORD *)(a1 + 0x258) = off_1481AB148;
  *(_DWORD *)(a1 + 0x2A8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x2AC) = 0;
  *(_QWORD *)(a1 + 0x2B0) = 0;
  *(_QWORD *)(a1 + 0x2B8) = 0;
  *(_QWORD *)(a1 + 0x2C0) = 0;
  *(_DWORD *)(a1 + 0x2C8) = 0x1000000;
  *(_BYTE *)(a1 + 0x2CC) = 0;
  *(_QWORD *)(a1 + 0x2D0) = 0;
  *(_DWORD *)(a1 + 0x2D8) = 0;
  *(_QWORD *)(a1 + 0x2A0) = off_1481AB2A8;
  sub_14157AE20(a1 + 0x2F0);
  *(_DWORD *)(a1 + 0x348) = 0xFFFFFFFF;
  *(_QWORD *)(a1 + 0x428) = off_1481ACC20;
  *(_QWORD *)(a1 + 0x458) = off_1481ACC20;
  *(_QWORD *)(a1 + 0x488) = off_1481ACC20;
  *(_QWORD *)(a1 + 0x4B8) = off_1481ACC20;
  *(_QWORD *)(a1 + 0x4E8) = off_1481ACC20;
  *(_BYTE *)(a1 + 0x34C) = 0;
  *(_QWORD *)(a1 + 0x350) = 0;
  *(_QWORD *)(a1 + 0x358) = 0;
  *(_QWORD *)(a1 + 0x360) = 0;
  *(_DWORD *)(a1 + 0x368) = 0x1000000;
  *(_BYTE *)(a1 + 0x36C) = 0;
  *(_QWORD *)(a1 + 0x370) = 0;
  *(_DWORD *)(a1 + 0x378) = 0;
  *(_QWORD *)(a1 + 0x340) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0x398) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x39C) = 0;
  *(_QWORD *)(a1 + 0x3A0) = 0;
  *(_QWORD *)(a1 + 0x3A8) = 0;
  *(_QWORD *)(a1 + 0x3B0) = 0;
  *(_DWORD *)(a1 + 0x3B8) = 0x1000000;
  *(_BYTE *)(a1 + 0x3BC) = 0;
  *(_QWORD *)(a1 + 0x3C0) = 0;
  *(_DWORD *)(a1 + 0x3C8) = 0;
  *(_QWORD *)(a1 + 0x390) = off_1481AB148;
  *(_DWORD *)(a1 + 0x3E0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x3E4) = 0;
  *(_QWORD *)(a1 + 0x3E8) = 0;
  *(_QWORD *)(a1 + 0x3F0) = 0;
  *(_QWORD *)(a1 + 0x3F8) = 0;
  *(_DWORD *)(a1 + 0x400) = 0x1000000;
  *(_BYTE *)(a1 + 0x404) = 0;
  *(_QWORD *)(a1 + 0x408) = 0;
  *(_DWORD *)(a1 + 0x410) = 0;
  *(_QWORD *)(a1 + 0x3D8) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0x430) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x434) = 0;
  *(_QWORD *)(a1 + 0x438) = 0;
  *(_QWORD *)(a1 + 0x440) = 0;
  *(_QWORD *)(a1 + 0x448) = 0;
  *(_WORD *)(a1 + 0x450) = 0xFFFF;
  *(_DWORD *)(a1 + 0x460) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x464) = 0;
  *(_QWORD *)(a1 + 0x468) = 0;
  *(_QWORD *)(a1 + 0x470) = 0;
  *(_QWORD *)(a1 + 0x478) = 0;
  *(_WORD *)(a1 + 0x480) = 0xFFFF;
  *(_DWORD *)(a1 + 0x490) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x494) = 0;
  *(_QWORD *)(a1 + 0x498) = 0;
  *(_QWORD *)(a1 + 0x4A0) = 0;
  *(_QWORD *)(a1 + 0x4A8) = 0;
  *(_WORD *)(a1 + 0x4B0) = 0xFFFF;
  *(_DWORD *)(a1 + 0x4C0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x4C4) = 0;
  *(_QWORD *)(a1 + 0x4C8) = 0;
  *(_QWORD *)(a1 + 0x4D0) = 0;
  *(_QWORD *)(a1 + 0x4D8) = 0;
  *(_WORD *)(a1 + 0x4E0) = 0xFFFF;
  *(_DWORD *)(a1 + 0x4F0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x4F4) = 0;
  *(_QWORD *)(a1 + 0x4F8) = 0;
  *(_QWORD *)(a1 + 0x500) = 0;
  *(_QWORD *)(a1 + 0x508) = 0;
  *(_WORD *)(a1 + 0x510) = 0xFFFF;
  *(_DWORD *)(a1 + 0x520) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x524) = 0;
  *(_QWORD *)(a1 + 0x528) = 0;
  *(_QWORD *)(a1 + 0x530) = 0;
  *(_QWORD *)(a1 + 0x538) = 0;
  *(_QWORD *)(a1 + 0x518) = off_1481ACC20;
  *(_WORD *)(a1 + 0x540) = 0xFFFF;
  *(_DWORD *)(a1 + 0x550) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x554) = 0;
  *(_QWORD *)(a1 + 0x558) = 0;
  *(_QWORD *)(a1 + 0x560) = 0;
  *(_QWORD *)(a1 + 0x568) = 0;
  *(_DWORD *)(a1 + 0x570) = 0x1000000;
  *(_BYTE *)(a1 + 0x574) = 0;
  *(_QWORD *)(a1 + 0x578) = 0;
  *(_DWORD *)(a1 + 0x580) = 0;
  *(_QWORD *)(a1 + 0x548) = off_1481AB148;
  *(_DWORD *)(a1 + 0x598) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x59C) = 0;
  *(_QWORD *)(a1 + 0x5A0) = 0;
  *(_QWORD *)(a1 + 0x5A8) = 0;
  *(_QWORD *)(a1 + 0x5B0) = 0;
  *(_DWORD *)(a1 + 0x5B8) = 0x1000000;
  *(_BYTE *)(a1 + 0x5BC) = 0;
  *(_QWORD *)(a1 + 0x5C0) = 0;
  *(_DWORD *)(a1 + 0x5C8) = 0;
  *(_QWORD *)(a1 + 0x590) = off_1481AB2A8;
  sub_14030A470(a1 + 0x5E0);
  *(_DWORD *)(a1 + 0x638) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x63C) = 0;
  *(_QWORD *)(a1 + 0x640) = 0;
  *(_QWORD *)(a1 + 0x648) = 0;
  *(_QWORD *)(a1 + 0x650) = 0;
  *(_DWORD *)(a1 + 0x658) = 0x1000000;
  *(_BYTE *)(a1 + 0x65C) = 0;
  *(_QWORD *)(a1 + 0x660) = 0;
  *(_DWORD *)(a1 + 0x668) = 0;
  *(_QWORD *)(a1 + 0x630) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0x688) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x68C) = 0;
  *(_QWORD *)(a1 + 0x690) = 0;
  *(_QWORD *)(a1 + 0x698) = 0;
  *(_QWORD *)(a1 + 0x6A0) = 0;
  *(_DWORD *)(a1 + 0x6A8) = 0x1000000;
  *(_BYTE *)(a1 + 0x6AC) = 0;
  *(_QWORD *)(a1 + 0x6B0) = 0;
  *(_DWORD *)(a1 + 0x6B8) = 0;
  *(_QWORD *)(a1 + 0x680) = off_148424C40;
  *(_DWORD *)(a1 + 0x6D0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x6D4) = 0;
  *(_QWORD *)(a1 + 0x6D8) = 0;
  *(_QWORD *)(a1 + 0x6E0) = 0;
  *(_QWORD *)(a1 + 0x6E8) = 0;
  *(_DWORD *)(a1 + 0x6F0) = 0x1000000;
  *(_BYTE *)(a1 + 0x6F4) = 0;
  *(_QWORD *)(a1 + 0x6F8) = 0;
  *(_DWORD *)(a1 + 0x700) = 0;
  *(_QWORD *)(a1 + 0x6C8) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0x720) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x724) = 0;
  *(_QWORD *)(a1 + 0x728) = 0;
  *(_QWORD *)(a1 + 0x730) = 0;
  *(_QWORD *)(a1 + 0x738) = 0;
  *(_DWORD *)(a1 + 0x740) = 0x1000000;
  *(_BYTE *)(a1 + 0x744) = 0;
  *(_QWORD *)(a1 + 0x748) = 0;
  *(_DWORD *)(a1 + 0x750) = 0;
  *(_QWORD *)(a1 + 0x718) = off_1481AB148;
  *(_DWORD *)(a1 + 0x768) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x76C) = 0;
  *(_QWORD *)(a1 + 0x770) = 0;
  *(_QWORD *)(a1 + 0x778) = 0;
  *(_QWORD *)(a1 + 0x780) = 0;
  *(_DWORD *)(a1 + 0x788) = 0x1000000;
  *(_BYTE *)(a1 + 0x78C) = 0;
  *(_QWORD *)(a1 + 0x790) = 0;
  *(_DWORD *)(a1 + 0x798) = 0;
  *(_QWORD *)(a1 + 0x760) = off_1481AB148;
  *(_DWORD *)(a1 + 0x7B0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x7B4) = 0;
  *(_QWORD *)(a1 + 0x7B8) = 0;
  *(_QWORD *)(a1 + 0x7C0) = 0;
  *(_QWORD *)(a1 + 0x7C8) = 0;
  *(_QWORD *)(a1 + 0x7A8) = off_148A05B18;
  *(_QWORD *)(a1 + 0x820) = off_148A05B18;
  *(_QWORD *)(a1 + 0x8E8) = off_148A05B18;
  *(_QWORD *)(a1 + 0x9B0) = off_148A05B18;
  *(_DWORD *)(a1 + 0x7D0) = 0x1000000;
  *(_BYTE *)(a1 + 0x7D4) = 0;
  *(_QWORD *)(a1 + 0x7D8) = 0;
  *(_DWORD *)(a1 + 0x7E0) = 0;
  *(_BYTE *)(a1 + 0x800) = 0;
  *(_QWORD *)(a1 + 0x808) = 0;
  *(_QWORD *)(a1 + 0x810) = 0;
  *(_QWORD *)(a1 + 0x818) = 0;
  *(_DWORD *)(a1 + 0x828) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x82C) = 0;
  *(_QWORD *)(a1 + 0x830) = 0;
  *(_QWORD *)(a1 + 0x838) = 0;
  *(_QWORD *)(a1 + 0x840) = 0;
  *(_DWORD *)(a1 + 0x848) = 0x1000000;
  *(_BYTE *)(a1 + 0x84C) = 0;
  *(_QWORD *)(a1 + 0x850) = 0;
  *(_DWORD *)(a1 + 0x858) = 0;
  *(_BYTE *)(a1 + 0x878) = 0;
  *(_QWORD *)(a1 + 0x880) = 0;
  *(_QWORD *)(a1 + 0x888) = 0;
  *(_QWORD *)(a1 + 0x890) = 0;
  *(_DWORD *)(a1 + 0x8A0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x8A4) = 0;
  *(_QWORD *)(a1 + 0x8A8) = 0;
  *(_QWORD *)(a1 + 0x8B0) = 0;
  *(_QWORD *)(a1 + 0x8B8) = 0;
  *(_DWORD *)(a1 + 0x8C0) = 0x1000000;
  *(_BYTE *)(a1 + 0x8C4) = 0;
  *(_QWORD *)(a1 + 0x8C8) = 0;
  *(_DWORD *)(a1 + 0x8D0) = 0;
  *(_QWORD *)(a1 + 0x898) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0x8F0) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x8F4) = 0;
  *(_QWORD *)(a1 + 0x8F8) = 0;
  *(_QWORD *)(a1 + 0x900) = 0;
  *(_QWORD *)(a1 + 0x908) = 0;
  *(_DWORD *)(a1 + 0x910) = 0x1000000;
  *(_BYTE *)(a1 + 0x914) = 0;
  *(_QWORD *)(a1 + 0x918) = 0;
  *(_DWORD *)(a1 + 0x920) = 0;
  *(_BYTE *)(a1 + 0x940) = 0;
  *(_QWORD *)(a1 + 0x948) = 0;
  *(_QWORD *)(a1 + 0x950) = 0;
  *(_QWORD *)(a1 + 0x958) = 0;
  *(_DWORD *)(a1 + 0x968) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x96C) = 0;
  *(_QWORD *)(a1 + 0x970) = 0;
  *(_QWORD *)(a1 + 0x978) = 0;
  *(_QWORD *)(a1 + 0x980) = 0;
  *(_DWORD *)(a1 + 0x988) = 0x1000000;
  *(_BYTE *)(a1 + 0x98C) = 0;
  *(_QWORD *)(a1 + 0x990) = 0;
  *(_DWORD *)(a1 + 0x998) = 0;
  *(_QWORD *)(a1 + 0x960) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0x9B8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0x9BC) = 0;
  *(_QWORD *)(a1 + 0x9C0) = 0;
  *(_QWORD *)(a1 + 0x9C8) = 0;
  *(_QWORD *)(a1 + 0x9D0) = 0;
  *(_DWORD *)(a1 + 0x9D8) = 0x1000000;
  *(_BYTE *)(a1 + 0x9DC) = 0;
  *(_QWORD *)(a1 + 0x9E0) = 0;
  *(_DWORD *)(a1 + 0x9E8) = 0;
  *(_BYTE *)(a1 + 0xA08) = 0;
  *(_QWORD *)(a1 + 0xA10) = 0;
  *(_QWORD *)(a1 + 0xA18) = 0;
  *(_QWORD *)(a1 + 0xA20) = 0;
  *(_DWORD *)(a1 + 0xA30) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xA34) = 0;
  *(_QWORD *)(a1 + 0xA38) = 0;
  *(_QWORD *)(a1 + 0xA40) = 0;
  *(_QWORD *)(a1 + 0xA48) = 0;
  *(_DWORD *)(a1 + 0xA50) = 0x1000000;
  *(_BYTE *)(a1 + 0xA54) = 0;
  *(_QWORD *)(a1 + 0xA58) = 0;
  *(_DWORD *)(a1 + 0xA60) = 0;
  *(_QWORD *)(a1 + 0xA28) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0xA80) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xA84) = 0;
  *(_QWORD *)(a1 + 0xA88) = 0;
  *(_QWORD *)(a1 + 0xA90) = 0;
  *(_QWORD *)(a1 + 0xA98) = 0;
  *(_DWORD *)(a1 + 0xAA0) = 0x1000000;
  *(_BYTE *)(a1 + 0xAA4) = 0;
  *(_QWORD *)(a1 + 0xAA8) = 0;
  *(_DWORD *)(a1 + 0xAB0) = 0;
  *(_QWORD *)(a1 + 0xA78) = off_1481AB148;
  *(_DWORD *)(a1 + 0xAC8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xACC) = 0;
  *(_QWORD *)(a1 + 0xAD0) = 0;
  *(_QWORD *)(a1 + 0xAD8) = 0;
  *(_QWORD *)(a1 + 0xAE0) = 0;
  *(_QWORD *)(a1 + 0xAC0) = off_1481ACC20;
  *(_WORD *)(a1 + 0xAE8) = 0xFFFF;
  *(_DWORD *)(a1 + 0xAF8) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xAFC) = 0;
  *(_QWORD *)(a1 + 0xB00) = 0;
  *(_QWORD *)(a1 + 0xB08) = 0;
  *(_QWORD *)(a1 + 0xB10) = 0;
  *(_DWORD *)(a1 + 0xB18) = 0x1000000;
  *(_BYTE *)(a1 + 0xB1C) = 0;
  *(_QWORD *)(a1 + 0xB20) = 0;
  *(_DWORD *)(a1 + 0xB28) = 0;
  *(_QWORD *)(a1 + 0xAF0) = off_1481AB148;
  *(_DWORD *)(a1 + 0xB40) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xB44) = 0;
  *(_QWORD *)(a1 + 0xB48) = 0;
  *(_QWORD *)(a1 + 0xB50) = 0;
  *(_QWORD *)(a1 + 0xB58) = 0;
  *(_DWORD *)(a1 + 0xB60) = 0x1000000;
  *(_BYTE *)(a1 + 0xB64) = 0;
  *(_QWORD *)(a1 + 0xB68) = 0;
  *(_DWORD *)(a1 + 0xB70) = 0;
  *(_QWORD *)(a1 + 0xB38) = off_1481AB2A8;
  *(_DWORD *)(a1 + 0xB90) = 0xFFFFFFFF;
  *(_BYTE *)(a1 + 0xB94) = 0;
  *(_QWORD *)(a1 + 0xB98) = 0;
  *(_QWORD *)(a1 + 0xBA0) = 0;
  *(_QWORD *)(a1 + 0xBA8) = 0;
  *(_DWORD *)(a1 + 0xBB0) = 0x1000000;
  *(_BYTE *)(a1 + 0xBB4) = 0;
  *(_QWORD *)(a1 + 0xBB8) = 0;
  *(_DWORD *)(a1 + 0xBC0) = 0;
  *(_QWORD *)(a1 + 0xB88) = off_148424C40;
  sub_140458AF0(a1 + 0xBD0);
  *(_QWORD *)(a1 + 0xBE0) = 0;
  *(_QWORD *)(a1 + 0xBE8) = 0;
  *(_QWORD *)(a1 + 0xBF0) = 0;
  *(_DWORD *)(a1 + 0xBF8) = 8;
  *(_QWORD *)(a1 + 0xC00) = 0;
  *(_DWORD *)(a1 + 0xC08) = 0xB9;
  *(_QWORD *)(a1 + 0xC10) = 0;
  *(_QWORD *)(a1 + 0xC18) = 0;
  *(_DWORD *)(a1 + 0xC20) = 1;
  *(_DWORD *)(a1 + 0xC24) = 6;
  sub_14036A7C0((_QWORD *)(a1 + 0xC28));
  *(_QWORD *)(a1 + 0xC40) = 0;
  *(_QWORD *)(a1 + 0xC48) = 0;
  sub_14036A7C0((_QWORD *)(a1 + 0xC50));
  sub_14036A7C0((_QWORD *)(a1 + 0xC68));
  sub_14036A7C0((_QWORD *)(a1 + 0xC80));
  sub_14036A7C0((_QWORD *)(a1 + 0xC98));
  sub_14036A7C0((_QWORD *)(a1 + 0xCB0));
  *(_QWORD *)(a1 + 0xCC8) = 0;
  *(_QWORD *)(a1 + 0xCD0) = 0;
  v2 = allocWithProfilerInfo_w(0x30u);
  *(_QWORD *)v2 = v2;
  *(_QWORD *)(v2 + 8) = v2;
  *(_QWORD *)(v2 + 0x10) = v2;
  *(_WORD *)(v2 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0xCC8) = v2;
  *(_QWORD *)(a1 + 0xCD8) = 0xF4240;
  *(_QWORD *)(a1 + 0xCE0) = 0;
  *(_DWORD *)(a1 + 0xCE8) = 0;
  *(_BYTE *)(a1 + 0xCEC) = 0;
  *(_DWORD *)(a1 + 0xCF0) = 0;
  *(_QWORD *)(a1 + 0xCF8) = 0;
  *(_QWORD *)(a1 + 0xD00) = 0;
  *(_QWORD *)(a1 + 0xD08) = 0;
  *(_QWORD *)(a1 + 0xD10) = 0;
  v3 = allocWithProfilerInfo_w(0x50u);
  *(_QWORD *)v3 = v3;
  *(_QWORD *)(v3 + 8) = v3;
  *(_QWORD *)(v3 + 0x10) = v3;
  *(_WORD *)(v3 + 0x18) = 0x101;
  *(_QWORD *)(a1 + 0xD08) = v3;
  result = a1;
  *(_QWORD *)(a1 + 0xD18) = 0;
  return result;
}

// --- End Function: sub_144C2E780 (0x144C2E780) ---

// --- Function: sub_144C3F0D0 (0x144C3F0D0) ---
__int64 __fastcall sub_144C3F0D0(__int64 a1)
{
  sub_144BCBCD0(a1 + 0xD08, a1 + 0xD08, *(const void ***)(*(_QWORD *)(a1 + 0xD08) + 8LL));
  sub_1402A3D30(*(const void **)(a1 + 0xD08));
  sub_1402A7E90(
    (std::_Tree_val<std::_Tree_simple_types<std::pair<double const ,int> > > *)(a1 + 0xCC8),
    (std::allocator<std::_Tree_node<std::pair<double const ,int>,void *> > *)(a1 + 0xCC8));
  sub_14030C070((__int64 *)(a1 + 0xB88));
  sub_14030C070((__int64 *)(a1 + 0xB38));
  sub_14030C070((__int64 *)(a1 + 0xAF0));
  sub_14030C0C0(a1 + 0xAC0);
  sub_14030C070((__int64 *)(a1 + 0xA78));
  sub_14030C070((__int64 *)(a1 + 0xA28));
  sub_142E84FE0(a1 + 0xA10);
  sub_141580E30(a1 + 0x9F0);
  sub_14030C070((__int64 *)(a1 + 0x9B0));
  sub_14030C070((__int64 *)(a1 + 0x960));
  sub_142E84FE0(a1 + 0x948);
  sub_141580E30(a1 + 0x928);
  sub_14030C070((__int64 *)(a1 + 0x8E8));
  sub_14030C070((__int64 *)(a1 + 0x898));
  sub_142E84FE0(a1 + 0x880);
  sub_141580E30(a1 + 0x860);
  sub_14030C070((__int64 *)(a1 + 0x820));
  sub_142E84FE0(a1 + 0x808);
  sub_141580E30(a1 + 0x7E8);
  sub_14030C070((__int64 *)(a1 + 0x7A8));
  sub_14030C070((__int64 *)(a1 + 0x760));
  sub_14030C070((__int64 *)(a1 + 0x718));
  sub_14030C070((__int64 *)(a1 + 0x6C8));
  sub_14030C070((__int64 *)(a1 + 0x680));
  sub_14030C070((__int64 *)(a1 + 0x630));
  sub_140370D10((_QWORD *)(a1 + 0x628));
  sub_140370D10((_QWORD *)(a1 + 0x620));
  sub_14030C070((__int64 *)(a1 + 0x5E0));
  sub_14030C070((__int64 *)(a1 + 0x590));
  sub_14030C070((__int64 *)(a1 + 0x548));
  sub_14030C0C0(a1 + 0x518);
  sub_14030C0C0(a1 + 0x4E8);
  sub_14030C0C0(a1 + 0x4B8);
  sub_14030C0C0(a1 + 0x488);
  sub_14030C0C0(a1 + 0x458);
  sub_14030C0C0(a1 + 0x428);
  sub_14030C070((__int64 *)(a1 + 0x3D8));
  sub_14030C070((__int64 *)(a1 + 0x390));
  sub_14030C070((__int64 *)(a1 + 0x340));
  sub_140370D10((_QWORD *)(a1 + 0x338));
  sub_140370D10((_QWORD *)(a1 + 0x330));
  sub_14030C070((__int64 *)(a1 + 0x2F0));
  sub_14030C070((__int64 *)(a1 + 0x2A0));
  sub_14030C070((__int64 *)(a1 + 0x258));
  sub_14030C070((__int64 *)(a1 + 0x210));
  sub_14030C070((__int64 *)(a1 + 0x1C8));
  sub_14030C070((__int64 *)(a1 + 0x180));
  sub_14030C070((__int64 *)(a1 + 0x138));
  sub_14030C070((__int64 *)(a1 + 0xE8));
  sub_140370D10((_QWORD *)(a1 + 0xE0));
  sub_140370D10((_QWORD *)(a1 + 0xD8));
  sub_14030C070((__int64 *)(a1 + 0x98));
  sub_140370D10((_QWORD *)(a1 + 0x90));
  sub_140370D10((_QWORD *)(a1 + 0x88));
  sub_14030C070((__int64 *)(a1 + 0x48));
  return sub_14030C070((__int64 *)a1);
}

// --- End Function: sub_144C3F0D0 (0x144C3F0D0) ---

// --- Function: sub_144C41280 (0x144C41280) ---
void __fastcall sub_144C41280(__int64 *a1)
{
  __int64 v1; // rbp
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // r14
  __int64 v4; // rdi
  __int64 *v5; // rsi
  __int64 v6; // r13
  __int64 v7; // rcx
  __int64 *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // r15
  unsigned int *v11; // rax
  unsigned int *v12; // rax
  int v13; // [rsp+20h] [rbp-298h]
  unsigned int v14; // [rsp+30h] [rbp-288h] BYREF
  void (__fastcall *v15)(__int64, __int64 *, unsigned int *, _QWORD *, int); // [rsp+38h] [rbp-280h]
  _BYTE v16[8]; // [rsp+40h] [rbp-278h] BYREF
  _BYTE v17[8]; // [rsp+48h] [rbp-270h] BYREF
  __int64 v18; // [rsp+50h] [rbp-268h] BYREF
  __int64 v19; // [rsp+60h] [rbp-258h] BYREF
  __int64 n0x1FF; // [rsp+68h] [rbp-250h]
  unsigned __int8 *v21; // [rsp+70h] [rbp-248h]
  _BYTE v22[520]; // [rsp+78h] [rbp-240h] BYREF

  v1 = *a1;
  if ( sub_14030ECC0(*a1 + 8) )
  {
    v2 = 0;
    v3 = (*(_QWORD *)(v1 + 0x68) - *(_QWORD *)(v1 + 0x60)) / 0xD20LL;
    if ( v3 )
    {
      v4 = 0;
      do
      {
        v5 = (__int64 *)(v4 + *(_QWORD *)(v1 + 0x60));
        if ( sub_14030ECC0(v1 + 8) )
        {
          v22[0] = 0;
          v21 = v22;
          v19 = 0;
          n0x1FF = 0x1FF;
          sub_1402A3190((__int64)&v19, "[%04llu]", v2);
          v6 = sub_14030ED10(v1 + 8);
          v7 = *v5;
          v15 = *(void (__fastcall **)(__int64, __int64 *, unsigned int *, _QWORD *, int))(*(_QWORD *)v6 + 8LL);
          v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64 *, _BYTE *))(v7 + 0x20))(v5, v16);
          if ( is_valid_handle_typeA(v8) )
            v9 = (_QWORD *)(*(__int64 (__fastcall **)(__int64 *, _BYTE *))(*v5 + 0x20))(v5, v17);
          else
            v9 = sub_1403297E0(v1, &v18);
          v10 = v9;
          v11 = (unsigned int *)sub_1402E07B0(v1);
          v12 = sub_14030A1F0(&v14, v11, v21);
          LOWORD(v13) = v2;
          v15(v6, v5, v12, v10, v13);
          if ( v21 != v22 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
            sub_147605980(v21);
          }
        }
        ++v2;
        v4 += 0xD20;
      }
      while ( v2 < v3 );
    }
  }
}

// --- End Function: sub_144C41280 (0x144C41280) ---

// --- Function: sub_144C5B6A0 (0x144C5B6A0) ---
void __fastcall sub_144C5B6A0(_QWORD *a1, __int64 a2)
{
  __int128 v2; // xmm6
  __int64 v3; // rdi
  __int64 v4; // r13
  int v5; // ebx
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 *ThreadLogContextSlot; // rax
  char v9; // al
  __int64 v10; // rdx
  char v11; // bl
  __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // r12
  __int64 (__fastcall ***v14)(_QWORD, __int128 *); // rax
  __int64 (__fastcall ***v15)(_QWORD); // rax
  __int64 v16; // rax
  int v17; // ebx
  __int64 *ThreadLogContextSlot_1; // rax
  bool v19; // bl
  float v20; // xmm8_4
  bool v21; // al
  const void **v22; // rax
  const void **v23; // rbx
  __int64 v24; // rax
  _QWORD *v25; // rax
  __int64 v29; // rbx
  __int64 v30; // rax
  _QWORD *v31; // rax
  _QWORD *v32; // rax
  float v35; // xmm0_4
  float v36; // kr00_4
  __int64 v37; // r15
  unsigned int n8_1; // ebx
  __m128 v41; // xmm0
  __int128 v45; // kr00_16
  char *v47; // rbx
  char *v48; // rsi
  char v49; // al
  __int64 v50; // rax
  int v51; // ebx
  __int64 v52; // rdx
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rcx
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 v58; // rax
  __int64 *ThreadLogContextSlot_3; // rax
  int v60; // ebx
  __int64 v61; // rcx
  __int64 *ThreadLogContextSlot_4; // rax
  float v63; // xmm6_4
  __int64 v64; // rbx
  __int64 v65; // rax
  float v66; // xmm1_4
  float v67; // xmm0_4
  _BYTE *v68; // rcx
  _LocaleUpdate *v69; // rcx
  const void **v70; // rax
  const void **v71; // rbx
  __int64 v72; // rax
  _QWORD *v73; // rax
  __int64 v77; // rbx
  __int64 v78; // rax
  _QWORD *v79; // rax
  _QWORD *v80; // rax
  float v83; // xmm0_4
  float v84; // kr00_4
  __int64 v85; // r12
  int n8; // ebx
  _QWORD *v87; // r15
  __m128 v90; // xmm0
  __int128 v94; // kr00_16
  int v96; // ebx
  __int64 v97; // rcx
  __int64 v98; // rax
  __int64 *ThreadLogContextSlot_2; // rax
  __int64 v100; // rbx
  __int64 v101; // rax
  float v102; // xmm1_4
  float v103; // xmm0_4
  _BYTE *v104; // rcx
  _LocaleUpdate *v105; // rcx
  int v106; // esi
  __int64 v107; // rax
  _BYTE *v108; // rbx
  unsigned __int64 v109; // rax
  size_t Size; // rdi
  void *p_p_p_p_p_p_p_p_p_p_p_p_Source_4; // rax
  __int64 *ThreadLogContextSlot_5; // rax
  const char *v114; // [rsp+20h] [rbp-E0h]
  __int64 v115; // [rsp+70h] [rbp-90h] BYREF
  char v116; // [rsp+78h] [rbp-88h] BYREF
  __int128 v117; // [rsp+80h] [rbp-80h] BYREF
  bool v118; // [rsp+90h] [rbp-70h]
  __int64 v119; // [rsp+98h] [rbp-68h] BYREF
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_2; // [rsp+A0h] [rbp-60h]
  const void *p_p_p_p_p_p_p_p_p_p_p_p_Source_5; // [rsp+A8h] [rbp-58h]
  unsigned __int8 *v122; // [rsp+B0h] [rbp-50h] BYREF
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v124; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v125; // [rsp+C8h] [rbp-38h]
  const void *v126; // [rsp+D0h] [rbp-30h]
  __int64 v127; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v128; // [rsp+E0h] [rbp-20h]
  const void *v129; // [rsp+E8h] [rbp-18h]
  __int64 (__fastcall **v130)(); // [rsp+F0h] [rbp-10h] BYREF
  unsigned int v131; // [rsp+F8h] [rbp-8h]
  char v132; // [rsp+FCh] [rbp-4h]
  __int128 v133; // [rsp+100h] [rbp+0h]
  __int64 v134; // [rsp+110h] [rbp+10h]
  char v135; // [rsp+118h] [rbp+18h]
  char v136; // [rsp+119h] [rbp+19h]
  char v137; // [rsp+11Ah] [rbp+1Ah]
  char v138; // [rsp+11Bh] [rbp+1Bh]
  char v139; // [rsp+11Ch] [rbp+1Ch]
  __int64 v140; // [rsp+120h] [rbp+20h]
  int v141; // [rsp+128h] [rbp+28h]
  __int16 v142; // [rsp+130h] [rbp+30h]
  __int64 (__fastcall **v143)(); // [rsp+138h] [rbp+38h] BYREF
  unsigned int v144; // [rsp+140h] [rbp+40h]
  char v145; // [rsp+144h] [rbp+44h]
  __int64 v146; // [rsp+148h] [rbp+48h]
  __int64 v147; // [rsp+150h] [rbp+50h]
  __int64 v148; // [rsp+158h] [rbp+58h]
  char v149; // [rsp+160h] [rbp+60h]
  int n0x10000; // [rsp+161h] [rbp+61h]
  __int64 v151; // [rsp+168h] [rbp+68h]
  int v152; // [rsp+170h] [rbp+70h]
  __int64 v153; // [rsp+180h] [rbp+80h]
  __int64 (__fastcall **v154)(); // [rsp+188h] [rbp+88h] BYREF
  unsigned int v155; // [rsp+190h] [rbp+90h]
  char v156; // [rsp+194h] [rbp+94h]
  __int64 v157; // [rsp+198h] [rbp+98h]
  __int64 v158; // [rsp+1A0h] [rbp+A0h]
  __int64 v159; // [rsp+1A8h] [rbp+A8h]
  char v160; // [rsp+1B0h] [rbp+B0h]
  int n0x10000_1; // [rsp+1B1h] [rbp+B1h]
  __int64 v162; // [rsp+1B8h] [rbp+B8h]
  int v163; // [rsp+1C0h] [rbp+C0h]
  __int64 v164; // [rsp+1D0h] [rbp+D0h]
  __int64 (__fastcall **v165)(); // [rsp+1D8h] [rbp+D8h] BYREF
  unsigned int v166; // [rsp+1E0h] [rbp+E0h]
  char v167; // [rsp+1E4h] [rbp+E4h]
  __int64 v168; // [rsp+1E8h] [rbp+E8h]
  __int64 v169; // [rsp+1F0h] [rbp+F0h]
  __int64 v170; // [rsp+1F8h] [rbp+F8h]
  char v171; // [rsp+200h] [rbp+100h]
  int n0x10000_2; // [rsp+201h] [rbp+101h]
  __int64 v173; // [rsp+208h] [rbp+108h]
  int v174; // [rsp+210h] [rbp+110h]
  char v175; // [rsp+219h] [rbp+119h]
  __int64 (__fastcall **v176)(); // [rsp+220h] [rbp+120h] BYREF
  unsigned int v177; // [rsp+228h] [rbp+128h]
  char v178; // [rsp+22Ch] [rbp+12Ch]
  __int128 v179; // [rsp+230h] [rbp+130h]
  __int64 v180; // [rsp+240h] [rbp+140h]
  char v181; // [rsp+248h] [rbp+148h]
  int n0x10000_3; // [rsp+249h] [rbp+149h]
  __int64 v183; // [rsp+250h] [rbp+150h]
  int v184; // [rsp+258h] [rbp+158h]
  char v185; // [rsp+261h] [rbp+161h]
  char n8_2; // [rsp+268h] [rbp+168h]
  int v187; // [rsp+26Ch] [rbp+16Ch]
  _QWORD v188[2]; // [rsp+270h] [rbp+170h] BYREF
  char v189; // [rsp+280h] [rbp+180h]
  _QWORD v190[2]; // [rsp+288h] [rbp+188h] BYREF
  char v191; // [rsp+298h] [rbp+198h]
  __int64 v192; // [rsp+2A0h] [rbp+1A0h] BYREF
  char *v193; // [rsp+2A8h] [rbp+1A8h] BYREF
  __int128 v194; // [rsp+2B0h] [rbp+1B0h] BYREF
  const void *v195; // [rsp+2C0h] [rbp+1C0h]
  __int64 v196; // [rsp+2C8h] [rbp+1C8h] BYREF
  int n0xB2; // [rsp+2D0h] [rbp+1D0h]
  char v198; // [rsp+2D4h] [rbp+1D4h] BYREF
  __int128 v199; // [rsp+2D8h] [rbp+1D8h] BYREF
  __int64 v200; // [rsp+2E8h] [rbp+1E8h]
  _BYTE v201[72]; // [rsp+2F0h] [rbp+1F0h] BYREF
  _BYTE v202[40]; // [rsp+338h] [rbp+238h] BYREF
  char v203; // [rsp+360h] [rbp+260h]
  void *v204; // [rsp+380h] [rbp+280h] BYREF
  _BYTE v205[40]; // [rsp+388h] [rbp+288h] BYREF
  char v206; // [rsp+3B0h] [rbp+2B0h]
  unsigned __int8 *v207; // [rsp+3D0h] [rbp+2D0h] BYREF
  _BYTE v208[40]; // [rsp+3D8h] [rbp+2D8h] BYREF
  char v209; // [rsp+400h] [rbp+300h]
  __int64 v210; // [rsp+420h] [rbp+320h]
  _BYTE v211[40]; // [rsp+428h] [rbp+328h] BYREF
  char v212; // [rsp+450h] [rbp+350h]
  float v213; // [rsp+46Ch] [rbp+36Ch]
  _BYTE v214[40]; // [rsp+470h] [rbp+370h] BYREF
  char v215; // [rsp+498h] [rbp+398h]
  float v216; // [rsp+4B4h] [rbp+3B4h]
  _QWORD v217[5]; // [rsp+4B8h] [rbp+3B8h] BYREF
  char v218; // [rsp+4E0h] [rbp+3E0h]
  float v219; // [rsp+4FCh] [rbp+3FCh]
  _BYTE v220[40]; // [rsp+500h] [rbp+400h] BYREF
  char v221; // [rsp+528h] [rbp+428h]
  float v222; // [rsp+544h] [rbp+444h]
  _BYTE v223[40]; // [rsp+548h] [rbp+448h] BYREF
  char v224; // [rsp+570h] [rbp+470h]
  char v225; // [rsp+589h] [rbp+489h]
  _BYTE v226[40]; // [rsp+680h] [rbp+580h] BYREF
  char v227; // [rsp+6A8h] [rbp+5A8h]
  char v228; // [rsp+6C1h] [rbp+5C1h]
  _BYTE v229[40]; // [rsp+6C8h] [rbp+5C8h] BYREF
  char v230; // [rsp+6F0h] [rbp+5F0h]
  __int64 v231; // [rsp+710h] [rbp+610h]
  _BYTE v232[40]; // [rsp+880h] [rbp+780h] BYREF
  char v233; // [rsp+8A8h] [rbp+7A8h]
  __int64 n6; // [rsp+8C8h] [rbp+7C8h]
  _BYTE v235[40]; // [rsp+920h] [rbp+820h] BYREF
  char v236; // [rsp+948h] [rbp+848h]
  __int64 n4; // [rsp+968h] [rbp+868h]
  _BYTE v238[40]; // [rsp+9B8h] [rbp+8B8h] BYREF
  char v239; // [rsp+9E0h] [rbp+8E0h]
  __int64 n2; // [rsp+A00h] [rbp+900h]
  _BYTE v241[40]; // [rsp+A08h] [rbp+908h] BYREF
  char v242; // [rsp+A30h] [rbp+930h]
  char v243; // [rsp+A49h] [rbp+949h]
  _BYTE v244[40]; // [rsp+A50h] [rbp+950h] BYREF
  char v245; // [rsp+A78h] [rbp+978h]
  char v246; // [rsp+A91h] [rbp+991h]
  _BYTE v247[40]; // [rsp+B88h] [rbp+A88h] BYREF
  char v248; // [rsp+BB0h] [rbp+AB0h]
  __int64 v249; // [rsp+BD0h] [rbp+AD0h]
  _BYTE v250[40]; // [rsp+C50h] [rbp+B50h] BYREF
  char v251; // [rsp+C78h] [rbp+B78h]
  __int64 v252; // [rsp+C98h] [rbp+B98h]
  _BYTE v253[96]; // [rsp+CA0h] [rbp+BA0h] BYREF
  char *v254; // [rsp+D00h] [rbp+C00h]
  char *v255; // [rsp+D08h] [rbp+C08h]
  _BYTE v256[40]; // [rsp+D68h] [rbp+C68h] BYREF
  char v257; // [rsp+D90h] [rbp+C90h]
  char v258; // [rsp+DA9h] [rbp+CA9h]
  _BYTE v259[40]; // [rsp+E78h] [rbp+D78h] BYREF
  char v260; // [rsp+EA0h] [rbp+DA0h]
  float v261; // [rsp+EBCh] [rbp+DBCh]
  __int128 v262; // [rsp+F00h] [rbp+E00h]
  int v263; // [rsp+F10h] [rbp+E10h]
  __int128 v264; // [rsp+F30h] [rbp+E30h]
  __int64 v265; // [rsp+F50h] [rbp+E50h]
  __int64 v266; // [rsp+F68h] [rbp+E68h]
  __int64 v267; // [rsp+F80h] [rbp+E80h]
  char v268[8]; // [rsp+1010h] [rbp+F10h] BYREF
  __int64 v269; // [rsp+1018h] [rbp+F18h]
  char *v270; // [rsp+1020h] [rbp+F20h]
  char v271; // [rsp+1028h] [rbp+F28h] BYREF
  unsigned __int64 v272; // [rsp+1050h] [rbp+F50h] BYREF
  __int64 n0x1FF; // [rsp+1058h] [rbp+F58h]
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_3; // [rsp+1060h] [rbp+F60h]
  _BYTE v275[520]; // [rsp+1068h] [rbp+F68h] BYREF
  __int64 v276; // [rsp+1270h] [rbp+1170h] BYREF
  __int64 n0x1FF_1; // [rsp+1278h] [rbp+1178h]
  _BYTE *v278; // [rsp+1280h] [rbp+1180h]
  _BYTE v279[520]; // [rsp+1288h] [rbp+1188h] BYREF
  __int128 v280; // [rsp+14C0h] [rbp+13C0h]

  v196 = a2;
  v3 = a2;
  v192 = (__int64)a1;
  v4 = (__int64)a1;
  if ( !a2 )
  {
    v115 = 0x97000000E0LL;
    v192 = (__int64)&v115;
    v193 = &v116;
    v5 = invokeGlobalCallbackAndMaskStatusBits(
           3,
           (__int64)&v192,
           (__int64)"CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
           "Shop Current Inventory has null shop inventory Items! shopId[$$] shopName[$$]");
    if ( (v5 & 0xFFFFF) != 0 )
    {
      v6 = *(_QWORD *)((*(_QWORD *)(*(_QWORD *)v4 + 0x1C0LL) & 0xFFFFFFFFFFFFLL) + 8) & 0xFFFFFFFFFFFFLL;
      *((_QWORD *)&v194 + 1) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x70LL))(v6);
      v7 = *(_QWORD *)v4;
      *(_QWORD *)&v194 = 0;
      v195 = 0;
      sub_1403B0A70(
        (unsigned __int64 *)((*(_QWORD *)(v7 + 0x1C0) & 0xFFFFFFFFFFFFLL) + 8),
        &p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
      p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
      v119 = 0;
      LOBYTE(p_p_p_p_p_p_p_p_p_p_p_p_Source_5) = 0;
      ThreadLogContextSlot = getThreadLogContextSlot();
      v115 = 0x97000000E0LL;
      v192 = (__int64)&v115;
      v193 = &v116;
      v117 = 0;
      sub_140441C40(
        3u,
        &v192,
        "CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
        "Shop Current Inventory has null shop inventory Items! shopId[$$] shopName[$$]",
        1,
        v5,
        &v117,
        0,
        (__int64)ThreadLogContextSlot,
        &v119,
        &v194);
      sub_1402A3D30(v195);
    }
    return;
  }
  v116 = 1;
  if ( !*(_DWORD *)(qword_149E7E430 + 0x208)
    || (v9 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a2 + 0x38LL))(a2, *a1 + 0x2648LL),
        v10 = *(_QWORD *)v3,
        v11 = v9,
        v116 = v9,
        !(*(unsigned __int8 (__fastcall **)(__int64))(v10 + 0x98))(v3))
    || v11 )
  {
    sub_14035B3E0(&v122);
    v12 = *(_QWORD *)v3;
    p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    v117 = *(_OWORD *)(*(__int64 (__fastcall **)(__int64, __int128 *))(v12 + 8))(v3, &v194);
    sub_14035BF60(&v199, &v117);
    if ( qword_149B4FCA0
      && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0)
      && (v14 = (__int64 (__fastcall ***)(_QWORD, __int128 *))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0
                                                                                                 + 0x240LL))(qword_149B4FCA0),
          (v15 = (__int64 (__fastcall ***)(_QWORD))(**v14)(v14, &v199)) != 0) )
    {
      v16 = (**v15)(v15);
      v200 = v16;
      if ( v16 )
      {
        v280 = v2;
        copyStringStructure((char **)&v122, (char **)(v16 + 8));
        if ( sub_1403E5570((_QWORD *)(v200 + 0x28)) )
        {
          v115 = 0x97000000E0LL;
          *(_QWORD *)&v117 = &v115;
          *((_QWORD *)&v117 + 1) = &v116;
          v17 = invokeGlobalCallbackAndMaskStatusBits(
                  4,
                  (__int64)&v117,
                  (__int64)"CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
                  "ResourceDataType record [$$] is missing defaultThumbnailPath");
          if ( (v17 & 0xFFFFF) != 0 )
          {
            v125 = *sub_1403B3D00((__int64)&v199);
            v124 = 0;
            v126 = 0;
            ThreadLogContextSlot_1 = getThreadLogContextSlot();
            v115 = 0x97000000E0LL;
            *(_QWORD *)&v117 = &v115;
            *((_QWORD *)&v117 + 1) = &v116;
            v194 = 0;
            sub_140444D10(
              4u,
              (__int64 *)&v117,
              "CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
              "ResourceDataType record [$$] is missing defaultThumbnailPath",
              1,
              v17,
              &v194,
              0,
              (__int64)ThreadLogContextSlot_1,
              &v124);
            sub_1402A3D30(v126);
          }
        }
        else
        {
          p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_14037FC70(v200 + 0x28);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = p_p_p_p_p_p_p_p_p_p_p_p_Source;
        }
        v19 = (*(double (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x18LL))(v3) > 0.0;
        v20 = 100.0;
        v21 = (*(double (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x20LL))(v3) > 0.0;
        v118 = v21;
        if ( !v19 )
        {
LABEL_147:
          if ( !v21 )
          {
LABEL_280:
            sub_140370D10(&v122);
            return;
          }
          sub_144C2E780((__int64)v201);
          v70 = (const void **)sub_14035F010(&v192, &v122);
          v71 = v70;
          if ( !v203 || sub_14037F680((unsigned __int16 **)&v204, v70) )
          {
            sub_140378020(&v204, v71);
            v203 = 1;
            sub_1403302D0((__int64)v202, 0);
          }
          sub_140370D10(&v192);
          CreateStringObjectFromString((void **)&v115, (const char *)p_p_p_p_p_p_p_p_p_p_p_p_Source);
          if ( !v206 || (unsigned int)sub_1403E4780(&v207, &v115) )
          {
            copyStringStructure((char **)&v207, (char **)&v115);
            v206 = 1;
            sub_1403302D0((__int64)v205, 0);
          }
          sub_140370D10(&v115);
          v72 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3);
          v73 = sub_14036A800(&v194, v72);
          v265 = sub_14036A710(v188, (__int64)v73)[2];
          v266 = v265;
          _XMM0 = sub_1403B6AB0();
          __asm { vcvttsd2si rax, xmm0 }
          if ( !v209 || v210 != _RAX )
          {
            v210 = _RAX;
            v209 = 1;
            sub_1403302D0((__int64)v208, 0);
          }
          *(double *)_XMM0.m128_u64 = (*(double (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v3 + 0x28LL))(
                                        v3,
                                        3,
                                        *(_QWORD *)(*(_QWORD *)v4 + 0x2880LL));
          __asm { vmovddup xmm0, xmm0 }
          v264 = _XMM0;
          if ( !v215 || v216 != 0.0 )
          {
            v215 = 1;
            v216 = 0.0;
            sub_1403302D0((__int64)v214, 0);
          }
          v77 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x60LL))(v3);
          v78 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3);
          v79 = sub_14036A800(&v194, v77 - v78);
          v80 = sub_14036A710(v188, (__int64)v79);
          _XMM1 = COERCE_UNSIGNED_INT64(*(double *)&v264 * 100.0);
          __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
          v267 = v80[2];
          if ( !v212 || (v83 = v213, v213 != *(float *)&_XMM2) )
          {
            v212 = 1;
            v213 = *(float *)&_XMM2;
            sub_1403302D0((__int64)v211, 0);
            v83 = v213;
          }
          v84 = (float)sub_1404EE670(3);
          if ( !v218 || (v83 = v219, v219 != v84) )
          {
            v218 = 1;
            v219 = v84;
            sub_1403302D0((__int64)v217, 0);
          }
          if ( (*(unsigned __int8 (__fastcall **)(_QWORD *))(v217[0] + 0x100LL))(v217) )
          {
            (*(void (__fastcall **)(_QWORD *))(v217[0] + 0xA0LL))(v217);
            if ( !v221 || v222 != v83 )
            {
              v221 = 1;
              v222 = v83;
              sub_1403302D0((__int64)v220, 0);
            }
          }
          if ( !v230 || v231 != 1 )
          {
            v231 = 1;
            v230 = 1;
            sub_1403302D0((__int64)v229, 0);
          }
          if ( !v227 || v228 )
          {
            v228 = 0;
            v227 = 1;
            sub_1403302D0((__int64)v226, 0);
          }
          v262 = *(_OWORD *)(*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v3 + 8LL))(v3, &v194);
          v263 = 0;
          if ( !v239 || n2 != 2 )
          {
            n2 = 2;
            v239 = 1;
            sub_1403302D0((__int64)v238, 0);
          }
          if ( !v242 || v243 )
          {
            v243 = 0;
            v242 = 1;
            sub_1403302D0((__int64)v241, 0);
          }
          sub_144DB9460(v201);
          sub_144DB8280(v201);
          if ( !v245 || v246 != 1 )
          {
            v246 = 1;
            v245 = 1;
            sub_1403302D0((__int64)v244, 0);
          }
          if ( !v257 || v258 )
          {
            v258 = 0;
            v257 = 1;
            sub_1403302D0((__int64)v256, 0);
          }
          if ( !v260 || v261 != 0.0 )
          {
            v260 = 1;
            v261 = 0.0;
            sub_1403302D0((__int64)v259, 0);
          }
          if ( !v248 || v249 )
          {
            v249 = 0;
            v248 = 1;
            sub_1403302D0((__int64)v247, 0);
          }
          if ( !v251 || v252 )
          {
            v252 = 0;
            v251 = 1;
            sub_1403302D0((__int64)v250, 0);
          }
          if ( !v224 || v225 )
          {
            v225 = 0;
            v224 = 1;
            sub_1403302D0((__int64)v223, 0);
          }
          v85 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x78LL))(v3);
          if ( v85 )
          {
            n8 = 1;
            v87 = unk_149E48628;
            do
            {
              if ( _bittest64(&v85, (unsigned __int8)(n8 - 1)) )
              {
                sub_144C2CD90((__int64)&v130);
                _XMM0 = sub_1403B6AB0();
                __asm { vcvttsd2si rax, xmm0 }
                if ( !v149 || v153 != _RAX )
                {
                  v153 = _RAX;
                  v149 = 1;
                  sub_1403302D0((__int64)&v143, 0);
                }
                v90 = sub_1403AF3B0();
                _XMM1 = 0;
                __asm { vcvtsi2sd xmm1, xmm1, rsi }
                *((_QWORD *)&v94 + 1) = v90.m128_u64[1];
                *(double *)&v94 = *(double *)v90.m128_u64 / *(double *)&_XMM1;
                _XMM0 = v94;
                __asm { vcvttsd2si rax, xmm0 }
                if ( !v160 || v164 != _RAX )
                {
                  v164 = _RAX;
                  v160 = 1;
                  sub_1403302D0((__int64)&v154, 0);
                }
                n8_2 = n8;
                if ( !v171 || v175 )
                {
                  v175 = 0;
                  v171 = 1;
                  sub_1403302D0((__int64)&v165, 0);
                }
                if ( !v181 || v185 )
                {
                  v185 = 0;
                  v181 = 1;
                  sub_1403302D0((__int64)&v176, 0);
                }
                sub_144E14AD0((_LocaleUpdate *)v253);
                sub_14030C070((__int64 *)&v176);
                sub_14030C070((__int64 *)&v165);
                sub_14030C070((__int64 *)&v154);
                sub_14030C070((__int64 *)&v143);
                sub_14030C070((__int64 *)&v130);
              }
              ++n8;
              v87 += 3;
            }
            while ( n8 < 8 );
          }
          else
          {
            v115 = 0x97000000E0LL;
            *(_QWORD *)&v117 = &v115;
            *((_QWORD *)&v117 + 1) = &v116;
            v96 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)&v117,
                    (__int64)"CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
                    "CEntityComponentCommodityUIProvider inventory is missing available box sizes in commodity [$$] for shop [$$]");
            if ( (v96 & 0xFFFFF) != 0 )
            {
              v97 = *(_QWORD *)((*(_QWORD *)(*(_QWORD *)v4 + 0x1C0LL) & 0xFFFFFFFFFFFFLL) + 8) & 0xFFFFFFFFFFFFLL;
              v98 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v97 + 0x70LL))(v97);
              v127 = 0;
              v128 = v98;
              v129 = 0;
              p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = (const ULONG_PTR *)*sub_140320320();
              v119 = 0;
              p_p_p_p_p_p_p_p_p_p_p_p_Source_5 = 0;
              ThreadLogContextSlot_2 = getThreadLogContextSlot();
              v115 = 0x97000000E0LL;
              *(_QWORD *)&v117 = &v115;
              *((_QWORD *)&v117 + 1) = &v116;
              v194 = 0;
              sub_14164D250(
                3u,
                (__int64 *)&v117,
                "CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
                "CEntityComponentCommodityUIProvider inventory is missing available box sizes in commodity [$$] for shop [$$]",
                1,
                v96,
                &v194,
                0,
                (__int64)ThreadLogContextSlot_2,
                &v119,
                &v127);
              sub_1402A3D30(p_p_p_p_p_p_p_p_p_p_p_p_Source_5);
              sub_1402A3D30(v129);
            }
          }
          v100 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x60LL))(v3);
          v101 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3);
          if ( v100 > 0 )
          {
            v102 = (float)v101;
            v103 = (float)v100;
            v20 = (float)(v102 / v103) * 100.0;
          }
          if ( v20 < *(float *)(sub_144D1CDC0() + 0x58) )
          {
            if ( v20 < *(float *)(sub_144D1CDC0() + 0x5C) )
            {
              if ( v20 < *(float *)(sub_144D1CDC0() + 0x60) )
              {
                if ( v20 < *(float *)(sub_144D1CDC0() + 0x64) )
                {
                  if ( v20 < *(float *)(sub_144D1CDC0() + 0x68) )
                  {
                    if ( v20 < *(float *)(sub_144D1CDC0() + 0x6C) )
                    {
                      if ( !v233 || n6 != 6 )
                      {
                        n6 = 6;
                        goto LABEL_249;
                      }
                    }
                    else if ( !v233 || n6 != 5 )
                    {
                      n6 = 5;
                      goto LABEL_249;
                    }
                  }
                  else if ( !v233 || n6 != 4 )
                  {
                    n6 = 4;
                    goto LABEL_249;
                  }
                }
                else if ( !v233 || n6 != 3 )
                {
                  n6 = 3;
                  goto LABEL_249;
                }
              }
              else if ( !v233 || n6 != 2 )
              {
                n6 = 2;
                goto LABEL_249;
              }
            }
            else if ( !v233 || n6 != 1 )
            {
              n6 = 1;
              goto LABEL_249;
            }
          }
          else if ( !v233 || n6 )
          {
            n6 = 0;
LABEL_249:
            v233 = 1;
            sub_1403302D0((__int64)v232, 0);
          }
          if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0xA0LL))(v3)
            && !v116
            && *(_DWORD *)(qword_149E7E430 + 0x208) )
          {
            if ( v233 && n6 == 0xD )
              goto LABEL_265;
            n6 = 0xD;
            v104 = v232;
            v233 = 1;
          }
          else
          {
            if ( !n6 )
            {
              if ( !v236 || n4 != 1 )
              {
                n4 = 1;
                v236 = 1;
                sub_1403302D0((__int64)v235, 0);
              }
              v105 = (_LocaleUpdate *)(*(_QWORD *)v4 + 0x860LL);
              goto LABEL_266;
            }
            if ( v236 && n4 == 4 )
            {
LABEL_265:
              v105 = (_LocaleUpdate *)(*(_QWORD *)v4 + 0x7E8LL);
LABEL_266:
              sub_144E14C60(v105);
              sub_144C3F0D0((__int64)v201);
              goto LABEL_280;
            }
            n4 = 4;
            v104 = v235;
            v236 = 1;
          }
          sub_1403302D0((__int64)v104, 0);
          goto LABEL_265;
        }
        sub_144C2E780((__int64)v201);
        v22 = (const void **)sub_14035F010(&v115, &v122);
        v23 = v22;
        if ( !v203 || sub_14037F680((unsigned __int16 **)&v204, v22) )
        {
          sub_140378020(&v204, v23);
          v203 = 1;
          sub_1403302D0((__int64)v202, 0);
        }
        sub_140370D10(&v115);
        CreateStringObjectFromString((void **)&v115, (const char *)p_p_p_p_p_p_p_p_p_p_p_p_Source);
        if ( !v206 || (unsigned int)sub_1403E4780(&v207, &v115) )
        {
          copyStringStructure((char **)&v207, (char **)&v115);
          v206 = 1;
          sub_1403302D0((__int64)v205, 0);
        }
        sub_140370D10(&v115);
        v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3);
        v25 = sub_14036A800(&v194, v24);
        v265 = sub_14036A710(v188, (__int64)v25)[2];
        v266 = v265;
        _XMM0 = sub_1403B6AB0();
        __asm { vcvttsd2si rax, xmm0 }
        if ( !v209 || v210 != _RAX )
        {
          v210 = _RAX;
          v209 = 1;
          sub_1403302D0((__int64)v208, 0);
        }
        *(double *)_XMM0.m128_u64 = (*(double (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v3 + 0x28LL))(
                                      v3,
                                      1,
                                      *(_QWORD *)(*(_QWORD *)v4 + 0x2880LL));
        __asm { vmovddup xmm0, xmm0 }
        v264 = _XMM0;
        if ( !v215 || v216 != 0.0 )
        {
          v215 = 1;
          v216 = 0.0;
          sub_1403302D0((__int64)v214, 0);
        }
        v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x60LL))(v3);
        v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3);
        v31 = sub_14036A800(&v194, v29 - v30);
        v32 = sub_14036A710(v188, (__int64)v31);
        _XMM1 = COERCE_UNSIGNED_INT64(*(double *)&v264 * 100.0);
        __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
        v267 = v32[2];
        if ( !v212 || (v35 = v213, v213 != *(float *)&_XMM2) )
        {
          v212 = 1;
          v213 = *(float *)&_XMM2;
          sub_1403302D0((__int64)v211, 0);
          v35 = v213;
        }
        v36 = (float)sub_1404EE670(1);
        if ( !v218 || (v35 = v219, v219 != v36) )
        {
          v218 = 1;
          v219 = v36;
          sub_1403302D0((__int64)v217, 0);
        }
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD *))(v217[0] + 0x100LL))(v217) )
        {
          (*(void (__fastcall **)(_QWORD *))(v217[0] + 0xA0LL))(v217);
          if ( !v221 || v222 != v35 )
          {
            v221 = 1;
            v222 = v35;
            sub_1403302D0((__int64)v220, 0);
          }
        }
        if ( !v230 || v231 != 1 )
        {
          v231 = 1;
          v230 = 1;
          sub_1403302D0((__int64)v229, 0);
        }
        if ( !v227 || v228 )
        {
          v228 = 0;
          v227 = 1;
          sub_1403302D0((__int64)v226, 0);
        }
        v262 = *(_OWORD *)(*(__int64 (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v3 + 8LL))(v3, &v194);
        v263 = 1;
        if ( !v239 || n2 != 2 )
        {
          n2 = 2;
          v239 = 1;
          sub_1403302D0((__int64)v238, 0);
        }
        if ( !v242 || v243 )
        {
          v243 = 0;
          v242 = 1;
          sub_1403302D0((__int64)v241, 0);
        }
        sub_144DB9460(v201);
        sub_144DB8280(v201);
        if ( !v245 || v246 != 1 )
        {
          v246 = 1;
          v245 = 1;
          sub_1403302D0((__int64)v244, 0);
        }
        if ( !v257 || v258 )
        {
          v258 = 0;
          v257 = 1;
          sub_1403302D0((__int64)v256, 0);
        }
        if ( !v260 || v261 != 0.0 )
        {
          v260 = 1;
          v261 = 0.0;
          sub_1403302D0((__int64)v259, 0);
        }
        if ( !v248 || v249 )
        {
          v249 = 0;
          v248 = 1;
          sub_1403302D0((__int64)v247, 0);
        }
        if ( !v251 || v252 )
        {
          v252 = 0;
          v251 = 1;
          sub_1403302D0((__int64)v250, 0);
        }
        if ( !v224 || v225 )
        {
          v225 = 0;
          v224 = 1;
          sub_1403302D0((__int64)v223, 0);
        }
        v37 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x78LL))(v3);
        if ( v37 )
        {
          for ( n8_1 = 1; n8_1 < 8; ++n8_1 )
          {
            if ( _bittest64(&v37, (unsigned __int8)(n8_1 - 1)) )
            {
              sub_144C2CD90((__int64)&v130);
              _XMM0 = sub_1403B6AB0();
              __asm { vcvttsd2si rax, xmm0 }
              if ( !v149 || v153 != _RAX )
              {
                v153 = _RAX;
                v149 = 1;
                sub_1403302D0((__int64)&v143, 0);
              }
              v41 = sub_1403AF3B0();
              _XMM1 = 0;
              __asm { vcvtsi2sd xmm1, xmm1, rsi }
              *((_QWORD *)&v45 + 1) = v41.m128_u64[1];
              *(double *)&v45 = *(double *)v41.m128_u64 / *(double *)&_XMM1;
              _XMM0 = v45;
              __asm { vcvttsd2si rax, xmm0 }
              if ( !v160 || v164 != _RAX )
              {
                v164 = _RAX;
                v160 = 1;
                sub_1403302D0((__int64)&v154, 0);
              }
              n8_2 = n8_1;
              if ( !v171 || v175 != 1 )
              {
                v175 = 1;
                v171 = 1;
                sub_1403302D0((__int64)&v165, 0);
              }
              if ( !v181 || v185 )
              {
                v185 = 0;
                v181 = 1;
                sub_1403302D0((__int64)&v176, 0);
              }
              sub_144E14AD0((_LocaleUpdate *)v253);
              sub_14030C070((__int64 *)&v176);
              sub_14030C070((__int64 *)&v165);
              sub_14030C070((__int64 *)&v154);
              sub_14030C070((__int64 *)&v143);
              sub_14030C070((__int64 *)&v130);
            }
          }
          v47 = v255;
          v275[0] = 0;
          p_p_p_p_p_p_p_p_p_p_p_p_Source_3 = (const ULONG_PTR *)v275;
          v272 = 0;
          n0x1FF = 0x1FF;
          if ( v254 != v255 )
          {
            v48 = v254 + 0x28;
            do
            {
              v134 = *((_QWORD *)v48 + 0xFFFFFFFF);
              v135 = *v48;
              v136 = v48[1];
              v137 = v48[2];
              v138 = v48[3];
              v139 = v48[4];
              v140 = *((_QWORD *)v48 + 1);
              v141 = *((_DWORD *)v48 + 4);
              v142 = *((_WORD *)v48 + 0xC);
              v153 = *((_QWORD *)v48 + 0xD);
              v131 = 0xFFFFFFFF;
              v132 = 0;
              v133 = 0;
              v130 = off_148A05888;
              v144 = 0xFFFFFFFF;
              v145 = 0;
              v146 = 0;
              v147 = 0;
              v148 = 0;
              n0x10000 = 0x10000;
              v151 = 0;
              v152 = 0;
              v143 = off_1481AB2A8;
              v149 = 1;
              sub_1403302D0((__int64)&v143, 0);
              v164 = *((_QWORD *)v48 + 0x17);
              v155 = 0xFFFFFFFF;
              v156 = 0;
              v157 = 0;
              v158 = 0;
              v159 = 0;
              n0x10000_1 = 0x10000;
              v162 = 0;
              v163 = 0;
              v154 = off_1481AB2A8;
              v160 = 1;
              sub_1403302D0((__int64)&v154, 0);
              v175 = v48[0x101];
              v166 = 0xFFFFFFFF;
              v167 = 0;
              v168 = 0;
              v169 = 0;
              v170 = 0;
              n0x10000_2 = 0x10000;
              v173 = 0;
              v174 = 0;
              v165 = off_1481AB148;
              v171 = 1;
              sub_1403302D0((__int64)&v165, 0);
              v49 = v48[0x149];
              v179 = 0;
              v185 = v49;
              v177 = 0xFFFFFFFF;
              v178 = 0;
              v180 = 0;
              n0x10000_3 = 0x10000;
              v183 = 0;
              v184 = 0;
              v176 = off_1481AB148;
              v181 = 1;
              sub_1403302D0((__int64)&v176, 0);
              n8_2 = v48[0x150];
              v187 = *((_DWORD *)v48 + 0x55);
              v278 = v279;
              v279[0] = 0;
              v276 = 0;
              n0x1FF_1 = 0x1FF;
              v50 = sub_1402A3190((__int64)&v276, " boxSize[%u]", v153);
              sub_1402DECA0(&v272, *(const void **)(v50 + 0x10), *(_QWORD *)v50);
              if ( v278 != v279 )
              {
                qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF_1;
                sub_147605980(v278);
              }
              sub_14030C070((__int64 *)&v176);
              sub_14030C070((__int64 *)&v165);
              sub_14030C070((__int64 *)&v154);
              sub_14030C070((__int64 *)&v143);
              sub_14030C070((__int64 *)&v130);
              v48 += 0x180;
            }
            while ( v48 + 0xFFFFFFD8 != v47 );
            v3 = v196;
            v4 = v192;
            p_p_p_p_p_p_p_p_p_p_p_p_Source = p_p_p_p_p_p_p_p_p_p_p_p_Source_1;
          }
          v192 = 0x97000000E0LL;
          *(_QWORD *)&v117 = &v192;
          *((_QWORD *)&v117 + 1) = (char *)&v193 + 4;
          LODWORD(v193) = 0xB2;
          v51 = invokeGlobalCallbackAndMaskStatusBits(
                  5,
                  (__int64)&v117,
                  (__int64)"CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
                  "AddingCommodityBox - playerId[$$] shopId[$$] shopName[$$] commodityName[$$] Available Box Sizes: $$");
          if ( (v51 & 0xFFFFF) != 0 )
          {
            v52 = *(_QWORD *)v3;
            p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = p_p_p_p_p_p_p_p_p_p_p_p_Source_3;
            v119 = 0;
            p_p_p_p_p_p_p_p_p_p_p_p_Source_5 = 0;
            v53 = (*(__int64 (__fastcall **)(__int64))(v52 + 0x10))(v3);
            v127 = 0;
            v128 = v53;
            v54 = *(_QWORD *)v4;
            v129 = 0;
            v55 = *(_QWORD *)((*(_QWORD *)(v54 + 0x1C0) & 0xFFFFFFFFFFFFLL) + 8) & 0xFFFFFFFFFFFFLL;
            v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v55 + 0x70LL))(v55);
            v124 = 0;
            v125 = v56;
            v57 = *(_QWORD *)v4;
            v126 = 0;
            sub_1403B0A70((unsigned __int64 *)((*(_QWORD *)(v57 + 0x1C0) & 0xFFFFFFFFFFFFLL) + 8), &v192);
            v190[1] = v192;
            v58 = *(_QWORD *)v4;
            v190[0] = 0;
            v191 = 0;
            v188[1] = *(_QWORD *)(v58 + 0x2880);
            v188[0] = 0;
            v189 = 0;
            ThreadLogContextSlot_3 = getThreadLogContextSlot();
            v196 = 0x97000000E0LL;
            *(_QWORD *)&v117 = &v196;
            *((_QWORD *)&v117 + 1) = &v198;
            n0xB2 = 0xB2;
            v194 = 0;
            _crtLCMapStringA_65(
              5u,
              (__int64 *)&v117,
              "CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
              "AddingCommodityBox - playerId[$$] shopId[$$] shopName[$$] commodityName[$$] Available Box Sizes: $$",
              1,
              v51,
              &v194,
              0,
              (__int64)ThreadLogContextSlot_3,
              v188,
              v190,
              &v124,
              &v127,
              &v119);
            sub_1402A3D30(v126);
            sub_1402A3D30(v129);
            sub_1402A3D30(p_p_p_p_p_p_p_p_p_p_p_p_Source_5);
          }
          if ( p_p_p_p_p_p_p_p_p_p_p_p_Source_3 != (const ULONG_PTR *)v275 )
          {
            qword_149B3AB68 += 0xFFFFFFFFFFFFFFFFuLL - n0x1FF;
            sub_147605980(p_p_p_p_p_p_p_p_p_p_p_p_Source_3);
          }
        }
        else
        {
          v115 = 0x97000000E0LL;
          *(_QWORD *)&v117 = &v115;
          *((_QWORD *)&v117 + 1) = &v116;
          v60 = invokeGlobalCallbackAndMaskStatusBits(
                  5,
                  (__int64)&v117,
                  (__int64)"CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
                  "CEntityComponentCommodityUIProvider inventory is missing available box sizes for shop %s",
                  v114);
          if ( (v60 & 0xFFFFF) != 0 )
          {
            v61 = *(_QWORD *)((*(_QWORD *)(*(_QWORD *)v4 + 0x1C0LL) & 0xFFFFFFFFFFFFLL) + 8) & 0xFFFFFFFFFFFFLL;
            p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v61 + 0x70LL))(v61);
            v119 = 0;
            p_p_p_p_p_p_p_p_p_p_p_p_Source_5 = 0;
            ThreadLogContextSlot_4 = getThreadLogContextSlot();
            v115 = 0x97000000E0LL;
            *(_QWORD *)&v117 = &v115;
            *((_QWORD *)&v117 + 1) = &v116;
            v194 = 0;
            sub_1404439B0(
              5u,
              (__int64 *)&v117,
              "CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
              "CEntityComponentCommodityUIProvider inventory is missing available box sizes for shop %s",
              1,
              v60,
              &v194,
              0,
              (__int64)ThreadLogContextSlot_4,
              &v119);
            sub_1402A3D30(p_p_p_p_p_p_p_p_p_p_p_p_Source_5);
          }
          if ( !v245 || v246 )
          {
            v246 = 0;
            v245 = 1;
            sub_1403302D0((__int64)v244, 0);
          }
        }
        v63 = 100.0;
        v64 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x60LL))(v3);
        v65 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x58LL))(v3);
        if ( v64 > 0 )
        {
          v66 = (float)v65;
          v67 = (float)v64;
          v63 = (float)(v66 / v67) * 100.0;
        }
        if ( v63 > *(float *)(sub_144D1CDC0() + 0x40) )
        {
          if ( v63 > *(float *)(sub_144D1CDC0() + 0x44) )
          {
            if ( v63 > *(float *)(sub_144D1CDC0() + 0x48) )
            {
              if ( v63 > *(float *)(sub_144D1CDC0() + 0x4C) )
              {
                if ( v63 > *(float *)(sub_144D1CDC0() + 0x50) )
                {
                  if ( v63 > *(float *)(sub_144D1CDC0() + 0x54) )
                  {
                    if ( !v233 || n6 != 6 )
                    {
                      n6 = 6;
                      goto LABEL_129;
                    }
                  }
                  else if ( !v233 || n6 != 5 )
                  {
                    n6 = 5;
                    goto LABEL_129;
                  }
                }
                else if ( !v233 || n6 != 4 )
                {
                  n6 = 4;
                  goto LABEL_129;
                }
              }
              else if ( !v233 || n6 != 3 )
              {
                n6 = 3;
                goto LABEL_129;
              }
            }
            else if ( !v233 || n6 != 2 )
            {
              n6 = 2;
              goto LABEL_129;
            }
          }
          else if ( !v233 || n6 != 1 )
          {
            n6 = 1;
            goto LABEL_129;
          }
        }
        else if ( !v233 || n6 )
        {
          n6 = 0;
LABEL_129:
          v233 = 1;
          sub_1403302D0((__int64)v232, 0);
        }
        if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0xA0LL))(v3)
          && !v116
          && *(_DWORD *)(qword_149E7E430 + 0x208) )
        {
          if ( v233 && n6 == 0xD )
            goto LABEL_145;
          n6 = 0xD;
          v68 = v232;
          v233 = 1;
        }
        else
        {
          if ( !n6 )
          {
            if ( !v236 || n4 != 3 )
            {
              n4 = 3;
              v236 = 1;
              sub_1403302D0((__int64)v235, 0);
            }
            v69 = (_LocaleUpdate *)(*(_QWORD *)v4 + 0x950LL);
            goto LABEL_146;
          }
          if ( v236 && n4 == 2 )
          {
LABEL_145:
            v69 = (_LocaleUpdate *)(*(_QWORD *)v4 + 0x8D8LL);
LABEL_146:
            sub_144E14C60(v69);
            sub_144C3F0D0((__int64)v201);
            v21 = v118;
            goto LABEL_147;
          }
          n4 = 2;
          v68 = v235;
          v236 = 1;
        }
        sub_1403302D0((__int64)v68, 0);
        goto LABEL_145;
      }
    }
    else
    {
      v200 = 0;
    }
    v115 = 0x97000000E0LL;
    *(_QWORD *)&v117 = &v115;
    *((_QWORD *)&v117 + 1) = &v116;
    v106 = invokeGlobalCallbackAndMaskStatusBits(
             3,
             (__int64)&v117,
             (__int64)"CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
             "commodity record [$$] is not in the ResourceDataTypes & could not be added to shop inventory.");
    if ( (v106 & 0xFFFFF) == 0 )
      goto LABEL_280;
    v107 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v3 + 8LL))(v3, &v192);
    v108 = *(_BYTE **)(sub_1402C4680((__int64)v268, v107) + 0x10);
    v119 = 0;
    sub_1402A3D30(0);
    v109 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v108[++v109] != 0 )
      ;
    Size = v109 + 1;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_4 = (void *)allocWithProfilerInfo_w(v109 + 1);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_5 = p_p_p_p_p_p_p_p_p_p_p_p_Source_4;
    p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = (const ULONG_PTR *)p_p_p_p_p_p_p_p_p_p_p_p_Source_4;
    if ( Size )
    {
      if ( p_p_p_p_p_p_p_p_p_p_p_p_Source_4 )
      {
        if ( v108 )
        {
          memcpy(p_p_p_p_p_p_p_p_p_p_p_p_Source_4, v108, Size);
          goto LABEL_277;
        }
        memset(p_p_p_p_p_p_p_p_p_p_p_p_Source_4, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
LABEL_277:
    if ( v270 != &v271 )
    {
      qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - v269;
      sub_147605980(v270);
    }
    ThreadLogContextSlot_5 = getThreadLogContextSlot();
    v115 = 0x97000000E0LL;
    *(_QWORD *)&v117 = &v115;
    *((_QWORD *)&v117 + 1) = &v116;
    v194 = 0;
    sub_140351BB0(
      3u,
      (__int64 *)&v117,
      "CEntityComponentCommodityUIProvider::LoadShopInventoryData::<lambda_1>::operator ()",
      "commodity record [$$] is not in the ResourceDataTypes & could not be added to shop inventory.",
      1,
      v106,
      &v194,
      0,
      (__int64)ThreadLogContextSlot_5,
      &v119);
    sub_1402A3D30(p_p_p_p_p_p_p_p_p_p_p_p_Source_5);
    goto LABEL_280;
  }
}

// --- End Function: sub_144C5B6A0 (0x144C5B6A0) ---

// --- Function: sub_144CADEB0 (0x144CADEB0) ---
void __fastcall sub_144CADEB0(__int64 a1, __int64 a2)
{
  sub_144C5B6A0(*(_QWORD **)(a1 + 0x10), a2);
}

// --- End Function: sub_144CADEB0 (0x144CADEB0) ---

// --- Function: sub_144CB9590 (0x144CB9590) ---
void __fastcall sub_144CB9590(int a1, __int64 a2, _QWORD *a3)
{
  int v4; // ecx
  _QWORD *v5; // rdi
  _QWORD *v6; // rax

  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        sub_1402A3D30(*(const void **)(a2 + 0x10));
        *(_QWORD *)(a2 + 0x10) = 0;
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
      }
    }
    else if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        *(_QWORD *)(a2 + 0x10) = 0;
        *(_QWORD *)a2 = *a3;
        *(_QWORD *)(a2 + 8) = 1;
      }
      else
      {
        *(_QWORD *)(a2 + 0x10) = a3[2];
        *(_QWORD *)a2 = *a3;
        *(_QWORD *)(a2 + 8) = a3[1];
      }
      a3[2] = 0;
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else
  {
    v5 = (_QWORD *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        *(_QWORD *)(a2 + 0x10) = 0;
        *(_QWORD *)a2 = *a3;
        *(_QWORD *)(a2 + 8) = 1;
      }
      else
      {
        v6 = (_QWORD *)allocWithProfilerInfo_w(8u);
        if ( v6 )
          *v6 = *v5;
        else
          v6 = 0;
        *(_QWORD *)(a2 + 0x10) = v6;
        *(_QWORD *)a2 = sub_144CADEB0;
        *(_QWORD *)(a2 + 8) = sub_144CB9590;
      }
    }
  }
}

// --- End Function: sub_144CB9590 (0x144CB9590) ---

// --- Function: sub_144CCC580 (0x144CCC580) ---
char __fastcall sub_144CCC580(unsigned __int64 a1, const char *p_unknown_1)
{
  bool v3; // zf
  int v4; // esi
  const char *p_unknown_3; // rcx
  __int64 v6; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  int v8; // esi
  const char *p_unknown; // rcx
  __int64 *ThreadLogContextSlot; // rax
  int *p_n0xE0; // [rsp+68h] [rbp-29h] BYREF
  char *v13; // [rsp+70h] [rbp-21h]
  __int128 v14; // [rsp+78h] [rbp-19h] BYREF
  _QWORD v15[2]; // [rsp+88h] [rbp-9h] BYREF
  const void *v16; // [rsp+98h] [rbp+7h]
  __int64 v17; // [rsp+A0h] [rbp+Fh] BYREF
  const char *p_unknown_2; // [rsp+A8h] [rbp+17h]
  const void *v19; // [rsp+B0h] [rbp+1Fh]
  _QWORD v20[2]; // [rsp+B8h] [rbp+27h] BYREF
  char v21; // [rsp+C8h] [rbp+37h]
  unsigned __int64 v22; // [rsp+F8h] [rbp+67h] BYREF
  int n0xE0; // [rsp+108h] [rbp+77h] BYREF
  int n0x97; // [rsp+10Ch] [rbp+7Bh]
  char v25; // [rsp+110h] [rbp+7Fh] BYREF

  v22 = a1;
  if ( !byte_149B501D5 )
  {
    v3 = !sub_14030EC00(&v22);
    n0xE0 = 0xE0;
    n0x97 = 0x97;
    p_n0xE0 = &n0xE0;
    v13 = &v25;
    if ( v3 )
    {
      v8 = invokeGlobalCallbackAndMaskStatusBits(
             3,
             (__int64)&p_n0xE0,
             (__int64)"ShopUtilities::CheckClientOnly",
             "Tried to execute a Client only function from [$$]!");
      if ( (v8 & 0xFFFFF) != 0 )
      {
        p_unknown = "unknown";
        v17 = 0;
        v19 = 0;
        if ( p_unknown_1 )
          p_unknown = p_unknown_1;
        p_unknown_2 = p_unknown;
        ThreadLogContextSlot = getThreadLogContextSlot();
        n0xE0 = 0xE0;
        p_n0xE0 = &n0xE0;
        n0x97 = 0x97;
        v13 = &v25;
        v14 = 0;
        sub_140442EF0(
          3u,
          (__int64 *)&p_n0xE0,
          "ShopUtilities::CheckClientOnly",
          "Tried to execute a Client only function from [$$]!",
          1,
          v8,
          &v14,
          0,
          (__int64)ThreadLogContextSlot,
          &v17);
        goto LABEL_11;
      }
    }
    else
    {
      v4 = invokeGlobalCallbackAndMaskStatusBits(
             3,
             (__int64)&p_n0xE0,
             (__int64)"ShopUtilities::CheckClientOnly",
             "Entity [$$] named [$$] Tried to execute a client only function from [$$]!");
      if ( (v4 & 0xFFFFF) != 0 )
      {
        p_unknown_3 = "unknown";
        v17 = 0;
        v19 = 0;
        if ( p_unknown_1 )
          p_unknown_3 = p_unknown_1;
        p_unknown_2 = p_unknown_3;
        v6 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v22 & 0xFFFFFFFFFFFFLL) + 0x70LL))(v22 & 0xFFFFFFFFFFFFLL);
        v15[0] = 0;
        v15[1] = v6;
        v16 = 0;
        v20[1] = *(_QWORD *)(*(__int64 (__fastcall **)(unsigned __int64, char *))(*(_QWORD *)(v22 & 0xFFFFFFFFFFFFLL)
                                                                                + 8LL))(
                              v22 & 0xFFFFFFFFFFFFLL,
                              &v25);
        v20[0] = 0;
        v21 = 0;
        ThreadLogContextSlot_1 = getThreadLogContextSlot();
        n0xE0 = 0xE0;
        p_n0xE0 = &n0xE0;
        n0x97 = 0x97;
        v13 = &v25;
        v14 = 0;
        sub_144BE9850(
          3u,
          (__int64 *)&p_n0xE0,
          "ShopUtilities::CheckClientOnly",
          "Entity [$$] named [$$] Tried to execute a client only function from [$$]!",
          1,
          v4,
          &v14,
          0,
          (__int64)ThreadLogContextSlot_1,
          v20,
          v15,
          &v17);
        sub_1402A3D30(v16);
LABEL_11:
        sub_1402A3D30(v19);
      }
    }
    return 0;
  }
  return 1;
}

// --- End Function: sub_144CCC580 (0x144CCC580) ---

// --- Function: sub_144D1CDC0 (0x144D1CDC0) ---
__int64 sub_144D1CDC0()
{
  __int64 result; // rax
  int v1; // ebx
  __int64 *ThreadLogContextSlot; // rax
  int *p_n0xE0; // [rsp+50h] [rbp-28h] BYREF
  char *v4; // [rsp+58h] [rbp-20h]
  __int128 v5; // [rsp+60h] [rbp-18h] BYREF
  int n0xE0; // [rsp+80h] [rbp+8h] BYREF
  int n0x97; // [rsp+84h] [rbp+Ch]
  char v8; // [rsp+88h] [rbp+10h] BYREF

  result = qword_149E48948;
  if ( !qword_149E48948 )
  {
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)qword_149B4FC78 + 0x58LL))(qword_149B4FC78, &n0xE0);
    n0xE0 = 0xE0;
    p_n0xE0 = &n0xE0;
    n0x97 = 0x97;
    v4 = &v8;
    v1 = invokeGlobalCallbackAndMaskStatusBits(
           3,
           (__int64)&p_n0xE0,
           (__int64)"CShopManager::GetGlobalShopCommodityParams",
           "Shop Manager is missing Global Commodity Data Record");
    if ( (v1 & 0xFFFFF) != 0 )
    {
      ThreadLogContextSlot = getThreadLogContextSlot();
      p_n0xE0 = &n0xE0;
      v4 = &v8;
      n0xE0 = 0xE0;
      v5 = 0;
      n0x97 = 0x97;
      sub_1403515F0(
        3u,
        (__int64 *)&p_n0xE0,
        "CShopManager::GetGlobalShopCommodityParams",
        "Shop Manager is missing Global Commodity Data Record",
        1,
        v1,
        &v5,
        0,
        (__int64)ThreadLogContextSlot);
    }
    return 0;
  }
  return result;
}

// --- End Function: sub_144D1CDC0 (0x144D1CDC0) ---

// --- Function: sub_144D5B060 (0x144D5B060) ---
char __fastcall sub_144D5B060(__int64 a1)
{
  __int64 v2; // rax
  int v3; // ebx
  __int64 *ThreadLogContextSlot; // rax
  __int64 v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  __int64 v8; // rdi
  __int64 v9; // rbx
  void (__fastcall *p_sub_144CB9590)(__int64, __int128 *); // r9
  __int64 (__fastcall *p_sub_144CADEB0)(); // rax
  __int64 v12; // r14
  __int64 v13; // rdx
  char v14; // dl
  char v15; // dl
  char v16; // dl
  char v17; // dl
  int *p_n0xE0; // [rsp+50h] [rbp+7h] BYREF
  __int64 *v20; // [rsp+58h] [rbp+Fh]
  __int128 p_sub_144CADEB0_1; // [rsp+60h] [rbp+17h] BYREF
  _QWORD *v22; // [rsp+70h] [rbp+27h]
  int n0xE0; // [rsp+B0h] [rbp+67h] BYREF
  int n0x97; // [rsp+B4h] [rbp+6Bh]
  __int64 v25; // [rsp+B8h] [rbp+6Fh] BYREF

  LOBYTE(v2) = sub_144CCC580(*(_QWORD *)(a1 + 8), "CEntityComponentCommodityUIProvider::LoadShopInventoryData");
  if ( (_BYTE)v2 )
  {
    if ( Handle::IsValid((_QWORD *)(a1 + 0x1C0)) )
    {
      sub_144E0F950(a1 + 0x770);
      sub_144E0F950(a1 + 0x7E8);
      sub_144E0F950(a1 + 0x860);
      sub_144E0F950(a1 + 0x8D8);
      sub_144E0F950(a1 + 0x950);
      v5 = *(_QWORD *)(a1 + 0x1C0) & 0xFFFFFFFFFFFFLL;
      v6 = (_QWORD *)allocWithProfilerInfo_w(8u);
      v7 = v6;
      if ( v6 )
      {
        *v6 = a1;
        v22 = v6;
      }
      else
      {
        v7 = 0;
        v22 = 0;
      }
      v8 = *(_QWORD *)(v5 + 0x320);
      v9 = *(_QWORD *)(v5 + 0x318);
      p_sub_144CB9590 = (void (__fastcall *)(__int64, __int128 *))sub_144CB9590;
      *((_QWORD *)&p_sub_144CADEB0_1 + 1) = sub_144CB9590;
      p_sub_144CADEB0 = sub_144CADEB0;
      *(_QWORD *)&p_sub_144CADEB0_1 = sub_144CADEB0;
      if ( v9 != v8 )
      {
        v12 = v9 + 0x48;
        while ( 1 )
        {
          v13 = v12;
          if ( !v9 )
            v13 = 0;
          if ( p_sub_144CB9590 == (void (__fastcall *)(__int64, __int128 *))1 )
          {
            ((void (__fastcall *)(__int64))p_sub_144CADEB0)(v13);
          }
          else if ( p_sub_144CADEB0 == sub_144CADEB0 )
          {
            sub_144C5B6A0(v7, v13);
          }
          else
          {
            ((void (__fastcall *)(__int128 *, __int64))p_sub_144CADEB0)(&p_sub_144CADEB0_1, v13);
          }
          p_sub_144CB9590 = (void (__fastcall *)(__int64, __int128 *))*((_QWORD *)&p_sub_144CADEB0_1 + 1);
          v9 += 0x358;
          v12 += 0x358;
          if ( v9 == v8 )
            break;
          v7 = v22;
          p_sub_144CADEB0 = (__int64 (__fastcall *)())p_sub_144CADEB0_1;
        }
      }
      if ( (unsigned __int64)p_sub_144CB9590 >= 2 )
        p_sub_144CB9590(2, &p_sub_144CADEB0_1);
      v14 = *(_QWORD *)(a1 + 0x848) != *(_QWORD *)(a1 + 0x850);
      if ( !*(_BYTE *)(a1 + 0xC90) || *(_BYTE *)(a1 + 0xCA9) != v14 )
      {
        *(_BYTE *)(a1 + 0xCA9) = v14;
        *(_BYTE *)(a1 + 0xC90) = 1;
        sub_1403302D0(a1 + 0xC68, 0);
      }
      v15 = *(_QWORD *)(a1 + 0x8C0) != *(_QWORD *)(a1 + 0x8C8);
      if ( !*(_BYTE *)(a1 + 0xCD8) || *(_BYTE *)(a1 + 0xCF1) != v15 )
      {
        *(_BYTE *)(a1 + 0xCF1) = v15;
        *(_BYTE *)(a1 + 0xCD8) = 1;
        sub_1403302D0(a1 + 0xCB0, 0);
      }
      v16 = *(_QWORD *)(a1 + 0x938) != *(_QWORD *)(a1 + 0x940);
      if ( !*(_BYTE *)(a1 + 0xD20) || *(_BYTE *)(a1 + 0xD39) != v16 )
      {
        *(_BYTE *)(a1 + 0xD39) = v16;
        *(_BYTE *)(a1 + 0xD20) = 1;
        sub_1403302D0(a1 + 0xCF8, 0);
      }
      v2 = *(_QWORD *)(a1 + 0x9B8);
      v17 = *(_QWORD *)(a1 + 0x9B0) != v2;
      if ( !*(_BYTE *)(a1 + 0xD68) || *(_BYTE *)(a1 + 0xD81) != v17 )
      {
        *(_BYTE *)(a1 + 0xD81) = v17;
        *(_BYTE *)(a1 + 0xD68) = 1;
        LOBYTE(v2) = sub_1403302D0(a1 + 0xD40, 0);
      }
    }
    else
    {
      n0xE0 = 0xE0;
      p_n0xE0 = &n0xE0;
      n0x97 = 0x97;
      v20 = &v25;
      LODWORD(v2) = invokeGlobalCallbackAndMaskStatusBits(
                      3,
                      (__int64)&p_n0xE0,
                      (__int64)"CEntityComponentCommodityUIProvider::LoadShopInventoryData",
                      "Tried CEntityComponentCommodityUIProvider::LoadShopInventoryData without a shop");
      v3 = v2;
      if ( (v2 & 0xFFFFF) != 0 )
      {
        ThreadLogContextSlot = getThreadLogContextSlot();
        p_n0xE0 = &n0xE0;
        v20 = &v25;
        n0xE0 = 0xE0;
        n0x97 = 0x97;
        p_sub_144CADEB0_1 = 0;
        LOBYTE(v2) = sub_1403515F0(
                       3u,
                       (__int64 *)&p_n0xE0,
                       "CEntityComponentCommodityUIProvider::LoadShopInventoryData",
                       "Tried CEntityComponentCommodityUIProvider::LoadShopInventoryData without a shop",
                       1,
                       v3,
                       &p_sub_144CADEB0_1,
                       0,
                       (__int64)ThreadLogContextSlot);
      }
    }
  }
  return v2;
}

// --- End Function: sub_144D5B060 (0x144D5B060) ---

// --- Function: sub_144D6F950 (0x144D6F950) ---
double __fastcall sub_144D6F950(__int64 a1)
{
  __int128 v1; // xmm6
  __int128 v2; // xmm7
  __int128 v3; // xmm8
  __int64 v4; // r15
  unsigned __int64 v5; // rcx
  __int64 v6; // rdi
  __int64 v7; // rbx
  unsigned __int8 *v8; // r12
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // rcx
  bool v12; // zf
  __int64 v13; // r14
  unsigned int v14; // ecx
  unsigned int v15; // r8d
  int v16; // esi
  int v17; // r15d
  int v18; // r11d
  int v19; // r10d
  int v20; // edx
  int v21; // r14d
  int v22; // r9d
  int v23; // r8d
  unsigned __int64 v24; // rax
  __int64 v25; // rsi
  unsigned __int64 v26; // rax
  __int64 v27; // rsi
  bool v28; // al
  const char *p_Unavailable; // rax
  __int64 *ThreadLogContextSlot; // rax
  double v31; // xmm0_8
  __int64 v32; // rsi
  __int64 v33; // rax
  _QWORD *v34; // rax
  __int64 v42; // rcx
  float v45; // kr00_4
  __int64 v46; // rcx
  float v49; // kr00_4
  float v52; // kr00_4
  __int64 v53; // r8
  __int64 v54; // r9
  __int64 v55; // rbx
  __int64 v56; // r8
  __int64 v57; // r9
  __int64 v58; // r9
  __int64 i; // r8
  __int64 v60; // rdx
  __int64 j; // rax
  float v63; // kr00_4
  int v66; // [rsp+20h] [rbp-F0h]
  int v67; // [rsp+28h] [rbp-E8h]
  int v68; // [rsp+50h] [rbp-C0h]
  unsigned __int8 *v69; // [rsp+90h] [rbp-80h]
  unsigned int v70; // [rsp+A0h] [rbp-70h]
  int v71; // [rsp+A4h] [rbp-6Ch]
  __int128 v72; // [rsp+B0h] [rbp-60h] BYREF
  const void *v73; // [rsp+C0h] [rbp-50h]
  __int64 v74; // [rsp+D0h] [rbp-40h]
  __int64 v75; // [rsp+D8h] [rbp-38h]
  unsigned __int64 v76; // [rsp+E0h] [rbp-30h] BYREF
  _QWORD v77[2]; // [rsp+E8h] [rbp-28h] BYREF
  const void *v78; // [rsp+F8h] [rbp-18h]
  int n0x3200; // [rsp+100h] [rbp-10h] BYREF
  __int64 v80; // [rsp+104h] [rbp-Ch]
  int v81; // [rsp+10Ch] [rbp-4h]
  unsigned __int64 v82; // [rsp+110h] [rbp+0h]
  unsigned __int64 v83; // [rsp+118h] [rbp+8h]
  __int64 v84; // [rsp+120h] [rbp+10h]
  __int64 v85; // [rsp+128h] [rbp+18h]
  _QWORD v86[2]; // [rsp+150h] [rbp+40h] BYREF
  _QWORD v87[2]; // [rsp+160h] [rbp+50h] BYREF
  __int128 v88; // [rsp+170h] [rbp+60h] BYREF
  __int64 v89; // [rsp+180h] [rbp+70h] BYREF
  _DWORD v90[3]; // [rsp+190h] [rbp+80h] BYREF
  char v91; // [rsp+19Ch] [rbp+8Ch] BYREF
  _DWORD v92[3]; // [rsp+1A0h] [rbp+90h] BYREF
  char v93; // [rsp+1ACh] [rbp+9Ch] BYREF
  __int64 v94; // [rsp+1B0h] [rbp+A0h] BYREF
  __int64 n0x24; // [rsp+1B8h] [rbp+A8h]
  _BYTE *v96; // [rsp+1C0h] [rbp+B0h]
  _BYTE v97[40]; // [rsp+1C8h] [rbp+B8h] BYREF
  __int128 v98; // [rsp+200h] [rbp+F0h]
  __int128 v99; // [rsp+210h] [rbp+100h]
  __int128 v100; // [rsp+220h] [rbp+110h]

  v74 = a1;
  v81 = 0;
  v4 = a1;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  n0x3200 = 0x3200;
  v80 = 1;
  v82 = __rdtsc();
  qword_149B4B870(
    &n0x3200,
    &word_149E499EC,
    "CEntityComponentCommodityUIProvider::OnInventoryUpdate",
    "W:\\p4-src\\CryEngine\\Code\\GameSDK\\GameDll\\Shop/EntityComponentCommodityUIProvider.cpp",
    0x1A3B);
  v5 = *(_QWORD *)(v4 + 8);
  HIWORD(n0x3200) = word_149E499EC;
  if ( sub_144CCC580(v5, "CEntityComponentCommodityUIProvider::OnInventoryUpdate") && *(_DWORD *)(v4 + 0x2868) )
  {
    sub_144D5B060(v4);
    v6 = *(_QWORD *)(v4 + 0xA30);
    v7 = *(_QWORD *)(v4 + 0xA28);
    v75 = v6;
    if ( v7 != v6 )
    {
      v8 = (unsigned __int8 *)(v7 + 0xC1C);
      v100 = v1;
      v99 = v2;
      v98 = v3;
      v69 = (unsigned __int8 *)(v7 + 0xC1C);
      while ( 1 )
      {
        v9 = *(_QWORD *)(v4 + 0x1C0) & 0xFFFFFFFFFFFFLL;
        v72 = *(_OWORD *)(v8 + 0xFFFFFFF4);
        v10 = *(_QWORD *)(v9 + 0x318);
        v11 = *(_QWORD *)(v9 + 0x320);
        v12 = v10 == v11;
        if ( v10 != v11 )
        {
          do
          {
            if ( *(_OWORD *)(v10 + 0x2B0) == v72 )
              break;
            v10 += 0x358;
          }
          while ( v10 != v11 );
          v12 = v10 == v11;
        }
        if ( v12 )
          v10 = 0;
        v13 = v10 + 0x48;
        if ( !v10 )
          v13 = 0;
        if ( v13 )
          break;
        v90[0] = 0xE0;
        v86[0] = v90;
        v90[1] = 0x97;
        v86[1] = &v91;
        v90[2] = 0xB2;
        v71 = invokeGlobalCallbackAndMaskStatusBits(
                4,
                (__int64)v86,
                (__int64)"CEntityComponentCommodityUIProvider::OnInventoryUpdate",
                "Resource GUID not found in Shop Inventory! - Shop[$$] resourceGUID[$$]");
        if ( (v71 & 0xFFFFF) != 0 )
        {
          v14 = *((_DWORD *)v8 + 0xFFFFFFFF);
          v15 = *((_DWORD *)v8 + 0xFFFFFFFD);
          v16 = *v8;
          v17 = v8[2];
          v96 = v97;
          v18 = (unsigned __int8)v15;
          v94 = 0;
          v19 = BYTE1(v15);
          v70 = HIBYTE(v15);
          v20 = BYTE2(v15);
          v97[0] = 0;
          v21 = v8[1];
          v22 = v69[0xFFFFFFFA];
          v23 = v69[0xFFFFFFFB];
          v68 = v8[3];
          v67 = v69[0xFFFFFFF8];
          v66 = v69[0xFFFFFFF9];
          n0x24 = 0x24;
          sub_1402C61F0(
            (__int64)&v94,
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            v23,
            v22,
            v66,
            v67,
            v70,
            v20,
            v19,
            v18,
            v68,
            v17,
            v21,
            v16,
            HIBYTE(v14),
            BYTE2(v14),
            BYTE1(v14),
            (unsigned __int8)v14);
          v4 = v74;
          v6 = v75;
          v77[0] = "CommodityUIProvider_Id";
          v77[1] = v96;
          v24 = *(_QWORD *)(v74 + 8);
          v78 = 0;
          v76 = v24;
          if ( !v24 )
            goto LABEL_27;
          v25 = v24 & 0xFFFFFFFFFFFFLL;
          v26 = HIWORD(v24);
          v27 = (v26 & 0xF000) != 0 ? v25 & 0xFFFFFF000000LL : v25 - 6;
          if ( *(_WORD *)(v27 + 2) != (v26 & 0xFFF) )
            goto LABEL_27;
          if ( *(_BYTE *)(NtCurrentTeb_w() + 0x12D) || (v28 = sub_140539D80()) )
            v28 = 1;
          if ( *(_WORD *)(v27 + 4) == 2 && v28 || sub_140392020(&v76) )
            p_Unavailable = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v4 + 8)
                                                                                         & 0xFFFFFFFFFFFFLL)
                                                                             + 0x70LL))(*(_QWORD *)(v4 + 8) & 0xFFFFFFFFFFFFLL);
          else
LABEL_27:
            p_Unavailable = "Unavailable";
          *((_QWORD *)&v72 + 1) = p_Unavailable;
          *(_QWORD *)&v72 = "CommodityUIProvider_Name";
          v73 = 0;
          ThreadLogContextSlot = getThreadLogContextSlot();
          v92[0] = 0xE0;
          v87[0] = v92;
          v92[1] = 0x97;
          v87[1] = &v93;
          v92[2] = 0xB2;
          v88 = 0;
          sub_144BFC980(
            4,
            (unsigned int)v87,
            (unsigned int)"CEntityComponentCommodityUIProvider::OnInventoryUpdate",
            (unsigned int)"Resource GUID not found in Shop Inventory! - Shop[$$] resourceGUID[$$]",
            1,
            v71,
            (__int64)&v88,
            0,
            (__int64)ThreadLogContextSlot,
            (__int64)&v72,
            (__int64)v77);
          sub_1402A3D30(v73);
          sub_1402A3D30(v78);
          if ( v96 != v97 )
          {
            qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - n0x24;
            sub_147605980(v96);
          }
          v8 = v69;
        }
LABEL_70:
        v8 += 0xD20;
        v7 += 0xD20;
        v69 = v8;
        if ( v7 == v6 )
          goto LABEL_71;
      }
      v31 = (*(double (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v13 + 0x28LL))(
              v13,
              3,
              *(_QWORD *)(v4 + 0x2880));
      *(double *)(v8 + 0x24) = v31;
      if ( *((_DWORD *)v8 + 0x35) == 4 )
      {
        *(double *)(v8 + 0x2C) = (*(double (**)(void))(*(_QWORD *)((*(_QWORD *)(v4 + 0x1C0) & 0xFFFFFFFFFFFFLL) + 0x330)
                                                     + 0x40LL))()
                               * *(double *)(v8 + 0x24)
                               * 0.01;
        if ( !v8[0xFFFFF664] || v8[0xFFFFF67D] != 1 )
        {
          v8[0xFFFFF67D] = 1;
LABEL_38:
          v8[0xFFFFF664] = 1;
          sub_1403302D0((__int64)(v8 + 0xFFFFF63C), 0);
        }
      }
      else
      {
        *(double *)(v8 + 0x2C) = v31;
        if ( !v8[0xFFFFF664] || v8[0xFFFFF67D] )
        {
          v8[0xFFFFF67D] = 0;
          goto LABEL_38;
        }
      }
      v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x60LL))(v13);
      v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 0x58LL))(v13);
      v34 = sub_14036A800(&v89, v32 - v33);
      *(_QWORD *)(v8 + 0x74) = sub_14036A710(v77, (__int64)v34)[2];
      if ( (__int64)AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)(v8 + 0xC)) <= 0 )
      {
        if ( !v8[0xFFFFF6AC] || *(_QWORD *)(v8 + 0xFFFFF6CC) )
        {
          *(_QWORD *)(v8 + 0xFFFFF6CC) = 0;
          v42 = (__int64)(v8 + 0xFFFFF684);
          v8[0xFFFFF6AC] = 1;
          goto LABEL_49;
        }
      }
      else
      {
        AK::WriteBytesMem::Bytes((AK::WriteBytesMem *)(v8 + 0xC));
        _XMM1 = 0;
        __asm { vcvtsi2sd xmm1, xmm1, rax }
        sub_1404EE670(3);
        _XMM0 = 0;
        __asm
        {
          vcvtsi2sd xmm0, xmm0, rax
          vcvttsd2si rax, xmm0
        }
        if ( !v8[0xFFFFF6AC] || *(_QWORD *)(v8 + 0xFFFFF6CC) != _RAX )
        {
          *(_QWORD *)(v8 + 0xFFFFF6CC) = _RAX;
          v8[0xFFFFF6AC] = 1;
          sub_1403302D0((__int64)(v8 + 0xFFFFF684), 0);
        }
        _XMM0 = sub_1403B6AB0();
        __asm { vcvttsd2si rax, xmm0 }
        if ( !v8[0xFFFFF74C] || *(_QWORD *)(v8 + 0xFFFFF76C) != _RAX )
        {
          *(_QWORD *)(v8 + 0xFFFFF76C) = _RAX;
          v42 = (__int64)(v8 + 0xFFFFF724);
          v8[0xFFFFF74C] = 1;
LABEL_49:
          sub_1403302D0(v42, 0);
        }
      }
      if ( *((_DWORD *)v8 + 2) == 3 )
      {
        _XMM1 = COERCE_UNSIGNED_INT64(100.0 * *(double *)(v8 + 0x2C));
        __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
        if ( !v8[0xFFFFF544] || *(float *)&_XMM2 != *((float *)v8 + 0xFFFFFD58) )
        {
          v8[0xFFFFF544] = 1;
          *((float *)v8 + 0xFFFFFD58) = *(float *)&_XMM2;
          sub_1403302D0((__int64)(v8 + 0xFFFFF51C), 0);
        }
        if ( !v8[0xFFFFFB85] )
        {
          _XMM0 = 0;
          __asm { vcvtsi2sd xmm0, xmm0, qword ptr [r12+0BCh] }
          v49 = (float)sub_1404EE670(3);
          if ( !v8[0xFFFFF5D4] || v49 != *((float *)v8 + 0xFFFFFD7C) )
          {
            v8[0xFFFFF5D4] = 1;
            *((float *)v8 + 0xFFFFFD7C) = v49;
            sub_1403302D0((__int64)(v8 + 0xFFFFF5AC), 0);
          }
          _XMM0 = 0;
          __asm { vcvtsi2sd xmm0, xmm0, qword ptr [r12+0BCh] }
          goto LABEL_64;
        }
        v45 = (float)sub_1404EE670(3);
        if ( v8[0xFFFFF5D4] && v45 == *((float *)v8 + 0xFFFFFD7C) )
        {
LABEL_64:
          v52 = (float)sub_1404EE670(3);
          if ( !v8[0xFFFFF61C] || v52 != *((float *)v8 + 0xFFFFFD8E) )
          {
            *((float *)v8 + 0xFFFFFD8E) = v52;
            v8[0xFFFFF61C] = 1;
            sub_1403302D0((__int64)(v8 + 0xFFFFF5F4), 0);
          }
          if ( !v8[0xFFFFF7E4] || *(_QWORD *)(v8 + 0xFFFFF804) != 1 )
          {
            *(_QWORD *)(v8 + 0xFFFFF804) = 1;
            v8[0xFFFFF7E4] = 1;
            sub_1403302D0((__int64)(v8 + 0xFFFFF7BC), 0);
          }
          goto LABEL_70;
        }
        *((float *)v8 + 0xFFFFFD7C) = v45;
        v8[0xFFFFF5D4] = 1;
        v46 = (__int64)(v8 + 0xFFFFF5AC);
      }
      else
      {
        v63 = (float)sub_1404EE670(3);
        if ( !v8[0xFFFFF5D4] || v63 != *((float *)v8 + 0xFFFFFD7C) )
        {
          v8[0xFFFFF5D4] = 1;
          *((float *)v8 + 0xFFFFFD7C) = v63;
          sub_1403302D0((__int64)(v8 + 0xFFFFF5AC), 0);
        }
        _XMM1 = COERCE_UNSIGNED_INT64(100.0 * *(double *)(v8 + 0x2C));
        __asm { vcvtsd2ss xmm2, xmm1, xmm1 }
        if ( v8[0xFFFFF544] && *(float *)&_XMM2 == *((float *)v8 + 0xFFFFFD58) )
          goto LABEL_64;
        *((float *)v8 + 0xFFFFFD58) = *(float *)&_XMM2;
        v8[0xFFFFF544] = 1;
        v46 = (__int64)(v8 + 0xFFFFF51C);
      }
      sub_1403302D0(v46, 0);
      goto LABEL_64;
    }
LABEL_71:
    if ( *(_QWORD *)(v4 + 0x1B60) == 1 )
    {
      if ( (v53 = *(_QWORD *)(v4 + 0x12D0), v53 > (__int64)0xFFFFFFFFFFFFFFFFuLL)
        && (v54 = *(_QWORD *)(v4 + 0x938), v53 < (*(_QWORD *)(v4 + 0x940) - v54) / 0xD20)
        && (v55 = v54 + 0xD20 * v53, *(_QWORD *)(v4 + 0x2220) == *(_QWORD *)(v55 + 0xC10))
        && *(_QWORD *)(v4 + 0x2228) == *(_QWORD *)(v55 + 0xC18)
        && v55
        || (v56 = *(_QWORD *)(v4 + 0x1320), v56 > (__int64)0xFFFFFFFFFFFFFFFFuLL)
        && (v57 = *(_QWORD *)(v4 + 0xA28), v56 < (*(_QWORD *)(v4 + 0xA30) - v57) / 0xD20)
        && (v55 = v57 + 0xD20 * v56, *(_QWORD *)(v4 + 0x2220) == *(_QWORD *)(v55 + 0xC10))
        && *(_QWORD *)(v4 + 0x2228) == *(_QWORD *)(v55 + 0xC18)
        && v55 )
      {
        *(_QWORD *)(v4 + 0x2238) = *(_QWORD *)(v55 + 0xC48);
        sub_14153FC40(v4 + 0x1C50, v55 + 0x138);
        sub_141583A20(v4 + 0x1CE8, v55 + 0x2A0);
        v58 = *(_QWORD *)(v4 + 0x2280);
        for ( i = *(_QWORD *)(v4 + 0x2278); i != v58; i += 0x40 )
        {
          v60 = *(_QWORD *)(i + 0x30);
          for ( j = *(_QWORD *)(i + 0x28); j != v60; j += 0x28 )
            *(double *)(j + 0x18) = *(float *)(v55 + 0x17C);
        }
      }
    }
    sub_144CD7110(v4);
  }
  v83 = __rdtsc();
  return qword_149B4B878(&n0x3200);
}

// --- End Function: sub_144D6F950 (0x144D6F950) ---

// --- Function: sub_144DB8280 (0x144DB8280) ---
__int64 __fastcall sub_144DB8280(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // rdi
  _BYTE *v4; // rsi
  int n3; // ecx
  __int64 result; // rax
  float v7; // kr00_4

  v1 = *(_QWORD *)(a1 + 0x808);
  v3 = *(_QWORD *)(a1 + 0x810);
  if ( v1 != v3 )
  {
    v4 = (_BYTE *)(v1 + 0x158);
    do
    {
      if ( !*v4 || v4[0x19] )
      {
        v4[0x19] = 0;
        *v4 = 1;
        sub_1403302D0((__int64)(v4 + 0xFFFFFFD8), 0);
      }
      v1 += 0x180;
      v4 += 0x180;
    }
    while ( v1 != v3 );
  }
  if ( !*(_BYTE *)(a1 + 0xA50) || *(_QWORD *)(a1 + 0xA70) != 0xFFFFFFFFFFFFFFFFuLL )
  {
    *(_QWORD *)(a1 + 0xA70) = 0xFFFFFFFFFFFFFFFFuLL;
    *(_BYTE *)(a1 + 0xA50) = 1;
    sub_1403302D0(a1 + 0xA28, 0);
  }
  if ( !*(_BYTE *)(a1 + 0x570) || *(_BYTE *)(a1 + 0x589) )
  {
    *(_BYTE *)(a1 + 0x589) = 0;
    *(_BYTE *)(a1 + 0x570) = 1;
    sub_1403302D0(a1 + 0x548, 0);
  }
  if ( !*(_BYTE *)(a1 + 0xB18) || *(_BYTE *)(a1 + 0xB31) )
  {
    *(_BYTE *)(a1 + 0xB31) = 0;
    *(_BYTE *)(a1 + 0xB18) = 1;
    sub_1403302D0(a1 + 0xAF0, 0);
  }
  *(_DWORD *)(a1 + 0xCE4) = 0;
  std::_Tree<std::_Tmap_traits<double,int,std::less<double>,std::allocator<std::pair<double const,int>>,0>>::clear((std::_Tree<std::_Tmap_traits<double,int,std::less<double>,std::allocator<std::pair<double const ,int> >,0> > *)(a1 + 0xCC8));
  sub_142E87100(a1 + 0x820);
  n3 = 3;
  if ( *(_DWORD *)(a1 + 0xC20) == 1 )
    n3 = 1;
  result = sub_1404EE670(n3);
  v7 = (float)result;
  if ( !*(_BYTE *)(a1 + 0x238) || v7 != *(float *)(a1 + 0x254) )
  {
    *(_BYTE *)(a1 + 0x238) = 1;
    *(float *)(a1 + 0x254) = v7;
    result = sub_1403302D0(a1 + 0x210, 0);
  }
  if ( !*(_BYTE *)(a1 + 0x400) || *(_QWORD *)(a1 + 0x420) != 1 )
  {
    *(_QWORD *)(a1 + 0x420) = 1;
    *(_BYTE *)(a1 + 0x400) = 1;
    return sub_1403302D0(a1 + 0x3D8, 0);
  }
  return result;
}

// --- End Function: sub_144DB8280 (0x144DB8280) ---

// --- Function: sub_144DB9460 (0x144DB9460) ---
__int64 __fastcall sub_144DB9460(__int64 a1)
{
  __int64 v2; // rcx
  _QWORD v4[3]; // [rsp+20h] [rbp-18h] BYREF
  void *v5; // [rsp+40h] [rbp+8h] BYREF

  v2 = a1 + 0x680;
  if ( !*(_BYTE *)(v2 + 0x28) || *(float *)(v2 + 0x44) != 0.0 )
  {
    *(_DWORD *)(v2 + 0x44) = 0;
    *(_BYTE *)(v2 + 0x28) = 1;
    sub_1403302D0(v2, 0);
  }
  sub_14036D890(v4, 0);
  *(_QWORD *)(a1 + 0xC38) = v4[1];
  if ( !*(_BYTE *)(a1 + 0x368) || *(_QWORD *)(a1 + 0x388) )
  {
    *(_QWORD *)(a1 + 0x388) = 0;
    *(_BYTE *)(a1 + 0x368) = 1;
    sub_1403302D0(a1 + 0x340, 0);
  }
  CreateStringObjectFromString(&v5, (const char *)&word_1481A69AC);
  if ( !*(_BYTE *)(a1 + 0x318) || (unsigned int)sub_1403E4780((unsigned __int8 **)(a1 + 0x338), &v5) )
  {
    copyStringStructure((char **)(a1 + 0x338), (char **)&v5);
    *(_BYTE *)(a1 + 0x318) = 1;
    sub_1403302D0(a1 + 0x2F0, 0);
  }
  sub_140370D10(&v5);
  if ( !*(_BYTE *)(a1 + 0x2C8) || *(_QWORD *)(a1 + 0x2E8) )
  {
    *(_QWORD *)(a1 + 0x2E8) = 0;
    *(_BYTE *)(a1 + 0x2C8) = 1;
    sub_1403302D0(a1 + 0x2A0, 0);
  }
  if ( !*(_BYTE *)(a1 + 0x570) || *(_BYTE *)(a1 + 0x589) )
  {
    *(_BYTE *)(a1 + 0x589) = 0;
    *(_BYTE *)(a1 + 0x570) = 1;
    sub_1403302D0(a1 + 0x548, 0);
  }
  if ( !*(_BYTE *)(a1 + 0xB18) || *(_BYTE *)(a1 + 0xB31) )
  {
    *(_BYTE *)(a1 + 0xB31) = 0;
    *(_BYTE *)(a1 + 0xB18) = 1;
    sub_1403302D0(a1 + 0xAF0, 0);
  }
  *(_DWORD *)(a1 + 0xCE4) = 0;
  std::_Tree<std::_Tmap_traits<double,int,std::less<double>,std::allocator<std::pair<double const,int>>,0>>::clear((std::_Tree<std::_Tmap_traits<double,int,std::less<double>,std::allocator<std::pair<double const ,int> >,0> > *)(a1 + 0xCC8));
  return sub_142E87100(a1 + 0x820);
}

// --- End Function: sub_144DB9460 (0x144DB9460) ---

// --- Function: sub_144DC87D0 (0x144DC87D0) ---
char __fastcall sub_144DC87D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r13
  int v6; // eax
  int v7; // edi
  __int64 *ThreadLogContextSlot; // rax
  int v9; // ebx
  __int64 v10; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  int v12; // ebx
  __int64 *ThreadLogContextSlot_2; // rax
  __int64 *v14; // r14
  unsigned __int64 v15; // r15
  unsigned __int64 allocSize; // rcx
  __int64 v17; // r13
  __int64 v18; // rax
  unsigned __int64 v19; // rsi
  __int64 v20; // r12
  unsigned __int64 v21; // rdi
  __int64 i; // rbx
  int v23; // esi
  __int64 v24; // rax
  const void **v25; // rax
  const void **v26; // rbx
  _LocaleUpdate *v27; // r15
  __int64 *j; // rbx
  int v29; // esi
  __int64 *ThreadLogContextSlot_4; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  const void **v33; // rax
  const void **v34; // rsi
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rsi
  int v38; // esi
  __int64 *ThreadLogContextSlot_5; // rax
  __int64 v40; // r14
  int v41; // r15d
  __int64 v42; // rax
  __int64 v43; // r14
  size_t Size_1; // rdi
  __int64 v45; // rax
  __int64 *ThreadLogContextSlot_7; // rax
  char *v47; // rcx
  __int64 v48; // rax
  __int64 **v49; // rax
  __int64 *k; // rax
  int v51; // r15d
  __int64 v52; // rax
  __int64 v53; // r14
  size_t Size; // rdi
  __int64 v55; // rax
  __int64 *ThreadLogContextSlot_6; // rax
  const void **v57; // rax
  const void **v58; // r14
  const char *v59; // rax
  __int128 *v60; // rax
  double v61; // xmm1_8
  __int64 v62; // rax
  int n2_1; // esi
  char v64; // di
  int v65; // edi
  __int64 *ThreadLogContextSlot_3; // rax
  __int64 v67; // rdx
  __int128 *v68; // rax
  double v69; // xmm1_8
  __int64 *v70; // rcx
  __int64 v71; // rdx
  __int64 v72; // rcx
  __int64 v74; // [rsp+60h] [rbp-A0h] BYREF
  __int64 *v75; // [rsp+68h] [rbp-98h] BYREF
  char *v76; // [rsp+70h] [rbp-90h]
  __int64 v77; // [rsp+78h] [rbp-88h] BYREF
  char *v78; // [rsp+80h] [rbp-80h]
  const void *v79; // [rsp+88h] [rbp-78h]
  __int64 v80; // [rsp+90h] [rbp-70h] BYREF
  char *v81; // [rsp+98h] [rbp-68h] BYREF
  char *v82; // [rsp+A0h] [rbp-60h] BYREF
  char *v83; // [rsp+A8h] [rbp-58h] BYREF
  _QWORD v84[2]; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v85; // [rsp+C0h] [rbp-40h] BYREF
  char *v86; // [rsp+C8h] [rbp-38h]
  const void *v87; // [rsp+D0h] [rbp-30h]
  __int128 v88; // [rsp+D8h] [rbp-28h] BYREF
  char v89[8]; // [rsp+E8h] [rbp-18h] BYREF
  _DWORD v90[2]; // [rsp+F0h] [rbp-10h] BYREF
  _DWORD v91[2]; // [rsp+F8h] [rbp-8h] BYREF
  unsigned __int8 *v92; // [rsp+100h] [rbp+0h] BYREF
  _DWORD v93[2]; // [rsp+108h] [rbp+8h] BYREF
  _DWORD v94[2]; // [rsp+110h] [rbp+10h] BYREF
  _DWORD v95[2]; // [rsp+118h] [rbp+18h] BYREF
  _DWORD v96[2]; // [rsp+120h] [rbp+20h] BYREF
  _DWORD v97[2]; // [rsp+128h] [rbp+28h] BYREF
  _DWORD v98[2]; // [rsp+130h] [rbp+30h] BYREF
  void *v99; // [rsp+138h] [rbp+38h] BYREF
  _DWORD v100[2]; // [rsp+140h] [rbp+40h] BYREF
  char v101; // [rsp+148h] [rbp+48h] BYREF
  __int128 v102; // [rsp+150h] [rbp+50h] BYREF
  _QWORD v103[2]; // [rsp+160h] [rbp+60h] BYREF
  const void *v104; // [rsp+170h] [rbp+70h]
  _QWORD v105[2]; // [rsp+178h] [rbp+78h] BYREF
  _QWORD v106[2]; // [rsp+188h] [rbp+88h] BYREF
  _QWORD v107[2]; // [rsp+198h] [rbp+98h] BYREF
  _QWORD v108[2]; // [rsp+1A8h] [rbp+A8h] BYREF
  _QWORD v109[2]; // [rsp+1B8h] [rbp+B8h] BYREF
  _QWORD v110[2]; // [rsp+1C8h] [rbp+C8h] BYREF
  _QWORD v111[2]; // [rsp+1D8h] [rbp+D8h] BYREF
  __int64 v112[2]; // [rsp+1E8h] [rbp+E8h] BYREF
  _QWORD v113[2]; // [rsp+1F8h] [rbp+F8h] BYREF
  _QWORD v114[2]; // [rsp+208h] [rbp+108h] BYREF
  __int128 v115; // [rsp+218h] [rbp+118h] BYREF
  __int128 v116; // [rsp+228h] [rbp+128h] BYREF
  __int128 v117; // [rsp+238h] [rbp+138h] BYREF
  __int128 v118; // [rsp+248h] [rbp+148h] BYREF
  char v119[16]; // [rsp+258h] [rbp+158h] BYREF
  char v120[16]; // [rsp+268h] [rbp+168h] BYREF
  char v121[16]; // [rsp+278h] [rbp+178h] BYREF
  char v122[16]; // [rsp+288h] [rbp+188h] BYREF
  __int64 v123; // [rsp+298h] [rbp+198h] BYREF
  _QWORD v124[2]; // [rsp+2A0h] [rbp+1A0h] BYREF
  _BYTE v125[72]; // [rsp+2B0h] [rbp+1B0h] BYREF
  _BYTE v126[40]; // [rsp+2F8h] [rbp+1F8h] BYREF
  char v127; // [rsp+320h] [rbp+220h]
  void *v128; // [rsp+340h] [rbp+240h] BYREF
  _BYTE v129[40]; // [rsp+348h] [rbp+248h] BYREF
  char v130; // [rsp+370h] [rbp+270h]
  char v131; // [rsp+389h] [rbp+289h]
  _BYTE v132[40]; // [rsp+390h] [rbp+290h] BYREF
  char v133; // [rsp+3B8h] [rbp+2B8h]
  char v134; // [rsp+3D1h] [rbp+2D1h]
  _BYTE v135[40]; // [rsp+3D8h] [rbp+2D8h] BYREF
  char v136; // [rsp+400h] [rbp+300h]
  char v137; // [rsp+419h] [rbp+319h]
  __int128 v138; // [rsp+428h] [rbp+328h]
  __int128 v139; // [rsp+438h] [rbp+338h]
  __int128 v140; // [rsp+448h] [rbp+348h]
  double v141; // [rsp+458h] [rbp+358h]
  char v142[40]; // [rsp+460h] [rbp+360h] BYREF
  char v143; // [rsp+488h] [rbp+388h]
  unsigned __int8 *v144; // [rsp+4A8h] [rbp+3A8h] BYREF
  int n2; // [rsp+4B0h] [rbp+3B0h]
  int n0x80; // [rsp+4B8h] [rbp+3B8h]
  char v147[16]; // [rsp+4C0h] [rbp+3C0h] BYREF
  int v148; // [rsp+4D0h] [rbp+3D0h]
  char v149[16]; // [rsp+550h] [rbp+450h] BYREF
  char v150[16]; // [rsp+560h] [rbp+460h] BYREF
  char v151[16]; // [rsp+570h] [rbp+470h] BYREF
  char v152[8]; // [rsp+580h] [rbp+480h] BYREF
  __int64 v153; // [rsp+588h] [rbp+488h]
  char *v154; // [rsp+590h] [rbp+490h]
  char v155; // [rsp+598h] [rbp+498h] BYREF
  char v156[8]; // [rsp+5C0h] [rbp+4C0h] BYREF
  __int64 v157; // [rsp+5C8h] [rbp+4C8h]
  char *v158; // [rsp+5D0h] [rbp+4D0h]
  char v159; // [rsp+5D8h] [rbp+4D8h] BYREF
  _BYTE v160[72]; // [rsp+600h] [rbp+500h] BYREF
  char v161[40]; // [rsp+648h] [rbp+548h] BYREF
  char v162; // [rsp+670h] [rbp+570h]
  void *v163; // [rsp+690h] [rbp+590h] BYREF
  char v164[40]; // [rsp+698h] [rbp+598h] BYREF
  char v165; // [rsp+6C0h] [rbp+5C0h]
  char v166; // [rsp+6D9h] [rbp+5D9h]
  char v167[40]; // [rsp+6E0h] [rbp+5E0h] BYREF
  char v168; // [rsp+708h] [rbp+608h]
  char v169; // [rsp+721h] [rbp+621h]
  char v170[40]; // [rsp+728h] [rbp+628h] BYREF
  char v171; // [rsp+750h] [rbp+650h]
  char v172; // [rsp+769h] [rbp+669h]
  __int128 v173; // [rsp+778h] [rbp+678h]
  __int128 v174; // [rsp+798h] [rbp+698h]
  __int64 v175; // [rsp+7A8h] [rbp+6A8h]
  int n3; // [rsp+800h] [rbp+700h]
  int v177; // [rsp+820h] [rbp+720h]
  _BYTE v178[72]; // [rsp+8A0h] [rbp+7A0h] BYREF
  char v179[40]; // [rsp+8E8h] [rbp+7E8h] BYREF
  char v180; // [rsp+910h] [rbp+810h]
  void *v181[46]; // [rsp+930h] [rbp+830h] BYREF
  int v182; // [rsp+AA0h] [rbp+9A0h]

  v80 = a1;
  v4 = a1;
  LOBYTE(v6) = sub_144CCC580(
                 *(_QWORD *)(a1 + 8),
                 "CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse");
  if ( !(_BYTE)v6 )
    return v6;
  if ( !*(_BYTE *)(v4 + 0x22F8) || *(_BYTE *)(v4 + 0x2311) )
  {
    *(_BYTE *)(v4 + 0x2311) = 0;
    *(_BYTE *)(v4 + 0x22F8) = 1;
    LOBYTE(v6) = sub_1403302D0(v4 + 0x22D0, 0);
  }
  if ( a3 != *(_QWORD *)(v4 + 0x2870) )
  {
    if ( n2_172 >= 2 )
    {
      v123 = 0x97000000E0LL;
      v75 = &v123;
      v76 = (char *)v124 + 4;
      LODWORD(v124[0]) = 0x1D;
      v6 = invokeGlobalCallbackAndMaskStatusBits(
             5,
             (__int64)&v75,
             (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
             "RequestId Mismatch - playerId[$$] Response requestId[$$] Current requestId[$$]");
      v7 = v6;
      if ( (v6 & 0xFFFFF) != 0 )
      {
        v76 = *(char **)(v4 + 0x2870);
        v78 = *(char **)(v4 + 0x2880);
        v75 = 0;
        v84[0] = 0;
        v84[1] = a3;
        v77 = 0;
        LOBYTE(v79) = 0;
        ThreadLogContextSlot = getThreadLogContextSlot();
        v123 = 0x97000000E0LL;
        v80 = (__int64)&v123;
        v81 = (char *)v124 + 4;
        LODWORD(v124[0]) = 0x1D;
        v88 = 0;
        LOBYTE(v6) = sub_144BE7120(
                       5,
                       (unsigned int)&v80,
                       (unsigned int)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
                       (unsigned int)"RequestId Mismatch - playerId[$$] Response requestId[$$] Current requestId[$$]",
                       1,
                       v7,
                       (__int64)&v88,
                       0,
                       (__int64)ThreadLogContextSlot,
                       (__int64)&v77,
                       (__int64)v84,
                       (__int64)&v75);
      }
    }
    return v6;
  }
  *(_DWORD *)(v4 + 0x2868) = 1;
  if ( n2_172 >= 2 )
  {
    sub_1464E73E0(qword_149E7E438, &v123);
    v123 = 0x97000000E0LL;
    v75 = &v123;
    v76 = (char *)v124 + 4;
    LODWORD(v124[0]) = 0x1D;
    v9 = invokeGlobalCallbackAndMaskStatusBits(
           5,
           (__int64)&v75,
           (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
           "[Client] Cargo Location Data Response - entity[$$], name[$$]");
    if ( (v9 & 0xFFFFF) != 0 )
    {
      v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v4 + 8) & 0xFFFFFFFFFFFFLL) + 0x70LL))(*(_QWORD *)(v4 + 8) & 0xFFFFFFFFFFFFLL);
      v103[0] = 0;
      v103[1] = v10;
      v104 = 0;
      sub_1403B0A70((unsigned __int64 *)(v4 + 8), v84);
      v78 = (char *)v84[0];
      v77 = 0;
      LOBYTE(v79) = 0;
      ThreadLogContextSlot_1 = getThreadLogContextSlot();
      v123 = 0x97000000E0LL;
      v75 = &v123;
      v76 = (char *)v124 + 4;
      LODWORD(v124[0]) = 0x1D;
      v88 = 0;
      sub_140441C40(
        5u,
        (__int64 *)&v75,
        "CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
        "[Client] Cargo Location Data Response - entity[$$], name[$$]",
        1,
        v9,
        &v88,
        0,
        (__int64)ThreadLogContextSlot_1,
        &v77,
        v103);
      sub_1402A3D30(v104);
    }
  }
  sub_144D5B060(v4);
  sub_144E0FA50(v4 + 0x1490);
  if ( !*(_BYTE *)(v4 + 0x1530) || *(_BYTE *)(v4 + 0x1549) )
  {
    *(_BYTE *)(v4 + 0x1549) = 0;
    *(_BYTE *)(v4 + 0x1530) = 1;
    sub_1403302D0(v4 + 0x1508, 0);
  }
  sub_144E0FA50(v4 + 0x1668);
  if ( !*(_BYTE *)(v4 + 0x1708) || *(_BYTE *)(v4 + 0x1721) )
  {
    *(_BYTE *)(v4 + 0x1721) = 0;
    *(_BYTE *)(v4 + 0x1708) = 1;
    sub_1403302D0(v4 + 0x16E0, 0);
  }
  if ( !*(_BYTE *)(v4 + 0x1780) || *(_QWORD *)(v4 + 0x17A0) )
  {
    *(_QWORD *)(v4 + 0x17A0) = 0;
    *(_BYTE *)(v4 + 0x1780) = 1;
    sub_1403302D0(v4 + 0x1758, 0);
  }
  sub_144E0FA50(v4 + 0x1840);
  if ( !*(_BYTE *)(v4 + 0x18E0) || *(_BYTE *)(v4 + 0x18F9) )
  {
    *(_BYTE *)(v4 + 0x18F9) = 0;
    *(_BYTE *)(v4 + 0x18E0) = 1;
    sub_1403302D0(v4 + 0x18B8, 0);
  }
  if ( !*(_BYTE *)(v4 + 0x1958) || *(_QWORD *)(v4 + 0x1978) )
  {
    *(_QWORD *)(v4 + 0x1978) = 0;
    *(_BYTE *)(v4 + 0x1958) = 1;
    sub_1403302D0(v4 + 0x1930, 0);
  }
  LOBYTE(v6) = sub_144C422D0(v4 + 0x2590, a2);
  if ( *(_QWORD *)(v4 + 0x2598) )
  {
    if ( !Handle::IsValid((_QWORD *)(v4 + 0x1C0)) )
    {
      v74 = 0x97000000E0LL;
      v123 = (__int64)&v74;
      v124[0] = &v75;
      v6 = invokeGlobalCallbackAndMaskStatusBits(
             3,
             (__int64)&v123,
             (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
             "CEntityComponentCommodityUIProvider not linked to an EntityComponentShop");
      v12 = v6;
      if ( (v6 & 0xFFFFF) != 0 )
      {
        ThreadLogContextSlot_2 = getThreadLogContextSlot();
        v123 = (__int64)&v74;
        v124[0] = &v75;
        v74 = 0x97000000E0LL;
        v88 = 0;
        LOBYTE(v6) = sub_1403515F0(
                       3u,
                       &v123,
                       "CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
                       "CEntityComponentCommodityUIProvider not linked to an EntityComponentShop",
                       1,
                       v12,
                       &v88,
                       0,
                       (__int64)ThreadLogContextSlot_2);
      }
      return v6;
    }
    v14 = (__int64 *)(v4 + 0x14F0);
    v15 = *(_QWORD *)(v4 + 0x2598) + 1LL;
    if ( (*(_QWORD *)(v4 + 0x1500) - *(_QWORD *)(v4 + 0x14F0)) / 0x298LL != v15 )
    {
      v84[0] = v4 + 0x1490;
      sub_144DED290(v4 + 0x1490);
      if ( v15 > (*(_QWORD *)(v4 + 0x1500) - *(_QWORD *)(v4 + 0x14F0)) / 0x298LL )
      {
        if ( v15 > 0x62B2E43DAFCEA6LL )
          unknown_libname_10();
        allocSize = 0x298 * v15;
        v17 = (*(_QWORD *)(v4 + 0x14F8) - *v14) / 0x298;
        if ( 0x298 * v15 < 0x1000 )
        {
          if ( allocSize )
            v19 = allocWithProfilerInfo_w(allocSize);
          else
            v19 = 0;
        }
        else
        {
          if ( allocSize + 0x27 < allocSize )
            sub_1402E1170();
          v18 = allocWithProfilerInfo_w(allocSize + 0x27);
          if ( !v18 )
            invalid_parameter_noinfo_noreturn();
          v19 = (v18 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL;
          *(_QWORD *)(v19 - 8) = v18;
        }
        v20 = v14[1];
        v21 = v19;
        for ( i = *v14; i != v20; i += 0x298 )
        {
          sub_144C34560(v21, i);
          v21 += 0x298LL;
        }
        sub_144E082C0(v14, v19, v17, v15);
        v4 = v80;
      }
      sub_1403302D0(v4 + 0x1490, 0);
      sub_144C41A80(v84);
    }
    sub_144C34890(v160);
    v23 = 0;
    v84[0] = 0;
    sub_144C34890(v178);
    v182 = 0;
    v24 = sub_144D1CDC0();
    v25 = (const void **)sub_14035F010(&v80, (unsigned __int8 **)(v24 + 0x1C8));
    v26 = v25;
    if ( !v180 || sub_14037F680((unsigned __int16 **)v181, v25) )
    {
      sub_140378020(v181, v26);
      v180 = 1;
      sub_1403302D0((__int64)v179, 0);
    }
    sub_140370D10(&v80);
    v27 = (_LocaleUpdate *)(v4 + 0x1490);
    sub_144E16460((_LocaleUpdate *)(v4 + 0x1490));
    for ( j = **(__int64 ***)(v4 + 0x2590); !*((_BYTE *)j + 0x19); v23 = v84[0] )
    {
      if ( *((_DWORD *)j + 0xC) == 1 )
      {
        if ( *(_BYTE *)(sub_1403335B0(*(_QWORD *)(v4 + 0x1C0) & 0xFFFFFFFFFFFFLL) + 0x62) )
        {
          if ( v23 )
          {
            sub_144C1A1E0(*(_QWORD *)(v4 + 0x14F0) + 0x210LL + 0x298LL * v23, v103, j + 4, j + 5);
          }
          else
          {
            v84[0] = (*(_QWORD *)(v4 + 0x14F8) - *(_QWORD *)(v4 + 0x14F0)) / 0x298LL;
            sub_14035B5F0(&v74);
            (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)qword_149B4FD30 + 0x58LL))(
              qword_149B4FD30,
              *(_QWORD *)(v4 + 0x2880),
              &v74);
            sub_144C34890(v125);
            if ( !v127 || sub_14037F680((unsigned __int16 **)&v128, &v74) )
            {
              sub_140378020(&v128, (const void **)&v74);
              v127 = 1;
              sub_1403302D0((__int64)v126, 0);
            }
            sub_144C1A1E0(v147, v121, j + 4, j + 5);
            v67 = j[4];
            n2 = 1;
            v68 = (__int128 *)operator"" _l(v122, v67, 0);
            v69 = *((double *)j + 9);
            v138 = *v68;
            v140 = *(_OWORD *)(j + 7);
            n0x80 = 0x80;
            v141 = v69;
            if ( !v136 || v137 )
            {
              v137 = 0;
              v136 = 1;
              sub_1403302D0((__int64)v135, 0);
            }
            v148 = 0;
            if ( !v133 || v134 != 1 )
            {
              v134 = 1;
              v133 = 1;
              sub_1403302D0((__int64)v132, 0);
            }
            if ( !v130 || v131 != 1 )
            {
              v131 = 1;
              v130 = 1;
              sub_1403302D0((__int64)v129, 0);
            }
            sub_144E16460(v27);
            sub_144C3FE10(v125);
            sub_140370D10(&v74);
          }
        }
        else
        {
          v100[0] = 0xE0;
          v110[0] = v100;
          v100[1] = 0x97;
          v110[1] = &v101;
          v65 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)v110,
                  (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
                  "Player Inventory included in m_CommodityLocationInfo despite not being allowed!");
          if ( (v65 & 0xFFFFF) != 0 )
          {
            ThreadLogContextSlot_3 = getThreadLogContextSlot();
            *(_QWORD *)&v88 = &v80;
            *((_QWORD *)&v88 + 1) = &v81;
            v80 = 0x97000000E0LL;
            v102 = 0;
            sub_1403515F0(
              3u,
              (__int64 *)&v88,
              "CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
              "Player Inventory included in m_CommodityLocationInfo despite not being allowed!",
              1,
              v65,
              &v102,
              0,
              (__int64)ThreadLogContextSlot_3);
          }
        }
        goto LABEL_79;
      }
      if ( *((_DWORD *)j + 0xC) != 2 )
      {
        if ( *((_DWORD *)j + 0xC) == 3 )
        {
          sub_14035B3E0(&v92);
          v31 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FC78 + 0xA0LL))(qword_149B4FC78);
          v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 0x1D0LL))(v31);
          (*(void (__fastcall **)(__int64, _QWORD, unsigned __int8 **))(*(_QWORD *)v32 + 0xD0LL))(
            v32,
            *(unsigned int *)((*(_QWORD *)(v4 + 0x1C0) & 0xFFFFFFFFFFFFLL) + 0x408),
            &v92);
          v33 = (const void **)sub_14035F010(&v75, &v92);
          v34 = v33;
          if ( !v162 || sub_14037F680((unsigned __int16 **)&v163, v33) )
          {
            sub_140378020(&v163, v34);
            v162 = 1;
            sub_1403302D0((__int64)v161, 0);
          }
          sub_140370D10(&v75);
          n3 = 3;
          v173 = *(_OWORD *)operator"" _l(v119, j[4], *((unsigned int *)j + 0xB));
          v174 = *(_OWORD *)(j + 7);
          v175 = j[9];
          if ( !v168 || v169 != 1 )
          {
            v169 = 1;
            v168 = 1;
            sub_1403302D0((__int64)v167, 0);
          }
          if ( !v165 || v166 != 1 )
          {
            v166 = 1;
            v165 = 1;
            sub_1403302D0((__int64)v164, 0);
          }
          if ( !v171 || v172 )
          {
            v172 = 0;
            v171 = 1;
            sub_1403302D0((__int64)v170, 0);
          }
          v177 = 0;
          sub_140370D10(&v92);
        }
        else
        {
          v90[0] = 0xE0;
          v111[0] = v90;
          v90[1] = 0x97;
          v111[1] = v91;
          v29 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)v111,
                  (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
                  "Invalid ECommoditySourceType[$$]");
          if ( (v29 & 0xFFFFF) != 0 )
          {
            v86 = (char *)sub_14052EB40(*((int *)j + 0xC), &qword_149A41EE0, 5u);
            v85 = 0;
            v87 = 0;
            ThreadLogContextSlot_4 = getThreadLogContextSlot();
            v91[0] = 0xE0;
            v112[0] = (__int64)v91;
            v91[1] = 0x97;
            v112[1] = (__int64)&v92;
            v116 = 0;
            sub_140444D10(
              3u,
              v112,
              "CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
              "Invalid ECommoditySourceType[$$]",
              1,
              v29,
              &v116,
              0,
              (__int64)ThreadLogContextSlot_4,
              &v85);
            sub_1402A3D30(v87);
          }
        }
        goto LABEL_79;
      }
      v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)gEnv + 0xC0LL))(gEnv);
      v36 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v35 + 0x10LL))(v35, *((unsigned int *)j + 0xA));
      v37 = v36;
      if ( !v36 )
      {
        v93[0] = 0xE0;
        v113[0] = v93;
        v93[1] = 0x97;
        v113[1] = v94;
        v38 = invokeGlobalCallbackAndMaskStatusBits(
                2,
                (__int64)v113,
                (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
                "CEntityComponentCommodityUIProvider class CRC [$$] not found!");
        if ( (v38 & 0xFFFFF) != 0 )
        {
          v114[1] = *((unsigned int *)j + 0xA);
          v114[0] = 0;
          ThreadLogContextSlot_5 = getThreadLogContextSlot();
          v94[0] = 0xE0;
          v105[0] = v94;
          v94[1] = 0x97;
          v105[1] = v95;
          v117 = 0;
          sub_140C5DF50(
            2,
            (__int64)v105,
            "CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
            (__int64)"CEntityComponentCommodityUIProvider class CRC [$$] not found!",
            1,
            v38,
            &v117,
            0,
            (__int64)ThreadLogContextSlot_5,
            v114);
        }
        goto LABEL_79;
      }
      v40 = sub_1464E7E40(qword_149E7E438, v36);
      if ( v40 )
      {
        if ( *(_BYTE *)(sub_1403335B0(*(_QWORD *)(v4 + 0x1C0) & 0xFFFFFFFFFFFFLL) + 0x64) )
        {
          sub_144C34890(v125);
          v57 = (const void **)sub_14035F010(&v123, (unsigned __int8 **)(v40 + 0x70));
          v58 = v57;
          if ( !v127 || sub_14037F680((unsigned __int16 **)&v128, v57) )
          {
            sub_140378020(&v128, v58);
            v127 = 1;
            sub_1403302D0((__int64)v126, 0);
          }
          sub_140370D10(&v123);
          v59 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x18LL))(v37);
          CreateStringObjectFromString(&v99, v59);
          if ( !v143 || (unsigned int)sub_1403E4780(&v144, &v99) )
          {
            copyStringStructure((char **)&v144, (char **)&v99);
            v143 = 1;
            sub_1403302D0((__int64)v142, 0);
          }
          sub_140370D10(&v99);
          v138 = *(_OWORD *)operator"" _l(v120, j[4], *((unsigned int *)j + 0xB));
          v60 = (__int128 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v37 + 0x10LL))(v37, v150);
          v61 = *((double *)j + 9);
          v139 = *v60;
          v140 = *(_OWORD *)(j + 7);
          n2 = 2;
          n0x80 = 0x81;
          v141 = v61;
          if ( !v130 || v131 != 1 )
          {
            v131 = 1;
            v130 = 1;
            sub_1403302D0((__int64)v129, 0);
          }
          if ( n0xFFFF_68 == (__int16)0xFFFF )
            n0xFFFF_68 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                            + 0x10LL))(
                                     qword_149B4FC88,
                                     v89,
                                     "EntityComponentCargoController");
          v62 = sub_143B72360(v37);
          if ( v62 && *(_BYTE *)(v62 + 0x38) )
          {
            if ( !v133 || v134 != 1 )
            {
              v134 = 1;
              v133 = 1;
              sub_1403302D0((__int64)v132, 0);
            }
            if ( !v136 || v137 )
            {
              v137 = 0;
              v136 = 1;
              sub_1403302D0((__int64)v135, 0);
            }
            v148 = 0;
          }
          else
          {
            n2_1 = *((_DWORD *)j + 0xB);
            v64 = n2_1 == 2;
            if ( !v136 || v137 != v64 )
            {
              v137 = n2_1 == 2;
              v136 = 1;
              sub_1403302D0((__int64)v135, 0);
            }
            v148 = (n2_1 == 2) + 1;
            if ( !v133 || v134 != v64 )
            {
              v134 = n2_1 == 2;
              v133 = 1;
              sub_1403302D0((__int64)v132, 0);
            }
          }
          sub_144E16460(v27);
          sub_144C3FE10(v125);
          goto LABEL_79;
        }
        v97[0] = 0xE0;
        v108[0] = v97;
        v97[1] = 0x97;
        v108[1] = v98;
        v51 = invokeGlobalCallbackAndMaskStatusBits(
                3,
                (__int64)v108,
                (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
                "Vehicle Inventory included in m_CommodityLocationInfo despite not being allowed! className[$$]");
        if ( (v51 & 0xFFFFF) == 0 )
          goto LABEL_78;
        v52 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v37 + 0x10LL))(v37, v151);
        v53 = sub_1402C4680((__int64)v156, v52);
        sub_1403E0AA0(&v83);
        Size = *(_QWORD *)v53;
        if ( *(_QWORD *)v53 )
        {
          sub_1403DE0C0(&v83, *(_QWORD *)v53);
          sub_1403E1FA0(v83, *(const void **)(v53 + 0x10), Size);
        }
        v86 = v83;
        v55 = *(_QWORD *)v37;
        v85 = 0;
        v87 = 0;
        v78 = (char *)(*(__int64 (__fastcall **)(__int64))(v55 + 0x18))(v37);
        v77 = 0;
        v79 = 0;
        ThreadLogContextSlot_6 = getThreadLogContextSlot();
        v98[0] = 0xE0;
        v109[0] = v98;
        v98[1] = 0x97;
        v109[1] = &v99;
        v115 = 0;
        sub_14164C630(
          3,
          (unsigned int)v109,
          (unsigned int)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
          (unsigned int)"Vehicle Inventory included in m_CommodityLocationInfo despite not being allowed! className[$$]",
          1,
          v51,
          (__int64)&v115,
          0,
          (__int64)ThreadLogContextSlot_6,
          (__int64)&v77,
          (__int64)&v85);
        sub_1402A3D30(v79);
        sub_1402A3D30(v87);
        sub_140370D10(&v83);
        v47 = v158;
        if ( v158 == &v159 )
          goto LABEL_78;
        v48 = 0xFFFFFFFFFFFFFFFFuLL - v157;
      }
      else
      {
        v95[0] = 0xE0;
        v106[0] = v95;
        v95[1] = 0x97;
        v106[1] = v96;
        v41 = invokeGlobalCallbackAndMaskStatusBits(
                3,
                (__int64)v106,
                (__int64)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
                "CEntityComponentCommodityUIProvider class missing definition! className[$$] classGUID[$$]");
        if ( (v41 & 0xFFFFF) == 0 )
          goto LABEL_78;
        v42 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v37 + 0x10LL))(v37, v149);
        v43 = sub_1402C4680((__int64)v152, v42);
        sub_1403E0AA0(&v82);
        Size_1 = *(_QWORD *)v43;
        if ( *(_QWORD *)v43 )
        {
          sub_1403DE0C0(&v82, *(_QWORD *)v43);
          sub_1403E1FA0(v82, *(const void **)(v43 + 0x10), Size_1);
        }
        v78 = v82;
        v45 = *(_QWORD *)v37;
        v77 = 0;
        v79 = 0;
        v86 = (char *)(*(__int64 (__fastcall **)(__int64))(v45 + 0x18))(v37);
        v85 = 0;
        v87 = 0;
        ThreadLogContextSlot_7 = getThreadLogContextSlot();
        v96[0] = 0xE0;
        v107[0] = v96;
        v96[1] = 0x97;
        v107[1] = v97;
        v118 = 0;
        sub_14164C630(
          3,
          (unsigned int)v107,
          (unsigned int)"CEntityComponentCommodityUIProvider::RmToken_CargoLocationDataResponse",
          (unsigned int)"CEntityComponentCommodityUIProvider class missing definition! className[$$] classGUID[$$]",
          1,
          v41,
          (__int64)&v118,
          0,
          (__int64)ThreadLogContextSlot_7,
          (__int64)&v85,
          (__int64)&v77);
        sub_1402A3D30(v87);
        sub_1402A3D30(v79);
        sub_140370D10(&v82);
        v47 = v154;
        if ( v154 == &v155 )
          goto LABEL_78;
        v48 = 0xFFFFFFFFFFFFFFFFuLL - v153;
      }
      qword_149B3AD38 += v48;
      sub_147605980(v47);
LABEL_78:
      v27 = (_LocaleUpdate *)(v4 + 0x1490);
LABEL_79:
      v49 = (__int64 **)j[2];
      if ( *((_BYTE *)v49 + 0x19) )
      {
        for ( k = (__int64 *)j[1]; !*((_BYTE *)k + 0x19); k = (__int64 *)k[1] )
        {
          if ( j != (__int64 *)k[2] )
            break;
          j = k;
        }
        j = k;
      }
      else
      {
        v70 = *v49;
        for ( j = (__int64 *)j[2]; !*((_BYTE *)v70 + 0x19); v70 = (__int64 *)*v70 )
          j = v70;
      }
    }
    sub_144D03A10(v4 + 0x1490);
    v71 = *(_QWORD *)(v4 + 0x14D8);
    v72 = *(_QWORD *)(v4 + 0x14D0);
    *(_QWORD *)&v102 = v4 + 0x1490;
    sub_144BD4E10(v72, v71, (v71 - v72) >> 3, &v102);
    sub_1403302D0(v4 + 0x1490, 0);
    sub_144E16460(v27);
    if ( *(_QWORD *)(v4 + 0x15C8) == 0xFFFFFFFFFFFFFFFFuLL )
    {
      if ( !*(_BYTE *)(v4 + 0x15A8) || *(_QWORD *)(v4 + 0x15C8) )
      {
        *(_QWORD *)(v4 + 0x15C8) = 0;
        *(_BYTE *)(v4 + 0x15A8) = 1;
        sub_1403302D0(v4 + 0x1580, 0);
      }
      if ( !*(_BYTE *)(v4 + 0x2340) || *(_BYTE *)(v4 + 0x2359) != 1 )
      {
        *(_BYTE *)(v4 + 0x2359) = 1;
        *(_BYTE *)(v4 + 0x2340) = 1;
        sub_1403302D0(v4 + 0x2318, 0);
      }
      if ( !*(_BYTE *)(v4 + 0x1A48) || *(_BYTE *)(v4 + 0x1A61) )
      {
        *(_BYTE *)(v4 + 0x1A61) = 0;
        *(_BYTE *)(v4 + 0x1A48) = 1;
        sub_1403302D0(v4 + 0x1A20, 0);
      }
    }
    sub_144CD7110(v4);
    sub_144C3FE10(v178);
    LOBYTE(v6) = sub_144C3FE10(v160);
  }
  return v6;
}

// --- End Function: sub_144DC87D0 (0x144DC87D0) ---

// --- Function: sub_144DCA790 (0x144DCA790) ---
void __fastcall sub_144DCA790(__int64 a1, __int64 a2, unsigned __int8 a3, int a4)
{
  __int64 v4; // r12
  __int64 v7; // r15
  int v8; // edi
  __int64 *ThreadLogContextSlot_4; // rax
  int v10; // r14d
  __int64 v11; // rcx
  __int64 *ThreadLogContextSlot_3; // rax
  __int64 v13; // r14
  int v14; // ebx
  __int64 *ThreadLogContextSlot_2; // rax
  int v16; // r12d
  __int64 v17; // rax
  __int64 *ThreadLogContextSlot; // rax
  unsigned __int8 **v19; // rax
  const void **v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  int v23; // r14d
  __int64 v24; // rax
  __int64 *ThreadLogContextSlot_1; // rax
  __int64 v26; // [rsp+60h] [rbp-A0h] BYREF
  __int128 v27; // [rsp+68h] [rbp-98h] BYREF
  __int64 v28; // [rsp+78h] [rbp-88h] BYREF
  __int64 v29; // [rsp+80h] [rbp-80h]
  const void *v30; // [rsp+88h] [rbp-78h]
  __int64 v31; // [rsp+90h] [rbp-70h] BYREF
  __int64 v32; // [rsp+98h] [rbp-68h]
  const void *v33; // [rsp+A0h] [rbp-60h]
  __int128 v34; // [rsp+A8h] [rbp-58h] BYREF
  const void *v35; // [rsp+B8h] [rbp-48h]
  __int64 v36; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v37; // [rsp+C8h] [rbp-38h]
  char v38; // [rsp+D0h] [rbp-30h]
  __int64 v39; // [rsp+D8h] [rbp-28h] BYREF
  __int128 *v40; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v41; // [rsp+E8h] [rbp-18h] BYREF
  int n0x1D; // [rsp+F0h] [rbp-10h]
  _BYTE v43[4]; // [rsp+F4h] [rbp-Ch] BYREF

  v4 = a4;
  LODWORD(v26) = a4;
  v7 = a3;
  if ( sub_144CCC580(*(_QWORD *)(a1 + 8), "CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse") )
  {
    if ( !*(_BYTE *)(a1 + 0x22F8) || *(_BYTE *)(a1 + 0x2311) )
    {
      *(_BYTE *)(a1 + 0x2311) = 0;
      *(_BYTE *)(a1 + 0x22F8) = 1;
      sub_1403302D0(a1 + 0x22D0, 0);
    }
    if ( *(_DWORD *)(a1 + 0x2868) )
    {
      if ( a2 == *(_QWORD *)(a1 + 0x2880) )
      {
        *(_DWORD *)(a1 + 0x2868) = 1;
        v13 = sub_144D1CEE0();
        if ( v13 )
        {
          if ( n2_172 >= 1 )
          {
            v41 = 0x97000000E0LL;
            v39 = (__int64)&v41;
            v40 = (__int128 *)v43;
            n0x1D = 0x1D;
            v16 = invokeGlobalCallbackAndMaskStatusBits(
                    5,
                    (__int64)&v39,
                    (__int64)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
                    "[Client] Responding to Commodity Trasaction Type [$$] - entity[$$], name[$$]");
            if ( (v16 & 0xFFFFF) != 0 )
            {
              v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL) + 0x70LL))(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFLL);
              v31 = 0;
              v32 = v17;
              v33 = 0;
              sub_1403B0A70((unsigned __int64 *)(a1 + 8), &v41);
              v37 = v41;
              v36 = 0;
              v38 = 0;
              v29 = sub_14052EB40((int)v26, &qword_149927620, 4u);
              v28 = 0;
              v30 = 0;
              ThreadLogContextSlot = getThreadLogContextSlot();
              v39 = 0x97000000E0LL;
              *(_QWORD *)&v27 = &v39;
              *((_QWORD *)&v27 + 1) = (char *)&v40 + 4;
              LODWORD(v40) = 0x1D;
              v34 = 0;
              sub_144BFE510(
                5,
                (unsigned int)&v27,
                (unsigned int)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
                (unsigned int)"[Client] Responding to Commodity Trasaction Type [$$] - entity[$$], name[$$]",
                1,
                v16,
                (__int64)&v34,
                0,
                (__int64)ThreadLogContextSlot,
                (__int64)&v28,
                (__int64)&v36,
                (__int64)&v31);
              sub_1402A3D30(v30);
              sub_1402A3D30(v33);
            }
            LODWORD(v4) = v26;
          }
          v19 = (unsigned __int8 **)sub_144D02D60(v13, &v26, (unsigned __int8)v7);
          v20 = (const void **)sub_14035F010(&v41, v19);
          sub_14030E010(a1 + 0x1DD8, v20);
          sub_140370D10(&v41);
          sub_140370D10(&v26);
          v21 = *(int *)(a1 + 0x2268);
          if ( !*(_BYTE *)(a1 + 0x1E50) || *(_QWORD *)(a1 + 0x1E70) != v21 )
          {
            *(_QWORD *)(a1 + 0x1E70) = v21;
            *(_BYTE *)(a1 + 0x1E50) = 1;
            sub_1403302D0(a1 + 0x1E28, 0);
          }
          v22 = a1 + 0x1E78;
          if ( (_BYTE)v7 )
          {
            if ( !*(_BYTE *)(a1 + 0x1EA0) || *(_QWORD *)(a1 + 0x1EC0) != 2 )
            {
              *(_QWORD *)(a1 + 0x1EC0) = 2;
              *(_BYTE *)(a1 + 0x1EA0) = 1;
              sub_1403302D0(v22, 0);
            }
            v26 = 0x97000000E0LL;
            *(_QWORD *)&v27 = &v26;
            *((_QWORD *)&v27 + 1) = &v27;
            v23 = invokeGlobalCallbackAndMaskStatusBits(
                    3,
                    (__int64)&v27,
                    (__int64)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
                    "Commodity Transaction Response Error - playerId[$$] result[$$] type[$$]");
            if ( (v23 & 0xFFFFF) != 0 )
            {
              v24 = sub_14052EB40((int)v4, &qword_149927620, 4u);
              v28 = 0;
              v29 = v24;
              v30 = 0;
              v32 = sub_14052EB40(v7, &qword_1499F0F10, 0x3Du);
              v31 = 0;
              v33 = 0;
              v36 = 0;
              v37 = a2;
              v38 = 0;
              ThreadLogContextSlot_1 = getThreadLogContextSlot();
              v26 = 0x97000000E0LL;
              *(_QWORD *)&v27 = &v26;
              *((_QWORD *)&v27 + 1) = &v27;
              v34 = 0;
              sub_14163ECD0(
                3,
                (unsigned int)&v27,
                (unsigned int)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
                (unsigned int)"Commodity Transaction Response Error - playerId[$$] result[$$] type[$$]",
                1,
                v23,
                (__int64)&v34,
                0,
                (__int64)ThreadLogContextSlot_1,
                (__int64)&v36,
                (__int64)&v31,
                (__int64)&v28);
              sub_1402A3D30(v33);
              sub_1402A3D30(v30);
            }
          }
          else
          {
            if ( !*(_BYTE *)(a1 + 0x1EA0) || *(_QWORD *)(a1 + 0x1EC0) != 1 )
            {
              *(_QWORD *)(a1 + 0x1EC0) = 1;
              *(_BYTE *)(a1 + 0x1EA0) = 1;
              sub_1403302D0(v22, 0);
            }
            *(_QWORD *)(a1 + 0x21F8) = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FC40
                                                                                             + 0x38LL))(
                                                    qword_149B4FC40,
                                                    0);
            sub_14153FC40(a1 + 0x2038, a1 + 0x1FF0);
            sub_1403A58C0(a1, 1u);
          }
          sub_144D5B060(a1);
          sub_144D59080(a1);
          sub_144CD6800(a1);
          if ( !*(_BYTE *)(a1 + 0x1B40) || *(_QWORD *)(a1 + 0x1B60) != 3 )
          {
            *(_QWORD *)(a1 + 0x1B60) = 3;
            *(_BYTE *)(a1 + 0x1B40) = 1;
            sub_1403302D0(a1 + 0x1B18, 0);
          }
        }
        else
        {
          v26 = 0x97000000E0LL;
          v39 = (__int64)&v26;
          v40 = &v27;
          v14 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)&v39,
                  (__int64)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
                  "SGlobalShopTerminalParams No longer valid");
          if ( (v14 & 0xFFFFF) != 0 )
          {
            ThreadLogContextSlot_2 = getThreadLogContextSlot();
            v39 = (__int64)&v26;
            v40 = &v27;
            v26 = 0x97000000E0LL;
            v27 = 0;
            sub_1403515F0(
              3u,
              &v39,
              "CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
              "SGlobalShopTerminalParams No longer valid",
              1,
              v14,
              &v27,
              0,
              (__int64)ThreadLogContextSlot_2);
          }
        }
      }
      else
      {
        v26 = 0x97000000E0LL;
        v39 = (__int64)&v26;
        v40 = &v27;
        v10 = invokeGlobalCallbackAndMaskStatusBits(
                4,
                (__int64)&v39,
                (__int64)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
                "playerId Mismatch! response playerId[$$]  client playerId[$$]");
        if ( (v10 & 0xFFFFF) != 0 )
        {
          v11 = *(_QWORD *)(a1 + 0x2880);
          v31 = 0;
          v32 = v11;
          LOBYTE(v33) = 0;
          v28 = 0;
          LOBYTE(v30) = 0;
          v29 = a2;
          ThreadLogContextSlot_3 = getThreadLogContextSlot();
          v26 = 0x97000000E0LL;
          v39 = (__int64)&v26;
          v40 = &v27;
          v27 = 0;
          sub_14163C590(
            4,
            (unsigned int)&v39,
            (unsigned int)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
            (unsigned int)"playerId Mismatch! response playerId[$$]  client playerId[$$]",
            1,
            v10,
            (__int64)&v27,
            0,
            (__int64)ThreadLogContextSlot_3,
            (__int64)&v28,
            (__int64)&v31);
        }
      }
    }
    else if ( n2_172 >= 1 )
    {
      v41 = 0x97000000E0LL;
      v39 = (__int64)&v41;
      v40 = (__int128 *)v43;
      n0x1D = 0x1D;
      v8 = invokeGlobalCallbackAndMaskStatusBits(
             5,
             (__int64)&v39,
             (__int64)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
             "Kiosk was closed upon CommodityTransactionResponse! playerId[$$] result[$$] Trasaction Type[$$]");
      if ( (v8 & 0xFFFFF) != 0 )
      {
        v29 = sub_14052EB40(v4, &qword_149927620, 4u);
        v28 = 0;
        v30 = 0;
        *((_QWORD *)&v34 + 1) = sub_14052EB40(v7, &qword_1499F0F10, 0x3Du);
        *(_QWORD *)&v34 = 0;
        v35 = 0;
        v31 = 0;
        v32 = a2;
        LOBYTE(v33) = 0;
        ThreadLogContextSlot_4 = getThreadLogContextSlot();
        v41 = 0x97000000E0LL;
        v39 = (__int64)&v41;
        v40 = (__int128 *)v43;
        n0x1D = 0x1D;
        v27 = 0;
        sub_14163ECD0(
          5,
          (unsigned int)&v39,
          (unsigned int)"CEntityComponentCommodityUIProvider::RmToken_CommodityTransactionResponse",
          (unsigned int)"Kiosk was closed upon CommodityTransactionResponse! playerId[$$] result[$$] Trasaction Type[$$]",
          1,
          v8,
          (__int64)&v27,
          0,
          (__int64)ThreadLogContextSlot_4,
          (__int64)&v31,
          (__int64)&v34,
          (__int64)&v28);
        sub_1402A3D30(v35);
        sub_1402A3D30(v30);
      }
    }
  }
}

// --- End Function: sub_144DCA790 (0x144DCA790) ---

// --- Function: sub_144DED0D0 (0x144DED0D0) ---
char __fastcall sub_144DED0D0(__int64 a1)
{
  __int64 v1; // rsi
  char result; // al
  __int64 v4; // rdi
  __int64 i; // rbx
  __int64 v6; // rax

  v1 = a1 + 8;
  result = sub_14030ECC0(a1 + 8);
  if ( result )
  {
    v4 = *(_QWORD *)(a1 + 0x68);
    for ( i = *(_QWORD *)(a1 + 0x60); i != v4; i += 0xD20 )
    {
      v6 = sub_14030ED10(v1);
      result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x10LL))(v6, i);
    }
  }
  return result;
}

// --- End Function: sub_144DED0D0 (0x144DED0D0) ---

// --- Function: sub_144E07F40 (0x144E07F40) ---
__int64 __fastcall sub_144E07F40(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rsi
  _QWORD *v10; // r8
  __int64 result; // rax

  v4 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(_QWORD **)(a1 + 8); v4 != i; v4 += 0x1A4 )
      (*(void (__fastcall **)(_QWORD *, _QWORD))*v4)(v4, 0);
    v10 = *(_QWORD **)a1;
    if ( (unsigned __int64)(0xD20 * ((*(_QWORD *)(a1 + 0x10) - *(_QWORD *)a1) / 0xD20LL)) >= 0x1000 )
    {
      if ( (unsigned __int64)v10 - v10[0xFFFFFFFF] - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = (_QWORD *)v10[0xFFFFFFFF];
    }
    sub_1402A3D30(v10);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 0xD20 * a3;
  result = a2 + 0xD20 * a4;
  *(_QWORD *)(a1 + 0x10) = result;
  return result;
}

// --- End Function: sub_144E07F40 (0x144E07F40) ---

// --- Function: sub_144E0F950 (0x144E0F950) ---
__int64 __fastcall sub_144E0F950(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  void (__fastcall ***v4)(_QWORD, _QWORD); // rbx
  void (__fastcall ***v5)(_QWORD, _QWORD); // rsi

  result = *(_QWORD *)(a1 + 0x68);
  if ( *(_QWORD *)(a1 + 0x60) != result )
  {
    if ( *(_BYTE *)(a1 + 0x58) )
    {
      v3 = *(_QWORD *)(a1 + 0x40);
      if ( v3 != *(_QWORD *)(a1 + 0x48) )
        *(_QWORD *)(a1 + 0x48) = v3;
    }
    v4 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 0x60);
    v5 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 + 0x68);
    if ( v4 != v5 )
    {
      do
      {
        (**v4)(v4, 0);
        v4 += 0x1A4;
      }
      while ( v4 != v5 );
      *(_QWORD *)(a1 + 0x68) = *(_QWORD *)(a1 + 0x60);
    }
    return sub_1403302D0(a1, 0);
  }
  return result;
}

// --- End Function: sub_144E0F950 (0x144E0F950) ---

// --- Function: sub_144E14AD0 (0x144E14AD0) ---
__int64 __fastcall sub_144E14AD0(_LocaleUpdate *this, __int64 a2)
{
  _BYTE *v4; // rdx
  _QWORD *v5; // rcx
  __int64 this_2; // rax
  __int128 v7; // rax
  _LocaleUpdate *this_1; // [rsp+30h] [rbp+8h] BYREF

  if ( *((_BYTE *)this + 0x58) )
  {
    v4 = (_BYTE *)*((_QWORD *)this + 9);
    v5 = (_QWORD *)((char *)this + 0x40);
    this_2 = (__int64)&v4[-*v5] >> 3;
    this_1 = (_LocaleUpdate *)this_2;
    if ( v4 == (_BYTE *)v5[2] )
    {
      sub_1402A6B30((__int64)v5, v4, &this_1);
    }
    else
    {
      *(_QWORD *)v4 = this_2;
      v5[1] += 8LL;
    }
  }
  if ( (*((_QWORD *)this + 0xD) - *((_QWORD *)this + 0xC)) / 0x180LL >= (unsigned __int64)((*((_QWORD *)this + 0xE)
                                                                                          - *((_QWORD *)this + 0xC))
                                                                                         / 0x180LL) )
  {
    this_1 = this;
    sub_142E78260((__int64)this);
    if ( *((_QWORD *)this + 0xD) == *((_QWORD *)this + 0xE) )
    {
      sub_144BC41F0((__int64 *)this + 0xC, *((_QWORD *)this + 0xD), a2);
    }
    else
    {
      sub_144C2CBA0(*((_QWORD *)this + 0xD), a2);
      *((_QWORD *)this + 0xD) += 0x180LL;
    }
    sub_140323750((__int64 *)(*((_QWORD *)this + 0xD) - 0x180LL), 1);
    sub_142DD7370((__int64 *)&this_1);
  }
  else
  {
    if ( *((_QWORD *)this + 0xD) == *((_QWORD *)this + 0xE) )
    {
      sub_144BC41F0((__int64 *)this + 0xC, *((_QWORD *)this + 0xD), a2);
    }
    else
    {
      sub_144C2CBA0(*((_QWORD *)this + 0xD), a2);
      *((_QWORD *)this + 0xD) += 0x180LL;
    }
    sub_140323750((__int64 *)(*((_QWORD *)this + 0xD) - 0x180LL), 1);
    v7 = (__int64)(*((_QWORD *)this + 0xD) - *((_QWORD *)this + 0xC)) * (__int128)0x2AAAAAAAAAAAAAABLL;
    sub_1415DBB70(
      this,
      *((_QWORD *)this + 0xD) - 0x180LL,
      (*((__int64 *)&v7 + 1) >> 6) - 1 + (*((_QWORD *)&v7 + 1) >> 0x3F));
  }
  return sub_1403302D0((__int64)this, 0);
}

// --- End Function: sub_144E14AD0 (0x144E14AD0) ---

// --- Function: sub_144E14C60 (0x144E14C60) ---
__int64 __fastcall sub_144E14C60(_LocaleUpdate *this, __int64 *a2)
{
  _BYTE *v4; // rdx
  _QWORD *v5; // rcx
  __int64 this_2; // rax
  __int128 v7; // rax
  _LocaleUpdate *this_1; // [rsp+30h] [rbp+8h] BYREF

  if ( *((_BYTE *)this + 0x58) )
  {
    v4 = (_BYTE *)*((_QWORD *)this + 9);
    v5 = (_QWORD *)((char *)this + 0x40);
    this_2 = (__int64)&v4[-*v5] >> 3;
    this_1 = (_LocaleUpdate *)this_2;
    if ( v4 == (_BYTE *)v5[2] )
    {
      sub_1402A6B30((__int64)v5, v4, &this_1);
    }
    else
    {
      *(_QWORD *)v4 = this_2;
      v5[1] += 8LL;
    }
  }
  sub_1403319D0(a2);
  if ( (*((_QWORD *)this + 0xD) - *((_QWORD *)this + 0xC)) / 0xD20LL >= (unsigned __int64)((*((_QWORD *)this + 0xE)
                                                                                          - *((_QWORD *)this + 0xC))
                                                                                         / 0xD20LL) )
  {
    this_1 = this;
    sub_144DED0D0((__int64)this);
    if ( *((_QWORD *)this + 0xD) == *((_QWORD *)this + 0xE) )
    {
      sub_144BC7F30((__int64 *)this + 0xC, *((_QWORD *)this + 0xD), (__int64)a2);
    }
    else
    {
      sub_144C2CF00(*((_QWORD *)this + 0xD), (__int64)a2);
      *((_QWORD *)this + 0xD) += 0xD20LL;
    }
    sub_144C41280((__int64 *)&this_1);
  }
  else
  {
    if ( *((_QWORD *)this + 0xD) == *((_QWORD *)this + 0xE) )
    {
      sub_144BC7F30((__int64 *)this + 0xC, *((_QWORD *)this + 0xD), (__int64)a2);
    }
    else
    {
      sub_144C2CF00(*((_QWORD *)this + 0xD), (__int64)a2);
      *((_QWORD *)this + 0xD) += 0xD20LL;
    }
    v7 = (__int64)(*((_QWORD *)this + 0xD) - *((_QWORD *)this + 0xC)) * (__int128)0x4E04E04E04E04E05LL;
    sub_1415DBB70(
      this,
      *((_QWORD *)this + 0xD) - 0xD20LL,
      (*((__int64 *)&v7 + 1) >> 0xA) - 1 + (*((_QWORD *)&v7 + 1) >> 0x3F));
  }
  return sub_1403302D0((__int64)this, 0);
}

// --- End Function: sub_144E14C60 (0x144E14C60) ---

// --- Function: sub_1474DA7B0 (0x1474DA7B0) ---
__int64 sub_1474DA7B0()
{
  __int64 result; // rax

  result = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 3672LL);
  if ( result )
    return *(unsigned __int8 *)(result + 1);
  return result;
}

// --- End Function: sub_1474DA7B0 (0x1474DA7B0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_1476030D0 (0x1476030D0) ---
unsigned __int64 __fastcall sub_1476030D0(unsigned __int64 n0xE000_1, unsigned __int64 profilerInfo)
{
  return sub_1476030E0(n0xE000_1, profilerInfo);
}

// --- End Function: sub_1476030D0 (0x1476030D0) ---

// --- Function: sub_1476052F0 (0x1476052F0) ---
double __fastcall sub_1476052F0(unsigned __int64 n0x6400000)
{
  _QWORD pExceptionObject[2]; // [rsp+30h] [rbp-68h] BYREF
  int n26880; // [rsp+40h] [rbp-58h] BYREF
  __int64 v5; // [rsp+44h] [rbp-54h]
  int v6; // [rsp+4Ch] [rbp-4Ch]
  unsigned __int64 v7; // [rsp+50h] [rbp-48h]
  unsigned __int64 v8; // [rsp+58h] [rbp-40h]
  __int64 v9; // [rsp+60h] [rbp-38h]
  __int64 v10; // [rsp+68h] [rbp-30h]

  if ( byte_1517022EC == 1 )
  {
    sub_141848E00(pExceptionObject);
    throw (stdext::bad_alloc *)pExceptionObject;
  }
  byte_149B4FEA4 = 1;
  qword_149B4FEA8 = n0x6400000;
  if ( n0x6400000 > 0x6400000 )
    sub_1475DF210(n0x6400000);
  n26880 = 26880;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 1;
  v7 = __rdtsc();
  qword_149B4B870(
    &n26880,
    &word_1517023A0,
    "OnMemoryAllocationFailure",
    "W:/p4-src/CryEngine/Code/CryEngine/CrySystem/CryMemoryManager.cpp",
    167);
  HIWORD(n26880) = word_1517023A0;
  sub_1475DF210(n0x6400000);
  v8 = __rdtsc();
  return qword_149B4B878(&n26880);
}

// --- End Function: sub_1476052F0 (0x1476052F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: _onexit (0x1480335BC) ---
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)(); // rdx

  if ( Table._first == (_PVFV *)0xFFFFFFFFFFFFFFFFLL )
    v2 = crt_atexit((_PVFV)Func);
  else
    v2 = register_onexit_function(&Table, Func);
  v3 = 0;
  if ( !v2 )
    return Func;
  return v3;
}

// --- End Function: _onexit (0x1480335BC) ---

// --- Function: atexit (0x1480335F8) ---
int __cdecl atexit(void (__cdecl *Func)())
{
  return (onexit((_onexit_t)Func) != 0) - 1;
}

// --- End Function: atexit (0x1480335F8) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6320);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6336);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6320) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 6320);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memcpy (0x14808212B) ---
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}

// --- End Function: memcpy (0x14808212B) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: free_0 (0x1480821F7) ---
// attributes: thunk
void __cdecl free_0(void *Block)
{
  free(Block);
}

// --- End Function: free_0 (0x1480821F7) ---

// --- Function: malloc_0 (0x1480821FD) ---
// attributes: thunk
void *__cdecl malloc_0(size_t Size)
{
  return malloc(Size);
}

// --- End Function: malloc_0 (0x1480821FD) ---

// --- Function: sub_1480BC650 (0x1480BC650) ---
void __fastcall sub_1480BC650()
{
  sub_140370D10(&unk_149B3B2F0);
}

// --- End Function: sub_1480BC650 (0x1480BC650) ---

// --- Function: sub_1480BD370 (0x1480BD370) ---
void __fastcall sub_1480BD370()
{
  if ( *(int *)(qword_149B3E060 - 4) > 0 )
    sub_147605980((const void *)(qword_149B3E060 - 8));
}

// --- End Function: sub_1480BD370 (0x1480BD370) ---

// --- Function: sub_1480BE950 (0x1480BE950) ---
__int64 sub_1480BE950()
{
  __int64 v0; // rax
  __int64 result; // rax

  v0 = NtCurrentTeb_w();
  sub_1402A3D30(*(const void **)(*(_QWORD *)(v0 + 16) + 24LL));
  result = NtCurrentTeb_w();
  *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL) = 0;
  return result;
}

// --- End Function: sub_1480BE950 (0x1480BE950) ---

