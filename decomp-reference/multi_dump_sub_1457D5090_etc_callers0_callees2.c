// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Functions:
//   - 0x1457D5090 (sub_1457D5090)
//   - 0x146F55020 (sub_146F55020)
//   - 0x146F55580 (sub_146F55580)
//   - 0x146F81FE0 (sub_146F81FE0)
//   - 0x146F82930 (sub_146F82930)
//   - 0x146F83220 (sub_146F83220)
// Caller Depth: 0
// Callee/Ref Depth: 2
// Total Functions Found: 126
// ------------------------------------------------------------

// --- Function: identity (0x1402A24F0) ---
// A simple passthrough function that returns its input argument unchanged.
__int64 __fastcall identity(__int64 input_value)
{
  return input_value;
}

// --- End Function: identity (0x1402A24F0) ---

// --- Function: sub_1402A2660 (0x1402A2660) ---
__int64 __fastcall sub_1402A2660(__int64 a1)
{
  return *(_QWORD *)a1;
}

// --- End Function: sub_1402A2660 (0x1402A2660) ---

// --- Function: sub_1402A3D30 (0x1402A3D30) ---
// A wrapper function that forwards its argument to `sub_147605980`, which appears
// to be a memory deallocation routine.
void __fastcall sub_1402A3D30(const void *ptr_to_free)
{
  sub_147605980(ptr_to_free);
}

// --- End Function: sub_1402A3D30 (0x1402A3D30) ---

// --- Function: allocWithProfilerInfo_w (0x1402A3D40) ---
// // A wrapper function for allocWithProfilerInfo that allocates memory // without
// providing specific profiler information. It simply forwards // the allocation
// size to the main allocation function with a null // profiler context. // //
// Parameters: //   allocSize: The size of memory in bytes to allocate. // //
// Returns: //   A pointer to the newly allocated memory block, or nullptr if
// allocation fails.
__int64 __fastcall allocWithProfilerInfo_w(unsigned __int64 allocSize)
{
  return allocWithProfilerInfo(allocSize, 0);
}

// --- End Function: allocWithProfilerInfo_w (0x1402A3D40) ---

// --- Function: sub_1402A6760 (0x1402A6760) ---
const vraudio::AudioBuffer **__fastcall sub_1402A6760(
        std::vector<vraudio::AudioBuffer const *> *this,
        const vraudio::AudioBuffer **const _Whereptr,
        const vraudio::AudioBuffer **<_Val_0>)
{
  __int64 v3; // rbp
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 allocSize; // rsi
  __int64 v13; // rax
  _QWORD *v14; // rbx
  _QWORD *v15; // r14
  void *v16; // rcx
  const vraudio::AudioBuffer **_Whereptr_2; // r8
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  size_t Size; // r8
  const void *v20; // rcx
  const vraudio::AudioBuffer **result; // rax

  v3 = ((__int64)_Whereptr - *(_QWORD *)this) >> 3;
  v5 = (__int64)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3;
  if ( v5 == 0x1FFFFFFFFFFFFFFFLL )
    unknown_libname_10();
  v8 = (__int64)(*((_QWORD *)this + 2) - *(_QWORD *)this) >> 3;
  v9 = v5 + 1;
  v10 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v11 = v5 + 1;
  if ( v10 + v8 >= v9 )
    v11 = v10 + v8;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  allocSize = 8 * v11;
  if ( allocSize < 0x1000 )
  {
    if ( allocSize )
      v14 = (_QWORD *)allocWithProfilerInfo_w(allocSize);
    else
      v14 = 0;
    goto LABEL_13;
  }
  if ( allocSize + 0x27 < allocSize )
LABEL_24:
    sub_1402E1170();
  v13 = allocWithProfilerInfo_w(allocSize + 0x27);
  if ( !v13 )
    goto LABEL_22;
  v14 = (_QWORD *)((v13 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v14[0xFFFFFFFF] = v13;
LABEL_13:
  v15 = &v14[v3];
  *v15 = *<_Val_0>;
  v16 = v14;
  _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)this + 1);
  _Whereptr_1 = *(const vraudio::AudioBuffer ***)this;
  if ( _Whereptr == _Whereptr_2 )
  {
    Size = (char *)_Whereptr_2 - (char *)_Whereptr_1;
  }
  else
  {
    memmove(v14, _Whereptr_1, (char *)_Whereptr - (char *)_Whereptr_1);
    v16 = v15 + 1;
    Size = *((_QWORD *)this + 1) - (_QWORD)_Whereptr;
    _Whereptr_1 = _Whereptr;
  }
  memmove(v16, _Whereptr_1, Size);
  v20 = *(const void **)this;
  if ( *(_QWORD *)this )
  {
    if ( ((*((_QWORD *)this + 2) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_20:
      sub_1402A3D30(v20);
      goto LABEL_21;
    }
    if ( (unsigned __int64)v20 - *((_QWORD *)v20 + 0xFFFFFFFF) - 8 <= 0x1F )
    {
      v20 = (const void *)*((_QWORD *)v20 + 0xFFFFFFFF);
      goto LABEL_20;
    }
LABEL_22:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *(_QWORD *)this = v14;
  result = (const vraudio::AudioBuffer **)&v14[v3];
  *((_QWORD *)this + 1) = &v14[v9];
  *((_QWORD *)this + 2) = &v14[allocSize / 8];
  return result;
}

// --- End Function: sub_1402A6760 (0x1402A6760) ---

// --- Function: sub_1402A9870 (0x1402A9870) ---
const void **__fastcall sub_1402A9870(const void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  char *Size_1; // r15
  __int64 v6; // rbx
  unsigned __int64 n0xF; // rbp
  char *v10; // r14
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 allocSize; // rcx
  __int64 v14; // rax
  _QWORD *v15; // rdi
  char *v16; // r14
  _QWORD *v17; // rbx

  Size_1 = (char *)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - (__int64)Size_1 < a2 )
    unknown_libname_9();
  n0xF = (unsigned __int64)Src[3];
  v10 = &Size_1[a2];
  v11 = (unsigned __int64)&Size_1[a2] | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = n0xF >> 1, n0xF > 0x7FFFFFFFFFFFFFFFLL - (n0xF >> 1)) )
  {
    allocSize = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v12 + n0xF )
      v6 = v12 + n0xF;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 == 0xFFFFFFFFFFFFFFFFuLL )
        v15 = 0;
      else
        v15 = (_QWORD *)allocWithProfilerInfo_w(v6 + 1);
      goto LABEL_15;
    }
    allocSize = v6 + 0x28;
    if ( v6 + 0x28 < (unsigned __int64)(v6 + 1) )
      sub_1402E1170();
  }
  v14 = allocWithProfilerInfo_w(allocSize);
  if ( !v14 )
    goto LABEL_20;
  v15 = (_QWORD *)((v14 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
  v15[0xFFFFFFFF] = v14;
LABEL_15:
  Src[2] = v10;
  v16 = (char *)v15 + (_QWORD)Size_1;
  Src[3] = (const void *)v6;
  if ( n0xF <= 0xF )
  {
    memcpy(v15, Src, (size_t)Size_1);
    memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v15, *Src, (size_t)Size_1);
  memcpy((char *)v15 + (_QWORD)Size_1, a4, Size);
  v16[Size] = 0;
  if ( n0xF + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)v17 - v17[0xFFFFFFFF] - 8 <= 0x1F )
    {
      v17 = (_QWORD *)v17[0xFFFFFFFF];
      goto LABEL_19;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_1402A3D30(v17);
LABEL_22:
  *Src = v15;
  return Src;
}

// --- End Function: sub_1402A9870 (0x1402A9870) ---

// --- Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B4910) ---
std::shared_ptr<vraudio::MixerNode> *__fastcall std::shared_ptr<vraudio::MixerNode>::operator=(
        std::shared_ptr<vraudio::MixerNode> *this,
        std::shared_ptr<vraudio::MixerNode> *_Right)
{
  __int64 v2; // rax
  __int64 v4; // r8
  volatile signed __int32 *v5; // rbx

  v2 = *(_QWORD *)_Right;
  v4 = *((_QWORD *)_Right + 1);
  *(_QWORD *)_Right = 0;
  *((_QWORD *)_Right + 1) = 0;
  v5 = (volatile signed __int32 *)*((_QWORD *)this + 1);
  *(_QWORD *)this = v2;
  *((_QWORD *)this + 1) = v4;
  if ( !v5 )
    return this;
  if ( _InterlockedExchangeAdd(v5 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v5)(v5);
    if ( _InterlockedExchangeAdd(v5 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v5 + 8LL))(v5);
  }
  return this;
}

// --- End Function: ??4?$shared_ptr@VMixerNode@vraudio@@@std@@QEAAAEAV01@$$QEAV01@@Z (0x1402B4910) ---

// --- Function: get_thread_context_ptr (0x1402C6400) ---
// The pointer is obtained by accessing the Thread Local Storage (TLS) array at a
// predefined index (TlsIndex) and adding a constant offset (0x310) to the
// retrieved TLS value. The returned pointer serves as a base address for accessing
// various thread-local fields and data.
__int64 get_thread_context_ptr()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 0x310LL;
}

// --- End Function: get_thread_context_ptr (0x1402C6400) ---

// --- Function: sub_1402D2710 (0x1402D2710) ---
// Acquires a read lock on a read-write lock. It handles recursive read lock
// acquisitions by the same thread by incrementing a recursive count. For non-
// recursive acquisitions, it atomically increments the lock state. If the
// incremented value indicates a pending write lock, it dispatches to a more
// detailed acquisition function, potentially for profiling or contention handling.
double __fastcall sub_1402D2710(__int64 rw_lock_ptr, const char *a2, const char *a3, char a4)
{
  signed __int64 v8; // rdx
  double result; // xmm0_8

  if ( *(_DWORD *)(rw_lock_ptr + 0x10) == *(_DWORD *)(get_thread_context_ptr() + 0x18) )
  {
    ++*(_DWORD *)(rw_lock_ptr + 0x14);
  }
  else
  {
    v8 = _InterlockedIncrement64((volatile signed __int64 *)rw_lock_ptr);
    if ( (v8 & 0x200000) != 0 )
      return rw_lock_acquire_read_lock_dispatch(rw_lock_ptr, v8, a2, a3, a4);
  }
  return result;
}

// --- End Function: sub_1402D2710 (0x1402D2710) ---

// --- Function: rw_lock_release_read_lock (0x1402D2790) ---
// Releases a read lock on a read-write lock. If the current thread is the
// recursive owner, it decrements the recursive count. Otherwise, it atomically
// decrements the main lock state. If the lock state transitions to indicate no
// more readers and pending write locks, it dispatches to a contention handler.
unsigned __int64 __fastcall rw_lock_release_read_lock(__int64 p_rw_lock_state)
{
  unsigned __int64 thread_context_ptr; // rax
  unsigned __int64 lock_state_after_decrement; // rdx

  thread_context_ptr = get_thread_context_ptr();
  if ( *(_DWORD *)(p_rw_lock_state + 0x10) == *(_DWORD *)(thread_context_ptr + 0x18)
    && (thread_context_ptr = *(unsigned int *)(p_rw_lock_state + 0x14), (_DWORD)thread_context_ptr) )
  {
    thread_context_ptr = (unsigned int)(thread_context_ptr - 1);
    *(_DWORD *)(p_rw_lock_state + 0x14) = thread_context_ptr;
  }
  else
  {
    lock_state_after_decrement = _InterlockedDecrement64((volatile signed __int64 *)p_rw_lock_state);
    if ( (lock_state_after_decrement & 0x3FF) == 0 )
    {
      thread_context_ptr = 0xFFFF0000FFC00000uLL;
      if ( (lock_state_after_decrement & 0xFFFF0000FFC00000uLL) != 0 )
        return rw_lock_handle_release_contention((volatile signed __int64 *)p_rw_lock_state, lock_state_after_decrement);
    }
  }
  return thread_context_ptr;
}

// --- End Function: rw_lock_release_read_lock (0x1402D2790) ---

// --- Function: sub_1402DE3A0 (0x1402DE3A0) ---
unsigned __int64 __fastcall sub_1402DE3A0(__int64 a1, const char *a2, const char *a3, char a4)
{
  unsigned __int64 thread_context_ptr; // rax
  int v9; // edi
  __int64 v10; // r8

  thread_context_ptr = get_thread_context_ptr();
  v9 = *(_DWORD *)(thread_context_ptr + 0x18);
  if ( *(_DWORD *)(a1 + 0x10) == v9 )
  {
    ++*(_DWORD *)(a1 + 0x14);
  }
  else
  {
    v10 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    thread_context_ptr = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0x200000, 0);
    if ( thread_context_ptr )
      thread_context_ptr = sub_1403DCD60(a1, thread_context_ptr, v10, a2, a3, a4);
    else
      *(_QWORD *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 0x10) = v9;
  }
  return thread_context_ptr;
}

// --- End Function: sub_1402DE3A0 (0x1402DE3A0) ---

// --- Function: sub_1402DE4A0 (0x1402DE4A0) ---
const ULONG_PTR *__fastcall sub_1402DE4A0(__int64 a1)
{
  int v1; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int64 n0x200000; // rax

  v1 = *(_DWORD *)(a1 + 0x14);
  if ( v1 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v1 - 1);
    *(_DWORD *)(a1 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(a1 + 0x10) = 0xFFFFFFFF;
    n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, 0, 0x200000);
    if ( n0x200000 == 0x200000 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return rw_lock_handle_write_release_contention(a1, n0x200000);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1402DE4A0 (0x1402DE4A0) ---

// --- Function: ?_Decref@_Ref_count_base@std@@QEAAXXZ (0x1402DEFC0) ---
void __fastcall std::_Ref_count_base::_Decref(std::_Ref_count_base *this)
{
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(std::_Ref_count_base *))this)(this);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(std::_Ref_count_base *))(*(_QWORD *)this + 8LL))(this);
  }
}

// --- End Function: ?_Decref@_Ref_count_base@std@@QEAAXXZ (0x1402DEFC0) ---

// --- Function: fprintf (0x1402F73D0) ---
int fprintf(FILE *File, const char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_1402A4380();
  return _stdio_common_vfprintf(*v4, File, Format, 0, va);
}

// --- End Function: fprintf (0x1402F73D0) ---

// --- Function: sub_1402FB100 (0x1402FB100) ---
void *__fastcall sub_1402FB100(_QWORD *a1, const void *a2, size_t Size)
{
  size_t n0x16; // rdi
  void *result; // rax
  unsigned __int64 allocSize; // rax
  __int64 v9; // rax
  _QWORD *v10; // rsi

  n0x16 = 0x7FFFFFFFFFFFFFFFLL;
  if ( Size > 0x7FFFFFFFFFFFFFFFLL )
    unknown_libname_9();
  a1[3] = 0xF;
  if ( Size <= 0xF )
  {
    a1[2] = Size;
    result = memcpy(a1, a2, Size);
    *((_BYTE *)a1 + Size) = 0;
    return result;
  }
  if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    allocSize = 0x8000000000000027uLL;
LABEL_6:
    v9 = allocWithProfilerInfo_w(allocSize);
    if ( !v9 )
      invalid_parameter_noinfo_noreturn();
    v10 = (_QWORD *)((v9 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
    v10[0xFFFFFFFF] = v9;
    goto LABEL_17;
  }
  n0x16 = Size | 0xF;
  if ( (Size | 0xF) < 0x16 )
    n0x16 = 0x16;
  if ( n0x16 + 1 >= 0x1000 )
  {
    allocSize = n0x16 + 0x28;
    if ( n0x16 + 0x28 < n0x16 + 1 )
      sub_1402E1170();
    goto LABEL_6;
  }
  if ( n0x16 == 0xFFFFFFFFFFFFFFFFuLL )
    v10 = 0;
  else
    v10 = (_QWORD *)allocWithProfilerInfo_w(n0x16 + 1);
LABEL_17:
  *a1 = v10;
  a1[2] = Size;
  a1[3] = n0x16;
  result = memcpy(v10, a2, Size);
  *((_BYTE *)v10 + Size) = 0;
  return result;
}

// --- End Function: sub_1402FB100 (0x1402FB100) ---

// --- Function: sub_1402FDEC0 (0x1402FDEC0) ---
__int64 __fastcall sub_1402FDEC0(char *a1, unsigned __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 n0x100; // rax
  unsigned __int64 v7; // r15
  char *v8; // rdi
  __int64 *v9; // r14
  char *v10; // rbp
  char *v11; // rsi
  size_t n8; // r14
  char *v13; // r9
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  char *i; // rcx
  __int64 v17; // rdx
  __int64 v18; // r14
  __int64 v19; // r10
  __int64 v20; // rbp
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 j; // rax
  __int64 v24; // r11
  __int64 v25; // r9
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // rsi
  __int64 *v31; // [rsp+30h] [rbp-38h] BYREF
  char *v32; // [rsp+38h] [rbp-30h]
  unsigned __int64 v33; // [rsp+70h] [rbp+8h] BYREF

  n0x100 = (a2 - (_QWORD)a1) & 0xFFFFFFFFFFFFFFF8uLL;
  v7 = a2;
  v8 = a1;
  if ( n0x100 <= 0x100 )
  {
LABEL_7:
    if ( v8 != (char *)v7 )
    {
      v11 = v8 + 8;
      if ( v8 + 8 != (char *)v7 )
      {
        n8 = 8;
        do
        {
          v13 = v11;
          v14 = *(_QWORD *)v11;
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 8LL);
          if ( *(_QWORD *)(*(_QWORD *)v11 + 8LL) < v15
            || *(_QWORD *)(*(_QWORD *)v11 + 8LL) == v15 && *(_QWORD *)(v14 + 0x50) < *(_QWORD *)(*(_QWORD *)v8 + 0x50LL) )
          {
            n0x100 = (__int64)memmove(v8 + 8, v8, n8);
            *(_QWORD *)v8 = v14;
          }
          else
          {
            for ( i = v11; ; v13 = i )
            {
              v17 = *((_QWORD *)i + 0xFFFFFFFF);
              i += 0xFFFFFFF8;
              n0x100 = *(_QWORD *)(v17 + 8);
              if ( *(_QWORD *)(v14 + 8) >= (unsigned __int64)n0x100 )
              {
                if ( *(_QWORD *)(v14 + 8) != n0x100 )
                  break;
                n0x100 = *(_QWORD *)(v17 + 0x50);
                if ( *(_QWORD *)(v14 + 0x50) >= (unsigned __int64)n0x100 )
                  break;
              }
              *(_QWORD *)v13 = v17;
            }
            *(_QWORD *)v13 = v14;
          }
          v11 += 8;
          n8 += 8LL;
        }
        while ( v11 != (char *)v7 );
      }
    }
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_1402FD7E0(&v31, (__int64 *)v8, v7);
      v9 = v31;
      v10 = v32;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(((char *)v31 - v8) & 0xFFFFFFFFFFFFFFF8uLL) >= (__int64)((v7 - (_QWORD)v32) & 0xFFFFFFFFFFFFFFF8uLL) )
      {
        sub_1402FDEC0(v32, v7, a3, a4);
        v7 = (unsigned __int64)v9;
      }
      else
      {
        sub_1402FDEC0(v8, (unsigned __int64)v31, a3, a4);
        v8 = v10;
      }
      n0x100 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      if ( n0x100 <= 0x100 )
        goto LABEL_7;
    }
    v18 = (__int64)(v7 - (_QWORD)v8) >> 3;
    v19 = (__int64)(v7 - (_QWORD)v8) >> 4;
    if ( v19 > 0 )
    {
      v20 = (v18 - 1) >> 1;
      do
      {
        v21 = *(_QWORD *)&v8[8 * v19-- - 8];
        v22 = v19;
        for ( j = v19; j < v20; v22 = j )
        {
          j = 2 * j + 2;
          v24 = *(_QWORD *)&v8[8 * j];
          v25 = *(_QWORD *)&v8[8 * j - 8];
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 < *(_QWORD *)(v25 + 8)
            || v26 == *(_QWORD *)(v25 + 8) && *(_QWORD *)(v24 + 0x50) < *(_QWORD *)(v25 + 0x50) )
          {
            --j;
          }
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * j];
        }
        if ( j == v20 && (v18 & 1) == 0 )
        {
          *(_QWORD *)&v8[8 * v22] = *(_QWORD *)&v8[8 * v18 - 8];
          v22 = v18 - 1;
        }
        if ( v19 < v22 )
        {
          do
          {
            v27 = (v22 - 1) >> 1;
            v28 = *(_QWORD *)&v8[8 * v27];
            v29 = *(_QWORD *)(v28 + 8);
            if ( v29 >= *(_QWORD *)(v21 + 8)
              && (v29 != *(_QWORD *)(v21 + 8) || *(_QWORD *)(v28 + 0x50) >= *(_QWORD *)(v21 + 0x50)) )
            {
              break;
            }
            *(_QWORD *)&v8[8 * v22] = v28;
            v22 = (v22 - 1) >> 1;
          }
          while ( v19 < v27 );
        }
        *(_QWORD *)&v8[8 * v22] = v21;
      }
      while ( v19 > 0 );
    }
    n0x100 = (v7 - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
    if ( n0x100 >= 0x10 )
    {
      v30 = (unsigned __int64 *)(v7 - 8);
      do
      {
        v33 = *v30;
        *v30 = *(_QWORD *)v8;
        sub_1402FDAA0((__int64)v8, 0, ((char *)v30 - v8) >> 3, &v33);
        v30 += 0xFFFFFFFF;
        n0x100 = ((unsigned __int64)v30 + 8LL - (_QWORD)v8) & 0xFFFFFFFFFFFFFFF8uLL;
      }
      while ( n0x100 >= 0x10 );
    }
  }
  return n0x100;
}

// --- End Function: sub_1402FDEC0 (0x1402FDEC0) ---

// --- Function: sub_1402FF3C0 (0x1402FF3C0) ---
_QWORD *__fastcall sub_1402FF3C0(__int64 **a1, const vraudio::AudioBuffer *__Val_0__)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 Size; // rdi
  size_t Size_1; // r8
  _BYTE *v10; // r9
  __int64 v11; // rcx
  __m256 *p_Src; // rbx
  char *v13; // rbx
  unsigned __int64 n0xF; // rbp
  __m256 *p_Src_2; // rdi
  __int64 v16; // r15
  _QWORD **v17; // rsi
  _QWORD *v18; // rbx
  __int64 Size_3; // r14
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // rcx
  _QWORD *v26; // rbx
  __m256 *p_Src_3; // rax
  _QWORD *result; // rax
  unsigned __int8 v29; // [rsp+30h] [rbp-68h]
  __m256 Src; // [rsp+38h] [rbp-60h] BYREF

  if ( *((_QWORD *)__Val_0__ + 2) )
  {
    if ( !**a1 )
    {
      v4 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
      v5 = v4;
      if ( v4 )
      {
        *v4 = 0;
        v4[1] = 0;
        v6 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
        *v6 = v6;
        v6[1] = v6;
        *v5 = v6;
      }
      else
      {
        v5 = 0;
      }
      **a1 = (__int64)v5;
    }
    v7 = (_BYTE *)*((_QWORD *)__Val_0__ + 1);
    Size = 0xFFFFFFFFFFFFFFFFuLL;
    memset(&Src, 0, sizeof(Src));
    Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_1;
    while ( v7[Size_1] );
    sub_1402FB100(&Src, v7, Size_1);
    v10 = (_BYTE *)*((_QWORD *)__Val_0__ + 2);
    do
      ++Size;
    while ( v10[Size] );
    v11 = *(_QWORD *)&Src.m256_f32[4];
    if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
    {
      sub_1402A9870((const void **)&Src, Size, v29, v10, Size);
    }
    else
    {
      p_Src = &Src;
      *(_QWORD *)&Src.m256_f32[4] += Size;
      if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
        p_Src = *(__m256 **)Src.m256_f32;
      v13 = (char *)p_Src + v11;
      memmove(v13, v10, Size);
      v13[Size] = 0;
    }
    n0xF = *(_QWORD *)&Src.m256_f32[6];
    p_Src_2 = *(__m256 **)Src.m256_f32;
    v16 = **a1;
    v17 = *(_QWORD ***)v16;
    v18 = **(_QWORD ***)v16;
    if ( v18 == *(_QWORD **)v16 )
      goto LABEL_26;
    Size_3 = *(_QWORD *)&Src.m256_f32[4];
    do
    {
      Size_2 = v18[4];
      Buf1 = v18 + 2;
      p_Src_1 = &Src;
      if ( n0xF > 0xF )
        p_Src_1 = p_Src_2;
      if ( v18[5] > 0xFu )
        Buf1 = (_QWORD *)*Buf1;
      if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
        break;
      v18 = (_QWORD *)*v18;
    }
    while ( v18 != v17 );
    if ( v18 == v17 )
    {
LABEL_26:
      if ( *(_QWORD *)(v16 + 8) == 0x555555555555555LL )
        std::_Xlength_error("list too long");
      v23 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v23 + 0x20) = 0;
      *(_QWORD *)(v23 + 0x28) = 0;
      *(__m256 *)(v23 + 0x10) = Src;
      *(_QWORD *)&Src.m256_f32[4] = 0;
      *(_QWORD *)&Src.m256_f32[6] = 0xF;
      LOBYTE(Src.m256_f32[0]) = 0;
      ++*(_QWORD *)(v16 + 8);
      v24 = v17[1];
      *(_QWORD *)v23 = v17;
      *(_QWORD *)(v23 + 8) = v24;
      v17[1] = (_QWORD *)v23;
      *v24 = v23;
      v25 = **a1;
      v26 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x10LL);
      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + 0x28LL) > 0xFu )
        v26 = (_QWORD *)*v26;
      n0xF = *(_QWORD *)&Src.m256_f32[6];
      p_Src_2 = *(__m256 **)Src.m256_f32;
    }
    else
    {
      v26 = v18 + 2;
      if ( v26[3] > 0xFu )
        v26 = (_QWORD *)*v26;
    }
    if ( n0xF > 0xF )
    {
      p_Src_3 = p_Src_2;
      if ( n0xF + 1 >= 0x1000 )
      {
        p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
        if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
        {
          __asm { vzeroupper }
          invalid_parameter_noinfo_noreturn();
        }
      }
      __asm { vzeroupper }
      sub_1402A3D30(p_Src_2);
    }
    result = v26;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)__Val_0__ + 1);
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1402FF3C0 (0x1402FF3C0) ---

// --- Function: sub_1402FFCB0 (0x1402FFCB0) ---
bool __fastcall sub_1402FFCB0(__int64 a1, _QWORD *a2, __int64 a3, __int64 __Val_0__, unsigned __int64 _Newcapacity)
{
  __int64 v7; // rax
  __int64 __Val_0___1; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r9
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  bool v16; // bp
  __int64 v17; // rdi
  __int64 v18; // rbx
  unsigned __int64 _Newcapacity_2; // rsi
  _QWORD *v20; // r15
  unsigned __int64 _Newcapacity_1; // rbx
  __int64 v22; // rdi
  unsigned __int64 v23; // r9
  char v24; // al
  __int64 v25; // r8
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rax
  unsigned __int64 v29; // [rsp+20h] [rbp-48h]
  bool v31; // [rsp+80h] [rbp+18h]

  v7 = sub_140300AB0(*(_DWORD *)(a3 + 0x24));
  if ( v9 + v7 > v10 )
    return 0;
  v12 = *(_DWORD *)(a3 + 0x20);
  v16 = 0;
  if ( v12 != 1 )
  {
    v13 = sub_140300AB0(v12);
    if ( v14 + v13 < v15 )
      v16 = 1;
  }
  v17 = *(_QWORD *)(a3 + 8);
  v18 = *(_QWORD *)a3;
  v31 = v16;
  if ( (v17 - *(_QWORD *)a3) / 0x70 != _Newcapacity )
  {
    if ( v18 != v17 )
    {
      do
      {
        if ( *(_BYTE *)(v18 + 0x58) && *(_QWORD *)v18 )
          (*(void (**)(void))(v18 + 0x40))();
        v18 += 0x70;
      }
      while ( v18 != v17 );
      *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
    }
    sub_1402FDB90((__int64 *)a3, _Newcapacity);
    __Val_0___1 = __Val_0__;
    v16 = 1;
    v31 = 1;
  }
  _Newcapacity_2 = 0;
  v20 = a2 + 1;
  _Newcapacity_1 = 0;
  if ( _Newcapacity )
  {
    v22 = __Val_0___1 + 0x30;
    v23 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    v29 = 0xFFFFFFFFFFFFFFD0uLL - __Val_0___1;
    while ( !v16 )
    {
      v20 = a2 + 1;
      if ( _Newcapacity_1 < (__int64)(a2[1] - *a2) >> 2
        && !*(_DWORD *)(*a2 + 4 * _Newcapacity_1)
        && *(_QWORD *)(v22 + 0x18)
        && *(_QWORD *)v22 )
      {
        if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 0x70LL <= _Newcapacity_1 )
          __debugbreak();
        v24 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))v22)(
                *(_QWORD *)(v22 - 0x30),
                *(_QWORD *)(v23 + v22 + *(_QWORD *)a3));
        v23 = v29;
        v16 = v24 == 0;
        v31 = v24 == 0;
      }
      ++_Newcapacity_1;
      v22 += 0x70;
      if ( _Newcapacity_1 >= _Newcapacity )
        goto LABEL_26;
    }
    goto LABEL_27;
  }
LABEL_26:
  if ( v16 )
  {
LABEL_27:
    if ( _Newcapacity )
    {
      v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
      v26 = __Val_0__ + 0x10;
      do
      {
        if ( _Newcapacity_2 < (__int64)(*v20 - *a2) >> 2
          && !*(_DWORD *)(*a2 + 4 * _Newcapacity_2)
          && *(_QWORD *)(v26 + 0x38)
          && *(_QWORD *)(v26 + 0x20) )
        {
          if ( (*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) / 0x70LL <= _Newcapacity_2 )
            __debugbreak();
          v27 = v26 + v25 + *(_QWORD *)a3;
          if ( *(_BYTE *)(v27 + 0x58) )
          {
            if ( *(_QWORD *)v27 )
              (*(void (**)(void))(v27 + 0x40))();
          }
          v28 = (*(__int64 (__fastcall **)(_QWORD))(v26 + 0x38))(*(_QWORD *)(v26 - 0x10));
          v25 = 0xFFFFFFFFFFFFFFF0uLL - __Val_0__;
          *(_QWORD *)v27 = v28;
          *(_QWORD *)(v27 + 8) = *(_QWORD *)(v26 - 8);
          *(_QWORD *)(v27 + 0x10) = *(_QWORD *)v26;
          *(_QWORD *)(v27 + 0x18) = *(_QWORD *)(v26 + 8);
          *(_QWORD *)(v27 + 0x20) = *(_QWORD *)(v26 + 0x10);
          *(_QWORD *)(v27 + 0x30) = *(_QWORD *)(v26 + 0x20);
          *(_QWORD *)(v27 + 0x28) = *(_QWORD *)(v26 + 0x18);
          *(_QWORD *)(v27 + 0x38) = *(_QWORD *)(v26 + 0x28);
          *(_QWORD *)(v27 + 0x40) = *(_QWORD *)(v26 + 0x30);
          *(_QWORD *)(v27 + 0x48) = *(_QWORD *)(v26 + 0x38);
          *(_QWORD *)(v27 + 0x50) = *(_QWORD *)(v26 + 0x40);
          *(_QWORD *)(v27 + 0x60) = *(_QWORD *)(v26 + 0x50);
          *(_QWORD *)(v27 + 0x68) = *(_QWORD *)(v26 + 0x58);
          *(_BYTE *)(v27 + 0x58) = 1;
          *(_BYTE *)(v27 + 0x59) = *(_BYTE *)(v26 + 0x49);
        }
        ++_Newcapacity_2;
        v26 += 0x70;
      }
      while ( _Newcapacity_2 < _Newcapacity );
      v16 = v31;
    }
    *(_QWORD *)(a3 + 0x18) = a1;
  }
  return v16;
}

// --- End Function: sub_1402FFCB0 (0x1402FFCB0) ---

// --- Function: sub_1403009B0 (0x1403009B0) ---
__int64 __fastcall sub_1403009B0(char *Buffer, size_t SizeInBytes, unsigned __int64 a3)
{
  int v3; // esi
  unsigned __int64 v7; // rbx
  __time64_t Time; // [rsp+20h] [rbp-58h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-50h] BYREF

  v3 = a3;
  if ( SizeInBytes < 0x20 )
    return 0xFFFFFFFFLL;
  v7 = a3 / 0x3E8;
  Time = a3 / 0x3E8;
  gmtime64_s(&Tm, &Time);
  strftime(Buffer, SizeInBytes, "%Y-%m-%dT%H:%M:%S", &Tm);
  return (unsigned int)(swprintf((wchar_t *)(Buffer + 0x13), SizeInBytes - 0x13, ".%03dZ", v3 - 0x3E8 * v7) + 0x13);
}

// --- End Function: sub_1403009B0 (0x1403009B0) ---

// --- Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---
// Executes a global callback function if registered, otherwise defaults to a
// status of 1. Subsequently, it masks specific status bits (bits 2 and 3) based on
// the state of global configuration flags (`qword_149B3B208` and
// `qword_149B3B210`).
__int64 invokeGlobalCallbackAndMaskStatusBits(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  __int64 status_bits; // rax

  if ( qword_149B3B1F0 )
    status_bits = qword_149B3B1F0(a1, a2, a3, a4);
  else
    status_bits = 1;
  if ( !qword_149B3B208 )
    status_bits = (unsigned int)status_bits & 0xFFFFFFFB;
  if ( !qword_149B3B210 )
    return (unsigned int)status_bits & 0xFFFFFFF7;
  return status_bits;
}

// --- End Function: invokeGlobalCallbackAndMaskStatusBits (0x140300A70) ---

// --- Function: sub_140302340 (0x140302340) ---
__int64 __fastcall sub_140302340(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int n4,
        __int64 *event_data_ptr,
        _BYTE *Src,
        char *a7,
        _QWORD *__Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a10,
        char *Buffer,
        size_t Size,
        int *a13,
        int a14,
        _DWORD *a15)
{
  int Sizea_2; // r14d
  int Sizea_1; // ebx
  char *v17; // rax
  size_t Size_5; // r13
  size_t Size_1; // rbx
  const void **v21; // rsi
  int v22; // eax
  int Sizea_4; // ecx
  void *v24; // rdi
  size_t Size_2; // r12
  char *Buffer_1; // r9
  size_t Size_3; // rsi
  char *v28; // rcx
  __int64 v29; // rdi
  char *v30; // rcx
  size_t Size_4; // r8
  __int64 v32; // rbp
  void *v33; // rdi
  char *v34; // rcx
  size_t Size_6; // rsi
  size_t Size_7; // rsi
  __int64 v37; // r14
  char *v38; // rcx
  size_t Size_8; // rbp
  void *v40; // rbp
  size_t Size_9; // rdi
  __int64 v42; // rdx
  char *v43; // rcx
  size_t Size_10; // r14
  __int64 v45; // r14
  char *v46; // rcx
  size_t n2; // r8
  char *v48; // r14
  size_t Size_11; // rbx
  char *v50; // rcx
  size_t Size_12; // rbp
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ebp
  int Sizea_3; // edi
  int v60; // eax
  char *v61; // rcx
  unsigned __int64 v62; // rdx
  __int64 v63; // rcx
  size_t Size_14; // rdi
  void *v65; // rsi
  char *Buffer_2; // rdx
  size_t Size_15; // rbp
  char *v68; // rcx
  __int64 Size_13; // rsi
  int v70; // eax
  int v71; // eax
  int v72; // eax
  void *v73; // r13
  size_t Size_16; // rsi
  char *Buffer_3; // r12
  size_t Size_17; // rdi
  char *v77; // rcx
  bool v78; // si
  unsigned __int64 _Newcapacity_1; // rdi
  _QWORD *__Val_0___1; // r13
  __int64 (__fastcall *v81)(_QWORD, char *, size_t, _QWORD, int, _QWORD); // r10
  int v82; // eax
  int v84; // [rsp+20h] [rbp-88h]
  unsigned int v85; // [rsp+50h] [rbp-58h]
  int v86; // [rsp+50h] [rbp-58h]
  void *v87; // [rsp+58h] [rbp-50h] BYREF
  void *v88; // [rsp+60h] [rbp-48h]
  int Sizea; // [rsp+108h] [rbp+60h]
  int Sizeb; // [rsp+108h] [rbp+60h]
  size_t Sizec; // [rsp+108h] [rbp+60h]
  int *v95; // [rsp+110h] [rbp+68h]

  Sizea_2 = 0;
  Sizea_1 = 0;
  v17 = off_149924708[0];
  if ( n4 > 3 )
  {
    if ( n4 <= 4 )
      v17 = off_149924720[0];
  }
  else
  {
    v17 = off_149924728[0];
  }
  Size_5 = 0xFFFFFFFFFFFFFFFFuLL;
  v87 = v17;
  v88 = v17;
  if ( (int)Size <= 0 )
  {
    Sizea = 0;
LABEL_141:
    *a13 = Sizea_2;
    goto LABEL_142;
  }
  Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
  v21 = (const void **)&off_149924738[0][n4];
  do
    ++Size_1;
  while ( *((_BYTE *)off_149924710 + Size_1) );
  if ( Size_1 >= Size )
    goto LABEL_25;
  if ( Size_1 )
  {
    if ( Buffer )
    {
      if ( off_149924710 )
      {
        memcpy(Buffer, off_149924710, Size_1);
        goto LABEL_15;
      }
      memset(Buffer, 0, Size);
    }
    *errno() = 0x16;
    invalid_parameter_noinfo();
  }
LABEL_15:
  if ( (Size_1 & 0x80000000) != 0LL || (int)Size_1 + 1LL >= Size )
    goto LABEL_25;
  if ( !&Buffer[(int)Size_1] )
  {
    *errno() = 0x16;
LABEL_22:
    invalid_parameter_noinfo();
    goto LABEL_23;
  }
  if ( Size == (int)Size_1 )
  {
    *errno() = 0x22;
    goto LABEL_22;
  }
  Buffer[(int)Size_1] = 0x5B;
LABEL_23:
  v22 = sub_1402FE770(
          (double *)Buffer,
          Size,
          (int)Size_1 + 1LL,
          (const void **)&v87,
          v21,
          (const void **)&off_149924710,
          "]");
  if ( v22 < 0 || (Sizea_4 = Size_1 + v22 + 1, v22 + 1 < 0) )
LABEL_25:
    Sizea_4 = 0xFFFFFFFF;
  Sizea_1 = Sizea_4;
  if ( Sizea_4 < 0 )
    Sizea_1 = 0;
  v85 = (unsigned int)Sizea_4 >> 0x1F;
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_141;
  v24 = off_149924710;
  Size_2 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_2;
  while ( *((_BYTE *)off_149924710 + Size_2) );
  if ( Size_2 + Sizea_1 >= Size )
    goto LABEL_125;
  Buffer_1 = Buffer;
  Size_3 = Size - Sizea_1;
  v28 = &Buffer[Sizea_1];
  if ( Size_2 )
  {
    if ( !v28 )
    {
LABEL_34:
      *errno() = 0x16;
LABEL_41:
      invalid_parameter_noinfo();
      goto LABEL_42;
    }
    if ( off_149924710 && Size_3 >= Size_2 )
    {
      memcpy(v28, off_149924710, Size_2);
    }
    else
    {
      memset(v28, 0, Size - Sizea_1);
      if ( !v24 )
        goto LABEL_34;
      if ( Size_3 < Size_2 )
      {
        *errno() = 0x22;
        goto LABEL_41;
      }
    }
LABEL_42:
    Buffer_1 = Buffer;
  }
  if ( (Size_2 & 0x80000000) != 0LL )
    goto LABEL_125;
  v29 = Sizea_1 + (__int64)(int)Size_2;
  if ( v29 + 2 >= Size )
    goto LABEL_125;
  v30 = &Buffer_1[v29];
  Size_4 = Size - v29;
  if ( !&Buffer_1[v29] )
  {
    *errno() = 0x16;
LABEL_50:
    invalid_parameter_noinfo();
    Buffer_1 = Buffer;
    goto LABEL_51;
  }
  if ( Size_4 < 2 )
  {
    memset(v30, 0, Size_4);
    *errno() = 0x22;
    goto LABEL_50;
  }
  *(_WORD *)v30 = 0x3C20;
LABEL_51:
  v32 = v29 + 2;
  Sizeb = Sizea_1;
  v33 = off_149924730;
  do
    ++Size_5;
  while ( *((_BYTE *)off_149924730 + Size_5) );
  if ( Size_5 + v32 >= Size )
    goto LABEL_125;
  v34 = &Buffer_1[v32];
  Size_6 = Size - v32;
  if ( Size_5 )
  {
    if ( !v34 )
    {
LABEL_56:
      *errno() = 0x16;
LABEL_63:
      invalid_parameter_noinfo();
      goto LABEL_64;
    }
    if ( off_149924730 && Size_6 >= Size_5 )
    {
      memcpy(v34, off_149924730, Size_5);
    }
    else
    {
      memset(v34, 0, Size - v32);
      if ( !v33 )
        goto LABEL_56;
      if ( Size_6 < Size_5 )
      {
        *errno() = 0x22;
        goto LABEL_63;
      }
    }
LABEL_64:
    Buffer_1 = Buffer;
  }
  if ( (Size_5 & 0x80000000) != 0LL )
    goto LABEL_125;
  Size_7 = 0xFFFFFFFFFFFFFFFFuLL;
  v37 = v32 + (int)Size_5;
  do
    ++Size_7;
  while ( Src[Size_7] );
  if ( Size_7 + v37 >= Size )
    goto LABEL_125;
  v38 = &Buffer_1[v37];
  Size_8 = Size - v37;
  if ( Size_7 )
  {
    if ( !v38 )
    {
LABEL_71:
      *errno() = 0x16;
LABEL_78:
      invalid_parameter_noinfo();
      goto LABEL_79;
    }
    if ( Src && Size_8 >= Size_7 )
    {
      memcpy(v38, Src, Size_7);
    }
    else
    {
      memset(v38, 0, Size - v37);
      if ( !Src )
        goto LABEL_71;
      if ( Size_8 < Size_7 )
      {
        *errno() = 0x22;
        goto LABEL_78;
      }
    }
LABEL_79:
    Buffer_1 = Buffer;
  }
  if ( (Size_7 & 0x80000000) != 0LL )
    goto LABEL_125;
  v40 = off_149924710;
  Size_9 = 0xFFFFFFFFFFFFFFFFuLL;
  v42 = v37 + (int)Size_7;
  v87 = (void *)v42;
  do
    ++Size_9;
  while ( *((_BYTE *)off_149924710 + Size_9) );
  if ( Size_9 + v42 >= Size )
    goto LABEL_125;
  v43 = &Buffer_1[v42];
  Size_10 = Size - v42;
  if ( Size_9 )
  {
    if ( !v43 )
    {
LABEL_86:
      *errno() = 0x16;
LABEL_93:
      invalid_parameter_noinfo();
      goto LABEL_94;
    }
    if ( off_149924710 && Size_10 >= Size_9 )
    {
      memcpy(v43, off_149924710, Size_9);
    }
    else
    {
      memset(v43, 0, Size - v42);
      if ( !v40 )
        goto LABEL_86;
      if ( Size_10 < Size_9 )
      {
        *errno() = 0x22;
        goto LABEL_93;
      }
    }
LABEL_94:
    v42 = (__int64)v87;
    Buffer_1 = Buffer;
  }
  if ( (Size_9 & 0x80000000) != 0LL )
    goto LABEL_125;
  v45 = v42 + (int)Size_9;
  if ( v45 + 2 >= Size )
    goto LABEL_125;
  v46 = &Buffer_1[v45];
  n2 = Size - v45;
  if ( &Buffer_1[v45] )
  {
    if ( n2 >= 2 )
    {
      *(_WORD *)v46 = 0x203E;
      goto LABEL_103;
    }
    memset(v46, 0, n2);
    *errno() = 0x22;
  }
  else
  {
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
  Buffer_1 = Buffer;
LABEL_103:
  v48 = (char *)(v45 + 2);
  Size_11 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_11;
  while ( *((_BYTE *)v88 + Size_11) );
  if ( (unsigned __int64)&v48[Size_11] >= Size )
    goto LABEL_124;
  v50 = &Buffer_1[(_QWORD)v48];
  Size_12 = Size - (_QWORD)v48;
  if ( !Size_11 )
    goto LABEL_116;
  if ( !v50 )
    goto LABEL_108;
  if ( v88 && Size_12 >= Size_11 )
  {
    memcpy(v50, v88, Size_11);
    goto LABEL_116;
  }
  memset(v50, 0, Size - (_QWORD)v48);
  if ( v88 )
  {
    if ( Size_12 >= Size_11 )
      goto LABEL_116;
    *errno() = 0x22;
  }
  else
  {
LABEL_108:
    *errno() = 0x16;
  }
  invalid_parameter_noinfo();
LABEL_116:
  if ( (Size_11 & 0x80000000) != 0LL )
  {
LABEL_124:
    Sizea_1 = Sizeb;
LABEL_125:
    v58 = 1;
    goto LABEL_126;
  }
  v52 = Size_11 + 2;
  Sizea_1 = Sizeb;
  if ( v52 < 0 )
    goto LABEL_125;
  v53 = Size_9 + v52;
  if ( v53 < 0 )
    goto LABEL_125;
  v54 = Size_7 + v53;
  if ( v54 < 0 )
    goto LABEL_125;
  v55 = Size_5 + v54;
  if ( v55 < 0 )
    goto LABEL_125;
  v56 = v55 + 2;
  if ( v56 < 0 )
    goto LABEL_125;
  v57 = Size_2 + v56;
  if ( v57 < 0 )
    goto LABEL_125;
  v58 = v85;
  Sizea_1 = Sizeb + v57;
LABEL_126:
  Sizea_2 = Sizea_1;
  Sizea = Sizea_1;
  Sizea_3 = Sizea_1;
  *a13 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  v60 = sub_140305400(
          (__int64)Buffer,
          Size,
          Sizea_1,
          a7,
          (__int64)__Val_0__,
          _Newcapacity,
          a10,
          0,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD310);
  if ( v60 < 0 )
    v58 = 1;
  Sizea_1 += v60;
  v86 = v58;
  if ( v60 < 0 )
    Sizea_1 = Sizea_3;
  Sizea = Sizea_1;
  Sizea_2 = Sizea_1;
  if ( Sizea_1 >= (int)Size )
    goto LABEL_142;
  if ( Sizea_1 + 1LL >= Size )
  {
    Sizea = Sizea_1;
LABEL_142:
    v86 = 1;
    v58 = 1;
    goto LABEL_143;
  }
  v61 = &Buffer[Sizea_1];
  if ( v61 )
  {
    if ( Size == Sizea_1 )
    {
      *errno() = 0x22;
      invalid_parameter_noinfo();
    }
    else
    {
      *v61 = 0x20;
    }
    ++Sizea_1;
    Sizea = Sizea_2;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    ++Sizea_1;
    Sizea = Sizea_2;
  }
LABEL_143:
  v62 = 0;
  v95 = 0;
  v63 = *event_data_ptr;
  if ( !((event_data_ptr[1] - *event_data_ptr) >> 2) )
    goto LABEL_175;
  do
  {
    if ( Sizea_1 < (int)Size )
    {
      Size_14 = 0xFFFFFFFFFFFFFFFFuLL;
      v65 = off_149924710;
      v87 = (void *)qword_149B3AEA0;
      Sizec = 8LL * *(unsigned int *)(v63 + 4 * v62);
      do
        ++Size_14;
      while ( *((_BYTE *)off_149924710 + Size_14) );
      if ( Size_14 + Sizea_1 >= Size )
        goto LABEL_171;
      Buffer_2 = Buffer;
      Size_15 = Size - Sizea_1;
      v68 = &Buffer[Sizea_1];
      if ( !Size_14 )
      {
LABEL_159:
        if ( (Size_14 & 0x80000000) == 0LL )
        {
          Size_13 = Sizea_1 + (__int64)(int)Size_14;
          if ( Size_13 + 1 < Size )
          {
            if ( &Buffer_2[Size_13] )
            {
              if ( Size != Size_13 )
              {
                Buffer_2[Size_13] = 0x5B;
LABEL_167:
                v70 = sub_1402FE770(
                        (double *)Buffer,
                        Size,
                        Size_13 + 1,
                        (const void **)&off_149924718,
                        (const void **)((char *)v87 + Sizec),
                        (const void **)&off_149924710,
                        "]");
                if ( v70 >= 0 )
                {
                  v71 = v70 + 1;
                  if ( v71 >= 0 )
                  {
                    v72 = Size_14 + v71;
                    if ( v72 >= 0 )
                    {
                      v58 = v86;
                      Sizea_1 += v72;
                      v62 = (unsigned __int64)v95;
                      goto LABEL_173;
                    }
                  }
                }
                goto LABEL_171;
              }
              *errno() = 0x22;
            }
            else
            {
              *errno() = 0x16;
            }
            invalid_parameter_noinfo();
            goto LABEL_167;
          }
        }
LABEL_171:
        v62 = (unsigned __int64)v95;
        v58 = 1;
        v86 = 1;
        goto LABEL_173;
      }
      if ( !v68 )
        goto LABEL_150;
      if ( off_149924710 && Size_15 >= Size_14 )
      {
        memcpy(v68, off_149924710, Size_14);
      }
      else
      {
        memset(v68, 0, Size - Sizea_1);
        if ( !v65 )
        {
LABEL_150:
          *errno() = 0x16;
LABEL_157:
          invalid_parameter_noinfo();
          goto LABEL_158;
        }
        if ( Size_15 < Size_14 )
        {
          *errno() = 0x22;
          goto LABEL_157;
        }
      }
LABEL_158:
      Buffer_2 = Buffer;
      goto LABEL_159;
    }
    v58 = 1;
    v86 = 1;
LABEL_173:
    v95 = (int *)++v62;
    v63 = *event_data_ptr;
  }
  while ( v62 < (event_data_ptr[1] - *event_data_ptr) >> 2 );
  Sizea = Sizea_2;
LABEL_175:
  if ( Sizea_1 >= (int)Size )
    goto LABEL_194;
  v73 = v88;
  Size_16 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_16;
  while ( *((_BYTE *)v88 + Size_16) );
  Buffer_3 = Buffer;
  if ( Size_16 + Sizea_1 >= Size )
    goto LABEL_191;
  Size_17 = Size - Sizea_1;
  v77 = &Buffer[Sizea_1];
  if ( !Size_16 )
    goto LABEL_189;
  if ( !v77 )
    goto LABEL_181;
  if ( v88 && Size_17 >= Size_16 )
  {
    memcpy(v77, v88, Size_16);
    goto LABEL_189;
  }
  memset(v77, 0, Size_17);
  if ( !v73 )
  {
LABEL_181:
    *errno() = 0x16;
    goto LABEL_188;
  }
  if ( Size_17 < Size_16 )
  {
    *errno() = 0x22;
LABEL_188:
    invalid_parameter_noinfo();
  }
LABEL_189:
  if ( (Size_16 & 0x80000000) != 0LL )
LABEL_191:
    v58 = 1;
  else
    Sizea_1 += Size_16;
  if ( Sizea_1 >= (int)Size )
  {
LABEL_194:
    Buffer_3 = Buffer;
    v58 = 1;
  }
  else
  {
    Buffer[Sizea_1] = 0;
  }
  v78 = (*a15 & 4) != 0;
  if ( _Newcapacity )
  {
    _Newcapacity_1 = 0;
    if ( (*a15 & 4) != 0 )
    {
      __Val_0___1 = __Val_0__;
      do
      {
        v81 = (__int64 (__fastcall *)(_QWORD, char *, size_t, _QWORD, int, _QWORD))__Val_0___1[5];
        if ( v81 )
        {
          if ( Sizea_1 >= (int)Size
            || (LOBYTE(v84) = 0, v82 = v81(*__Val_0___1, &Buffer_3[Sizea_1], Size - Sizea_1, 0, v84, 0), v82 < 0) )
          {
            v58 = 1;
          }
          else
          {
            Sizea_1 += v82;
          }
        }
        ++_Newcapacity_1;
        __Val_0___1 += 0xE;
      }
      while ( _Newcapacity_1 < _Newcapacity );
      Sizea_2 = Sizea;
    }
  }
  if ( Sizea_1 >= (int)Size )
  {
    v58 = 1;
LABEL_209:
    if ( Size > 3 )
    {
      *(_WORD *)&Buffer_3[Size - 4] = 0x2E2E;
      Buffer_3[Size - 2] = 0x2E;
    }
  }
  else
  {
    Buffer_3[Sizea_1] = 0;
    if ( v58 )
      goto LABEL_209;
  }
  Buffer_3[Size - 1] = 0;
  if ( v78 )
    qword_149B3B208(a2, a3, n4, Buffer_3, Sizea_1, a14);
  return (unsigned int)(Sizea_2 - v58);
}

// --- End Function: sub_140302340 (0x140302340) ---

// --- Function: sub_140302E40 (0x140302E40) ---
__int64 __fastcall sub_140302E40(
        unsigned __int64 a1,
        __int64 a2,
        _BYTE *p_Buffer,
        _BYTE *a4,
        unsigned int n4,
        _QWORD *event_data_ptr,
        char *a7,
        char *a8,
        __int64 __Val_0__,
        unsigned __int64 _Newcapacity,
        __int64 a11,
        __int64 a12,
        unsigned __int64 n0xF_29,
        double *Buffer,
        unsigned __int64 n0xF,
        __int64 a16,
        int a17,
        unsigned int a18,
        int a19)
{
  unsigned int n4_1; // r14d
  double *Buffer_1; // r15
  _QWORD *event_data_ptr_1; // r11
  int n0xF_2; // ebx
  unsigned __int64 n0xF_1; // r9
  unsigned __int64 n0xF_3; // r12
  size_t Size; // rdi
  char *v29; // rcx
  size_t Size_1; // rbx
  __int64 v31; // rbx
  double *v32; // rcx
  size_t Size_2; // r8
  __int64 v34; // r14
  size_t Size_3; // rbx
  char *v36; // rcx
  size_t Size_4; // rsi
  __int64 v38; // rsi
  double *v39; // rcx
  size_t Size_5; // r8
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int n0xF_25; // r13d
  int v47; // r13d
  int v48; // edi
  int v49; // eax
  bool v50; // al
  bool v51; // r14
  bool v52; // bp
  int v53; // eax
  int n0xF_4; // ebp
  int n0xF_6; // esi
  signed int n0xF_18; // edi
  int v57; // eax
  __int64 *event_data_ptr_3; // r9
  __int64 v59; // rdx
  __int64 v60; // rcx
  __int64 v61; // rax
  unsigned __int64 v62; // r8
  __int64 v63; // r15
  __int64 v64; // r14
  _BYTE *v65; // rsi
  __int64 v66; // r12
  size_t Size_6; // rdi
  size_t Size_7; // rbp
  char *v69; // rcx
  __int64 v70; // rcx
  size_t n2; // r8
  _WORD *v72; // rcx
  bool v73; // sf
  int v74; // ecx
  __int64 v75; // rax
  __int64 v76; // r15
  __int64 v77; // r14
  int v78; // eax
  int v79; // eax
  signed int n0xF_27; // ebp
  int n0xF_8; // r14d
  int n0xF_9; // r15d
  int n0xF_10; // edx
  char *v84; // r14
  int v85; // eax
  int n0xF_11; // ecx
  size_t Size_8; // r8
  double *v88; // rcx
  __int64 v89; // rdi
  __int64 i; // rbp
  int v91; // eax
  int n0xF_12; // ecx
  size_t Size_9; // r8
  double *v94; // rcx
  _BYTE *v95; // rcx
  size_t Size_10; // r8
  double *v97; // rcx
  int n0xF_13; // ebp
  int v99; // eax
  _BYTE *v100; // rcx
  unsigned __int64 n0xF_14; // rdx
  bool v102; // bp
  __int64 v103; // r14
  unsigned __int64 n0xF_21; // r15
  unsigned __int64 v105; // rsi
  __int64 v106; // r14
  int n0xF_15; // edx
  signed int n0xF_19; // ecx
  bool v109; // r15
  int n0xF_16; // r12d
  size_t Size_11; // r8
  _WORD *v112; // rcx
  _BYTE *v113; // rcx
  __int64 v114; // rax
  unsigned __int64 v115; // r9
  double *Buffer_2; // rdx
  _BYTE *v117; // rdi
  __int64 v118; // rbp
  size_t Size_12; // rbx
  char *v120; // rcx
  size_t Size_13; // rsi
  __int64 v122; // rcx
  size_t Size_14; // r8
  _WORD *v124; // rcx
  int v125; // ecx
  _BYTE *v126; // rcx
  unsigned __int64 n0xF_22; // r8
  double *Buffer_3; // r12
  unsigned __int64 v129; // r8
  _BYTE *v130; // rcx
  int n0xF_23; // esi
  int v132; // eax
  double *Buffer_4; // rsi
  _BYTE *v134; // rcx
  size_t Size_15; // r8
  _WORD *v136; // rcx
  int v137; // eax
  size_t Size_16; // r8
  double *v139; // rcx
  int v140; // eax
  size_t Size_17; // r8
  _WORD *v142; // rcx
  size_t n0xF_24; // rdi
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  __int64 v146; // r14
  _BYTE *v147; // rdi
  int p_n0xF; // [rsp+20h] [rbp-148h]
  unsigned int *p_n0xFa; // [rsp+20h] [rbp-148h]
  bool v151; // [rsp+80h] [rbp-E8h]
  bool v152; // [rsp+81h] [rbp-E7h]
  signed int n0xF_26; // [rsp+84h] [rbp-E4h]
  int n0xF_7; // [rsp+84h] [rbp-E4h]
  signed int n0xF_20; // [rsp+84h] [rbp-E4h]
  bool v156; // [rsp+90h] [rbp-D8h]
  unsigned __int64 n0xF_17; // [rsp+98h] [rbp-D0h]
  unsigned int n0xF_5[2]; // [rsp+A8h] [rbp-C0h] BYREF
  _QWORD *event_data_ptr_2; // [rsp+B0h] [rbp-B8h]
  unsigned __int64 v160; // [rsp+B8h] [rbp-B0h]
  _BYTE *v161; // [rsp+C0h] [rbp-A8h]
  __int64 v162; // [rsp+C8h] [rbp-A0h]
  __int64 __Val_0___1; // [rsp+D0h] [rbp-98h]
  char *v164; // [rsp+D8h] [rbp-90h]
  __int64 v165; // [rsp+E0h] [rbp-88h]
  char *v166; // [rsp+E8h] [rbp-80h]
  void (__fastcall *v167)(_QWORD, __int64, _BYTE *, _QWORD, char *, _QWORD *, __int64, _QWORD, char *, __int64, unsigned __int64, char *, unsigned __int64, __int128 *); // [rsp+F0h] [rbp-78h] BYREF
  __int64 v168; // [rsp+F8h] [rbp-70h]
  __int128 v169; // [rsp+100h] [rbp-68h] BYREF

  n4_1 = n4;
  Buffer_1 = Buffer;
  event_data_ptr_1 = event_data_ptr;
  v166 = a7;
  v164 = a8;
  __Val_0___1 = __Val_0__;
  v168 = a12;
  v165 = a16;
  v161 = a4;
  n0xF_2 = 0;
  n0xF_1 = n0xF;
  v167 = 0;
  v162 = a2;
  n0xF_3 = n0xF + 0x80;
  n0xF_5[0] = n4;
  event_data_ptr_2 = event_data_ptr;
  n0xF_17 = n0xF + 0x80;
  v169 = 0;
  if ( (int)n0xF <= 0 )
  {
    v47 = 1;
    goto LABEL_62;
  }
  if ( n0xF <= 0xF )
    goto LABEL_57;
  if ( Buffer )
  {
    *Buffer = 0x73656D697440227BLL;
    *((_DWORD *)Buffer + 2) = 0x706D6174;
    *((_WORD *)Buffer + 6) = 0x3A22;
    *((_BYTE *)Buffer + 0xE) = 0x22;
  }
  else
  {
    *errno() = 0x16;
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
  }
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_Buffer[Size] );
  if ( Size + 0xF >= n0xF_1 )
  {
LABEL_56:
    n0xF_1 = n0xF;
    event_data_ptr_1 = event_data_ptr_2;
LABEL_57:
    n0xF_25 = 0xFFFFFFFF;
    goto LABEL_58;
  }
  v29 = (char *)Buffer + 0xF;
  Size_1 = n0xF_1 - 0xF;
  if ( Size )
  {
    if ( Buffer == (double *)0xFFFFFFFFFFFFFFF1LL )
    {
LABEL_11:
      *errno() = 0x16;
LABEL_18:
      invalid_parameter_noinfo();
      goto LABEL_19;
    }
    if ( p_Buffer && Size_1 >= Size )
    {
      memcpy(v29, p_Buffer, Size);
    }
    else
    {
      memset(v29, 0, n0xF_1 - 0xF);
      if ( !p_Buffer )
        goto LABEL_11;
      if ( Size_1 < Size )
      {
        *errno() = 0x22;
        goto LABEL_18;
      }
    }
LABEL_19:
    n0xF_1 = n0xF;
  }
  if ( (Size & 0x80000000) != 0LL )
    goto LABEL_56;
  v31 = (int)Size + 0xFLL;
  if ( (int)Size + 0x18LL >= n0xF_1 )
    goto LABEL_56;
  v32 = (double *)((char *)Buffer + v31);
  Size_2 = n0xF_1 - v31;
  if ( !(double *)((char *)Buffer + v31) )
  {
    *errno() = 0x16;
LABEL_27:
    invalid_parameter_noinfo();
    n0xF_1 = n0xF;
    goto LABEL_28;
  }
  if ( Size_2 < 9 )
  {
    memset(v32, 0, Size_2);
    *errno() = 0x22;
    goto LABEL_27;
  }
  *v32 = 0x3A22646940222C22LL;
  *((_BYTE *)v32 + 8) = 0x22;
LABEL_28:
  v34 = (int)Size + 0x18LL;
  Size_3 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size_3;
  while ( a4[Size_3] );
  if ( Size_3 + v34 >= n0xF_1 )
    goto LABEL_56;
  v36 = (char *)Buffer + v34;
  Size_4 = n0xF_1 - v34;
  if ( Size_3 )
  {
    if ( !v36 )
    {
LABEL_33:
      *errno() = 0x16;
LABEL_40:
      invalid_parameter_noinfo();
      goto LABEL_41;
    }
    if ( a4 && Size_4 >= Size_3 )
    {
      memcpy(v36, a4, Size_3);
    }
    else
    {
      memset(v36, 0, n0xF_1 - v34);
      if ( !a4 )
        goto LABEL_33;
      if ( Size_4 < Size_3 )
      {
        *errno() = 0x22;
        goto LABEL_40;
      }
    }
LABEL_41:
    n0xF_1 = n0xF;
  }
  if ( (Size_3 & 0x80000000) != 0LL )
    goto LABEL_56;
  v38 = v34 + (int)Size_3;
  if ( v38 + 0xD >= n0xF_1 )
    goto LABEL_56;
  v39 = (double *)((char *)Buffer + v38);
  Size_5 = n0xF_1 - v38;
  if ( !(double *)((char *)Buffer + v38) )
  {
    *errno() = 0x16;
LABEL_49:
    invalid_parameter_noinfo();
    goto LABEL_50;
  }
  if ( Size_5 < 0xD )
  {
    memset(v39, 0, Size_5);
    *errno() = 0x22;
    goto LABEL_49;
  }
  *v39 = 0x5F67736D40222C22LL;
  *((_DWORD *)v39 + 2) = 0x22786469;
  *((_BYTE *)v39 + 0xC) = 0x3A;
LABEL_50:
  v41 = sub_1402FE6B0((__int64)Buffer, n0xF, v38 + 0xD, a1);
  if ( v41 < 0 )
    goto LABEL_56;
  v42 = v41 + 0xD;
  if ( v42 < 0 )
    goto LABEL_56;
  v43 = Size_3 + v42;
  if ( v43 < 0 )
    goto LABEL_56;
  v44 = v43 + 9;
  if ( v44 < 0 )
    goto LABEL_56;
  v45 = Size + v44;
  if ( v45 < 0 )
    goto LABEL_56;
  n0xF_1 = n0xF;
  event_data_ptr_1 = event_data_ptr_2;
  n0xF_25 = v45 + 0xF;
LABEL_58:
  n4_1 = n4;
  n0xF_2 = n0xF_25;
  if ( n0xF_25 < 0 )
    n0xF_2 = 0;
  v47 = (unsigned int)n0xF_25 >> 0x1F;
LABEL_62:
  v48 = a17;
  if ( (a18 & 0x10) != 0 && qword_149B3B218 )
  {
    if ( n0xF_2 >= (int)n0xF_1 )
    {
      v47 = 1;
    }
    else
    {
      v49 = qword_149B3B218(
              v162,
              v161,
              n4_1,
              v166,
              event_data_ptr_1,
              v165,
              a17,
              v164,
              __Val_0___1,
              _Newcapacity,
              (char *)Buffer + n0xF_2,
              n0xF_1 - n0xF_2,
              &a18);
      if ( v49 < 0 )
        v47 = 1;
      else
        n0xF_2 += v49;
    }
  }
  v50 = (a18 & 8) != 0 && qword_149B3B210;
  v156 = v50;
  v51 = (a18 & 1) != 0 && n2_125 == 2;
  v152 = v51;
  v52 = (a18 & 2) != 0 && n2_126 == 2;
  v151 = v52;
  if ( !v50 && !v51 && !v52 )
    goto LABEL_354;
  if ( qword_149B3B1E8 )
  {
    if ( n0xF_2 >= (int)n0xF_3 )
    {
      n0xF_6 = n0xF + 0x80;
      n0xF_26 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_95;
    }
    v53 = qword_149B3B1E8((char *)Buffer + n0xF_2, n0xF_3 - n0xF_2, qword_149B3B1E8, n0xF_1);
    if ( v53 < 0 )
    {
      v47 = 1;
      n0xF_26 = n0xF + 0x80;
      n0xF_4 = n0xF_2;
      n0xF_6 = n0xF + 0x80;
      n0xF_18 = n0xF + 0x80;
      goto LABEL_89;
    }
    n0xF_2 += v53;
  }
  n0xF_26 = n0xF + 0x80;
  n0xF_4 = n0xF_2;
  n0xF_6 = n0xF + 0x80;
  n0xF_18 = n0xF + 0x80;
  if ( n0xF_2 < (int)n0xF_3 )
  {
LABEL_89:
    v57 = sub_1402FEBF0(
            Buffer,
            n0xF_3,
            n0xF_2,
            ",\"@severity\":",
            n0xF_5,
            ",\"severity\":\"",
            (const void **)&off_149924738[0][n4],
            "\",\"tags\":[");
    if ( v57 < 0 )
      v47 = 1;
    n0xF_2 += v57;
    if ( v57 < 0 )
      n0xF_2 = n0xF_4;
    goto LABEL_96;
  }
LABEL_95:
  v47 = 1;
LABEL_96:
  event_data_ptr_3 = event_data_ptr_2;
  v59 = event_data_ptr_2[1];
  v60 = *event_data_ptr_2;
  v61 = (v59 - *event_data_ptr_2) >> 2;
  if ( !v61 )
    goto LABEL_145;
  v62 = 0;
  v160 = 0;
  if ( v61 == 1 )
    goto LABEL_134;
  do
  {
    n0xF_5[0] = n0xF_18;
    n0xF_7 = n0xF_6;
    if ( n0xF_2 >= n0xF_6 )
      goto LABEL_131;
    v63 = qword_149B3AEA0;
    v64 = *(unsigned int *)(v60 + 4 * v62);
    if ( n0xF_2 + 1LL >= n0xF_3 )
      goto LABEL_131;
    if ( !(double *)((char *)Buffer + n0xF_2) )
    {
      *errno() = 0x16;
LABEL_105:
      invalid_parameter_noinfo();
      goto LABEL_106;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
      goto LABEL_105;
    }
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
LABEL_106:
    v65 = *(_BYTE **)(v63 + 8 * v64);
    v66 = n0xF_2 + 1LL;
    Size_6 = 0xFFFFFFFFFFFFFFFFuLL;
    do
      ++Size_6;
    while ( v65[Size_6] );
    if ( Size_6 + v66 >= n0xF_17 )
    {
LABEL_129:
      n0xF_3 = n0xF + 0x80;
LABEL_130:
      n0xF_6 = n0xF_7;
      n0xF_18 = n0xF_5[0];
      v62 = v160;
      event_data_ptr_3 = event_data_ptr_2;
      goto LABEL_131;
    }
    Size_7 = n0xF_17 - v66;
    v69 = (char *)Buffer + v66;
    if ( Size_6 )
    {
      if ( !v69 )
        goto LABEL_111;
      if ( v65 && Size_7 >= Size_6 )
      {
        memcpy(v69, v65, Size_6);
        goto LABEL_119;
      }
      memset(v69, 0, n0xF_17 - v66);
      if ( v65 )
      {
        if ( Size_7 >= Size_6 )
          goto LABEL_119;
        *errno() = 0x22;
      }
      else
      {
LABEL_111:
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
    }
LABEL_119:
    if ( (Size_6 & 0x80000000) != 0LL )
      goto LABEL_129;
    v70 = v66 + (int)Size_6;
    n0xF_3 = n0xF + 0x80;
    if ( v70 + 2 >= n0xF_17 )
      goto LABEL_130;
    n2 = n0xF_17 - v70;
    v72 = (_WORD *)((char *)Buffer + v70);
    if ( v72 )
    {
      if ( n2 >= 2 )
      {
        *v72 = 0x2C22;
        goto LABEL_127;
      }
      memset(v72, 0, n2);
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
LABEL_127:
    v73 = (int)Size_6 + 3 < 0;
    v74 = Size_6 + 3;
    v62 = v160;
    event_data_ptr_3 = event_data_ptr_2;
    n0xF_6 = n0xF_7;
    n0xF_18 = n0xF_5[0];
    if ( !v73 )
    {
      n0xF_2 += v74;
      goto LABEL_132;
    }
LABEL_131:
    v47 = 1;
LABEL_132:
    v59 = event_data_ptr_3[1];
    ++v62;
    v60 = *event_data_ptr_3;
    v75 = v59 - *event_data_ptr_3;
    v160 = v62;
  }
  while ( v62 < (v75 >> 2) - 1 );
  n0xF_26 = n0xF_18;
LABEL_134:
  if ( n0xF_2 >= n0xF_6 )
    goto LABEL_148;
  v76 = qword_149B3AEA0;
  v77 = *(unsigned int *)(v60 + 4 * ((v59 - v60) >> 2) - 4);
  if ( n0xF_2 + 1LL >= n0xF_3 )
    goto LABEL_157;
  if ( !(double *)((char *)Buffer + n0xF_2) )
  {
    *errno() = 0x16;
    goto LABEL_141;
  }
  if ( n0xF_3 == n0xF_2 )
  {
    *errno() = 0x22;
LABEL_141:
    invalid_parameter_noinfo();
  }
  else
  {
    *((_BYTE *)Buffer + n0xF_2) = 0x22;
  }
  v78 = sub_1402FE920(Buffer, n0xF_3, n0xF_2 + 1LL, (const void **)(v76 + 8 * v77), "\"");
  if ( v78 < 0 || (v79 = v78 + 1, v79 < 0) )
  {
LABEL_157:
    n0xF_27 = n0xF_18;
    n0xF_8 = n0xF_6;
    v47 = 1;
    n0xF_9 = n0xF_2;
    n0xF_10 = n0xF_2;
    goto LABEL_146;
  }
  n0xF_2 += v79;
  n0xF_26 = n0xF_18;
LABEL_145:
  n0xF_27 = n0xF_18;
  n0xF_8 = n0xF_6;
  n0xF_9 = n0xF_2;
  n0xF_10 = n0xF_2;
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_148:
    v47 = 1;
  }
  else
  {
LABEL_146:
    if ( n0xF_2 + 0xBLL >= n0xF_3 )
    {
      n0xF_2 = n0xF_10;
      n0xF_26 = n0xF_18;
      goto LABEL_148;
    }
    Size_8 = n0xF_3 - n0xF_2;
    v88 = (double *)((char *)Buffer + n0xF_2);
    if ( !v88 )
    {
      *errno() = 0x16;
      goto LABEL_163;
    }
    if ( Size_8 < 0xB )
    {
      memset(v88, 0, Size_8);
      *errno() = 0x22;
LABEL_163:
      invalid_parameter_noinfo();
    }
    else
    {
      *v88 = 0x746E657665222C5DLL;
      *((_WORD *)v88 + 4) = 0x3A22;
      *((_BYTE *)v88 + 0xA) = 0x22;
    }
    n0xF_26 = n0xF_27;
    n0xF_2 = n0xF_9 + 0xB;
    n0xF_6 = n0xF_8;
    n0xF_18 = n0xF_27;
  }
  if ( *v166 )
  {
    v84 = v166;
    do
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v85 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *v84);
        if ( v85 < 0 )
          v47 = 1;
        n0xF_11 = v85 + n0xF_2;
        if ( v85 < 0 )
          n0xF_11 = n0xF_2;
        n0xF_2 = n0xF_11;
      }
      ++v84;
    }
    while ( *v84 );
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_171:
    v47 = 1;
  }
  else
  {
    if ( n0xF_2 + 0xDLL >= n0xF_3 )
    {
      n0xF_26 = n0xF_18;
      goto LABEL_171;
    }
    Size_9 = n0xF_3 - n0xF_2;
    v94 = (double *)((char *)Buffer + n0xF_2);
    if ( !v94 )
    {
      *errno() = 0x16;
      goto LABEL_185;
    }
    if ( Size_9 < 0xD )
    {
      memset(v94, 0, Size_9);
      *errno() = 0x22;
LABEL_185:
      invalid_parameter_noinfo();
    }
    else
    {
      *v94 = 0x617373656D222C22LL;
      *((_DWORD *)v94 + 2) = 0x3A226567;
      *((_BYTE *)v94 + 0xC) = 0x22;
    }
    n0xF_2 += 0xD;
    n0xF_26 = n0xF_18;
  }
  if ( a17 > 0 )
  {
    v89 = v165;
    for ( i = 0; i < a17; ++i )
    {
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        v91 = sub_140300BC0((double *)((char *)Buffer + n0xF_2), (int)n0xF - n0xF_2, *(_BYTE *)(v89 + i));
        if ( v91 < 0 )
          v47 = 1;
        n0xF_12 = v91 + n0xF_2;
        if ( v91 < 0 )
          n0xF_12 = n0xF_2;
        n0xF_2 = n0xF_12;
      }
    }
    n0xF_18 = n0xF_26;
    n0xF_3 = n0xF + 0x80;
  }
  if ( n0xF_2 >= n0xF_6 )
  {
LABEL_208:
    v47 = 1;
    goto LABEL_209;
  }
  if ( n0xF_2 + 1LL < n0xF_3 )
  {
    v95 = (char *)Buffer + n0xF_2;
    if ( v95 )
    {
      if ( n0xF_3 != n0xF_2 )
      {
        *v95 = 0x22;
LABEL_199:
        ++n0xF_2;
        goto LABEL_200;
      }
      *errno() = 0x22;
    }
    else
    {
      *errno() = 0x16;
    }
    invalid_parameter_noinfo();
    goto LABEL_199;
  }
  v47 = 1;
LABEL_200:
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 0xBLL >= n0xF_3 )
    goto LABEL_208;
  Size_10 = n0xF_3 - n0xF_2;
  v97 = (double *)((char *)Buffer + n0xF_2);
  if ( !v97 )
  {
    *errno() = 0x16;
    goto LABEL_207;
  }
  if ( Size_10 < 0xB )
  {
    memset(v97, 0, Size_10);
    *errno() = 0x22;
LABEL_207:
    invalid_parameter_noinfo();
    n0xF_2 += 0xB;
  }
  else
  {
    *v97 = 0x6F746F727040222CLL;
    n0xF_2 += 0xB;
    *((_WORD *)v97 + 4) = 0x3A22;
    *((_BYTE *)v97 + 0xA) = 0x22;
  }
LABEL_209:
  n0xF_13 = n0xF_2;
  if ( n0xF_2 >= (int)n0xF )
  {
    v47 = 1;
  }
  else
  {
    v99 = sub_140305400(
            (__int64)Buffer,
            n0xF,
            n0xF_2,
            v164,
            __Val_0___1,
            _Newcapacity,
            a11,
            1,
            (__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, _BYTE *))sub_1402FD350);
    if ( v99 < 0 )
      v47 = 1;
    n0xF_2 += v99;
    if ( v99 < 0 )
      n0xF_2 = n0xF_13;
  }
  if ( n0xF_2 >= n0xF_6 || n0xF_2 + 1LL >= n0xF_3 )
  {
    v47 = 1;
  }
  else
  {
    v100 = (char *)Buffer + n0xF_2;
    if ( !v100 )
    {
      *errno() = 0x16;
      goto LABEL_222;
    }
    if ( n0xF_3 == n0xF_2 )
    {
      *errno() = 0x22;
LABEL_222:
      invalid_parameter_noinfo();
      ++n0xF_2;
    }
    else
    {
      *v100 = 0x22;
      ++n0xF_2;
    }
  }
  n0xF_14 = n0xF_29;
  v102 = 0;
  *(_QWORD *)n0xF_5 = 0;
  v103 = 0;
  n0xF_21 = 0;
  if ( n0xF_29 )
  {
    while ( !v47 )
    {
      v105 = *(_QWORD *)(v168 + 8 * n0xF_21);
      v160 = v105;
      if ( v103 != *(_QWORD *)(v105 + 8) )
      {
        if ( v102 )
        {
          if ( n0xF_2 < n0xF_18 )
          {
            if ( n0xF_2 + 2LL >= n0xF_3 )
            {
              v106 = *(_QWORD *)(v105 + 0x50);
              v47 = 1;
              n0xF_20 = n0xF_18;
              n0xF_15 = n0xF_2;
              n0xF_19 = n0xF_18;
              v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
              n0xF_16 = n0xF_2;
              goto LABEL_248;
            }
            Size_11 = n0xF_3 - n0xF_2;
            v112 = (_WORD *)((char *)Buffer + n0xF_2);
            if ( !v112 )
            {
              *errno() = 0x16;
              goto LABEL_236;
            }
            if ( Size_11 < 2 )
            {
              memset(v112, 0, Size_11);
              *errno() = 0x22;
LABEL_236:
              invalid_parameter_noinfo();
              n0xF_2 += 2;
            }
            else
            {
              *v112 = 0x2C5D;
              n0xF_2 += 2;
            }
LABEL_247:
            v114 = *(_QWORD *)(v105 + 0x50);
            n0xF_15 = n0xF_2;
            n0xF_20 = n0xF_18;
            n0xF_19 = n0xF_18;
            n0xF_16 = n0xF_2;
            v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
            v106 = v114;
            v109 = v102;
            if ( n0xF_2 < n0xF_18 )
            {
LABEL_248:
              v115 = n0xF + 0x80;
              if ( n0xF_2 + 1LL >= n0xF_17 )
              {
                v105 = v160;
                n0xF_18 = n0xF_19;
                n0xF_2 = n0xF_15;
                v102 = v109;
                v114 = v106;
                goto LABEL_283;
              }
              Buffer_2 = Buffer;
              if ( !(double *)((char *)Buffer + n0xF_2) )
              {
                *errno() = 0x16;
                goto LABEL_255;
              }
              if ( n0xF_17 == n0xF_2 )
              {
                *errno() = 0x22;
LABEL_255:
                invalid_parameter_noinfo();
                Buffer_2 = Buffer;
                v115 = n0xF + 0x80;
              }
              else
              {
                *((_BYTE *)Buffer + n0xF_2) = 0x22;
              }
              v117 = *(_BYTE **)(v105 + 8);
              v118 = n0xF_2 + 1LL;
              Size_12 = 0xFFFFFFFFFFFFFFFFuLL;
              do
                ++Size_12;
              while ( v117[Size_12] );
              if ( Size_12 + v118 >= v115 )
                goto LABEL_280;
              v120 = (char *)Buffer_2 + v118;
              Size_13 = v115 - v118;
              if ( Size_12 )
              {
                if ( !v120 )
                  goto LABEL_261;
                if ( v117 && Size_13 >= Size_12 )
                {
                  memcpy(v120, v117, Size_12);
                  goto LABEL_269;
                }
                memset(v120, 0, v115 - v118);
                if ( !v117 )
                {
LABEL_261:
                  *errno() = 0x16;
                  goto LABEL_268;
                }
                if ( Size_13 < Size_12 )
                {
                  *errno() = 0x22;
LABEL_268:
                  invalid_parameter_noinfo();
                }
LABEL_269:
                v115 = n0xF + 0x80;
                Buffer_2 = Buffer;
              }
              if ( (Size_12 & 0x80000000) != 0LL || (v122 = v118 + (int)Size_12, v122 + 2 >= v115) )
              {
LABEL_280:
                n0xF_18 = n0xF_20;
                n0xF_2 = n0xF_16;
                v102 = v109;
                v114 = v106;
              }
              else
              {
                Size_14 = v115 - v122;
                v124 = (_WORD *)((char *)Buffer_2 + v122);
                if ( !v124 )
                {
                  *errno() = 0x16;
                  goto LABEL_277;
                }
                if ( Size_14 < 2 )
                {
                  memset(v124, 0, Size_14);
                  *errno() = 0x22;
LABEL_277:
                  invalid_parameter_noinfo();
                }
                else
                {
                  *v124 = 0x3A22;
                }
                n0xF_18 = n0xF_20;
                v73 = (int)Size_12 + 3 < 0;
                v125 = Size_12 + 3;
                n0xF_2 = n0xF_16;
                v114 = v106;
                v102 = v109;
                if ( !v73 )
                {
                  v105 = v160;
                  n0xF_2 = v125 + n0xF_16;
                  goto LABEL_284;
                }
              }
              v105 = v160;
            }
LABEL_283:
            v47 = 1;
LABEL_284:
            if ( v114 != 0xFFFFFFFFFFFFFFFFuLL )
            {
              if ( n0xF_2 < n0xF_18 && n0xF_2 + 1LL < n0xF_17 )
              {
                v126 = (char *)Buffer + n0xF_2;
                if ( !v126 )
                {
                  *errno() = 0x16;
                  goto LABEL_292;
                }
                if ( n0xF_17 == n0xF_2 )
                {
                  *errno() = 0x22;
LABEL_292:
                  invalid_parameter_noinfo();
                  v103 = *(_QWORD *)(v105 + 8);
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                }
                else
                {
                  n0xF_21 = *(_QWORD *)n0xF_5;
                  ++n0xF_2;
                  *v126 = 0x5B;
                  v103 = *(_QWORD *)(v105 + 8);
                }
LABEL_306:
                Buffer_3 = Buffer;
                goto LABEL_307;
              }
              v47 = 1;
            }
            v103 = *(_QWORD *)(v105 + 8);
            n0xF_21 = *(_QWORD *)n0xF_5;
            goto LABEL_306;
          }
LABEL_282:
          v114 = *(_QWORD *)(v105 + 0x50);
          v102 = v114 != 0xFFFFFFFFFFFFFFFFuLL;
          goto LABEL_283;
        }
        if ( n0xF_2 >= n0xF_18 )
          goto LABEL_282;
        if ( n0xF_2 + 1LL >= n0xF_3 )
        {
          v106 = *(_QWORD *)(v105 + 0x50);
          n0xF_19 = n0xF_18;
          n0xF_20 = n0xF_18;
          v47 = 1;
          n0xF_15 = n0xF_2;
          v109 = v106 != 0xFFFFFFFFFFFFFFFFuLL;
          n0xF_16 = n0xF_2;
          goto LABEL_248;
        }
        v113 = (char *)Buffer + n0xF_2;
        if ( !v113 )
        {
          *errno() = 0x16;
          goto LABEL_245;
        }
        if ( n0xF_3 == n0xF_2 )
        {
          *errno() = 0x22;
LABEL_245:
          invalid_parameter_noinfo();
        }
        else
        {
          *v113 = 0x2C;
        }
        ++n0xF_2;
        goto LABEL_247;
      }
      if ( !v103 || n0xF_21 >= n0xF_14 )
        goto LABEL_306;
      if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
      {
        v47 = 1;
        goto LABEL_306;
      }
      n0xF_22 = n0xF_3;
      Buffer_3 = Buffer;
      v129 = n0xF_22 - n0xF_2;
      v130 = (char *)Buffer + n0xF_2;
      if ( v130 )
      {
        if ( v129 )
        {
          *v130 = 0x2C;
          ++n0xF_2;
          goto LABEL_307;
        }
        *errno() = 0x22;
      }
      else
      {
        *errno() = 0x16;
      }
      invalid_parameter_noinfo();
      ++n0xF_2;
LABEL_307:
      n0xF_23 = n0xF_2;
      if ( n0xF_2 >= (int)n0xF )
      {
        v47 = 1;
      }
      else
      {
        LOBYTE(p_n0xF) = 1;
        v132 = (*(__int64 (__fastcall **)(_QWORD, char *, unsigned __int64, _QWORD, int, _QWORD))(v160 + 0x20))(
                 *(_QWORD *)v160,
                 (char *)Buffer_3 + n0xF_2,
                 n0xF - n0xF_2,
                 0,
                 p_n0xF,
                 0);
        if ( v132 < 0 )
          v47 = 1;
        n0xF_2 += v132;
        if ( v132 < 0 )
          n0xF_2 = n0xF_23;
        if ( !v47 )
        {
          n0xF_3 = n0xF + 0x80;
          goto LABEL_314;
        }
      }
      n0xF_3 = n0xF + 0x80;
      if ( n0xF_2 >= n0xF_18 )
      {
        v47 = 1;
LABEL_314:
        Buffer_4 = Buffer;
      }
      else
      {
        Buffer_4 = Buffer;
        if ( n0xF_2 + 6LL >= n0xF_17 )
        {
          v47 = 1;
          goto LABEL_315;
        }
        Size_15 = n0xF_17 - n0xF_2;
        v136 = (_WORD *)((char *)Buffer + n0xF_2);
        if ( !v136 )
        {
          *errno() = 0x16;
          goto LABEL_331;
        }
        if ( Size_15 < 6 )
        {
          memset(v136, 0, Size_15);
          *errno() = 0x22;
LABEL_331:
          invalid_parameter_noinfo();
          n0xF_2 += 6;
        }
        else
        {
          n0xF_2 += 6;
          *(_DWORD *)v136 = 0x6C756E22;
          v136[2] = 0x226C;
        }
      }
LABEL_315:
      n0xF_14 = n0xF_29;
      if ( (n0xF_21 == n0xF_29 - 1 || v47) && v102 )
      {
        if ( n0xF_2 >= n0xF_18 || n0xF_2 + 1LL >= n0xF_3 )
        {
          v47 = 1;
        }
        else
        {
          v134 = (char *)Buffer_4 + n0xF_2;
          if ( !v134 )
          {
            *errno() = 0x16;
            goto LABEL_336;
          }
          if ( n0xF_3 == n0xF_2 )
          {
            *errno() = 0x22;
LABEL_336:
            invalid_parameter_noinfo();
            n0xF_14 = n0xF_29;
            ++n0xF_2;
          }
          else
          {
            *v134 = 0x5D;
            ++n0xF_2;
          }
        }
      }
      *(_QWORD *)n0xF_5 = ++n0xF_21;
      if ( n0xF_21 >= n0xF_14 )
        break;
      continue;
    }
  }
  Buffer_1 = Buffer;
  if ( a19 <= 1 )
  {
LABEL_343:
    if ( v47 && n0xF_2 < n0xF_18 )
      goto LABEL_345;
  }
  else if ( n0xF_2 < n0xF_18 )
  {
    v137 = sub_1402FEA70(Buffer, n0xF_3, n0xF_2, ",\"EVT_COUNT\":", &a19);
    if ( v137 >= 0 )
    {
      n0xF_2 += v137;
      goto LABEL_343;
    }
LABEL_345:
    if ( n0xF_2 + 0xDLL < n0xF_3 )
    {
      Size_16 = n0xF_3 - n0xF_2;
      v139 = (double *)((char *)Buffer + n0xF_2);
      if ( !v139 )
      {
        *errno() = 0x16;
        goto LABEL_351;
      }
      if ( Size_16 < 0xD )
      {
        memset(v139, 0, Size_16);
        *errno() = 0x22;
LABEL_351:
        invalid_parameter_noinfo();
      }
      else
      {
        *v139 = 0x4C465245564F222CLL;
        *((_DWORD *)v139 + 2) = 0x3A22574F;
        *((_BYTE *)v139 + 0xC) = 0x31;
      }
      n0xF_2 += 0xD;
    }
  }
  v52 = v151;
  v51 = v152;
  v48 = a17;
LABEL_354:
  if ( (a18 & 0xFFF00) != 0 )
  {
    if ( qword_149B3B220 )
    {
      if ( n0xF_2 < (int)n0xF )
      {
        v140 = qword_149B3B220(
                 a18,
                 v162,
                 v161,
                 n4,
                 v166,
                 event_data_ptr_2,
                 v165,
                 v48,
                 v164,
                 __Val_0___1,
                 _Newcapacity,
                 (char *)Buffer_1 + n0xF_2,
                 n0xF - n0xF_2,
                 &v169,
                 &v167);
        if ( v140 >= 0 )
          n0xF_2 += v140;
      }
    }
  }
  if ( n0xF_2 >= (int)n0xF_3 )
    goto LABEL_369;
  if ( n0xF_2 + 2LL >= n0xF_3 )
    goto LABEL_368;
  Size_17 = n0xF_3 - n0xF_2;
  v142 = (_WORD *)((char *)Buffer_1 + n0xF_2);
  if ( !v142 )
  {
    *errno() = 0x16;
    goto LABEL_366;
  }
  if ( Size_17 < 2 )
  {
    memset(v142, 0, Size_17);
    *errno() = 0x22;
LABEL_366:
    invalid_parameter_noinfo();
  }
  else
  {
    *v142 = 0xA7D;
  }
  n0xF_2 += 2;
  if ( n0xF_2 >= (int)n0xF_3 )
  {
LABEL_369:
    n0xF_24 = n0xF_2;
  }
  else
  {
LABEL_368:
    n0xF_24 = n0xF_2;
    *((_BYTE *)Buffer_1 + n0xF_2) = 0;
  }
  *((_BYTE *)Buffer_1 + n0xF_3 - 1) = 0;
  if ( v51 )
  {
    Stream = __acrt_iob_func(1u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream);
  }
  if ( v52 )
  {
    Stream_1 = __acrt_iob_func(2u);
    fwrite(Buffer_1, n0xF_24, 1u, Stream_1);
  }
  v146 = v162;
  if ( v156 )
  {
    p_n0xFa = (unsigned int *)n0xF_24;
    v147 = v161;
    qword_149B3B210(v162, v161, n4, Buffer_1, p_n0xFa, a19);
  }
  else
  {
    v147 = v161;
  }
  if ( v167 )
    v167(
      a18,
      v146,
      v147,
      n4,
      v166,
      event_data_ptr_2,
      v165,
      a17,
      v164,
      __Val_0___1,
      _Newcapacity,
      (char *)Buffer_1 + n0xF_2,
      n0xF - n0xF_2,
      &v169);
  return (unsigned int)n0xF_2;
}

// --- End Function: sub_140302E40 (0x140302E40) ---

// --- Function: sub_1403044D0 (0x1403044D0) ---
void __fastcall sub_1403044D0(__int64 a1, unsigned __int64 _Newcapacity)
{
  const void *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 allocSize; // rcx
  unsigned __int64 _Newsize; // rdi
  __int64 v8; // rax
  _QWORD *_Newvec; // rbx

  v4 = *(const void **)a1;
  if ( _Newcapacity > (__int64)(*(_QWORD *)(a1 + 0x10) - (_QWORD)v4) >> 3 )
  {
    if ( _Newcapacity > 0x1FFFFFFFFFFFFFFFLL )
      unknown_libname_10();
    v5 = *(_QWORD *)(a1 + 8) - (_QWORD)v4;
    allocSize = 8 * _Newcapacity;
    _Newsize = v5 >> 3;
    if ( 8 * _Newcapacity < 0x1000 )
    {
      if ( allocSize )
        _Newvec = (_QWORD *)allocWithProfilerInfo_w(allocSize);
      else
        _Newvec = 0;
    }
    else
    {
      if ( allocSize + 0x27 < allocSize )
        sub_1402E1170();
      v8 = allocWithProfilerInfo_w(allocSize + 0x27);
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      _Newvec = (_QWORD *)((v8 + 0x27) & 0xFFFFFFFFFFFFFFE0uLL);
      _Newvec[0xFFFFFFFF] = v8;
    }
    memmove(_Newvec, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    std::vector<vraudio::AudioBuffer const *>::_Change_array(
      (std::vector<vraudio::AudioBuffer const *> *)a1,
      (const vraudio::AudioBuffer **const)_Newvec,
      _Newsize,
      _Newcapacity);
  }
}

// --- End Function: sub_1403044D0 (0x1403044D0) ---

// --- Function: sub_1403045C0 (0x1403045C0) ---
// A comprehensive function for logging and dispatching telemetry events. It
// captures system time, generates unique identifiers, formats event data
// (including parameters and tags) into a buffer, and conditionally outputs to
// console or dispatches to various logging handlers based on configuration and
// event type. It also handles dynamic memory allocation and deallocation for event
// data structures.
void __fastcall sub_1403045C0(
        unsigned int event_severity_level,
        __int64 *event_data_ptr_1,
        char *a3,
        char *a4,
        vraudio::AudioBuffer *__Val_0___8,
        unsigned __int64 _Newcapacity,
        __int64 a7,
        __int64 a8,
        _QWORD *a9,
        __int64 a10)
{
  _QWORD *v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // r14
  unsigned __int64 n0x10; // rax
  std::vector<vraudio::AudioBuffer const *> *v14; // r12
  unsigned __int64 n0x400; // rbx
  __int64 v16; // r13
  char *v17; // r15
  __int64 v18; // r14
  vraudio::AudioBuffer *__Val_0___1; // rdi
  unsigned __int8 v20; // si
  vraudio::AudioBuffer *__Val_0___3; // r15
  std::vector<vraudio::AudioBuffer const *> *v22; // rax
  std::vector<vraudio::AudioBuffer const *> *v23; // rdi
  unsigned __int64 n0x400_1; // r14
  __int64 v25; // rcx
  const vraudio::AudioBuffer **__Val_0_; // rbx
  const vraudio::AudioBuffer **_Whereptr; // rdx
  const vraudio::AudioBuffer **_Whereptr_1; // rdx
  unsigned __int64 v29; // r13
  __int64 (__fastcall *v30)(_QWORD, unsigned __int64 *, unsigned __int64 *); // rax
  __int64 v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdi
  _QWORD *v34; // r13
  bool v35; // zf
  _QWORD *v36; // rbx
  _QWORD *v37; // rax
  _BYTE *v38; // rdx
  unsigned __int64 Size; // rbx
  size_t Size_1; // r8
  _BYTE *v41; // r9
  __int64 v42; // rcx
  __m256 *p_Src; // r14
  char *v44; // r14
  const vraudio::AudioBuffer *__Val_0___7; // r12
  unsigned __int64 n0xF; // r13
  __m256 *p_Src_2; // r15
  _QWORD *v48; // r14
  _QWORD *v49; // rbx
  __int64 Size_3; // r12
  size_t Size_2; // r8
  _QWORD *Buf1; // rcx
  __m256 *p_Src_1; // rdx
  __int64 v54; // rax
  __int64 *v55; // rcx
  __int64 v56; // rcx
  _QWORD *v57; // rbx
  const void *v58; // rcx
  std::vector<vraudio::AudioBuffer const *> *v59; // r14
  __m256 *p_Src_3; // rax
  std::vector<vraudio::AudioBuffer const *> *v61; // rax
  unsigned __int64 n0x400_2; // r15
  __int64 v63; // rcx
  const vraudio::AudioBuffer **__Val_0__1; // rbx
  const vraudio::AudioBuffer **_Whereptr_2; // rdx
  const vraudio::AudioBuffer **_Whereptr_3; // rdx
  __int64 v67; // rax
  char *v68; // r11
  __int64 v69; // r8
  unsigned __int64 _Newcapacity_1; // r10
  char *v71; // rdi
  int v72; // r13d
  __int64 v73; // rcx
  __int64 v74; // r9
  unsigned __int64 n0x400_3; // r8
  __int64 v76; // rdx
  unsigned __int64 n0x8000; // rsi
  unsigned __int64 n0x8000_2; // rbx
  __int64 n0x100000; // rcx
  unsigned __int64 *p_n0x8000; // rax
  __int64 v81; // rax
  const void *v82; // r15
  char *v83; // r14
  __int64 v84; // rax
  void *v85; // rsp
  __int64 (__fastcall *v86)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *); // rax
  int v87; // edx
  int v88; // r12d
  char v89; // cl
  int v90; // eax
  FILE *File; // rax
  int n2_126; // r8d
  FILE *File_1; // rax
  char v94; // al
  bool v95; // dl
  bool v96; // cl
  unsigned __int64 *p_n0x8000_1; // rcx
  __int64 v98; // rax
  unsigned __int64 n0x8000_3; // rbx
  __int64 Buffer_2; // rax
  const void *Buffer_3; // rsi
  double *Buffer_1; // r8
  __int64 v103; // rax
  void *v104; // rsp
  char v105; // dl
  Stream *Stream; // rax
  Stream *Stream_1; // rax
  const void **v108; // rsi
  _QWORD **v109; // rcx
  _QWORD *v110; // rbx
  unsigned __int64 n0xF_1; // rdx
  _QWORD *v112; // rdi
  _QWORD *v113; // rcx
  std::vector<vraudio::AudioBuffer const *> *v114; // rbx
  _QWORD *v115; // rcx
  int v116; // [rsp+90h] [rbp-10h]
  unsigned __int8 v117; // [rsp+A0h] [rbp+0h] BYREF
  unsigned __int64 n0xF_29; // [rsp+A8h] [rbp+8h]
  std::vector<vraudio::AudioBuffer const *> *v119; // [rsp+B0h] [rbp+10h]
  __int64 v120; // [rsp+B8h] [rbp+18h]
  unsigned int n4; // [rsp+C0h] [rbp+20h]
  __int64 v122; // [rsp+C8h] [rbp+28h] BYREF
  int v123[2]; // [rsp+D0h] [rbp+30h]
  char *v124; // [rsp+D8h] [rbp+38h]
  struct _FILETIME FileTime; // [rsp+E0h] [rbp+40h] BYREF
  unsigned __int64 n0x10_1; // [rsp+E8h] [rbp+48h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+F0h] [rbp+50h]
  __int64 v128; // [rsp+F8h] [rbp+58h]
  unsigned __int64 __Val_0___4; // [rsp+100h] [rbp+60h] BYREF
  unsigned __int64 v130; // [rsp+108h] [rbp+68h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+110h] [rbp+70h]
  char *v132; // [rsp+118h] [rbp+78h]
  char *v133; // [rsp+120h] [rbp+80h]
  __int64 *event_data_ptr; // [rsp+128h] [rbp+88h]
  vraudio::AudioBuffer *__Val_0___5; // [rsp+130h] [rbp+90h]
  _QWORD *v136; // [rsp+138h] [rbp+98h]
  const vraudio::AudioBuffer *__Val_0___6; // [rsp+140h] [rbp+A0h] BYREF
  unsigned __int64 _Newcapacity_2; // [rsp+148h] [rbp+A8h]
  __int64 n0x100000_1; // [rsp+150h] [rbp+B0h] BYREF
  unsigned __int64 n0x8000_1; // [rsp+158h] [rbp+B8h] BYREF
  const void **v141; // [rsp+160h] [rbp+C0h] BYREF
  __int64 *v142; // [rsp+168h] [rbp+C8h] BYREF
  unsigned __int64 v143; // [rsp+170h] [rbp+D0h]
  __m256 Src; // [rsp+180h] [rbp+E0h] BYREF
  _SYSTEMTIME SystemTime; // [rsp+1A0h] [rbp+100h] BYREF
  _QWORD v146[16]; // [rsp+1B0h] [rbp+110h] BYREF
  _QWORD v147[1024]; // [rsp+230h] [rbp+190h] BYREF
  char Buffer[32]; // [rsp+2230h] [rbp+2190h] BYREF
  wchar_t String[20]; // [rsp+2250h] [rbp+21B0h] BYREF

  v10 = a9;
  v11 = a10;
  v132 = a4;
  v133 = a3;
  event_data_ptr = event_data_ptr_1;
  n4 = event_severity_level;
  __Val_0__ = __Val_0___8;
  if ( qword_149B3B188 )
  {
    v12 = qword_149B3B188();
  }
  else
  {
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    v12 = SystemTime.wMilliseconds + 0x3E8LL * (int)((*(_QWORD *)&FileTime - 0x19DB1DED53E8000LL) / 0x989680uLL);
  }
  v128 = v12;
  if ( v11 && !sub_1402FFCB0(v12, v10, v11, (__int64)__Val_0___8, _Newcapacity) )
    return;
  if ( qword_149B3B1E0 )
  {
    FileTime = (struct _FILETIME)((__int64 (__fastcall *)(wchar_t *, __int64))qword_149B3B1E0)(String, 0x25);
  }
  else
  {
    FileTime = (struct _FILETIME)qword_149B3B250++;
    swprintf(String, 0x25u, "00000000-0000-0000-0000-000000000000");
  }
  sub_1403009B0(Buffer, 0x20u, v12);
  v142 = (__int64 *)&v141;
  n0x10 = 0;
  v141 = 0;
  v14 = 0;
  v119 = 0;
  n0x400 = 0;
  n0xF_29 = 0;
  v16 = 0;
  v120 = 0;
  v17 = 0;
  n0x10_1 = 0;
  v18 = 0;
  v124 = 0;
  v122 = 0;
  _Newcapacity_2 = 0;
  if ( !_Newcapacity )
  {
LABEL_105:
    v71 = (char *)v147;
    goto LABEL_106;
  }
  __Val_0___1 = __Val_0__;
  v20 = v117;
  __Val_0___2 = __Val_0__;
  while ( 2 )
  {
    __Val_0___3 = __Val_0___1;
    if ( *((_BYTE *)__Val_0___1 + 0x59) && n0x10 < 0x10 )
    {
      v146[n0x10++] = __Val_0___1;
      n0x10_1 = n0x10;
    }
    *(_QWORD *)&SystemTime.wYear = n0x10;
    __Val_0___4 = (unsigned __int64)__Val_0___1;
    if ( n0x400 < 0x400 )
    {
      v147[n0x400] = __Val_0___1;
LABEL_30:
      n0xF_29 = ++n0x400;
      goto LABEL_31;
    }
    if ( byte_149924748 )
    {
      if ( !v14 )
      {
        __asm { vzeroupper }
        v22 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
        v14 = v22;
        v119 = v22;
        if ( v22 )
        {
          v23 = v22;
          *(_QWORD *)v22 = 0;
          n0x400_1 = 0;
          *((_QWORD *)v22 + 1) = 0;
          v25 = (__int64)v22;
          *((_QWORD *)v22 + 2) = 0;
        }
        else
        {
          v14 = 0;
          v23 = 0;
          n0x400_1 = 0;
          v119 = 0;
          v25 = 0;
        }
        sub_1403044D0(v25, _Newcapacity);
        __Val_0_ = (const vraudio::AudioBuffer **)v147;
        do
        {
          _Whereptr = (const vraudio::AudioBuffer **)*((_QWORD *)v23 + 1);
          if ( _Whereptr == *((const vraudio::AudioBuffer ***)v23 + 2) )
          {
            sub_1402A6760(v14, _Whereptr, __Val_0_);
          }
          else
          {
            *_Whereptr = *__Val_0_;
            *((_QWORD *)v23 + 1) += 8LL;
          }
          ++n0x400_1;
          ++__Val_0_;
        }
        while ( n0x400_1 < 0x400 );
        n0x400 = n0xF_29;
        __Val_0___1 = __Val_0___2;
        v18 = v122;
      }
      _Whereptr_1 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
      if ( _Whereptr_1 == *((const vraudio::AudioBuffer ***)v14 + 2) )
      {
        __asm { vzeroupper }
        sub_1402A6760(v14, _Whereptr_1, (const vraudio::AudioBuffer **)&__Val_0___4);
      }
      else
      {
        *_Whereptr_1 = __Val_0___1;
        *((_QWORD *)v14 + 1) += 8LL;
      }
      goto LABEL_30;
    }
LABEL_31:
    v120 = *((_QWORD *)__Val_0___1 + 0xD) + v16;
    __asm { vzeroupper }
    *((_QWORD *)__Val_0___1 + 1) = sub_1402FF3C0(&v142, __Val_0___1);
    v29 = v18;
    v30 = (__int64 (__fastcall *)(_QWORD, unsigned __int64 *, unsigned __int64 *))*((_QWORD *)__Val_0___1 + 7);
    v143 = v18++;
    v122 = v18;
    if ( !v30 )
    {
      v68 = v124;
      goto LABEL_98;
    }
    __Val_0___4 = 0;
    v130 = 0;
    v31 = v30(*(_QWORD *)__Val_0___1, &v130, &__Val_0___4);
    v32 = 0;
    *(_QWORD *)v123 = 0;
    if ( !v130 )
      goto LABEL_94;
    v33 = v142;
    v34 = (_QWORD *)(v31 + 0x10);
    v136 = (_QWORD *)(v31 + 0x10);
    do
    {
      __Val_0___3 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      __Val_0___5 = (vraudio::AudioBuffer *)(v34 + 0xFFFFFFFE);
      v35 = *v34 == 0;
      v122 = v18 + 1;
      v34[8] = v18;
      if ( v35 )
      {
        v57 = (_QWORD *)v34[0xFFFFFFFF];
        v59 = 0;
      }
      else
      {
        if ( !*v33 )
        {
          __asm { vzeroupper }
          v36 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
          if ( v36 )
          {
            *v36 = 0;
            v36[1] = 0;
            v37 = (_QWORD *)allocWithProfilerInfo_w(0x30u);
            *v37 = v37;
            v37[1] = v37;
            *v36 = v37;
          }
          else
          {
            v36 = 0;
          }
          *v33 = (__int64)v36;
        }
        v38 = (_BYTE *)v34[0xFFFFFFFF];
        Size = 0xFFFFFFFFFFFFFFFFuLL;
        memset(&Src, 0, sizeof(Src));
        Size_1 = 0xFFFFFFFFFFFFFFFFuLL;
        do
          ++Size_1;
        while ( v38[Size_1] );
        __asm { vzeroupper }
        sub_1402FB100(&Src, v38, Size_1);
        v41 = (_BYTE *)*v34;
        do
          ++Size;
        while ( v41[Size] );
        v42 = *(_QWORD *)&Src.m256_f32[4];
        if ( Size > *(_QWORD *)&Src.m256_f32[6] - *(_QWORD *)&Src.m256_f32[4] )
        {
          sub_1402A9870((const void **)&Src, Size, v20, v41, Size);
        }
        else
        {
          p_Src = &Src;
          *(_QWORD *)&Src.m256_f32[4] += Size;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
            p_Src = *(__m256 **)Src.m256_f32;
          v44 = (char *)p_Src + v42;
          memmove(v44, v41, Size);
          v44[Size] = 0;
        }
        __Val_0___7 = (const vraudio::AudioBuffer *)*v33;
        n0xF = *(_QWORD *)&Src.m256_f32[6];
        p_Src_2 = *(__m256 **)Src.m256_f32;
        __Val_0___6 = __Val_0___7;
        v48 = *(_QWORD **)__Val_0___7;
        v49 = **(_QWORD ***)__Val_0___7;
        if ( v49 == *(_QWORD **)__Val_0___7 )
          goto LABEL_59;
        Size_3 = *(_QWORD *)&Src.m256_f32[4];
        do
        {
          Size_2 = v49[4];
          Buf1 = v49 + 2;
          p_Src_1 = &Src;
          if ( n0xF > 0xF )
            p_Src_1 = p_Src_2;
          if ( v49[5] > 0xFu )
            Buf1 = (_QWORD *)*Buf1;
          if ( Size_2 == Size_3 && !memcmp(Buf1, p_Src_1, Size_2) )
            break;
          v49 = (_QWORD *)*v49;
        }
        while ( v49 != v48 );
        __Val_0___7 = __Val_0___6;
        if ( v49 == v48 )
        {
LABEL_59:
          if ( *((_QWORD *)__Val_0___7 + 1) == 0x555555555555555LL )
            std::_Xlength_error("list too long");
          v54 = allocWithProfilerInfo_w(0x30u);
          *(_QWORD *)(v54 + 0x20) = 0;
          *(_QWORD *)(v54 + 0x28) = 0;
          *(__m256 *)(v54 + 0x10) = Src;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          LOBYTE(Src.m256_f32[0]) = 0;
          ++*((_QWORD *)__Val_0___7 + 1);
          v55 = (__int64 *)v48[1];
          *(_QWORD *)v54 = v48;
          *(_QWORD *)(v54 + 8) = v55;
          v48[1] = v54;
          *v55 = v54;
          v56 = *(_QWORD *)*v33;
          v57 = (_QWORD *)(*(_QWORD *)(v56 + 8) + 0x10LL);
          if ( *(_QWORD *)(*(_QWORD *)(v56 + 8) + 0x28LL) > 0xFu )
            v57 = (_QWORD *)*v57;
          if ( *(_QWORD *)&Src.m256_f32[6] > 0xFu )
          {
            v58 = *(const void **)Src.m256_f32;
            if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[6] + 1LL) >= 0x1000 )
            {
              v58 = *(const void **)(*(_QWORD *)Src.m256_f32 - 8LL);
              if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v58 - 8LL) > 0x1F )
                goto LABEL_100;
            }
            __asm { vzeroupper }
            sub_1402A3D30(v58);
          }
LABEL_66:
          v14 = v119;
          v59 = 0;
          v34 = v136;
          __Val_0___3 = __Val_0___5;
          v32 = *(_QWORD *)v123;
          *(_QWORD *)&Src.m256_f32[4] = 0;
          LOBYTE(Src.m256_f32[0]) = 0;
          *(_QWORD *)&Src.m256_f32[6] = 0xF;
          goto LABEL_74;
        }
        v57 = v49 + 2;
        if ( v57[3] > 0xFu )
          v57 = (_QWORD *)*v57;
        if ( n0xF <= 0xF )
          goto LABEL_66;
        p_Src_3 = p_Src_2;
        if ( n0xF + 1 >= 0x1000 )
        {
          p_Src_2 = *(__m256 **)&p_Src_2[0xFFFFFFFF].m256_f32[6];
          if ( (unsigned __int64)((char *)p_Src_3 - (char *)p_Src_2 - 8) > 0x1F )
          {
LABEL_100:
            __asm { vzeroupper }
            invalid_parameter_noinfo_noreturn();
          }
        }
        sub_1402A3D30(p_Src_2);
        v14 = v119;
        v59 = 0;
        v34 = v136;
        __Val_0___3 = __Val_0___5;
        v32 = *(_QWORD *)v123;
        *(_QWORD *)&Src.m256_f32[4] = 0;
        LOBYTE(Src.m256_f32[0]) = 0;
        *(_QWORD *)&Src.m256_f32[6] = 0xF;
      }
LABEL_74:
      *((_QWORD *)__Val_0___3 + 1) = v57;
      n0x400 = n0xF_29;
      __Val_0___6 = __Val_0___3;
      if ( n0xF_29 >= 0x400 )
      {
        if ( !byte_149924748 )
          goto LABEL_92;
        if ( !v14 )
        {
          __asm { vzeroupper }
          v61 = (std::vector<vraudio::AudioBuffer const *> *)allocWithProfilerInfo_w(0x18u);
          n0x400_2 = 0;
          v119 = v61;
          v14 = v61;
          if ( v61 )
          {
            *(_QWORD *)v61 = 0;
            v63 = (__int64)v61;
            *((_QWORD *)v61 + 1) = 0;
            *((_QWORD *)v61 + 2) = 0;
            v59 = v61;
          }
          else
          {
            v14 = 0;
            v119 = 0;
            v63 = 0;
          }
          sub_1403044D0(v63, _Newcapacity);
          __Val_0__1 = (const vraudio::AudioBuffer **)v147;
          do
          {
            _Whereptr_2 = (const vraudio::AudioBuffer **)*((_QWORD *)v59 + 1);
            if ( _Whereptr_2 == *((const vraudio::AudioBuffer ***)v59 + 2) )
            {
              sub_1402A6760(v14, _Whereptr_2, __Val_0__1);
            }
            else
            {
              *_Whereptr_2 = *__Val_0__1;
              *((_QWORD *)v59 + 1) += 8LL;
            }
            ++n0x400_2;
            ++__Val_0__1;
          }
          while ( n0x400_2 < 0x400 );
          n0x400 = n0xF_29;
          __Val_0___3 = __Val_0___5;
        }
        _Whereptr_3 = (const vraudio::AudioBuffer **)*((_QWORD *)v14 + 1);
        if ( _Whereptr_3 == *((const vraudio::AudioBuffer ***)v14 + 2) )
        {
          __asm { vzeroupper }
          sub_1402A6760(v14, _Whereptr_3, &__Val_0___6);
        }
        else
        {
          *_Whereptr_3 = __Val_0___3;
          *((_QWORD *)v14 + 1) += 8LL;
        }
        v32 = *(_QWORD *)v123;
      }
      else
      {
        v147[n0xF_29] = __Val_0___3;
      }
      n0xF_29 = ++n0x400;
LABEL_92:
      ++v32;
      v67 = v34[0xB] + v120;
      v34 += 0xE;
      v18 = v122;
      v120 = v67;
      *(_QWORD *)v123 = v32;
      v136 = v34;
    }
    while ( v32 < v130 );
    __Val_0___1 = __Val_0___2;
    v29 = v143;
LABEL_94:
    if ( __Val_0___4 > 1 )
      v29 = 0xFFFFFFFFFFFFFFFFuLL;
    v68 = &v124[__Val_0___4];
    v124 += __Val_0___4;
LABEL_98:
    __Val_0___1 = (vraudio::AudioBuffer *)((char *)__Val_0___1 + 0x70);
    v69 = v120;
    _Newcapacity_1 = _Newcapacity_2 + 1;
    *((_QWORD *)__Val_0___3 + 0xA) = v29;
    _Newcapacity_2 = _Newcapacity_1;
    __Val_0___2 = __Val_0___1;
    if ( _Newcapacity_1 < _Newcapacity )
    {
      n0x10 = n0x10_1;
      v16 = v69;
      continue;
    }
    break;
  }
  v17 = v68;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  v124 = v68;
  if ( !v14 )
    goto LABEL_105;
  if ( !((__int64)(*((_QWORD *)v14 + 1) - *(_QWORD *)v14) >> 3) )
    __debugbreak();
  v71 = *(char **)v14;
  v119 = v14;
  n0xF_29 = n0x400;
  v120 = v69;
  n0x10_1 = *(_QWORD *)&SystemTime.wYear;
  v124 = v68;
LABEL_106:
  __asm { vzeroupper }
  sub_1402FDEC0(v71, (unsigned __int64)&v71[8 * n0x400], (__int64)(8 * n0x400) >> 3, v117);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  for ( n0x400_3 = 0; n0x400_3 < n0x400; ++n0x400_3 )
  {
    v76 = *(_QWORD *)&v71[8 * n0x400_3];
    if ( v74 == *(_QWORD *)(v76 + 8) )
    {
      if ( ++v73 == 1 )
        *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3 - 8] + 0x50LL) = 0;
      *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 0x50LL) = v73;
    }
    else
    {
      v73 = 0;
      *(_QWORD *)(v76 + 0x50) = -(__int64)(*(_QWORD *)(v76 + 0x50) != 0xFFFFFFFFFFFFFFFFuLL);
      v74 = *(_QWORD *)(*(_QWORD *)&v71[8 * n0x400_3] + 8LL);
    }
  }
  n0x8000 = 0x8000;
  n0x8000_2 = qword_149B3B230;
  n0x100000 = 0x100000;
  if ( qword_149B3B240 )
    n0x8000 = qword_149B3B240;
  n0x8000_1 = n0x8000;
  if ( qword_149B3B248 )
    n0x100000 = qword_149B3B248;
  n0x100000_1 = n0x100000;
  p_n0x8000 = (unsigned __int64 *)&n0x100000_1;
  if ( !byte_149924748 )
    p_n0x8000 = &n0x8000_1;
  if ( !qword_149B3B230 )
    n0x8000_2 = (_QWORD)(v17 + 1) << 0xA;
  if ( *p_n0x8000 < n0x8000_2 )
    n0x8000_2 = *p_n0x8000;
  if ( n0x8000_2 <= n0x8000 )
  {
    v82 = 0;
  }
  else
  {
    v81 = allocWithProfilerInfo_w(n0x8000_2);
    v82 = (const void *)v81;
    if ( v81 )
    {
      v83 = (char *)v81;
      goto LABEL_130;
    }
  }
  v84 = n0x8000_2 + 0xF;
  if ( n0x8000_2 + 0xF < n0x8000_2 )
    v84 = 0xFFFFFFFFFFFFFF0LL;
  v85 = alloca(v84 & 0xFFFFFFFFFFFFFFF0uLL);
  v83 = (char *)&v117;
LABEL_130:
  v86 = (__int64 (__fastcall *)(__int64, _QWORD, char *, __int64 *, char *, vraudio::AudioBuffer *, unsigned __int64, _QWORD *, unsigned __int64, __int64 *))qword_149B3B1F8;
  v87 = 1;
  *v83 = 0;
  v88 = 0;
  LODWORD(v122) = 0;
  v123[0] = 1;
  if ( v86 && qword_149B3B200 && byte_149924748 )
  {
    v87 = v86(v128, n4, v133, event_data_ptr, v132, __Val_0__, _Newcapacity, v146, n0x10_1, &a8);
    v123[0] = v87;
  }
  v89 = a8;
  if ( (a8 & 0xFFFFF) != 0 )
  {
    v90 = sub_140302340(
            *(_QWORD *)&FileTime,
            v128,
            (__int64)String,
            n4,
            event_data_ptr,
            v133,
            v132,
            __Val_0__,
            _Newcapacity,
            a7,
            v83,
            n0x8000_2,
            (int *)&v122,
            v87,
            &a8);
    v89 = a8;
    v88 = v90;
    v72 = v122;
  }
  if ( n2_125 == 1 && (v89 & 1) != 0 )
  {
    File = __acrt_iob_func(1u);
    fprintf(File, "%s %s\n", Buffer, v83);
    v89 = a8;
  }
  n2_126 = ::n2_126;
  if ( ::n2_126 == 1 && (v89 & 2) != 0 )
  {
    File_1 = __acrt_iob_func(::n2_126 + 1);
    fprintf(File_1, "%s %s\n", Buffer, v83);
    n2_126 = ::n2_126;
  }
  v83[v88] = 0;
  v94 = a8;
  v95 = (a8 & 1) != 0 && n2_125 == 2;
  v96 = (a8 & 2) != 0 && n2_126 == 2;
  if ( (a8 & 0xFFF18) != 0 || v95 || v96 )
  {
    p_n0x8000_1 = (unsigned __int64 *)&n0x100000_1;
    if ( !byte_149924748 )
      p_n0x8000_1 = &n0x8000_1;
    v98 = qword_149B3B238;
    if ( !qword_149B3B238 )
      v98 = v120 + v88 + ((_QWORD)(v124 + 4) << 9);
    n0x8000_3 = v98 + 0x80;
    if ( *p_n0x8000_1 < v98 + 0x80 )
      n0x8000_3 = *p_n0x8000_1;
    if ( n0x8000_3 <= n0x8000 )
    {
      Buffer_3 = 0;
    }
    else
    {
      Buffer_2 = allocWithProfilerInfo_w(n0x8000_3);
      Buffer_3 = (const void *)Buffer_2;
      if ( Buffer_2 )
      {
        Buffer_1 = (double *)Buffer_2;
        goto LABEL_166;
      }
    }
    v103 = n0x8000_3 + 0xF;
    if ( n0x8000_3 + 0xF < n0x8000_3 )
      v103 = 0xFFFFFFFFFFFFFF0LL;
    v104 = alloca(v103 & 0xFFFFFFFFFFFFFFF0uLL);
    Buffer_1 = (double *)&v117;
LABEL_166:
    v116 = v123[0];
    *(_BYTE *)Buffer_1 = 0;
    sub_140302E40(
      *(_QWORD *)&FileTime,
      v128,
      Buffer,
      String,
      n4,
      event_data_ptr,
      v133,
      v132,
      (__int64)__Val_0__,
      _Newcapacity,
      a7,
      (__int64)v71,
      n0xF_29,
      Buffer_1,
      n0x8000_3 - 0x80,
      (__int64)&v83[v72],
      v88 - v72,
      a8,
      v116);
    sub_1402A3D30(Buffer_3);
    v94 = a8;
  }
  v105 = byte_149B3AEA8;
  if ( byte_149B3AEA8 )
  {
    if ( (v94 & 1) != 0 )
    {
      Stream = __acrt_iob_func(1u);
      fflush(Stream);
      v94 = a8;
      v105 = byte_149B3AEA8;
    }
    if ( v105 )
    {
      if ( (v94 & 2) != 0 )
      {
        Stream_1 = __acrt_iob_func(2u);
        fflush(Stream_1);
      }
    }
  }
  sub_1402A3D30(v82);
  v108 = v141;
  if ( v141 )
  {
    v109 = (_QWORD **)*v141;
    **((_QWORD **)*v141 + 1) = 0;
    v110 = *v109;
    if ( *v109 )
    {
      do
      {
        n0xF_1 = v110[5];
        v112 = (_QWORD *)*v110;
        if ( n0xF_1 > 0xF )
        {
          v113 = (_QWORD *)v110[2];
          if ( n0xF_1 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v113 - v113[0xFFFFFFFF] - 8 > 0x1F )
              goto LABEL_190;
            v113 = (_QWORD *)v113[0xFFFFFFFF];
          }
          sub_1402A3D30(v113);
        }
        v110[4] = 0;
        v110[5] = 0xF;
        *((_BYTE *)v110 + 0x10) = 0;
        sub_1402A3D30(v110);
        v110 = v112;
      }
      while ( v112 );
    }
    sub_1402A3D30(*v108);
    sub_1402A3D30(v108);
  }
  v114 = v119;
  if ( v119 )
  {
    v115 = *(_QWORD **)v119;
    if ( *(_QWORD *)v119 )
    {
      if ( ((*((_QWORD *)v119 + 2) - (_QWORD)v115) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)v115 - v115[0xFFFFFFFF] - 8 > 0x1F )
LABEL_190:
          invalid_parameter_noinfo_noreturn();
        v115 = (_QWORD *)v115[0xFFFFFFFF];
      }
      sub_1402A3D30(v115);
      *(_QWORD *)v114 = 0;
      *((_QWORD *)v114 + 1) = 0;
      *((_QWORD *)v114 + 2) = 0;
    }
    sub_1402A3D30(v114);
  }
}

// --- End Function: sub_1403045C0 (0x1403045C0) ---

// --- Function: swprintf (0x140305E10) ---
int swprintf(wchar_t *Buffer, size_t Count, const wchar_t *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_1402A4380();
  result = _stdio_common_vsprintf(*v6 | 2LL, (char *)Buffer, Count, (const char *)Format, 0, va);
  if ( result < 0 )
    return 0xFFFFFFFF;
  return result;
}

// --- End Function: swprintf (0x140305E10) ---

// --- Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---
// Determines if an entity descriptor is valid and accessible. The descriptor's
// lower 48 bits encode the entity's base address or ID, and its higher 16 bits
// encode entity type and flags. The function performs the following checks: 1.
// Ensures the descriptor is not zero. 2. Derives an entity header pointer based on
// flags in the descriptor (potentially aligning the base address or using a fixed
// offset). 3. Verifies a type ID within the entity header (at offset +2) matches a
// part of the descriptor's flags (lower 12 bits of HIWORD). 4. Checks for a
// privileged or bypass state from thread-local storage or via
// `is_thread_privileged_or_bypass_mode`. 5. Returns true if: - The entity header's
// status field (at offset +4) is 2 AND the privileged/bypass state is active. OR -
// A more complex validation via `validate_entity_descriptor_detailed_access`
// succeeds. This function determines if an entity is valid for access or
// processing.
bool __fastcall is_entity_descriptor_valid_or_accessible(unsigned __int64 *entity_desc_ptr)
{
  unsigned __int64 entity_desc_val; // r9
  __int64 entity_base_addr_or_id; // r10
  unsigned __int64 entity_type_flags; // r9
  __int64 align_mask; // rax
  __int64 aligned_base_addr_or_id; // r10
  __int64 entity_header_ptr; // rbx
  bool is_privileged_or_bypass; // al

  entity_desc_val = *entity_desc_ptr;
  if ( !*entity_desc_ptr )
    return 0;
  entity_base_addr_or_id = entity_desc_val & 0xFFFFFFFFFFFFLL;
  entity_type_flags = HIWORD(entity_desc_val);
  if ( (entity_type_flags & 0xF000) != 0 )
  {
    align_mask = map_flag_to_mask(0x2000u);
    entity_header_ptr = aligned_base_addr_or_id & ~(align_mask - 1);
  }
  else
  {
    entity_header_ptr = entity_base_addr_or_id - 6;
  }
  if ( *(_WORD *)(entity_header_ptr + 2) != (entity_type_flags & 0xFFF) )
    return 0;
  if ( *(_BYTE *)(get_thread_context_ptr() + 0x12D) || (is_privileged_or_bypass = is_thread_privileged_or_bypass_mode()) )
    is_privileged_or_bypass = 1;
  return *(_WORD *)(entity_header_ptr + 4) == 2 && is_privileged_or_bypass
      || validate_entity_descriptor_detailed_access(entity_desc_ptr) != 0;
}

// --- End Function: is_entity_descriptor_valid_or_accessible (0x14030EC00) ---

// --- Function: sub_1403335B0 (0x1403335B0) ---
__int64 __fastcall sub_1403335B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x40);
}

// --- End Function: sub_1403335B0 (0x1403335B0) ---

// --- Function: sub_1403360E0 (0x1403360E0) ---
__int64 __fastcall sub_1403360E0(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *p_sub_1403E1870)(unsigned int, __int64, __int64); // rax

  sub_1403E30D0();
  if ( (dword_149B3D560 & 0x100000) != 0 )
  {
    p_sub_1403E1870 = (__int64 (__fastcall *)(unsigned int, __int64, __int64))sub_1403E15D0;
  }
  else
  {
    sub_1403E19B0();
    p_sub_1403E1870 = (__int64 (__fastcall *)(unsigned int, __int64, __int64))sub_1403E1870;
  }
  psub_1403360E0 = p_sub_1403E1870;
  return p_sub_1403E1870(a1, a2, a3);
}

// --- End Function: sub_1403360E0 (0x1403360E0) ---

// --- Function: sub_14033A860 (0x14033A860) ---
_QWORD *__fastcall sub_14033A860(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(__int64, char *, __int16 *); // rsi
  __int16 n0xFFFF; // ax
  __int64 v6; // rcx
  _QWORD *result; // rax
  __int16 n0xFFFF_1; // [rsp+40h] [rbp+8h] BYREF
  char v9; // [rsp+48h] [rbp+10h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF

  v4 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)a1 + 0x340LL);
  n0xFFFF = n0xFFFF_24;
  if ( n0xFFFF_24 == (__int16)0xFFFF )
  {
    n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                 + 0x10LL))(
                          pEngineComponentScheduler,
                          &v9,
                          "IEntityPhysicalProxy");
    n0xFFFF_24 = n0xFFFF;
  }
  n0xFFFF_1 = n0xFFFF;
  v6 = *(_QWORD *)v4(a1, &v10, &n0xFFFF_1);
  result = a2;
  *a2 = v6;
  return result;
}

// --- End Function: sub_14033A860 (0x14033A860) ---

// --- Function: sub_14035B160 (0x14035B160) ---
void **__fastcall sub_14035B160(void **a1, const void **a2)
{
  size_t Size; // rsi
  _DWORD *v5; // rax

  *a1 = (char *)&qword_149B3B33C + 4;
  Size = *((int *)*a2 + 0xFFFFFFFE);
  if ( (_DWORD)Size )
  {
    v5 = (_DWORD *)allocWithProfilerInfo(Size + 9, 0);
    *a1 = v5 + 2;
    *v5 = Size;
    v5[1] = Size;
    *((_BYTE *)*a1 + Size) = 0;
    if ( *a1 != *a2 )
      memcpy(*a1, *a2, Size);
  }
  return a1;
}

// --- End Function: sub_14035B160 (0x14035B160) ---

// --- Function: sub_140370740 (0x140370740) ---
__int64 __fastcall sub_140370740(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 0xE0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)a1 = 6;
  *(_QWORD *)(a1 + 0x38) = 0x8000000000000000uLL;
  result = a1;
  *(_DWORD *)(a1 + 0x10) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x28) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x34) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 4) = 0x80000000;
  *(_DWORD *)(a1 + 8) = 0x80000000;
  *(_DWORD *)(a1 + 0x60) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x64) = 0xFFBFFFFF;
  *(_QWORD *)(a1 + 0x70) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x78) = 0x80000000;
  *(_QWORD *)(a1 + 0x80) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x90) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x68) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x6C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x88) = 0x80000000;
  *(_DWORD *)(a1 + 0x9C) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xA4) = 0x80000000;
  *(_QWORD *)(a1 + 0xA8) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0xB0) = 0x80000000;
  *(_DWORD *)(a1 + 0xB4) = 0x80000000;
  *(_DWORD *)(a1 + 0xB8) = 0x80000000;
  *(_DWORD *)(a1 + 0xBC) = 0x80000000;
  *(_DWORD *)(a1 + 0xD0) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xD4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xD8) = 0xFFBFFFFF;
  *(_QWORD *)(a1 + 0xF0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_DWORD *)(a1 + 0x2C) = 0x80000000;
  *(_DWORD *)(a1 + 0xF8) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0xE8) = 0x80000000;
  *(_OWORD *)(a1 + 0xC0) = xmmword_1481AD6E0;
  *(_DWORD *)(a1 + 0x30) = 0;
  *(_DWORD *)(a1 + 0xC) = 1;
  *(_DWORD *)(a1 + 0xA0) = 0;
  *(_QWORD *)(a1 + 0x50) = 0;
  *(_QWORD *)(a1 + 0x40) = 0;
  *(_QWORD *)(a1 + 0x58) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x48) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x100) = 0;
  *(_DWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x110) = 0;
  return result;
}

// --- End Function: sub_140370740 (0x140370740) ---

// --- Function: sub_140370D10 (0x140370D10) ---
// // Decrements a reference count associated with a managed object and //
// deallocates the object's memory if the reference count is still positive. //
// This pattern is characteristic of shared pointer or reference-counted // memory
// management, where the reference count is stored in a control block // located
// just before the actual data pointed to by *a1. // // Parameters: //
// pManagedObjectPtr: A pointer to a QWORD, where the QWORD itself points //
// to the managed data. The reference count is expected //                      at
// an offset of -8 bytes from this data pointer.
void __fastcall sub_140370D10(_QWORD *pManagedObjectPtr)
{
  int *v1; // rcx

  v1 = (int *)(*pManagedObjectPtr - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_140370F70 (0x140370F70) ---
void __fastcall sub_140370F70(__int64 a1)
{
  sub_1402A3D30(*(const void **)(a1 + 0x10));
}

// --- End Function: sub_140370F70 (0x140370F70) ---

// --- Function: sub_1403785B0 (0x1403785B0) ---
__int64 *__fastcall sub_1403785B0(__int64 *a1, __int64 *a2)
{
  __int64 v3; // rcx
  __int64 *result; // rax

  v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  if ( v3 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x10LL))(v3);
    result = a1;
    *a2 = 0;
  }
  else
  {
    result = a1;
    *a2 = 0;
  }
  return result;
}

// --- End Function: sub_1403785B0 (0x1403785B0) ---

// --- Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---
bool __fastcall AssetMeta::HasActorSubresource(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int16 n4; // cx

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v3 = (*(__int64 (__fastcall **)(char *, __int64, _QWORD))(*(_QWORD *)pEntitySystem + 0x128LL))(
         pEntitySystem,
         v1 & 0xFFFFFFFFFFFFLL,
         0);
  n4 = *(_WORD *)(v3 + 4);
  if ( n4 == 4 || *(_WORD *)(v3 + 2) != (HIWORD(v1) & 0xFFF) )
    return 0;
  if ( n4 != 2 || *(_QWORD *)get_thread_context_ptr() )
    return sub_140391F30(a1) != 0;
  return 1;
}

// --- End Function: AssetMeta::HasActorSubresource (0x14037FBB0) ---

// --- Function: sub_14037FC70 (0x14037FC70) ---
const ULONG_PTR *__fastcall sub_14037FC70(__int64 a1)
{
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax

  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)a1 )
    return *(const ULONG_PTR **)a1;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_14037FC70 (0x14037FC70) ---

// --- Function: HIWORD_w (0x14037FC90) ---
bool __fastcall HIWORD_w(_QWORD *a1)
{
  return *a1 && *(_QWORD *)((*a1 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(*a1);
}

// --- End Function: HIWORD_w (0x14037FC90) ---

// --- Function: sub_1403B3E60 (0x1403B3E60) ---
const char *sub_1403B3E60()
{
  return "TraceContext";
}

// --- End Function: sub_1403B3E60 (0x1403B3E60) ---

// --- Function: sub_1403C33A0 (0x1403C33A0) ---
__int64 __fastcall sub_1403C33A0(__int64 a1, unsigned __int32 a2, const char *a3, char a4)
{
  if ( a4 && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return sub_1403C3410(a1, a2, a3);
  else
    return sub_1403C3680(a1, a2, a3);
}

// --- End Function: sub_1403C33A0 (0x1403C33A0) ---

// --- Function: sub_1403C3410 (0x1403C3410) ---
__int64 __fastcall sub_1403C3410(__int64 a1, unsigned __int32 a2, const char *a3)
{
  __int64 p_profiler_system; // r15
  __int64 thread_context_ptr; // rax
  __int64 v8; // rsi
  unsigned int v9; // r14d
  unsigned __int32 v10; // eax
  __int64 thread_context_ptr_1; // rax
  int v12; // edx
  bool v13; // zf
  signed __int32 v14; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  unsigned __int32 v16; // ett
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int n0x1600; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+34h] [rbp-75h]
  int n2; // [rsp+3Ch] [rbp-6Dh]
  unsigned __int64 v21; // [rsp+40h] [rbp-69h]
  unsigned __int64 v22; // [rsp+48h] [rbp-61h]
  __int64 v23; // [rsp+50h] [rbp-59h]
  __int64 v24; // [rsp+58h] [rbp-51h]
  int n0x1600_1; // [rsp+80h] [rbp-29h] BYREF
  __int64 v26; // [rsp+84h] [rbp-25h]
  int n2_1; // [rsp+8Ch] [rbp-1Dh]
  unsigned __int64 v28; // [rsp+90h] [rbp-19h]
  unsigned __int64 v29; // [rsp+98h] [rbp-11h]
  __int64 v30; // [rsp+A0h] [rbp-9h]
  __int64 v31; // [rsp+A8h] [rbp-1h]
  _BYTE v32[16]; // [rsp+D0h] [rbp+27h] BYREF
  char v33; // [rsp+118h] [rbp+6Fh] BYREF

  p_profiler_system = ::p_profiler_system;
  thread_context_ptr = get_thread_context_ptr();
  v8 = *(_QWORD *)thread_context_ptr;
  v9 = *(_DWORD *)(*(_QWORD *)thread_context_ptr + 0x11CLL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
    p_profiler_system,
    v32,
    &v33);
  do
  {
    while ( 1 )
    {
      v10 = a2;
      if ( (a2 & 1) == 0 )
        break;
      v12 = v9 << 0x10;
      if ( (a2 & 0xFFFF0000) != 0 )
      {
        *(_DWORD *)(v8 + 0x124) = HIWORD(a2);
        v14 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v12 | (unsigned __int16)a2, a2);
        v13 = a2 == v14;
        a2 = v14;
        if ( v13 )
        {
          n0x1600 = 0x1600;
          v19 = 1;
          n2 = 2;
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v21 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600,
            &word_149B3E374,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x91);
          p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600) = word_149B3E374;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(p_profiler_system, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v22 = __rdtsc();
          qword_149B4B878(&n0x1600);
        }
      }
      else
      {
        *(_DWORD *)(v8 + 0x124) = 0xFFFFFFFF;
        v16 = a2;
        a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | v12, a2);
        if ( v16 == a2 )
        {
          n0x1600_1 = 0x1600;
          v26 = 1;
          n2_1 = 2;
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v28 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E378,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0xB2);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E378;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)p_profiler_system + 0xE8LL))(p_profiler_system, v9);
          a2 = *(_DWORD *)a1;
          v9 = *(_DWORD *)(v8 + 0x11C);
          v29 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    a2 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 | 1, a2);
  }
  while ( v10 != a2 );
  thread_context_ptr_1 = get_thread_context_ptr();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(thread_context_ptr_1 + 0x20);
  return thread_context_ptr_1;
}

// --- End Function: sub_1403C3410 (0x1403C3410) ---

// --- Function: sub_1403C3680 (0x1403C3680) ---
__int64 __fastcall sub_1403C3680(__int64 a1, signed __int32 a2, const char *a3)
{
  char v3; // r14
  signed __int32 v7; // ecx
  bool v8; // zf
  signed __int32 v9; // eax
  __int64 thread_context_ptr; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  signed __int32 v12; // esi
  signed __int32 v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  signed __int32 v15; // [rsp+38h] [rbp-69h] BYREF
  signed __int32 v16[3]; // [rsp+3Ch] [rbp-65h] BYREF
  int n0x1600; // [rsp+48h] [rbp-59h] BYREF
  __int64 v18; // [rsp+4Ch] [rbp-55h]
  int n2; // [rsp+54h] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+58h] [rbp-49h]
  unsigned __int64 v21; // [rsp+60h] [rbp-41h]
  __int64 v22; // [rsp+68h] [rbp-39h]
  __int64 v23; // [rsp+70h] [rbp-31h]
  int n0x1600_1; // [rsp+98h] [rbp-9h] BYREF
  __int64 v25; // [rsp+9Ch] [rbp-5h]
  int n2_1; // [rsp+A4h] [rbp+3h]
  unsigned __int64 v27; // [rsp+A8h] [rbp+7h]
  unsigned __int64 v28; // [rsp+B0h] [rbp+Fh]
  __int64 v29; // [rsp+B8h] [rbp+17h]
  __int64 v30; // [rsp+C0h] [rbp+1Fh]

  v3 = 0;
  do
  {
    while ( (a2 & 1) != 0 )
    {
      if ( v3 )
      {
        n0x1600 = 0x1600;
        v18 = 1;
        n2 = 2;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v20 = __rdtsc();
        isProfileFunctionsInitialized(
          &n0x1600,
          &word_149B3E36C,
          "Wait For Critical Section",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
          0x38);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        HIWORD(n0x1600) = word_149B3E36C;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v15 = a2;
        qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
        a2 = *(_DWORD *)a1;
        v21 = __rdtsc();
        qword_149B4B878(&n0x1600);
      }
      else
      {
        v12 = a2 + 2;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)a1, a2 + 2, a2);
        v8 = a2 == v13;
        a2 = v13;
        if ( v8 )
        {
          v3 = 1;
          n0x1600_1 = 0x1600;
          v25 = 1;
          n2_1 = 2;
          v28 = 0;
          v29 = 0;
          v30 = 0;
          v27 = __rdtsc();
          isProfileFunctionsInitialized(
            &n0x1600_1,
            &word_149B3E370,
            "Wait For Critical Section",
            "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigCriticalSection.cpp",
            0x50);
          p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
          HIWORD(n0x1600_1) = word_149B3E370;
          if ( *(_QWORD *)(a1 + 8) )
            p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
          qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
          qword_149B4B8B0("Caller: %s", a3);
          v16[0] = v12;
          qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
          a2 = *(_DWORD *)a1;
          v28 = __rdtsc();
          qword_149B4B878(&n0x1600_1);
        }
      }
    }
    v7 = (a2 | 1) - 2;
    if ( !v3 )
      v7 = a2 | 1;
    v9 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v7, a2);
    v8 = a2 == v9;
    a2 = v9;
  }
  while ( !v8 );
  thread_context_ptr = get_thread_context_ptr();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(thread_context_ptr + 0x20);
  return thread_context_ptr;
}

// --- End Function: sub_1403C3680 (0x1403C3680) ---

// --- Function: sub_1403C3960 (0x1403C3960) ---
char **__fastcall sub_1403C3960(char **a1)
{
  char *v1; // r9
  char v3; // al
  char v4; // cl

  v1 = *a1;
  v3 = **a1;
  if ( v3 )
  {
    do
    {
      ++v1;
      v4 = v3 + 0x20;
      if ( (unsigned __int8)(v3 - 0x41) > 0x19u )
        v4 = v3;
      v1[0xFFFFFFFF] = v4;
      v3 = *v1;
    }
    while ( *v1 );
  }
  return a1;
}

// --- End Function: sub_1403C3960 (0x1403C3960) ---

// --- Function: sub_1403DB1F0 (0x1403DB1F0) ---
const ULONG_PTR *__fastcall sub_1403DB1F0(__int64 a1, unsigned __int32 a2)
{
  signed __int32 v4; // ebx
  int v5; // edx
  signed __int32 v6; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+58h] [rbp+10h] BYREF
  __int64 v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2 & 0xFFFFFFFE;
    if ( (a2 & 0xFFFE) == 0 && (a2 & 0xFFFF0000) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
        p_profiler_system,
        &v10,
        &v9);
      v4 = (unsigned __int16)v4;
      v5 = *(_DWORD *)(((((unsigned __int64)a2 >> 0x10) & (unsigned int)(v9 - 1)) << 9) + v10 + 0x124);
      if ( v5 != 0xFFFFFFFF )
        v4 = (v5 << 0x10) | (unsigned __int16)v4;
    }
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v4, a2);
    if ( a2 == v6 )
      break;
    a2 = v6;
  }
  if ( (a2 & 0xFFFE) != 0 )
  {
    qword_149B3B488(a1);
  }
  else if ( (a2 & 0xFFFF0000) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)p_profiler_system + 0xF8LL))(
      p_profiler_system,
      &v11,
      &v8);
    *(_DWORD *)(((HIWORD(a2) & (unsigned __int64)(unsigned int)(v8 - 1)) << 9) + v11 + 0x11C) = (unsigned __int16)(HIWORD(a2) + v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
  }
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(a1 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_1403DB1F0 (0x1403DB1F0) ---

// --- Function: sub_1403DCD60 (0x1403DCD60) ---
signed __int64 __fastcall sub_1403DCD60(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        char a6)
{
  if ( a6 && *(_BYTE *)(get_thread_context_ptr() + 0x1C) && gEnv )
    return rw_lock_acquire_write_lock_profiled(a1, a2, a3, a4, a5);
  else
    return rw_lock_acquire_write_lock_unprofiled(a1, a2, a3, a4, a5);
}

// --- End Function: sub_1403DCD60 (0x1403DCD60) ---

// --- Function: rw_lock_handle_write_release_contention (0x1403DD380) ---
// Manages complex state transitions during write lock release, particularly when
// contention or specific lock flags are present. It continuously attempts to
// atomically update the lock state using `_InterlockedCompareExchange64`.
// Depending on the resulting lock state, it may trigger further release operations
// (e.g., waking waiting threads via `qword_149B3B490` or `qword_149B3B488`) or
// update thread context information related to lock ownership and counts. Finally,
// it resets the lock owner pointer at `p_rw_lock_state + 8` to a default/null
// value.
const ULONG_PTR *__fastcall rw_lock_handle_write_release_contention(
        __int64 p_rw_lock_state,
        unsigned __int64 current_lock_value)
{
  signed __int64 new_lock_value; // rdi
  unsigned int thread_context_owner_id; // edx
  signed __int64 current_lock_value_1; // rax
  __int64 p_profiler_system; // rdi
  __int64 thread_context_ptr_1; // r8
  int thread_context_owner_id_2; // ecx
  __int64 thread_context_ptr_2; // r8
  unsigned __int64 thread_id_high_word; // rbx
  const ULONG_PTR *default_lock_owner_ptr; // rax
  int thread_context_info_1; // [rsp+70h] [rbp+8h] BYREF
  int thread_context_info_2; // [rsp+78h] [rbp+10h] BYREF
  __int64 thread_context_ptr_3; // [rsp+80h] [rbp+18h] BYREF
  __int64 thread_context_ptr_4; // [rsp+88h] [rbp+20h] BYREF

  while ( 1 )
  {
    new_lock_value = current_lock_value & 0xFFFFFFFFFFD003FFuLL;
    if ( (current_lock_value & 0xFFFF00100000LL) != 0 )
    {
      new_lock_value = current_lock_value & 0xFFFF0000FFC003FFuLL;
    }
    else if ( (current_lock_value & 0xFFC003FF) == 0 && (current_lock_value & 0xFFFF000000000000uLL) != 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_4,
        &thread_context_info_2);
      new_lock_value = current_lock_value & 0xFFFFFFD003FFLL;
      thread_context_owner_id = *(_DWORD *)(((HIWORD(current_lock_value) & (unsigned int)(thread_context_info_2 - 1)) << 9)
                                          + thread_context_ptr_4
                                          + 0x124);
      if ( thread_context_owner_id != 0xFFFFFFFF )
        new_lock_value |= (unsigned __int64)thread_context_owner_id << 0x30;
    }
    current_lock_value_1 = _InterlockedCompareExchange64(
                             (volatile signed __int64 *)p_rw_lock_state,
                             new_lock_value,
                             current_lock_value);
    if ( current_lock_value == current_lock_value_1 )
      break;
    current_lock_value = current_lock_value_1;
  }
  if ( (current_lock_value & 0x3FF) != 0 )
  {
    if ( (current_lock_value & 0x100000) != 0 )
      qword_149B3B490(p_rw_lock_state);
    if ( (current_lock_value & 0xFFFF00000000LL) != 0 )
    {
      p_profiler_system = ::p_profiler_system;
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
        ::p_profiler_system,
        &thread_context_ptr_3,
        &thread_context_info_1);
      thread_context_ptr_1 = thread_context_ptr_3
                           + ((WORD2(current_lock_value) & (unsigned __int64)(unsigned int)(thread_context_info_1 - 1)) << 9);
      LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_1 + 0x124);
      *(_DWORD *)(thread_context_ptr_1 + 0x11C) = (unsigned __int16)(WORD2(current_lock_value) + thread_context_info_1);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      while ( (_DWORD)current_lock_value != 0xFFFFFFFF )
      {
        thread_context_owner_id_2 = (unsigned __int16)(current_lock_value + thread_context_info_1);
        thread_context_ptr_2 = thread_context_ptr_3
                             + ((unsigned __int64)((unsigned int)current_lock_value & (thread_context_info_1 - 1)) << 9);
        LODWORD(current_lock_value) = *(_DWORD *)(thread_context_ptr_2 + 0x124);
        *(_DWORD *)(thread_context_ptr_2 + 0x11C) = thread_context_owner_id_2;
        (*(void (__fastcall **)(__int64))(*(_QWORD *)p_profiler_system + 0xD8LL))(p_profiler_system);
      }
    }
  }
  else if ( (current_lock_value & 0xFFC00000) != 0 )
  {
    qword_149B3B488(p_rw_lock_state);
  }
  else if ( (current_lock_value & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)::p_profiler_system + 0xF8LL))(
      ::p_profiler_system,
      &thread_context_ptr_3,
      &thread_context_info_1);
    thread_id_high_word = HIWORD(current_lock_value);
    *(_DWORD *)(((unsigned __int64)((unsigned int)thread_id_high_word & (thread_context_info_1 - 1)) << 9)
              + thread_context_ptr_3
              + 0x11C) = (unsigned __int16)(thread_id_high_word + thread_context_info_1);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::p_profiler_system + 0xD8LL))(
      ::p_profiler_system,
      (unsigned int)thread_id_high_word);
  }
  default_lock_owner_ptr = &p_p_p_p_p_p_p_p_p_p_p_Source;
  *(_QWORD *)(p_rw_lock_state + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
  return default_lock_owner_ptr;
}

// --- End Function: rw_lock_handle_write_release_contention (0x1403DD380) ---

// --- Function: allocWithProfilerInfo_ww (0x1403E4B50) ---
__int64 allocWithProfilerInfo_ww()
{
  return allocWithProfilerInfo_w(1u);
}

// --- End Function: allocWithProfilerInfo_ww (0x1403E4B50) ---

// --- Function: sub_1403E4B90 (0x1403E4B90) ---
_QWORD *__fastcall sub_1403E4B90(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  _BYTE *v4; // rbx
  unsigned __int64 v5; // rcx
  size_t Size; // rsi
  void *v8; // rax

  result = (_QWORD *)allocWithProfilerInfo_w(0x18u);
  v3 = result;
  if ( result )
  {
    result[2] = 0;
    *result = *a1;
    v4 = (_BYTE *)a1[1];
    sub_1402A3D30(0);
    v5 = 0xFFFFFFFFFFFFFFFFuLL;
    while ( v4[++v5] != 0 )
      ;
    Size = v5 + 1;
    v8 = (void *)allocWithProfilerInfo_w(v5 + 1);
    v3[2] = v8;
    v3[1] = v8;
    if ( Size )
    {
      if ( v8 )
      {
        if ( v4 )
        {
          memcpy(v8, v4, Size);
          return v3;
        }
        memset(v8, 0, Size);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return v3;
  }
  return result;
}

// --- End Function: sub_1403E4B90 (0x1403E4B90) ---

// --- Function: sub_1403E4E60 (0x1403E4E60) ---
void __fastcall sub_1403E4E60(const void *ptr_to_free)
{
  sub_1402A3D30(ptr_to_free);
}

// --- End Function: sub_1403E4E60 (0x1403E4E60) ---

// --- Function: sub_1403E4E80 (0x1403E4E80) ---
void __fastcall sub_1403E4E80(const void **a1)
{
  if ( a1 )
  {
    sub_1402A3D30(a1[2]);
    sub_1402A3D30(a1);
  }
}

// --- End Function: sub_1403E4E80 (0x1403E4E80) ---

// --- Function: sub_1403E6750 (0x1403E6750) ---
unsigned __int64 __fastcall sub_1403E6750(unsigned __int64 *a1)
{
  if ( is_entity_descriptor_valid_or_accessible(a1) )
    return *a1 & 0xFFFFFFFFFFFFLL;
  else
    return 0;
}

// --- End Function: sub_1403E6750 (0x1403E6750) ---

// --- Function: sub_1403E7650 (0x1403E7650) ---
bool __fastcall sub_1403E7650(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // r8
  signed __int64 v4; // r8
  int v5; // ecx
  int v6; // edx

  v2 = *(unsigned __int8 **)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 8);
  if ( v2 == v3 )
    return 1;
  if ( !v2 || !v3 )
    return 0;
  v4 = v3 - v2;
  do
  {
    v5 = v2[v4];
    v6 = *v2 - v5;
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return !v6;
}

// --- End Function: sub_1403E7650 (0x1403E7650) ---

// --- Function: sub_1403E77F0 (0x1403E77F0) ---
char __fastcall sub_1403E77F0(__int64 a1, _BYTE *a2)
{
  unsigned int n0x10; // r8d
  __int64 v3; // rcx

  n0x10 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( a2[v3] == *a2 )
  {
    ++n0x10;
    ++a2;
    if ( n0x10 >= 0x10 )
      return 1;
  }
  return 0;
}

// --- End Function: sub_1403E77F0 (0x1403E77F0) ---

// --- Function: sub_1403EB0E0 (0x1403EB0E0) ---
__int64 __fastcall sub_1403EB0E0(__int64 a1, _BYTE *a2, int a3)
{
  const char *p_null; // r8

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  return sub_140300D10(a2, a3, (__int64)p_null, 1);
}

// --- End Function: sub_1403EB0E0 (0x1403EB0E0) ---

// --- Function: sub_1403EB240 (0x1403EB240) ---
__int64 __fastcall sub_1403EB240(unsigned __int8 *a1, __int64 a2, unsigned __int64 n12_1)
{
  int v3; // edi
  int n0xC; // ebx
  int v8; // eax
  void *v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  void *v13; // rcx
  int v14; // eax
  _WORD *v15; // rax

  v3 = 0;
  n0xC = 0;
  if ( (int)n12_1 > 0 )
  {
    if ( n12_1 <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      if ( a2 )
      {
        *(double *)a2 = 0x496563617254227BLL;
        *(_DWORD *)(a2 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC = 0xC;
      if ( (int)n12_1 <= 0xC )
        goto LABEL_52;
    }
    v8 = sub_1404F4760(a1, (_BYTE *)((unsigned int)n0xC + a2), n12_1 - (unsigned int)n0xC);
    if ( v8 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v8;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x13 )
    {
      v3 = 1;
    }
    else
    {
      v9 = (void *)(a2 + n0xC);
      if ( v9 )
      {
        qmemcpy(v9, "\",\"TraceParentId\":\"", 0x13);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x13;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v10 = sub_1404F4100(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v10 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v10;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0xC )
    {
      v3 = 1;
    }
    else
    {
      v11 = a2 + n0xC;
      if ( v11 )
      {
        *(double *)v11 = 0x496E617053222C22LL;
        *(_DWORD *)(v11 + 8) = 0x223A2264;
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0xC;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v12 = sub_1404F4350(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v12 < 0 )
    {
      v3 = 1;
    }
    else
    {
      n0xC += v12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    if ( n12_1 - n0xC <= 0x12 )
    {
      v3 = 1;
    }
    else
    {
      v13 = (void *)(a2 + n0xC);
      if ( v13 )
      {
        qmemcpy(v13, "\",\"ParentSpanId\":\"", 0x12);
      }
      else
      {
        *errno() = 0x16;
        invalid_parameter_noinfo();
      }
      n0xC += 0x12;
      if ( n0xC >= (int)n12_1 )
        goto LABEL_52;
    }
    v14 = sub_1404F3FB0(a1, (_BYTE *)(n0xC + a2), n12_1 - n0xC);
    if ( v14 < 0 )
    {
      v3 = 1;
      goto LABEL_46;
    }
    n0xC += v14;
    if ( n0xC < (int)n12_1 )
    {
LABEL_46:
      if ( n12_1 - n0xC <= 2 )
      {
        v3 = 1;
      }
      else
      {
        v15 = (_WORD *)(a2 + n0xC);
        if ( v15 )
        {
          *v15 = 0x7D22;
        }
        else
        {
          *errno() = 0x16;
          invalid_parameter_noinfo();
        }
        n0xC += 2;
      }
    }
  }
LABEL_52:
  if ( v3 )
    return 0xFFFFFFFF;
  return (unsigned int)n0xC;
}

// --- End Function: sub_1403EB240 (0x1403EB240) ---

// --- Function: sub_1403EB580 (0x1403EB580) ---
__int64 __fastcall sub_1403EB580(__int64 a1, _BYTE *a2, size_t Size_1, __int64 a4, char a5)
{
  const char *p_null; // rdx
  __int64 result; // rax
  size_t Size; // rbx

  p_null = "null";
  if ( *(_QWORD *)(a1 + 8) )
    p_null = *(const char **)(a1 + 8);
  if ( a5 )
    return sub_140300D10(a2, Size_1, (__int64)p_null, 0);
  result = 0xFFFFFFFFFFFFFFFFuLL;
  Size = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++Size;
  while ( p_null[Size] );
  if ( Size < Size_1 )
  {
    if ( Size )
    {
      if ( a2 )
      {
        if ( p_null )
        {
          memcpy(a2, p_null, Size);
          return (unsigned int)Size;
        }
        memset(a2, 0, Size_1);
      }
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
    return (unsigned int)Size;
  }
  return result;
}

// --- End Function: sub_1403EB580 (0x1403EB580) ---

// --- Function: sub_1403EB6A0 (0x1403EB6A0) ---
// attributes: thunk
__int64 __fastcall sub_1403EB6A0(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 n0x21)
{
  return sub_1404F4760(a1, a2, n0x21);
}

// --- End Function: sub_1403EB6A0 (0x1403EB6A0) ---

// --- Function: sub_140452E50 (0x140452E50) ---
__int64 __fastcall sub_140452E50(__int64 a1, _DWORD *a2, char a3)
{
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = a3;
  *(_DWORD *)a1 = *a2;
  return a1;
}

// --- End Function: sub_140452E50 (0x140452E50) ---

// --- Function: sub_1404558D0 (0x1404558D0) ---
__int64 __fastcall sub_1404558D0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rcx
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  int v6; // eax
  int v7; // ebx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdx

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2[2];
  *(_OWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x20) = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
  v3 = a1 + 0x20;
  v4 = (__int64)((unsigned __int128)((__int64)(a2[0x35] - a2[0x34]) * (__int128)0x4924924924924925LL) >> 0x40) >> 4;
  v5 = (v4 >> 0x3F) + v4;
  v6 = *(_DWORD *)(((unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL) - 4) & 0x7FFFFFFF;
  if ( (int)v5 <= v6 )
  {
    sub_140504650(v3, v5, 0);
    return a1;
  }
  v7 = v5 - v6;
  sub_140504650(v3, v5, 0);
  v8 = *(_QWORD *)(a1 + 0x20);
  v9 = *(unsigned int *)(v8 - 4);
  LODWORD(v9) = v9 & 0x7FFFFFFF;
  v10 = v8 + 0x18 * (v9 - v7);
  v11 = v10 + 0x18LL * v7;
  if ( v10 == v11 )
    return a1;
  do
  {
    *(_OWORD *)v10 = *(_OWORD *)(a1 + 8);
    *(double *)(v10 + 0x10) = *(double *)(a1 + 0x18);
    v10 += 0x18;
  }
  while ( v10 != v11 );
  return a1;
}

// --- End Function: sub_1404558D0 (0x1404558D0) ---

// --- Function: sub_140488D30 (0x140488D30) ---
__int64 __fastcall sub_140488D30(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  __int64 v3; // rax
  volatile signed __int32 *v7; // rbx
  __int64 v8; // r8
  __int64 v9; // r10
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  __int64 v12; // r9
  __int64 result; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  volatile signed __int32 *v16; // rcx
  volatile signed __int32 *v17; // rbx
  __int64 v18; // [rsp+20h] [rbp-48h] BYREF
  __int128 v19; // [rsp+28h] [rbp-40h]
  __int64 v20; // [rsp+38h] [rbp-30h]
  char v21; // [rsp+70h] [rbp+8h] BYREF

  v3 = a3[1];
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)(v3 + 8));
  v7 = (volatile signed __int32 *)a3[1];
  v18 = *a2;
  v19 = 0;
  if ( v7 )
  {
    *(_QWORD *)&v19 = *a3;
    *((_QWORD *)&v19 + 1) = v7;
    _InterlockedIncrement(v7 + 3);
    if ( _InterlockedExchangeAdd(v7 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
      if ( _InterlockedExchangeAdd(v7 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8LL))(v7);
    }
  }
  v8 = *a1;
  v9 = *a2;
  v10 = a1[1] - *a1;
  v20 = *a2;
  v11 = v10 / 0x18;
  while ( (__int64)v11 > 0 )
  {
    v12 = v8 + 0x18 * (v11 >> 1);
    if ( *(_DWORD *)v12 < (unsigned int)v9
      || *(_DWORD *)(v8 + 0x18 * (v11 >> 1)) == (_DWORD)v9 && *(_BYTE *)(v12 + 4) < BYTE4(v20) )
    {
      v8 = v12 + 0x18;
      v11 += 0xFFFFFFFFFFFFFFFFuLL - (v11 >> 1);
    }
    else
    {
      v11 >>= 1;
    }
  }
  if ( v8 != a1[1] && *(_DWORD *)v8 == *(_DWORD *)a2 && *(_BYTE *)(v8 + 4) == *((_BYTE *)a2 + 4) )
  {
    result = a3[1];
    v14 = 0;
    v15 = 0;
    if ( result )
    {
      v14 = *a3;
      _InterlockedIncrement((volatile signed __int32 *)(result + 0xC));
      v15 = result;
    }
    *(_QWORD *)(v8 + 8) = v14;
    v16 = *(volatile signed __int32 **)(v8 + 0x10);
    *(_QWORD *)(v8 + 0x10) = v15;
    if ( v16 )
    {
      result = (unsigned int)_InterlockedExchangeAdd(v16 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v16 + 8LL))(v16);
    }
  }
  else
  {
    result = ((__int64 (__fastcall *)(__int64 *, char *, __int64, __int64 *))sub_14044BCB0)(a1, &v21, v8, &v18);
  }
  if ( *((_QWORD *)&v19 + 1) )
  {
    result = (unsigned int)_InterlockedExchangeAdd(
                             (volatile signed __int32 *)(*((_QWORD *)&v19 + 1) + 0xCLL),
                             0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      result = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)&v19 + 1) + 8LL))(*((_QWORD *)&v19 + 1));
  }
  v17 = (volatile signed __int32 *)a3[1];
  if ( v17 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v17 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v17)(v17);
      if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v17 + 8LL))(v17);
    }
  }
  return result;
}

// --- End Function: sub_140488D30 (0x140488D30) ---

// --- Function: sub_1404AA480 (0x1404AA480) ---
_OWORD *__fastcall sub_1404AA480(__int64 *a1, _OWORD *a2, __int64 *a3)
{
  __int64 v4; // r9
  __int64 v5; // r10
  unsigned __int64 v7; // rdx
  __int64 v8; // r8
  __int64 v9; // rdx
  signed __int32 v10; // eax
  signed __int32 v11; // ett
  __int128 v12; // xmm0
  _OWORD *result; // rax
  __int128 v14; // [rsp+20h] [rbp-58h]
  __int64 v15; // [rsp+40h] [rbp-38h]

  v4 = *a1;
  v5 = *a3;
  v15 = *a3;
  v7 = (a1[1] - *a1) / 0x18;
  while ( (__int64)v7 > 0 )
  {
    v8 = v4 + 0x18 * (v7 >> 1);
    if ( *(_DWORD *)v8 < (unsigned int)v5
      || *(_DWORD *)(v4 + 0x18 * (v7 >> 1)) == (_DWORD)v5 && *(_BYTE *)(v8 + 4) < BYTE4(v15) )
    {
      v4 = v8 + 0x18;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
    else
    {
      v7 >>= 1;
    }
  }
  if ( v4 != a1[1] && *(_DWORD *)v4 == *(_DWORD *)a3 && *(_BYTE *)(v4 + 4) == *((_BYTE *)a3 + 4) )
  {
    v9 = *(_QWORD *)(v4 + 0x10);
    v14 = 0;
    if ( v9 )
    {
      v10 = *(_DWORD *)(v9 + 8);
      if ( v10 )
      {
        while ( 1 )
        {
          v11 = v10;
          v10 = _InterlockedCompareExchange((volatile signed __int32 *)(v9 + 8), v10 + 1, v10);
          if ( v11 == v10 )
            break;
          if ( !v10 )
          {
            v12 = 0;
            goto LABEL_19;
          }
        }
        v14 = *(_OWORD *)(v4 + 8);
      }
    }
    v12 = v14;
  }
  else
  {
    v12 = 0;
  }
LABEL_19:
  result = a2;
  *a2 = v12;
  return result;
}

// --- End Function: sub_1404AA480 (0x1404AA480) ---

// --- Function: sub_1404B3EA0 (0x1404B3EA0) ---
_QWORD *sub_1404B3EA0()
{
  __int64 v0; // rbx
  _QWORD *result; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 n0x10; // rcx
  _QWORD *v5; // rax
  _QWORD *ThreadLocalStoragePointer; // rax
  __int64 TlsIndex; // rcx
  __int64 v8; // rcx
  int v9; // eax

  v0 = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  if ( !v0 )
  {
    sub_140539D30((__int64)"fallback thread");
    v0 = *(_QWORD *)(get_thread_context_ptr() + 0x10);
  }
  result = *(_QWORD **)(v0 + 0x18);
  if ( !result )
  {
    v2 = (_QWORD *)allocWithProfilerInfo_w(0xB08u);
    v3 = v2;
    if ( v2 )
    {
      *v2 = 0;
      n0x10 = 0x10;
      v5 = v2 + 1;
      do
      {
        *(__m256i *)v5 = (__m256i)0LL;
        v5[4] = 0;
        v5[5] = 0;
        *(__m256i *)(v5 + 6) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xA) = (__m256i)0LL;
        *(__m256i *)(v5 + 0xE) = (__m256i)0LL;
        *(__m256i *)(v5 + 0x12) = (__m256i)0LL;
        v5 += 0x16;
        --n0x10;
      }
      while ( n0x10 );
    }
    else
    {
      v3 = 0;
    }
    ThreadLocalStoragePointer = NtCurrentTeb()->ThreadLocalStoragePointer;
    TlsIndex = (unsigned int)::TlsIndex;
    *(_QWORD *)(v0 + 0x18) = v3;
    v8 = ThreadLocalStoragePointer[TlsIndex];
    v9 = *(_DWORD *)(v8 + 0xF0);
    if ( (v9 & 1) == 0 )
    {
      *(_DWORD *)(v8 + 0xF0) = v9 | 1;
      __asm { vzeroupper }
      _tlregdtor((__int64)sub_1480BE950);
      v3 = *(_QWORD **)(v0 + 0x18);
    }
    result = v3;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_1404B3EA0 (0x1404B3EA0) ---

// --- Function: getThreadLogContextSlot (0x1404BDCA0) ---
// Retrieves a pointer to the current thread's logging context slot from Thread
// Local Storage (TLS). The specific slot is determined by an index stored within
// the TLS data block.
__int64 *getThreadLogContextSlot()
{
  unsigned __int64 *thread_base_ctx_ptr; // rax
  unsigned __int64 *thread_base_ctx_ptr_1; // rcx
  unsigned __int64 n0xF; // rax

  thread_base_ctx_ptr = sub_1404B3EA0();
  thread_base_ctx_ptr_1 = thread_base_ctx_ptr;
  if ( !thread_base_ctx_ptr )
    return &ThreadLogContextSlot;
  n0xF = *thread_base_ctx_ptr;
  if ( n0xF > 0xF )
    n0xF = 0xF;
  return (__int64 *)&thread_base_ctx_ptr_1[0x16 * n0xF + 1];
}

// --- End Function: getThreadLogContextSlot (0x1404BDCA0) ---

// --- Function: sub_140504650 (0x140504650) ---
unsigned __int64 __fastcall sub_140504650(__int64 *a1, int a2, char a3)
{
  __int64 v3; // r9
  int v7; // r11d
  int v8; // r8d
  unsigned __int64 v9; // rdx
  int v10; // ecx
  int v11; // eax
  __int64 v12; // rax
  unsigned __int64 result; // rax
  __int64 v14; // r8
  int v15; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v7 = *(_DWORD *)(*a1 - 4);
  v8 = v7 & 0x7FFFFFFF;
  if ( v7 >= 0 )
    v9 = 0x18 * v8 / 0x18uLL;
  else
    LODWORD(v9) = *(_DWORD *)(0x18 * v8 + v3);
  v10 = 0;
  v11 = 0;
  if ( a3 )
    LOBYTE(v11) = a2 > (int)v9;
  else
    LOBYTE(v11) = a2 != (_DWORD)v9;
  if ( v11 )
  {
    v15 = a2;
    if ( v7 )
      v10 = v3;
    v12 = sub_14044F6D0((_DWORD)a1, v10, v8, (unsigned int)&v15, 8, a3);
    *a1 = v12;
    v3 = v12;
    if ( !v12 )
    {
      result = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
      *a1 = (unsigned __int64)&unk_149B3B40B & 0xFFFFFFFFFFFFFFF8uLL;
      return result;
    }
    LODWORD(v9) = v15;
  }
  *(_DWORD *)(v3 - 4) = a2;
  v14 = 0x18 * a2;
  result = v14 + 4;
  if ( 0x18LL * (int)v9 >= (unsigned __int64)(v14 + 4) )
  {
    *(_DWORD *)(v3 - 4) = a2 | 0x80000000;
    *(_DWORD *)(v14 + v3) = v9;
  }
  return result;
}

// --- End Function: sub_140504650 (0x140504650) ---

// --- Function: sub_1405A87F0 (0x1405A87F0) ---
unsigned __int64 *__fastcall sub_1405A87F0(unsigned __int64 *a1, unsigned __int64 a2)
{
  bool v3; // al
  unsigned __int64 v4; // rcx
  bool v5; // zf
  unsigned __int64 *result; // rax
  __int64 v7; // [rsp+38h] [rbp+10h] BYREF

  if ( a2 && *(_QWORD *)((a2 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(a2) )
  {
    v7 = (*(__int64 (__fastcall **)(unsigned __int64, __int64))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL) + 0x80LL))(
           a2 & 0xFFFFFFFFFFFFLL,
           2);
    v3 = is_entity_descriptor_valid_or_accessible((unsigned __int64 *)&v7);
    v4 = 0;
    v5 = !v3;
    result = a1;
    if ( !v5 )
      v4 = v7;
    *a1 = v4;
  }
  else
  {
    result = a1;
    *a1 = 0;
  }
  return result;
}

// --- End Function: sub_1405A87F0 (0x1405A87F0) ---

// --- Function: sub_1407EAB20 (0x1407EAB20) ---
unsigned __int64 __fastcall sub_1407EAB20(unsigned __int64 *a1, int a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // r10
  int v6; // ecx
  int v7; // eax
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rdx
  int v10; // eax
  unsigned __int64 v11; // rax
  unsigned __int64 result; // rax
  __int64 v13; // rdx
  int v14; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a1;
  v6 = *(_DWORD *)(*a1 - 4);
  v7 = 4 * v6;
  if ( v6 >= 0 )
    v8 = (unsigned __int64)v7 >> 2;
  else
    LODWORD(v8) = *(_DWORD *)(v7 + v3);
  v9 = 0;
  v10 = 0;
  if ( a3 )
    LOBYTE(v10) = a2 > (int)v8;
  else
    LOBYTE(v10) = a2 != (_DWORD)v8;
  if ( v10 )
  {
    v14 = a2;
    if ( v6 )
      v9 = v3;
    v11 = sub_140600380((__int64)a1, v9, v6 & 0x7FFFFFFF, &v14, 4u, a3);
    *a1 = v11;
    v3 = v11;
    if ( !v11 )
    {
      result = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
      *a1 = (unsigned __int64)&unk_149B3B407 & 0xFFFFFFFFFFFFFFFCuLL;
      return result;
    }
    LODWORD(v8) = v14;
  }
  v13 = 4 * a2;
  *(_DWORD *)(v3 - 4) = a2;
  result = v13 + 4;
  if ( 4LL * (int)v8 >= (unsigned __int64)(v13 + 4) )
  {
    *(_DWORD *)(v3 - 4) = a2 | 0x80000000;
    *(_DWORD *)(v13 + v3) = v8;
  }
  return result;
}

// --- End Function: sub_1407EAB20 (0x1407EAB20) ---

// --- Function: sub_140970360 (0x140970360) ---
__int64 __fastcall sub_140970360(__int64 a1)
{
  return *(_QWORD *)(a1 + 0xE8);
}

// --- End Function: sub_140970360 (0x140970360) ---

// --- Function: sub_141D17630 (0x141D17630) ---
// attributes: thunk
__int64 __fastcall sub_141D17630(__int64 a1)
{
  return sub_1403335B0(a1);
}

// --- End Function: sub_141D17630 (0x141D17630) ---

// --- Function: sub_141EF0850 (0x141EF0850) ---
__int64 __fastcall sub_141EF0850(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 0x24) = 0x3F800000;
  *(_QWORD *)(a1 + 0xC) = 0;
  *(_QWORD *)(a1 + 0x14) = 0;
  *(_QWORD *)(a1 + 0x1C) = 0;
  *(_QWORD *)(a1 + 0xB0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x48) = 0x1000004FFLL;
  result = a1;
  *(_OWORD *)(a1 + 0x90) = xmmword_14853E958;
  *(_QWORD *)(a1 + 0xC0) = 0;
  *(_QWORD *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0;
  *(_QWORD *)(a1 + 0xD8) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 0x74) = 1;
  *(_QWORD *)(a1 + 0x50) = 0x81;
  *(_QWORD *)(a1 + 0x30) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_DWORD *)(a1 + 0x28) = 0x3F800000;
  *(_QWORD *)(a1 + 0x60) = 0;
  *(_QWORD *)(a1 + 0x68) = 0;
  *(_DWORD *)(a1 + 0x70) = 0;
  *(_QWORD *)(a1 + 0x78) = 0;
  *(_QWORD *)(a1 + 0x80) = 0;
  *(_DWORD *)(a1 + 0xA0) = 0;
  *(_BYTE *)(a1 + 0xAC) = 0;
  *(_DWORD *)(a1 + 0x88) = 0;
  *(_DWORD *)(a1 + 0x8C) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0xA8) = 1;
  *(_DWORD *)(a1 + 0xB8) = 0;
  *(_DWORD *)(a1 + 0xA4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 8) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 4) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x40) = 0x80000000;
  *(_DWORD *)(a1 + 0x58) = 0xFFBFFFFF;
  *(_DWORD *)(a1 + 0x5C) = 0x80000000;
  return result;
}

// --- End Function: sub_141EF0850 (0x141EF0850) ---

// --- Function: sub_14217D620 (0x14217D620) ---
__int64 *__fastcall sub_14217D620(__int64 *a1, __int64 *a2)
{
  __int64 v3; // rcx
  __int64 *result; // rax

  v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  if ( v3 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x118LL))(v3);
    result = a1;
    *a2 = 0;
  }
  else
  {
    result = a1;
    *a2 = 0;
  }
  return result;
}

// --- End Function: sub_14217D620 (0x14217D620) ---

// --- Function: sub_1422DAC10 (0x1422DAC10) ---
__int64 __fastcall sub_1422DAC10(__int64 *a1, __int64 a2, __m128i *a3)
{
  __m128i *v3; // r10
  __m128i *v5; // rax
  unsigned __int64 v7; // r9
  char v8; // dl
  __m128i v9; // xmm0
  __int64 result; // rax
  __m128i v11; // xmm1
  __m128i *v12; // rcx
  int v13; // edx
  __m128i *v14; // r8

  v3 = (__m128i *)a1[1];
  v5 = (__m128i *)*a1;
  v7 = ((__int64)v3->m128i_i64 - *a1) >> 4;
  while ( v7 )
  {
    if ( v5[v7 >> 1].m128i_i32[0] >= a3->m128i_i32[0] )
    {
      v7 >>= 1;
    }
    else
    {
      v5 += (v7 >> 1) + 1;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  v8 = 0;
  if ( v5 != v3 && a3->m128i_i32[0] >= v5->m128i_i32[0] )
    goto LABEL_15;
  if ( v3 == (__m128i *)a1[2] )
  {
    v5 = (__m128i *)sub_140307D70(a1, v5, a3);
    v8 = 1;
LABEL_15:
    *(_QWORD *)a2 = v5;
    result = a2;
    *(_BYTE *)(a2 + 8) = v8;
    return result;
  }
  if ( v5 == v3 )
  {
    v9 = *a3;
    *(_QWORD *)a2 = v5;
    *v3 = v9;
    a1[1] += 0x10;
    result = a2;
    *(_BYTE *)(a2 + 8) = 1;
  }
  else
  {
    v11 = *a3;
    v12 = v3 + 0xFFFFFFFF;
    *v3 = v3[0xFFFFFFFFLL];
    a1[1] += 0x10;
    if ( &v3[0xFFFFFFFF] != v5 )
    {
      do
      {
        v13 = v12[0xFFFFFFFF].m128i_i32[0];
        v14 = v12;
        v12 += 0xFFFFFFFF;
        v14->m128i_i32[0] = v13;
        v12[1].m128i_i64[1] = v12->m128i_i64[1];
      }
      while ( v12 != v5 );
    }
    *(_QWORD *)a2 = v5;
    v5->m128i_i32[0] = v11.m128i_i32[0];
    v5->m128i_i64[1] = _mm_extract_epi64(v11, 1);
    *(_BYTE *)(a2 + 8) = 1;
    return a2;
  }
  return result;
}

// --- End Function: sub_1422DAC10 (0x1422DAC10) ---

// --- Function: sub_142370910 (0x142370910) ---
__int64 __fastcall sub_142370910(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  const char *p_null; // rdx
  unsigned __int64 v6; // rax
  const char *p_null_2; // rcx
  const char *p_null_1; // r8
  unsigned __int64 v9; // rcx

  *(_QWORD *)(a1 + 0x70) = a3;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = "TraceContext";
  p_null = "null";
  *(_WORD *)(a1 + 0x58) = 0x100;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  v6 = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  *(_QWORD *)(a1 + 0x78) = "Asset";
  *(_BYTE *)(a1 + 0xC9) = 1;
  *(_QWORD *)(a1 + 0x80) = *a3;
  *(_QWORD *)(a1 + 0x88) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x90) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0xA0) = sub_1403E7650;
  *(_QWORD *)(a1 + 0xB0) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0xB8) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x98) = 0;
  *(_QWORD *)(a1 + 0xA8) = 0;
  *(_QWORD *)(a1 + 0xC0) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0xC8) = 0;
  *(_QWORD *)(a1 + 0xD0) = 0x18;
  p_null_2 = (const char *)a3[1];
  p_null_1 = "null";
  if ( p_null_2 )
    p_null_1 = p_null_2;
  v9 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v9;
  while ( p_null_1[v9] );
  *(_QWORD *)(a1 + 0xD8) = v9;
  *(_QWORD *)(a1 + 0xE8) = "Name";
  *(_QWORD *)(a1 + 0xE0) = a4;
  *(_BYTE *)(a1 + 0x139) = 0;
  *(_QWORD *)(a1 + 0xF0) = *a4;
  *(_QWORD *)(a1 + 0xF8) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x100) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x110) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x120) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x128) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x108) = 0;
  *(_QWORD *)(a1 + 0x118) = 0;
  *(_QWORD *)(a1 + 0x130) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x138) = 0;
  *(_QWORD *)(a1 + 0x140) = 0x18;
  if ( a4[1] )
    p_null = (const char *)a4[1];
  do
    ++v6;
  while ( p_null[v6] );
  *(_QWORD *)(a1 + 0x148) = v6;
  return 3;
}

// --- End Function: sub_142370910 (0x142370910) ---

// --- Function: sub_1426FC490 (0x1426FC490) ---
_QWORD *__fastcall sub_1426FC490(_QWORD *a1, _QWORD *a2)
{
  *a1 = 0;
  a1[1] = 0;
  if ( a2[1] )
    InterlockedIncrement_w_1(a2[1]);
  *a1 = *a2;
  a1[1] = a2[1];
  return a1;
}

// --- End Function: sub_1426FC490 (0x1426FC490) ---

// --- Function: sub_142704CD0 (0x142704CD0) ---
_QWORD *__fastcall sub_142704CD0(_QWORD *a1, __int64 *a2)
{
  __int64 v3; // [rsp+50h] [rbp-28h]
  __int64 v4; // [rsp+58h] [rbp-20h]
  __int64 v5; // [rsp+60h] [rbp-18h]
  std::_Ref_count_base *v6; // [rsp+60h] [rbp-18h]

  v4 = *a2;
  v5 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  *a1 = v4;
  v3 = v5;
  v6 = (std::_Ref_count_base *)a1[1];
  a1[1] = v3;
  if ( v6 )
    std::_Ref_count_base::_Decref(v6);
  return a1;
}

// --- End Function: sub_142704CD0 (0x142704CD0) ---

// --- Function: sub_142744750 (0x142744750) ---
__int64 __fastcall sub_142744750(unsigned __int8 input_byte)
{
  return (unsigned int)input_byte + 0xC7;
}

// --- End Function: sub_142744750 (0x142744750) ---

// --- Function: sub_142EB3EF0 (0x142EB3EF0) ---
_QWORD *__fastcall sub_142EB3EF0(_QWORD *a1, __int64 *a2)
{
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = *a2;
  *a1 = 0;
  a1[1] = 0;
  if ( a2[1] )
    InterlockedIncrement_w_1(a2[1]);
  *a1 = v3;
  a1[1] = a2[1];
  return a1;
}

// --- End Function: sub_142EB3EF0 (0x142EB3EF0) ---

// --- Function: sub_1457B6950 (0x1457B6950) ---
_QWORD *__fastcall sub_1457B6950(__int64 *a1, _QWORD *a2, _DWORD *a3)
{
  _QWORD *v4; // rax
  __int64 v5; // [rsp+30h] [rbp-B8h]
  __int64 v6; // [rsp+40h] [rbp-A8h] BYREF
  __int64 v7; // [rsp+48h] [rbp-A0h]
  __int64 v8; // [rsp+50h] [rbp-98h] BYREF
  __int64 *v9; // [rsp+58h] [rbp-90h]
  char v10; // [rsp+60h] [rbp-88h]
  __int128 v11; // [rsp+68h] [rbp-80h] BYREF
  __int128 v12; // [rsp+78h] [rbp-70h] BYREF
  __int64 v13; // [rsp+88h] [rbp-60h]
  __int64 *v14; // [rsp+90h] [rbp-58h]
  __int64 v15; // [rsp+98h] [rbp-50h]
  __int64 *v16; // [rsp+A0h] [rbp-48h]
  __int64 v17; // [rsp+A8h] [rbp-40h]
  __int64 v18; // [rsp+B0h] [rbp-38h]
  void (__fastcall *v19)(__int64, _DWORD *); // [rsp+B8h] [rbp-30h]
  _QWORD *v20; // [rsp+C0h] [rbp-28h]
  _QWORD v21[4]; // [rsp+C8h] [rbp-20h] BYREF

  sub_140452E50((__int64)&v8, a3, 2);
  v9 = a1 + 3;
  v10 = 1;
  v14 = a1 + 3;
  sub_1402D2710((__int64)(a1 + 3), "CMannequinUserParamsManager::FindOrCreateParams", "m_lock", 1);
  sub_1404AA480(a1, &v11, &v8);
  v15 = v11;
  if ( (_QWORD)v11 )
  {
    sub_142EB3EF0(a2, (__int64 *)&v11);
    if ( *((_QWORD *)&v11 + 1) )
      std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v11 + 1));
    if ( v10 )
      rw_lock_release_read_lock((__int64)v9);
    return a2;
  }
  else
  {
    if ( *((_QWORD *)&v11 + 1) )
      std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v11 + 1));
    if ( v10 )
      rw_lock_release_read_lock((__int64)v9);
    v5 = (__int64)(a1 + 3);
    v16 = a1 + 3;
    sub_1402DE3A0((__int64)(a1 + 3), "CMannequinUserParamsManager::FindOrCreateParams", "m_lock", 1);
    sub_1404AA480(a1, &v12, &v8);
    v17 = v12;
    if ( (_QWORD)v12 )
    {
      sub_142EB3EF0(a2, (__int64 *)&v12);
      if ( *((_QWORD *)&v12 + 1) )
        std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v12 + 1));
      if ( a1 != (__int64 *)0xFFFFFFFFFFFFFFE8LL )
        sub_1402DE4A0(v5);
      return a2;
    }
    else
    {
      if ( *((_QWORD *)&v12 + 1) )
        std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v12 + 1));
      sub_1457BC8F0(&v6);
      v18 = v6;
      v13 = v6;
      v19 = *(void (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)v6 + 8LL);
      v19(v6, a3);
      v20 = v21;
      v4 = sub_1426FC490(v21, &v6);
      sub_140488D30(a1, &v8, v4);
      *a2 = 0;
      a2[1] = 0;
      *a2 = v6;
      a2[1] = v7;
      v6 = 0;
      v7 = 0;
      if ( a1 != (__int64 *)0xFFFFFFFFFFFFFFE8LL )
        sub_1402DE4A0(v5);
      return a2;
    }
  }
}

// --- End Function: sub_1457B6950 (0x1457B6950) ---

// --- Function: sub_1457B6CA0 (0x1457B6CA0) ---
_QWORD *__fastcall sub_1457B6CA0(__int64 *a1, _QWORD *a2, _DWORD *a3)
{
  _QWORD *v4; // rax
  __int64 v5; // [rsp+30h] [rbp-B8h]
  __int64 v6; // [rsp+40h] [rbp-A8h] BYREF
  __int64 v7; // [rsp+48h] [rbp-A0h]
  __int64 v8; // [rsp+50h] [rbp-98h] BYREF
  __int64 *v9; // [rsp+58h] [rbp-90h]
  char v10; // [rsp+60h] [rbp-88h]
  __int128 v11; // [rsp+68h] [rbp-80h] BYREF
  __int128 v12; // [rsp+78h] [rbp-70h] BYREF
  __int64 v13; // [rsp+88h] [rbp-60h]
  __int64 *v14; // [rsp+90h] [rbp-58h]
  __int64 v15; // [rsp+98h] [rbp-50h]
  __int64 *v16; // [rsp+A0h] [rbp-48h]
  __int64 v17; // [rsp+A8h] [rbp-40h]
  __int64 v18; // [rsp+B0h] [rbp-38h]
  void (__fastcall *v19)(__int64, _DWORD *); // [rsp+B8h] [rbp-30h]
  _QWORD *v20; // [rsp+C0h] [rbp-28h]
  _QWORD v21[4]; // [rsp+C8h] [rbp-20h] BYREF

  sub_140452E50((__int64)&v8, a3, 3);
  v9 = a1 + 3;
  v10 = 1;
  v14 = a1 + 3;
  sub_1402D2710((__int64)(a1 + 3), "CMannequinUserParamsManager::FindOrCreateParams", "m_lock", 1);
  sub_1404AA480(a1, &v11, &v8);
  v15 = v11;
  if ( (_QWORD)v11 )
  {
    sub_142EB3EF0(a2, (__int64 *)&v11);
    if ( *((_QWORD *)&v11 + 1) )
      std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v11 + 1));
    if ( v10 )
      rw_lock_release_read_lock((__int64)v9);
    return a2;
  }
  else
  {
    if ( *((_QWORD *)&v11 + 1) )
      std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v11 + 1));
    if ( v10 )
      rw_lock_release_read_lock((__int64)v9);
    v5 = (__int64)(a1 + 3);
    v16 = a1 + 3;
    sub_1402DE3A0((__int64)(a1 + 3), "CMannequinUserParamsManager::FindOrCreateParams", "m_lock", 1);
    sub_1404AA480(a1, &v12, &v8);
    v17 = v12;
    if ( (_QWORD)v12 )
    {
      sub_142EB3EF0(a2, (__int64 *)&v12);
      if ( *((_QWORD *)&v12 + 1) )
        std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v12 + 1));
      if ( a1 != (__int64 *)0xFFFFFFFFFFFFFFE8LL )
        sub_1402DE4A0(v5);
      return a2;
    }
    else
    {
      if ( *((_QWORD *)&v12 + 1) )
        std::_Ref_count_base::_Decref(*((std::_Ref_count_base **)&v12 + 1));
      sub_1457BC980(&v6);
      v18 = v6;
      v13 = v6;
      v19 = *(void (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)v6 + 8LL);
      v19(v6, a3);
      v20 = v21;
      v4 = sub_1426FC490(v21, &v6);
      sub_140488D30(a1, &v8, v4);
      *a2 = 0;
      a2[1] = 0;
      *a2 = v6;
      a2[1] = v7;
      v6 = 0;
      v7 = 0;
      if ( a1 != (__int64 *)0xFFFFFFFFFFFFFFE8LL )
        sub_1402DE4A0(v5);
      return a2;
    }
  }
}

// --- End Function: sub_1457B6CA0 (0x1457B6CA0) ---

// --- Function: sub_1457B9A20 (0x1457B9A20) ---
__int64 __fastcall sub_1457B9A20(__int64 a1, __int64 *ThreadLogContextSlot, __int64 a3, __int64 a4, __int64 a5)
{
  *(_QWORD *)a1 = ThreadLogContextSlot;
  *(_QWORD *)(a1 + 8) = sub_1403B3E60();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = 0;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB6A0;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB240;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E77F0;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E60;
  *(_QWORD *)(a1 + 0x48) = allocWithProfilerInfo_ww;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0xB0;
  *(_QWORD *)(a1 + 0x68) = 0xA8;
  return sub_1457BAC60(a1 + 0x70, a3, a4, a5) + 1;
}

// --- End Function: sub_1457B9A20 (0x1457B9A20) ---

// --- Function: sub_1457BAC60 (0x1457BAC60) ---
__int64 __fastcall sub_1457BAC60(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v5; // [rsp+20h] [rbp-48h]
  const char *p_null; // [rsp+30h] [rbp-38h]

  *(_QWORD *)a1 = identity((__int64)a2);
  *(_QWORD *)(a1 + 8) = sub_1403B3DB0();
  *(_BYTE *)(a1 + 0x59) = 1;
  *(_QWORD *)(a1 + 0x10) = *a2;
  *(_QWORD *)(a1 + 0x18) = sub_1403EB580;
  *(_QWORD *)(a1 + 0x20) = sub_1403EB0E0;
  *(_QWORD *)(a1 + 0x28) = 0;
  *(_QWORD *)(a1 + 0x30) = sub_1403E7650;
  *(_QWORD *)(a1 + 0x38) = 0;
  *(_QWORD *)(a1 + 0x40) = sub_1403E4E80;
  *(_QWORD *)(a1 + 0x48) = sub_1403E4B90;
  *(_QWORD *)(a1 + 0x50) = 0xFFFFFFFFFFFFFFFFuLL;
  *(_BYTE *)(a1 + 0x58) = 0;
  *(_QWORD *)(a1 + 0x60) = 0x18;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
    p_null = *(const char **)(*(_QWORD *)a1 + 8LL);
  else
    p_null = "null";
  v5 = 0xFFFFFFFFFFFFFFFFuLL;
  do
    ++v5;
  while ( p_null[v5] );
  *(_QWORD *)(a1 + 0x68) = v5;
  return sub_1457BADF0(a1 + 0x70, a3, a4) + 1;
}

// --- End Function: sub_1457BAC60 (0x1457BAC60) ---

// --- Function: sub_1457BC8F0 (0x1457BC8F0) ---
_QWORD *__fastcall sub_1457BC8F0(_QWORD *a1)
{
  __int64 v2; // [rsp+20h] [rbp-28h]
  __int64 v3; // [rsp+28h] [rbp-20h]

  v2 = allocWithProfilerInfo_w(0xF8u);
  if ( v2 )
    v3 = std::optional<unsigned __int64>::optional<unsigned __int64>(v2);
  else
    v3 = 0;
  *a1 = 0;
  a1[1] = 0;
  *a1 = v3 + 0x10;
  a1[1] = v3;
  return a1;
}

// --- End Function: sub_1457BC8F0 (0x1457BC8F0) ---

// --- Function: sub_1457BC980 (0x1457BC980) ---
_QWORD *__fastcall sub_1457BC980(_QWORD *a1)
{
  __int64 v2; // [rsp+20h] [rbp-28h]
  __int64 v3; // [rsp+28h] [rbp-20h]

  v2 = allocWithProfilerInfo_w(0x3B8u);
  if ( v2 )
    v3 = std::optional<unsigned __int64>::optional<unsigned __int64>(v2);
  else
    v3 = 0;
  *a1 = 0;
  a1[1] = 0;
  *a1 = v3 + 0x10;
  a1[1] = v3;
  return a1;
}

// --- End Function: sub_1457BC980 (0x1457BC980) ---

// --- Function: sub_1457D5090 (0x1457D5090) ---
__int64 __fastcall sub_1457D5090(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  std::shared_ptr<vraudio::MixerNode> *_Right; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  _QWORD *v6; // rax
  void *v7; // rsp
  __int64 v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rax
  void *v11; // rsp
  __int64 *v12; // rax
  __int64 *v13; // rax
  __int64 v14; // r8
  void *v15; // rsp
  __int64 v16; // rax
  __int64 v17; // rax
  void *v18; // rsp
  void *v19; // rsp
  __int64 v21; // [rsp+18h] [rbp-1D8h]
  _BYTE v22[64]; // [rsp+30h] [rbp-1C0h] BYREF
  __int64 v23; // [rsp+88h] [rbp-168h]
  _BYTE v24[256]; // [rsp+A0h] [rbp-150h] BYREF
  __int64 v25; // [rsp+1F0h] [rbp+0h]
  char v26; // [rsp+1F8h] [rbp+8h]
  int n2; // [rsp+1FCh] [rbp+Ch]
  int v28; // [rsp+200h] [rbp+10h]
  int v29; // [rsp+204h] [rbp+14h]
  unsigned int v31; // [rsp+20Ch] [rbp+1Ch]
  unsigned int v33; // [rsp+214h] [rbp+24h]
  unsigned int v35; // [rsp+21Ch] [rbp+2Ch]
  unsigned int v37; // [rsp+224h] [rbp+34h]
  unsigned int v39; // [rsp+22Ch] [rbp+3Ch]
  unsigned int v41; // [rsp+234h] [rbp+44h]
  unsigned int v43; // [rsp+23Ch] [rbp+4Ch]
  unsigned int v45; // [rsp+244h] [rbp+54h]
  unsigned int v47; // [rsp+24Ch] [rbp+5Ch]
  unsigned int v49; // [rsp+254h] [rbp+64h]
  unsigned int v51; // [rsp+25Ch] [rbp+6Ch]
  unsigned int v53; // [rsp+264h] [rbp+74h]
  int v54; // [rsp+268h] [rbp+78h]
  int v55; // [rsp+26Ch] [rbp+7Ch]
  int v56; // [rsp+270h] [rbp+80h]
  BOOL v57; // [rsp+274h] [rbp+84h]
  __int64 v58; // [rsp+278h] [rbp+88h] BYREF
  __int64 v59; // [rsp+280h] [rbp+90h] BYREF
  vraudio::AudioBuffer *__Val_0___2; // [rsp+288h] [rbp+98h]
  unsigned __int64 v61; // [rsp+290h] [rbp+A0h]
  _BYTE *v62; // [rsp+298h] [rbp+A8h]
  vraudio::AudioBuffer *__Val_0___3; // [rsp+2A0h] [rbp+B0h]
  unsigned __int64 v64; // [rsp+2A8h] [rbp+B8h]
  unsigned __int64 v65; // [rsp+2B0h] [rbp+C0h]
  __int64 v66; // [rsp+2B8h] [rbp+C8h]
  _BYTE *v67; // [rsp+2C0h] [rbp+D0h]
  vraudio::AudioBuffer *__Val_0___4; // [rsp+2C8h] [rbp+D8h]
  unsigned __int64 v69; // [rsp+2D0h] [rbp+E0h]
  __int64 v70; // [rsp+2D8h] [rbp+E8h]
  _BYTE *v71; // [rsp+2E0h] [rbp+F0h]
  __int64 v72; // [rsp+2E8h] [rbp+F8h]
  __int64 v73; // [rsp+2F0h] [rbp+100h]
  __int64 v74; // [rsp+2F8h] [rbp+108h]
  __int64 v75; // [rsp+300h] [rbp+110h]
  __int64 v76; // [rsp+308h] [rbp+118h]
  __int64 v77; // [rsp+310h] [rbp+120h]
  __int64 v78; // [rsp+318h] [rbp+128h]
  unsigned __int64 v79; // [rsp+320h] [rbp+130h]
  unsigned __int64 v80; // [rsp+328h] [rbp+138h]
  __int64 v81; // [rsp+330h] [rbp+140h]
  _BYTE *v82; // [rsp+338h] [rbp+148h]
  vraudio::AudioBuffer *__Val_0__; // [rsp+340h] [rbp+150h]
  __int64 v84; // [rsp+348h] [rbp+158h]
  unsigned __int64 v85; // [rsp+350h] [rbp+160h]
  unsigned __int64 v86; // [rsp+358h] [rbp+168h]
  __int64 v87; // [rsp+360h] [rbp+170h]
  _BYTE *v88; // [rsp+368h] [rbp+178h]
  vraudio::AudioBuffer *__Val_0___1; // [rsp+370h] [rbp+180h]
  __int64 v90; // [rsp+378h] [rbp+188h]
  __int64 v91; // [rsp+380h] [rbp+190h]
  __int64 v92; // [rsp+388h] [rbp+198h]
  __int64 v93; // [rsp+390h] [rbp+1A0h]
  __int64 v94; // [rsp+398h] [rbp+1A8h]
  __int64 v95; // [rsp+3A0h] [rbp+1B0h]
  __int64 v96; // [rsp+3A8h] [rbp+1B8h]
  __int64 v97; // [rsp+3B0h] [rbp+1C0h]
  __int64 v98; // [rsp+3B8h] [rbp+1C8h]
  __int64 v99; // [rsp+3C0h] [rbp+1D0h]
  __int64 v100; // [rsp+3C8h] [rbp+1D8h]
  __int64 v101; // [rsp+3D0h] [rbp+1E0h]
  __int64 v102; // [rsp+3D8h] [rbp+1E8h]
  __int64 v103; // [rsp+3E0h] [rbp+1F0h]
  __int64 v104; // [rsp+3E8h] [rbp+1F8h]
  unsigned __int64 v105; // [rsp+3F0h] [rbp+200h]
  unsigned int v106; // [rsp+3F8h] [rbp+208h]
  unsigned int v107; // [rsp+3FCh] [rbp+20Ch]
  unsigned int v108; // [rsp+400h] [rbp+210h]
  unsigned int v109; // [rsp+404h] [rbp+214h]
  unsigned int v110; // [rsp+408h] [rbp+218h]
  unsigned int v111; // [rsp+40Ch] [rbp+21Ch]
  unsigned int v112; // [rsp+410h] [rbp+220h]
  unsigned int v113; // [rsp+414h] [rbp+224h]
  unsigned int v114; // [rsp+418h] [rbp+228h]
  unsigned int v115; // [rsp+41Ch] [rbp+22Ch]
  unsigned int v116; // [rsp+420h] [rbp+230h]
  unsigned int v117; // [rsp+424h] [rbp+234h]
  const ULONG_PTR *v118; // [rsp+428h] [rbp+238h]
  __int64 (__fastcall *v119)(__int64, const ULONG_PTR *); // [rsp+430h] [rbp+240h]
  __int64 v120; // [rsp+438h] [rbp+248h]
  __int64 v121; // [rsp+440h] [rbp+250h]
  __int64 v122; // [rsp+448h] [rbp+258h]
  __int64 v123; // [rsp+450h] [rbp+260h]
  __int64 (__fastcall *v124)(__int64, _BYTE *, __int64, __int64); // [rsp+458h] [rbp+268h]
  __int64 v125; // [rsp+460h] [rbp+270h]
  const ULONG_PTR *v126; // [rsp+468h] [rbp+278h]
  __int64 (__fastcall *v127)(__int64, __int64 *, const ULONG_PTR *); // [rsp+470h] [rbp+280h]
  __int64 (__fastcall *v128)(unsigned __int64, __int64 *); // [rsp+478h] [rbp+288h]
  __int64 v129; // [rsp+480h] [rbp+290h]
  __int64 v130; // [rsp+488h] [rbp+298h]
  __int64 v131; // [rsp+490h] [rbp+2A0h]
  _QWORD *v132; // [rsp+498h] [rbp+2A8h]
  _QWORD *v133; // [rsp+4A0h] [rbp+2B0h]
  __int64 *ThreadLogContextSlot; // [rsp+4A8h] [rbp+2B8h]
  const void *v135; // [rsp+4B0h] [rbp+2C0h]
  __int64 v136; // [rsp+4B8h] [rbp+2C8h] BYREF
  const ULONG_PTR *v137; // [rsp+4C0h] [rbp+2D0h]
  __int64 (__fastcall *v138)(__int64, __int64 *, const ULONG_PTR *); // [rsp+4C8h] [rbp+2D8h]
  __int64 (__fastcall *v139)(unsigned __int64, __int64 *); // [rsp+4D0h] [rbp+2E0h]
  __int64 v140; // [rsp+4D8h] [rbp+2E8h]
  __int64 v141; // [rsp+4E0h] [rbp+2F0h]
  __int64 v142; // [rsp+4E8h] [rbp+2F8h]
  _QWORD *v143; // [rsp+4F0h] [rbp+300h]
  _QWORD *v144; // [rsp+4F8h] [rbp+308h]
  __int64 *ThreadLogContextSlot_1; // [rsp+500h] [rbp+310h]
  const void *v146; // [rsp+508h] [rbp+318h]
  __int64 v147; // [rsp+510h] [rbp+320h] BYREF
  __int64 v148; // [rsp+518h] [rbp+328h]
  __int64 v149; // [rsp+520h] [rbp+330h]
  __int64 v150; // [rsp+528h] [rbp+338h]
  void (__fastcall *v151)(__int64, _QWORD, __int64); // [rsp+530h] [rbp+340h]
  __int64 v152; // [rsp+538h] [rbp+348h]
  __int64 v153; // [rsp+540h] [rbp+350h]
  __int64 v154; // [rsp+548h] [rbp+358h]
  void (__fastcall *v155)(__int64, _QWORD, __int64); // [rsp+550h] [rbp+360h]
  __int64 v156; // [rsp+558h] [rbp+368h]
  __int64 v157; // [rsp+560h] [rbp+370h]
  __int64 v158; // [rsp+568h] [rbp+378h]
  void (__fastcall *v159)(__int64, _QWORD, __int64); // [rsp+570h] [rbp+380h]
  __int64 v160; // [rsp+578h] [rbp+388h]
  __int64 v161; // [rsp+580h] [rbp+390h]
  __int64 v162; // [rsp+588h] [rbp+398h]
  void (__fastcall *v163)(__int64, _QWORD, __int64); // [rsp+590h] [rbp+3A0h]
  __int64 v164; // [rsp+598h] [rbp+3A8h]
  __int64 v165; // [rsp+5A0h] [rbp+3B0h]
  __int64 v166; // [rsp+5A8h] [rbp+3B8h]
  void (__fastcall *v167)(__int64, _QWORD, __int64); // [rsp+5B0h] [rbp+3C0h]
  __int64 v168; // [rsp+5B8h] [rbp+3C8h]
  __int64 v169; // [rsp+5C0h] [rbp+3D0h]
  __int64 v170; // [rsp+5C8h] [rbp+3D8h]
  void (__fastcall *v171)(__int64, _QWORD, __int64); // [rsp+5D0h] [rbp+3E0h]
  __int64 v172; // [rsp+5D8h] [rbp+3E8h]
  __int64 v173; // [rsp+5E0h] [rbp+3F0h]
  __int64 v174; // [rsp+5E8h] [rbp+3F8h]
  void (__fastcall *v175)(__int64, _QWORD, __int64); // [rsp+5F0h] [rbp+400h]
  __int64 v176; // [rsp+5F8h] [rbp+408h]
  __int64 v177; // [rsp+600h] [rbp+410h]
  __int64 v178; // [rsp+608h] [rbp+418h]
  void (__fastcall *v179)(__int64, _QWORD, __int64); // [rsp+610h] [rbp+420h]
  __int64 v180; // [rsp+618h] [rbp+428h]
  __int64 v181; // [rsp+620h] [rbp+430h]
  __int64 v182; // [rsp+628h] [rbp+438h]
  void (__fastcall *v183)(__int64, _QWORD, __int64); // [rsp+630h] [rbp+440h]
  __int64 v184; // [rsp+638h] [rbp+448h]
  __int64 v185; // [rsp+640h] [rbp+450h]
  __int64 v186; // [rsp+648h] [rbp+458h]
  void (__fastcall *v187)(__int64, _QWORD, __int64); // [rsp+650h] [rbp+460h]
  __int64 v188; // [rsp+658h] [rbp+468h]
  __int64 v189; // [rsp+660h] [rbp+470h]
  __int64 v190; // [rsp+668h] [rbp+478h]
  void (__fastcall *v191)(__int64, _QWORD, __int64); // [rsp+670h] [rbp+480h]
  __int64 v192; // [rsp+678h] [rbp+488h]
  __int64 v193; // [rsp+680h] [rbp+490h]
  __int64 v194; // [rsp+688h] [rbp+498h]
  void (__fastcall *v195)(__int64, _QWORD, __int64); // [rsp+690h] [rbp+4A0h]
  __int64 (__fastcall *v196)(unsigned __int64, __int64 *); // [rsp+698h] [rbp+4A8h]
  __int64 v197; // [rsp+6A0h] [rbp+4B0h]
  __int64 v198; // [rsp+6A8h] [rbp+4B8h]
  __int64 v199; // [rsp+6B0h] [rbp+4C0h]
  _QWORD *v200; // [rsp+6B8h] [rbp+4C8h]
  _QWORD *v201; // [rsp+6C0h] [rbp+4D0h]
  __int64 *ThreadLogContextSlot_2; // [rsp+6C8h] [rbp+4D8h]
  const void *v203; // [rsp+6D0h] [rbp+4E0h]
  __int64 v204; // [rsp+6D8h] [rbp+4E8h] BYREF
  __int64 (__fastcall *v205)(unsigned __int64, __int64 *); // [rsp+6E0h] [rbp+4F0h]
  __int64 v206; // [rsp+6E8h] [rbp+4F8h]
  __int64 v207; // [rsp+6F0h] [rbp+500h]
  const ULONG_PTR *v208; // [rsp+6F8h] [rbp+508h]
  const ULONG_PTR *v209; // [rsp+700h] [rbp+510h]
  _QWORD *v210; // [rsp+708h] [rbp+518h]
  _QWORD *v211; // [rsp+710h] [rbp+520h]
  _QWORD *v212; // [rsp+718h] [rbp+528h]
  __int64 *ThreadLogContextSlot_3; // [rsp+720h] [rbp+530h]
  const void *v214; // [rsp+728h] [rbp+538h]
  const void *v215; // [rsp+730h] [rbp+540h]
  __int64 v216; // [rsp+738h] [rbp+548h] BYREF
  __int64 (__fastcall *v217)(unsigned __int64, __int64 *); // [rsp+740h] [rbp+550h]
  __int64 v218; // [rsp+748h] [rbp+558h]
  __int64 v219; // [rsp+750h] [rbp+560h]
  __int64 v220; // [rsp+758h] [rbp+568h]
  _QWORD *v221; // [rsp+760h] [rbp+570h]
  _QWORD *v222; // [rsp+768h] [rbp+578h]
  __int64 *ThreadLogContextSlot_4; // [rsp+770h] [rbp+580h]
  const void *v224; // [rsp+778h] [rbp+588h]
  __int64 v225; // [rsp+780h] [rbp+590h] BYREF
  _QWORD v226[2]; // [rsp+788h] [rbp+598h] BYREF
  const void *v227; // [rsp+798h] [rbp+5A8h]
  _QWORD v228[3]; // [rsp+7A0h] [rbp+5B0h] BYREF
  _QWORD v229[2]; // [rsp+7B8h] [rbp+5C8h] BYREF
  const void *v230; // [rsp+7C8h] [rbp+5D8h]
  _QWORD v231[2]; // [rsp+7D0h] [rbp+5E0h] BYREF
  const void *v232; // [rsp+7E0h] [rbp+5F0h]
  _QWORD v233[2]; // [rsp+7E8h] [rbp+5F8h] BYREF
  const void *v234; // [rsp+7F8h] [rbp+608h]
  _QWORD v235[3]; // [rsp+800h] [rbp+610h] BYREF
  _QWORD v236[3]; // [rsp+818h] [rbp+628h] BYREF
  _QWORD v237[2]; // [rsp+830h] [rbp+640h] BYREF
  const void *v238; // [rsp+840h] [rbp+650h]
  _QWORD v239[2]; // [rsp+848h] [rbp+658h] BYREF
  const void *v240; // [rsp+858h] [rbp+668h]
  _QWORD v241[3]; // [rsp+860h] [rbp+670h] BYREF
  _QWORD v242[3]; // [rsp+878h] [rbp+688h] BYREF
  _QWORD v243[2]; // [rsp+890h] [rbp+6A0h] BYREF
  _QWORD src__8[2]; // [rsp+8A0h] [rbp+6B0h] BYREF
  _QWORD src__9[2]; // [rsp+8B0h] [rbp+6C0h] BYREF
  _QWORD v246[2]; // [rsp+8C0h] [rbp+6D0h] BYREF
  _QWORD src__6[2]; // [rsp+8D0h] [rbp+6E0h] BYREF
  _BYTE v248[8]; // [rsp+8E0h] [rbp+6F0h] BYREF
  std::_Ref_count_base *v249; // [rsp+8E8h] [rbp+6F8h]
  _QWORD src_[2]; // [rsp+8F0h] [rbp+700h] BYREF
  _QWORD src__1[2]; // [rsp+900h] [rbp+710h] BYREF
  _QWORD v252[2]; // [rsp+910h] [rbp+720h] BYREF
  _QWORD src__2[2]; // [rsp+920h] [rbp+730h] BYREF
  _QWORD src__3[2]; // [rsp+930h] [rbp+740h] BYREF
  _QWORD v255[2]; // [rsp+940h] [rbp+750h] BYREF
  _BYTE v256[8]; // [rsp+950h] [rbp+760h] BYREF
  std::_Ref_count_base *v257; // [rsp+958h] [rbp+768h]
  _QWORD src__4[2]; // [rsp+960h] [rbp+770h] BYREF
  _QWORD src__5[2]; // [rsp+970h] [rbp+780h] BYREF
  _QWORD v260[2]; // [rsp+980h] [rbp+790h] BYREF
  _BYTE v261[8]; // [rsp+990h] [rbp+7A0h] BYREF
  std::_Ref_count_base *v262; // [rsp+998h] [rbp+7A8h]
  _QWORD src__7[6]; // [rsp+9A0h] [rbp+7B0h] BYREF
  _BYTE dst_[16]; // [rsp+9D0h] [rbp+7E0h] BYREF
  __int64 dst__1[2]; // [rsp+9E0h] [rbp+7F0h] BYREF
  _BYTE dst__2[16]; // [rsp+9F0h] [rbp+800h] BYREF
  __int64 dst__3[2]; // [rsp+A00h] [rbp+810h] BYREF
  _BYTE dst__4[16]; // [rsp+A10h] [rbp+820h] BYREF
  __int64 dst__5[2]; // [rsp+A20h] [rbp+830h] BYREF
  _BYTE dst__6[16]; // [rsp+A30h] [rbp+840h] BYREF
  __int64 dst__7[2]; // [rsp+A40h] [rbp+850h] BYREF
  __int64 dst__9[3]; // [rsp+A50h] [rbp+860h] BYREF
  _BYTE dst__8[16]; // [rsp+A68h] [rbp+878h] BYREF
  _DWORD v274[3]; // [rsp+A78h] [rbp+888h] BYREF
  char v275; // [rsp+A84h] [rbp+894h] BYREF
  _DWORD v276[3]; // [rsp+A88h] [rbp+898h] BYREF
  char v277; // [rsp+A94h] [rbp+8A4h] BYREF
  _DWORD v278[3]; // [rsp+A98h] [rbp+8A8h] BYREF
  char v279; // [rsp+AA4h] [rbp+8B4h] BYREF
  _DWORD v280[3]; // [rsp+AA8h] [rbp+8B8h] BYREF
  char v281; // [rsp+AB4h] [rbp+8C4h] BYREF
  _DWORD v282[3]; // [rsp+AB8h] [rbp+8C8h] BYREF
  char v283; // [rsp+AC4h] [rbp+8D4h] BYREF
  _DWORD v284[3]; // [rsp+AC8h] [rbp+8D8h] BYREF
  char v285; // [rsp+AD4h] [rbp+8E4h] BYREF
  _DWORD v286[3]; // [rsp+AD8h] [rbp+8E8h] BYREF
  char v287; // [rsp+AE4h] [rbp+8F4h] BYREF
  _DWORD v288[3]; // [rsp+AE8h] [rbp+8F8h] BYREF
  char v289; // [rsp+AF4h] [rbp+904h] BYREF
  _DWORD v290[3]; // [rsp+AF8h] [rbp+908h] BYREF
  char v291; // [rsp+B04h] [rbp+914h] BYREF
  _DWORD v292[3]; // [rsp+B08h] [rbp+918h] BYREF
  char v293; // [rsp+B14h] [rbp+924h] BYREF

  n2 = *(_DWORD *)(sub_141D17630(a1) + 0x48);
  if ( n2 )
  {
    if ( n2 == 1 )
    {
      *(_DWORD *)(a1 + 0x2F8) = 6;
    }
    else if ( n2 == 2 )
    {
      *(_DWORD *)(a1 + 0x2F8) = 2;
    }
    else
    {
      v26 = 0;
      *(_DWORD *)(a1 + 0x2F8) = 5;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 0x2F8) = 5;
  }
  v72 = *(_QWORD *)(identity((__int64)&pSystem) + 0x98);
  v73 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v72 + 0xA0LL))(v72);
  v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v73 + 0x108LL))(v73);
  v1 = sub_141D17630(a1);
  if ( sub_14037FC70(v1 + 0x18) )
  {
    v74 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x18LL))(v25);
    v119 = *(__int64 (__fastcall **)(__int64, const ULONG_PTR *))(*(_QWORD *)v74 + 0x18LL);
    v2 = sub_141D17630(a1);
    v118 = sub_14037FC70(v2 + 0x18);
    v75 = v119(v74, v118);
    if ( v75 )
    {
      v76 = allocWithProfilerInfo_w(0x28u);
      if ( v76 )
        v77 = sub_1404558D0(v76, v75);
      else
        v77 = 0;
      *(_QWORD *)(a1 + 0xC0) = v77;
      v124 = *(__int64 (__fastcall **)(__int64, _BYTE *, __int64, __int64))(*(_QWORD *)v25 + 0x20LL);
      v122 = *(_QWORD *)(a1 + 0xC0);
      v120 = *(_QWORD *)(a1 + 8);
      v121 = v120;
      v123 = v120;
      _Right = (std::shared_ptr<vraudio::MixerNode> *)v124(v25, v248, v120, v122);
      std::shared_ptr<vraudio::MixerNode>::operator=((std::shared_ptr<vraudio::MixerNode> *)(a1 + 0xB0), _Right);
      if ( v249 )
        std::_Ref_count_base::_Decref(v249);
      v125 = *(_QWORD *)(a1 + 0xB0);
      v57 = v125 != 0;
      if ( v125 )
      {
        v4 = sub_141D17630(a1);
        if ( sub_14037FC70(v4 + 0x28) )
        {
          v78 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x18LL))(v25);
          v127 = *(__int64 (__fastcall **)(__int64, __int64 *, const ULONG_PTR *))(*(_QWORD *)v78 + 8LL);
          v5 = sub_141D17630(a1);
          v126 = sub_14037FC70(v5 + 0x28);
          v6 = (_QWORD *)v127(v78, &v58, v126);
          sub_14217D620((_QWORD *)(a1 + 0xC8), v6);
          if ( v58 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v58 + 0x118LL))(v58);
          v58 = 0;
        }
        else
        {
          v292[0] = sub_142744750(0x2Bu);
          v292[1] = 0x1C;
          v292[2] = 0;
          src_[0] = v292;
          src_[1] = &v293;
          qmemcpy(dst_, src_, sizeof(dst_));
          v28 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)dst_,
                  (__int64)"AnimatedCharacter Initialization",
                  "No Animation Database 3P specified in data for entity [$$] - Check character setup!");
          if ( (v28 & 0xFFFFF) != 0 )
          {
            v79 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
            v128 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v79 + 0x78LL);
            v129 = v128(v79, &v136);
            v130 = sub_1402A2660(v129);
            v228[0] = 0;
            v228[1] = v130;
            v228[2] = 0;
            v132 = v228;
            v80 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
            v81 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v80 + 0x20LL))(v80);
            v131 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v81 + 0x18LL))(v81);
            v229[0] = 0;
            v229[1] = v131;
            v230 = 0;
            v133 = v229;
            ThreadLogContextSlot = getThreadLogContextSlot();
            v252[0] = 0;
            v252[1] = 0;
            v284[0] = sub_142744750(0x2Bu);
            v284[1] = 0x1C;
            v284[2] = 0;
            src__1[0] = v284;
            src__1[1] = &v285;
            qmemcpy(dst__1, src__1, sizeof(dst__1));
            src__7[2] = 3;
            v7 = alloca(0x150);
            v82 = v24;
            __Val_0__ = (vraudio::AudioBuffer *)v24;
            sub_142370910(v24, ThreadLogContextSlot, v133, v132);
            LODWORD(v23) = v28;
            sub_1403045C0(
              3u,
              dst__1,
              "AnimatedCharacter Initialization",
              "No Animation Database 3P specified in data for entity [$$] - Check character setup!",
              __Val_0__,
              3u,
              2,
              v23,
              v252,
              0);
            v135 = v230;
            sub_1402A3D30(v230);
            sub_140370F70((__int64)v228);
            sub_140370D10(&v136);
          }
        }
        v8 = sub_141D17630(a1);
        if ( sub_14037FC70(v8 + 0x38) )
        {
          v84 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x18LL))(v25);
          v138 = *(__int64 (__fastcall **)(__int64, __int64 *, const ULONG_PTR *))(*(_QWORD *)v84 + 8LL);
          v9 = sub_141D17630(a1);
          v137 = sub_14037FC70(v9 + 0x38);
          v10 = (_QWORD *)v138(v84, &v59, v137);
          sub_14217D620((_QWORD *)(a1 + 0xD0), v10);
          if ( v59 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v59 + 0x118LL))(v59);
          v59 = 0;
        }
        else
        {
          v290[0] = sub_142744750(0x2Bu);
          v290[1] = 0x1C;
          v290[2] = 0;
          src__2[0] = v290;
          src__2[1] = &v291;
          qmemcpy(dst__2, src__2, sizeof(dst__2));
          v29 = invokeGlobalCallbackAndMaskStatusBits(
                  3,
                  (__int64)dst__2,
                  (__int64)"AnimatedCharacter Initialization",
                  "No Sound Database specified in data for entity [$$] - Check character setup!");
          if ( (v29 & 0xFFFFF) != 0 )
          {
            v85 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
            v139 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v85 + 0x78LL);
            v140 = v139(v85, &v147);
            v141 = sub_1402A2660(v140);
            v242[0] = 0;
            v242[1] = v141;
            v242[2] = 0;
            v143 = v242;
            v86 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
            v87 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v86 + 0x20LL))(v86);
            v142 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v87 + 0x18LL))(v87);
            v226[0] = 0;
            v226[1] = v142;
            v227 = 0;
            v144 = v226;
            ThreadLogContextSlot_1 = getThreadLogContextSlot();
            v255[0] = 0;
            v255[1] = 0;
            v288[0] = sub_142744750(0x2Bu);
            v288[1] = 0x1C;
            v288[2] = 0;
            src__3[0] = v288;
            src__3[1] = &v289;
            qmemcpy(dst__3, src__3, sizeof(dst__3));
            src__7[3] = 3;
            v11 = alloca(0x150);
            v88 = v24;
            __Val_0___1 = (vraudio::AudioBuffer *)v24;
            sub_142370910(v24, ThreadLogContextSlot_1, v144, v143);
            LODWORD(v23) = v29;
            sub_1403045C0(
              3u,
              dst__3,
              "AnimatedCharacter Initialization",
              "No Sound Database specified in data for entity [$$] - Check character setup!",
              __Val_0___1,
              3u,
              2,
              v23,
              v255,
              0);
            v146 = v227;
            sub_1402A3D30(v227);
            sub_140370F70((__int64)v242);
            sub_140370D10(&v147);
          }
        }
        v90 = sub_140970360(qword_149E7E438);
        v91 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v90 + 0x108LL))(v90);
        v92 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v91 + 0x28LL))(v91);
        v12 = (__int64 *)sub_1457B6CA0(v92, v261, **(_QWORD **)(a1 + 0xC0));
        sub_142704CD0((_QWORD *)(a1 + 0xD8), v12);
        if ( v262 )
          std::_Ref_count_base::_Decref(v262);
        v13 = (__int64 *)sub_1457B6950(v92, v256, **(_QWORD **)(a1 + 0xC0));
        sub_142704CD0((_QWORD *)(a1 + 0xE8), v13);
        if ( v257 )
          std::_Ref_count_base::_Decref(v257);
        v148 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v148 + 0x1D4) != 0xFFFFFFFF )
        {
          v149 = *(_QWORD *)(a1 + 0xB0);
          v93 = v149;
          v151 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v149 + 0x140LL);
          v150 = *(_QWORD *)(a1 + 0xD8);
          v31 = v106;
          v31 = *(_DWORD *)(v150 + 0x1D4);
          LOBYTE(v14) = 1;
          v151(v149, v31, v14);
        }
        v152 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v152 + 0x1D8) != 0xFFFFFFFF )
        {
          v153 = *(_QWORD *)(a1 + 0xB0);
          v94 = v153;
          v155 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v153 + 0x140LL);
          v154 = *(_QWORD *)(a1 + 0xD8);
          v33 = v107;
          v33 = *(_DWORD *)(v154 + 0x1D8);
          LOBYTE(v14) = 1;
          v155(v153, v33, v14);
        }
        v156 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v156 + 0x1DC) != 0xFFFFFFFF )
        {
          v157 = *(_QWORD *)(a1 + 0xB0);
          v95 = v157;
          v159 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v157 + 0x140LL);
          v158 = *(_QWORD *)(a1 + 0xD8);
          v35 = v108;
          v35 = *(_DWORD *)(v158 + 0x1DC);
          LOBYTE(v14) = 1;
          v159(v157, v35, v14);
        }
        v160 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v160 + 0x1E0) != 0xFFFFFFFF )
        {
          v161 = *(_QWORD *)(a1 + 0xB0);
          v96 = v161;
          v163 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v161 + 0x140LL);
          v162 = *(_QWORD *)(a1 + 0xD8);
          v37 = v109;
          v37 = *(_DWORD *)(v162 + 0x1E0);
          LOBYTE(v14) = 1;
          v163(v161, v37, v14);
        }
        v164 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v164 + 0x1E4) != 0xFFFFFFFF )
        {
          v165 = *(_QWORD *)(a1 + 0xB0);
          v97 = v165;
          v167 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v165 + 0x140LL);
          v166 = *(_QWORD *)(a1 + 0xD8);
          v39 = v110;
          v39 = *(_DWORD *)(v166 + 0x1E4);
          LOBYTE(v14) = 1;
          v167(v165, v39, v14);
        }
        v168 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v168 + 0x1E8) != 0xFFFFFFFF )
        {
          v169 = *(_QWORD *)(a1 + 0xB0);
          v98 = v169;
          v171 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v169 + 0x140LL);
          v170 = *(_QWORD *)(a1 + 0xD8);
          v41 = v111;
          v41 = *(_DWORD *)(v170 + 0x1E8);
          LOBYTE(v14) = 1;
          v171(v169, v41, v14);
        }
        v172 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v172 + 0x1EC) != 0xFFFFFFFF )
        {
          v173 = *(_QWORD *)(a1 + 0xB0);
          v99 = v173;
          v175 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v173 + 0x140LL);
          v174 = *(_QWORD *)(a1 + 0xD8);
          v43 = v112;
          v43 = *(_DWORD *)(v174 + 0x1EC);
          LOBYTE(v14) = 1;
          v175(v173, v43, v14);
        }
        v176 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v176 + 0x1F0) != 0xFFFFFFFF )
        {
          v177 = *(_QWORD *)(a1 + 0xB0);
          v100 = v177;
          v179 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v177 + 0x140LL);
          v178 = *(_QWORD *)(a1 + 0xD8);
          v45 = v113;
          v45 = *(_DWORD *)(v178 + 0x1F0);
          LOBYTE(v14) = 1;
          v179(v177, v45, v14);
        }
        v180 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v180 + 0x1F8) != 0xFFFFFFFF )
        {
          v181 = *(_QWORD *)(a1 + 0xB0);
          v101 = v181;
          v183 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v181 + 0x140LL);
          v182 = *(_QWORD *)(a1 + 0xD8);
          v47 = v114;
          v47 = *(_DWORD *)(v182 + 0x1F8);
          LOBYTE(v14) = 1;
          v183(v181, v47, v14);
        }
        v184 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v184 + 0x208) != 0xFFFFFFFF )
        {
          v185 = *(_QWORD *)(a1 + 0xB0);
          v102 = v185;
          v187 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v185 + 0x140LL);
          v186 = *(_QWORD *)(a1 + 0xD8);
          v49 = v115;
          v49 = *(_DWORD *)(v186 + 0x208);
          LOBYTE(v14) = 1;
          v187(v185, v49, v14);
        }
        v188 = *(_QWORD *)(a1 + 0xD8);
        if ( *(_DWORD *)(v188 + 0x20C) != 0xFFFFFFFF )
        {
          v189 = *(_QWORD *)(a1 + 0xB0);
          v103 = v189;
          v191 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v189 + 0x140LL);
          v190 = *(_QWORD *)(a1 + 0xD8);
          v51 = v116;
          v51 = *(_DWORD *)(v190 + 0x20C);
          LOBYTE(v14) = 1;
          v191(v189, v51, v14);
        }
        v192 = *(_QWORD *)(a1 + 0xE8);
        if ( *(_DWORD *)(v192 + 0x64) != 0xFFFFFFFF )
        {
          v193 = *(_QWORD *)(a1 + 0xB0);
          v104 = v193;
          v195 = *(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v193 + 0x148LL);
          v194 = *(_QWORD *)(a1 + 0xE8);
          v53 = v117;
          v53 = *(_DWORD *)(v194 + 0x64);
          LOBYTE(v14) = 1;
          v195(v193, v53, v14);
        }
      }
      else
      {
        v286[0] = sub_142744750(0x2Bu);
        v286[1] = 0x1C;
        v286[2] = 0;
        src__4[0] = v286;
        src__4[1] = &v287;
        qmemcpy(dst__4, src__4, sizeof(dst__4));
        v54 = invokeGlobalCallbackAndMaskStatusBits(
                3,
                (__int64)dst__4,
                (__int64)"AnimatedCharacter Initialization",
                "Unable to create Action Controller for entity [$$] - Check character setup!");
        if ( (v54 & 0xFFFFF) != 0 )
        {
          v105 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
          v196 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v105 + 0x78LL);
          v197 = v196(v105, &v204);
          v198 = sub_1402A2660(v197);
          v241[0] = 0;
          v241[1] = v198;
          v241[2] = 0;
          v200 = v241;
          v69 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
          v70 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v69 + 0x20LL))(v69);
          v199 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v70 + 0x18LL))(v70);
          v231[0] = 0;
          v231[1] = v199;
          v232 = 0;
          v201 = v231;
          ThreadLogContextSlot_2 = getThreadLogContextSlot();
          v260[0] = 0;
          v260[1] = 0;
          v282[0] = sub_142744750(0x2Bu);
          v282[1] = 0x1C;
          v282[2] = 0;
          src__5[0] = v282;
          src__5[1] = &v283;
          qmemcpy(dst__5, src__5, sizeof(dst__5));
          src__7[4] = 3;
          v15 = alloca(0x150);
          v71 = v24;
          __Val_0___2 = (vraudio::AudioBuffer *)v24;
          sub_142370910(v24, ThreadLogContextSlot_2, v201, v200);
          LODWORD(v23) = v54;
          sub_1403045C0(
            3u,
            dst__5,
            "AnimatedCharacter Initialization",
            "Unable to create Action Controller for entity [$$] - Check character setup!",
            __Val_0___2,
            3u,
            2,
            v23,
            v260,
            0);
          v203 = v232;
          sub_1402A3D30(v232);
          sub_140370F70((__int64)v241);
          sub_140370D10(&v204);
        }
      }
    }
    else
    {
      v280[0] = sub_142744750(0x2Bu);
      v280[1] = 0x1C;
      v280[2] = 0;
      src__6[0] = v280;
      src__6[1] = &v281;
      qmemcpy(dst__6, src__6, sizeof(dst__6));
      v55 = invokeGlobalCallbackAndMaskStatusBits(
              3,
              (__int64)dst__6,
              (__int64)"AnimatedCharacter Initialization",
              "Unable to load controller definition file [$$] for entity [$$] - Check character setup!");
      if ( (v55 & 0xFFFFF) != 0 )
      {
        v61 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
        v205 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v61 + 0x78LL);
        v206 = v205(v61, &v216);
        v207 = sub_1402A2660(v206);
        v235[0] = 0;
        v235[1] = v207;
        v235[2] = 0;
        v210 = v235;
        v16 = sub_141D17630(a1);
        v208 = sub_14037FC70(v16 + 0x18);
        v237[0] = 0;
        v237[1] = v208;
        v238 = 0;
        v211 = v237;
        v17 = sub_141D17630(a1);
        v209 = sub_14037FC70(v17 + 0x18);
        v239[0] = 0;
        v239[1] = v209;
        v240 = 0;
        v212 = v239;
        ThreadLogContextSlot_3 = getThreadLogContextSlot();
        v243[0] = 0;
        v243[1] = 0;
        v278[0] = sub_142744750(0x2Bu);
        v278[1] = 0x1C;
        v278[2] = 0;
        src__7[0] = v278;
        src__7[1] = &v279;
        qmemcpy(dst__7, src__7, sizeof(dst__7));
        src__7[5] = 4;
        v18 = alloca(0x1C0);
        v62 = v22;
        __Val_0___3 = (vraudio::AudioBuffer *)v22;
        sub_1457B9A20((unsigned int)v22, (_DWORD)ThreadLogContextSlot_3, (_DWORD)v212, (_DWORD)v211, (__int64)v210);
        LODWORD(v21) = v55;
        sub_1403045C0(
          3u,
          dst__7,
          "AnimatedCharacter Initialization",
          "Unable to load controller definition file [$$] for entity [$$] - Check character setup!",
          __Val_0___3,
          4u,
          2,
          v21,
          v243,
          0);
        v214 = v240;
        sub_1402A3D30(v240);
        v215 = v238;
        sub_1402A3D30(v238);
        sub_140370F70((__int64)v235);
        sub_140370D10(&v216);
      }
    }
  }
  else
  {
    v276[0] = sub_142744750(0x2Bu);
    v276[1] = 0x1C;
    v276[2] = 0;
    src__8[0] = v276;
    src__8[1] = &v277;
    qmemcpy(dst__8, src__8, sizeof(dst__8));
    v56 = invokeGlobalCallbackAndMaskStatusBits(
            3,
            (__int64)dst__8,
            (__int64)"AnimatedCharacter Initialization",
            "No Action Controller specified in data for entity [$$] - Check character setup!");
    if ( (v56 & 0xFFFFF) != 0 )
    {
      v64 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
      v217 = *(__int64 (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v64 + 0x78LL);
      v218 = v217(v64, &v225);
      v219 = sub_1402A2660(v218);
      v236[0] = 0;
      v236[1] = v219;
      v236[2] = 0;
      v221 = v236;
      v65 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
      v66 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v65 + 0x20LL))(v65);
      v220 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v66 + 0x18LL))(v66);
      v233[0] = 0;
      v233[1] = v220;
      v234 = 0;
      v222 = v233;
      ThreadLogContextSlot_4 = getThreadLogContextSlot();
      v246[0] = 0;
      v246[1] = 0;
      v274[0] = sub_142744750(0x2Bu);
      v274[1] = 0x1C;
      v274[2] = 0;
      src__9[0] = v274;
      src__9[1] = &v275;
      qmemcpy(dst__9, src__9, 0x10u);
      dst__9[2] = 3;
      v19 = alloca(0x150);
      v67 = v24;
      __Val_0___4 = (vraudio::AudioBuffer *)v24;
      sub_142370910(v24, ThreadLogContextSlot_4, v222, v221);
      LODWORD(v23) = v56;
      sub_1403045C0(
        3u,
        dst__9,
        "AnimatedCharacter Initialization",
        "No Action Controller specified in data for entity [$$] - Check character setup!",
        __Val_0___4,
        3u,
        2,
        v23,
        v246,
        0);
      v224 = v234;
      sub_1402A3D30(v234);
      sub_140370F70((__int64)v236);
      sub_140370D10(&v225);
    }
  }
  return sub_1457E3030(a1);
}

// --- End Function: sub_1457D5090 (0x1457D5090) ---

// --- Function: sub_1457E2F40 (0x1457E2F40) ---
__int64 __fastcall sub_1457E2F40(__int64 a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // [rsp+20h] [rbp-C8h]
  __int64 v3; // [rsp+28h] [rbp-C0h] BYREF
  __int64 v4; // [rsp+30h] [rbp-B8h]
  void (__fastcall *v5)(unsigned __int64, __int64 *); // [rsp+38h] [rbp-B0h]
  __int64 (__fastcall *v6)(__int64, _BYTE *); // [rsp+40h] [rbp-A8h]
  _BYTE v7[4]; // [rsp+50h] [rbp-98h] BYREF
  float v8; // [rsp+54h] [rbp-94h]
  float v9; // [rsp+58h] [rbp-90h]
  float v10; // [rsp+94h] [rbp-54h]

  sub_142EC37E0((__int64)v7);
  v2 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  v5 = *(void (__fastcall **)(unsigned __int64, __int64 *))(*(_QWORD *)v2 + 0x3B8LL);
  v5(v2, &v3);
  result = HIWORD_w(&v3);
  if ( (_BYTE)result )
  {
    v4 = sub_14030ECF0(&v3);
    v6 = *(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v4 + 0x20LL);
    result = v6(v4, v7);
    if ( (_DWORD)result )
    {
      *(float *)(a1 + 0x104) = v8;
      *(float *)(a1 + 0x108) = v9;
      result = a1;
      *(float *)(a1 + 0x10C) = v10;
    }
  }
  return result;
}

// --- End Function: sub_1457E2F40 (0x1457E2F40) ---

// --- Function: sub_1457E3030 (0x1457E3030) ---
__int64 __fastcall sub_1457E3030(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 0xB0) )
  {
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xB0) + 0x20LL))(*(_QWORD *)(a1 + 0xB0));
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0xB0) + 0x28LL))(*(_QWORD *)(a1 + 0xB0));
    (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 0xB0) + 0xF0LL))(*(_QWORD *)(a1 + 0xB0), 7);
  }
  sub_1457E3130(a1);
  return sub_1457E2F40(a1);
}

// --- End Function: sub_1457E3030 (0x1457E3030) ---

// --- Function: sub_1457E3130 (0x1457E3130) ---
__int64 __fastcall sub_1457E3130(__int64 a1)
{
  __int64 v1; // rax
  __int64 result; // rax
  char v3; // [rsp+20h] [rbp-288h]
  unsigned __int64 n4; // [rsp+50h] [rbp-258h]
  unsigned __int64 n7; // [rsp+58h] [rbp-250h]
  unsigned __int64 n5; // [rsp+68h] [rbp-240h]
  float v7; // [rsp+78h] [rbp-230h]
  float v8; // [rsp+80h] [rbp-228h]
  float v9; // [rsp+88h] [rbp-220h]
  float v10; // [rsp+90h] [rbp-218h]
  float v11; // [rsp+98h] [rbp-210h]
  __int64 v12; // [rsp+D8h] [rbp-1D0h]
  unsigned __int64 v13; // [rsp+E0h] [rbp-1C8h]
  float src__1[4]; // [rsp+E8h] [rbp-1C0h] BYREF
  float src__2[4]; // [rsp+F8h] [rbp-1B0h] BYREF
  float src__3[4]; // [rsp+108h] [rbp-1A0h] BYREF
  float src__4[4]; // [rsp+118h] [rbp-190h] BYREF
  __int64 v18; // [rsp+128h] [rbp-180h]
  __int64 v19; // [rsp+130h] [rbp-178h]
  __int64 v20; // [rsp+138h] [rbp-170h]
  AK::WriteBytesCount *v21; // [rsp+140h] [rbp-168h]
  AK::WriteBytesCount *v22; // [rsp+148h] [rbp-160h]
  AK::WriteBytesCount *v23; // [rsp+150h] [rbp-158h]
  AK::WriteBytesCount *v24; // [rsp+158h] [rbp-150h]
  __int64 v25; // [rsp+160h] [rbp-148h]
  __int64 v26; // [rsp+168h] [rbp-140h]
  __int64 v27; // [rsp+170h] [rbp-138h]
  __int64 v28; // [rsp+178h] [rbp-130h]
  __int64 v29; // [rsp+180h] [rbp-128h]
  __int64 v30; // [rsp+188h] [rbp-120h]
  __int64 v31; // [rsp+190h] [rbp-118h]
  __int64 v32; // [rsp+198h] [rbp-110h]
  __int64 v33; // [rsp+1A0h] [rbp-108h]
  unsigned __int64 v34; // [rsp+1A8h] [rbp-100h]
  __int64 v35; // [rsp+1B0h] [rbp-F8h]
  __int64 (__fastcall *v36)(unsigned __int64, _BYTE *, __int64, _QWORD, char); // [rsp+1B8h] [rbp-F0h]
  __int64 v37; // [rsp+1C0h] [rbp-E8h]
  __int64 v38; // [rsp+1C8h] [rbp-E0h]
  __int64 v39; // [rsp+1D0h] [rbp-D8h]
  _BYTE src_[28]; // [rsp+1D8h] [rbp-D0h] BYREF
  _BYTE src__5[28]; // [rsp+1F4h] [rbp-B4h] BYREF
  _BYTE src__6[16]; // [rsp+210h] [rbp-98h] BYREF
  float v43; // [rsp+220h] [rbp-88h]
  float v44; // [rsp+224h] [rbp-84h]
  float v45; // [rsp+228h] [rbp-80h]
  float v46; // [rsp+22Ch] [rbp-7Ch]
  float v47; // [rsp+230h] [rbp-78h]
  float v48; // [rsp+234h] [rbp-74h]
  float v49; // [rsp+238h] [rbp-70h]
  float v50; // [rsp+23Ch] [rbp-6Ch]
  float v51; // [rsp+240h] [rbp-68h]
  float v52; // [rsp+244h] [rbp-64h]
  float v53; // [rsp+248h] [rbp-60h]
  float v54; // [rsp+24Ch] [rbp-5Ch]
  _BYTE v55[88]; // [rsp+250h] [rbp-58h] BYREF

  sub_143606890(a1 + 0xF8);
  *(_BYTE *)(a1 + 0x18E) = 0;
  *(_DWORD *)(a1 + 0x114) = 0xFFFFFFFF;
  v12 = *(_QWORD *)(identity((__int64)&pSystem) + 0xF8);
  *(_DWORD *)(a1 + 0x118) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x538LL))(v12);
  *(_DWORD *)(a1 + 0x11C) = 0xFFFFFFFF;
  *(float *)(a1 + 0x170) = 0x3F800000;
  sub_1433ADB50((float *)(a1 + 0x174));
  *(float *)(a1 + 0x184) = 0x3F800000;
  *(float *)(a1 + 0x188) = sub_1433712C0(a1 + 0x174);
  *(_DWORD *)(a1 + 0x120) = 0;
  *(_DWORD *)(a1 + 0x124) = 0;
  *(float *)(a1 + 0x130) = 0;
  *(float *)(a1 + 0x12C) = 0;
  *(float *)(a1 + 0x128) = 0;
  *(float *)(a1 + 0x140) = 0x3F800000;
  *(float *)(a1 + 0x134) = 0;
  *(float *)(a1 + 0x138) = 0;
  *(float *)(a1 + 0x13C) = 0;
  sub_1457E2F30(a1 + 0x144);
  *(float *)(a1 + 0x198) = 0;
  *(float *)(a1 + 0x19C) = 0;
  *(float *)(a1 + 0x190) = 0;
  *(float *)(a1 + 0x194) = 0;
  *(float *)(a1 + 0x1A0) = 0;
  v13 = sub_1403E6750((unsigned __int64 *)(a1 + 8));
  v36 = *(__int64 (__fastcall **)(unsigned __int64, _BYTE *, __int64, _QWORD, char))(*(_QWORD *)v13 + 0x1E8LL);
  v3 = 0;
  v1 = v36(v13, v55, 2, 0, v3);
  sub_1402B4740(a1 + 0x1E8, v1);
  *(float *)(a1 + 0x27C) = 0x3F800000;
  *(float *)(a1 + 0x270) = 0;
  *(float *)(a1 + 0x274) = 0;
  *(float *)(a1 + 0x278) = 0;
  *(float *)(a1 + 0x280) = 0;
  *(float *)(a1 + 0x284) = 0;
  *(float *)(a1 + 0x288) = 0;
  for ( n7 = 0; n7 < 7; ++n7 )
  {
    *(_DWORD *)(a1 + 0x2A4 + 4 * n7) = 1;
    *(_DWORD *)(a1 + 0x2C0 + 4 * n7) = 1;
  }
  for ( n4 = 0; n4 < 4; ++n4 )
  {
    *(_DWORD *)(a1 + 0x2A4 + 4 * n4) = 0;
    *(_DWORD *)(a1 + 0x2C0 + 4 * n4) = 0;
  }
  for ( n5 = 0; n5 < 5; ++n5 )
    *(_DWORD *)(a1 + 4 * n5 + 0x2E0) = 0;
  *(_DWORD *)(a1 + 0x2F4) = 0;
  *(float *)(a1 + 0x310) = 0x3F800000;
  *(float *)(a1 + 0x304) = 0;
  *(float *)(a1 + 0x308) = 0;
  *(float *)(a1 + 0x30C) = 0;
  *(float *)(a1 + 0x314) = 0;
  *(float *)(a1 + 0x318) = 0;
  *(float *)(a1 + 0x31C) = 0;
  *(_DWORD *)(a1 + 0x320) = 0;
  v47 = 0.0;
  v48 = 0.0;
  v37 = LOBYTE(v47);
  v20 = LOBYTE(v47);
  v49 = 0.0;
  v50 = 0.0;
  v38 = LOBYTE(v49);
  v19 = LOBYTE(v49);
  v51 = 0.0;
  v52 = 0.0;
  v39 = LOBYTE(v51);
  v18 = LOBYTE(v51);
  *(_QWORD *)src_ = LOBYTE(v51);
  *(_QWORD *)&src_[8] = LOBYTE(v49);
  *(_QWORD *)&src_[0x10] = LOBYTE(v47);
  *(float *)&src_[0x18] = 0.050000001;
  qmemcpy((void *)(a1 + 0x344), src_, 0x1Cu);
  v21 = qword_149E12BA0;
  v7 = *((float *)qword_149E12BA0 + 0x22);
  src__1[0] = 0.0;
  src__1[1] = 0.0;
  src__1[2] = 0.0;
  src__1[3] = v7;
  qmemcpy((void *)(a1 + 0x360), src__1, 0x10u);
  v22 = qword_149E12BA0;
  v8 = *((float *)qword_149E12BA0 + 0x20);
  src__2[0] = 0.0;
  src__2[1] = 0.0;
  src__2[2] = 0.0;
  src__2[3] = v8;
  qmemcpy((void *)(a1 + 0x370), src__2, 0x10u);
  v23 = qword_149E12BA0;
  v11 = *((float *)qword_149E12BA0 + 0x20);
  src__3[0] = 0.0;
  src__3[1] = 0.0;
  src__3[2] = 0.0;
  src__3[3] = v11;
  qmemcpy((void *)(a1 + 0x380), src__3, 0x10u);
  v24 = qword_149E12BA0;
  v9 = *((float *)qword_149E12BA0 + 0x20);
  src__4[0] = 0.0;
  src__4[1] = 0.0;
  src__4[2] = 0.0;
  src__4[3] = v9;
  qmemcpy((void *)(a1 + 0x390), src__4, 0x10u);
  v10 = *((float *)qword_149E12BA0 + 0x21);
  v53 = 0.0;
  v54 = 0.0;
  v25 = LOBYTE(v53);
  v26 = LOBYTE(v53);
  v33 = LOBYTE(v53);
  v43 = 0.0;
  v44 = 0.0;
  v27 = LOBYTE(v43);
  v28 = LOBYTE(v43);
  v32 = LOBYTE(v43);
  v45 = 0.0;
  v46 = 0.0;
  v29 = LOBYTE(v45);
  v30 = LOBYTE(v45);
  v31 = LOBYTE(v45);
  *(_QWORD *)src__5 = LOBYTE(v45);
  *(_QWORD *)&src__5[8] = LOBYTE(v43);
  *(_QWORD *)&src__5[0x10] = LOBYTE(v53);
  *(float *)&src__5[0x18] = v10;
  qmemcpy((void *)(a1 + 0x3A0), src__5, 0x1Cu);
  *(_BYTE *)(a1 + 0x340) = 0;
  *(float *)(a1 + 0x298) = 0x7F7FFFFF;
  *(float *)(a1 + 0x29C) = 0;
  *(_BYTE *)(a1 + 0x2A0) = 0;
  *(_BYTE *)(a1 + 0x2FC) = 0;
  *(float *)(a1 + 0x3BC) = 0;
  *(_BYTE *)(a1 + 0x3C0) = 0;
  *(_BYTE *)(a1 + 0x110) = 0;
  *(_BYTE *)(a1 + 0x111) = 0;
  *(_BYTE *)(a1 + 0x112) = 0;
  if ( HIWORD_w((_QWORD *)(a1 + 0x3C8)) )
  {
    v35 = *(_QWORD *)(identity((__int64)&pSystem) + 0x20);
    v34 = *(_QWORD *)(a1 + 0x3C8);
    sub_1420373C0(v35, v34);
    set_ptr_null((_QWORD *)(a1 + 0x3C8));
  }
  sub_1432075F0(a1);
  *(_BYTE *)(a1 + 0x1A4) = 0;
  *(_BYTE *)(a1 + 0x1A5) = 0;
  *(float *)(a1 + 0x1B4) = 0x3F800000;
  *(float *)(a1 + 0x1A8) = 0;
  *(float *)(a1 + 0x1AC) = 0;
  *(float *)(a1 + 0x1B0) = 0;
  *(float *)(a1 + 0x1B8) = 0;
  *(float *)(a1 + 0x1BC) = 0;
  *(float *)(a1 + 0x1C0) = 0;
  *(_BYTE *)(a1 + 0x1C4) = 0;
  sub_1402AE7E0((__int64)src__6);
  qmemcpy((void *)(a1 + 0x1C8), src__6, 0xCu);
  *(_BYTE *)(a1 + 0x1D4) = 0;
  *(float *)(a1 + 0x1E4) = 0x3F800000;
  *(float *)(a1 + 0x1D8) = 0;
  *(float *)(a1 + 0x1DC) = 0;
  result = a1 + 0x1D8;
  *(float *)(a1 + 0x1E0) = 0;
  return result;
}

// --- End Function: sub_1457E3130 (0x1457E3130) ---

// --- Function: sub_14696E540 (0x14696E540) ---
void __fastcall sub_14696E540(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rdi
  const void *v4; // r14
  unsigned __int64 *i; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    v3 = *(_QWORD *)(v1 - 8);
    v4 = (const void *)(v1 - 8);
    for ( i = (unsigned __int64 *)(v1 + 0x10 * v3); v3; --v3 )
    {
      i += 0xFFFFFFFE;
      sub_1407EAB20(i, 0, 0);
    }
    sub_1402A3D30(v4);
    *a1 = 0;
  }
  else
  {
    *a1 = 0;
  }
}

// --- End Function: sub_14696E540 (0x14696E540) ---

// --- Function: sub_146E1D330 (0x146E1D330) ---
__int64 __fastcall sub_146E1D330(__int64 a1)
{
  __int64 result; // rax
  int v3; // ebx
  const void *v4; // rcx

  if ( AssetMeta::HasActorSubresource((__int64 *)(a1 + 8))
    && *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 0x72E0LL) + 0x4D8LL) == 0x55AA55AA )
  {
    result = sub_146E40FA0(a1);
    *(_DWORD *)(a1 + 0x140) = result;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 0x140);
    result = sub_146E40FA0(a1);
    if ( (int)result > v3 )
    {
      v4 = *(const void **)(a1 + 0x138);
      *(_DWORD *)(a1 + 0x140) = (((((int)result + 0xF) >> 0x1F) & 0xF) + result + 0xF) & 0xFFFFFFF0;
      if ( v4 )
      {
        sub_1402A3D30(v4);
        *(_QWORD *)(a1 + 0x138) = 0;
      }
      result = allocWithProfilerInfo_w(saturated_mul(*(int *)(a1 + 0x140), 0x24u));
      *(_QWORD *)(a1 + 0x138) = result;
    }
  }
  return result;
}

// --- End Function: sub_146E1D330 (0x146E1D330) ---

// --- Function: sub_146E2F800 (0x146E2F800) ---
__int64 __fastcall sub_146E2F800(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int16 n4; // dx
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_QWORD *)(a1 + 8);
  v5 = v1;
  if ( v1
    && (v2 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL), n4 = *(_WORD *)(v2 + 4), n4 != 4)
    && *(_WORD *)(v2 + 2) == (HIWORD(v1) & 0xFFF)
    && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v5)) )
  {
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v1 & 0xFFFFFFFFFFFFLL) + 0x6E8LL))(v1 & 0xFFFFFFFFFFFFLL);
  }
  else
  {
    return 0;
  }
}

// --- End Function: sub_146E2F800 (0x146E2F800) ---

// --- Function: sub_146E402D0 (0x146E402D0) ---
void __fastcall sub_146E402D0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int16 n4; // dx
  __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_QWORD *)(a1 + 8);
  v4 = v1;
  if ( v1 )
  {
    v2 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v2 + 4);
    if ( n4 != 4
      && *(_WORD *)(v2 + 2) == (HIWORD(v1) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v4)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)(v1 & 0xFFFFFFFFFFFFLL) + 0x6F0LL))(v1 & 0xFFFFFFFFFFFFLL);
    }
  }
}

// --- End Function: sub_146E402D0 (0x146E402D0) ---

// --- Function: sub_146E44B20 (0x146E44B20) ---
char __fastcall sub_146E44B20(float *a1, int a2, __int64 **a3, __int64 a4, int a5)
{
  __int128 v5; // xmm6
  __int128 v6; // xmm7
  __int128 v7; // xmm8
  __int128 v8; // xmm9
  __int128 v9; // xmm10
  __int128 v10; // xmm11
  __int128 v11; // xmm12
  __int128 v12; // xmm13
  __int128 v13; // xmm14
  __int128 v14; // xmm15
  void *v15; // rbx
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  __int64 v20; // rsi
  __int64 v21; // rax
  bool v22; // al
  __int64 v23; // rdx
  int v24; // eax
  __int64 v35; // rcx
  void *v36; // rsi
  float v37; // xmm3_4
  float v38; // xmm4_4
  float v39; // kr00_4
  __int64 v42; // rbx
  int v43; // r12d
  unsigned __int32 v44; // eax
  __int64 v45; // rax
  _QWORD *v46; // rcx
  __int64 v47; // r12
  __int64 v48; // r13
  bool v49; // zf
  __int64 v50; // rsi
  __int64 v51; // rax
  int v52; // ecx
  __int64 v53; // rdx
  void **v54; // rax
  char **v55; // rax
  float v56; // xmm1_4
  unsigned __int64 v57; // rdx
  __int64 v58; // rax
  __int64 v59; // rax
  __int128 v60; // xmm0
  __int64 v61; // rax
  __int64 v62; // rax
  __int64 v63; // rax
  __int64 *v64; // rcx
  float v65; // xmm3_4
  float v66; // xmm0_4
  float v67; // kr00_4
  float v68; // xmm8_4
  float v69; // xmm12_4
  float v70; // xmm13_4
  float v71; // xmm10_4
  float v72; // xmm14_4
  float v73; // xmm15_4
  float v74; // xmm11_4
  float v75; // xmm7_4
  float v76; // xmm6_4
  float v77; // xmm4_4
  float v78; // xmm3_4
  float v79; // xmm4_4
  float v80; // xmm3_4
  __int64 v81; // rax
  int v82; // eax
  __int64 v83; // rcx
  int v84; // eax
  unsigned __int32 v85; // eax
  char result; // al
  __int64 *v87; // rcx
  void *v88; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int64 v89; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v90; // [rsp+40h] [rbp-C0h]
  void (__fastcall *v91)(__int64 *, _QWORD *); // [rsp+48h] [rbp-B8h]
  __int64 *v92; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v93; // [rsp+58h] [rbp-A8h] BYREF
  const char *v94; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v95; // [rsp+68h] [rbp-98h]
  unsigned __int64 v96; // [rsp+70h] [rbp-90h] BYREF
  __int64 *v97; // [rsp+78h] [rbp-88h]
  _BYTE v98[4]; // [rsp+80h] [rbp-80h] BYREF
  float v99; // [rsp+84h] [rbp-7Ch]
  float v100; // [rsp+88h] [rbp-78h]
  float v101; // [rsp+8Ch] [rbp-74h]
  float v102; // [rsp+90h] [rbp-70h]
  float v103; // [rsp+94h] [rbp-6Ch]
  float v104; // [rsp+98h] [rbp-68h]
  float v105; // [rsp+9Ch] [rbp-64h]
  float v106; // [rsp+A0h] [rbp-60h]
  float v107; // [rsp+A4h] [rbp-5Ch]
  float v108; // [rsp+A8h] [rbp-58h]
  __int64 v109; // [rsp+F8h] [rbp-8h]
  int n2; // [rsp+100h] [rbp+0h]
  __int64 v111; // [rsp+130h] [rbp+30h]
  _QWORD v112[10]; // [rsp+160h] [rbp+60h] BYREF
  __int128 v113; // [rsp+1B0h] [rbp+B0h]
  float v114; // [rsp+1C0h] [rbp+C0h]
  float v115; // [rsp+1C4h] [rbp+C4h]
  float v116; // [rsp+1C8h] [rbp+C8h]
  float v117; // [rsp+1CCh] [rbp+CCh]
  int v118; // [rsp+1D0h] [rbp+D0h]
  __int64 v119; // [rsp+1D8h] [rbp+D8h]
  __int64 v120; // [rsp+1E0h] [rbp+E0h]
  __int128 v121; // [rsp+1E8h] [rbp+E8h]
  double v122; // [rsp+1F8h] [rbp+F8h]
  float v123; // [rsp+200h] [rbp+100h]
  float v124; // [rsp+204h] [rbp+104h]
  char v125; // [rsp+208h] [rbp+108h]
  _QWORD v126[2]; // [rsp+210h] [rbp+110h] BYREF
  unsigned int v127; // [rsp+220h] [rbp+120h]
  int v128; // [rsp+224h] [rbp+124h]
  __int64 v129; // [rsp+228h] [rbp+128h]
  __int64 v130; // [rsp+230h] [rbp+130h]
  __int64 v131; // [rsp+238h] [rbp+138h]
  __int64 v132; // [rsp+240h] [rbp+140h]
  __int64 v133; // [rsp+248h] [rbp+148h]
  __int64 v134; // [rsp+250h] [rbp+150h]
  int v135; // [rsp+258h] [rbp+158h]
  int v136; // [rsp+25Ch] [rbp+15Ch]
  __int64 v137; // [rsp+260h] [rbp+160h]
  _QWORD v138[2]; // [rsp+268h] [rbp+168h] BYREF
  int v139; // [rsp+278h] [rbp+178h]
  int v140; // [rsp+27Ch] [rbp+17Ch]
  __int64 v141; // [rsp+280h] [rbp+180h]
  __int64 v142; // [rsp+288h] [rbp+188h]
  __int64 v143; // [rsp+290h] [rbp+190h]
  __int64 v144; // [rsp+298h] [rbp+198h]
  __int64 v145; // [rsp+2A0h] [rbp+1A0h]
  __int64 v146; // [rsp+2A8h] [rbp+1A8h]
  int v147; // [rsp+2B0h] [rbp+1B0h]
  int v148; // [rsp+2B4h] [rbp+1B4h]
  __int64 v149; // [rsp+2B8h] [rbp+1B8h]
  __int64 v150; // [rsp+2C0h] [rbp+1C0h] BYREF
  _BYTE v151[100]; // [rsp+2D0h] [rbp+1D0h] BYREF
  float v152; // [rsp+334h] [rbp+234h]
  wchar_t String[128]; // [rsp+3F0h] [rbp+2F0h] BYREF
  __int128 v154; // [rsp+500h] [rbp+400h]
  __int128 v155; // [rsp+510h] [rbp+410h]
  __int128 v156; // [rsp+520h] [rbp+420h]
  __int128 v157; // [rsp+530h] [rbp+430h]
  __int128 v158; // [rsp+540h] [rbp+440h]
  __int128 v159; // [rsp+550h] [rbp+450h]
  __int128 v160; // [rsp+560h] [rbp+460h]
  __int128 v161; // [rsp+570h] [rbp+470h]
  __int128 v162; // [rsp+580h] [rbp+480h]
  __int128 v163; // [rsp+590h] [rbp+490h]

  v15 = (void *)a2;
  if ( a2 >= 0
    && (v18 = *(_QWORD *)(*(_QWORD *)a1 + 0x72E0LL), (int)v15 < *(_DWORD *)(v18 + 0x528))
    && (v19 = *((_QWORD *)a1 + 3)) != 0
    && *(_QWORD *)((v19 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v19)
    && *(_DWORD *)(v18 + 0x4D8) == 0x55AA55AA )
  {
    if ( !AssetMeta::HasActorSubresource((__int64 *)a1 + 1) )
    {
      v93 = *(_QWORD *)(*(_QWORD *)a1 + 0x7358LL);
      if ( is_entity_descriptor_valid_or_accessible(&v93) )
        *((_QWORD *)a1 + 1) = *sub_14033A860(v93 & 0xFFFFFFFFFFFFLL, &v150);
    }
    sub_140370740((__int64)v151);
    sub_146E4C0B0(a1, (unsigned int)v15, 7);
    if ( *a3 )
    {
      v20 = *(_QWORD *)a1;
      v163 = v5;
      v162 = v6;
      sub_141EF0850((__int64)v98);
      v21 = *(_QWORD *)a1;
      LODWORD(v89) = 0;
      v96 = *(_QWORD *)(v21 + 0x7358);
      v22 = is_entity_descriptor_valid_or_accessible(&v96);
      v23 = *(_QWORD *)a1;
      if ( v22 )
      {
        n2 = 2;
        v109 = *(_QWORD *)(v23 + 0x7358);
        v111 = *(_QWORD *)(v23 + 0x7358);
        v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v23 + 0x7358) & 0xFFFFFFFFFFFFLL) + 0x198LL))(*(_QWORD *)(v23 + 0x7358) & 0xFFFFFFFFFFFFLL);
        v23 = *(_QWORD *)a1;
        LODWORD(v89) = v24;
      }
      else
      {
        n2 = 4;
        v109 = v23;
      }
      *(float *)&v88 = v152;
      _XMM6 = 0;
      if ( (LODWORD(v152) & 0xFFA00000) != 0xFFA00000 )
      {
        _XMM0 = LODWORD(v99);
        __asm
        {
          vcmpltss xmm1, xmm6, xmm2
          vblendvps xmm1, xmm0, xmm2, xmm1
        }
        v99 = *(float *)&_XMM1;
      }
      _XMM0 = LODWORD(v100);
      __asm
      {
        vcmpless xmm1, xmm6, xmm2
        vblendvps xmm1, xmm0, xmm2, xmm1
      }
      _XMM0 = LODWORD(v99);
      v100 = *(float *)&_XMM1;
      __asm
      {
        vcmpltss xmm1, xmm6, xmm3
        vblendvps xmm1, xmm0, xmm3, xmm1
      }
      v99 = *(float *)&_XMM1;
      v35 = *(_QWORD *)(v20 + 0x4E78);
      v36 = v15;
      v88 = v15;
      v37 = *(float *)(0x1CLL * (_QWORD)v15 + v35 + 0x10) + a1[0x16];
      v38 = *(float *)(0x1CLL * (_QWORD)v15 + v35 + 0x14) + a1[0x17];
      v39 = *(float *)(0x1CLL * (_QWORD)v15 + v35 + 0x18) + a1[0x18];
      v103 = v39;
      v101 = v37;
      v102 = v38;
      v104 = *(float *)(0x1CLL * (_QWORD)v15 + v35);
      v105 = *(float *)(0x1CLL * (_QWORD)v15 + v35 + 4);
      v106 = *(float *)(0x1CLL * (_QWORD)v15 + v35 + 8);
      v107 = *(float *)(0x1CLL * (_QWORD)v15 + v35 + 0xC);
      _XMM2 = *(unsigned __int64 *)(v23 + 0x7218);
      __asm { vcvtpd2ps xmm2, xmm2 }
      if ( fabs(*(float *)&_XMM2 - 1.0) > 0.001 )
      {
        v101 = v37 * *(float *)&_XMM2;
        v103 = v39 * *(float *)&_XMM2;
        v108 = *(float *)&_XMM2;
        v102 = v38 * *(float *)&_XMM2;
      }
      sub_146E402D0((__int64)a1);
      v42 = *(_QWORD *)a1 + 0x50E8LL;
      v43 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
      if ( *(_DWORD *)(v42 + 0x10) == v43 )
      {
        ++*(_DWORD *)(v42 + 0x14);
      }
      else
      {
        v44 = _InterlockedCompareExchange((volatile signed __int32 *)v42, 1, 0);
        if ( v44 )
          sub_1403C33A0(v42, v44, "CSkeletonPhysics::PhysicalizeStatObjOnJoint", 1);
        else
          *(_QWORD *)(v42 + 8) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
        *(_DWORD *)(v42 + 0x10) = v43;
      }
      v45 = *(_QWORD *)a1;
      v90 = *(_QWORD *)(*(_QWORD *)a1 + 0x5100LL) + 0x88LL * (_QWORD)v36;
      v46 = *(_QWORD **)(v45 + 0x72E0);
      v47 = v46[0xAF];
      v48 = v46[0xB2];
      if ( v47 == v46[0xB0] )
        v47 = 0;
      v49 = v48 == v46[0xB3];
      v95 = v46[0xB5];
      if ( v49 )
        v48 = 0;
      if ( HIWORD_w((_QWORD *)a1 + 6) )
      {
        v97 = *a3;
        v50 = 0xFFFFFFFFFFFFFFFFuLL;
        v51 = *v97;
        v128 = 0;
        v127 = 0xFFFFFFFF;
        v129 = 0;
        v91 = *(void (__fastcall **)(__int64 *, _QWORD *))(v51 + 0x4C0);
        v136 = 0;
        v126[0] = *((_QWORD *)a1 + 6);
        v126[1] = v98;
        v130 = *((_QWORD *)a1 + 7);
        v131 = *((_QWORD *)a1 + 8);
        v132 = sub_146E2F800((__int64)a1);
        v134 = v90 + 0x58;
        v92 = (__int64 *)(v90 + 0x28);
        v133 = v90 + 0x28;
        if ( v48 )
          v52 = *(unsigned __int16 *)(v48 + 2LL * (_QWORD)v88);
        else
          v52 = 0;
        v135 = v52;
        if ( v47 )
          v53 = v95 + 2LL * *(unsigned __int16 *)(v47 + 2LL * (_QWORD)v88);
        else
          v53 = 0;
        v137 = v53;
        v91(v97, v126);
        memset(String, 0, sizeof(String));
        v54 = sub_14035B160(
                &v88,
                (const void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 0x72E0LL) + 0x4F0LL) + 0x20LL * (_QWORD)v88));
        v55 = sub_1403C3960((char **)v54);
        sub_14035B160((void **)&v94, (const void **)v55);
        sub_140370D10(&v88);
        swprintf(String, 0xFFu, "joint:%s:attached_to:%s", v94, (const char *)&p_p_p_p_p_p_p_p_p_p_p_Source);
        v56 = a1[0x1E];
        v57 = *((_QWORD *)a1 + 6);
        v112[0] = v92;
        v112[1] = v90 + 0x40;
        v112[2] = v90 + 0x58;
        v112[3] = *((_QWORD *)a1 + 6);
        v58 = *((_QWORD *)a1 + 3);
        v121 = xmmword_148C9AE90;
        v112[5] = v58;
        v59 = *((_QWORD *)a1 + 7);
        v122 = 0.0;
        v60 = *(_OWORD *)(a1 + 0x19);
        v112[6] = v59;
        v61 = *((_QWORD *)a1 + 8);
        v113 = v60;
        *(float *)&v60 = a1[0x1D];
        v112[7] = v61;
        v62 = *((_QWORD *)a1 + 5);
        v114 = *(float *)&v60;
        *(float *)&v60 = a1[0x1F];
        v112[8] = v62;
        v112[9] = v62;
        v118 = v89;
        v123 = 0.0;
        v124 = 0.0;
        v115 = v56;
        v116 = *(float *)&v60;
        v117 = 1.0;
        v120 = 0;
        v125 = 0;
        v112[4] = 0;
        *(_QWORD *)&v121 = *sub_1405A87F0(&v89, v57);
        do
          ++v50;
        while ( *((_BYTE *)String + v50) );
        DWORD2(v121) = ~(unsigned int)psub_1403360E0(0xFFFFFFFF, (__int64)String, v50);
        v63 = sub_146E2F800((__int64)a1);
        v64 = *a3;
        v119 = v63;
        (*(void (__fastcall **)(__int64 *, _QWORD *))(*v64 + 0x4D8))(v64, v112);
        sub_140370D10(&v94);
      }
      else
      {
        if ( !*((_BYTE *)a1 + 0x148) )
        {
          v65 = v104;
          v66 = a1[0x1A];
          v67 = v104 * v66;
          v161 = v7;
          v68 = v105;
          v160 = v8;
          v159 = v9;
          v158 = v10;
          v157 = v11;
          v69 = v105 * v66;
          v156 = v12;
          v70 = a1[0x1B];
          v71 = v106 * v70;
          v155 = v13;
          v72 = a1[0x1C];
          v154 = v14;
          v73 = a1[0x19];
          v104 = (float)((float)((float)(v106 * v66) - (float)(v105 * v70)) + (float)(v104 * v72)) + (float)(v73 * v107);
          v105 = (float)((float)((float)(v65 * v70) - (float)(v106 * v73)) + (float)(v105 * v72))
               + (float)(v107 * a1[0x1A]);
          v106 = (float)((float)((float)(v68 * v73) - v67) + (float)(v106 * v72)) + (float)(v70 * v107);
          v74 = a1[0x1A];
          v107 = (float)(v72 * v107) - (float)((float)((float)(v65 * v73) + v69) + v71);
          v75 = (float)((float)(v103 * v74) - (float)(v102 * v70)) + (float)(v101 * v72);
          v76 = (float)((float)(v101 * v70) - (float)(v103 * v73)) + (float)(v102 * v72);
          v77 = (float)((float)(v102 * v73) - (float)(v101 * v74)) + (float)(v103 * v72);
          v78 = (float)(v70 * v75) - (float)(v73 * v77);
          v79 = (float)((float)(v101 + (float)((float)(v74 * v77) - (float)(v70 * v76)))
                      + (float)((float)(v74 * v77) - (float)(v70 * v76)))
              + a1[0x1D];
          v80 = (float)((float)(v102 + v78) + v78) + a1[0x1E];
          v103 = (float)((float)(v103 + (float)((float)(v73 * v76) - (float)(v74 * v75)))
                       + (float)((float)(v73 * v76) - (float)(v74 * v75)))
               + a1[0x1F];
          v101 = v79;
          v102 = v80;
        }
        v92 = *a3;
        v81 = *v92;
        v140 = 0;
        v141 = 0;
        v91 = *(void (__fastcall **)(__int64 *, _QWORD *))(v81 + 0x4C0);
        v148 = 0;
        v138[0] = *((_QWORD *)a1 + 3);
        v138[1] = v98;
        v139 = a5;
        v142 = *((_QWORD *)a1 + 4);
        v143 = *((_QWORD *)a1 + 5);
        v144 = sub_146E2F800((__int64)a1);
        v145 = v90 + 0x28;
        v146 = v90 + 0x58;
        if ( v48 )
          v82 = *(unsigned __int16 *)(v48 + 2LL * (_QWORD)v36);
        else
          v82 = 0;
        v147 = v82;
        if ( v47 )
          v83 = v95 + 2LL * *(unsigned __int16 *)(v47 + 2LL * (_QWORD)v36);
        else
          v83 = 0;
        v149 = v83;
        v91(v92, v138);
      }
      sub_146E1D330((__int64)a1);
      sub_146E556D0(a1);
      v84 = *(_DWORD *)(v42 + 0x14);
      if ( v84 )
      {
        *(_DWORD *)(v42 + 0x14) = v84 - 1;
      }
      else
      {
        *(_DWORD *)(v42 + 0x10) = 0xFFFFFFFF;
        v85 = _InterlockedCompareExchange((volatile signed __int32 *)v42, 0, 1);
        if ( v85 == 1 )
          *(_QWORD *)(v42 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        else
          sub_1403DB1F0(v42, v85);
      }
      sub_146E4A200(a1);
      if ( *a3 )
        (*(void (__fastcall **)(_QWORD))(**a3 + 8))(*a3);
      result = 1;
      goto LABEL_59;
    }
    sub_146E4A200(a1);
    v87 = *a3;
  }
  else
  {
    v87 = *a3;
  }
  if ( v87 )
    (*(void (__fastcall **)(__int64 *))(*v87 + 8))(v87);
  result = 0;
LABEL_59:
  *a3 = 0;
  return result;
}

// --- End Function: sub_146E44B20 (0x146E44B20) ---

// --- Function: sub_146E4A200 (0x146E4A200) ---
__int64 __fastcall sub_146E4A200(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 v2; // rbx
  int v3; // edi
  unsigned __int32 v4; // eax
  _QWORD *v5; // r13
  _QWORD *v6; // r12
  int v7; // ebp
  __int64 v8; // rdx
  _QWORD *v9; // rbx
  __int64 v10; // r15
  __int64 v11; // rdi
  _QWORD *v12; // rsi
  __int64 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rax
  __int64 v16; // rdi
  __int64 v17; // rax
  __int64 v18; // r14
  __int64 v19; // rax
  int v20; // eax
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v22; // eax
  _QWORD *v23; // r15
  _QWORD *v24; // r14
  __int64 v25; // rcx
  __int64 v26; // r12
  __int64 v27; // rbp
  __int64 v28; // rbx
  __int64 v29; // rdi
  __int64 v30; // rax
  __int64 v31; // rsi
  __int16 v32; // ax
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_2; // rdi
  __int64 p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rsi
  __int16 v35; // ax
  int v36; // [rsp+20h] [rbp-98h] BYREF
  __int16 v37; // [rsp+24h] [rbp-94h]
  char v38[16]; // [rsp+28h] [rbp-90h] BYREF
  char v39[16]; // [rsp+38h] [rbp-80h] BYREF
  char v40[16]; // [rsp+48h] [rbp-70h] BYREF
  char v41[96]; // [rsp+58h] [rbp-60h] BYREF
  _QWORD *v42; // [rsp+C0h] [rbp+8h] BYREF
  __int64 v43; // [rsp+C8h] [rbp+10h]
  int v44; // [rsp+D0h] [rbp+18h] BYREF
  int v45; // [rsp+D4h] [rbp+1Ch]
  __int64 v46; // [rsp+D8h] [rbp+20h] BYREF

  v42 = a1;
  v1 = a1;
  if ( *(_DWORD *)(*(_QWORD *)(*a1 + 0x72E0LL) + 0x4D8LL) == 0x55AA55AA )
  {
    v46 = *a1 + 0x50E8LL;
    v2 = v46;
    v3 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
    if ( *(_DWORD *)(v2 + 0x10) == v3 )
    {
      ++*(_DWORD *)(v2 + 0x14);
    }
    else
    {
      v4 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 1, 0);
      if ( v4 )
        sub_1403C33A0(v2, v4, "CSkeletonPhysics::RefreshPartIdDB", 1);
      else
        *(_QWORD *)(v2 + 8) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      *(_DWORD *)(v2 + 0x10) = v3;
    }
    v5 = v1 + 0x2A;
    sub_1404FF550(v1 + 0x2A);
    v6 = v1 + 0x32;
    sub_1404FF550(v1 + 0x32);
    v7 = 0;
    v8 = (*(_DWORD *)(*v1 + 0x5108LL) - *(_DWORD *)(*v1 + 0x5100LL)) / 0x88;
    v43 = v8;
    if ( v8 > 0 )
    {
      v9 = v42;
      v10 = 0;
      do
      {
        v11 = 0;
        v12 = (_QWORD *)(v10 + *(_QWORD *)(*v9 + 0x5100LL));
        v13 = (__int64)(v12[6] - v12[5]) >> 2;
        v14 = (int)v13;
        if ( (int)v13 > 0 )
        {
          do
          {
            v15 = v12[5];
            HIDWORD(v42) = v7;
            LODWORD(v42) = *(_DWORD *)(v15 + 4 * v11);
            sub_146E14F70(v5, v38, &v42);
            ++v11;
          }
          while ( v11 < v14 );
          v8 = v43;
        }
        v16 = 0;
        v17 = (__int64)(v12[9] - v12[8]) >> 2;
        v18 = (int)v17;
        if ( (int)v17 > 0 )
        {
          do
          {
            v19 = v12[8];
            v45 = v7;
            v44 = *(_DWORD *)(v19 + 4 * v16);
            sub_146E14F70(v6, v39, &v44);
            ++v16;
          }
          while ( v16 < v18 );
          v8 = v43;
        }
        ++v7;
        v10 += 0x88;
        v43 = --v8;
      }
      while ( v8 );
      v2 = v46;
    }
    v20 = *(_DWORD *)(v2 + 0x14);
    if ( v20 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned int)(v20 - 1);
      *(_DWORD *)(v2 + 0x14) = p_p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      *(_DWORD *)(v2 + 0x10) = 0xFFFFFFFF;
      v22 = _InterlockedCompareExchange((volatile signed __int32 *)v2, 0, 1);
      if ( v22 == 1 )
      {
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (__int64)&p_p_p_p_p_p_p_p_p_p_p_Source;
        *(_QWORD *)(v2 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      }
      else
      {
        return (__int64)sub_1403DB1F0(v2, v22);
      }
    }
  }
  else
  {
    v23 = a1 + 0x2A;
    sub_1404FF550(a1 + 0x2A);
    v24 = v1 + 0x32;
    sub_1404FF550(v1 + 0x32);
    v25 = v1[0x12] - v1[0x11];
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (unsigned __int64)(v25
                                                      + ((unsigned __int128)(v25
                                                                           * (__int128)(__int64)0x8AD8F2FBA9386823uLL) >> 0x40)) >> 0x3F;
    v26 = (int)(v25 / 0x1D8);
    if ( (int)(v25 / 0x1D8) > 0 )
    {
      v27 = 0;
      do
      {
        v28 = v1[0x11];
        v29 = 0;
        v30 = (__int64)(*(_QWORD *)(v28 + v27 + 0x80) - *(_QWORD *)(v28 + v27 + 0x78)) >> 2;
        v31 = (int)v30;
        if ( (int)v30 > 0 )
        {
          do
          {
            v32 = *(_WORD *)(v28 + v27 + 6);
            LODWORD(v46) = *(_DWORD *)(*(_QWORD *)(v28 + v27 + 0x78) + 4 * v29);
            WORD2(v46) = v32;
            sub_146E14D20(v23, v40, &v46);
            ++v29;
          }
          while ( v29 < v31 );
        }
        p_p_p_p_p_p_p_p_p_p_p_p_Source_2 = 0;
        p_p_p_p_p_p_p_p_p_p_p_p_Source = (__int64)(*(_QWORD *)(v28 + v27 + 0x98) - *(_QWORD *)(v28 + v27 + 0x90)) >> 2;
        p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = (int)p_p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( (int)p_p_p_p_p_p_p_p_p_p_p_p_Source > 0 )
        {
          do
          {
            v35 = *(_WORD *)(v28 + v27 + 6);
            v36 = *(_DWORD *)(*(_QWORD *)(v28 + v27 + 0x90) + 4 * p_p_p_p_p_p_p_p_p_p_p_p_Source_2);
            v37 = v35;
            p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_146E14D20(v24, v41, &v36);
            ++p_p_p_p_p_p_p_p_p_p_p_p_Source_2;
          }
          while ( p_p_p_p_p_p_p_p_p_p_p_p_Source_2 < p_p_p_p_p_p_p_p_p_p_p_p_Source_1 );
        }
        v1 = v42;
        v27 += 0x1D8;
        --v26;
      }
      while ( v26 );
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_146E4A200 (0x146E4A200) ---

// --- Function: sub_146E4B1F0 (0x146E4B1F0) ---
__int64 __fastcall sub_146E4B1F0(_QWORD *a1, int a2, __int64 a3, char a4)
{
  char v4; // r12
  volatile signed __int32 *v5; // rsi
  __int64 v6; // rdi
  int v9; // ebx
  unsigned __int32 v10; // eax
  _QWORD *v11; // r14
  unsigned __int8 v12; // bl
  _QWORD *v13; // rax
  unsigned __int64 v14; // rcx
  __int64 **v15; // rax
  __int64 *v16; // rcx
  __int64 v17; // rax
  void (__fastcall *v18)(__int64 *, _QWORD *); // r8
  __int64 **v19; // rax
  __int64 *v20; // rcx
  __int64 v21; // rax
  void (__fastcall *v22)(__int64 *, _QWORD *); // r8
  __int64 **v23; // rax
  __int64 *v24; // rcx
  __int64 v25; // rax
  void (__fastcall *v26)(__int64 *, _QWORD *); // r8
  bool v27; // al
  unsigned __int64 v28; // rdi
  char v29; // r13
  __int64 n8; // rcx
  __int64 v31; // rdx
  __int64 v32; // rdx
  __int64 v33; // rbx
  __int64 v34; // rax
  __int16 n4; // dx
  unsigned __int64 v36; // rdi
  __int64 v37; // rbx
  __int64 v38; // rax
  __int16 n4_1; // dx
  unsigned __int64 v40; // rdi
  __int64 v41; // rbx
  __int64 v42; // rax
  __int16 n4_2; // dx
  unsigned __int64 v44; // rcx
  __int128 **v45; // r13
  __int128 *v46; // rdi
  __int128 *v47; // r13
  __int128 *v48; // rax
  unsigned __int64 v49; // rdi
  __int64 v50; // rbx
  __int64 v51; // rax
  __int16 n4_3; // dx
  unsigned __int64 v53; // rdi
  __int64 v54; // rcx
  __int64 v55; // rcx
  __int64 v56; // rbx
  __int64 v57; // rax
  __int16 n4_4; // dx
  unsigned __int64 v59; // rcx
  __int64 v60; // rbx
  __int64 v61; // rdi
  __int64 v62; // rax
  __int16 n4_5; // dx
  unsigned __int64 v64; // rcx
  __int64 v65; // rbx
  __int64 v66; // rdi
  __int64 v67; // rax
  __int16 n4_6; // dx
  int v69; // r8d
  __int128 *v70; // r13
  __int128 *v71; // rax
  __int64 v72; // rbx
  __int64 v73; // rdi
  __int64 v74; // rax
  __int16 n4_7; // dx
  unsigned __int64 v76; // rdx
  __int64 v77; // rcx
  __int64 v78; // rax
  unsigned __int64 v79; // rcx
  __int64 v80; // rax
  __int64 v81; // rax
  int v82; // ecx
  unsigned __int32 v83; // eax
  _DWORD v85[2]; // [rsp+20h] [rbp-E0h] BYREF
  int v86; // [rsp+28h] [rbp-D8h]
  __int64 v87; // [rsp+30h] [rbp-D0h]
  __int64 v88; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v89; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v90; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v91; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v92; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v93; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v94; // [rsp+68h] [rbp-98h] BYREF
  __int64 v95; // [rsp+70h] [rbp-90h] BYREF
  volatile signed __int32 *v96; // [rsp+78h] [rbp-88h]
  _QWORD v97[6]; // [rsp+80h] [rbp-80h] BYREF
  bool v98; // [rsp+B0h] [rbp-50h]
  bool v99; // [rsp+B1h] [rbp-4Fh]
  _BYTE v100[5]; // [rsp+B2h] [rbp-4Eh]
  char v101; // [rsp+B7h] [rbp-49h]
  _QWORD v102[6]; // [rsp+B8h] [rbp-48h] BYREF
  bool v103; // [rsp+E8h] [rbp-18h]
  bool v104; // [rsp+E9h] [rbp-17h]
  _BYTE v105[5]; // [rsp+EAh] [rbp-16h]
  char v106; // [rsp+EFh] [rbp-11h]
  _QWORD v107[6]; // [rsp+F0h] [rbp-10h] BYREF
  bool v108; // [rsp+120h] [rbp+20h]
  bool v109; // [rsp+121h] [rbp+21h]
  _BYTE v110[5]; // [rsp+122h] [rbp+22h]
  char v111; // [rsp+127h] [rbp+27h]
  int n0x1E; // [rsp+130h] [rbp+30h] BYREF
  __int128 v113; // [rsp+138h] [rbp+38h]
  unsigned int v114; // [rsp+148h] [rbp+48h]
  __int64 v115; // [rsp+14Ch] [rbp+4Ch]
  unsigned int v116; // [rsp+15Ch] [rbp+5Ch]
  __int128 v117; // [rsp+160h] [rbp+60h]
  int n0x1E_1; // [rsp+170h] [rbp+70h] BYREF
  __int128 v119; // [rsp+178h] [rbp+78h]
  unsigned int v120; // [rsp+188h] [rbp+88h]
  __int64 v121; // [rsp+18Ch] [rbp+8Ch]
  unsigned int v122; // [rsp+19Ch] [rbp+9Ch]
  __int128 v123; // [rsp+1A0h] [rbp+A0h]
  __int128 *v124; // [rsp+200h] [rbp+100h]
  __int128 *v125; // [rsp+200h] [rbp+100h]

  v4 = a4;
  v6 = a2;
  v96 = (volatile signed __int32 *)(*a1 + 0x50E8LL);
  v5 = v96;
  v9 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *((_DWORD *)v96 + 4) == v9 )
  {
    ++*((_DWORD *)v96 + 5);
  }
  else
  {
    v10 = _InterlockedCompareExchange(v96, 1, 0);
    if ( v10 )
      sub_1403C33A0((__int64)v96, v10, "CSkeletonPhysics::RemovePhysicsOnCGAJointInternal", 1);
    else
      *((_QWORD *)v96 + 1) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    *((_DWORD *)v5 + 4) = v9;
  }
  v11 = (_QWORD *)(*(_QWORD *)(*a1 + 0x5100LL) + 0x88 * v6);
  if ( v11[5] == v11[6] && v11[8] == v11[9] && v11[0xB] == v11[0xC] && v11[0xE] == v11[0xF] )
  {
    v12 = 0;
    goto LABEL_138;
  }
  v13 = (_QWORD *)sub_146F54F80(*(_QWORD *)(*a1 + 0x5100LL) + 0x88 * v6);
  v14 = a1[6];
  if ( !*v13 )
  {
    v85[0] = 7;
    v85[1] = 0x80000000;
    if ( v14 )
      v27 = *(_QWORD *)((v14 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v14);
    else
      v27 = 0;
    v28 = a1[3];
    v29 = a4;
    n8 = 8;
    if ( !v27 )
      n8 = 5;
    v31 = v11[n8 + 1] - v11[n8];
    v87 = v11[n8];
    v32 = v31 >> 2;
    v86 = v32;
    if ( v28 )
    {
      if ( *(_QWORD *)((v28 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v28) && (a4 & 2) != 0 && (int)v32 > 0 )
      {
        v33 = a1[1];
        v88 = v33;
        if ( v33 )
        {
          v34 = sub_1403B4B50(v33 & 0xFFFFFFFFFFFFLL);
          n4 = *(_WORD *)(v34 + 4);
          if ( n4 != 4
            && *(_WORD *)(v34 + 2) == (HIWORD(v33) & 0xFFF)
            && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v88)) )
          {
            (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v33 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
              v33 & 0xFFFFFFFFFFFFLL,
              v85,
              v28);
          }
        }
      }
    }
    v36 = a1[4];
    if ( v36 )
    {
      if ( *(_QWORD *)((v36 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v36) && v86 > 0 && (a4 & 4) != 0 )
      {
        v37 = a1[1];
        v89 = v37;
        if ( v37 )
        {
          v38 = sub_1403B4B50(v37 & 0xFFFFFFFFFFFFLL);
          n4_1 = *(_WORD *)(v38 + 4);
          if ( n4_1 != 4
            && *(_WORD *)(v38 + 2) == (HIWORD(v37) & 0xFFF)
            && (n4_1 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v89)) )
          {
            (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v37 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
              v37 & 0xFFFFFFFFFFFFLL,
              v85,
              v36);
          }
        }
      }
    }
    v40 = a1[5];
    if ( v40 )
    {
      if ( *(_QWORD *)((v40 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v40) && v86 > 0 && (a4 & 4) != 0 )
      {
        v41 = a1[1];
        v90 = v41;
        if ( v41 )
        {
          v42 = sub_1403B4B50(v41 & 0xFFFFFFFFFFFFLL);
          n4_2 = *(_WORD *)(v42 + 4);
          if ( n4_2 != 4
            && *(_WORD *)(v42 + 2) == (HIWORD(v41) & 0xFFF)
            && (n4_2 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v90)) )
          {
            (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v41 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
              v41 & 0xFFFFFFFFFFFFLL,
              v85,
              v40);
          }
        }
      }
    }
    if ( (a4 & 8) != 0 )
    {
      v44 = a1[6];
      if ( !v44 || (v45 = (__int128 **)(v11 + 0xE), *(_QWORD *)((v44 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v44)) )
        v45 = (__int128 **)(v11 + 0xB);
      v46 = v45[1];
      v47 = *v45;
      v124 = v46;
      if ( v47 != v46 )
      {
        v48 = v46;
        do
        {
          v49 = a1[3];
          n0x1E = 0x1E;
          v114 = 0x80000000;
          v116 = 0xFFF7FFFF;
          v115 = 1;
          v117 = xmmword_1484AE0C0;
          v113 = *v47;
          if ( v49 )
          {
            if ( *(_QWORD *)((v49 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v49) )
            {
              v50 = a1[1];
              v91 = v50;
              if ( v50 )
              {
                v51 = sub_1403B4B50(v50 & 0xFFFFFFFFFFFFLL);
                n4_3 = *(_WORD *)(v51 + 4);
                if ( n4_3 != 4
                  && *(_WORD *)(v51 + 2) == (HIWORD(v50) & 0xFFF)
                  && (n4_3 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v91)) )
                {
                  (*(void (__fastcall **)(__int64, int *, unsigned __int64))(*(_QWORD *)(v50 & 0xFFFFFFFFFFFFLL)
                                                                           + 0x718LL))(
                    v50 & 0xFFFFFFFFFFFFLL,
                    &n0x1E,
                    v49);
                }
              }
            }
            v48 = v124;
          }
          ++v47;
        }
        while ( v47 != v48 );
      }
      v29 = a4;
    }
    v53 = a1[6];
    if ( v53 && *(_QWORD *)((v53 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v53) && (v29 & 1) != 0 )
    {
      v54 = v11[6] - v11[5];
      v87 = v11[5];
      v55 = v54 >> 2;
      v86 = v55;
      if ( (v29 & 2) != 0 && (int)v55 > 0 )
      {
        v56 = a1[1];
        v92 = v56;
        if ( v56 )
        {
          v57 = sub_1403B4B50(v56 & 0xFFFFFFFFFFFFLL);
          n4_4 = *(_WORD *)(v57 + 4);
          if ( n4_4 != 4
            && *(_WORD *)(v57 + 2) == (HIWORD(v56) & 0xFFF)
            && (n4_4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v92)) )
          {
            (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v56 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
              v56 & 0xFFFFFFFFFFFFLL,
              v85,
              v53);
          }
        }
      }
      if ( (v29 & 4) != 0 )
      {
        v59 = a1[4];
        if ( v59 )
        {
          if ( *(_QWORD *)((a1[4] & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v59) && v86 > 0 )
          {
            v60 = a1[1];
            v61 = a1[7];
            v93 = v60;
            if ( v60 )
            {
              v62 = sub_1403B4B50(v60 & 0xFFFFFFFFFFFFLL);
              n4_5 = *(_WORD *)(v62 + 4);
              if ( n4_5 != 4
                && *(_WORD *)(v62 + 2) == (HIWORD(v60) & 0xFFF)
                && (n4_5 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v93)) )
              {
                (*(void (__fastcall **)(__int64, _DWORD *, __int64))(*(_QWORD *)(v60 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
                  v60 & 0xFFFFFFFFFFFFLL,
                  v85,
                  v61);
              }
            }
          }
        }
        v64 = a1[5];
        if ( v64 )
        {
          if ( *(_QWORD *)((a1[5] & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v64) && v86 > 0 )
          {
            v65 = a1[1];
            v66 = a1[8];
            v94 = v65;
            if ( v65 )
            {
              v67 = sub_1403B4B50(v65 & 0xFFFFFFFFFFFFLL);
              n4_6 = *(_WORD *)(v67 + 4);
              if ( n4_6 != 4
                && *(_WORD *)(v67 + 2) == (HIWORD(v65) & 0xFFF)
                && (n4_6 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v94)) )
              {
                (*(void (__fastcall **)(__int64, _DWORD *, __int64))(*(_QWORD *)(v65 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
                  v65 & 0xFFFFFFFFFFFFLL,
                  v85,
                  v66);
              }
            }
          }
        }
      }
      v69 = a4 & 8;
      if ( (a4 & 8) == 0 )
        goto LABEL_122;
      v70 = (__int128 *)v11[0xB];
      v125 = (__int128 *)v11[0xC];
      if ( v70 == v125 )
        goto LABEL_122;
      v71 = (__int128 *)v11[0xC];
      do
      {
        v72 = a1[1];
        v73 = a1[6];
        n0x1E_1 = 0x1E;
        v120 = 0x80000000;
        v122 = 0xFFF7FFFF;
        v121 = 1;
        v95 = v72;
        v123 = xmmword_1484AE0C0;
        v119 = *v70;
        if ( v72 )
        {
          v74 = sub_1403B4B50(v72 & 0xFFFFFFFFFFFFLL);
          n4_7 = *(_WORD *)(v74 + 4);
          if ( n4_7 != 4
            && *(_WORD *)(v74 + 2) == (HIWORD(v72) & 0xFFF)
            && (n4_7 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v95)) )
          {
            (*(void (__fastcall **)(__int64, int *, __int64))(*(_QWORD *)(v72 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
              v72 & 0xFFFFFFFFFFFFLL,
              &n0x1E_1,
              v73);
          }
          v71 = v125;
        }
        ++v70;
      }
      while ( v70 != v71 );
      v5 = v96;
    }
    v69 = a4 & 8;
LABEL_122:
    v76 = a1[6];
    v77 = v11[0xE];
    if ( v76 && *(_QWORD *)((a1[6] & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v76) )
    {
      v78 = v11[8];
      if ( v78 != v11[9] )
        v11[9] = v78;
      if ( v69 && v77 != v11[0xF] )
        v11[0xF] = v77;
    }
    if ( (a4 & 1) != 0 || (v79 = a1[6]) == 0 || *(_QWORD *)((a1[6] & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v79) )
    {
      v80 = v11[5];
      if ( v80 != v11[6] )
        v11[6] = v80;
      if ( v69 )
      {
        v81 = v11[0xB];
        if ( v81 != v11[0xC] )
          v11[0xC] = v81;
      }
    }
    goto LABEL_137;
  }
  if ( v14 )
  {
    if ( *(_QWORD *)((v14 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v14) )
    {
      v15 = (__int64 **)sub_146F54F80(v11);
      v16 = *v15;
      v17 = **v15;
      v97[1] = v11 + 0xE;
      v97[5] = a3;
      *(_DWORD *)&v100[1] = 0;
      v18 = *(void (__fastcall **)(__int64 *, _QWORD *))(v17 + 0x4C8);
      v97[0] = v11 + 8;
      v97[2] = a1[3];
      v97[3] = a1[4];
      v97[4] = a1[5];
      v98 = (a4 & 2) != 0;
      v99 = (a4 & 4) != 0;
      *(_DWORD *)v100 = (a4 & 8) != 0;
      v101 = 0;
      v18(v16, v97);
      if ( (a4 & 1) != 0 )
      {
        v19 = (__int64 **)sub_146F54F80(v11);
        v20 = *v19;
        v21 = **v19;
        v102[0] = v11 + 5;
        *(_DWORD *)&v105[1] = 0;
        v106 = 0;
        v22 = *(void (__fastcall **)(__int64 *, _QWORD *))(v21 + 0x4C8);
        v102[2] = a1[6];
        v102[3] = a1[7];
        v102[4] = a1[8];
        v102[5] = a3;
        v102[1] = v11 + 0xB;
        v103 = (a4 & 2) != 0;
        v104 = (a4 & 4) != 0;
        *(_DWORD *)v105 = (a4 & 8) != 0;
        v22(v20, v102);
      }
      goto LABEL_137;
    }
    v4 = a4;
  }
  v23 = (__int64 **)sub_146F54F80(v11);
  v24 = *v23;
  v25 = **v23;
  v107[0] = v11 + 5;
  *(_DWORD *)&v110[1] = 0;
  v111 = 0;
  v26 = *(void (__fastcall **)(__int64 *, _QWORD *))(v25 + 0x4C8);
  v107[2] = a1[3];
  v107[3] = a1[4];
  v107[4] = a1[5];
  v107[1] = v11 + 0xB;
  v108 = (v4 & 2) != 0;
  v109 = (v4 & 4) != 0;
  v107[5] = a3;
  *(_DWORD *)v110 = (v4 & 8) != 0;
  v26(v24, v107);
LABEL_137:
  v12 = 1;
LABEL_138:
  v82 = *((_DWORD *)v5 + 5);
  if ( v82 )
  {
    *((_DWORD *)v5 + 5) = v82 - 1;
  }
  else
  {
    *((_DWORD *)v5 + 4) = 0xFFFFFFFF;
    v83 = _InterlockedCompareExchange(v5, 0, 1);
    if ( v83 == 1 )
      *((_QWORD *)v5 + 1) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0((__int64)v5, v83);
  }
  return v12;
}

// --- End Function: sub_146E4B1F0 (0x146E4B1F0) ---

// --- Function: sub_146E4BBA0 (0x146E4BBA0) ---
char __fastcall sub_146E4BBA0(_QWORD *a1, int a2, __int64 a3, char a4)
{
  __int64 v6; // rcx
  __int64 v7; // r10
  __int64 v8; // rdx
  __int64 v9; // r15
  _QWORD *v10; // r12
  unsigned __int64 v11; // rcx
  _QWORD *v12; // rax
  unsigned __int64 v13; // rdi
  __int64 v14; // rbx
  __int64 v15; // rax
  __int16 n4; // dx
  unsigned __int64 v17; // rdi
  __int64 v18; // rbx
  __int64 v19; // rax
  __int16 n4_1; // dx
  unsigned __int64 v21; // rdi
  __int64 v22; // rbx
  __int64 v23; // rax
  __int16 n4_2; // dx
  unsigned __int64 v25; // rdi
  __int64 v26; // rax
  __int64 v27; // rbx
  __int64 v28; // rax
  __int16 n4_3; // dx
  __int64 v30; // rbx
  __int64 v31; // rdi
  __int64 v32; // rax
  __int16 n4_4; // dx
  __int64 v34; // rbx
  __int64 v35; // rdi
  __int64 v36; // rax
  __int16 n4_5; // dx
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // rcx
  __int64 v40; // rax
  __int64 v42; // [rsp+20h] [rbp-20h] BYREF
  _DWORD v43[2]; // [rsp+28h] [rbp-18h] BYREF
  int v44; // [rsp+30h] [rbp-10h]
  __int64 v45; // [rsp+38h] [rbp-8h]

  if ( a2 < 0 )
    return 0;
  v6 = a1[0x11];
  v7 = a2;
  if ( a2 >= (unsigned __int64)((a1[0x12] - v6) / 0x1D8) )
    return 0;
  v8 = *(_QWORD *)(0x1D8LL * a2 + v6 + 0x78);
  v9 = 0x1D8 * v7 + v6;
  v10 = (_QWORD *)(0x1D8 * v7 + v6 + 0x90);
  if ( v8 == *(_QWORD *)(v9 + 0x80) && *v10 == v10[1] )
    return 0;
  v11 = a1[6];
  v43[0] = 7;
  v43[1] = 0x80000000;
  if ( v11 && *(_QWORD *)((v11 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v11) )
  {
    v8 = *v10;
    v12 = v10;
  }
  else
  {
    v12 = (_QWORD *)(v9 + 0x78);
  }
  v13 = a1[3];
  v44 = (v12[1] - v8) >> 2;
  v45 = v8;
  if ( v13 )
  {
    if ( *(_QWORD *)((v13 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v13) && (a4 & 2) != 0 )
    {
      v14 = a1[1];
      v42 = v14;
      if ( v14 )
      {
        v15 = sub_1403B4B50(v14 & 0xFFFFFFFFFFFFLL);
        n4 = *(_WORD *)(v15 + 4);
        if ( n4 != 4
          && *(_WORD *)(v15 + 2) == (HIWORD(v14) & 0xFFF)
          && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v42)) )
        {
          (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v14 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
            v14 & 0xFFFFFFFFFFFFLL,
            v43,
            v13);
        }
      }
    }
  }
  v17 = a1[4];
  if ( v17 )
  {
    if ( *(_QWORD *)((v17 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v17) && (a4 & 4) != 0 )
    {
      v18 = a1[1];
      v42 = v18;
      if ( v18 )
      {
        v19 = sub_1403B4B50(v18 & 0xFFFFFFFFFFFFLL);
        n4_1 = *(_WORD *)(v19 + 4);
        if ( n4_1 != 4
          && *(_WORD *)(v19 + 2) == (HIWORD(v18) & 0xFFF)
          && (n4_1 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v42)) )
        {
          (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v18 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
            v18 & 0xFFFFFFFFFFFFLL,
            v43,
            v17);
        }
      }
    }
  }
  v21 = a1[5];
  if ( v21 )
  {
    if ( *(_QWORD *)((v21 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v21) && (a4 & 4) != 0 )
    {
      v22 = a1[1];
      v42 = v22;
      if ( v22 )
      {
        v23 = sub_1403B4B50(v22 & 0xFFFFFFFFFFFFLL);
        n4_2 = *(_WORD *)(v23 + 4);
        if ( n4_2 != 4
          && *(_WORD *)(v23 + 2) == (HIWORD(v22) & 0xFFF)
          && (n4_2 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v42)) )
        {
          (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v22 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
            v22 & 0xFFFFFFFFFFFFLL,
            v43,
            v21);
        }
      }
    }
  }
  v25 = a1[6];
  if ( v25 && *(_QWORD *)((v25 & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v25) && (a4 & 1) != 0 )
  {
    v26 = *(_QWORD *)(v9 + 0x80) - *(_QWORD *)(v9 + 0x78);
    v45 = *(_QWORD *)(v9 + 0x78);
    v44 = v26 >> 2;
    if ( (a4 & 2) != 0 )
    {
      v27 = a1[1];
      v42 = v27;
      if ( v27 )
      {
        v28 = sub_1403B4B50(v27 & 0xFFFFFFFFFFFFLL);
        n4_3 = *(_WORD *)(v28 + 4);
        if ( n4_3 != 4
          && *(_WORD *)(v28 + 2) == (HIWORD(v27) & 0xFFF)
          && (n4_3 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v42)) )
        {
          (*(void (__fastcall **)(__int64, _DWORD *, unsigned __int64))(*(_QWORD *)(v27 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
            v27 & 0xFFFFFFFFFFFFLL,
            v43,
            v25);
        }
      }
    }
    if ( HIWORD_w(a1 + 4) && (a4 & 4) != 0 )
    {
      v30 = a1[1];
      v31 = a1[7];
      v42 = v30;
      if ( v30 )
      {
        v32 = sub_1403B4B50(v30 & 0xFFFFFFFFFFFFLL);
        n4_4 = *(_WORD *)(v32 + 4);
        if ( n4_4 != 4
          && *(_WORD *)(v32 + 2) == (HIWORD(v30) & 0xFFF)
          && (n4_4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v42)) )
        {
          (*(void (__fastcall **)(__int64, _DWORD *, __int64))(*(_QWORD *)(v30 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
            v30 & 0xFFFFFFFFFFFFLL,
            v43,
            v31);
        }
      }
    }
    if ( HIWORD_w(a1 + 5) && (a4 & 4) != 0 )
    {
      v34 = a1[1];
      v35 = a1[8];
      v42 = v34;
      if ( v34 )
      {
        v36 = sub_1403B4B50(v34 & 0xFFFFFFFFFFFFLL);
        n4_5 = *(_WORD *)(v36 + 4);
        if ( n4_5 != 4
          && *(_WORD *)(v36 + 2) == (HIWORD(v34) & 0xFFF)
          && (n4_5 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v42)) )
        {
          (*(void (__fastcall **)(__int64, _DWORD *, __int64))(*(_QWORD *)(v34 & 0xFFFFFFFFFFFFLL) + 0x718LL))(
            v34 & 0xFFFFFFFFFFFFLL,
            v43,
            v35);
        }
      }
    }
  }
  v38 = a1[6];
  if ( v38 && *(_QWORD *)((a1[6] & 0xFFFFFFFFFFFFLL) + 8) == HIWORD(v38) && *v10 != v10[1] )
    v10[1] = *v10;
  if ( (a4 & 1) != 0 || (v39 = a1[6]) == 0 || *(_QWORD *)((a1[6] & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v39) )
  {
    v40 = *(_QWORD *)(v9 + 0x78);
    if ( v40 != *(_QWORD *)(v9 + 0x80) )
      *(_QWORD *)(v9 + 0x80) = v40;
  }
  return 1;
}

// --- End Function: sub_146E4BBA0 (0x146E4BBA0) ---

// --- Function: sub_146E4C0B0 (0x146E4C0B0) ---
char __fastcall sub_146E4C0B0(_QWORD *a1, int a2, char n7)
{
  unsigned __int64 v6; // rcx
  __int64 v7; // rax
  char v8; // al
  char v9; // di

  if ( a2 < 0 )
    return 0;
  if ( a2 >= *(_DWORD *)(*(_QWORD *)(*a1 + 0x72E0LL) + 0x528LL) )
    return 0;
  v6 = a1[3];
  if ( !v6 || *(_QWORD *)((v6 & 0xFFFFFFFFFFFFLL) + 8) != HIWORD(v6) )
    return 0;
  sub_146E402D0((__int64)a1);
  v7 = sub_146E2F800((__int64)a1);
  if ( *(_DWORD *)(*(_QWORD *)(*a1 + 0x72E0LL) + 0x4D8LL) == 0x55AA55AA )
    v8 = sub_146E4B1F0(a1, a2, v7, n7);
  else
    v8 = sub_146E4BBA0(a1, a2, v7, n7);
  v9 = v8;
  sub_146E1D330((__int64)a1);
  sub_146E556D0(a1);
  sub_146E4A200(a1);
  return v9;
}

// --- End Function: sub_146E4C0B0 (0x146E4C0B0) ---

// --- Function: sub_146E556D0 (0x146E556D0) ---
void __fastcall sub_146E556D0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int16 n4; // dx
  __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_QWORD *)(a1 + 8);
  v4 = v1;
  if ( v1 )
  {
    v2 = sub_1403B4B50(v1 & 0xFFFFFFFFFFFFLL);
    n4 = *(_WORD *)(v2 + 4);
    if ( n4 != 4
      && *(_WORD *)(v2 + 2) == (HIWORD(v1) & 0xFFF)
      && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v4)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)(v1 & 0xFFFFFFFFFFFFLL) + 0x6F8LL))(v1 & 0xFFFFFFFFFFFFLL);
    }
  }
}

// --- End Function: sub_146E556D0 (0x146E556D0) ---

// --- Function: sub_146EF1BB0 (0x146EF1BB0) ---
void __fastcall sub_146EF1BB0(__int64 *a1, __int16 *a2, __int16 *a3)
{
  __int16 *v4; // rbx
  _BYTE *v6; // rsi
  unsigned __int64 v7; // rax
  _WORD *v8; // rcx
  __int16 v9; // bp

  if ( a2 != a3 )
  {
    v4 = a2;
    do
    {
      v6 = (_BYTE *)*a1;
      v7 = (a1[1] - *a1) >> 1;
      while ( (__int64)v7 > 0 )
      {
        if ( *(_WORD *)&v6[2 * (v7 >> 1)] >= (unsigned __int16)*v4 )
        {
          v7 >>= 1;
        }
        else
        {
          v6 += 2 * (v7 >> 1) + 2;
          v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
        }
      }
      v8 = (_WORD *)a1[1];
      if ( v6 == (_BYTE *)v8 || (unsigned __int16)*v4 < *(_WORD *)v6 )
      {
        if ( v8 == (_WORD *)a1[2] )
        {
          sub_140344D10(a1, v6, v4);
        }
        else
        {
          v9 = *v4;
          if ( v6 == (_BYTE *)v8 )
          {
            *v8 = v9;
            a1[1] += 2;
          }
          else
          {
            *v8 = v8[0xFFFFFFFF];
            a1[1] += 2;
            memmove(v6 + 2, v6, (char *)(v8 + 0xFFFFFFFF) - v6);
            *(_WORD *)v6 = v9;
          }
        }
      }
      ++v4;
    }
    while ( v4 != a3 );
  }
}

// --- End Function: sub_146EF1BB0 (0x146EF1BB0) ---

// --- Function: sub_146EF6DD0 (0x146EF6DD0) ---
__int64 *__fastcall sub_146EF6DD0(__int64 **a1, __int64 *a2, int a3)
{
  unsigned __int16 v3; // bx
  __int64 v6; // r9
  __int64 v7; // rdx
  unsigned __int16 v8; // si
  __int64 v9; // rbp
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rcx
  __int16 *v13; // rcx
  __int16 *v15[5]; // [rsp+20h] [rbp-28h] BYREF

  v3 = 0;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v6 = **a1;
  if ( v6 )
  {
    v7 = *a1[1];
    if ( v7 )
    {
      v8 = *(_WORD *)(v7 + 2LL * a3);
      if ( v8 )
      {
        v9 = *(unsigned __int16 *)(v6 + 2LL * a3);
        do
        {
          v10 = *(_QWORD *)(a1[2][1] + 0x7350);
          v11 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v10 + 0x3F8LL))(
                  v10,
                  *(unsigned __int16 *)(*a1[3] + 2 * (v9 + v3)));
          if ( v11 )
          {
            v12 = *(_QWORD *)(v11 + 0xA0);
            if ( v12 )
            {
              (*(void (__fastcall **)(__int64, __int16 **))(*(_QWORD *)v12 + 0x5E8LL))(v12, v15);
              sub_146EF1BB0(a2, v15[0], v15[1]);
              v13 = v15[0];
              if ( v15[0] )
              {
                if ( (unsigned __int64)(2 * (v15[2] - v15[0])) >= 0x1000 )
                {
                  v13 = (__int16 *)*((_QWORD *)v15[0] + 0xFFFFFFFF);
                  if ( (unsigned __int64)((char *)v15[0] - (char *)v13 - 8) > 0x1F )
                    invalid_parameter_noinfo_noreturn();
                }
                sub_1402A3D30(v13);
              }
            }
          }
          ++v3;
        }
        while ( v3 < v8 );
      }
    }
  }
  return a2;
}

// --- End Function: sub_146EF6DD0 (0x146EF6DD0) ---

// --- Function: sub_146F0FB20 (0x146F0FB20) ---
void __fastcall sub_146F0FB20(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int128 v9; // xmm11
  __int128 v10; // xmm12
  __int128 v11; // xmm13
  __int128 v12; // xmm14
  __int128 v13; // xmm15
  __int64 v14; // r15
  __int64 v15; // r14
  __int64 v17; // rax
  double v18; // xmm1_8
  double v19; // xmm8_8
  double v20; // xmm5_8
  double v21; // xmm7_8
  double v22; // xmm0_8
  double v24; // xmm14_8
  double v25; // xmm6_8
  double v26; // xmm9_8
  __int64 v27; // rbx
  __int64 v29; // rax
  __int64 v30; // rax
  double *v31; // rax
  double v32; // xmm11_8
  double v33; // xmm12_8
  double v34; // xmm9_8
  double v35; // xmm10_8
  double v36; // xmm8_8
  double v37; // xmm7_8
  double v38; // xmm4_8
  double v39; // xmm5_8
  double v40; // xmm6_8
  double v41; // xmm7_8
  double v42; // xmm4_8
  double v43; // kr00_8
  double v44; // xmm1_8
  double v45; // xmm2_8
  double v46; // xmm12_8
  double v47; // xmm10_8
  double v48; // xmm11_8
  double v49; // xmm9_8
  double v50; // xmm7_8
  double v51; // xmm6_8
  double v52; // xmm5_8
  double v53; // xmm3_8
  volatile signed __int32 *v54; // rbx
  void (***v55)(void); // rdi
  int v56; // r12d
  unsigned __int32 v57; // eax
  void (***v58)(void); // rcx
  int v59; // eax
  unsigned __int32 v60; // eax
  __int64 v61; // rax
  float *v62; // rax
  float v63; // xmm10_4
  float v64; // xmm4_4
  float v65; // xmm1_4
  float v66; // xmm6_4
  float v67; // xmm9_4
  float v68; // xmm13_4
  float v69; // xmm3_4
  float v70; // xmm5_4
  float v71; // xmm12_4
  float v72; // xmm14_4
  float v73; // xmm4_4
  float v74; // xmm2_4
  float v75; // xmm1_4
  float v76; // xmm7_4
  float v77; // xmm6_4
  float v78; // xmm0_4
  float v79; // xmm3_4
  float v80; // xmm1_4
  float v81; // xmm10_4
  float v82; // xmm2_4
  __int64 v83; // r15
  __int64 pSystem; // rsi
  __int64 (__fastcall *v85)(__int64, __int64, _QWORD, double *, _DWORD, __int64, _QWORD *, char, _BYTE); // rbx
  __int64 v86; // rax
  char v87; // bl
  __int64 v88; // rcx
  unsigned __int64 v89; // r8
  double v90; // [rsp+58h] [rbp-B0h]
  double v91; // [rsp+58h] [rbp-B0h]
  __m128i v92; // [rsp+60h] [rbp-A8h] BYREF
  double v93; // [rsp+70h] [rbp-98h] BYREF
  __int128 v94; // [rsp+A0h] [rbp-68h]
  double v95; // [rsp+B0h] [rbp-58h]
  double v96[16]; // [rsp+B8h] [rbp-50h] BYREF
  __int128 v97; // [rsp+138h] [rbp+30h]
  double v98; // [rsp+148h] [rbp+40h]
  _BYTE v99[56]; // [rsp+150h] [rbp+48h] BYREF
  _QWORD v100[2]; // [rsp+188h] [rbp+80h] BYREF
  int v101; // [rsp+198h] [rbp+90h]
  int v102; // [rsp+19Ch] [rbp+94h]
  int v103; // [rsp+1A0h] [rbp+98h]
  int v104; // [rsp+1A4h] [rbp+9Ch]
  int v105; // [rsp+1A8h] [rbp+A0h]
  char v106; // [rsp+1ACh] [rbp+A4h]
  char v107; // [rsp+1ADh] [rbp+A5h]
  char v108; // [rsp+1AEh] [rbp+A6h]
  char v109; // [rsp+1AFh] [rbp+A7h]
  float v110; // [rsp+1B0h] [rbp+A8h]
  float v111; // [rsp+1B4h] [rbp+ACh]
  float v112; // [rsp+1B8h] [rbp+B0h]
  float v113; // [rsp+1BCh] [rbp+B4h]
  float v114; // [rsp+1C0h] [rbp+B8h]
  float v115; // [rsp+1C4h] [rbp+BCh]
  float v116; // [rsp+1C8h] [rbp+C0h]
  float v117; // [rsp+1CCh] [rbp+C4h]
  float v118; // [rsp+1D0h] [rbp+C8h]
  float v119; // [rsp+1D4h] [rbp+CCh]
  float v120; // [rsp+1D8h] [rbp+D0h]
  float v121; // [rsp+1DCh] [rbp+D4h]
  __int128 v122; // [rsp+1E8h] [rbp+E0h]
  int v123; // [rsp+1F8h] [rbp+F0h]
  _OWORD v124[12]; // [rsp+208h] [rbp+100h] BYREF

  v14 = a3;
  v15 = a2;
  if ( !BYTE1(isSandboxEditor) )
  {
    v17 = *(_QWORD *)(a1 + 8);
    v124[0xB] = v4;
    v124[0xA] = v5;
    v124[9] = v6;
    v124[8] = v7;
    v124[7] = v8;
    v124[6] = v9;
    v124[5] = v10;
    v124[4] = v11;
    v124[3] = v12;
    v124[2] = v13;
    v18 = *(double *)(a4 + 0x30);
    v19 = *(double *)(a4 + 0x18);
    v20 = *(double *)a4;
    v21 = *(double *)(a4 + 8);
    v94 = *(_OWORD *)(a4 + 0x20);
    v22 = *(double *)(a4 + 0x10);
    v90 = v22;
    v93 = v19;
    v95 = v18;
    if ( a3 )
    {
      v24 = v95;
      *(_QWORD *)&_XMM15 = *((_QWORD *)&v94 + 1);
      *(_QWORD *)&_XMM13 = v94;
    }
    else
    {
      _XMM13 = *(_OWORD *)(v17 + 0x7200);
      v24 = *(double *)(v17 + 0x7210);
      v25 = *(double *)(v17 + 0x71E0);
      v21 = *(double *)(v17 + 0x71E8);
      v26 = *(double *)(v17 + 0x71F0);
      v19 = *(double *)(v17 + 0x71F8);
      v27 = *(_QWORD *)(v17 + 0x7358) & 0xFFFFFFFFFFFFLL;
      __asm { vunpckhpd xmm15, xmm13, xmm13 }
      v91 = v25;
      v29 = *(_QWORD *)v27;
      *(double *)v124 = v21;
      *(double *)v92.m128i_i64 = v26;
      v93 = v19;
      *(double *)&v94 = *(double *)&_XMM13;
      *((double *)&v94 + 1) = *(double *)&_XMM15;
      v95 = v24;
      v97 = _XMM13;
      v98 = v24;
      v30 = (*(__int64 (__fastcall **)(__int64))(v29 + 0x668))(v27);
      v14 = v30;
      if ( v30 )
      {
        v31 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64, _QWORD))(*(_QWORD *)v30 + 0x80LL))(
                          v30,
                          v99,
                          1,
                          (unsigned int)dword_149B4FDFC);
        v32 = v31[1];
        v33 = v31[2];
        v34 = *v31;
        v35 = v31[3];
        v36 = v24 * v32 - *(double *)&_XMM15 * v33 + *(double *)&_XMM13 * v35;
        v37 = *(double *)&_XMM13 * v33 - v24 * *v31 + *(double *)&_XMM15 * v35;
        v38 = *(double *)&_XMM15 * *v31 - *(double *)&_XMM13 * v32 + v24 * v35;
        v39 = v32 * v38 - v33 * v37;
        v40 = v33 * v36 - *v31 * v38;
        v41 = *v31 * v37 - v32 * v36;
        v42 = v39 + v31[4] + *(double *)&_XMM13 + v39;
        v43 = v41 + v31[6];
        *((double *)&v94 + 1) = v40 + v31[5] + *(double *)&_XMM15 + v40;
        *(_QWORD *)&_XMM15 = *((_QWORD *)&v94 + 1);
        v24 = v43 + v24 + v41;
        *(double *)&v94 = v42;
        *(double *)&_XMM13 = v42;
        v20 = v32 * *(double *)v92.m128i_i64 - v33 * *(double *)v124 + v91 * v35 + v93 * v34;
        v21 = v91 * v33 - v34 * *(double *)v92.m128i_i64 + v35 * *(double *)v124 + v93 * v32;
        v44 = v91 * v34;
        v90 = v34 * *(double *)v124 - v91 * v32 + v35 * *(double *)v92.m128i_i64 + v93 * v33;
        v19 = v93 * v35 - v44 - v32 * *(double *)v124 - v33 * *(double *)v92.m128i_i64;
        v93 = v19;
        v95 = v24;
        v22 = v90;
      }
      else
      {
        v22 = v26;
        v90 = v26;
        v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 0x648LL))(v27);
        v20 = v25;
      }
    }
    v45 = v21 + v21;
    v46 = 1.0 - (v20 + v20) * v20;
    v47 = (v20 + v20) * v19;
    v48 = (v21 + v21) * v21;
    v49 = (v22 + v22) * v21;
    v50 = (v22 + v22) * v20;
    v51 = v45 * v20;
    v52 = (v22 + v22) * v90;
    v53 = (v22 + v22) * v93;
    v96[0] = 1.0 - v48 - v52;
    v96[2] = v50 + v45 * v19;
    v96[5] = v46 - v52;
    v96[4] = v53 + v51;
    v96[8] = v50 - v45 * v19;
    v96[6] = v49 - v47;
    v54 = (volatile signed __int32 *)(a1 + 0xAE8);
    v96[0xA] = v46 - v48;
    v96[1] = v51 - v53;
    v96[3] = *(double *)&_XMM13;
    v96[7] = *(double *)&_XMM15;
    v96[9] = v49 + v47;
    v96[0xB] = v24;
    v55 = 0;
    v56 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
    if ( *(_DWORD *)(a1 + 0xAF8) == v56 )
    {
      ++*(_DWORD *)(a1 + 0xAFC);
    }
    else
    {
      v57 = _InterlockedCompareExchange(v54, 1, 0);
      if ( v57 )
        sub_1403C33A0(a1 + 0xAE8, v57, "CSkeletonPose::CreatePortalAtJoint", 1);
      else
        *(_QWORD *)(a1 + 0xAF0) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      *(_DWORD *)(a1 + 0xAF8) = v56;
    }
    v58 = *(void (****)(void))sub_146F54F80(*(_QWORD *)(a1 + 0xB00) + 0x88 * v15);
    if ( v58 )
    {
      v55 = v58;
      (**v58)();
    }
    v59 = *(_DWORD *)(a1 + 0xAFC);
    if ( v59 )
    {
      *(_DWORD *)(a1 + 0xAFC) = v59 - 1;
    }
    else
    {
      *(_DWORD *)(a1 + 0xAF8) = 0xFFFFFFFF;
      v60 = _InterlockedCompareExchange(v54, 0, 1);
      if ( v60 == 1 )
        *(_QWORD *)(a1 + 0xAF0) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      else
        sub_1403DB1F0(a1 + 0xAE8, v60);
    }
    v61 = ((__int64 (__fastcall *)(void (***)(void)))(*v55)[0x76])(v55);
    v100[1] = *(_QWORD *)(v61 + 8);
    v101 = *(_DWORD *)(v61 + 0x10);
    v102 = *(_DWORD *)(v61 + 0x14);
    v103 = *(_DWORD *)(v61 + 0x18);
    v104 = *(_DWORD *)(v61 + 0x1C);
    v105 = *(_DWORD *)(v61 + 0x20);
    v106 = *(_BYTE *)(v61 + 0x24);
    v107 = *(_BYTE *)(v61 + 0x25);
    v108 = *(_BYTE *)(v61 + 0x26);
    v109 = *(_BYTE *)(v61 + 0x27);
    v122 = *(_OWORD *)(v61 + 0x60);
    v123 = *(_DWORD *)(v61 + 0x70);
    v100[0] = v14;
    v122 = *sub_1403F6DC0(v124);
    v62 = (float *)(*(_QWORD *)(a1 + 0x878) + 0x1C * v15);
    v63 = *v62;
    v64 = v62[1];
    v65 = v62[3];
    v66 = v62[2];
    v67 = (float)(v66 + v66) * v64;
    v68 = (float)(v64 + v64) * v64;
    v69 = (float)(v64 + v64) * *v62;
    v70 = v65 * (float)(v64 + v64);
    v71 = v65 * (float)(v63 + v63);
    v72 = 1.0 - (float)((float)(v63 + v63) * v63);
    v73 = (float)(v66 + v66) * *v62;
    v74 = (float)(v66 + v66) * v66;
    v75 = v65 * (float)(v66 + v66);
    v76 = v69 - v75;
    v77 = (float)(1.0 - v68) - v74;
    v78 = v62[4];
    v79 = v75 + v69;
    v80 = v62[5];
    v81 = v72 - v74;
    v82 = v62[6];
    v120 = v72 - v68;
    v110 = v77;
    v111 = v76;
    v112 = v73 + v70;
    v113 = v78;
    v114 = v79;
    v115 = v81;
    v116 = v67 - v71;
    v117 = v80;
    v118 = v73 - v70;
    v119 = v67 + v71;
    v121 = v82;
    v83 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)::pSystem + 0x2D0LL))(::pSystem);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v83 + 0x128LL))(v83);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v83 + 0x138LL))(v83);
    pSystem = ::pSystem;
    v85 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, double *, _DWORD, __int64, _QWORD *, char, _BYTE))(*(_QWORD *)::pSystem + 0x2E8LL);
    v86 = ((__int64 (__fastcall *)(void (***)(void)))(*v55)[0x6A])(v55);
    v87 = v85(pSystem, v83, 0, v96, 0, v86, v100, 1, 0);
    v88 = *(_QWORD *)(a1 + 0x978);
    v89 = (*(_QWORD *)(a1 + 0x980) - v88) >> 4;
    while ( v89 )
    {
      if ( *(_DWORD *)(v88 + 0x10 * (v89 >> 1)) >= (int)v15 )
      {
        v89 >>= 1;
      }
      else
      {
        v88 += 0x10 * (v89 >> 1) + 0x10;
        v89 += 0xFFFFFFFFFFFFFFFFuLL - (v89 >> 1);
      }
    }
    if ( v88 == *(_QWORD *)(a1 + 0x980) || (int)v15 < *(_DWORD *)v88 )
    {
      v92.m128i_i32[0] = v15;
      v92.m128i_i64[1] = 0;
      v88 = *(_QWORD *)sub_1422DAC10((__int64 *)(a1 + 0x978), (__int64)&v93, &v92);
    }
    *(_QWORD *)(v88 + 8) = v83;
    if ( !v87 )
      sub_146F11680(a1, v15, 1, 1u);
    if ( v55 )
      ((void (__fastcall *)(void (***)(void)))(*v55)[1])(v55);
  }
}

// --- End Function: sub_146F0FB20 (0x146F0FB20) ---

// --- Function: sub_146F10CC0 (0x146F10CC0) ---
void __fastcall sub_146F10CC0(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __int128 v9; // xmm11
  __int128 v10; // xmm12
  __int128 v11; // xmm13
  __int128 v12; // xmm14
  __int128 v13; // xmm15
  __int64 v16; // r12
  __int128 v18; // xmm0
  double v19; // xmm1_8
  double v20; // xmm6_8
  double v21; // xmm8_8
  double v22; // xmm5_8
  double v23; // xmm7_8
  double v25; // xmm14_8
  double v26; // xmm10_8
  double v27; // xmm6_8
  double v28; // xmm9_8
  __int64 v29; // rax
  __int64 v31; // rax
  double *v32; // rax
  double v33; // xmm11_8
  double v34; // xmm12_8
  double v35; // xmm9_8
  double v36; // xmm10_8
  double v37; // xmm8_8
  double v38; // xmm7_8
  double v39; // xmm4_8
  double v40; // xmm5_8
  double v41; // xmm6_8
  double v42; // xmm7_8
  double v43; // xmm4_8
  double v44; // kr00_8
  __int64 v45; // rax
  __int64 v46; // r8
  __int64 v47; // rdi
  double v48; // xmm2_8
  double v49; // xmm3_8
  double v50; // xmm12_8
  double v51; // xmm10_8
  double v52; // xmm11_8
  double v53; // xmm9_8
  double v54; // xmm7_8
  double v55; // xmm6_8
  double v56; // xmm5_8
  double v57; // xmm3_8
  unsigned __int64 v58; // rdx
  volatile signed __int32 *v59; // rbx
  void (***v60)(void); // rsi
  unsigned __int32 v61; // eax
  void (***v62)(void); // rcx
  int v63; // eax
  unsigned __int32 v64; // eax
  __int64 v65; // rax
  __int128 *v66; // rax
  __int64 v67; // rcx
  float *v68; // rax
  float v69; // xmm10_4
  float v70; // xmm4_4
  float v71; // xmm1_4
  float v72; // xmm6_4
  float v73; // xmm9_4
  float v74; // xmm13_4
  float v75; // xmm3_4
  float v76; // xmm5_4
  float v77; // xmm12_4
  float v78; // xmm14_4
  float v79; // xmm4_4
  float v80; // xmm2_4
  float v81; // xmm1_4
  float v82; // xmm7_4
  float v83; // xmm6_4
  float v84; // xmm0_4
  float v85; // xmm10_4
  float v86; // xmm2_4
  float v87; // kr00_4
  float v88; // xmm1_4
  char v89; // al
  __int64 pSystem; // r15
  char v91; // bl
  unsigned __int8 (__fastcall *v92)(__int64, _QWORD, _QWORD, double *, _DWORD, __int64, _QWORD *, char, char); // r14
  __int64 v93; // rax
  double v94; // [rsp+50h] [rbp-B0h]
  int v95; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v96; // [rsp+58h] [rbp-A8h] BYREF
  double v97; // [rsp+60h] [rbp-A0h]
  double v98; // [rsp+68h] [rbp-98h]
  double v99[6]; // [rsp+70h] [rbp-90h] BYREF
  __int128 v100; // [rsp+A0h] [rbp-60h]
  double v101; // [rsp+B0h] [rbp-50h]
  double v102[16]; // [rsp+C0h] [rbp-40h] BYREF
  __int128 v103; // [rsp+140h] [rbp+40h]
  double v104; // [rsp+150h] [rbp+50h]
  _BYTE v105[56]; // [rsp+158h] [rbp+58h] BYREF
  _QWORD v106[2]; // [rsp+190h] [rbp+90h] BYREF
  int v107; // [rsp+1A0h] [rbp+A0h]
  int v108; // [rsp+1A4h] [rbp+A4h]
  int v109; // [rsp+1A8h] [rbp+A8h]
  int v110; // [rsp+1ACh] [rbp+ACh]
  int v111; // [rsp+1B0h] [rbp+B0h]
  char v112; // [rsp+1B4h] [rbp+B4h]
  char v113; // [rsp+1B5h] [rbp+B5h]
  char v114; // [rsp+1B6h] [rbp+B6h]
  char v115; // [rsp+1B7h] [rbp+B7h]
  float v116; // [rsp+1B8h] [rbp+B8h]
  float v117; // [rsp+1BCh] [rbp+BCh]
  float v118; // [rsp+1C0h] [rbp+C0h]
  float v119; // [rsp+1C4h] [rbp+C4h]
  float v120; // [rsp+1C8h] [rbp+C8h]
  float v121; // [rsp+1CCh] [rbp+CCh]
  float v122; // [rsp+1D0h] [rbp+D0h]
  float v123; // [rsp+1D4h] [rbp+D4h]
  float v124; // [rsp+1D8h] [rbp+D8h]
  float v125; // [rsp+1DCh] [rbp+DCh]
  float v126; // [rsp+1E0h] [rbp+E0h]
  float v127; // [rsp+1E4h] [rbp+E4h]
  __int128 v128; // [rsp+1F0h] [rbp+F0h]
  int v129; // [rsp+200h] [rbp+100h]
  _OWORD v130[12]; // [rsp+210h] [rbp+110h] BYREF

  v16 = a2;
  if ( !BYTE1(isSandboxEditor) )
  {
    v96 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x7358LL);
    if ( is_entity_descriptor_valid_or_accessible(&v96)
      && !(*(unsigned __int8 (__fastcall **)(unsigned __int64, __int64))(*(_QWORD *)(v96 & 0xFFFFFFFFFFFFLL) + 0x40LL))(
            v96 & 0xFFFFFFFFFFFFLL,
            0x8000) )
    {
      v130[0xB] = v4;
      v130[0xA] = v5;
      v130[9] = v6;
      v130[8] = v7;
      v130[7] = v8;
      v130[6] = v9;
      v130[5] = v10;
      v130[4] = v11;
      v130[3] = v12;
      v130[2] = v13;
      v18 = *(_OWORD *)(a4 + 0x20);
      v19 = *(double *)(a4 + 0x30);
      v20 = *(double *)(a4 + 0x10);
      v21 = *(double *)(a4 + 0x18);
      v22 = *(double *)a4;
      v23 = *(double *)(a4 + 8);
      v99[0] = v20;
      v94 = v21;
      v100 = v18;
      v101 = v19;
      if ( a3 )
      {
        v25 = v101;
        *(_QWORD *)&_XMM15 = *((_QWORD *)&v100 + 1);
        *(_QWORD *)&_XMM13 = v100;
      }
      else
      {
        _XMM13 = *(_OWORD *)(*(_QWORD *)(a1 + 8) + 0x7200LL);
        v25 = *(double *)(*(_QWORD *)(a1 + 8) + 0x7210LL);
        v26 = *(double *)(*(_QWORD *)(a1 + 8) + 0x71E0LL);
        v27 = *(double *)(*(_QWORD *)(a1 + 8) + 0x71E8LL);
        v28 = *(double *)(*(_QWORD *)(a1 + 8) + 0x71F0LL);
        v21 = *(double *)(*(_QWORD *)(a1 + 8) + 0x71F8LL);
        v29 = *(_QWORD *)(v96 & 0xFFFFFFFFFFFFLL);
        __asm { vunpckhpd xmm15, xmm13, xmm13 }
        *(double *)v130 = v26;
        v97 = v27;
        v98 = v28;
        v94 = v21;
        *(double *)&v100 = *(double *)&_XMM13;
        *((double *)&v100 + 1) = *(double *)&_XMM15;
        v101 = v25;
        v103 = _XMM13;
        v104 = v25;
        v31 = (*(__int64 (__fastcall **)(unsigned __int64))(v29 + 0x668))(v96 & 0xFFFFFFFFFFFFLL);
        a3 = v31;
        if ( v31 )
        {
          v32 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, __int64, _QWORD))(*(_QWORD *)v31 + 0x80LL))(
                            v31,
                            v105,
                            1,
                            (unsigned int)dword_149B4FDFC);
          v33 = v32[1];
          v34 = v32[2];
          v35 = *v32;
          v36 = v32[3];
          v37 = v25 * v33 - *(double *)&_XMM15 * v34 + *(double *)&_XMM13 * v36;
          v38 = *(double *)&_XMM13 * v34 - v25 * *v32 + *(double *)&_XMM15 * v36;
          v39 = *(double *)&_XMM15 * *v32 - *(double *)&_XMM13 * v33 + v25 * v36;
          v40 = v33 * v39 - v34 * v38;
          v41 = v34 * v37 - *v32 * v39;
          v42 = *v32 * v38 - v33 * v37;
          v43 = v40 + v32[4] + *(double *)&_XMM13 + v40;
          v44 = v42 + v32[6];
          *((double *)&v100 + 1) = v41 + v32[5] + *(double *)&_XMM15 + v41;
          *(_QWORD *)&_XMM15 = *((_QWORD *)&v100 + 1);
          v25 = v44 + v25 + v42;
          v22 = v33 * v98 - v34 * v97 + *(double *)v130 * v36 + v94 * v35;
          *(double *)&v100 = v43;
          *(double *)&_XMM13 = v43;
          v23 = *(double *)v130 * v34 - v35 * v98 + v36 * v97 + v94 * v33;
          v20 = v35 * v97 - *(double *)v130 * v33 + v36 * v98 + v94 * v34;
          v21 = v94 * v36 - v35 * *(double *)v130 - v33 * v97 - v34 * v98;
          v94 = v21;
          v101 = v25;
          v99[0] = v20;
        }
        else
        {
          v45 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(v96 & 0xFFFFFFFFFFFFLL) + 0x648LL))(v96 & 0xFFFFFFFFFFFFLL);
          v23 = v27;
          v20 = v28;
          v99[0] = v28;
          a3 = v45;
          v22 = v26;
        }
      }
      v46 = *(_QWORD *)(a1 + 0x968);
      v47 = *(_QWORD *)(a1 + 0x960);
      v48 = v23 + v23;
      v49 = v20 + v20;
      v50 = 1.0 - (v22 + v22) * v22;
      v51 = (v22 + v22) * v21;
      v52 = (v23 + v23) * v23;
      v53 = (v20 + v20) * v23;
      v54 = (v20 + v20) * v22;
      v55 = v48 * v22;
      v56 = v49 * v99[0];
      v57 = v49 * v94;
      v102[0] = 1.0 - v52 - v56;
      v102[2] = v54 + v48 * v21;
      v102[5] = v50 - v56;
      v102[4] = v57 + v55;
      v102[8] = v54 - v48 * v21;
      v102[6] = v53 - v51;
      v58 = (v46 - v47) >> 3;
      v102[7] = *(double *)&_XMM15;
      v102[0xA] = v50 - v52;
      v102[1] = v55 - v57;
      v102[3] = *(double *)&_XMM13;
      v102[9] = v53 + v51;
      v102[0xB] = v25;
      while ( v58 )
      {
        if ( *(_DWORD *)(v47 + 8 * (v58 >> 1)) >= (int)v16 )
        {
          v58 >>= 1;
        }
        else
        {
          v47 += 8 * (v58 >> 1) + 8;
          v58 += 0xFFFFFFFFFFFFFFFFuLL - (v58 >> 1);
        }
      }
      if ( v47 == v46 || (int)v16 < *(_DWORD *)v47 )
      {
        LODWORD(v130[0]) = v16;
        BYTE4(v130[0]) = 0;
        v47 = *(_QWORD *)sub_146F8F5F0(a1 + 0x960, v99, v130);
      }
      v59 = (volatile signed __int32 *)(a1 + 0xAE8);
      v60 = 0;
      v95 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
      if ( *(_DWORD *)(a1 + 0xAF8) == v95 )
      {
        ++*(_DWORD *)(a1 + 0xAFC);
      }
      else
      {
        v61 = _InterlockedCompareExchange(v59, 1, 0);
        if ( v61 )
          sub_1403C33A0(a1 + 0xAE8, v61, "CSkeletonPose::CreateVisAreaAtJoint", 1);
        else
          *(_QWORD *)(a1 + 0xAF0) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
        *(_DWORD *)(a1 + 0xAF8) = v95;
      }
      v62 = *(void (****)(void))sub_146F54F80(*(_QWORD *)(a1 + 0xB00) + 0x88 * v16);
      if ( v62 )
      {
        v60 = v62;
        (**v62)();
      }
      v63 = *(_DWORD *)(a1 + 0xAFC);
      if ( v63 )
      {
        *(_DWORD *)(a1 + 0xAFC) = v63 - 1;
      }
      else
      {
        *(_DWORD *)(a1 + 0xAF8) = 0xFFFFFFFF;
        v64 = _InterlockedCompareExchange(v59, 0, 1);
        if ( v64 == 1 )
          *(_QWORD *)(a1 + 0xAF0) = &p_p_p_p_p_p_p_p_p_p_p_Source;
        else
          sub_1403DB1F0(a1 + 0xAE8, v64);
      }
      v65 = ((__int64 (__fastcall *)(void (***)(void)))(*v60)[0x76])(v60);
      v106[1] = *(_QWORD *)(v65 + 8);
      v107 = *(_DWORD *)(v65 + 0x10);
      v108 = *(_DWORD *)(v65 + 0x14);
      v109 = *(_DWORD *)(v65 + 0x18);
      v110 = *(_DWORD *)(v65 + 0x1C);
      v111 = *(_DWORD *)(v65 + 0x20);
      v112 = *(_BYTE *)(v65 + 0x24);
      v113 = *(_BYTE *)(v65 + 0x25);
      v114 = *(_BYTE *)(v65 + 0x26);
      v115 = *(_BYTE *)(v65 + 0x27);
      v128 = *(_OWORD *)(v65 + 0x60);
      v129 = *(_DWORD *)(v65 + 0x70);
      v106[0] = a3;
      v66 = sub_1403F6DC0(v130);
      v67 = *(_QWORD *)(a1 + 0x958);
      v128 = *v66;
      v68 = (float *)(*(_QWORD *)(a1 + 0x878) + 0x1C * v16);
      v69 = *v68;
      v70 = v68[1];
      v71 = v68[3];
      v72 = v68[2];
      v73 = (float)(v72 + v72) * v70;
      v74 = (float)(v70 + v70) * v70;
      v75 = (float)(v70 + v70) * *v68;
      v76 = v71 * (float)(v70 + v70);
      v77 = v71 * (float)(v69 + v69);
      v78 = 1.0 - (float)((float)(v69 + v69) * v69);
      v79 = (float)(v72 + v72) * *v68;
      v80 = (float)(v72 + v72) * v72;
      v81 = v71 * (float)(v72 + v72);
      v82 = v75 - v81;
      v83 = (float)(1.0 - v74) - v80;
      v84 = v68[4];
      v85 = v78 - v80;
      v86 = v68[6];
      v87 = v81 + v75;
      v88 = v68[5];
      v126 = v78 - v74;
      v116 = v83;
      v117 = v82;
      v118 = v79 + v76;
      v119 = v84;
      v120 = v87;
      v121 = v85;
      v122 = v73 - v77;
      v123 = v88;
      v124 = v79 - v76;
      v125 = v73 + v77;
      v127 = v86;
      if ( v67 )
      {
        v89 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v67 + 0x160LL))(v67);
      }
      else
      {
        *(_QWORD *)(a1 + 0x958) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)::pSystem + 0x2D0LL))(::pSystem);
        v89 = 0;
      }
      *(_BYTE *)(v47 + 4) = v89;
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x958) + 0x138LL))(*(_QWORD *)(a1 + 0x958));
      pSystem = ::pSystem;
      v91 = *(_BYTE *)(v47 + 4);
      v92 = *(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD, double *, _DWORD, __int64, _QWORD *, char, char))(*(_QWORD *)::pSystem + 0x2E8LL);
      v93 = ((__int64 (__fastcall *)(void (***)(void)))(*v60)[0x6A])(v60);
      if ( !v92(pSystem, *(_QWORD *)(a1 + 0x958), 0, v102, 0, v93, v106, v91, 1) )
        sub_146F11750(a1, v16, 1, 1u);
      if ( v60 )
        ((void (__fastcall *)(void (***)(void)))(*v60)[1])(v60);
    }
  }
}

// --- End Function: sub_146F10CC0 (0x146F10CC0) ---

// --- Function: sub_146F11680 (0x146F11680) ---
unsigned __int64 __fastcall sub_146F11680(__int64 a1, int a2, char a3, unsigned __int8 a4)
{
  __int64 v4; // r10
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // rcx
  unsigned __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 i; // r10

  v4 = *(_QWORD *)(a1 + 0x978);
  v6 = (*(_QWORD *)(a1 + 0x980) - v4) >> 4;
  while ( v6 )
  {
    v7 = v6 >> 1;
    result = 2 * (v6 >> 1);
    if ( *(_DWORD *)(v4 + 0x10 * (v6 >> 1)) >= a2 )
    {
      v6 >>= 1;
    }
    else
    {
      result = 0xFFFFFFFFFFFFFFFFuLL - v7;
      v4 += 0x10 * (v6 >> 1) + 0x10;
      v6 += 0xFFFFFFFFFFFFFFFFuLL - v7;
    }
  }
  if ( v4 != *(_QWORD *)(a1 + 0x980) && a2 < *(_DWORD *)v4 )
    v4 = *(_QWORD *)(a1 + 0x980);
  v9 = *(_QWORD *)(a1 + 0x980);
  if ( v4 != v9 )
  {
    v10 = *(_QWORD *)(v4 + 8);
    for ( i = v4 + 0x10; i != v9; i += 0x10 )
    {
      *(_DWORD *)(i - 0x10) = *(_DWORD *)i;
      result = *(_QWORD *)(i + 8);
      *(_QWORD *)(i - 8) = result;
    }
    *(_QWORD *)(a1 + 0x980) -= 0x10LL;
    if ( a3 || (*(_BYTE *)(a1 + 0x94C) & 0x10) != 0 )
      return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)pSystem + 0x2D8LL))(pSystem, v10, a4);
  }
  return result;
}

// --- End Function: sub_146F11680 (0x146F11680) ---

// --- Function: sub_146F11750 (0x146F11750) ---
__int64 __fastcall sub_146F11750(__int64 a1, int a2, char a3, unsigned __int8 a4)
{
  __int64 v4; // rdi
  __int64 result; // rax
  unsigned __int64 v7; // r10
  __int64 v9; // rdx
  unsigned __int8 v10; // di

  v4 = *(_QWORD *)(a1 + 0x968);
  result = *(_QWORD *)(a1 + 0x960);
  v7 = (v4 - result) >> 3;
  while ( v7 )
  {
    if ( *(_DWORD *)(result + 8 * (v7 >> 1)) >= a2 )
    {
      v7 >>= 1;
    }
    else
    {
      result += 8 * (v7 >> 1) + 8;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  if ( result != v4 && a2 < *(_DWORD *)result )
    result = *(_QWORD *)(a1 + 0x968);
  v9 = *(_QWORD *)(a1 + 0x968);
  if ( result != v4 )
  {
    v10 = *(_BYTE *)(result + 4);
    for ( result += 8; result != v9; result += 8 )
    {
      *(_DWORD *)(result - 8) = *(_DWORD *)result;
      *(_BYTE *)(result - 4) = *(_BYTE *)(result + 4);
    }
    *(_QWORD *)(a1 + 0x968) -= 8LL;
    if ( a3 || (*(_BYTE *)(a1 + 0x94C) & 0x10) != 0 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x958) + 0x110LL))(*(_QWORD *)(a1 + 0x958)) )
      {
        return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 0x958) + 0x168LL))(
                 *(_QWORD *)(a1 + 0x958),
                 v10,
                 a4);
      }
      else
      {
        result = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)pSystem + 0x2D8LL))(
                   pSystem,
                   *(_QWORD *)(a1 + 0x958),
                   a4);
        *(_QWORD *)(a1 + 0x958) = 0;
      }
    }
  }
  return result;
}

// --- End Function: sub_146F11750 (0x146F11750) ---

// --- Function: sub_146F48390 (0x146F48390) ---
_QWORD *__fastcall sub_146F48390(__int64 a1, _QWORD *a2, char a3)
{
  __int64 v6; // rbx
  __int64 (__fastcall *v7)(__int64, char *, __int16 *); // rbp
  __int16 n0xFFFF; // ax
  __int64 v9; // rbx
  __int64 v10; // rax
  __int16 n4; // dx
  __int64 v12; // rbx
  __int64 v13; // rax
  _QWORD *v14; // rax
  __int64 v15; // rcx
  _QWORD *v16; // r14
  _QWORD *v17; // rax
  __int64 v18; // rcx
  _QWORD *v19; // rbx
  __int64 v20; // rax
  __int64 v21; // rbx
  bool v22; // cl
  __int64 v23; // rbx
  __int64 v25; // [rsp+50h] [rbp+8h] BYREF
  char v26; // [rsp+58h] [rbp+10h] BYREF
  __int16 n0xFFFF_1; // [rsp+60h] [rbp+18h] BYREF

  *a2 = 0;
  if ( is_entity_descriptor_valid_or_accessible((unsigned __int64 *)(a1 + 0x7358)) )
  {
    v6 = *(_QWORD *)(a1 + 0x7358) & 0xFFFFFFFFFFFFLL;
    v7 = *(__int64 (__fastcall **)(__int64, char *, __int16 *))(*(_QWORD *)v6 + 0x340LL);
    n0xFFFF = n0xFFFF_43;
    if ( n0xFFFF_43 == (__int16)0xFFFF )
    {
      n0xFFFF = *(_WORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, const char *))(*(_QWORD *)pEngineComponentScheduler
                                                                                      + 0x10LL))(
                            pEngineComponentScheduler,
                            &v25,
                            "IEntityRenderProxy");
      n0xFFFF_43 = n0xFFFF;
    }
    n0xFFFF_1 = n0xFFFF;
    v9 = *(_QWORD *)v7(v6, &v26, &n0xFFFF_1);
    v25 = v9;
    if ( v9 )
    {
      v10 = sub_1403B4B50(v9 & 0xFFFFFFFFFFFFLL);
      n4 = *(_WORD *)(v10 + 4);
      if ( n4 != 4
        && *(_WORD *)(v10 + 2) == (HIWORD(v9) & 0xFFF)
        && (n4 == 2 && !*(_QWORD *)get_thread_context_ptr() || sub_140391F30(&v25)) )
      {
        v12 = v9 & 0xFFFFFFFFFFFFLL;
        v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x5D8LL))(v12);
        v14 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v13 + 0x130LL))(v13, &v25);
        v15 = *a2;
        v16 = v14;
        *a2 = *v14;
        *v14 = v15;
        if ( v15 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 0x10LL))(v15);
        *v16 = 0;
        if ( v25 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x10LL))(v25);
        if ( !*a2 )
        {
          v17 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v12 + 0x5A8LL))(
                            v12,
                            &v25,
                            *(unsigned int *)(a1 + 0x7360));
          v18 = *a2;
          v19 = v17;
          *a2 = *v17;
          *v17 = v18;
          if ( v18 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 0x10LL))(v18);
          *v19 = 0;
          if ( v25 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v25 + 0x10LL))(v25);
        }
      }
    }
  }
  v20 = *a2;
  if ( !*a2 )
  {
    v21 = *(_QWORD *)(a1 + 0x7348);
    if ( v21 )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v21 + 8LL))(*(_QWORD *)(a1 + 0x7348));
      if ( *a2 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x10LL))(*a2);
      *a2 = v21;
      v20 = v21;
    }
  }
  v22 = !a3 || *(_QWORD *)(a1 + 0x7368) != a1;
  if ( !v20 && v22 )
  {
    v23 = *(_QWORD *)(a1 + 0x7340);
    if ( v23 )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v23 + 8LL))(*(_QWORD *)(a1 + 0x7340));
      if ( *a2 )
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 0x10LL))(*a2);
      *a2 = v23;
    }
  }
  return a2;
}

// --- End Function: sub_146F48390 (0x146F48390) ---

// --- Function: sub_146F54F80 (0x146F54F80) ---
__int64 *__fastcall sub_146F54F80(__int64 a1)
{
  __int64 v3; // rcx

  if ( (dword_1515BC4D8 & 1) == 0 )
  {
    qword_1515BC4D0 = 0;
    dword_1515BC4D8 |= 1u;
    atexit(sub_148172620);
  }
  if ( *(_BYTE *)(a1 + 0x18) )
    return (__int64 *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 0x10) + 0x1F0LL))(*(_QWORD *)(a1 + 0x10));
  v3 = *(_QWORD *)(a1 + 8);
  if ( v3 )
    return (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x80LL))(v3);
  else
    return &qword_1515BC4D0;
}

// --- End Function: sub_146F54F80 (0x146F54F80) ---

// --- Function: sub_146F55020 (0x146F55020) ---
_QWORD *__fastcall sub_146F55020(_QWORD *a1, _QWORD *a2, int a3)
{
  __int64 v3; // rbp
  __int64 v6; // rbx
  int v7; // r14d
  unsigned __int32 v8; // eax
  __int64 v9; // rdx
  void (__fastcall ****v10)(_QWORD); // rax
  void (__fastcall ***v11)(_QWORD); // rcx
  int v12; // eax
  unsigned __int32 v13; // eax
  _QWORD *result; // rax

  v3 = a3;
  if ( a3 >= 0 && a3 < *(_DWORD *)(*(_QWORD *)(a1[1] + 0x72E0LL) + 0x528LL) )
  {
    v6 = (__int64)(a1 + 0x15D);
    v7 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
    if ( *(_DWORD *)(v6 + 0x10) == v7 )
    {
      ++*(_DWORD *)(v6 + 0x14);
    }
    else
    {
      v8 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 1, 0);
      if ( v8 )
        sub_1403C33A0(v6, v8, "CSkeletonPose::GetStatObjOnJoint", 1);
      else
        *(_QWORD *)(v6 + 8) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
      *(_DWORD *)(v6 + 0x10) = v7;
    }
    v9 = a1[0x160];
    if ( v9 == a1[0x161] )
    {
      *a2 = 0;
      v12 = *(_DWORD *)(v6 + 0x14);
      if ( !v12 )
      {
        *(_DWORD *)(v6 + 0x10) = 0xFFFFFFFF;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 0, 1);
        if ( v13 == 1 )
        {
          *(_QWORD *)(v6 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
          return a2;
        }
        goto LABEL_19;
      }
    }
    else
    {
      v10 = (void (__fastcall ****)(_QWORD))sub_146F54F80(v9 + 0x88 * v3);
      v11 = *v10;
      *a2 = *v10;
      if ( v11 )
        (**v11)(v11);
      v12 = *(_DWORD *)(v6 + 0x14);
      if ( !v12 )
      {
        *(_DWORD *)(v6 + 0x10) = 0xFFFFFFFF;
        v13 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 0, 1);
        if ( v13 == 1 )
        {
          *(_QWORD *)(v6 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
          return a2;
        }
LABEL_19:
        sub_1403DB1F0(v6, v13);
        return a2;
      }
    }
    *(_DWORD *)(v6 + 0x14) = v12 - 1;
    return a2;
  }
  result = a2;
  *a2 = 0;
  return result;
}

// --- End Function: sub_146F55020 (0x146F55020) ---

// --- Function: sub_146F554F0 (0x146F554F0) ---
int *__fastcall sub_146F554F0(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v3; // rcx

  if ( (dword_1515BC4F4 & 1) == 0 )
  {
    dword_1515BC4E0 = 0;
    dword_1515BC4F4 |= 1u;
    n0x5070700 = 0x5070700;
    word_1515BC4E8 = 0;
    dword_1515BC4EB = 0;
    byte_1515BC4EA = 0;
    word_1515BC4EF = 0;
    byte_1515BC4F1 = 0;
  }
  if ( *(_BYTE *)(a1 + 0x18) )
  {
    v1 = *(_QWORD *)(a1 + 0x10);
    if ( v1 )
      return (int *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v1 + 0x208LL))(*(_QWORD *)(a1 + 0x10));
  }
  v3 = *(_QWORD *)(a1 + 8);
  if ( v3 )
    return (int *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 0x98LL))(v3);
  else
    return &dword_1515BC4E0;
}

// --- End Function: sub_146F554F0 (0x146F554F0) ---

// --- Function: sub_146F55580 (0x146F55580) ---
__int64 __fastcall sub_146F55580(__int64 a1, __int64 a2, int a3)
{
  unsigned __int64 v3; // r15
  __int64 v4; // rbx
  int v7; // r14d
  unsigned __int32 v8; // eax
  __int64 v9; // r8
  int *v10; // rax
  char v11; // al
  int v12; // eax
  unsigned __int32 v13; // eax

  v3 = a3;
  v4 = a1 + 0xAE8;
  v7 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
    if ( v8 )
      sub_1403C33A0(v4, v8, "CSkeletonPose::GetVisualStateOnJoint", 1);
    else
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    *(_DWORD *)(v4 + 0x10) = v7;
  }
  if ( (v3 & 0x80000000) == 0LL
    && (v9 = *(_QWORD *)(a1 + 0xB00), v3 < (*(_QWORD *)(a1 + 0xB08) - v9) / 0x88)
    && *(_QWORD *)sub_146F54F80(0x88 * v3 + v9) )
  {
    v10 = sub_146F554F0(0x88 * v3 + *(_QWORD *)(a1 + 0xB00));
    *(_BYTE *)a2 = *(_BYTE *)v10;
    *(_BYTE *)(a2 + 1) = *((_BYTE *)v10 + 1);
    *(_BYTE *)(a2 + 2) = *((_BYTE *)v10 + 2);
    *(_BYTE *)(a2 + 3) = *((_BYTE *)v10 + 3);
    *(_BYTE *)(a2 + 4) = *((_BYTE *)v10 + 4);
    *(_BYTE *)(a2 + 5) = *((_BYTE *)v10 + 5);
    *(_BYTE *)(a2 + 6) = *((_BYTE *)v10 + 6);
    *(_BYTE *)(a2 + 7) = *((_BYTE *)v10 + 7);
    *(_BYTE *)(a2 + 8) = *((_BYTE *)v10 + 8);
    *(_DWORD *)(a2 + 9) = *(int *)((char *)v10 + 9);
    *(_DWORD *)(a2 + 0xD) = *(int *)((char *)v10 + 0xD);
    v11 = *((_BYTE *)v10 + 0x11);
  }
  else
  {
    v11 = 0;
    *(_OWORD *)a2 = 0;
    *(_WORD *)(a2 + 0x10) = 0;
    *(_DWORD *)(a2 + 0xD) = 0;
    *(_QWORD *)(a2 + 5) = 0x50707;
  }
  *(_BYTE *)(a2 + 0x11) = v11;
  v12 = *(_DWORD *)(v4 + 0x14);
  if ( v12 )
  {
    *(_DWORD *)(v4 + 0x14) = v12 - 1;
  }
  else
  {
    *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
    v13 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
    if ( v13 == 1 )
      *(_QWORD *)(v4 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(v4, v13);
  }
  return a2;
}

// --- End Function: sub_146F55580 (0x146F55580) ---

// --- Function: sub_146F75590 (0x146F75590) ---
__int64 __fastcall sub_146F75590(__int64 a1, int a2)
{
  float v2; // xmm0_4
  __int64 v3; // rbp
  __int64 v4; // rbx
  int v6; // esi
  unsigned __int32 v7; // eax
  __int64 v8; // rsi
  __int64 v9; // r12
  __int64 v10; // r14
  __int64 *v11; // rax
  __int64 v12; // r15
  unsigned int v13; // ebp
  int v14; // r14d
  unsigned int v15; // eax
  __int64 v16; // r8
  __int64 v17; // rcx
  int v20; // ecx
  unsigned int v21; // edi
  unsigned __int32 v22; // eax

  v3 = a2;
  v4 = a1 + 0xAE8;
  v6 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(v4 + 0x10) == v6 )
  {
    ++*(_DWORD *)(v4 + 0x14);
  }
  else
  {
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 1, 0);
    if ( v7 )
      sub_1403C33A0(v4, v7, "CSkeletonPose::PropogateDrawDist", 1);
    else
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    *(_DWORD *)(v4 + 0x10) = v6;
  }
  v8 = 0x88 * v3;
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x72E0LL);
  v10 = 0x88 * v3 + *(_QWORD *)(a1 + 0xB00);
  if ( *sub_146F54F80(v10) )
  {
    v11 = sub_146F54F80(v8 + *(_QWORD *)(a1 + 0xB00));
    (*(void (__fastcall **)(__int64))(*(_QWORD *)*v11 + 0x328LL))(*v11);
  }
  else
  {
    v2 = 0.0;
  }
  *(float *)(v10 + 0x1C) = v2;
  v12 = 0x20 * v3;
  v13 = v3 + 1;
  v14 = 0;
  if ( *(_WORD *)(v12 + *(_QWORD *)(v9 + 0x4F0) + 0xE) )
  {
    do
    {
      v15 = sub_146F75590(a1, v13);
      v16 = *(_QWORD *)(a1 + 0xB00);
      ++v14;
      v17 = (int)v13;
      v13 = v15;
      _XMM0 = *(unsigned int *)(0x88 * v17 + v16 + 0x1C);
      __asm { vmaxss  xmm1, xmm0, dword ptr [r8+rsi+1Ch] }
      *(float *)(v16 + v8 + 0x1C) = *(float *)&_XMM1;
    }
    while ( v14 < *(unsigned __int16 *)(*(_QWORD *)(v9 + 0x4F0) + v12 + 0xE) );
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 0xB00) + v8 + 0x20) = v13;
  v20 = *(_DWORD *)(v4 + 0x14);
  v21 = *(_DWORD *)(*(_QWORD *)(a1 + 0xB00) + v8 + 0x20);
  if ( v20 )
  {
    *(_DWORD *)(v4 + 0x14) = v20 - 1;
  }
  else
  {
    *(_DWORD *)(v4 + 0x10) = 0xFFFFFFFF;
    v22 = _InterlockedCompareExchange((volatile signed __int32 *)v4, 0, 1);
    if ( v22 == 1 )
      *(_QWORD *)(v4 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(v4, v22);
  }
  return v21;
}

// --- End Function: sub_146F75590 (0x146F75590) ---

// --- Function: sub_146F78EA0 (0x146F78EA0) ---
__int64 *__fastcall sub_146F78EA0(_QWORD *a1, _QWORD *a2, __int16 **a3)
{
  __int64 v5; // rdi
  __int64 v7; // rbx
  void (__fastcall *v8)(__int64, __int64); // r15
  __int64 *result; // rax
  __int64 v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // rcx
  _QWORD *v13; // rax
  __int64 v14; // rcx
  _QWORD *v15; // r14
  const void *v16; // rcx
  const void *v17; // rcx
  __int128 v18; // [rsp+20h] [rbp-50h] BYREF
  __int64 v19; // [rsp+30h] [rbp-40h]
  __int64 v20; // [rsp+38h] [rbp-38h] BYREF
  __int128 v21; // [rsp+40h] [rbp-30h] BYREF
  __int64 v22; // [rsp+50h] [rbp-20h]
  char v23; // [rsp+58h] [rbp-18h]
  int v24; // [rsp+5Ch] [rbp-14h]
  char v25; // [rsp+60h] [rbp-10h]
  __int64 v26; // [rsp+A0h] [rbp+30h] BYREF

  LODWORD(v26) = 0;
  v5 = a1[1];
  if ( v5 )
  {
    v7 = *a2;
    v8 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 0x20LL);
    if ( *a2 )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v7 + 8LL))(*a2);
      v8(v5, v7);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 0x10LL))(v7);
    }
    else
    {
      if ( *((_BYTE *)a1 + 0x18) )
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)a1[2] + 0x130LL))(a1[2], &v26);
      else
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v5 + 0x88LL))(v5, &v26);
      v8(v5, v26);
      if ( v26 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x10LL))(v26);
      v26 = 0;
    }
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)a1[1] + 0x40LL))(a1[1]);
  }
  result = sub_146F54F80((__int64)a1);
  v10 = *result;
  if ( *result )
  {
    (**(void (__fastcall ***)(__int64))v10)(v10);
    result = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x5E0LL))(v10);
    if ( (_BYTE)result )
    {
      v11 = *a2;
      if ( *a2 )
      {
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v11 + 8LL))(*a2);
      }
      else
      {
        if ( *((_BYTE *)a1 + 0x18) )
        {
          (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)a1[2] + 0x130LL))(a1[2], &v26);
          v11 = v26;
        }
        else
        {
          v12 = a1[1];
          if ( v12 )
          {
            (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v12 + 0x88LL))(v12, &v26);
            v11 = v26;
          }
          else
          {
            v11 = 0;
          }
        }
        v26 = 0;
      }
      (*(void (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v10 + 0x5E8LL))(v10, &v18);
      sub_146EF1BB0((__int64 *)&v18, *a3, a3[1]);
      v20 = 0;
      v22 = 0;
      v24 = 0;
      v25 = 0;
      v21 = 0;
      if ( v11 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
        if ( v20 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x10LL))(v20);
        v20 = v11;
      }
      v23 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 0x5E0LL))(v10);
      sub_1403420D0(&v21, v18, (__int64)(*((_QWORD *)&v18 + 1) - v18) >> 1);
      v13 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)qword_149B4FCE0 + 0x70LL))(
                        qword_149B4FCE0,
                        &v26,
                        &v20);
      v14 = *a1;
      v15 = v13;
      *a1 = *v13;
      *v13 = v14;
      if ( v14 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x10LL))(v14);
      *v15 = 0;
      if ( v26 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v26 + 0x10LL))(v26);
      v16 = (const void *)v21;
      if ( (_QWORD)v21 )
      {
        if ( (unsigned __int64)(2 * ((v22 - (__int64)v21) >> 1)) >= 0x1000 )
        {
          v16 = *(const void **)(v21 - 8);
          if ( (unsigned __int64)(v21 - (_QWORD)v16 - 8) > 0x1F )
LABEL_38:
            invalid_parameter_noinfo_noreturn();
        }
        sub_1402A3D30(v16);
        v21 = 0;
        v22 = 0;
      }
      if ( v20 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x10LL))(v20);
      v17 = (const void *)v18;
      v20 = 0;
      if ( (_QWORD)v18 )
      {
        if ( (unsigned __int64)(2 * ((v19 - (__int64)v18) >> 1)) >= 0x1000 )
        {
          v17 = *(const void **)(v18 - 8);
          if ( (unsigned __int64)(v18 - (_QWORD)v17 - 8) > 0x1F )
            goto LABEL_38;
        }
        sub_1402A3D30(v17);
        v18 = 0;
        v19 = 0;
      }
      if ( v11 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x10LL))(v11);
      return (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
    }
  }
  if ( *a1 )
  {
    result = (__int64 *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a1 + 0x10LL))(*a1);
    *a1 = 0;
  }
  if ( v10 )
    return (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
  return result;
}

// --- End Function: sub_146F78EA0 (0x146F78EA0) ---

// --- Function: sub_146F791B0 (0x146F791B0) ---
const ULONG_PTR *__fastcall sub_146F791B0(__int64 a1, int a2)
{
  __int64 v2; // r15
  __int64 v4; // rax
  volatile signed __int32 *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rdi
  int v9; // r12d
  unsigned __int32 v10; // eax
  _QWORD *v11; // rdi
  __int64 *v12; // rax
  const void *v13; // rcx
  __int64 v14; // r8
  unsigned int v15; // r13d
  __int64 v16; // r9
  _QWORD *v17; // r12
  unsigned int v18; // ecx
  unsigned __int16 v19; // si
  unsigned __int16 v20; // di
  __int64 v21; // r15
  __int64 v22; // rax
  __int64 v23; // rcx
  __int16 *v24; // rcx
  const void *v25; // rcx
  int v26; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v28; // eax
  __int64 v29; // [rsp+20h] [rbp-49h] BYREF
  __int128 v30; // [rsp+28h] [rbp-41h] BYREF
  __int64 v31; // [rsp+38h] [rbp-31h]
  __int16 *v32[3]; // [rsp+40h] [rbp-29h] BYREF
  __int64 *v33[4]; // [rsp+58h] [rbp-11h] BYREF
  __int64 v34[9]; // [rsp+78h] [rbp+Fh] BYREF
  __int64 v35; // [rsp+D0h] [rbp+67h] BYREF
  __int64 v36; // [rsp+E0h] [rbp+77h] BYREF
  __int64 v37; // [rsp+E8h] [rbp+7Fh] BYREF

  v2 = a2;
  sub_146F48390(*(_QWORD *)(a1 + 8), &v37, 0);
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (volatile signed __int32 *)(a1 + 0xAE8);
  v33[2] = (__int64 *)a1;
  v6 = *(_QWORD **)(v4 + 0x72E0);
  v7 = v6[0xAF];
  if ( v7 == v6[0xB0] )
    v7 = 0;
  v35 = v7;
  v8 = v6[0xB2];
  if ( v8 == v6[0xB3] )
    v8 = 0;
  v36 = v8;
  v29 = v6[0xB5];
  v33[0] = &v35;
  v33[1] = &v36;
  v33[3] = &v29;
  v9 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(a1 + 0xAF8) == v9 )
  {
    ++*(_DWORD *)(a1 + 0xAFC);
  }
  else
  {
    v10 = _InterlockedCompareExchange(v5, 1, 0);
    if ( v10 )
      sub_1403C33A0(a1 + 0xAE8, v10, "CSkeletonPose::RecreateGPUMaterialPermutationCache", 1);
    else
      *(_QWORD *)(a1 + 0xAF0) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    v7 = v35;
    v8 = v36;
    *(_DWORD *)(a1 + 0xAF8) = v9;
  }
  if ( (_DWORD)v2 == 0xFFFFFFFF )
  {
    v14 = *(_QWORD *)(a1 + 0xB00);
    v15 = 0;
    if ( (*(_QWORD *)(a1 + 0xB08) - v14) / 0x88 )
    {
      v16 = 0;
      while ( 1 )
      {
        v17 = (_QWORD *)(v14 + 0x88 * v16);
        v31 = 0;
        v30 = 0;
        if ( v7 )
        {
          if ( v8 )
          {
            v18 = *(unsigned __int16 *)(v7 + 2LL * (int)v15);
            v19 = *(_WORD *)(v8 + 2LL * (int)v15);
            v20 = 0;
            if ( v19 )
            {
              v21 = v18;
              do
              {
                v22 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 0x7350LL) + 0x3F8LL))(
                        *(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x7350LL),
                        *(unsigned __int16 *)(v29 + 2 * (v21 + v20)));
                if ( v22 )
                {
                  v23 = *(_QWORD *)(v22 + 0xA0);
                  if ( v23 )
                  {
                    (*(void (__fastcall **)(__int64, __int16 **))(*(_QWORD *)v23 + 0x5E8LL))(v23, v32);
                    sub_146EF1BB0((__int64 *)&v30, v32[0], v32[1]);
                    v24 = v32[0];
                    if ( v32[0] )
                    {
                      if ( (unsigned __int64)(2 * (v32[2] - v32[0])) >= 0x1000 )
                      {
                        v24 = (__int16 *)*((_QWORD *)v32[0] + 0xFFFFFFFF);
                        if ( (unsigned __int64)((char *)v32[0] - (char *)v24 - 8) > 0x1F )
                          invalid_parameter_noinfo_noreturn();
                      }
                      sub_1402A3D30(v24);
                    }
                  }
                }
                ++v20;
              }
              while ( v20 < v19 );
            }
          }
        }
        sub_146F78EA0(v17, &v37, (__int16 **)&v30);
        v25 = (const void *)v30;
        if ( (_QWORD)v30 )
        {
          if ( (unsigned __int64)(2 * ((v31 - (__int64)v30) >> 1)) >= 0x1000 )
          {
            v25 = *(const void **)(v30 - 8);
            if ( (unsigned __int64)(v30 - (_QWORD)v25 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_1402A3D30(v25);
        }
        v14 = *(_QWORD *)(a1 + 0xB00);
        v16 = ++v15;
        if ( v15 >= (unsigned __int64)((*(_QWORD *)(a1 + 0xB08) - v14) / 0x88) )
          break;
        v7 = v35;
        v8 = v36;
      }
    }
  }
  else
  {
    v11 = (_QWORD *)(*(_QWORD *)(a1 + 0xB00) + 0x88 * v2);
    v12 = sub_146EF6DD0(v33, v34, v2);
    sub_146F78EA0(v11, &v37, (__int16 **)v12);
    v13 = (const void *)v34[0];
    if ( v34[0] )
    {
      if ( (unsigned __int64)(2 * ((v34[2] - v34[0]) >> 1)) >= 0x1000 )
      {
        v13 = *(const void **)(v34[0] - 8);
        if ( (unsigned __int64)(v34[0] - (_QWORD)v13 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_1402A3D30(v13);
    }
  }
  v26 = *(_DWORD *)(a1 + 0xAFC);
  if ( v26 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v26 - 1);
    *(_DWORD *)(a1 + 0xAFC) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(a1 + 0xAF8) = 0xFFFFFFFF;
    v28 = _InterlockedCompareExchange(v5, 0, 1);
    if ( v28 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(a1 + 0xAF0) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = sub_1403DB1F0(a1 + 0xAE8, v28);
    }
  }
  if ( v37 )
    return (const ULONG_PTR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x10LL))(v37);
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_146F791B0 (0x146F791B0) ---

// --- Function: sub_146F79550 (0x146F79550) ---
void __fastcall sub_146F79550(__int64 a1, int a2, _QWORD *a3)
{
  __int64 v6; // rcx
  __int64 v7; // rsi
  __int64 v8; // rbx
  int v9; // r14d
  __int64 v10; // r8
  unsigned __int64 v11; // rax
  int v12; // eax
  unsigned __int64 n0x200000; // rax
  __m128i v18; // [rsp+30h] [rbp-98h] BYREF
  _BYTE v19[16]; // [rsp+40h] [rbp-88h] BYREF
  __int128 v20; // [rsp+50h] [rbp-78h] BYREF
  double v21; // [rsp+60h] [rbp-68h]
  double v22; // [rsp+68h] [rbp-60h]
  double v24; // [rsp+80h] [rbp-48h]
  unsigned __int64 v25; // [rsp+E8h] [rbp+20h] BYREF

  if ( !BYTE1(isSandboxEditor) )
  {
    v25 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x7358LL);
    if ( !is_entity_descriptor_valid_or_accessible(&v25)
      || (v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x7358LL) & 0xFFFFFFFFFFFFLL,
          !(*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 0x40LL))(v6, 0x8000)) )
    {
      sub_146F11750(a1, a2, 0, 0);
      sub_146F11680(a1, a2, 0, 0);
      if ( *a3 )
      {
        if ( (*(unsigned __int8 (**)(void))(*(_QWORD *)*a3 + 0x500LL))() )
        {
          LODWORD(v25) = a2;
          BYTE4(v25) = 0xFF;
          sub_146F8F5F0(a1 + 0x960, &v18, &v25);
          if ( (*(_BYTE *)(a1 + 0x94C) & 0x10) != 0 )
          {
            _XMM0 = 0;
            _XMM1 = 0;
            __asm
            {
              vmovupd [rsp+0C8h+var_78], xmm0
              vmovupd [rsp+0C8h+var_58], xmm1
            }
            v22 = 1.0;
            v21 = 0.0;
            v24 = 0.0;
            sub_146F10CC0(a1, a2, 0, (__int64)&v20);
          }
        }
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(*(_QWORD *)*a3 + 0x508LL))(*a3) )
        {
          v18.m128i_i32[0] = a2;
          v18.m128i_i64[1] = 0;
          sub_1422DAC10((__int64 *)(a1 + 0x978), (__int64)v19, &v18);
          if ( (*(_BYTE *)(a1 + 0x94C) & 0x10) != 0 )
          {
            _XMM0 = 0;
            _XMM1 = 0;
            __asm
            {
              vmovupd [rsp+0C8h+var_78], xmm0
              vmovupd [rsp+0C8h+var_58], xmm1
            }
            v22 = 1.0;
            v21 = 0.0;
            v24 = 0.0;
            sub_146F0FB20(a1, a2, 0, (__int64)&v20);
          }
        }
      }
      else if ( *(_QWORD *)(a1 + 0x950) )
      {
        v7 = _InterlockedExchange64((volatile __int64 *)(a1 + 0x950), 0);
        if ( v7 != qword_149AFBF50 )
        {
          v8 = (*(__int64 (**)(void))(*(_QWORD *)qword_149B4FBE8 + 0xA0LL))();
          v9 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
          if ( *(_DWORD *)(v8 + 0x10) == v9 )
          {
            ++*(_DWORD *)(v8 + 0x14);
          }
          else
          {
            v10 = *(_QWORD *)(get_thread_context_ptr() + 0x20);
            v11 = _InterlockedCompareExchange64((volatile signed __int64 *)v8, 0x200000, 0);
            if ( v11 )
              sub_1403DCD60(
                v8,
                v11,
                v10,
                "CSkeletonPose::RecreateVisAreasAtJoint",
                "gEnv->pZoneSystem->GetAnimatedVisAreaUpdateLock()",
                1);
            else
              *(_QWORD *)(v8 + 8) = v10;
            *(_DWORD *)(v8 + 0x10) = v9;
          }
          (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 0x1D0LL))(v7, a1);
          if ( v8 )
          {
            v12 = *(_DWORD *)(v8 + 0x14);
            if ( v12 )
            {
              *(_DWORD *)(v8 + 0x14) = v12 - 1;
            }
            else
            {
              *(_DWORD *)(v8 + 0x10) = 0xFFFFFFFF;
              n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v8, 0, 0x200000);
              if ( n0x200000 == 0x200000 )
                *(_QWORD *)(v8 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
              else
                rw_lock_handle_write_release_contention(v8, n0x200000);
            }
          }
        }
      }
    }
  }
}

// --- End Function: sub_146F79550 (0x146F79550) ---

// --- Function: sub_146F81FE0 (0x146F81FE0) ---
const ULONG_PTR *__fastcall sub_146F81FE0(_QWORD *a1, int a2, unsigned __int8 a3)
{
  __int64 v4; // rbp
  __int64 v6; // rbx
  int v7; // edi
  unsigned __int32 v8; // eax
  __int64 v9; // r8
  __int64 v10; // rdi
  __int64 v11; // rcx
  __int64 v12; // rcx
  int v13; // eax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rax
  unsigned __int32 v15; // eax

  v4 = a2;
  v6 = (__int64)(a1 + 0x15D);
  v7 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(v6 + 0x10) == v7 )
  {
    ++*(_DWORD *)(v6 + 0x14);
  }
  else
  {
    v8 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 1, 0);
    if ( v8 )
      sub_1403C33A0(v6, v8, "CSkeletonPose::SetJointVisibility", 1);
    else
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    *(_DWORD *)(v6 + 0x10) = v7;
  }
  if ( (int)v4 >= 0 )
  {
    v9 = a1[0x160];
    if ( (int)v4 < (int)((a1[0x161] - v9) / 0x88) )
    {
      v10 = v9 + 0x88 * v4;
      sub_146F831C0(v10, a3);
      v11 = *(_QWORD *)(v10 + 8);
      if ( v11 )
      {
        if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x38LL))(v11) )
        {
          v12 = a1[0x575];
          if ( v12 )
            (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v12 + 0x38LL))(v12, *(_QWORD *)(v10 + 8));
        }
      }
    }
  }
  v13 = *(_DWORD *)(v6 + 0x14);
  if ( v13 )
  {
    p_p_p_p_p_p_p_p_p_p_p_p_Source = (const ULONG_PTR *)(unsigned int)(v13 - 1);
    *(_DWORD *)(v6 + 0x14) = (_DWORD)p_p_p_p_p_p_p_p_p_p_p_p_Source;
  }
  else
  {
    *(_DWORD *)(v6 + 0x10) = 0xFFFFFFFF;
    v15 = _InterlockedCompareExchange((volatile signed __int32 *)v6, 0, 1);
    if ( v15 == 1 )
    {
      p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
      *(_QWORD *)(v6 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    }
    else
    {
      return sub_1403DB1F0(v6, v15);
    }
  }
  return p_p_p_p_p_p_p_p_p_p_p_p_Source;
}

// --- End Function: sub_146F81FE0 (0x146F81FE0) ---

// --- Function: sub_146F82930 (0x146F82930) ---
void __fastcall sub_146F82930(__int64 a1, int a2, _QWORD *a3, unsigned __int8 a4, int a5)
{
  __int64 v5; // r13
  __int64 *v9; // rcx
  volatile signed __int32 *v10; // rbx
  int v11; // edi
  unsigned __int32 v12; // eax
  __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 *v15; // r12
  char n0xA; // di
  __int64 v17; // rcx
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 *v21; // rcx
  __int64 v22; // rax
  _QWORD *v23; // rax
  __int64 v24; // r8
  _QWORD *v25; // r12
  __int64 v26; // rdi
  unsigned __int8 v27; // r14
  __int64 v28; // rsi
  __int64 (__fastcall *v29)(__int64, _QWORD); // rdi
  unsigned int v30; // eax
  __int64 v31; // rax
  char v32; // al
  int v33; // eax
  unsigned __int32 v34; // eax
  __int64 v35; // [rsp+48h] [rbp-31h] BYREF
  __int64 v36; // [rsp+50h] [rbp-29h] BYREF
  __int64 v37; // [rsp+58h] [rbp-21h] BYREF
  __int64 *v38; // [rsp+60h] [rbp-19h] BYREF
  __int64 v39; // [rsp+68h] [rbp-11h] BYREF
  __int64 v40; // [rsp+70h] [rbp-9h] BYREF
  __int64 v41; // [rsp+78h] [rbp-1h]
  __int64 v42; // [rsp+C8h] [rbp+4Fh] BYREF
  int v43; // [rsp+D0h] [rbp+57h]
  _QWORD *v44; // [rsp+D8h] [rbp+5Fh]

  if ( a2 < 0 )
    return;
  v44 = a3;
  v5 = a2;
  v43 = 0;
  v41 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 0x72E0LL);
  if ( a2 >= *(_DWORD *)(v41 + 0x528) )
    return;
  if ( a4 )
  {
    v9 = (__int64 *)*a3;
    v38 = v9;
    if ( v9 )
      (*(void (__fastcall **)(__int64 *))*v9)(v9);
    sub_146E44B20((float *)(a1 + 0x18), v5, &v38, a4, a5);
  }
  else
  {
    sub_146E4C0B0(a1 + 0x18, (unsigned int)a2, 7);
  }
  v10 = (volatile signed __int32 *)(a1 + 0xAE8);
  v11 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(a1 + 0xAF8) == v11 )
  {
    ++*(_DWORD *)(a1 + 0xAFC);
  }
  else
  {
    v12 = _InterlockedCompareExchange(v10, 1, 0);
    if ( v12 )
      sub_1403C33A0(a1 + 0xAE8, v12, "CSkeletonPose::SetStatObjOnJoint", 1);
    else
      *(_QWORD *)(a1 + 0xAF0) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    *(_DWORD *)(a1 + 0xAF8) = v11;
  }
  v13 = *(_QWORD *)(a1 + 0xB00) + 0x88 * v5;
  if ( *(_BYTE *)(v13 + 0x18) )
  {
    (*(void (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)(v13 + 0x10) + 0x130LL))(*(_QWORD *)(v13 + 0x10), &v35);
  }
  else
  {
    v14 = *(_QWORD *)(v13 + 8);
    if ( !v14 )
    {
      v35 = 0;
      goto LABEL_26;
    }
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v14 + 0x88LL))(v14, &v35);
  }
  if ( !v35 )
  {
LABEL_26:
    if ( *a3 )
    {
      v18 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*a3 + 0x228LL))(*a3, &v37);
      n0xA = 0xA;
      v19 = *v18;
    }
    else
    {
      v18 = &v40;
      v19 = 0;
      n0xA = 0xC;
    }
    v36 = v19;
    v15 = &v36;
    *v18 = 0;
    goto LABEL_30;
  }
  if ( *(_BYTE *)(v13 + 0x18) )
  {
    (*(void (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)(v13 + 0x10) + 0x130LL))(*(_QWORD *)(v13 + 0x10), &v42);
    v15 = &v42;
    n0xA = 1;
  }
  else
  {
    v17 = *(_QWORD *)(v13 + 8);
    if ( v17 )
    {
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v17 + 0x88LL))(v17, &v42);
      v15 = &v42;
    }
    else
    {
      v15 = &v42;
      v42 = 0;
    }
    n0xA = 1;
  }
LABEL_30:
  v20 = *(_QWORD *)(v13 + 8);
  if ( v20 && *(_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 0x80LL))(v20) )
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(v13 + 8) + 0x48LL))(*(_QWORD *)(v13 + 8));
  v21 = *(__int64 **)(v13 + 0x10);
  if ( v21 )
  {
    v22 = *v21;
    if ( *(_BYTE *)(v13 + 0x25) )
    {
      (*(void (__fastcall **)(__int64 *, _QWORD *))(v22 + 0x1F8))(v21, v44);
      (*(void (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)(v13 + 0x10) + 0x128LL))(*(_QWORD *)(v13 + 0x10), v15);
    }
    else
    {
      (*(void (__fastcall **)(__int64 *, __int64))(v22 + 0x120))(v21, 1);
      *(_QWORD *)(v13 + 0x10) = 0;
    }
  }
  if ( *(_BYTE *)(v13 + 0x18) || !*v44 )
  {
    v25 = v44;
  }
  else
  {
    if ( !*(_QWORD *)(v13 + 8) )
    {
      v23 = (_QWORD *)(*(__int64 (__fastcall **)(_LocaleUpdate *, __int64 *))(*(_QWORD *)pRenderer + 0x508LL))(
                        pRenderer,
                        &v39);
      sub_1403785B0((_QWORD *)(v13 + 8), v23);
      if ( v39 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v39 + 0x10LL))(v39);
      (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(v13 + 8) + 0x28LL))(*(_QWORD *)(v13 + 8), v13);
    }
    v24 = *v15;
    v25 = v44;
    (*(void (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(v13 + 8) + 0x18LL))(*(_QWORD *)(v13 + 8), *v44, v24);
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v13 + 8) + 0x58LL))(
      *(_QWORD *)(v13 + 8),
      *(unsigned __int8 *)(v13 + 0x24));
  }
  if ( (n0xA & 8) != 0 )
  {
    n0xA &= ~8u;
    if ( v36 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v36 + 0x10LL))(v36);
    v36 = 0;
  }
  if ( (n0xA & 4) != 0 )
  {
    n0xA &= ~4u;
    if ( v40 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 0x10LL))(v40);
  }
  if ( (n0xA & 2) != 0 )
  {
    if ( v37 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v37 + 0x10LL))(v37);
    v37 = 0;
  }
  if ( (n0xA & 1) != 0 )
  {
    if ( v42 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v42 + 0x10LL))(v42);
    v42 = 0;
  }
  if ( v35 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 0x10LL))(v35);
  sub_146F791B0(a1, (unsigned int)v5);
  sub_146F79550(a1, (unsigned int)v5, v25);
  sub_146F75590(a1, 0);
  sub_14696E540((__int64 *)(a1 + 0x910));
  if ( *v25 )
  {
    if ( *(_QWORD *)(a1 + 0x2BA8) )
    {
      if ( !*(_BYTE *)(v13 + 0x18) )
      {
        if ( *(_QWORD *)(v13 + 8) )
        {
          v26 = *(_QWORD *)(v41 + 0x4E0);
          if ( (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v25 + 0x118LL))(*v25) == v26 )
          {
            v27 = *(_BYTE *)(v13 + 0x24);
            if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(*(_QWORD *)*v25 + 0x410LL))(*v25) )
            {
              v28 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v25 + 0x118LL))(*v25);
              v29 = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v28 + 0x3F8LL);
              v30 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v25 + 0x3D0LL))(*v25);
              v31 = v29(v28, v30);
              if ( v31 )
              {
                v32 = *(_BYTE *)(v31 + 0xBC);
                v27 = (v32 & 2) == 0 && (v32 & 4) != 0;
              }
            }
            sub_146F81FE0(a1, (unsigned int)v5, v27);
          }
        }
      }
    }
  }
  v33 = *(_DWORD *)(a1 + 0xAFC);
  if ( v33 )
  {
    *(_DWORD *)(a1 + 0xAFC) = v33 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xAF8) = 0xFFFFFFFF;
    v34 = _InterlockedCompareExchange(v10, 0, 1);
    if ( v34 == 1 )
      *(_QWORD *)(a1 + 0xAF0) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0(a1 + 0xAE8, v34);
  }
}

// --- End Function: sub_146F82930 (0x146F82930) ---

// --- Function: sub_146F831C0 (0x146F831C0) ---
__int64 __fastcall sub_146F831C0(__int64 a1, unsigned __int8 a2)
{
  __int64 v4; // rcx
  __int64 result; // rax
  __int64 v6; // rcx

  if ( *(_BYTE *)(a1 + 0x18) )
  {
    v4 = *(_QWORD *)(a1 + 0x10);
    if ( v4 )
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 0x98LL))(v4, a2 ^ 1u);
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8);
    if ( v6 )
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 0x58LL))(v6);
    *(_BYTE *)(a1 + 0x24) = a2;
  }
  return result;
}

// --- End Function: sub_146F831C0 (0x146F831C0) ---

// --- Function: sub_146F83220 (0x146F83220) ---
__int64 __fastcall sub_146F83220(__int64 a1, int a2, __int64 a3)
{
  unsigned __int64 v4; // r14
  volatile signed __int32 *v6; // rbx
  int v7; // ebp
  unsigned __int32 v8; // eax
  __int64 v9; // r8
  unsigned __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rdx
  char v14; // al
  unsigned __int8 v15; // si
  __int64 v16; // rcx
  int v17; // ecx
  unsigned __int32 v18; // eax

  v4 = a2;
  v6 = (volatile signed __int32 *)(a1 + 0xAE8);
  v7 = *(_DWORD *)(get_thread_context_ptr() + 0x18);
  if ( *(_DWORD *)(a1 + 0xAF8) == v7 )
  {
    ++*(_DWORD *)(a1 + 0xAFC);
  }
  else
  {
    v8 = _InterlockedCompareExchange(v6, 1, 0);
    if ( v8 )
      sub_1403C33A0((__int64)v6, v8, "CSkeletonPose::SetVisualStateOnJoint", 1);
    else
      *(_QWORD *)(a1 + 0xAF0) = *(_QWORD *)(get_thread_context_ptr() + 0x20);
    *(_DWORD *)(a1 + 0xAF8) = v7;
  }
  if ( (v4 & 0x80000000) != 0LL )
    goto LABEL_14;
  v9 = *(_QWORD *)(a1 + 0xB00);
  v10 = (*(_QWORD *)(a1 + 0xB08) - v9) / 0x88;
  if ( v4 >= v10 )
    goto LABEL_14;
  v11 = 0x88 * v4;
  if ( *(_BYTE *)(0x88 * v4 + v9 + 0x18) )
  {
    v12 = *(_QWORD *)(v11 + v9 + 0x10);
    if ( v12 )
    {
      v13 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64, unsigned __int64))(*(_QWORD *)v12 + 0x208LL))(
              v12,
              v10,
              v9,
              v4);
      *(_BYTE *)v13 = *(_BYTE *)a3;
      *(_BYTE *)(v13 + 1) = *(_BYTE *)(a3 + 1);
      *(_BYTE *)(v13 + 2) = *(_BYTE *)(a3 + 2);
      *(_BYTE *)(v13 + 3) = *(_BYTE *)(a3 + 3);
      *(_BYTE *)(v13 + 4) = *(_BYTE *)(a3 + 4);
      *(_BYTE *)(v13 + 5) = *(_BYTE *)(a3 + 5);
      *(_BYTE *)(v13 + 6) = *(_BYTE *)(a3 + 6);
      *(_BYTE *)(v13 + 7) = *(_BYTE *)(a3 + 7);
      *(_BYTE *)(v13 + 8) = *(_BYTE *)(a3 + 8);
      *(_DWORD *)(v13 + 9) = *(_DWORD *)(a3 + 9);
      *(_DWORD *)(v13 + 0xD) = *(_DWORD *)(a3 + 0xD);
      v14 = *(_BYTE *)(a3 + 0x11);
      v15 = 1;
      *(_BYTE *)(v13 + 0x11) = v14;
      goto LABEL_15;
    }
  }
  v16 = *(_QWORD *)(v11 + v9 + 8);
  if ( v16 )
  {
    (*(void (__fastcall **)(__int64, __int64, __int64, unsigned __int64))(*(_QWORD *)v16 + 0x60LL))(v16, a3, v9, v4);
    v15 = 1;
  }
  else
  {
LABEL_14:
    v15 = 0;
  }
LABEL_15:
  v17 = *(_DWORD *)(a1 + 0xAFC);
  if ( v17 )
  {
    *(_DWORD *)(a1 + 0xAFC) = v17 - 1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xAF8) = 0xFFFFFFFF;
    v18 = _InterlockedCompareExchange(v6, 0, 1);
    if ( v18 == 1 )
      *(_QWORD *)(a1 + 0xAF0) = &p_p_p_p_p_p_p_p_p_p_p_Source;
    else
      sub_1403DB1F0((__int64)v6, v18);
  }
  return v15;
}

// --- End Function: sub_146F83220 (0x146F83220) ---

// --- Function: sub_146F8F5F0 (0x146F8F5F0) ---
__int64 __fastcall sub_146F8F5F0(const vraudio::AudioBuffer ***a1, __int64 a2, const vraudio::AudioBuffer **__Val_0_)
{
  const vraudio::AudioBuffer **_Whereptr_2; // r11
  const vraudio::AudioBuffer **_Whereptr; // rax
  unsigned __int64 v7; // r9
  char v8; // dl
  const vraudio::AudioBuffer *v9; // r9
  __int64 result; // rax
  const vraudio::AudioBuffer **_Whereptr_1; // rcx
  int v12; // edx
  _DWORD *_Whereptr_3; // r8

  _Whereptr_2 = a1[1];
  _Whereptr = *a1;
  v7 = _Whereptr_2 - *a1;
  while ( v7 )
  {
    if ( SLODWORD(_Whereptr[v7 >> 1]) >= *(_DWORD *)__Val_0_ )
    {
      v7 >>= 1;
    }
    else
    {
      _Whereptr += (v7 >> 1) + 1;
      v7 += 0xFFFFFFFFFFFFFFFFuLL - (v7 >> 1);
    }
  }
  v8 = 0;
  if ( _Whereptr != _Whereptr_2 && *(_DWORD *)__Val_0_ >= *(_DWORD *)_Whereptr )
    goto LABEL_15;
  if ( _Whereptr_2 == a1[2] )
  {
    _Whereptr = sub_1402A6760((std::vector<vraudio::AudioBuffer const *> *)a1, _Whereptr, __Val_0_);
    v8 = 1;
LABEL_15:
    *(_QWORD *)a2 = _Whereptr;
    result = a2;
    *(_BYTE *)(a2 + 8) = v8;
    return result;
  }
  v9 = *__Val_0_;
  if ( _Whereptr == _Whereptr_2 )
  {
    *_Whereptr_2 = v9;
    ++a1[1];
    *(_QWORD *)a2 = _Whereptr;
    result = a2;
    *(_BYTE *)(a2 + 8) = 1;
  }
  else
  {
    _Whereptr_1 = _Whereptr_2 + 0xFFFFFFFF;
    *_Whereptr_2 = _Whereptr_2[0xFFFFFFFF];
    ++a1[1];
    if ( _Whereptr_2 + 0xFFFFFFFF != _Whereptr )
    {
      do
      {
        v12 = *((_DWORD *)_Whereptr_1 + 0xFFFFFFFE);
        _Whereptr_3 = _Whereptr_1;
        _Whereptr_1 += 0xFFFFFFFF;
        *_Whereptr_3 = v12;
        *((_BYTE *)_Whereptr_1 + 0xC) = *((_BYTE *)_Whereptr_1 + 4);
      }
      while ( _Whereptr_1 != _Whereptr );
    }
    *((_BYTE *)_Whereptr + 4) = BYTE4(v9);
    *(_DWORD *)_Whereptr = (_DWORD)v9;
    *(_QWORD *)a2 = _Whereptr;
    result = a2;
    *(_BYTE *)(a2 + 8) = 1;
  }
  return result;
}

// --- End Function: sub_146F8F5F0 (0x146F8F5F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( gEnv && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: allocWithProfilerInfo (0x147605A30) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char v4; // al
  __int64 v5; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    v4 = sub_1474DA7B0();
    sub_14056A7D0(v4);
    v5 = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1476030D0(v5 + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
      return result;
    sub_1476052F0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x147605A30) ---

// --- Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}

// --- End Function: ?_Xlength_error@std@@YAXPEBD@Z (0x14803278E) ---

// --- Function: atexit (0x1480335F8) ---
int __cdecl atexit(void (__cdecl *Func)())
{
  return (onexit((_onexit_t)Func) != 0) - 1;
}

// --- End Function: atexit (0x1480335F8) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit += 0xFFFFF000;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 rotatedCookie; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  rotatedCookie = __ROL8__(StackCookie, 0x10);
  if ( (_WORD)rotatedCookie )
  {
    StackCookie = __ROR8__(rotatedCookie, 0x10);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = 0xC0000409;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: memmove (0x148082131) ---
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}

// --- End Function: memmove (0x148082131) ---

// --- Function: memset (0x148082137) ---
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}

// --- End Function: memset (0x148082137) ---

// --- Function: memcmp (0x148082155) ---
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}

// --- End Function: memcmp (0x148082155) ---

// --- Function: sub_148172620 (0x148172620) ---
void __fastcall sub_148172620()
{
  if ( qword_1515BC4D0 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_1515BC4D0 + 8LL))(qword_1515BC4D0);
  qword_1515BC4D0 = 0;
}

// --- End Function: sub_148172620 (0x148172620) ---

