// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146B45A50 (CEntityClassRegistry::FindClass)
// Caller Depth: 1
// Callee/Ref Depth: 5
// Total Functions Found: 26
// ------------------------------------------------------------

// --- Function: sub_1402A4380 (0x1402A4380) ---
void *sub_1402A4380()
{
  return &unk_149B3AA80;
}

// --- End Function: sub_1402A4380 (0x1402A4380) ---

// --- Function: NtCurrentTeb_w (0x1402C6400) ---
__int64 NtCurrentTeb_w()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: NtCurrentTeb_w (0x1402C6400) ---

// --- Function: sub_1402D2790 (0x1402D2790) ---
unsigned __int64 __fastcall sub_1402D2790(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = NtCurrentTeb_w();
  if ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(result + 24) && (result = *(unsigned int *)(a1 + 20), (_DWORD)result) )
  {
    result = (unsigned int)(result - 1);
    *(_DWORD *)(a1 + 20) = result;
  }
  else
  {
    v3 = _InterlockedDecrement64((volatile signed __int64 *)a1);
    if ( (v3 & 0x3FF) == 0 )
    {
      result = 0xFFFF0000FFC00000uLL;
      if ( (v3 & 0xFFFF0000FFC00000uLL) != 0 )
        return sub_1403CB820((volatile signed __int64 *)a1, v3);
    }
  }
  return result;
}

// --- End Function: sub_1402D2790 (0x1402D2790) ---

// --- Function: sub_14035B120 (0x14035B120) ---
_QWORD *__fastcall sub_14035B120(_QWORD *a1, _QWORD *a2)
{
  *a1 = (char *)&qword_149B3B33C + 4;
  *a1 = *a2;
  return a1;
}

// --- End Function: sub_14035B120 (0x14035B120) ---

// --- Function: sub_140370D10 (0x140370D10) ---
void __fastcall sub_140370D10(_QWORD *a1)
{
  int *v1; // rcx

  v1 = (int *)(*a1 - 8LL);
  if ( v1[1] > 0 )
    sub_147605980(v1);
}

// --- End Function: sub_140370D10 (0x140370D10) ---

// --- Function: sub_14039B170 (0x14039B170) ---
FARPROC __fastcall sub_14039B170(LPCSTR lpLibFileName, LPCSTR lpProcName, char a3)
{
  HMODULE hModule; // rax
  FARPROC v7; // rbx
  FARPROC result; // rax
  HMODULE hModule_1; // rax

  hModule = GetModuleHandleA(0);
  if ( a3 )
  {
    v7 = 0;
  }
  else
  {
    result = GetProcAddress(hModule, lpProcName);
    v7 = result;
    if ( result )
      return result;
  }
  hModule_1 = LoadLibraryA(lpLibFileName);
  if ( hModule_1 )
    return GetProcAddress(hModule_1, lpProcName);
  else
    return v7;
}

// --- End Function: sub_14039B170 (0x14039B170) ---

// --- Function: sub_1403CB300 (0x1403CB300) ---
double __fastcall sub_1403CB300(__int64 a1, signed __int64 a2, const char *a3, const char *a4, char a5)
{
  if ( a5 && *(_BYTE *)(NtCurrentTeb_w() + 28) && qword_149B4FDB8 )
    return sub_1403CB380(a1, a2, a3, a4);
  else
    return sub_1403CB5B0(a1, a2, a3, a4);
}

// --- End Function: sub_1403CB300 (0x1403CB300) ---

// --- Function: sub_1403CB380 (0x1403CB380) ---
double __fastcall sub_1403CB380(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  __int64 v4; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned int v11; // r15d
  unsigned __int64 v12; // rdx
  bool v13; // zf
  signed __int64 v14; // rax
  __int16 v15; // ax
  signed __int64 v16; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  _BYTE v19[16]; // [rsp+30h] [rbp-29h] BYREF
  int n5632; // [rsp+40h] [rbp-19h] BYREF
  __int64 v21; // [rsp+44h] [rbp-15h]
  int n2; // [rsp+4Ch] [rbp-Dh]
  unsigned __int64 v23; // [rsp+50h] [rbp-9h]
  unsigned __int64 v24; // [rsp+58h] [rbp-1h]
  __int64 v25; // [rsp+60h] [rbp+7h]
  __int64 v26; // [rsp+68h] [rbp+Fh]
  char v27; // [rsp+C8h] [rbp+6Fh] BYREF

  v4 = qword_149B4FCF8;
  v9 = NtCurrentTeb_w();
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(*(_QWORD *)v9 + 284LL);
  (*(void (__fastcall **)(__int64, _BYTE *, char *))(*(_QWORD *)v4 + 248LL))(v4, v19, &v27);
  if ( (a2 & 0x200000) == 0 )
    return result;
  v12 = (unsigned __int64)v11 << 32;
  while ( (a2 & 0xFFFF00000000LL) != 0 )
  {
    *(_DWORD *)(v10 + 292) = WORD2(a2);
    v14 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12 | a2 & 0xFFFF0000FFFFFFFFuLL, a2);
    v13 = a2 == v14;
    a2 = v14;
    if ( v13 )
    {
      n5632 = 5632;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v21 = 1;
      n2 = 2;
      v23 = __rdtsc();
      qword_149B4B870(
        &n5632,
        &word_149B3E384,
        "Wait For RLock",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
        146);
      v15 = word_149B3E384;
      goto LABEL_10;
    }
LABEL_7:
    if ( (a2 & 0x200000) == 0 )
      return result;
  }
  *(_DWORD *)(v10 + 292) = -1;
  v16 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, a2 | v12, a2);
  v13 = a2 == v16;
  a2 = v16;
  if ( !v13 )
    goto LABEL_7;
  n5632 = 5632;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v21 = 1;
  n2 = 2;
  v23 = __rdtsc();
  qword_149B4B870(
    &n5632,
    &word_149B3E388,
    "Wait For RLock",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
    177);
  v15 = word_149B3E388;
LABEL_10:
  HIWORD(n5632) = v15;
  qword_149B4B8B0("Lock: %s", a4);
  p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
  if ( *(_QWORD *)(a1 + 8) )
    p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
  qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
  qword_149B4B8B0("Caller: %s", a3);
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 232LL))(v4, v11);
  v24 = __rdtsc();
  return qword_149B4B878(&n5632);
}

// --- End Function: sub_1403CB380 (0x1403CB380) ---

// --- Function: sub_1403CB5B0 (0x1403CB5B0) ---
double __fastcall sub_1403CB5B0(__int64 a1, signed __int64 a2, const char *a3, const char *a4)
{
  signed __int64 v6; // rbx
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source_1; // rdx
  int *p_n5632; // rcx
  int v10; // edi
  bool v11; // zf
  signed __int64 v12; // rax
  const ULONG_PTR *p_p_p_p_p_p_p_p_p_p_p_p_Source; // rdx
  double result; // xmm0_8
  int v15; // [rsp+30h] [rbp-69h] BYREF
  _DWORD v16[3]; // [rsp+34h] [rbp-65h] BYREF
  int n5632_1; // [rsp+40h] [rbp-59h] BYREF
  __int64 v18; // [rsp+44h] [rbp-55h]
  int n2_1; // [rsp+4Ch] [rbp-4Dh]
  unsigned __int64 v20; // [rsp+50h] [rbp-49h]
  unsigned __int64 v21; // [rsp+58h] [rbp-41h]
  __int64 v22; // [rsp+60h] [rbp-39h]
  __int64 v23; // [rsp+68h] [rbp-31h]
  int n5632; // [rsp+90h] [rbp-9h] BYREF
  __int64 v25; // [rsp+94h] [rbp-5h]
  int n2; // [rsp+9Ch] [rbp+3h]
  unsigned __int64 v27; // [rsp+A0h] [rbp+7h]
  unsigned __int64 v28; // [rsp+A8h] [rbp+Fh]
  __int64 v29; // [rsp+B0h] [rbp+17h]
  __int64 v30; // [rsp+B8h] [rbp+1Fh]

  if ( (a2 & 0x200000) != 0 )
  {
    v6 = a2;
    while ( 1 )
    {
      if ( (v6 & 0xFFC00) != 0 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_149B4FCF8 + 296LL))(qword_149B4FCF8, a1);
      if ( (v6 & 0x100000) != 0 )
        break;
      v10 = v6 | 0x100000;
      v12 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v6 | 0x100000, v6);
      v11 = v6 == v12;
      v6 = v12;
      if ( v11 )
      {
        n5632 = 5632;
        v25 = 1;
        n2 = 2;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v27 = __rdtsc();
        qword_149B4B870(
          &n5632,
          &word_149B3E380,
          "Wait For RLock",
          "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
          98);
        HIWORD(n5632) = word_149B3E380;
        qword_149B4B8B0("Lock: %s", a4);
        p_p_p_p_p_p_p_p_p_p_p_p_Source = &p_p_p_p_p_p_p_p_p_p_p_Source;
        if ( *(_QWORD *)(a1 + 8) )
          p_p_p_p_p_p_p_p_p_p_p_p_Source = *(const ULONG_PTR **)(a1 + 8);
        qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source);
        qword_149B4B8B0("Caller: %s", a3);
        v16[0] = v10;
        qword_149B3B480(a1, v16, 4, 0xFFFFFFFFLL);
        v6 = *(_QWORD *)a1;
        p_n5632 = &n5632;
        v28 = __rdtsc();
        goto LABEL_13;
      }
LABEL_14:
      if ( (v6 & 0x200000) == 0 )
        return result;
    }
    n5632_1 = 5632;
    v18 = 1;
    n2_1 = 2;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v20 = __rdtsc();
    qword_149B4B870(
      &n5632_1,
      &word_149B3E37C,
      "Wait For RLock",
      "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Multithreading/CigRWLock.cpp",
      74);
    HIWORD(n5632_1) = word_149B3E37C;
    qword_149B4B8B0("Lock: %s", a4);
    p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = &p_p_p_p_p_p_p_p_p_p_p_Source;
    if ( *(_QWORD *)(a1 + 8) )
      p_p_p_p_p_p_p_p_p_p_p_p_Source_1 = *(const ULONG_PTR **)(a1 + 8);
    qword_149B4B8B0("LockOwner: %s", p_p_p_p_p_p_p_p_p_p_p_p_Source_1);
    qword_149B4B8B0("Caller: %s", a3);
    v15 = v6;
    qword_149B3B480(a1, &v15, 4, 0xFFFFFFFFLL);
    v6 = *(_QWORD *)a1;
    p_n5632 = &n5632_1;
    v21 = __rdtsc();
LABEL_13:
    result = qword_149B4B878(p_n5632);
    goto LABEL_14;
  }
  return result;
}

// --- End Function: sub_1403CB5B0 (0x1403CB5B0) ---

// --- Function: sub_1403CB820 (0x1403CB820) ---
unsigned __int64 __fastcall sub_1403CB820(volatile signed __int64 *a1, unsigned __int64 a2)
{
  signed __int64 v4; // rdx
  unsigned int v5; // r8d
  unsigned __int64 result; // rax
  unsigned __int64 v7; // rbx
  int v8; // [rsp+60h] [rbp+8h] BYREF
  int v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF
  __int64 v11; // [rsp+78h] [rbp+20h] BYREF

  while ( 1 )
  {
    v4 = a2;
    if ( (a2 & 0xFFC00000) == 0 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(
        qword_149B4FCF8,
        &v10,
        &v8);
      v4 = a2 & 0xFFFFFFFFFFFFLL;
      v5 = *(_DWORD *)(((HIWORD(a2) & (unsigned int)(v8 - 1)) << 9) + v10 + 292);
      if ( v5 != -1 )
        v4 |= (unsigned __int64)v5 << 48;
    }
    result = _InterlockedCompareExchange64(a1, v4, a2);
    if ( a2 == result )
      break;
    if ( (result & 0x3FF) != 0 || (result & 0x200000) != 0 || (result & 0xFFFF0000FFC00000uLL) == 0 )
      return result;
    a2 = result;
  }
  if ( (a2 & 0xFFC00000) != 0 )
    return qword_149B3B488(a1);
  result = 0xFFFF000000000000uLL;
  if ( (a2 & 0xFFFF000000000000uLL) != 0 )
  {
    (*(void (__fastcall **)(__int64, __int64 *, int *))(*(_QWORD *)qword_149B4FCF8 + 248LL))(qword_149B4FCF8, &v11, &v9);
    v7 = HIWORD(a2);
    *(_DWORD *)(((unsigned __int64)((unsigned int)v7 & (v9 - 1)) << 9) + v11 + 284) = (unsigned __int16)(v7 + v9);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)qword_149B4FCF8 + 216LL))(
             qword_149B4FCF8,
             (unsigned int)v7);
  }
  return result;
}

// --- End Function: sub_1403CB820 (0x1403CB820) ---

// --- Function: sub_1403E4780 (0x1403E4780) ---
__int64 __fastcall sub_1403E4780(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  unsigned __int8 v4; // cl

  v2 = *a1;
  v3 = *a2 - (_QWORD)*a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0;
  }
  return v4 < v2[v3] ? 0xFFFFFFFF : 1;
}

// --- End Function: sub_1403E4780 (0x1403E4780) ---

// --- Function: LogFatalError (0x1405C0CD0) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *Format, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int n0x1000; // eax
  char Buffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list va; // [rsp+1058h] [rbp+10h] BYREF

  va_start(va, Format);
  v1 = (__int64 (*)(void))qword_149B4FB98;
  if ( !qword_149B4FB98 )
  {
    v2 = sub_14039B170(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_149B4FB98);
    v1 = (__int64 (*)(void))qword_149B4FB98;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_149B4FDB8 || !qword_149B4FCA0 )
    {
      __debugbreak();
      while ( 1 )
        ;
    }
    v4 = sub_1402A4380();
    n0x1000 = _stdio_common_vsprintf(*v4 | 2LL, Buffer, 0x1000u, Format, 0, va);
    if ( n0x1000 < 0 )
      n0x1000 = -1;
    if ( (unsigned int)n0x1000 >= 0x1000 )
      Buffer[4095] = 0;
    return (_BYTE *)(*(__int64 (__fastcall **)(__int64, const wchar_t *, char *))(*(_QWORD *)qword_149B4FCA0 + 280LL))(
                      qword_149B4FCA0,
                      &Format_,
                      Buffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405C0CD0) ---

// --- Function: CEntityClassRegistry::FindClass (0x146B45A50) ---
__int64 __fastcall CEntityClassRegistry::FindClass(__int64 a1, __int64 a2)
{
  signed __int64 v4; // rdx
  __int64 *v5; // rdi
  unsigned __int8 **v6; // rbx
  __int64 v7; // rbx
  __int64 v9; // [rsp+30h] [rbp-18h] BYREF
  unsigned __int8 *v10[2]; // [rsp+38h] [rbp-10h] BYREF

  if ( *(_DWORD *)(a1 + 0x28) == *(_DWORD *)(NtCurrentTeb_w() + 0x18) )
  {
    ++*(_DWORD *)(a1 + 0x2C);
  }
  else
  {
    v4 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 0x18));
    if ( (v4 & 0x200000) != 0 )
      sub_1403CB300(a1 + 0x18, v4, "CEntityClassRegistry::FindClass", "m_lock", 1);
  }
  v9 = a2;
  sub_14035B120(v10, &v9);
  v5 = *(__int64 **)(a1 + 0x30);
  v6 = (unsigned __int8 **)v5[1];
  while ( !*((_BYTE *)v6 + 0x19) )
  {
    if ( (int)sub_1403E4780(v6 + 4, v10) >= 0 )
    {
      v5 = (__int64 *)v6;
      v6 = (unsigned __int8 **)*v6;
    }
    else
    {
      v6 = (unsigned __int8 **)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 0x19) || (int)sub_1403E4780(v10, v5 + 4) < 0 )
    v5 = *(__int64 **)(a1 + 0x30);
  v10[0] = (unsigned __int8 *)&qword_149B3B33C + 4;
  sub_140370D10(v10);
  if ( v5 == *(__int64 **)(a1 + 0x30) )
    v7 = 0;
  else
    v7 = v5[5];
  sub_1402D2790(a1 + 0x18);
  return v7;
}

// --- End Function: CEntityClassRegistry::FindClass (0x146B45A50) ---

// --- Function: sub_146B5AF70 (0x146B5AF70) ---
__int64 __fastcall sub_146B5AF70(__int64 a1, _QWORD *a2, const void **a3)
{
  __int64 result; // rax
  int v6; // edi
  char *v7; // r15
  __int64 v8; // rsi
  char *v9; // rax
  char *v10; // rbx
  __int64 Class; // rbx
  __int64 v12; // [rsp+90h] [rbp-80h] BYREF
  __int64 v13; // [rsp+98h] [rbp-78h] BYREF
  __int64 v14; // [rsp+A0h] [rbp-70h] BYREF
  void *v15; // [rsp+A8h] [rbp-68h] BYREF
  __int64 v16; // [rsp+B0h] [rbp-60h] BYREF
  char v17; // [rsp+C0h] [rbp-50h] BYREF
  char v18; // [rsp+C4h] [rbp-4Ch] BYREF
  char v19; // [rsp+C8h] [rbp-48h] BYREF
  char v20; // [rsp+CCh] [rbp-44h] BYREF
  char v21; // [rsp+D0h] [rbp-40h] BYREF
  char v22; // [rsp+D4h] [rbp-3Ch] BYREF
  char v23; // [rsp+D8h] [rbp-38h] BYREF
  char v24; // [rsp+DCh] [rbp-34h] BYREF
  char v25; // [rsp+E0h] [rbp-30h] BYREF
  char v26; // [rsp+E4h] [rbp-2Ch] BYREF
  char v27; // [rsp+E8h] [rbp-28h] BYREF
  char v28; // [rsp+ECh] [rbp-24h] BYREF
  char v29; // [rsp+F0h] [rbp-20h] BYREF
  char v30; // [rsp+F4h] [rbp-1Ch] BYREF
  char v31; // [rsp+F8h] [rbp-18h] BYREF
  char v32; // [rsp+FCh] [rbp-14h] BYREF

  result = (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(*(_QWORD *)qword_149B4FCA0 + 0x3B0LL))(
             qword_149B4FCA0,
             &v14,
             *a2,
             0);
  if ( v14 )
  {
    v6 = 0;
    result = (*(__int64 (**)(void))(*(_QWORD *)v14 + 0x158LL))();
    if ( (int)result > 0 )
    {
      do
      {
        (*(void (__fastcall **)(__int64, __int64 *, _QWORD))(*(_QWORD *)v14 + 0x160LL))(v14, &v12, (unsigned int)v6);
        if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *))(*(_QWORD *)v12 + 0x48LL))(
               v12,
               "EntityPrototype") )
        {
          v7 = (char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v12 + 0x110LL))(v12, "Name");
          v8 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v12 + 0x110LL))(v12, "Class");
          v9 = (char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v12 + 0x110LL))(v12, "Id");
          v10 = v9;
          if ( *v9 == 0x7B )
            v10 = v9 + 1;
          if ( sscanf_s(
                 v10,
                 "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                 &v17,
                 &v18,
                 &v19,
                 &v20,
                 &v21,
                 &v22,
                 &v23,
                 &v24,
                 &v25,
                 &v26,
                 &v27,
                 &v28,
                 &v29,
                 &v30,
                 &v31,
                 &v32) == 0x10 )
            sub_1402BC380(&v16, v10);
          Class = CEntityClassRegistry::FindClass(a1, v8);
          if ( Class )
          {
            sub_14035B160(&v15, a3);
            sub_140384840(&v15, ".");
            sub_14035B160((void **)&v13, (const void **)&v15);
            sub_140384840((void **)&v13, v7);
            sub_140370D10(&v15);
            if ( CEntityClassRegistry::FindClass(a1, v13) )
              sub_146AABD10((__int64)"Trying to register entity archetype %s but an entity class already exists with this name");
            else
              sub_146B695D0(a1, Class, v13);
            sub_140370D10(&v13);
          }
          else
          {
            sub_146AABD10((__int64)"EntityArchetype %s references unknown entity class %s");
          }
        }
        if ( v12 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 0x28LL))(v12);
        ++v6;
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x158LL))(v14);
      }
      while ( v6 < (int)result );
    }
    if ( v14 )
      return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x28LL))(v14);
  }
  return result;
}

// --- End Function: sub_146B5AF70 (0x146B5AF70) ---

// --- Function: sub_146B696D0 (0x146B696D0) ---
char __fastcall sub_146B696D0(__int64 a1, _QWORD *a2)
{
  __int64 v5; // r15
  int v6; // ebx
  __int64 v7; // r8
  unsigned __int64 v8; // rax
  __m128i v9; // xmm0
  __int64 v10; // rsi
  unsigned __int64 v11; // r9
  __int64 v12; // rbx
  __m128i v13; // xmm6
  __int64 v14; // rax
  bool v15; // cf
  unsigned __int64 v16; // rcx
  bool v17; // cf
  __int64 inserted; // r14
  __int64 v19; // rax
  __int64 v20; // rax
  double v21; // xmm0_8
  int v22; // eax
  int v23; // esi
  __int64 v24; // rax
  char *v25; // rcx
  __int64 v26; // rdi
  const char *v27; // rbx
  __int64 v28; // rax
  __int64 v29; // rbx
  unsigned __int16 *v30; // rax
  int v31; // ebx
  __int64 *ThreadLogContextSlot; // rax
  __int64 v33; // rbx
  __int64 *v34; // rsi
  unsigned __int64 v35; // r11
  __int64 *v36; // r10
  unsigned __int64 v37; // r9
  __int64 v38; // rcx
  char v39; // di
  __int64 *v40; // rax
  unsigned __int64 v41; // r8
  bool v42; // cf
  unsigned __int64 v43; // rdx
  bool v44; // cf
  unsigned __int64 v45; // rbx
  __int64 v46; // r9
  bool v47; // cf
  bool v48; // cf
  __int64 v49; // rax
  __int64 v50; // rdi
  __int64 v51; // rcx
  __int64 v52; // rax
  __int64 v53; // rax
  int v54; // eax
  unsigned __int64 n0x200000_1; // rax
  _QWORD *v56; // rax
  _QWORD *v57; // rdi
  _QWORD *v58; // rbx
  __int64 v59; // r8
  _QWORD *v60; // rax
  const void *v61; // rbx
  unsigned __int64 v64; // rax
  unsigned __int64 n8_2; // r8
  unsigned __int64 v68; // rax
  unsigned __int64 n8_1; // rdx
  _WORD *v70; // r12
  _WORD *v71; // rdi
  __int64 v72; // rdx
  __int64 n8_3; // rcx
  const void *n8_4; // rax
  __int64 v75; // rbx
  __int64 v76; // rax
  __int64 v77; // r14
  int v78; // esi
  __int64 *ThreadLogContextSlot_1; // rax
  _QWORD **v80; // rcx
  _QWORD *v81; // rdx
  _QWORD *v82; // rbx
  int v83; // eax
  unsigned __int64 n0x200000; // rax
  __int128 v85; // [rsp+60h] [rbp-A0h]
  float v86; // [rsp+80h] [rbp-80h] BYREF
  const void *v87[2]; // [rsp+88h] [rbp-78h] BYREF
  const void *v88; // [rsp+98h] [rbp-68h] BYREF
  __int128 v89; // [rsp+A0h] [rbp-60h]
  __int64 n7; // [rsp+B0h] [rbp-50h]
  unsigned __int64 n8; // [rsp+B8h] [rbp-48h]
  char v92[8]; // [rsp+C0h] [rbp-40h] BYREF
  void *v93; // [rsp+C8h] [rbp-38h] BYREF
  __int64 v94; // [rsp+D0h] [rbp-30h]
  _QWORD v95[2]; // [rsp+D8h] [rbp-28h] BYREF
  const void *v96; // [rsp+E8h] [rbp-18h]
  _QWORD v97[2]; // [rsp+F0h] [rbp-10h] BYREF
  const void *v98; // [rsp+100h] [rbp+0h]
  _QWORD v99[2]; // [rsp+108h] [rbp+8h] BYREF
  const void *v100; // [rsp+118h] [rbp+18h]
  _QWORD v101[2]; // [rsp+120h] [rbp+20h] BYREF
  const void *v102; // [rsp+130h] [rbp+30h]
  int v103; // [rsp+138h] [rbp+38h] BYREF
  _QWORD *v104; // [rsp+140h] [rbp+40h]
  _QWORD v105[2]; // [rsp+148h] [rbp+48h] BYREF
  _QWORD v106[2]; // [rsp+158h] [rbp+58h] BYREF
  _QWORD v107[2]; // [rsp+168h] [rbp+68h] BYREF
  _QWORD v108[3]; // [rsp+178h] [rbp+78h] BYREF
  __int128 v109; // [rsp+190h] [rbp+90h] BYREF
  _BYTE v110[16]; // [rsp+1A0h] [rbp+A0h] BYREF
  __int128 v111; // [rsp+1B0h] [rbp+B0h] BYREF
  __int128 v112; // [rsp+1C0h] [rbp+C0h] BYREF
  __int128 v113; // [rsp+1D0h] [rbp+D0h] BYREF
  __int128 v114; // [rsp+1E0h] [rbp+E0h] BYREF
  __int128 v115; // [rsp+1F0h] [rbp+F0h] BYREF
  char v116[16]; // [rsp+200h] [rbp+100h] BYREF
  __m128i v117; // [rsp+210h] [rbp+110h] BYREF
  _DWORD v118[3]; // [rsp+220h] [rbp+120h] BYREF
  char v119; // [rsp+22Ch] [rbp+12Ch] BYREF
  _DWORD v120[3]; // [rsp+230h] [rbp+130h] BYREF
  char v121; // [rsp+23Ch] [rbp+13Ch] BYREF
  _DWORD v122[3]; // [rsp+240h] [rbp+140h] BYREF
  char v123; // [rsp+24Ch] [rbp+14Ch] BYREF
  _DWORD v124[3]; // [rsp+250h] [rbp+150h] BYREF
  char v125; // [rsp+25Ch] [rbp+15Ch] BYREF
  _BYTE v126[16]; // [rsp+260h] [rbp+160h] BYREF
  __m128i v127; // [rsp+270h] [rbp+170h]
  _QWORD *v128; // [rsp+280h] [rbp+180h]
  char v129[8]; // [rsp+290h] [rbp+190h] BYREF
  __int64 v130; // [rsp+298h] [rbp+198h]
  char *v131; // [rsp+2A0h] [rbp+1A0h]
  char v132; // [rsp+2A8h] [rbp+1A8h] BYREF
  char v133[8]; // [rsp+2D0h] [rbp+1D0h] BYREF
  __int64 v134; // [rsp+2D8h] [rbp+1D8h]
  char *v135; // [rsp+2E0h] [rbp+1E0h]
  char v136; // [rsp+2E8h] [rbp+1E8h] BYREF
  char v137[8]; // [rsp+310h] [rbp+210h] BYREF
  __int64 v138; // [rsp+318h] [rbp+218h]
  char *v139; // [rsp+320h] [rbp+220h]
  char v140; // [rsp+328h] [rbp+228h] BYREF
  char v141[8]; // [rsp+350h] [rbp+250h] BYREF
  __int64 v142; // [rsp+358h] [rbp+258h]
  char *v143; // [rsp+360h] [rbp+260h]
  char v144; // [rsp+368h] [rbp+268h] BYREF

  v94 = a1;
  if ( CEntityClassRegistry::FindClass(a1, a2[2]) )
  {
    sub_146AABD10((__int64)"CEntityClassRegistry::RegisterClass failed, class with name %s already registered");
    return 0;
  }
  if ( *(_BYTE *)(a1 + 0x130) && !(_BYTE)qword_149B501D6 )
    LogFatalError(
      "CEntityClassRegistry::RegisterClass failed, not allowed to register classes after CEntityClassRegistry::LockClasse"
      "s has been called");
  v5 = a1 + 0x18;
  v6 = *(_DWORD *)(NtCurrentTeb_w() + 0x18);
  if ( *(_DWORD *)(a1 + 0x28) == v6 )
  {
    ++*(_DWORD *)(a1 + 0x2C);
  }
  else
  {
    v7 = *(_QWORD *)(NtCurrentTeb_w() + 0x20);
    v8 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0x200000, 0);
    if ( v8 )
      sub_1403DCD60(a1 + 0x18, v8, v7, "CEntityClassRegistry::RegisterClass", "m_lock", 1);
    else
      *(_QWORD *)(a1 + 0x20) = v7;
    *(_DWORD *)(a1 + 0x28) = v6;
  }
  CreateStringObjectFromString(&v93, (const char *)a2[2]);
  *(_QWORD *)sub_141E553D0(a1 + 0x30, &v93) = a2;
  sub_140370D10(&v93);
  v9 = *(__m128i *)(a2 + 0xF);
  v117 = v9;
  if ( v9.m128i_i64[0] || _mm_extract_epi64(v9, 1) )
  {
    v10 = *(_QWORD *)(a1 + 0x50);
    v11 = a2[0x10];
    v12 = v10;
    v13 = v9;
    v127 = v9;
    v14 = *(_QWORD *)(v10 + 8);
    v128 = a2;
    *(_QWORD *)&v85 = v14;
    DWORD2(v85) = 0;
    while ( !*(_BYTE *)(v14 + 0x19) )
    {
      *(_QWORD *)&v85 = v14;
      v15 = *(_QWORD *)(v14 + 0x20) < v9.m128i_i64[0];
      if ( *(_QWORD *)(v14 + 0x20) == v9.m128i_i64[0] )
        v15 = *(_QWORD *)(v14 + 0x28) < v11;
      if ( v15 )
      {
        v14 = *(_QWORD *)(v14 + 0x10);
        DWORD2(v85) = 0;
      }
      else
      {
        v12 = v14;
        DWORD2(v85) = 1;
        v14 = *(_QWORD *)v14;
      }
    }
    if ( *(_BYTE *)(v12 + 0x19) )
      goto LABEL_28;
    v16 = *(_QWORD *)(v12 + 0x20);
    v17 = v9.m128i_i64[0] < v16;
    if ( v9.m128i_i64[0] == v16 )
      v17 = v11 < *(_QWORD *)(v12 + 0x28);
    if ( v17 )
    {
LABEL_28:
      if ( *(_QWORD *)(a1 + 0x58) == 0x492492492492492LL )
        unknown_libname_7();
      v20 = allocWithProfilerInfo_w(0x38u);
      v21 = *(double *)&v128;
      *(__m128i *)(v20 + 0x20) = v13;
      *(double *)(v20 + 0x30) = v21;
      *(_QWORD *)v20 = v10;
      *(_QWORD *)(v20 + 8) = v10;
      *(_QWORD *)(v20 + 0x10) = v10;
      *(_WORD *)(v20 + 0x18) = 0;
      v109 = v85;
      inserted = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
                   (__int64 **)(a1 + 0x50),
                   (__int64)&v109,
                   v20);
    }
    else
    {
      inserted = v12;
      if ( !(_BYTE)qword_149B501D6 )
      {
        v19 = sub_1402C4680((__int64)v129, (__int64)&v117);
        LogFatalError(
          "Class GUID collision, existing class %s and new class %s have same guid %s",
          *(const char **)(*(_QWORD *)(v12 + 0x30) + 0x10LL),
          (const char *)a2[2],
          *(const char **)(v19 + 0x10));
        if ( v131 != &v132 )
        {
          qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - v130;
          sub_147605980(v131);
        }
      }
    }
    (*(void (__fastcall **)(_QWORD *, _BYTE *, _QWORD, unsigned __int64))(*a2 + 0x10LL))(a2, v126, *a2, v11);
    v22 = psub_1403360E0(0xFFFFFFFF, (__int64)v126, 0x10);
    v23 = ~v22;
    if ( v22 == 0xFFFFFFFF )
    {
      if ( (_BYTE)qword_149B501D6 != (_BYTE)v23 )
        goto LABEL_41;
      v24 = sub_1402C4680((__int64)v133, (__int64)&v117);
      LogFatalError(
        "Class GUID CRC matches INVALID_CLASS_CRC (Name=\"%s\" GUID=%s CRC=%u)",
        (const char *)a2[2],
        *(const char **)(v24 + 0x10),
        0);
      v25 = v135;
      if ( v135 == &v136 )
        goto LABEL_41;
      v26 = 0xFFFFFFFFFFFFFFFFuLL - v134;
    }
    else
    {
      v103 = ~v22;
      v104 = a2;
      sub_140C61830(a1 + 0x60, v110, &v103);
      if ( v110[8] || (_BYTE)qword_149B501D6 )
        goto LABEL_41;
      v27 = *(const char **)(sub_1402C4680((__int64)v141, (__int64)&v117) + 0x10);
      v111 = *(_OWORD *)(*(_QWORD *)(inserted + 0x30) + 0x78LL);
      v28 = sub_1402C4680((__int64)v137, (__int64)&v111);
      LogFatalError(
        "Class GUID CRC collision, existing class %s and new class %s have guids %s and %s that result in the same CRC",
        *(const char **)(*(_QWORD *)(inserted + 0x30) + 0x10LL),
        (const char *)a2[2],
        *(const char **)(v28 + 0x10),
        v27);
      if ( v139 != &v140 )
      {
        qword_149B3AD38 += 0xFFFFFFFFFFFFFFFFuLL - v138;
        sub_147605980(v139);
      }
      v25 = v143;
      if ( v143 == &v144 )
        goto LABEL_41;
      v26 = 0xFFFFFFFFFFFFFFFFuLL - v142;
    }
    qword_149B3AD38 += v26;
    sub_147605980(v25);
LABEL_41:
    *((_DWORD *)a2 + 8) = v23;
  }
  v29 = sub_146B67860((__int64)a2, (__int64)"SMovableObjectContainerParams");
  v30 = (unsigned __int16 *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)qword_149B4FC88
                                                                                     + 0x10LL))(
                              qword_149B4FC88,
                              v92,
                              "EntityComponentObjectContainer");
  if ( (unsigned __int8)sub_146B377C0(a2, *v30) )
  {
    if ( v29 )
    {
      v124[0] = 0xE9;
      v105[0] = v124;
      v124[1] = 0x1C;
      v105[1] = &v125;
      v124[2] = 0x2C;
      v31 = invokeGlobalCallbackAndMaskStatusBits(
              2,
              (__int64)v105,
              (__int64)"UnstreamableObjectContainerComponentWithMovableParams",
              "Unstreamable object containers cannot have the Movable Object container flag set in the static class param"
              "eters, you should use the StreamingObjectContainer component instead.");
      if ( (v31 & 0xFFFFF) != 0 )
      {
        v101[1] = a2[2];
        v101[0] = 0;
        v102 = 0;
        ThreadLogContextSlot = getThreadLogContextSlot();
        v122[0] = 0xE9;
        v106[0] = v122;
        v122[1] = 0x1C;
        v106[1] = &v123;
        v122[2] = 0x2C;
        v112 = 0;
        sub_140442060(
          2,
          (unsigned int)v106,
          (unsigned int)"UnstreamableObjectContainerComponentWithMovableParams",
          (unsigned int)"Unstreamable object containers cannot have the Movable Object container flag set in the static c"
                        "lass parameters, you should use the StreamingObjectContainer component instead.",
          2,
          v31,
          (__int64)&v112,
          0,
          (__int64)ThreadLogContextSlot,
          (__int64)v101);
        sub_1402A3D30(v102);
      }
    }
  }
  v33 = sub_146B67860((__int64)a2, (__int64)"SUniqueEntityClass");
  if ( !v33 )
    goto LABEL_95;
  v34 = *(__int64 **)(a1 + 0xD0);
  v35 = a2[0x10];
  v36 = v34;
  v37 = a2[0xF];
  v38 = v34[1];
  v39 = *(_BYTE *)(v38 + 0x19);
  if ( !v39 )
  {
    v40 = (__int64 *)v34[1];
    do
    {
      v41 = v40[4];
      v42 = v41 < v37;
      if ( v41 == v37 )
        v42 = v40[5] < v35;
      if ( v42 )
      {
        v40 = (__int64 *)v40[2];
      }
      else
      {
        v36 = v40;
        v40 = (__int64 *)*v40;
      }
    }
    while ( !*((_BYTE *)v40 + 0x19) );
  }
  if ( !*((_BYTE *)v36 + 0x19) )
  {
    v43 = v36[4];
    v44 = v37 < v43;
    if ( v37 == v43 )
      v44 = v35 < v36[5];
    if ( !v44 && v36 != v34 && v36[6] )
    {
LABEL_95:
      v87[0] = 0;
      v87[1] = 0;
      v56 = (_QWORD *)sub_140391AB0((__int64)v87, 0x18u);
      *v56 = v56;
      v57 = v56;
      v56[1] = v56;
      v86 = 1.0;
      v87[0] = v56;
      v88 = 0;
      v89 = 0;
      n7 = 7;
      n8 = 8;
      v58 = (_QWORD *)sub_140391AB0((__int64)&v88, 0x80u);
      v59 = (__int64)(*((_QWORD *)&v89 + 1) - (_QWORD)v88) >> 3;
      if ( v59 )
        sub_1403A3120((__int64)&v88, v88, 8 * v59);
      v60 = v58 + 0x10;
      v88 = v58;
      *(_QWORD *)&v89 = v58 + 0x10;
      *((_QWORD *)&v89 + 1) = v58 + 0x10;
      do
        *v58++ = v57;
      while ( v58 != v60 );
      v61 = v88;
      _XMM1 = 0;
      __asm { vroundss xmm1, xmm1, xmm0, 2 }
      v64 = 0;
      if ( *(float *)&_XMM1 >= 9.223372e18 )
      {
        *(float *)&_XMM1 = *(float *)&_XMM1 - 9.223372e18;
        if ( *(float *)&_XMM1 < 9.223372e18 )
          v64 = 0x8000000000000000uLL;
      }
      n8_2 = v64 + (unsigned int)(int)*(float *)&_XMM1;
      _XMM1 = 0;
      __asm { vroundss xmm1, xmm1, xmm0, 2 }
      v68 = 0;
      if ( *(float *)&_XMM1 >= 9.223372e18 )
      {
        *(float *)&_XMM1 = *(float *)&_XMM1 - 9.223372e18;
        if ( *(float *)&_XMM1 < 9.223372e18 )
          v68 = 0x8000000000000000uLL;
      }
      n8_1 = v68 + (unsigned int)(int)*(float *)&_XMM1;
      if ( n8_1 < n8_2 )
        n8_1 = n8_2;
      if ( n8_1 > n8 )
      {
        sub_146B884C0(&v86);
        v61 = v88;
      }
      v70 = (_WORD *)a2[6];
      v71 = (_WORD *)a2[5];
      if ( v71 == v70 )
      {
LABEL_122:
        if ( v61 )
        {
          sub_1403A3120((__int64)&v88, v61, (*((_QWORD *)&v89 + 1) - (_QWORD)v61) & 0xFFFFFFFFFFFFFFF8uLL);
          v89 = 0;
          v88 = 0;
        }
        v80 = (_QWORD **)v87[0];
        **((_QWORD **)v87[0] + 1) = 0;
        v81 = *v80;
        if ( *v80 )
        {
          do
          {
            v82 = (_QWORD *)*v81;
            sub_1403A3120((__int64)v87, v81, 0x18u);
            v81 = v82;
          }
          while ( v82 );
        }
        sub_1403A3120((__int64)v87, v87[0], 0x18u);
        if ( v5 )
        {
          v83 = *(_DWORD *)(v5 + 0x14);
          if ( v83 )
          {
            *(_DWORD *)(v5 + 0x14) = v83 - 1;
          }
          else
          {
            *(_DWORD *)(v5 + 0x10) = 0xFFFFFFFF;
            n0x200000 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
            if ( n0x200000 == 0x200000 )
              *(_QWORD *)(v5 + 8) = &p_p_p_p_p_p_p_p_p_p_p_Source;
            else
              sub_1403DD380(v5, n0x200000);
          }
        }
        sub_146B5FCB0(v94, 0, a2);
        return 1;
      }
      while ( 1 )
      {
        v72 = (unsigned __int16)*v71;
        n8_3 = *((_QWORD *)v61 + 2 * (unsigned __int16)(n7 & v72) + 1);
        if ( (const void *)n8_3 == v87[0] )
          goto LABEL_115;
        n8_2 = *((_QWORD *)v61 + 2 * (unsigned __int16)(n7 & *v71));
        if ( (_WORD)v72 != *(_WORD *)(n8_3 + 0x10) )
          break;
LABEL_116:
        n8_4 = v87[0];
        if ( n8_3 )
          n8_4 = (const void *)n8_3;
        if ( n8_4 != v87[0] )
        {
          v75 = a2[2];
          v76 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(*(_QWORD *)qword_149B4FC88 + 0x20LL))(
                  qword_149B4FC88,
                  v72,
                  n8_2);
          v120[0] = 0xE9;
          v77 = v76;
          v120[1] = 0x1C;
          v120[2] = 0x31;
          v107[0] = v120;
          v107[1] = &v121;
          v78 = invokeGlobalCallbackAndMaskStatusBits(
                  2,
                  (__int64)v107,
                  (__int64)"Duplicated Component in Entity Class",
                  "Duplicated Component '$$' in Entity Class '$$'");
          if ( (v78 & 0xFFFFF) != 0 )
          {
            v97[1] = v77;
            v95[0] = 0;
            v98 = 0;
            v99[0] = 0;
            v100 = 0;
            v95[1] = v75;
            v96 = 0;
            v97[0] = 0;
            v99[1] = v75;
            ThreadLogContextSlot_1 = getThreadLogContextSlot();
            v118[0] = 0xE9;
            v108[0] = v118;
            v118[1] = 0x1C;
            v108[1] = &v119;
            v118[2] = 0x31;
            v115 = 0;
            sub_1450F6050(
              2,
              (unsigned int)v108,
              (unsigned int)"Duplicated Component in Entity Class",
              (unsigned int)"Duplicated Component '$$' in Entity Class '$$'",
              2,
              v78,
              (__int64)&v115,
              0,
              (__int64)ThreadLogContextSlot_1,
              (__int64)v99,
              (__int64)v97,
              (__int64)v95);
            sub_1402A3D30(v100);
            sub_1402A3D30(v98);
            sub_1402A3D30(v96);
          }
        }
        sub_146B1F030(&v86, v116, v71);
        v61 = v88;
        v71 += 0x10;
        if ( v71 == v70 )
          goto LABEL_122;
      }
      while ( n8_3 != n8_2 )
      {
        n8_3 = *(_QWORD *)(n8_3 + 8);
        if ( (_WORD)v72 == *(_WORD *)(n8_3 + 0x10) )
          goto LABEL_116;
      }
LABEL_115:
      n8_3 = 0;
      goto LABEL_116;
    }
  }
  v45 = *(_QWORD *)(v33 + 8);
  if ( v45 )
  {
    if ( v45 - 0x2E90CF4B80LL > 0x1E847F )
    {
      LogFatalError(
        "Unique Entity class record was assigned an Entity Id that is outside of the Global Pre-allocated scope. Please u"
        "pdate the class record. name[%s]",
        a2[2]);
      goto LABEL_88;
    }
    v46 = *(_QWORD *)(a1 + 0xD0);
    *(_QWORD *)&v85 = v34[1];
    DWORD2(v85) = 0;
    if ( !v39 )
    {
      do
      {
        *(_QWORD *)&v85 = v38;
        v47 = *(_QWORD *)(v38 + 0x20) < v117.m128i_i64[0];
        if ( *(_QWORD *)(v38 + 0x20) == v117.m128i_i64[0] )
          v47 = *(_QWORD *)(v38 + 0x28) < v117.m128i_i64[1];
        if ( v47 )
        {
          v38 = *(_QWORD *)(v38 + 0x10);
          DWORD2(v85) = 0;
        }
        else
        {
          v46 = v38;
          DWORD2(v85) = 1;
          v38 = *(_QWORD *)v38;
        }
      }
      while ( !*(_BYTE *)(v38 + 0x19) );
    }
    if ( *(_BYTE *)(v46 + 0x19) )
      goto LABEL_75;
    v48 = v117.m128i_i64[0] < *(_QWORD *)(v46 + 0x20);
    if ( v117.m128i_i64[0] == *(_QWORD *)(v46 + 0x20) )
      v48 = v117.m128i_i64[1] < *(_QWORD *)(v46 + 0x28);
    if ( v48 )
    {
LABEL_75:
      if ( *(_QWORD *)(a1 + 0xD8) == 0x492492492492492LL )
        goto LABEL_133;
      v49 = allocWithProfilerInfo_w(0x38u);
      *(__m128i *)(v49 + 0x20) = v117;
      *(_QWORD *)(v49 + 0x30) = 0;
      *(_QWORD *)v49 = v34;
      *(_QWORD *)(v49 + 8) = v34;
      *(_QWORD *)(v49 + 0x10) = v34;
      *(_WORD *)(v49 + 0x18) = 0;
      v113 = v85;
      v46 = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
              (__int64 **)(a1 + 0xD0),
              (__int64)&v113,
              v49);
    }
    *(_QWORD *)(v46 + 0x30) = v45;
    v50 = *(_QWORD *)(a1 + 0xF0);
    DWORD2(v85) = 0;
    v51 = v50;
    v52 = *(_QWORD *)(v50 + 8);
    *(_QWORD *)&v85 = v52;
    while ( !*(_BYTE *)(v52 + 0x19) )
    {
      *(_QWORD *)&v85 = v52;
      if ( *(_QWORD *)(v52 + 0x20) >= v45 )
      {
        v51 = v52;
        DWORD2(v85) = 1;
        v52 = *(_QWORD *)v52;
      }
      else
      {
        v52 = *(_QWORD *)(v52 + 0x10);
        DWORD2(v85) = 0;
      }
    }
    if ( !*(_BYTE *)(v51 + 0x19) && v45 >= *(_QWORD *)(v51 + 0x20) )
      goto LABEL_86;
    if ( *(_QWORD *)(a1 + 0xF8) != 0x555555555555555LL )
    {
      v53 = allocWithProfilerInfo_w(0x30u);
      *(_QWORD *)(v53 + 0x20) = v45;
      *(_QWORD *)(v53 + 0x28) = 0;
      *(_QWORD *)v53 = v50;
      *(_QWORD *)(v53 + 8) = v50;
      *(_QWORD *)(v53 + 0x10) = v50;
      *(_WORD *)(v53 + 0x18) = 0;
      v114 = v85;
      v51 = std::_Tree_val<std::_Tree_simple_types<std::pair<openvdb::v8_1::math::Coord const,openvdb::v8_1::tree::RootNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::InternalNode<openvdb::v8_1::tree::LeafNode<openvdb::v8_1::math::Vec4<float>,3>,4>,5>>::NodeStruct>>>::_Insert_node(
              (__int64 **)(a1 + 0xF0),
              (__int64)&v114,
              v53);
LABEL_86:
      *(_QWORD *)(v51 + 0x28) = a2;
      goto LABEL_95;
    }
LABEL_133:
    unknown_libname_7();
  }
  LogFatalError("Unique Entity class does not have an EntityId assigned in its record. name[%s]", a2[2]);
LABEL_88:
  if ( a1 != 0xFFFFFFFFFFFFFFE8uLL )
  {
    v54 = *(_DWORD *)(a1 + 0x2C);
    if ( v54 )
    {
      *(_DWORD *)(a1 + 0x2C) = v54 - 1;
      return 0;
    }
    *(_DWORD *)(a1 + 0x28) = 0xFFFFFFFF;
    n0x200000_1 = _InterlockedCompareExchange64((volatile signed __int64 *)v5, 0, 0x200000);
    if ( n0x200000_1 == 0x200000 )
    {
      *(_QWORD *)(a1 + 0x20) = &p_p_p_p_p_p_p_p_p_p_p_Source;
      return 0;
    }
    sub_1403DD380(a1 + 0x18, n0x200000_1);
  }
  return 0;
}

// --- End Function: sub_146B696D0 (0x146B696D0) ---

// --- Function: sub_146B6ADD0 (0x146B6ADD0) ---
double __fastcall sub_146B6ADD0(_QWORD *a1)
{
  int i; // ebx
  __int64 v3; // r14
  _WORD *v4; // rax
  _WORD *v5; // rdx
  __int64 v6; // rbx
  _QWORD *v7; // rax
  int v8; // eax
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  __int64 v14; // [rsp+38h] [rbp-D0h] BYREF
  EntityClassDefinition **p_EntityClassDefinition; // [rsp+40h] [rbp-C8h] BYREF
  char *v16; // [rsp+48h] [rbp-C0h] BYREF
  _QWORD v17[2]; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v18; // [rsp+60h] [rbp-A8h] BYREF
  __int64 (__fastcall *p_sub_146B30FD0)(); // [rsp+68h] [rbp-A0h] BYREF
  __int64 (__fastcall *p_sub_146B32030)(); // [rsp+70h] [rbp-98h]
  _QWORD *v21; // [rsp+78h] [rbp-90h]
  __int64 v22; // [rsp+80h] [rbp-88h] BYREF
  int n0x2900; // [rsp+88h] [rbp-80h] BYREF
  __int64 v24; // [rsp+8Ch] [rbp-7Ch]
  int v25; // [rsp+94h] [rbp-74h]
  unsigned __int64 v26; // [rsp+98h] [rbp-70h]
  unsigned __int64 v27; // [rsp+A0h] [rbp-68h]
  __int64 v28; // [rsp+A8h] [rbp-60h]
  __int64 v29; // [rsp+B0h] [rbp-58h]
  _BYTE v30[24]; // [rsp+D8h] [rbp-30h] BYREF
  __int64 (__fastcall *p_sub_140498620)(); // [rsp+F0h] [rbp-18h] BYREF
  __int64 (__fastcall *n2)(); // [rsp+F8h] [rbp-10h]
  _QWORD *v33; // [rsp+100h] [rbp-8h]
  int v34; // [rsp+120h] [rbp+18h]
  char v35; // [rsp+124h] [rbp+1Ch]

  v25 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  n0x2900 = 0x2900;
  v24 = 1;
  v26 = __rdtsc();
  qword_149B4B870(
    &n0x2900,
    &word_1515B1D2C,
    "CEntityClassRegistry::RegisterEntityClasses",
    "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryEntitySystem\\EntityClassRegistry.cpp",
    0x179);
  HIWORD(n0x2900) = word_1515B1D2C;
  (*(void (__fastcall **)(__int64, _QWORD *, const char *, _QWORD))(*(_QWORD *)qword_149B4FCA0 + 0x3B0LL))(
    qword_149B4FCA0,
    v17,
    "Libs/ComponentDependency.xml",
    0);
  if ( v17[0] )
  {
    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)v17[0] + 0x48LL))(
            v17[0],
            "ComponentDependency") )
      LogFatalError(
        "ComponentDependency check file [%s] does not contain a ComponentDependency node",
        "Libs/ComponentDependency.xml");
    (*(void (__fastcall **)(_QWORD, __int64 *, const char *))(*(_QWORD *)v17[0] + 0x168LL))(
      v17[0],
      &v14,
      "CreationOrder");
    if ( v14 )
    {
      for ( i = 0; i < (*(int (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x158LL))(v14); ++i )
      {
        (*(void (__fastcall **)(__int64, const char **, _QWORD))(*(_QWORD *)v14 + 0x160LL))(
          v14,
          &p_EntityClassDefinition,
          (unsigned int)i);
        v3 = (*(__int64 (__fastcall **)(const char *, const char *))(*(_QWORD *)p_EntityClassDefinition + 0x110LL))(
               p_EntityClassDefinition,
               "name");
        if ( (unsigned __int8)sub_146A38520(*(_QWORD *)(qword_1515B19E8 + 0x7E0), v3) )
        {
          v4 = (_WORD *)sub_146A320C0(*(_QWORD *)(qword_1515B19E8 + 0x7E0), &v18, v3);
          v5 = (_WORD *)a1[0x18];
          if ( v5 == (_WORD *)a1[0x19] )
          {
            sub_1411F87F0(a1 + 0x17, v5, v4);
          }
          else
          {
            *v5 = *v4;
            a1[0x18] += 2LL;
          }
        }
        if ( p_EntityClassDefinition )
          (*(void (__fastcall **)(const char *))(*(_QWORD *)p_EntityClassDefinition + 0x28LL))(p_EntityClassDefinition);
      }
      if ( v14 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 0x28LL))(v14);
    }
    if ( v17[0] )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v17[0] + 0x28LL))(v17[0]);
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)qword_149B4FC40 + 0x48LL))(qword_149B4FC40, &v22);
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_149B4FCA0 + 0x240LL))(qword_149B4FCA0);
  v7 = (_QWORD *)allocWithProfilerInfo_w(8u);
  if ( v7 )
  {
    *v7 = a1;
    v21 = v7;
  }
  else
  {
    v21 = 0;
  }
  p_sub_146B30FD0 = sub_146B30FD0;
  p_sub_146B32030 = sub_146B32030;
  p_EntityClassDefinition = "EntityClassDefinition";
  sub_14035B120(&v16, &p_EntityClassDefinition);
  sub_14044CF30(v6 + 0xE8, v17, &v16);
  v16 = (char *)&qword_149B3B33C + 4;
  sub_140370D10(&v16);
  if ( v17[0] != *(_QWORD *)(v6 + 0xE8) + *(_QWORD *)(v6 + 0x100) )
  {
    sub_1402B14B0((__int64)v30, 0xF, 0, "ForEachRecord");
    v8 = *(_DWORD *)(*(_QWORD *)(v17[1] + 8LL) - 4LL) & 0x7FFFFFFF;
    v35 = 1;
    v34 = v8;
    if ( (unsigned __int64)n2 >= 2 )
    {
      ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))n2)(2, &p_sub_140498620);
      n2 = 0;
    }
    p_sub_140498620 = 0;
    v9 = (_QWORD *)allocWithProfilerInfo_w(0x10u);
    if ( v9 )
    {
      *v9 = &p_sub_146B30FD0;
      v9[1] = v17;
      v33 = v9;
    }
    else
    {
      v33 = 0;
    }
    p_sub_140498620 = sub_140498620;
    n2 = sub_140499CE0;
    (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)qword_149B4FCF8 + 0x20LL))(qword_149B4FCF8, v30);
    sub_1402B45A0(v30);
  }
  if ( (unsigned __int64)p_sub_146B32030 >= 2 )
    ((void (__fastcall *)(__int64, __int64 (__fastcall **)()))p_sub_146B32030)(2, &p_sub_146B30FD0);
  v10 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, const char **))(*(_QWORD *)qword_149B4FC40 + 0x48LL))(
                    qword_149B4FC40,
                    &p_EntityClassDefinition);
  sub_1405975C0(v10, v17, &v22);
  _XMM0 = sub_140597760();
  __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
  sub_1403A2CE0((__int64)"Registered entity classes in %fs", *(float *)&_XMM1);
  a1[0x20] = CEntityClassRegistry::FindClass((__int64)a1, (__int64)"Default");
  v27 = __rdtsc();
  return qword_149B4B878(&n0x2900);
}

// --- End Function: sub_146B6ADD0 (0x146B6ADD0) ---

// --- Function: sub_147602930 (0x147602930) ---
void __fastcall sub_147602930(__int64 a1)
{
  sub_147602940(a1);
}

// --- End Function: sub_147602930 (0x147602930) ---

// --- Function: sub_147602940 (0x147602940) ---
void __fastcall sub_147602940(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rdx
  volatile signed __int64 *v5; // rcx
  int v6; // eax
  unsigned __int64 n0x28; // r9
  _QWORD *v8; // rcx
  unsigned int n0x10; // eax

  if ( a1 )
  {
    if ( *(_BYTE *)((a1 & 0xFFFFFFC000000000uLL) + 0x14) )
    {
      v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
      v3 = (unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL);
      if ( *(_BYTE *)(v2 + 0xF01) )
      {
        v4 = (_QWORD *)(a1 + *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 0x10) - 8LL);
        v5 = &unk_151700CD0[4 * *(_QWORD *)((unsigned int)dword_151701E6C + (a1 & 0xFFFFFFFFFE000000uLL) + 8)];
      }
      else
      {
        if ( !*(_BYTE *)(v2 + 0xF00) )
        {
          *(_BYTE *)(v2 + 0xF00) = 1;
          v6 = *(_DWORD *)(v2 + 0x17E0);
          if ( (v6 & 1) == 0 )
          {
            *(_DWORD *)(v2 + 0x17E0) = v6 | 1;
            _tlregdtor((__int64)sub_148177D00);
          }
        }
        n0x28 = *(_QWORD *)(v3 + 8);
        v4 = (_QWORD *)(a1 + *(_QWORD *)(v3 + 0x10) - 8LL);
        if ( n0x28 <= 0x28 )
        {
          v8 = (_QWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF00);
          n0x10 = *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) + 1;
          if ( n0x10 < 0x10 )
          {
            *(_DWORD *)(v2 + 0x10 * (n0x28 + 1) + 0xF0C) = n0x10;
            *v4 = *v8;
            *v8 = v4;
            return;
          }
        }
        v5 = &unk_151700CD0[4 * n0x28];
      }
      sub_1476046F0(v5, v4, 0xFFFFFFFF);
    }
    else
    {
      sub_147602A80((__int64)&qword_151700CC0, a1);
    }
  }
}

// --- End Function: sub_147602940 (0x147602940) ---

// --- Function: sub_147602A80 (0x147602A80) ---
void __fastcall sub_147602A80(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned __int32 v4; // eax
  __int64 v5; // r13
  int v6; // ebx
  unsigned int v7; // ebp
  unsigned __int32 v8; // r15d
  unsigned int v9; // ebx
  unsigned __int32 v10; // [rsp+20h] [rbp-88h]
  unsigned __int32 v11; // [rsp+20h] [rbp-88h]
  int n0x1600; // [rsp+30h] [rbp-78h] BYREF
  __int64 v13; // [rsp+34h] [rbp-74h]
  int n2; // [rsp+3Ch] [rbp-6Ch]
  unsigned __int64 v15; // [rsp+40h] [rbp-68h]
  unsigned __int64 v16; // [rsp+48h] [rbp-60h]
  __int64 v17; // [rsp+50h] [rbp-58h]
  __int64 v18; // [rsp+58h] [rbp-50h]

  v3 = a1 + 0x12F0;
  v4 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 0x12F0), 1u);
  v5 = a1 + 0x12F0 + 0x10 * (v4 & 0x1F);
  v6 = (v4 >> 5) & 0x7FFF;
  v7 = ((v4 - 0x20) >> 5) & 0x7FFF;
  v8 = *(_DWORD *)(v5 + 8);
  if ( (v8 & 0x7FFF) != v7 )
  {
    if ( qword_149B4FDB8 )
    {
      n0x1600 = 0x1600;
      v13 = 1;
      n2 = 2;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v15 = __rdtsc();
      qword_149B4B870(
        &n0x1600,
        &word_1517021C0,
        "Wait on Full Queue",
        "W:\\p4-src\\CryEngine\\Code\\CryEngine\\CryCommon\\Containers/CigProducerConsumerQueue.h",
        0xB2);
      HIWORD(n0x1600) = word_1517021C0;
      LOBYTE(v11) = 0;
      sub_1407E63A0(v3, (volatile signed __int32 *)(v5 + 8), v8, v7, v11);
      v16 = __rdtsc();
      qword_149B4B878(&n0x1600);
    }
    else
    {
      LOBYTE(v10) = 0;
      sub_1407E63A0(a1 + 0x12F0, (volatile signed __int32 *)(v5 + 8), v8, v7, v10);
    }
  }
  *(_QWORD *)(v5 + 0x10) = a2;
  v9 = _InterlockedExchange((volatile __int32 *)(v5 + 0xC), v6);
  if ( (v9 & 0xFFFF8000) != 0 )
    sub_1407E6520(v3, v5 + 0xC, v9);
}

// --- End Function: sub_147602A80 (0x147602A80) ---

// --- Function: sub_1476046F0 (0x1476046F0) ---
char __fastcall sub_1476046F0(volatile signed __int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __m128i v4; // rt0
  __m128i v5; // xmm0
  signed __int64 epi64; // r9
  __int64 v7; // rdx
  __m128i v8; // rt0
  signed __int64 v10; // [rsp+18h] [rbp-40h]
  __m128i v11; // [rsp+30h] [rbp-28h]

  v4 = 0u;
  _InterlockedCompareExchange128(a1, 0, 0, v4.m128i_i64);
  v5 = v4;
  if ( (unsigned int)(v4.m128i_i32[3] + 1) >= a3 )
    return 0;
  while ( 1 )
  {
    epi64 = _mm_extract_epi64(v5, 1);
    *a2 = v5.m128i_i64[0];
    LODWORD(v10) = epi64 + 1;
    HIDWORD(v10) = HIDWORD(epi64) + 1;
    v8.m128i_i64[0] = v5.m128i_i64[0];
    v8.m128i_i64[1] = epi64;
    _InterlockedCompareExchange128(a1, v10, (signed __int64)a2, v8.m128i_i64);
    v7 = v8.m128i_i64[1];
    v11 = v8;
    if ( v8.m128i_i64[0] == v5.m128i_i64[0] && (_DWORD)v7 == (_DWORD)epi64 )
      break;
    v5 = v11;
    if ( (unsigned int)(HIDWORD(v7) + 1) >= a3 )
      return 0;
  }
  return 1;
}

// --- End Function: sub_1476046F0 (0x1476046F0) ---

// --- Function: sub_147605980 (0x147605980) ---
void __fastcall sub_147605980(const void *a1)
{
  if ( a1 )
  {
    if ( qword_149B4FDB8 && qword_149B4FBE8 && a1 == (const void *)qword_149B4FBE8 )
      __debugbreak();
    if ( (unsigned __int64)a1 < qword_149B00898 || (unsigned __int64)a1 >= qword_149B00898 + 0x8000000000LL )
    {
      if ( (unsigned __int64)a1 >= qword_149B00878 && (unsigned __int64)a1 < qword_149B00878 + 0x200000000LL )
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", a1);
      sub_147602930((__int64)a1);
    }
  }
}

// --- End Function: sub_147605980 (0x147605980) ---

// --- Function: __alloca_probe (0x1480336A0) ---
unsigned __int64 __fastcall _alloca_probe()
{
  unsigned __int64 result; // rax
  char *StackLimit_1; // r10
  char *StackLimit; // r11
  char v3; // [rsp+18h] [rbp+8h] BYREF

  StackLimit_1 = &v3 - result;
  if ( (unsigned __int64)&v3 < result )
    StackLimit_1 = 0;
  StackLimit = (char *)NtCurrentTeb()->NtTib.StackLimit;
  if ( StackLimit_1 < StackLimit )
  {
    LOWORD(StackLimit_1) = (unsigned __int16)StackLimit_1 & 0xF000;
    do
    {
      StackLimit -= 4096;
      *StackLimit = 0;
    }
    while ( StackLimit_1 != StackLimit );
  }
  return result;
}

// --- End Function: __alloca_probe (0x1480336A0) ---

// --- Function: __security_check_cookie (0x148033700) ---
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}

// --- End Function: __security_check_cookie (0x148033700) ---

// --- Function: __tlregdtor (0x1480337C8) ---
__int64 __fastcall _tlregdtor(__int64 a1)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx

  v2 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v3 = *(_QWORD **)(v2 + 6320);
  if ( !v3 )
  {
    v3 = (_QWORD *)(v2 + 6336);
LABEL_7:
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v2 + 6320) = v3;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v3 == 30 )
  {
    v3 = malloc_0(0x100u);
    free_0(0);
    if ( !v3 )
      return 0xFFFFFFFFLL;
    v3[1] = *(_QWORD *)(v2 + 6320);
    goto LABEL_7;
  }
LABEL_8:
  v3[(*(_DWORD *)v3)++ + 2] = a1;
  return 0;
}

// --- End Function: __tlregdtor (0x1480337C8) ---

// --- Function: __report_gsfailure (0x1480338FC) ---
void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 StackCookie_1; // [rsp+40h] [rbp+8h] BYREF

  StackCookie_1 = StackCookie;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&StackCookie_1;
  qword_151736400 = retaddr;
  ContextRecord.Rcx = StackCookie_1;
  dword_1517363F0 = -1073740791;
  dword_1517363F4 = 1;
  dword_151736408 = 1;
  unk_151736410 = 2;
  _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

// --- End Function: __report_gsfailure (0x1480338FC) ---

// --- Function: sub_148177D00 (0x148177D00) ---
__int64 sub_148177D00()
{
  volatile signed __int64 *v0; // rdi
  __int64 ThreadLocalStoragePointer; // rax
  __int64 n0x8C; // rsi
  __int64 v3; // rbp
  __int64 v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *v6; // rax
  int v7; // r9d
  _QWORD *v8; // r8

  v0 = unk_151700CD0;
  ThreadLocalStoragePointer = (__int64)NtCurrentTeb()->ThreadLocalStoragePointer;
  n0x8C = 0x8C;
  v3 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF00LL;
  v4 = *(_QWORD *)(ThreadLocalStoragePointer + 8LL * (unsigned int)TlsIndex) + 0xF10LL;
  do
  {
    v5 = *(_QWORD **)v4;
    if ( *(_QWORD *)v4 )
    {
      v6 = (_QWORD *)*v5;
      v7 = 1;
      v8 = *(_QWORD **)v4;
      if ( *v5 )
      {
        do
        {
          ++v7;
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while ( v6 );
      }
      ThreadLocalStoragePointer = sub_1476047E0(v0, (signed __int64)v5, v8, v7);
      *(_QWORD *)v4 = 0;
      *(_DWORD *)(v4 + 0xC) = 0;
    }
    v4 += 0x10;
    v0 += 4;
    --n0x8C;
  }
  while ( n0x8C );
  *(_BYTE *)(v3 + 1) = 1;
  return ThreadLocalStoragePointer;
}

// --- End Function: sub_148177D00 (0x148177D00) ---

