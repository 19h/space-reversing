// Decompiled code dump generated by Code Dumper (Callers/Callees/Refs)
// Start Function: 0x146919090 (sub_146919090)
// Caller Depth: 0
// Callee/Ref Depth: 3
// Total Functions Found: 44
// ------------------------------------------------------------

// --- Function: free_memory_wrapper (0x1402A1E20) ---
// Wrapper function that forwards the memory deallocation request to
// `sub_14739AF10`.
void __fastcall free_memory_wrapper(const void *ptr_to_free)
{
  sub_14739AF10(ptr_to_free);
}

// --- End Function: free_memory_wrapper (0x1402A1E20) ---

// --- Function: allocWithoutProfiling (0x1402A1E30) ---
__int64 __fastcall allocWithoutProfiling(unsigned __int64 size)
{
  return allocWithProfilerInfo(size, 0);
}

// --- End Function: allocWithoutProfiling (0x1402A1E30) ---

// --- Function: get_tls_data_offset_784 (0x1402C4010) ---
// Retrieves a pointer to a thread-specific data structure. Accesses the TEB's
// ThreadLocalStoragePointer array using the global TlsIndex, retrieves the base
// pointer for this thread's data, and adds a fixed offset of 784 bytes.
__int64 get_tls_data_offset_784()
{
  return *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 784LL;
}

// --- End Function: get_tls_data_offset_784 (0x1402C4010) ---

// --- Function: is_valid_handle_typeB (0x14030C8B0) ---
// Validates a packed handle (QWORD containing a pointer in the lower 48 bits and
// flags in the upper 16 bits).  Calculates the pointer to the handle's metadata,
// potentially adjusting based on high flag bits (0xF000) using `map_flag_to_mask`.
// Checks if the lower 12 bits of the handle flags match the flags stored in the
// metadata (at offset +2).  If the metadata type (at offset +4) is 2 and certain
// thread state flags are set (checked via TLS offset +37 or
// `is_thread_flag_57_or_38_set`), the handle is considered valid.  Otherwise,
// delegates the validation to `check_handle_access_by_state_extended`.
bool __fastcall is_valid_handle_typeB(unsigned __int64 *packed_handle_ptr)
{
  unsigned __int64 packed_handle_value; // r9
  __int64 handle_ptr; // r10
  unsigned __int64 handle_flags; // r9
  __int64 mask_from_flag; // rax
  __int64 handle_ptr_copy; // r10
  __int64 metadata_ptr; // rbx
  bool is_thread_state_ok; // al

  packed_handle_value = *packed_handle_ptr;
  if ( !*packed_handle_ptr )
  {
    return 0;
  }
  handle_ptr = packed_handle_value & 0xFFFFFFFFFFFFLL;
  handle_flags = HIWORD(packed_handle_value);
  if ( (handle_flags & 0xF000) != 0 )
  {
    mask_from_flag = map_flag_to_mask(0x2000u);
    metadata_ptr = handle_ptr_copy & ~(mask_from_flag - 1);
  }
  else
  {
    metadata_ptr = handle_ptr - 6;
  }
  if ( *(_WORD *)(metadata_ptr + 2) != (handle_flags & 0xFFF) )
  {
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || (is_thread_state_ok = is_thread_flag_57_or_38_set()) )
  {
    is_thread_state_ok = 1;
  }
  return *(_WORD *)(metadata_ptr + 4) == 2 && is_thread_state_ok
      || check_handle_access_by_state_extended(packed_handle_ptr) != 0;
}

// --- End Function: is_valid_handle_typeB (0x14030C8B0) ---

// --- Function: check_handle_access_by_state (0x14031DD70) ---
// Checks access permissions for the provided packed handle. Retrieves handle
// metadata using `get_handle_metadata`. Validates access based on the state field
// (metadata + 4): - State 0: Returns false (invalid). - State 1: Checks if the
// handle's payload exists in a thread-local list using
// `check_thread_list_contains_value`. - State 2: Returns true if specific thread
// flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3: Checks thread
// state and compares the payload value against a constant using
// `check_thread_state_and_value_not_equal`. - Other states: Return false.
char __fastcall check_handle_access_by_state(_QWORD *packed_handle_ptr)
{
  __int64 handle_value; // rbx
  __int64 metadata_ptr; // rax
  _QWORD *payload_ptr; // rax
  __int64 payload_ptr_state2; // rax
  __int64 payload_ptr_state1; // rax

  handle_value = *packed_handle_ptr & 0xFFFFFFFFFFFFLL;
  metadata_ptr = get_handle_metadata_ptr(handle_value);
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    payload_ptr_state1 = get_handle_payload_ptr(handle_value);
    return check_thread_list_contains_value(payload_ptr_state1);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( *(_WORD *)(metadata_ptr + 4) == 3 )
    {
      payload_ptr = (_QWORD *)get_handle_payload_ptr(handle_value);
      return check_thread_state_and_value_not_equal(payload_ptr);
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  payload_ptr_state2 = get_handle_payload_ptr(handle_value);
  return validate_access_with_virtual_calls(payload_ptr_state2);
}

// --- End Function: check_handle_access_by_state (0x14031DD70) ---

// --- Function: map_flag_to_mask (0x140322940) ---
// Maps specific input flag values to corresponding bitmask values. Returns 0 if
// the input flag is not recognized. Mappings: 0x2000 -> 0x1000000 0x4000 ->
// 0x2000000 24576 (0x6000) -> 0x4000000 0x8000 -> 0x8000000 0xA000 -> 0x20000000
// 0xC000 -> 0x80000000
__int64 __fastcall map_flag_to_mask(unsigned __int16 input_flag)
{
  unsigned int v1; // edx
  __int64 result; // rax

  if ( input_flag > 0x8000u )
  {
    if ( input_flag == 0xA000 )
    {
      return 0x20000000;
    }
    else
    {
      result = 0x80000000LL;
      if ( input_flag != 0xC000 )
      {
        return 0;
      }
    }
  }
  else
  {
    switch ( input_flag )
    {
      case 0x8000u:
        return 0x8000000;
      case 0x2000u:
        return 0x1000000;
      case 0x4000u:
        return 0x2000000;
      default:
        v1 = 0;
        if ( input_flag == 24576 )
        {
          return 0x4000000;
        }
        return v1;
    }
  }
  return result;
}

// --- End Function: map_flag_to_mask (0x140322940) ---

// --- Function: sub_14033FE60 (0x14033FE60) ---
void __fastcall sub_14033FE60(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  char *v3; // rbx
  unsigned __int64 v5; // rbp
  __int64 v6; // rsi
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rdi
  _QWORD *ptr_to_free; // rcx
  unsigned __int64 size; // r15
  __int64 v13; // rax
  char *v14; // r8
  unsigned __int64 v15; // rdi
  char *v16; // r15
  __int64 *v17; // rdi
  __int64 v18; // rsi
  __int64 v19; // rcx
  int v20; // eax
  unsigned __int64 v21; // rsi
  _QWORD *v22; // rbx

  v3 = (char *)*a1;
  v5 = a3;
  v6 = a2;
  v7 = (__int64)(a1[2] - *a1) >> 5;
  if ( a3 > v7 )
  {
    if ( a3 > 0x7FFFFFFFFFFFFFFLL )
    {
      unknown_libname_10();
    }
    v8 = v7 >> 1;
    if ( v7 <= 0x7FFFFFFFFFFFFFFLL - (v7 >> 1) )
    {
      v9 = v8 + v7;
      if ( v8 + v7 < a3 )
      {
        v9 = a3;
      }
    }
    else
    {
      v9 = 0x7FFFFFFFFFFFFFFLL;
    }
    v10 = 0;
    if ( v3 )
    {
      sub_140340F60(v3, a1[1], a1);
      ptr_to_free = (_QWORD *)*a1;
      if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)ptr_to_free - *(ptr_to_free - 1) - 8 > 0x1F )
        {
          goto LABEL_17;
        }
        ptr_to_free = (_QWORD *)*(ptr_to_free - 1);
      }
      free_memory_wrapper(ptr_to_free);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if ( v9 > 0x7FFFFFFFFFFFFFFLL )
    {
      goto LABEL_40;
    }
    size = 32 * v9;
    if ( size < 0x1000 )
    {
      if ( size )
      {
        v10 = allocWithoutProfiling(size);
      }
      goto LABEL_20;
    }
    if ( size + 39 < size )
    {
LABEL_40:
      sub_1402DEE40();
    }
    v13 = allocWithoutProfiling(size + 39);
    if ( v13 )
    {
      v10 = (v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v10 - 8) = v13;
LABEL_20:
      *a1 = v10;
      a1[1] = v10;
      a1[2] = size + v10;
      a1[1] = sub_14034C930(v6, v5, v10, a1);
      return;
    }
LABEL_17:
    invalid_parameter_noinfo_noreturn();
  }
  v14 = (char *)a1[1];
  v15 = (v14 - v3) >> 5;
  if ( v5 <= v15 )
  {
    v16 = &v3[32 * v5];
    if ( v5 )
    {
      v17 = (__int64 *)(a2 + 8);
      do
      {
        *(_WORD *)v3 = *((_WORD *)v17 - 4);
        v18 = *v17;
        if ( *((_QWORD *)v3 + 1) != *v17 )
        {
          if ( v18 )
          {
            (*(void (__fastcall **)(__int64))(*(_QWORD *)(v18 + 8) + 8LL))(v18 + 8);
          }
          v19 = *((_QWORD *)v3 + 1);
          if ( v19 )
          {
            (*(void (__fastcall **)(__int64))(*(_QWORD *)(v19 + 8) + 16LL))(v19 + 8);
          }
          *((_QWORD *)v3 + 1) = v18;
        }
        v3[16] = 0;
        v3[17] = *((_BYTE *)v17 + 9);
        v20 = *((_DWORD *)v17 + 4);
        v17 += 4;
        *((_DWORD *)v3 + 6) = v20;
        v3 += 32;
        --v5;
      }
      while ( v5 );
    }
    v21 = a1[1];
    if ( v16 != (char *)v21 )
    {
      v22 = v16 + 8;
      do
      {
        if ( *v22 )
        {
          (*(void (__fastcall **)(__int64))(*(_QWORD *)(*v22 + 8LL) + 16LL))(*v22 + 8LL);
        }
        *v22 = 0;
        v22 += 4;
      }
      while ( v22 - 1 != (_QWORD *)v21 );
    }
    a1[1] = (unsigned __int64)v16;
  }
  else
  {
    for ( ; v3 != v14; v6 += 32 )
    {
      sub_140379CE0(v3, v6);
      v14 = (char *)a1[1];
      v3 += 32;
    }
    a1[1] = sub_14034C930(v6, v5 - v15, v14, a1);
  }
}

// --- End Function: sub_14033FE60 (0x14033FE60) ---

// --- Function: sub_1403428D0 (0x1403428D0) ---
unsigned __int64 __fastcall sub_1403428D0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r14
  __int64 v5; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rdi
  unsigned __int64 size; // rcx
  __int64 v13; // rax
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // r14
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rcx

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 5;
  if ( v5 == 0x7FFFFFFFFFFFFFFLL )
  {
    unknown_libname_10();
  }
  v8 = (a1[2] - *a1) >> 5;
  v9 = v8 >> 1;
  v10 = v5 + 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFLL - (v8 >> 1) )
  {
    goto LABEL_21;
  }
  v11 = v5 + 1;
  if ( v9 + v8 >= v10 )
  {
    v11 = v9 + v8;
  }
  if ( v11 > 0x7FFFFFFFFFFFFFFLL )
  {
    goto LABEL_21;
  }
  size = 32 * v11;
  if ( 32 * v11 < 0x1000 )
  {
    if ( size )
    {
      v14 = allocWithoutProfiling(size);
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_14;
  }
  if ( size + 39 < size )
  {
LABEL_21:
    sub_1402DEE40();
  }
  v13 = allocWithoutProfiling(size + 39);
  if ( !v13 )
  {
    invalid_parameter_noinfo_noreturn();
  }
  v14 = (v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
LABEL_14:
  v15 = v14 + (v4 & 0xFFFFFFFFFFFFFFE0uLL);
  *(_WORD *)v15 = *(_WORD *)a3;
  v16 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(v15 + 8) = v16;
  if ( v16 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)(v16 + 8) + 8LL))(v16 + 8);
  }
  *(_WORD *)(v15 + 16) = 0;
  *(_DWORD *)(v15 + 24) = *(_DWORD *)(a3 + 24);
  v17 = a1[1];
  v18 = *a1;
  if ( a2 == v17 )
  {
    sub_14034C1D0(v18, v17, v14, a1);
  }
  else
  {
    sub_14034CF70(v18, a2, v14, a1);
    sub_14034CF70(a2, a1[1], v15 + 32, a1);
  }
  sub_1403DA310(a1, v14, v10, v11);
  return v15;
}

// --- End Function: sub_1403428D0 (0x1403428D0) ---

// --- Function: initializeEmptyStringStructure (0x140357A40) ---
// Initializes the string structure pointed to by `a1` to represent an empty string
// by setting its internal pointer to the global empty string sentinel
// `qword_149808ABC + 4`.
void __fastcall initializeEmptyStringStructure(_QWORD *string_struct_ptr)
{
  *string_struct_ptr = (char *)&qword_149808ABC + 4;
}

// --- End Function: initializeEmptyStringStructure (0x140357A40) ---

// --- Function: Mat44f::SetIdentity (0x14035C6E0) ---
_DWORD *__fastcall Mat44f::SetIdentity(_DWORD *a1)
{
  *a1 = -268435456;
  return a1;
}

// --- End Function: Mat44f::SetIdentity (0x14035C6E0) ---

// --- Function: DestroyStringObject (0x14036D270) ---
// Deallocates the memory buffer associated with a string object created by
// `CreateStringObjectFromString`.  It accesses metadata stored 8 bytes before the
// provided data pointer to get the allocation base pointer required by the
// deallocation function `sub_14739AF10`.  @param ppStringObjectData Pointer to the
// variable holding the pointer to the string object's data.
void __fastcall DestroyStringObject(_QWORD *ppStringObjectData)
{
  int *pStringMetadata; // rcx

  pStringMetadata = (int *)(*ppStringObjectData - 8LL);
  if ( pStringMetadata[1] > 0 )
  {
    sub_14739AF10(pStringMetadata);
  }
}

// --- End Function: DestroyStringObject (0x14036D270) ---

// --- Function: sub_14036E4A0 (0x14036E4A0) ---
void __fastcall sub_14036E4A0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rsi
  __int64 v4; // rcx
  _QWORD *ptr_to_free; // rcx

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 4 )
    {
      v4 = v1[1];
      if ( v4 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)(v4 + 8) + 16LL))(v4 + 8);
      }
      v1[1] = 0;
    }
    ptr_to_free = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)ptr_to_free - *(ptr_to_free - 1) - 8 > 0x1F )
      {
        invalid_parameter_noinfo_noreturn();
      }
      ptr_to_free = (_QWORD *)*(ptr_to_free - 1);
    }
    free_memory_wrapper(ptr_to_free);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

// --- End Function: sub_14036E4A0 (0x14036E4A0) ---

// --- Function: sub_14036EF50 (0x14036EF50) ---
__int64 __fastcall sub_14036EF50(_DWORD *a1)
{
  __int64 result; // rax

  if ( *a1 != -268435456 )
  {
    return (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)qword_14981D218 + 248LL))(qword_14981D218, a1);
  }
  return result;
}

// --- End Function: sub_14036EF50 (0x14036EF50) ---

// --- Function: SEntityTransform::SetEntityFlags (0x14038A190) ---
void *__fastcall SEntityTransform::SetEntityFlags(__int64 a1, int a2)
{
  void **v4; // rcx
  void *result; // rax

  if ( (a2 & 0x1000) != 0 )
  {
    v4 = (void **)(a1 + 184);
    result = *v4;
    if ( *((_DWORD *)*v4 - 2) )
    {
      result = (void *)sub_1403E4C30(v4, 0, 32);
    }
    *(_DWORD *)(a1 + 192) |= a2;
  }
  else
  {
    *(_DWORD *)(a1 + 192) |= a2;
  }
  return result;
}

// --- End Function: SEntityTransform::SetEntityFlags (0x14038A190) ---

// --- Function: check_thread_list_contains_value (0x14038E3B0) ---
// Checks if a value, obtained by calling the virtual function at offset +8 of
// `object_ptr`, exists within a sorted list stored in the current thread's local
// storage. Retrieves thread data via `get_thread_specific_data_offset_784`. If the
// thread status allows (`*(DWORD*)(thread_data + 8) == 0`), it performs a binary
// search for the value within the QWORD array defined by pointers at `thread_data
// + 16` and `thread_data + 24`.
bool __fastcall check_thread_list_contains_value(__int64 payload_ptr_state1)
{
  __int64 thread_data; // rbx
  unsigned __int64 *v3; // rax
  char *list_begin_1; // r10
  char *list_begin; // rcx
  unsigned __int64 search_value; // rdx
  unsigned __int64 search_range_count; // r8
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) )
  {
    return 0;
  }
  v3 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state1 + 8LL))(
                             payload_ptr_state1,
                             &vf_output_temp);
  list_begin_1 = *(char **)(thread_data + 24);
  list_begin = *(char **)(thread_data + 16);
  search_value = *v3;
  search_range_count = (list_begin_1 - list_begin) >> 4;
  while ( search_range_count )
  {
    if ( *(_QWORD *)&list_begin[16 * (search_range_count >> 1)] >= search_value )
    {
      search_range_count >>= 1;
    }
    else
    {
      list_begin += 16 * (search_range_count >> 1) + 16;
      search_range_count += -1LL - (search_range_count >> 1);
    }
  }
  if ( list_begin == list_begin_1 )
  {
    return 0;
  }
  if ( search_value < *(_QWORD *)list_begin )
  {
    list_begin = *(char **)(thread_data + 24);
  }
  return list_begin != list_begin_1;
}

// --- End Function: check_thread_list_contains_value (0x14038E3B0) ---

// --- Function: check_thread_state_and_value_not_equal (0x14038E470) ---
// Checks if the current thread's data exists, has the status field at offset +8
// equal to 1, and if the value pointed to by `value_ptr` is not equal to the
// specific constant 0x13374770CLL.
bool __fastcall check_thread_state_and_value_not_equal(_QWORD *value_ptr)
{
  __int64 thread_data; // rax

  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
  return thread_data && *(_DWORD *)(thread_data + 8) == 1 && *value_ptr != 0x13374770CLL;
}

// --- End Function: check_thread_state_and_value_not_equal (0x14038E470) ---

// --- Function: validate_access_with_virtual_calls (0x14038E4B0) ---
// Validates access by checking thread state and the feature flag from
// `is_illegal_entity_access_check_enabled()`. If permitted, it calls the virtual
// function at offset +8 on `object_ptr` to get a value, and then calls the virtual
// function at offset +984 on the global object `qword_14981D2A0`, passing the
// retrieved value.
char __fastcall validate_access_with_virtual_calls(__int64 payload_ptr_state2)
{
  __int64 thread_data; // rax
  __int64 global_validator_object; // rdi
  __int64 (__fastcall *global_validator_vtable)(__int64, _QWORD); // rbx
  _QWORD *value_from_object_ptr; // rax
  char vf_output_temp; // [rsp+38h] [rbp+10h] BYREF

  if ( !*(_QWORD *)get_tls_data_offset_784() )
  {
    return 1;
  }
  thread_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
  if ( !thread_data || *(_DWORD *)(thread_data + 8) || !is_illegal_entity_access_check_enabled() )
  {
    return 1;
  }
  global_validator_object = ::global_validator_object;
  global_validator_vtable = *(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)::global_validator_object + 984LL);
  value_from_object_ptr = (_QWORD *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)payload_ptr_state2 + 8LL))(
                                      payload_ptr_state2,
                                      &vf_output_temp);
  return global_validator_vtable(global_validator_object, *value_from_object_ptr);
}

// --- End Function: validate_access_with_virtual_calls (0x14038E4B0) ---

// --- Function: check_handle_access_by_state_extended (0x14038E620) ---
// Checks access permissions for the provided packed handle using extended logic.
// Calculates the metadata pointer based on high bits in the packed handle.
// Validates access based on the state field (metadata + 4): - State 0: Returns
// false (invalid). - State 1: Checks if the handle's payload exists in a thread-
// local list using `check_thread_list_contains_value`. - State 2: Returns true if
// specific thread flags are set (`get_thread_specific_data_offset_784() + 37` or
// `check_thread_flag_57_or_38`), otherwise validates access using
// `validate_access_with_virtual_calls` on the payload. - State 3 or 4: Returns
// true if thread data exists, its status field at +8 is 1, and the payload value
// is not equal to the constant 0x13374770CLL. - Other states: Return false.
char __fastcall check_handle_access_by_state_extended(_QWORD *packed_handle_ptr)
{
  _QWORD *handle_payload_ptr; // rbx
  __int64 metadata_ptr; // rax
  __int64 thread_specific_data; // rax

  handle_payload_ptr = (_QWORD *)(*packed_handle_ptr & 0xFFFFFFFFFFFFLL);
  if ( (*packed_handle_ptr & 0xF000000000000000uLL) != 0 )
  {
    metadata_ptr = *packed_handle_ptr & 0xFFFFFF000000LL;
  }
  else
  {
    metadata_ptr = (__int64)handle_payload_ptr - 6;
  }
  if ( !*(_WORD *)(metadata_ptr + 4) )
  {
    return 0;
  }
  if ( *(_WORD *)(metadata_ptr + 4) == 1 )
  {
    return check_thread_list_contains_value((__int64)handle_payload_ptr);
  }
  if ( *(_WORD *)(metadata_ptr + 4) != 2 )
  {
    if ( (unsigned int)*(unsigned __int16 *)(metadata_ptr + 4) - 3 <= 1 )
    {
      thread_specific_data = *(_QWORD *)(*(_QWORD *)(get_tls_data_offset_784() + 16) + 8LL);
      if ( thread_specific_data )
      {
        if ( *(_DWORD *)(thread_specific_data + 8) == 1 )
        {
          return *handle_payload_ptr != 0x13374770CLL;
        }
      }
    }
    return 0;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || is_thread_flag_57_or_38_set() )
  {
    return 1;
  }
  else
  {
    return validate_access_with_virtual_calls((__int64)handle_payload_ptr);
  }
}

// --- End Function: check_handle_access_by_state_extended (0x14038E620) ---

// --- Function: get_handle_payload_ptr (0x1403AC8D0) ---
// Retrieves the QWORD value at offset +8 from the structure pointed to by
// `metadata_or_object_ptr` and returns its lower 48 bits (masked with
// 0xFFFFFFFFFFFF). This likely extracts an embedded payload pointer or handle.
__int64 __fastcall get_handle_payload_ptr(__int64 metadata_or_object_ptr)
{
  return *(_QWORD *)(metadata_or_object_ptr + 8) & 0xFFFFFFFFFFFFLL;
}

// --- End Function: get_handle_payload_ptr (0x1403AC8D0) ---

// --- Function: sub_1403AC900 (0x1403AC900) ---
_QWORD *__fastcall sub_1403AC900(unsigned __int64 *a1, _QWORD *a2)
{
  if ( is_valid_handle_typeB(a1) )
  {
    (*(void (__fastcall **)(unsigned __int64, _QWORD *))(*(_QWORD *)(*a1 & 0xFFFFFFFFFFFFLL) + 8LL))(
      *a1 & 0xFFFFFFFFFFFFLL,
      a2);
  }
  else
  {
    *a2 = 0;
  }
  return a2;
}

// --- End Function: sub_1403AC900 (0x1403AC900) ---

// --- Function: get_handle_metadata_ptr (0x1403B0A30) ---
// Retrieves a pointer to the metadata structure associated with the given handle.
// Calls the virtual function at offset +296 on the global object
// `global_validator_object`, passing the handle.
__int64 __fastcall get_handle_metadata_ptr(__int64 handle_value)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)global_validator_object + 296LL))(
           global_validator_object,
           handle_value,
           0);
}

// --- End Function: get_handle_metadata_ptr (0x1403B0A30) ---

// --- Function: sub_1403CF640 (0x1403CF640) ---
void __fastcall sub_1403CF640(unsigned __int64 *a1, unsigned __int64 a2)
{
  _WORD **v4; // rdi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rcx
  __int64 *v10; // rax
  __int64 v11; // r15
  _WORD *v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rsi
  unsigned __int64 v15; // rbx
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rdi
  void (__fastcall *v19)(__int64, unsigned __int64 *, __int128 *); // rbx
  unsigned __int64 v20; // [rsp+20h] [rbp-78h] BYREF
  _QWORD v21[3]; // [rsp+28h] [rbp-70h] BYREF
  __int128 v22; // [rsp+40h] [rbp-58h] BYREF
  _BYTE v23[16]; // [rsp+50h] [rbp-48h] BYREF

  if ( a2 )
  {
    if ( *a1 )
    {
      LogFatalError("Setting a class on spawn params that were already set up");
    }
    *a1 = a2;
    v4 = (_WORD **)(a1 + 1);
    v5 = a1[3];
    v6 = 0;
    v7 = a1[2];
    v8 = a1[1];
    a1[3] = 0;
    a1[2] = 0;
    a1[1] = 0;
    v9 = *a1;
    v21[2] = v5;
    v21[0] = v8;
    v21[1] = v7;
    v10 = (__int64 *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)v9 + 96LL))(v9);
    if ( a1 + 1 != (unsigned __int64 *)v10 )
    {
      sub_14033FE60(a1 + 1, *v10, (v10[1] - *v10) >> 5);
    }
    if ( (__int64)(v7 - v8) >> 5 )
    {
      v11 = 0;
      do
      {
        if ( (__int64)(v7 - v8) >> 5 <= v6 )
        {
          __debugbreak();
        }
        v12 = *v4;
        v13 = a1[2];
        if ( *v4 == (_WORD *)v13 )
        {
LABEL_13:
          if ( (__int64)(v7 - v8) >> 5 <= v6 )
          {
            __debugbreak();
          }
          v14 = v11 + v8;
          v15 = a1[2];
          if ( v13 == a1[3] )
          {
            sub_1403428D0((__int64 *)a1 + 1, v13, v11 + v8);
          }
          else
          {
            *(_WORD *)v13 = *(_WORD *)v14;
            v16 = *(_QWORD *)(v14 + 8);
            *(_QWORD *)(v13 + 8) = v16;
            if ( v16 )
            {
              (*(void (__fastcall **)(__int64))(*(_QWORD *)(v16 + 8) + 8LL))(v16 + 8);
            }
            *(_WORD *)(v15 + 16) = 0;
            *(_DWORD *)(v15 + 24) = *(_DWORD *)(v14 + 24);
            a1[2] += 32LL;
          }
        }
        else
        {
          while ( *v12 != *(_WORD *)(v11 + v8) )
          {
            v12 += 16;
            if ( v12 == (_WORD *)v13 )
            {
              goto LABEL_13;
            }
          }
        }
        ++v6;
        v11 += 32;
      }
      while ( v6 < (__int64)(v7 - v8) >> 5 );
    }
    v17 = (*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)*a1 + 120LL))(*a1);
    (*(void (__fastcall **)(__int64, unsigned __int64 *, __int64))(*(_QWORD *)qword_14981D218 + 232LL))(
      qword_14981D218,
      a1 + 20,
      v17);
    if ( (*(unsigned __int8 (__fastcall **)(unsigned __int64))(*(_QWORD *)*a1 + 136LL))(*a1) )
    {
      v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)global_validator_object + 192LL))(global_validator_object);
      v19 = *(void (__fastcall **)(__int64, unsigned __int64 *, __int128 *))(*(_QWORD *)v18 + 72LL);
      v22 = *(_OWORD *)(*(__int64 (__fastcall **)(unsigned __int64, _BYTE *))(*(_QWORD *)*a1 + 16LL))(*a1, v23);
      v19(v18, &v20, &v22);
      a1[8] = v20;
    }
    sub_14036E4A0(v21);
  }
}

// --- End Function: sub_1403CF640 (0x1403CF640) ---

// --- Function: SEntityTransform::ApplyWorldPose (0x1403D1C40) ---
__int64 __fastcall SEntityTransform::ApplyWorldPose(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm5
  double v4; // xmm6_8
  double v5; // xmm7_8
  __int64 result; // rax
  __int128 v7; // kr00_16
  double v8; // xmm8_8
  double v13; // xmm3_8
  double v14; // xmm5_8
  double v15; // xmm1_8
  double v16; // xmm2_8

  *(_QWORD *)(a1 + 136) = a3;
  *(_QWORD *)(a1 + 152) = a3;
  *(_DWORD *)(a1 + 144) = 1186995890;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)a2;
  v3 = *(unsigned __int64 *)(a2 + 8);
  *(double *)(a1 + 80) = *(double *)&v3;
  v4 = *(double *)(a2 + 16);
  *(double *)(a1 + 88) = v4;
  v5 = *(double *)(a2 + 24);
  *(double *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 32);
  *(double *)(a1 + 120) = *(double *)(a2 + 48);
  result = *(_QWORD *)(a2 + 56);
  *((_QWORD *)&v7 + 1) = *((_QWORD *)&v3 + 1);
  *(_QWORD *)(a1 + 128) = result;
  v8 = *(double *)(a1 + 72);
  *(double *)&v7 = *(double *)&v3 * *(double *)&v3 + v4 * v4 + v8 * v8 + v5 * v5;
  _XMM1 = v7;
  if ( *(double *)&v7 <= 0.00000000999999993922529 )
  {
    v16 = 1.0;
    v13 = 0.0;
    v14 = 0.0;
    v15 = 0.0;
  }
  else
  {
    __asm { vmovddup xmm0, xmm1 }
    __asm
    {
      vsqrtpd xmm2, xmm0
      vunpckhpd xmm2, xmm2, xmm2
    }
    v13 = v4 * (1.0 / *(double *)&_XMM2);
    v14 = *(double *)&v3 * (1.0 / *(double *)&_XMM2);
    v15 = v8 * (1.0 / *(double *)&_XMM2);
    v16 = v5 * (1.0 / *(double *)&_XMM2);
  }
  *(double *)(a1 + 96) = v16;
  *(double *)(a1 + 72) = v15;
  *(double *)(a1 + 80) = v14;
  *(double *)(a1 + 88) = v13;
  if ( *(double *)(a1 + 128) <= 0.0 )
  {
    result = 0x3FF0000000000000LL;
    *(_QWORD *)(a1 + 128) = 0x3FF0000000000000LL;
  }
  return result;
}

// --- End Function: SEntityTransform::ApplyWorldPose (0x1403D1C40) ---

// --- Function: sub_1403E4C30 (0x1403E4C30) ---
__int64 __fastcall sub_1403E4C30(void **a1, unsigned __int64 a2, char Val)
{
  _DWORD *v3; // r14
  int Val_1; // ebp
  unsigned __int64 v6; // r15
  size_t Size; // rbx
  __int64 result; // rax

  v3 = *a1;
  Val_1 = Val;
  v6 = *((int *)*a1 - 2);
  if ( a2 <= v6 )
  {
    if ( a2 >= v6 )
    {
      return result;
    }
    *(v3 - 2) = a2;
    goto LABEL_11;
  }
  Size = a2 - v6;
  if ( a2 == v6 )
  {
    return result;
  }
  if ( a2 <= (int)*(v3 - 1) )
  {
    memset((char *)v3 + v6, Val, Size);
    *((_DWORD *)*a1 - 2) = v6 + Size;
LABEL_11:
    result = *((int *)*a1 - 2);
    *((_BYTE *)*a1 + result) = 0;
    return result;
  }
  sub_1403D95E0((char **)a1, a2);
  if ( *a1 != v3 )
  {
    memcpy(*a1, v3, (int)*(v3 - 2));
  }
  result = (__int64)memset((char *)*a1 + (int)*(v3 - 2), Val_1, Size);
  if ( (int)*(v3 - 1) > 0 )
  {
    sub_14739AF10(v3 - 2);
  }
  return result;
}

// --- End Function: sub_1403E4C30 (0x1403E4C30) ---

// --- Function: sub_140452310 (0x140452310) ---
__int64 __fastcall sub_140452310(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 96) = 0x3FF0000000000000LL;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0x3FF0000000000000LL;
  *(_QWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  Mat44f::SetIdentity((_DWORD *)(a1 + 160));
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  initializeEmptyStringStructure((_QWORD *)(a1 + 184));
  *(_QWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 8;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_BYTE *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = -1;
  *(_QWORD *)(a1 + 272) = 1;
  initializeEmptyStringStructure((_QWORD *)(a1 + 280));
  *(_QWORD *)(a1 + 288) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  initializeEmptyStringStructure((_QWORD *)(a1 + 304));
  result = a1;
  *(_DWORD *)(a1 + 312) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_BYTE *)(a1 + 320) = 0;
  return result;
}

// --- End Function: sub_140452310 (0x140452310) ---

// --- Function: sub_140532ED0 (0x140532ED0) ---
_QWORD *__fastcall sub_140532ED0(_QWORD *a1, _QWORD *a2)
{
  _DWORD *v2; // rax

  *a1 = off_147F6BA70;
  a1[1] = a2[1];
  a1[2] = a2[2];
  v2 = (_DWORD *)a2[3];
  a1[3] = v2;
  if ( v2 )
  {
    ++*v2;
  }
  return a1;
}

// --- End Function: sub_140532ED0 (0x140532ED0) ---

// --- Function: sub_140532F00 (0x140532F00) ---
_QWORD *__fastcall sub_140532F00(_QWORD *a1, __int64 a2)
{
  _DWORD *v3; // rax

  a1[1] = a2;
  *a1 = off_147F6BA70;
  (*(void (__fastcall **)(__int64, _QWORD *, __int64))(*(_QWORD *)global_validator_object + 288LL))(
    global_validator_object,
    a1 + 2,
    a2);
  v3 = (_DWORD *)allocWithoutProfiling(4u);
  if ( v3 )
  {
    *v3 = 1;
    a1[3] = v3;
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

// --- End Function: sub_140532F00 (0x140532F00) ---

// --- Function: sub_140532F70 (0x140532F70) ---
__int64 __fastcall sub_140532F70(_QWORD *a1)
{
  *a1 = off_147F6BA70;
  return sub_140533050();
}

// --- End Function: sub_140532F70 (0x140532F70) ---

// --- Function: sub_140532FD0 (0x140532FD0) ---
unsigned __int64 __fastcall sub_140532FD0(__int64 a1)
{
  bool valid; // cl
  unsigned __int64 result; // rax
  unsigned __int64 v3; // [rsp+30h] [rbp+8h] BYREF

  v3 = *(_QWORD *)(a1 + 16);
  valid = is_valid_handle_typeB(&v3);
  result = v3 & 0xFFFFFFFFFFFFLL;
  if ( !valid )
  {
    return 0;
  }
  return result;
}

// --- End Function: sub_140532FD0 (0x140532FD0) ---

// --- Function: sub_140533050 (0x140533050) ---
void __fastcall sub_140533050(__int64 a1)
{
  _DWORD *v2; // rax
  unsigned __int64 *v4; // rax
  __int64 v5; // rax
  int n100; // ebp
  unsigned __int64 *v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // rbx
  bool v13; // al
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int64 v16; // [rsp+50h] [rbp+8h] BYREF
  char v17; // [rsp+58h] [rbp+10h] BYREF

  if ( *(_QWORD *)(a1 + 8) )
  {
    v2 = *(_DWORD **)(a1 + 24);
    if ( v2 )
    {
      if ( (*v2)-- == 1 )
      {
        if ( is_valid_handle_typeB((unsigned __int64 *)(a1 + 16)) )
        {
          v4 = (unsigned __int64 *)(a1 + 16);
        }
        else
        {
          v4 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)global_validator_object
                                                                                      + 288LL))(
                                     global_validator_object,
                                     &v17,
                                     *(_QWORD *)(a1 + 8));
        }
        v16 = *v4;
        if ( is_valid_handle_typeB(&v16) )
        {
          (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)global_validator_object + 344LL))(
            global_validator_object,
            v16);
        }
        else
        {
          v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pCNetwork + 40LL))(pCNetwork);
          if ( v5 )
          {
            (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 112LL))(v5, *(_QWORD *)(a1 + 8));
          }
        }
        for ( n100 = 0; n100 < 100; ++n100 )
        {
          v7 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)global_validator_object
                                                                                      + 288LL))(
                                     global_validator_object,
                                     &v17,
                                     *(_QWORD *)(a1 + 8));
          v8 = *v7;
          *(_QWORD *)(a1 + 16) = *v7;
          if ( !v8 )
          {
            break;
          }
          v9 = v8;
          v10 = HIWORD(v8);
          v11 = v9 & 0xFFFFFFFFFFFFLL;
          v12 = (v10 & 0xF000) != 0 ? v11 & 0xFFFFFF000000LL : v11 - 6;
          if ( *(_WORD *)(v12 + 2) != (v10 & 0xFFF) )
          {
            break;
          }
          if ( !*(_BYTE *)(get_tls_data_offset_784() + 37) )
          {
            v13 = is_thread_flag_57_or_38_set();
            if ( !v13 )
            {
              goto LABEL_27;
            }
          }
          v13 = 1;
LABEL_27:
          if ( (*(_WORD *)(v12 + 4) != 2 || !v13) && !check_handle_access_by_state_extended((_QWORD *)(a1 + 16)) )
          {
            break;
          }
          v14 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 1624LL))(Parameter_3);
          v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 80LL))(v14);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 96LL))(v15);
        }
        free_memory_wrapper(*(const void **)(a1 + 24));
        *(_QWORD *)(a1 + 16) = 0;
        *(_QWORD *)(a1 + 8) = 0;
        *(_QWORD *)(a1 + 24) = 0;
      }
    }
  }
}

// --- End Function: sub_140533050 (0x140533050) ---

// --- Function: sub_140533350 (0x140533350) ---
_QWORD *__fastcall sub_140533350(__int64 a1, _QWORD *a2, int a3)
{
  int v3; // ebp
  unsigned __int64 *v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // rbx
  unsigned __int64 v10; // rcx
  __int64 v11; // rbx
  bool v12; // al
  __int64 v13; // rax
  __int64 v14; // rax
  char v16; // [rsp+68h] [rbp+20h] BYREF

  v3 = 0;
  if ( a3 <= 0 )
  {
LABEL_14:
    *a2 = 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)global_validator_object
                                                                                  + 288LL))(
                                 global_validator_object,
                                 &v16,
                                 *(_QWORD *)(a1 + 8));
      v8 = *v7;
      *(_QWORD *)(a1 + 16) = *v7;
      if ( v8 )
      {
        v9 = v8 & 0xFFFFFFFFFFFFLL;
        v10 = HIWORD(v8);
        v11 = (v10 & 0xF000) != 0 ? v9 & 0xFFFFFF000000LL : v9 - 6;
        if ( *(_WORD *)(v11 + 2) == (v10 & 0xFFF) )
        {
          if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || (v12 = is_thread_flag_57_or_38_set()) )
          {
            v12 = 1;
          }
          if ( *(_WORD *)(v11 + 4) == 2 && v12 || check_handle_access_by_state_extended((_QWORD *)(a1 + 16)) )
          {
            break;
          }
        }
      }
      v13 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 1624LL))(Parameter_3);
      v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 80LL))(v13);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 96LL))(v14);
      if ( ++v3 >= a3 )
      {
        goto LABEL_14;
      }
    }
    *a2 = *(_QWORD *)(a1 + 16);
  }
  return a2;
}

// --- End Function: sub_140533350 (0x140533350) ---

// --- Function: is_thread_flag_57_or_38_set (0x140535D40) ---
// Checks specific boolean flags within thread-local storage (TLS). Retrieves a
// pointer from `TLS_base + 16` (where `TLS_base` is the result of
// `get_thread_specific_data_offset_784`). - If the pointer is valid, checks the
// byte flag at `pointer + 57`. - If the pointer is null, checks the byte flag at
// `TLS_base + 38`. Returns true if the checked flag is non-zero, false otherwise.
bool is_thread_flag_57_or_38_set()
{
  __int64 thread_data_ptr_offset_16; // rcx

  thread_data_ptr_offset_16 = *(_QWORD *)(get_tls_data_offset_784() + 16);
  if ( thread_data_ptr_offset_16 )
  {
    return *(_BYTE *)(thread_data_ptr_offset_16 + 57) != 0;
  }
  else
  {
    return *(_BYTE *)(get_tls_data_offset_784() + 38) != 0;
  }
}

// --- End Function: is_thread_flag_57_or_38_set (0x140535D40) ---

// --- Function: LogFatalError (0x1405BD370) ---
// Formats a string using printf-style arguments and logs it as a fatal error.
// Checks if the fatal error system is initialized. If not properly initialized
// (missing `Parameter_3` or `qword_14981D3D8`), it triggers a debug break.
// Otherwise, it formats the message into a buffer and calls an external logging
// function via a function pointer derived from the global `Parameter_3`.  @param
// Format A printf-style format string. @param ... Variadic arguments for the
// format string. @return Returns the result of the external logging function call,
// though typically execution may halt.
_BYTE *LogFatalError(const char *pszFormat, ...)
{
  __int64 (*v1)(void); // rax
  FARPROC v2; // rax
  _BYTE *result; // rax
  _QWORD *v4; // rax
  int charsWritten; // eax
  char formattedMessageBuffer[4096]; // [rsp+30h] [rbp-1018h] BYREF
  va_list args; // [rsp+1058h] [rbp+10h] BYREF

  va_start(args, pszFormat);
  v1 = (__int64 (*)(void))qword_14981D1B8;
  if ( !qword_14981D1B8 )
  {
    v2 = sub_140397520(0, "__InitFatalFunctions__", 0);
    ((void (__fastcall *)(__int64 *))v2)(&qword_14981D1B8);
    v1 = (__int64 (*)(void))qword_14981D1B8;
  }
  result = (_BYTE *)v1();
  if ( !*result )
  {
    if ( !qword_14981D3D8 || !Parameter_3 )
    {
      __debugbreak();
      while ( 1 )
      {
        ;
      }
    }
    v4 = sub_1402A2470();
    charsWritten = _stdio_common_vsprintf(*v4 | 2LL, formattedMessageBuffer, 0x1000u, pszFormat, 0, args);
    if ( charsWritten < 0 )
    {
      charsWritten = -1;
    }
    if ( (unsigned int)charsWritten >= 0x1000 )
    {
      formattedMessageBuffer[4095] = 0;
    }
    return (_BYTE *)(*(__int64 (__fastcall **)(Parameter *, const wchar_t *, char *))(*(_QWORD *)Parameter_3 + 280LL))(
                      Parameter_3,
                      &Format_,
                      formattedMessageBuffer);
  }
  return result;
}

// --- End Function: LogFatalError (0x1405BD370) ---

// --- Function: sub_1415876F0 (0x1415876F0) ---
char __fastcall sub_1415876F0(unsigned __int64 **a1, unsigned __int64 a2)
{
  unsigned __int64 *handle_metadata_ptr; // rax
  __int64 (__fastcall *v5)(unsigned __int64, char *, __int16 *); // rdi
  __int16 v6; // ax
  unsigned __int64 v7; // rdi
  __int16 n2; // cx
  __int16 v10; // [rsp+50h] [rbp+8h] BYREF
  char v11; // [rsp+58h] [rbp+10h] BYREF
  unsigned __int64 v12; // [rsp+60h] [rbp+18h] BYREF
  char v13; // [rsp+68h] [rbp+20h] BYREF

  LOBYTE(handle_metadata_ptr) = is_valid_handle_typeB(*a1);
  if ( !(_BYTE)handle_metadata_ptr )
  {
    v5 = *(__int64 (__fastcall **)(unsigned __int64, char *, __int16 *))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL) + 824LL);
    v6 = word_1495F945C;
    if ( word_1495F945C == -1 )
    {
      v6 = *(_WORD *)(*(__int64 (__fastcall **)(__int64, char *, const char *))(*(_QWORD *)global_dispatcher_ptr + 16LL))(
                       global_dispatcher_ptr,
                       &v11,
                       "IEntityComponentSolarSystem");
      word_1495F945C = v6;
    }
    v10 = v6;
    handle_metadata_ptr = (unsigned __int64 *)v5(a2 & 0xFFFFFFFFFFFFLL, &v13, &v10);
    v7 = *handle_metadata_ptr;
    v12 = v7;
    if ( v7 )
    {
      handle_metadata_ptr = (unsigned __int64 *)get_handle_metadata_ptr(v7 & 0xFFFFFFFFFFFFLL);
      n2 = *((_WORD *)handle_metadata_ptr + 2);
      if ( n2 != 4 && *((_WORD *)handle_metadata_ptr + 1) == (HIWORD(v7) & 0xFFF) )
      {
        if ( n2 == 2 && !*(_QWORD *)get_tls_data_offset_784()
          || (LOBYTE(handle_metadata_ptr) = check_handle_access_by_state(&v12), (_BYTE)handle_metadata_ptr) )
        {
          handle_metadata_ptr = (unsigned __int64 *)(*(__int64 (__fastcall **)(unsigned __int64))(*(_QWORD *)(a2 & 0xFFFFFFFFFFFFLL)
                                                                                                + 1624LL))(a2 & 0xFFFFFFFFFFFFLL);
          if ( handle_metadata_ptr )
          {
            LOWORD(handle_metadata_ptr) = (*(__int64 (__fastcall **)(unsigned __int64 *))(*handle_metadata_ptr + 72))(handle_metadata_ptr);
            if ( (_WORD)handle_metadata_ptr )
            {
              handle_metadata_ptr = *a1;
              **a1 = a2;
            }
          }
        }
      }
    }
  }
  return (char)handle_metadata_ptr;
}

// --- End Function: sub_1415876F0 (0x1415876F0) ---

// --- Function: sub_146918A20 (0x146918A20) ---
__int64 __fastcall sub_146918A20(__int64 a1, __int64 a2)
{
  __m256 *v2; // rbx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rax
  __m256 v8; // ymm0
  bool v9; // zf
  __int64 result; // rax
  __int64 v11; // [rsp+20h] [rbp-48h] BYREF
  __int64 v12; // [rsp+28h] [rbp-40h] BYREF
  __int64 *v13; // [rsp+30h] [rbp-38h] BYREF
  __m256 v14; // [rsp+38h] [rbp-30h] BYREF

  v2 = *(__m256 **)(a2 + 16);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pCZoneSystem + 16LL))(pCZoneSystem);
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v4 + 48LL))(v4, &v12);
  v11 = 0;
  v5 = *(_QWORD *)(v12 & 0xFFFFFFFFFFFFLL);
  v13 = &v11;
  *(_QWORD *)v14.m256_f32 = &v13;
  *(_QWORD *)&v14.m256_f32[2] = sub_1415876F0;
  (*(void (__fastcall **)(__int64, __m256 *))(v5 + 224))(v12 & 0xFFFFFFFFFFFFLL, &v14);
  *(_QWORD *)a1 = 0x3FD157E6AAFF2FC4LL;
  *(_QWORD *)(a1 + 24) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 16) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 8) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 48) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 40) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 32) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 264) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 256) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 248) = 0x7FF0000000000001LL;
  *(_QWORD *)(a1 + 272) = 0x5F138D352E5096AFLL;
  *(_QWORD *)(a1 + 280) = 0x5F138D352E5096AFLL;
  *(_QWORD *)(a1 + 288) = 0x5F138D352E5096AFLL;
  *(_QWORD *)(a1 + 296) = 0xDF138D352E5096AFuLL;
  *(_QWORD *)(a1 + 304) = 0xDF138D352E5096AFuLL;
  *(_QWORD *)(a1 + 312) = 0xDF138D352E5096AFuLL;
  v6 = v11;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(_BYTE *)(a1 + 404) = 0;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v6 & 0xFFFFFFFFFFFFLL) + 1624LL))(v6 & 0xFFFFFFFFFFFFLL);
  v8 = *v2;
  *(_QWORD *)(a1 + 352) = v7;
  v9 = v7 == 0;
  v14 = v8;
  *(__m256 *)(a1 + 320) = v8;
  result = a1;
  *(_BYTE *)(a1 + 404) = 1;
  if ( !v9 )
  {
    *(_BYTE *)(a1 + 400) = 1;
  }
  __asm { vzeroupper }
  return result;
}

// --- End Function: sub_146918A20 (0x146918A20) ---

// --- Function: sub_146918BE0 (0x146918BE0) ---
void __fastcall sub_146918BE0(int a1, __int64 a2, _QWORD *a3)
{
  int v4; // ecx
  __m256i *v5; // rdi
  __m256i *v6; // rax
  __m256i *v7; // rcx

  if ( !a1 )
  {
    v5 = (__m256i *)a3[2];
    if ( *a3 )
    {
      if ( a3[1] == 1 )
      {
        *(_QWORD *)(a2 + 16) = 0;
        *(_QWORD *)a2 = *a3;
        *(_QWORD *)(a2 + 8) = 1;
        __asm { vzeroupper }
        return;
      }
      v6 = (__m256i *)allocWithoutProfiling(0x20u);
      v7 = v6;
      if ( v6 )
      {
        *v6 = *v5;
      }
      else
      {
        v7 = 0;
      }
      *(_QWORD *)(a2 + 16) = v7;
      *(_QWORD *)a2 = sub_146918A20;
      *(_QWORD *)(a2 + 8) = sub_146918BE0;
    }
    goto LABEL_16;
  }
  v4 = a1 - 1;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      free_memory_wrapper(*(const void **)(a2 + 16));
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      __asm { vzeroupper }
      return;
    }
    goto LABEL_16;
  }
  if ( !*a3 )
  {
LABEL_16:
    __asm { vzeroupper }
    return;
  }
  if ( a3[1] == 1 )
  {
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = *a3;
    *(_QWORD *)(a2 + 8) = 1;
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
  else
  {
    *(_QWORD *)(a2 + 16) = a3[2];
    *(_QWORD *)a2 = *a3;
    *(_QWORD *)(a2 + 8) = a3[1];
    a3[2] = 0;
    *a3 = 0;
    a3[1] = 0;
    __asm { vzeroupper }
  }
}

// --- End Function: sub_146918BE0 (0x146918BE0) ---

// --- Function: sub_146919090 (0x146919090) ---
_QWORD *__fastcall sub_146919090(_QWORD *a1, double *a2, double *a3)
{
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 *v10; // rax
  double v11; // xmm1_8
  __int64 v12; // r8
  __int64 v13; // rbx
  __int64 (__fastcall *v14)(__int64, _BYTE *, _BYTE *, __int64); // rdi
  __int64 v15; // rax
  _QWORD *v16; // rax
  volatile signed __int32 *v17; // rbx
  __int64 *v18; // rax
  double v19; // xmm1_8
  __int64 v20; // r8
  __int64 v21; // rbx
  __int64 (__fastcall *v22)(__int64, _BYTE *, _BYTE *, __int64); // rdi
  __int64 v23; // rax
  _QWORD *v24; // rax
  volatile signed __int32 *v25; // rbx
  void (__fastcall *v26)(__int64, __int64 *); // r8
  unsigned __int64 *v27; // rdi
  __int64 n61440; // rdx
  unsigned __int64 v29; // rcx
  __int64 v30; // rbx
  unsigned __int64 v31; // rcx
  __int64 v32; // rbx
  bool v33; // al
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned __int64 *v36; // rdi
  unsigned __int64 v37; // rcx
  __int64 v38; // rbx
  unsigned __int64 v39; // rcx
  __int64 v40; // rbx
  bool v41; // al
  __int64 v42; // rax
  __int64 v43; // rax
  __int64 v44; // rax
  double *v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rax
  double *v49; // rax
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 v52; // rcx
  __int64 v53; // rcx
  __int64 v54; // rcx
  int v56; // [rsp+20h] [rbp-E0h]
  unsigned __int64 *v57; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v58; // [rsp+38h] [rbp-C8h] BYREF
  _QWORD v59[2]; // [rsp+40h] [rbp-C0h] BYREF
  _BYTE v60[32]; // [rsp+50h] [rbp-B0h] BYREF
  _BYTE v61[32]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v62; // [rsp+90h] [rbp-70h] BYREF
  _BYTE v63[8]; // [rsp+98h] [rbp-68h] BYREF
  __int64 v64; // [rsp+A0h] [rbp-60h] BYREF
  _BYTE v65[8]; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE v66[8]; // [rsp+B0h] [rbp-50h] BYREF
  _BYTE v67[8]; // [rsp+B8h] [rbp-48h] BYREF
  _BYTE v68[8]; // [rsp+C0h] [rbp-40h] BYREF
  volatile signed __int32 *v69; // [rsp+C8h] [rbp-38h]
  _BYTE v70[8]; // [rsp+D0h] [rbp-30h] BYREF
  volatile signed __int32 *v71; // [rsp+D8h] [rbp-28h]
  __int128 v72; // [rsp+E0h] [rbp-20h] BYREF
  double v73; // [rsp+F0h] [rbp-10h]
  __int128 v74; // [rsp+100h] [rbp+0h] BYREF
  double v75; // [rsp+110h] [rbp+10h]
  __int128 v76; // [rsp+120h] [rbp+20h] BYREF
  double v77; // [rsp+130h] [rbp+30h]
  _BYTE v78[24]; // [rsp+140h] [rbp+40h] BYREF
  _BYTE v79[24]; // [rsp+158h] [rbp+58h] BYREF
  _BYTE v80[8]; // [rsp+170h] [rbp+70h] BYREF
  _BYTE v81[32]; // [rsp+178h] [rbp+78h] BYREF
  __int64 v82; // [rsp+198h] [rbp+98h]
  __int64 v83; // [rsp+1A0h] [rbp+A0h]
  __int64 v84; // [rsp+1A8h] [rbp+A8h]
  _DWORD v85[6]; // [rsp+210h] [rbp+110h] BYREF
  _QWORD v86[12]; // [rsp+228h] [rbp+128h] BYREF
  _QWORD v87[3]; // [rsp+288h] [rbp+188h] BYREF
  _QWORD v88[4]; // [rsp+2A0h] [rbp+1A0h] BYREF
  _BYTE v89[8]; // [rsp+2C0h] [rbp+1C0h] BYREF
  _BYTE v90[32]; // [rsp+2C8h] [rbp+1C8h] BYREF
  __int64 v91; // [rsp+2E8h] [rbp+1E8h]
  __int64 v92; // [rsp+2F0h] [rbp+1F0h]
  __int64 v93; // [rsp+2F8h] [rbp+1F8h]
  _DWORD v94[6]; // [rsp+360h] [rbp+260h] BYREF
  _QWORD v95[12]; // [rsp+378h] [rbp+278h] BYREF
  _QWORD v96[3]; // [rsp+3D8h] [rbp+2D8h] BYREF
  _QWORD v97[12]; // [rsp+3F0h] [rbp+2F0h] BYREF
  __int64 v98; // [rsp+460h] [rbp+360h] BYREF
  unsigned __int64 v99; // [rsp+468h] [rbp+368h] BYREF
  __int64 v100; // [rsp+470h] [rbp+370h] BYREF
  __int64 v101; // [rsp+478h] [rbp+378h] BYREF

  _XMM0 = 0;
  v73 = 0.0;
  __asm { vmovupd xmmword ptr [rbp+350h+var_370], xmm0 }
  sub_146919720(&v100, "bubbel", &v72);
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pCZoneSystem + 16LL))(pCZoneSystem);
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v7 + 48LL))(v7, &v101);
  v99 = 0;
  v8 = *(_QWORD *)(v101 & 0xFFFFFFFFFFFFLL);
  v57 = &v99;
  v59[0] = &v57;
  v59[1] = sub_1415876F0;
  (*(void (__fastcall **)(__int64, _QWORD *))(v8 + 224))(v101 & 0xFFFFFFFFFFFFLL, v59);
  LOBYTE(v9) = 3;
  (*(void (__fastcall **)(__int64, __int64 *, const char *, __int64, _DWORD))(*(_QWORD *)global_validator_object + 200LL))(
    global_validator_object,
    &v98,
    "UnitTestingABCreateBatch",
    v9,
    0);
  v10 = sub_1403AC900(&v99, &v62);
  v11 = a2[2];
  v12 = *v10;
  v74 = *(_OWORD *)a2;
  v75 = v11;
  sub_146919990(v89, &v74, v12);
  v13 = v98;
  v14 = *(__int64 (__fastcall **)(__int64, _BYTE *, _BYTE *, __int64))(*(_QWORD *)v98 + 32LL);
  v15 = (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)global_validator_object + 272LL))(
          global_validator_object,
          v68);
  v16 = (_QWORD *)v14(v13, v63, v89, v15);
  sub_140532F00(v61, *v16);
  v17 = v69;
  if ( v69 )
  {
    if ( _InterlockedExchangeAdd(v69 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v17)(v17);
      if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v17 + 8LL))(v17);
      }
    }
  }
  v18 = sub_1403AC900(&v99, &v64);
  v19 = a3[2];
  v20 = *v18;
  v76 = *(_OWORD *)a3;
  v77 = v19;
  sub_146919850(v80, &v76, v20);
  v21 = v98;
  v22 = *(__int64 (__fastcall **)(__int64, _BYTE *, _BYTE *, __int64))(*(_QWORD *)v98 + 32LL);
  v23 = (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)global_validator_object + 272LL))(
          global_validator_object,
          v70);
  v24 = (_QWORD *)v22(v21, v65, v80, v23);
  sub_140532F00(v60, *v24);
  v25 = v71;
  if ( v71 )
  {
    if ( _InterlockedExchangeAdd(v71 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v25)(v25);
      if ( _InterlockedExchangeAdd(v25 + 3, 0xFFFFFFFF) == 1 )
      {
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v25 + 8LL))(v25);
      }
    }
  }
  v26 = *(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)global_validator_object + 208LL);
  v58 = v98;
  v98 = 0;
  v26(global_validator_object, &v58);
  v27 = (unsigned __int64 *)sub_140533350(v61, v66, 100);
  n61440 = 61440;
  v29 = *v27;
  if ( !*v27 )
  {
    goto LABEL_20;
  }
  v30 = v29 & 0xFFFFFFFFFFFFLL;
  v31 = HIWORD(v29);
  v32 = (v31 & 0xF000) != 0 ? v30 & 0xFFFFFF000000LL : v30 - 6;
  if ( *(_WORD *)(v32 + 2) != (v31 & 0xFFF) )
  {
    goto LABEL_20;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || (v33 = is_thread_flag_57_or_38_set()) )
  {
    v33 = 1;
  }
  if ( (*(_WORD *)(v32 + 4) != 2 || !v33) && !check_handle_access_by_state_extended(v27) )
  {
LABEL_20:
    v34 = (*(__int64 (__fastcall **)(Parameter *, __int64))(*(_QWORD *)Parameter_3 + 1624LL))(Parameter_3, n61440);
    v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 80LL))(v34);
    LOBYTE(v56) = 0;
    (*(void (__fastcall **)(__int64, const char *, const char *, __int64, int, const ULONG_PTR *))(*(_QWORD *)v35 + 88LL))(
      v35,
      "entityA.WaitOnSpawn()",
      "W:/p4-src/CryEngine/Code/CryEngine/CryEntitySystem/UnitTests/UnitTests_EntitySystem.cpp",
      74,
      v56,
      &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
  }
  v36 = (unsigned __int64 *)sub_140533350(v60, v67, 100);
  v37 = *v36;
  if ( !*v36 )
  {
    goto LABEL_32;
  }
  v38 = v37 & 0xFFFFFFFFFFFFLL;
  v39 = HIWORD(v37);
  v40 = (v39 & 0xF000) != 0 ? v38 & 0xFFFFFF000000LL : v38 - 6;
  if ( *(_WORD *)(v40 + 2) != (v39 & 0xFFF) )
  {
    goto LABEL_32;
  }
  if ( *(_BYTE *)(get_tls_data_offset_784() + 37) || (v41 = is_thread_flag_57_or_38_set()) )
  {
    v41 = 1;
  }
  if ( (*(_WORD *)(v40 + 4) != 2 || !v41) && !check_handle_access_by_state_extended(v36) )
  {
LABEL_32:
    v42 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 1624LL))(Parameter_3);
    v43 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v42 + 80LL))(v42);
    LOBYTE(v56) = 0;
    (*(void (__fastcall **)(__int64, const char *, const char *, __int64, int, const ULONG_PTR *))(*(_QWORD *)v43 + 88LL))(
      v43,
      "entityB.WaitOnSpawn()",
      "W:/p4-src/CryEngine/Code/CryEngine/CryEntitySystem/UnitTests/UnitTests_EntitySystem.cpp",
      75,
      v56,
      &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
  }
  v44 = sub_140532FD0(v61);
  v45 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v44 + 704LL))(v44, v78, 0);
  if ( *a2 != *v45 || a2[1] != v45[1] || a2[2] != v45[2] )
  {
    v46 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 1624LL))(Parameter_3);
    v47 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v46 + 80LL))(v46);
    LOBYTE(v56) = 0;
    (*(void (__fastcall **)(__int64, const char *, const char *, __int64, int, const ULONG_PTR *))(*(_QWORD *)v47 + 88LL))(
      v47,
      "entityA->GetWorldPos() == entityAPos",
      "W:/p4-src/CryEngine/Code/CryEngine/CryEntitySystem/UnitTests/UnitTests_EntitySystem.cpp",
      77,
      v56,
      &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
  }
  v48 = sub_140532FD0(v60);
  v49 = (double *)(*(__int64 (__fastcall **)(__int64, _BYTE *, _QWORD))(*(_QWORD *)v48 + 704LL))(v48, v79, 0);
  if ( *a3 != *v49 || a3[1] != v49[1] || a3[2] != v49[2] )
  {
    v50 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 1624LL))(Parameter_3);
    v51 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v50 + 80LL))(v50);
    LOBYTE(v56) = 0;
    (*(void (__fastcall **)(__int64, const char *, const char *, __int64, int, const ULONG_PTR *))(*(_QWORD *)v51 + 88LL))(
      v51,
      "entityB->GetWorldPos() == entityBPos",
      "W:/p4-src/CryEngine/Code/CryEngine/CryEntitySystem/UnitTests/UnitTests_EntitySystem.cpp",
      78,
      v56,
      &p_p_W__p4_src_CryEngine_Code_SDKs_Optick_1_3_1_src_optick_core_cpp);
  }
  v52 = v100;
  *a1 = v100;
  if ( v52 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v52 + 8LL))(v52);
  }
  sub_140532ED0(a1 + 1, v60);
  sub_140532ED0(a1 + 5, v61);
  sub_140532F70(v60);
  DestroyStringObject(v88);
  DestroyStringObject(v87);
  DestroyStringObject(v86);
  sub_14036EF50(v85);
  if ( v84 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v84 + 40LL))(v84);
  }
  if ( v83 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v83 + 40LL))(v83);
  }
  v53 = v82;
  if ( v82 && _InterlockedExchangeAdd((volatile signed __int32 *)(v82 + 12), 0xFFFFFFFF) == 1 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v53 + 8LL))(v53);
  }
  sub_14036E4A0(v81);
  sub_140532F70(v61);
  DestroyStringObject(v97);
  DestroyStringObject(v96);
  DestroyStringObject(v95);
  sub_14036EF50(v94);
  if ( v93 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v93 + 40LL))(v93);
  }
  if ( v92 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v92 + 40LL))(v92);
  }
  v54 = v91;
  if ( v91 && _InterlockedExchangeAdd((volatile signed __int32 *)(v91 + 12), 0xFFFFFFFF) == 1 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v54 + 8LL))(v54);
  }
  sub_14036E4A0(v90);
  if ( v98 )
  {
    (**(void (__fastcall ***)(__int64, __int64))v98)(v98, 1);
  }
  if ( v100 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v100 + 16LL))(v100);
  }
  return a1;
}

// --- End Function: sub_146919090 (0x146919090) ---

// --- Function: sub_146919720 (0x146919720) ---
__int64 __fastcall sub_146919720(__int64 a1, char *p_bubbel, double *a3, double a4)
{
  __int128 v4; // xmm6
  _QWORD *v8; // rax
  __int128 v9; // xmm0
  double v10; // xmm1_8
  _QWORD *v11; // rsi
  __int64 v12; // r9
  void (__fastcall *v13)(_QWORD *, __int64, __int64, char *, __int64 (__fastcall **)(__int64, __int64)); // r14
  __m256 *v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 (__fastcall *p_sub_146918A20)(__int64, __int64); // [rsp+30h] [rbp-58h] BYREF
  void (__fastcall *p_sub_146918BE0)(__int64, __int64 (__fastcall **)(__int64, __int64)); // [rsp+38h] [rbp-50h]
  __m256 *v20; // [rsp+40h] [rbp-48h]
  __m256 v21; // [rsp+48h] [rbp-40h]
  __int128 v22; // [rsp+70h] [rbp-18h]

  v22 = v4;
  v8 = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)global_validator_object + 720LL))(global_validator_object);
  v9 = *(_OWORD *)a3;
  v10 = a3[2];
  v11 = v8;
  v12 = *v8;
  *(double *)&v21.m256_f32[6] = a4;
  *(_OWORD *)v21.m256_f32 = v9;
  *(double *)&v21.m256_f32[4] = v10;
  v13 = *(void (__fastcall **)(_QWORD *, __int64, __int64, char *, __int64 (__fastcall **)(__int64, __int64)))(v12 + 48);
  v14 = (__m256 *)allocWithoutProfiling(0x20u);
  if ( v14 )
  {
    *v14 = v21;
    v20 = v14;
  }
  else
  {
    v20 = 0;
  }
  p_sub_146918A20 = sub_146918A20;
  p_sub_146918BE0 = (void (__fastcall *)(__int64, __int64 (__fastcall **)(__int64, __int64)))sub_146918BE0;
  __asm { vzeroupper }
  v13(v11, a1, 1, p_bubbel, &p_sub_146918A20);
  if ( (unsigned __int64)p_sub_146918BE0 >= 2 )
  {
    p_sub_146918BE0(2, &p_sub_146918A20);
  }
  v15 = (*(__int64 (__fastcall **)(Parameter *))(*(_QWORD *)Parameter_3 + 1624LL))(Parameter_3);
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 80LL))(v15);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 96LL))(v16);
  return a1;
}

// --- End Function: sub_146919720 (0x146919720) ---

// --- Function: sub_146919850 (0x146919850) ---
unsigned __int64 *__fastcall sub_146919850(unsigned __int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  _QWORD v13[2]; // [rsp+20h] [rbp-68h] BYREF
  _OWORD v14[3]; // [rsp+30h] [rbp-58h] BYREF
  double v15; // [rsp+60h] [rbp-28h]
  double v16; // [rsp+68h] [rbp-20h]
  unsigned __int64 v17; // [rsp+90h] [rbp+8h] BYREF
  __int64 v18; // [rsp+98h] [rbp+10h] BYREF
  unsigned __int64 *v19; // [rsp+A0h] [rbp+18h] BYREF
  __int64 v20; // [rsp+A8h] [rbp+20h] BYREF

  v3 = a3;
  if ( !a3 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pCZoneSystem + 16LL))(pCZoneSystem);
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v6 + 48LL))(v6, &v18);
    v17 = 0;
    v7 = *(_QWORD *)(v18 & 0xFFFFFFFFFFFFLL);
    v19 = &v17;
    v13[0] = &v19;
    v13[1] = sub_1415876F0;
    (*(void (__fastcall **)(__int64, _QWORD *))(v7 + 224))(v18 & 0xFFFFFFFFFFFFLL, v13);
    v3 = *sub_1403AC900(&v17, &v20);
  }
  sub_140452310((__int64)a1);
  __asm { vmovupd xmm1, cs:xmmword_147F3E170 }
  _XMM0 = 0;
  __asm { vmovupd [rsp+88h+var_58], xmm0 }
  v14[2] = *(_OWORD *)a2;
  __asm { vmovupd [rsp+88h+var_48], xmm1 }
  *(_QWORD *)&_XMM1 = *(_QWORD *)(a2 + 16);
  v16 = 1.0;
  v15 = *(double *)&_XMM1;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)global_validator_object + 192LL))(global_validator_object);
  v11 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v10 + 32LL))(v10, "Default");
  sub_1403CF640(a1, v11);
  SEntityTransform::SetEntityFlags((__int64)a1, 4096);
  SEntityTransform::ApplyWorldPose((__int64)a1, (__int64)v14, v3);
  return a1;
}

// --- End Function: sub_146919850 (0x146919850) ---

// --- Function: sub_146919990 (0x146919990) ---
unsigned __int64 *__fastcall sub_146919990(unsigned __int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  _QWORD v13[2]; // [rsp+20h] [rbp-68h] BYREF
  _OWORD v14[3]; // [rsp+30h] [rbp-58h] BYREF
  double v15; // [rsp+60h] [rbp-28h]
  double v16; // [rsp+68h] [rbp-20h]
  unsigned __int64 v17; // [rsp+90h] [rbp+8h] BYREF
  __int64 v18; // [rsp+98h] [rbp+10h] BYREF
  unsigned __int64 *v19; // [rsp+A0h] [rbp+18h] BYREF
  __int64 v20; // [rsp+A8h] [rbp+20h] BYREF

  v3 = a3;
  if ( !a3 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)pCZoneSystem + 16LL))(pCZoneSystem);
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v6 + 48LL))(v6, &v18);
    v17 = 0;
    v7 = *(_QWORD *)(v18 & 0xFFFFFFFFFFFFLL);
    v19 = &v17;
    v13[0] = &v19;
    v13[1] = sub_1415876F0;
    (*(void (__fastcall **)(__int64, _QWORD *))(v7 + 224))(v18 & 0xFFFFFFFFFFFFLL, v13);
    v3 = *sub_1403AC900(&v17, &v20);
  }
  sub_140452310((__int64)a1);
  __asm { vmovupd xmm1, cs:xmmword_147F3E170 }
  _XMM0 = 0;
  __asm { vmovupd [rsp+88h+var_58], xmm0 }
  v14[2] = *(_OWORD *)a2;
  __asm { vmovupd [rsp+88h+var_48], xmm1 }
  *(_QWORD *)&_XMM1 = *(_QWORD *)(a2 + 16);
  v16 = 1.0;
  v15 = *(double *)&_XMM1;
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)global_validator_object + 192LL))(global_validator_object);
  v11 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)v10 + 32LL))(v10, "CoreEngineFT_SpawnZone");
  sub_1403CF640(a1, v11);
  SEntityTransform::SetEntityFlags((__int64)a1, 5120);
  SEntityTransform::ApplyWorldPose((__int64)a1, (__int64)v14, v3);
  return a1;
}

// --- End Function: sub_146919990 (0x146919990) ---

// --- Function: sub_147397F30 (0x147397F30) ---
void __fastcall sub_147397F30(__int64 pCZoneSystem)
{
  sub_147397F40(pCZoneSystem);
}

// --- End Function: sub_147397F30 (0x147397F30) ---

// --- Function: sub_14739AF10 (0x14739AF10) ---
void __fastcall sub_14739AF10(const void *pCZoneSystem)
{
  if ( pCZoneSystem )
  {
    if ( qword_14981D3D8 && ::pCZoneSystem && pCZoneSystem == (const void *)::pCZoneSystem )
    {
      __debugbreak();
    }
    if ( (unsigned __int64)pCZoneSystem < pCZoneSystem_1
      || (unsigned __int64)pCZoneSystem >= pCZoneSystem_1 + 0x8000000000LL )
    {
      if ( (unsigned __int64)pCZoneSystem >= pCZoneSystem_0
        && (unsigned __int64)pCZoneSystem < pCZoneSystem_0 + 0x200000000LL )
      {
        LogFatalError("Address %p was allocated by persistent malloc and cannot be freed!", pCZoneSystem);
      }
      sub_147397F30((__int64)pCZoneSystem);
    }
  }
}

// --- End Function: sub_14739AF10 (0x14739AF10) ---

// --- Function: allocWithProfilerInfo (0x14739AFC0) ---
__int64 __fastcall allocWithProfilerInfo(unsigned __int64 allocSize, struct _exception *profilerInfo)
{
  char tls_byte_at_offset_3401; // al
  __int64 profileSize; // rax
  __int64 result; // rax

  if ( allocSize )
  {
    tls_byte_at_offset_3401 = get_tls_byte_at_offset_3401();
    sub_140566BA0(tls_byte_at_offset_3401);
    profileSize = AK::MemoryMgr::StopProfileThreadUsage(profilerInfo);
    result = sub_1473986B0(profileSize + allocSize, (unsigned __int64)profilerInfo);
    if ( result )
    {
      return result;
    }
    sub_14739A8D0(allocSize);
  }
  return 0;
}

// --- End Function: allocWithProfilerInfo (0x14739AFC0) ---

// --- Function: security_check_cookie (0x147DC7890) ---
// Verifies the stack security cookie. If the value provided (`stack_cookie`) does
// not match the expected global cookie (`_security_cookie`) or appears tampered
// with, it reports a security failure and terminates the process.
void __cdecl security_check_cookie(uintptr_t stack_cookie)
{
  __int64 rotated_cookie; // rcx

  if ( stack_cookie != _security_cookie )
  {
ReportFailure:
    _report_gsfailure(stack_cookie);
  }
  rotated_cookie = __ROL8__(stack_cookie, 16);
  if ( (_WORD)rotated_cookie )
  {
    stack_cookie = __ROR8__(rotated_cookie, 16);
    goto ReportFailure;
  }
}

// --- End Function: security_check_cookie (0x147DC7890) ---

